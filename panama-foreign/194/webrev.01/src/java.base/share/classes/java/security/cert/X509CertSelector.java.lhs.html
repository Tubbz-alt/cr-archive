<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/security/cert/X509CertSelector.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.security.cert;
  27 
  28 import java.io.IOException;
  29 import java.math.BigInteger;
  30 import java.security.PublicKey;
  31 import java.util.*;
  32 import javax.security.auth.x500.X500Principal;
  33 
  34 import sun.security.util.*;
  35 import sun.security.x509.*;
  36 
  37 /**
  38  * A {@code CertSelector} that selects {@code X509Certificates} that
  39  * match all specified criteria. This class is particularly useful when
  40  * selecting certificates from a {@code CertStore} to build a
  41  * PKIX-compliant certification path.
  42  * &lt;p&gt;
  43  * When first constructed, an {@code X509CertSelector} has no criteria
  44  * enabled and each of the {@code get} methods return a default value
  45  * ({@code null}, or {@code -1} for the {@link #getBasicConstraints
  46  * getBasicConstraints} method). Therefore, the {@link #match match}
  47  * method would return {@code true} for any {@code X509Certificate}.
  48  * Typically, several criteria are enabled (by calling
  49  * {@link #setIssuer setIssuer} or
  50  * {@link #setKeyUsage setKeyUsage}, for instance) and then the
  51  * {@code X509CertSelector} is passed to
  52  * {@link CertStore#getCertificates CertStore.getCertificates} or some similar
  53  * method.
  54  * &lt;p&gt;
  55  * Several criteria can be enabled (by calling {@link #setIssuer setIssuer}
  56  * and {@link #setSerialNumber setSerialNumber},
  57  * for example) such that the {@code match} method
  58  * usually uniquely matches a single {@code X509Certificate}. We say
  59  * usually, since it is possible for two issuing CAs to have the same
  60  * distinguished name and each issue a certificate with the same serial
  61  * number. Other unique combinations include the issuer, subject,
  62  * subjectKeyIdentifier and/or the subjectPublicKey criteria.
  63  * &lt;p&gt;
  64  * Please refer to &lt;a href=&quot;http://tools.ietf.org/html/rfc5280&quot;&gt;RFC 5280:
  65  * Internet X.509 Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt; for
  66  * definitions of the X.509 certificate extensions mentioned below.
  67  * &lt;p&gt;
  68  * &lt;b&gt;Concurrent Access&lt;/b&gt;
  69  * &lt;p&gt;
  70  * Unless otherwise specified, the methods defined in this class are not
  71  * thread-safe. Multiple threads that need to access a single
  72  * object concurrently should synchronize amongst themselves and
  73  * provide the necessary locking. Multiple threads each manipulating
  74  * separate objects need not synchronize.
  75  *
  76  * @see CertSelector
  77  * @see X509Certificate
  78  *
  79  * @since       1.4
  80  * @author      Steve Hanna
  81  */
  82 public class X509CertSelector implements CertSelector {
  83 
  84     private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);
  85 
  86     private static final ObjectIdentifier ANY_EXTENDED_KEY_USAGE =
  87         ObjectIdentifier.of(KnownOIDs.anyExtendedKeyUsage);
  88 
  89     static {
  90         CertPathHelperImpl.initialize();
  91     }
  92 
  93     private BigInteger serialNumber;
  94     private X500Principal issuer;
  95     private X500Principal subject;
  96     private byte[] subjectKeyID;
  97     private byte[] authorityKeyID;
  98     private Date certificateValid;
  99     private Date privateKeyValid;
 100     private ObjectIdentifier subjectPublicKeyAlgID;
 101     private PublicKey subjectPublicKey;
 102     private byte[] subjectPublicKeyBytes;
 103     private boolean[] keyUsage;
 104     private Set&lt;String&gt; keyPurposeSet;
 105     private Set&lt;ObjectIdentifier&gt; keyPurposeOIDSet;
 106     private Set&lt;List&lt;?&gt;&gt; subjectAlternativeNames;
 107     private Set&lt;GeneralNameInterface&gt; subjectAlternativeGeneralNames;
 108     private CertificatePolicySet policy;
 109     private Set&lt;String&gt; policySet;
 110     private Set&lt;List&lt;?&gt;&gt; pathToNames;
 111     private Set&lt;GeneralNameInterface&gt; pathToGeneralNames;
 112     private NameConstraintsExtension nc;
 113     private byte[] ncBytes;
 114     private int basicConstraints = -1;
 115     private X509Certificate x509Cert;
 116     private boolean matchAllSubjectAltNames = true;
 117 
 118     private static final Boolean FALSE = Boolean.FALSE;
 119 
<a name="1" id="anc1"></a><span class="line-removed"> 120     private static final int PRIVATE_KEY_USAGE_ID = 0;</span>
<span class="line-removed"> 121     private static final int SUBJECT_ALT_NAME_ID = 1;</span>
<span class="line-removed"> 122     private static final int NAME_CONSTRAINTS_ID = 2;</span>
<span class="line-removed"> 123     private static final int CERT_POLICIES_ID = 3;</span>
<span class="line-removed"> 124     private static final int EXTENDED_KEY_USAGE_ID = 4;</span>
<span class="line-removed"> 125     private static final int NUM_OF_EXTENSIONS = 5;</span>
<span class="line-removed"> 126     private static final String[] EXTENSION_OIDS = new String[NUM_OF_EXTENSIONS];</span>
<span class="line-removed"> 127 </span>
<span class="line-removed"> 128     static {</span>
<span class="line-removed"> 129         EXTENSION_OIDS[PRIVATE_KEY_USAGE_ID]  = &quot;2.5.29.16&quot;;</span>
<span class="line-removed"> 130         EXTENSION_OIDS[SUBJECT_ALT_NAME_ID]   = &quot;2.5.29.17&quot;;</span>
<span class="line-removed"> 131         EXTENSION_OIDS[NAME_CONSTRAINTS_ID]   = &quot;2.5.29.30&quot;;</span>
<span class="line-removed"> 132         EXTENSION_OIDS[CERT_POLICIES_ID]      = &quot;2.5.29.32&quot;;</span>
<span class="line-removed"> 133         EXTENSION_OIDS[EXTENDED_KEY_USAGE_ID] = &quot;2.5.29.37&quot;;</span>
<span class="line-removed"> 134     };</span>
<span class="line-removed"> 135 </span>
 136     /* Constants representing the GeneralName types */
 137     static final int NAME_ANY = 0;
 138     static final int NAME_RFC822 = 1;
 139     static final int NAME_DNS = 2;
 140     static final int NAME_X400 = 3;
 141     static final int NAME_DIRECTORY = 4;
 142     static final int NAME_EDI = 5;
 143     static final int NAME_URI = 6;
 144     static final int NAME_IP = 7;
 145     static final int NAME_OID = 8;
 146 
 147     /**
 148      * Creates an {@code X509CertSelector}. Initially, no criteria are set
 149      * so any {@code X509Certificate} will match.
 150      */
 151     public X509CertSelector() {
 152         // empty
 153     }
 154 
 155     /**
 156      * Sets the certificateEquals criterion. The specified
 157      * {@code X509Certificate} must be equal to the
 158      * {@code X509Certificate} passed to the {@code match} method.
 159      * If {@code null}, then this check is not applied.
 160      *
 161      * &lt;p&gt;This method is particularly useful when it is necessary to
 162      * match a single certificate. Although other criteria can be specified
 163      * in conjunction with the certificateEquals criterion, it is usually not
 164      * practical or necessary.
 165      *
 166      * @param cert the {@code X509Certificate} to match (or
 167      * {@code null})
 168      * @see #getCertificate
 169      */
 170     public void setCertificate(X509Certificate cert) {
 171         x509Cert = cert;
 172     }
 173 
 174     /**
 175      * Sets the serialNumber criterion. The specified serial number
 176      * must match the certificate serial number in the
 177      * {@code X509Certificate}. If {@code null}, any certificate
 178      * serial number will do.
 179      *
 180      * @param serial the certificate serial number to match
 181      *        (or {@code null})
 182      * @see #getSerialNumber
 183      */
 184     public void setSerialNumber(BigInteger serial) {
 185         serialNumber = serial;
 186     }
 187 
 188     /**
 189      * Sets the issuer criterion. The specified distinguished name
 190      * must match the issuer distinguished name in the
 191      * {@code X509Certificate}. If {@code null}, any issuer
 192      * distinguished name will do.
 193      *
 194      * @param issuer a distinguished name as X500Principal
 195      *                 (or {@code null})
 196      * @since 1.5
 197      */
 198     public void setIssuer(X500Principal issuer) {
 199         this.issuer = issuer;
 200     }
 201 
 202     /**
 203      * &lt;strong&gt;Denigrated&lt;/strong&gt;, use {@linkplain #setIssuer(X500Principal)}
 204      * or {@linkplain #setIssuer(byte[])} instead. This method should not be
 205      * relied on as it can fail to match some certificates because of a loss of
 206      * encoding information in the
 207      * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; String form
 208      * of some distinguished names.
 209      * &lt;p&gt;
 210      * Sets the issuer criterion. The specified distinguished name
 211      * must match the issuer distinguished name in the
 212      * {@code X509Certificate}. If {@code null}, any issuer
 213      * distinguished name will do.
 214      * &lt;p&gt;
 215      * If {@code issuerDN} is not {@code null}, it should contain a
 216      * distinguished name, in RFC 2253 format.
 217      *
 218      * @param issuerDN a distinguished name in RFC 2253 format
 219      *                 (or {@code null})
 220      * @throws IOException if a parsing error occurs (incorrect form for DN)
 221      */
 222     public void setIssuer(String issuerDN) throws IOException {
 223         if (issuerDN == null) {
 224             issuer = null;
 225         } else {
 226             issuer = new X500Name(issuerDN).asX500Principal();
 227         }
 228     }
 229 
 230     /**
 231      * Sets the issuer criterion. The specified distinguished name
 232      * must match the issuer distinguished name in the
 233      * {@code X509Certificate}. If {@code null} is specified,
 234      * the issuer criterion is disabled and any issuer distinguished name will
 235      * do.
 236      * &lt;p&gt;
 237      * If {@code issuerDN} is not {@code null}, it should contain a
 238      * single DER encoded distinguished name, as defined in X.501. The ASN.1
 239      * notation for this structure is as follows.
 240      * &lt;pre&gt;{@code
 241      * Name ::= CHOICE {
 242      *   RDNSequence }
 243      *
 244      * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
 245      *
 246      * RelativeDistinguishedName ::=
 247      *   SET SIZE (1 .. MAX) OF AttributeTypeAndValue
 248      *
 249      * AttributeTypeAndValue ::= SEQUENCE {
 250      *   type     AttributeType,
 251      *   value    AttributeValue }
 252      *
 253      * AttributeType ::= OBJECT IDENTIFIER
 254      *
 255      * AttributeValue ::= ANY DEFINED BY AttributeType
 256      * ....
 257      * DirectoryString ::= CHOICE {
 258      *       teletexString           TeletexString (SIZE (1..MAX)),
 259      *       printableString         PrintableString (SIZE (1..MAX)),
 260      *       universalString         UniversalString (SIZE (1..MAX)),
 261      *       utf8String              UTF8String (SIZE (1.. MAX)),
 262      *       bmpString               BMPString (SIZE (1..MAX)) }
 263      * }&lt;/pre&gt;
 264      * &lt;p&gt;
 265      * Note that the byte array specified here is cloned to protect against
 266      * subsequent modifications.
 267      *
 268      * @param issuerDN a byte array containing the distinguished name
 269      *                 in ASN.1 DER encoded form (or {@code null})
 270      * @throws IOException if an encoding error occurs (incorrect form for DN)
 271      */
 272     public void setIssuer(byte[] issuerDN) throws IOException {
 273         try {
 274             issuer = (issuerDN == null ? null : new X500Principal(issuerDN));
 275         } catch (IllegalArgumentException e) {
 276             throw new IOException(&quot;Invalid name&quot;, e);
 277         }
 278     }
 279 
 280     /**
 281      * Sets the subject criterion. The specified distinguished name
 282      * must match the subject distinguished name in the
 283      * {@code X509Certificate}. If {@code null}, any subject
 284      * distinguished name will do.
 285      *
 286      * @param subject a distinguished name as X500Principal
 287      *                  (or {@code null})
 288      * @since 1.5
 289      */
 290     public void setSubject(X500Principal subject) {
 291         this.subject = subject;
 292     }
 293 
 294     /**
 295      * &lt;strong&gt;Denigrated&lt;/strong&gt;, use {@linkplain #setSubject(X500Principal)}
 296      * or {@linkplain #setSubject(byte[])} instead. This method should not be
 297      * relied on as it can fail to match some certificates because of a loss of
 298      * encoding information in the RFC 2253 String form of some distinguished
 299      * names.
 300      * &lt;p&gt;
 301      * Sets the subject criterion. The specified distinguished name
 302      * must match the subject distinguished name in the
 303      * {@code X509Certificate}. If {@code null}, any subject
 304      * distinguished name will do.
 305      * &lt;p&gt;
 306      * If {@code subjectDN} is not {@code null}, it should contain a
 307      * distinguished name, in RFC 2253 format.
 308      *
 309      * @param subjectDN a distinguished name in RFC 2253 format
 310      *                  (or {@code null})
 311      * @throws IOException if a parsing error occurs (incorrect form for DN)
 312      */
 313     public void setSubject(String subjectDN) throws IOException {
 314         if (subjectDN == null) {
 315             subject = null;
 316         } else {
 317             subject = new X500Name(subjectDN).asX500Principal();
 318         }
 319     }
 320 
 321     /**
 322      * Sets the subject criterion. The specified distinguished name
 323      * must match the subject distinguished name in the
 324      * {@code X509Certificate}. If {@code null}, any subject
 325      * distinguished name will do.
 326      * &lt;p&gt;
 327      * If {@code subjectDN} is not {@code null}, it should contain a
 328      * single DER encoded distinguished name, as defined in X.501. For the ASN.1
 329      * notation for this structure, see
 330      * {@link #setIssuer(byte [] issuerDN) setIssuer(byte [] issuerDN)}.
 331      *
 332      * @param subjectDN a byte array containing the distinguished name in
 333      *                  ASN.1 DER format (or {@code null})
 334      * @throws IOException if an encoding error occurs (incorrect form for DN)
 335      */
 336     public void setSubject(byte[] subjectDN) throws IOException {
 337         try {
 338             subject = (subjectDN == null ? null : new X500Principal(subjectDN));
 339         } catch (IllegalArgumentException e) {
 340             throw new IOException(&quot;Invalid name&quot;, e);
 341         }
 342     }
 343 
 344     /**
 345      * Sets the subjectKeyIdentifier criterion. The
 346      * {@code X509Certificate} must contain a SubjectKeyIdentifier
 347      * extension for which the contents of the extension
 348      * matches the specified criterion value.
 349      * If the criterion value is {@code null}, no
 350      * subjectKeyIdentifier check will be done.
 351      * &lt;p&gt;
 352      * If {@code subjectKeyID} is not {@code null}, it
 353      * should contain a single DER encoded value corresponding to the contents
 354      * of the extension value (not including the object identifier,
 355      * criticality setting, and encapsulating OCTET STRING)
 356      * for a SubjectKeyIdentifier extension.
 357      * The ASN.1 notation for this structure follows.
 358      *
 359      * &lt;pre&gt;{@code
 360      * SubjectKeyIdentifier ::= KeyIdentifier
 361      *
 362      * KeyIdentifier ::= OCTET STRING
 363      * }&lt;/pre&gt;
 364      * &lt;p&gt;
 365      * Since the format of subject key identifiers is not mandated by
 366      * any standard, subject key identifiers are not parsed by the
 367      * {@code X509CertSelector}. Instead, the values are compared using
 368      * a byte-by-byte comparison.
 369      * &lt;p&gt;
 370      * Note that the byte array supplied here is cloned to protect against
 371      * subsequent modifications.
 372      *
 373      * @param subjectKeyID the subject key identifier (or {@code null})
 374      * @see #getSubjectKeyIdentifier
 375      */
 376     public void setSubjectKeyIdentifier(byte[] subjectKeyID) {
 377         if (subjectKeyID == null) {
 378             this.subjectKeyID = null;
 379         } else {
 380             this.subjectKeyID = subjectKeyID.clone();
 381         }
 382     }
 383 
 384     /**
 385      * Sets the authorityKeyIdentifier criterion. The
 386      * {@code X509Certificate} must contain an
 387      * AuthorityKeyIdentifier extension for which the contents of the
 388      * extension value matches the specified criterion value.
 389      * If the criterion value is {@code null}, no
 390      * authorityKeyIdentifier check will be done.
 391      * &lt;p&gt;
 392      * If {@code authorityKeyID} is not {@code null}, it
 393      * should contain a single DER encoded value corresponding to the contents
 394      * of the extension value (not including the object identifier,
 395      * criticality setting, and encapsulating OCTET STRING)
 396      * for an AuthorityKeyIdentifier extension.
 397      * The ASN.1 notation for this structure follows.
 398      *
 399      * &lt;pre&gt;{@code
 400      * AuthorityKeyIdentifier ::= SEQUENCE {
 401      *    keyIdentifier             [0] KeyIdentifier           OPTIONAL,
 402      *    authorityCertIssuer       [1] GeneralNames            OPTIONAL,
 403      *    authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }
 404      *
 405      * KeyIdentifier ::= OCTET STRING
 406      * }&lt;/pre&gt;
 407      * &lt;p&gt;
 408      * Authority key identifiers are not parsed by the
 409      * {@code X509CertSelector}.  Instead, the values are
 410      * compared using a byte-by-byte comparison.
 411      * &lt;p&gt;
 412      * When the {@code keyIdentifier} field of
 413      * {@code AuthorityKeyIdentifier} is populated, the value is
 414      * usually taken from the {@code SubjectKeyIdentifier} extension
 415      * in the issuer&#39;s certificate.  Note, however, that the result of
 416      * {@code X509Certificate.getExtensionValue(&lt;SubjectKeyIdentifier Object
 417      * Identifier&gt;)} on the issuer&#39;s certificate may NOT be used
 418      * directly as the input to {@code setAuthorityKeyIdentifier}.
 419      * This is because the SubjectKeyIdentifier contains
 420      * only a KeyIdentifier OCTET STRING, and not a SEQUENCE of
 421      * KeyIdentifier, GeneralNames, and CertificateSerialNumber.
 422      * In order to use the extension value of the issuer certificate&#39;s
 423      * {@code SubjectKeyIdentifier}
 424      * extension, it will be necessary to extract the value of the embedded
 425      * {@code KeyIdentifier} OCTET STRING, then DER encode this OCTET
 426      * STRING inside a SEQUENCE.
 427      * For more details on SubjectKeyIdentifier, see
 428      * {@link #setSubjectKeyIdentifier(byte[] subjectKeyID)}.
 429      * &lt;p&gt;
 430      * Note also that the byte array supplied here is cloned to protect against
 431      * subsequent modifications.
 432      *
 433      * @param authorityKeyID the authority key identifier
 434      *        (or {@code null})
 435      * @see #getAuthorityKeyIdentifier
 436      */
 437     public void setAuthorityKeyIdentifier(byte[] authorityKeyID) {
 438         if (authorityKeyID == null) {
 439             this.authorityKeyID = null;
 440         } else {
 441             this.authorityKeyID = authorityKeyID.clone();
 442         }
 443     }
 444 
 445     /**
 446      * Sets the certificateValid criterion. The specified date must fall
 447      * within the certificate validity period for the
 448      * {@code X509Certificate}. If {@code null}, no certificateValid
 449      * check will be done.
 450      * &lt;p&gt;
 451      * Note that the {@code Date} supplied here is cloned to protect
 452      * against subsequent modifications.
 453      *
 454      * @param certValid the {@code Date} to check (or {@code null})
 455      * @see #getCertificateValid
 456      */
 457     public void setCertificateValid(Date certValid) {
 458         if (certValid == null) {
 459             certificateValid = null;
 460         } else {
 461             certificateValid = (Date)certValid.clone();
 462         }
 463     }
 464 
 465     /**
 466      * Sets the privateKeyValid criterion. The specified date must fall
 467      * within the private key validity period for the
 468      * {@code X509Certificate}. If {@code null}, no privateKeyValid
 469      * check will be done.
 470      * &lt;p&gt;
 471      * Note that the {@code Date} supplied here is cloned to protect
 472      * against subsequent modifications.
 473      *
 474      * @param privateKeyValid the {@code Date} to check (or
 475      *                        {@code null})
 476      * @see #getPrivateKeyValid
 477      */
 478     public void setPrivateKeyValid(Date privateKeyValid) {
 479         if (privateKeyValid == null) {
 480             this.privateKeyValid = null;
 481         } else {
 482             this.privateKeyValid = (Date)privateKeyValid.clone();
 483         }
 484     }
 485 
 486     /**
 487      * Sets the subjectPublicKeyAlgID criterion. The
 488      * {@code X509Certificate} must contain a subject public key
 489      * with the specified algorithm. If {@code null}, no
 490      * subjectPublicKeyAlgID check will be done.
 491      *
 492      * @param oid The object identifier (OID) of the algorithm to check
 493      *            for (or {@code null}). An OID is represented by a
 494      *            set of nonnegative integers separated by periods.
 495      * @throws IOException if the OID is invalid, such as
 496      * the first component being not 0, 1 or 2 or the second component
 497      * being greater than 39.
 498      *
 499      * @see #getSubjectPublicKeyAlgID
 500      */
 501     public void setSubjectPublicKeyAlgID(String oid) throws IOException {
 502         if (oid == null) {
 503             subjectPublicKeyAlgID = null;
 504         } else {
 505             subjectPublicKeyAlgID = ObjectIdentifier.of(oid);
 506         }
 507     }
 508 
 509     /**
 510      * Sets the subjectPublicKey criterion. The
 511      * {@code X509Certificate} must contain the specified subject public
 512      * key. If {@code null}, no subjectPublicKey check will be done.
 513      *
 514      * @param key the subject public key to check for (or {@code null})
 515      * @see #getSubjectPublicKey
 516      */
 517     public void setSubjectPublicKey(PublicKey key) {
 518         if (key == null) {
 519             subjectPublicKey = null;
 520             subjectPublicKeyBytes = null;
 521         } else {
 522             subjectPublicKey = key;
 523             subjectPublicKeyBytes = key.getEncoded();
 524         }
 525     }
 526 
 527     /**
 528      * Sets the subjectPublicKey criterion. The {@code X509Certificate}
 529      * must contain the specified subject public key. If {@code null},
 530      * no subjectPublicKey check will be done.
 531      * &lt;p&gt;
 532      * Because this method allows the public key to be specified as a byte
 533      * array, it may be used for unknown key types.
 534      * &lt;p&gt;
 535      * If {@code key} is not {@code null}, it should contain a
 536      * single DER encoded SubjectPublicKeyInfo structure, as defined in X.509.
 537      * The ASN.1 notation for this structure is as follows.
 538      * &lt;pre&gt;{@code
 539      * SubjectPublicKeyInfo  ::=  SEQUENCE  {
 540      *   algorithm            AlgorithmIdentifier,
 541      *   subjectPublicKey     BIT STRING  }
 542      *
 543      * AlgorithmIdentifier  ::=  SEQUENCE  {
 544      *   algorithm               OBJECT IDENTIFIER,
 545      *   parameters              ANY DEFINED BY algorithm OPTIONAL  }
 546      *                              -- contains a value of the type
 547      *                              -- registered for use with the
 548      *                              -- algorithm object identifier value
 549      * }&lt;/pre&gt;
 550      * &lt;p&gt;
 551      * Note that the byte array supplied here is cloned to protect against
 552      * subsequent modifications.
 553      *
 554      * @param key a byte array containing the subject public key in ASN.1 DER
 555      *            form (or {@code null})
 556      * @throws IOException if an encoding error occurs (incorrect form for
 557      * subject public key)
 558      * @see #getSubjectPublicKey
 559      */
 560     public void setSubjectPublicKey(byte[] key) throws IOException {
 561         if (key == null) {
 562             subjectPublicKey = null;
 563             subjectPublicKeyBytes = null;
 564         } else {
 565             subjectPublicKeyBytes = key.clone();
 566             subjectPublicKey = X509Key.parse(new DerValue(subjectPublicKeyBytes));
 567         }
 568     }
 569 
 570     /**
 571      * Sets the keyUsage criterion. The {@code X509Certificate}
 572      * must allow the specified keyUsage values. If {@code null}, no
 573      * keyUsage check will be done. Note that an {@code X509Certificate}
 574      * that has no keyUsage extension implicitly allows all keyUsage values.
 575      * &lt;p&gt;
 576      * Note that the boolean array supplied here is cloned to protect against
 577      * subsequent modifications.
 578      *
 579      * @param keyUsage a boolean array in the same format as the boolean
 580      *                 array returned by
 581      * {@link X509Certificate#getKeyUsage() X509Certificate.getKeyUsage()}.
 582      *                 Or {@code null}.
 583      * @see #getKeyUsage
 584      */
 585     public void setKeyUsage(boolean[] keyUsage) {
 586         if (keyUsage == null) {
 587             this.keyUsage = null;
 588         } else {
 589             this.keyUsage = keyUsage.clone();
 590         }
 591     }
 592 
 593     /**
 594      * Sets the extendedKeyUsage criterion. The {@code X509Certificate}
 595      * must allow the specified key purposes in its extended key usage
 596      * extension. If {@code keyPurposeSet} is empty or {@code null},
 597      * no extendedKeyUsage check will be done. Note that an
 598      * {@code X509Certificate} that has no extendedKeyUsage extension
 599      * implicitly allows all key purposes.
 600      * &lt;p&gt;
 601      * Note that the {@code Set} is cloned to protect against
 602      * subsequent modifications.
 603      *
 604      * @param keyPurposeSet a {@code Set} of key purpose OIDs in string
 605      * format (or {@code null}). Each OID is represented by a set of
 606      * nonnegative integers separated by periods.
 607      * @throws IOException if the OID is invalid, such as
 608      * the first component being not 0, 1 or 2 or the second component
 609      * being greater than 39.
 610      * @see #getExtendedKeyUsage
 611      */
 612     public void setExtendedKeyUsage(Set&lt;String&gt; keyPurposeSet) throws IOException {
 613         if ((keyPurposeSet == null) || keyPurposeSet.isEmpty()) {
 614             this.keyPurposeSet = null;
 615             keyPurposeOIDSet = null;
 616         } else {
 617             this.keyPurposeSet =
 618                 Collections.unmodifiableSet(new HashSet&lt;&gt;(keyPurposeSet));
 619             keyPurposeOIDSet = new HashSet&lt;&gt;();
 620             for (String s : this.keyPurposeSet) {
 621                 keyPurposeOIDSet.add(ObjectIdentifier.of(s));
 622             }
 623         }
 624     }
 625 
 626     /**
 627      * Enables/disables matching all of the subjectAlternativeNames
 628      * specified in the {@link #setSubjectAlternativeNames
 629      * setSubjectAlternativeNames} or {@link #addSubjectAlternativeName
 630      * addSubjectAlternativeName} methods. If enabled,
 631      * the {@code X509Certificate} must contain all of the
 632      * specified subject alternative names. If disabled, the
 633      * {@code X509Certificate} must contain at least one of the
 634      * specified subject alternative names.
 635      *
 636      * &lt;p&gt;The matchAllNames flag is {@code true} by default.
 637      *
 638      * @param matchAllNames if {@code true}, the flag is enabled;
 639      * if {@code false}, the flag is disabled.
 640      * @see #getMatchAllSubjectAltNames
 641      */
 642     public void setMatchAllSubjectAltNames(boolean matchAllNames) {
 643         this.matchAllSubjectAltNames = matchAllNames;
 644     }
 645 
 646     /**
 647      * Sets the subjectAlternativeNames criterion. The
 648      * {@code X509Certificate} must contain all or at least one of the
 649      * specified subjectAlternativeNames, depending on the value of
 650      * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames
 651      * setMatchAllSubjectAltNames}).
 652      * &lt;p&gt;
 653      * This method allows the caller to specify, with a single method call,
 654      * the complete set of subject alternative names for the
 655      * subjectAlternativeNames criterion. The specified value replaces
 656      * the previous value for the subjectAlternativeNames criterion.
 657      * &lt;p&gt;
 658      * The {@code names} parameter (if not {@code null}) is a
 659      * {@code Collection} with one
 660      * entry for each name to be included in the subject alternative name
 661      * criterion. Each entry is a {@code List} whose first entry is an
 662      * {@code Integer} (the name type, 0-8) and whose second
 663      * entry is a {@code String} or a byte array (the name, in
 664      * string or ASN.1 DER encoded form, respectively).
 665      * There can be multiple names of the same type. If {@code null}
 666      * is supplied as the value for this argument, no
 667      * subjectAlternativeNames check will be performed.
 668      * &lt;p&gt;
 669      * Each subject alternative name in the {@code Collection}
 670      * may be specified either as a {@code String} or as an ASN.1 encoded
 671      * byte array. For more details about the formats used, see
 672      * {@link #addSubjectAlternativeName(int type, String name)
 673      * addSubjectAlternativeName(int type, String name)} and
 674      * {@link #addSubjectAlternativeName(int type, byte [] name)
 675      * addSubjectAlternativeName(int type, byte [] name)}.
 676      * &lt;p&gt;
 677      * &lt;strong&gt;Note:&lt;/strong&gt; for distinguished names, specify the byte
 678      * array form instead of the String form. See the note in
 679      * {@link #addSubjectAlternativeName(int, String)} for more information.
 680      * &lt;p&gt;
 681      * Note that the {@code names} parameter can contain duplicate
 682      * names (same name and name type), but they may be removed from the
 683      * {@code Collection} of names returned by the
 684      * {@link #getSubjectAlternativeNames getSubjectAlternativeNames} method.
 685      * &lt;p&gt;
 686      * Note that a deep copy is performed on the {@code Collection} to
 687      * protect against subsequent modifications.
 688      *
 689      * @param names a {@code Collection} of names (or {@code null})
 690      * @throws IOException if a parsing error occurs
 691      * @see #getSubjectAlternativeNames
 692      */
 693     public void setSubjectAlternativeNames(Collection&lt;List&lt;?&gt;&gt; names)
 694             throws IOException {
 695         if (names == null) {
 696             subjectAlternativeNames = null;
 697             subjectAlternativeGeneralNames = null;
 698         } else {
 699             if (names.isEmpty()) {
 700                 subjectAlternativeNames = null;
 701                 subjectAlternativeGeneralNames = null;
 702                 return;
 703             }
 704             Set&lt;List&lt;?&gt;&gt; tempNames = cloneAndCheckNames(names);
 705             // Ensure that we either set both of these or neither
 706             subjectAlternativeGeneralNames = parseNames(tempNames);
 707             subjectAlternativeNames = tempNames;
 708         }
 709     }
 710 
 711     /**
 712      * Adds a name to the subjectAlternativeNames criterion. The
 713      * {@code X509Certificate} must contain all or at least one
 714      * of the specified subjectAlternativeNames, depending on the value of
 715      * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames
 716      * setMatchAllSubjectAltNames}).
 717      * &lt;p&gt;
 718      * This method allows the caller to add a name to the set of subject
 719      * alternative names.
 720      * The specified name is added to any previous value for the
 721      * subjectAlternativeNames criterion. If the specified name is a
 722      * duplicate, it may be ignored.
 723      * &lt;p&gt;
 724      * The name is provided in string format.
 725      * &lt;a href=&quot;http://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt;, DNS, and URI
 726      * names use the well-established string formats for those types (subject to
 727      * the restrictions included in RFC 5280). IPv4 address names are
 728      * supplied using dotted quad notation. OID address names are represented
 729      * as a series of nonnegative integers separated by periods. And
 730      * directory names (distinguished names) are supplied in RFC 2253 format.
 731      * No standard string format is defined for otherNames, X.400 names,
 732      * EDI party names, IPv6 address names, or any other type of names. They
 733      * should be specified using the
 734      * {@link #addSubjectAlternativeName(int type, byte [] name)
 735      * addSubjectAlternativeName(int type, byte [] name)}
 736      * method.
 737      * &lt;p&gt;
 738      * &lt;strong&gt;Note:&lt;/strong&gt; for distinguished names, use
 739      * {@linkplain #addSubjectAlternativeName(int, byte[])} instead.
 740      * This method should not be relied on as it can fail to match some
 741      * certificates because of a loss of encoding information in the RFC 2253
 742      * String form of some distinguished names.
 743      *
 744      * @param type the name type (0-8, as specified in
 745      *             RFC 5280, section 4.2.1.6)
 746      * @param name the name in string form (not {@code null})
 747      * @throws IOException if a parsing error occurs
 748      */
 749     public void addSubjectAlternativeName(int type, String name)
 750             throws IOException {
 751         addSubjectAlternativeNameInternal(type, name);
 752     }
 753 
 754     /**
 755      * Adds a name to the subjectAlternativeNames criterion. The
 756      * {@code X509Certificate} must contain all or at least one
 757      * of the specified subjectAlternativeNames, depending on the value of
 758      * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames
 759      * setMatchAllSubjectAltNames}).
 760      * &lt;p&gt;
 761      * This method allows the caller to add a name to the set of subject
 762      * alternative names.
 763      * The specified name is added to any previous value for the
 764      * subjectAlternativeNames criterion. If the specified name is a
 765      * duplicate, it may be ignored.
 766      * &lt;p&gt;
 767      * The name is provided as a byte array. This byte array should contain
 768      * the DER encoded name, as it would appear in the GeneralName structure
 769      * defined in RFC 5280 and X.509. The encoded byte array should only contain
 770      * the encoded value of the name, and should not include the tag associated
 771      * with the name in the GeneralName structure. The ASN.1 definition of this
 772      * structure appears below.
 773      * &lt;pre&gt;{@code
 774      *  GeneralName ::= CHOICE {
 775      *       otherName                       [0]     OtherName,
 776      *       rfc822Name                      [1]     IA5String,
 777      *       dNSName                         [2]     IA5String,
 778      *       x400Address                     [3]     ORAddress,
 779      *       directoryName                   [4]     Name,
 780      *       ediPartyName                    [5]     EDIPartyName,
 781      *       uniformResourceIdentifier       [6]     IA5String,
 782      *       iPAddress                       [7]     OCTET STRING,
 783      *       registeredID                    [8]     OBJECT IDENTIFIER}
 784      * }&lt;/pre&gt;
 785      * &lt;p&gt;
 786      * Note that the byte array supplied here is cloned to protect against
 787      * subsequent modifications.
 788      *
 789      * @param type the name type (0-8, as listed above)
 790      * @param name a byte array containing the name in ASN.1 DER encoded form
 791      * @throws IOException if a parsing error occurs
 792      */
 793     public void addSubjectAlternativeName(int type, byte[] name)
 794             throws IOException {
 795         // clone because byte arrays are modifiable
 796         addSubjectAlternativeNameInternal(type, name.clone());
 797     }
 798 
 799     /**
 800      * A private method that adds a name (String or byte array) to the
 801      * subjectAlternativeNames criterion. The {@code X509Certificate}
 802      * must contain the specified subjectAlternativeName.
 803      *
 804      * @param type the name type (0-8, as specified in
 805      *             RFC 5280, section 4.2.1.6)
 806      * @param name the name in string or byte array form
 807      * @throws IOException if a parsing error occurs
 808      */
 809     private void addSubjectAlternativeNameInternal(int type, Object name)
 810             throws IOException {
 811         // First, ensure that the name parses
 812         GeneralNameInterface tempName = makeGeneralNameInterface(type, name);
 813         if (subjectAlternativeNames == null) {
 814             subjectAlternativeNames = new HashSet&lt;&gt;();
 815         }
 816         if (subjectAlternativeGeneralNames == null) {
 817             subjectAlternativeGeneralNames = new HashSet&lt;&gt;();
 818         }
 819         List&lt;Object&gt; list = new ArrayList&lt;&gt;(2);
 820         list.add(Integer.valueOf(type));
 821         list.add(name);
 822         subjectAlternativeNames.add(list);
 823         subjectAlternativeGeneralNames.add(tempName);
 824     }
 825 
 826     /**
 827      * Parse an argument of the form passed to setSubjectAlternativeNames,
 828      * returning a {@code Collection} of
 829      * {@code GeneralNameInterface}s.
 830      * Throw an IllegalArgumentException or a ClassCastException
 831      * if the argument is malformed.
 832      *
 833      * @param names a Collection with one entry per name.
 834      *              Each entry is a {@code List} whose first entry
 835      *              is an Integer (the name type, 0-8) and whose second
 836      *              entry is a String or a byte array (the name, in
 837      *              string or ASN.1 DER encoded form, respectively).
 838      *              There can be multiple names of the same type. Null is
 839      *              not an acceptable value.
 840      * @return a Set of {@code GeneralNameInterface}s
 841      * @throws IOException if a parsing error occurs
 842      */
 843     private static Set&lt;GeneralNameInterface&gt; parseNames(Collection&lt;List&lt;?&gt;&gt; names) throws IOException {
 844         Set&lt;GeneralNameInterface&gt; genNames = new HashSet&lt;&gt;();
 845         for (List&lt;?&gt; nameList : names) {
 846             if (nameList.size() != 2) {
 847                 throw new IOException(&quot;name list size not 2&quot;);
 848             }
 849             Object o =  nameList.get(0);
 850             if (!(o instanceof Integer)) {
 851                 throw new IOException(&quot;expected an Integer&quot;);
 852             }
 853             int nameType = ((Integer)o).intValue();
 854             o = nameList.get(1);
 855             genNames.add(makeGeneralNameInterface(nameType, o));
 856         }
 857 
 858         return genNames;
 859     }
 860 
 861     /**
 862      * Compare for equality two objects of the form passed to
 863      * setSubjectAlternativeNames (or X509CRLSelector.setIssuerNames).
 864      * Throw an {@code IllegalArgumentException} or a
 865      * {@code ClassCastException} if one of the objects is malformed.
 866      *
 867      * @param object1 a Collection containing the first object to compare
 868      * @param object2 a Collection containing the second object to compare
 869      * @return true if the objects are equal, false otherwise
 870      */
 871     static boolean equalNames(Collection&lt;?&gt; object1, Collection&lt;?&gt; object2) {
 872         if ((object1 == null) || (object2 == null)) {
 873             return object1 == object2;
 874         }
 875         return object1.equals(object2);
 876     }
 877 
 878     /**
 879      * Make a {@code GeneralNameInterface} out of a name type (0-8) and an
 880      * Object that may be a byte array holding the ASN.1 DER encoded
 881      * name or a String form of the name.  Except for X.509
 882      * Distinguished Names, the String form of the name must not be the
 883      * result from calling toString on an existing GeneralNameInterface
 884      * implementing class.  The output of toString is not compatible
 885      * with the String constructors for names other than Distinguished
 886      * Names.
 887      *
 888      * @param type name type (0-8)
 889      * @param name name as ASN.1 Der-encoded byte array or String
 890      * @return a GeneralNameInterface name
 891      * @throws IOException if a parsing error occurs
 892      */
 893     static GeneralNameInterface makeGeneralNameInterface(int type, Object name)
 894             throws IOException {
 895         GeneralNameInterface result;
 896         if (debug != null) {
 897             debug.println(&quot;X509CertSelector.makeGeneralNameInterface(&quot;
 898                 + type + &quot;)...&quot;);
 899         }
 900 
 901         if (name instanceof String) {
 902             if (debug != null) {
 903                 debug.println(&quot;X509CertSelector.makeGeneralNameInterface() &quot;
 904                     + &quot;name is String: &quot; + name);
 905             }
 906             switch (type) {
 907             case NAME_RFC822:
 908                 result = new RFC822Name((String)name);
 909                 break;
 910             case NAME_DNS:
 911                 result = new DNSName((String)name);
 912                 break;
 913             case NAME_DIRECTORY:
 914                 result = new X500Name((String)name);
 915                 break;
 916             case NAME_URI:
 917                 result = new URIName((String)name);
 918                 break;
 919             case NAME_IP:
 920                 result = new IPAddressName((String)name);
 921                 break;
 922             case NAME_OID:
 923                 result = new OIDName((String)name);
 924                 break;
 925             default:
 926                 throw new IOException(&quot;unable to parse String names of type &quot;
 927                                       + type);
 928             }
 929             if (debug != null) {
 930                 debug.println(&quot;X509CertSelector.makeGeneralNameInterface() &quot;
 931                     + &quot;result: &quot; + result.toString());
 932             }
 933         } else if (name instanceof byte[]) {
 934             DerValue val = new DerValue((byte[]) name);
 935             if (debug != null) {
 936                 debug.println
 937                     (&quot;X509CertSelector.makeGeneralNameInterface() is byte[]&quot;);
 938             }
 939 
 940             switch (type) {
 941             case NAME_ANY:
 942                 result = new OtherName(val);
 943                 break;
 944             case NAME_RFC822:
 945                 result = new RFC822Name(val);
 946                 break;
 947             case NAME_DNS:
 948                 result = new DNSName(val);
 949                 break;
 950             case NAME_X400:
 951                 result = new X400Address(val);
 952                 break;
 953             case NAME_DIRECTORY:
 954                 result = new X500Name(val);
 955                 break;
 956             case NAME_EDI:
 957                 result = new EDIPartyName(val);
 958                 break;
 959             case NAME_URI:
 960                 result = new URIName(val);
 961                 break;
 962             case NAME_IP:
 963                 result = new IPAddressName(val);
 964                 break;
 965             case NAME_OID:
 966                 result = new OIDName(val);
 967                 break;
 968             default:
 969                 throw new IOException(&quot;unable to parse byte array names of &quot;
 970                     + &quot;type &quot; + type);
 971             }
 972             if (debug != null) {
 973                 debug.println(&quot;X509CertSelector.makeGeneralNameInterface() result: &quot;
 974                     + result.toString());
 975             }
 976         } else {
 977             if (debug != null) {
 978                 debug.println(&quot;X509CertSelector.makeGeneralName() input name &quot;
 979                     + &quot;not String or byte array&quot;);
 980             }
 981             throw new IOException(&quot;name not String or byte array&quot;);
 982         }
 983         return result;
 984     }
 985 
 986 
 987     /**
 988      * Sets the name constraints criterion. The {@code X509Certificate}
 989      * must have subject and subject alternative names that
 990      * meet the specified name constraints.
 991      * &lt;p&gt;
 992      * The name constraints are specified as a byte array. This byte array
 993      * should contain the DER encoded form of the name constraints, as they
 994      * would appear in the NameConstraints structure defined in RFC 5280
 995      * and X.509. The ASN.1 definition of this structure appears below.
 996      *
 997      * &lt;pre&gt;{@code
 998      *  NameConstraints ::= SEQUENCE {
 999      *       permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,
1000      *       excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }
1001      *
1002      *  GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree
1003      *
1004      *  GeneralSubtree ::= SEQUENCE {
1005      *       base                    GeneralName,
1006      *       minimum         [0]     BaseDistance DEFAULT 0,
1007      *       maximum         [1]     BaseDistance OPTIONAL }
1008      *
1009      *  BaseDistance ::= INTEGER (0..MAX)
1010      *
1011      *  GeneralName ::= CHOICE {
1012      *       otherName                       [0]     OtherName,
1013      *       rfc822Name                      [1]     IA5String,
1014      *       dNSName                         [2]     IA5String,
1015      *       x400Address                     [3]     ORAddress,
1016      *       directoryName                   [4]     Name,
1017      *       ediPartyName                    [5]     EDIPartyName,
1018      *       uniformResourceIdentifier       [6]     IA5String,
1019      *       iPAddress                       [7]     OCTET STRING,
1020      *       registeredID                    [8]     OBJECT IDENTIFIER}
1021      * }&lt;/pre&gt;
1022      * &lt;p&gt;
1023      * Note that the byte array supplied here is cloned to protect against
1024      * subsequent modifications.
1025      *
1026      * @param bytes a byte array containing the ASN.1 DER encoding of
1027      *              a NameConstraints extension to be used for checking
1028      *              name constraints. Only the value of the extension is
1029      *              included, not the OID or criticality flag. Can be
1030      *              {@code null},
1031      *              in which case no name constraints check will be performed.
1032      * @throws IOException if a parsing error occurs
1033      * @see #getNameConstraints
1034      */
1035     public void setNameConstraints(byte[] bytes) throws IOException {
1036         if (bytes == null) {
1037             ncBytes = null;
1038             nc = null;
1039         } else {
1040             ncBytes = bytes.clone();
1041             nc = new NameConstraintsExtension(FALSE, bytes);
1042         }
1043     }
1044 
1045     /**
1046      * Sets the basic constraints constraint. If the value is greater than or
1047      * equal to zero, {@code X509Certificates} must include a
1048      * basicConstraints extension with
1049      * a pathLen of at least this value. If the value is -2, only end-entity
1050      * certificates are accepted. If the value is -1, no check is done.
1051      * &lt;p&gt;
1052      * This constraint is useful when building a certification path forward
1053      * (from the target toward the trust anchor. If a partial path has been
1054      * built, any candidate certificate must have a maxPathLen value greater
1055      * than or equal to the number of certificates in the partial path.
1056      *
1057      * @param minMaxPathLen the value for the basic constraints constraint
1058      * @throws IllegalArgumentException if the value is less than -2
1059      * @see #getBasicConstraints
1060      */
1061     public void setBasicConstraints(int minMaxPathLen) {
1062         if (minMaxPathLen &lt; -2) {
1063             throw new IllegalArgumentException(&quot;basic constraints less than -2&quot;);
1064         }
1065         basicConstraints = minMaxPathLen;
1066     }
1067 
1068     /**
1069      * Sets the policy constraint. The {@code X509Certificate} must
1070      * include at least one of the specified policies in its certificate
1071      * policies extension. If {@code certPolicySet} is empty, then the
1072      * {@code X509Certificate} must include at least some specified policy
1073      * in its certificate policies extension. If {@code certPolicySet} is
1074      * {@code null}, no policy check will be performed.
1075      * &lt;p&gt;
1076      * Note that the {@code Set} is cloned to protect against
1077      * subsequent modifications.
1078      *
1079      * @param certPolicySet a {@code Set} of certificate policy OIDs in
1080      *                      string format (or {@code null}). Each OID is
1081      *                      represented by a set of nonnegative integers
1082      *                    separated by periods.
1083      * @throws IOException if a parsing error occurs on the OID such as
1084      * the first component is not 0, 1 or 2 or the second component is
1085      * greater than 39.
1086      * @see #getPolicy
1087      */
1088     public void setPolicy(Set&lt;String&gt; certPolicySet) throws IOException {
1089         if (certPolicySet == null) {
1090             policySet = null;
1091             policy = null;
1092         } else {
1093             // Snapshot set and parse it
1094             Set&lt;String&gt; tempSet = Collections.unmodifiableSet
1095                                         (new HashSet&lt;&gt;(certPolicySet));
1096             /* Convert to Vector of ObjectIdentifiers */
1097             Iterator&lt;String&gt; i = tempSet.iterator();
1098             Vector&lt;CertificatePolicyId&gt; polIdVector = new Vector&lt;&gt;();
1099             while (i.hasNext()) {
1100                 Object o = i.next();
1101                 if (!(o instanceof String)) {
1102                     throw new IOException(&quot;non String in certPolicySet&quot;);
1103                 }
1104                 polIdVector.add(new CertificatePolicyId
1105                         (ObjectIdentifier.of((String)o)));
1106             }
1107             // If everything went OK, make the changes
1108             policySet = tempSet;
1109             policy = new CertificatePolicySet(polIdVector);
1110         }
1111     }
1112 
1113     /**
1114      * Sets the pathToNames criterion. The {@code X509Certificate} must
1115      * not include name constraints that would prohibit building a
1116      * path to the specified names.
1117      * &lt;p&gt;
1118      * This method allows the caller to specify, with a single method call,
1119      * the complete set of names which the {@code X509Certificates}&#39;s
1120      * name constraints must permit. The specified value replaces
1121      * the previous value for the pathToNames criterion.
1122      * &lt;p&gt;
1123      * This constraint is useful when building a certification path forward
1124      * (from the target toward the trust anchor. If a partial path has been
1125      * built, any candidate certificate must not include name constraints that
1126      * would prohibit building a path to any of the names in the partial path.
1127      * &lt;p&gt;
1128      * The {@code names} parameter (if not {@code null}) is a
1129      * {@code Collection} with one
1130      * entry for each name to be included in the pathToNames
1131      * criterion. Each entry is a {@code List} whose first entry is an
1132      * {@code Integer} (the name type, 0-8) and whose second
1133      * entry is a {@code String} or a byte array (the name, in
1134      * string or ASN.1 DER encoded form, respectively).
1135      * There can be multiple names of the same type. If {@code null}
1136      * is supplied as the value for this argument, no
1137      * pathToNames check will be performed.
1138      * &lt;p&gt;
1139      * Each name in the {@code Collection}
1140      * may be specified either as a {@code String} or as an ASN.1 encoded
1141      * byte array. For more details about the formats used, see
1142      * {@link #addPathToName(int type, String name)
1143      * addPathToName(int type, String name)} and
1144      * {@link #addPathToName(int type, byte [] name)
1145      * addPathToName(int type, byte [] name)}.
1146      * &lt;p&gt;
1147      * &lt;strong&gt;Note:&lt;/strong&gt; for distinguished names, specify the byte
1148      * array form instead of the String form. See the note in
1149      * {@link #addPathToName(int, String)} for more information.
1150      * &lt;p&gt;
1151      * Note that the {@code names} parameter can contain duplicate
1152      * names (same name and name type), but they may be removed from the
1153      * {@code Collection} of names returned by the
1154      * {@link #getPathToNames getPathToNames} method.
1155      * &lt;p&gt;
1156      * Note that a deep copy is performed on the {@code Collection} to
1157      * protect against subsequent modifications.
1158      *
1159      * @param names a {@code Collection} with one entry per name
1160      *              (or {@code null})
1161      * @throws IOException if a parsing error occurs
1162      * @see #getPathToNames
1163      */
1164     public void setPathToNames(Collection&lt;List&lt;?&gt;&gt; names) throws IOException {
1165         if ((names == null) || names.isEmpty()) {
1166             pathToNames = null;
1167             pathToGeneralNames = null;
1168         } else {
1169             Set&lt;List&lt;?&gt;&gt; tempNames = cloneAndCheckNames(names);
1170             pathToGeneralNames = parseNames(tempNames);
1171             // Ensure that we either set both of these or neither
1172             pathToNames = tempNames;
1173         }
1174     }
1175 
1176     // called from CertPathHelper
1177     void setPathToNamesInternal(Set&lt;GeneralNameInterface&gt; names) {
1178         // set names to non-null dummy value
1179         // this breaks getPathToNames()
1180         pathToNames = Collections.&lt;List&lt;?&gt;&gt;emptySet();
1181         pathToGeneralNames = names;
1182     }
1183 
1184     /**
1185      * Adds a name to the pathToNames criterion. The {@code X509Certificate}
1186      * must not include name constraints that would prohibit building a
1187      * path to the specified name.
1188      * &lt;p&gt;
1189      * This method allows the caller to add a name to the set of names which
1190      * the {@code X509Certificates}&#39;s name constraints must permit.
1191      * The specified name is added to any previous value for the
1192      * pathToNames criterion.  If the name is a duplicate, it may be ignored.
1193      * &lt;p&gt;
1194      * The name is provided in string format. RFC 822, DNS, and URI names
1195      * use the well-established string formats for those types (subject to
1196      * the restrictions included in RFC 5280). IPv4 address names are
1197      * supplied using dotted quad notation. OID address names are represented
1198      * as a series of nonnegative integers separated by periods. And
1199      * directory names (distinguished names) are supplied in RFC 2253 format.
1200      * No standard string format is defined for otherNames, X.400 names,
1201      * EDI party names, IPv6 address names, or any other type of names. They
1202      * should be specified using the
1203      * {@link #addPathToName(int type, byte [] name)
1204      * addPathToName(int type, byte [] name)} method.
1205      * &lt;p&gt;
1206      * &lt;strong&gt;Note:&lt;/strong&gt; for distinguished names, use
1207      * {@linkplain #addPathToName(int, byte[])} instead.
1208      * This method should not be relied on as it can fail to match some
1209      * certificates because of a loss of encoding information in the RFC 2253
1210      * String form of some distinguished names.
1211      *
1212      * @param type the name type (0-8, as specified in
1213      *             RFC 5280, section 4.2.1.6)
1214      * @param name the name in string form
1215      * @throws IOException if a parsing error occurs
1216      */
1217     public void addPathToName(int type, String name) throws IOException {
1218         addPathToNameInternal(type, name);
1219     }
1220 
1221     /**
1222      * Adds a name to the pathToNames criterion. The {@code X509Certificate}
1223      * must not include name constraints that would prohibit building a
1224      * path to the specified name.
1225      * &lt;p&gt;
1226      * This method allows the caller to add a name to the set of names which
1227      * the {@code X509Certificates}&#39;s name constraints must permit.
1228      * The specified name is added to any previous value for the
1229      * pathToNames criterion. If the name is a duplicate, it may be ignored.
1230      * &lt;p&gt;
1231      * The name is provided as a byte array. This byte array should contain
1232      * the DER encoded name, as it would appear in the GeneralName structure
1233      * defined in RFC 5280 and X.509. The ASN.1 definition of this structure
1234      * appears in the documentation for
1235      * {@link #addSubjectAlternativeName(int type, byte [] name)
1236      * addSubjectAlternativeName(int type, byte [] name)}.
1237      * &lt;p&gt;
1238      * Note that the byte array supplied here is cloned to protect against
1239      * subsequent modifications.
1240      *
1241      * @param type the name type (0-8, as specified in
1242      *             RFC 5280, section 4.2.1.6)
1243      * @param name a byte array containing the name in ASN.1 DER encoded form
1244      * @throws IOException if a parsing error occurs
1245      */
1246     public void addPathToName(int type, byte [] name) throws IOException {
1247         // clone because byte arrays are modifiable
1248         addPathToNameInternal(type, name.clone());
1249     }
1250 
1251     /**
1252      * A private method that adds a name (String or byte array) to the
1253      * pathToNames criterion. The {@code X509Certificate} must contain
1254      * the specified pathToName.
1255      *
1256      * @param type the name type (0-8, as specified in
1257      *             RFC 5280, section 4.2.1.6)
1258      * @param name the name in string or byte array form
1259      * @throws IOException if an encoding error occurs (incorrect form for DN)
1260      */
1261     private void addPathToNameInternal(int type, Object name)
1262             throws IOException {
1263         // First, ensure that the name parses
1264         GeneralNameInterface tempName = makeGeneralNameInterface(type, name);
1265         if (pathToGeneralNames == null) {
1266             pathToNames = new HashSet&lt;&gt;();
1267             pathToGeneralNames = new HashSet&lt;&gt;();
1268         }
1269         List&lt;Object&gt; list = new ArrayList&lt;&gt;(2);
1270         list.add(Integer.valueOf(type));
1271         list.add(name);
1272         pathToNames.add(list);
1273         pathToGeneralNames.add(tempName);
1274     }
1275 
1276     /**
1277      * Returns the certificateEquals criterion. The specified
1278      * {@code X509Certificate} must be equal to the
1279      * {@code X509Certificate} passed to the {@code match} method.
1280      * If {@code null}, this check is not applied.
1281      *
1282      * @return the {@code X509Certificate} to match (or {@code null})
1283      * @see #setCertificate
1284      */
1285     public X509Certificate getCertificate() {
1286         return x509Cert;
1287     }
1288 
1289     /**
1290      * Returns the serialNumber criterion. The specified serial number
1291      * must match the certificate serial number in the
1292      * {@code X509Certificate}. If {@code null}, any certificate
1293      * serial number will do.
1294      *
1295      * @return the certificate serial number to match
1296      *                (or {@code null})
1297      * @see #setSerialNumber
1298      */
1299     public BigInteger getSerialNumber() {
1300         return serialNumber;
1301     }
1302 
1303     /**
1304      * Returns the issuer criterion as an {@code X500Principal}. This
1305      * distinguished name must match the issuer distinguished name in the
1306      * {@code X509Certificate}. If {@code null}, the issuer criterion
1307      * is disabled and any issuer distinguished name will do.
1308      *
1309      * @return the required issuer distinguished name as X500Principal
1310      *         (or {@code null})
1311      * @since 1.5
1312      */
1313     public X500Principal getIssuer() {
1314         return issuer;
1315     }
1316 
1317     /**
1318      * &lt;strong&gt;Denigrated&lt;/strong&gt;, use {@linkplain #getIssuer()} or
1319      * {@linkplain #getIssuerAsBytes()} instead. This method should not be
1320      * relied on as it can fail to match some certificates because of a loss of
1321      * encoding information in the RFC 2253 String form of some distinguished
1322      * names.
1323      * &lt;p&gt;
1324      * Returns the issuer criterion as a {@code String}. This
1325      * distinguished name must match the issuer distinguished name in the
1326      * {@code X509Certificate}. If {@code null}, the issuer criterion
1327      * is disabled and any issuer distinguished name will do.
1328      * &lt;p&gt;
1329      * If the value returned is not {@code null}, it is a
1330      * distinguished name, in RFC 2253 format.
1331      *
1332      * @return the required issuer distinguished name in RFC 2253 format
1333      *         (or {@code null})
1334      */
1335     public String getIssuerAsString() {
1336         return (issuer == null ? null : issuer.getName());
1337     }
1338 
1339     /**
1340      * Returns the issuer criterion as a byte array. This distinguished name
1341      * must match the issuer distinguished name in the
1342      * {@code X509Certificate}. If {@code null}, the issuer criterion
1343      * is disabled and any issuer distinguished name will do.
1344      * &lt;p&gt;
1345      * If the value returned is not {@code null}, it is a byte
1346      * array containing a single DER encoded distinguished name, as defined in
1347      * X.501. The ASN.1 notation for this structure is supplied in the
1348      * documentation for
1349      * {@link #setIssuer(byte [] issuerDN) setIssuer(byte [] issuerDN)}.
1350      * &lt;p&gt;
1351      * Note that the byte array returned is cloned to protect against
1352      * subsequent modifications.
1353      *
1354      * @return a byte array containing the required issuer distinguished name
1355      *         in ASN.1 DER format (or {@code null})
1356      * @throws IOException if an encoding error occurs
1357      */
1358     public byte[] getIssuerAsBytes() throws IOException {
1359         return (issuer == null ? null: issuer.getEncoded());
1360     }
1361 
1362     /**
1363      * Returns the subject criterion as an {@code X500Principal}. This
1364      * distinguished name must match the subject distinguished name in the
1365      * {@code X509Certificate}. If {@code null}, the subject criterion
1366      * is disabled and any subject distinguished name will do.
1367      *
1368      * @return the required subject distinguished name as X500Principal
1369      *         (or {@code null})
1370      * @since 1.5
1371      */
1372     public X500Principal getSubject() {
1373         return subject;
1374     }
1375 
1376     /**
1377      * &lt;strong&gt;Denigrated&lt;/strong&gt;, use {@linkplain #getSubject()} or
1378      * {@linkplain #getSubjectAsBytes()} instead. This method should not be
1379      * relied on as it can fail to match some certificates because of a loss of
1380      * encoding information in the RFC 2253 String form of some distinguished
1381      * names.
1382      * &lt;p&gt;
1383      * Returns the subject criterion as a {@code String}. This
1384      * distinguished name must match the subject distinguished name in the
1385      * {@code X509Certificate}. If {@code null}, the subject criterion
1386      * is disabled and any subject distinguished name will do.
1387      * &lt;p&gt;
1388      * If the value returned is not {@code null}, it is a
1389      * distinguished name, in RFC 2253 format.
1390      *
1391      * @return the required subject distinguished name in RFC 2253 format
1392      *         (or {@code null})
1393      */
1394     public String getSubjectAsString() {
1395         return (subject == null ? null : subject.getName());
1396     }
1397 
1398     /**
1399      * Returns the subject criterion as a byte array. This distinguished name
1400      * must match the subject distinguished name in the
1401      * {@code X509Certificate}. If {@code null}, the subject criterion
1402      * is disabled and any subject distinguished name will do.
1403      * &lt;p&gt;
1404      * If the value returned is not {@code null}, it is a byte
1405      * array containing a single DER encoded distinguished name, as defined in
1406      * X.501. The ASN.1 notation for this structure is supplied in the
1407      * documentation for
1408      * {@link #setSubject(byte [] subjectDN) setSubject(byte [] subjectDN)}.
1409      * &lt;p&gt;
1410      * Note that the byte array returned is cloned to protect against
1411      * subsequent modifications.
1412      *
1413      * @return a byte array containing the required subject distinguished name
1414      *         in ASN.1 DER format (or {@code null})
1415      * @throws IOException if an encoding error occurs
1416      */
1417     public byte[] getSubjectAsBytes() throws IOException {
1418         return (subject == null ? null : subject.getEncoded());
1419     }
1420 
1421     /**
1422      * Returns the subjectKeyIdentifier criterion. The
1423      * {@code X509Certificate} must contain a SubjectKeyIdentifier
1424      * extension with the specified value. If {@code null}, no
1425      * subjectKeyIdentifier check will be done.
1426      * &lt;p&gt;
1427      * Note that the byte array returned is cloned to protect against
1428      * subsequent modifications.
1429      *
1430      * @return the key identifier (or {@code null})
1431      * @see #setSubjectKeyIdentifier
1432      */
1433     public byte[] getSubjectKeyIdentifier() {
1434         if (subjectKeyID == null) {
1435             return null;
1436         }
1437         return subjectKeyID.clone();
1438     }
1439 
1440     /**
1441      * Returns the authorityKeyIdentifier criterion. The
1442      * {@code X509Certificate} must contain a AuthorityKeyIdentifier
1443      * extension with the specified value. If {@code null}, no
1444      * authorityKeyIdentifier check will be done.
1445      * &lt;p&gt;
1446      * Note that the byte array returned is cloned to protect against
1447      * subsequent modifications.
1448      *
1449      * @return the key identifier (or {@code null})
1450      * @see #setAuthorityKeyIdentifier
1451      */
1452     public byte[] getAuthorityKeyIdentifier() {
1453         if (authorityKeyID == null) {
1454           return null;
1455         }
1456         return authorityKeyID.clone();
1457     }
1458 
1459     /**
1460      * Returns the certificateValid criterion. The specified date must fall
1461      * within the certificate validity period for the
1462      * {@code X509Certificate}. If {@code null}, no certificateValid
1463      * check will be done.
1464      * &lt;p&gt;
1465      * Note that the {@code Date} returned is cloned to protect against
1466      * subsequent modifications.
1467      *
1468      * @return the {@code Date} to check (or {@code null})
1469      * @see #setCertificateValid
1470      */
1471     public Date getCertificateValid() {
1472         if (certificateValid == null) {
1473             return null;
1474         }
1475         return (Date)certificateValid.clone();
1476     }
1477 
1478     /**
1479      * Returns the privateKeyValid criterion. The specified date must fall
1480      * within the private key validity period for the
1481      * {@code X509Certificate}. If {@code null}, no privateKeyValid
1482      * check will be done.
1483      * &lt;p&gt;
1484      * Note that the {@code Date} returned is cloned to protect against
1485      * subsequent modifications.
1486      *
1487      * @return the {@code Date} to check (or {@code null})
1488      * @see #setPrivateKeyValid
1489      */
1490     public Date getPrivateKeyValid() {
1491         if (privateKeyValid == null) {
1492             return null;
1493         }
1494         return (Date)privateKeyValid.clone();
1495     }
1496 
1497     /**
1498      * Returns the subjectPublicKeyAlgID criterion. The
1499      * {@code X509Certificate} must contain a subject public key
1500      * with the specified algorithm. If {@code null}, no
1501      * subjectPublicKeyAlgID check will be done.
1502      *
1503      * @return the object identifier (OID) of the signature algorithm to check
1504      *         for (or {@code null}). An OID is represented by a set of
1505      *         nonnegative integers separated by periods.
1506      * @see #setSubjectPublicKeyAlgID
1507      */
1508     public String getSubjectPublicKeyAlgID() {
1509         if (subjectPublicKeyAlgID == null) {
1510             return null;
1511         }
1512         return subjectPublicKeyAlgID.toString();
1513     }
1514 
1515     /**
1516      * Returns the subjectPublicKey criterion. The
1517      * {@code X509Certificate} must contain the specified subject
1518      * public key. If {@code null}, no subjectPublicKey check will be done.
1519      *
1520      * @return the subject public key to check for (or {@code null})
1521      * @see #setSubjectPublicKey
1522      */
1523     public PublicKey getSubjectPublicKey() {
1524         return subjectPublicKey;
1525     }
1526 
1527     /**
1528      * Returns the keyUsage criterion. The {@code X509Certificate}
1529      * must allow the specified keyUsage values. If null, no keyUsage
1530      * check will be done.
1531      * &lt;p&gt;
1532      * Note that the boolean array returned is cloned to protect against
1533      * subsequent modifications.
1534      *
1535      * @return a boolean array in the same format as the boolean
1536      *                 array returned by
1537      * {@link X509Certificate#getKeyUsage() X509Certificate.getKeyUsage()}.
1538      *                 Or {@code null}.
1539      * @see #setKeyUsage
1540      */
1541     public boolean[] getKeyUsage() {
1542         if (keyUsage == null) {
1543             return null;
1544         }
1545         return keyUsage.clone();
1546     }
1547 
1548     /**
1549      * Returns the extendedKeyUsage criterion. The {@code X509Certificate}
1550      * must allow the specified key purposes in its extended key usage
1551      * extension. If the {@code keyPurposeSet} returned is empty or
1552      * {@code null}, no extendedKeyUsage check will be done. Note that an
1553      * {@code X509Certificate} that has no extendedKeyUsage extension
1554      * implicitly allows all key purposes.
1555      *
1556      * @return an immutable {@code Set} of key purpose OIDs in string
1557      * format (or {@code null})
1558      * @see #setExtendedKeyUsage
1559      */
1560     public Set&lt;String&gt; getExtendedKeyUsage() {
1561         return keyPurposeSet;
1562     }
1563 
1564     /**
1565      * Indicates if the {@code X509Certificate} must contain all
1566      * or at least one of the subjectAlternativeNames
1567      * specified in the {@link #setSubjectAlternativeNames
1568      * setSubjectAlternativeNames} or {@link #addSubjectAlternativeName
1569      * addSubjectAlternativeName} methods. If {@code true},
1570      * the {@code X509Certificate} must contain all of the
1571      * specified subject alternative names. If {@code false}, the
1572      * {@code X509Certificate} must contain at least one of the
1573      * specified subject alternative names.
1574      *
1575      * @return {@code true} if the flag is enabled;
1576      * {@code false} if the flag is disabled. The flag is
1577      * {@code true} by default.
1578      * @see #setMatchAllSubjectAltNames
1579      */
1580     public boolean getMatchAllSubjectAltNames() {
1581         return matchAllSubjectAltNames;
1582     }
1583 
1584     /**
1585      * Returns a copy of the subjectAlternativeNames criterion.
1586      * The {@code X509Certificate} must contain all or at least one
1587      * of the specified subjectAlternativeNames, depending on the value
1588      * of the matchAllNames flag (see {@link #getMatchAllSubjectAltNames
1589      * getMatchAllSubjectAltNames}). If the value returned is
1590      * {@code null}, no subjectAlternativeNames check will be performed.
1591      * &lt;p&gt;
1592      * If the value returned is not {@code null}, it is a
1593      * {@code Collection} with
1594      * one entry for each name to be included in the subject alternative name
1595      * criterion. Each entry is a {@code List} whose first entry is an
1596      * {@code Integer} (the name type, 0-8) and whose second
1597      * entry is a {@code String} or a byte array (the name, in
1598      * string or ASN.1 DER encoded form, respectively).
1599      * There can be multiple names of the same type.  Note that the
1600      * {@code Collection} returned may contain duplicate names (same name
1601      * and name type).
1602      * &lt;p&gt;
1603      * Each subject alternative name in the {@code Collection}
1604      * may be specified either as a {@code String} or as an ASN.1 encoded
1605      * byte array. For more details about the formats used, see
1606      * {@link #addSubjectAlternativeName(int type, String name)
1607      * addSubjectAlternativeName(int type, String name)} and
1608      * {@link #addSubjectAlternativeName(int type, byte [] name)
1609      * addSubjectAlternativeName(int type, byte [] name)}.
1610      * &lt;p&gt;
1611      * Note that a deep copy is performed on the {@code Collection} to
1612      * protect against subsequent modifications.
1613      *
1614      * @return a {@code Collection} of names (or {@code null})
1615      * @see #setSubjectAlternativeNames
1616      */
1617     public Collection&lt;List&lt;?&gt;&gt; getSubjectAlternativeNames() {
1618         if (subjectAlternativeNames == null) {
1619             return null;
1620         }
1621         return cloneNames(subjectAlternativeNames);
1622     }
1623 
1624     /**
1625      * Clone an object of the form passed to
1626      * setSubjectAlternativeNames and setPathToNames.
1627      * Throw a {@code RuntimeException} if the argument is malformed.
1628      * &lt;p&gt;
1629      * This method wraps cloneAndCheckNames, changing any
1630      * {@code IOException} into a {@code RuntimeException}. This
1631      * method should be used when the object being
1632      * cloned has already been checked, so there should never be any exceptions.
1633      *
1634      * @param names a {@code Collection} with one entry per name.
1635      *              Each entry is a {@code List} whose first entry
1636      *              is an Integer (the name type, 0-8) and whose second
1637      *              entry is a String or a byte array (the name, in
1638      *              string or ASN.1 DER encoded form, respectively).
1639      *              There can be multiple names of the same type. Null
1640      *              is not an acceptable value.
1641      * @return a deep copy of the specified {@code Collection}
1642      * @throws RuntimeException if a parsing error occurs
1643      */
1644     private static Set&lt;List&lt;?&gt;&gt; cloneNames(Collection&lt;List&lt;?&gt;&gt; names) {
1645         try {
1646             return cloneAndCheckNames(names);
1647         } catch (IOException e) {
1648             throw new RuntimeException(&quot;cloneNames encountered IOException: &quot; +
1649                                        e.getMessage());
1650         }
1651     }
1652 
1653     /**
1654      * Clone and check an argument of the form passed to
1655      * setSubjectAlternativeNames and setPathToNames.
1656      * Throw an {@code IOException} if the argument is malformed.
1657      *
1658      * @param names a {@code Collection} with one entry per name.
1659      *              Each entry is a {@code List} whose first entry
1660      *              is an Integer (the name type, 0-8) and whose second
1661      *              entry is a String or a byte array (the name, in
1662      *              string or ASN.1 DER encoded form, respectively).
1663      *              There can be multiple names of the same type.
1664      *              {@code null} is not an acceptable value.
1665      * @return a deep copy of the specified {@code Collection}
1666      * @throws IOException if a parsing error occurs
1667      */
1668     private static Set&lt;List&lt;?&gt;&gt; cloneAndCheckNames(Collection&lt;List&lt;?&gt;&gt; names) throws IOException {
1669         // Copy the Lists and Collection
1670         Set&lt;List&lt;?&gt;&gt; namesCopy = new HashSet&lt;&gt;();
1671         for (List&lt;?&gt; o : names)
1672         {
1673             namesCopy.add(new ArrayList&lt;&gt;(o));
1674         }
1675 
1676         // Check the contents of the Lists and clone any byte arrays
1677         for (List&lt;?&gt; list : namesCopy) {
1678             @SuppressWarnings(&quot;unchecked&quot;) // See javadoc for parameter &quot;names&quot;.
1679             List&lt;Object&gt; nameList = (List&lt;Object&gt;)list;
1680             if (nameList.size() != 2) {
1681                 throw new IOException(&quot;name list size not 2&quot;);
1682             }
1683             Object o = nameList.get(0);
1684             if (!(o instanceof Integer)) {
1685                 throw new IOException(&quot;expected an Integer&quot;);
1686             }
1687             int nameType = ((Integer)o).intValue();
1688             if ((nameType &lt; 0) || (nameType &gt; 8)) {
1689                 throw new IOException(&quot;name type not 0-8&quot;);
1690             }
1691             Object nameObject = nameList.get(1);
1692             if (!(nameObject instanceof byte[]) &amp;&amp;
1693                 !(nameObject instanceof String)) {
1694                 if (debug != null) {
1695                     debug.println(&quot;X509CertSelector.cloneAndCheckNames() &quot;
1696                         + &quot;name not byte array&quot;);
1697                 }
1698                 throw new IOException(&quot;name not byte array or String&quot;);
1699             }
1700             if (nameObject instanceof byte[]) {
1701                 nameList.set(1, ((byte[]) nameObject).clone());
1702             }
1703         }
1704         return namesCopy;
1705     }
1706 
1707     /**
1708      * Returns the name constraints criterion. The {@code X509Certificate}
1709      * must have subject and subject alternative names that
1710      * meet the specified name constraints.
1711      * &lt;p&gt;
1712      * The name constraints are returned as a byte array. This byte array
1713      * contains the DER encoded form of the name constraints, as they
1714      * would appear in the NameConstraints structure defined in RFC 5280
1715      * and X.509. The ASN.1 notation for this structure is supplied in the
1716      * documentation for
1717      * {@link #setNameConstraints(byte [] bytes) setNameConstraints(byte [] bytes)}.
1718      * &lt;p&gt;
1719      * Note that the byte array returned is cloned to protect against
1720      * subsequent modifications.
1721      *
1722      * @return a byte array containing the ASN.1 DER encoding of
1723      *         a NameConstraints extension used for checking name constraints.
1724      *         {@code null} if no name constraints check will be performed.
1725      * @see #setNameConstraints
1726      */
1727     public byte[] getNameConstraints() {
1728         if (ncBytes == null) {
1729             return null;
1730         } else {
1731             return ncBytes.clone();
1732         }
1733     }
1734 
1735     /**
1736      * Returns the basic constraints constraint. If the value is greater than
1737      * or equal to zero, the {@code X509Certificates} must include a
1738      * basicConstraints extension with a pathLen of at least this value.
1739      * If the value is -2, only end-entity certificates are accepted. If
1740      * the value is -1, no basicConstraints check is done.
1741      *
1742      * @return the value for the basic constraints constraint
1743      * @see #setBasicConstraints
1744      */
1745     public int getBasicConstraints() {
1746         return basicConstraints;
1747     }
1748 
1749     /**
1750      * Returns the policy criterion. The {@code X509Certificate} must
1751      * include at least one of the specified policies in its certificate policies
1752      * extension. If the {@code Set} returned is empty, then the
1753      * {@code X509Certificate} must include at least some specified policy
1754      * in its certificate policies extension. If the {@code Set} returned is
1755      * {@code null}, no policy check will be performed.
1756      *
1757      * @return an immutable {@code Set} of certificate policy OIDs in
1758      *         string format (or {@code null})
1759      * @see #setPolicy
1760      */
1761     public Set&lt;String&gt; getPolicy() {
1762         return policySet;
1763     }
1764 
1765     /**
1766      * Returns a copy of the pathToNames criterion. The
1767      * {@code X509Certificate} must not include name constraints that would
1768      * prohibit building a path to the specified names. If the value
1769      * returned is {@code null}, no pathToNames check will be performed.
1770      * &lt;p&gt;
1771      * If the value returned is not {@code null}, it is a
1772      * {@code Collection} with one
1773      * entry for each name to be included in the pathToNames
1774      * criterion. Each entry is a {@code List} whose first entry is an
1775      * {@code Integer} (the name type, 0-8) and whose second
1776      * entry is a {@code String} or a byte array (the name, in
1777      * string or ASN.1 DER encoded form, respectively).
1778      * There can be multiple names of the same type. Note that the
1779      * {@code Collection} returned may contain duplicate names (same
1780      * name and name type).
1781      * &lt;p&gt;
1782      * Each name in the {@code Collection}
1783      * may be specified either as a {@code String} or as an ASN.1 encoded
1784      * byte array. For more details about the formats used, see
1785      * {@link #addPathToName(int type, String name)
1786      * addPathToName(int type, String name)} and
1787      * {@link #addPathToName(int type, byte [] name)
1788      * addPathToName(int type, byte [] name)}.
1789      * &lt;p&gt;
1790      * Note that a deep copy is performed on the {@code Collection} to
1791      * protect against subsequent modifications.
1792      *
1793      * @return a {@code Collection} of names (or {@code null})
1794      * @see #setPathToNames
1795      */
1796     public Collection&lt;List&lt;?&gt;&gt; getPathToNames() {
1797         if (pathToNames == null) {
1798             return null;
1799         }
1800         return cloneNames(pathToNames);
1801     }
1802 
1803     /**
1804      * Return a printable representation of the {@code CertSelector}.
1805      *
1806      * @return a {@code String} describing the contents of the
1807      *         {@code CertSelector}
1808      */
1809     public String toString() {
1810         StringBuilder sb = new StringBuilder();
1811         sb.append(&quot;X509CertSelector: [\n&quot;);
1812         if (x509Cert != null) {
1813             sb.append(&quot;  Certificate: &quot; + x509Cert.toString() + &quot;\n&quot;);
1814         }
1815         if (serialNumber != null) {
1816             sb.append(&quot;  Serial Number: &quot; + serialNumber.toString() + &quot;\n&quot;);
1817         }
1818         if (issuer != null) {
1819             sb.append(&quot;  Issuer: &quot; + getIssuerAsString() + &quot;\n&quot;);
1820         }
1821         if (subject != null) {
1822             sb.append(&quot;  Subject: &quot; + getSubjectAsString() + &quot;\n&quot;);
1823         }
1824         sb.append(&quot;  matchAllSubjectAltNames flag: &quot;
1825                   + String.valueOf(matchAllSubjectAltNames) + &quot;\n&quot;);
1826         if (subjectAlternativeNames != null) {
1827             sb.append(&quot;  SubjectAlternativeNames:\n&quot;);
1828             Iterator&lt;List&lt;?&gt;&gt; i = subjectAlternativeNames.iterator();
1829             while (i.hasNext()) {
1830                 List&lt;?&gt; list = i.next();
1831                 sb.append(&quot;    type &quot; + list.get(0) +
1832                           &quot;, name &quot; + list.get(1) + &quot;\n&quot;);
1833             }
1834         }
1835         if (subjectKeyID != null) {
1836             HexDumpEncoder enc = new HexDumpEncoder();
1837             sb.append(&quot;  Subject Key Identifier: &quot; +
1838                       enc.encodeBuffer(subjectKeyID) + &quot;\n&quot;);
1839         }
1840         if (authorityKeyID != null) {
1841             HexDumpEncoder enc = new HexDumpEncoder();
1842             sb.append(&quot;  Authority Key Identifier: &quot; +
1843                       enc.encodeBuffer(authorityKeyID) + &quot;\n&quot;);
1844         }
1845         if (certificateValid != null) {
1846             sb.append(&quot;  Certificate Valid: &quot; +
1847                       certificateValid.toString() + &quot;\n&quot;);
1848         }
1849         if (privateKeyValid != null) {
1850             sb.append(&quot;  Private Key Valid: &quot; +
1851                       privateKeyValid.toString() + &quot;\n&quot;);
1852         }
1853         if (subjectPublicKeyAlgID != null) {
1854             sb.append(&quot;  Subject Public Key AlgID: &quot; +
1855                       subjectPublicKeyAlgID.toString() + &quot;\n&quot;);
1856         }
1857         if (subjectPublicKey != null) {
1858             sb.append(&quot;  Subject Public Key: &quot; +
1859                       subjectPublicKey.toString() + &quot;\n&quot;);
1860         }
1861         if (keyUsage != null) {
1862             sb.append(&quot;  Key Usage: &quot; + keyUsageToString(keyUsage) + &quot;\n&quot;);
1863         }
1864         if (keyPurposeSet != null) {
1865             sb.append(&quot;  Extended Key Usage: &quot; +
1866                       keyPurposeSet.toString() + &quot;\n&quot;);
1867         }
1868         if (policy != null) {
1869             sb.append(&quot;  Policy: &quot; + policy.toString() + &quot;\n&quot;);
1870         }
1871         if (pathToGeneralNames != null) {
1872             sb.append(&quot;  Path to names:\n&quot;);
1873             Iterator&lt;GeneralNameInterface&gt; i = pathToGeneralNames.iterator();
1874             while (i.hasNext()) {
1875                 sb.append(&quot;    &quot; + i.next() + &quot;\n&quot;);
1876             }
1877         }
1878         sb.append(&quot;]&quot;);
1879         return sb.toString();
1880     }
1881 
1882     // Copied from sun.security.x509.KeyUsageExtension
1883     // (without calling the superclass)
1884     /**
1885      * Returns a printable representation of the KeyUsage.
1886      */
1887     private static String keyUsageToString(boolean[] k) {
1888         String s = &quot;KeyUsage [\n&quot;;
1889         try {
1890             if (k[0]) {
1891                 s += &quot;  DigitalSignature\n&quot;;
1892             }
1893             if (k[1]) {
1894                 s += &quot;  Non_repudiation\n&quot;;
1895             }
1896             if (k[2]) {
1897                 s += &quot;  Key_Encipherment\n&quot;;
1898             }
1899             if (k[3]) {
1900                 s += &quot;  Data_Encipherment\n&quot;;
1901             }
1902             if (k[4]) {
1903                 s += &quot;  Key_Agreement\n&quot;;
1904             }
1905             if (k[5]) {
1906                 s += &quot;  Key_CertSign\n&quot;;
1907             }
1908             if (k[6]) {
1909                 s += &quot;  Crl_Sign\n&quot;;
1910             }
1911             if (k[7]) {
1912                 s += &quot;  Encipher_Only\n&quot;;
1913             }
1914             if (k[8]) {
1915                 s += &quot;  Decipher_Only\n&quot;;
1916             }
1917         } catch (ArrayIndexOutOfBoundsException ex) {}
1918 
1919         s += &quot;]\n&quot;;
1920 
1921         return (s);
1922     }
1923 
1924     /**
1925      * Returns an Extension object given any X509Certificate and extension oid.
1926      * Throw an {@code IOException} if the extension byte value is
1927      * malformed.
1928      *
1929      * @param cert a {@code X509Certificate}
1930      * @param extId an {@code integer} which specifies the extension index.
1931      * Currently, the supported extensions are as follows:
1932      * index 0 - PrivateKeyUsageExtension
1933      * index 1 - SubjectAlternativeNameExtension
1934      * index 2 - NameConstraintsExtension
1935      * index 3 - CertificatePoliciesExtension
1936      * index 4 - ExtendedKeyUsageExtension
1937      * @return an {@code Extension} object whose real type is as specified
1938      * by the extension oid.
1939      * @throws IOException if cannot construct the {@code Extension}
1940      * object with the extension encoding retrieved from the passed in
1941      * {@code X509Certificate}.
1942      */
<a name="2" id="anc2"></a><span class="line-modified">1943     private static Extension getExtensionObject(X509Certificate cert, int extId)</span>
1944             throws IOException {
1945         if (cert instanceof X509CertImpl) {
<a name="3" id="anc3"></a><span class="line-modified">1946             X509CertImpl impl = (X509CertImpl)cert;</span>
1947             switch (extId) {
<a name="4" id="anc4"></a><span class="line-modified">1948             case PRIVATE_KEY_USAGE_ID:</span>
<span class="line-modified">1949                 return impl.getPrivateKeyUsageExtension();</span>
<span class="line-modified">1950             case SUBJECT_ALT_NAME_ID:</span>
<span class="line-modified">1951                 return impl.getSubjectAlternativeNameExtension();</span>
<span class="line-modified">1952             case NAME_CONSTRAINTS_ID:</span>
<span class="line-modified">1953                 return impl.getNameConstraintsExtension();</span>
<span class="line-modified">1954             case CERT_POLICIES_ID:</span>
<span class="line-modified">1955                 return impl.getCertificatePoliciesExtension();</span>
<span class="line-modified">1956             case EXTENDED_KEY_USAGE_ID:</span>
<span class="line-modified">1957                 return impl.getExtendedKeyUsageExtension();</span>
<span class="line-modified">1958             default:</span>
<span class="line-modified">1959                 return null;</span>
1960             }
1961         }
<a name="5" id="anc5"></a><span class="line-modified">1962         byte[] rawExtVal = cert.getExtensionValue(EXTENSION_OIDS[extId]);</span>
1963         if (rawExtVal == null) {
1964             return null;
1965         }
1966         DerInputStream in = new DerInputStream(rawExtVal);
1967         byte[] encoded = in.getOctetString();
1968         switch (extId) {
<a name="6" id="anc6"></a><span class="line-modified">1969         case PRIVATE_KEY_USAGE_ID:</span>
<span class="line-modified">1970             try {</span>
<span class="line-modified">1971                 return new PrivateKeyUsageExtension(FALSE, encoded);</span>
<span class="line-modified">1972             } catch (CertificateException ex) {</span>
<span class="line-modified">1973                 throw new IOException(ex.getMessage());</span>
<span class="line-modified">1974             }</span>
<span class="line-modified">1975         case SUBJECT_ALT_NAME_ID:</span>
<span class="line-modified">1976             return new SubjectAlternativeNameExtension(FALSE, encoded);</span>
<span class="line-modified">1977         case NAME_CONSTRAINTS_ID:</span>
<span class="line-modified">1978             return new NameConstraintsExtension(FALSE, encoded);</span>
<span class="line-modified">1979         case CERT_POLICIES_ID:</span>
<span class="line-modified">1980             return new CertificatePoliciesExtension(FALSE, encoded);</span>
<span class="line-modified">1981         case EXTENDED_KEY_USAGE_ID:</span>
<span class="line-modified">1982             return new ExtendedKeyUsageExtension(FALSE, encoded);</span>
<span class="line-modified">1983         default:</span>
<span class="line-modified">1984             return null;</span>
1985         }
1986     }
1987 
1988     /**
1989      * Decides whether a {@code Certificate} should be selected.
1990      *
1991      * @param cert the {@code Certificate} to be checked
1992      * @return {@code true} if the {@code Certificate} should be
1993      *         selected, {@code false} otherwise
1994      */
1995     public boolean match(Certificate cert) {
1996         if (!(cert instanceof X509Certificate)) {
1997             return false;
1998         }
1999         X509Certificate xcert = (X509Certificate)cert;
2000 
2001         if (debug != null) {
2002             debug.println(&quot;X509CertSelector.match(SN: &quot;
2003                 + (xcert.getSerialNumber()).toString(16) + &quot;\n  Issuer: &quot;
2004                 + xcert.getIssuerDN() + &quot;\n  Subject: &quot; + xcert.getSubjectDN()
2005                 + &quot;)&quot;);
2006         }
2007 
2008         /* match on X509Certificate */
2009         if (x509Cert != null) {
2010             if (!x509Cert.equals(xcert)) {
2011                 if (debug != null) {
2012                     debug.println(&quot;X509CertSelector.match: &quot;
2013                         + &quot;certs don&#39;t match&quot;);
2014                 }
2015                 return false;
2016             }
2017         }
2018 
2019         /* match on serial number */
2020         if (serialNumber != null) {
2021             if (!serialNumber.equals(xcert.getSerialNumber())) {
2022                 if (debug != null) {
2023                     debug.println(&quot;X509CertSelector.match: &quot;
2024                         + &quot;serial numbers don&#39;t match&quot;);
2025                 }
2026                 return false;
2027             }
2028         }
2029 
2030         /* match on issuer name */
2031         if (issuer != null) {
2032             if (!issuer.equals(xcert.getIssuerX500Principal())) {
2033                 if (debug != null) {
2034                     debug.println(&quot;X509CertSelector.match: &quot;
2035                         + &quot;issuer DNs don&#39;t match&quot;);
2036                 }
2037                 return false;
2038             }
2039         }
2040 
2041         /* match on subject name */
2042         if (subject != null) {
2043             if (!subject.equals(xcert.getSubjectX500Principal())) {
2044                 if (debug != null) {
2045                     debug.println(&quot;X509CertSelector.match: &quot;
2046                         + &quot;subject DNs don&#39;t match&quot;);
2047                 }
2048                 return false;
2049             }
2050         }
2051 
2052         /* match on certificate validity range */
2053         if (certificateValid != null) {
2054             try {
2055                 xcert.checkValidity(certificateValid);
2056             } catch (CertificateException e) {
2057                 if (debug != null) {
2058                     debug.println(&quot;X509CertSelector.match: &quot;
2059                         + &quot;certificate not within validity period&quot;);
2060                 }
2061                 return false;
2062             }
2063         }
2064 
2065         /* match on subject public key */
2066         if (subjectPublicKeyBytes != null) {
2067             byte[] certKey = xcert.getPublicKey().getEncoded();
2068             if (!Arrays.equals(subjectPublicKeyBytes, certKey)) {
2069                 if (debug != null) {
2070                     debug.println(&quot;X509CertSelector.match: &quot;
2071                         + &quot;subject public keys don&#39;t match&quot;);
2072                 }
2073                 return false;
2074             }
2075         }
2076 
2077         boolean result = matchBasicConstraints(xcert)
2078                       &amp;&amp; matchKeyUsage(xcert)
2079                       &amp;&amp; matchExtendedKeyUsage(xcert)
2080                       &amp;&amp; matchSubjectKeyID(xcert)
2081                       &amp;&amp; matchAuthorityKeyID(xcert)
2082                       &amp;&amp; matchPrivateKeyValid(xcert)
2083                       &amp;&amp; matchSubjectPublicKeyAlgID(xcert)
2084                       &amp;&amp; matchPolicy(xcert)
2085                       &amp;&amp; matchSubjectAlternativeNames(xcert)
2086                       &amp;&amp; matchPathToNames(xcert)
2087                       &amp;&amp; matchNameConstraints(xcert);
2088 
2089         if (result &amp;&amp; (debug != null)) {
2090             debug.println(&quot;X509CertSelector.match returning: true&quot;);
2091         }
2092         return result;
2093     }
2094 
2095     /* match on subject key identifier extension value */
2096     private boolean matchSubjectKeyID(X509Certificate xcert) {
2097         if (subjectKeyID == null) {
2098             return true;
2099         }
2100         try {
2101             byte[] extVal = xcert.getExtensionValue(&quot;2.5.29.14&quot;);
2102             if (extVal == null) {
2103                 if (debug != null) {
2104                     debug.println(&quot;X509CertSelector.match: &quot;
2105                         + &quot;no subject key ID extension&quot;);
2106                 }
2107                 return false;
2108             }
2109             DerInputStream in = new DerInputStream(extVal);
2110             byte[] certSubjectKeyID = in.getOctetString();
2111             if (certSubjectKeyID == null ||
2112                     !Arrays.equals(subjectKeyID, certSubjectKeyID)) {
2113                 if (debug != null) {
2114                     debug.println(&quot;X509CertSelector.match: subject key IDs &quot; +
2115                         &quot;don&#39;t match\nX509CertSelector.match: subjectKeyID: &quot; +
2116                         Arrays.toString(subjectKeyID) +
2117                         &quot;\nX509CertSelector.match: certSubjectKeyID: &quot; +
2118                         Arrays.toString(certSubjectKeyID));
2119                 }
2120                 return false;
2121             }
2122         } catch (IOException ex) {
2123             if (debug != null) {
2124                 debug.println(&quot;X509CertSelector.match: &quot;
2125                     + &quot;exception in subject key ID check&quot;);
2126             }
2127             return false;
2128         }
2129         return true;
2130     }
2131 
2132     /* match on authority key identifier extension value */
2133     private boolean matchAuthorityKeyID(X509Certificate xcert) {
2134         if (authorityKeyID == null) {
2135             return true;
2136         }
2137         try {
2138             byte[] extVal = xcert.getExtensionValue(&quot;2.5.29.35&quot;);
2139             if (extVal == null) {
2140                 if (debug != null) {
2141                     debug.println(&quot;X509CertSelector.match: &quot;
2142                         + &quot;no authority key ID extension&quot;);
2143                 }
2144                 return false;
2145             }
2146             DerInputStream in = new DerInputStream(extVal);
2147             byte[] certAuthKeyID = in.getOctetString();
2148             if (certAuthKeyID == null ||
2149                     !Arrays.equals(authorityKeyID, certAuthKeyID)) {
2150                 if (debug != null) {
2151                     debug.println(&quot;X509CertSelector.match: &quot;
2152                         + &quot;authority key IDs don&#39;t match&quot;);
2153                 }
2154                 return false;
2155             }
2156         } catch (IOException ex) {
2157             if (debug != null) {
2158                 debug.println(&quot;X509CertSelector.match: &quot;
2159                     + &quot;exception in authority key ID check&quot;);
2160             }
2161             return false;
2162         }
2163         return true;
2164     }
2165 
2166     /* match on private key usage range */
2167     private boolean matchPrivateKeyValid(X509Certificate xcert) {
2168         if (privateKeyValid == null) {
2169             return true;
2170         }
2171         PrivateKeyUsageExtension ext = null;
2172         try {
2173             ext = (PrivateKeyUsageExtension)
<a name="7" id="anc7"></a><span class="line-modified">2174                 getExtensionObject(xcert, PRIVATE_KEY_USAGE_ID);</span>
2175             if (ext != null) {
2176                 ext.valid(privateKeyValid);
2177             }
2178         } catch (CertificateExpiredException e1) {
2179             if (debug != null) {
2180                 String time = &quot;n/a&quot;;
2181                 try {
2182                     Date notAfter = ext.get(PrivateKeyUsageExtension.NOT_AFTER);
2183                     time = notAfter.toString();
2184                 } catch (CertificateException ex) {
2185                     // not able to retrieve notAfter value
2186                 }
2187                 debug.println(&quot;X509CertSelector.match: private key usage not &quot;
2188                     + &quot;within validity date; ext.NOT_After: &quot;
2189                     + time + &quot;; X509CertSelector: &quot;
2190                     + this.toString());
2191                 e1.printStackTrace();
2192             }
2193             return false;
2194         } catch (CertificateNotYetValidException e2) {
2195             if (debug != null) {
2196                 String time = &quot;n/a&quot;;
2197                 try {
2198                     Date notBefore = ext.get(PrivateKeyUsageExtension.NOT_BEFORE);
2199                     time = notBefore.toString();
2200                 } catch (CertificateException ex) {
2201                     // not able to retrieve notBefore value
2202                 }
2203                 debug.println(&quot;X509CertSelector.match: private key usage not &quot;
2204                     + &quot;within validity date; ext.NOT_BEFORE: &quot;
2205                     + time + &quot;; X509CertSelector: &quot;
2206                     + this.toString());
2207                 e2.printStackTrace();
2208             }
2209             return false;
2210         } catch (IOException e4) {
2211             if (debug != null) {
2212                 debug.println(&quot;X509CertSelector.match: IOException in &quot;
2213                     + &quot;private key usage check; X509CertSelector: &quot;
2214                     + this.toString());
2215                 e4.printStackTrace();
2216             }
2217             return false;
2218         }
2219         return true;
2220     }
2221 
2222     /* match on subject public key algorithm OID */
2223     private boolean matchSubjectPublicKeyAlgID(X509Certificate xcert) {
2224         if (subjectPublicKeyAlgID == null) {
2225             return true;
2226         }
2227         try {
2228             byte[] encodedKey = xcert.getPublicKey().getEncoded();
2229             DerValue val = new DerValue(encodedKey);
2230             if (val.tag != DerValue.tag_Sequence) {
2231                 throw new IOException(&quot;invalid key format&quot;);
2232             }
2233 
2234             AlgorithmId algID = AlgorithmId.parse(val.data.getDerValue());
2235             if (debug != null) {
2236                 debug.println(&quot;X509CertSelector.match: subjectPublicKeyAlgID = &quot;
2237                     + subjectPublicKeyAlgID + &quot;, xcert subjectPublicKeyAlgID = &quot;
2238                     + algID.getOID());
2239             }
2240             if (!subjectPublicKeyAlgID.equals(algID.getOID())) {
2241                 if (debug != null) {
2242                     debug.println(&quot;X509CertSelector.match: &quot;
2243                         + &quot;subject public key alg IDs don&#39;t match&quot;);
2244                 }
2245                 return false;
2246             }
2247         } catch (IOException e5) {
2248             if (debug != null) {
2249                 debug.println(&quot;X509CertSelector.match: IOException in subject &quot;
2250                     + &quot;public key algorithm OID check&quot;);
2251             }
2252             return false;
2253         }
2254         return true;
2255     }
2256 
2257     /* match on key usage extension value */
2258     private boolean matchKeyUsage(X509Certificate xcert) {
2259         if (keyUsage == null) {
2260             return true;
2261         }
2262         boolean[] certKeyUsage = xcert.getKeyUsage();
2263         if (certKeyUsage != null) {
2264             for (int keyBit = 0; keyBit &lt; keyUsage.length; keyBit++) {
2265                 if (keyUsage[keyBit] &amp;&amp;
2266                     ((keyBit &gt;= certKeyUsage.length) || !certKeyUsage[keyBit])) {
2267                     if (debug != null) {
2268                         debug.println(&quot;X509CertSelector.match: &quot;
2269                             + &quot;key usage bits don&#39;t match&quot;);
2270                     }
2271                     return false;
2272                 }
2273             }
2274         }
2275         return true;
2276     }
2277 
2278     /* match on extended key usage purpose OIDs */
2279     private boolean matchExtendedKeyUsage(X509Certificate xcert) {
2280         if ((keyPurposeSet == null) || keyPurposeSet.isEmpty()) {
2281             return true;
2282         }
2283         try {
2284             ExtendedKeyUsageExtension ext =
2285                 (ExtendedKeyUsageExtension)getExtensionObject(xcert,
<a name="8" id="anc8"></a><span class="line-modified">2286                                                 EXTENDED_KEY_USAGE_ID);</span>
2287             if (ext != null) {
2288                 Vector&lt;ObjectIdentifier&gt; certKeyPurposeVector =
2289                     ext.get(ExtendedKeyUsageExtension.USAGES);
2290                 if (!certKeyPurposeVector.contains(ANY_EXTENDED_KEY_USAGE)
2291                         &amp;&amp; !certKeyPurposeVector.containsAll(keyPurposeOIDSet)) {
2292                     if (debug != null) {
2293                         debug.println(&quot;X509CertSelector.match: cert failed &quot;
2294                             + &quot;extendedKeyUsage criterion&quot;);
2295                     }
2296                     return false;
2297                 }
2298             }
2299         } catch (IOException ex) {
2300             if (debug != null) {
2301                 debug.println(&quot;X509CertSelector.match: &quot;
2302                     + &quot;IOException in extended key usage check&quot;);
2303             }
2304             return false;
2305         }
2306         return true;
2307     }
2308 
2309     /* match on subject alternative name extension names */
2310     private boolean matchSubjectAlternativeNames(X509Certificate xcert) {
2311         if ((subjectAlternativeNames == null) || subjectAlternativeNames.isEmpty()) {
2312             return true;
2313         }
2314         try {
2315             SubjectAlternativeNameExtension sanExt =
<a name="9" id="anc9"></a><span class="line-modified">2316                 (SubjectAlternativeNameExtension) getExtensionObject(xcert,</span>
<span class="line-modified">2317                                                       SUBJECT_ALT_NAME_ID);</span>
2318             if (sanExt == null) {
2319                 if (debug != null) {
2320                   debug.println(&quot;X509CertSelector.match: &quot;
2321                       + &quot;no subject alternative name extension&quot;);
2322                 }
2323                 return false;
2324             }
2325             GeneralNames certNames =
2326                     sanExt.get(SubjectAlternativeNameExtension.SUBJECT_NAME);
2327             Iterator&lt;GeneralNameInterface&gt; i =
2328                                 subjectAlternativeGeneralNames.iterator();
2329             while (i.hasNext()) {
2330                 GeneralNameInterface matchName = i.next();
2331                 boolean found = false;
2332                 for (Iterator&lt;GeneralName&gt; t = certNames.iterator();
2333                                                 t.hasNext() &amp;&amp; !found; ) {
2334                     GeneralNameInterface certName = (t.next()).getName();
2335                     found = certName.equals(matchName);
2336                 }
2337                 if (!found &amp;&amp; (matchAllSubjectAltNames || !i.hasNext())) {
2338                     if (debug != null) {
2339                       debug.println(&quot;X509CertSelector.match: subject alternative &quot;
2340                           + &quot;name &quot; + matchName + &quot; not found&quot;);
2341                     }
2342                     return false;
2343                 } else if (found &amp;&amp; !matchAllSubjectAltNames) {
2344                     break;
2345                 }
2346             }
2347         } catch (IOException ex) {
2348             if (debug != null)
2349                 debug.println(&quot;X509CertSelector.match: IOException in subject &quot;
2350                     + &quot;alternative name check&quot;);
2351             return false;
2352         }
2353         return true;
2354     }
2355 
2356     /* match on name constraints */
2357     private boolean matchNameConstraints(X509Certificate xcert) {
2358         if (nc == null) {
2359             return true;
2360         }
2361         try {
2362             if (!nc.verify(xcert)) {
2363                 if (debug != null) {
2364                     debug.println(&quot;X509CertSelector.match: &quot;
2365                         + &quot;name constraints not satisfied&quot;);
2366                 }
2367                 return false;
2368             }
2369         } catch (IOException e) {
2370             if (debug != null) {
2371                 debug.println(&quot;X509CertSelector.match: &quot;
2372                     + &quot;IOException in name constraints check&quot;);
2373             }
2374             return false;
2375         }
2376         return true;
2377     }
2378 
2379     /* match on policy OIDs */
2380     private boolean matchPolicy(X509Certificate xcert) {
2381         if (policy == null) {
2382             return true;
2383         }
2384         try {
2385             CertificatePoliciesExtension ext = (CertificatePoliciesExtension)
<a name="10" id="anc10"></a><span class="line-modified">2386                 getExtensionObject(xcert, CERT_POLICIES_ID);</span>
2387             if (ext == null) {
2388                 if (debug != null) {
2389                   debug.println(&quot;X509CertSelector.match: &quot;
2390                       + &quot;no certificate policy extension&quot;);
2391                 }
2392                 return false;
2393             }
2394             List&lt;PolicyInformation&gt; policies = ext.get(CertificatePoliciesExtension.POLICIES);
2395             /*
2396              * Convert the Vector of PolicyInformation to a Vector
2397              * of CertificatePolicyIds for easier comparison.
2398              */
2399             List&lt;CertificatePolicyId&gt; policyIDs = new ArrayList&lt;&gt;(policies.size());
2400             for (PolicyInformation info : policies) {
2401                 policyIDs.add(info.getPolicyIdentifier());
2402             }
2403             if (policy != null) {
2404                 boolean foundOne = false;
2405                 /*
2406                  * if the user passes in an empty policy Set, then
2407                  * we just want to make sure that the candidate certificate
2408                  * has some policy OID in its CertPoliciesExtension
2409                  */
2410                 if (policy.getCertPolicyIds().isEmpty()) {
2411                     if (policyIDs.isEmpty()) {
2412                         if (debug != null) {
2413                             debug.println(&quot;X509CertSelector.match: &quot;
2414                                 + &quot;cert failed policyAny criterion&quot;);
2415                         }
2416                         return false;
2417                     }
2418                 } else {
2419                     for (CertificatePolicyId id : policy.getCertPolicyIds()) {
2420                         if (policyIDs.contains(id)) {
2421                             foundOne = true;
2422                             break;
2423                         }
2424                     }
2425                     if (!foundOne) {
2426                         if (debug != null) {
2427                             debug.println(&quot;X509CertSelector.match: &quot;
2428                                 + &quot;cert failed policyAny criterion&quot;);
2429                         }
2430                         return false;
2431                     }
2432                 }
2433             }
2434         } catch (IOException ex) {
2435             if (debug != null) {
2436                 debug.println(&quot;X509CertSelector.match: &quot;
2437                     + &quot;IOException in certificate policy ID check&quot;);
2438             }
2439             return false;
2440         }
2441         return true;
2442     }
2443 
2444     /* match on pathToNames */
2445     private boolean matchPathToNames(X509Certificate xcert) {
2446         if (pathToGeneralNames == null) {
2447             return true;
2448         }
2449         try {
2450             NameConstraintsExtension ext = (NameConstraintsExtension)
<a name="11" id="anc11"></a><span class="line-modified">2451                 getExtensionObject(xcert, NAME_CONSTRAINTS_ID);</span>
2452             if (ext == null) {
2453                 return true;
2454             }
2455             if ((debug != null) &amp;&amp; Debug.isOn(&quot;certpath&quot;)) {
2456                 debug.println(&quot;X509CertSelector.match pathToNames:\n&quot;);
2457                 Iterator&lt;GeneralNameInterface&gt; i =
2458                                         pathToGeneralNames.iterator();
2459                 while (i.hasNext()) {
2460                     debug.println(&quot;    &quot; + i.next() + &quot;\n&quot;);
2461                 }
2462             }
2463 
2464             GeneralSubtrees permitted =
2465                     ext.get(NameConstraintsExtension.PERMITTED_SUBTREES);
2466             GeneralSubtrees excluded =
2467                     ext.get(NameConstraintsExtension.EXCLUDED_SUBTREES);
2468             if (excluded != null) {
2469                 if (matchExcluded(excluded) == false) {
2470                     return false;
2471                 }
2472             }
2473             if (permitted != null) {
2474                 if (matchPermitted(permitted) == false) {
2475                     return false;
2476                 }
2477             }
2478         } catch (IOException ex) {
2479             if (debug != null) {
2480                 debug.println(&quot;X509CertSelector.match: &quot;
2481                     + &quot;IOException in name constraints check&quot;);
2482             }
2483             return false;
2484         }
2485         return true;
2486     }
2487 
2488     private boolean matchExcluded(GeneralSubtrees excluded) {
2489         /*
2490          * Enumerate through excluded and compare each entry
2491          * to all pathToNames. If any pathToName is within any of the
2492          * subtrees listed in excluded, return false.
2493          */
2494         for (Iterator&lt;GeneralSubtree&gt; t = excluded.iterator(); t.hasNext(); ) {
2495             GeneralSubtree tree = t.next();
2496             GeneralNameInterface excludedName = tree.getName().getName();
2497             Iterator&lt;GeneralNameInterface&gt; i = pathToGeneralNames.iterator();
2498             while (i.hasNext()) {
2499                 GeneralNameInterface pathToName = i.next();
2500                 if (excludedName.getType() == pathToName.getType()) {
2501                     switch (pathToName.constrains(excludedName)) {
2502                     case GeneralNameInterface.NAME_WIDENS:
2503                     case GeneralNameInterface.NAME_MATCH:
2504                         if (debug != null) {
2505                             debug.println(&quot;X509CertSelector.match: name constraints &quot;
2506                                 + &quot;inhibit path to specified name&quot;);
2507                             debug.println(&quot;X509CertSelector.match: excluded name: &quot; +
2508                                 pathToName);
2509                         }
2510                         return false;
2511                     default:
2512                     }
2513                 }
2514             }
2515         }
2516         return true;
2517     }
2518 
2519     private boolean matchPermitted(GeneralSubtrees permitted) {
2520         /*
2521          * Enumerate through pathToNames, checking that each pathToName
2522          * is in at least one of the subtrees listed in permitted.
2523          * If not, return false. However, if no subtrees of a given type
2524          * are listed, all names of that type are permitted.
2525          */
2526         Iterator&lt;GeneralNameInterface&gt; i = pathToGeneralNames.iterator();
2527         while (i.hasNext()) {
2528             GeneralNameInterface pathToName = i.next();
2529             Iterator&lt;GeneralSubtree&gt; t = permitted.iterator();
2530             boolean permittedNameFound = false;
2531             boolean nameTypeFound = false;
2532             String names = &quot;&quot;;
2533             while (t.hasNext() &amp;&amp; !permittedNameFound) {
2534                 GeneralSubtree tree = t.next();
2535                 GeneralNameInterface permittedName = tree.getName().getName();
2536                 if (permittedName.getType() == pathToName.getType()) {
2537                     nameTypeFound = true;
2538                     names = names + &quot;  &quot; + permittedName;
2539                     switch (pathToName.constrains(permittedName)) {
2540                     case GeneralNameInterface.NAME_WIDENS:
2541                     case GeneralNameInterface.NAME_MATCH:
2542                         permittedNameFound = true;
2543                         break;
2544                     default:
2545                     }
2546                 }
2547             }
2548             if (!permittedNameFound &amp;&amp; nameTypeFound) {
2549                 if (debug != null)
2550                   debug.println(&quot;X509CertSelector.match: &quot; +
2551                             &quot;name constraints inhibit path to specified name; &quot; +
2552                             &quot;permitted names of type &quot; + pathToName.getType() +
2553                             &quot;: &quot; + names);
2554                 return false;
2555             }
2556         }
2557         return true;
2558     }
2559 
2560     /* match on basic constraints */
2561     private boolean matchBasicConstraints(X509Certificate xcert) {
2562         if (basicConstraints == -1) {
2563             return true;
2564         }
2565         int maxPathLen = xcert.getBasicConstraints();
2566         if (basicConstraints == -2) {
2567             if (maxPathLen != -1) {
2568                 if (debug != null) {
2569                     debug.println(&quot;X509CertSelector.match: not an EE cert&quot;);
2570                 }
2571                 return false;
2572             }
2573         } else {
2574             if (maxPathLen &lt; basicConstraints) {
2575                 if (debug != null) {
2576                     debug.println(&quot;X509CertSelector.match: cert&#39;s maxPathLen &quot; +
2577                             &quot;is less than the min maxPathLen set by &quot; +
2578                             &quot;basicConstraints. &quot; +
2579                             &quot;(&quot; + maxPathLen + &quot; &lt; &quot; + basicConstraints + &quot;)&quot;);
2580                 }
2581                 return false;
2582             }
2583         }
2584         return true;
2585     }
2586 
2587     @SuppressWarnings(&quot;unchecked&quot;) // Safe casts assuming clone() works correctly
2588     private static &lt;T&gt; Set&lt;T&gt; cloneSet(Set&lt;T&gt; set) {
2589         if (set instanceof HashSet) {
2590             Object clone = ((HashSet&lt;T&gt;)set).clone();
2591             return (Set&lt;T&gt;)clone;
2592         } else {
2593             return new HashSet&lt;T&gt;(set);
2594         }
2595     }
2596 
2597     /**
2598      * Returns a copy of this object.
2599      *
2600      * @return the copy
2601      */
2602     public Object clone() {
2603         try {
2604             X509CertSelector copy = (X509CertSelector)super.clone();
2605             // Must clone these because addPathToName et al. modify them
2606             if (subjectAlternativeNames != null) {
2607                 copy.subjectAlternativeNames =
2608                         cloneSet(subjectAlternativeNames);
2609                 copy.subjectAlternativeGeneralNames =
2610                         cloneSet(subjectAlternativeGeneralNames);
2611             }
2612             if (pathToGeneralNames != null) {
2613                 copy.pathToNames = cloneSet(pathToNames);
2614                 copy.pathToGeneralNames = cloneSet(pathToGeneralNames);
2615             }
2616             return copy;
2617         } catch (CloneNotSupportedException e) {
2618             /* Cannot happen */
2619             throw new InternalError(e.toString(), e);
2620         }
2621     }
2622 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
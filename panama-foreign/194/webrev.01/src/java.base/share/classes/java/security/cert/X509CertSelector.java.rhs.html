<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/security/cert/X509CertSelector.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.security.cert;
  27 
  28 import java.io.IOException;
  29 import java.math.BigInteger;
  30 import java.security.PublicKey;
  31 import java.util.*;
  32 import javax.security.auth.x500.X500Principal;
  33 
  34 import sun.security.util.*;
  35 import sun.security.x509.*;
  36 
  37 /**
  38  * A {@code CertSelector} that selects {@code X509Certificates} that
  39  * match all specified criteria. This class is particularly useful when
  40  * selecting certificates from a {@code CertStore} to build a
  41  * PKIX-compliant certification path.
  42  * &lt;p&gt;
  43  * When first constructed, an {@code X509CertSelector} has no criteria
  44  * enabled and each of the {@code get} methods return a default value
  45  * ({@code null}, or {@code -1} for the {@link #getBasicConstraints
  46  * getBasicConstraints} method). Therefore, the {@link #match match}
  47  * method would return {@code true} for any {@code X509Certificate}.
  48  * Typically, several criteria are enabled (by calling
  49  * {@link #setIssuer setIssuer} or
  50  * {@link #setKeyUsage setKeyUsage}, for instance) and then the
  51  * {@code X509CertSelector} is passed to
  52  * {@link CertStore#getCertificates CertStore.getCertificates} or some similar
  53  * method.
  54  * &lt;p&gt;
  55  * Several criteria can be enabled (by calling {@link #setIssuer setIssuer}
  56  * and {@link #setSerialNumber setSerialNumber},
  57  * for example) such that the {@code match} method
  58  * usually uniquely matches a single {@code X509Certificate}. We say
  59  * usually, since it is possible for two issuing CAs to have the same
  60  * distinguished name and each issue a certificate with the same serial
  61  * number. Other unique combinations include the issuer, subject,
  62  * subjectKeyIdentifier and/or the subjectPublicKey criteria.
  63  * &lt;p&gt;
  64  * Please refer to &lt;a href=&quot;http://tools.ietf.org/html/rfc5280&quot;&gt;RFC 5280:
  65  * Internet X.509 Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt; for
  66  * definitions of the X.509 certificate extensions mentioned below.
  67  * &lt;p&gt;
  68  * &lt;b&gt;Concurrent Access&lt;/b&gt;
  69  * &lt;p&gt;
  70  * Unless otherwise specified, the methods defined in this class are not
  71  * thread-safe. Multiple threads that need to access a single
  72  * object concurrently should synchronize amongst themselves and
  73  * provide the necessary locking. Multiple threads each manipulating
  74  * separate objects need not synchronize.
  75  *
  76  * @see CertSelector
  77  * @see X509Certificate
  78  *
  79  * @since       1.4
  80  * @author      Steve Hanna
  81  */
  82 public class X509CertSelector implements CertSelector {
  83 
  84     private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);
  85 
  86     private static final ObjectIdentifier ANY_EXTENDED_KEY_USAGE =
  87         ObjectIdentifier.of(KnownOIDs.anyExtendedKeyUsage);
  88 
  89     static {
  90         CertPathHelperImpl.initialize();
  91     }
  92 
  93     private BigInteger serialNumber;
  94     private X500Principal issuer;
  95     private X500Principal subject;
  96     private byte[] subjectKeyID;
  97     private byte[] authorityKeyID;
  98     private Date certificateValid;
  99     private Date privateKeyValid;
 100     private ObjectIdentifier subjectPublicKeyAlgID;
 101     private PublicKey subjectPublicKey;
 102     private byte[] subjectPublicKeyBytes;
 103     private boolean[] keyUsage;
 104     private Set&lt;String&gt; keyPurposeSet;
 105     private Set&lt;ObjectIdentifier&gt; keyPurposeOIDSet;
 106     private Set&lt;List&lt;?&gt;&gt; subjectAlternativeNames;
 107     private Set&lt;GeneralNameInterface&gt; subjectAlternativeGeneralNames;
 108     private CertificatePolicySet policy;
 109     private Set&lt;String&gt; policySet;
 110     private Set&lt;List&lt;?&gt;&gt; pathToNames;
 111     private Set&lt;GeneralNameInterface&gt; pathToGeneralNames;
 112     private NameConstraintsExtension nc;
 113     private byte[] ncBytes;
 114     private int basicConstraints = -1;
 115     private X509Certificate x509Cert;
 116     private boolean matchAllSubjectAltNames = true;
 117 
 118     private static final Boolean FALSE = Boolean.FALSE;
 119 
<a name="1" id="anc1"></a>















 120     /* Constants representing the GeneralName types */
 121     static final int NAME_ANY = 0;
 122     static final int NAME_RFC822 = 1;
 123     static final int NAME_DNS = 2;
 124     static final int NAME_X400 = 3;
 125     static final int NAME_DIRECTORY = 4;
 126     static final int NAME_EDI = 5;
 127     static final int NAME_URI = 6;
 128     static final int NAME_IP = 7;
 129     static final int NAME_OID = 8;
 130 
 131     /**
 132      * Creates an {@code X509CertSelector}. Initially, no criteria are set
 133      * so any {@code X509Certificate} will match.
 134      */
 135     public X509CertSelector() {
 136         // empty
 137     }
 138 
 139     /**
 140      * Sets the certificateEquals criterion. The specified
 141      * {@code X509Certificate} must be equal to the
 142      * {@code X509Certificate} passed to the {@code match} method.
 143      * If {@code null}, then this check is not applied.
 144      *
 145      * &lt;p&gt;This method is particularly useful when it is necessary to
 146      * match a single certificate. Although other criteria can be specified
 147      * in conjunction with the certificateEquals criterion, it is usually not
 148      * practical or necessary.
 149      *
 150      * @param cert the {@code X509Certificate} to match (or
 151      * {@code null})
 152      * @see #getCertificate
 153      */
 154     public void setCertificate(X509Certificate cert) {
 155         x509Cert = cert;
 156     }
 157 
 158     /**
 159      * Sets the serialNumber criterion. The specified serial number
 160      * must match the certificate serial number in the
 161      * {@code X509Certificate}. If {@code null}, any certificate
 162      * serial number will do.
 163      *
 164      * @param serial the certificate serial number to match
 165      *        (or {@code null})
 166      * @see #getSerialNumber
 167      */
 168     public void setSerialNumber(BigInteger serial) {
 169         serialNumber = serial;
 170     }
 171 
 172     /**
 173      * Sets the issuer criterion. The specified distinguished name
 174      * must match the issuer distinguished name in the
 175      * {@code X509Certificate}. If {@code null}, any issuer
 176      * distinguished name will do.
 177      *
 178      * @param issuer a distinguished name as X500Principal
 179      *                 (or {@code null})
 180      * @since 1.5
 181      */
 182     public void setIssuer(X500Principal issuer) {
 183         this.issuer = issuer;
 184     }
 185 
 186     /**
 187      * &lt;strong&gt;Denigrated&lt;/strong&gt;, use {@linkplain #setIssuer(X500Principal)}
 188      * or {@linkplain #setIssuer(byte[])} instead. This method should not be
 189      * relied on as it can fail to match some certificates because of a loss of
 190      * encoding information in the
 191      * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; String form
 192      * of some distinguished names.
 193      * &lt;p&gt;
 194      * Sets the issuer criterion. The specified distinguished name
 195      * must match the issuer distinguished name in the
 196      * {@code X509Certificate}. If {@code null}, any issuer
 197      * distinguished name will do.
 198      * &lt;p&gt;
 199      * If {@code issuerDN} is not {@code null}, it should contain a
 200      * distinguished name, in RFC 2253 format.
 201      *
 202      * @param issuerDN a distinguished name in RFC 2253 format
 203      *                 (or {@code null})
 204      * @throws IOException if a parsing error occurs (incorrect form for DN)
 205      */
 206     public void setIssuer(String issuerDN) throws IOException {
 207         if (issuerDN == null) {
 208             issuer = null;
 209         } else {
 210             issuer = new X500Name(issuerDN).asX500Principal();
 211         }
 212     }
 213 
 214     /**
 215      * Sets the issuer criterion. The specified distinguished name
 216      * must match the issuer distinguished name in the
 217      * {@code X509Certificate}. If {@code null} is specified,
 218      * the issuer criterion is disabled and any issuer distinguished name will
 219      * do.
 220      * &lt;p&gt;
 221      * If {@code issuerDN} is not {@code null}, it should contain a
 222      * single DER encoded distinguished name, as defined in X.501. The ASN.1
 223      * notation for this structure is as follows.
 224      * &lt;pre&gt;{@code
 225      * Name ::= CHOICE {
 226      *   RDNSequence }
 227      *
 228      * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
 229      *
 230      * RelativeDistinguishedName ::=
 231      *   SET SIZE (1 .. MAX) OF AttributeTypeAndValue
 232      *
 233      * AttributeTypeAndValue ::= SEQUENCE {
 234      *   type     AttributeType,
 235      *   value    AttributeValue }
 236      *
 237      * AttributeType ::= OBJECT IDENTIFIER
 238      *
 239      * AttributeValue ::= ANY DEFINED BY AttributeType
 240      * ....
 241      * DirectoryString ::= CHOICE {
 242      *       teletexString           TeletexString (SIZE (1..MAX)),
 243      *       printableString         PrintableString (SIZE (1..MAX)),
 244      *       universalString         UniversalString (SIZE (1..MAX)),
 245      *       utf8String              UTF8String (SIZE (1.. MAX)),
 246      *       bmpString               BMPString (SIZE (1..MAX)) }
 247      * }&lt;/pre&gt;
 248      * &lt;p&gt;
 249      * Note that the byte array specified here is cloned to protect against
 250      * subsequent modifications.
 251      *
 252      * @param issuerDN a byte array containing the distinguished name
 253      *                 in ASN.1 DER encoded form (or {@code null})
 254      * @throws IOException if an encoding error occurs (incorrect form for DN)
 255      */
 256     public void setIssuer(byte[] issuerDN) throws IOException {
 257         try {
 258             issuer = (issuerDN == null ? null : new X500Principal(issuerDN));
 259         } catch (IllegalArgumentException e) {
 260             throw new IOException(&quot;Invalid name&quot;, e);
 261         }
 262     }
 263 
 264     /**
 265      * Sets the subject criterion. The specified distinguished name
 266      * must match the subject distinguished name in the
 267      * {@code X509Certificate}. If {@code null}, any subject
 268      * distinguished name will do.
 269      *
 270      * @param subject a distinguished name as X500Principal
 271      *                  (or {@code null})
 272      * @since 1.5
 273      */
 274     public void setSubject(X500Principal subject) {
 275         this.subject = subject;
 276     }
 277 
 278     /**
 279      * &lt;strong&gt;Denigrated&lt;/strong&gt;, use {@linkplain #setSubject(X500Principal)}
 280      * or {@linkplain #setSubject(byte[])} instead. This method should not be
 281      * relied on as it can fail to match some certificates because of a loss of
 282      * encoding information in the RFC 2253 String form of some distinguished
 283      * names.
 284      * &lt;p&gt;
 285      * Sets the subject criterion. The specified distinguished name
 286      * must match the subject distinguished name in the
 287      * {@code X509Certificate}. If {@code null}, any subject
 288      * distinguished name will do.
 289      * &lt;p&gt;
 290      * If {@code subjectDN} is not {@code null}, it should contain a
 291      * distinguished name, in RFC 2253 format.
 292      *
 293      * @param subjectDN a distinguished name in RFC 2253 format
 294      *                  (or {@code null})
 295      * @throws IOException if a parsing error occurs (incorrect form for DN)
 296      */
 297     public void setSubject(String subjectDN) throws IOException {
 298         if (subjectDN == null) {
 299             subject = null;
 300         } else {
 301             subject = new X500Name(subjectDN).asX500Principal();
 302         }
 303     }
 304 
 305     /**
 306      * Sets the subject criterion. The specified distinguished name
 307      * must match the subject distinguished name in the
 308      * {@code X509Certificate}. If {@code null}, any subject
 309      * distinguished name will do.
 310      * &lt;p&gt;
 311      * If {@code subjectDN} is not {@code null}, it should contain a
 312      * single DER encoded distinguished name, as defined in X.501. For the ASN.1
 313      * notation for this structure, see
 314      * {@link #setIssuer(byte [] issuerDN) setIssuer(byte [] issuerDN)}.
 315      *
 316      * @param subjectDN a byte array containing the distinguished name in
 317      *                  ASN.1 DER format (or {@code null})
 318      * @throws IOException if an encoding error occurs (incorrect form for DN)
 319      */
 320     public void setSubject(byte[] subjectDN) throws IOException {
 321         try {
 322             subject = (subjectDN == null ? null : new X500Principal(subjectDN));
 323         } catch (IllegalArgumentException e) {
 324             throw new IOException(&quot;Invalid name&quot;, e);
 325         }
 326     }
 327 
 328     /**
 329      * Sets the subjectKeyIdentifier criterion. The
 330      * {@code X509Certificate} must contain a SubjectKeyIdentifier
 331      * extension for which the contents of the extension
 332      * matches the specified criterion value.
 333      * If the criterion value is {@code null}, no
 334      * subjectKeyIdentifier check will be done.
 335      * &lt;p&gt;
 336      * If {@code subjectKeyID} is not {@code null}, it
 337      * should contain a single DER encoded value corresponding to the contents
 338      * of the extension value (not including the object identifier,
 339      * criticality setting, and encapsulating OCTET STRING)
 340      * for a SubjectKeyIdentifier extension.
 341      * The ASN.1 notation for this structure follows.
 342      *
 343      * &lt;pre&gt;{@code
 344      * SubjectKeyIdentifier ::= KeyIdentifier
 345      *
 346      * KeyIdentifier ::= OCTET STRING
 347      * }&lt;/pre&gt;
 348      * &lt;p&gt;
 349      * Since the format of subject key identifiers is not mandated by
 350      * any standard, subject key identifiers are not parsed by the
 351      * {@code X509CertSelector}. Instead, the values are compared using
 352      * a byte-by-byte comparison.
 353      * &lt;p&gt;
 354      * Note that the byte array supplied here is cloned to protect against
 355      * subsequent modifications.
 356      *
 357      * @param subjectKeyID the subject key identifier (or {@code null})
 358      * @see #getSubjectKeyIdentifier
 359      */
 360     public void setSubjectKeyIdentifier(byte[] subjectKeyID) {
 361         if (subjectKeyID == null) {
 362             this.subjectKeyID = null;
 363         } else {
 364             this.subjectKeyID = subjectKeyID.clone();
 365         }
 366     }
 367 
 368     /**
 369      * Sets the authorityKeyIdentifier criterion. The
 370      * {@code X509Certificate} must contain an
 371      * AuthorityKeyIdentifier extension for which the contents of the
 372      * extension value matches the specified criterion value.
 373      * If the criterion value is {@code null}, no
 374      * authorityKeyIdentifier check will be done.
 375      * &lt;p&gt;
 376      * If {@code authorityKeyID} is not {@code null}, it
 377      * should contain a single DER encoded value corresponding to the contents
 378      * of the extension value (not including the object identifier,
 379      * criticality setting, and encapsulating OCTET STRING)
 380      * for an AuthorityKeyIdentifier extension.
 381      * The ASN.1 notation for this structure follows.
 382      *
 383      * &lt;pre&gt;{@code
 384      * AuthorityKeyIdentifier ::= SEQUENCE {
 385      *    keyIdentifier             [0] KeyIdentifier           OPTIONAL,
 386      *    authorityCertIssuer       [1] GeneralNames            OPTIONAL,
 387      *    authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }
 388      *
 389      * KeyIdentifier ::= OCTET STRING
 390      * }&lt;/pre&gt;
 391      * &lt;p&gt;
 392      * Authority key identifiers are not parsed by the
 393      * {@code X509CertSelector}.  Instead, the values are
 394      * compared using a byte-by-byte comparison.
 395      * &lt;p&gt;
 396      * When the {@code keyIdentifier} field of
 397      * {@code AuthorityKeyIdentifier} is populated, the value is
 398      * usually taken from the {@code SubjectKeyIdentifier} extension
 399      * in the issuer&#39;s certificate.  Note, however, that the result of
 400      * {@code X509Certificate.getExtensionValue(&lt;SubjectKeyIdentifier Object
 401      * Identifier&gt;)} on the issuer&#39;s certificate may NOT be used
 402      * directly as the input to {@code setAuthorityKeyIdentifier}.
 403      * This is because the SubjectKeyIdentifier contains
 404      * only a KeyIdentifier OCTET STRING, and not a SEQUENCE of
 405      * KeyIdentifier, GeneralNames, and CertificateSerialNumber.
 406      * In order to use the extension value of the issuer certificate&#39;s
 407      * {@code SubjectKeyIdentifier}
 408      * extension, it will be necessary to extract the value of the embedded
 409      * {@code KeyIdentifier} OCTET STRING, then DER encode this OCTET
 410      * STRING inside a SEQUENCE.
 411      * For more details on SubjectKeyIdentifier, see
 412      * {@link #setSubjectKeyIdentifier(byte[] subjectKeyID)}.
 413      * &lt;p&gt;
 414      * Note also that the byte array supplied here is cloned to protect against
 415      * subsequent modifications.
 416      *
 417      * @param authorityKeyID the authority key identifier
 418      *        (or {@code null})
 419      * @see #getAuthorityKeyIdentifier
 420      */
 421     public void setAuthorityKeyIdentifier(byte[] authorityKeyID) {
 422         if (authorityKeyID == null) {
 423             this.authorityKeyID = null;
 424         } else {
 425             this.authorityKeyID = authorityKeyID.clone();
 426         }
 427     }
 428 
 429     /**
 430      * Sets the certificateValid criterion. The specified date must fall
 431      * within the certificate validity period for the
 432      * {@code X509Certificate}. If {@code null}, no certificateValid
 433      * check will be done.
 434      * &lt;p&gt;
 435      * Note that the {@code Date} supplied here is cloned to protect
 436      * against subsequent modifications.
 437      *
 438      * @param certValid the {@code Date} to check (or {@code null})
 439      * @see #getCertificateValid
 440      */
 441     public void setCertificateValid(Date certValid) {
 442         if (certValid == null) {
 443             certificateValid = null;
 444         } else {
 445             certificateValid = (Date)certValid.clone();
 446         }
 447     }
 448 
 449     /**
 450      * Sets the privateKeyValid criterion. The specified date must fall
 451      * within the private key validity period for the
 452      * {@code X509Certificate}. If {@code null}, no privateKeyValid
 453      * check will be done.
 454      * &lt;p&gt;
 455      * Note that the {@code Date} supplied here is cloned to protect
 456      * against subsequent modifications.
 457      *
 458      * @param privateKeyValid the {@code Date} to check (or
 459      *                        {@code null})
 460      * @see #getPrivateKeyValid
 461      */
 462     public void setPrivateKeyValid(Date privateKeyValid) {
 463         if (privateKeyValid == null) {
 464             this.privateKeyValid = null;
 465         } else {
 466             this.privateKeyValid = (Date)privateKeyValid.clone();
 467         }
 468     }
 469 
 470     /**
 471      * Sets the subjectPublicKeyAlgID criterion. The
 472      * {@code X509Certificate} must contain a subject public key
 473      * with the specified algorithm. If {@code null}, no
 474      * subjectPublicKeyAlgID check will be done.
 475      *
 476      * @param oid The object identifier (OID) of the algorithm to check
 477      *            for (or {@code null}). An OID is represented by a
 478      *            set of nonnegative integers separated by periods.
 479      * @throws IOException if the OID is invalid, such as
 480      * the first component being not 0, 1 or 2 or the second component
 481      * being greater than 39.
 482      *
 483      * @see #getSubjectPublicKeyAlgID
 484      */
 485     public void setSubjectPublicKeyAlgID(String oid) throws IOException {
 486         if (oid == null) {
 487             subjectPublicKeyAlgID = null;
 488         } else {
 489             subjectPublicKeyAlgID = ObjectIdentifier.of(oid);
 490         }
 491     }
 492 
 493     /**
 494      * Sets the subjectPublicKey criterion. The
 495      * {@code X509Certificate} must contain the specified subject public
 496      * key. If {@code null}, no subjectPublicKey check will be done.
 497      *
 498      * @param key the subject public key to check for (or {@code null})
 499      * @see #getSubjectPublicKey
 500      */
 501     public void setSubjectPublicKey(PublicKey key) {
 502         if (key == null) {
 503             subjectPublicKey = null;
 504             subjectPublicKeyBytes = null;
 505         } else {
 506             subjectPublicKey = key;
 507             subjectPublicKeyBytes = key.getEncoded();
 508         }
 509     }
 510 
 511     /**
 512      * Sets the subjectPublicKey criterion. The {@code X509Certificate}
 513      * must contain the specified subject public key. If {@code null},
 514      * no subjectPublicKey check will be done.
 515      * &lt;p&gt;
 516      * Because this method allows the public key to be specified as a byte
 517      * array, it may be used for unknown key types.
 518      * &lt;p&gt;
 519      * If {@code key} is not {@code null}, it should contain a
 520      * single DER encoded SubjectPublicKeyInfo structure, as defined in X.509.
 521      * The ASN.1 notation for this structure is as follows.
 522      * &lt;pre&gt;{@code
 523      * SubjectPublicKeyInfo  ::=  SEQUENCE  {
 524      *   algorithm            AlgorithmIdentifier,
 525      *   subjectPublicKey     BIT STRING  }
 526      *
 527      * AlgorithmIdentifier  ::=  SEQUENCE  {
 528      *   algorithm               OBJECT IDENTIFIER,
 529      *   parameters              ANY DEFINED BY algorithm OPTIONAL  }
 530      *                              -- contains a value of the type
 531      *                              -- registered for use with the
 532      *                              -- algorithm object identifier value
 533      * }&lt;/pre&gt;
 534      * &lt;p&gt;
 535      * Note that the byte array supplied here is cloned to protect against
 536      * subsequent modifications.
 537      *
 538      * @param key a byte array containing the subject public key in ASN.1 DER
 539      *            form (or {@code null})
 540      * @throws IOException if an encoding error occurs (incorrect form for
 541      * subject public key)
 542      * @see #getSubjectPublicKey
 543      */
 544     public void setSubjectPublicKey(byte[] key) throws IOException {
 545         if (key == null) {
 546             subjectPublicKey = null;
 547             subjectPublicKeyBytes = null;
 548         } else {
 549             subjectPublicKeyBytes = key.clone();
 550             subjectPublicKey = X509Key.parse(new DerValue(subjectPublicKeyBytes));
 551         }
 552     }
 553 
 554     /**
 555      * Sets the keyUsage criterion. The {@code X509Certificate}
 556      * must allow the specified keyUsage values. If {@code null}, no
 557      * keyUsage check will be done. Note that an {@code X509Certificate}
 558      * that has no keyUsage extension implicitly allows all keyUsage values.
 559      * &lt;p&gt;
 560      * Note that the boolean array supplied here is cloned to protect against
 561      * subsequent modifications.
 562      *
 563      * @param keyUsage a boolean array in the same format as the boolean
 564      *                 array returned by
 565      * {@link X509Certificate#getKeyUsage() X509Certificate.getKeyUsage()}.
 566      *                 Or {@code null}.
 567      * @see #getKeyUsage
 568      */
 569     public void setKeyUsage(boolean[] keyUsage) {
 570         if (keyUsage == null) {
 571             this.keyUsage = null;
 572         } else {
 573             this.keyUsage = keyUsage.clone();
 574         }
 575     }
 576 
 577     /**
 578      * Sets the extendedKeyUsage criterion. The {@code X509Certificate}
 579      * must allow the specified key purposes in its extended key usage
 580      * extension. If {@code keyPurposeSet} is empty or {@code null},
 581      * no extendedKeyUsage check will be done. Note that an
 582      * {@code X509Certificate} that has no extendedKeyUsage extension
 583      * implicitly allows all key purposes.
 584      * &lt;p&gt;
 585      * Note that the {@code Set} is cloned to protect against
 586      * subsequent modifications.
 587      *
 588      * @param keyPurposeSet a {@code Set} of key purpose OIDs in string
 589      * format (or {@code null}). Each OID is represented by a set of
 590      * nonnegative integers separated by periods.
 591      * @throws IOException if the OID is invalid, such as
 592      * the first component being not 0, 1 or 2 or the second component
 593      * being greater than 39.
 594      * @see #getExtendedKeyUsage
 595      */
 596     public void setExtendedKeyUsage(Set&lt;String&gt; keyPurposeSet) throws IOException {
 597         if ((keyPurposeSet == null) || keyPurposeSet.isEmpty()) {
 598             this.keyPurposeSet = null;
 599             keyPurposeOIDSet = null;
 600         } else {
 601             this.keyPurposeSet =
 602                 Collections.unmodifiableSet(new HashSet&lt;&gt;(keyPurposeSet));
 603             keyPurposeOIDSet = new HashSet&lt;&gt;();
 604             for (String s : this.keyPurposeSet) {
 605                 keyPurposeOIDSet.add(ObjectIdentifier.of(s));
 606             }
 607         }
 608     }
 609 
 610     /**
 611      * Enables/disables matching all of the subjectAlternativeNames
 612      * specified in the {@link #setSubjectAlternativeNames
 613      * setSubjectAlternativeNames} or {@link #addSubjectAlternativeName
 614      * addSubjectAlternativeName} methods. If enabled,
 615      * the {@code X509Certificate} must contain all of the
 616      * specified subject alternative names. If disabled, the
 617      * {@code X509Certificate} must contain at least one of the
 618      * specified subject alternative names.
 619      *
 620      * &lt;p&gt;The matchAllNames flag is {@code true} by default.
 621      *
 622      * @param matchAllNames if {@code true}, the flag is enabled;
 623      * if {@code false}, the flag is disabled.
 624      * @see #getMatchAllSubjectAltNames
 625      */
 626     public void setMatchAllSubjectAltNames(boolean matchAllNames) {
 627         this.matchAllSubjectAltNames = matchAllNames;
 628     }
 629 
 630     /**
 631      * Sets the subjectAlternativeNames criterion. The
 632      * {@code X509Certificate} must contain all or at least one of the
 633      * specified subjectAlternativeNames, depending on the value of
 634      * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames
 635      * setMatchAllSubjectAltNames}).
 636      * &lt;p&gt;
 637      * This method allows the caller to specify, with a single method call,
 638      * the complete set of subject alternative names for the
 639      * subjectAlternativeNames criterion. The specified value replaces
 640      * the previous value for the subjectAlternativeNames criterion.
 641      * &lt;p&gt;
 642      * The {@code names} parameter (if not {@code null}) is a
 643      * {@code Collection} with one
 644      * entry for each name to be included in the subject alternative name
 645      * criterion. Each entry is a {@code List} whose first entry is an
 646      * {@code Integer} (the name type, 0-8) and whose second
 647      * entry is a {@code String} or a byte array (the name, in
 648      * string or ASN.1 DER encoded form, respectively).
 649      * There can be multiple names of the same type. If {@code null}
 650      * is supplied as the value for this argument, no
 651      * subjectAlternativeNames check will be performed.
 652      * &lt;p&gt;
 653      * Each subject alternative name in the {@code Collection}
 654      * may be specified either as a {@code String} or as an ASN.1 encoded
 655      * byte array. For more details about the formats used, see
 656      * {@link #addSubjectAlternativeName(int type, String name)
 657      * addSubjectAlternativeName(int type, String name)} and
 658      * {@link #addSubjectAlternativeName(int type, byte [] name)
 659      * addSubjectAlternativeName(int type, byte [] name)}.
 660      * &lt;p&gt;
 661      * &lt;strong&gt;Note:&lt;/strong&gt; for distinguished names, specify the byte
 662      * array form instead of the String form. See the note in
 663      * {@link #addSubjectAlternativeName(int, String)} for more information.
 664      * &lt;p&gt;
 665      * Note that the {@code names} parameter can contain duplicate
 666      * names (same name and name type), but they may be removed from the
 667      * {@code Collection} of names returned by the
 668      * {@link #getSubjectAlternativeNames getSubjectAlternativeNames} method.
 669      * &lt;p&gt;
 670      * Note that a deep copy is performed on the {@code Collection} to
 671      * protect against subsequent modifications.
 672      *
 673      * @param names a {@code Collection} of names (or {@code null})
 674      * @throws IOException if a parsing error occurs
 675      * @see #getSubjectAlternativeNames
 676      */
 677     public void setSubjectAlternativeNames(Collection&lt;List&lt;?&gt;&gt; names)
 678             throws IOException {
 679         if (names == null) {
 680             subjectAlternativeNames = null;
 681             subjectAlternativeGeneralNames = null;
 682         } else {
 683             if (names.isEmpty()) {
 684                 subjectAlternativeNames = null;
 685                 subjectAlternativeGeneralNames = null;
 686                 return;
 687             }
 688             Set&lt;List&lt;?&gt;&gt; tempNames = cloneAndCheckNames(names);
 689             // Ensure that we either set both of these or neither
 690             subjectAlternativeGeneralNames = parseNames(tempNames);
 691             subjectAlternativeNames = tempNames;
 692         }
 693     }
 694 
 695     /**
 696      * Adds a name to the subjectAlternativeNames criterion. The
 697      * {@code X509Certificate} must contain all or at least one
 698      * of the specified subjectAlternativeNames, depending on the value of
 699      * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames
 700      * setMatchAllSubjectAltNames}).
 701      * &lt;p&gt;
 702      * This method allows the caller to add a name to the set of subject
 703      * alternative names.
 704      * The specified name is added to any previous value for the
 705      * subjectAlternativeNames criterion. If the specified name is a
 706      * duplicate, it may be ignored.
 707      * &lt;p&gt;
 708      * The name is provided in string format.
 709      * &lt;a href=&quot;http://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt;, DNS, and URI
 710      * names use the well-established string formats for those types (subject to
 711      * the restrictions included in RFC 5280). IPv4 address names are
 712      * supplied using dotted quad notation. OID address names are represented
 713      * as a series of nonnegative integers separated by periods. And
 714      * directory names (distinguished names) are supplied in RFC 2253 format.
 715      * No standard string format is defined for otherNames, X.400 names,
 716      * EDI party names, IPv6 address names, or any other type of names. They
 717      * should be specified using the
 718      * {@link #addSubjectAlternativeName(int type, byte [] name)
 719      * addSubjectAlternativeName(int type, byte [] name)}
 720      * method.
 721      * &lt;p&gt;
 722      * &lt;strong&gt;Note:&lt;/strong&gt; for distinguished names, use
 723      * {@linkplain #addSubjectAlternativeName(int, byte[])} instead.
 724      * This method should not be relied on as it can fail to match some
 725      * certificates because of a loss of encoding information in the RFC 2253
 726      * String form of some distinguished names.
 727      *
 728      * @param type the name type (0-8, as specified in
 729      *             RFC 5280, section 4.2.1.6)
 730      * @param name the name in string form (not {@code null})
 731      * @throws IOException if a parsing error occurs
 732      */
 733     public void addSubjectAlternativeName(int type, String name)
 734             throws IOException {
 735         addSubjectAlternativeNameInternal(type, name);
 736     }
 737 
 738     /**
 739      * Adds a name to the subjectAlternativeNames criterion. The
 740      * {@code X509Certificate} must contain all or at least one
 741      * of the specified subjectAlternativeNames, depending on the value of
 742      * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames
 743      * setMatchAllSubjectAltNames}).
 744      * &lt;p&gt;
 745      * This method allows the caller to add a name to the set of subject
 746      * alternative names.
 747      * The specified name is added to any previous value for the
 748      * subjectAlternativeNames criterion. If the specified name is a
 749      * duplicate, it may be ignored.
 750      * &lt;p&gt;
 751      * The name is provided as a byte array. This byte array should contain
 752      * the DER encoded name, as it would appear in the GeneralName structure
 753      * defined in RFC 5280 and X.509. The encoded byte array should only contain
 754      * the encoded value of the name, and should not include the tag associated
 755      * with the name in the GeneralName structure. The ASN.1 definition of this
 756      * structure appears below.
 757      * &lt;pre&gt;{@code
 758      *  GeneralName ::= CHOICE {
 759      *       otherName                       [0]     OtherName,
 760      *       rfc822Name                      [1]     IA5String,
 761      *       dNSName                         [2]     IA5String,
 762      *       x400Address                     [3]     ORAddress,
 763      *       directoryName                   [4]     Name,
 764      *       ediPartyName                    [5]     EDIPartyName,
 765      *       uniformResourceIdentifier       [6]     IA5String,
 766      *       iPAddress                       [7]     OCTET STRING,
 767      *       registeredID                    [8]     OBJECT IDENTIFIER}
 768      * }&lt;/pre&gt;
 769      * &lt;p&gt;
 770      * Note that the byte array supplied here is cloned to protect against
 771      * subsequent modifications.
 772      *
 773      * @param type the name type (0-8, as listed above)
 774      * @param name a byte array containing the name in ASN.1 DER encoded form
 775      * @throws IOException if a parsing error occurs
 776      */
 777     public void addSubjectAlternativeName(int type, byte[] name)
 778             throws IOException {
 779         // clone because byte arrays are modifiable
 780         addSubjectAlternativeNameInternal(type, name.clone());
 781     }
 782 
 783     /**
 784      * A private method that adds a name (String or byte array) to the
 785      * subjectAlternativeNames criterion. The {@code X509Certificate}
 786      * must contain the specified subjectAlternativeName.
 787      *
 788      * @param type the name type (0-8, as specified in
 789      *             RFC 5280, section 4.2.1.6)
 790      * @param name the name in string or byte array form
 791      * @throws IOException if a parsing error occurs
 792      */
 793     private void addSubjectAlternativeNameInternal(int type, Object name)
 794             throws IOException {
 795         // First, ensure that the name parses
 796         GeneralNameInterface tempName = makeGeneralNameInterface(type, name);
 797         if (subjectAlternativeNames == null) {
 798             subjectAlternativeNames = new HashSet&lt;&gt;();
 799         }
 800         if (subjectAlternativeGeneralNames == null) {
 801             subjectAlternativeGeneralNames = new HashSet&lt;&gt;();
 802         }
 803         List&lt;Object&gt; list = new ArrayList&lt;&gt;(2);
 804         list.add(Integer.valueOf(type));
 805         list.add(name);
 806         subjectAlternativeNames.add(list);
 807         subjectAlternativeGeneralNames.add(tempName);
 808     }
 809 
 810     /**
 811      * Parse an argument of the form passed to setSubjectAlternativeNames,
 812      * returning a {@code Collection} of
 813      * {@code GeneralNameInterface}s.
 814      * Throw an IllegalArgumentException or a ClassCastException
 815      * if the argument is malformed.
 816      *
 817      * @param names a Collection with one entry per name.
 818      *              Each entry is a {@code List} whose first entry
 819      *              is an Integer (the name type, 0-8) and whose second
 820      *              entry is a String or a byte array (the name, in
 821      *              string or ASN.1 DER encoded form, respectively).
 822      *              There can be multiple names of the same type. Null is
 823      *              not an acceptable value.
 824      * @return a Set of {@code GeneralNameInterface}s
 825      * @throws IOException if a parsing error occurs
 826      */
 827     private static Set&lt;GeneralNameInterface&gt; parseNames(Collection&lt;List&lt;?&gt;&gt; names) throws IOException {
 828         Set&lt;GeneralNameInterface&gt; genNames = new HashSet&lt;&gt;();
 829         for (List&lt;?&gt; nameList : names) {
 830             if (nameList.size() != 2) {
 831                 throw new IOException(&quot;name list size not 2&quot;);
 832             }
 833             Object o =  nameList.get(0);
 834             if (!(o instanceof Integer)) {
 835                 throw new IOException(&quot;expected an Integer&quot;);
 836             }
 837             int nameType = ((Integer)o).intValue();
 838             o = nameList.get(1);
 839             genNames.add(makeGeneralNameInterface(nameType, o));
 840         }
 841 
 842         return genNames;
 843     }
 844 
 845     /**
 846      * Compare for equality two objects of the form passed to
 847      * setSubjectAlternativeNames (or X509CRLSelector.setIssuerNames).
 848      * Throw an {@code IllegalArgumentException} or a
 849      * {@code ClassCastException} if one of the objects is malformed.
 850      *
 851      * @param object1 a Collection containing the first object to compare
 852      * @param object2 a Collection containing the second object to compare
 853      * @return true if the objects are equal, false otherwise
 854      */
 855     static boolean equalNames(Collection&lt;?&gt; object1, Collection&lt;?&gt; object2) {
 856         if ((object1 == null) || (object2 == null)) {
 857             return object1 == object2;
 858         }
 859         return object1.equals(object2);
 860     }
 861 
 862     /**
 863      * Make a {@code GeneralNameInterface} out of a name type (0-8) and an
 864      * Object that may be a byte array holding the ASN.1 DER encoded
 865      * name or a String form of the name.  Except for X.509
 866      * Distinguished Names, the String form of the name must not be the
 867      * result from calling toString on an existing GeneralNameInterface
 868      * implementing class.  The output of toString is not compatible
 869      * with the String constructors for names other than Distinguished
 870      * Names.
 871      *
 872      * @param type name type (0-8)
 873      * @param name name as ASN.1 Der-encoded byte array or String
 874      * @return a GeneralNameInterface name
 875      * @throws IOException if a parsing error occurs
 876      */
 877     static GeneralNameInterface makeGeneralNameInterface(int type, Object name)
 878             throws IOException {
 879         GeneralNameInterface result;
 880         if (debug != null) {
 881             debug.println(&quot;X509CertSelector.makeGeneralNameInterface(&quot;
 882                 + type + &quot;)...&quot;);
 883         }
 884 
 885         if (name instanceof String) {
 886             if (debug != null) {
 887                 debug.println(&quot;X509CertSelector.makeGeneralNameInterface() &quot;
 888                     + &quot;name is String: &quot; + name);
 889             }
 890             switch (type) {
 891             case NAME_RFC822:
 892                 result = new RFC822Name((String)name);
 893                 break;
 894             case NAME_DNS:
 895                 result = new DNSName((String)name);
 896                 break;
 897             case NAME_DIRECTORY:
 898                 result = new X500Name((String)name);
 899                 break;
 900             case NAME_URI:
 901                 result = new URIName((String)name);
 902                 break;
 903             case NAME_IP:
 904                 result = new IPAddressName((String)name);
 905                 break;
 906             case NAME_OID:
 907                 result = new OIDName((String)name);
 908                 break;
 909             default:
 910                 throw new IOException(&quot;unable to parse String names of type &quot;
 911                                       + type);
 912             }
 913             if (debug != null) {
 914                 debug.println(&quot;X509CertSelector.makeGeneralNameInterface() &quot;
 915                     + &quot;result: &quot; + result.toString());
 916             }
 917         } else if (name instanceof byte[]) {
 918             DerValue val = new DerValue((byte[]) name);
 919             if (debug != null) {
 920                 debug.println
 921                     (&quot;X509CertSelector.makeGeneralNameInterface() is byte[]&quot;);
 922             }
 923 
 924             switch (type) {
 925             case NAME_ANY:
 926                 result = new OtherName(val);
 927                 break;
 928             case NAME_RFC822:
 929                 result = new RFC822Name(val);
 930                 break;
 931             case NAME_DNS:
 932                 result = new DNSName(val);
 933                 break;
 934             case NAME_X400:
 935                 result = new X400Address(val);
 936                 break;
 937             case NAME_DIRECTORY:
 938                 result = new X500Name(val);
 939                 break;
 940             case NAME_EDI:
 941                 result = new EDIPartyName(val);
 942                 break;
 943             case NAME_URI:
 944                 result = new URIName(val);
 945                 break;
 946             case NAME_IP:
 947                 result = new IPAddressName(val);
 948                 break;
 949             case NAME_OID:
 950                 result = new OIDName(val);
 951                 break;
 952             default:
 953                 throw new IOException(&quot;unable to parse byte array names of &quot;
 954                     + &quot;type &quot; + type);
 955             }
 956             if (debug != null) {
 957                 debug.println(&quot;X509CertSelector.makeGeneralNameInterface() result: &quot;
 958                     + result.toString());
 959             }
 960         } else {
 961             if (debug != null) {
 962                 debug.println(&quot;X509CertSelector.makeGeneralName() input name &quot;
 963                     + &quot;not String or byte array&quot;);
 964             }
 965             throw new IOException(&quot;name not String or byte array&quot;);
 966         }
 967         return result;
 968     }
 969 
 970 
 971     /**
 972      * Sets the name constraints criterion. The {@code X509Certificate}
 973      * must have subject and subject alternative names that
 974      * meet the specified name constraints.
 975      * &lt;p&gt;
 976      * The name constraints are specified as a byte array. This byte array
 977      * should contain the DER encoded form of the name constraints, as they
 978      * would appear in the NameConstraints structure defined in RFC 5280
 979      * and X.509. The ASN.1 definition of this structure appears below.
 980      *
 981      * &lt;pre&gt;{@code
 982      *  NameConstraints ::= SEQUENCE {
 983      *       permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,
 984      *       excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }
 985      *
 986      *  GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree
 987      *
 988      *  GeneralSubtree ::= SEQUENCE {
 989      *       base                    GeneralName,
 990      *       minimum         [0]     BaseDistance DEFAULT 0,
 991      *       maximum         [1]     BaseDistance OPTIONAL }
 992      *
 993      *  BaseDistance ::= INTEGER (0..MAX)
 994      *
 995      *  GeneralName ::= CHOICE {
 996      *       otherName                       [0]     OtherName,
 997      *       rfc822Name                      [1]     IA5String,
 998      *       dNSName                         [2]     IA5String,
 999      *       x400Address                     [3]     ORAddress,
1000      *       directoryName                   [4]     Name,
1001      *       ediPartyName                    [5]     EDIPartyName,
1002      *       uniformResourceIdentifier       [6]     IA5String,
1003      *       iPAddress                       [7]     OCTET STRING,
1004      *       registeredID                    [8]     OBJECT IDENTIFIER}
1005      * }&lt;/pre&gt;
1006      * &lt;p&gt;
1007      * Note that the byte array supplied here is cloned to protect against
1008      * subsequent modifications.
1009      *
1010      * @param bytes a byte array containing the ASN.1 DER encoding of
1011      *              a NameConstraints extension to be used for checking
1012      *              name constraints. Only the value of the extension is
1013      *              included, not the OID or criticality flag. Can be
1014      *              {@code null},
1015      *              in which case no name constraints check will be performed.
1016      * @throws IOException if a parsing error occurs
1017      * @see #getNameConstraints
1018      */
1019     public void setNameConstraints(byte[] bytes) throws IOException {
1020         if (bytes == null) {
1021             ncBytes = null;
1022             nc = null;
1023         } else {
1024             ncBytes = bytes.clone();
1025             nc = new NameConstraintsExtension(FALSE, bytes);
1026         }
1027     }
1028 
1029     /**
1030      * Sets the basic constraints constraint. If the value is greater than or
1031      * equal to zero, {@code X509Certificates} must include a
1032      * basicConstraints extension with
1033      * a pathLen of at least this value. If the value is -2, only end-entity
1034      * certificates are accepted. If the value is -1, no check is done.
1035      * &lt;p&gt;
1036      * This constraint is useful when building a certification path forward
1037      * (from the target toward the trust anchor. If a partial path has been
1038      * built, any candidate certificate must have a maxPathLen value greater
1039      * than or equal to the number of certificates in the partial path.
1040      *
1041      * @param minMaxPathLen the value for the basic constraints constraint
1042      * @throws IllegalArgumentException if the value is less than -2
1043      * @see #getBasicConstraints
1044      */
1045     public void setBasicConstraints(int minMaxPathLen) {
1046         if (minMaxPathLen &lt; -2) {
1047             throw new IllegalArgumentException(&quot;basic constraints less than -2&quot;);
1048         }
1049         basicConstraints = minMaxPathLen;
1050     }
1051 
1052     /**
1053      * Sets the policy constraint. The {@code X509Certificate} must
1054      * include at least one of the specified policies in its certificate
1055      * policies extension. If {@code certPolicySet} is empty, then the
1056      * {@code X509Certificate} must include at least some specified policy
1057      * in its certificate policies extension. If {@code certPolicySet} is
1058      * {@code null}, no policy check will be performed.
1059      * &lt;p&gt;
1060      * Note that the {@code Set} is cloned to protect against
1061      * subsequent modifications.
1062      *
1063      * @param certPolicySet a {@code Set} of certificate policy OIDs in
1064      *                      string format (or {@code null}). Each OID is
1065      *                      represented by a set of nonnegative integers
1066      *                    separated by periods.
1067      * @throws IOException if a parsing error occurs on the OID such as
1068      * the first component is not 0, 1 or 2 or the second component is
1069      * greater than 39.
1070      * @see #getPolicy
1071      */
1072     public void setPolicy(Set&lt;String&gt; certPolicySet) throws IOException {
1073         if (certPolicySet == null) {
1074             policySet = null;
1075             policy = null;
1076         } else {
1077             // Snapshot set and parse it
1078             Set&lt;String&gt; tempSet = Collections.unmodifiableSet
1079                                         (new HashSet&lt;&gt;(certPolicySet));
1080             /* Convert to Vector of ObjectIdentifiers */
1081             Iterator&lt;String&gt; i = tempSet.iterator();
1082             Vector&lt;CertificatePolicyId&gt; polIdVector = new Vector&lt;&gt;();
1083             while (i.hasNext()) {
1084                 Object o = i.next();
1085                 if (!(o instanceof String)) {
1086                     throw new IOException(&quot;non String in certPolicySet&quot;);
1087                 }
1088                 polIdVector.add(new CertificatePolicyId
1089                         (ObjectIdentifier.of((String)o)));
1090             }
1091             // If everything went OK, make the changes
1092             policySet = tempSet;
1093             policy = new CertificatePolicySet(polIdVector);
1094         }
1095     }
1096 
1097     /**
1098      * Sets the pathToNames criterion. The {@code X509Certificate} must
1099      * not include name constraints that would prohibit building a
1100      * path to the specified names.
1101      * &lt;p&gt;
1102      * This method allows the caller to specify, with a single method call,
1103      * the complete set of names which the {@code X509Certificates}&#39;s
1104      * name constraints must permit. The specified value replaces
1105      * the previous value for the pathToNames criterion.
1106      * &lt;p&gt;
1107      * This constraint is useful when building a certification path forward
1108      * (from the target toward the trust anchor. If a partial path has been
1109      * built, any candidate certificate must not include name constraints that
1110      * would prohibit building a path to any of the names in the partial path.
1111      * &lt;p&gt;
1112      * The {@code names} parameter (if not {@code null}) is a
1113      * {@code Collection} with one
1114      * entry for each name to be included in the pathToNames
1115      * criterion. Each entry is a {@code List} whose first entry is an
1116      * {@code Integer} (the name type, 0-8) and whose second
1117      * entry is a {@code String} or a byte array (the name, in
1118      * string or ASN.1 DER encoded form, respectively).
1119      * There can be multiple names of the same type. If {@code null}
1120      * is supplied as the value for this argument, no
1121      * pathToNames check will be performed.
1122      * &lt;p&gt;
1123      * Each name in the {@code Collection}
1124      * may be specified either as a {@code String} or as an ASN.1 encoded
1125      * byte array. For more details about the formats used, see
1126      * {@link #addPathToName(int type, String name)
1127      * addPathToName(int type, String name)} and
1128      * {@link #addPathToName(int type, byte [] name)
1129      * addPathToName(int type, byte [] name)}.
1130      * &lt;p&gt;
1131      * &lt;strong&gt;Note:&lt;/strong&gt; for distinguished names, specify the byte
1132      * array form instead of the String form. See the note in
1133      * {@link #addPathToName(int, String)} for more information.
1134      * &lt;p&gt;
1135      * Note that the {@code names} parameter can contain duplicate
1136      * names (same name and name type), but they may be removed from the
1137      * {@code Collection} of names returned by the
1138      * {@link #getPathToNames getPathToNames} method.
1139      * &lt;p&gt;
1140      * Note that a deep copy is performed on the {@code Collection} to
1141      * protect against subsequent modifications.
1142      *
1143      * @param names a {@code Collection} with one entry per name
1144      *              (or {@code null})
1145      * @throws IOException if a parsing error occurs
1146      * @see #getPathToNames
1147      */
1148     public void setPathToNames(Collection&lt;List&lt;?&gt;&gt; names) throws IOException {
1149         if ((names == null) || names.isEmpty()) {
1150             pathToNames = null;
1151             pathToGeneralNames = null;
1152         } else {
1153             Set&lt;List&lt;?&gt;&gt; tempNames = cloneAndCheckNames(names);
1154             pathToGeneralNames = parseNames(tempNames);
1155             // Ensure that we either set both of these or neither
1156             pathToNames = tempNames;
1157         }
1158     }
1159 
1160     // called from CertPathHelper
1161     void setPathToNamesInternal(Set&lt;GeneralNameInterface&gt; names) {
1162         // set names to non-null dummy value
1163         // this breaks getPathToNames()
1164         pathToNames = Collections.&lt;List&lt;?&gt;&gt;emptySet();
1165         pathToGeneralNames = names;
1166     }
1167 
1168     /**
1169      * Adds a name to the pathToNames criterion. The {@code X509Certificate}
1170      * must not include name constraints that would prohibit building a
1171      * path to the specified name.
1172      * &lt;p&gt;
1173      * This method allows the caller to add a name to the set of names which
1174      * the {@code X509Certificates}&#39;s name constraints must permit.
1175      * The specified name is added to any previous value for the
1176      * pathToNames criterion.  If the name is a duplicate, it may be ignored.
1177      * &lt;p&gt;
1178      * The name is provided in string format. RFC 822, DNS, and URI names
1179      * use the well-established string formats for those types (subject to
1180      * the restrictions included in RFC 5280). IPv4 address names are
1181      * supplied using dotted quad notation. OID address names are represented
1182      * as a series of nonnegative integers separated by periods. And
1183      * directory names (distinguished names) are supplied in RFC 2253 format.
1184      * No standard string format is defined for otherNames, X.400 names,
1185      * EDI party names, IPv6 address names, or any other type of names. They
1186      * should be specified using the
1187      * {@link #addPathToName(int type, byte [] name)
1188      * addPathToName(int type, byte [] name)} method.
1189      * &lt;p&gt;
1190      * &lt;strong&gt;Note:&lt;/strong&gt; for distinguished names, use
1191      * {@linkplain #addPathToName(int, byte[])} instead.
1192      * This method should not be relied on as it can fail to match some
1193      * certificates because of a loss of encoding information in the RFC 2253
1194      * String form of some distinguished names.
1195      *
1196      * @param type the name type (0-8, as specified in
1197      *             RFC 5280, section 4.2.1.6)
1198      * @param name the name in string form
1199      * @throws IOException if a parsing error occurs
1200      */
1201     public void addPathToName(int type, String name) throws IOException {
1202         addPathToNameInternal(type, name);
1203     }
1204 
1205     /**
1206      * Adds a name to the pathToNames criterion. The {@code X509Certificate}
1207      * must not include name constraints that would prohibit building a
1208      * path to the specified name.
1209      * &lt;p&gt;
1210      * This method allows the caller to add a name to the set of names which
1211      * the {@code X509Certificates}&#39;s name constraints must permit.
1212      * The specified name is added to any previous value for the
1213      * pathToNames criterion. If the name is a duplicate, it may be ignored.
1214      * &lt;p&gt;
1215      * The name is provided as a byte array. This byte array should contain
1216      * the DER encoded name, as it would appear in the GeneralName structure
1217      * defined in RFC 5280 and X.509. The ASN.1 definition of this structure
1218      * appears in the documentation for
1219      * {@link #addSubjectAlternativeName(int type, byte [] name)
1220      * addSubjectAlternativeName(int type, byte [] name)}.
1221      * &lt;p&gt;
1222      * Note that the byte array supplied here is cloned to protect against
1223      * subsequent modifications.
1224      *
1225      * @param type the name type (0-8, as specified in
1226      *             RFC 5280, section 4.2.1.6)
1227      * @param name a byte array containing the name in ASN.1 DER encoded form
1228      * @throws IOException if a parsing error occurs
1229      */
1230     public void addPathToName(int type, byte [] name) throws IOException {
1231         // clone because byte arrays are modifiable
1232         addPathToNameInternal(type, name.clone());
1233     }
1234 
1235     /**
1236      * A private method that adds a name (String or byte array) to the
1237      * pathToNames criterion. The {@code X509Certificate} must contain
1238      * the specified pathToName.
1239      *
1240      * @param type the name type (0-8, as specified in
1241      *             RFC 5280, section 4.2.1.6)
1242      * @param name the name in string or byte array form
1243      * @throws IOException if an encoding error occurs (incorrect form for DN)
1244      */
1245     private void addPathToNameInternal(int type, Object name)
1246             throws IOException {
1247         // First, ensure that the name parses
1248         GeneralNameInterface tempName = makeGeneralNameInterface(type, name);
1249         if (pathToGeneralNames == null) {
1250             pathToNames = new HashSet&lt;&gt;();
1251             pathToGeneralNames = new HashSet&lt;&gt;();
1252         }
1253         List&lt;Object&gt; list = new ArrayList&lt;&gt;(2);
1254         list.add(Integer.valueOf(type));
1255         list.add(name);
1256         pathToNames.add(list);
1257         pathToGeneralNames.add(tempName);
1258     }
1259 
1260     /**
1261      * Returns the certificateEquals criterion. The specified
1262      * {@code X509Certificate} must be equal to the
1263      * {@code X509Certificate} passed to the {@code match} method.
1264      * If {@code null}, this check is not applied.
1265      *
1266      * @return the {@code X509Certificate} to match (or {@code null})
1267      * @see #setCertificate
1268      */
1269     public X509Certificate getCertificate() {
1270         return x509Cert;
1271     }
1272 
1273     /**
1274      * Returns the serialNumber criterion. The specified serial number
1275      * must match the certificate serial number in the
1276      * {@code X509Certificate}. If {@code null}, any certificate
1277      * serial number will do.
1278      *
1279      * @return the certificate serial number to match
1280      *                (or {@code null})
1281      * @see #setSerialNumber
1282      */
1283     public BigInteger getSerialNumber() {
1284         return serialNumber;
1285     }
1286 
1287     /**
1288      * Returns the issuer criterion as an {@code X500Principal}. This
1289      * distinguished name must match the issuer distinguished name in the
1290      * {@code X509Certificate}. If {@code null}, the issuer criterion
1291      * is disabled and any issuer distinguished name will do.
1292      *
1293      * @return the required issuer distinguished name as X500Principal
1294      *         (or {@code null})
1295      * @since 1.5
1296      */
1297     public X500Principal getIssuer() {
1298         return issuer;
1299     }
1300 
1301     /**
1302      * &lt;strong&gt;Denigrated&lt;/strong&gt;, use {@linkplain #getIssuer()} or
1303      * {@linkplain #getIssuerAsBytes()} instead. This method should not be
1304      * relied on as it can fail to match some certificates because of a loss of
1305      * encoding information in the RFC 2253 String form of some distinguished
1306      * names.
1307      * &lt;p&gt;
1308      * Returns the issuer criterion as a {@code String}. This
1309      * distinguished name must match the issuer distinguished name in the
1310      * {@code X509Certificate}. If {@code null}, the issuer criterion
1311      * is disabled and any issuer distinguished name will do.
1312      * &lt;p&gt;
1313      * If the value returned is not {@code null}, it is a
1314      * distinguished name, in RFC 2253 format.
1315      *
1316      * @return the required issuer distinguished name in RFC 2253 format
1317      *         (or {@code null})
1318      */
1319     public String getIssuerAsString() {
1320         return (issuer == null ? null : issuer.getName());
1321     }
1322 
1323     /**
1324      * Returns the issuer criterion as a byte array. This distinguished name
1325      * must match the issuer distinguished name in the
1326      * {@code X509Certificate}. If {@code null}, the issuer criterion
1327      * is disabled and any issuer distinguished name will do.
1328      * &lt;p&gt;
1329      * If the value returned is not {@code null}, it is a byte
1330      * array containing a single DER encoded distinguished name, as defined in
1331      * X.501. The ASN.1 notation for this structure is supplied in the
1332      * documentation for
1333      * {@link #setIssuer(byte [] issuerDN) setIssuer(byte [] issuerDN)}.
1334      * &lt;p&gt;
1335      * Note that the byte array returned is cloned to protect against
1336      * subsequent modifications.
1337      *
1338      * @return a byte array containing the required issuer distinguished name
1339      *         in ASN.1 DER format (or {@code null})
1340      * @throws IOException if an encoding error occurs
1341      */
1342     public byte[] getIssuerAsBytes() throws IOException {
1343         return (issuer == null ? null: issuer.getEncoded());
1344     }
1345 
1346     /**
1347      * Returns the subject criterion as an {@code X500Principal}. This
1348      * distinguished name must match the subject distinguished name in the
1349      * {@code X509Certificate}. If {@code null}, the subject criterion
1350      * is disabled and any subject distinguished name will do.
1351      *
1352      * @return the required subject distinguished name as X500Principal
1353      *         (or {@code null})
1354      * @since 1.5
1355      */
1356     public X500Principal getSubject() {
1357         return subject;
1358     }
1359 
1360     /**
1361      * &lt;strong&gt;Denigrated&lt;/strong&gt;, use {@linkplain #getSubject()} or
1362      * {@linkplain #getSubjectAsBytes()} instead. This method should not be
1363      * relied on as it can fail to match some certificates because of a loss of
1364      * encoding information in the RFC 2253 String form of some distinguished
1365      * names.
1366      * &lt;p&gt;
1367      * Returns the subject criterion as a {@code String}. This
1368      * distinguished name must match the subject distinguished name in the
1369      * {@code X509Certificate}. If {@code null}, the subject criterion
1370      * is disabled and any subject distinguished name will do.
1371      * &lt;p&gt;
1372      * If the value returned is not {@code null}, it is a
1373      * distinguished name, in RFC 2253 format.
1374      *
1375      * @return the required subject distinguished name in RFC 2253 format
1376      *         (or {@code null})
1377      */
1378     public String getSubjectAsString() {
1379         return (subject == null ? null : subject.getName());
1380     }
1381 
1382     /**
1383      * Returns the subject criterion as a byte array. This distinguished name
1384      * must match the subject distinguished name in the
1385      * {@code X509Certificate}. If {@code null}, the subject criterion
1386      * is disabled and any subject distinguished name will do.
1387      * &lt;p&gt;
1388      * If the value returned is not {@code null}, it is a byte
1389      * array containing a single DER encoded distinguished name, as defined in
1390      * X.501. The ASN.1 notation for this structure is supplied in the
1391      * documentation for
1392      * {@link #setSubject(byte [] subjectDN) setSubject(byte [] subjectDN)}.
1393      * &lt;p&gt;
1394      * Note that the byte array returned is cloned to protect against
1395      * subsequent modifications.
1396      *
1397      * @return a byte array containing the required subject distinguished name
1398      *         in ASN.1 DER format (or {@code null})
1399      * @throws IOException if an encoding error occurs
1400      */
1401     public byte[] getSubjectAsBytes() throws IOException {
1402         return (subject == null ? null : subject.getEncoded());
1403     }
1404 
1405     /**
1406      * Returns the subjectKeyIdentifier criterion. The
1407      * {@code X509Certificate} must contain a SubjectKeyIdentifier
1408      * extension with the specified value. If {@code null}, no
1409      * subjectKeyIdentifier check will be done.
1410      * &lt;p&gt;
1411      * Note that the byte array returned is cloned to protect against
1412      * subsequent modifications.
1413      *
1414      * @return the key identifier (or {@code null})
1415      * @see #setSubjectKeyIdentifier
1416      */
1417     public byte[] getSubjectKeyIdentifier() {
1418         if (subjectKeyID == null) {
1419             return null;
1420         }
1421         return subjectKeyID.clone();
1422     }
1423 
1424     /**
1425      * Returns the authorityKeyIdentifier criterion. The
1426      * {@code X509Certificate} must contain a AuthorityKeyIdentifier
1427      * extension with the specified value. If {@code null}, no
1428      * authorityKeyIdentifier check will be done.
1429      * &lt;p&gt;
1430      * Note that the byte array returned is cloned to protect against
1431      * subsequent modifications.
1432      *
1433      * @return the key identifier (or {@code null})
1434      * @see #setAuthorityKeyIdentifier
1435      */
1436     public byte[] getAuthorityKeyIdentifier() {
1437         if (authorityKeyID == null) {
1438           return null;
1439         }
1440         return authorityKeyID.clone();
1441     }
1442 
1443     /**
1444      * Returns the certificateValid criterion. The specified date must fall
1445      * within the certificate validity period for the
1446      * {@code X509Certificate}. If {@code null}, no certificateValid
1447      * check will be done.
1448      * &lt;p&gt;
1449      * Note that the {@code Date} returned is cloned to protect against
1450      * subsequent modifications.
1451      *
1452      * @return the {@code Date} to check (or {@code null})
1453      * @see #setCertificateValid
1454      */
1455     public Date getCertificateValid() {
1456         if (certificateValid == null) {
1457             return null;
1458         }
1459         return (Date)certificateValid.clone();
1460     }
1461 
1462     /**
1463      * Returns the privateKeyValid criterion. The specified date must fall
1464      * within the private key validity period for the
1465      * {@code X509Certificate}. If {@code null}, no privateKeyValid
1466      * check will be done.
1467      * &lt;p&gt;
1468      * Note that the {@code Date} returned is cloned to protect against
1469      * subsequent modifications.
1470      *
1471      * @return the {@code Date} to check (or {@code null})
1472      * @see #setPrivateKeyValid
1473      */
1474     public Date getPrivateKeyValid() {
1475         if (privateKeyValid == null) {
1476             return null;
1477         }
1478         return (Date)privateKeyValid.clone();
1479     }
1480 
1481     /**
1482      * Returns the subjectPublicKeyAlgID criterion. The
1483      * {@code X509Certificate} must contain a subject public key
1484      * with the specified algorithm. If {@code null}, no
1485      * subjectPublicKeyAlgID check will be done.
1486      *
1487      * @return the object identifier (OID) of the signature algorithm to check
1488      *         for (or {@code null}). An OID is represented by a set of
1489      *         nonnegative integers separated by periods.
1490      * @see #setSubjectPublicKeyAlgID
1491      */
1492     public String getSubjectPublicKeyAlgID() {
1493         if (subjectPublicKeyAlgID == null) {
1494             return null;
1495         }
1496         return subjectPublicKeyAlgID.toString();
1497     }
1498 
1499     /**
1500      * Returns the subjectPublicKey criterion. The
1501      * {@code X509Certificate} must contain the specified subject
1502      * public key. If {@code null}, no subjectPublicKey check will be done.
1503      *
1504      * @return the subject public key to check for (or {@code null})
1505      * @see #setSubjectPublicKey
1506      */
1507     public PublicKey getSubjectPublicKey() {
1508         return subjectPublicKey;
1509     }
1510 
1511     /**
1512      * Returns the keyUsage criterion. The {@code X509Certificate}
1513      * must allow the specified keyUsage values. If null, no keyUsage
1514      * check will be done.
1515      * &lt;p&gt;
1516      * Note that the boolean array returned is cloned to protect against
1517      * subsequent modifications.
1518      *
1519      * @return a boolean array in the same format as the boolean
1520      *                 array returned by
1521      * {@link X509Certificate#getKeyUsage() X509Certificate.getKeyUsage()}.
1522      *                 Or {@code null}.
1523      * @see #setKeyUsage
1524      */
1525     public boolean[] getKeyUsage() {
1526         if (keyUsage == null) {
1527             return null;
1528         }
1529         return keyUsage.clone();
1530     }
1531 
1532     /**
1533      * Returns the extendedKeyUsage criterion. The {@code X509Certificate}
1534      * must allow the specified key purposes in its extended key usage
1535      * extension. If the {@code keyPurposeSet} returned is empty or
1536      * {@code null}, no extendedKeyUsage check will be done. Note that an
1537      * {@code X509Certificate} that has no extendedKeyUsage extension
1538      * implicitly allows all key purposes.
1539      *
1540      * @return an immutable {@code Set} of key purpose OIDs in string
1541      * format (or {@code null})
1542      * @see #setExtendedKeyUsage
1543      */
1544     public Set&lt;String&gt; getExtendedKeyUsage() {
1545         return keyPurposeSet;
1546     }
1547 
1548     /**
1549      * Indicates if the {@code X509Certificate} must contain all
1550      * or at least one of the subjectAlternativeNames
1551      * specified in the {@link #setSubjectAlternativeNames
1552      * setSubjectAlternativeNames} or {@link #addSubjectAlternativeName
1553      * addSubjectAlternativeName} methods. If {@code true},
1554      * the {@code X509Certificate} must contain all of the
1555      * specified subject alternative names. If {@code false}, the
1556      * {@code X509Certificate} must contain at least one of the
1557      * specified subject alternative names.
1558      *
1559      * @return {@code true} if the flag is enabled;
1560      * {@code false} if the flag is disabled. The flag is
1561      * {@code true} by default.
1562      * @see #setMatchAllSubjectAltNames
1563      */
1564     public boolean getMatchAllSubjectAltNames() {
1565         return matchAllSubjectAltNames;
1566     }
1567 
1568     /**
1569      * Returns a copy of the subjectAlternativeNames criterion.
1570      * The {@code X509Certificate} must contain all or at least one
1571      * of the specified subjectAlternativeNames, depending on the value
1572      * of the matchAllNames flag (see {@link #getMatchAllSubjectAltNames
1573      * getMatchAllSubjectAltNames}). If the value returned is
1574      * {@code null}, no subjectAlternativeNames check will be performed.
1575      * &lt;p&gt;
1576      * If the value returned is not {@code null}, it is a
1577      * {@code Collection} with
1578      * one entry for each name to be included in the subject alternative name
1579      * criterion. Each entry is a {@code List} whose first entry is an
1580      * {@code Integer} (the name type, 0-8) and whose second
1581      * entry is a {@code String} or a byte array (the name, in
1582      * string or ASN.1 DER encoded form, respectively).
1583      * There can be multiple names of the same type.  Note that the
1584      * {@code Collection} returned may contain duplicate names (same name
1585      * and name type).
1586      * &lt;p&gt;
1587      * Each subject alternative name in the {@code Collection}
1588      * may be specified either as a {@code String} or as an ASN.1 encoded
1589      * byte array. For more details about the formats used, see
1590      * {@link #addSubjectAlternativeName(int type, String name)
1591      * addSubjectAlternativeName(int type, String name)} and
1592      * {@link #addSubjectAlternativeName(int type, byte [] name)
1593      * addSubjectAlternativeName(int type, byte [] name)}.
1594      * &lt;p&gt;
1595      * Note that a deep copy is performed on the {@code Collection} to
1596      * protect against subsequent modifications.
1597      *
1598      * @return a {@code Collection} of names (or {@code null})
1599      * @see #setSubjectAlternativeNames
1600      */
1601     public Collection&lt;List&lt;?&gt;&gt; getSubjectAlternativeNames() {
1602         if (subjectAlternativeNames == null) {
1603             return null;
1604         }
1605         return cloneNames(subjectAlternativeNames);
1606     }
1607 
1608     /**
1609      * Clone an object of the form passed to
1610      * setSubjectAlternativeNames and setPathToNames.
1611      * Throw a {@code RuntimeException} if the argument is malformed.
1612      * &lt;p&gt;
1613      * This method wraps cloneAndCheckNames, changing any
1614      * {@code IOException} into a {@code RuntimeException}. This
1615      * method should be used when the object being
1616      * cloned has already been checked, so there should never be any exceptions.
1617      *
1618      * @param names a {@code Collection} with one entry per name.
1619      *              Each entry is a {@code List} whose first entry
1620      *              is an Integer (the name type, 0-8) and whose second
1621      *              entry is a String or a byte array (the name, in
1622      *              string or ASN.1 DER encoded form, respectively).
1623      *              There can be multiple names of the same type. Null
1624      *              is not an acceptable value.
1625      * @return a deep copy of the specified {@code Collection}
1626      * @throws RuntimeException if a parsing error occurs
1627      */
1628     private static Set&lt;List&lt;?&gt;&gt; cloneNames(Collection&lt;List&lt;?&gt;&gt; names) {
1629         try {
1630             return cloneAndCheckNames(names);
1631         } catch (IOException e) {
1632             throw new RuntimeException(&quot;cloneNames encountered IOException: &quot; +
1633                                        e.getMessage());
1634         }
1635     }
1636 
1637     /**
1638      * Clone and check an argument of the form passed to
1639      * setSubjectAlternativeNames and setPathToNames.
1640      * Throw an {@code IOException} if the argument is malformed.
1641      *
1642      * @param names a {@code Collection} with one entry per name.
1643      *              Each entry is a {@code List} whose first entry
1644      *              is an Integer (the name type, 0-8) and whose second
1645      *              entry is a String or a byte array (the name, in
1646      *              string or ASN.1 DER encoded form, respectively).
1647      *              There can be multiple names of the same type.
1648      *              {@code null} is not an acceptable value.
1649      * @return a deep copy of the specified {@code Collection}
1650      * @throws IOException if a parsing error occurs
1651      */
1652     private static Set&lt;List&lt;?&gt;&gt; cloneAndCheckNames(Collection&lt;List&lt;?&gt;&gt; names) throws IOException {
1653         // Copy the Lists and Collection
1654         Set&lt;List&lt;?&gt;&gt; namesCopy = new HashSet&lt;&gt;();
1655         for (List&lt;?&gt; o : names)
1656         {
1657             namesCopy.add(new ArrayList&lt;&gt;(o));
1658         }
1659 
1660         // Check the contents of the Lists and clone any byte arrays
1661         for (List&lt;?&gt; list : namesCopy) {
1662             @SuppressWarnings(&quot;unchecked&quot;) // See javadoc for parameter &quot;names&quot;.
1663             List&lt;Object&gt; nameList = (List&lt;Object&gt;)list;
1664             if (nameList.size() != 2) {
1665                 throw new IOException(&quot;name list size not 2&quot;);
1666             }
1667             Object o = nameList.get(0);
1668             if (!(o instanceof Integer)) {
1669                 throw new IOException(&quot;expected an Integer&quot;);
1670             }
1671             int nameType = ((Integer)o).intValue();
1672             if ((nameType &lt; 0) || (nameType &gt; 8)) {
1673                 throw new IOException(&quot;name type not 0-8&quot;);
1674             }
1675             Object nameObject = nameList.get(1);
1676             if (!(nameObject instanceof byte[]) &amp;&amp;
1677                 !(nameObject instanceof String)) {
1678                 if (debug != null) {
1679                     debug.println(&quot;X509CertSelector.cloneAndCheckNames() &quot;
1680                         + &quot;name not byte array&quot;);
1681                 }
1682                 throw new IOException(&quot;name not byte array or String&quot;);
1683             }
1684             if (nameObject instanceof byte[]) {
1685                 nameList.set(1, ((byte[]) nameObject).clone());
1686             }
1687         }
1688         return namesCopy;
1689     }
1690 
1691     /**
1692      * Returns the name constraints criterion. The {@code X509Certificate}
1693      * must have subject and subject alternative names that
1694      * meet the specified name constraints.
1695      * &lt;p&gt;
1696      * The name constraints are returned as a byte array. This byte array
1697      * contains the DER encoded form of the name constraints, as they
1698      * would appear in the NameConstraints structure defined in RFC 5280
1699      * and X.509. The ASN.1 notation for this structure is supplied in the
1700      * documentation for
1701      * {@link #setNameConstraints(byte [] bytes) setNameConstraints(byte [] bytes)}.
1702      * &lt;p&gt;
1703      * Note that the byte array returned is cloned to protect against
1704      * subsequent modifications.
1705      *
1706      * @return a byte array containing the ASN.1 DER encoding of
1707      *         a NameConstraints extension used for checking name constraints.
1708      *         {@code null} if no name constraints check will be performed.
1709      * @see #setNameConstraints
1710      */
1711     public byte[] getNameConstraints() {
1712         if (ncBytes == null) {
1713             return null;
1714         } else {
1715             return ncBytes.clone();
1716         }
1717     }
1718 
1719     /**
1720      * Returns the basic constraints constraint. If the value is greater than
1721      * or equal to zero, the {@code X509Certificates} must include a
1722      * basicConstraints extension with a pathLen of at least this value.
1723      * If the value is -2, only end-entity certificates are accepted. If
1724      * the value is -1, no basicConstraints check is done.
1725      *
1726      * @return the value for the basic constraints constraint
1727      * @see #setBasicConstraints
1728      */
1729     public int getBasicConstraints() {
1730         return basicConstraints;
1731     }
1732 
1733     /**
1734      * Returns the policy criterion. The {@code X509Certificate} must
1735      * include at least one of the specified policies in its certificate policies
1736      * extension. If the {@code Set} returned is empty, then the
1737      * {@code X509Certificate} must include at least some specified policy
1738      * in its certificate policies extension. If the {@code Set} returned is
1739      * {@code null}, no policy check will be performed.
1740      *
1741      * @return an immutable {@code Set} of certificate policy OIDs in
1742      *         string format (or {@code null})
1743      * @see #setPolicy
1744      */
1745     public Set&lt;String&gt; getPolicy() {
1746         return policySet;
1747     }
1748 
1749     /**
1750      * Returns a copy of the pathToNames criterion. The
1751      * {@code X509Certificate} must not include name constraints that would
1752      * prohibit building a path to the specified names. If the value
1753      * returned is {@code null}, no pathToNames check will be performed.
1754      * &lt;p&gt;
1755      * If the value returned is not {@code null}, it is a
1756      * {@code Collection} with one
1757      * entry for each name to be included in the pathToNames
1758      * criterion. Each entry is a {@code List} whose first entry is an
1759      * {@code Integer} (the name type, 0-8) and whose second
1760      * entry is a {@code String} or a byte array (the name, in
1761      * string or ASN.1 DER encoded form, respectively).
1762      * There can be multiple names of the same type. Note that the
1763      * {@code Collection} returned may contain duplicate names (same
1764      * name and name type).
1765      * &lt;p&gt;
1766      * Each name in the {@code Collection}
1767      * may be specified either as a {@code String} or as an ASN.1 encoded
1768      * byte array. For more details about the formats used, see
1769      * {@link #addPathToName(int type, String name)
1770      * addPathToName(int type, String name)} and
1771      * {@link #addPathToName(int type, byte [] name)
1772      * addPathToName(int type, byte [] name)}.
1773      * &lt;p&gt;
1774      * Note that a deep copy is performed on the {@code Collection} to
1775      * protect against subsequent modifications.
1776      *
1777      * @return a {@code Collection} of names (or {@code null})
1778      * @see #setPathToNames
1779      */
1780     public Collection&lt;List&lt;?&gt;&gt; getPathToNames() {
1781         if (pathToNames == null) {
1782             return null;
1783         }
1784         return cloneNames(pathToNames);
1785     }
1786 
1787     /**
1788      * Return a printable representation of the {@code CertSelector}.
1789      *
1790      * @return a {@code String} describing the contents of the
1791      *         {@code CertSelector}
1792      */
1793     public String toString() {
1794         StringBuilder sb = new StringBuilder();
1795         sb.append(&quot;X509CertSelector: [\n&quot;);
1796         if (x509Cert != null) {
1797             sb.append(&quot;  Certificate: &quot; + x509Cert.toString() + &quot;\n&quot;);
1798         }
1799         if (serialNumber != null) {
1800             sb.append(&quot;  Serial Number: &quot; + serialNumber.toString() + &quot;\n&quot;);
1801         }
1802         if (issuer != null) {
1803             sb.append(&quot;  Issuer: &quot; + getIssuerAsString() + &quot;\n&quot;);
1804         }
1805         if (subject != null) {
1806             sb.append(&quot;  Subject: &quot; + getSubjectAsString() + &quot;\n&quot;);
1807         }
1808         sb.append(&quot;  matchAllSubjectAltNames flag: &quot;
1809                   + String.valueOf(matchAllSubjectAltNames) + &quot;\n&quot;);
1810         if (subjectAlternativeNames != null) {
1811             sb.append(&quot;  SubjectAlternativeNames:\n&quot;);
1812             Iterator&lt;List&lt;?&gt;&gt; i = subjectAlternativeNames.iterator();
1813             while (i.hasNext()) {
1814                 List&lt;?&gt; list = i.next();
1815                 sb.append(&quot;    type &quot; + list.get(0) +
1816                           &quot;, name &quot; + list.get(1) + &quot;\n&quot;);
1817             }
1818         }
1819         if (subjectKeyID != null) {
1820             HexDumpEncoder enc = new HexDumpEncoder();
1821             sb.append(&quot;  Subject Key Identifier: &quot; +
1822                       enc.encodeBuffer(subjectKeyID) + &quot;\n&quot;);
1823         }
1824         if (authorityKeyID != null) {
1825             HexDumpEncoder enc = new HexDumpEncoder();
1826             sb.append(&quot;  Authority Key Identifier: &quot; +
1827                       enc.encodeBuffer(authorityKeyID) + &quot;\n&quot;);
1828         }
1829         if (certificateValid != null) {
1830             sb.append(&quot;  Certificate Valid: &quot; +
1831                       certificateValid.toString() + &quot;\n&quot;);
1832         }
1833         if (privateKeyValid != null) {
1834             sb.append(&quot;  Private Key Valid: &quot; +
1835                       privateKeyValid.toString() + &quot;\n&quot;);
1836         }
1837         if (subjectPublicKeyAlgID != null) {
1838             sb.append(&quot;  Subject Public Key AlgID: &quot; +
1839                       subjectPublicKeyAlgID.toString() + &quot;\n&quot;);
1840         }
1841         if (subjectPublicKey != null) {
1842             sb.append(&quot;  Subject Public Key: &quot; +
1843                       subjectPublicKey.toString() + &quot;\n&quot;);
1844         }
1845         if (keyUsage != null) {
1846             sb.append(&quot;  Key Usage: &quot; + keyUsageToString(keyUsage) + &quot;\n&quot;);
1847         }
1848         if (keyPurposeSet != null) {
1849             sb.append(&quot;  Extended Key Usage: &quot; +
1850                       keyPurposeSet.toString() + &quot;\n&quot;);
1851         }
1852         if (policy != null) {
1853             sb.append(&quot;  Policy: &quot; + policy.toString() + &quot;\n&quot;);
1854         }
1855         if (pathToGeneralNames != null) {
1856             sb.append(&quot;  Path to names:\n&quot;);
1857             Iterator&lt;GeneralNameInterface&gt; i = pathToGeneralNames.iterator();
1858             while (i.hasNext()) {
1859                 sb.append(&quot;    &quot; + i.next() + &quot;\n&quot;);
1860             }
1861         }
1862         sb.append(&quot;]&quot;);
1863         return sb.toString();
1864     }
1865 
1866     // Copied from sun.security.x509.KeyUsageExtension
1867     // (without calling the superclass)
1868     /**
1869      * Returns a printable representation of the KeyUsage.
1870      */
1871     private static String keyUsageToString(boolean[] k) {
1872         String s = &quot;KeyUsage [\n&quot;;
1873         try {
1874             if (k[0]) {
1875                 s += &quot;  DigitalSignature\n&quot;;
1876             }
1877             if (k[1]) {
1878                 s += &quot;  Non_repudiation\n&quot;;
1879             }
1880             if (k[2]) {
1881                 s += &quot;  Key_Encipherment\n&quot;;
1882             }
1883             if (k[3]) {
1884                 s += &quot;  Data_Encipherment\n&quot;;
1885             }
1886             if (k[4]) {
1887                 s += &quot;  Key_Agreement\n&quot;;
1888             }
1889             if (k[5]) {
1890                 s += &quot;  Key_CertSign\n&quot;;
1891             }
1892             if (k[6]) {
1893                 s += &quot;  Crl_Sign\n&quot;;
1894             }
1895             if (k[7]) {
1896                 s += &quot;  Encipher_Only\n&quot;;
1897             }
1898             if (k[8]) {
1899                 s += &quot;  Decipher_Only\n&quot;;
1900             }
1901         } catch (ArrayIndexOutOfBoundsException ex) {}
1902 
1903         s += &quot;]\n&quot;;
1904 
1905         return (s);
1906     }
1907 
1908     /**
1909      * Returns an Extension object given any X509Certificate and extension oid.
1910      * Throw an {@code IOException} if the extension byte value is
1911      * malformed.
1912      *
1913      * @param cert a {@code X509Certificate}
1914      * @param extId an {@code integer} which specifies the extension index.
1915      * Currently, the supported extensions are as follows:
1916      * index 0 - PrivateKeyUsageExtension
1917      * index 1 - SubjectAlternativeNameExtension
1918      * index 2 - NameConstraintsExtension
1919      * index 3 - CertificatePoliciesExtension
1920      * index 4 - ExtendedKeyUsageExtension
1921      * @return an {@code Extension} object whose real type is as specified
1922      * by the extension oid.
1923      * @throws IOException if cannot construct the {@code Extension}
1924      * object with the extension encoding retrieved from the passed in
1925      * {@code X509Certificate}.
1926      */
<a name="2" id="anc2"></a><span class="line-modified">1927     private static Extension getExtensionObject(X509Certificate cert, KnownOIDs extId)</span>
1928             throws IOException {
1929         if (cert instanceof X509CertImpl) {
<a name="3" id="anc3"></a><span class="line-modified">1930             X509CertImpl impl = (X509CertImpl) cert;</span>
1931             switch (extId) {
<a name="4" id="anc4"></a><span class="line-modified">1932                 case PrivateKeyUsage:</span>
<span class="line-modified">1933                     return impl.getPrivateKeyUsageExtension();</span>
<span class="line-modified">1934                 case SubjectAlternativeName:</span>
<span class="line-modified">1935                     return impl.getSubjectAlternativeNameExtension();</span>
<span class="line-modified">1936                 case NameConstraints:</span>
<span class="line-modified">1937                     return impl.getNameConstraintsExtension();</span>
<span class="line-modified">1938                 case CertificatePolicies:</span>
<span class="line-modified">1939                     return impl.getCertificatePoliciesExtension();</span>
<span class="line-modified">1940                 case extendedKeyUsage:</span>
<span class="line-modified">1941                     return impl.getExtendedKeyUsageExtension();</span>
<span class="line-modified">1942                 default:</span>
<span class="line-modified">1943                     return null;</span>
1944             }
1945         }
<a name="5" id="anc5"></a><span class="line-modified">1946         byte[] rawExtVal = cert.getExtensionValue(extId.value());</span>
1947         if (rawExtVal == null) {
1948             return null;
1949         }
1950         DerInputStream in = new DerInputStream(rawExtVal);
1951         byte[] encoded = in.getOctetString();
1952         switch (extId) {
<a name="6" id="anc6"></a><span class="line-modified">1953             case PrivateKeyUsage:</span>
<span class="line-modified">1954                 try {</span>
<span class="line-modified">1955                     return new PrivateKeyUsageExtension(FALSE, encoded);</span>
<span class="line-modified">1956                 } catch (CertificateException ex) {</span>
<span class="line-modified">1957                     throw new IOException(ex.getMessage());</span>
<span class="line-modified">1958                 }</span>
<span class="line-modified">1959             case SubjectAlternativeName:</span>
<span class="line-modified">1960                 return new SubjectAlternativeNameExtension(FALSE, encoded);</span>
<span class="line-modified">1961             case NameConstraints:</span>
<span class="line-modified">1962                 return new NameConstraintsExtension(FALSE, encoded);</span>
<span class="line-modified">1963             case CertificatePolicies:</span>
<span class="line-modified">1964                 return new CertificatePoliciesExtension(FALSE, encoded);</span>
<span class="line-modified">1965             case extendedKeyUsage:</span>
<span class="line-modified">1966                 return new ExtendedKeyUsageExtension(FALSE, encoded);</span>
<span class="line-modified">1967             default:</span>
<span class="line-modified">1968                 return null;</span>
1969         }
1970     }
1971 
1972     /**
1973      * Decides whether a {@code Certificate} should be selected.
1974      *
1975      * @param cert the {@code Certificate} to be checked
1976      * @return {@code true} if the {@code Certificate} should be
1977      *         selected, {@code false} otherwise
1978      */
1979     public boolean match(Certificate cert) {
1980         if (!(cert instanceof X509Certificate)) {
1981             return false;
1982         }
1983         X509Certificate xcert = (X509Certificate)cert;
1984 
1985         if (debug != null) {
1986             debug.println(&quot;X509CertSelector.match(SN: &quot;
1987                 + (xcert.getSerialNumber()).toString(16) + &quot;\n  Issuer: &quot;
1988                 + xcert.getIssuerDN() + &quot;\n  Subject: &quot; + xcert.getSubjectDN()
1989                 + &quot;)&quot;);
1990         }
1991 
1992         /* match on X509Certificate */
1993         if (x509Cert != null) {
1994             if (!x509Cert.equals(xcert)) {
1995                 if (debug != null) {
1996                     debug.println(&quot;X509CertSelector.match: &quot;
1997                         + &quot;certs don&#39;t match&quot;);
1998                 }
1999                 return false;
2000             }
2001         }
2002 
2003         /* match on serial number */
2004         if (serialNumber != null) {
2005             if (!serialNumber.equals(xcert.getSerialNumber())) {
2006                 if (debug != null) {
2007                     debug.println(&quot;X509CertSelector.match: &quot;
2008                         + &quot;serial numbers don&#39;t match&quot;);
2009                 }
2010                 return false;
2011             }
2012         }
2013 
2014         /* match on issuer name */
2015         if (issuer != null) {
2016             if (!issuer.equals(xcert.getIssuerX500Principal())) {
2017                 if (debug != null) {
2018                     debug.println(&quot;X509CertSelector.match: &quot;
2019                         + &quot;issuer DNs don&#39;t match&quot;);
2020                 }
2021                 return false;
2022             }
2023         }
2024 
2025         /* match on subject name */
2026         if (subject != null) {
2027             if (!subject.equals(xcert.getSubjectX500Principal())) {
2028                 if (debug != null) {
2029                     debug.println(&quot;X509CertSelector.match: &quot;
2030                         + &quot;subject DNs don&#39;t match&quot;);
2031                 }
2032                 return false;
2033             }
2034         }
2035 
2036         /* match on certificate validity range */
2037         if (certificateValid != null) {
2038             try {
2039                 xcert.checkValidity(certificateValid);
2040             } catch (CertificateException e) {
2041                 if (debug != null) {
2042                     debug.println(&quot;X509CertSelector.match: &quot;
2043                         + &quot;certificate not within validity period&quot;);
2044                 }
2045                 return false;
2046             }
2047         }
2048 
2049         /* match on subject public key */
2050         if (subjectPublicKeyBytes != null) {
2051             byte[] certKey = xcert.getPublicKey().getEncoded();
2052             if (!Arrays.equals(subjectPublicKeyBytes, certKey)) {
2053                 if (debug != null) {
2054                     debug.println(&quot;X509CertSelector.match: &quot;
2055                         + &quot;subject public keys don&#39;t match&quot;);
2056                 }
2057                 return false;
2058             }
2059         }
2060 
2061         boolean result = matchBasicConstraints(xcert)
2062                       &amp;&amp; matchKeyUsage(xcert)
2063                       &amp;&amp; matchExtendedKeyUsage(xcert)
2064                       &amp;&amp; matchSubjectKeyID(xcert)
2065                       &amp;&amp; matchAuthorityKeyID(xcert)
2066                       &amp;&amp; matchPrivateKeyValid(xcert)
2067                       &amp;&amp; matchSubjectPublicKeyAlgID(xcert)
2068                       &amp;&amp; matchPolicy(xcert)
2069                       &amp;&amp; matchSubjectAlternativeNames(xcert)
2070                       &amp;&amp; matchPathToNames(xcert)
2071                       &amp;&amp; matchNameConstraints(xcert);
2072 
2073         if (result &amp;&amp; (debug != null)) {
2074             debug.println(&quot;X509CertSelector.match returning: true&quot;);
2075         }
2076         return result;
2077     }
2078 
2079     /* match on subject key identifier extension value */
2080     private boolean matchSubjectKeyID(X509Certificate xcert) {
2081         if (subjectKeyID == null) {
2082             return true;
2083         }
2084         try {
2085             byte[] extVal = xcert.getExtensionValue(&quot;2.5.29.14&quot;);
2086             if (extVal == null) {
2087                 if (debug != null) {
2088                     debug.println(&quot;X509CertSelector.match: &quot;
2089                         + &quot;no subject key ID extension&quot;);
2090                 }
2091                 return false;
2092             }
2093             DerInputStream in = new DerInputStream(extVal);
2094             byte[] certSubjectKeyID = in.getOctetString();
2095             if (certSubjectKeyID == null ||
2096                     !Arrays.equals(subjectKeyID, certSubjectKeyID)) {
2097                 if (debug != null) {
2098                     debug.println(&quot;X509CertSelector.match: subject key IDs &quot; +
2099                         &quot;don&#39;t match\nX509CertSelector.match: subjectKeyID: &quot; +
2100                         Arrays.toString(subjectKeyID) +
2101                         &quot;\nX509CertSelector.match: certSubjectKeyID: &quot; +
2102                         Arrays.toString(certSubjectKeyID));
2103                 }
2104                 return false;
2105             }
2106         } catch (IOException ex) {
2107             if (debug != null) {
2108                 debug.println(&quot;X509CertSelector.match: &quot;
2109                     + &quot;exception in subject key ID check&quot;);
2110             }
2111             return false;
2112         }
2113         return true;
2114     }
2115 
2116     /* match on authority key identifier extension value */
2117     private boolean matchAuthorityKeyID(X509Certificate xcert) {
2118         if (authorityKeyID == null) {
2119             return true;
2120         }
2121         try {
2122             byte[] extVal = xcert.getExtensionValue(&quot;2.5.29.35&quot;);
2123             if (extVal == null) {
2124                 if (debug != null) {
2125                     debug.println(&quot;X509CertSelector.match: &quot;
2126                         + &quot;no authority key ID extension&quot;);
2127                 }
2128                 return false;
2129             }
2130             DerInputStream in = new DerInputStream(extVal);
2131             byte[] certAuthKeyID = in.getOctetString();
2132             if (certAuthKeyID == null ||
2133                     !Arrays.equals(authorityKeyID, certAuthKeyID)) {
2134                 if (debug != null) {
2135                     debug.println(&quot;X509CertSelector.match: &quot;
2136                         + &quot;authority key IDs don&#39;t match&quot;);
2137                 }
2138                 return false;
2139             }
2140         } catch (IOException ex) {
2141             if (debug != null) {
2142                 debug.println(&quot;X509CertSelector.match: &quot;
2143                     + &quot;exception in authority key ID check&quot;);
2144             }
2145             return false;
2146         }
2147         return true;
2148     }
2149 
2150     /* match on private key usage range */
2151     private boolean matchPrivateKeyValid(X509Certificate xcert) {
2152         if (privateKeyValid == null) {
2153             return true;
2154         }
2155         PrivateKeyUsageExtension ext = null;
2156         try {
2157             ext = (PrivateKeyUsageExtension)
<a name="7" id="anc7"></a><span class="line-modified">2158                 getExtensionObject(xcert, KnownOIDs.PrivateKeyUsage);</span>
2159             if (ext != null) {
2160                 ext.valid(privateKeyValid);
2161             }
2162         } catch (CertificateExpiredException e1) {
2163             if (debug != null) {
2164                 String time = &quot;n/a&quot;;
2165                 try {
2166                     Date notAfter = ext.get(PrivateKeyUsageExtension.NOT_AFTER);
2167                     time = notAfter.toString();
2168                 } catch (CertificateException ex) {
2169                     // not able to retrieve notAfter value
2170                 }
2171                 debug.println(&quot;X509CertSelector.match: private key usage not &quot;
2172                     + &quot;within validity date; ext.NOT_After: &quot;
2173                     + time + &quot;; X509CertSelector: &quot;
2174                     + this.toString());
2175                 e1.printStackTrace();
2176             }
2177             return false;
2178         } catch (CertificateNotYetValidException e2) {
2179             if (debug != null) {
2180                 String time = &quot;n/a&quot;;
2181                 try {
2182                     Date notBefore = ext.get(PrivateKeyUsageExtension.NOT_BEFORE);
2183                     time = notBefore.toString();
2184                 } catch (CertificateException ex) {
2185                     // not able to retrieve notBefore value
2186                 }
2187                 debug.println(&quot;X509CertSelector.match: private key usage not &quot;
2188                     + &quot;within validity date; ext.NOT_BEFORE: &quot;
2189                     + time + &quot;; X509CertSelector: &quot;
2190                     + this.toString());
2191                 e2.printStackTrace();
2192             }
2193             return false;
2194         } catch (IOException e4) {
2195             if (debug != null) {
2196                 debug.println(&quot;X509CertSelector.match: IOException in &quot;
2197                     + &quot;private key usage check; X509CertSelector: &quot;
2198                     + this.toString());
2199                 e4.printStackTrace();
2200             }
2201             return false;
2202         }
2203         return true;
2204     }
2205 
2206     /* match on subject public key algorithm OID */
2207     private boolean matchSubjectPublicKeyAlgID(X509Certificate xcert) {
2208         if (subjectPublicKeyAlgID == null) {
2209             return true;
2210         }
2211         try {
2212             byte[] encodedKey = xcert.getPublicKey().getEncoded();
2213             DerValue val = new DerValue(encodedKey);
2214             if (val.tag != DerValue.tag_Sequence) {
2215                 throw new IOException(&quot;invalid key format&quot;);
2216             }
2217 
2218             AlgorithmId algID = AlgorithmId.parse(val.data.getDerValue());
2219             if (debug != null) {
2220                 debug.println(&quot;X509CertSelector.match: subjectPublicKeyAlgID = &quot;
2221                     + subjectPublicKeyAlgID + &quot;, xcert subjectPublicKeyAlgID = &quot;
2222                     + algID.getOID());
2223             }
2224             if (!subjectPublicKeyAlgID.equals(algID.getOID())) {
2225                 if (debug != null) {
2226                     debug.println(&quot;X509CertSelector.match: &quot;
2227                         + &quot;subject public key alg IDs don&#39;t match&quot;);
2228                 }
2229                 return false;
2230             }
2231         } catch (IOException e5) {
2232             if (debug != null) {
2233                 debug.println(&quot;X509CertSelector.match: IOException in subject &quot;
2234                     + &quot;public key algorithm OID check&quot;);
2235             }
2236             return false;
2237         }
2238         return true;
2239     }
2240 
2241     /* match on key usage extension value */
2242     private boolean matchKeyUsage(X509Certificate xcert) {
2243         if (keyUsage == null) {
2244             return true;
2245         }
2246         boolean[] certKeyUsage = xcert.getKeyUsage();
2247         if (certKeyUsage != null) {
2248             for (int keyBit = 0; keyBit &lt; keyUsage.length; keyBit++) {
2249                 if (keyUsage[keyBit] &amp;&amp;
2250                     ((keyBit &gt;= certKeyUsage.length) || !certKeyUsage[keyBit])) {
2251                     if (debug != null) {
2252                         debug.println(&quot;X509CertSelector.match: &quot;
2253                             + &quot;key usage bits don&#39;t match&quot;);
2254                     }
2255                     return false;
2256                 }
2257             }
2258         }
2259         return true;
2260     }
2261 
2262     /* match on extended key usage purpose OIDs */
2263     private boolean matchExtendedKeyUsage(X509Certificate xcert) {
2264         if ((keyPurposeSet == null) || keyPurposeSet.isEmpty()) {
2265             return true;
2266         }
2267         try {
2268             ExtendedKeyUsageExtension ext =
2269                 (ExtendedKeyUsageExtension)getExtensionObject(xcert,
<a name="8" id="anc8"></a><span class="line-modified">2270                                                 KnownOIDs.extendedKeyUsage);</span>
2271             if (ext != null) {
2272                 Vector&lt;ObjectIdentifier&gt; certKeyPurposeVector =
2273                     ext.get(ExtendedKeyUsageExtension.USAGES);
2274                 if (!certKeyPurposeVector.contains(ANY_EXTENDED_KEY_USAGE)
2275                         &amp;&amp; !certKeyPurposeVector.containsAll(keyPurposeOIDSet)) {
2276                     if (debug != null) {
2277                         debug.println(&quot;X509CertSelector.match: cert failed &quot;
2278                             + &quot;extendedKeyUsage criterion&quot;);
2279                     }
2280                     return false;
2281                 }
2282             }
2283         } catch (IOException ex) {
2284             if (debug != null) {
2285                 debug.println(&quot;X509CertSelector.match: &quot;
2286                     + &quot;IOException in extended key usage check&quot;);
2287             }
2288             return false;
2289         }
2290         return true;
2291     }
2292 
2293     /* match on subject alternative name extension names */
2294     private boolean matchSubjectAlternativeNames(X509Certificate xcert) {
2295         if ((subjectAlternativeNames == null) || subjectAlternativeNames.isEmpty()) {
2296             return true;
2297         }
2298         try {
2299             SubjectAlternativeNameExtension sanExt =
<a name="9" id="anc9"></a><span class="line-modified">2300                 (SubjectAlternativeNameExtension) getExtensionObject(</span>
<span class="line-modified">2301                         xcert, KnownOIDs.SubjectAlternativeName);</span>
2302             if (sanExt == null) {
2303                 if (debug != null) {
2304                   debug.println(&quot;X509CertSelector.match: &quot;
2305                       + &quot;no subject alternative name extension&quot;);
2306                 }
2307                 return false;
2308             }
2309             GeneralNames certNames =
2310                     sanExt.get(SubjectAlternativeNameExtension.SUBJECT_NAME);
2311             Iterator&lt;GeneralNameInterface&gt; i =
2312                                 subjectAlternativeGeneralNames.iterator();
2313             while (i.hasNext()) {
2314                 GeneralNameInterface matchName = i.next();
2315                 boolean found = false;
2316                 for (Iterator&lt;GeneralName&gt; t = certNames.iterator();
2317                                                 t.hasNext() &amp;&amp; !found; ) {
2318                     GeneralNameInterface certName = (t.next()).getName();
2319                     found = certName.equals(matchName);
2320                 }
2321                 if (!found &amp;&amp; (matchAllSubjectAltNames || !i.hasNext())) {
2322                     if (debug != null) {
2323                       debug.println(&quot;X509CertSelector.match: subject alternative &quot;
2324                           + &quot;name &quot; + matchName + &quot; not found&quot;);
2325                     }
2326                     return false;
2327                 } else if (found &amp;&amp; !matchAllSubjectAltNames) {
2328                     break;
2329                 }
2330             }
2331         } catch (IOException ex) {
2332             if (debug != null)
2333                 debug.println(&quot;X509CertSelector.match: IOException in subject &quot;
2334                     + &quot;alternative name check&quot;);
2335             return false;
2336         }
2337         return true;
2338     }
2339 
2340     /* match on name constraints */
2341     private boolean matchNameConstraints(X509Certificate xcert) {
2342         if (nc == null) {
2343             return true;
2344         }
2345         try {
2346             if (!nc.verify(xcert)) {
2347                 if (debug != null) {
2348                     debug.println(&quot;X509CertSelector.match: &quot;
2349                         + &quot;name constraints not satisfied&quot;);
2350                 }
2351                 return false;
2352             }
2353         } catch (IOException e) {
2354             if (debug != null) {
2355                 debug.println(&quot;X509CertSelector.match: &quot;
2356                     + &quot;IOException in name constraints check&quot;);
2357             }
2358             return false;
2359         }
2360         return true;
2361     }
2362 
2363     /* match on policy OIDs */
2364     private boolean matchPolicy(X509Certificate xcert) {
2365         if (policy == null) {
2366             return true;
2367         }
2368         try {
2369             CertificatePoliciesExtension ext = (CertificatePoliciesExtension)
<a name="10" id="anc10"></a><span class="line-modified">2370                 getExtensionObject(xcert, KnownOIDs.CertificatePolicies);</span>
2371             if (ext == null) {
2372                 if (debug != null) {
2373                   debug.println(&quot;X509CertSelector.match: &quot;
2374                       + &quot;no certificate policy extension&quot;);
2375                 }
2376                 return false;
2377             }
2378             List&lt;PolicyInformation&gt; policies = ext.get(CertificatePoliciesExtension.POLICIES);
2379             /*
2380              * Convert the Vector of PolicyInformation to a Vector
2381              * of CertificatePolicyIds for easier comparison.
2382              */
2383             List&lt;CertificatePolicyId&gt; policyIDs = new ArrayList&lt;&gt;(policies.size());
2384             for (PolicyInformation info : policies) {
2385                 policyIDs.add(info.getPolicyIdentifier());
2386             }
2387             if (policy != null) {
2388                 boolean foundOne = false;
2389                 /*
2390                  * if the user passes in an empty policy Set, then
2391                  * we just want to make sure that the candidate certificate
2392                  * has some policy OID in its CertPoliciesExtension
2393                  */
2394                 if (policy.getCertPolicyIds().isEmpty()) {
2395                     if (policyIDs.isEmpty()) {
2396                         if (debug != null) {
2397                             debug.println(&quot;X509CertSelector.match: &quot;
2398                                 + &quot;cert failed policyAny criterion&quot;);
2399                         }
2400                         return false;
2401                     }
2402                 } else {
2403                     for (CertificatePolicyId id : policy.getCertPolicyIds()) {
2404                         if (policyIDs.contains(id)) {
2405                             foundOne = true;
2406                             break;
2407                         }
2408                     }
2409                     if (!foundOne) {
2410                         if (debug != null) {
2411                             debug.println(&quot;X509CertSelector.match: &quot;
2412                                 + &quot;cert failed policyAny criterion&quot;);
2413                         }
2414                         return false;
2415                     }
2416                 }
2417             }
2418         } catch (IOException ex) {
2419             if (debug != null) {
2420                 debug.println(&quot;X509CertSelector.match: &quot;
2421                     + &quot;IOException in certificate policy ID check&quot;);
2422             }
2423             return false;
2424         }
2425         return true;
2426     }
2427 
2428     /* match on pathToNames */
2429     private boolean matchPathToNames(X509Certificate xcert) {
2430         if (pathToGeneralNames == null) {
2431             return true;
2432         }
2433         try {
2434             NameConstraintsExtension ext = (NameConstraintsExtension)
<a name="11" id="anc11"></a><span class="line-modified">2435                 getExtensionObject(xcert, KnownOIDs.NameConstraints);</span>
2436             if (ext == null) {
2437                 return true;
2438             }
2439             if ((debug != null) &amp;&amp; Debug.isOn(&quot;certpath&quot;)) {
2440                 debug.println(&quot;X509CertSelector.match pathToNames:\n&quot;);
2441                 Iterator&lt;GeneralNameInterface&gt; i =
2442                                         pathToGeneralNames.iterator();
2443                 while (i.hasNext()) {
2444                     debug.println(&quot;    &quot; + i.next() + &quot;\n&quot;);
2445                 }
2446             }
2447 
2448             GeneralSubtrees permitted =
2449                     ext.get(NameConstraintsExtension.PERMITTED_SUBTREES);
2450             GeneralSubtrees excluded =
2451                     ext.get(NameConstraintsExtension.EXCLUDED_SUBTREES);
2452             if (excluded != null) {
2453                 if (matchExcluded(excluded) == false) {
2454                     return false;
2455                 }
2456             }
2457             if (permitted != null) {
2458                 if (matchPermitted(permitted) == false) {
2459                     return false;
2460                 }
2461             }
2462         } catch (IOException ex) {
2463             if (debug != null) {
2464                 debug.println(&quot;X509CertSelector.match: &quot;
2465                     + &quot;IOException in name constraints check&quot;);
2466             }
2467             return false;
2468         }
2469         return true;
2470     }
2471 
2472     private boolean matchExcluded(GeneralSubtrees excluded) {
2473         /*
2474          * Enumerate through excluded and compare each entry
2475          * to all pathToNames. If any pathToName is within any of the
2476          * subtrees listed in excluded, return false.
2477          */
2478         for (Iterator&lt;GeneralSubtree&gt; t = excluded.iterator(); t.hasNext(); ) {
2479             GeneralSubtree tree = t.next();
2480             GeneralNameInterface excludedName = tree.getName().getName();
2481             Iterator&lt;GeneralNameInterface&gt; i = pathToGeneralNames.iterator();
2482             while (i.hasNext()) {
2483                 GeneralNameInterface pathToName = i.next();
2484                 if (excludedName.getType() == pathToName.getType()) {
2485                     switch (pathToName.constrains(excludedName)) {
2486                     case GeneralNameInterface.NAME_WIDENS:
2487                     case GeneralNameInterface.NAME_MATCH:
2488                         if (debug != null) {
2489                             debug.println(&quot;X509CertSelector.match: name constraints &quot;
2490                                 + &quot;inhibit path to specified name&quot;);
2491                             debug.println(&quot;X509CertSelector.match: excluded name: &quot; +
2492                                 pathToName);
2493                         }
2494                         return false;
2495                     default:
2496                     }
2497                 }
2498             }
2499         }
2500         return true;
2501     }
2502 
2503     private boolean matchPermitted(GeneralSubtrees permitted) {
2504         /*
2505          * Enumerate through pathToNames, checking that each pathToName
2506          * is in at least one of the subtrees listed in permitted.
2507          * If not, return false. However, if no subtrees of a given type
2508          * are listed, all names of that type are permitted.
2509          */
2510         Iterator&lt;GeneralNameInterface&gt; i = pathToGeneralNames.iterator();
2511         while (i.hasNext()) {
2512             GeneralNameInterface pathToName = i.next();
2513             Iterator&lt;GeneralSubtree&gt; t = permitted.iterator();
2514             boolean permittedNameFound = false;
2515             boolean nameTypeFound = false;
2516             String names = &quot;&quot;;
2517             while (t.hasNext() &amp;&amp; !permittedNameFound) {
2518                 GeneralSubtree tree = t.next();
2519                 GeneralNameInterface permittedName = tree.getName().getName();
2520                 if (permittedName.getType() == pathToName.getType()) {
2521                     nameTypeFound = true;
2522                     names = names + &quot;  &quot; + permittedName;
2523                     switch (pathToName.constrains(permittedName)) {
2524                     case GeneralNameInterface.NAME_WIDENS:
2525                     case GeneralNameInterface.NAME_MATCH:
2526                         permittedNameFound = true;
2527                         break;
2528                     default:
2529                     }
2530                 }
2531             }
2532             if (!permittedNameFound &amp;&amp; nameTypeFound) {
2533                 if (debug != null)
2534                   debug.println(&quot;X509CertSelector.match: &quot; +
2535                             &quot;name constraints inhibit path to specified name; &quot; +
2536                             &quot;permitted names of type &quot; + pathToName.getType() +
2537                             &quot;: &quot; + names);
2538                 return false;
2539             }
2540         }
2541         return true;
2542     }
2543 
2544     /* match on basic constraints */
2545     private boolean matchBasicConstraints(X509Certificate xcert) {
2546         if (basicConstraints == -1) {
2547             return true;
2548         }
2549         int maxPathLen = xcert.getBasicConstraints();
2550         if (basicConstraints == -2) {
2551             if (maxPathLen != -1) {
2552                 if (debug != null) {
2553                     debug.println(&quot;X509CertSelector.match: not an EE cert&quot;);
2554                 }
2555                 return false;
2556             }
2557         } else {
2558             if (maxPathLen &lt; basicConstraints) {
2559                 if (debug != null) {
2560                     debug.println(&quot;X509CertSelector.match: cert&#39;s maxPathLen &quot; +
2561                             &quot;is less than the min maxPathLen set by &quot; +
2562                             &quot;basicConstraints. &quot; +
2563                             &quot;(&quot; + maxPathLen + &quot; &lt; &quot; + basicConstraints + &quot;)&quot;);
2564                 }
2565                 return false;
2566             }
2567         }
2568         return true;
2569     }
2570 
2571     @SuppressWarnings(&quot;unchecked&quot;) // Safe casts assuming clone() works correctly
2572     private static &lt;T&gt; Set&lt;T&gt; cloneSet(Set&lt;T&gt; set) {
2573         if (set instanceof HashSet) {
2574             Object clone = ((HashSet&lt;T&gt;)set).clone();
2575             return (Set&lt;T&gt;)clone;
2576         } else {
2577             return new HashSet&lt;T&gt;(set);
2578         }
2579     }
2580 
2581     /**
2582      * Returns a copy of this object.
2583      *
2584      * @return the copy
2585      */
2586     public Object clone() {
2587         try {
2588             X509CertSelector copy = (X509CertSelector)super.clone();
2589             // Must clone these because addPathToName et al. modify them
2590             if (subjectAlternativeNames != null) {
2591                 copy.subjectAlternativeNames =
2592                         cloneSet(subjectAlternativeNames);
2593                 copy.subjectAlternativeGeneralNames =
2594                         cloneSet(subjectAlternativeGeneralNames);
2595             }
2596             if (pathToGeneralNames != null) {
2597                 copy.pathToNames = cloneSet(pathToNames);
2598                 copy.pathToGeneralNames = cloneSet(pathToGeneralNames);
2599             }
2600             return copy;
2601         } catch (CloneNotSupportedException e) {
2602             /* Cannot happen */
2603             throw new InternalError(e.toString(), e);
2604         }
2605     }
2606 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
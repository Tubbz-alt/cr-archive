<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jdeps/share/classes/com/sun/tools/javap/AttributeWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javap;
  27 
  28 import java.util.Collection;
  29 
  30 import com.sun.tools.classfile.AccessFlags;
  31 import com.sun.tools.classfile.AnnotationDefault_attribute;
  32 import com.sun.tools.classfile.Attribute;
  33 import com.sun.tools.classfile.Attributes;
  34 import com.sun.tools.classfile.BootstrapMethods_attribute;
  35 import com.sun.tools.classfile.CharacterRangeTable_attribute;
  36 import com.sun.tools.classfile.CharacterRangeTable_attribute.Entry;
  37 import com.sun.tools.classfile.Code_attribute;
  38 import com.sun.tools.classfile.CompilationID_attribute;
  39 import com.sun.tools.classfile.ConstantPool;
  40 import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;
  41 import com.sun.tools.classfile.ConstantPoolException;
  42 import com.sun.tools.classfile.ConstantValue_attribute;
  43 import com.sun.tools.classfile.DefaultAttribute;
  44 import com.sun.tools.classfile.Deprecated_attribute;
  45 import com.sun.tools.classfile.Descriptor;
  46 import com.sun.tools.classfile.Descriptor.InvalidDescriptor;
  47 import com.sun.tools.classfile.EnclosingMethod_attribute;
  48 import com.sun.tools.classfile.Exceptions_attribute;
  49 import com.sun.tools.classfile.InnerClasses_attribute;
  50 import com.sun.tools.classfile.InnerClasses_attribute.Info;
  51 import com.sun.tools.classfile.LineNumberTable_attribute;
  52 import com.sun.tools.classfile.LocalVariableTable_attribute;
  53 import com.sun.tools.classfile.LocalVariableTypeTable_attribute;
  54 import com.sun.tools.classfile.MethodParameters_attribute;
  55 import com.sun.tools.classfile.Module_attribute;
  56 import com.sun.tools.classfile.ModuleHashes_attribute;
  57 import com.sun.tools.classfile.ModuleMainClass_attribute;
  58 import com.sun.tools.classfile.ModulePackages_attribute;
  59 import com.sun.tools.classfile.ModuleResolution_attribute;
  60 import com.sun.tools.classfile.ModuleTarget_attribute;
  61 import com.sun.tools.classfile.NestHost_attribute;
  62 import com.sun.tools.classfile.NestMembers_attribute;
  63 import com.sun.tools.classfile.Record_attribute;
  64 import com.sun.tools.classfile.RuntimeInvisibleAnnotations_attribute;
  65 import com.sun.tools.classfile.RuntimeInvisibleParameterAnnotations_attribute;
  66 import com.sun.tools.classfile.RuntimeInvisibleTypeAnnotations_attribute;
  67 import com.sun.tools.classfile.RuntimeParameterAnnotations_attribute;
  68 import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;
  69 import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;
  70 import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;
  71 import com.sun.tools.classfile.Signature;
  72 import com.sun.tools.classfile.Signature_attribute;
  73 import com.sun.tools.classfile.SourceDebugExtension_attribute;
  74 import com.sun.tools.classfile.SourceFile_attribute;
  75 import com.sun.tools.classfile.SourceID_attribute;
  76 import com.sun.tools.classfile.StackMapTable_attribute;
  77 import com.sun.tools.classfile.StackMap_attribute;
  78 import com.sun.tools.classfile.Synthetic_attribute;
  79 import com.sun.tools.classfile.Type;
  80 
  81 import static com.sun.tools.classfile.AccessFlags.*;
  82 
  83 import com.sun.tools.javac.util.Assert;
  84 import com.sun.tools.javac.util.StringUtils;
  85 
  86 import java.util.stream.Collectors;
  87 import java.util.stream.IntStream;
  88 import java.util.stream.Stream;
  89 
  90 /*
  91  *  A writer for writing Attributes as text.
  92  *
  93  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  94  *  If you write code that depends on this, you do so at your own risk.
  95  *  This code and its internal interfaces are subject to change or
  96  *  deletion without notice.&lt;/b&gt;
  97  */
  98 public class AttributeWriter extends BasicWriter
  99         implements Attribute.Visitor&lt;Void,Void&gt;
 100 {
 101     public static AttributeWriter instance(Context context) {
 102         AttributeWriter instance = context.get(AttributeWriter.class);
 103         if (instance == null)
 104             instance = new AttributeWriter(context);
 105         return instance;
 106     }
 107 
 108     protected AttributeWriter(Context context) {
 109         super(context);
 110         context.put(AttributeWriter.class, this);
 111         annotationWriter = AnnotationWriter.instance(context);
 112         codeWriter = CodeWriter.instance(context);
 113         constantWriter = ConstantWriter.instance(context);
 114         options = Options.instance(context);
 115     }
 116 
 117     public void write(Object owner, Attribute attr, ConstantPool constant_pool) {
 118         if (attr != null) {
 119             Assert.checkNonNull(constant_pool);
 120             Assert.checkNonNull(owner);
 121             this.constant_pool = constant_pool;
 122             this.owner = owner;
 123             attr.accept(this, null);
 124         }
 125     }
 126 
 127     public void write(Object owner, Attributes attrs, ConstantPool constant_pool) {
 128         if (attrs != null) {
 129             Assert.checkNonNull(constant_pool);
 130             Assert.checkNonNull(owner);
 131             this.constant_pool = constant_pool;
 132             this.owner = owner;
 133             for (Attribute attr: attrs)
 134                 attr.accept(this, null);
 135         }
 136     }
 137 
 138     @Override
 139     public Void visitDefault(DefaultAttribute attr, Void ignore) {
 140         byte[] data = attr.info;
 141         int i = 0;
 142         int j = 0;
 143         print(&quot;  &quot;);
 144         try {
 145             print(attr.getName(constant_pool));
 146         } catch (ConstantPoolException e) {
 147             report(e);
 148             print(&quot;attribute name = #&quot; + attr.attribute_name_index);
 149         }
 150         print(&quot;: &quot;);
 151         print(&quot;length = 0x&quot; + toHex(attr.info.length));
 152         if (attr.reason != null) {
 153             print(&quot; (&quot; + attr.reason + &quot;)&quot;);
 154         }
 155         println();
 156 
 157         print(&quot;   &quot;);
 158 
 159         while (i &lt; data.length) {
 160             print(toHex(data[i], 2));
 161 
 162             j++;
 163             if (j == 16) {
 164                 println();
 165                 print(&quot;   &quot;);
 166                 j = 0;
 167             } else {
 168                 print(&quot; &quot;);
 169             }
 170             i++;
 171         }
 172         println();
 173         return null;
 174     }
 175 
 176     @Override
 177     public Void visitAnnotationDefault(AnnotationDefault_attribute attr, Void ignore) {
 178         println(&quot;AnnotationDefault:&quot;);
 179         indent(+1);
 180         print(&quot;default_value: &quot;);
 181         annotationWriter.write(attr.default_value);
 182         indent(-1);
 183         println();
 184         return null;
 185     }
 186 
 187     @Override
 188     public Void visitBootstrapMethods(BootstrapMethods_attribute attr, Void p) {
 189         println(Attribute.BootstrapMethods + &quot;:&quot;);
 190         for (int i = 0; i &lt; attr.bootstrap_method_specifiers.length ; i++) {
 191             BootstrapMethods_attribute.BootstrapMethodSpecifier bsm = attr.bootstrap_method_specifiers[i];
 192             indent(+1);
 193             print(i + &quot;: #&quot; + bsm.bootstrap_method_ref + &quot; &quot;);
 194             println(constantWriter.stringValue(bsm.bootstrap_method_ref));
 195             indent(+1);
 196             println(&quot;Method arguments:&quot;);
 197             indent(+1);
 198             for (int j = 0; j &lt; bsm.bootstrap_arguments.length; j++) {
 199                 print(&quot;#&quot; + bsm.bootstrap_arguments[j] + &quot; &quot;);
 200                 println(constantWriter.stringValue(bsm.bootstrap_arguments[j]));
 201             }
 202             indent(-3);
 203         }
 204         return null;
 205     }
 206 
 207     @Override
 208     public Void visitCharacterRangeTable(CharacterRangeTable_attribute attr, Void ignore) {
 209         println(&quot;CharacterRangeTable:&quot;);
 210         indent(+1);
 211         for (Entry e : attr.character_range_table) {
 212             print(String.format(&quot;    %2d, %2d, %6x, %6x, %4x&quot;,
 213                     e.start_pc, e.end_pc,
 214                     e.character_range_start, e.character_range_end,
 215                     e.flags));
 216             tab();
 217             print(String.format(&quot;// %2d, %2d, %4d:%02d, %4d:%02d&quot;,
 218                     e.start_pc, e.end_pc,
 219                     (e.character_range_start &gt;&gt; 10), (e.character_range_start &amp; 0x3ff),
 220                     (e.character_range_end &gt;&gt; 10), (e.character_range_end &amp; 0x3ff)));
 221             if ((e.flags &amp; CharacterRangeTable_attribute.CRT_STATEMENT) != 0)
 222                 print(&quot;, statement&quot;);
 223             if ((e.flags &amp; CharacterRangeTable_attribute.CRT_BLOCK) != 0)
 224                 print(&quot;, block&quot;);
 225             if ((e.flags &amp; CharacterRangeTable_attribute.CRT_ASSIGNMENT) != 0)
 226                 print(&quot;, assignment&quot;);
 227             if ((e.flags &amp; CharacterRangeTable_attribute.CRT_FLOW_CONTROLLER) != 0)
 228                 print(&quot;, flow-controller&quot;);
 229             if ((e.flags &amp; CharacterRangeTable_attribute.CRT_FLOW_TARGET) != 0)
 230                 print(&quot;, flow-target&quot;);
 231             if ((e.flags &amp; CharacterRangeTable_attribute.CRT_INVOKE) != 0)
 232                 print(&quot;, invoke&quot;);
 233             if ((e.flags &amp; CharacterRangeTable_attribute.CRT_CREATE) != 0)
 234                 print(&quot;, create&quot;);
 235             if ((e.flags &amp; CharacterRangeTable_attribute.CRT_BRANCH_TRUE) != 0)
 236                 print(&quot;, branch-true&quot;);
 237             if ((e.flags &amp; CharacterRangeTable_attribute.CRT_BRANCH_FALSE) != 0)
 238                 print(&quot;, branch-false&quot;);
 239             println();
 240         }
 241         indent(-1);
 242         return null;
 243     }
 244 
 245     @Override
 246     public Void visitCode(Code_attribute attr, Void ignore) {
 247         codeWriter.write(attr, constant_pool);
 248         return null;
 249     }
 250 
 251     @Override
 252     public Void visitCompilationID(CompilationID_attribute attr, Void ignore) {
 253         constantWriter.write(attr.compilationID_index);
 254         return null;
 255     }
 256 
 257     @Override
 258     public Void visitConstantValue(ConstantValue_attribute attr, Void ignore) {
 259         print(&quot;ConstantValue: &quot;);
 260         constantWriter.write(attr.constantvalue_index);
 261         println();
 262         return null;
 263     }
 264 
 265     @Override
 266     public Void visitDeprecated(Deprecated_attribute attr, Void ignore) {
 267         println(&quot;Deprecated: true&quot;);
 268         return null;
 269     }
 270 
 271     @Override
 272     public Void visitEnclosingMethod(EnclosingMethod_attribute attr, Void ignore) {
 273         print(&quot;EnclosingMethod: #&quot; + attr.class_index + &quot;.#&quot; + attr.method_index);
 274         tab();
 275         print(&quot;// &quot; + getJavaClassName(attr));
 276         if (attr.method_index != 0)
 277             print(&quot;.&quot; + getMethodName(attr));
 278         println();
 279         return null;
 280     }
 281 
 282     private String getJavaClassName(EnclosingMethod_attribute a) {
 283         try {
 284             return getJavaName(a.getClassName(constant_pool));
 285         } catch (ConstantPoolException e) {
 286             return report(e);
 287         }
 288     }
 289 
 290     private String getMethodName(EnclosingMethod_attribute a) {
 291         try {
 292             return a.getMethodName(constant_pool);
 293         } catch (ConstantPoolException e) {
 294             return report(e);
 295         }
 296     }
 297 
 298     @Override
 299     public Void visitExceptions(Exceptions_attribute attr, Void ignore) {
 300         println(&quot;Exceptions:&quot;);
 301         indent(+1);
 302         print(&quot;throws &quot;);
 303         for (int i = 0; i &lt; attr.number_of_exceptions; i++) {
 304             if (i &gt; 0)
 305                 print(&quot;, &quot;);
 306             print(getJavaException(attr, i));
 307         }
 308         println();
 309         indent(-1);
 310         return null;
 311     }
 312 
 313     private String getJavaException(Exceptions_attribute attr, int index) {
 314         try {
 315             return getJavaName(attr.getException(index, constant_pool));
 316         } catch (ConstantPoolException e) {
 317             return report(e);
 318         }
 319     }
 320 
 321 
 322     @Override
 323     public Void visitInnerClasses(InnerClasses_attribute attr, Void ignore) {
 324         boolean first = true;
 325         for (Info info : attr.classes) {
 326             //access
 327             AccessFlags access_flags = info.inner_class_access_flags;
 328             if (options.checkAccess(access_flags)) {
 329                 if (first) {
 330                     writeInnerClassHeader();
 331                     first = false;
 332                 }
 333                 for (String name: access_flags.getInnerClassModifiers())
 334                     print(name + &quot; &quot;);
 335                 if (info.inner_name_index != 0) {
 336                     print(&quot;#&quot; + info.inner_name_index + &quot;= &quot;);
 337                 }
 338                 print(&quot;#&quot; + info.inner_class_info_index);
 339                 if (info.outer_class_info_index != 0) {
 340                     print(&quot; of #&quot; + info.outer_class_info_index);
 341                 }
 342                 print(&quot;;&quot;);
 343                 tab();
 344                 print(&quot;// &quot;);
 345                 if (info.inner_name_index != 0) {
 346                     print(getInnerName(constant_pool, info) + &quot;=&quot;);
 347                 }
 348                 constantWriter.write(info.inner_class_info_index);
 349                 if (info.outer_class_info_index != 0) {
 350                     print(&quot; of &quot;);
 351                     constantWriter.write(info.outer_class_info_index);
 352                 }
 353                 println();
 354             }
 355         }
 356         if (!first)
 357             indent(-1);
 358         return null;
 359     }
 360 
 361     String getInnerName(ConstantPool constant_pool, InnerClasses_attribute.Info info) {
 362         try {
 363             return info.getInnerName(constant_pool);
 364         } catch (ConstantPoolException e) {
 365             return report(e);
 366         }
 367     }
 368 
 369     private void writeInnerClassHeader() {
 370         println(&quot;InnerClasses:&quot;);
 371         indent(+1);
 372     }
 373 
 374     @Override
 375     public Void visitLineNumberTable(LineNumberTable_attribute attr, Void ignore) {
 376         println(&quot;LineNumberTable:&quot;);
 377         indent(+1);
 378         for (LineNumberTable_attribute.Entry entry: attr.line_number_table) {
 379             println(&quot;line &quot; + entry.line_number + &quot;: &quot; + entry.start_pc);
 380         }
 381         indent(-1);
 382         return null;
 383     }
 384 
 385     @Override
 386     public Void visitLocalVariableTable(LocalVariableTable_attribute attr, Void ignore) {
 387         println(&quot;LocalVariableTable:&quot;);
 388         indent(+1);
 389         println(&quot;Start  Length  Slot  Name   Signature&quot;);
 390         for (LocalVariableTable_attribute.Entry entry : attr.local_variable_table) {
 391             println(String.format(&quot;%5d %7d %5d %5s   %s&quot;,
 392                     entry.start_pc, entry.length, entry.index,
 393                     constantWriter.stringValue(entry.name_index),
 394                     constantWriter.stringValue(entry.descriptor_index)));
 395         }
 396         indent(-1);
 397         return null;
 398     }
 399 
 400     @Override
 401     public Void visitLocalVariableTypeTable(LocalVariableTypeTable_attribute attr, Void ignore) {
 402         println(&quot;LocalVariableTypeTable:&quot;);
 403         indent(+1);
 404         println(&quot;Start  Length  Slot  Name   Signature&quot;);
 405         for (LocalVariableTypeTable_attribute.Entry entry : attr.local_variable_table) {
 406             println(String.format(&quot;%5d %7d %5d %5s   %s&quot;,
 407                     entry.start_pc, entry.length, entry.index,
 408                     constantWriter.stringValue(entry.name_index),
 409                     constantWriter.stringValue(entry.signature_index)));
 410         }
 411         indent(-1);
 412         return null;
 413     }
 414 
 415     @Override
 416     public Void visitNestHost(NestHost_attribute attr, Void aVoid) {
 417         print(&quot;NestHost: &quot;);
 418         constantWriter.write(attr.top_index);
 419         println();
 420         return null;
 421     }
 422 
 423     private String getJavaClassName(ModuleMainClass_attribute a) {
 424         try {
 425             return getJavaName(a.getMainClassName(constant_pool));
 426         } catch (ConstantPoolException e) {
 427             return report(e);
 428         }
 429     }
 430 
 431     private static final String format = &quot;%-31s%s&quot;;
 432 
 433     @Override
 434     public Void visitMethodParameters(MethodParameters_attribute attr,
 435                                       Void ignore) {
 436         final String header = String.format(format, &quot;Name&quot;, &quot;Flags&quot;);
 437         println(&quot;MethodParameters:&quot;);
 438         indent(+1);
 439         println(header);
 440         for (MethodParameters_attribute.Entry entry :
 441                  attr.method_parameter_table) {
 442             String namestr =
 443                 entry.name_index != 0 ?
 444                 constantWriter.stringValue(entry.name_index) : &quot;&lt;no name&gt;&quot;;
 445             String flagstr =
 446                 (0 != (entry.flags &amp; ACC_FINAL) ? &quot;final &quot; : &quot;&quot;) +
 447                 (0 != (entry.flags &amp; ACC_MANDATED) ? &quot;mandated &quot; : &quot;&quot;) +
 448                 (0 != (entry.flags &amp; ACC_SYNTHETIC) ? &quot;synthetic&quot; : &quot;&quot;);
 449             println(String.format(format, namestr, flagstr));
 450         }
 451         indent(-1);
 452         return null;
 453     }
 454 
 455     @Override
 456     public Void visitModule(Module_attribute attr, Void ignore) {
 457         println(&quot;Module:&quot;);
 458         indent(+1);
 459 
 460         print(&quot;#&quot; + attr.module_name);
 461         print(&quot;,&quot;);
 462         print(String.format(&quot;%x&quot;, attr.module_flags));
 463         tab();
 464         print(&quot;// &quot; + constantWriter.stringValue(attr.module_name));
 465         if ((attr.module_flags &amp; Module_attribute.ACC_OPEN) != 0)
 466             print(&quot; ACC_OPEN&quot;);
 467         if ((attr.module_flags &amp; Module_attribute.ACC_MANDATED) != 0)
 468             print(&quot; ACC_MANDATED&quot;);
 469         if ((attr.module_flags &amp; Module_attribute.ACC_SYNTHETIC) != 0)
 470             print(&quot; ACC_SYNTHETIC&quot;);
 471         println();
 472         print(&quot;#&quot; + attr.module_version_index);
 473         if (attr.module_version_index != 0) {
 474             tab();
 475             print(&quot;// &quot; + constantWriter.stringValue(attr.module_version_index));
 476         }
 477         println();
 478 
 479         printRequiresTable(attr);
 480         printExportsTable(attr);
 481         printOpensTable(attr);
 482         printUsesTable(attr);
 483         printProvidesTable(attr);
 484         indent(-1);
 485         return null;
 486     }
 487 
 488     protected void printRequiresTable(Module_attribute attr) {
 489         Module_attribute.RequiresEntry[] entries = attr.requires;
 490         print(entries.length);
 491         tab();
 492         println(&quot;// &quot; + &quot;requires&quot;);
 493         indent(+1);
 494         for (Module_attribute.RequiresEntry e: entries) {
 495             print(&quot;#&quot; + e.requires_index + &quot;,&quot; + String.format(&quot;%x&quot;, e.requires_flags));
 496             tab();
 497             print(&quot;// &quot; + constantWriter.stringValue(e.requires_index));
 498             if ((e.requires_flags &amp; Module_attribute.ACC_TRANSITIVE) != 0)
 499                 print(&quot; ACC_TRANSITIVE&quot;);
 500             if ((e.requires_flags &amp; Module_attribute.ACC_STATIC_PHASE) != 0)
 501                 print(&quot; ACC_STATIC_PHASE&quot;);
 502             if ((e.requires_flags &amp; Module_attribute.ACC_SYNTHETIC) != 0)
 503                 print(&quot; ACC_SYNTHETIC&quot;);
 504             if ((e.requires_flags &amp; Module_attribute.ACC_MANDATED) != 0)
 505                 print(&quot; ACC_MANDATED&quot;);
 506             println();
 507             print(&quot;#&quot; + e.requires_version_index);
 508             if (e.requires_version_index != 0) {
 509                 tab();
 510                 print(&quot;// &quot; + constantWriter.stringValue(e.requires_version_index));
 511             }
 512             println();
 513         }
 514         indent(-1);
 515     }
 516 
 517     protected void printExportsTable(Module_attribute attr) {
 518         Module_attribute.ExportsEntry[] entries = attr.exports;
 519         print(entries.length);
 520         tab();
 521         println(&quot;// exports&quot;);
 522         indent(+1);
 523         for (Module_attribute.ExportsEntry e: entries) {
 524             printExportOpenEntry(e.exports_index, e.exports_flags, e.exports_to_index);
 525         }
 526         indent(-1);
 527     }
 528 
 529     protected void printOpensTable(Module_attribute attr) {
 530         Module_attribute.OpensEntry[] entries = attr.opens;
 531         print(entries.length);
 532         tab();
 533         println(&quot;// opens&quot;);
 534         indent(+1);
 535         for (Module_attribute.OpensEntry e: entries) {
 536             printExportOpenEntry(e.opens_index, e.opens_flags, e.opens_to_index);
 537         }
 538         indent(-1);
 539     }
 540 
 541     protected void printExportOpenEntry(int index, int flags, int[] to_index) {
 542         print(&quot;#&quot; + index + &quot;,&quot; + String.format(&quot;%x&quot;, flags));
 543         tab();
 544         print(&quot;// &quot;);
 545         print(constantWriter.stringValue(index));
 546         if ((flags &amp; Module_attribute.ACC_MANDATED) != 0)
 547             print(&quot; ACC_MANDATED&quot;);
 548         if ((flags &amp; Module_attribute.ACC_SYNTHETIC) != 0)
 549             print(&quot; ACC_SYNTHETIC&quot;);
 550         if (to_index.length == 0) {
 551             println();
 552         } else {
 553             println(&quot; to ... &quot; + to_index.length);
 554             indent(+1);
 555             for (int to: to_index) {
 556                 print(&quot;#&quot; + to);
 557                 tab();
 558                 println(&quot;// ... to &quot; + constantWriter.stringValue(to));
 559             }
 560             indent(-1);
 561         }
 562     }
 563 
 564     protected void printUsesTable(Module_attribute attr) {
 565         int[] entries = attr.uses_index;
 566         print(entries.length);
 567         tab();
 568         println(&quot;// &quot; + &quot;uses&quot;);
 569         indent(+1);
 570         for (int e: entries) {
 571             print(&quot;#&quot; + e);
 572             tab();
 573             println(&quot;// &quot; + constantWriter.stringValue(e));
 574         }
 575         indent(-1);
 576     }
 577 
 578     protected void printProvidesTable(Module_attribute attr) {
 579         Module_attribute.ProvidesEntry[] entries = attr.provides;
 580         print(entries.length);
 581         tab();
 582         println(&quot;// &quot; + &quot;provides&quot;);
 583         indent(+1);
 584         for (Module_attribute.ProvidesEntry e: entries) {
 585             print(&quot;#&quot; + e.provides_index);
 586             tab();
 587             print(&quot;// &quot;);
 588             print(constantWriter.stringValue(e.provides_index));
 589             println(&quot; with ... &quot; + e.with_count);
 590             indent(+1);
 591             for (int with : e.with_index) {
 592                 print(&quot;#&quot; + with);
 593                 tab();
 594                 println(&quot;// ... with &quot; + constantWriter.stringValue(with));
 595             }
 596             indent(-1);
 597         }
 598         indent(-1);
 599     }
 600 
 601     @Override
 602     public Void visitModuleHashes(ModuleHashes_attribute attr, Void ignore) {
 603         println(&quot;ModuleHashes:&quot;);
 604         indent(+1);
 605         print(&quot;algorithm: #&quot; + attr.algorithm_index);
 606         tab();
 607         println(&quot;// &quot; + getAlgorithm(attr));
 608         print(attr.hashes_table_length);
 609         tab();
 610         println(&quot;// hashes&quot;);
 611         for (ModuleHashes_attribute.Entry e : attr.hashes_table) {
 612             print(&quot;#&quot; + e.module_name_index);
 613             tab();
 614             println(&quot;// &quot; + getModuleName(e));
 615             println(&quot;hash_length: &quot; + e.hash.length);
 616             println(&quot;hash: [&quot; + toHex(e.hash) + &quot;]&quot;);
 617         }
 618         indent(-1);
 619         return null;
 620     }
 621 
 622     private String getAlgorithm(ModuleHashes_attribute attr) {
 623         try {
 624             return constant_pool.getUTF8Value(attr.algorithm_index);
 625         } catch (ConstantPoolException e) {
 626             return report(e);
 627         }
 628     }
 629 
 630     private String getModuleName(ModuleHashes_attribute.Entry entry) {
 631         try {
 632             int utf8Index = constant_pool.getModuleInfo(entry.module_name_index).name_index;
 633             return constant_pool.getUTF8Value(utf8Index);
 634         } catch (ConstantPoolException e) {
 635             return report(e);
 636         }
 637     }
 638 
 639     @Override
 640     public Void visitModuleMainClass(ModuleMainClass_attribute attr, Void ignore) {
 641         print(&quot;ModuleMainClass: #&quot; + attr.main_class_index);
 642         tab();
 643         print(&quot;// &quot; + getJavaClassName(attr));
 644         println();
 645         return null;
 646     }
 647 
 648     @Override
 649     public Void visitModulePackages(ModulePackages_attribute attr, Void ignore) {
 650         println(&quot;ModulePackages: &quot;);
 651         indent(+1);
 652         for (int i = 0; i &lt; attr.packages_count; i++) {
 653             print(&quot;#&quot; + attr.packages_index[i]);
 654             tab();
 655             println(&quot;// &quot; + getJavaPackage(attr, i));
 656         }
 657         indent(-1);
 658         return null;
 659     }
 660 
 661     private String getJavaPackage(ModulePackages_attribute attr, int index) {
 662         try {
 663             return getJavaName(attr.getPackage(index, constant_pool));
 664         } catch (ConstantPoolException e) {
 665             return report(e);
 666         }
 667     }
 668 
 669     @Override
 670     public Void visitModuleResolution(ModuleResolution_attribute attr, Void ignore) {
 671         println(&quot;ModuleResolution:&quot;);
 672         indent(+1);
 673         print(String.format(&quot;%x&quot;, attr.resolution_flags));
 674         tab();
 675         print(&quot;// &quot;);
 676         int flags = attr.resolution_flags;
 677         if ((flags &amp; ModuleResolution_attribute.DO_NOT_RESOLVE_BY_DEFAULT) != 0)
 678             print(&quot; DO_NOT_RESOLVE_BY_DEFAULT&quot;);
 679         if ((flags &amp; ModuleResolution_attribute.WARN_DEPRECATED) != 0)
 680             print(&quot; WARN_DEPRECATED&quot;);
 681         if ((flags &amp; ModuleResolution_attribute.WARN_DEPRECATED_FOR_REMOVAL) != 0)
 682             print(&quot; WARN_DEPRECATED_FOR_REMOVAL&quot;);
 683         if ((flags &amp; ModuleResolution_attribute.WARN_INCUBATING) != 0)
 684             print(&quot; WARN_INCUBATING&quot;);
 685         println();
 686         indent(-1);
 687         return null;
 688     }
 689 
 690     @Override
 691     public Void visitModuleTarget(ModuleTarget_attribute attr, Void ignore) {
 692         println(&quot;ModuleTarget:&quot;);
 693         indent(+1);
 694         print(&quot;target_platform: #&quot; + attr.target_platform_index);
 695         if (attr.target_platform_index != 0) {
 696             tab();
 697             print(&quot;// &quot; + getTargetPlatform(attr));
 698         }
 699         println();
 700         indent(-1);
 701         return null;
 702     }
 703 
 704     private String getTargetPlatform(ModuleTarget_attribute attr) {
 705         try {
 706             return constant_pool.getUTF8Value(attr.target_platform_index);
 707         } catch (ConstantPoolException e) {
 708             return report(e);
 709         }
 710     }
 711 
 712     @Override
 713     public Void visitNestMembers(NestMembers_attribute attr, Void aVoid) {
 714         println(&quot;NestMembers:&quot;);
 715         indent(+1);
 716         try {
 717             CONSTANT_Class_info[] children = attr.getChildren(constant_pool);
 718             for (int i = 0; i &lt; attr.members_indexes.length; i++) {
 719                 println(constantWriter.stringValue(children[i]));
 720             }
 721             indent(-1);
 722         } catch (ConstantPoolException ex) {
 723             throw new AssertionError(ex);
 724         }
 725         return null;
 726     }
 727 
 728     @Override
 729     public Void visitRecord(Record_attribute attr, Void p) {
 730         println(&quot;Record:&quot;);
 731         indent(+1);
 732         for (Record_attribute.ComponentInfo componentInfo : attr.component_info_arr) {
 733             Signature_attribute sigAttr = (Signature_attribute) componentInfo.attributes.get(Attribute.Signature);
 734 
 735             if (sigAttr == null)
 736                 print(getJavaFieldType(componentInfo.descriptor));
 737             else {
 738                 try {
 739                     Type t = sigAttr.getParsedSignature().getType(constant_pool);
 740                     print(getJavaName(t.toString()));
 741                 } catch (ConstantPoolException e) {
 742                     // report error?
 743                     // fall back on non-generic descriptor
 744                     print(getJavaFieldType(componentInfo.descriptor));
 745                 }
 746             }
 747 
 748             print(&quot; &quot;);
 749             try {
 750                 print(componentInfo.getName(constant_pool));
 751             } catch (ConstantPoolException e) {
 752                 report(e);
 753                 return null;
 754             }
 755             print(&quot;;&quot;);
 756             println();
 757             indent(+1);
 758             if (options.showDescriptors) {
 759                 println(&quot;descriptor: &quot; + getValue(componentInfo.descriptor));
 760             }
 761             if (options.showAllAttrs) {
 762                 for (Attribute componentAttr: componentInfo.attributes)
 763                     write(componentInfo, componentAttr, constant_pool);
 764                 println();
 765             }
 766             indent(-1);
 767         }
 768         indent(-1);
 769         return null;
 770     }
 771 
 772     String getValue(Descriptor d) {
 773         try {
 774             return d.getValue(constant_pool);
 775         } catch (ConstantPoolException e) {
 776             return report(e);
 777         }
 778     }
 779 
 780     void writeList(String prefix, Collection&lt;?&gt; items, String suffix) {
 781         print(prefix);
 782         String sep = &quot;&quot;;
 783         for (Object item: items) {
 784             print(sep);
 785             print(item);
 786             sep = &quot;, &quot;;
 787         }
 788         print(suffix);
 789     }
 790 
 791     String getJavaFieldType(Descriptor d) {
 792         try {
 793             return getJavaName(d.getFieldType(constant_pool));
 794         } catch (ConstantPoolException e) {
 795             return report(e);
 796         } catch (InvalidDescriptor e) {
 797             return report(e);
 798         }
 799     }
 800 
 801     void writeModifiers(Collection&lt;String&gt; items) {
 802         for (Object item: items) {
 803             print(item);
 804             print(&quot; &quot;);
 805         }
 806     }
 807 
 808     @Override
 809     public Void visitRuntimeVisibleAnnotations(RuntimeVisibleAnnotations_attribute attr, Void ignore) {
 810         println(&quot;RuntimeVisibleAnnotations:&quot;);
 811         indent(+1);
 812         for (int i = 0; i &lt; attr.annotations.length; i++) {
 813             print(i + &quot;: &quot;);
 814             annotationWriter.write(attr.annotations[i]);
 815             println();
 816         }
 817         indent(-1);
 818         return null;
 819     }
 820 
 821     @Override
 822     public Void visitRuntimeInvisibleAnnotations(RuntimeInvisibleAnnotations_attribute attr, Void ignore) {
 823         println(&quot;RuntimeInvisibleAnnotations:&quot;);
 824         indent(+1);
 825         for (int i = 0; i &lt; attr.annotations.length; i++) {
 826             print(i + &quot;: &quot;);
 827             annotationWriter.write(attr.annotations[i]);
 828             println();
 829         }
 830         indent(-1);
 831         return null;
 832     }
 833 
 834     @Override
 835     public Void visitRuntimeVisibleTypeAnnotations(RuntimeVisibleTypeAnnotations_attribute attr, Void ignore) {
 836         println(&quot;RuntimeVisibleTypeAnnotations:&quot;);
 837         indent(+1);
 838         for (int i = 0; i &lt; attr.annotations.length; i++) {
 839             print(i + &quot;: &quot;);
 840             annotationWriter.write(attr.annotations[i]);
 841             println();
 842         }
 843         indent(-1);
 844         return null;
 845     }
 846 
 847     @Override
 848     public Void visitRuntimeInvisibleTypeAnnotations(RuntimeInvisibleTypeAnnotations_attribute attr, Void ignore) {
 849         println(&quot;RuntimeInvisibleTypeAnnotations:&quot;);
 850         indent(+1);
 851         for (int i = 0; i &lt; attr.annotations.length; i++) {
 852             print(i + &quot;: &quot;);
 853             annotationWriter.write(attr.annotations[i]);
 854             println();
 855         }
 856         indent(-1);
 857         return null;
 858     }
 859 
 860     private void visitParameterAnnotations(String message, RuntimeParameterAnnotations_attribute attr) {
 861         println(message);
 862         indent(+1);
 863         for (int param = 0; param &lt; attr.parameter_annotations.length; param++) {
 864             println(&quot;parameter &quot; + param + &quot;: &quot;);
 865             indent(+1);
 866             for (int i = 0; i &lt; attr.parameter_annotations[param].length; i++) {
 867                 print(i + &quot;: &quot;);
 868                 annotationWriter.write(attr.parameter_annotations[param][i]);
 869                 println();
 870             }
 871             indent(-1);
 872         }
 873         indent(-1);
 874     }
 875 
 876     @Override
 877     public Void visitRuntimeVisibleParameterAnnotations(RuntimeVisibleParameterAnnotations_attribute attr, Void ignore) {
 878         visitParameterAnnotations(&quot;RuntimeVisibleParameterAnnotations:&quot;, (RuntimeParameterAnnotations_attribute) attr);
 879         return null;
 880     }
 881 
 882     @Override
 883     public Void visitRuntimeInvisibleParameterAnnotations(RuntimeInvisibleParameterAnnotations_attribute attr, Void ignore) {
 884         visitParameterAnnotations(&quot;RuntimeInvisibleParameterAnnotations:&quot;, (RuntimeParameterAnnotations_attribute) attr);
 885         return null;
 886     }
 887 
 888     @Override
 889     public Void visitSignature(Signature_attribute attr, Void ignore) {
 890         print(&quot;Signature: #&quot; + attr.signature_index);
 891         tab();
 892         println(&quot;// &quot; + getSignature(attr));
 893         return null;
 894     }
 895 
 896     String getSignature(Signature_attribute info) {
 897         try {
 898             return info.getSignature(constant_pool);
 899         } catch (ConstantPoolException e) {
 900             return report(e);
 901         }
 902     }
 903 
 904     @Override
 905     public Void visitSourceDebugExtension(SourceDebugExtension_attribute attr, Void ignore) {
 906         println(&quot;SourceDebugExtension:&quot;);
 907         indent(+1);
 908         for (String s: attr.getValue().split(&quot;[\r\n]+&quot;)) {
 909             println(s);
 910         }
 911         indent(-1);
 912         return null;
 913     }
 914 
 915     @Override
 916     public Void visitSourceFile(SourceFile_attribute attr, Void ignore) {
 917         println(&quot;SourceFile: \&quot;&quot; + getSourceFile(attr) + &quot;\&quot;&quot;);
 918         return null;
 919     }
 920 
 921     private String getSourceFile(SourceFile_attribute attr) {
 922         try {
 923             return attr.getSourceFile(constant_pool);
 924         } catch (ConstantPoolException e) {
 925             return report(e);
 926         }
 927     }
 928 
 929     @Override
 930     public Void visitSourceID(SourceID_attribute attr, Void ignore) {
 931         constantWriter.write(attr.sourceID_index);
 932         return null;
 933     }
 934 
 935     @Override
 936     public Void visitStackMap(StackMap_attribute attr, Void ignore) {
 937         println(&quot;StackMap: number_of_entries = &quot; + attr.number_of_entries);
 938         indent(+1);
 939         StackMapTableWriter w = new StackMapTableWriter();
 940         for (StackMapTable_attribute.stack_map_frame entry : attr.entries) {
 941             w.write(entry);
 942         }
 943         indent(-1);
 944         return null;
 945     }
 946 
 947     @Override
 948     public Void visitStackMapTable(StackMapTable_attribute attr, Void ignore) {
 949         println(&quot;StackMapTable: number_of_entries = &quot; + attr.number_of_entries);
 950         indent(+1);
 951         StackMapTableWriter w = new StackMapTableWriter();
 952         for (StackMapTable_attribute.stack_map_frame entry : attr.entries) {
 953             w.write(entry);
 954         }
 955         indent(-1);
 956         return null;
 957     }
 958 
 959     class StackMapTableWriter // also handles CLDC StackMap attributes
 960             implements StackMapTable_attribute.stack_map_frame.Visitor&lt;Void,Void&gt; {
 961         public void write(StackMapTable_attribute.stack_map_frame frame) {
 962             frame.accept(this, null);
 963         }
 964 
 965         @Override
 966         public Void visit_same_frame(StackMapTable_attribute.same_frame frame, Void p) {
 967             printHeader(frame, &quot;/* same */&quot;);
 968             return null;
 969         }
 970 
 971         @Override
 972         public Void visit_same_locals_1_stack_item_frame(StackMapTable_attribute.same_locals_1_stack_item_frame frame, Void p) {
 973             printHeader(frame, &quot;/* same_locals_1_stack_item */&quot;);
 974             indent(+1);
 975             printMap(&quot;stack&quot;, frame.stack);
 976             indent(-1);
 977             return null;
 978         }
 979 
 980         @Override
 981         public Void visit_same_locals_1_stack_item_frame_extended(StackMapTable_attribute.same_locals_1_stack_item_frame_extended frame, Void p) {
 982             printHeader(frame, &quot;/* same_locals_1_stack_item_frame_extended */&quot;);
 983             indent(+1);
 984             println(&quot;offset_delta = &quot; + frame.offset_delta);
 985             printMap(&quot;stack&quot;, frame.stack);
 986             indent(-1);
 987             return null;
 988         }
 989 
 990         @Override
 991         public Void visit_chop_frame(StackMapTable_attribute.chop_frame frame, Void p) {
 992             printHeader(frame, &quot;/* chop */&quot;);
 993             indent(+1);
 994             println(&quot;offset_delta = &quot; + frame.offset_delta);
 995             indent(-1);
 996             return null;
 997         }
 998 
 999         @Override
1000         public Void visit_same_frame_extended(StackMapTable_attribute.same_frame_extended frame, Void p) {
1001             printHeader(frame, &quot;/* same_frame_extended */&quot;);
1002             indent(+1);
1003             println(&quot;offset_delta = &quot; + frame.offset_delta);
1004             indent(-1);
1005             return null;
1006         }
1007 
1008         @Override
1009         public Void visit_append_frame(StackMapTable_attribute.append_frame frame, Void p) {
1010             printHeader(frame, &quot;/* append */&quot;);
1011             indent(+1);
1012             println(&quot;offset_delta = &quot; + frame.offset_delta);
1013             printMap(&quot;locals&quot;, frame.locals);
1014             indent(-1);
1015             return null;
1016         }
1017 
1018         @Override
1019         public Void visit_full_frame(StackMapTable_attribute.full_frame frame, Void p) {
1020             if (frame instanceof StackMap_attribute.stack_map_frame) {
1021                 printHeader(frame, &quot;offset = &quot; + frame.offset_delta);
1022                 indent(+1);
1023             } else {
1024                 printHeader(frame, &quot;/* full_frame */&quot;);
1025                 indent(+1);
1026                 println(&quot;offset_delta = &quot; + frame.offset_delta);
1027             }
1028             printMap(&quot;locals&quot;, frame.locals);
1029             printMap(&quot;stack&quot;, frame.stack);
1030             indent(-1);
1031             return null;
1032         }
1033 
1034         void printHeader(StackMapTable_attribute.stack_map_frame frame, String extra) {
1035             print(&quot;frame_type = &quot; + frame.frame_type + &quot; &quot;);
1036             println(extra);
1037         }
1038 
1039         void printMap(String name, StackMapTable_attribute.verification_type_info[] map) {
1040             print(name + &quot; = [&quot;);
1041             for (int i = 0; i &lt; map.length; i++) {
1042                 StackMapTable_attribute.verification_type_info info = map[i];
1043                 int tag = info.tag;
1044                 switch (tag) {
1045                     case StackMapTable_attribute.verification_type_info.ITEM_Object:
1046                         print(&quot; &quot;);
1047                         constantWriter.write(((StackMapTable_attribute.Object_variable_info) info).cpool_index);
1048                         break;
1049                     case StackMapTable_attribute.verification_type_info.ITEM_Uninitialized:
1050                         print(&quot; &quot; + mapTypeName(tag));
1051                         print(&quot; &quot; + ((StackMapTable_attribute.Uninitialized_variable_info) info).offset);
1052                         break;
1053                     default:
1054                         print(&quot; &quot; + mapTypeName(tag));
1055                 }
1056                 print(i == (map.length - 1) ? &quot; &quot; : &quot;,&quot;);
1057             }
1058             println(&quot;]&quot;);
1059         }
1060 
1061         String mapTypeName(int tag) {
1062             switch (tag) {
1063             case StackMapTable_attribute.verification_type_info.ITEM_Top:
1064                 return &quot;top&quot;;
1065 
1066             case StackMapTable_attribute.verification_type_info.ITEM_Integer:
1067                 return &quot;int&quot;;
1068 
1069             case StackMapTable_attribute.verification_type_info.ITEM_Float:
1070                 return &quot;float&quot;;
1071 
1072             case StackMapTable_attribute.verification_type_info.ITEM_Long:
1073                 return &quot;long&quot;;
1074 
1075             case StackMapTable_attribute.verification_type_info.ITEM_Double:
1076                 return &quot;double&quot;;
1077 
1078             case StackMapTable_attribute.verification_type_info.ITEM_Null:
1079                 return &quot;null&quot;;
1080 
1081             case StackMapTable_attribute.verification_type_info.ITEM_UninitializedThis:
1082                 return &quot;this&quot;;
1083 
1084             case StackMapTable_attribute.verification_type_info.ITEM_Object:
1085                 return &quot;CP&quot;;
1086 
1087             case StackMapTable_attribute.verification_type_info.ITEM_Uninitialized:
1088                 return &quot;uninitialized&quot;;
1089 
1090             default:
1091                 report(&quot;unrecognized verification_type_info tag: &quot; + tag);
1092                 return &quot;[tag:&quot; + tag + &quot;]&quot;;
1093             }
1094         }
1095     }
1096 
1097     @Override
1098     public Void visitSynthetic(Synthetic_attribute attr, Void ignore) {
1099         println(&quot;Synthetic: true&quot;);
1100         return null;
1101     }
1102 
1103     static String getJavaName(String name) {
1104         return name.replace(&#39;/&#39;, &#39;.&#39;);
1105     }
1106 
1107     String toHex(byte b, int w) {
1108         return toHex(b &amp; 0xff, w);
1109     }
1110 
1111     static String toHex(int i) {
1112         return StringUtils.toUpperCase(Integer.toString(i, 16));
1113     }
1114 
1115     static String toHex(int i, int w) {
1116         String s = StringUtils.toUpperCase(Integer.toHexString(i));
1117         while (s.length() &lt; w)
1118             s = &quot;0&quot; + s;
1119         return StringUtils.toUpperCase(s);
1120     }
1121 
1122     static String toHex(byte[] ba) {
1123         StringBuilder sb = new StringBuilder(ba.length);
1124         for (byte b: ba) {
1125             sb.append(String.format(&quot;%02x&quot;, b &amp; 0xff));
1126         }
1127         return sb.toString();
1128     }
1129 
1130     private final AnnotationWriter annotationWriter;
1131     private final CodeWriter codeWriter;
1132     private final ConstantWriter constantWriter;
1133     private final Options options;
1134 
1135     private ConstantPool constant_pool;
1136     private Object owner;
1137 }
    </pre>
  </body>
</html>
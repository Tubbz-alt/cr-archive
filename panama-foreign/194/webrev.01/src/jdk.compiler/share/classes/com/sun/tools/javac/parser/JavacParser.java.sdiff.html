<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavaTokenizer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../processing/JavacProcessingEnvironment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 169                      boolean keepEndPositions,
 170                      boolean parseModuleInfo) {
 171         this.S = S;
 172         nextToken(); // prime the pump
 173         this.F = fac.F;
 174         this.log = fac.log;
 175         this.names = fac.names;
 176         this.source = fac.source;
 177         this.preview = fac.preview;
 178         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 179         this.keepDocComments = keepDocComments;
 180         this.parseModuleInfo = parseModuleInfo;
 181         docComments = newDocCommentTable(keepDocComments, fac);
 182         this.keepLineMap = keepLineMap;
 183         this.errorTree = F.Erroneous();
 184         endPosTable = newEndPosTable(keepEndPositions);
 185         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 186                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 187         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 188                 Feature.RECORDS.allowedInSource(source);


 189     }
 190 
 191     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 192         return  keepEndPositions
 193                 ? new SimpleEndPosTable(this)
 194                 : new EmptyEndPosTable(this);
 195     }
 196 
 197     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 198         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 199     }
 200 
 201     /** Switch: should we fold strings?
 202      */
 203     boolean allowStringFolding;
 204 
 205     /** Switch: should we keep docComments?
 206      */
 207     boolean keepDocComments;
 208 
 209     /** Switch: should we keep line table?
 210      */
 211     boolean keepLineMap;
 212 
 213     /** Switch: is &quot;this&quot; allowed as an identifier?
 214      * This is needed to parse receiver types.
 215      */
 216     boolean allowThisIdent;
 217 
 218     /** Switch: is yield statement allowed in this source level?
 219      */
 220     boolean allowYieldStatement;
 221 
 222     /** Switch: are records allowed in this source level?
 223      */
 224     boolean allowRecords;
 225 




 226     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 227      */
 228     JCVariableDecl receiverParam;
 229 
 230     /** When terms are parsed, the mode determines which is expected:
 231      *     mode = EXPR        : an expression
 232      *     mode = TYPE        : a type
 233      *     mode = NOPARAMS    : no parameters allowed for type
 234      *     mode = TYPEARG     : type argument
 235      *     mode |= NOLAMBDA   : lambdas are not allowed
 236      */
 237     protected static final int EXPR = 0x1;
 238     protected static final int TYPE = 0x2;
 239     protected static final int NOPARAMS = 0x4;
 240     protected static final int TYPEARG = 0x8;
 241     protected static final int DIAMOND = 0x10;
 242     protected static final int NOLAMBDA = 0x20;
 243 
 244     protected void selectExprMode() {
 245         mode = (mode &amp; NOLAMBDA) | EXPR;
</pre>
<hr />
<pre>
2606                             lookahead++;
2607                         }
2608                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2609                         break;
2610                     case SEMI: //error recovery - this is not a valid statement:
2611                         isYieldStatement = true;
2612                         break;
2613                     default:
2614                         isYieldStatement = false;
2615                         break;
2616                 }
2617 
2618                 if (isYieldStatement) {
2619                     nextToken();
2620                     JCExpression t = term(EXPR);
2621                     accept(SEMI);
2622                     return List.of(toP(F.at(pos).Yield(t)));
2623                 }
2624 
2625                 //else intentional fall-through













2626             }
2627         }
2628         if (isRecordStart() &amp;&amp; allowRecords) {
2629             dc = token.comment(CommentStyle.JAVADOC);
2630             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2631         } else {
2632             Token prevToken = token;
2633             JCExpression t = term(EXPR | TYPE);
2634             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2635                 nextToken();
2636                 JCStatement stat = parseStatementAsBlock();
2637                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2638             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2639                 pos = token.pos;
2640                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2641                 F.at(pos);
2642                 return localVariableDeclarations(mods, t);
2643             } else {
2644                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2645                 t = checkExprStat(t);
</pre>
<hr />
<pre>
3055         }
3056         int lastPos;
3057     loop:
3058         while (true) {
3059             long flag;
3060             switch (token.kind) {
3061             case PRIVATE     : flag = Flags.PRIVATE; break;
3062             case PROTECTED   : flag = Flags.PROTECTED; break;
3063             case PUBLIC      : flag = Flags.PUBLIC; break;
3064             case STATIC      : flag = Flags.STATIC; break;
3065             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3066             case FINAL       : flag = Flags.FINAL; break;
3067             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3068             case NATIVE      : flag = Flags.NATIVE; break;
3069             case VOLATILE    : flag = Flags.VOLATILE; break;
3070             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3071             case STRICTFP    : flag = Flags.STRICTFP; break;
3072             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3073             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3074             case ERROR       : flag = 0; nextToken(); break;














3075             default: break loop;
3076             }
3077             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3078             lastPos = token.pos;
3079             nextToken();
3080             if (flag == Flags.ANNOTATION) {
3081                 if (token.kind != INTERFACE) {
3082                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3083                     // if first modifier is an annotation, set pos to annotation&#39;s.
3084                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3085                         pos = ann.pos;
3086                     annotations.append(ann);
3087                     flag = 0;
3088                 }
3089             }
3090             flags |= flag;
3091         }
3092         switch (token.kind) {
3093         case ENUM: flags |= Flags.ENUM; break;
3094         case INTERFACE: flags |= Flags.INTERFACE; break;
</pre>
<hr />
<pre>
3303             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3304                 return Source.JDK10;
3305             } else if (shouldWarn) {
3306                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3307             }
3308         }
3309         if (name == names.yield) {
3310             if (allowYieldStatement) {
3311                 return Source.JDK14;
3312             } else if (shouldWarn) {
3313                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3314             }
3315         }
3316         if (name == names.record) {
3317             if (allowRecords) {
3318                 return Source.JDK14;
3319             } else if (shouldWarn) {
3320                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3321             }
3322         }







3323         return null;
3324     }
3325 
3326     /** VariableDeclaratorId = Ident BracketsOpt
3327      */
3328     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3329         return variableDeclaratorId(mods, type, false);
3330     }
3331     //where
3332     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3333         int pos = token.pos;
3334         Name name;
3335         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3336             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3337             name = token.name();
3338             nextToken();
3339         } else {
3340             if (allowThisIdent ||
3341                 !lambdaParameter ||
3342                 LAX_IDENTIFIER.accepts(token.kind) ||
</pre>
<hr />
<pre>
3697      *  @param mods    The modifiers starting the class declaration
3698      *  @param dc       The documentation comment for the class, or null.
3699      */
3700     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3701         int pos = token.pos;
3702         accept(CLASS);
3703         Name name = typeName();
3704 
3705         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3706 
3707         JCExpression extending = null;
3708         if (token.kind == EXTENDS) {
3709             nextToken();
3710             extending = parseType();
3711         }
3712         List&lt;JCExpression&gt; implementing = List.nil();
3713         if (token.kind == IMPLEMENTS) {
3714             nextToken();
3715             implementing = typeList();
3716         }









3717         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3718         JCClassDecl result = toP(F.at(pos).ClassDef(
<span class="line-modified">3719             mods, name, typarams, extending, implementing, defs));</span>
3720         attach(result, dc);
3721         return result;
3722     }
3723 
3724     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3725         int pos = token.pos;
3726         nextToken();
3727         mods.flags |= Flags.RECORD;
3728         Name name = typeName();
3729 
3730         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3731 
3732         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);
3733 
3734         List&lt;JCExpression&gt; implementing = List.nil();
3735         if (token.kind == IMPLEMENTS) {
3736             nextToken();
3737             implementing = typeList();
3738         }
3739         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
</pre>
<hr />
<pre>
3776     }
3777 
3778     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3779      *                         [EXTENDS TypeList] InterfaceBody
3780      *  @param mods    The modifiers starting the interface declaration
3781      *  @param dc       The documentation comment for the interface, or null.
3782      */
3783     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3784         int pos = token.pos;
3785         accept(INTERFACE);
3786 
3787         Name name = typeName();
3788 
3789         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3790 
3791         List&lt;JCExpression&gt; extending = List.nil();
3792         if (token.kind == EXTENDS) {
3793             nextToken();
3794             extending = typeList();
3795         }
<span class="line-modified">3796         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, true, false);</span>










3797         JCClassDecl result = toP(F.at(pos).ClassDef(
<span class="line-modified">3798             mods, name, typarams, null, extending, defs));</span>
3799         attach(result, dc);
3800         return result;
3801     }
3802 
3803     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3804      *  @param mods    The modifiers starting the enum declaration
3805      *  @param dc       The documentation comment for the enum, or null.
3806      */
3807     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3808         int pos = token.pos;
3809         accept(ENUM);
3810 
3811         Name name = typeName();
3812 
3813         List&lt;JCExpression&gt; implementing = List.nil();
3814         if (token.kind == IMPLEMENTS) {
3815             nextToken();
3816             implementing = typeList();
3817         }
3818 
</pre>
<hr />
<pre>
4124                     } else {
4125                         pos = token.pos;
4126                         List&lt;JCTree&gt; err;
4127                         if (isVoid || typarams.nonEmpty()) {
4128                             JCMethodDecl m =
4129                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4130                                                             List.nil(), List.nil(), null, null));
4131                             attach(m, dc);
4132                             err = List.of(m);
4133                         } else {
4134                             err = List.nil();
4135                         }
4136                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4137                     }
4138                 }
4139             }
4140         }
4141     }
4142 
4143     protected boolean isRecordStart() {
<span class="line-modified">4144      if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;</span>
4145             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4146              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4147              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
<span class="line-modified">4148           checkSourceLevel(Feature.RECORDS);</span>
<span class="line-modified">4149           return true;</span>
<span class="line-modified">4150     } else {</span>
<span class="line-modified">4151        return false;</span>
<span class="line-modified">4152    }</span>
<span class="line-modified">4153 }</span>














































4154 
4155     /** MethodDeclaratorRest =
4156      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4157      *  VoidMethodDeclaratorRest =
4158      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4159      *  ConstructorDeclaratorRest =
4160      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4161      */
4162     protected JCTree methodDeclaratorRest(int pos,
4163                               JCModifiers mods,
4164                               JCExpression type,
4165                               Name name,
4166                               List&lt;JCTypeParameter&gt; typarams,
4167                               boolean isInterface, boolean isVoid,
4168                               boolean isRecord,
4169                               Comment dc) {
4170         if (isInterface) {
4171             if ((mods.flags &amp; Flags.STATIC) != 0) {
4172                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4173             }
</pre>
</td>
<td>
<hr />
<pre>
 169                      boolean keepEndPositions,
 170                      boolean parseModuleInfo) {
 171         this.S = S;
 172         nextToken(); // prime the pump
 173         this.F = fac.F;
 174         this.log = fac.log;
 175         this.names = fac.names;
 176         this.source = fac.source;
 177         this.preview = fac.preview;
 178         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 179         this.keepDocComments = keepDocComments;
 180         this.parseModuleInfo = parseModuleInfo;
 181         docComments = newDocCommentTable(keepDocComments, fac);
 182         this.keepLineMap = keepLineMap;
 183         this.errorTree = F.Erroneous();
 184         endPosTable = newEndPosTable(keepEndPositions);
 185         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 186                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 187         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 188                 Feature.RECORDS.allowedInSource(source);
<span class="line-added"> 189         this.allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 190                 Feature.SEALED_CLASSES.allowedInSource(source);</span>
 191     }
 192 
 193     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 194         return  keepEndPositions
 195                 ? new SimpleEndPosTable(this)
 196                 : new EmptyEndPosTable(this);
 197     }
 198 
 199     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 200         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 201     }
 202 
 203     /** Switch: should we fold strings?
 204      */
 205     boolean allowStringFolding;
 206 
 207     /** Switch: should we keep docComments?
 208      */
 209     boolean keepDocComments;
 210 
 211     /** Switch: should we keep line table?
 212      */
 213     boolean keepLineMap;
 214 
 215     /** Switch: is &quot;this&quot; allowed as an identifier?
 216      * This is needed to parse receiver types.
 217      */
 218     boolean allowThisIdent;
 219 
 220     /** Switch: is yield statement allowed in this source level?
 221      */
 222     boolean allowYieldStatement;
 223 
 224     /** Switch: are records allowed in this source level?
 225      */
 226     boolean allowRecords;
 227 
<span class="line-added"> 228     /** Switch: are sealed types allowed in this source level?</span>
<span class="line-added"> 229      */</span>
<span class="line-added"> 230     boolean allowSealedTypes;</span>
<span class="line-added"> 231 </span>
 232     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 233      */
 234     JCVariableDecl receiverParam;
 235 
 236     /** When terms are parsed, the mode determines which is expected:
 237      *     mode = EXPR        : an expression
 238      *     mode = TYPE        : a type
 239      *     mode = NOPARAMS    : no parameters allowed for type
 240      *     mode = TYPEARG     : type argument
 241      *     mode |= NOLAMBDA   : lambdas are not allowed
 242      */
 243     protected static final int EXPR = 0x1;
 244     protected static final int TYPE = 0x2;
 245     protected static final int NOPARAMS = 0x4;
 246     protected static final int TYPEARG = 0x8;
 247     protected static final int DIAMOND = 0x10;
 248     protected static final int NOLAMBDA = 0x20;
 249 
 250     protected void selectExprMode() {
 251         mode = (mode &amp; NOLAMBDA) | EXPR;
</pre>
<hr />
<pre>
2612                             lookahead++;
2613                         }
2614                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2615                         break;
2616                     case SEMI: //error recovery - this is not a valid statement:
2617                         isYieldStatement = true;
2618                         break;
2619                     default:
2620                         isYieldStatement = false;
2621                         break;
2622                 }
2623 
2624                 if (isYieldStatement) {
2625                     nextToken();
2626                     JCExpression t = term(EXPR);
2627                     accept(SEMI);
2628                     return List.of(toP(F.at(pos).Yield(t)));
2629                 }
2630 
2631                 //else intentional fall-through
<span class="line-added">2632             } else {</span>
<span class="line-added">2633                 if (isNonSealedClassStart(true)) {</span>
<span class="line-added">2634                     log.error(token.pos, Errors.SealedOrNonSealedLocalClassesNotAllowed);</span>
<span class="line-added">2635                     nextToken();</span>
<span class="line-added">2636                     nextToken();</span>
<span class="line-added">2637                     nextToken();</span>
<span class="line-added">2638                     return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), token.comment(CommentStyle.JAVADOC)));</span>
<span class="line-added">2639                 } else if (isSealedClassStart(true)) {</span>
<span class="line-added">2640                     checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">2641                     log.error(token.pos, Errors.SealedOrNonSealedLocalClassesNotAllowed);</span>
<span class="line-added">2642                     nextToken();</span>
<span class="line-added">2643                     return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), token.comment(CommentStyle.JAVADOC)));</span>
<span class="line-added">2644                 }</span>
2645             }
2646         }
2647         if (isRecordStart() &amp;&amp; allowRecords) {
2648             dc = token.comment(CommentStyle.JAVADOC);
2649             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2650         } else {
2651             Token prevToken = token;
2652             JCExpression t = term(EXPR | TYPE);
2653             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2654                 nextToken();
2655                 JCStatement stat = parseStatementAsBlock();
2656                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2657             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2658                 pos = token.pos;
2659                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2660                 F.at(pos);
2661                 return localVariableDeclarations(mods, t);
2662             } else {
2663                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2664                 t = checkExprStat(t);
</pre>
<hr />
<pre>
3074         }
3075         int lastPos;
3076     loop:
3077         while (true) {
3078             long flag;
3079             switch (token.kind) {
3080             case PRIVATE     : flag = Flags.PRIVATE; break;
3081             case PROTECTED   : flag = Flags.PROTECTED; break;
3082             case PUBLIC      : flag = Flags.PUBLIC; break;
3083             case STATIC      : flag = Flags.STATIC; break;
3084             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3085             case FINAL       : flag = Flags.FINAL; break;
3086             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3087             case NATIVE      : flag = Flags.NATIVE; break;
3088             case VOLATILE    : flag = Flags.VOLATILE; break;
3089             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3090             case STRICTFP    : flag = Flags.STRICTFP; break;
3091             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3092             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3093             case ERROR       : flag = 0; nextToken(); break;
<span class="line-added">3094             case IDENTIFIER  : {</span>
<span class="line-added">3095                 if (isNonSealedClassStart(false)) {</span>
<span class="line-added">3096                     flag = Flags.NON_SEALED;</span>
<span class="line-added">3097                     nextToken();</span>
<span class="line-added">3098                     nextToken();</span>
<span class="line-added">3099                     break;</span>
<span class="line-added">3100                 }</span>
<span class="line-added">3101                 if (isSealedClassStart(false)) {</span>
<span class="line-added">3102                     checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">3103                     flag = Flags.SEALED;</span>
<span class="line-added">3104                     break;</span>
<span class="line-added">3105                 }</span>
<span class="line-added">3106                 break loop;</span>
<span class="line-added">3107             }</span>
3108             default: break loop;
3109             }
3110             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3111             lastPos = token.pos;
3112             nextToken();
3113             if (flag == Flags.ANNOTATION) {
3114                 if (token.kind != INTERFACE) {
3115                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3116                     // if first modifier is an annotation, set pos to annotation&#39;s.
3117                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3118                         pos = ann.pos;
3119                     annotations.append(ann);
3120                     flag = 0;
3121                 }
3122             }
3123             flags |= flag;
3124         }
3125         switch (token.kind) {
3126         case ENUM: flags |= Flags.ENUM; break;
3127         case INTERFACE: flags |= Flags.INTERFACE; break;
</pre>
<hr />
<pre>
3336             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3337                 return Source.JDK10;
3338             } else if (shouldWarn) {
3339                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3340             }
3341         }
3342         if (name == names.yield) {
3343             if (allowYieldStatement) {
3344                 return Source.JDK14;
3345             } else if (shouldWarn) {
3346                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3347             }
3348         }
3349         if (name == names.record) {
3350             if (allowRecords) {
3351                 return Source.JDK14;
3352             } else if (shouldWarn) {
3353                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3354             }
3355         }
<span class="line-added">3356         if (name == names.sealed) {</span>
<span class="line-added">3357             if (allowSealedTypes) {</span>
<span class="line-added">3358                 return Source.JDK15;</span>
<span class="line-added">3359             } else if (shouldWarn) {</span>
<span class="line-added">3360                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK15));</span>
<span class="line-added">3361             }</span>
<span class="line-added">3362         }</span>
3363         return null;
3364     }
3365 
3366     /** VariableDeclaratorId = Ident BracketsOpt
3367      */
3368     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3369         return variableDeclaratorId(mods, type, false);
3370     }
3371     //where
3372     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3373         int pos = token.pos;
3374         Name name;
3375         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3376             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3377             name = token.name();
3378             nextToken();
3379         } else {
3380             if (allowThisIdent ||
3381                 !lambdaParameter ||
3382                 LAX_IDENTIFIER.accepts(token.kind) ||
</pre>
<hr />
<pre>
3737      *  @param mods    The modifiers starting the class declaration
3738      *  @param dc       The documentation comment for the class, or null.
3739      */
3740     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3741         int pos = token.pos;
3742         accept(CLASS);
3743         Name name = typeName();
3744 
3745         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3746 
3747         JCExpression extending = null;
3748         if (token.kind == EXTENDS) {
3749             nextToken();
3750             extending = parseType();
3751         }
3752         List&lt;JCExpression&gt; implementing = List.nil();
3753         if (token.kind == IMPLEMENTS) {
3754             nextToken();
3755             implementing = typeList();
3756         }
<span class="line-added">3757         List&lt;JCExpression&gt; permitting = List.nil();</span>
<span class="line-added">3758         if (allowSealedTypes &amp;&amp; token.kind == IDENTIFIER &amp;&amp; token.name() == names.permits) {</span>
<span class="line-added">3759             checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">3760             if ((mods.flags &amp; Flags.SEALED) == 0) {</span>
<span class="line-added">3761                 log.error(token.pos, Errors.InvalidPermitsClause(Fragments.ClassIsNotSealed(&quot;class&quot;)));</span>
<span class="line-added">3762             }</span>
<span class="line-added">3763             nextToken();</span>
<span class="line-added">3764             permitting = qualidentList(false);</span>
<span class="line-added">3765         }</span>
3766         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3767         JCClassDecl result = toP(F.at(pos).ClassDef(
<span class="line-modified">3768             mods, name, typarams, extending, implementing, permitting, defs));</span>
3769         attach(result, dc);
3770         return result;
3771     }
3772 
3773     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3774         int pos = token.pos;
3775         nextToken();
3776         mods.flags |= Flags.RECORD;
3777         Name name = typeName();
3778 
3779         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3780 
3781         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);
3782 
3783         List&lt;JCExpression&gt; implementing = List.nil();
3784         if (token.kind == IMPLEMENTS) {
3785             nextToken();
3786             implementing = typeList();
3787         }
3788         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
</pre>
<hr />
<pre>
3825     }
3826 
3827     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3828      *                         [EXTENDS TypeList] InterfaceBody
3829      *  @param mods    The modifiers starting the interface declaration
3830      *  @param dc       The documentation comment for the interface, or null.
3831      */
3832     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3833         int pos = token.pos;
3834         accept(INTERFACE);
3835 
3836         Name name = typeName();
3837 
3838         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3839 
3840         List&lt;JCExpression&gt; extending = List.nil();
3841         if (token.kind == EXTENDS) {
3842             nextToken();
3843             extending = typeList();
3844         }
<span class="line-modified">3845         List&lt;JCExpression&gt; permitting = List.nil();</span>
<span class="line-added">3846         if (allowSealedTypes &amp;&amp; token.kind == IDENTIFIER &amp;&amp; token.name() == names.permits) {</span>
<span class="line-added">3847             checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">3848             if ((mods.flags &amp; Flags.SEALED) == 0) {</span>
<span class="line-added">3849                 log.error(token.pos, Errors.InvalidPermitsClause(Fragments.ClassIsNotSealed(&quot;interface&quot;)));</span>
<span class="line-added">3850             }</span>
<span class="line-added">3851             nextToken();</span>
<span class="line-added">3852             permitting = typeList();</span>
<span class="line-added">3853         }</span>
<span class="line-added">3854         List&lt;JCTree&gt; defs;</span>
<span class="line-added">3855         defs = classInterfaceOrRecordBody(name, true, false);</span>
3856         JCClassDecl result = toP(F.at(pos).ClassDef(
<span class="line-modified">3857             mods, name, typarams, null, extending, permitting, defs));</span>
3858         attach(result, dc);
3859         return result;
3860     }
3861 
3862     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3863      *  @param mods    The modifiers starting the enum declaration
3864      *  @param dc       The documentation comment for the enum, or null.
3865      */
3866     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3867         int pos = token.pos;
3868         accept(ENUM);
3869 
3870         Name name = typeName();
3871 
3872         List&lt;JCExpression&gt; implementing = List.nil();
3873         if (token.kind == IMPLEMENTS) {
3874             nextToken();
3875             implementing = typeList();
3876         }
3877 
</pre>
<hr />
<pre>
4183                     } else {
4184                         pos = token.pos;
4185                         List&lt;JCTree&gt; err;
4186                         if (isVoid || typarams.nonEmpty()) {
4187                             JCMethodDecl m =
4188                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4189                                                             List.nil(), List.nil(), null, null));
4190                             attach(m, dc);
4191                             err = List.of(m);
4192                         } else {
4193                             err = List.nil();
4194                         }
4195                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4196                     }
4197                 }
4198             }
4199         }
4200     }
4201 
4202     protected boolean isRecordStart() {
<span class="line-modified">4203         if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;</span>
4204             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4205              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4206              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
<span class="line-modified">4207              checkSourceLevel(Feature.RECORDS);</span>
<span class="line-modified">4208             return true;</span>
<span class="line-modified">4209         } else {</span>
<span class="line-modified">4210             return false;</span>
<span class="line-modified">4211         }</span>
<span class="line-modified">4212     }</span>
<span class="line-added">4213 </span>
<span class="line-added">4214     protected boolean isNonSealedClassStart(boolean local) {</span>
<span class="line-added">4215         if (isNonSealedIdentifier(token, 0)) {</span>
<span class="line-added">4216             Token next = S.token(3);</span>
<span class="line-added">4217             return allowedAfterSealedOrNonSealed(next, local, true);</span>
<span class="line-added">4218         }</span>
<span class="line-added">4219         return false;</span>
<span class="line-added">4220     }</span>
<span class="line-added">4221 </span>
<span class="line-added">4222     protected boolean isNonSealedIdentifier(Token someToken, int lookAheadOffset) {</span>
<span class="line-added">4223         if (someToken.name() == names.non &amp;&amp; peekToken(lookAheadOffset, TokenKind.SUB, TokenKind.IDENTIFIER)) {</span>
<span class="line-added">4224             Token tokenSub = S.token(lookAheadOffset + 1);</span>
<span class="line-added">4225             Token tokenSealed = S.token(lookAheadOffset + 2);</span>
<span class="line-added">4226             if (someToken.endPos == tokenSub.pos &amp;&amp;</span>
<span class="line-added">4227                     tokenSub.endPos == tokenSealed.pos &amp;&amp;</span>
<span class="line-added">4228                     tokenSealed.name() == names.sealed) {</span>
<span class="line-added">4229                 checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">4230                 return true;</span>
<span class="line-added">4231             }</span>
<span class="line-added">4232         }</span>
<span class="line-added">4233         return false;</span>
<span class="line-added">4234     }</span>
<span class="line-added">4235 </span>
<span class="line-added">4236     protected boolean isSealedClassStart(boolean local) {</span>
<span class="line-added">4237         if (token.name() == names.sealed) {</span>
<span class="line-added">4238             Token next = S.token(1);</span>
<span class="line-added">4239             if (allowedAfterSealedOrNonSealed(next, local, false)) {</span>
<span class="line-added">4240                 checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">4241                 return true;</span>
<span class="line-added">4242             }</span>
<span class="line-added">4243         }</span>
<span class="line-added">4244         return false;</span>
<span class="line-added">4245     }</span>
<span class="line-added">4246 </span>
<span class="line-added">4247     private boolean allowedAfterSealedOrNonSealed(Token next, boolean local, boolean currentIsNonSealed) {</span>
<span class="line-added">4248         return local ?</span>
<span class="line-added">4249             switch (next.kind) {</span>
<span class="line-added">4250                 case MONKEYS_AT, ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -&gt; true;</span>
<span class="line-added">4251                 default -&gt; false;</span>
<span class="line-added">4252             } :</span>
<span class="line-added">4253             switch (next.kind) {</span>
<span class="line-added">4254                 case MONKEYS_AT, PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -&gt; true;</span>
<span class="line-added">4255                 case IDENTIFIER -&gt; isNonSealedIdentifier(next, currentIsNonSealed ? 3 : 1) || next.name() == names.sealed;</span>
<span class="line-added">4256                 default -&gt; false;</span>
<span class="line-added">4257             };</span>
<span class="line-added">4258     }</span>
4259 
4260     /** MethodDeclaratorRest =
4261      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4262      *  VoidMethodDeclaratorRest =
4263      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4264      *  ConstructorDeclaratorRest =
4265      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4266      */
4267     protected JCTree methodDeclaratorRest(int pos,
4268                               JCModifiers mods,
4269                               JCExpression type,
4270                               Name name,
4271                               List&lt;JCTypeParameter&gt; typarams,
4272                               boolean isInterface, boolean isVoid,
4273                               boolean isRecord,
4274                               Comment dc) {
4275         if (isInterface) {
4276             if ((mods.flags &amp; Flags.STATIC) != 0) {
4277                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4278             }
</pre>
</td>
</tr>
</table>
<center><a href="JavaTokenizer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../processing/JavacProcessingEnvironment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 
  29 
  30 import com.sun.source.tree.Tree;
  31 import com.sun.source.util.TreePath;
  32 import com.sun.tools.javac.code.*;
  33 import com.sun.tools.javac.comp.AttrContext;
  34 import com.sun.tools.javac.comp.Env;
  35 import com.sun.tools.javac.tree.JCTree.*;
  36 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  37 import com.sun.tools.javac.util.*;
  38 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  39 
  40 import static com.sun.tools.javac.code.Flags.*;
  41 import static com.sun.tools.javac.code.Kinds.Kind.*;
  42 import static com.sun.tools.javac.code.TypeTag.BOT;
  43 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  44 import static com.sun.tools.javac.tree.JCTree.Tag.BLOCK;
  45 import static com.sun.tools.javac.tree.JCTree.Tag.SYNCHRONIZED;
  46 
  47 import javax.tools.JavaFileObject;
  48 
  49 import java.util.function.ToIntFunction;
  50 
  51 import static com.sun.tools.javac.tree.JCTree.JCOperatorExpression.OperandPos.LEFT;
  52 import static com.sun.tools.javac.tree.JCTree.JCOperatorExpression.OperandPos.RIGHT;
  53 
  54 /** Utility class containing inspector methods for trees.
  55  *
  56  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  57  *  If you write code that depends on this, you do so at your own risk.
  58  *  This code and its internal interfaces are subject to change or
  59  *  deletion without notice.&lt;/b&gt;
  60  */
  61 public class TreeInfo {
  62 
  63     public static List&lt;JCExpression&gt; args(JCTree t) {
  64         switch (t.getTag()) {
  65             case APPLY:
  66                 return ((JCMethodInvocation)t).args;
  67             case NEWCLASS:
  68                 return ((JCNewClass)t).args;
  69             default:
  70                 return null;
  71         }
  72     }
  73 
  74     /** Is tree a constructor declaration?
  75      */
  76     public static boolean isConstructor(JCTree tree) {
  77         if (tree.hasTag(METHODDEF)) {
  78             Name name = ((JCMethodDecl) tree).name;
  79             return name == name.table.names.init;
  80         } else {
  81             return false;
  82         }
  83     }
  84 
  85     public static boolean isCanonicalConstructor(JCTree tree) {
  86         // the record flag is only set to the canonical constructor
  87         return isConstructor(tree) &amp;&amp; (((JCMethodDecl)tree).sym.flags_field &amp; RECORD) != 0;
  88     }
  89 
  90     public static boolean isCompactConstructor(JCTree tree) {
  91         // the record flag is only set to the canonical constructor
  92         return isCanonicalConstructor(tree) &amp;&amp; (((JCMethodDecl)tree).sym.flags_field &amp; COMPACT_RECORD_CONSTRUCTOR) != 0;
  93     }
  94 
  95     public static boolean isReceiverParam(JCTree tree) {
  96         if (tree.hasTag(VARDEF)) {
  97             return ((JCVariableDecl)tree).nameexpr != null;
  98         } else {
  99             return false;
 100         }
 101     }
 102 
 103     /** Is there a constructor declaration in the given list of trees?
 104      */
 105     public static boolean hasConstructors(List&lt;JCTree&gt; trees) {
 106         for (List&lt;JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
 107             if (isConstructor(l.head)) return true;
 108         return false;
 109     }
 110 
 111     /** Is there a constructor invocation in the given list of trees?
 112      */
 113     public static Name getConstructorInvocationName(List&lt;? extends JCTree&gt; trees, Names names) {
 114         for (JCTree tree : trees) {
 115             if (tree.hasTag(EXEC)) {
 116                 JCExpressionStatement stat = (JCExpressionStatement)tree;
 117                 if (stat.expr.hasTag(APPLY)) {
 118                     JCMethodInvocation apply = (JCMethodInvocation)stat.expr;
 119                     Name methName = TreeInfo.name(apply.meth);
 120                     if (methName == names._this ||
 121                         methName == names._super) {
 122                         return methName;
 123                     }
 124                 }
 125             }
 126         }
 127         return names.empty;
 128     }
 129 
 130     public static boolean isMultiCatch(JCCatch catchClause) {
 131         return catchClause.param.vartype.hasTag(TYPEUNION);
 132     }
 133 
 134     /** Is statement an initializer for a synthetic field?
 135      */
 136     public static boolean isSyntheticInit(JCTree stat) {
 137         if (stat.hasTag(EXEC)) {
 138             JCExpressionStatement exec = (JCExpressionStatement)stat;
 139             if (exec.expr.hasTag(ASSIGN)) {
 140                 JCAssign assign = (JCAssign)exec.expr;
 141                 if (assign.lhs.hasTag(SELECT)) {
 142                     JCFieldAccess select = (JCFieldAccess)assign.lhs;
 143                     if (select.sym != null &amp;&amp;
 144                         (select.sym.flags() &amp; SYNTHETIC) != 0) {
 145                         Name selected = name(select.selected);
 146                         if (selected != null &amp;&amp; selected == selected.table.names._this)
 147                             return true;
 148                     }
 149                 }
 150             }
 151         }
 152         return false;
 153     }
 154 
 155     /** If the expression is a method call, return the method name, null
 156      *  otherwise. */
 157     public static Name calledMethodName(JCTree tree) {
 158         if (tree.hasTag(EXEC)) {
 159             JCExpressionStatement exec = (JCExpressionStatement)tree;
 160             if (exec.expr.hasTag(APPLY)) {
 161                 Name mname = TreeInfo.name(((JCMethodInvocation) exec.expr).meth);
 162                 return mname;
 163             }
 164         }
 165         return null;
 166     }
 167 
 168     /** Is this a call to this or super?
 169      */
 170     public static boolean isSelfCall(JCTree tree) {
 171         Name name = calledMethodName(tree);
 172         if (name != null) {
 173             Names names = name.table.names;
 174             return name==names._this || name==names._super;
 175         } else {
 176             return false;
 177         }
 178     }
 179 
 180     /** Is this tree a &#39;this&#39; identifier?
 181      */
 182     public static boolean isThisQualifier(JCTree tree) {
 183         switch (tree.getTag()) {
 184             case PARENS:
 185                 return isThisQualifier(skipParens(tree));
 186             case IDENT: {
 187                 JCIdent id = (JCIdent)tree;
 188                 return id.name == id.name.table.names._this;
 189             }
 190             default:
 191                 return false;
 192         }
 193     }
 194 
 195     /** Is this tree an identifier, possibly qualified by &#39;this&#39;?
 196      */
 197     public static boolean isIdentOrThisDotIdent(JCTree tree) {
 198         switch (tree.getTag()) {
 199             case PARENS:
 200                 return isIdentOrThisDotIdent(skipParens(tree));
 201             case IDENT:
 202                 return true;
 203             case SELECT:
 204                 return isThisQualifier(((JCFieldAccess)tree).selected);
 205             default:
 206                 return false;
 207         }
 208     }
 209 
 210     /** Is this a call to super?
 211      */
 212     public static boolean isSuperCall(JCTree tree) {
 213         Name name = calledMethodName(tree);
 214         if (name != null) {
 215             Names names = name.table.names;
 216             return name==names._super;
 217         } else {
 218             return false;
 219         }
 220     }
 221 
 222     public static List&lt;JCVariableDecl&gt; recordFields(JCClassDecl tree) {
 223         return tree.defs.stream()
 224                 .filter(t -&gt; t.hasTag(VARDEF))
 225                 .map(t -&gt; (JCVariableDecl)t)
 226                 .filter(vd -&gt; (vd.getModifiers().flags &amp; (Flags.RECORD)) == RECORD)
 227                 .collect(List.collector());
 228     }
 229 
 230     public static List&lt;Type&gt; recordFieldTypes(JCClassDecl tree) {
 231         return recordFields(tree).stream()
 232                 .map(vd -&gt; vd.type)
 233                 .collect(List.collector());
 234     }
 235 
 236     /** Is this a constructor whose first (non-synthetic) statement is not
 237      *  of the form this(...)?
 238      */
 239     public static boolean isInitialConstructor(JCTree tree) {
 240         JCMethodInvocation app = firstConstructorCall(tree);
 241         if (app == null) return false;
 242         Name meth = name(app.meth);
 243         return meth == null || meth != meth.table.names._this;
 244     }
 245 
 246     /** Return the first call in a constructor definition. */
 247     public static JCMethodInvocation firstConstructorCall(JCTree tree) {
 248         if (!tree.hasTag(METHODDEF)) return null;
 249         JCMethodDecl md = (JCMethodDecl) tree;
 250         Names names = md.name.table.names;
 251         if (md.name != names.init) return null;
 252         if (md.body == null) return null;
 253         List&lt;JCStatement&gt; stats = md.body.stats;
 254         // Synthetic initializations can appear before the super call.
 255         while (stats.nonEmpty() &amp;&amp; isSyntheticInit(stats.head))
 256             stats = stats.tail;
 257         if (stats.isEmpty()) return null;
 258         if (!stats.head.hasTag(EXEC)) return null;
 259         JCExpressionStatement exec = (JCExpressionStatement) stats.head;
 260         if (!exec.expr.hasTag(APPLY)) return null;
 261         return (JCMethodInvocation)exec.expr;
 262     }
 263 
 264     /** Return true if a tree represents a diamond new expr. */
 265     public static boolean isDiamond(JCTree tree) {
 266         switch(tree.getTag()) {
 267             case TYPEAPPLY: return ((JCTypeApply)tree).getTypeArguments().isEmpty();
 268             case NEWCLASS: return isDiamond(((JCNewClass)tree).clazz);
 269             case ANNOTATED_TYPE: return isDiamond(((JCAnnotatedType)tree).underlyingType);
 270             default: return false;
 271         }
 272     }
 273 
 274     public static boolean isEnumInit(JCTree tree) {
 275         switch (tree.getTag()) {
 276             case VARDEF:
 277                 return (((JCVariableDecl)tree).mods.flags &amp; ENUM) != 0;
 278             default:
 279                 return false;
 280         }
 281     }
 282 
 283     /** set &#39;polyKind&#39; on given tree */
 284     public static void setPolyKind(JCTree tree, PolyKind pkind) {
 285         switch (tree.getTag()) {
 286             case APPLY:
 287                 ((JCMethodInvocation)tree).polyKind = pkind;
 288                 break;
 289             case NEWCLASS:
 290                 ((JCNewClass)tree).polyKind = pkind;
 291                 break;
 292             case REFERENCE:
 293                 ((JCMemberReference)tree).refPolyKind = pkind;
 294                 break;
 295             default:
 296                 throw new AssertionError(&quot;Unexpected tree: &quot; + tree);
 297         }
 298     }
 299 
 300     /** set &#39;varargsElement&#39; on given tree */
 301     public static void setVarargsElement(JCTree tree, Type varargsElement) {
 302         switch (tree.getTag()) {
 303             case APPLY:
 304                 ((JCMethodInvocation)tree).varargsElement = varargsElement;
 305                 break;
 306             case NEWCLASS:
 307                 ((JCNewClass)tree).varargsElement = varargsElement;
 308                 break;
 309             case REFERENCE:
 310                 ((JCMemberReference)tree).varargsElement = varargsElement;
 311                 break;
 312             default:
 313                 throw new AssertionError(&quot;Unexpected tree: &quot; + tree);
 314         }
 315     }
 316 
 317     /** Return true if the tree corresponds to an expression statement */
 318     public static boolean isExpressionStatement(JCExpression tree) {
 319         switch(tree.getTag()) {
 320             case PREINC: case PREDEC:
 321             case POSTINC: case POSTDEC:
 322             case ASSIGN:
 323             case BITOR_ASG: case BITXOR_ASG: case BITAND_ASG:
 324             case SL_ASG: case SR_ASG: case USR_ASG:
 325             case PLUS_ASG: case MINUS_ASG:
 326             case MUL_ASG: case DIV_ASG: case MOD_ASG:
 327             case APPLY: case NEWCLASS:
 328             case ERRONEOUS:
 329                 return true;
 330             default:
 331                 return false;
 332         }
 333     }
 334 
 335     /** Return true if the tree corresponds to a statement */
 336     public static boolean isStatement(JCTree tree) {
 337         return (tree instanceof JCStatement) &amp;&amp;
 338                 !tree.hasTag(CLASSDEF) &amp;&amp;
 339                 !tree.hasTag(Tag.BLOCK) &amp;&amp;
 340                 !tree.hasTag(METHODDEF);
 341     }
 342 
 343     /**
 344      * Return true if the AST corresponds to a static select of the kind A.B
 345      */
 346     public static boolean isStaticSelector(JCTree base, Names names) {
 347         if (base == null)
 348             return false;
 349         switch (base.getTag()) {
 350             case IDENT:
 351                 JCIdent id = (JCIdent)base;
 352                 return id.name != names._this &amp;&amp;
 353                         id.name != names._super &amp;&amp;
 354                         isStaticSym(base);
 355             case SELECT:
 356                 return isStaticSym(base) &amp;&amp;
 357                     isStaticSelector(((JCFieldAccess)base).selected, names);
 358             case TYPEAPPLY:
 359             case TYPEARRAY:
 360                 return true;
 361             case ANNOTATED_TYPE:
 362                 return isStaticSelector(((JCAnnotatedType)base).underlyingType, names);
 363             default:
 364                 return false;
 365         }
 366     }
 367     //where
 368         private static boolean isStaticSym(JCTree tree) {
 369             Symbol sym = symbol(tree);
 370             return (sym.kind == TYP || sym.kind == PCK);
 371         }
 372 
 373     /** Return true if a tree represents the null literal. */
 374     public static boolean isNull(JCTree tree) {
 375         if (!tree.hasTag(LITERAL))
 376             return false;
 377         JCLiteral lit = (JCLiteral) tree;
 378         return (lit.typetag == BOT);
 379     }
 380 
 381     /** Return true iff this tree is a child of some annotation. */
 382     public static boolean isInAnnotation(Env&lt;?&gt; env, JCTree tree) {
 383         TreePath tp = TreePath.getPath(env.toplevel, tree);
 384         if (tp != null) {
 385             for (Tree t : tp) {
 386                 if (t.getKind() == Tree.Kind.ANNOTATION)
 387                     return true;
 388             }
 389         }
 390         return false;
 391     }
 392 
 393     public static String getCommentText(Env&lt;?&gt; env, JCTree tree) {
 394         DocCommentTable docComments = (tree.hasTag(JCTree.Tag.TOPLEVEL))
 395                 ? ((JCCompilationUnit) tree).docComments
 396                 : env.toplevel.docComments;
 397         return (docComments == null) ? null : docComments.getCommentText(tree);
 398     }
 399 
 400     public static DCTree.DCDocComment getCommentTree(Env&lt;?&gt; env, JCTree tree) {
 401         DocCommentTable docComments = (tree.hasTag(JCTree.Tag.TOPLEVEL))
 402                 ? ((JCCompilationUnit) tree).docComments
 403                 : env.toplevel.docComments;
 404         return (docComments == null) ? null : docComments.getCommentTree(tree);
 405     }
 406 
 407     /** The position of the first statement in a block, or the position of
 408      *  the block itself if it is empty.
 409      */
 410     public static int firstStatPos(JCTree tree) {
 411         if (tree.hasTag(BLOCK) &amp;&amp; ((JCBlock) tree).stats.nonEmpty())
 412             return ((JCBlock) tree).stats.head.pos;
 413         else
 414             return tree.pos;
 415     }
 416 
 417     /** The end position of given tree, if it is a block with
 418      *  defined endpos.
 419      */
 420     public static int endPos(JCTree tree) {
 421         if (tree.hasTag(BLOCK) &amp;&amp; ((JCBlock) tree).endpos != Position.NOPOS)
 422             return ((JCBlock) tree).endpos;
 423         else if (tree.hasTag(SYNCHRONIZED))
 424             return endPos(((JCSynchronized) tree).body);
 425         else if (tree.hasTag(TRY)) {
 426             JCTry t = (JCTry) tree;
 427             return endPos((t.finalizer != null) ? t.finalizer
 428                           : (t.catchers.nonEmpty() ? t.catchers.last().body : t.body));
 429         } else if (tree.hasTag(SWITCH_EXPRESSION) &amp;&amp;
 430                    ((JCSwitchExpression) tree).endpos != Position.NOPOS) {
 431             return ((JCSwitchExpression) tree).endpos;
 432         } else
 433             return tree.pos;
 434     }
 435 
 436 
 437     /** Get the start position for a tree node.  The start position is
 438      * defined to be the position of the first character of the first
 439      * token of the node&#39;s source text.
 440      * @param tree  The tree node
 441      */
 442     public static int getStartPos(JCTree tree) {
 443         if (tree == null)
 444             return Position.NOPOS;
 445 
 446         switch(tree.getTag()) {
 447             case MODULEDEF: {
 448                 JCModuleDecl md = (JCModuleDecl)tree;
 449                 return md.mods.annotations.isEmpty() ? md.pos :
 450                        md.mods.annotations.head.pos;
 451             }
 452             case PACKAGEDEF: {
 453                 JCPackageDecl pd = (JCPackageDecl)tree;
 454                 return pd.annotations.isEmpty() ? pd.pos :
 455                        pd.annotations.head.pos;
 456             }
 457             case APPLY:
 458                 return getStartPos(((JCMethodInvocation) tree).meth);
 459             case ASSIGN:
 460                 return getStartPos(((JCAssign) tree).lhs);
 461             case BITOR_ASG: case BITXOR_ASG: case BITAND_ASG:
 462             case SL_ASG: case SR_ASG: case USR_ASG:
 463             case PLUS_ASG: case MINUS_ASG: case MUL_ASG:
 464             case DIV_ASG: case MOD_ASG:
 465             case OR: case AND: case BITOR:
 466             case BITXOR: case BITAND: case EQ:
 467             case NE: case LT: case GT:
 468             case LE: case GE: case SL:
 469             case SR: case USR: case PLUS:
 470             case MINUS: case MUL: case DIV:
 471             case MOD:
 472             case POSTINC:
 473             case POSTDEC:
 474                 return getStartPos(((JCOperatorExpression) tree).getOperand(LEFT));
 475             case CLASSDEF: {
 476                 JCClassDecl node = (JCClassDecl)tree;
 477                 if (node.mods.pos != Position.NOPOS)
 478                     return node.mods.pos;
 479                 break;
 480             }
 481             case CONDEXPR:
 482                 return getStartPos(((JCConditional) tree).cond);
 483             case EXEC:
 484                 return getStartPos(((JCExpressionStatement) tree).expr);
 485             case INDEXED:
 486                 return getStartPos(((JCArrayAccess) tree).indexed);
 487             case METHODDEF: {
 488                 JCMethodDecl node = (JCMethodDecl)tree;
 489                 if (node.mods.pos != Position.NOPOS)
 490                     return node.mods.pos;
 491                 if (node.typarams.nonEmpty()) // List.nil() used for no typarams
 492                     return getStartPos(node.typarams.head);
 493                 return node.restype == null ? node.pos : getStartPos(node.restype);
 494             }
 495             case SELECT:
 496                 return getStartPos(((JCFieldAccess) tree).selected);
 497             case TYPEAPPLY:
 498                 return getStartPos(((JCTypeApply) tree).clazz);
 499             case TYPEARRAY:
 500                 return getStartPos(((JCArrayTypeTree) tree).elemtype);
 501             case TYPETEST:
 502                 return getStartPos(((JCInstanceOf) tree).expr);
 503             case ANNOTATED_TYPE: {
 504                 JCAnnotatedType node = (JCAnnotatedType) tree;
 505                 if (node.annotations.nonEmpty()) {
 506                     if (node.underlyingType.hasTag(TYPEARRAY) ||
 507                             node.underlyingType.hasTag(SELECT)) {
 508                         return getStartPos(node.underlyingType);
 509                     } else {
 510                         return getStartPos(node.annotations.head);
 511                     }
 512                 } else {
 513                     return getStartPos(node.underlyingType);
 514                 }
 515             }
 516             case NEWCLASS: {
 517                 JCNewClass node = (JCNewClass)tree;
 518                 if (node.encl != null)
 519                     return getStartPos(node.encl);
 520                 break;
 521             }
 522             case VARDEF: {
 523                 JCVariableDecl node = (JCVariableDecl)tree;
 524                 if (node.startPos != Position.NOPOS) {
 525                     return node.startPos;
 526                 } else if (node.mods.pos != Position.NOPOS) {
 527                     return node.mods.pos;
 528                 } else if (node.vartype == null || node.vartype.pos == Position.NOPOS) {
 529                     //if there&#39;s no type (partially typed lambda parameter)
 530                     //simply return node position
 531                     return node.pos;
 532                 } else {
 533                     return getStartPos(node.vartype);
 534                 }
 535             }
 536             case BINDINGPATTERN: {
 537                 JCBindingPattern node = (JCBindingPattern)tree;
 538                 return getStartPos(node.vartype);
 539             }
 540             case ERRONEOUS: {
 541                 JCErroneous node = (JCErroneous)tree;
 542                 if (node.errs != null &amp;&amp; node.errs.nonEmpty())
 543                     return getStartPos(node.errs.head);
 544             }
 545         }
 546         return tree.pos;
 547     }
 548 
 549     /** The end position of given tree, given  a table of end positions generated by the parser
 550      */
 551     public static int getEndPos(JCTree tree, EndPosTable endPosTable) {
 552         if (tree == null)
 553             return Position.NOPOS;
 554 
 555         if (endPosTable == null) {
 556             // fall back on limited info in the tree
 557             return endPos(tree);
 558         }
 559 
 560         int mapPos = endPosTable.getEndPos(tree);
 561         if (mapPos != Position.NOPOS)
 562             return mapPos;
 563 
 564         switch(tree.getTag()) {
 565             case BITOR_ASG: case BITXOR_ASG: case BITAND_ASG:
 566             case SL_ASG: case SR_ASG: case USR_ASG:
 567             case PLUS_ASG: case MINUS_ASG: case MUL_ASG:
 568             case DIV_ASG: case MOD_ASG:
 569             case OR: case AND: case BITOR:
 570             case BITXOR: case BITAND: case EQ:
 571             case NE: case LT: case GT:
 572             case LE: case GE: case SL:
 573             case SR: case USR: case PLUS:
 574             case MINUS: case MUL: case DIV:
 575             case MOD:
 576             case POS:
 577             case NEG:
 578             case NOT:
 579             case COMPL:
 580             case PREINC:
 581             case PREDEC:
 582                 return getEndPos(((JCOperatorExpression) tree).getOperand(RIGHT), endPosTable);
 583             case CASE:
 584                 return getEndPos(((JCCase) tree).stats.last(), endPosTable);
 585             case CATCH:
 586                 return getEndPos(((JCCatch) tree).body, endPosTable);
 587             case CONDEXPR:
 588                 return getEndPos(((JCConditional) tree).falsepart, endPosTable);
 589             case FORLOOP:
 590                 return getEndPos(((JCForLoop) tree).body, endPosTable);
 591             case FOREACHLOOP:
 592                 return getEndPos(((JCEnhancedForLoop) tree).body, endPosTable);
 593             case IF: {
 594                 JCIf node = (JCIf)tree;
 595                 if (node.elsepart == null) {
 596                     return getEndPos(node.thenpart, endPosTable);
 597                 } else {
 598                     return getEndPos(node.elsepart, endPosTable);
 599                 }
 600             }
 601             case LABELLED:
 602                 return getEndPos(((JCLabeledStatement) tree).body, endPosTable);
 603             case MODIFIERS:
 604                 return getEndPos(((JCModifiers) tree).annotations.last(), endPosTable);
 605             case SYNCHRONIZED:
 606                 return getEndPos(((JCSynchronized) tree).body, endPosTable);
 607             case TOPLEVEL:
 608                 return getEndPos(((JCCompilationUnit) tree).defs.last(), endPosTable);
 609             case TRY: {
 610                 JCTry node = (JCTry)tree;
 611                 if (node.finalizer != null) {
 612                     return getEndPos(node.finalizer, endPosTable);
 613                 } else if (!node.catchers.isEmpty()) {
 614                     return getEndPos(node.catchers.last(), endPosTable);
 615                 } else {
 616                     return getEndPos(node.body, endPosTable);
 617                 }
 618             }
 619             case WILDCARD:
 620                 return getEndPos(((JCWildcard) tree).inner, endPosTable);
 621             case TYPECAST:
 622                 return getEndPos(((JCTypeCast) tree).expr, endPosTable);
 623             case TYPETEST:
 624                 return getEndPos(((JCInstanceOf) tree).pattern, endPosTable);
 625             case WHILELOOP:
 626                 return getEndPos(((JCWhileLoop) tree).body, endPosTable);
 627             case ANNOTATED_TYPE:
 628                 return getEndPos(((JCAnnotatedType) tree).underlyingType, endPosTable);
 629             case ERRONEOUS: {
 630                 JCErroneous node = (JCErroneous)tree;
 631                 if (node.errs != null &amp;&amp; node.errs.nonEmpty())
 632                     return getEndPos(node.errs.last(), endPosTable);
 633             }
 634         }
 635         return Position.NOPOS;
 636     }
 637 
 638 
 639     /** A DiagnosticPosition with the preferred position set to the
 640      *  end position of given tree, if it is a block with
 641      *  defined endpos.
 642      */
 643     public static DiagnosticPosition diagEndPos(final JCTree tree) {
 644         final int endPos = TreeInfo.endPos(tree);
 645         return new DiagnosticPosition() {
 646             public JCTree getTree() { return tree; }
 647             public int getStartPosition() { return TreeInfo.getStartPos(tree); }
 648             public int getPreferredPosition() { return endPos; }
 649             public int getEndPosition(EndPosTable endPosTable) {
 650                 return TreeInfo.getEndPos(tree, endPosTable);
 651             }
 652         };
 653     }
 654 
 655     public enum PosKind {
 656         START_POS(TreeInfo::getStartPos),
 657         FIRST_STAT_POS(TreeInfo::firstStatPos),
 658         END_POS(TreeInfo::endPos);
 659 
 660         final ToIntFunction&lt;JCTree&gt; posFunc;
 661 
 662         PosKind(ToIntFunction&lt;JCTree&gt; posFunc) {
 663             this.posFunc = posFunc;
 664         }
 665 
 666         int toPos(JCTree tree) {
 667             return posFunc.applyAsInt(tree);
 668         }
 669     }
 670 
 671     /** The position of the finalizer of given try/synchronized statement.
 672      */
 673     public static int finalizerPos(JCTree tree, PosKind posKind) {
 674         if (tree.hasTag(TRY)) {
 675             JCTry t = (JCTry) tree;
 676             Assert.checkNonNull(t.finalizer);
 677             return posKind.toPos(t.finalizer);
 678         } else if (tree.hasTag(SYNCHRONIZED)) {
 679             return endPos(((JCSynchronized) tree).body);
 680         } else {
 681             throw new AssertionError();
 682         }
 683     }
 684 
 685     /** Find the position for reporting an error about a symbol, where
 686      *  that symbol is defined somewhere in the given tree. */
 687     public static int positionFor(final Symbol sym, final JCTree tree) {
 688         JCTree decl = declarationFor(sym, tree);
 689         return ((decl != null) ? decl : tree).pos;
 690     }
 691 
 692     /** Find the position for reporting an error about a symbol, where
 693      *  that symbol is defined somewhere in the given tree. */
 694     public static DiagnosticPosition diagnosticPositionFor(final Symbol sym, final JCTree tree) {
<a name="2" id="anc2"></a><span class="line-modified"> 695         return diagnosticPositionFor(sym, tree, false);</span>

 696     }
 697 
<a name="3" id="anc3"></a><span class="line-modified"> 698     public static DiagnosticPosition diagnosticPositionFor(final Symbol sym, final JCTree tree, boolean returnNullIfNotFound) {</span>
<span class="line-modified"> 699         class DiagScanner extends DeclScanner {</span>
<span class="line-modified"> 700             DiagScanner(Symbol sym) {</span>
<span class="line-modified"> 701                 super(sym);</span>
















 702             }
<a name="4" id="anc4"></a><span class="line-modified"> 703 </span>
<span class="line-modified"> 704             public void visitIdent(JCIdent that) {</span>



 705                 if (that.sym == sym) result = that;
<a name="5" id="anc5"></a><span class="line-modified"> 706                 else super.visitIdent(that);</span>
 707             }
<a name="6" id="anc6"></a><span class="line-modified"> 708             public void visitSelect(JCFieldAccess that) {</span>
 709                 if (that.sym == sym) result = that;
<a name="7" id="anc7"></a><span class="line-modified"> 710                 else super.visitSelect(that);</span>




 711             }
 712         }
<a name="8" id="anc8"></a><span class="line-modified"> 713         DiagScanner s = new DiagScanner(sym);</span>
<span class="line-added"> 714         tree.accept(s);</span>
<span class="line-added"> 715         JCTree decl = s.result;</span>
<span class="line-added"> 716         if (decl == null &amp;&amp; returnNullIfNotFound) { return null; }</span>
<span class="line-added"> 717         return ((decl != null) ? decl : tree).pos();</span>
<span class="line-added"> 718     }</span>
<span class="line-added"> 719 </span>
<span class="line-added"> 720     public static DiagnosticPosition diagnosticPositionFor(final Symbol sym, final List&lt;? extends JCTree&gt; trees) {</span>
<span class="line-added"> 721         return trees.stream().map(t -&gt; TreeInfo.diagnosticPositionFor(sym, t)).filter(t -&gt; t != null).findFirst().get();</span>
<span class="line-added"> 722     }</span>
<span class="line-added"> 723 </span>
<span class="line-added"> 724     private static class DeclScanner extends TreeScanner {</span>
<span class="line-added"> 725         final Symbol sym;</span>
<span class="line-added"> 726 </span>
<span class="line-added"> 727         DeclScanner(final Symbol sym) {</span>
<span class="line-added"> 728             this.sym = sym;</span>
<span class="line-added"> 729         }</span>
<span class="line-added"> 730 </span>
<span class="line-added"> 731         JCTree result = null;</span>
<span class="line-added"> 732         public void scan(JCTree tree) {</span>
<span class="line-added"> 733             if (tree!=null &amp;&amp; result==null)</span>
<span class="line-added"> 734                 tree.accept(this);</span>
<span class="line-added"> 735         }</span>
<span class="line-added"> 736         public void visitTopLevel(JCCompilationUnit that) {</span>
<span class="line-added"> 737             if (that.packge == sym) result = that;</span>
<span class="line-added"> 738             else super.visitTopLevel(that);</span>
<span class="line-added"> 739         }</span>
<span class="line-added"> 740         public void visitModuleDef(JCModuleDecl that) {</span>
<span class="line-added"> 741             if (that.sym == sym) result = that;</span>
<span class="line-added"> 742             // no need to scan within module declaration</span>
<span class="line-added"> 743         }</span>
<span class="line-added"> 744         public void visitPackageDef(JCPackageDecl that) {</span>
<span class="line-added"> 745             if (that.packge == sym) result = that;</span>
<span class="line-added"> 746             else super.visitPackageDef(that);</span>
<span class="line-added"> 747         }</span>
<span class="line-added"> 748         public void visitClassDef(JCClassDecl that) {</span>
<span class="line-added"> 749             if (that.sym == sym) result = that;</span>
<span class="line-added"> 750             else super.visitClassDef(that);</span>
<span class="line-added"> 751         }</span>
<span class="line-added"> 752         public void visitMethodDef(JCMethodDecl that) {</span>
<span class="line-added"> 753             if (that.sym == sym) result = that;</span>
<span class="line-added"> 754             else super.visitMethodDef(that);</span>
<span class="line-added"> 755         }</span>
<span class="line-added"> 756         public void visitVarDef(JCVariableDecl that) {</span>
<span class="line-added"> 757             if (that.sym == sym) result = that;</span>
<span class="line-added"> 758             else super.visitVarDef(that);</span>
<span class="line-added"> 759         }</span>
<span class="line-added"> 760         public void visitTypeParameter(JCTypeParameter that) {</span>
<span class="line-added"> 761             if (that.type != null &amp;&amp; that.type.tsym == sym) result = that;</span>
<span class="line-added"> 762             else super.visitTypeParameter(that);</span>
<span class="line-added"> 763         }</span>
<span class="line-added"> 764     }</span>
<span class="line-added"> 765 </span>
<span class="line-added"> 766     /** Find the declaration for a symbol, where</span>
<span class="line-added"> 767      *  that symbol is defined somewhere in the given tree. */</span>
<span class="line-added"> 768     public static JCTree declarationFor(final Symbol sym, final JCTree tree) {</span>
<span class="line-added"> 769         DeclScanner s = new DeclScanner(sym);</span>
 770         tree.accept(s);
 771         return s.result;
 772     }
 773 
 774     public static Env&lt;AttrContext&gt; scopeFor(JCTree node, JCCompilationUnit unit) {
 775         return scopeFor(pathFor(node, unit));
 776     }
 777 
 778     public static Env&lt;AttrContext&gt; scopeFor(List&lt;JCTree&gt; path) {
 779         // TODO: not implemented yet
 780         throw new UnsupportedOperationException(&quot;not implemented yet&quot;);
 781     }
 782 
 783     public static List&lt;JCTree&gt; pathFor(final JCTree node, final JCCompilationUnit unit) {
 784         class Result extends Error {
 785             static final long serialVersionUID = -5942088234594905625L;
 786             List&lt;JCTree&gt; path;
 787             Result(List&lt;JCTree&gt; path) {
 788                 this.path = path;
 789             }
 790         }
 791         class PathFinder extends TreeScanner {
 792             List&lt;JCTree&gt; path = List.nil();
 793             public void scan(JCTree tree) {
 794                 if (tree != null) {
 795                     path = path.prepend(tree);
 796                     if (tree == node)
 797                         throw new Result(path);
 798                     super.scan(tree);
 799                     path = path.tail;
 800                 }
 801             }
 802         }
 803         try {
 804             new PathFinder().scan(unit);
 805         } catch (Result result) {
 806             return result.path;
 807         }
 808         return List.nil();
 809     }
 810 
 811     /** Return the statement referenced by a label.
 812      *  If the label refers to a loop or switch, return that switch
 813      *  otherwise return the labelled statement itself
 814      */
 815     public static JCTree referencedStatement(JCLabeledStatement tree) {
 816         JCTree t = tree;
 817         do t = ((JCLabeledStatement) t).body;
 818         while (t.hasTag(LABELLED));
 819         switch (t.getTag()) {
 820         case DOLOOP: case WHILELOOP: case FORLOOP: case FOREACHLOOP: case SWITCH:
 821             return t;
 822         default:
 823             return tree;
 824         }
 825     }
 826 
 827     /** Skip parens and return the enclosed expression
 828      */
 829     public static JCExpression skipParens(JCExpression tree) {
 830         while (tree.hasTag(PARENS)) {
 831             tree = ((JCParens) tree).expr;
 832         }
 833         return tree;
 834     }
 835 
 836     /** Skip parens and return the enclosed expression
 837      */
 838     public static JCTree skipParens(JCTree tree) {
 839         if (tree.hasTag(PARENS))
 840             return skipParens((JCParens)tree);
 841         else
 842             return tree;
 843     }
 844 
 845     /** Return the types of a list of trees.
 846      */
 847     public static List&lt;Type&gt; types(List&lt;? extends JCTree&gt; trees) {
 848         ListBuffer&lt;Type&gt; ts = new ListBuffer&lt;&gt;();
 849         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
 850             ts.append(l.head.type);
 851         return ts.toList();
 852     }
 853 
 854     /** If this tree is an identifier or a field or a parameterized type,
 855      *  return its name, otherwise return null.
 856      */
 857     public static Name name(JCTree tree) {
 858         switch (tree.getTag()) {
 859         case IDENT:
 860             return ((JCIdent) tree).name;
 861         case SELECT:
 862             return ((JCFieldAccess) tree).name;
 863         case TYPEAPPLY:
 864             return name(((JCTypeApply) tree).clazz);
 865         default:
 866             return null;
 867         }
 868     }
 869 
 870     /** If this tree is a qualified identifier, its return fully qualified name,
 871      *  otherwise return null.
 872      */
 873     public static Name fullName(JCTree tree) {
 874         tree = skipParens(tree);
 875         switch (tree.getTag()) {
 876         case IDENT:
 877             return ((JCIdent) tree).name;
 878         case SELECT:
 879             Name sname = fullName(((JCFieldAccess) tree).selected);
 880             return sname == null ? null : sname.append(&#39;.&#39;, name(tree));
 881         default:
 882             return null;
 883         }
 884     }
 885 
 886     public static Symbol symbolFor(JCTree node) {
 887         Symbol sym = symbolForImpl(node);
 888 
 889         return sym != null ? sym.baseSymbol() : null;
 890     }
 891 
 892     private static Symbol symbolForImpl(JCTree node) {
 893         node = skipParens(node);
 894         switch (node.getTag()) {
 895         case TOPLEVEL:
 896             JCCompilationUnit cut = (JCCompilationUnit) node;
 897             JCModuleDecl moduleDecl = cut.getModuleDecl();
 898             if (isModuleInfo(cut) &amp;&amp; moduleDecl != null)
 899                 return symbolFor(moduleDecl);
 900             return cut.packge;
 901         case MODULEDEF:
 902             return ((JCModuleDecl) node).sym;
 903         case PACKAGEDEF:
 904             return ((JCPackageDecl) node).packge;
 905         case CLASSDEF:
 906             return ((JCClassDecl) node).sym;
 907         case METHODDEF:
 908             return ((JCMethodDecl) node).sym;
 909         case VARDEF:
 910             return ((JCVariableDecl) node).sym;
 911         case IDENT:
 912             return ((JCIdent) node).sym;
 913         case SELECT:
 914             return ((JCFieldAccess) node).sym;
 915         case REFERENCE:
 916             return ((JCMemberReference) node).sym;
 917         case NEWCLASS:
 918             return ((JCNewClass) node).constructor;
 919         case APPLY:
 920             return symbolFor(((JCMethodInvocation) node).meth);
 921         case TYPEAPPLY:
 922             return symbolFor(((JCTypeApply) node).clazz);
 923         case ANNOTATION:
 924         case TYPE_ANNOTATION:
 925         case TYPEPARAMETER:
 926             if (node.type != null)
 927                 return node.type.tsym;
 928             return null;
 929         case BINDINGPATTERN:
 930             return ((JCBindingPattern) node).symbol;
 931         default:
 932             return null;
 933         }
 934     }
 935 
 936     public static boolean isDeclaration(JCTree node) {
 937         node = skipParens(node);
 938         switch (node.getTag()) {
 939         case PACKAGEDEF:
 940         case CLASSDEF:
 941         case METHODDEF:
 942         case VARDEF:
 943             return true;
 944         default:
 945             return false;
 946         }
 947     }
 948 
 949     /** If this tree is an identifier or a field, return its symbol,
 950      *  otherwise return null.
 951      */
 952     public static Symbol symbol(JCTree tree) {
 953         tree = skipParens(tree);
 954         switch (tree.getTag()) {
 955         case IDENT:
 956             return ((JCIdent) tree).sym;
 957         case SELECT:
 958             return ((JCFieldAccess) tree).sym;
 959         case TYPEAPPLY:
 960             return symbol(((JCTypeApply) tree).clazz);
 961         case ANNOTATED_TYPE:
 962             return symbol(((JCAnnotatedType) tree).underlyingType);
 963         case REFERENCE:
 964             return ((JCMemberReference) tree).sym;
 965         default:
 966             return null;
 967         }
 968     }
 969 
 970     /** If this tree has a modifiers field, return it otherwise return null
 971      */
 972     public static JCModifiers getModifiers(JCTree tree) {
 973         tree = skipParens(tree);
 974         switch (tree.getTag()) {
 975             case VARDEF:
 976                 return ((JCVariableDecl) tree).mods;
 977             case METHODDEF:
 978                 return ((JCMethodDecl) tree).mods;
 979             case CLASSDEF:
 980                 return ((JCClassDecl) tree).mods;
 981             case MODULEDEF:
 982                 return ((JCModuleDecl) tree).mods;
 983         default:
 984             return null;
 985         }
 986     }
 987 
 988     /** Return true if this is a nonstatic selection. */
 989     public static boolean nonstaticSelect(JCTree tree) {
 990         tree = skipParens(tree);
 991         if (!tree.hasTag(SELECT)) return false;
 992         JCFieldAccess s = (JCFieldAccess) tree;
 993         Symbol e = symbol(s.selected);
 994         return e == null || (e.kind != PCK &amp;&amp; e.kind != TYP);
 995     }
 996 
 997     /** If this tree is an identifier or a field, set its symbol, otherwise skip.
 998      */
 999     public static void setSymbol(JCTree tree, Symbol sym) {
1000         tree = skipParens(tree);
1001         switch (tree.getTag()) {
1002         case IDENT:
1003             ((JCIdent) tree).sym = sym; break;
1004         case SELECT:
1005             ((JCFieldAccess) tree).sym = sym; break;
1006         default:
1007         }
1008     }
1009 
1010     /** If this tree is a declaration or a block, return its flags field,
1011      *  otherwise return 0.
1012      */
1013     public static long flags(JCTree tree) {
1014         switch (tree.getTag()) {
1015         case VARDEF:
1016             return ((JCVariableDecl) tree).mods.flags;
1017         case METHODDEF:
1018             return ((JCMethodDecl) tree).mods.flags;
1019         case CLASSDEF:
1020             return ((JCClassDecl) tree).mods.flags;
1021         case BLOCK:
1022             return ((JCBlock) tree).flags;
1023         default:
1024             return 0;
1025         }
1026     }
1027 
1028     /** Return first (smallest) flag in `flags&#39;:
1029      *  pre: flags != 0
1030      */
1031     public static long firstFlag(long flags) {
1032         long flag = 1;
1033         while ((flag &amp; flags &amp; ExtendedStandardFlags) == 0)
1034             flag = flag &lt;&lt; 1;
1035         return flag;
1036     }
1037 
1038     /** Return flags as a string, separated by &quot; &quot;.
1039      */
1040     public static String flagNames(long flags) {
1041         return Flags.toString(flags &amp; ExtendedStandardFlags).trim();
1042     }
1043 
1044     /** Operator precedences values.
1045      */
1046     public static final int
1047         notExpression = -1,   // not an expression
1048         noPrec = 0,           // no enclosing expression
1049         assignPrec = 1,
1050         assignopPrec = 2,
1051         condPrec = 3,
1052         orPrec = 4,
1053         andPrec = 5,
1054         bitorPrec = 6,
1055         bitxorPrec = 7,
1056         bitandPrec = 8,
1057         eqPrec = 9,
1058         ordPrec = 10,
1059         shiftPrec = 11,
1060         addPrec = 12,
1061         mulPrec = 13,
1062         prefixPrec = 14,
1063         postfixPrec = 15,
1064         precCount = 16;
1065 
1066 
1067     /** Map operators to their precedence levels.
1068      */
1069     public static int opPrec(JCTree.Tag op) {
1070         switch(op) {
1071         case POS:
1072         case NEG:
1073         case NOT:
1074         case COMPL:
1075         case PREINC:
1076         case PREDEC: return prefixPrec;
1077         case POSTINC:
1078         case POSTDEC:
1079         case NULLCHK: return postfixPrec;
1080         case ASSIGN: return assignPrec;
1081         case BITOR_ASG:
1082         case BITXOR_ASG:
1083         case BITAND_ASG:
1084         case SL_ASG:
1085         case SR_ASG:
1086         case USR_ASG:
1087         case PLUS_ASG:
1088         case MINUS_ASG:
1089         case MUL_ASG:
1090         case DIV_ASG:
1091         case MOD_ASG: return assignopPrec;
1092         case OR: return orPrec;
1093         case AND: return andPrec;
1094         case EQ:
1095         case NE: return eqPrec;
1096         case LT:
1097         case GT:
1098         case LE:
1099         case GE: return ordPrec;
1100         case BITOR: return bitorPrec;
1101         case BITXOR: return bitxorPrec;
1102         case BITAND: return bitandPrec;
1103         case SL:
1104         case SR:
1105         case USR: return shiftPrec;
1106         case PLUS:
1107         case MINUS: return addPrec;
1108         case MUL:
1109         case DIV:
1110         case MOD: return mulPrec;
1111         case TYPETEST: return ordPrec;
1112         default: throw new AssertionError();
1113         }
1114     }
1115 
1116     static Tree.Kind tagToKind(JCTree.Tag tag) {
1117         switch (tag) {
1118         // Postfix expressions
1119         case POSTINC:           // _ ++
1120             return Tree.Kind.POSTFIX_INCREMENT;
1121         case POSTDEC:           // _ --
1122             return Tree.Kind.POSTFIX_DECREMENT;
1123 
1124         // Unary operators
1125         case PREINC:            // ++ _
1126             return Tree.Kind.PREFIX_INCREMENT;
1127         case PREDEC:            // -- _
1128             return Tree.Kind.PREFIX_DECREMENT;
1129         case POS:               // +
1130             return Tree.Kind.UNARY_PLUS;
1131         case NEG:               // -
1132             return Tree.Kind.UNARY_MINUS;
1133         case COMPL:             // ~
1134             return Tree.Kind.BITWISE_COMPLEMENT;
1135         case NOT:               // !
1136             return Tree.Kind.LOGICAL_COMPLEMENT;
1137 
1138         // Binary operators
1139 
1140         // Multiplicative operators
1141         case MUL:               // *
1142             return Tree.Kind.MULTIPLY;
1143         case DIV:               // /
1144             return Tree.Kind.DIVIDE;
1145         case MOD:               // %
1146             return Tree.Kind.REMAINDER;
1147 
1148         // Additive operators
1149         case PLUS:              // +
1150             return Tree.Kind.PLUS;
1151         case MINUS:             // -
1152             return Tree.Kind.MINUS;
1153 
1154         // Shift operators
1155         case SL:                // &lt;&lt;
1156             return Tree.Kind.LEFT_SHIFT;
1157         case SR:                // &gt;&gt;
1158             return Tree.Kind.RIGHT_SHIFT;
1159         case USR:               // &gt;&gt;&gt;
1160             return Tree.Kind.UNSIGNED_RIGHT_SHIFT;
1161 
1162         // Relational operators
1163         case LT:                // &lt;
1164             return Tree.Kind.LESS_THAN;
1165         case GT:                // &gt;
1166             return Tree.Kind.GREATER_THAN;
1167         case LE:                // &lt;=
1168             return Tree.Kind.LESS_THAN_EQUAL;
1169         case GE:                // &gt;=
1170             return Tree.Kind.GREATER_THAN_EQUAL;
1171 
1172         // Equality operators
1173         case EQ:                // ==
1174             return Tree.Kind.EQUAL_TO;
1175         case NE:                // !=
1176             return Tree.Kind.NOT_EQUAL_TO;
1177 
1178         // Bitwise and logical operators
1179         case BITAND:            // &amp;
1180             return Tree.Kind.AND;
1181         case BITXOR:            // ^
1182             return Tree.Kind.XOR;
1183         case BITOR:             // |
1184             return Tree.Kind.OR;
1185 
1186         // Conditional operators
1187         case AND:               // &amp;&amp;
1188             return Tree.Kind.CONDITIONAL_AND;
1189         case OR:                // ||
1190             return Tree.Kind.CONDITIONAL_OR;
1191 
1192         // Assignment operators
1193         case MUL_ASG:           // *=
1194             return Tree.Kind.MULTIPLY_ASSIGNMENT;
1195         case DIV_ASG:           // /=
1196             return Tree.Kind.DIVIDE_ASSIGNMENT;
1197         case MOD_ASG:           // %=
1198             return Tree.Kind.REMAINDER_ASSIGNMENT;
1199         case PLUS_ASG:          // +=
1200             return Tree.Kind.PLUS_ASSIGNMENT;
1201         case MINUS_ASG:         // -=
1202             return Tree.Kind.MINUS_ASSIGNMENT;
1203         case SL_ASG:            // &lt;&lt;=
1204             return Tree.Kind.LEFT_SHIFT_ASSIGNMENT;
1205         case SR_ASG:            // &gt;&gt;=
1206             return Tree.Kind.RIGHT_SHIFT_ASSIGNMENT;
1207         case USR_ASG:           // &gt;&gt;&gt;=
1208             return Tree.Kind.UNSIGNED_RIGHT_SHIFT_ASSIGNMENT;
1209         case BITAND_ASG:        // &amp;=
1210             return Tree.Kind.AND_ASSIGNMENT;
1211         case BITXOR_ASG:        // ^=
1212             return Tree.Kind.XOR_ASSIGNMENT;
1213         case BITOR_ASG:         // |=
1214             return Tree.Kind.OR_ASSIGNMENT;
1215 
1216         // Null check (implementation detail), for example, __.getClass()
1217         case NULLCHK:
1218             return Tree.Kind.OTHER;
1219 
1220         case ANNOTATION:
1221             return Tree.Kind.ANNOTATION;
1222         case TYPE_ANNOTATION:
1223             return Tree.Kind.TYPE_ANNOTATION;
1224 
1225         case EXPORTS:
1226             return Tree.Kind.EXPORTS;
1227         case OPENS:
1228             return Tree.Kind.OPENS;
1229 
1230         default:
1231             return null;
1232         }
1233     }
1234 
1235     /**
1236      * Returns the underlying type of the tree if it is an annotated type,
1237      * or the tree itself otherwise.
1238      */
1239     public static JCExpression typeIn(JCExpression tree) {
1240         switch (tree.getTag()) {
1241         case ANNOTATED_TYPE:
1242             return ((JCAnnotatedType)tree).underlyingType;
1243         case IDENT: /* simple names */
1244         case TYPEIDENT: /* primitive name */
1245         case SELECT: /* qualified name */
1246         case TYPEARRAY: /* array types */
1247         case WILDCARD: /* wild cards */
1248         case TYPEPARAMETER: /* type parameters */
1249         case TYPEAPPLY: /* parameterized types */
1250         case ERRONEOUS: /* error tree TODO: needed for BadCast JSR308 test case. Better way? */
1251             return tree;
1252         default:
1253             throw new AssertionError(&quot;Unexpected type tree: &quot; + tree);
1254         }
1255     }
1256 
1257     /* Return the inner-most type of a type tree.
1258      * For an array that contains an annotated type, return that annotated type.
1259      * TODO: currently only used by Pretty. Describe behavior better.
1260      */
1261     public static JCTree innermostType(JCTree type, boolean skipAnnos) {
1262         JCTree lastAnnotatedType = null;
1263         JCTree cur = type;
1264         loop: while (true) {
1265             switch (cur.getTag()) {
1266             case TYPEARRAY:
1267                 lastAnnotatedType = null;
1268                 cur = ((JCArrayTypeTree)cur).elemtype;
1269                 break;
1270             case WILDCARD:
1271                 lastAnnotatedType = null;
1272                 cur = ((JCWildcard)cur).inner;
1273                 break;
1274             case ANNOTATED_TYPE:
1275                 lastAnnotatedType = cur;
1276                 cur = ((JCAnnotatedType)cur).underlyingType;
1277                 break;
1278             default:
1279                 break loop;
1280             }
1281         }
1282         if (!skipAnnos &amp;&amp; lastAnnotatedType!=null) {
1283             return lastAnnotatedType;
1284         } else {
1285             return cur;
1286         }
1287     }
1288 
1289     private static class TypeAnnotationFinder extends TreeScanner {
1290         public boolean foundTypeAnno = false;
1291 
1292         @Override
1293         public void scan(JCTree tree) {
1294             if (foundTypeAnno || tree == null)
1295                 return;
1296             super.scan(tree);
1297         }
1298 
1299         public void visitAnnotation(JCAnnotation tree) {
1300             foundTypeAnno = foundTypeAnno || tree.hasTag(TYPE_ANNOTATION);
1301         }
1302     }
1303 
1304     public static boolean containsTypeAnnotation(JCTree e) {
1305         TypeAnnotationFinder finder = new TypeAnnotationFinder();
1306         finder.scan(e);
1307         return finder.foundTypeAnno;
1308     }
1309 
1310     public static boolean isModuleInfo(JCCompilationUnit tree) {
1311         return tree.sourcefile.isNameCompatible(&quot;module-info&quot;, JavaFileObject.Kind.SOURCE)
1312                 &amp;&amp; tree.getModuleDecl() != null;
1313     }
1314 
1315     public static JCModuleDecl getModule(JCCompilationUnit t) {
1316         if (t.defs.nonEmpty()) {
1317             JCTree def = t.defs.head;
1318             if (def.hasTag(MODULEDEF))
1319                 return (JCModuleDecl) def;
1320         }
1321         return null;
1322     }
1323 
1324     public static boolean isPackageInfo(JCCompilationUnit tree) {
1325         return tree.sourcefile.isNameCompatible(&quot;package-info&quot;, JavaFileObject.Kind.SOURCE);
1326     }
1327 
1328 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.annotation.Inherited;
  30 import java.util.Collections;
  31 import java.util.EnumSet;
  32 import java.util.HashMap;
  33 import java.util.Map;
  34 import java.util.Set;
  35 import java.util.concurrent.Callable;
  36 import java.util.function.Supplier;
  37 
  38 import javax.lang.model.element.Element;
  39 import javax.lang.model.element.ElementKind;
  40 import javax.lang.model.element.ElementVisitor;
  41 import javax.lang.model.element.ExecutableElement;
  42 import javax.lang.model.element.Modifier;
  43 import javax.lang.model.element.ModuleElement;
  44 import javax.lang.model.element.NestingKind;
  45 import javax.lang.model.element.PackageElement;
  46 import javax.lang.model.element.RecordComponentElement;
  47 import javax.lang.model.element.TypeElement;
  48 import javax.lang.model.element.TypeParameterElement;
  49 import javax.lang.model.element.VariableElement;
  50 import javax.tools.JavaFileManager;
  51 import javax.tools.JavaFileObject;
  52 
  53 import com.sun.tools.javac.code.Kinds.Kind;
  54 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.comp.Attr;
  57 import com.sun.tools.javac.comp.AttrContext;
  58 import com.sun.tools.javac.comp.Env;
  59 import com.sun.tools.javac.jvm.*;
  60 import com.sun.tools.javac.jvm.PoolConstant;
  61 import com.sun.tools.javac.tree.JCTree;
  62 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
  63 import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
  64 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
  65 import com.sun.tools.javac.tree.JCTree.Tag;
  66 import com.sun.tools.javac.util.*;
  67 import com.sun.tools.javac.util.DefinedBy.Api;
  68 import com.sun.tools.javac.util.List;
  69 import com.sun.tools.javac.util.Name;
  70 
  71 import static com.sun.tools.javac.code.Flags.*;
  72 import static com.sun.tools.javac.code.Kinds.*;
  73 import static com.sun.tools.javac.code.Kinds.Kind.*;
  74 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  75 import com.sun.tools.javac.code.Scope.WriteableScope;
  76 import static com.sun.tools.javac.code.TypeTag.CLASS;
  77 import static com.sun.tools.javac.code.TypeTag.FORALL;
  78 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  79 import static com.sun.tools.javac.jvm.ByteCodes.iadd;
  80 import static com.sun.tools.javac.jvm.ByteCodes.ishll;
  81 import static com.sun.tools.javac.jvm.ByteCodes.lushrl;
  82 import static com.sun.tools.javac.jvm.ByteCodes.lxor;
  83 import static com.sun.tools.javac.jvm.ByteCodes.string_add;
  84 
  85 /** Root class for Java symbols. It contains subclasses
  86  *  for specific sorts of symbols, such as variables, methods and operators,
  87  *  types, packages. Each subclass is represented as a static inner class
  88  *  inside Symbol.
  89  *
  90  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  91  *  If you write code that depends on this, you do so at your own risk.
  92  *  This code and its internal interfaces are subject to change or
  93  *  deletion without notice.&lt;/b&gt;
  94  */
  95 public abstract class Symbol extends AnnoConstruct implements PoolConstant, Element {
  96 
  97     /** The kind of this symbol.
  98      *  @see Kinds
  99      */
 100     public Kind kind;
 101 
 102     /** The flags of this symbol.
 103      */
 104     public long flags_field;
 105 
 106     /** An accessor method for the flags of this symbol.
 107      *  Flags of class symbols should be accessed through the accessor
 108      *  method to make sure that the class symbol is loaded.
 109      */
 110     public long flags() { return flags_field; }
 111 
 112     /** The name of this symbol in Utf8 representation.
 113      */
 114     public Name name;
 115 
 116     /** The type of this symbol.
 117      */
 118     public Type type;
 119 
 120     /** The owner of this symbol.
 121      */
 122     public Symbol owner;
 123 
 124     /** The completer of this symbol.
 125      * This should never equal null (NULL_COMPLETER should be used instead).
 126      */
 127     public Completer completer;
 128 
 129     /** A cache for the type erasure of this symbol.
 130      */
 131     public Type erasure_field;
 132 
 133     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;annotations&quot;&gt;
 134 
 135     /** The attributes of this symbol are contained in this
 136      * SymbolMetadata. The SymbolMetadata instance is NOT immutable.
 137      */
 138     protected SymbolMetadata metadata;
 139 
 140 
 141     /** An accessor method for the attributes of this symbol.
 142      *  Attributes of class symbols should be accessed through the accessor
 143      *  method to make sure that the class symbol is loaded.
 144      */
 145     public List&lt;Attribute.Compound&gt; getRawAttributes() {
 146         return (metadata == null)
 147                 ? List.nil()
 148                 : metadata.getDeclarationAttributes();
 149     }
 150 
 151     /** An accessor method for the type attributes of this symbol.
 152      *  Attributes of class symbols should be accessed through the accessor
 153      *  method to make sure that the class symbol is loaded.
 154      */
 155     public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
 156         return (metadata == null)
 157                 ? List.nil()
 158                 : metadata.getTypeAttributes();
 159     }
 160 
 161     /** Fetch a particular annotation from a symbol. */
 162     public Attribute.Compound attribute(Symbol anno) {
 163         for (Attribute.Compound a : getRawAttributes()) {
 164             if (a.type.tsym == anno) return a;
 165         }
 166         return null;
 167     }
 168 
 169     public boolean annotationsPendingCompletion() {
 170         return metadata == null ? false : metadata.pendingCompletion();
 171     }
 172 
 173     public void appendAttributes(List&lt;Attribute.Compound&gt; l) {
 174         if (l.nonEmpty()) {
 175             initedMetadata().append(l);
 176         }
 177     }
 178 
 179     public void appendClassInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 180         if (l.nonEmpty()) {
 181             initedMetadata().appendClassInitTypeAttributes(l);
 182         }
 183     }
 184 
 185     public void appendInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 186         if (l.nonEmpty()) {
 187             initedMetadata().appendInitTypeAttributes(l);
 188         }
 189     }
 190 
 191     public void appendUniqueTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 192         if (l.nonEmpty()) {
 193             initedMetadata().appendUniqueTypes(l);
 194         }
 195     }
 196 
 197     public List&lt;Attribute.TypeCompound&gt; getClassInitTypeAttributes() {
 198         return (metadata == null)
 199                 ? List.nil()
 200                 : metadata.getClassInitTypeAttributes();
 201     }
 202 
 203     public List&lt;Attribute.TypeCompound&gt; getInitTypeAttributes() {
 204         return (metadata == null)
 205                 ? List.nil()
 206                 : metadata.getInitTypeAttributes();
 207     }
 208 
 209     public void setInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 210         initedMetadata().setInitTypeAttributes(l);
 211     }
 212 
 213     public void setClassInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 214         initedMetadata().setClassInitTypeAttributes(l);
 215     }
 216 
 217     public List&lt;Attribute.Compound&gt; getDeclarationAttributes() {
 218         return (metadata == null)
 219                 ? List.nil()
 220                 : metadata.getDeclarationAttributes();
 221     }
 222 
 223     public boolean hasAnnotations() {
 224         return (metadata != null &amp;&amp; !metadata.isEmpty());
 225     }
 226 
 227     public boolean hasTypeAnnotations() {
 228         return (metadata != null &amp;&amp; !metadata.isTypesEmpty());
 229     }
 230 
 231     public boolean isCompleted() {
 232         return completer.isTerminal();
 233     }
 234 
 235     public void prependAttributes(List&lt;Attribute.Compound&gt; l) {
 236         if (l.nonEmpty()) {
 237             initedMetadata().prepend(l);
 238         }
 239     }
 240 
 241     public void resetAnnotations() {
 242         initedMetadata().reset();
 243     }
 244 
 245     public void setAttributes(Symbol other) {
 246         if (metadata != null || other.metadata != null) {
 247             initedMetadata().setAttributes(other.metadata);
 248         }
 249     }
 250 
 251     public void setDeclarationAttributes(List&lt;Attribute.Compound&gt; a) {
 252         if (metadata != null || a.nonEmpty()) {
 253             initedMetadata().setDeclarationAttributes(a);
 254         }
 255     }
 256 
 257     public void setTypeAttributes(List&lt;Attribute.TypeCompound&gt; a) {
 258         if (metadata != null || a.nonEmpty()) {
 259             if (metadata == null)
 260                 metadata = new SymbolMetadata(this);
 261             metadata.setTypeAttributes(a);
 262         }
 263     }
 264 
 265     private SymbolMetadata initedMetadata() {
 266         if (metadata == null)
 267             metadata = new SymbolMetadata(this);
 268         return metadata;
 269     }
 270 
 271     /** This method is intended for debugging only. */
 272     public SymbolMetadata getMetadata() {
 273         return metadata;
 274     }
 275 
 276     // &lt;/editor-fold&gt;
 277 
 278     /** Construct a symbol with given kind, flags, name, type and owner.
 279      */
 280     public Symbol(Kind kind, long flags, Name name, Type type, Symbol owner) {
 281         this.kind = kind;
 282         this.flags_field = flags;
 283         this.type = type;
 284         this.owner = owner;
 285         this.completer = Completer.NULL_COMPLETER;
 286         this.erasure_field = null;
 287         this.name = name;
 288     }
 289 
 290     @Override
 291     public int poolTag() {
 292         throw new AssertionError(&quot;Invalid pool entry&quot;);
 293     }
 294 
 295     /** Clone this symbol with new owner.
 296      *  Legal only for fields and methods.
 297      */
 298     public Symbol clone(Symbol newOwner) {
 299         throw new AssertionError();
 300     }
 301 
 302     public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 303         return v.visitSymbol(this, p);
 304     }
 305 
 306     /** The Java source which this symbol represents.
 307      *  A description of this symbol; overrides Object.
 308      */
 309     public String toString() {
 310         return name.toString();
 311     }
 312 
 313     /** A Java source description of the location of this symbol; used for
 314      *  error reporting.
 315      *
 316      * @return null if the symbol is a package or a toplevel class defined in
 317      * the default package; otherwise, the owner symbol is returned
 318      */
 319     public Symbol location() {
 320         if (owner.name == null || (owner.name.isEmpty() &amp;&amp;
 321                                    (owner.flags() &amp; BLOCK) == 0 &amp;&amp;
 322                                    owner.kind != PCK &amp;&amp;
 323                                    owner.kind != TYP)) {
 324             return null;
 325         }
 326         return owner;
 327     }
 328 
 329     public Symbol location(Type site, Types types) {
 330         if (owner.name == null || owner.name.isEmpty()) {
 331             return location();
 332         }
 333         if (owner.type.hasTag(CLASS)) {
 334             Type ownertype = types.asOuterSuper(site, owner);
 335             if (ownertype != null) return ownertype.tsym;
 336         }
 337         return owner;
 338     }
 339 
 340     public Symbol baseSymbol() {
 341         return this;
 342     }
 343 
 344     /** The symbol&#39;s erased type.
 345      */
 346     public Type erasure(Types types) {
 347         if (erasure_field == null)
 348             erasure_field = types.erasure(type);
 349         return erasure_field;
 350     }
 351 
 352     /** The external type of a symbol. This is the symbol&#39;s erased type
 353      *  except for constructors of inner classes which get the enclosing
 354      *  instance class added as first argument.
 355      */
 356     public Type externalType(Types types) {
 357         Type t = erasure(types);
 358         if (name == name.table.names.init &amp;&amp; owner.hasOuterInstance()) {
 359             Type outerThisType = types.erasure(owner.type.getEnclosingType());
 360             return new MethodType(t.getParameterTypes().prepend(outerThisType),
 361                                   t.getReturnType(),
 362                                   t.getThrownTypes(),
 363                                   t.tsym);
 364         } else {
 365             return t;
 366         }
 367     }
 368 
 369     public boolean isDeprecated() {
 370         return (flags_field &amp; DEPRECATED) != 0;
 371     }
 372 
 373     public boolean hasDeprecatedAnnotation() {
 374         return (flags_field &amp; DEPRECATED_ANNOTATION) != 0;
 375     }
 376 
 377     public boolean isDeprecatedForRemoval() {
 378         return (flags_field &amp; DEPRECATED_REMOVAL) != 0;
 379     }
 380 
 381     public boolean isPreviewApi() {
 382         return (flags_field &amp; PREVIEW_API) != 0;
 383     }
 384 
 385     public boolean isDeprecatableViaAnnotation() {
 386         switch (getKind()) {
 387             case LOCAL_VARIABLE:
 388             case PACKAGE:
 389             case PARAMETER:
 390             case RESOURCE_VARIABLE:
 391             case EXCEPTION_PARAMETER:
 392                 return false;
 393             default:
 394                 return true;
 395         }
 396     }
 397 
 398     public boolean isStatic() {
 399         return
 400             (flags() &amp; STATIC) != 0 ||
 401             (owner.flags() &amp; INTERFACE) != 0 &amp;&amp; kind != MTH &amp;&amp;
 402              name != name.table.names._this;
 403     }
 404 
 405     public boolean isInterface() {
 406         return (flags() &amp; INTERFACE) != 0;
 407     }
 408 
 409     public boolean isAbstract() {
 410         return (flags_field &amp; ABSTRACT) != 0;
 411     }
 412 
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 
 417     public boolean isPublic() {
 418         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 419     }
 420 
 421     public boolean isEnum() {
 422         return (flags() &amp; ENUM) != 0;
 423     }
 424 
 425     public boolean isSealed() {
 426         return (flags_field &amp; SEALED) != 0;
 427     }
 428 
 429     public boolean isNonSealed() {
 430         return (flags_field &amp; NON_SEALED) != 0;
 431     }
 432 
 433     public boolean isFinal() {
 434         return (flags_field &amp; FINAL) != 0;
 435     }
 436 
 437    /** Is this symbol declared (directly or indirectly) local
 438      *  to a method or variable initializer?
 439      *  Also includes fields of inner classes which are in
 440      *  turn local to a method or variable initializer.
 441      */
 442     public boolean isLocal() {
 443         return
 444             (owner.kind.matches(KindSelector.VAL_MTH) ||
 445              (owner.kind == TYP &amp;&amp; owner.isLocal()));
 446     }
 447 
 448     /** Has this symbol an empty name? This includes anonymous
 449      *  inner classes.
 450      */
 451     public boolean isAnonymous() {
 452         return name.isEmpty();
 453     }
 454 
 455     /** Is this symbol a constructor?
 456      */
 457     public boolean isConstructor() {
 458         return name == name.table.names.init;
 459     }
 460 
 461     public boolean isDynamic() {
 462         return false;
 463     }
 464 
 465     /** The fully qualified name of this symbol.
 466      *  This is the same as the symbol&#39;s name except for class symbols,
 467      *  which are handled separately.
 468      */
 469     public Name getQualifiedName() {
 470         return name;
 471     }
 472 
 473     /** The fully qualified name of this symbol after converting to flat
 474      *  representation. This is the same as the symbol&#39;s name except for
 475      *  class symbols, which are handled separately.
 476      */
 477     public Name flatName() {
 478         return getQualifiedName();
 479     }
 480 
 481     /** If this is a class or package, its members, otherwise null.
 482      */
 483     public WriteableScope members() {
 484         return null;
 485     }
 486 
 487     /** A class is an inner class if it it has an enclosing instance class.
 488      */
 489     public boolean isInner() {
 490         return kind == TYP &amp;&amp; type.getEnclosingType().hasTag(CLASS);
 491     }
 492 
 493     /** An inner class has an outer instance if it is not an interface
 494      *  it has an enclosing instance class which might be referenced from the class.
 495      *  Nested classes can see instance members of their enclosing class.
 496      *  Their constructors carry an additional this$n parameter, inserted
 497      *  implicitly by the compiler.
 498      *
 499      *  @see #isInner
 500      */
 501     public boolean hasOuterInstance() {
 502         return
 503             type.getEnclosingType().hasTag(CLASS) &amp;&amp; (flags() &amp; (INTERFACE | NOOUTERTHIS)) == 0;
 504     }
 505 
 506     /** The closest enclosing class of this symbol&#39;s declaration.
 507      *  Warning: this (misnamed) method returns the receiver itself
 508      *  when the receiver is a class (as opposed to its enclosing
 509      *  class as one may be misled to believe.)
 510      */
 511     public ClassSymbol enclClass() {
 512         Symbol c = this;
 513         while (c != null &amp;&amp;
 514                (!c.kind.matches(KindSelector.TYP) || !c.type.hasTag(CLASS))) {
 515             c = c.owner;
 516         }
 517         return (ClassSymbol)c;
 518     }
 519 
 520     /** The outermost class which indirectly owns this symbol.
 521      */
 522     public ClassSymbol outermostClass() {
 523         Symbol sym = this;
 524         Symbol prev = null;
 525         while (sym.kind != PCK) {
 526             prev = sym;
 527             sym = sym.owner;
 528         }
 529         return (ClassSymbol) prev;
 530     }
 531 
 532     /** The package which indirectly owns this symbol.
 533      */
 534     public PackageSymbol packge() {
 535         Symbol sym = this;
 536         while (sym.kind != PCK) {
 537             sym = sym.owner;
 538         }
 539         return (PackageSymbol) sym;
 540     }
 541 
 542     /** Is this symbol a subclass of `base&#39;? Only defined for ClassSymbols.
 543      */
 544     public boolean isSubClass(Symbol base, Types types) {
 545         throw new AssertionError(&quot;isSubClass &quot; + this);
 546     }
 547 
 548     /** Fully check membership: hierarchy, protection, and hiding.
 549      *  Does not exclude methods not inherited due to overriding.
 550      */
 551     public boolean isMemberOf(TypeSymbol clazz, Types types) {
 552         return
 553             owner == clazz ||
 554             clazz.isSubClass(owner, types) &amp;&amp;
 555             isInheritedIn(clazz, types) &amp;&amp;
 556             !hiddenIn((ClassSymbol)clazz, types);
 557     }
 558 
 559     /** Is this symbol the same as or enclosed by the given class? */
 560     public boolean isEnclosedBy(ClassSymbol clazz) {
 561         for (Symbol sym = this; sym.kind != PCK; sym = sym.owner)
 562             if (sym == clazz) return true;
 563         return false;
 564     }
 565 
 566     private boolean hiddenIn(ClassSymbol clazz, Types types) {
 567         Symbol sym = hiddenInInternal(clazz, types);
 568         Assert.check(sym != null, &quot;the result of hiddenInInternal() can&#39;t be null&quot;);
 569         /* If we find the current symbol then there is no symbol hiding it
 570          */
 571         return sym != this;
 572     }
 573 
 574     /** This method looks in the supertypes graph that has the current class as the
 575      * initial node, till it finds the current symbol or another symbol that hides it.
 576      * If the current class has more than one supertype (extends one class and
 577      * implements one or more interfaces) then null can be returned, meaning that
 578      * a wrong path in the supertypes graph was selected. Null can only be returned
 579      * as a temporary value, as a result of the recursive call.
 580      */
 581     private Symbol hiddenInInternal(ClassSymbol currentClass, Types types) {
 582         if (currentClass == owner) {
 583             return this;
 584         }
 585         for (Symbol sym : currentClass.members().getSymbolsByName(name)) {
 586             if (sym.kind == kind &amp;&amp;
 587                     (kind != MTH ||
 588                     (sym.flags() &amp; STATIC) != 0 &amp;&amp;
 589                     types.isSubSignature(sym.type, type))) {
 590                 return sym;
 591             }
 592         }
 593         Symbol hiddenSym = null;
 594         for (Type st : types.interfaces(currentClass.type)
 595                 .prepend(types.supertype(currentClass.type))) {
 596             if (st != null &amp;&amp; (st.hasTag(CLASS))) {
 597                 Symbol sym = hiddenInInternal((ClassSymbol)st.tsym, types);
 598                 if (sym == this) {
 599                     return this;
 600                 } else if (sym != null) {
 601                     hiddenSym = sym;
 602                 }
 603             }
 604         }
 605         return hiddenSym;
 606     }
 607 
 608     /** Is this symbol accessible in a given class?
 609      *  PRE: If symbol&#39;s owner is a interface,
 610      *       it is already assumed that the interface is a superinterface
 611      *       the given class.
 612      *  @param clazz  The class for which we want to establish membership.
 613      *                This must be a subclass of the member&#39;s owner.
 614      */
 615     public final boolean isAccessibleIn(Symbol clazz, Types types) {
 616         switch ((int)(flags_field &amp; Flags.AccessFlags)) {
 617         default: // error recovery
 618         case PUBLIC:
 619             return true;
 620         case PRIVATE:
 621             return this.owner == clazz;
 622         case PROTECTED:
 623             // we model interfaces as extending Object
 624             return (clazz.flags() &amp; INTERFACE) == 0;
 625         case 0:
 626             PackageSymbol thisPackage = this.packge();
 627             for (Symbol sup = clazz;
 628                  sup != null &amp;&amp; sup != this.owner;
 629                  sup = types.supertype(sup.type).tsym) {
 630                 while (sup.type.hasTag(TYPEVAR))
 631                     sup = sup.type.getUpperBound().tsym;
 632                 if (sup.type.isErroneous())
 633                     return true; // error recovery
 634                 if ((sup.flags() &amp; COMPOUND) != 0)
 635                     continue;
 636                 if (sup.packge() != thisPackage)
 637                     return false;
 638             }
 639             return (clazz.flags() &amp; INTERFACE) == 0;
 640         }
 641     }
 642 
 643     /** Is this symbol inherited into a given class?
 644      *  PRE: If symbol&#39;s owner is a interface,
 645      *       it is already assumed that the interface is a superinterface
 646      *       of the given class.
 647      *  @param clazz  The class for which we want to establish membership.
 648      *                This must be a subclass of the member&#39;s owner.
 649      */
 650     public boolean isInheritedIn(Symbol clazz, Types types) {
 651         return isAccessibleIn(clazz, types);
 652     }
 653 
 654     /** The (variable or method) symbol seen as a member of given
 655      *  class type`site&#39; (this might change the symbol&#39;s type).
 656      *  This is used exclusively for producing diagnostics.
 657      */
 658     public Symbol asMemberOf(Type site, Types types) {
 659         throw new AssertionError();
 660     }
 661 
 662     /** Does this method symbol override `other&#39; symbol, when both are seen as
 663      *  members of class `origin&#39;?  It is assumed that _other is a member
 664      *  of origin.
 665      *
 666      *  It is assumed that both symbols have the same name.  The static
 667      *  modifier is ignored for this test.
 668      *
 669      *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
 670      */
 671     public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult) {
 672         return false;
 673     }
 674 
 675     /** Complete the elaboration of this symbol&#39;s definition.
 676      */
 677     public void complete() throws CompletionFailure {
 678         if (completer != Completer.NULL_COMPLETER) {
 679             Completer c = completer;
 680             completer = Completer.NULL_COMPLETER;
 681             c.complete(this);
 682         }
 683     }
 684 
 685     public void apiComplete() throws CompletionFailure {
 686         try {
 687             complete();
 688         } catch (CompletionFailure cf) {
 689             cf.dcfh.handleAPICompletionFailure(cf);
 690         }
 691     }
 692 
 693     /** True if the symbol represents an entity that exists.
 694      */
 695     public boolean exists() {
 696         return true;
 697     }
 698 
 699     @DefinedBy(Api.LANGUAGE_MODEL)
 700     public Type asType() {
 701         return type;
 702     }
 703 
 704     @DefinedBy(Api.LANGUAGE_MODEL)
 705     public Symbol getEnclosingElement() {
 706         return owner;
 707     }
 708 
 709     @DefinedBy(Api.LANGUAGE_MODEL)
 710     public ElementKind getKind() {
 711         return ElementKind.OTHER;       // most unkind
 712     }
 713 
 714     @DefinedBy(Api.LANGUAGE_MODEL)
 715     public Set&lt;Modifier&gt; getModifiers() {
 716         apiComplete();
 717         return Flags.asModifierSet(flags());
 718     }
 719 
 720     @DefinedBy(Api.LANGUAGE_MODEL)
 721     public Name getSimpleName() {
 722         return name;
 723     }
 724 
 725     /**
 726      * This is the implementation for {@code
 727      * javax.lang.model.element.Element.getAnnotationMirrors()}.
 728      */
 729     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 730     public List&lt;Attribute.Compound&gt; getAnnotationMirrors() {
 731         apiComplete();
 732         return getRawAttributes();
 733     }
 734 
 735 
 736     // TODO: getEnclosedElements should return a javac List, fix in FilteredMemberList
 737     @DefinedBy(Api.LANGUAGE_MODEL)
 738     public java.util.List&lt;Symbol&gt; getEnclosedElements() {
 739         return List.nil();
 740     }
 741 
 742     public List&lt;TypeVariableSymbol&gt; getTypeParameters() {
 743         ListBuffer&lt;TypeVariableSymbol&gt; l = new ListBuffer&lt;&gt;();
 744         for (Type t : type.getTypeArguments()) {
 745             Assert.check(t.tsym.getKind() == ElementKind.TYPE_PARAMETER);
 746             l.append((TypeVariableSymbol)t.tsym);
 747         }
 748         return l.toList();
 749     }
 750 
 751     public static class DelegatedSymbol&lt;T extends Symbol&gt; extends Symbol {
 752         protected T other;
 753         public DelegatedSymbol(T other) {
 754             super(other.kind, other.flags_field, other.name, other.type, other.owner);
 755             this.other = other;
 756         }
 757         public String toString() { return other.toString(); }
 758         public Symbol location() { return other.location(); }
 759         public Symbol location(Type site, Types types) { return other.location(site, types); }
 760         public Symbol baseSymbol() { return other; }
 761         public Type erasure(Types types) { return other.erasure(types); }
 762         public Type externalType(Types types) { return other.externalType(types); }
 763         public boolean isLocal() { return other.isLocal(); }
 764         public boolean isConstructor() { return other.isConstructor(); }
 765         public Name getQualifiedName() { return other.getQualifiedName(); }
 766         public Name flatName() { return other.flatName(); }
 767         public WriteableScope members() { return other.members(); }
 768         public boolean isInner() { return other.isInner(); }
 769         public boolean hasOuterInstance() { return other.hasOuterInstance(); }
 770         public ClassSymbol enclClass() { return other.enclClass(); }
 771         public ClassSymbol outermostClass() { return other.outermostClass(); }
 772         public PackageSymbol packge() { return other.packge(); }
 773         public boolean isSubClass(Symbol base, Types types) { return other.isSubClass(base, types); }
 774         public boolean isMemberOf(TypeSymbol clazz, Types types) { return other.isMemberOf(clazz, types); }
 775         public boolean isEnclosedBy(ClassSymbol clazz) { return other.isEnclosedBy(clazz); }
 776         public boolean isInheritedIn(Symbol clazz, Types types) { return other.isInheritedIn(clazz, types); }
 777         public Symbol asMemberOf(Type site, Types types) { return other.asMemberOf(site, types); }
 778         public void complete() throws CompletionFailure { other.complete(); }
 779 
 780         @DefinedBy(Api.LANGUAGE_MODEL)
 781         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
 782             return other.accept(v, p);
 783         }
 784 
 785         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 786             return v.visitSymbol(other, p);
 787         }
 788 
 789         public T getUnderlyingSymbol() {
 790             return other;
 791         }
 792     }
 793 
 794     /** A base class for Symbols representing types.
 795      */
 796     public static abstract class TypeSymbol extends Symbol {
 797         public TypeSymbol(Kind kind, long flags, Name name, Type type, Symbol owner) {
 798             super(kind, flags, name, type, owner);
 799         }
 800         /** form a fully qualified name from a name and an owner
 801          */
 802         static public Name formFullName(Name name, Symbol owner) {
 803             if (owner == null) return name;
 804             if ((owner.kind != ERR) &amp;&amp;
 805                 (owner.kind.matches(KindSelector.VAL_MTH) ||
 806                  (owner.kind == TYP &amp;&amp; owner.type.hasTag(TYPEVAR))
 807                  )) return name;
 808             Name prefix = owner.getQualifiedName();
 809             if (prefix == null || prefix == prefix.table.names.empty)
 810                 return name;
 811             else return prefix.append(&#39;.&#39;, name);
 812         }
 813 
 814         /** form a fully qualified name from a name and an owner, after
 815          *  converting to flat representation
 816          */
 817         static public Name formFlatName(Name name, Symbol owner) {
 818             if (owner == null || owner.kind.matches(KindSelector.VAL_MTH) ||
 819                 (owner.kind == TYP &amp;&amp; owner.type.hasTag(TYPEVAR))
 820                 ) return name;
 821             char sep = owner.kind == TYP ? &#39;$&#39; : &#39;.&#39;;
 822             Name prefix = owner.flatName();
 823             if (prefix == null || prefix == prefix.table.names.empty)
 824                 return name;
 825             else return prefix.append(sep, name);
 826         }
 827 
 828         /**
 829          * A partial ordering between type symbols that refines the
 830          * class inheritance graph.
 831          *
 832          * Type variables always precede other kinds of symbols.
 833          */
 834         public final boolean precedes(TypeSymbol that, Types types) {
 835             if (this == that)
 836                 return false;
 837             if (type.hasTag(that.type.getTag())) {
 838                 if (type.hasTag(CLASS)) {
 839                     return
 840                         types.rank(that.type) &lt; types.rank(this.type) ||
 841                         types.rank(that.type) == types.rank(this.type) &amp;&amp;
 842                         that.getQualifiedName().compareTo(this.getQualifiedName()) &lt; 0;
 843                 } else if (type.hasTag(TYPEVAR)) {
 844                     return types.isSubtype(this.type, that.type);
 845                 }
 846             }
 847             return type.hasTag(TYPEVAR);
 848         }
 849 
 850         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 851         public List&lt;Symbol&gt; getEnclosedElements() {
 852             List&lt;Symbol&gt; list = List.nil();
 853             if (kind == TYP &amp;&amp; type.hasTag(TYPEVAR)) {
 854                 return list;
 855             }
 856             apiComplete();
 857             for (Symbol sym : members().getSymbols(NON_RECURSIVE)) {
 858                 sym.apiComplete();
 859                 if ((sym.flags() &amp; SYNTHETIC) == 0 &amp;&amp; sym.owner == this &amp;&amp; sym.kind != ERR) {
 860                     list = list.prepend(sym);
 861                 }
 862             }
 863             return list;
 864         }
 865 
 866         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
 867             Assert.error(&quot;Only on ClassSymbol&quot;);
 868             return null; //unreachable
 869         }
 870 
 871         public boolean isAnnotationType() { return false; }
 872 
 873         @Override
 874         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 875             return v.visitTypeSymbol(this, p);
 876         }
 877     }
 878 
 879     /**
 880      * Type variables are represented by instances of this class.
 881      */
 882     public static class TypeVariableSymbol
 883             extends TypeSymbol implements TypeParameterElement {
 884 
 885         public TypeVariableSymbol(long flags, Name name, Type type, Symbol owner) {
 886             super(TYP, flags, name, type, owner);
 887         }
 888 
 889         @DefinedBy(Api.LANGUAGE_MODEL)
 890         public ElementKind getKind() {
 891             return ElementKind.TYPE_PARAMETER;
 892         }
 893 
 894         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 895         public Symbol getGenericElement() {
 896             return owner;
 897         }
 898 
 899         @DefinedBy(Api.LANGUAGE_MODEL)
 900         public List&lt;Type&gt; getBounds() {
 901             TypeVar t = (TypeVar)type;
 902             Type bound = t.getUpperBound();
 903             if (!bound.isCompound())
 904                 return List.of(bound);
 905             ClassType ct = (ClassType)bound;
 906             if (!ct.tsym.erasure_field.isInterface()) {
 907                 return ct.interfaces_field.prepend(ct.supertype_field);
 908             } else {
 909                 // No superclass was given in bounds.
 910                 // In this case, supertype is Object, erasure is first interface.
 911                 return ct.interfaces_field;
 912             }
 913         }
 914 
 915         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 916         public List&lt;Attribute.Compound&gt; getAnnotationMirrors() {
 917             // Declaration annotations on type variables are stored in type attributes
 918             // on the owner of the TypeVariableSymbol
 919             List&lt;Attribute.TypeCompound&gt; candidates = owner.getRawTypeAttributes();
 920             int index = owner.getTypeParameters().indexOf(this);
 921             List&lt;Attribute.Compound&gt; res = List.nil();
 922             for (Attribute.TypeCompound a : candidates) {
 923                 if (isCurrentSymbolsAnnotation(a, index))
 924                     res = res.prepend(a);
 925             }
 926 
 927             return res.reverse();
 928         }
 929 
 930         // Helper to getAnnotation[s]
 931         @Override
 932         public &lt;A extends Annotation&gt; Attribute.Compound getAttribute(Class&lt;A&gt; annoType) {
 933             String name = annoType.getName();
 934 
 935             // Declaration annotations on type variables are stored in type attributes
 936             // on the owner of the TypeVariableSymbol
 937             List&lt;Attribute.TypeCompound&gt; candidates = owner.getRawTypeAttributes();
 938             int index = owner.getTypeParameters().indexOf(this);
 939             for (Attribute.TypeCompound anno : candidates)
 940                 if (isCurrentSymbolsAnnotation(anno, index) &amp;&amp;
 941                     name.contentEquals(anno.type.tsym.flatName()))
 942                     return anno;
 943 
 944             return null;
 945         }
 946             //where:
 947             boolean isCurrentSymbolsAnnotation(Attribute.TypeCompound anno, int index) {
 948                 return (anno.position.type == TargetType.CLASS_TYPE_PARAMETER ||
 949                         anno.position.type == TargetType.METHOD_TYPE_PARAMETER) &amp;&amp;
 950                         anno.position.parameter_index == index;
 951             }
 952 
 953 
 954         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 955         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
 956             return v.visitTypeParameter(this, p);
 957         }
 958     }
 959     /** A class for module symbols.
 960      */
 961     public static class ModuleSymbol extends TypeSymbol
 962             implements ModuleElement {
 963 
 964         public Name version;
 965         public JavaFileManager.Location sourceLocation;
 966         public JavaFileManager.Location classLocation;
 967         public JavaFileManager.Location patchLocation;
 968         public JavaFileManager.Location patchOutputLocation;
 969 
 970         /** All directives, in natural order. */
 971         public List&lt;com.sun.tools.javac.code.Directive&gt; directives;
 972         public List&lt;com.sun.tools.javac.code.Directive.RequiresDirective&gt; requires;
 973         public List&lt;com.sun.tools.javac.code.Directive.ExportsDirective&gt; exports;
 974         public List&lt;com.sun.tools.javac.code.Directive.OpensDirective&gt; opens;
 975         public List&lt;com.sun.tools.javac.code.Directive.ProvidesDirective&gt; provides;
 976         public List&lt;com.sun.tools.javac.code.Directive.UsesDirective&gt; uses;
 977 
 978         public ClassSymbol module_info;
 979 
 980         public PackageSymbol unnamedPackage;
 981         public Map&lt;Name, PackageSymbol&gt; visiblePackages;
 982         public Set&lt;ModuleSymbol&gt; readModules;
 983         public List&lt;Symbol&gt; enclosedPackages = List.nil();
 984 
 985         public Completer usesProvidesCompleter = Completer.NULL_COMPLETER;
 986         public final Set&lt;ModuleFlags&gt; flags = EnumSet.noneOf(ModuleFlags.class);
 987         public final Set&lt;ModuleResolutionFlags&gt; resolutionFlags = EnumSet.noneOf(ModuleResolutionFlags.class);
 988 
 989         /**
 990          * Create a ModuleSymbol with an associated module-info ClassSymbol.
 991          */
 992         public static ModuleSymbol create(Name name, Name module_info) {
 993             ModuleSymbol msym = new ModuleSymbol(name, null);
 994             ClassSymbol info = new ClassSymbol(Flags.MODULE, module_info, msym);
 995             info.fullname = formFullName(module_info, msym);
 996             info.flatname = info.fullname;
 997             info.members_field = WriteableScope.create(info);
 998             msym.module_info = info;
 999             return msym;
1000         }
1001 
1002         public ModuleSymbol(Name name, Symbol owner) {
1003             super(MDL, 0, name, null, owner);
1004             Assert.checkNonNull(name);
1005             this.type = new ModuleType(this);
1006         }
1007 
1008         @Override
1009         public int poolTag() {
1010             return ClassFile.CONSTANT_Module;
1011         }
1012 
1013         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1014         public Name getSimpleName() {
1015             return Convert.shortName(name);
1016         }
1017 
1018         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1019         public boolean isOpen() {
1020             return flags.contains(ModuleFlags.OPEN);
1021         }
1022 
1023         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1024         public boolean isUnnamed() {
1025             return name.isEmpty() &amp;&amp; owner == null;
1026         }
1027 
1028         @Override
1029         public boolean isDeprecated() {
1030             return hasDeprecatedAnnotation();
1031         }
1032 
1033         public boolean isNoModule() {
1034             return false;
1035         }
1036 
1037         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1038         public ElementKind getKind() {
1039             return ElementKind.MODULE;
1040         }
1041 
1042         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1043         public java.util.List&lt;Directive&gt; getDirectives() {
1044             apiComplete();
1045             completeUsesProvides();
1046             return Collections.unmodifiableList(directives);
1047         }
1048 
1049         public void completeUsesProvides() {
1050             if (usesProvidesCompleter != Completer.NULL_COMPLETER) {
1051                 Completer c = usesProvidesCompleter;
1052                 usesProvidesCompleter = Completer.NULL_COMPLETER;
1053                 c.complete(this);
1054             }
1055         }
1056 
1057         @Override
1058         public ClassSymbol outermostClass() {
1059             return null;
1060         }
1061 
1062         @Override
1063         public String toString() {
1064             // TODO: the following strings should be localized
1065             // Do this with custom anon subtypes in Symtab
1066             String n = (name == null) ? &quot;&lt;unknown&gt;&quot;
1067                     : (name.isEmpty()) ? &quot;&lt;unnamed&gt;&quot;
1068                     : String.valueOf(name);
1069             return n;
1070         }
1071 
1072         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1073         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1074             return v.visitModule(this, p);
1075         }
1076 
1077         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1078         public List&lt;Symbol&gt; getEnclosedElements() {
1079             List&lt;Symbol&gt; list = List.nil();
1080             for (Symbol sym : enclosedPackages) {
1081                 if (sym.members().anyMatch(m -&gt; m.kind == TYP))
1082                     list = list.prepend(sym);
1083             }
1084             return list;
1085         }
1086 
1087         public void reset() {
1088             this.directives = null;
1089             this.requires = null;
1090             this.exports = null;
1091             this.provides = null;
1092             this.uses = null;
1093             this.visiblePackages = null;
1094         }
1095 
1096     }
1097 
1098     public enum ModuleFlags {
1099         OPEN(0x0020),
1100         SYNTHETIC(0x1000),
1101         MANDATED(0x8000);
1102 
1103         public static int value(Set&lt;ModuleFlags&gt; s) {
1104             int v = 0;
1105             for (ModuleFlags f: s)
1106                 v |= f.value;
1107             return v;
1108         }
1109 
1110         private ModuleFlags(int value) {
1111             this.value = value;
1112         }
1113 
1114         public final int value;
1115     }
1116 
1117     public enum ModuleResolutionFlags {
1118         DO_NOT_RESOLVE_BY_DEFAULT(0x0001),
1119         WARN_DEPRECATED(0x0002),
1120         WARN_DEPRECATED_REMOVAL(0x0004),
1121         WARN_INCUBATING(0x0008);
1122 
1123         public static int value(Set&lt;ModuleResolutionFlags&gt; s) {
1124             int v = 0;
1125             for (ModuleResolutionFlags f: s)
1126                 v |= f.value;
1127             return v;
1128         }
1129 
1130         private ModuleResolutionFlags(int value) {
1131             this.value = value;
1132         }
1133 
1134         public final int value;
1135     }
1136 
1137     /** A class for package symbols
1138      */
1139     public static class PackageSymbol extends TypeSymbol
1140         implements PackageElement {
1141 
1142         public WriteableScope members_field;
1143         public Name fullname;
1144         public ClassSymbol package_info; // see bug 6443073
1145         public ModuleSymbol modle;
1146         // the file containing the documentation comments for the package
1147         public JavaFileObject sourcefile;
1148 
1149         public PackageSymbol(Name name, Type type, Symbol owner) {
1150             super(PCK, 0, name, type, owner);
1151             this.members_field = null;
1152             this.fullname = formFullName(name, owner);
1153         }
1154 
1155         public PackageSymbol(Name name, Symbol owner) {
1156             this(name, null, owner);
1157             this.type = new PackageType(this);
1158         }
1159 
1160         public String toString() {
1161             return fullname.toString();
1162         }
1163 
1164         @DefinedBy(Api.LANGUAGE_MODEL)
1165         public Name getQualifiedName() {
1166             return fullname;
1167         }
1168 
1169         @DefinedBy(Api.LANGUAGE_MODEL)
1170         public boolean isUnnamed() {
1171             return name.isEmpty() &amp;&amp; owner != null;
1172         }
1173 
1174         public WriteableScope members() {
1175             complete();
1176             return members_field;
1177         }
1178 
1179         @Override
1180         public int poolTag() {
1181             return ClassFile.CONSTANT_Package;
1182         }
1183 
1184         public long flags() {
1185             complete();
1186             return flags_field;
1187         }
1188 
1189         @Override
1190         public List&lt;Attribute.Compound&gt; getRawAttributes() {
1191             complete();
1192             if (package_info != null) {
1193                 package_info.complete();
1194                 mergeAttributes();
1195             }
1196             return super.getRawAttributes();
1197         }
1198 
1199         private void mergeAttributes() {
1200             if (metadata == null &amp;&amp;
1201                 package_info.metadata != null) {
1202                 metadata = new SymbolMetadata(this);
1203                 metadata.setAttributes(package_info.metadata);
1204             }
1205         }
1206 
1207         /** A package &quot;exists&quot; if a type or package that exists has
1208          *  been seen within it.
1209          */
1210         public boolean exists() {
1211             return (flags_field &amp; EXISTS) != 0;
1212         }
1213 
1214         @DefinedBy(Api.LANGUAGE_MODEL)
1215         public ElementKind getKind() {
1216             return ElementKind.PACKAGE;
1217         }
1218 
1219         @DefinedBy(Api.LANGUAGE_MODEL)
1220         public Symbol getEnclosingElement() {
1221             return modle != null &amp;&amp; !modle.isNoModule() ? modle : null;
1222         }
1223 
1224         @DefinedBy(Api.LANGUAGE_MODEL)
1225         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1226             return v.visitPackage(this, p);
1227         }
1228 
1229         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1230             return v.visitPackageSymbol(this, p);
1231         }
1232 
1233         /**Resets the Symbol into the state good for next round of annotation processing.*/
1234         public void reset() {
1235             metadata = null;
1236         }
1237 
1238     }
1239 
1240     public static class RootPackageSymbol extends PackageSymbol {
1241         public final MissingInfoHandler missingInfoHandler;
1242         public final boolean allowPrivateInvokeVirtual;
1243 
1244         public RootPackageSymbol(Name name, Symbol owner,
1245                                  MissingInfoHandler missingInfoHandler,
1246                                  boolean allowPrivateInvokeVirtual) {
1247             super(name, owner);
1248             this.missingInfoHandler = missingInfoHandler;
1249             this.allowPrivateInvokeVirtual = allowPrivateInvokeVirtual;
1250         }
1251 
1252     }
1253 
1254     /** A class for class symbols
1255      */
1256     public static class ClassSymbol extends TypeSymbol implements TypeElement {
1257 
1258         /** a scope for all class members; variables, methods and inner classes
1259          *  type parameters are not part of this scope
1260          */
1261         public WriteableScope members_field;
1262 
1263         /** the fully qualified name of the class, i.e. pck.outer.inner.
1264          *  null for anonymous classes
1265          */
1266         public Name fullname;
1267 
1268         /** the fully qualified name of the class after converting to flat
1269          *  representation, i.e. pck.outer$inner,
1270          *  set externally for local and anonymous classes
1271          */
1272         public Name flatname;
1273 
1274         /** the sourcefile where the class came from
1275          */
1276         public JavaFileObject sourcefile;
1277 
1278         /** the classfile from where to load this class
1279          *  this will have extension .class or .java
1280          */
1281         public JavaFileObject classfile;
1282 
1283         /** the list of translated local classes (used for generating
1284          * InnerClasses attribute)
1285          */
1286         public List&lt;ClassSymbol&gt; trans_local;
1287 
1288         /** the annotation metadata attached to this class */
1289         private AnnotationTypeMetadata annotationTypeMetadata;
1290 
1291         /* the list of any of record components, only non empty if the class is a record
1292          * and it has at least one record component
1293          */
1294         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1295 
1296         // sealed classes related fields
1297         /** The classes, or interfaces, permitted to extend this class, or interface
1298          */
1299         public List&lt;Symbol&gt; permitted;
1300 
1301         public boolean isPermittedExplicit = false;
1302 
1303         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1304             super(TYP, flags, name, type, owner);
1305             this.members_field = null;
1306             this.fullname = formFullName(name, owner);
1307             this.flatname = formFlatName(name, owner);
1308             this.sourcefile = null;
1309             this.classfile = null;
1310             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1311             this.permitted = List.nil();
1312         }
1313 
1314         public ClassSymbol(long flags, Name name, Symbol owner) {
1315             this(
1316                 flags,
1317                 name,
1318                 new ClassType(Type.noType, null, null),
1319                 owner);
1320             this.type.tsym = this;
1321         }
1322 
1323         /** The Java source which this symbol represents.
1324          */
1325         public String toString() {
1326             return className();
1327         }
1328 
1329         public long flags() {
1330             complete();
1331             return flags_field;
1332         }
1333 
1334         public WriteableScope members() {
1335             complete();
1336             return members_field;
1337         }
1338 
1339         @Override
1340         public List&lt;Attribute.Compound&gt; getRawAttributes() {
1341             complete();
1342             return super.getRawAttributes();
1343         }
1344 
1345         @Override
1346         public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
1347             complete();
1348             return super.getRawTypeAttributes();
1349         }
1350 
1351         public Type erasure(Types types) {
1352             if (erasure_field == null)
1353                 erasure_field = new ClassType(types.erasure(type.getEnclosingType()),
1354                                               List.nil(), this,
1355                                               type.getMetadata());
1356             return erasure_field;
1357         }
1358 
1359         public String className() {
1360             if (name.isEmpty())
1361                 return
1362                     Log.getLocalizedString(&quot;anonymous.class&quot;, flatname);
1363             else
1364                 return fullname.toString();
1365         }
1366 
1367         @DefinedBy(Api.LANGUAGE_MODEL)
1368         public Name getQualifiedName() {
1369             return fullname;
1370         }
1371 
1372         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1373         public List&lt;Symbol&gt; getEnclosedElements() {
1374             List&lt;Symbol&gt; result = super.getEnclosedElements();
1375             if (!recordComponents.isEmpty()) {
1376                 List&lt;RecordComponent&gt; reversed = recordComponents.reverse();
1377                 for (RecordComponent rc : reversed) {
1378                     result = result.prepend(rc);
1379                 }
1380             }
1381             return result;
1382         }
1383 
1384         public Name flatName() {
1385             return flatname;
1386         }
1387 
1388         public boolean isSubClass(Symbol base, Types types) {
1389             if (this == base) {
1390                 return true;
1391             } else if ((base.flags() &amp; INTERFACE) != 0) {
1392                 for (Type t = type; t.hasTag(CLASS); t = types.supertype(t))
1393                     for (List&lt;Type&gt; is = types.interfaces(t);
1394                          is.nonEmpty();
1395                          is = is.tail)
1396                         if (is.head.tsym.isSubClass(base, types)) return true;
1397             } else {
1398                 for (Type t = type; t.hasTag(CLASS); t = types.supertype(t))
1399                     if (t.tsym == base) return true;
1400             }
1401             return false;
1402         }
1403 
1404         /** Complete the elaboration of this symbol&#39;s definition.
1405          */
1406         public void complete() throws CompletionFailure {
1407             Completer origCompleter = completer;
1408             try {
1409                 super.complete();
1410             } catch (CompletionFailure ex) {
1411                 ex.dcfh.classSymbolCompleteFailed(this, origCompleter);
1412                 // quiet error recovery
1413                 flags_field |= (PUBLIC|STATIC);
1414                 this.type = new ErrorType(this, Type.noType);
1415                 throw ex;
1416             }
1417         }
1418 
1419         @DefinedBy(Api.LANGUAGE_MODEL)
1420         public List&lt;Type&gt; getInterfaces() {
1421             apiComplete();
1422             if (type instanceof ClassType) {
1423                 ClassType t = (ClassType)type;
1424                 if (t.interfaces_field == null) // FIXME: shouldn&#39;t be null
1425                     t.interfaces_field = List.nil();
1426                 if (t.all_interfaces_field != null)
1427                     return Type.getModelTypes(t.all_interfaces_field);
1428                 return t.interfaces_field;
1429             } else {
1430                 return List.nil();
1431             }
1432         }
1433 
1434         @DefinedBy(Api.LANGUAGE_MODEL)
1435         public Type getSuperclass() {
1436             apiComplete();
1437             if (type instanceof ClassType) {
1438                 ClassType t = (ClassType)type;
1439                 if (t.supertype_field == null) // FIXME: shouldn&#39;t be null
1440                     t.supertype_field = Type.noType;
1441                 // An interface has no superclass; its supertype is Object.
1442                 return t.isInterface()
1443                     ? Type.noType
1444                     : t.supertype_field.getModelType();
1445             } else {
1446                 return Type.noType;
1447             }
1448         }
1449 
1450         /**
1451          * Returns the next class to search for inherited annotations or {@code null}
1452          * if the next class can&#39;t be found.
1453          */
1454         private ClassSymbol getSuperClassToSearchForAnnotations() {
1455 
1456             Type sup = getSuperclass();
1457 
1458             if (!sup.hasTag(CLASS) || sup.isErroneous())
1459                 return null;
1460 
1461             return (ClassSymbol) sup.tsym;
1462         }
1463 
1464 
1465         @Override
1466         protected &lt;A extends Annotation&gt; A[] getInheritedAnnotations(Class&lt;A&gt; annoType) {
1467 
1468             ClassSymbol sup = getSuperClassToSearchForAnnotations();
1469 
1470             return sup == null ? super.getInheritedAnnotations(annoType)
1471                                : sup.getAnnotationsByType(annoType);
1472         }
1473 
1474 
1475         @DefinedBy(Api.LANGUAGE_MODEL)
1476         @SuppressWarnings(&quot;preview&quot;)
1477         public ElementKind getKind() {
1478             apiComplete();
1479             long flags = flags();
1480             if ((flags &amp; ANNOTATION) != 0)
1481                 return ElementKind.ANNOTATION_TYPE;
1482             else if ((flags &amp; INTERFACE) != 0)
1483                 return ElementKind.INTERFACE;
1484             else if ((flags &amp; ENUM) != 0)
1485                 return ElementKind.ENUM;
1486             else if ((flags &amp; RECORD) != 0)
1487                 return ElementKind.RECORD;
1488             else
1489                 return ElementKind.CLASS;
1490         }
1491 
1492         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1493         public Set&lt;Modifier&gt; getModifiers() {
1494             apiComplete();
1495             long flags = flags();
1496             return Flags.asModifierSet(flags &amp; ~DEFAULT);
1497         }
1498 
1499         public RecordComponent getRecordComponent(VarSymbol field) {
1500             for (RecordComponent rc : recordComponents) {
1501                 if (rc.name == field.name) {
1502                     return rc;
1503                 }
1504             }
1505             return null;
1506         }
1507 
1508         public RecordComponent getRecordComponent(JCVariableDecl var, boolean addIfMissing, List&lt;JCAnnotation&gt; annotations) {
1509             for (RecordComponent rc : recordComponents) {
1510                 /* it could be that a record erroneously declares two record components with the same name, in that
1511                  * case we need to use the position to disambiguate
1512                  */
1513                 if (rc.name == var.name &amp;&amp; var.pos == rc.pos) {
1514                     return rc;
1515                 }
1516             }
1517             RecordComponent rc = null;
1518             if (addIfMissing) {
1519                 recordComponents = recordComponents.append(rc = new RecordComponent(var, annotations));
1520             }
1521             return rc;
1522         }
1523 
1524         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1525         @SuppressWarnings(&quot;preview&quot;)
1526         public List&lt;? extends RecordComponent&gt; getRecordComponents() {
1527             return recordComponents;
1528         }
1529 
1530         @DefinedBy(Api.LANGUAGE_MODEL)
1531         public NestingKind getNestingKind() {
1532             apiComplete();
1533             if (owner.kind == PCK)
1534                 return NestingKind.TOP_LEVEL;
1535             else if (name.isEmpty())
1536                 return NestingKind.ANONYMOUS;
1537             else if (owner.kind == MTH)
1538                 return NestingKind.LOCAL;
1539             else
1540                 return NestingKind.MEMBER;
1541         }
1542 
1543         @Override
1544         protected &lt;A extends Annotation&gt; Attribute.Compound getAttribute(final Class&lt;A&gt; annoType) {
1545 
1546             Attribute.Compound attrib = super.getAttribute(annoType);
1547 
1548             boolean inherited = annoType.isAnnotationPresent(Inherited.class);
1549             if (attrib != null || !inherited)
1550                 return attrib;
1551 
1552             // Search supertypes
1553             ClassSymbol superType = getSuperClassToSearchForAnnotations();
1554             return superType == null ? null
1555                                      : superType.getAttribute(annoType);
1556         }
1557 
1558         @DefinedBy(Api.LANGUAGE_MODEL)
1559         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1560             return v.visitType(this, p);
1561         }
1562 
1563         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1564             return v.visitClassSymbol(this, p);
1565         }
1566 
1567         public void markAbstractIfNeeded(Types types) {
1568             if (types.enter.getEnv(this) != null &amp;&amp;
1569                 (flags() &amp; ENUM) != 0 &amp;&amp; types.supertype(type).tsym == types.syms.enumSym &amp;&amp;
1570                 (flags() &amp; (FINAL | ABSTRACT)) == 0) {
1571                 if (types.firstUnimplementedAbstract(this) != null)
1572                     // add the ABSTRACT flag to an enum
1573                     flags_field |= ABSTRACT;
1574             }
1575         }
1576 
1577         /**Resets the Symbol into the state good for next round of annotation processing.*/
1578         public void reset() {
1579             kind = TYP;
1580             erasure_field = null;
1581             members_field = null;
1582             flags_field = 0;
1583             if (type instanceof ClassType) {
1584                 ClassType t = (ClassType)type;
1585                 t.setEnclosingType(Type.noType);
1586                 t.rank_field = -1;
1587                 t.typarams_field = null;
1588                 t.allparams_field = null;
1589                 t.supertype_field = null;
1590                 t.interfaces_field = null;
1591                 t.all_interfaces_field = null;
1592             }
1593             clearAnnotationMetadata();
1594         }
1595 
1596         public void clearAnnotationMetadata() {
1597             metadata = null;
1598             annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1599         }
1600 
1601         @Override
1602         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1603             return annotationTypeMetadata;
1604         }
1605 
1606         @Override
1607         public boolean isAnnotationType() {
1608             return (flags_field &amp; Flags.ANNOTATION) != 0;
1609         }
1610 
1611         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1612             Assert.checkNonNull(a);
1613             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1614             this.annotationTypeMetadata = a;
1615         }
1616 
1617         public boolean isRecord() {
1618             return (flags_field &amp; RECORD) != 0;
1619         }
1620 
1621         @DefinedBy(Api.LANGUAGE_MODEL)
1622         public List&lt;Type&gt; getPermittedSubclasses() {
1623             return permitted.map(s -&gt; s.type);
1624         }
1625     }
1626 
1627 
1628     /** A class for variable symbols
1629      */
1630     public static class VarSymbol extends Symbol implements VariableElement {
1631 
1632         /** The variable&#39;s declaration position.
1633          */
1634         public int pos = Position.NOPOS;
1635 
1636         /** The variable&#39;s address. Used for different purposes during
1637          *  flow analysis, translation and code generation.
1638          *  Flow analysis:
1639          *    If this is a blank final or local variable, its sequence number.
1640          *  Translation:
1641          *    If this is a private field, its access number.
1642          *  Code generation:
1643          *    If this is a local variable, its logical slot number.
1644          */
1645         public int adr = -1;
1646 
1647         /** Construct a variable symbol, given its flags, name, type and owner.
1648          */
1649         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1650             super(VAR, flags, name, type, owner);
1651         }
1652 
1653         @Override
1654         public int poolTag() {
1655             return ClassFile.CONSTANT_Fieldref;
1656         }
1657 
1658         public MethodHandleSymbol asMethodHandle(boolean getter) {
1659             return new MethodHandleSymbol(this, getter);
1660         }
1661 
1662         /** Clone this symbol with new owner.
1663          */
1664         public VarSymbol clone(Symbol newOwner) {
1665             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
1666                 @Override
1667                 public Symbol baseSymbol() {
1668                     return VarSymbol.this;
1669                 }
1670 
1671                 @Override
1672                 public Object poolKey(Types types) {
1673                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1674                 }
1675             };
1676             v.pos = pos;
1677             v.adr = adr;
1678             v.data = data;
1679 //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
1680             return v;
1681         }
1682 
1683         public String toString() {
1684             return name.toString();
1685         }
1686 
1687         public Symbol asMemberOf(Type site, Types types) {
1688             return new VarSymbol(flags_field, name, types.memberType(site, this), owner);
1689         }
1690 
1691         @DefinedBy(Api.LANGUAGE_MODEL)
1692         public ElementKind getKind() {
1693             long flags = flags();
1694             if ((flags &amp; PARAMETER) != 0) {
1695                 if (isExceptionParameter())
1696                     return ElementKind.EXCEPTION_PARAMETER;
1697                 else
1698                     return ElementKind.PARAMETER;
1699             } else if ((flags &amp; ENUM) != 0) {
1700                 return ElementKind.ENUM_CONSTANT;
1701             } else if (owner.kind == TYP || owner.kind == ERR) {
1702                 return ElementKind.FIELD;
1703             } else if (isResourceVariable()) {
1704                 return ElementKind.RESOURCE_VARIABLE;
1705             } else if ((flags &amp; MATCH_BINDING) != 0) {
1706                 @SuppressWarnings(&quot;preview&quot;)
1707                 ElementKind kind = ElementKind.BINDING_VARIABLE;
1708                 return kind;
1709             } else {
1710                 return ElementKind.LOCAL_VARIABLE;
1711             }
1712         }
1713 
1714         @DefinedBy(Api.LANGUAGE_MODEL)
1715         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1716             return v.visitVariable(this, p);
1717         }
1718 
1719         @DefinedBy(Api.LANGUAGE_MODEL)
1720         public Object getConstantValue() { // Mirror API
1721             return Constants.decode(getConstValue(), type);
1722         }
1723 
1724         public void setLazyConstValue(final Env&lt;AttrContext&gt; env,
1725                                       final Attr attr,
1726                                       final JCVariableDecl variable)
1727         {
1728             setData((Callable&lt;Object&gt;)() -&gt; attr.attribLazyConstantValue(env, variable, type));
1729         }
1730 
1731         /**
1732          * The variable&#39;s constant value, if this is a constant.
1733          * Before the constant value is evaluated, it points to an
1734          * initializer environment.  If this is not a constant, it can
1735          * be used for other stuff.
1736          */
1737         private Object data;
1738 
1739         public boolean isExceptionParameter() {
1740             return data == ElementKind.EXCEPTION_PARAMETER;
1741         }
1742 
1743         public boolean isResourceVariable() {
1744             return data == ElementKind.RESOURCE_VARIABLE;
1745         }
1746 
1747         public Object getConstValue() {
1748             // TODO: Consider if getConstValue and getConstantValue can be collapsed
1749             if (data == ElementKind.EXCEPTION_PARAMETER ||
1750                 data == ElementKind.RESOURCE_VARIABLE) {
1751                 return null;
1752             } else if (data instanceof Callable&lt;?&gt;) {
1753                 // In this case, this is a final variable, with an as
1754                 // yet unevaluated initializer.
1755                 Callable&lt;?&gt; eval = (Callable&lt;?&gt;)data;
1756                 data = null; // to make sure we don&#39;t evaluate this twice.
1757                 try {
1758                     data = eval.call();
1759                 } catch (Exception ex) {
1760                     throw new AssertionError(ex);
1761                 }
1762             }
1763             return data;
1764         }
1765 
1766         public void setData(Object data) {
1767             Assert.check(!(data instanceof Env&lt;?&gt;), this);
1768             this.data = data;
1769         }
1770 
1771         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1772             return v.visitVarSymbol(this, p);
1773         }
1774     }
1775 
1776     @SuppressWarnings(&quot;preview&quot;)
1777     public static class RecordComponent extends VarSymbol implements RecordComponentElement {
1778         public MethodSymbol accessor;
1779         public JCTree.JCMethodDecl accessorMeth;
1780         /* the original annotations applied to the record component
1781          */
1782         private final List&lt;JCAnnotation&gt; originalAnnos;
1783         /* if the user happens to erroneously declare two components with the same name, we need a way to differentiate
1784          * them, the code will fail anyway but we need to keep the information for better error recovery
1785          */
1786         private final int pos;
1787 
1788         /**
1789          * Construct a record component, given its flags, name, type and owner.
1790          */
1791         public RecordComponent(JCVariableDecl fieldDecl, List&lt;JCAnnotation&gt; annotations) {
1792             super(PUBLIC, fieldDecl.sym.name, fieldDecl.sym.type, fieldDecl.sym.owner);
1793             this.originalAnnos = annotations;
1794             this.pos = fieldDecl.pos;
1795         }
1796 
1797         public List&lt;JCAnnotation&gt; getOriginalAnnos() { return originalAnnos; }
1798 
1799         public boolean isVarargs() {
1800             return type.hasTag(TypeTag.ARRAY) &amp;&amp; ((ArrayType)type).isVarargs();
1801         }
1802 
1803         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1804         @SuppressWarnings(&quot;preview&quot;)
1805         public ElementKind getKind() {
1806             return ElementKind.RECORD_COMPONENT;
1807         }
1808 
1809         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1810         public ExecutableElement getAccessor() {
1811             return accessor;
1812         }
1813 
1814         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1815         @SuppressWarnings(&quot;preview&quot;)
1816         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1817             return v.visitRecordComponent(this, p);
1818         }
1819     }
1820 
1821     public static class ParamSymbol extends VarSymbol {
1822         public ParamSymbol(long flags, Name name, Type type, Symbol owner) {
1823             super(flags, name, type, owner);
1824         }
1825 
1826         @Override
1827         public Name getSimpleName() {
1828             if ((flags_field &amp; NAME_FILLED) == 0) {
1829                 flags_field |= NAME_FILLED;
1830                 Symbol rootPack = this;
1831                 while (rootPack != null &amp;&amp; !(rootPack instanceof RootPackageSymbol)) {
1832                     rootPack = rootPack.owner;
1833                 }
1834                 if (rootPack != null) {
1835                     Name inferredName =
1836                             ((RootPackageSymbol) rootPack).missingInfoHandler.getParameterName(this);
1837                     if (inferredName != null) {
1838                         this.name = inferredName;
1839                     }
1840                 }
1841             }
1842             return super.getSimpleName();
1843         }
1844 
1845     }
1846 
1847     public static class BindingSymbol extends VarSymbol {
1848 
1849         public BindingSymbol(Name name, Type type, Symbol owner) {
1850             super(Flags.FINAL | Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);
1851         }
1852 
1853         public boolean isAliasFor(BindingSymbol b) {
1854             return aliases().containsAll(b.aliases());
1855         }
1856 
1857         List&lt;BindingSymbol&gt; aliases() {
1858             return List.of(this);
1859         }
1860 
1861         public void preserveBinding() {
1862             flags_field |= Flags.MATCH_BINDING_TO_OUTER;
1863         }
1864 
1865         public boolean isPreserved() {
1866             return (flags_field &amp; Flags.MATCH_BINDING_TO_OUTER) != 0;
1867         }
1868     }
1869 
1870     /** A class for method symbols.
1871      */
1872     public static class MethodSymbol extends Symbol implements ExecutableElement {
1873 
1874         /** The code of the method. */
1875         public Code code = null;
1876 
1877         /** The extra (synthetic/mandated) parameters of the method. */
1878         public List&lt;VarSymbol&gt; extraParams = List.nil();
1879 
1880         /** The captured local variables in an anonymous class */
1881         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1882 
1883         /** The parameters of the method. */
1884         public List&lt;VarSymbol&gt; params = null;
1885 
1886         /** For an annotation type element, its default value if any.
1887          *  The value is null if none appeared in the method
1888          *  declaration.
1889          */
1890         public Attribute defaultValue = null;
1891 
1892         /** Construct a method symbol, given its flags, name, type and owner.
1893          */
1894         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
1895             super(MTH, flags, name, type, owner);
1896             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
1897         }
1898 
1899         /** Clone this symbol with new owner.
1900          */
1901         public MethodSymbol clone(Symbol newOwner) {
1902             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
1903                 @Override
1904                 public Symbol baseSymbol() {
1905                     return MethodSymbol.this;
1906                 }
1907 
1908                 @Override
1909                 public Object poolKey(Types types) {
1910                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1911                 }
1912             };
1913             m.code = code;
1914             return m;
1915         }
1916 
1917         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1918         public Set&lt;Modifier&gt; getModifiers() {
1919             long flags = flags();
1920             return Flags.asModifierSet((flags &amp; DEFAULT) != 0 ? flags &amp; ~ABSTRACT : flags);
1921         }
1922 
1923         /** The Java source which this symbol represents.
1924          */
1925         public String toString() {
1926             if ((flags() &amp; BLOCK) != 0) {
1927                 return owner.name.toString();
1928             } else {
1929                 String s = (name == name.table.names.init)
1930                     ? owner.name.toString()
1931                     : name.toString();
1932                 if (type != null) {
1933                     if (type.hasTag(FORALL))
1934                         s = &quot;&lt;&quot; + ((ForAll)type).getTypeArguments() + &quot;&gt;&quot; + s;
1935                     s += &quot;(&quot; + type.argtypes((flags() &amp; VARARGS) != 0) + &quot;)&quot;;
1936                 }
1937                 return s;
1938             }
1939         }
1940 
1941         @Override
1942         public int poolTag() {
1943             return owner.isInterface() ?
1944                     ClassFile.CONSTANT_InterfaceMethodref : ClassFile.CONSTANT_Methodref;
1945         }
1946 
1947         public boolean isHandle() {
1948             return false;
1949         }
1950 
1951 
1952         public MethodHandleSymbol asHandle() {
1953             return new MethodHandleSymbol(this);
1954         }
1955 
1956         /** find a symbol that this (proxy method) symbol implements.
1957          *  @param    c       The class whose members are searched for
1958          *                    implementations
1959          */
1960         public Symbol implemented(TypeSymbol c, Types types) {
1961             Symbol impl = null;
1962             for (List&lt;Type&gt; is = types.interfaces(c.type);
1963                  impl == null &amp;&amp; is.nonEmpty();
1964                  is = is.tail) {
1965                 TypeSymbol i = is.head.tsym;
1966                 impl = implementedIn(i, types);
1967                 if (impl == null)
1968                     impl = implemented(i, types);
1969             }
1970             return impl;
1971         }
1972 
1973         public Symbol implementedIn(TypeSymbol c, Types types) {
1974             Symbol impl = null;
1975             for (Symbol sym : c.members().getSymbolsByName(name)) {
1976                 if (this.overrides(sym, (TypeSymbol)owner, types, true) &amp;&amp;
1977                     // FIXME: I suspect the following requires a
1978                     // subst() for a parametric return type.
1979                     types.isSameType(type.getReturnType(),
1980                                      types.memberType(owner.type, sym).getReturnType())) {
1981                     impl = sym;
1982                 }
1983             }
1984             return impl;
1985         }
1986 
1987         /** Will the erasure of this method be considered by the VM to
1988          *  override the erasure of the other when seen from class `origin&#39;?
1989          */
1990         public boolean binaryOverrides(Symbol _other, TypeSymbol origin, Types types) {
1991             if (isConstructor() || _other.kind != MTH) return false;
1992 
1993             if (this == _other) return true;
1994             MethodSymbol other = (MethodSymbol)_other;
1995 
1996             // check for a direct implementation
1997             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
1998                 types.asSuper(owner.type, other.owner) != null &amp;&amp;
1999                 types.isSameType(erasure(types), other.erasure(types)))
2000                 return true;
2001 
2002             // check for an inherited implementation
2003             return
2004                 (flags() &amp; ABSTRACT) == 0 &amp;&amp;
2005                 other.isOverridableIn(origin) &amp;&amp;
2006                 this.isMemberOf(origin, types) &amp;&amp;
2007                 types.isSameType(erasure(types), other.erasure(types));
2008         }
2009 
2010         /** The implementation of this (abstract) symbol in class origin,
2011          *  from the VM&#39;s point of view, null if method does not have an
2012          *  implementation in class.
2013          *  @param origin   The class of which the implementation is a member.
2014          */
2015         public MethodSymbol binaryImplementation(ClassSymbol origin, Types types) {
2016             for (TypeSymbol c = origin; c != null; c = types.supertype(c.type).tsym) {
2017                 for (Symbol sym : c.members().getSymbolsByName(name)) {
2018                     if (sym.kind == MTH &amp;&amp;
2019                         ((MethodSymbol)sym).binaryOverrides(this, origin, types))
2020                         return (MethodSymbol)sym;
2021                 }
2022             }
2023             return null;
2024         }
2025 
2026         /** Does this symbol override `other&#39; symbol, when both are seen as
2027          *  members of class `origin&#39;?  It is assumed that _other is a member
2028          *  of origin.
2029          *
2030          *  It is assumed that both symbols have the same name.  The static
2031          *  modifier is ignored for this test.
2032          *
2033          *  A quirk in the works is that if the receiver is a method symbol for
2034          *  an inherited abstract method we answer false summarily all else being
2035          *  immaterial. Abstract &quot;own&quot; methods (i.e `this&#39; is a direct member of
2036          *  origin) don&#39;t get rejected as summarily and are put to test against the
2037          *  suitable criteria.
2038          *
2039          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2040          */
2041         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult) {
2042             return overrides(_other, origin, types, checkResult, true);
2043         }
2044 
2045         /** Does this symbol override `other&#39; symbol, when both are seen as
2046          *  members of class `origin&#39;?  It is assumed that _other is a member
2047          *  of origin.
2048          *
2049          *  Caveat: If `this&#39; is an abstract inherited member of origin, it is
2050          *  deemed to override `other&#39; only when `requireConcreteIfInherited&#39;
2051          *  is false.
2052          *
2053          *  It is assumed that both symbols have the same name.  The static
2054          *  modifier is ignored for this test.
2055          *
2056          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2057          */
2058         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult,
2059                                             boolean requireConcreteIfInherited) {
2060             if (isConstructor() || _other.kind != MTH) return false;
2061 
2062             if (this == _other) return true;
2063             MethodSymbol other = (MethodSymbol)_other;
2064 
2065             // check for a direct implementation
2066             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
2067                 types.asSuper(owner.type, other.owner) != null) {
2068                 Type mt = types.memberType(owner.type, this);
2069                 Type ot = types.memberType(owner.type, other);
2070                 if (types.isSubSignature(mt, ot)) {
2071                     if (!checkResult)
2072                         return true;
2073                     if (types.returnTypeSubstitutable(mt, ot))
2074                         return true;
2075                 }
2076             }
2077 
2078             // check for an inherited implementation
2079             if (((flags() &amp; ABSTRACT) != 0 &amp;&amp; requireConcreteIfInherited) ||
2080                     ((other.flags() &amp; ABSTRACT) == 0 &amp;&amp; (other.flags() &amp; DEFAULT) == 0) ||
2081                     !other.isOverridableIn(origin) ||
2082                     !this.isMemberOf(origin, types))
2083                 return false;
2084 
2085             // assert types.asSuper(origin.type, other.owner) != null;
2086             Type mt = types.memberType(origin.type, this);
2087             Type ot = types.memberType(origin.type, other);
2088             return
2089                 types.isSubSignature(mt, ot) &amp;&amp;
2090                 (!checkResult || types.resultSubtype(mt, ot, types.noWarnings));
2091         }
2092 
2093         private boolean isOverridableIn(TypeSymbol origin) {
2094             // JLS 8.4.6.1
2095             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2096             case Flags.PRIVATE:
2097                 return false;
2098             case Flags.PUBLIC:
2099                 return !this.owner.isInterface() ||
2100                         (flags_field &amp; STATIC) == 0;
2101             case Flags.PROTECTED:
2102                 return (origin.flags() &amp; INTERFACE) == 0;
2103             case 0:
2104                 // for package private: can only override in the same
2105                 // package
2106                 return
2107                     this.packge() == origin.packge() &amp;&amp;
2108                     (origin.flags() &amp; INTERFACE) == 0;
2109             default:
2110                 return false;
2111             }
2112         }
2113 
2114         @Override
2115         public boolean isInheritedIn(Symbol clazz, Types types) {
2116             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2117                 case PUBLIC:
2118                     return !this.owner.isInterface() ||
2119                             clazz == owner ||
2120                             (flags_field &amp; STATIC) == 0;
2121                 default:
2122                     return super.isInheritedIn(clazz, types);
2123             }
2124         }
2125 
2126         public boolean isLambdaMethod() {
2127             return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
2128         }
2129 
2130         /** override this method to point to the original enclosing method if this method symbol represents a synthetic
2131          *  lambda method
2132          */
2133         public MethodSymbol originalEnclosingMethod() {
2134             return this;
2135         }
2136 
2137         /** The implementation of this (abstract) symbol in class origin;
2138          *  null if none exists. Synthetic methods are not considered
2139          *  as possible implementations.
2140          */
2141         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
2142             return implementation(origin, types, checkResult, implementation_filter);
2143         }
2144         // where
2145             public static final Filter&lt;Symbol&gt; implementation_filter = s -&gt;
2146                     s.kind == MTH &amp;&amp; (s.flags() &amp; SYNTHETIC) == 0;
2147 
2148         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2149             MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);
2150             if (res != null)
2151                 return res;
2152             // if origin is derived from a raw type, we might have missed
2153             // an implementation because we do not know enough about instantiations.
2154             // in this case continue with the supertype as origin.
2155             if (types.isDerivedRaw(origin.type) &amp;&amp; !origin.isInterface())
2156                 return implementation(types.supertype(origin.type).tsym, types, checkResult);
2157             else
2158                 return null;
2159         }
2160 
2161         public List&lt;VarSymbol&gt; params() {
2162             owner.complete();
2163             if (params == null) {
2164                 ListBuffer&lt;VarSymbol&gt; newParams = new ListBuffer&lt;&gt;();
2165                 int i = 0;
2166                 for (Type t : type.getParameterTypes()) {
2167                     Name paramName = name.table.fromString(&quot;arg&quot; + i);
2168                     VarSymbol param = new VarSymbol(PARAMETER, paramName, t, this);
2169                     newParams.append(param);
2170                     i++;
2171                 }
2172                 params = newParams.toList();
2173             }
2174             Assert.checkNonNull(params);
2175             return params;
2176         }
2177 
2178         public Symbol asMemberOf(Type site, Types types) {
2179             return new MethodSymbol(flags_field, name, types.memberType(site, this), owner);
2180         }
2181 
2182         @DefinedBy(Api.LANGUAGE_MODEL)
2183         public ElementKind getKind() {
2184             if (name == name.table.names.init)
2185                 return ElementKind.CONSTRUCTOR;
2186             else if (name == name.table.names.clinit)
2187                 return ElementKind.STATIC_INIT;
2188             else if ((flags() &amp; BLOCK) != 0)
2189                 return isStatic() ? ElementKind.STATIC_INIT : ElementKind.INSTANCE_INIT;
2190             else
2191                 return ElementKind.METHOD;
2192         }
2193 
2194         public boolean isStaticOrInstanceInit() {
2195             return getKind() == ElementKind.STATIC_INIT ||
2196                     getKind() == ElementKind.INSTANCE_INIT;
2197         }
2198 
2199         @DefinedBy(Api.LANGUAGE_MODEL)
2200         public Attribute getDefaultValue() {
2201             return defaultValue;
2202         }
2203 
2204         @DefinedBy(Api.LANGUAGE_MODEL)
2205         public List&lt;VarSymbol&gt; getParameters() {
2206             return params();
2207         }
2208 
2209         @DefinedBy(Api.LANGUAGE_MODEL)
2210         public boolean isVarArgs() {
2211             return (flags() &amp; VARARGS) != 0;
2212         }
2213 
2214         @DefinedBy(Api.LANGUAGE_MODEL)
2215         public boolean isDefault() {
2216             return (flags() &amp; DEFAULT) != 0;
2217         }
2218 
2219         @DefinedBy(Api.LANGUAGE_MODEL)
2220         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
2221             return v.visitExecutable(this, p);
2222         }
2223 
2224         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2225             return v.visitMethodSymbol(this, p);
2226         }
2227 
2228         @DefinedBy(Api.LANGUAGE_MODEL)
2229         public Type getReceiverType() {
2230             Type result = asType().getReceiverType();
2231             return (result == null) ? Type.noType : result;
2232         }
2233 
2234         @DefinedBy(Api.LANGUAGE_MODEL)
2235         public Type getReturnType() {
2236             return asType().getReturnType();
2237         }
2238 
2239         @DefinedBy(Api.LANGUAGE_MODEL)
2240         public List&lt;Type&gt; getThrownTypes() {
2241             return asType().getThrownTypes();
2242         }
2243     }
2244 
2245     /** A class for invokedynamic method calls.
2246      */
2247     public static class DynamicMethodSymbol extends MethodSymbol implements Dynamic {
2248 
2249         public LoadableConstant[] staticArgs;
2250         public MethodHandleSymbol bsm;
2251 
2252         public DynamicMethodSymbol(Name name, Symbol owner, MethodHandleSymbol bsm, Type type, LoadableConstant[] staticArgs) {
2253             super(0, name, type, owner);
2254             this.bsm = bsm;
2255             this.staticArgs = staticArgs;
2256         }
2257 
2258         @Override
2259         public boolean isDynamic() {
2260             return true;
2261         }
2262 
2263         @Override
2264         public LoadableConstant[] staticArgs() {
2265             return staticArgs;
2266         }
2267 
2268         @Override
2269         public MethodHandleSymbol bootstrapMethod() {
2270             return bsm;
2271         }
2272 
2273         @Override
2274         public int poolTag() {
2275             return ClassFile.CONSTANT_InvokeDynamic;
2276         }
2277 
2278         @Override
2279         public Type dynamicType() {
2280             return type;
2281         }
2282     }
2283 
2284     /** A class for condy.
2285      */
2286     public static class DynamicVarSymbol extends VarSymbol implements Dynamic, LoadableConstant {
2287         public LoadableConstant[] staticArgs;
2288         public MethodHandleSymbol bsm;
2289 
2290         public DynamicVarSymbol(Name name, Symbol owner, MethodHandleSymbol bsm, Type type, LoadableConstant[] staticArgs) {
2291             super(0, name, type, owner);
2292             this.bsm = bsm;
2293             this.staticArgs = staticArgs;
2294         }
2295 
2296         @Override
2297         public boolean isDynamic() {
2298             return true;
2299         }
2300 
2301         @Override
2302         public PoolConstant dynamicType() {
2303             return type;
2304         }
2305 
2306         @Override
2307         public LoadableConstant[] staticArgs() {
2308             return staticArgs;
2309         }
2310 
2311         @Override
2312         public LoadableConstant bootstrapMethod() {
2313             return bsm;
2314         }
2315 
2316         @Override
2317         public int poolTag() {
2318             return ClassFile.CONSTANT_Dynamic;
2319         }
2320     }
2321 
2322     /** A class for method handles.
2323      */
2324     public static class MethodHandleSymbol extends MethodSymbol implements LoadableConstant {
2325 
2326         private Symbol refSym;
2327         private boolean getter;
2328 
2329         public MethodHandleSymbol(Symbol msym) {
2330             this(msym, false);
2331         }
2332 
2333         public MethodHandleSymbol(Symbol msym, boolean getter) {
2334             super(msym.flags_field, msym.name, msym.type, msym.owner);
2335             this.refSym = msym;
2336             this.getter = getter;
2337         }
2338 
2339         /**
2340          * Returns the kind associated with this method handle.
2341          */
2342         public int referenceKind() {
2343             if (refSym.kind == VAR) {
2344                 return getter ?
2345                         refSym.isStatic() ? ClassFile.REF_getStatic : ClassFile.REF_getField :
2346                         refSym.isStatic() ? ClassFile.REF_putStatic : ClassFile.REF_putField;
2347             } else {
2348                 if (refSym.isConstructor()) {
2349                     return ClassFile.REF_newInvokeSpecial;
2350                 } else {
2351                     if (refSym.isStatic()) {
2352                         return ClassFile.REF_invokeStatic;
2353                     } else if ((refSym.flags() &amp; PRIVATE) != 0 &amp;&amp; !allowPrivateInvokeVirtual()) {
2354                         return ClassFile.REF_invokeSpecial;
2355                     } else if (refSym.enclClass().isInterface()) {
2356                         return ClassFile.REF_invokeInterface;
2357                     } else {
2358                         return ClassFile.REF_invokeVirtual;
2359                     }
2360                 }
2361             }
2362         }
2363 
2364         private boolean allowPrivateInvokeVirtual() {
2365             Symbol rootPack = this;
2366             while (rootPack != null &amp;&amp; !(rootPack instanceof RootPackageSymbol)) {
2367                 rootPack = rootPack.owner;
2368             }
2369             return rootPack != null &amp;&amp; ((RootPackageSymbol) rootPack).allowPrivateInvokeVirtual;
2370         }
2371         @Override
2372         public int poolTag() {
2373             return ClassFile.CONSTANT_MethodHandle;
2374         }
2375 
2376         @Override
2377         public Object poolKey(Types types) {
2378             return new Pair&lt;&gt;(baseSymbol(), referenceKind());
2379         }
2380 
2381         @Override
2382         public MethodHandleSymbol asHandle() {
2383             return this;
2384         }
2385 
2386         @Override
2387         public Symbol baseSymbol() {
2388             return refSym;
2389         }
2390 
2391 
2392         @Override
2393         public boolean isHandle() {
2394             return true;
2395         }
2396     }
2397 
2398     /** A class for predefined operators.
2399      */
2400     public static class OperatorSymbol extends MethodSymbol {
2401 
2402         public int opcode;
2403         private int accessCode = Integer.MIN_VALUE;
2404 
2405         public OperatorSymbol(Name name, Type type, int opcode, Symbol owner) {
2406             super(PUBLIC | STATIC, name, type, owner);
2407             this.opcode = opcode;
2408         }
2409 
2410         @Override
2411         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2412             return v.visitOperatorSymbol(this, p);
2413         }
2414 
2415         public int getAccessCode(Tag tag) {
2416             if (accessCode != Integer.MIN_VALUE &amp;&amp; !tag.isIncOrDecUnaryOp()) {
2417                 return accessCode;
2418             }
2419             accessCode = AccessCode.from(tag, opcode);
2420             return accessCode;
2421         }
2422 
2423         /** Access codes for dereferencing, assignment,
2424          *  and pre/post increment/decrement.
2425 
2426          *  All access codes for accesses to the current class are even.
2427          *  If a member of the superclass should be accessed instead (because
2428          *  access was via a qualified super), add one to the corresponding code
2429          *  for the current class, making the number odd.
2430          *  This numbering scheme is used by the backend to decide whether
2431          *  to issue an invokevirtual or invokespecial call.
2432          *
2433          *  @see Gen#visitSelect(JCFieldAccess tree)
2434          */
2435         public enum AccessCode {
2436             UNKNOWN(-1, Tag.NO_TAG),
2437             DEREF(0, Tag.NO_TAG),
2438             ASSIGN(2, Tag.ASSIGN),
2439             PREINC(4, Tag.PREINC),
2440             PREDEC(6, Tag.PREDEC),
2441             POSTINC(8, Tag.POSTINC),
2442             POSTDEC(10, Tag.POSTDEC),
2443             FIRSTASGOP(12, Tag.NO_TAG);
2444 
2445             public final int code;
2446             public final Tag tag;
2447             public static final int numberOfAccessCodes = (lushrl - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code + 2;
2448 
2449             AccessCode(int code, Tag tag) {
2450                 this.code = code;
2451                 this.tag = tag;
2452             }
2453 
2454             static public AccessCode getFromCode(int code) {
2455                 for (AccessCode aCodes : AccessCode.values()) {
2456                     if (aCodes.code == code) {
2457                         return aCodes;
2458                     }
2459                 }
2460                 return UNKNOWN;
2461             }
2462 
2463             static int from(Tag tag, int opcode) {
2464                 /** Map bytecode of binary operation to access code of corresponding
2465                 *  assignment operation. This is always an even number.
2466                 */
2467                 switch (tag) {
2468                     case PREINC:
2469                         return AccessCode.PREINC.code;
2470                     case PREDEC:
2471                         return AccessCode.PREDEC.code;
2472                     case POSTINC:
2473                         return AccessCode.POSTINC.code;
2474                     case POSTDEC:
2475                         return AccessCode.POSTDEC.code;
2476                 }
2477                 if (iadd &lt;= opcode &amp;&amp; opcode &lt;= lxor) {
2478                     return (opcode - iadd) * 2 + FIRSTASGOP.code;
2479                 } else if (opcode == string_add) {
2480                     return (lxor + 1 - iadd) * 2 + FIRSTASGOP.code;
2481                 } else if (ishll &lt;= opcode &amp;&amp; opcode &lt;= lushrl) {
2482                     return (opcode - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code;
2483                 }
2484                 return -1;
2485             }
2486         }
2487     }
2488 
2489     /** Symbol completer interface.
2490      */
2491     public static interface Completer {
2492 
2493         /** Dummy completer to be used when the symbol has been completed or
2494          * does not need completion.
2495          */
2496         public final static Completer NULL_COMPLETER = new Completer() {
2497             public void complete(Symbol sym) { }
2498             public boolean isTerminal() { return true; }
2499         };
2500 
2501         void complete(Symbol sym) throws CompletionFailure;
2502 
2503         /** Returns true if this completer is &lt;em&gt;terminal&lt;/em&gt;. A terminal
2504          * completer is used as a place holder when the symbol is completed.
2505          * Calling complete on a terminal completer will not affect the symbol.
2506          *
2507          * The dummy NULL_COMPLETER and the GraphDependencies completer are
2508          * examples of terminal completers.
2509          *
2510          * @return true iff this completer is terminal
2511          */
2512         default boolean isTerminal() {
2513             return false;
2514         }
2515     }
2516 
2517     public static class CompletionFailure extends RuntimeException {
2518         private static final long serialVersionUID = 0;
2519         public final transient DeferredCompletionFailureHandler dcfh;
2520         public transient Symbol sym;
2521 
2522         /** A diagnostic object describing the failure
2523          */
2524         private transient JCDiagnostic diag;
2525 
2526         private transient Supplier&lt;JCDiagnostic&gt; diagSupplier;
2527 
2528         public CompletionFailure(Symbol sym, Supplier&lt;JCDiagnostic&gt; diagSupplier, DeferredCompletionFailureHandler dcfh) {
2529             this.dcfh = dcfh;
2530             this.sym = sym;
2531             this.diagSupplier = diagSupplier;
2532 //          this.printStackTrace();//DEBUG
2533         }
2534 
2535         public JCDiagnostic getDiagnostic() {
2536             if (diag == null &amp;&amp; diagSupplier != null) {
2537                 diag = diagSupplier.get();
2538             }
2539             return diag;
2540         }
2541 
2542         @Override
2543         public String getMessage() {
2544             return getDiagnostic().getMessage(null);
2545         }
2546 
2547         public JCDiagnostic getDetailValue() {
2548             return getDiagnostic();
2549         }
2550 
2551         @Override
2552         public CompletionFailure initCause(Throwable cause) {
2553             super.initCause(cause);
2554             return this;
2555         }
2556 
2557         public void resetDiagnostic(Supplier&lt;JCDiagnostic&gt; diagSupplier) {
2558             this.diagSupplier = diagSupplier;
2559             this.diag = null;
2560         }
2561 
2562     }
2563 
2564     /**
2565      * A visitor for symbols.  A visitor is used to implement operations
2566      * (or relations) on symbols.  Most common operations on types are
2567      * binary relations and this interface is designed for binary
2568      * relations, that is, operations on the form
2569      * Symbol&amp;nbsp;&amp;times;&amp;nbsp;P&amp;nbsp;&amp;rarr;&amp;nbsp;R.
2570      * &lt;!-- In plain text: Type x P -&gt; R --&gt;
2571      *
2572      * @param &lt;R&gt; the return type of the operation implemented by this
2573      * visitor; use Void if no return type is needed.
2574      * @param &lt;P&gt; the type of the second argument (the first being the
2575      * symbol itself) of the operation implemented by this visitor; use
2576      * Void if a second argument is not needed.
2577      */
2578     public interface Visitor&lt;R,P&gt; {
2579         R visitClassSymbol(ClassSymbol s, P arg);
2580         R visitMethodSymbol(MethodSymbol s, P arg);
2581         R visitPackageSymbol(PackageSymbol s, P arg);
2582         R visitOperatorSymbol(OperatorSymbol s, P arg);
2583         R visitVarSymbol(VarSymbol s, P arg);
2584         R visitTypeSymbol(TypeSymbol s, P arg);
2585         R visitSymbol(Symbol s, P arg);
2586     }
2587 }
    </pre>
  </body>
</html>
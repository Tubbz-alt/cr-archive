<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.processing;
 27 
 28 import javax.annotation.processing.*;
 29 import javax.lang.model.*;
 30 import javax.lang.model.element.*;
 31 import static javax.lang.model.element.ElementKind.*;
 32 import static javax.lang.model.element.NestingKind.*;
 33 import static javax.lang.model.element.ModuleElement.*;
 34 import javax.lang.model.type.*;
 35 import javax.lang.model.util.*;
 36 
 37 import java.io.PrintWriter;
 38 import java.io.Writer;
 39 import java.util.*;
 40 import java.util.stream.Collectors;
 41 
 42 
 43 import com.sun.tools.javac.util.DefinedBy;
 44 import com.sun.tools.javac.util.DefinedBy.Api;
 45 import com.sun.tools.javac.util.StringUtils;
 46 
 47 /**
 48  * A processor which prints out elements.  Used to implement the
 49  * -Xprint option; the included visitor class is used to implement
 50  * Elements.printElements.
 51  *
 52  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 53  * If you write code that depends on this, you do so at your own risk.
 54  * This code and its internal interfaces are subject to change or
 55  * deletion without notice.&lt;/b&gt;
 56  */
 57 @SupportedAnnotationTypes(&quot;*&quot;)
 58 @SupportedSourceVersion(SourceVersion.RELEASE_15)
 59 public class PrintingProcessor extends AbstractProcessor {
 60     PrintWriter writer;
 61 
 62     public PrintingProcessor() {
 63         super();
 64         writer = new PrintWriter(System.out);
 65     }
 66 
 67     public void setWriter(Writer w) {
 68         writer = new PrintWriter(w);
 69     }
 70 
 71     @Override @DefinedBy(Api.ANNOTATION_PROCESSING)
 72     public boolean process(Set&lt;? extends TypeElement&gt; tes,
 73                            RoundEnvironment renv) {
 74 
 75         for(Element element : renv.getRootElements()) {
 76             print(element);
 77         }
 78 
 79         // Just print the elements, nothing more to do.
 80         return true;
 81     }
 82 
 83     void print(Element element) {
 84         new PrintingElementVisitor(writer, processingEnv.getElementUtils()).
 85             visit(element).flush();
 86     }
 87 
 88     /**
 89      * Used for the -Xprint option and called by Elements.printElements
 90      */
 91     @SuppressWarnings(&quot;preview&quot;)
 92     public static class PrintingElementVisitor
 93         extends SimpleElementVisitor14&lt;PrintingElementVisitor, Boolean&gt; {
 94         int indentation; // Indentation level;
 95         final PrintWriter writer;
 96         final Elements elementUtils;
 97 
 98         public PrintingElementVisitor(Writer w, Elements elementUtils) {
 99             super();
100             this.writer = new PrintWriter(w);
101             this.elementUtils = elementUtils;
102             indentation = 0;
103         }
104 
105         @Override @DefinedBy(Api.LANGUAGE_MODEL)
106         protected PrintingElementVisitor defaultAction(Element e, Boolean newLine) {
107             if (newLine != null &amp;&amp; newLine)
108                 writer.println();
109             printDocComment(e);
110             printModifiers(e);
111             return this;
112         }
113 
114         @Override @DefinedBy(Api.LANGUAGE_MODEL)
115         public PrintingElementVisitor visitRecordComponent(RecordComponentElement e, Boolean p) {
116                 // Do nothing; printing of component information done by
117                 // printing the record type itself
118             return this;
119         }
120 
121         @Override @DefinedBy(Api.LANGUAGE_MODEL)
122         public PrintingElementVisitor visitExecutable(ExecutableElement e, Boolean p) {
123             ElementKind kind = e.getKind();
124 
125             if (kind != STATIC_INIT &amp;&amp;
126                 kind != INSTANCE_INIT) {
127                 Element enclosing = e.getEnclosingElement();
128 
129                 // Don&#39;t print out the constructor of an anonymous class
130                 if (kind == CONSTRUCTOR &amp;&amp;
131                     enclosing != null &amp;&amp;
132                     NestingKind.ANONYMOUS ==
133                     // Use an anonymous class to determine anonymity!
134                     (new SimpleElementVisitor14&lt;NestingKind, Void&gt;() {
135                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
136                         public NestingKind visitType(TypeElement e, Void p) {
137                             return e.getNestingKind();
138                         }
139                     }).visit(enclosing))
140                     return this;
141 
142                 defaultAction(e, true);
143                 printFormalTypeParameters(e, true);
144 
145                 switch(kind) {
146                     case CONSTRUCTOR:
147                     // Print out simple name of the class
148                     writer.print(e.getEnclosingElement().getSimpleName());
149                     break;
150 
151                     case METHOD:
152                     writer.print(e.getReturnType().toString());
153                     writer.print(&quot; &quot;);
154                     writer.print(e.getSimpleName().toString());
155                     break;
156                 }
157 
158                 writer.print(&quot;(&quot;);
159                 printParameters(e);
160                 writer.print(&quot;)&quot;);
161                 AnnotationValue defaultValue = e.getDefaultValue();
162                 if (defaultValue != null)
163                     writer.print(&quot; default &quot; + defaultValue);
164 
165                 printThrows(e);
166                 writer.println(&quot;;&quot;);
167             }
168             return this;
169         }
170 
171 
172         @Override @DefinedBy(Api.LANGUAGE_MODEL)
173         public PrintingElementVisitor visitType(TypeElement e, Boolean p) {
174             ElementKind kind = e.getKind();
175             NestingKind nestingKind = e.getNestingKind();
176 
177             if (NestingKind.ANONYMOUS == nestingKind) {
178                 // Print out an anonymous class in the style of a
179                 // class instance creation expression rather than a
180                 // class declaration.
181                 writer.print(&quot;new &quot;);
182 
183                 // If the anonymous class implements an interface
184                 // print that name, otherwise print the superclass.
185                 List&lt;? extends TypeMirror&gt; interfaces = e.getInterfaces();
186                 if (!interfaces.isEmpty())
187                     writer.print(interfaces.get(0));
188                 else
189                     writer.print(e.getSuperclass());
190 
191                 writer.print(&quot;(&quot;);
192                 // Anonymous classes that implement an interface can&#39;t
193                 // have any constructor arguments.
194                 if (interfaces.isEmpty()) {
195                     // Print out the parameter list from the sole
196                     // constructor.  For now, don&#39;t try to elide any
197                     // synthetic parameters by determining if the
198                     // anonymous class is in a static context, etc.
199                     List&lt;? extends ExecutableElement&gt; constructors =
200                         ElementFilter.constructorsIn(e.getEnclosedElements());
201 
202                     if (!constructors.isEmpty())
203                         printParameters(constructors.get(0));
204                 }
205                 writer.print(&quot;)&quot;);
206             } else {
207                 if (nestingKind == TOP_LEVEL) {
208                     PackageElement pkg = elementUtils.getPackageOf(e);
209                     if (!pkg.isUnnamed())
210                         writer.print(&quot;package &quot; + pkg.getQualifiedName() + &quot;;\n&quot;);
211                 }
212 
213                 defaultAction(e, true);
214 
215                 switch(kind) {
216                 case ANNOTATION_TYPE:
217                     writer.print(&quot;@interface&quot;);
218                     break;
219                 default:
220                     writer.print(StringUtils.toLowerCase(kind.toString()));
221                 }
222                 writer.print(&quot; &quot;);
223                 writer.print(e.getSimpleName());
224 
225                 printFormalTypeParameters(e, false);
226 
227                 if (kind == RECORD) {
228                     // Print out record components
229                     writer.print(&quot;(&quot;);
230                     writer.print(e.getRecordComponents()
231                                  .stream()
232                                  .map(recordDes -&gt; recordDes.asType().toString() + &quot; &quot; + recordDes.getSimpleName())
233                                  .collect(Collectors.joining(&quot;, &quot;)));
234                     writer.print(&quot;)&quot;);
235                 }
236 
237                 // Print superclass information if informative
238                 if (kind == CLASS) {
239                     TypeMirror supertype = e.getSuperclass();
240                     if (supertype.getKind() != TypeKind.NONE) {
241                         TypeElement e2 = (TypeElement)
242                             ((DeclaredType) supertype).asElement();
243                         if (e2.getSuperclass().getKind() != TypeKind.NONE)
244                             writer.print(&quot; extends &quot; + supertype);
245                     }
246                 }
247 
248                 printInterfaces(e);
249                 printPermittedSubclasses(e);
250             }
251             writer.println(&quot; {&quot;);
252             indentation++;
253 
254             if (kind == ENUM) {
255                 List&lt;Element&gt; enclosedElements = new ArrayList&lt;&gt;(e.getEnclosedElements());
256                 // Handle any enum constants specially before other entities.
257                 List&lt;Element&gt; enumConstants = new ArrayList&lt;&gt;();
258                 for(Element element : enclosedElements) {
259                     if (element.getKind() == ENUM_CONSTANT)
260                         enumConstants.add(element);
261                 }
262                 if (!enumConstants.isEmpty()) {
263                     int i;
264                     for(i = 0; i &lt; enumConstants.size()-1; i++) {
265                         this.visit(enumConstants.get(i), true);
266                         writer.print(&quot;,&quot;);
267                     }
268                     this.visit(enumConstants.get(i), true);
269                     writer.println(&quot;;\n&quot;);
270 
271                     enclosedElements.removeAll(enumConstants);
272                 }
273 
274                 for(Element element : enclosedElements)
275                     this.visit(element);
276             } else {
277                 for(Element element :
278                         (kind != RECORD ?
279                          e.getEnclosedElements() :
280                          e.getEnclosedElements()
281                          .stream()
282                          .filter(elt -&gt; elementUtils.getOrigin(elt) == Elements.Origin.EXPLICIT )
283                          .collect(Collectors.toList()) ) )
284                     this.visit(element);
285             }
286 
287             indentation--;
288             indent();
289             writer.println(&quot;}&quot;);
290             return this;
291         }
292 
293         @Override @DefinedBy(Api.LANGUAGE_MODEL)
294         public PrintingElementVisitor visitVariable(VariableElement e, Boolean newLine) {
295             ElementKind kind = e.getKind();
296             defaultAction(e, newLine);
297 
298             if (kind == ENUM_CONSTANT)
299                 writer.print(e.getSimpleName());
300             else {
301                 writer.print(e.asType().toString() + &quot; &quot; + e.getSimpleName() );
302                 Object constantValue  = e.getConstantValue();
303                 if (constantValue != null) {
304                     writer.print(&quot; = &quot;);
305                     writer.print(elementUtils.getConstantExpression(constantValue));
306                 }
307                 writer.println(&quot;;&quot;);
308             }
309             return this;
310         }
311 
312         @Override @DefinedBy(Api.LANGUAGE_MODEL)
313         public PrintingElementVisitor visitTypeParameter(TypeParameterElement e, Boolean p) {
314             writer.print(e.getSimpleName());
315             return this;
316         }
317 
318         // Should we do more here?
319         @Override @DefinedBy(Api.LANGUAGE_MODEL)
320         public PrintingElementVisitor visitPackage(PackageElement e, Boolean p) {
321             defaultAction(e, false);
322             if (!e.isUnnamed())
323                 writer.println(&quot;package &quot; + e.getQualifiedName() + &quot;;&quot;);
324             else
325                 writer.println(&quot;// Unnamed package&quot;);
326             return this;
327         }
328 
329         @Override @DefinedBy(Api.LANGUAGE_MODEL)
330         public PrintingElementVisitor visitModule(ModuleElement e, Boolean p) {
331             defaultAction(e, false);
332 
333             if (!e.isUnnamed()) {
334                 if (e.isOpen()) {
335                     writer.print(&quot;open &quot;);
336                 }
337                 writer.println(&quot;module &quot; + e.getQualifiedName() + &quot; {&quot;);
338                 indentation++;
339                 for (ModuleElement.Directive directive : e.getDirectives()) {
340                     printDirective(directive);
341                 }
342                 indentation--;
343                 writer.println(&quot;}&quot;);
344             } else
345                 writer.println(&quot;// Unnamed module&quot;); // Should we do more here?
346             return this;
347         }
348 
349         private void printDirective(ModuleElement.Directive directive) {
350             indent();
351             (new PrintDirective(writer)).visit(directive);
352             writer.println(&quot;;&quot;);
353         }
354 
355         private static class PrintDirective implements ModuleElement.DirectiveVisitor&lt;Void, Void&gt; {
356             private final PrintWriter writer;
357 
358             PrintDirective(PrintWriter writer) {
359                 this.writer = writer;
360             }
361 
362             @Override @DefinedBy(Api.LANGUAGE_MODEL)
363             public Void visitExports(ExportsDirective d, Void p) {
364                 // &quot;exports package-name [to module-name-list]&quot;
365                 writer.print(&quot;exports &quot;);
366                 writer.print(d.getPackage().getQualifiedName());
367                 printModuleList(d.getTargetModules());
368                 return null;
369             }
370 
371             @Override @DefinedBy(Api.LANGUAGE_MODEL)
372             public Void visitOpens(OpensDirective d, Void p) {
373                 // opens package-name [to module-name-list]
374                 writer.print(&quot;opens &quot;);
375                 writer.print(d.getPackage().getQualifiedName());
376                 printModuleList(d.getTargetModules());
377                 return null;
378             }
379 
380             @Override @DefinedBy(Api.LANGUAGE_MODEL)
381             public Void visitProvides(ProvidesDirective d, Void p) {
382                 // provides service-name with implementation-name
383                 writer.print(&quot;provides &quot;);
384                 writer.print(d.getService().getQualifiedName());
385                 writer.print(&quot; with &quot;);
386                 printNameableList(d.getImplementations());
387                 return null;
388             }
389 
390             @Override @DefinedBy(Api.LANGUAGE_MODEL)
391             public Void visitRequires(RequiresDirective d, Void p) {
392                 // requires (static|transitive)* module-name
393                 writer.print(&quot;requires &quot;);
394                 if (d.isStatic())
395                     writer.print(&quot;static &quot;);
396                 if (d.isTransitive())
397                     writer.print(&quot;transitive &quot;);
398                 writer.print(d.getDependency().getQualifiedName());
399                 return null;
400             }
401 
402             @Override @DefinedBy(Api.LANGUAGE_MODEL)
403             public Void visitUses(UsesDirective d, Void p) {
404                 // uses service-name
405                 writer.print(&quot;uses &quot;);
406                 writer.print(d.getService().getQualifiedName());
407                 return null;
408             }
409 
410             private void printModuleList(List&lt;? extends ModuleElement&gt; modules) {
411                 if (modules != null) {
412                     writer.print(&quot; to &quot;);
413                     printNameableList(modules);
414                 }
415             }
416 
417             private void printNameableList(List&lt;? extends QualifiedNameable&gt; nameables) {
418                 writer.print(nameables.stream().
419                              map(QualifiedNameable::getQualifiedName).
420                              collect(Collectors.joining(&quot;, &quot;)));
421             }
422         }
423 
424         public void flush() {
425             writer.flush();
426         }
427 
428         private void printDocComment(Element e) {
429             String docComment = elementUtils.getDocComment(e);
430 
431             if (docComment != null) {
432                 // Break comment into lines
433                 java.util.StringTokenizer st = new StringTokenizer(docComment,
434                                                                   &quot;\n\r&quot;);
435                 indent();
436                 writer.println(&quot;/**&quot;);
437 
438                 while(st.hasMoreTokens()) {
439                     indent();
440                     writer.print(&quot; *&quot;);
441                     writer.println(st.nextToken());
442                 }
443 
444                 indent();
445                 writer.println(&quot; */&quot;);
446             }
447         }
448 
449         private void printModifiers(Element e) {
450             ElementKind kind = e.getKind();
451             if (kind == PARAMETER) {
452                 // Print annotation inline
453                 writer.print(annotationsToString(e));
454             } else {
455                 printAnnotations(e);
456                 indent();
457             }
458 
459             if (kind == ENUM_CONSTANT)
460                 return;
461 
462             Set&lt;Modifier&gt; modifiers = new LinkedHashSet&lt;&gt;();
463             modifiers.addAll(e.getModifiers());
464 
465             switch (kind) {
466             case ANNOTATION_TYPE:
467             case INTERFACE:
468                 modifiers.remove(Modifier.ABSTRACT);
469                 break;
470 
471             case ENUM:
472                 modifiers.remove(Modifier.FINAL);
473                 modifiers.remove(Modifier.ABSTRACT);
474                 modifiers.remove(Modifier.SEALED);
475                 break;
476 
477             case RECORD:
478                 modifiers.remove(Modifier.FINAL);
479                 break;
480 
481             case METHOD:
482             case FIELD:
483                 Element enclosingElement = e.getEnclosingElement();
484                 if (enclosingElement != null &amp;&amp;
485                     enclosingElement.getKind().isInterface()) {
486                     modifiers.remove(Modifier.PUBLIC);
487                     modifiers.remove(Modifier.ABSTRACT); // only for methods
488                     modifiers.remove(Modifier.STATIC);   // only for fields
489                     modifiers.remove(Modifier.FINAL);    // only for fields
490                 }
491                 break;
492 
493             }
494             if (!modifiers.isEmpty()) {
495                 writer.print(modifiers.stream()
496                              .map(Modifier::toString)
497                              .collect(Collectors.joining(&quot; &quot;, &quot;&quot;, &quot; &quot;)));
498             }
499         }
500 
501         private void printFormalTypeParameters(Parameterizable e,
502                                                boolean pad) {
503             List&lt;? extends TypeParameterElement&gt; typeParams = e.getTypeParameters();
504             if (!typeParams.isEmpty()) {
505                 writer.print(typeParams.stream()
506                              .map(tpe -&gt; annotationsToString(tpe) + tpe.toString())
507                              .collect(Collectors.joining(&quot;, &quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
508                 if (pad)
509                     writer.print(&quot; &quot;);
510             }
511         }
512 
513         private String annotationsToString(Element e) {
514             List&lt;? extends AnnotationMirror&gt; annotations = e.getAnnotationMirrors();
515             return annotations.isEmpty() ?
516                 &quot;&quot; :
517                 annotations.stream()
518                 .map(AnnotationMirror::toString)
519                 .collect(Collectors.joining(&quot; &quot;, &quot;&quot;, &quot; &quot;));
520         }
521 
522         private void printAnnotations(Element e) {
523             List&lt;? extends AnnotationMirror&gt; annots = e.getAnnotationMirrors();
524             for(AnnotationMirror annotationMirror : annots) {
525                 indent();
526                 writer.println(annotationMirror);
527             }
528         }
529 
530         // TODO: Refactor
531         private void printParameters(ExecutableElement e) {
532             List&lt;? extends VariableElement&gt; parameters = e.getParameters();
533             int size = parameters.size();
534 
535             switch (size) {
536             case 0:
537                 break;
538 
539             case 1:
540                 for(VariableElement parameter: parameters) {
541                     printModifiers(parameter);
542 
543                     if (e.isVarArgs() ) {
544                         TypeMirror tm = parameter.asType();
545                         if (tm.getKind() != TypeKind.ARRAY)
546                             throw new AssertionError(&quot;Var-args parameter is not an array type: &quot; + tm);
547                         writer.print((ArrayType.class.cast(tm)).getComponentType() );
548                         writer.print(&quot;...&quot;);
549                     } else
550                         writer.print(parameter.asType());
551                     writer.print(&quot; &quot; + parameter.getSimpleName());
552                 }
553                 break;
554 
555             default:
556                 {
557                     int i = 1;
558                     for(VariableElement parameter: parameters) {
559                         if (i == 2)
560                             indentation++;
561 
562                         if (i &gt; 1)
563                             indent();
564 
565                         printModifiers(parameter);
566 
567                         if (i == size &amp;&amp; e.isVarArgs() ) {
568                             TypeMirror tm = parameter.asType();
569                             if (tm.getKind() != TypeKind.ARRAY)
570                                 throw new AssertionError(&quot;Var-args parameter is not an array type: &quot; + tm);
571                                     writer.print((ArrayType.class.cast(tm)).getComponentType() );
572 
573                             writer.print(&quot;...&quot;);
574                         } else
575                             writer.print(parameter.asType());
576                         writer.print(&quot; &quot; + parameter.getSimpleName());
577 
578                         if (i &lt; size)
579                             writer.println(&quot;,&quot;);
580 
581                         i++;
582                     }
583 
584                     if (parameters.size() &gt;= 2)
585                         indentation--;
586                 }
587                 break;
588             }
589         }
590 
591         private void printInterfaces(TypeElement e) {
592             ElementKind kind = e.getKind();
593 
594             if(kind != ANNOTATION_TYPE) {
595                 List&lt;? extends TypeMirror&gt; interfaces = e.getInterfaces();
596                 if (!interfaces.isEmpty()) {
597                     writer.print((kind.isClass() ? &quot; implements &quot; : &quot; extends &quot;));
598                     writer.print(interfaces.stream()
599                                  .map(TypeMirror::toString)
600                                  .collect(Collectors.joining(&quot;, &quot;)));
601                 }
602             }
603         }
604 
605         private void printPermittedSubclasses(TypeElement e) {
606             List&lt;? extends TypeMirror&gt; subtypes = e.getPermittedSubclasses();
607             if (!subtypes.isEmpty()) { // could remove this check with more complicated joining call
608                 writer.print(&quot; permits &quot;);
609                 writer.print(subtypes
610                              .stream()
611                              .map(subtype -&gt; subtype.toString())
612                              .collect(Collectors.joining(&quot;, &quot;)));
613             }
614         }
615 
616         private void printThrows(ExecutableElement e) {
617             List&lt;? extends TypeMirror&gt; thrownTypes = e.getThrownTypes();
618             final int size = thrownTypes.size();
619             if (size != 0) {
620                 writer.print(&quot; throws&quot;);
621 
622                 int i = 1;
623                 for(TypeMirror thrownType: thrownTypes) {
624                     if (i == 1)
625                         writer.print(&quot; &quot;);
626 
627                     if (i == 2)
628                         indentation++;
629 
630                     if (i &gt;= 2)
631                         indent();
632 
633                     writer.print(thrownType);
634 
635                     if (i != size)
636                         writer.println(&quot;, &quot;);
637 
638                     i++;
639                 }
640 
641                 if (size &gt;= 2)
642                     indentation--;
643             }
644         }
645 
646         private static final String [] spaces = {
647             &quot;&quot;,
648             &quot;  &quot;,
649             &quot;    &quot;,
650             &quot;      &quot;,
651             &quot;        &quot;,
652             &quot;          &quot;,
653             &quot;            &quot;,
654             &quot;              &quot;,
655             &quot;                &quot;,
656             &quot;                  &quot;,
657             &quot;                    &quot;
658         };
659 
660         private void indent() {
661             int indentation = this.indentation;
662             if (indentation &lt; 0)
663                 return;
664             final int maxIndex = spaces.length - 1;
665 
666             while (indentation &gt; maxIndex) {
667                 writer.print(spaces[maxIndex]);
668                 indentation -= maxIndex;
669             }
670             writer.print(spaces[indentation]);
671         }
672 
673     }
674 }
    </pre>
  </body>
</html>
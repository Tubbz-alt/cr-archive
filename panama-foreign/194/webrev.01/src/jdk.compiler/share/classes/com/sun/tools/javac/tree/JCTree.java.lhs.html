<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.io.IOException;
  29 import java.io.StringWriter;
  30 import java.util.*;
  31 
  32 import javax.lang.model.element.Modifier;
  33 import javax.lang.model.type.TypeKind;
  34 import javax.tools.JavaFileObject;
  35 
  36 import com.sun.source.tree.*;
  37 import com.sun.tools.javac.code.*;
  38 import com.sun.tools.javac.code.Directive.RequiresDirective;
  39 import com.sun.tools.javac.code.Scope.*;
  40 import com.sun.tools.javac.code.Symbol.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.DefinedBy.Api;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.List;
  45 
  46 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  47 
  48 import javax.tools.JavaFileManager.Location;
  49 
  50 import com.sun.source.tree.ModuleTree.ModuleKind;
  51 import com.sun.tools.javac.code.Directive.ExportsDirective;
  52 import com.sun.tools.javac.code.Directive.OpensDirective;
  53 import com.sun.tools.javac.code.Type.ModuleType;
  54 
  55 /**
  56  * Root class for abstract syntax tree nodes. It provides definitions
  57  * for specific tree nodes as subclasses nested inside.
  58  *
  59  * &lt;p&gt;Each subclass is highly standardized.  It generally contains
  60  * only tree fields for the syntactic subcomponents of the node.  Some
  61  * classes that represent identifier uses or definitions also define a
  62  * Symbol field that denotes the represented identifier.  Classes for
  63  * non-local jumps also carry the jump target as a field.  The root
  64  * class Tree itself defines fields for the tree&#39;s type and position.
  65  * No other fields are kept in a tree node; instead parameters are
  66  * passed to methods accessing the node.
  67  *
  68  * &lt;p&gt;Except for the methods defined by com.sun.source, the only
  69  * method defined in subclasses is `visit&#39; which applies a given
  70  * visitor to the tree. The actual tree processing is done by visitor
  71  * classes in other packages. The abstract class Visitor, as well as
  72  * an Factory interface for trees, are defined as inner classes in
  73  * Tree.
  74  *
  75  * &lt;p&gt;To avoid ambiguities with the Tree API in com.sun.source all sub
  76  * classes should, by convention, start with JC (javac).
  77  *
  78  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  79  * If you write code that depends on this, you do so at your own risk.
  80  * This code and its internal interfaces are subject to change or
  81  * deletion without notice.&lt;/b&gt;
  82  *
  83  * @see TreeMaker
  84  * @see TreeInfo
  85  * @see TreeTranslator
  86  * @see Pretty
  87  */
  88 public abstract class JCTree implements Tree, Cloneable, DiagnosticPosition {
  89 
  90     /* Tree tag values, identifying kinds of trees */
  91     public enum Tag {
  92         /** For methods that return an invalid tag if a given condition is not met
  93          */
  94         NO_TAG,
  95 
  96         /** Toplevel nodes, of type TopLevel, representing entire source files.
  97         */
  98         TOPLEVEL,
  99 
 100         /** Package level definitions.
 101          */
 102         PACKAGEDEF,
 103 
 104         /** Import clauses, of type Import.
 105          */
 106         IMPORT,
 107 
 108         /** Class definitions, of type ClassDef.
 109          */
 110         CLASSDEF,
 111 
 112         /** Method definitions, of type MethodDef.
 113          */
 114         METHODDEF,
 115 
 116         /** Variable definitions, of type VarDef.
 117          */
 118         VARDEF,
 119 
 120         /** The no-op statement &quot;;&quot;, of type Skip
 121          */
 122         SKIP,
 123 
 124         /** Blocks, of type Block.
 125          */
 126         BLOCK,
 127 
 128         /** Do-while loops, of type DoLoop.
 129          */
 130         DOLOOP,
 131 
 132         /** While-loops, of type WhileLoop.
 133          */
 134         WHILELOOP,
 135 
 136         /** For-loops, of type ForLoop.
 137          */
 138         FORLOOP,
 139 
 140         /** Foreach-loops, of type ForeachLoop.
 141          */
 142         FOREACHLOOP,
 143 
 144         /** Labelled statements, of type Labelled.
 145          */
 146         LABELLED,
 147 
 148         /** Switch statements, of type Switch.
 149          */
 150         SWITCH,
 151 
 152         /** Case parts in switch statements/expressions, of type Case.
 153          */
 154         CASE,
 155 
 156         /** Switch expression statements, of type Switch.
 157          */
 158         SWITCH_EXPRESSION,
 159 
 160         /** Synchronized statements, of type Synchronized.
 161          */
 162         SYNCHRONIZED,
 163 
 164         /** Try statements, of type Try.
 165          */
 166         TRY,
 167 
 168         /** Catch clauses in try statements, of type Catch.
 169          */
 170         CATCH,
 171 
 172         /** Conditional expressions, of type Conditional.
 173          */
 174         CONDEXPR,
 175 
 176         /** Conditional statements, of type If.
 177          */
 178         IF,
 179 
 180         /** Expression statements, of type Exec.
 181          */
 182         EXEC,
 183 
 184         /** Break statements, of type Break.
 185          */
 186         BREAK,
 187 
 188         /** Yield statements, of type Yield.
 189          */
 190         YIELD,
 191 
 192         /** Continue statements, of type Continue.
 193          */
 194         CONTINUE,
 195 
 196         /** Return statements, of type Return.
 197          */
 198         RETURN,
 199 
 200         /** Throw statements, of type Throw.
 201          */
 202         THROW,
 203 
 204         /** Assert statements, of type Assert.
 205          */
 206         ASSERT,
 207 
 208         /** Method invocation expressions, of type Apply.
 209          */
 210         APPLY,
 211 
 212         /** Class instance creation expressions, of type NewClass.
 213          */
 214         NEWCLASS,
 215 
 216         /** Array creation expressions, of type NewArray.
 217          */
 218         NEWARRAY,
 219 
 220         /** Lambda expression, of type Lambda.
 221          */
 222         LAMBDA,
 223 
 224         /** Parenthesized subexpressions, of type Parens.
 225          */
 226         PARENS,
 227 
 228         /** Assignment expressions, of type Assign.
 229          */
 230         ASSIGN,
 231 
 232         /** Type cast expressions, of type TypeCast.
 233          */
 234         TYPECAST,
 235 
 236         /** Type test expressions, of type TypeTest.
 237          */
 238         TYPETEST,
 239 
 240         /** Patterns.
 241          */
 242         BINDINGPATTERN,
 243 
 244         /** Indexed array expressions, of type Indexed.
 245          */
 246         INDEXED,
 247 
 248         /** Selections, of type Select.
 249          */
 250         SELECT,
 251 
 252         /** Member references, of type Reference.
 253          */
 254         REFERENCE,
 255 
 256         /** Simple identifiers, of type Ident.
 257          */
 258         IDENT,
 259 
 260         /** Literals, of type Literal.
 261          */
 262         LITERAL,
 263 
 264         /** Basic type identifiers, of type TypeIdent.
 265          */
 266         TYPEIDENT,
 267 
 268         /** Array types, of type TypeArray.
 269          */
 270         TYPEARRAY,
 271 
 272         /** Parameterized types, of type TypeApply.
 273          */
 274         TYPEAPPLY,
 275 
 276         /** Union types, of type TypeUnion.
 277          */
 278         TYPEUNION,
 279 
 280         /** Intersection types, of type TypeIntersection.
 281          */
 282         TYPEINTERSECTION,
 283 
 284         /** Formal type parameters, of type TypeParameter.
 285          */
 286         TYPEPARAMETER,
 287 
 288         /** Type argument.
 289          */
 290         WILDCARD,
 291 
 292         /** Bound kind: extends, super, exact, or unbound
 293          */
 294         TYPEBOUNDKIND,
 295 
 296         /** metadata: Annotation.
 297          */
 298         ANNOTATION,
 299 
 300         /** metadata: Type annotation.
 301          */
 302         TYPE_ANNOTATION,
 303 
 304         /** metadata: Modifiers
 305          */
 306         MODIFIERS,
 307 
 308         /** An annotated type tree.
 309          */
 310         ANNOTATED_TYPE,
 311 
 312         /** Error trees, of type Erroneous.
 313          */
 314         ERRONEOUS,
 315 
 316         /** Unary operators, of type Unary.
 317          */
 318         POS,                             // +
 319         NEG,                             // -
 320         NOT,                             // !
 321         COMPL,                           // ~
 322         PREINC,                          // ++ _
 323         PREDEC,                          // -- _
 324         POSTINC,                         // _ ++
 325         POSTDEC,                         // _ --
 326 
 327         /** unary operator for null reference checks, only used internally.
 328          */
 329         NULLCHK,
 330 
 331         /** Binary operators, of type Binary.
 332          */
 333         OR,                              // ||
 334         AND,                             // &amp;&amp;
 335         BITOR,                           // |
 336         BITXOR,                          // ^
 337         BITAND,                          // &amp;
 338         EQ,                              // ==
 339         NE,                              // !=
 340         LT,                              // &lt;
 341         GT,                              // &gt;
 342         LE,                              // &lt;=
 343         GE,                              // &gt;=
 344         SL,                              // &lt;&lt;
 345         SR,                              // &gt;&gt;
 346         USR,                             // &gt;&gt;&gt;
 347         PLUS,                            // +
 348         MINUS,                           // -
 349         MUL,                             // *
 350         DIV,                             // /
 351         MOD,                             // %
 352 
 353         /** Assignment operators, of type Assignop.
 354          */
 355         BITOR_ASG(BITOR),                // |=
 356         BITXOR_ASG(BITXOR),              // ^=
 357         BITAND_ASG(BITAND),              // &amp;=
 358 
 359         SL_ASG(SL),                      // &lt;&lt;=
 360         SR_ASG(SR),                      // &gt;&gt;=
 361         USR_ASG(USR),                    // &gt;&gt;&gt;=
 362         PLUS_ASG(PLUS),                  // +=
 363         MINUS_ASG(MINUS),                // -=
 364         MUL_ASG(MUL),                    // *=
 365         DIV_ASG(DIV),                    // /=
 366         MOD_ASG(MOD),                    // %=
 367 
 368         MODULEDEF,
 369         EXPORTS,
 370         OPENS,
 371         PROVIDES,
 372         REQUIRES,
 373         USES,
 374 
 375         /** A synthetic let expression, of type LetExpr.
 376          */
 377         LETEXPR;                         // ala scheme
 378 
 379         private final Tag noAssignTag;
 380 
 381         private static final int numberOfOperators = MOD.ordinal() - POS.ordinal() + 1;
 382 
 383         private Tag(Tag noAssignTag) {
 384             this.noAssignTag = noAssignTag;
 385         }
 386 
 387         private Tag() {
 388             this(null);
 389         }
 390 
 391         public static int getNumberOfOperators() {
 392             return numberOfOperators;
 393         }
 394 
 395         public Tag noAssignOp() {
 396             if (noAssignTag != null)
 397                 return noAssignTag;
 398             throw new AssertionError(&quot;noAssignOp() method is not available for non assignment tags&quot;);
 399         }
 400 
 401         public boolean isPostUnaryOp() {
 402             return (this == POSTINC || this == POSTDEC);
 403         }
 404 
 405         public boolean isIncOrDecUnaryOp() {
 406             return (this == PREINC || this == PREDEC || this == POSTINC || this == POSTDEC);
 407         }
 408 
 409         public boolean isAssignop() {
 410             return noAssignTag != null;
 411         }
 412 
 413         public int operatorIndex() {
 414             return (this.ordinal() - POS.ordinal());
 415         }
 416     }
 417 
 418     /* The (encoded) position in the source file. @see util.Position.
 419      */
 420     public int pos;
 421 
 422     /* The type of this node.
 423      */
 424     public Type type;
 425 
 426     /* The tag of this node -- one of the constants declared above.
 427      */
 428     public abstract Tag getTag();
 429 
 430     /* Returns true if the tag of this node is equals to tag.
 431      */
 432     public boolean hasTag(Tag tag) {
 433         return tag == getTag();
 434     }
 435 
 436     /** Convert a tree to a pretty-printed string. */
 437     @Override
 438     public String toString() {
 439         StringWriter s = new StringWriter();
 440         try {
 441             new Pretty(s, false).printExpr(this);
 442         }
 443         catch (IOException e) {
 444             // should never happen, because StringWriter is defined
 445             // never to throw any IOExceptions
 446             throw new AssertionError(e);
 447         }
 448         return s.toString();
 449     }
 450 
 451     /** Set position field and return this tree.
 452      */
 453     public JCTree setPos(int pos) {
 454         this.pos = pos;
 455         return this;
 456     }
 457 
 458     /** Set type field and return this tree.
 459      */
 460     public JCTree setType(Type type) {
 461         this.type = type;
 462         return this;
 463     }
 464 
 465     /** Visit this tree with a given visitor.
 466      */
 467     public abstract void accept(Visitor v);
 468 
 469     @DefinedBy(Api.COMPILER_TREE)
 470     public abstract &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d);
 471 
 472     /** Return a shallow copy of this tree.
 473      */
 474     @Override
 475     public Object clone() {
 476         try {
 477             return super.clone();
 478         } catch(CloneNotSupportedException e) {
 479             throw new RuntimeException(e);
 480         }
 481     }
 482 
 483     /** Get a default position for this tree node.
 484      */
 485     public DiagnosticPosition pos() {
 486         return this;
 487     }
 488 
 489     // for default DiagnosticPosition
 490     public JCTree getTree() {
 491         return this;
 492     }
 493 
 494     // for default DiagnosticPosition
 495     public int getStartPosition() {
 496         return TreeInfo.getStartPos(this);
 497     }
 498 
 499     // for default DiagnosticPosition
 500     public int getPreferredPosition() {
 501         return pos;
 502     }
 503 
 504     // for default DiagnosticPosition
 505     public int getEndPosition(EndPosTable endPosTable) {
 506         return TreeInfo.getEndPos(this, endPosTable);
 507     }
 508 
 509     /**
 510      * Everything in one source file is kept in a {@linkplain JCCompilationUnit} structure.
 511      */
 512     public static class JCCompilationUnit extends JCTree implements CompilationUnitTree {
 513         /** All definitions in this file (ClassDef, Import, and Skip) */
 514         public List&lt;JCTree&gt; defs;
 515         /** The source file name. */
 516         public JavaFileObject sourcefile;
 517         /** The module to which this compilation unit belongs. */
 518         public ModuleSymbol modle;
 519         /** The location in which this compilation unit was found. */
 520         public Location locn;
 521         /** The package to which this compilation unit belongs. */
 522         public PackageSymbol packge;
 523         /** A scope containing top level classes. */
 524         public WriteableScope toplevelScope;
 525         /** A scope for all named imports. */
 526         public NamedImportScope namedImportScope;
 527         /** A scope for all import-on-demands. */
 528         public StarImportScope starImportScope;
 529         /** Line starting positions, defined only if option -g is set. */
 530         public Position.LineMap lineMap = null;
 531         /** A table that stores all documentation comments indexed by the tree
 532          * nodes they refer to. defined only if option -s is set. */
 533         public DocCommentTable docComments = null;
 534         /* An object encapsulating ending positions of source ranges indexed by
 535          * the tree nodes they belong to. Defined only if option -Xjcov is set. */
 536         public EndPosTable endPositions = null;
 537         protected JCCompilationUnit(List&lt;JCTree&gt; defs) {
 538             this.defs = defs;
 539         }
 540         @Override
 541         public void accept(Visitor v) { v.visitTopLevel(this); }
 542 
 543         @DefinedBy(Api.COMPILER_TREE)
 544         public Kind getKind() { return Kind.COMPILATION_UNIT; }
 545 
 546         public JCModuleDecl getModuleDecl() {
 547             for (JCTree tree : defs) {
 548                 if (tree.hasTag(MODULEDEF)) {
 549                     return (JCModuleDecl) tree;
 550                 }
 551             }
 552 
 553             return null;
 554         }
 555 
 556         @DefinedBy(Api.COMPILER_TREE)
 557         public JCPackageDecl getPackage() {
 558             // PackageDecl must be the first entry if it exists
 559             if (!defs.isEmpty() &amp;&amp; defs.head.hasTag(PACKAGEDEF))
 560                 return (JCPackageDecl)defs.head;
 561             return null;
 562         }
 563         @DefinedBy(Api.COMPILER_TREE)
 564         public List&lt;JCAnnotation&gt; getPackageAnnotations() {
 565             JCPackageDecl pd = getPackage();
 566             return pd != null ? pd.getAnnotations() : List.nil();
 567         }
 568         @DefinedBy(Api.COMPILER_TREE)
 569         public ExpressionTree getPackageName() {
 570             JCPackageDecl pd = getPackage();
 571             return pd != null ? pd.getPackageName() : null;
 572         }
 573 
 574         @DefinedBy(Api.COMPILER_TREE)
 575         public List&lt;JCImport&gt; getImports() {
 576             ListBuffer&lt;JCImport&gt; imports = new ListBuffer&lt;&gt;();
 577             for (JCTree tree : defs) {
 578                 if (tree.hasTag(IMPORT))
 579                     imports.append((JCImport)tree);
 580                 else if (!tree.hasTag(PACKAGEDEF) &amp;&amp; !tree.hasTag(SKIP))
 581                     break;
 582             }
 583             return imports.toList();
 584         }
 585         @DefinedBy(Api.COMPILER_TREE)
 586         public JavaFileObject getSourceFile() {
 587             return sourcefile;
 588         }
 589         @DefinedBy(Api.COMPILER_TREE)
 590         public Position.LineMap getLineMap() {
 591             return lineMap;
 592         }
 593         @DefinedBy(Api.COMPILER_TREE)
 594         public List&lt;JCTree&gt; getTypeDecls() {
 595             List&lt;JCTree&gt; typeDefs;
 596             for (typeDefs = defs; !typeDefs.isEmpty(); typeDefs = typeDefs.tail)
 597                 if (!typeDefs.head.hasTag(PACKAGEDEF) &amp;&amp; !typeDefs.head.hasTag(IMPORT))
 598                     break;
 599             return typeDefs;
 600         }
 601         @Override @DefinedBy(Api.COMPILER_TREE)
 602         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 603             return v.visitCompilationUnit(this, d);
 604         }
 605 
 606         @Override
 607         public Tag getTag() {
 608             return TOPLEVEL;
 609         }
 610     }
 611 
 612     /**
 613      * Package definition.
 614      */
 615     public static class JCPackageDecl extends JCTree implements PackageTree {
 616         public List&lt;JCAnnotation&gt; annotations;
 617         /** The tree representing the package clause. */
 618         public JCExpression pid;
 619         public PackageSymbol packge;
 620         public JCPackageDecl(List&lt;JCAnnotation&gt; annotations, JCExpression pid) {
 621             this.annotations = annotations;
 622             this.pid = pid;
 623         }
 624         @Override
 625         public void accept(Visitor v) { v.visitPackageDef(this); }
 626         @DefinedBy(Api.COMPILER_TREE)
 627         public Kind getKind() {
 628             return Kind.PACKAGE;
 629         }
 630         @DefinedBy(Api.COMPILER_TREE)
 631         public List&lt;JCAnnotation&gt; getAnnotations() {
 632             return annotations;
 633         }
 634         @DefinedBy(Api.COMPILER_TREE)
 635         public JCExpression getPackageName() {
 636             return pid;
 637         }
 638         @Override @DefinedBy(Api.COMPILER_TREE)
 639         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 640             return v.visitPackage(this, d);
 641         }
 642         @Override
 643         public Tag getTag() {
 644             return PACKAGEDEF;
 645         }
 646     }
 647 
 648     /**
 649      * An import clause.
 650      */
 651     public static class JCImport extends JCTree implements ImportTree {
 652         public boolean staticImport;
 653         /** The imported class(es). */
 654         public JCTree qualid;
 655         public com.sun.tools.javac.code.Scope importScope;
 656         protected JCImport(JCTree qualid, boolean importStatic) {
 657             this.qualid = qualid;
 658             this.staticImport = importStatic;
 659         }
 660         @Override
 661         public void accept(Visitor v) { v.visitImport(this); }
 662 
 663         @DefinedBy(Api.COMPILER_TREE)
 664         public boolean isStatic() { return staticImport; }
 665         @DefinedBy(Api.COMPILER_TREE)
 666         public JCTree getQualifiedIdentifier() { return qualid; }
 667 
 668         @DefinedBy(Api.COMPILER_TREE)
 669         public Kind getKind() { return Kind.IMPORT; }
 670         @Override @DefinedBy(Api.COMPILER_TREE)
 671         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 672             return v.visitImport(this, d);
 673         }
 674 
 675         @Override
 676         public Tag getTag() {
 677             return IMPORT;
 678         }
 679     }
 680 
 681     public static abstract class JCStatement extends JCTree implements StatementTree {
 682         @Override
 683         public JCStatement setType(Type type) {
 684             super.setType(type);
 685             return this;
 686         }
 687         @Override
 688         public JCStatement setPos(int pos) {
 689             super.setPos(pos);
 690             return this;
 691         }
 692     }
 693 
 694     public static abstract class JCExpression extends JCTree implements ExpressionTree {
 695         @Override
 696         public JCExpression setType(Type type) {
 697             super.setType(type);
 698             return this;
 699         }
 700         @Override
 701         public JCExpression setPos(int pos) {
 702             super.setPos(pos);
 703             return this;
 704         }
 705 
 706         public boolean isPoly() { return false; }
 707         public boolean isStandalone() { return true; }
 708     }
 709 
 710     /**
 711      * Common supertype for all poly expression trees (lambda, method references,
 712      * conditionals, method and constructor calls)
 713      */
 714     public static abstract class JCPolyExpression extends JCExpression {
 715 
 716         /**
 717          * A poly expression can only be truly &#39;poly&#39; in certain contexts
 718          */
 719         public enum PolyKind {
 720             /** poly expression to be treated as a standalone expression */
 721             STANDALONE,
 722             /** true poly expression */
 723             POLY
 724         }
 725 
 726         /** is this poly expression a &#39;true&#39; poly expression? */
 727         public PolyKind polyKind;
 728 
 729         @Override public boolean isPoly() { return polyKind == PolyKind.POLY; }
 730         @Override public boolean isStandalone() { return polyKind == PolyKind.STANDALONE; }
 731     }
 732 
 733     /**
 734      * Common supertype for all functional expression trees (lambda and method references)
 735      */
 736     public static abstract class JCFunctionalExpression extends JCPolyExpression {
 737 
 738         public JCFunctionalExpression() {
 739             //a functional expression is always a &#39;true&#39; poly
 740             polyKind = PolyKind.POLY;
 741         }
 742 
 743         /** list of target types inferred for this functional expression. */
 744         public Type target;
 745 
 746         public Type getDescriptorType(Types types) {
 747             return target != null ? types.findDescriptorType(target) : types.createErrorType(null);
 748         }
 749     }
 750 
 751     /**
 752      * A class definition.
 753      */
 754     public static class JCClassDecl extends JCStatement implements ClassTree {
 755         /** the modifiers */
 756         public JCModifiers mods;
 757         /** the name of the class */
 758         public Name name;
 759         /** formal class parameters */
 760         public List&lt;JCTypeParameter&gt; typarams;
 761         /** the classes this class extends */
 762         public JCExpression extending;
 763         /** the interfaces implemented by this class */
 764         public List&lt;JCExpression&gt; implementing;
<a name="1" id="anc1"></a>

 765         /** all variables and methods defined in this class */
 766         public List&lt;JCTree&gt; defs;
 767         /** the symbol */
 768         public ClassSymbol sym;
 769         protected JCClassDecl(JCModifiers mods,
 770                            Name name,
 771                            List&lt;JCTypeParameter&gt; typarams,
 772                            JCExpression extending,
 773                            List&lt;JCExpression&gt; implementing,
<a name="2" id="anc2"></a>
 774                            List&lt;JCTree&gt; defs,
 775                            ClassSymbol sym)
 776         {
 777             this.mods = mods;
 778             this.name = name;
 779             this.typarams = typarams;
 780             this.extending = extending;
 781             this.implementing = implementing;
<a name="3" id="anc3"></a>
 782             this.defs = defs;
 783             this.sym = sym;
 784         }
 785         @Override
 786         public void accept(Visitor v) { v.visitClassDef(this); }
 787 
 788         @SuppressWarnings(&quot;preview&quot;)
 789         @DefinedBy(Api.COMPILER_TREE)
 790         public Kind getKind() {
 791             if ((mods.flags &amp; Flags.ANNOTATION) != 0)
 792                 return Kind.ANNOTATION_TYPE;
 793             else if ((mods.flags &amp; Flags.INTERFACE) != 0)
 794                 return Kind.INTERFACE;
 795             else if ((mods.flags &amp; Flags.ENUM) != 0)
 796                 return Kind.ENUM;
 797             else if ((mods.flags &amp; Flags.RECORD) != 0)
 798                 return Kind.RECORD;
 799             else
 800                 return Kind.CLASS;
 801         }
 802 
 803         @DefinedBy(Api.COMPILER_TREE)
 804         public JCModifiers getModifiers() { return mods; }
 805         @DefinedBy(Api.COMPILER_TREE)
 806         public Name getSimpleName() { return name; }
 807         @DefinedBy(Api.COMPILER_TREE)
 808         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 809             return typarams;
 810         }
 811         @DefinedBy(Api.COMPILER_TREE)
 812         public JCExpression getExtendsClause() { return extending; }
 813         @DefinedBy(Api.COMPILER_TREE)
 814         public List&lt;JCExpression&gt; getImplementsClause() {
 815             return implementing;
 816         }
<a name="4" id="anc4"></a>




 817         @DefinedBy(Api.COMPILER_TREE)
 818         public List&lt;JCTree&gt; getMembers() {
 819             return defs;
 820         }
 821         @Override @DefinedBy(Api.COMPILER_TREE)
 822         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 823             return v.visitClass(this, d);
 824         }
 825 
 826         @Override
 827         public Tag getTag() {
 828             return CLASSDEF;
 829         }
 830     }
 831 
 832     /**
 833      * A method definition.
 834      */
 835     public static class JCMethodDecl extends JCTree implements MethodTree {
 836         /** method modifiers */
 837         public JCModifiers mods;
 838         /** method name */
 839         public Name name;
 840         /** type of method return value */
 841         public JCExpression restype;
 842         /** type parameters */
 843         public List&lt;JCTypeParameter&gt; typarams;
 844         /** receiver parameter */
 845         public JCVariableDecl recvparam;
 846         /** value parameters */
 847         public List&lt;JCVariableDecl&gt; params;
 848         /** exceptions thrown by this method */
 849         public List&lt;JCExpression&gt; thrown;
 850         /** statements in the method */
 851         public JCBlock body;
 852         /** default value, for annotation types */
 853         public JCExpression defaultValue;
 854         /** method symbol */
 855         public MethodSymbol sym;
 856         /** does this method completes normally */
 857         public boolean completesNormally;
 858 
 859         protected JCMethodDecl(JCModifiers mods,
 860                             Name name,
 861                             JCExpression restype,
 862                             List&lt;JCTypeParameter&gt; typarams,
 863                             JCVariableDecl recvparam,
 864                             List&lt;JCVariableDecl&gt; params,
 865                             List&lt;JCExpression&gt; thrown,
 866                             JCBlock body,
 867                             JCExpression defaultValue,
 868                             MethodSymbol sym)
 869         {
 870             this.mods = mods;
 871             this.name = name;
 872             this.restype = restype;
 873             this.typarams = typarams;
 874             this.params = params;
 875             this.recvparam = recvparam;
 876             // TODO: do something special if the given type is null?
 877             // receiver != null ? receiver : List.&lt;JCTypeAnnotation&gt;nil());
 878             this.thrown = thrown;
 879             this.body = body;
 880             this.defaultValue = defaultValue;
 881             this.sym = sym;
 882         }
 883         @Override
 884         public void accept(Visitor v) { v.visitMethodDef(this); }
 885 
 886         @DefinedBy(Api.COMPILER_TREE)
 887         public Kind getKind() { return Kind.METHOD; }
 888         @DefinedBy(Api.COMPILER_TREE)
 889         public JCModifiers getModifiers() { return mods; }
 890         @DefinedBy(Api.COMPILER_TREE)
 891         public Name getName() { return name; }
 892         @DefinedBy(Api.COMPILER_TREE)
 893         public JCTree getReturnType() { return restype; }
 894         @DefinedBy(Api.COMPILER_TREE)
 895         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 896             return typarams;
 897         }
 898         @DefinedBy(Api.COMPILER_TREE)
 899         public List&lt;JCVariableDecl&gt; getParameters() {
 900             return params;
 901         }
 902         @DefinedBy(Api.COMPILER_TREE)
 903         public JCVariableDecl getReceiverParameter() { return recvparam; }
 904         @DefinedBy(Api.COMPILER_TREE)
 905         public List&lt;JCExpression&gt; getThrows() {
 906             return thrown;
 907         }
 908         @DefinedBy(Api.COMPILER_TREE)
 909         public JCBlock getBody() { return body; }
 910         @DefinedBy(Api.COMPILER_TREE)
 911         public JCTree getDefaultValue() { // for annotation types
 912             return defaultValue;
 913         }
 914         @Override @DefinedBy(Api.COMPILER_TREE)
 915         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 916             return v.visitMethod(this, d);
 917         }
 918 
 919         @Override
 920         public Tag getTag() {
 921             return METHODDEF;
 922         }
 923   }
 924 
 925     /**
 926      * A variable definition.
 927      */
 928     public static class JCVariableDecl extends JCStatement implements VariableTree {
 929         /** variable modifiers */
 930         public JCModifiers mods;
 931         /** variable name */
 932         public Name name;
 933         /** variable name expression */
 934         public JCExpression nameexpr;
 935         /** type of the variable */
 936         public JCExpression vartype;
 937         /** variable&#39;s initial value */
 938         public JCExpression init;
 939         /** symbol */
 940         public VarSymbol sym;
 941         /** explicit start pos */
 942         public int startPos = Position.NOPOS;
 943 
 944         protected JCVariableDecl(JCModifiers mods,
 945                          Name name,
 946                          JCExpression vartype,
 947                          JCExpression init,
 948                          VarSymbol sym) {
 949             this.mods = mods;
 950             this.name = name;
 951             this.vartype = vartype;
 952             this.init = init;
 953             this.sym = sym;
 954         }
 955 
 956         protected JCVariableDecl(JCModifiers mods,
 957                          JCExpression nameexpr,
 958                          JCExpression vartype) {
 959             this(mods, null, vartype, null, null);
 960             this.nameexpr = nameexpr;
 961             if (nameexpr.hasTag(Tag.IDENT)) {
 962                 this.name = ((JCIdent)nameexpr).name;
 963             } else {
 964                 // Only other option is qualified name x.y.this;
 965                 this.name = ((JCFieldAccess)nameexpr).name;
 966             }
 967         }
 968 
 969         public boolean isImplicitlyTyped() {
 970             return vartype == null;
 971         }
 972 
 973         @Override
 974         public void accept(Visitor v) { v.visitVarDef(this); }
 975 
 976         @DefinedBy(Api.COMPILER_TREE)
 977         public Kind getKind() { return Kind.VARIABLE; }
 978         @DefinedBy(Api.COMPILER_TREE)
 979         public JCModifiers getModifiers() { return mods; }
 980         @DefinedBy(Api.COMPILER_TREE)
 981         public Name getName() { return name; }
 982         @DefinedBy(Api.COMPILER_TREE)
 983         public JCExpression getNameExpression() { return nameexpr; }
 984         @DefinedBy(Api.COMPILER_TREE)
 985         public JCTree getType() { return vartype; }
 986         @DefinedBy(Api.COMPILER_TREE)
 987         public JCExpression getInitializer() {
 988             return init;
 989         }
 990         @Override @DefinedBy(Api.COMPILER_TREE)
 991         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 992             return v.visitVariable(this, d);
 993         }
 994 
 995         @Override
 996         public Tag getTag() {
 997             return VARDEF;
 998         }
 999     }
1000 
1001     /**
1002      * A no-op statement &quot;;&quot;.
1003      */
1004     public static class JCSkip extends JCStatement implements EmptyStatementTree {
1005         protected JCSkip() {
1006         }
1007         @Override
1008         public void accept(Visitor v) { v.visitSkip(this); }
1009 
1010         @DefinedBy(Api.COMPILER_TREE)
1011         public Kind getKind() { return Kind.EMPTY_STATEMENT; }
1012         @Override @DefinedBy(Api.COMPILER_TREE)
1013         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1014             return v.visitEmptyStatement(this, d);
1015         }
1016 
1017         @Override
1018         public Tag getTag() {
1019             return SKIP;
1020         }
1021     }
1022 
1023     /**
1024      * A statement block.
1025      */
1026     public static class JCBlock extends JCStatement implements BlockTree {
1027         /** flags */
1028         public long flags;
1029         /** statements */
1030         public List&lt;JCStatement&gt; stats;
1031         /** Position of closing brace, optional. */
1032         public int endpos = Position.NOPOS;
1033         protected JCBlock(long flags, List&lt;JCStatement&gt; stats) {
1034             this.stats = stats;
1035             this.flags = flags;
1036         }
1037         @Override
1038         public void accept(Visitor v) { v.visitBlock(this); }
1039 
1040         @DefinedBy(Api.COMPILER_TREE)
1041         public Kind getKind() { return Kind.BLOCK; }
1042         @DefinedBy(Api.COMPILER_TREE)
1043         public List&lt;JCStatement&gt; getStatements() {
1044             return stats;
1045         }
1046         @DefinedBy(Api.COMPILER_TREE)
1047         public boolean isStatic() { return (flags &amp; Flags.STATIC) != 0; }
1048         @Override @DefinedBy(Api.COMPILER_TREE)
1049         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1050             return v.visitBlock(this, d);
1051         }
1052 
1053         @Override
1054         public Tag getTag() {
1055             return BLOCK;
1056         }
1057     }
1058 
1059     /**
1060      * A do loop
1061      */
1062     public static class JCDoWhileLoop extends JCStatement implements DoWhileLoopTree {
1063         public JCStatement body;
1064         public JCExpression cond;
1065         protected JCDoWhileLoop(JCStatement body, JCExpression cond) {
1066             this.body = body;
1067             this.cond = cond;
1068         }
1069         @Override
1070         public void accept(Visitor v) { v.visitDoLoop(this); }
1071 
1072         @DefinedBy(Api.COMPILER_TREE)
1073         public Kind getKind() { return Kind.DO_WHILE_LOOP; }
1074         @DefinedBy(Api.COMPILER_TREE)
1075         public JCExpression getCondition() { return cond; }
1076         @DefinedBy(Api.COMPILER_TREE)
1077         public JCStatement getStatement() { return body; }
1078         @Override @DefinedBy(Api.COMPILER_TREE)
1079         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1080             return v.visitDoWhileLoop(this, d);
1081         }
1082 
1083         @Override
1084         public Tag getTag() {
1085             return DOLOOP;
1086         }
1087     }
1088 
1089     /**
1090      * A while loop
1091      */
1092     public static class JCWhileLoop extends JCStatement implements WhileLoopTree {
1093         public JCExpression cond;
1094         public JCStatement body;
1095         protected JCWhileLoop(JCExpression cond, JCStatement body) {
1096             this.cond = cond;
1097             this.body = body;
1098         }
1099         @Override
1100         public void accept(Visitor v) { v.visitWhileLoop(this); }
1101 
1102         @DefinedBy(Api.COMPILER_TREE)
1103         public Kind getKind() { return Kind.WHILE_LOOP; }
1104         @DefinedBy(Api.COMPILER_TREE)
1105         public JCExpression getCondition() { return cond; }
1106         @DefinedBy(Api.COMPILER_TREE)
1107         public JCStatement getStatement() { return body; }
1108         @Override @DefinedBy(Api.COMPILER_TREE)
1109         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1110             return v.visitWhileLoop(this, d);
1111         }
1112 
1113         @Override
1114         public Tag getTag() {
1115             return WHILELOOP;
1116         }
1117     }
1118 
1119     /**
1120      * A for loop.
1121      */
1122     public static class JCForLoop extends JCStatement implements ForLoopTree {
1123         public List&lt;JCStatement&gt; init;
1124         public JCExpression cond;
1125         public List&lt;JCExpressionStatement&gt; step;
1126         public JCStatement body;
1127         protected JCForLoop(List&lt;JCStatement&gt; init,
1128                           JCExpression cond,
1129                           List&lt;JCExpressionStatement&gt; update,
1130                           JCStatement body)
1131         {
1132             this.init = init;
1133             this.cond = cond;
1134             this.step = update;
1135             this.body = body;
1136         }
1137         @Override
1138         public void accept(Visitor v) { v.visitForLoop(this); }
1139 
1140         @DefinedBy(Api.COMPILER_TREE)
1141         public Kind getKind() { return Kind.FOR_LOOP; }
1142         @DefinedBy(Api.COMPILER_TREE)
1143         public JCExpression getCondition() { return cond; }
1144         @DefinedBy(Api.COMPILER_TREE)
1145         public JCStatement getStatement() { return body; }
1146         @DefinedBy(Api.COMPILER_TREE)
1147         public List&lt;JCStatement&gt; getInitializer() {
1148             return init;
1149         }
1150         @DefinedBy(Api.COMPILER_TREE)
1151         public List&lt;JCExpressionStatement&gt; getUpdate() {
1152             return step;
1153         }
1154         @Override @DefinedBy(Api.COMPILER_TREE)
1155         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1156             return v.visitForLoop(this, d);
1157         }
1158 
1159         @Override
1160         public Tag getTag() {
1161             return FORLOOP;
1162         }
1163     }
1164 
1165     /**
1166      * The enhanced for loop.
1167      */
1168     public static class JCEnhancedForLoop extends JCStatement implements EnhancedForLoopTree {
1169         public JCVariableDecl var;
1170         public JCExpression expr;
1171         public JCStatement body;
1172         protected JCEnhancedForLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {
1173             this.var = var;
1174             this.expr = expr;
1175             this.body = body;
1176         }
1177         @Override
1178         public void accept(Visitor v) { v.visitForeachLoop(this); }
1179 
1180         @DefinedBy(Api.COMPILER_TREE)
1181         public Kind getKind() { return Kind.ENHANCED_FOR_LOOP; }
1182         @DefinedBy(Api.COMPILER_TREE)
1183         public JCVariableDecl getVariable() { return var; }
1184         @DefinedBy(Api.COMPILER_TREE)
1185         public JCExpression getExpression() { return expr; }
1186         @DefinedBy(Api.COMPILER_TREE)
1187         public JCStatement getStatement() { return body; }
1188         @Override @DefinedBy(Api.COMPILER_TREE)
1189         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1190             return v.visitEnhancedForLoop(this, d);
1191         }
1192         @Override
1193         public Tag getTag() {
1194             return FOREACHLOOP;
1195         }
1196     }
1197 
1198     /**
1199      * A labelled expression or statement.
1200      */
1201     public static class JCLabeledStatement extends JCStatement implements LabeledStatementTree {
1202         public Name label;
1203         public JCStatement body;
1204         protected JCLabeledStatement(Name label, JCStatement body) {
1205             this.label = label;
1206             this.body = body;
1207         }
1208         @Override
1209         public void accept(Visitor v) { v.visitLabelled(this); }
1210         @DefinedBy(Api.COMPILER_TREE)
1211         public Kind getKind() { return Kind.LABELED_STATEMENT; }
1212         @DefinedBy(Api.COMPILER_TREE)
1213         public Name getLabel() { return label; }
1214         @DefinedBy(Api.COMPILER_TREE)
1215         public JCStatement getStatement() { return body; }
1216         @Override @DefinedBy(Api.COMPILER_TREE)
1217         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1218             return v.visitLabeledStatement(this, d);
1219         }
1220         @Override
1221         public Tag getTag() {
1222             return LABELLED;
1223         }
1224     }
1225 
1226     /**
1227      * A &quot;switch ( ) { }&quot; construction.
1228      */
1229     public static class JCSwitch extends JCStatement implements SwitchTree {
1230         public JCExpression selector;
1231         public List&lt;JCCase&gt; cases;
1232         protected JCSwitch(JCExpression selector, List&lt;JCCase&gt; cases) {
1233             this.selector = selector;
1234             this.cases = cases;
1235         }
1236         @Override
1237         public void accept(Visitor v) { v.visitSwitch(this); }
1238 
1239         @DefinedBy(Api.COMPILER_TREE)
1240         public Kind getKind() { return Kind.SWITCH; }
1241         @DefinedBy(Api.COMPILER_TREE)
1242         public JCExpression getExpression() { return selector; }
1243         @DefinedBy(Api.COMPILER_TREE)
1244         public List&lt;JCCase&gt; getCases() { return cases; }
1245         @Override @DefinedBy(Api.COMPILER_TREE)
1246         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1247             return v.visitSwitch(this, d);
1248         }
1249         @Override
1250         public Tag getTag() {
1251             return SWITCH;
1252         }
1253     }
1254 
1255     /**
1256      * A &quot;case  :&quot; of a switch.
1257      */
1258     public static class JCCase extends JCStatement implements CaseTree {
1259         //as CaseKind is deprecated for removal (as it is part of a preview feature),
1260         //using indirection through these fields to avoid unnecessary @SuppressWarnings:
1261         public static final CaseKind STATEMENT = CaseKind.STATEMENT;
1262         public static final CaseKind RULE = CaseKind.RULE;
1263         public final CaseKind caseKind;
1264         public List&lt;JCExpression&gt; pats;
1265         public List&lt;JCStatement&gt; stats;
1266         public JCTree body;
1267         public boolean completesNormally;
1268         protected JCCase(CaseKind caseKind, List&lt;JCExpression&gt; pats,
1269                          List&lt;JCStatement&gt; stats, JCTree body) {
1270             Assert.checkNonNull(pats);
1271             Assert.check(pats.isEmpty() || pats.head != null);
1272             this.caseKind = caseKind;
1273             this.pats = pats;
1274             this.stats = stats;
1275             this.body = body;
1276         }
1277         @Override
1278         public void accept(Visitor v) { v.visitCase(this); }
1279 
1280         @Override @DefinedBy(Api.COMPILER_TREE)
1281         public Kind getKind() { return Kind.CASE; }
1282         @Override @Deprecated @DefinedBy(Api.COMPILER_TREE)
1283         public JCExpression getExpression() { return pats.head; }
1284         @Override @DefinedBy(Api.COMPILER_TREE)
1285         public List&lt;JCExpression&gt; getExpressions() { return pats; }
1286         @Override @DefinedBy(Api.COMPILER_TREE)
1287         public List&lt;JCStatement&gt; getStatements() {
1288             return caseKind == CaseKind.STATEMENT ? stats : null;
1289         }
1290         @Override @DefinedBy(Api.COMPILER_TREE)
1291         public JCTree getBody() { return body; }
1292         @Override @DefinedBy(Api.COMPILER_TREE)
1293         public CaseKind getCaseKind() {
1294             return caseKind;
1295         }
1296         @Override @DefinedBy(Api.COMPILER_TREE)
1297         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1298             return v.visitCase(this, d);
1299         }
1300         @Override
1301         public Tag getTag() {
1302             return CASE;
1303         }
1304     }
1305 
1306     /**
1307      * A &quot;switch ( ) { }&quot; construction.
1308      */
1309     public static class JCSwitchExpression extends JCPolyExpression implements SwitchExpressionTree {
1310         public JCExpression selector;
1311         public List&lt;JCCase&gt; cases;
1312         /** Position of closing brace, optional. */
1313         public int endpos = Position.NOPOS;
1314         protected JCSwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
1315             this.selector = selector;
1316             this.cases = cases;
1317         }
1318         @Override
1319         public void accept(Visitor v) { v.visitSwitchExpression(this); }
1320 
1321         @DefinedBy(Api.COMPILER_TREE)
1322         public Kind getKind() { return Kind.SWITCH_EXPRESSION; }
1323         @DefinedBy(Api.COMPILER_TREE)
1324         public JCExpression getExpression() { return selector; }
1325         @DefinedBy(Api.COMPILER_TREE)
1326         public List&lt;JCCase&gt; getCases() { return cases; }
1327         @Override @DefinedBy(Api.COMPILER_TREE)
1328         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1329             return v.visitSwitchExpression(this, d);
1330         }
1331         @Override
1332         public Tag getTag() {
1333             return SWITCH_EXPRESSION;
1334         }
1335     }
1336 
1337     /**
1338      * A synchronized block.
1339      */
1340     public static class JCSynchronized extends JCStatement implements SynchronizedTree {
1341         public JCExpression lock;
1342         public JCBlock body;
1343         protected JCSynchronized(JCExpression lock, JCBlock body) {
1344             this.lock = lock;
1345             this.body = body;
1346         }
1347         @Override
1348         public void accept(Visitor v) { v.visitSynchronized(this); }
1349 
1350         @DefinedBy(Api.COMPILER_TREE)
1351         public Kind getKind() { return Kind.SYNCHRONIZED; }
1352         @DefinedBy(Api.COMPILER_TREE)
1353         public JCExpression getExpression() { return lock; }
1354         @DefinedBy(Api.COMPILER_TREE)
1355         public JCBlock getBlock() { return body; }
1356         @Override @DefinedBy(Api.COMPILER_TREE)
1357         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1358             return v.visitSynchronized(this, d);
1359         }
1360         @Override
1361         public Tag getTag() {
1362             return SYNCHRONIZED;
1363         }
1364     }
1365 
1366     /**
1367      * A &quot;try { } catch ( ) { } finally { }&quot; block.
1368      */
1369     public static class JCTry extends JCStatement implements TryTree {
1370         public JCBlock body;
1371         public List&lt;JCCatch&gt; catchers;
1372         public JCBlock finalizer;
1373         public List&lt;JCTree&gt; resources;
1374         public boolean finallyCanCompleteNormally;
1375         protected JCTry(List&lt;JCTree&gt; resources,
1376                         JCBlock body,
1377                         List&lt;JCCatch&gt; catchers,
1378                         JCBlock finalizer) {
1379             this.body = body;
1380             this.catchers = catchers;
1381             this.finalizer = finalizer;
1382             this.resources = resources;
1383         }
1384         @Override
1385         public void accept(Visitor v) { v.visitTry(this); }
1386 
1387         @DefinedBy(Api.COMPILER_TREE)
1388         public Kind getKind() { return Kind.TRY; }
1389         @DefinedBy(Api.COMPILER_TREE)
1390         public JCBlock getBlock() { return body; }
1391         @DefinedBy(Api.COMPILER_TREE)
1392         public List&lt;JCCatch&gt; getCatches() {
1393             return catchers;
1394         }
1395         @DefinedBy(Api.COMPILER_TREE)
1396         public JCBlock getFinallyBlock() { return finalizer; }
1397         @Override @DefinedBy(Api.COMPILER_TREE)
1398         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1399             return v.visitTry(this, d);
1400         }
1401         @Override @DefinedBy(Api.COMPILER_TREE)
1402         public List&lt;JCTree&gt; getResources() {
1403             return resources;
1404         }
1405         @Override
1406         public Tag getTag() {
1407             return TRY;
1408         }
1409     }
1410 
1411     /**
1412      * A catch block.
1413      */
1414     public static class JCCatch extends JCTree implements CatchTree {
1415         public JCVariableDecl param;
1416         public JCBlock body;
1417         protected JCCatch(JCVariableDecl param, JCBlock body) {
1418             this.param = param;
1419             this.body = body;
1420         }
1421         @Override
1422         public void accept(Visitor v) { v.visitCatch(this); }
1423 
1424         @DefinedBy(Api.COMPILER_TREE)
1425         public Kind getKind() { return Kind.CATCH; }
1426         @DefinedBy(Api.COMPILER_TREE)
1427         public JCVariableDecl getParameter() { return param; }
1428         @DefinedBy(Api.COMPILER_TREE)
1429         public JCBlock getBlock() { return body; }
1430         @Override @DefinedBy(Api.COMPILER_TREE)
1431         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1432             return v.visitCatch(this, d);
1433         }
1434         @Override
1435         public Tag getTag() {
1436             return CATCH;
1437         }
1438     }
1439 
1440     /**
1441      * A ( ) ? ( ) : ( ) conditional expression
1442      */
1443     public static class JCConditional extends JCPolyExpression implements ConditionalExpressionTree {
1444         public JCExpression cond;
1445         public JCExpression truepart;
1446         public JCExpression falsepart;
1447         protected JCConditional(JCExpression cond,
1448                               JCExpression truepart,
1449                               JCExpression falsepart)
1450         {
1451             this.cond = cond;
1452             this.truepart = truepart;
1453             this.falsepart = falsepart;
1454         }
1455         @Override
1456         public void accept(Visitor v) { v.visitConditional(this); }
1457 
1458         @DefinedBy(Api.COMPILER_TREE)
1459         public Kind getKind() { return Kind.CONDITIONAL_EXPRESSION; }
1460         @DefinedBy(Api.COMPILER_TREE)
1461         public JCExpression getCondition() { return cond; }
1462         @DefinedBy(Api.COMPILER_TREE)
1463         public JCExpression getTrueExpression() { return truepart; }
1464         @DefinedBy(Api.COMPILER_TREE)
1465         public JCExpression getFalseExpression() { return falsepart; }
1466         @Override @DefinedBy(Api.COMPILER_TREE)
1467         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1468             return v.visitConditionalExpression(this, d);
1469         }
1470         @Override
1471         public Tag getTag() {
1472             return CONDEXPR;
1473         }
1474     }
1475 
1476     /**
1477      * An &quot;if ( ) { } else { }&quot; block
1478      */
1479     public static class JCIf extends JCStatement implements IfTree {
1480         public JCExpression cond;
1481         public JCStatement thenpart;
1482         public JCStatement elsepart;
1483         protected JCIf(JCExpression cond,
1484                      JCStatement thenpart,
1485                      JCStatement elsepart)
1486         {
1487             this.cond = cond;
1488             this.thenpart = thenpart;
1489             this.elsepart = elsepart;
1490         }
1491         @Override
1492         public void accept(Visitor v) { v.visitIf(this); }
1493 
1494         @DefinedBy(Api.COMPILER_TREE)
1495         public Kind getKind() { return Kind.IF; }
1496         @DefinedBy(Api.COMPILER_TREE)
1497         public JCExpression getCondition() { return cond; }
1498         @DefinedBy(Api.COMPILER_TREE)
1499         public JCStatement getThenStatement() { return thenpart; }
1500         @DefinedBy(Api.COMPILER_TREE)
1501         public JCStatement getElseStatement() { return elsepart; }
1502         @Override @DefinedBy(Api.COMPILER_TREE)
1503         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1504             return v.visitIf(this, d);
1505         }
1506         @Override
1507         public Tag getTag() {
1508             return IF;
1509         }
1510     }
1511 
1512     /**
1513      * an expression statement
1514      */
1515     public static class JCExpressionStatement extends JCStatement implements ExpressionStatementTree {
1516         /** expression structure */
1517         public JCExpression expr;
1518         protected JCExpressionStatement(JCExpression expr)
1519         {
1520             this.expr = expr;
1521         }
1522         @Override
1523         public void accept(Visitor v) { v.visitExec(this); }
1524 
1525         @DefinedBy(Api.COMPILER_TREE)
1526         public Kind getKind() { return Kind.EXPRESSION_STATEMENT; }
1527         @DefinedBy(Api.COMPILER_TREE)
1528         public JCExpression getExpression() { return expr; }
1529         @Override @DefinedBy(Api.COMPILER_TREE)
1530         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1531             return v.visitExpressionStatement(this, d);
1532         }
1533         @Override
1534         public Tag getTag() {
1535             return EXEC;
1536         }
1537 
1538         /** Convert a expression-statement tree to a pretty-printed string. */
1539         @Override
1540         public String toString() {
1541             StringWriter s = new StringWriter();
1542             try {
1543                 new Pretty(s, false).printStat(this);
1544             }
1545             catch (IOException e) {
1546                 // should never happen, because StringWriter is defined
1547                 // never to throw any IOExceptions
1548                 throw new AssertionError(e);
1549             }
1550             return s.toString();
1551         }
1552     }
1553 
1554     /**
1555      * A break from a loop or switch.
1556      */
1557     public static class JCBreak extends JCStatement implements BreakTree {
1558         public Name label;
1559         public JCTree target;
1560         protected JCBreak(Name label, JCTree target) {
1561             this.label = label;
1562             this.target = target;
1563         }
1564         @Override
1565         public void accept(Visitor v) { v.visitBreak(this); }
1566         public boolean isValueBreak() {
1567             return target != null &amp;&amp; target.hasTag(SWITCH_EXPRESSION);
1568         }
1569 
1570         @DefinedBy(Api.COMPILER_TREE)
1571         public Kind getKind() { return Kind.BREAK; }
1572         @DefinedBy(Api.COMPILER_TREE)
1573         public Name getLabel() {
1574             return label;
1575         }
1576         @Override @DefinedBy(Api.COMPILER_TREE)
1577         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1578             return v.visitBreak(this, d);
1579         }
1580         @Override
1581         public Tag getTag() {
1582             return BREAK;
1583         }
1584     }
1585 
1586     /**
1587      * A break-with from a switch expression.
1588      */
1589     public static class JCYield extends JCStatement implements YieldTree {
1590         public JCExpression value;
1591         public JCTree target;
1592         protected JCYield(JCExpression value, JCTree target) {
1593             this.value = value;
1594             this.target = target;
1595         }
1596         @Override
1597         public void accept(Visitor v) { v.visitYield(this); }
1598         @DefinedBy(Api.COMPILER_TREE)
1599         public Kind getKind() { return Kind.YIELD; }
1600         @DefinedBy(Api.COMPILER_TREE)
1601         public JCExpression getValue() { return value; }
1602         @Override @DefinedBy(Api.COMPILER_TREE)
1603         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1604             return v.visitYield(this, d);
1605         }
1606         @Override
1607         public Tag getTag() {
1608             return YIELD;
1609         }
1610     }
1611 
1612     /**
1613      * A continue of a loop.
1614      */
1615     public static class JCContinue extends JCStatement implements ContinueTree {
1616         public Name label;
1617         public JCTree target;
1618         protected JCContinue(Name label, JCTree target) {
1619             this.label = label;
1620             this.target = target;
1621         }
1622         @Override
1623         public void accept(Visitor v) { v.visitContinue(this); }
1624 
1625         @DefinedBy(Api.COMPILER_TREE)
1626         public Kind getKind() { return Kind.CONTINUE; }
1627         @DefinedBy(Api.COMPILER_TREE)
1628         public Name getLabel() { return label; }
1629         @Override @DefinedBy(Api.COMPILER_TREE)
1630         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1631             return v.visitContinue(this, d);
1632         }
1633         @Override
1634         public Tag getTag() {
1635             return CONTINUE;
1636         }
1637     }
1638 
1639     /**
1640      * A return statement.
1641      */
1642     public static class JCReturn extends JCStatement implements ReturnTree {
1643         public JCExpression expr;
1644         protected JCReturn(JCExpression expr) {
1645             this.expr = expr;
1646         }
1647         @Override
1648         public void accept(Visitor v) { v.visitReturn(this); }
1649 
1650         @DefinedBy(Api.COMPILER_TREE)
1651         public Kind getKind() { return Kind.RETURN; }
1652         @DefinedBy(Api.COMPILER_TREE)
1653         public JCExpression getExpression() { return expr; }
1654         @Override @DefinedBy(Api.COMPILER_TREE)
1655         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1656             return v.visitReturn(this, d);
1657         }
1658         @Override
1659         public Tag getTag() {
1660             return RETURN;
1661         }
1662     }
1663 
1664     /**
1665      * A throw statement.
1666      */
1667     public static class JCThrow extends JCStatement implements ThrowTree {
1668         public JCExpression expr;
1669         protected JCThrow(JCExpression expr) {
1670             this.expr = expr;
1671         }
1672         @Override
1673         public void accept(Visitor v) { v.visitThrow(this); }
1674 
1675         @DefinedBy(Api.COMPILER_TREE)
1676         public Kind getKind() { return Kind.THROW; }
1677         @DefinedBy(Api.COMPILER_TREE)
1678         public JCExpression getExpression() { return expr; }
1679         @Override @DefinedBy(Api.COMPILER_TREE)
1680         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1681             return v.visitThrow(this, d);
1682         }
1683         @Override
1684         public Tag getTag() {
1685             return THROW;
1686         }
1687     }
1688 
1689     /**
1690      * An assert statement.
1691      */
1692     public static class JCAssert extends JCStatement implements AssertTree {
1693         public JCExpression cond;
1694         public JCExpression detail;
1695         protected JCAssert(JCExpression cond, JCExpression detail) {
1696             this.cond = cond;
1697             this.detail = detail;
1698         }
1699         @Override
1700         public void accept(Visitor v) { v.visitAssert(this); }
1701 
1702         @DefinedBy(Api.COMPILER_TREE)
1703         public Kind getKind() { return Kind.ASSERT; }
1704         @DefinedBy(Api.COMPILER_TREE)
1705         public JCExpression getCondition() { return cond; }
1706         @DefinedBy(Api.COMPILER_TREE)
1707         public JCExpression getDetail() { return detail; }
1708         @Override @DefinedBy(Api.COMPILER_TREE)
1709         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1710             return v.visitAssert(this, d);
1711         }
1712         @Override
1713         public Tag getTag() {
1714             return ASSERT;
1715         }
1716     }
1717 
1718     /**
1719      * A method invocation
1720      */
1721     public static class JCMethodInvocation extends JCPolyExpression implements MethodInvocationTree {
1722         public List&lt;JCExpression&gt; typeargs;
1723         public JCExpression meth;
1724         public List&lt;JCExpression&gt; args;
1725         public Type varargsElement;
1726         protected JCMethodInvocation(List&lt;JCExpression&gt; typeargs,
1727                         JCExpression meth,
1728                         List&lt;JCExpression&gt; args)
1729         {
1730             this.typeargs = (typeargs == null) ? List.nil()
1731                                                : typeargs;
1732             this.meth = meth;
1733             this.args = args;
1734         }
1735         @Override
1736         public void accept(Visitor v) { v.visitApply(this); }
1737 
1738         @DefinedBy(Api.COMPILER_TREE)
1739         public Kind getKind() { return Kind.METHOD_INVOCATION; }
1740         @DefinedBy(Api.COMPILER_TREE)
1741         public List&lt;JCExpression&gt; getTypeArguments() {
1742             return typeargs;
1743         }
1744         @DefinedBy(Api.COMPILER_TREE)
1745         public JCExpression getMethodSelect() { return meth; }
1746         @DefinedBy(Api.COMPILER_TREE)
1747         public List&lt;JCExpression&gt; getArguments() {
1748             return args;
1749         }
1750         @Override @DefinedBy(Api.COMPILER_TREE)
1751         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1752             return v.visitMethodInvocation(this, d);
1753         }
1754         @Override
1755         public JCMethodInvocation setType(Type type) {
1756             super.setType(type);
1757             return this;
1758         }
1759         @Override
1760         public Tag getTag() {
1761             return(APPLY);
1762         }
1763     }
1764 
1765     /**
1766      * A new(...) operation.
1767      */
1768     public static class JCNewClass extends JCPolyExpression implements NewClassTree {
1769         public JCExpression encl;
1770         public List&lt;JCExpression&gt; typeargs;
1771         public JCExpression clazz;
1772         public List&lt;JCExpression&gt; args;
1773         public JCClassDecl def;
1774         public Symbol constructor;
1775         public Type varargsElement;
1776         public Type constructorType;
1777         protected JCNewClass(JCExpression encl,
1778                            List&lt;JCExpression&gt; typeargs,
1779                            JCExpression clazz,
1780                            List&lt;JCExpression&gt; args,
1781                            JCClassDecl def)
1782         {
1783             this.encl = encl;
1784             this.typeargs = (typeargs == null) ? List.nil()
1785                                                : typeargs;
1786             this.clazz = clazz;
1787             this.args = args;
1788             this.def = def;
1789         }
1790         @Override
1791         public void accept(Visitor v) { v.visitNewClass(this); }
1792 
1793         @DefinedBy(Api.COMPILER_TREE)
1794         public Kind getKind() { return Kind.NEW_CLASS; }
1795         @DefinedBy(Api.COMPILER_TREE)
1796         public JCExpression getEnclosingExpression() { // expr.new C&lt; ... &gt; ( ... )
1797             return encl;
1798         }
1799         @DefinedBy(Api.COMPILER_TREE)
1800         public List&lt;JCExpression&gt; getTypeArguments() {
1801             return typeargs;
1802         }
1803         @DefinedBy(Api.COMPILER_TREE)
1804         public JCExpression getIdentifier() { return clazz; }
1805         @DefinedBy(Api.COMPILER_TREE)
1806         public List&lt;JCExpression&gt; getArguments() {
1807             return args;
1808         }
1809         @DefinedBy(Api.COMPILER_TREE)
1810         public JCClassDecl getClassBody() { return def; }
1811         @Override @DefinedBy(Api.COMPILER_TREE)
1812         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1813             return v.visitNewClass(this, d);
1814         }
1815         @Override
1816         public Tag getTag() {
1817             return NEWCLASS;
1818         }
1819 
1820         public boolean classDeclRemoved() {
1821             return false;
1822         }
1823     }
1824 
1825     /**
1826      * A new[...] operation.
1827      */
1828     public static class JCNewArray extends JCExpression implements NewArrayTree {
1829         public JCExpression elemtype;
1830         public List&lt;JCExpression&gt; dims;
1831         // type annotations on inner-most component
1832         public List&lt;JCAnnotation&gt; annotations;
1833         // type annotations on dimensions
1834         public List&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations;
1835         public List&lt;JCExpression&gt; elems;
1836         protected JCNewArray(JCExpression elemtype,
1837                            List&lt;JCExpression&gt; dims,
1838                            List&lt;JCExpression&gt; elems)
1839         {
1840             this.elemtype = elemtype;
1841             this.dims = dims;
1842             this.annotations = List.nil();
1843             this.dimAnnotations = List.nil();
1844             this.elems = elems;
1845         }
1846         @Override
1847         public void accept(Visitor v) { v.visitNewArray(this); }
1848 
1849         @DefinedBy(Api.COMPILER_TREE)
1850         public Kind getKind() { return Kind.NEW_ARRAY; }
1851         @DefinedBy(Api.COMPILER_TREE)
1852         public JCExpression getType() { return elemtype; }
1853         @DefinedBy(Api.COMPILER_TREE)
1854         public List&lt;JCExpression&gt; getDimensions() {
1855             return dims;
1856         }
1857         @DefinedBy(Api.COMPILER_TREE)
1858         public List&lt;JCExpression&gt; getInitializers() {
1859             return elems;
1860         }
1861         @Override @DefinedBy(Api.COMPILER_TREE)
1862         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1863             return v.visitNewArray(this, d);
1864         }
1865         @Override
1866         public Tag getTag() {
1867             return NEWARRAY;
1868         }
1869 
1870         @Override @DefinedBy(Api.COMPILER_TREE)
1871         public List&lt;JCAnnotation&gt; getAnnotations() {
1872             return annotations;
1873         }
1874 
1875         @Override @DefinedBy(Api.COMPILER_TREE)
1876         public List&lt;List&lt;JCAnnotation&gt;&gt; getDimAnnotations() {
1877             return dimAnnotations;
1878         }
1879     }
1880 
1881     /**
1882      * A lambda expression.
1883      */
1884     public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {
1885 
1886         public enum ParameterKind {
1887             IMPLICIT,
1888             EXPLICIT
1889         }
1890 
1891         public List&lt;JCVariableDecl&gt; params;
1892         public JCTree body;
1893         public boolean canCompleteNormally = true;
1894         public ParameterKind paramKind;
1895 
1896         public JCLambda(List&lt;JCVariableDecl&gt; params,
1897                         JCTree body) {
1898             this.params = params;
1899             this.body = body;
1900             if (params.isEmpty() ||
1901                 params.head.vartype != null) {
1902                 paramKind = ParameterKind.EXPLICIT;
1903             } else {
1904                 paramKind = ParameterKind.IMPLICIT;
1905             }
1906         }
1907         @Override
1908         public Tag getTag() {
1909             return LAMBDA;
1910         }
1911         @Override
1912         public void accept(Visitor v) {
1913             v.visitLambda(this);
1914         }
1915         @Override @DefinedBy(Api.COMPILER_TREE)
1916         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
1917             return v.visitLambdaExpression(this, d);
1918         }
1919         @DefinedBy(Api.COMPILER_TREE)
1920         public Kind getKind() {
1921             return Kind.LAMBDA_EXPRESSION;
1922         }
1923         @DefinedBy(Api.COMPILER_TREE)
1924         public JCTree getBody() {
1925             return body;
1926         }
1927         @DefinedBy(Api.COMPILER_TREE)
1928         public java.util.List&lt;? extends VariableTree&gt; getParameters() {
1929             return params;
1930         }
1931         @Override
1932         public JCLambda setType(Type type) {
1933             super.setType(type);
1934             return this;
1935         }
1936         @Override @DefinedBy(Api.COMPILER_TREE)
1937         public BodyKind getBodyKind() {
1938             return body.hasTag(BLOCK) ?
1939                     BodyKind.STATEMENT :
1940                     BodyKind.EXPRESSION;
1941         }
1942     }
1943 
1944     /**
1945      * A parenthesized subexpression ( ... )
1946      */
1947     public static class JCParens extends JCExpression implements ParenthesizedTree {
1948         public JCExpression expr;
1949         protected JCParens(JCExpression expr) {
1950             this.expr = expr;
1951         }
1952         @Override
1953         public void accept(Visitor v) { v.visitParens(this); }
1954 
1955         @DefinedBy(Api.COMPILER_TREE)
1956         public Kind getKind() { return Kind.PARENTHESIZED; }
1957         @DefinedBy(Api.COMPILER_TREE)
1958         public JCExpression getExpression() { return expr; }
1959         @Override @DefinedBy(Api.COMPILER_TREE)
1960         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1961             return v.visitParenthesized(this, d);
1962         }
1963         @Override
1964         public Tag getTag() {
1965             return PARENS;
1966         }
1967     }
1968 
1969     /**
1970      * A assignment with &quot;=&quot;.
1971      */
1972     public static class JCAssign extends JCExpression implements AssignmentTree {
1973         public JCExpression lhs;
1974         public JCExpression rhs;
1975         protected JCAssign(JCExpression lhs, JCExpression rhs) {
1976             this.lhs = lhs;
1977             this.rhs = rhs;
1978         }
1979         @Override
1980         public void accept(Visitor v) { v.visitAssign(this); }
1981 
1982         @DefinedBy(Api.COMPILER_TREE)
1983         public Kind getKind() { return Kind.ASSIGNMENT; }
1984         @DefinedBy(Api.COMPILER_TREE)
1985         public JCExpression getVariable() { return lhs; }
1986         @DefinedBy(Api.COMPILER_TREE)
1987         public JCExpression getExpression() { return rhs; }
1988         @Override @DefinedBy(Api.COMPILER_TREE)
1989         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1990             return v.visitAssignment(this, d);
1991         }
1992         @Override
1993         public Tag getTag() {
1994             return ASSIGN;
1995         }
1996     }
1997 
1998     public static abstract class JCOperatorExpression extends JCExpression {
1999         public enum OperandPos {
2000             LEFT,
2001             RIGHT
2002         }
2003 
2004         protected Tag opcode;
2005         public OperatorSymbol operator;
2006 
2007         public OperatorSymbol getOperator() {
2008             return operator;
2009         }
2010 
2011         @Override
2012         public Tag getTag() {
2013             return opcode;
2014         }
2015 
2016         public abstract JCExpression getOperand(OperandPos pos);
2017     }
2018 
2019     /**
2020      * An assignment with &quot;+=&quot;, &quot;|=&quot; ...
2021      */
2022     public static class JCAssignOp extends JCOperatorExpression implements CompoundAssignmentTree {
2023         public JCExpression lhs;
2024         public JCExpression rhs;
2025         protected JCAssignOp(Tag opcode, JCTree lhs, JCTree rhs, OperatorSymbol operator) {
2026             this.opcode = opcode;
2027             this.lhs = (JCExpression)lhs;
2028             this.rhs = (JCExpression)rhs;
2029             this.operator = operator;
2030         }
2031         @Override
2032         public void accept(Visitor v) { v.visitAssignop(this); }
2033 
2034         @DefinedBy(Api.COMPILER_TREE)
2035         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2036         @DefinedBy(Api.COMPILER_TREE)
2037         public JCExpression getVariable() { return lhs; }
2038         @DefinedBy(Api.COMPILER_TREE)
2039         public JCExpression getExpression() { return rhs; }
2040         @Override @DefinedBy(Api.COMPILER_TREE)
2041         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2042             return v.visitCompoundAssignment(this, d);
2043         }
2044         @Override
2045         public JCExpression getOperand(OperandPos pos) {
2046             return pos == OperandPos.LEFT ? lhs : rhs;
2047         }
2048     }
2049 
2050     /**
2051      * A unary operation.
2052      */
2053     public static class JCUnary extends JCOperatorExpression implements UnaryTree {
2054         public JCExpression arg;
2055         protected JCUnary(Tag opcode, JCExpression arg) {
2056             this.opcode = opcode;
2057             this.arg = arg;
2058         }
2059         @Override
2060         public void accept(Visitor v) { v.visitUnary(this); }
2061 
2062         @DefinedBy(Api.COMPILER_TREE)
2063         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2064         @DefinedBy(Api.COMPILER_TREE)
2065         public JCExpression getExpression() { return arg; }
2066         @Override @DefinedBy(Api.COMPILER_TREE)
2067         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2068             return v.visitUnary(this, d);
2069         }
2070         public void setTag(Tag tag) {
2071             opcode = tag;
2072         }
2073         @Override
2074         public JCExpression getOperand(OperandPos pos) {
2075             return arg;
2076         }
2077     }
2078 
2079     /**
2080      * A binary operation.
2081      */
2082     public static class JCBinary extends JCOperatorExpression implements BinaryTree {
2083         public JCExpression lhs;
2084         public JCExpression rhs;
2085         protected JCBinary(Tag opcode,
2086                          JCExpression lhs,
2087                          JCExpression rhs,
2088                          OperatorSymbol operator) {
2089             this.opcode = opcode;
2090             this.lhs = lhs;
2091             this.rhs = rhs;
2092             this.operator = operator;
2093         }
2094         @Override
2095         public void accept(Visitor v) { v.visitBinary(this); }
2096 
2097         @DefinedBy(Api.COMPILER_TREE)
2098         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2099         @DefinedBy(Api.COMPILER_TREE)
2100         public JCExpression getLeftOperand() { return lhs; }
2101         @DefinedBy(Api.COMPILER_TREE)
2102         public JCExpression getRightOperand() { return rhs; }
2103         @Override @DefinedBy(Api.COMPILER_TREE)
2104         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2105             return v.visitBinary(this, d);
2106         }
2107         @Override
2108         public JCExpression getOperand(OperandPos pos) {
2109             return pos == OperandPos.LEFT ? lhs : rhs;
2110         }
2111     }
2112 
2113     /**
2114      * A type cast.
2115      */
2116     public static class JCTypeCast extends JCExpression implements TypeCastTree {
2117         public JCTree clazz;
2118         public JCExpression expr;
2119         protected JCTypeCast(JCTree clazz, JCExpression expr) {
2120             this.clazz = clazz;
2121             this.expr = expr;
2122         }
2123         @Override
2124         public void accept(Visitor v) { v.visitTypeCast(this); }
2125 
2126         @DefinedBy(Api.COMPILER_TREE)
2127         public Kind getKind() { return Kind.TYPE_CAST; }
2128         @DefinedBy(Api.COMPILER_TREE)
2129         public JCTree getType() { return clazz; }
2130         @DefinedBy(Api.COMPILER_TREE)
2131         public JCExpression getExpression() { return expr; }
2132         @Override @DefinedBy(Api.COMPILER_TREE)
2133         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2134             return v.visitTypeCast(this, d);
2135         }
2136         @Override
2137         public Tag getTag() {
2138             return TYPECAST;
2139         }
2140     }
2141 
2142     /**
2143      * A type test.
2144      */
2145     public static class JCInstanceOf extends JCExpression implements InstanceOfTree {
2146         public JCExpression expr;
2147         public JCTree pattern;
2148         protected JCInstanceOf(JCExpression expr, JCTree pattern) {
2149             this.expr = expr;
2150             this.pattern = pattern;
2151         }
2152         @Override
2153         public void accept(Visitor v) { v.visitTypeTest(this); }
2154 
2155         @DefinedBy(Api.COMPILER_TREE)
2156         public Kind getKind() { return Kind.INSTANCE_OF; }
2157         @DefinedBy(Api.COMPILER_TREE)
2158         public JCTree getType() { return pattern instanceof JCPattern ? pattern.hasTag(BINDINGPATTERN) ? ((JCBindingPattern) pattern).vartype : null : pattern; }
2159 
2160         @Override @DefinedBy(Api.COMPILER_TREE)
2161         public JCPattern getPattern() {
2162             return pattern instanceof JCPattern ? (JCPattern) pattern : null;
2163         }
2164 
2165         @DefinedBy(Api.COMPILER_TREE)
2166         public JCExpression getExpression() { return expr; }
2167         @Override @DefinedBy(Api.COMPILER_TREE)
2168         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2169             return v.visitInstanceOf(this, d);
2170         }
2171         @Override
2172         public Tag getTag() {
2173             return TYPETEST;
2174         }
2175     }
2176 
2177     /**
2178      * Pattern matching forms.
2179      */
2180     public static abstract class JCPattern extends JCTree
2181             implements PatternTree {
2182         public JCExpression constExpression() {
2183             return null;
2184         }
2185     }
2186 
2187     public static class JCBindingPattern extends JCPattern
2188             implements BindingPatternTree {
2189         public Name name;
2190         public BindingSymbol symbol;
2191         public JCTree vartype;
2192 
2193         protected JCBindingPattern(Name name, BindingSymbol symbol, JCTree vartype) {
2194             this.name = name;
2195             this.symbol = symbol;
2196             this.vartype = vartype;
2197         }
2198 
2199         @DefinedBy(Api.COMPILER_TREE)
2200         public Name getBinding() {
2201             return name;
2202         }
2203 
2204         @Override @DefinedBy(Api.COMPILER_TREE)
2205         public Tree getType() {
2206             return vartype;
2207         }
2208 
2209         @Override
2210         public void accept(Visitor v) {
2211             v.visitBindingPattern(this);
2212         }
2213 
2214         @DefinedBy(Api.COMPILER_TREE)
2215         public Kind getKind() {
2216             return Kind.BINDING_PATTERN;
2217         }
2218 
2219         @Override
2220         @DefinedBy(Api.COMPILER_TREE)
2221         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2222             return v.visitBindingPattern(this, d);
2223         }
2224 
2225         @Override
2226         public Tag getTag() {
2227             return BINDINGPATTERN;
2228         }
2229     }
2230 
2231     /**
2232      * An array selection
2233      */
2234     public static class JCArrayAccess extends JCExpression implements ArrayAccessTree {
2235         public JCExpression indexed;
2236         public JCExpression index;
2237         protected JCArrayAccess(JCExpression indexed, JCExpression index) {
2238             this.indexed = indexed;
2239             this.index = index;
2240         }
2241         @Override
2242         public void accept(Visitor v) { v.visitIndexed(this); }
2243 
2244         @DefinedBy(Api.COMPILER_TREE)
2245         public Kind getKind() { return Kind.ARRAY_ACCESS; }
2246         @DefinedBy(Api.COMPILER_TREE)
2247         public JCExpression getExpression() { return indexed; }
2248         @DefinedBy(Api.COMPILER_TREE)
2249         public JCExpression getIndex() { return index; }
2250         @Override @DefinedBy(Api.COMPILER_TREE)
2251         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2252             return v.visitArrayAccess(this, d);
2253         }
2254         @Override
2255         public Tag getTag() {
2256             return INDEXED;
2257         }
2258     }
2259 
2260     /**
2261      * Selects through packages and classes
2262      */
2263     public static class JCFieldAccess extends JCExpression implements MemberSelectTree {
2264         /** selected Tree hierarchy */
2265         public JCExpression selected;
2266         /** name of field to select thru */
2267         public Name name;
2268         /** symbol of the selected class */
2269         public Symbol sym;
2270         protected JCFieldAccess(JCExpression selected, Name name, Symbol sym) {
2271             this.selected = selected;
2272             this.name = name;
2273             this.sym = sym;
2274         }
2275         @Override
2276         public void accept(Visitor v) { v.visitSelect(this); }
2277 
2278         @DefinedBy(Api.COMPILER_TREE)
2279         public Kind getKind() { return Kind.MEMBER_SELECT; }
2280         @DefinedBy(Api.COMPILER_TREE)
2281         public JCExpression getExpression() { return selected; }
2282         @Override @DefinedBy(Api.COMPILER_TREE)
2283         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2284             return v.visitMemberSelect(this, d);
2285         }
2286         @DefinedBy(Api.COMPILER_TREE)
2287         public Name getIdentifier() { return name; }
2288         @Override
2289         public Tag getTag() {
2290             return SELECT;
2291         }
2292     }
2293 
2294     /**
2295      * Selects a member expression.
2296      */
2297     public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {
2298 
2299         public ReferenceMode mode;
2300         public ReferenceKind kind;
2301         public Name name;
2302         public JCExpression expr;
2303         public List&lt;JCExpression&gt; typeargs;
2304         public Symbol sym;
2305         public Type varargsElement;
2306         public PolyKind refPolyKind;
2307         public boolean ownerAccessible;
2308         private OverloadKind overloadKind;
2309         public Type referentType;
2310 
2311         public enum OverloadKind {
2312             OVERLOADED,
2313             UNOVERLOADED,
2314             ERROR
2315         }
2316 
2317         /**
2318          * Javac-dependent classification for member references, based
2319          * on relevant properties w.r.t. code-generation
2320          */
2321         public enum ReferenceKind {
2322             /** super # instMethod */
2323             SUPER(ReferenceMode.INVOKE, false),
2324             /** Type # instMethod */
2325             UNBOUND(ReferenceMode.INVOKE, true),
2326             /** Type # staticMethod */
2327             STATIC(ReferenceMode.INVOKE, false),
2328             /** Expr # instMethod */
2329             BOUND(ReferenceMode.INVOKE, false),
2330             /** Inner # new */
2331             IMPLICIT_INNER(ReferenceMode.NEW, false),
2332             /** Toplevel # new */
2333             TOPLEVEL(ReferenceMode.NEW, false),
2334             /** ArrayType # new */
2335             ARRAY_CTOR(ReferenceMode.NEW, false);
2336 
2337             final ReferenceMode mode;
2338             final boolean unbound;
2339 
2340             private ReferenceKind(ReferenceMode mode, boolean unbound) {
2341                 this.mode = mode;
2342                 this.unbound = unbound;
2343             }
2344 
2345             public boolean isUnbound() {
2346                 return unbound;
2347             }
2348         }
2349 
2350         public JCMemberReference(ReferenceMode mode, Name name, JCExpression expr, List&lt;JCExpression&gt; typeargs) {
2351             this.mode = mode;
2352             this.name = name;
2353             this.expr = expr;
2354             this.typeargs = typeargs;
2355         }
2356         @Override
2357         public void accept(Visitor v) { v.visitReference(this); }
2358 
2359         @DefinedBy(Api.COMPILER_TREE)
2360         public Kind getKind() { return Kind.MEMBER_REFERENCE; }
2361         @Override @DefinedBy(Api.COMPILER_TREE)
2362         public ReferenceMode getMode() { return mode; }
2363         @Override @DefinedBy(Api.COMPILER_TREE)
2364         public JCExpression getQualifierExpression() { return expr; }
2365         @Override @DefinedBy(Api.COMPILER_TREE)
2366         public Name getName() { return name; }
2367         @Override @DefinedBy(Api.COMPILER_TREE)
2368         public List&lt;JCExpression&gt; getTypeArguments() { return typeargs; }
2369 
2370         @Override @DefinedBy(Api.COMPILER_TREE)
2371         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2372             return v.visitMemberReference(this, d);
2373         }
2374         @Override
2375         public Tag getTag() {
2376             return REFERENCE;
2377         }
2378         public boolean hasKind(ReferenceKind kind) {
2379             return this.kind == kind;
2380         }
2381 
2382         /**
2383          * @return the overloadKind
2384          */
2385         public OverloadKind getOverloadKind() {
2386             return overloadKind;
2387         }
2388 
2389         /**
2390          * @param overloadKind the overloadKind to set
2391          */
2392         public void setOverloadKind(OverloadKind overloadKind) {
2393             this.overloadKind = overloadKind;
2394         }
2395     }
2396 
2397     /**
2398      * An identifier
2399      */
2400     public static class JCIdent extends JCExpression implements IdentifierTree {
2401         /** the name */
2402         public Name name;
2403         /** the symbol */
2404         public Symbol sym;
2405         protected JCIdent(Name name, Symbol sym) {
2406             this.name = name;
2407             this.sym = sym;
2408         }
2409         @Override
2410         public void accept(Visitor v) { v.visitIdent(this); }
2411 
2412         @DefinedBy(Api.COMPILER_TREE)
2413         public Kind getKind() { return Kind.IDENTIFIER; }
2414         @DefinedBy(Api.COMPILER_TREE)
2415         public Name getName() { return name; }
2416         @Override @DefinedBy(Api.COMPILER_TREE)
2417         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2418             return v.visitIdentifier(this, d);
2419         }
2420         @Override
2421         public Tag getTag() {
2422             return IDENT;
2423         }
2424     }
2425 
2426     /**
2427      * A constant value given literally.
2428      */
2429     public static class JCLiteral extends JCExpression implements LiteralTree {
2430         public TypeTag typetag;
2431         /** value representation */
2432         public Object value;
2433         protected JCLiteral(TypeTag typetag, Object value) {
2434             this.typetag = typetag;
2435             this.value = value;
2436         }
2437         @Override
2438         public void accept(Visitor v) { v.visitLiteral(this); }
2439 
2440         @DefinedBy(Api.COMPILER_TREE)
2441         public Kind getKind() {
2442             return typetag.getKindLiteral();
2443         }
2444 
2445         @DefinedBy(Api.COMPILER_TREE)
2446         public Object getValue() {
2447             switch (typetag) {
2448                 case BOOLEAN:
2449                     int bi = (Integer) value;
2450                     return (bi != 0);
2451                 case CHAR:
2452                     int ci = (Integer) value;
2453                     char c = (char) ci;
2454                     if (c != ci)
2455                         throw new AssertionError(&quot;bad value for char literal&quot;);
2456                     return c;
2457                 default:
2458                     return value;
2459             }
2460         }
2461         @Override @DefinedBy(Api.COMPILER_TREE)
2462         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2463             return v.visitLiteral(this, d);
2464         }
2465         @Override
2466         public JCLiteral setType(Type type) {
2467             super.setType(type);
2468             return this;
2469         }
2470         @Override
2471         public Tag getTag() {
2472             return LITERAL;
2473         }
2474     }
2475 
2476     /**
2477      * Identifies a basic type.
2478      * @see TypeTag
2479      */
2480     public static class JCPrimitiveTypeTree extends JCExpression implements PrimitiveTypeTree {
2481         /** the basic type id */
2482         public TypeTag typetag;
2483         protected JCPrimitiveTypeTree(TypeTag typetag) {
2484             this.typetag = typetag;
2485         }
2486         @Override
2487         public void accept(Visitor v) { v.visitTypeIdent(this); }
2488 
2489         @DefinedBy(Api.COMPILER_TREE)
2490         public Kind getKind() { return Kind.PRIMITIVE_TYPE; }
2491         @DefinedBy(Api.COMPILER_TREE)
2492         public TypeKind getPrimitiveTypeKind() {
2493             return typetag.getPrimitiveTypeKind();
2494         }
2495 
2496         @Override @DefinedBy(Api.COMPILER_TREE)
2497         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2498             return v.visitPrimitiveType(this, d);
2499         }
2500         @Override
2501         public Tag getTag() {
2502             return TYPEIDENT;
2503         }
2504     }
2505 
2506     /**
2507      * An array type, A[]
2508      */
2509     public static class JCArrayTypeTree extends JCExpression implements ArrayTypeTree {
2510         public JCExpression elemtype;
2511         protected JCArrayTypeTree(JCExpression elemtype) {
2512             this.elemtype = elemtype;
2513         }
2514         @Override
2515         public void accept(Visitor v) { v.visitTypeArray(this); }
2516 
2517         @DefinedBy(Api.COMPILER_TREE)
2518         public Kind getKind() { return Kind.ARRAY_TYPE; }
2519         @DefinedBy(Api.COMPILER_TREE)
2520         public JCTree getType() { return elemtype; }
2521         @Override @DefinedBy(Api.COMPILER_TREE)
2522         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2523             return v.visitArrayType(this, d);
2524         }
2525         @Override
2526         public Tag getTag() {
2527             return TYPEARRAY;
2528         }
2529     }
2530 
2531     /**
2532      * A parameterized type, {@literal T&lt;...&gt;}
2533      */
2534     public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {
2535         public JCExpression clazz;
2536         public List&lt;JCExpression&gt; arguments;
2537         protected JCTypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments) {
2538             this.clazz = clazz;
2539             this.arguments = arguments;
2540         }
2541         @Override
2542         public void accept(Visitor v) { v.visitTypeApply(this); }
2543 
2544         @DefinedBy(Api.COMPILER_TREE)
2545         public Kind getKind() { return Kind.PARAMETERIZED_TYPE; }
2546         @DefinedBy(Api.COMPILER_TREE)
2547         public JCTree getType() { return clazz; }
2548         @DefinedBy(Api.COMPILER_TREE)
2549         public List&lt;JCExpression&gt; getTypeArguments() {
2550             return arguments;
2551         }
2552         @Override @DefinedBy(Api.COMPILER_TREE)
2553         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2554             return v.visitParameterizedType(this, d);
2555         }
2556         @Override
2557         public Tag getTag() {
2558             return TYPEAPPLY;
2559         }
2560     }
2561 
2562     /**
2563      * A union type, T1 | T2 | ... Tn (used in multicatch statements)
2564      */
2565     public static class JCTypeUnion extends JCExpression implements UnionTypeTree {
2566 
2567         public List&lt;JCExpression&gt; alternatives;
2568 
2569         protected JCTypeUnion(List&lt;JCExpression&gt; components) {
2570             this.alternatives = components;
2571         }
2572         @Override
2573         public void accept(Visitor v) { v.visitTypeUnion(this); }
2574 
2575         @DefinedBy(Api.COMPILER_TREE)
2576         public Kind getKind() { return Kind.UNION_TYPE; }
2577 
2578         @DefinedBy(Api.COMPILER_TREE)
2579         public List&lt;JCExpression&gt; getTypeAlternatives() {
2580             return alternatives;
2581         }
2582         @Override @DefinedBy(Api.COMPILER_TREE)
2583         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2584             return v.visitUnionType(this, d);
2585         }
2586         @Override
2587         public Tag getTag() {
2588             return TYPEUNION;
2589         }
2590     }
2591 
2592     /**
2593      * An intersection type, {@code T1 &amp; T2 &amp; ... Tn} (used in cast expressions)
2594      */
2595     public static class JCTypeIntersection extends JCExpression implements IntersectionTypeTree {
2596 
2597         public List&lt;JCExpression&gt; bounds;
2598 
2599         protected JCTypeIntersection(List&lt;JCExpression&gt; bounds) {
2600             this.bounds = bounds;
2601         }
2602         @Override
2603         public void accept(Visitor v) { v.visitTypeIntersection(this); }
2604 
2605         @DefinedBy(Api.COMPILER_TREE)
2606         public Kind getKind() { return Kind.INTERSECTION_TYPE; }
2607 
2608         @DefinedBy(Api.COMPILER_TREE)
2609         public List&lt;JCExpression&gt; getBounds() {
2610             return bounds;
2611         }
2612         @Override @DefinedBy(Api.COMPILER_TREE)
2613         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2614             return v.visitIntersectionType(this, d);
2615         }
2616         @Override
2617         public Tag getTag() {
2618             return TYPEINTERSECTION;
2619         }
2620     }
2621 
2622     /**
2623      * A formal class parameter.
2624      */
2625     public static class JCTypeParameter extends JCTree implements TypeParameterTree {
2626         /** name */
2627         public Name name;
2628         /** bounds */
2629         public List&lt;JCExpression&gt; bounds;
2630         /** type annotations on type parameter */
2631         public List&lt;JCAnnotation&gt; annotations;
2632         protected JCTypeParameter(Name name, List&lt;JCExpression&gt; bounds, List&lt;JCAnnotation&gt; annotations) {
2633             this.name = name;
2634             this.bounds = bounds;
2635             this.annotations = annotations;
2636         }
2637         @Override
2638         public void accept(Visitor v) { v.visitTypeParameter(this); }
2639 
2640         @DefinedBy(Api.COMPILER_TREE)
2641         public Kind getKind() { return Kind.TYPE_PARAMETER; }
2642         @DefinedBy(Api.COMPILER_TREE)
2643         public Name getName() { return name; }
2644         @DefinedBy(Api.COMPILER_TREE)
2645         public List&lt;JCExpression&gt; getBounds() {
2646             return bounds;
2647         }
2648         @DefinedBy(Api.COMPILER_TREE)
2649         public List&lt;JCAnnotation&gt; getAnnotations() {
2650             return annotations;
2651         }
2652         @Override @DefinedBy(Api.COMPILER_TREE)
2653         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2654             return v.visitTypeParameter(this, d);
2655         }
2656         @Override
2657         public Tag getTag() {
2658             return TYPEPARAMETER;
2659         }
2660     }
2661 
2662     public static class JCWildcard extends JCExpression implements WildcardTree {
2663         public TypeBoundKind kind;
2664         public JCTree inner;
2665         protected JCWildcard(TypeBoundKind kind, JCTree inner) {
2666             this.kind = Assert.checkNonNull(kind);
2667             this.inner = inner;
2668         }
2669         @Override
2670         public void accept(Visitor v) { v.visitWildcard(this); }
2671 
2672         @DefinedBy(Api.COMPILER_TREE)
2673         public Kind getKind() {
2674             switch (kind.kind) {
2675             case UNBOUND:
2676                 return Kind.UNBOUNDED_WILDCARD;
2677             case EXTENDS:
2678                 return Kind.EXTENDS_WILDCARD;
2679             case SUPER:
2680                 return Kind.SUPER_WILDCARD;
2681             default:
2682                 throw new AssertionError(&quot;Unknown wildcard bound &quot; + kind);
2683             }
2684         }
2685         @DefinedBy(Api.COMPILER_TREE)
2686         public JCTree getBound() { return inner; }
2687         @Override @DefinedBy(Api.COMPILER_TREE)
2688         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2689             return v.visitWildcard(this, d);
2690         }
2691         @Override
2692         public Tag getTag() {
2693             return Tag.WILDCARD;
2694         }
2695     }
2696 
2697     public static class TypeBoundKind extends JCTree {
2698         public BoundKind kind;
2699         protected TypeBoundKind(BoundKind kind) {
2700             this.kind = kind;
2701         }
2702         @Override
2703         public void accept(Visitor v) { v.visitTypeBoundKind(this); }
2704 
2705         @DefinedBy(Api.COMPILER_TREE)
2706         public Kind getKind() {
2707             throw new AssertionError(&quot;TypeBoundKind is not part of a public API&quot;);
2708         }
2709         @Override @DefinedBy(Api.COMPILER_TREE)
2710         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2711             throw new AssertionError(&quot;TypeBoundKind is not part of a public API&quot;);
2712         }
2713         @Override
2714         public Tag getTag() {
2715             return TYPEBOUNDKIND;
2716         }
2717     }
2718 
2719     public static class JCAnnotation extends JCExpression implements AnnotationTree {
2720         // Either Tag.ANNOTATION or Tag.TYPE_ANNOTATION
2721         private Tag tag;
2722 
2723         public JCTree annotationType;
2724         public List&lt;JCExpression&gt; args;
2725         public Attribute.Compound attribute;
2726 
2727         protected JCAnnotation(Tag tag, JCTree annotationType, List&lt;JCExpression&gt; args) {
2728             this.tag = tag;
2729             this.annotationType = annotationType;
2730             this.args = args;
2731         }
2732 
2733         @Override
2734         public void accept(Visitor v) { v.visitAnnotation(this); }
2735 
2736         @DefinedBy(Api.COMPILER_TREE)
2737         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2738 
2739         @DefinedBy(Api.COMPILER_TREE)
2740         public JCTree getAnnotationType() { return annotationType; }
2741         @DefinedBy(Api.COMPILER_TREE)
2742         public List&lt;JCExpression&gt; getArguments() {
2743             return args;
2744         }
2745         @Override @DefinedBy(Api.COMPILER_TREE)
2746         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2747             return v.visitAnnotation(this, d);
2748         }
2749         @Override
2750         public Tag getTag() {
2751             return tag;
2752         }
2753     }
2754 
2755     public static class JCModifiers extends JCTree implements com.sun.source.tree.ModifiersTree {
2756         public long flags;
2757         public List&lt;JCAnnotation&gt; annotations;
2758         protected JCModifiers(long flags, List&lt;JCAnnotation&gt; annotations) {
2759             this.flags = flags;
2760             this.annotations = annotations;
2761         }
2762         @Override
2763         public void accept(Visitor v) { v.visitModifiers(this); }
2764 
2765         @DefinedBy(Api.COMPILER_TREE)
2766         public Kind getKind() { return Kind.MODIFIERS; }
2767         @DefinedBy(Api.COMPILER_TREE)
2768         public Set&lt;Modifier&gt; getFlags() {
2769             return Flags.asModifierSet(flags);
2770         }
2771         @DefinedBy(Api.COMPILER_TREE)
2772         public List&lt;JCAnnotation&gt; getAnnotations() {
2773             return annotations;
2774         }
2775         @Override @DefinedBy(Api.COMPILER_TREE)
2776         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2777             return v.visitModifiers(this, d);
2778         }
2779         @Override
2780         public Tag getTag() {
2781             return MODIFIERS;
2782         }
2783     }
2784 
2785     public static class JCAnnotatedType extends JCExpression implements com.sun.source.tree.AnnotatedTypeTree {
2786         // type annotations
2787         public List&lt;JCAnnotation&gt; annotations;
2788         public JCExpression underlyingType;
2789 
2790         protected JCAnnotatedType(List&lt;JCAnnotation&gt; annotations, JCExpression underlyingType) {
2791             Assert.check(annotations != null &amp;&amp; annotations.nonEmpty());
2792             this.annotations = annotations;
2793             this.underlyingType = underlyingType;
2794         }
2795         @Override
2796         public void accept(Visitor v) { v.visitAnnotatedType(this); }
2797 
2798         @DefinedBy(Api.COMPILER_TREE)
2799         public Kind getKind() { return Kind.ANNOTATED_TYPE; }
2800         @DefinedBy(Api.COMPILER_TREE)
2801         public List&lt;JCAnnotation&gt; getAnnotations() {
2802             return annotations;
2803         }
2804         @DefinedBy(Api.COMPILER_TREE)
2805         public JCExpression getUnderlyingType() {
2806             return underlyingType;
2807         }
2808         @Override @DefinedBy(Api.COMPILER_TREE)
2809         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2810             return v.visitAnnotatedType(this, d);
2811         }
2812         @Override
2813         public Tag getTag() {
2814             return ANNOTATED_TYPE;
2815         }
2816     }
2817 
2818     public static abstract class JCDirective extends JCTree
2819         implements DirectiveTree {
2820     }
2821 
2822     public static class JCModuleDecl extends JCTree implements ModuleTree {
2823         public JCModifiers mods;
2824         public ModuleType type;
2825         private final ModuleKind kind;
2826         public JCExpression qualId;
2827         public List&lt;JCDirective&gt; directives;
2828         public ModuleSymbol sym;
2829 
2830         protected JCModuleDecl(JCModifiers mods, ModuleKind kind,
2831                 JCExpression qualId, List&lt;JCDirective&gt; directives) {
2832             this.mods = mods;
2833             this.kind = kind;
2834             this.qualId = qualId;
2835             this.directives = directives;
2836         }
2837 
2838         @Override
2839         public void accept(Visitor v) { v.visitModuleDef(this); }
2840 
2841         @Override @DefinedBy(Api.COMPILER_TREE)
2842         public Kind getKind() {
2843             return Kind.MODULE;
2844         }
2845 
2846         @Override @DefinedBy(Api.COMPILER_TREE)
2847         public List&lt;? extends AnnotationTree&gt; getAnnotations() {
2848             return mods.annotations;
2849         }
2850 
2851         @Override @DefinedBy(Api.COMPILER_TREE)
2852         public ModuleKind getModuleType() {
2853             return kind;
2854         }
2855 
2856         @Override @DefinedBy(Api.COMPILER_TREE)
2857         public JCExpression getName() {
2858             return qualId;
2859         }
2860 
2861         @Override @DefinedBy(Api.COMPILER_TREE)
2862         public List&lt;JCDirective&gt; getDirectives() {
2863             return directives;
2864         }
2865 
2866         @Override @DefinedBy(Api.COMPILER_TREE)
2867         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2868             return v.visitModule(this, d);
2869         }
2870 
2871         @Override
2872         public Tag getTag() {
2873             return MODULEDEF;
2874         }
2875     }
2876 
2877     public static class JCExports extends JCDirective
2878             implements ExportsTree {
2879         public JCExpression qualid;
2880         public List&lt;JCExpression&gt; moduleNames;
2881         public ExportsDirective directive;
2882 
2883         protected JCExports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
2884             this.qualid = qualId;
2885             this.moduleNames = moduleNames;
2886         }
2887 
2888         @Override
2889         public void accept(Visitor v) { v.visitExports(this); }
2890 
2891         @Override @DefinedBy(Api.COMPILER_TREE)
2892         public Kind getKind() {
2893             return Kind.EXPORTS;
2894         }
2895 
2896         @Override @DefinedBy(Api.COMPILER_TREE)
2897         public JCExpression getPackageName() {
2898             return qualid;
2899         }
2900 
2901         @Override @DefinedBy(Api.COMPILER_TREE)
2902         public List&lt;JCExpression&gt; getModuleNames() {
2903             return moduleNames;
2904         }
2905 
2906         @Override @DefinedBy(Api.COMPILER_TREE)
2907         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2908             return v.visitExports(this, d);
2909         }
2910 
2911         @Override
2912         public Tag getTag() {
2913             return Tag.EXPORTS;
2914         }
2915     }
2916 
2917     public static class JCOpens extends JCDirective
2918             implements OpensTree {
2919         public JCExpression qualid;
2920         public List&lt;JCExpression&gt; moduleNames;
2921         public OpensDirective directive;
2922 
2923         protected JCOpens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
2924             this.qualid = qualId;
2925             this.moduleNames = moduleNames;
2926         }
2927 
2928         @Override
2929         public void accept(Visitor v) { v.visitOpens(this); }
2930 
2931         @Override @DefinedBy(Api.COMPILER_TREE)
2932         public Kind getKind() {
2933             return Kind.OPENS;
2934         }
2935 
2936         @Override @DefinedBy(Api.COMPILER_TREE)
2937         public JCExpression getPackageName() {
2938             return qualid;
2939         }
2940 
2941         @Override @DefinedBy(Api.COMPILER_TREE)
2942         public List&lt;JCExpression&gt; getModuleNames() {
2943             return moduleNames;
2944         }
2945 
2946         @Override @DefinedBy(Api.COMPILER_TREE)
2947         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2948             return v.visitOpens(this, d);
2949         }
2950 
2951         @Override
2952         public Tag getTag() {
2953             return Tag.OPENS;
2954         }
2955     }
2956 
2957     public static class JCProvides extends JCDirective
2958             implements ProvidesTree {
2959         public JCExpression serviceName;
2960         public List&lt;JCExpression&gt; implNames;
2961 
2962         protected JCProvides(JCExpression serviceName, List&lt;JCExpression&gt; implNames) {
2963             this.serviceName = serviceName;
2964             this.implNames = implNames;
2965         }
2966 
2967         @Override
2968         public void accept(Visitor v) { v.visitProvides(this); }
2969 
2970         @Override @DefinedBy(Api.COMPILER_TREE)
2971         public Kind getKind() {
2972             return Kind.PROVIDES;
2973         }
2974 
2975         @Override @DefinedBy(Api.COMPILER_TREE)
2976         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2977             return v.visitProvides(this, d);
2978         }
2979 
2980         @Override @DefinedBy(Api.COMPILER_TREE)
2981         public JCExpression getServiceName() {
2982             return serviceName;
2983         }
2984 
2985         @Override @DefinedBy(Api.COMPILER_TREE)
2986         public List&lt;JCExpression&gt; getImplementationNames() {
2987             return implNames;
2988         }
2989 
2990         @Override
2991         public Tag getTag() {
2992             return PROVIDES;
2993         }
2994     }
2995 
2996     public static class JCRequires extends JCDirective
2997             implements RequiresTree {
2998         public boolean isTransitive;
2999         public boolean isStaticPhase;
3000         public JCExpression moduleName;
3001         public RequiresDirective directive;
3002 
3003         protected JCRequires(boolean isTransitive, boolean isStaticPhase, JCExpression moduleName) {
3004             this.isTransitive = isTransitive;
3005             this.isStaticPhase = isStaticPhase;
3006             this.moduleName = moduleName;
3007         }
3008 
3009         @Override
3010         public void accept(Visitor v) { v.visitRequires(this); }
3011 
3012         @Override @DefinedBy(Api.COMPILER_TREE)
3013         public Kind getKind() {
3014             return Kind.REQUIRES;
3015         }
3016 
3017         @Override @DefinedBy(Api.COMPILER_TREE)
3018         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3019             return v.visitRequires(this, d);
3020         }
3021 
3022         @Override @DefinedBy(Api.COMPILER_TREE)
3023         public boolean isTransitive() {
3024             return isTransitive;
3025         }
3026 
3027         @Override @DefinedBy(Api.COMPILER_TREE)
3028         public boolean isStatic() {
3029             return isStaticPhase;
3030         }
3031 
3032         @Override @DefinedBy(Api.COMPILER_TREE)
3033         public JCExpression getModuleName() {
3034             return moduleName;
3035         }
3036 
3037         @Override
3038         public Tag getTag() {
3039             return REQUIRES;
3040         }
3041     }
3042 
3043     public static class JCUses extends JCDirective
3044             implements UsesTree {
3045         public JCExpression qualid;
3046 
3047         protected JCUses(JCExpression qualId) {
3048             this.qualid = qualId;
3049         }
3050 
3051         @Override
3052         public void accept(Visitor v) { v.visitUses(this); }
3053 
3054         @Override @DefinedBy(Api.COMPILER_TREE)
3055         public Kind getKind() {
3056             return Kind.USES;
3057         }
3058 
3059         @Override @DefinedBy(Api.COMPILER_TREE)
3060         public JCExpression getServiceName() {
3061             return qualid;
3062         }
3063 
3064         @Override @DefinedBy(Api.COMPILER_TREE)
3065         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3066             return v.visitUses(this, d);
3067         }
3068 
3069         @Override
3070         public Tag getTag() {
3071             return USES;
3072         }
3073     }
3074 
3075     public static class JCErroneous extends JCExpression
3076             implements ErroneousTree {
3077         public List&lt;? extends JCTree&gt; errs;
3078         protected JCErroneous(List&lt;? extends JCTree&gt; errs) {
3079             this.errs = errs;
3080         }
3081         @Override
3082         public void accept(Visitor v) { v.visitErroneous(this); }
3083 
3084         @DefinedBy(Api.COMPILER_TREE)
3085         public Kind getKind() { return Kind.ERRONEOUS; }
3086 
3087         @DefinedBy(Api.COMPILER_TREE)
3088         public List&lt;? extends JCTree&gt; getErrorTrees() {
3089             return errs;
3090         }
3091 
3092         @Override @DefinedBy(Api.COMPILER_TREE)
3093         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3094             return v.visitErroneous(this, d);
3095         }
3096         @Override
3097         public Tag getTag() {
3098             return ERRONEOUS;
3099         }
3100     }
3101 
3102     /** (let int x = 3; in x+2) */
3103     public static class LetExpr extends JCExpression {
3104         public List&lt;JCStatement&gt; defs;
3105         public JCExpression expr;
3106         /**true if a expr should be run through Gen.genCond:*/
3107         public boolean needsCond;
3108         protected LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr) {
3109             this.defs = defs;
3110             this.expr = expr;
3111         }
3112         @Override
3113         public void accept(Visitor v) { v.visitLetExpr(this); }
3114 
3115         @DefinedBy(Api.COMPILER_TREE)
3116         public Kind getKind() {
3117             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3118         }
3119         @Override @DefinedBy(Api.COMPILER_TREE)
3120         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3121             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3122         }
3123         @Override
3124         public Tag getTag() {
3125             return LETEXPR;
3126         }
3127     }
3128 
3129     /** An interface for tree factories
3130      */
3131     public interface Factory {
3132         JCCompilationUnit TopLevel(List&lt;JCTree&gt; defs);
3133         JCPackageDecl PackageDecl(List&lt;JCAnnotation&gt; annotations,
3134                                   JCExpression pid);
3135         JCImport Import(JCTree qualid, boolean staticImport);
3136         JCClassDecl ClassDef(JCModifiers mods,
3137                           Name name,
3138                           List&lt;JCTypeParameter&gt; typarams,
3139                           JCExpression extending,
3140                           List&lt;JCExpression&gt; implementing,
3141                           List&lt;JCTree&gt; defs);
3142         JCMethodDecl MethodDef(JCModifiers mods,
3143                             Name name,
3144                             JCExpression restype,
3145                             List&lt;JCTypeParameter&gt; typarams,
3146                             JCVariableDecl recvparam,
3147                             List&lt;JCVariableDecl&gt; params,
3148                             List&lt;JCExpression&gt; thrown,
3149                             JCBlock body,
3150                             JCExpression defaultValue);
3151         JCVariableDecl VarDef(JCModifiers mods,
3152                       Name name,
3153                       JCExpression vartype,
3154                       JCExpression init);
3155         JCSkip Skip();
3156         JCBlock Block(long flags, List&lt;JCStatement&gt; stats);
3157         JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond);
3158         JCWhileLoop WhileLoop(JCExpression cond, JCStatement body);
3159         JCForLoop ForLoop(List&lt;JCStatement&gt; init,
3160                         JCExpression cond,
3161                         List&lt;JCExpressionStatement&gt; step,
3162                         JCStatement body);
3163         JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body);
3164         JCLabeledStatement Labelled(Name label, JCStatement body);
3165         JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases);
3166         JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases);
3167         JCCase Case(CaseTree.CaseKind caseKind, List&lt;JCExpression&gt; pat,
3168                     List&lt;JCStatement&gt; stats, JCTree body);
3169         JCSynchronized Synchronized(JCExpression lock, JCBlock body);
3170         JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer);
3171         JCTry Try(List&lt;JCTree&gt; resources,
3172                   JCBlock body,
3173                   List&lt;JCCatch&gt; catchers,
3174                   JCBlock finalizer);
3175         JCCatch Catch(JCVariableDecl param, JCBlock body);
3176         JCConditional Conditional(JCExpression cond,
3177                                 JCExpression thenpart,
3178                                 JCExpression elsepart);
3179         JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart);
3180         JCExpressionStatement Exec(JCExpression expr);
3181         JCBreak Break(Name label);
3182         JCYield Yield(JCExpression value);
3183         JCContinue Continue(Name label);
3184         JCReturn Return(JCExpression expr);
3185         JCThrow Throw(JCExpression expr);
3186         JCAssert Assert(JCExpression cond, JCExpression detail);
3187         JCMethodInvocation Apply(List&lt;JCExpression&gt; typeargs,
3188                     JCExpression fn,
3189                     List&lt;JCExpression&gt; args);
3190         JCNewClass NewClass(JCExpression encl,
3191                           List&lt;JCExpression&gt; typeargs,
3192                           JCExpression clazz,
3193                           List&lt;JCExpression&gt; args,
3194                           JCClassDecl def);
3195         JCNewArray NewArray(JCExpression elemtype,
3196                           List&lt;JCExpression&gt; dims,
3197                           List&lt;JCExpression&gt; elems);
3198         JCParens Parens(JCExpression expr);
3199         JCAssign Assign(JCExpression lhs, JCExpression rhs);
3200         JCAssignOp Assignop(Tag opcode, JCTree lhs, JCTree rhs);
3201         JCUnary Unary(Tag opcode, JCExpression arg);
3202         JCBinary Binary(Tag opcode, JCExpression lhs, JCExpression rhs);
3203         JCTypeCast TypeCast(JCTree expr, JCExpression type);
3204         JCInstanceOf TypeTest(JCExpression expr, JCTree clazz);
3205         JCBindingPattern BindingPattern(Name name, JCTree vartype);
3206         JCArrayAccess Indexed(JCExpression indexed, JCExpression index);
3207         JCFieldAccess Select(JCExpression selected, Name selector);
3208         JCIdent Ident(Name idname);
3209         JCLiteral Literal(TypeTag tag, Object value);
3210         JCPrimitiveTypeTree TypeIdent(TypeTag typetag);
3211         JCArrayTypeTree TypeArray(JCExpression elemtype);
3212         JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments);
3213         JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds);
3214         JCWildcard Wildcard(TypeBoundKind kind, JCTree type);
3215         TypeBoundKind TypeBoundKind(BoundKind kind);
3216         JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args);
3217         JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations);
3218         JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs);
3219         JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind, JCExpression qualId, List&lt;JCDirective&gt; directives);
3220         JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3221         JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3222         JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames);
3223         JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId);
3224         JCUses Uses(JCExpression qualId);
3225         LetExpr LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr);
3226     }
3227 
3228     /** A generic visitor class for trees.
3229      */
3230     public static abstract class Visitor {
3231         public void visitTopLevel(JCCompilationUnit that)    { visitTree(that); }
3232         public void visitPackageDef(JCPackageDecl that)      { visitTree(that); }
3233         public void visitImport(JCImport that)               { visitTree(that); }
3234         public void visitClassDef(JCClassDecl that)          { visitTree(that); }
3235         public void visitMethodDef(JCMethodDecl that)        { visitTree(that); }
3236         public void visitVarDef(JCVariableDecl that)         { visitTree(that); }
3237         public void visitSkip(JCSkip that)                   { visitTree(that); }
3238         public void visitBlock(JCBlock that)                 { visitTree(that); }
3239         public void visitDoLoop(JCDoWhileLoop that)          { visitTree(that); }
3240         public void visitWhileLoop(JCWhileLoop that)         { visitTree(that); }
3241         public void visitForLoop(JCForLoop that)             { visitTree(that); }
3242         public void visitForeachLoop(JCEnhancedForLoop that) { visitTree(that); }
3243         public void visitLabelled(JCLabeledStatement that)   { visitTree(that); }
3244         public void visitSwitch(JCSwitch that)               { visitTree(that); }
3245         public void visitCase(JCCase that)                   { visitTree(that); }
3246         public void visitSwitchExpression(JCSwitchExpression that)               { visitTree(that); }
3247         public void visitSynchronized(JCSynchronized that)   { visitTree(that); }
3248         public void visitTry(JCTry that)                     { visitTree(that); }
3249         public void visitCatch(JCCatch that)                 { visitTree(that); }
3250         public void visitConditional(JCConditional that)     { visitTree(that); }
3251         public void visitIf(JCIf that)                       { visitTree(that); }
3252         public void visitExec(JCExpressionStatement that)    { visitTree(that); }
3253         public void visitBreak(JCBreak that)                 { visitTree(that); }
3254         public void visitYield(JCYield that)                 { visitTree(that); }
3255         public void visitContinue(JCContinue that)           { visitTree(that); }
3256         public void visitReturn(JCReturn that)               { visitTree(that); }
3257         public void visitThrow(JCThrow that)                 { visitTree(that); }
3258         public void visitAssert(JCAssert that)               { visitTree(that); }
3259         public void visitApply(JCMethodInvocation that)      { visitTree(that); }
3260         public void visitNewClass(JCNewClass that)           { visitTree(that); }
3261         public void visitNewArray(JCNewArray that)           { visitTree(that); }
3262         public void visitLambda(JCLambda that)               { visitTree(that); }
3263         public void visitParens(JCParens that)               { visitTree(that); }
3264         public void visitAssign(JCAssign that)               { visitTree(that); }
3265         public void visitAssignop(JCAssignOp that)           { visitTree(that); }
3266         public void visitUnary(JCUnary that)                 { visitTree(that); }
3267         public void visitBinary(JCBinary that)               { visitTree(that); }
3268         public void visitTypeCast(JCTypeCast that)           { visitTree(that); }
3269         public void visitTypeTest(JCInstanceOf that)         { visitTree(that); }
3270         public void visitBindingPattern(JCBindingPattern that) { visitTree(that); }
3271         public void visitIndexed(JCArrayAccess that)         { visitTree(that); }
3272         public void visitSelect(JCFieldAccess that)          { visitTree(that); }
3273         public void visitReference(JCMemberReference that)   { visitTree(that); }
3274         public void visitIdent(JCIdent that)                 { visitTree(that); }
3275         public void visitLiteral(JCLiteral that)             { visitTree(that); }
3276         public void visitTypeIdent(JCPrimitiveTypeTree that) { visitTree(that); }
3277         public void visitTypeArray(JCArrayTypeTree that)     { visitTree(that); }
3278         public void visitTypeApply(JCTypeApply that)         { visitTree(that); }
3279         public void visitTypeUnion(JCTypeUnion that)         { visitTree(that); }
3280         public void visitTypeIntersection(JCTypeIntersection that)  { visitTree(that); }
3281         public void visitTypeParameter(JCTypeParameter that) { visitTree(that); }
3282         public void visitWildcard(JCWildcard that)           { visitTree(that); }
3283         public void visitTypeBoundKind(TypeBoundKind that)   { visitTree(that); }
3284         public void visitAnnotation(JCAnnotation that)       { visitTree(that); }
3285         public void visitModifiers(JCModifiers that)         { visitTree(that); }
3286         public void visitAnnotatedType(JCAnnotatedType that) { visitTree(that); }
3287         public void visitErroneous(JCErroneous that)         { visitTree(that); }
3288         public void visitModuleDef(JCModuleDecl that)        { visitTree(that); }
3289         public void visitExports(JCExports that)             { visitTree(that); }
3290         public void visitOpens(JCOpens that)                 { visitTree(that); }
3291         public void visitProvides(JCProvides that)           { visitTree(that); }
3292         public void visitRequires(JCRequires that)           { visitTree(that); }
3293         public void visitUses(JCUses that)                   { visitTree(that); }
3294         public void visitLetExpr(LetExpr that)               { visitTree(that); }
3295 
3296         public void visitTree(JCTree that)                   { Assert.error(); }
3297     }
3298 
3299 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
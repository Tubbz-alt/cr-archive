<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 
  27 package com.sun.tools.javac.comp;
  28 
  29 import java.io.IOException;
  30 import java.util.Arrays;
  31 import java.util.Collection;
  32 import java.util.Collections;
  33 import java.util.EnumSet;
  34 import java.util.HashMap;
  35 import java.util.HashSet;
  36 import java.util.LinkedHashMap;
  37 import java.util.LinkedHashSet;
  38 import java.util.Map;
  39 import java.util.Set;
  40 import java.util.function.Consumer;
  41 import java.util.function.Predicate;
  42 import java.util.regex.Matcher;
  43 import java.util.regex.Pattern;
  44 import java.util.stream.Collectors;
  45 import java.util.stream.Stream;
  46 
  47 import javax.lang.model.SourceVersion;
  48 import javax.tools.JavaFileManager;
  49 import javax.tools.JavaFileManager.Location;
  50 import javax.tools.JavaFileObject;
  51 import javax.tools.JavaFileObject.Kind;
  52 import javax.tools.StandardLocation;
  53 
  54 import com.sun.source.tree.ModuleTree.ModuleKind;
  55 import com.sun.tools.javac.code.ClassFinder;
  56 import com.sun.tools.javac.code.DeferredLintHandler;
  57 import com.sun.tools.javac.code.Directive;
  58 import com.sun.tools.javac.code.Directive.ExportsDirective;
  59 import com.sun.tools.javac.code.Directive.ExportsFlag;
  60 import com.sun.tools.javac.code.Directive.OpensDirective;
  61 import com.sun.tools.javac.code.Directive.OpensFlag;
  62 import com.sun.tools.javac.code.Directive.RequiresDirective;
  63 import com.sun.tools.javac.code.Directive.RequiresFlag;
  64 import com.sun.tools.javac.code.Directive.UsesDirective;
  65 import com.sun.tools.javac.code.Flags;
  66 import com.sun.tools.javac.code.Flags.Flag;
  67 import com.sun.tools.javac.code.Lint.LintCategory;
  68 import com.sun.tools.javac.code.ModuleFinder;
  69 import com.sun.tools.javac.code.Source;
  70 import com.sun.tools.javac.code.Source.Feature;
  71 import com.sun.tools.javac.code.Symbol;
  72 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  73 import com.sun.tools.javac.code.Symbol.Completer;
  74 import com.sun.tools.javac.code.Symbol.CompletionFailure;
  75 import com.sun.tools.javac.code.Symbol.MethodSymbol;
  76 import com.sun.tools.javac.code.Symbol.ModuleFlags;
  77 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  78 import com.sun.tools.javac.code.Symbol.PackageSymbol;
  79 import com.sun.tools.javac.code.Symtab;
  80 import com.sun.tools.javac.code.Type;
  81 import com.sun.tools.javac.code.Types;
  82 import com.sun.tools.javac.jvm.ClassWriter;
  83 import com.sun.tools.javac.jvm.JNIWriter;
  84 import com.sun.tools.javac.jvm.Target;
  85 import com.sun.tools.javac.main.Option;
  86 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  87 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  88 import com.sun.tools.javac.tree.JCTree;
  89 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
  90 import com.sun.tools.javac.tree.JCTree.JCDirective;
  91 import com.sun.tools.javac.tree.JCTree.JCExports;
  92 import com.sun.tools.javac.tree.JCTree.JCExpression;
  93 import com.sun.tools.javac.tree.JCTree.JCModuleDecl;
  94 import com.sun.tools.javac.tree.JCTree.JCOpens;
  95 import com.sun.tools.javac.tree.JCTree.JCProvides;
  96 import com.sun.tools.javac.tree.JCTree.JCRequires;
  97 import com.sun.tools.javac.tree.JCTree.JCUses;
  98 import com.sun.tools.javac.tree.JCTree.Tag;
  99 import com.sun.tools.javac.tree.TreeInfo;
 100 import com.sun.tools.javac.util.Assert;
 101 import com.sun.tools.javac.util.Context;
 102 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 103 import com.sun.tools.javac.util.List;
 104 import com.sun.tools.javac.util.ListBuffer;
 105 import com.sun.tools.javac.util.Log;
 106 import com.sun.tools.javac.util.Name;
 107 import com.sun.tools.javac.util.Names;
 108 import com.sun.tools.javac.util.Options;
 109 
 110 import static com.sun.tools.javac.code.Flags.ABSTRACT;
 111 import static com.sun.tools.javac.code.Flags.ENUM;
 112 import static com.sun.tools.javac.code.Flags.PUBLIC;
 113 import static com.sun.tools.javac.code.Flags.UNATTRIBUTED;
 114 
 115 import com.sun.tools.javac.code.Kinds;
 116 
 117 import static com.sun.tools.javac.code.Kinds.Kind.ERR;
 118 import static com.sun.tools.javac.code.Kinds.Kind.MDL;
 119 import static com.sun.tools.javac.code.Kinds.Kind.MTH;
 120 
 121 import com.sun.tools.javac.code.Symbol.ModuleResolutionFlags;
 122 
 123 import static com.sun.tools.javac.code.TypeTag.CLASS;
 124 
 125 /**
 126  *  TODO: fill in
 127  *
 128  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 129  *  If you write code that depends on this, you do so at your own risk.
 130  *  This code and its internal interfaces are subject to change or
 131  *  deletion without notice.&lt;/b&gt;
 132  */
 133 public class Modules extends JCTree.Visitor {
 134     private static final String ALL_SYSTEM = &quot;ALL-SYSTEM&quot;;
 135     private static final String ALL_MODULE_PATH = &quot;ALL-MODULE-PATH&quot;;
 136 
 137     private final Log log;
 138     private final Names names;
 139     private final Symtab syms;
 140     private final Attr attr;
 141     private final Check chk;
 142     private final DeferredLintHandler deferredLintHandler;
 143     private final TypeEnvs typeEnvs;
 144     private final Types types;
 145     private final JavaFileManager fileManager;
 146     private final ModuleFinder moduleFinder;
 147     private final Source source;
 148     private final Target target;
 149     private final boolean allowModules;
 150     private final boolean allowAccessIntoSystem;
 151 
 152     public final boolean multiModuleMode;
 153 
 154     private final Name java_se;
 155     private final Name java_;
 156 
 157     ModuleSymbol defaultModule;
 158 
 159     private final String addExportsOpt;
 160     private Map&lt;ModuleSymbol, Set&lt;ExportsDirective&gt;&gt; addExports;
 161     private final String addReadsOpt;
 162     private Map&lt;ModuleSymbol, Set&lt;RequiresDirective&gt;&gt; addReads;
 163     private final String addModsOpt;
 164     private final Set&lt;String&gt; extraAddMods = new HashSet&lt;&gt;();
 165     private final String limitModsOpt;
 166     private final Set&lt;String&gt; extraLimitMods = new HashSet&lt;&gt;();
 167     private final String moduleVersionOpt;
 168 
 169     private final boolean lintOptions;
 170 
 171     private Set&lt;ModuleSymbol&gt; rootModules = null;
 172     private final Set&lt;ModuleSymbol&gt; warnedMissing = new HashSet&lt;&gt;();
 173 
 174     public PackageNameFinder findPackageInFile;
 175 
 176     public static Modules instance(Context context) {
 177         Modules instance = context.get(Modules.class);
 178         if (instance == null)
 179             instance = new Modules(context);
 180         return instance;
 181     }
 182 
 183     protected Modules(Context context) {
 184         context.put(Modules.class, this);
 185         log = Log.instance(context);
 186         names = Names.instance(context);
 187         syms = Symtab.instance(context);
 188         attr = Attr.instance(context);
 189         chk = Check.instance(context);
 190         deferredLintHandler = DeferredLintHandler.instance(context);
 191         typeEnvs = TypeEnvs.instance(context);
 192         moduleFinder = ModuleFinder.instance(context);
 193         types = Types.instance(context);
 194         fileManager = context.get(JavaFileManager.class);
 195         source = Source.instance(context);
 196         target = Target.instance(context);
 197         allowModules = Feature.MODULES.allowedInSource(source);
 198         Options options = Options.instance(context);
 199 
 200         allowAccessIntoSystem = options.isUnset(Option.RELEASE);
 201         lintOptions = options.isUnset(Option.XLINT_CUSTOM, &quot;-&quot; + LintCategory.OPTIONS.option);
 202 
 203         multiModuleMode = fileManager.hasLocation(StandardLocation.MODULE_SOURCE_PATH);
 204         ClassWriter classWriter = ClassWriter.instance(context);
 205         classWriter.multiModuleMode = multiModuleMode;
 206         JNIWriter jniWriter = JNIWriter.instance(context);
 207         jniWriter.multiModuleMode = multiModuleMode;
 208 
 209         java_se = names.fromString(&quot;java.se&quot;);
 210         java_ = names.fromString(&quot;java.&quot;);
 211 
 212         addExportsOpt = options.get(Option.ADD_EXPORTS);
 213         addReadsOpt = options.get(Option.ADD_READS);
 214         addModsOpt = options.get(Option.ADD_MODULES);
 215         limitModsOpt = options.get(Option.LIMIT_MODULES);
 216         moduleVersionOpt = options.get(Option.MODULE_VERSION);
 217     }
 218 
 219     int depth = -1;
 220 
 221     public void addExtraAddModules(String... extras) {
 222         extraAddMods.addAll(Arrays.asList(extras));
 223     }
 224 
 225     boolean inInitModules;
 226     public void initModules(List&lt;JCCompilationUnit&gt; trees) {
 227         Assert.check(!inInitModules);
 228         try {
 229             inInitModules = true;
 230             Assert.checkNull(rootModules);
 231             enter(trees, modules -&gt; {
 232                 Assert.checkNull(rootModules);
 233                 Assert.checkNull(allModules);
 234                 this.rootModules = modules;
 235                 setupAllModules(); //initialize the module graph
 236                 Assert.checkNonNull(allModules);
 237                 inInitModules = false;
 238             }, null);
 239         } finally {
 240             inInitModules = false;
 241         }
 242     }
 243 
 244     public boolean enter(List&lt;JCCompilationUnit&gt; trees, ClassSymbol c) {
 245         Assert.check(rootModules != null || inInitModules || !allowModules);
 246         return enter(trees, modules -&gt; {}, c);
 247     }
 248 
 249     private boolean enter(List&lt;JCCompilationUnit&gt; trees, Consumer&lt;Set&lt;ModuleSymbol&gt;&gt; init, ClassSymbol c) {
 250         if (!allowModules) {
 251             for (JCCompilationUnit tree: trees) {
 252                 tree.modle = syms.noModule;
 253             }
 254             defaultModule = syms.noModule;
 255             return true;
 256         }
 257 
 258         int startErrors = log.nerrors;
 259 
 260         depth++;
 261         try {
 262             // scan trees for module defs
 263             Set&lt;ModuleSymbol&gt; roots = enterModules(trees, c);
 264 
 265             setCompilationUnitModules(trees, roots, c);
 266 
 267             init.accept(roots);
 268 
 269             for (ModuleSymbol msym: roots) {
 270                 msym.complete();
 271             }
 272         } catch (CompletionFailure ex) {
 273             chk.completionError(null, ex);
 274         } finally {
 275             depth--;
 276         }
 277 
 278         return (log.nerrors == startErrors);
 279     }
 280 
 281     public Completer getCompleter() {
 282         return mainCompleter;
 283     }
 284 
 285     public ModuleSymbol getDefaultModule() {
 286         return defaultModule;
 287     }
 288 
 289     public boolean modulesInitialized() {
 290         return allModules != null;
 291     }
 292 
 293     private Set&lt;ModuleSymbol&gt; enterModules(List&lt;JCCompilationUnit&gt; trees, ClassSymbol c) {
 294         Set&lt;ModuleSymbol&gt; modules = new LinkedHashSet&lt;&gt;();
 295         for (JCCompilationUnit tree : trees) {
 296             JavaFileObject prev = log.useSource(tree.sourcefile);
 297             try {
 298                 enterModule(tree, c, modules);
 299             } finally {
 300                 log.useSource(prev);
 301             }
 302         }
 303         return modules;
 304     }
 305 
 306 
 307     private void enterModule(JCCompilationUnit toplevel, ClassSymbol c, Set&lt;ModuleSymbol&gt; modules) {
 308         boolean isModuleInfo = toplevel.sourcefile.isNameCompatible(&quot;module-info&quot;, Kind.SOURCE);
 309         boolean isModuleDecl = toplevel.getModuleDecl() != null;
 310         if (isModuleDecl) {
 311             JCModuleDecl decl = toplevel.getModuleDecl();
 312             if (!isModuleInfo) {
 313                 log.error(decl.pos(), Errors.ModuleDeclSbInModuleInfoJava);
 314             }
 315             Name name = TreeInfo.fullName(decl.qualId);
 316             ModuleSymbol sym;
 317             if (c != null) {
 318                 sym = (ModuleSymbol) c.owner;
 319                 Assert.checkNonNull(sym.name);
 320                 Name treeName = TreeInfo.fullName(decl.qualId);
 321                 if (sym.name != treeName) {
 322                     log.error(decl.pos(), Errors.ModuleNameMismatch(name, sym.name));
 323                 }
 324             } else {
 325                 sym = syms.enterModule(name);
 326                 if (sym.module_info.sourcefile != null &amp;&amp; sym.module_info.sourcefile != toplevel.sourcefile) {
 327                     log.error(decl.pos(), Errors.DuplicateModule(sym));
 328                     return;
 329                 }
 330             }
 331             sym.completer = getSourceCompleter(toplevel);
 332             sym.module_info.sourcefile = toplevel.sourcefile;
 333             decl.sym = sym;
 334 
 335             if (multiModuleMode || modules.isEmpty()) {
 336                 modules.add(sym);
 337             } else {
 338                 log.error(toplevel.pos(), Errors.TooManyModules);
 339             }
 340 
 341             Env&lt;AttrContext&gt; provisionalEnv = new Env&lt;&gt;(decl, null);
 342 
 343             provisionalEnv.toplevel = toplevel;
 344             typeEnvs.put(sym, provisionalEnv);
 345         } else if (isModuleInfo) {
 346             if (multiModuleMode) {
 347                 JCTree tree = toplevel.defs.isEmpty() ? toplevel : toplevel.defs.head;
 348                 log.error(tree.pos(), Errors.ExpectedModule);
 349             }
 350         }
 351     }
 352 
 353     private void setCompilationUnitModules(List&lt;JCCompilationUnit&gt; trees, Set&lt;ModuleSymbol&gt; rootModules, ClassSymbol c) {
 354         // update the module for each compilation unit
 355         if (multiModuleMode) {
 356             boolean patchesAutomaticModules = false;
 357             for (JCCompilationUnit tree: trees) {
 358                 if (tree.defs.isEmpty()) {
 359                     tree.modle = syms.unnamedModule;
 360                     continue;
 361                 }
 362 
 363                 JavaFileObject prev = log.useSource(tree.sourcefile);
 364                 try {
 365                     Location msplocn = getModuleLocation(tree);
 366                     Location plocn = fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH) ?
 367                             fileManager.getLocationForModule(StandardLocation.PATCH_MODULE_PATH,
 368                                                              tree.sourcefile) :
 369                             null;
 370 
 371                     if (plocn != null) {
 372                         Name name = names.fromString(fileManager.inferModuleName(plocn));
 373                         ModuleSymbol msym = moduleFinder.findModule(name);
 374                         tree.modle = msym;
 375                         rootModules.add(msym);
 376                         patchesAutomaticModules |= (msym.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0;
 377 
 378                         if (msplocn != null) {
 379                             Name mspname = names.fromString(fileManager.inferModuleName(msplocn));
 380                             if (name != mspname) {
 381                                 log.error(tree.pos(), Errors.FilePatchedAndMsp(name, mspname));
 382                             }
 383                         }
 384                     } else if (msplocn != null) {
 385                         if (tree.getModuleDecl() != null) {
 386                             JavaFileObject canonical =
 387                                     fileManager.getJavaFileForInput(msplocn, &quot;module-info&quot;, Kind.SOURCE);
 388                             if (canonical == null || !fileManager.isSameFile(canonical, tree.sourcefile)) {
 389                                 log.error(tree.pos(), Errors.ModuleNotFoundOnModuleSourcePath);
 390                             }
 391                         }
 392                         Name name = names.fromString(fileManager.inferModuleName(msplocn));
 393                         ModuleSymbol msym;
 394                         JCModuleDecl decl = tree.getModuleDecl();
 395                         if (decl != null) {
 396                             msym = decl.sym;
 397                             if (msym.name != name) {
 398                                 log.error(decl.qualId, Errors.ModuleNameMismatch(msym.name, name));
 399                             }
 400                         } else {
 401                             if (tree.getPackage() == null) {
 402                                 log.error(tree.pos(), Errors.UnnamedPkgNotAllowedNamedModules);
 403                             }
 404                             msym = syms.enterModule(name);
 405                         }
 406                         if (msym.sourceLocation == null) {
 407                             msym.sourceLocation = msplocn;
 408                             if (fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH)) {
 409                                 msym.patchLocation = fileManager.getLocationForModule(
 410                                         StandardLocation.PATCH_MODULE_PATH, msym.name.toString());
 411                             }
 412                             if (fileManager.hasLocation(StandardLocation.CLASS_OUTPUT)) {
 413                                 Location outputLocn = fileManager.getLocationForModule(
 414                                         StandardLocation.CLASS_OUTPUT, msym.name.toString());
 415                                 if (msym.patchLocation == null) {
 416                                     msym.classLocation = outputLocn;
 417                                 } else {
 418                                     msym.patchOutputLocation = outputLocn;
 419                                 }
 420                             }
 421                         }
 422                         tree.modle = msym;
 423                         rootModules.add(msym);
 424                     } else if (c != null &amp;&amp; c.packge().modle == syms.unnamedModule) {
 425                         tree.modle = syms.unnamedModule;
 426                     } else {
 427                         if (tree.getModuleDecl() != null) {
 428                             log.error(tree.pos(), Errors.ModuleNotFoundOnModuleSourcePath);
 429                         } else {
 430                             log.error(tree.pos(), Errors.NotInModuleOnModuleSourcePath);
 431                         }
 432                         tree.modle = syms.errModule;
 433                     }
 434                 } catch (IOException e) {
 435                     throw new Error(e); // FIXME
 436                 } finally {
 437                     log.useSource(prev);
 438                 }
 439             }
 440             if (!patchesAutomaticModules) {
 441                 checkNoAllModulePath();
 442             }
 443             if (syms.unnamedModule.sourceLocation == null) {
 444                 syms.unnamedModule.completer = getUnnamedModuleCompleter();
 445                 syms.unnamedModule.sourceLocation = StandardLocation.SOURCE_PATH;
 446                 syms.unnamedModule.classLocation = StandardLocation.CLASS_PATH;
 447             }
 448             defaultModule = syms.unnamedModule;
 449         } else {
 450             ModuleSymbol module = null;
 451             if (defaultModule == null) {
 452                 String moduleOverride = singleModuleOverride(trees);
 453                 switch (rootModules.size()) {
 454                     case 0:
 455                         try {
 456                             defaultModule = moduleFinder.findSingleModule();
 457                         } catch (CompletionFailure cf) {
 458                             chk.completionError(null, cf);
 459                             defaultModule = syms.unnamedModule;
 460                         }
 461                         if (defaultModule == syms.unnamedModule) {
 462                             if (moduleOverride != null) {
 463                                 defaultModule = moduleFinder.findModule(names.fromString(moduleOverride));
 464                                 defaultModule.patchOutputLocation = StandardLocation.CLASS_OUTPUT;
 465                                 if ((defaultModule.flags_field &amp; Flags.AUTOMATIC_MODULE) == 0) {
 466                                     checkNoAllModulePath();
 467                                 }
 468                             } else {
 469                                 // Question: why not do findAllModules and initVisiblePackages here?
 470                                 // i.e. body of unnamedModuleCompleter
 471                                 defaultModule.completer = getUnnamedModuleCompleter();
 472                                 defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
 473                                 defaultModule.classLocation = StandardLocation.CLASS_PATH;
 474                             }
 475                         } else {
 476                             checkNoAllModulePath();
 477                             defaultModule.complete();
 478                             // Question: why not do completeModule here?
 479                             defaultModule.completer = sym -&gt; completeModule((ModuleSymbol) sym);
 480                             defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
 481                         }
 482                         rootModules.add(defaultModule);
 483                         break;
 484                     case 1:
 485                         checkNoAllModulePath();
 486                         defaultModule = rootModules.iterator().next();
 487                         defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
 488                         if (fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH)) {
 489                             try {
 490                                 defaultModule.patchLocation = fileManager.getLocationForModule(
 491                                         StandardLocation.PATCH_MODULE_PATH, defaultModule.name.toString());
 492                             } catch (IOException ex) {
 493                                 throw new Error(ex);
 494                             }
 495                         }
 496                         if (defaultModule.patchLocation == null) {
 497                             defaultModule.classLocation = StandardLocation.CLASS_OUTPUT;
 498                         } else {
 499                             defaultModule.patchOutputLocation = StandardLocation.CLASS_OUTPUT;
 500                         }
 501                         break;
 502                     default:
 503                         Assert.error(&quot;too many modules&quot;);
 504                 }
 505             } else if (rootModules.size() == 1) {
 506                 module = rootModules.iterator().next();
 507                 module.complete();
 508                 module.completer = sym -&gt; completeModule((ModuleSymbol) sym);
 509             } else {
 510                 Assert.check(rootModules.isEmpty());
 511                 Assert.checkNonNull(c);
 512                 module = c.packge().modle;
 513                 rootModules.add(module);
 514             }
 515 
 516             if (defaultModule != syms.unnamedModule) {
 517                 syms.unnamedModule.completer = getUnnamedModuleCompleter();
 518                 syms.unnamedModule.classLocation = StandardLocation.CLASS_PATH;
 519             }
 520 
 521             if (module == null) {
 522                 module = defaultModule;
 523             }
 524 
 525             for (JCCompilationUnit tree : trees) {
 526                 if (defaultModule != syms.unnamedModule
 527                         &amp;&amp; defaultModule.sourceLocation == StandardLocation.SOURCE_PATH
 528                         &amp;&amp; fileManager.hasLocation(StandardLocation.SOURCE_PATH)) {
 529                     checkSourceLocation(tree, module);
 530                 }
 531                 tree.modle = module;
 532             }
 533         }
 534     }
 535 
 536     private void checkSourceLocation(JCCompilationUnit tree, ModuleSymbol msym) {
 537         try {
 538             JavaFileObject fo = tree.sourcefile;
 539             if (fileManager.contains(msym.sourceLocation, fo)) {
 540                 return;
 541             }
 542             if (msym.patchLocation != null &amp;&amp; fileManager.contains(msym.patchLocation, fo)) {
 543                 return;
 544             }
 545             if (fileManager.hasLocation(StandardLocation.SOURCE_OUTPUT)) {
 546                 if (fileManager.contains(StandardLocation.SOURCE_OUTPUT, fo)) {
 547                     return;
 548                 }
 549             } else {
 550                 if (fileManager.contains(StandardLocation.CLASS_OUTPUT, fo)) {
 551                     return;
 552                 }
 553             }
 554         } catch (IOException e) {
 555             throw new Error(e);
 556         }
 557 
 558         JavaFileObject prev = log.useSource(tree.sourcefile);
 559         try {
 560             log.error(tree.pos(), Errors.FileSbOnSourceOrPatchPathForModule);
 561         } finally {
 562             log.useSource(prev);
 563         }
 564     }
 565 
 566     private String singleModuleOverride(List&lt;JCCompilationUnit&gt; trees) {
 567         if (!fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH)) {
 568             return null;
 569         }
 570 
 571         Set&lt;String&gt; override = new LinkedHashSet&lt;&gt;();
 572         for (JCCompilationUnit tree : trees) {
 573             JavaFileObject fo = tree.sourcefile;
 574 
 575             try {
 576                 Location loc =
 577                         fileManager.getLocationForModule(StandardLocation.PATCH_MODULE_PATH, fo);
 578 
 579                 if (loc != null) {
 580                     override.add(fileManager.inferModuleName(loc));
 581                 }
 582             } catch (IOException ex) {
 583                 throw new Error(ex);
 584             }
 585         }
 586 
 587         switch (override.size()) {
 588             case 0: return null;
 589             case 1: return override.iterator().next();
 590             default:
 591                 log.error(Errors.TooManyPatchedModules(override));
 592                 return null;
 593         }
 594     }
 595 
 596     /**
 597      * Determine the location for the module on the module source path
 598      * or source output directory which contains a given CompilationUnit.
 599      * If the source output directory is unset, the class output directory
 600      * will be checked instead.
 601      * {@code null} is returned if no such module can be found.
 602      * @param tree the compilation unit tree
 603      * @return the location for the enclosing module
 604      * @throws IOException if there is a problem while searching for the module.
 605      */
 606     private Location getModuleLocation(JCCompilationUnit tree) throws IOException {
 607         JavaFileObject fo = tree.sourcefile;
 608 
 609         Location loc =
 610                 fileManager.getLocationForModule(StandardLocation.MODULE_SOURCE_PATH, fo);
 611         if (loc == null) {
 612             Location sourceOutput = fileManager.hasLocation(StandardLocation.SOURCE_OUTPUT) ?
 613                     StandardLocation.SOURCE_OUTPUT : StandardLocation.CLASS_OUTPUT;
 614             loc =
 615                 fileManager.getLocationForModule(sourceOutput, fo);
 616         }
 617         return loc;
 618     }
 619 
 620     private void checkNoAllModulePath() {
 621         if (addModsOpt != null &amp;&amp; Arrays.asList(addModsOpt.split(&quot;,&quot;)).contains(ALL_MODULE_PATH)) {
 622             log.error(Errors.AddmodsAllModulePathInvalid);
 623         }
 624     }
 625 
 626     private final Completer mainCompleter = new Completer() {
 627         @Override
 628         public void complete(Symbol sym) throws CompletionFailure {
 629             ModuleSymbol msym = moduleFinder.findModule((ModuleSymbol) sym);
 630 
 631             if (msym.kind == ERR) {
 632                 //make sure the module is initialized:
 633                 initErrModule(msym);
 634             } else if ((msym.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0) {
 635                 setupAutomaticModule(msym);
 636             } else {
 637                 try {
 638                     msym.module_info.complete();
 639                 } catch (CompletionFailure cf) {
 640                     msym.kind = ERR;
 641                     //make sure the module is initialized:
 642                     initErrModule(msym);
 643                     completeModule(msym);
 644                     throw cf;
 645                 }
 646             }
 647 
 648             // If module-info comes from a .java file, the underlying
 649             // call of classFinder.fillIn will have called through the
 650             // source completer, to Enter, and then to Modules.enter,
 651             // which will call completeModule.
 652             // But, if module-info comes from a .class file, the underlying
 653             // call of classFinder.fillIn will just call ClassReader to read
 654             // the .class file, and so we call completeModule here.
 655             if (msym.module_info.classfile == null || msym.module_info.classfile.getKind() == Kind.CLASS) {
 656                 completeModule(msym);
 657             }
 658         }
 659 
 660         private void initErrModule(ModuleSymbol msym) {
 661             msym.directives = List.nil();
 662             msym.exports = List.nil();
 663             msym.provides = List.nil();
 664             msym.requires = List.nil();
 665             msym.uses = List.nil();
 666         }
 667 
 668         @Override
 669         public String toString() {
 670             return &quot;mainCompleter&quot;;
 671         }
 672     };
 673 
 674     private void setupAutomaticModule(ModuleSymbol msym) throws CompletionFailure {
 675         try {
 676             ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
 677             ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
 678             Set&lt;String&gt; seenPackages = new HashSet&lt;&gt;();
 679 
 680             for (JavaFileObject clazz : fileManager.list(msym.classLocation, &quot;&quot;, EnumSet.of(Kind.CLASS), true)) {
 681                 String binName = fileManager.inferBinaryName(msym.classLocation, clazz);
 682                 String pack = binName.lastIndexOf(&#39;.&#39;) != (-1) ? binName.substring(0, binName.lastIndexOf(&#39;.&#39;)) : &quot;&quot;; //unnamed package????
 683                 if (seenPackages.add(pack)) {
 684                     ExportsDirective d = new ExportsDirective(syms.enterPackage(msym, names.fromString(pack)), null);
 685                     //TODO: opens?
 686                     directives.add(d);
 687                     exports.add(d);
 688                 }
 689             }
 690 
 691             msym.exports = exports.toList();
 692             msym.provides = List.nil();
 693             msym.requires = List.nil();
 694             msym.uses = List.nil();
 695             msym.directives = directives.toList();
 696         } catch (IOException ex) {
 697             throw new IllegalStateException(ex);
 698         }
 699     }
 700 
 701     private void completeAutomaticModule(ModuleSymbol msym) throws CompletionFailure {
 702         ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
 703 
 704         directives.addAll(msym.directives);
 705 
 706         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
 707 
 708         for (ModuleSymbol ms : allModules()) {
 709             if (ms == syms.unnamedModule || ms == msym)
 710                 continue;
 711             Set&lt;RequiresFlag&gt; flags = (ms.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0 ?
 712                     EnumSet.of(RequiresFlag.TRANSITIVE) : EnumSet.noneOf(RequiresFlag.class);
 713             RequiresDirective d = new RequiresDirective(ms, flags);
 714             directives.add(d);
 715             requires.add(d);
 716         }
 717 
 718         RequiresDirective requiresUnnamed = new RequiresDirective(syms.unnamedModule);
 719         directives.add(requiresUnnamed);
 720         requires.add(requiresUnnamed);
 721 
 722         msym.requires = requires.toList();
 723         msym.directives = directives.toList();
 724     }
 725 
 726     private Completer getSourceCompleter(JCCompilationUnit tree) {
 727         return new Completer() {
 728             @Override
 729             public void complete(Symbol sym) throws CompletionFailure {
 730                 ModuleSymbol msym = (ModuleSymbol) sym;
 731                 msym.flags_field |= UNATTRIBUTED;
 732                 ModuleVisitor v = new ModuleVisitor();
 733                 JavaFileObject prev = log.useSource(tree.sourcefile);
 734                 JCModuleDecl moduleDecl = tree.getModuleDecl();
 735                 DiagnosticPosition prevLintPos = deferredLintHandler.setPos(moduleDecl.pos());
 736 
 737                 try {
 738                     moduleDecl.accept(v);
 739                     completeModule(msym);
 740                     checkCyclicDependencies(moduleDecl);
 741                 } finally {
 742                     log.useSource(prev);
 743                     deferredLintHandler.setPos(prevLintPos);
 744                     msym.flags_field &amp;= ~UNATTRIBUTED;
 745                 }
 746             }
 747 
 748             @Override
 749             public String toString() {
 750                 return &quot;SourceCompleter: &quot; + tree.sourcefile.getName();
 751             }
 752 
 753         };
 754     }
 755 
 756     public boolean isRootModule(ModuleSymbol module) {
 757         Assert.checkNonNull(rootModules);
 758         return rootModules.contains(module);
 759     }
 760 
 761     public Set&lt;ModuleSymbol&gt; getRootModules() {
 762         Assert.checkNonNull(rootModules);
 763         return rootModules;
 764     }
 765 
 766     class ModuleVisitor extends JCTree.Visitor {
 767         private ModuleSymbol sym;
 768         private final Set&lt;ModuleSymbol&gt; allRequires = new HashSet&lt;&gt;();
 769         private final Map&lt;PackageSymbol,List&lt;ExportsDirective&gt;&gt; allExports = new HashMap&lt;&gt;();
 770         private final Map&lt;PackageSymbol,List&lt;OpensDirective&gt;&gt; allOpens = new HashMap&lt;&gt;();
 771 
 772         @Override
 773         public void visitModuleDef(JCModuleDecl tree) {
 774             sym = Assert.checkNonNull(tree.sym);
 775 
 776             if (tree.getModuleType() == ModuleKind.OPEN) {
 777                 sym.flags.add(ModuleFlags.OPEN);
 778             }
 779             sym.flags_field |= (tree.mods.flags &amp; Flags.DEPRECATED);
 780 
 781             sym.requires = List.nil();
 782             sym.exports = List.nil();
 783             sym.opens = List.nil();
 784             tree.directives.forEach(t -&gt; t.accept(this));
 785             sym.requires = sym.requires.reverse();
 786             sym.exports = sym.exports.reverse();
 787             sym.opens = sym.opens.reverse();
 788             ensureJavaBase();
 789         }
 790 
 791         @Override
 792         public void visitRequires(JCRequires tree) {
 793             ModuleSymbol msym = lookupModule(tree.moduleName);
 794             if (msym.kind != MDL) {
 795                 log.error(tree.moduleName.pos(), Errors.ModuleNotFound(msym));
 796                 warnedMissing.add(msym);
 797             } else if (allRequires.contains(msym)) {
 798                 log.error(tree.moduleName.pos(), Errors.DuplicateRequires(msym));
 799             } else {
 800                 allRequires.add(msym);
 801                 Set&lt;RequiresFlag&gt; flags = EnumSet.noneOf(RequiresFlag.class);
 802                 if (tree.isTransitive) {
 803                     if (msym == syms.java_base &amp;&amp; source.compareTo(Source.JDK10) &gt;= 0) {
 804                         log.error(tree.pos(), Errors.ModifierNotAllowedHere(names.transitive));
 805                     } else {
 806                         flags.add(RequiresFlag.TRANSITIVE);
 807                     }
 808                 }
 809                 if (tree.isStaticPhase) {
 810                     if (msym == syms.java_base &amp;&amp; source.compareTo(Source.JDK10) &gt;= 0) {
 811                         log.error(tree.pos(), Errors.ModNotAllowedHere(EnumSet.of(Flag.STATIC)));
 812                     } else {
 813                         flags.add(RequiresFlag.STATIC_PHASE);
 814                     }
 815                 }
 816                 RequiresDirective d = new RequiresDirective(msym, flags);
 817                 tree.directive = d;
 818                 sym.requires = sym.requires.prepend(d);
 819             }
 820         }
 821 
 822         @Override
 823         public void visitExports(JCExports tree) {
 824             Name name = TreeInfo.fullName(tree.qualid);
 825             PackageSymbol packge = syms.enterPackage(sym, name);
 826             attr.setPackageSymbols(tree.qualid, packge);
 827 
 828             List&lt;ExportsDirective&gt; exportsForPackage = allExports.computeIfAbsent(packge, p -&gt; List.nil());
 829             for (ExportsDirective d : exportsForPackage) {
 830                 reportExportsConflict(tree, packge);
 831             }
 832 
 833             List&lt;ModuleSymbol&gt; toModules = null;
 834             if (tree.moduleNames != null) {
 835                 Set&lt;ModuleSymbol&gt; to = new LinkedHashSet&lt;&gt;();
 836                 for (JCExpression n: tree.moduleNames) {
 837                     ModuleSymbol msym = lookupModule(n);
 838                     chk.checkModuleExists(n.pos(), msym);
 839                     for (ExportsDirective d : exportsForPackage) {
 840                         checkDuplicateExportsToModule(n, msym, d);
 841                     }
 842                     if (!to.add(msym)) {
 843                         reportExportsConflictToModule(n, msym);
 844                     }
 845                 }
 846                 toModules = List.from(to);
 847             }
 848 
 849             if (toModules == null || !toModules.isEmpty()) {
 850                 Set&lt;ExportsFlag&gt; flags = EnumSet.noneOf(ExportsFlag.class);
 851                 ExportsDirective d = new ExportsDirective(packge, toModules, flags);
 852                 sym.exports = sym.exports.prepend(d);
 853                 tree.directive = d;
 854 
 855                 allExports.put(packge, exportsForPackage.prepend(d));
 856             }
 857         }
 858 
 859         private void reportExportsConflict(JCExports tree, PackageSymbol packge) {
 860             log.error(tree.qualid.pos(), Errors.ConflictingExports(packge));
 861         }
 862 
 863         private void checkDuplicateExportsToModule(JCExpression name, ModuleSymbol msym,
 864                 ExportsDirective d) {
 865             if (d.modules != null) {
 866                 for (ModuleSymbol other : d.modules) {
 867                     if (msym == other) {
 868                         reportExportsConflictToModule(name, msym);
 869                     }
 870                 }
 871             }
 872         }
 873 
 874         private void reportExportsConflictToModule(JCExpression name, ModuleSymbol msym) {
 875             log.error(name.pos(), Errors.ConflictingExportsToModule(msym));
 876         }
 877 
 878         @Override
 879         public void visitOpens(JCOpens tree) {
 880             Name name = TreeInfo.fullName(tree.qualid);
 881             PackageSymbol packge = syms.enterPackage(sym, name);
 882             attr.setPackageSymbols(tree.qualid, packge);
 883 
 884             if (sym.flags.contains(ModuleFlags.OPEN)) {
 885                 log.error(tree.pos(), Errors.NoOpensUnlessStrong);
 886             }
 887             List&lt;OpensDirective&gt; opensForPackage = allOpens.computeIfAbsent(packge, p -&gt; List.nil());
 888             for (OpensDirective d : opensForPackage) {
 889                 reportOpensConflict(tree, packge);
 890             }
 891 
 892             List&lt;ModuleSymbol&gt; toModules = null;
 893             if (tree.moduleNames != null) {
 894                 Set&lt;ModuleSymbol&gt; to = new LinkedHashSet&lt;&gt;();
 895                 for (JCExpression n: tree.moduleNames) {
 896                     ModuleSymbol msym = lookupModule(n);
 897                     chk.checkModuleExists(n.pos(), msym);
 898                     for (OpensDirective d : opensForPackage) {
 899                         checkDuplicateOpensToModule(n, msym, d);
 900                     }
 901                     if (!to.add(msym)) {
 902                         reportOpensConflictToModule(n, msym);
 903                     }
 904                 }
 905                 toModules = List.from(to);
 906             }
 907 
 908             if (toModules == null || !toModules.isEmpty()) {
 909                 Set&lt;OpensFlag&gt; flags = EnumSet.noneOf(OpensFlag.class);
 910                 OpensDirective d = new OpensDirective(packge, toModules, flags);
 911                 sym.opens = sym.opens.prepend(d);
 912                 tree.directive = d;
 913 
 914                 allOpens.put(packge, opensForPackage.prepend(d));
 915             }
 916         }
 917 
 918         private void reportOpensConflict(JCOpens tree, PackageSymbol packge) {
 919             log.error(tree.qualid.pos(), Errors.ConflictingOpens(packge));
 920         }
 921 
 922         private void checkDuplicateOpensToModule(JCExpression name, ModuleSymbol msym,
 923                 OpensDirective d) {
 924             if (d.modules != null) {
 925                 for (ModuleSymbol other : d.modules) {
 926                     if (msym == other) {
 927                         reportOpensConflictToModule(name, msym);
 928                     }
 929                 }
 930             }
 931         }
 932 
 933         private void reportOpensConflictToModule(JCExpression name, ModuleSymbol msym) {
 934             log.error(name.pos(), Errors.ConflictingOpensToModule(msym));
 935         }
 936 
 937         @Override
 938         public void visitProvides(JCProvides tree) { }
 939 
 940         @Override
 941         public void visitUses(JCUses tree) { }
 942 
 943         private void ensureJavaBase() {
 944             if (sym.name == names.java_base)
 945                 return;
 946 
 947             for (RequiresDirective d: sym.requires) {
 948                 if (d.module.name == names.java_base)
 949                     return;
 950             }
 951 
 952             ModuleSymbol java_base = syms.enterModule(names.java_base);
 953             Directive.RequiresDirective d =
 954                     new Directive.RequiresDirective(java_base,
 955                             EnumSet.of(Directive.RequiresFlag.MANDATED));
 956             sym.requires = sym.requires.prepend(d);
 957         }
 958 
 959         private ModuleSymbol lookupModule(JCExpression moduleName) {
 960             Name name = TreeInfo.fullName(moduleName);
 961             ModuleSymbol msym = moduleFinder.findModule(name);
 962             TreeInfo.setSymbol(moduleName, msym);
 963             return msym;
 964         }
 965     }
 966 
 967     public Completer getUsesProvidesCompleter() {
 968         return sym -&gt; {
 969             ModuleSymbol msym = (ModuleSymbol) sym;
 970 
 971             msym.complete();
 972 
 973             Env&lt;AttrContext&gt; env = typeEnvs.get(msym);
 974             UsesProvidesVisitor v = new UsesProvidesVisitor(msym, env);
 975             JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 976             JCModuleDecl decl = env.toplevel.getModuleDecl();
 977             DiagnosticPosition prevLintPos = deferredLintHandler.setPos(decl.pos());
 978 
 979             try {
 980                 decl.accept(v);
 981             } finally {
 982                 log.useSource(prev);
 983                 deferredLintHandler.setPos(prevLintPos);
 984             }
 985         };
 986     }
 987 
 988     class UsesProvidesVisitor extends JCTree.Visitor {
 989         private final ModuleSymbol msym;
 990         private final Env&lt;AttrContext&gt; env;
 991 
 992         private final Set&lt;ClassSymbol&gt; allUses = new HashSet&lt;&gt;();
 993         private final Map&lt;ClassSymbol, Set&lt;ClassSymbol&gt;&gt; allProvides = new HashMap&lt;&gt;();
 994 
 995         public UsesProvidesVisitor(ModuleSymbol msym, Env&lt;AttrContext&gt; env) {
 996             this.msym = msym;
 997             this.env = env;
 998         }
 999 
1000         @Override @SuppressWarnings(&quot;unchecked&quot;)
1001         public void visitModuleDef(JCModuleDecl tree) {
1002             msym.directives = List.nil();
1003             msym.provides = List.nil();
1004             msym.uses = List.nil();
1005             tree.directives.forEach(t -&gt; t.accept(this));
1006             msym.directives = msym.directives.reverse();
1007             msym.provides = msym.provides.reverse();
1008             msym.uses = msym.uses.reverse();
1009 
1010             if (msym.requires.nonEmpty() &amp;&amp; msym.requires.head.flags.contains(RequiresFlag.MANDATED))
1011                 msym.directives = msym.directives.prepend(msym.requires.head);
1012 
1013             msym.directives = msym.directives.appendList(List.from(addReads.getOrDefault(msym, Collections.emptySet())));
1014 
1015             checkForCorrectness();
1016         }
1017 
1018         @Override
1019         public void visitExports(JCExports tree) {
1020             Iterable&lt;Symbol&gt; packageContent = tree.directive.packge.members().getSymbols();
1021             List&lt;JavaFileObject&gt; filesToCheck = List.nil();
1022             boolean packageNotEmpty = false;
1023             for (Symbol sym : packageContent) {
1024                 if (sym.kind != Kinds.Kind.TYP)
1025                     continue;
1026                 ClassSymbol csym = (ClassSymbol) sym;
1027                 if (sym.completer.isTerminal() ||
1028                     csym.classfile.getKind() == Kind.CLASS) {
1029                     packageNotEmpty = true;
1030                     filesToCheck = List.nil();
1031                     break;
1032                 }
1033                 if (csym.classfile.getKind() == Kind.SOURCE) {
1034                     filesToCheck = filesToCheck.prepend(csym.classfile);
1035                 }
1036             }
1037             for (JavaFileObject jfo : filesToCheck) {
1038                 if (findPackageInFile.findPackageNameOf(jfo) == tree.directive.packge.fullname) {
1039                     packageNotEmpty = true;
1040                     break;
1041                 }
1042             }
1043             if (!packageNotEmpty) {
1044                 log.error(tree.qualid.pos(), Errors.PackageEmptyOrNotFound(tree.directive.packge));
1045             }
1046             msym.directives = msym.directives.prepend(tree.directive);
1047         }
1048 
1049         @Override
1050         public void visitOpens(JCOpens tree) {
1051             chk.checkPackageExistsForOpens(tree.qualid, tree.directive.packge);
1052             msym.directives = msym.directives.prepend(tree.directive);
1053         }
1054 
1055         MethodSymbol noArgsConstructor(ClassSymbol tsym) {
1056             for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {
1057                 MethodSymbol mSym = (MethodSymbol)sym;
1058                 if (mSym.params().isEmpty()) {
1059                     return mSym;
1060                 }
1061             }
1062             return null;
1063         }
1064 
1065         MethodSymbol factoryMethod(ClassSymbol tsym) {
1066             for (Symbol sym : tsym.members().getSymbolsByName(names.provider, sym -&gt; sym.kind == MTH)) {
1067                 MethodSymbol mSym = (MethodSymbol)sym;
1068                 if (mSym.isStatic() &amp;&amp; (mSym.flags() &amp; Flags.PUBLIC) != 0 &amp;&amp; mSym.params().isEmpty()) {
1069                     return mSym;
1070                 }
1071             }
1072             return null;
1073         }
1074 
1075         Map&lt;Directive.ProvidesDirective, JCProvides&gt; directiveToTreeMap = new HashMap&lt;&gt;();
1076 
1077         @Override
1078         public void visitProvides(JCProvides tree) {
1079             Type st = attr.attribType(tree.serviceName, env, syms.objectType);
1080             ClassSymbol service = (ClassSymbol) st.tsym;
1081             if (allProvides.containsKey(service)) {
1082                 log.error(tree.serviceName.pos(), Errors.RepeatedProvidesForService(service));
1083             }
1084             ListBuffer&lt;ClassSymbol&gt; impls = new ListBuffer&lt;&gt;();
1085             for (JCExpression implName : tree.implNames) {
1086                 Type it;
1087                 boolean prevVisitingServiceImplementation = env.info.visitingServiceImplementation;
1088                 try {
1089                     env.info.visitingServiceImplementation = true;
1090                     it = attr.attribType(implName, env, syms.objectType);
1091                 } finally {
1092                     env.info.visitingServiceImplementation = prevVisitingServiceImplementation;
1093                 }
1094                 ClassSymbol impl = (ClassSymbol) it.tsym;
1095                 if ((impl.flags_field &amp; PUBLIC) == 0) {
1096                     log.error(implName.pos(), Errors.NotDefPublic(impl, impl.location()));
1097                 }
1098                 //find provider factory:
1099                 MethodSymbol factory = factoryMethod(impl);
1100                 if (factory != null) {
1101                     Type returnType = factory.type.getReturnType();
1102                     if (!types.isSubtype(returnType, st)) {
1103                         log.error(implName.pos(), Errors.ServiceImplementationProviderReturnMustBeSubtypeOfServiceInterface);
1104                     }
1105                 } else {
1106                     if (!types.isSubtype(it, st)) {
1107                         log.error(implName.pos(), Errors.ServiceImplementationMustBeSubtypeOfServiceInterface);
1108                     } else if ((impl.flags() &amp; ABSTRACT) != 0) {
1109                         log.error(implName.pos(), Errors.ServiceImplementationIsAbstract(impl));
1110                     } else if (impl.isInner()) {
1111                         log.error(implName.pos(), Errors.ServiceImplementationIsInner(impl));
1112                     } else {
1113                         MethodSymbol constr = noArgsConstructor(impl);
1114                         if (constr == null) {
1115                             log.error(implName.pos(), Errors.ServiceImplementationDoesntHaveANoArgsConstructor(impl));
1116                         } else if ((constr.flags() &amp; PUBLIC) == 0) {
1117                             log.error(implName.pos(), Errors.ServiceImplementationNoArgsConstructorNotPublic(impl));
1118                         }
1119                     }
1120                 }
1121                 if (it.hasTag(CLASS)) {
1122                     if (allProvides.computeIfAbsent(service, s -&gt; new HashSet&lt;&gt;()).add(impl)) {
1123                         impls.append(impl);
1124                     } else {
1125                         log.error(implName.pos(), Errors.DuplicateProvides(service, impl));
1126                     }
1127                 }
1128             }
1129             if (st.hasTag(CLASS) &amp;&amp; !impls.isEmpty()) {
1130                 Directive.ProvidesDirective d = new Directive.ProvidesDirective(service, impls.toList());
1131                 msym.provides = msym.provides.prepend(d);
1132                 msym.directives = msym.directives.prepend(d);
1133                 directiveToTreeMap.put(d, tree);
1134             }
1135         }
1136 
1137         @Override
1138         public void visitRequires(JCRequires tree) {
1139             if (tree.directive != null &amp;&amp; allModules().contains(tree.directive.module)) {
1140                 chk.checkDeprecated(tree.moduleName.pos(), msym, tree.directive.module);
1141                 chk.checkModuleRequires(tree.moduleName.pos(), tree.directive);
1142                 msym.directives = msym.directives.prepend(tree.directive);
1143             }
1144         }
1145 
1146         @Override
1147         public void visitUses(JCUses tree) {
1148             Type st = attr.attribType(tree.qualid, env, syms.objectType);
1149             Symbol sym = TreeInfo.symbol(tree.qualid);
1150             if ((sym.flags() &amp; ENUM) != 0) {
1151                 log.error(tree.qualid.pos(), Errors.ServiceDefinitionIsEnum(st.tsym));
1152             } else if (st.hasTag(CLASS)) {
1153                 ClassSymbol service = (ClassSymbol) st.tsym;
1154                 if (allUses.add(service)) {
1155                     Directive.UsesDirective d = new Directive.UsesDirective(service);
1156                     msym.uses = msym.uses.prepend(d);
1157                     msym.directives = msym.directives.prepend(d);
1158                 } else {
1159                     log.error(tree.pos(), Errors.DuplicateUses(service));
1160                 }
1161             }
1162         }
1163 
1164         private void checkForCorrectness() {
1165             for (Directive.ProvidesDirective provides : msym.provides) {
1166                 JCProvides tree = directiveToTreeMap.get(provides);
1167                 for (ClassSymbol impl : provides.impls) {
1168                     /* The implementation must be defined in the same module as the provides directive
1169                      * (else, error)
1170                      */
1171                     PackageSymbol implementationDefiningPackage = impl.packge();
1172                     if (implementationDefiningPackage.modle != msym) {
1173                         // TODO: should use tree for the implementation name, not the entire provides tree
1174                         // TODO: should improve error message to identify the implementation type
1175                         log.error(tree.pos(), Errors.ServiceImplementationNotInRightModule(implementationDefiningPackage.modle));
1176                     }
1177 
1178                     /* There is no inherent requirement that module that provides a service should actually
1179                      * use it itself. However, it is a pointless declaration if the service package is not
1180                      * exported and there is no uses for the service.
1181                      */
1182                     PackageSymbol interfaceDeclaringPackage = provides.service.packge();
1183                     boolean isInterfaceDeclaredInCurrentModule = interfaceDeclaringPackage.modle == msym;
1184                     boolean isInterfaceExportedFromAReadableModule =
1185                             msym.visiblePackages.get(interfaceDeclaringPackage.fullname) == interfaceDeclaringPackage;
1186                     if (isInterfaceDeclaredInCurrentModule &amp;&amp; !isInterfaceExportedFromAReadableModule) {
1187                         // ok the interface is declared in this module. Let&#39;s check if it&#39;s exported
1188                         boolean warn = true;
1189                         for (ExportsDirective export : msym.exports) {
1190                             if (interfaceDeclaringPackage == export.packge) {
1191                                 warn = false;
1192                                 break;
1193                             }
1194                         }
1195                         if (warn) {
1196                             for (UsesDirective uses : msym.uses) {
1197                                 if (provides.service == uses.service) {
1198                                     warn = false;
1199                                     break;
1200                                 }
1201                             }
1202                         }
1203                         if (warn) {
1204                             log.warning(tree.pos(), Warnings.ServiceProvidedButNotExportedOrUsed(provides.service));
1205                         }
1206                     }
1207                 }
1208             }
1209         }
1210     }
1211 
1212     private Set&lt;ModuleSymbol&gt; allModules;
1213 
1214     public Set&lt;ModuleSymbol&gt; allModules() {
1215         Assert.checkNonNull(allModules);
1216         return allModules;
1217     }
1218 
1219     private void setupAllModules() {
1220         Assert.checkNonNull(rootModules);
1221         Assert.checkNull(allModules);
1222 
1223         Set&lt;ModuleSymbol&gt; observable;
1224 
1225         if (limitModsOpt == null &amp;&amp; extraLimitMods.isEmpty()) {
1226             observable = null;
1227         } else {
1228             Set&lt;ModuleSymbol&gt; limitMods = new HashSet&lt;&gt;();
1229             if (limitModsOpt != null) {
1230                 for (String limit : limitModsOpt.split(&quot;,&quot;)) {
1231                     if (!isValidName(limit))
1232                         continue;
1233                     limitMods.add(syms.enterModule(names.fromString(limit)));
1234                 }
1235             }
1236             for (String limit : extraLimitMods) {
1237                 limitMods.add(syms.enterModule(names.fromString(limit)));
1238             }
1239             observable = computeTransitiveClosure(limitMods, rootModules, null);
1240             observable.addAll(rootModules);
1241             if (lintOptions) {
1242                 for (ModuleSymbol msym : limitMods) {
1243                     if (!observable.contains(msym)) {
1244                         log.warning(LintCategory.OPTIONS,
1245                                 Warnings.ModuleForOptionNotFound(Option.LIMIT_MODULES, msym));
1246                     }
1247                 }
1248             }
1249         }
1250 
1251         Predicate&lt;ModuleSymbol&gt; observablePred = sym -&gt;
1252              (observable == null) ? (moduleFinder.findModule(sym).kind != ERR) : observable.contains(sym);
1253         Predicate&lt;ModuleSymbol&gt; systemModulePred = sym -&gt; (sym.flags() &amp; Flags.SYSTEM_MODULE) != 0;
1254         Set&lt;ModuleSymbol&gt; enabledRoot = new LinkedHashSet&lt;&gt;();
1255 
1256         if (rootModules.contains(syms.unnamedModule)) {
1257             Predicate&lt;ModuleSymbol&gt; jdkModulePred;
1258             if (target.allApiModulesAreRoots()) {
1259                 jdkModulePred = sym -&gt; {
1260                     sym.complete();
1261                     return sym.exports.stream().anyMatch(e -&gt; e.modules == null);
1262                 };
1263             } else {
1264                 ModuleSymbol javaSE = syms.getModule(java_se);
1265                 if (javaSE != null &amp;&amp; (observable == null || observable.contains(javaSE))) {
1266                     jdkModulePred = sym -&gt; {
1267                         sym.complete();
1268                         return !sym.name.startsWith(java_)
1269                             &amp;&amp; sym.exports.stream().anyMatch(e -&gt; e.modules == null);
1270                     };
1271                     enabledRoot.add(javaSE);
1272                 } else {
1273                     jdkModulePred = sym -&gt; true;
1274                 }
1275             }
1276 
1277             Predicate&lt;ModuleSymbol&gt; noIncubatorPred = sym -&gt; {
1278                 sym.complete();
1279                 return !sym.resolutionFlags.contains(ModuleResolutionFlags.DO_NOT_RESOLVE_BY_DEFAULT);
1280             };
1281 
1282             for (ModuleSymbol sym : new HashSet&lt;&gt;(syms.getAllModules())) {
1283                 try {
1284                     if (systemModulePred.test(sym) &amp;&amp; observablePred.test(sym) &amp;&amp; jdkModulePred.test(sym) &amp;&amp; noIncubatorPred.test(sym)) {
1285                         enabledRoot.add(sym);
1286                     }
1287                 } catch (CompletionFailure ex) {
1288                     chk.completionError(null, ex);
1289                 }
1290             }
1291         }
1292 
1293         enabledRoot.addAll(rootModules);
1294 
1295         if (addModsOpt != null || !extraAddMods.isEmpty()) {
1296             Set&lt;String&gt; fullAddMods = new HashSet&lt;&gt;();
1297             fullAddMods.addAll(extraAddMods);
1298 
1299             if (addModsOpt != null) {
1300                 fullAddMods.addAll(Arrays.asList(addModsOpt.split(&quot;,&quot;)));
1301             }
1302 
1303             for (String added : fullAddMods) {
1304                 Stream&lt;ModuleSymbol&gt; modules;
1305                 switch (added) {
1306                     case ALL_SYSTEM:
1307                         modules = new HashSet&lt;&gt;(syms.getAllModules())
1308                                 .stream()
1309                                 .filter(systemModulePred.and(observablePred));
1310                         break;
1311                     case ALL_MODULE_PATH:
1312                         modules = new HashSet&lt;&gt;(syms.getAllModules())
1313                                 .stream()
1314                                 .filter(systemModulePred.negate().and(observablePred));
1315                         break;
1316                     default:
1317                         if (!isValidName(added))
1318                             continue;
1319                         modules = Stream.of(syms.enterModule(names.fromString(added)));
1320                         break;
1321                 }
1322                 modules.forEach(sym -&gt; {
1323                     enabledRoot.add(sym);
1324                     if (observable != null)
1325                         observable.add(sym);
1326                 });
1327             }
1328         }
1329 
1330         Set&lt;ModuleSymbol&gt; result = computeTransitiveClosure(enabledRoot, rootModules, observable);
1331 
1332         result.add(syms.unnamedModule);
1333 
1334         boolean hasAutomatic = result.stream().anyMatch(IS_AUTOMATIC);
1335 
1336         if (hasAutomatic) {
1337             syms.getAllModules()
1338                 .stream()
1339                 .filter(IS_AUTOMATIC)
1340                 .forEach(result::add);
1341         }
1342 
1343         String incubatingModules = result.stream()
1344                 .filter(msym -&gt; msym.resolutionFlags.contains(ModuleResolutionFlags.WARN_INCUBATING))
1345                 .map(msym -&gt; msym.name.toString())
1346                 .collect(Collectors.joining(&quot;,&quot;));
1347 
1348         if (!incubatingModules.isEmpty()) {
1349             log.warning(Warnings.IncubatingModules(incubatingModules));
1350         }
1351 
1352         allModules = result;
1353 
1354         //add module versions from options, if any:
1355         if (moduleVersionOpt != null) {
1356             Name version = names.fromString(moduleVersionOpt);
1357             rootModules.forEach(m -&gt; m.version = version);
1358         }
1359     }
1360     //where:
1361         private static final Predicate&lt;ModuleSymbol&gt; IS_AUTOMATIC =
1362                 m -&gt; (m.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0;
1363 
1364     public boolean isInModuleGraph(ModuleSymbol msym) {
1365         return allModules == null || allModules.contains(msym);
1366     }
1367 
1368     private Set&lt;ModuleSymbol&gt; computeTransitiveClosure(Set&lt;? extends ModuleSymbol&gt; base,
1369                                                        Set&lt;? extends ModuleSymbol&gt; rootModules,
1370                                                        Set&lt;ModuleSymbol&gt; observable) {
1371         List&lt;ModuleSymbol&gt; primaryTodo = List.nil();
1372         List&lt;ModuleSymbol&gt; secondaryTodo = List.nil();
1373 
1374         for (ModuleSymbol ms : base) {
1375             if (rootModules.contains(ms)) {
1376                 primaryTodo = primaryTodo.prepend(ms);
1377             } else {
1378                 secondaryTodo = secondaryTodo.prepend(ms);
1379             }
1380         }
1381 
1382         Set&lt;ModuleSymbol&gt; result = new LinkedHashSet&lt;&gt;();
1383         result.add(syms.java_base);
1384 
1385         while (primaryTodo.nonEmpty() || secondaryTodo.nonEmpty()) {
1386             try {
1387                 ModuleSymbol current;
1388                 boolean isPrimaryTodo;
1389                 if (primaryTodo.nonEmpty()) {
1390                     current = primaryTodo.head;
1391                     primaryTodo = primaryTodo.tail;
1392                     isPrimaryTodo = true;
1393                 } else {
1394                     current = secondaryTodo.head;
1395                     secondaryTodo = secondaryTodo.tail;
1396                     isPrimaryTodo = false;
1397                 }
1398                 if (observable != null &amp;&amp; !observable.contains(current))
1399                     continue;
1400                 if (!result.add(current) || current == syms.unnamedModule || ((current.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0))
1401                     continue;
1402                 current.complete();
1403                 if (current.kind == ERR &amp;&amp; (isPrimaryTodo || base.contains(current)) &amp;&amp; warnedMissing.add(current)) {
1404                     log.error(Errors.ModuleNotFound(current));
1405                 }
1406                 for (RequiresDirective rd : current.requires) {
1407                     if (rd.module == syms.java_base) continue;
1408                     if ((rd.isTransitive() &amp;&amp; isPrimaryTodo) || rootModules.contains(current)) {
1409                         primaryTodo = primaryTodo.prepend(rd.module);
1410                     } else {
1411                         secondaryTodo = secondaryTodo.prepend(rd.module);
1412                     }
1413                 }
1414             } catch (CompletionFailure ex) {
1415                 chk.completionError(null, ex);
1416             }
1417         }
1418 
1419         return result;
1420     }
1421 
1422     public ModuleSymbol getObservableModule(Name name) {
1423         ModuleSymbol mod = syms.getModule(name);
1424 
1425         if (allModules().contains(mod)) {
1426             return mod;
1427         }
1428 
1429         return null;
1430     }
1431 
1432     private Completer getUnnamedModuleCompleter() {
1433         moduleFinder.findAllModules();
1434         return new Symbol.Completer() {
1435             @Override
1436             public void complete(Symbol sym) throws CompletionFailure {
1437                 if (inInitModules) {
1438                     sym.completer = this;
1439                     return ;
1440                 }
1441                 ModuleSymbol msym = (ModuleSymbol) sym;
1442                 Set&lt;ModuleSymbol&gt; allModules = new HashSet&lt;&gt;(allModules());
1443                 allModules.remove(syms.unnamedModule);
1444                 for (ModuleSymbol m : allModules) {
1445                     m.complete();
1446                 }
1447                 initVisiblePackages(msym, allModules);
1448             }
1449 
1450             @Override
1451             public String toString() {
1452                 return &quot;unnamedModule Completer&quot;;
1453             }
1454         };
1455     }
1456 
1457     private final Map&lt;ModuleSymbol, Set&lt;ModuleSymbol&gt;&gt; requiresTransitiveCache = new HashMap&lt;&gt;();
1458 
1459     private void completeModule(ModuleSymbol msym) {
1460         if (inInitModules) {
1461             msym.completer = sym -&gt; completeModule(msym);
1462             return ;
1463         }
1464 
1465         if ((msym.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0) {
1466             completeAutomaticModule(msym);
1467         }
1468 
1469         Assert.checkNonNull(msym.requires);
1470 
1471         initAddReads();
1472 
1473         msym.requires = msym.requires.appendList(List.from(addReads.getOrDefault(msym, Collections.emptySet())));
1474 
1475         List&lt;RequiresDirective&gt; requires = msym.requires;
1476 
1477         while (requires.nonEmpty()) {
1478             if (!allModules().contains(requires.head.module)) {
1479                 Env&lt;AttrContext&gt; env = typeEnvs.get(msym);
1480                 if (env != null) {
1481                     JavaFileObject origSource = log.useSource(env.toplevel.sourcefile);
1482                     try {
1483                         log.error(/*XXX*/env.tree, Errors.ModuleNotFound(requires.head.module));
1484                     } finally {
1485                         log.useSource(origSource);
1486                     }
1487                 } else {
1488                     Assert.check((msym.flags() &amp; Flags.AUTOMATIC_MODULE) == 0);
1489                 }
1490                 msym.requires = List.filter(msym.requires, requires.head);
1491             }
1492             requires = requires.tail;
1493         }
1494 
1495         Set&lt;ModuleSymbol&gt; readable = new LinkedHashSet&lt;&gt;();
1496         Set&lt;ModuleSymbol&gt; requiresTransitive = new HashSet&lt;&gt;();
1497 
1498         for (RequiresDirective d : msym.requires) {
1499             d.module.complete();
1500             readable.add(d.module);
1501             Set&lt;ModuleSymbol&gt; s = retrieveRequiresTransitive(d.module);
1502             Assert.checkNonNull(s, () -&gt; &quot;no entry in cache for &quot; + d.module);
1503             readable.addAll(s);
1504             if (d.flags.contains(RequiresFlag.TRANSITIVE)) {
1505                 requiresTransitive.add(d.module);
1506                 requiresTransitive.addAll(s);
1507             }
1508         }
1509 
1510         requiresTransitiveCache.put(msym, requiresTransitive);
1511         initVisiblePackages(msym, readable);
1512         for (ExportsDirective d: msym.exports) {
1513             if (d.packge != null) {
1514                 d.packge.modle = msym;
1515             }
1516         }
1517     }
1518 
1519     private Set&lt;ModuleSymbol&gt; retrieveRequiresTransitive(ModuleSymbol msym) {
1520         Set&lt;ModuleSymbol&gt; requiresTransitive = requiresTransitiveCache.get(msym);
1521 
1522         if (requiresTransitive == null) {
1523             //the module graph may contain cycles involving automatic modules or --add-reads edges
1524             requiresTransitive = new HashSet&lt;&gt;();
1525 
1526             Set&lt;ModuleSymbol&gt; seen = new HashSet&lt;&gt;();
1527             List&lt;ModuleSymbol&gt; todo = List.of(msym);
1528 
1529             while (todo.nonEmpty()) {
1530                 ModuleSymbol current = todo.head;
1531                 todo = todo.tail;
1532                 if (!seen.add(current))
1533                     continue;
1534                 requiresTransitive.add(current);
1535                 current.complete();
1536                 Iterable&lt;? extends RequiresDirective&gt; requires;
1537                 if (current != syms.unnamedModule) {
1538                     Assert.checkNonNull(current.requires, () -&gt; current + &quot;.requires == null; &quot; + msym);
1539                     requires = current.requires;
1540                     for (RequiresDirective rd : requires) {
1541                         if (rd.isTransitive())
1542                             todo = todo.prepend(rd.module);
1543                     }
1544                 } else {
1545                     for (ModuleSymbol mod : allModules()) {
1546                         todo = todo.prepend(mod);
1547                     }
1548                 }
1549             }
1550 
1551             requiresTransitive.remove(msym);
1552         }
1553 
1554         return requiresTransitive;
1555     }
1556 
1557     private void initVisiblePackages(ModuleSymbol msym, Collection&lt;ModuleSymbol&gt; readable) {
1558         initAddExports();
1559 
1560         msym.visiblePackages = new LinkedHashMap&lt;&gt;();
1561         msym.readModules = new HashSet&lt;&gt;(readable);
1562 
1563         Map&lt;Name, ModuleSymbol&gt; seen = new HashMap&lt;&gt;();
1564 
1565         for (ModuleSymbol rm : readable) {
1566             if (rm == syms.unnamedModule)
1567                 continue;
1568             addVisiblePackages(msym, seen, rm, rm.exports);
1569         }
1570 
1571         addExports.forEach((exportsFrom, exports) -&gt; {
1572             if (msym.readModules.contains(exportsFrom)) {
1573                 addVisiblePackages(msym, seen, exportsFrom, exports);
1574             }
1575         });
1576     }
1577 
1578     private void addVisiblePackages(ModuleSymbol msym,
1579                                     Map&lt;Name, ModuleSymbol&gt; seenPackages,
1580                                     ModuleSymbol exportsFrom,
1581                                     Collection&lt;ExportsDirective&gt; exports) {
1582         for (ExportsDirective d : exports) {
1583             if (d.modules == null || d.modules.contains(msym)) {
1584                 Name packageName = d.packge.fullname;
1585                 ModuleSymbol previousModule = seenPackages.get(packageName);
1586 
1587                 if (previousModule != null &amp;&amp; previousModule != exportsFrom) {
1588                     Env&lt;AttrContext&gt; env = typeEnvs.get(msym);
1589                     JavaFileObject origSource = env != null ? log.useSource(env.toplevel.sourcefile)
1590                                                             : null;
1591                     DiagnosticPosition pos = env != null ? env.tree.pos() : null;
1592                     try {
1593                         if (msym.isUnnamed()) {
1594                             log.error(pos, Errors.PackageClashFromRequiresInUnnamed(packageName,
1595                                                                                     previousModule, exportsFrom));
1596                         } else {
1597                             log.error(pos, Errors.PackageClashFromRequires(msym, packageName,
1598                                                                            previousModule, exportsFrom));
1599                         }
1600                     } finally {
1601                         if (env != null)
1602                             log.useSource(origSource);
1603                     }
1604                     continue;
1605                 }
1606 
1607                 seenPackages.put(packageName, exportsFrom);
1608                 msym.visiblePackages.put(d.packge.fullname, d.packge);
1609             }
1610         }
1611     }
1612 
1613     private void initAddExports() {
1614         if (addExports != null)
1615             return;
1616 
1617         addExports = new LinkedHashMap&lt;&gt;();
1618         Set&lt;ModuleSymbol&gt; unknownModules = new HashSet&lt;&gt;();
1619 
1620         if (addExportsOpt == null)
1621             return;
1622 
1623         Pattern ep = Pattern.compile(&quot;([^/]+)/([^=]+)=(.*)&quot;);
1624         for (String s: addExportsOpt.split(&quot;\0+&quot;)) {
1625             if (s.isEmpty())
1626                 continue;
1627             Matcher em = ep.matcher(s);
1628             if (!em.matches()) {
1629                 continue;
1630             }
1631 
1632             // Terminology comes from
1633             //  --add-exports module/package=target,...
1634             // Compare to
1635             //  module module { exports package to target, ... }
1636             String moduleName = em.group(1);
1637             String packageName = em.group(2);
1638             String targetNames = em.group(3);
1639 
1640             if (!isValidName(moduleName))
1641                 continue;
1642 
1643             ModuleSymbol msym = syms.enterModule(names.fromString(moduleName));
1644             if (!isKnownModule(msym, unknownModules))
1645                 continue;
1646 
1647             if (!isValidName(packageName))
1648                 continue;
1649 
1650             if (!allowAccessIntoSystem &amp;&amp; (msym.flags() &amp; Flags.SYSTEM_MODULE) != 0) {
1651                 log.error(Errors.AddExportsWithRelease(msym));
1652                 continue;
1653             }
1654 
1655             PackageSymbol p = syms.enterPackage(msym, names.fromString(packageName));
1656             p.modle = msym;  // TODO: do we need this?
1657 
1658             List&lt;ModuleSymbol&gt; targetModules = List.nil();
1659             for (String toModule : targetNames.split(&quot;[ ,]+&quot;)) {
1660                 ModuleSymbol m;
1661                 if (toModule.equals(&quot;ALL-UNNAMED&quot;)) {
1662                     m = syms.unnamedModule;
1663                 } else {
1664                     if (!isValidName(toModule))
1665                         continue;
1666                     m = syms.enterModule(names.fromString(toModule));
1667                     if (!isKnownModule(m, unknownModules))
1668                         continue;
1669                 }
1670                 targetModules = targetModules.prepend(m);
1671             }
1672 
1673             Set&lt;ExportsDirective&gt; extra = addExports.computeIfAbsent(msym, _x -&gt; new LinkedHashSet&lt;&gt;());
1674             ExportsDirective d = new ExportsDirective(p, targetModules);
1675             extra.add(d);
1676         }
1677     }
1678 
1679     private boolean isKnownModule(ModuleSymbol msym, Set&lt;ModuleSymbol&gt; unknownModules) {
1680         if (allModules.contains(msym)) {
1681             return true;
1682         }
1683 
1684         if (!unknownModules.contains(msym)) {
1685             if (lintOptions) {
1686                 log.warning(LintCategory.OPTIONS,
1687                         Warnings.ModuleForOptionNotFound(Option.ADD_EXPORTS, msym));
1688             }
1689             unknownModules.add(msym);
1690         }
1691         return false;
1692     }
1693 
1694     private void initAddReads() {
1695         if (addReads != null)
1696             return;
1697 
1698         addReads = new LinkedHashMap&lt;&gt;();
1699 
1700         if (addReadsOpt == null)
1701             return;
1702 
1703         Pattern rp = Pattern.compile(&quot;([^=]+)=(.*)&quot;);
1704         for (String s : addReadsOpt.split(&quot;\0+&quot;)) {
1705             if (s.isEmpty())
1706                 continue;
1707             Matcher rm = rp.matcher(s);
1708             if (!rm.matches()) {
1709                 continue;
1710             }
1711 
1712             // Terminology comes from
1713             //  --add-reads source-module=target-module,...
1714             // Compare to
1715             //  module source-module { requires target-module; ... }
1716             String sourceName = rm.group(1);
1717             String targetNames = rm.group(2);
1718 
1719             if (!isValidName(sourceName))
1720                 continue;
1721 
1722             ModuleSymbol msym = syms.enterModule(names.fromString(sourceName));
1723             if (!allModules.contains(msym)) {
1724                 if (lintOptions) {
1725                     log.warning(Warnings.ModuleForOptionNotFound(Option.ADD_READS, msym));
1726                 }
1727                 continue;
1728             }
1729 
1730             if (!allowAccessIntoSystem &amp;&amp; (msym.flags() &amp; Flags.SYSTEM_MODULE) != 0) {
1731                 log.error(Errors.AddReadsWithRelease(msym));
1732                 continue;
1733             }
1734 
1735             for (String targetName : targetNames.split(&quot;[ ,]+&quot;, -1)) {
1736                 ModuleSymbol targetModule;
1737                 if (targetName.equals(&quot;ALL-UNNAMED&quot;)) {
1738                     targetModule = syms.unnamedModule;
1739                 } else {
1740                     if (!isValidName(targetName))
1741                         continue;
1742                     targetModule = syms.enterModule(names.fromString(targetName));
1743                     if (!allModules.contains(targetModule)) {
1744                         if (lintOptions) {
1745                             log.warning(LintCategory.OPTIONS, Warnings.ModuleForOptionNotFound(Option.ADD_READS, targetModule));
1746                         }
1747                         continue;
1748                     }
1749                 }
1750                 addReads.computeIfAbsent(msym, m -&gt; new HashSet&lt;&gt;())
1751                         .add(new RequiresDirective(targetModule, EnumSet.of(RequiresFlag.EXTRA)));
1752             }
1753         }
1754     }
1755 
1756     private void checkCyclicDependencies(JCModuleDecl mod) {
1757         for (JCDirective d : mod.directives) {
1758             JCRequires rd;
1759             if (!d.hasTag(Tag.REQUIRES) || (rd = (JCRequires) d).directive == null)
1760                 continue;
1761             Set&lt;ModuleSymbol&gt; nonSyntheticDeps = new HashSet&lt;&gt;();
1762             List&lt;ModuleSymbol&gt; queue = List.of(rd.directive.module);
1763             while (queue.nonEmpty()) {
1764                 ModuleSymbol current = queue.head;
1765                 queue = queue.tail;
1766                 if (!nonSyntheticDeps.add(current))
1767                     continue;
1768                 current.complete();
1769                 if ((current.flags() &amp; Flags.AUTOMATIC_MODULE) != 0)
1770                     continue;
1771                 Assert.checkNonNull(current.requires, current::toString);
1772                 for (RequiresDirective dep : current.requires) {
1773                     if (!dep.flags.contains(RequiresFlag.EXTRA))
1774                         queue = queue.prepend(dep.module);
1775                 }
1776             }
1777             if (nonSyntheticDeps.contains(mod.sym)) {
1778                 log.error(rd.moduleName.pos(), Errors.CyclicRequires(rd.directive.module));
1779             }
1780         }
1781     }
1782 
1783     private boolean isValidName(CharSequence name) {
1784         return SourceVersion.isName(name, Source.toSourceVersion(source));
1785     }
1786 
1787     // DEBUG
1788     private String toString(ModuleSymbol msym) {
1789         return msym.name + &quot;[&quot;
1790                 + &quot;kind:&quot; + msym.kind + &quot;;&quot;
1791                 + &quot;locn:&quot; + toString(msym.sourceLocation) + &quot;,&quot; + toString(msym.classLocation) + &quot;;&quot;
1792                 + &quot;info:&quot; + toString(msym.module_info.sourcefile) + &quot;,&quot;
1793                             + toString(msym.module_info.classfile) + &quot;,&quot;
1794                             + msym.module_info.completer
1795                 + &quot;]&quot;;
1796     }
1797 
1798     // DEBUG
1799     String toString(Location locn) {
1800         return (locn == null) ? &quot;--&quot; : locn.getName();
1801     }
1802 
1803     // DEBUG
1804     String toString(JavaFileObject fo) {
1805         return (fo == null) ? &quot;--&quot; : fo.getName();
1806     }
1807 
1808     public void newRound() {
1809         allModules = null;
1810         rootModules = null;
1811         defaultModule = null;
1812         warnedMissing.clear();
1813     }
1814 
1815     public interface PackageNameFinder {
1816         public Name findPackageNameOf(JavaFileObject jfo);
1817     }
1818 }
    </pre>
  </body>
</html>
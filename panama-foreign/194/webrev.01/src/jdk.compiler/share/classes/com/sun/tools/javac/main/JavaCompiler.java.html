<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/main/JavaCompiler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.main;
  27 
  28 import java.io.*;
  29 import java.util.Collection;
  30 import java.util.Collections;
  31 import java.util.HashMap;
  32 import java.util.HashSet;
  33 import java.util.LinkedHashMap;
  34 import java.util.LinkedHashSet;
  35 import java.util.Map;
  36 import java.util.MissingResourceException;
  37 import java.util.Queue;
  38 import java.util.ResourceBundle;
  39 import java.util.Set;
  40 import java.util.function.Function;
  41 
  42 import javax.annotation.processing.Processor;
  43 import javax.lang.model.SourceVersion;
  44 import javax.lang.model.element.ElementVisitor;
  45 import javax.tools.DiagnosticListener;
  46 import javax.tools.JavaFileManager;
  47 import javax.tools.JavaFileObject;
  48 import javax.tools.JavaFileObject.Kind;
  49 import javax.tools.StandardLocation;
  50 
  51 import com.sun.source.util.TaskEvent;
  52 import com.sun.tools.javac.api.MultiTaskListener;
  53 import com.sun.tools.javac.code.*;
  54 import com.sun.tools.javac.code.Lint.LintCategory;
  55 import com.sun.tools.javac.code.Source.Feature;
  56 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  57 import com.sun.tools.javac.code.Symbol.CompletionFailure;
  58 import com.sun.tools.javac.code.Symbol.PackageSymbol;
  59 import com.sun.tools.javac.comp.*;
  60 import com.sun.tools.javac.comp.CompileStates.CompileState;
  61 import com.sun.tools.javac.file.JavacFileManager;
  62 import com.sun.tools.javac.jvm.*;
  63 import com.sun.tools.javac.parser.*;
  64 import com.sun.tools.javac.platform.PlatformDescription;
  65 import com.sun.tools.javac.processing.*;
  66 import com.sun.tools.javac.tree.*;
  67 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
  68 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
  69 import com.sun.tools.javac.tree.JCTree.JCExpression;
  70 import com.sun.tools.javac.tree.JCTree.JCLambda;
  71 import com.sun.tools.javac.tree.JCTree.JCMemberReference;
  72 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
  73 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
  74 import com.sun.tools.javac.util.*;
  75 import com.sun.tools.javac.util.DefinedBy.Api;
  76 import com.sun.tools.javac.util.JCDiagnostic.Factory;
  77 import com.sun.tools.javac.util.Log.DiagnosticHandler;
  78 import com.sun.tools.javac.util.Log.DiscardDiagnosticHandler;
  79 import com.sun.tools.javac.util.Log.WriterKind;
  80 
  81 import static com.sun.tools.javac.code.Kinds.Kind.*;
  82 
  83 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  84 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  85 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  86 import com.sun.tools.javac.resources.CompilerProperties.Notes;
  87 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  88 
  89 import static com.sun.tools.javac.code.TypeTag.CLASS;
  90 import static com.sun.tools.javac.main.Option.*;
  91 import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag.*;
  92 
  93 import static javax.tools.StandardLocation.CLASS_OUTPUT;
  94 
  95 import com.sun.tools.javac.tree.JCTree.JCModuleDecl;
  96 
  97 /** This class could be the main entry point for GJC when GJC is used as a
  98  *  component in a larger software system. It provides operations to
  99  *  construct a new compiler, and to run a new compiler on a set of source
 100  *  files.
 101  *
 102  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 103  *  If you write code that depends on this, you do so at your own risk.
 104  *  This code and its internal interfaces are subject to change or
 105  *  deletion without notice.&lt;/b&gt;
 106  */
 107 public class JavaCompiler {
 108     /** The context key for the compiler. */
 109     public static final Context.Key&lt;JavaCompiler&gt; compilerKey = new Context.Key&lt;&gt;();
 110 
 111     /** Get the JavaCompiler instance for this context. */
 112     public static JavaCompiler instance(Context context) {
 113         JavaCompiler instance = context.get(compilerKey);
 114         if (instance == null)
 115             instance = new JavaCompiler(context);
 116         return instance;
 117     }
 118 
 119     /** The current version number as a string.
 120      */
 121     public static String version() {
 122         return version(&quot;release&quot;);  // mm.nn.oo[-milestone]
 123     }
 124 
 125     /** The current full version number as a string.
 126      */
 127     public static String fullVersion() {
 128         return version(&quot;full&quot;); // mm.mm.oo[-milestone]-build
 129     }
 130 
 131     private static final String versionRBName = &quot;com.sun.tools.javac.resources.version&quot;;
 132     private static ResourceBundle versionRB;
 133 
 134     private static String version(String key) {
 135         if (versionRB == null) {
 136             try {
 137                 versionRB = ResourceBundle.getBundle(versionRBName);
 138             } catch (MissingResourceException e) {
 139                 return Log.getLocalizedString(&quot;version.not.available&quot;);
 140             }
 141         }
 142         try {
 143             return versionRB.getString(key);
 144         }
 145         catch (MissingResourceException e) {
 146             return Log.getLocalizedString(&quot;version.not.available&quot;);
 147         }
 148     }
 149 
 150     /**
 151      * Control how the compiler&#39;s latter phases (attr, flow, desugar, generate)
 152      * are connected. Each individual file is processed by each phase in turn,
 153      * but with different compile policies, you can control the order in which
 154      * each class is processed through its next phase.
 155      *
 156      * &lt;p&gt;Generally speaking, the compiler will &quot;fail fast&quot; in the face of
 157      * errors, although not aggressively so. flow, desugar, etc become no-ops
 158      * once any errors have occurred. No attempt is currently made to determine
 159      * if it might be safe to process a class through its next phase because
 160      * it does not depend on any unrelated errors that might have occurred.
 161      */
 162     protected static enum CompilePolicy {
 163         /**
 164          * Just attribute the parse trees.
 165          */
 166         ATTR_ONLY,
 167 
 168         /**
 169          * Just attribute and do flow analysis on the parse trees.
 170          * This should catch most user errors.
 171          */
 172         CHECK_ONLY,
 173 
 174         /**
 175          * Attribute everything, then do flow analysis for everything,
 176          * then desugar everything, and only then generate output.
 177          * This means no output will be generated if there are any
 178          * errors in any classes.
 179          */
 180         SIMPLE,
 181 
 182         /**
 183          * Groups the classes for each source file together, then process
 184          * each group in a manner equivalent to the {@code SIMPLE} policy.
 185          * This means no output will be generated if there are any
 186          * errors in any of the classes in a source file.
 187          */
 188         BY_FILE,
 189 
 190         /**
 191          * Completely process each entry on the todo list in turn.
 192          * -- this is the same for 1.5.
 193          * Means output might be generated for some classes in a compilation unit
 194          * and not others.
 195          */
 196         BY_TODO;
 197 
 198         static CompilePolicy decode(String option) {
 199             if (option == null)
 200                 return DEFAULT_COMPILE_POLICY;
 201             else if (option.equals(&quot;attr&quot;))
 202                 return ATTR_ONLY;
 203             else if (option.equals(&quot;check&quot;))
 204                 return CHECK_ONLY;
 205             else if (option.equals(&quot;simple&quot;))
 206                 return SIMPLE;
 207             else if (option.equals(&quot;byfile&quot;))
 208                 return BY_FILE;
 209             else if (option.equals(&quot;bytodo&quot;))
 210                 return BY_TODO;
 211             else
 212                 return DEFAULT_COMPILE_POLICY;
 213         }
 214     }
 215 
 216     private static final CompilePolicy DEFAULT_COMPILE_POLICY = CompilePolicy.BY_TODO;
 217 
 218     protected static enum ImplicitSourcePolicy {
 219         /** Don&#39;t generate or process implicitly read source files. */
 220         NONE,
 221         /** Generate classes for implicitly read source files. */
 222         CLASS,
 223         /** Like CLASS, but generate warnings if annotation processing occurs */
 224         UNSET;
 225 
 226         static ImplicitSourcePolicy decode(String option) {
 227             if (option == null)
 228                 return UNSET;
 229             else if (option.equals(&quot;none&quot;))
 230                 return NONE;
 231             else if (option.equals(&quot;class&quot;))
 232                 return CLASS;
 233             else
 234                 return UNSET;
 235         }
 236     }
 237 
 238     /** The log to be used for error reporting.
 239      */
 240     public Log log;
 241 
 242     /** Factory for creating diagnostic objects
 243      */
 244     JCDiagnostic.Factory diagFactory;
 245 
 246     /** The tree factory module.
 247      */
 248     protected TreeMaker make;
 249 
 250     /** The class finder.
 251      */
 252     protected ClassFinder finder;
 253 
 254     /** The class reader.
 255      */
 256     protected ClassReader reader;
 257 
 258     /** The class writer.
 259      */
 260     protected ClassWriter writer;
 261 
 262     /** The native header writer.
 263      */
 264     protected JNIWriter jniWriter;
 265 
 266     /** The module for the symbol table entry phases.
 267      */
 268     protected Enter enter;
 269 
 270     /** The symbol table.
 271      */
 272     protected Symtab syms;
 273 
 274     /** The language version.
 275      */
 276     protected Source source;
 277 
 278     /** The preview language version.
 279      */
 280     protected Preview preview;
 281 
 282     /** The module for code generation.
 283      */
 284     protected Gen gen;
 285 
 286     /** The name table.
 287      */
 288     protected Names names;
 289 
 290     /** The attributor.
 291      */
 292     protected Attr attr;
 293 
 294     /** The analyzer
 295      */
 296     protected Analyzer analyzer;
 297 
 298     /** The attributor.
 299      */
 300     protected Check chk;
 301 
 302     /** The flow analyzer.
 303      */
 304     protected Flow flow;
 305 
 306     /** The modules visitor
 307      */
 308     protected Modules modules;
 309 
 310     /** The module finder
 311      */
 312     protected ModuleFinder moduleFinder;
 313 
 314     /** The diagnostics factory
 315      */
 316     protected JCDiagnostic.Factory diags;
 317 
 318     protected DeferredCompletionFailureHandler dcfh;
 319 
 320     /** The type eraser.
 321      */
 322     protected TransTypes transTypes;
 323 
 324     /** The syntactic sugar desweetener.
 325      */
 326     protected Lower lower;
 327 
 328     /** The annotation annotator.
 329      */
 330     protected Annotate annotate;
 331 
 332     /** Force a completion failure on this name
 333      */
 334     protected final Name completionFailureName;
 335 
 336     /** Type utilities.
 337      */
 338     protected Types types;
 339 
 340     /** Access to file objects.
 341      */
 342     protected JavaFileManager fileManager;
 343 
 344     /** Factory for parsers.
 345      */
 346     protected ParserFactory parserFactory;
 347 
 348     /** Broadcasting listener for progress events
 349      */
 350     protected MultiTaskListener taskListener;
 351 
 352     /**
 353      * SourceCompleter that delegates to the readSourceFile method of this class.
 354      */
 355     protected final Symbol.Completer sourceCompleter =
 356             sym -&gt; readSourceFile((ClassSymbol) sym);
 357 
 358     /**
 359      * Command line options.
 360      */
 361     protected Options options;
 362 
 363     protected Context context;
 364 
 365     /**
 366      * Flag set if any annotation processing occurred.
 367      **/
 368     protected boolean annotationProcessingOccurred;
 369 
 370     /**
 371      * Flag set if any implicit source files read.
 372      **/
 373     protected boolean implicitSourceFilesRead;
 374 
 375     private boolean enterDone;
 376 
 377     protected CompileStates compileStates;
 378 
 379     /** Construct a new compiler using a shared context.
 380      */
 381     public JavaCompiler(Context context) {
 382         this.context = context;
 383         context.put(compilerKey, this);
 384 
 385         // if fileManager not already set, register the JavacFileManager to be used
 386         if (context.get(JavaFileManager.class) == null)
 387             JavacFileManager.preRegister(context);
 388 
 389         names = Names.instance(context);
 390         log = Log.instance(context);
 391         diagFactory = JCDiagnostic.Factory.instance(context);
 392         finder = ClassFinder.instance(context);
 393         reader = ClassReader.instance(context);
 394         make = TreeMaker.instance(context);
 395         writer = ClassWriter.instance(context);
 396         jniWriter = JNIWriter.instance(context);
 397         enter = Enter.instance(context);
 398         todo = Todo.instance(context);
 399 
 400         fileManager = context.get(JavaFileManager.class);
 401         parserFactory = ParserFactory.instance(context);
 402         compileStates = CompileStates.instance(context);
 403 
 404         try {
 405             // catch completion problems with predefineds
 406             syms = Symtab.instance(context);
 407         } catch (CompletionFailure ex) {
 408             // inlined Check.completionError as it is not initialized yet
 409             log.error(Errors.CantAccess(ex.sym, ex.getDetailValue()));
 410         }
 411         source = Source.instance(context);
 412         preview = Preview.instance(context);
 413         attr = Attr.instance(context);
 414         analyzer = Analyzer.instance(context);
 415         chk = Check.instance(context);
 416         gen = Gen.instance(context);
 417         flow = Flow.instance(context);
 418         transTypes = TransTypes.instance(context);
 419         lower = Lower.instance(context);
 420         annotate = Annotate.instance(context);
 421         types = Types.instance(context);
 422         taskListener = MultiTaskListener.instance(context);
 423         modules = Modules.instance(context);
 424         moduleFinder = ModuleFinder.instance(context);
 425         diags = Factory.instance(context);
 426         dcfh = DeferredCompletionFailureHandler.instance(context);
 427 
 428         finder.sourceCompleter = sourceCompleter;
 429         modules.findPackageInFile = this::findPackageInFile;
 430         moduleFinder.moduleNameFromSourceReader = this::readModuleName;
 431 
 432         options = Options.instance(context);
 433 
 434         verbose       = options.isSet(VERBOSE);
 435         sourceOutput  = options.isSet(PRINTSOURCE); // used to be -s
 436         lineDebugInfo = options.isUnset(G_CUSTOM) ||
 437                         options.isSet(G_CUSTOM, &quot;lines&quot;);
 438         genEndPos     = options.isSet(XJCOV) ||
 439                         context.get(DiagnosticListener.class) != null;
 440         devVerbose    = options.isSet(&quot;dev&quot;);
 441         processPcks   = options.isSet(&quot;process.packages&quot;);
 442         werror        = options.isSet(WERROR);
 443 
 444         verboseCompilePolicy = options.isSet(&quot;verboseCompilePolicy&quot;);
 445 
 446         if (options.isSet(&quot;should-stop.at&quot;) &amp;&amp;
 447             CompileState.valueOf(options.get(&quot;should-stop.at&quot;)) == CompileState.ATTR)
 448             compilePolicy = CompilePolicy.ATTR_ONLY;
 449         else
 450             compilePolicy = CompilePolicy.decode(options.get(&quot;compilePolicy&quot;));
 451 
 452         implicitSourcePolicy = ImplicitSourcePolicy.decode(options.get(&quot;-implicit&quot;));
 453 
 454         completionFailureName =
 455             options.isSet(&quot;failcomplete&quot;)
 456             ? names.fromString(options.get(&quot;failcomplete&quot;))
 457             : null;
 458 
 459         shouldStopPolicyIfError =
 460             options.isSet(&quot;should-stop.at&quot;) // backwards compatible
 461             ? CompileState.valueOf(options.get(&quot;should-stop.at&quot;))
 462             : options.isSet(&quot;should-stop.ifError&quot;)
 463             ? CompileState.valueOf(options.get(&quot;should-stop.ifError&quot;))
 464             : CompileState.INIT;
 465         shouldStopPolicyIfNoError =
 466             options.isSet(&quot;should-stop.ifNoError&quot;)
 467             ? CompileState.valueOf(options.get(&quot;should-stop.ifNoError&quot;))
 468             : CompileState.GENERATE;
 469 
 470         if (options.isUnset(&quot;diags.legacy&quot;))
 471             log.setDiagnosticFormatter(RichDiagnosticFormatter.instance(context));
 472 
 473         PlatformDescription platformProvider = context.get(PlatformDescription.class);
 474 
 475         if (platformProvider != null)
 476             closeables = closeables.prepend(platformProvider);
 477 
 478         silentFail = new Symbol(ABSENT_TYP, 0, names.empty, Type.noType, syms.rootPackage) {
 479             @DefinedBy(Api.LANGUAGE_MODEL)
 480             public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
 481                 return v.visitUnknown(this, p);
 482             }
 483             @Override
 484             public boolean exists() {
 485                 return false;
 486             }
 487         };
 488 
 489     }
 490 
 491     /* Switches:
 492      */
 493 
 494     /** Verbose output.
 495      */
 496     public boolean verbose;
 497 
 498     /** Emit plain Java source files rather than class files.
 499      */
 500     public boolean sourceOutput;
 501 
 502 
 503     /** Generate code with the LineNumberTable attribute for debugging
 504      */
 505     public boolean lineDebugInfo;
 506 
 507     /** Switch: should we store the ending positions?
 508      */
 509     public boolean genEndPos;
 510 
 511     /** Switch: should we debug ignored exceptions
 512      */
 513     protected boolean devVerbose;
 514 
 515     /** Switch: should we (annotation) process packages as well
 516      */
 517     protected boolean processPcks;
 518 
 519     /** Switch: treat warnings as errors
 520      */
 521     protected boolean werror;
 522 
 523     /** Switch: is annotation processing requested explicitly via
 524      * CompilationTask.setProcessors?
 525      */
 526     protected boolean explicitAnnotationProcessingRequested = false;
 527 
 528     /**
 529      * The policy for the order in which to perform the compilation
 530      */
 531     protected CompilePolicy compilePolicy;
 532 
 533     /**
 534      * The policy for what to do with implicitly read source files
 535      */
 536     protected ImplicitSourcePolicy implicitSourcePolicy;
 537 
 538     /**
 539      * Report activity related to compilePolicy
 540      */
 541     public boolean verboseCompilePolicy;
 542 
 543     /**
 544      * Policy of how far to continue compilation after errors have occurred.
 545      * Set this to minimum CompileState (INIT) to stop as soon as possible
 546      * after errors.
 547      */
 548     public CompileState shouldStopPolicyIfError;
 549 
 550     /**
 551      * Policy of how far to continue compilation when no errors have occurred.
 552      * Set this to maximum CompileState (GENERATE) to perform full compilation.
 553      * Set this lower to perform partial compilation, such as -proc:only.
 554      */
 555     public CompileState shouldStopPolicyIfNoError;
 556 
 557     /** A queue of all as yet unattributed classes.
 558      */
 559     public Todo todo;
 560 
 561     /** A list of items to be closed when the compilation is complete.
 562      */
 563     public List&lt;Closeable&gt; closeables = List.nil();
 564 
 565     /** The set of currently compiled inputfiles, needed to ensure
 566      *  we don&#39;t accidentally overwrite an input file when -s is set.
 567      *  initialized by `compile&#39;.
 568      */
 569     protected Set&lt;JavaFileObject&gt; inputFiles = new HashSet&lt;&gt;();
 570 
 571     /** Used by the resolveBinaryNameOrIdent to say that the given type cannot be found, and that
 572      *  an error has already been produced about that.
 573      */
 574     private final Symbol silentFail;
 575 
 576     protected boolean shouldStop(CompileState cs) {
 577         CompileState shouldStopPolicy = (errorCount() &gt; 0 || unrecoverableError())
 578             ? shouldStopPolicyIfError
 579             : shouldStopPolicyIfNoError;
 580         return cs.isAfter(shouldStopPolicy);
 581     }
 582 
 583     /** The number of errors reported so far.
 584      */
 585     public int errorCount() {
 586         if (werror &amp;&amp; log.nerrors == 0 &amp;&amp; log.nwarnings &gt; 0) {
 587             log.error(Errors.WarningsAndWerror);
 588         }
 589         return log.nerrors;
 590     }
 591 
 592     protected final &lt;T&gt; Queue&lt;T&gt; stopIfError(CompileState cs, Queue&lt;T&gt; queue) {
 593         return shouldStop(cs) ? new ListBuffer&lt;T&gt;() : queue;
 594     }
 595 
 596     protected final &lt;T&gt; List&lt;T&gt; stopIfError(CompileState cs, List&lt;T&gt; list) {
 597         return shouldStop(cs) ? List.nil() : list;
 598     }
 599 
 600     /** The number of warnings reported so far.
 601      */
 602     public int warningCount() {
 603         return log.nwarnings;
 604     }
 605 
 606     /** Try to open input stream with given name.
 607      *  Report an error if this fails.
 608      *  @param filename   The file name of the input stream to be opened.
 609      */
 610     public CharSequence readSource(JavaFileObject filename) {
 611         try {
 612             inputFiles.add(filename);
 613             return filename.getCharContent(false);
 614         } catch (IOException e) {
 615             log.error(Errors.ErrorReadingFile(filename, JavacFileManager.getMessage(e)));
 616             return null;
 617         }
 618     }
 619 
 620     /** Parse contents of input stream.
 621      *  @param filename     The name of the file from which input stream comes.
 622      *  @param content      The characters to be parsed.
 623      */
 624     protected JCCompilationUnit parse(JavaFileObject filename, CharSequence content) {
 625         long msec = now();
 626         JCCompilationUnit tree = make.TopLevel(List.nil());
 627         if (content != null) {
 628             if (verbose) {
 629                 log.printVerbose(&quot;parsing.started&quot;, filename);
 630             }
 631             if (!taskListener.isEmpty()) {
 632                 TaskEvent e = new TaskEvent(TaskEvent.Kind.PARSE, filename);
 633                 taskListener.started(e);
 634                 keepComments = true;
 635                 genEndPos = true;
 636             }
 637             Parser parser = parserFactory.newParser(content, keepComments(), genEndPos,
 638                                 lineDebugInfo, filename.isNameCompatible(&quot;module-info&quot;, Kind.SOURCE));
 639             tree = parser.parseCompilationUnit();
 640             if (verbose) {
 641                 log.printVerbose(&quot;parsing.done&quot;, Long.toString(elapsed(msec)));
 642             }
 643         }
 644 
 645         tree.sourcefile = filename;
 646 
 647         if (content != null &amp;&amp; !taskListener.isEmpty()) {
 648             TaskEvent e = new TaskEvent(TaskEvent.Kind.PARSE, tree);
 649             taskListener.finished(e);
 650         }
 651 
 652         return tree;
 653     }
 654     // where
 655         public boolean keepComments = false;
 656         protected boolean keepComments() {
 657             return keepComments || sourceOutput;
 658         }
 659 
 660 
 661     /** Parse contents of file.
 662      *  @param filename     The name of the file to be parsed.
 663      */
 664     @Deprecated
 665     public JCTree.JCCompilationUnit parse(String filename) {
 666         JavacFileManager fm = (JavacFileManager)fileManager;
 667         return parse(fm.getJavaFileObjectsFromStrings(List.of(filename)).iterator().next());
 668     }
 669 
 670     /** Parse contents of file.
 671      *  @param filename     The name of the file to be parsed.
 672      */
 673     public JCTree.JCCompilationUnit parse(JavaFileObject filename) {
 674         JavaFileObject prev = log.useSource(filename);
 675         try {
 676             JCTree.JCCompilationUnit t = parse(filename, readSource(filename));
 677             if (t.endPositions != null)
 678                 log.setEndPosTable(filename, t.endPositions);
 679             return t;
 680         } finally {
 681             log.useSource(prev);
 682         }
 683     }
 684 
 685     /** Resolve an identifier which may be the binary name of a class or
 686      * the Java name of a class or package.
 687      * @param name      The name to resolve
 688      */
 689     public Symbol resolveBinaryNameOrIdent(String name) {
 690         ModuleSymbol msym;
 691         String typeName;
 692         int sep = name.indexOf(&#39;/&#39;);
 693         if (sep == -1) {
 694             msym = modules.getDefaultModule();
 695             typeName = name;
 696         } else if (Feature.MODULES.allowedInSource(source)) {
 697             Name modName = names.fromString(name.substring(0, sep));
 698 
 699             msym = moduleFinder.findModule(modName);
 700             typeName = name.substring(sep + 1);
 701         } else {
 702             log.error(Errors.InvalidModuleSpecifier(name));
 703             return silentFail;
 704         }
 705 
 706         return resolveBinaryNameOrIdent(msym, typeName);
 707     }
 708 
 709     /** Resolve an identifier which may be the binary name of a class or
 710      * the Java name of a class or package.
 711      * @param msym      The module in which the search should be performed
 712      * @param name      The name to resolve
 713      */
 714     public Symbol resolveBinaryNameOrIdent(ModuleSymbol msym, String name) {
 715         try {
 716             Name flatname = names.fromString(name.replace(&quot;/&quot;, &quot;.&quot;));
 717             return finder.loadClass(msym, flatname);
 718         } catch (CompletionFailure ignore) {
 719             return resolveIdent(msym, name);
 720         }
 721     }
 722 
 723     /** Resolve an identifier.
 724      * @param msym      The module in which the search should be performed
 725      * @param name      The identifier to resolve
 726      */
 727     public Symbol resolveIdent(ModuleSymbol msym, String name) {
 728         if (name.equals(&quot;&quot;))
 729             return syms.errSymbol;
 730         JavaFileObject prev = log.useSource(null);
 731         try {
 732             JCExpression tree = null;
 733             for (String s : name.split(&quot;\\.&quot;, -1)) {
 734                 if (!SourceVersion.isIdentifier(s)) // TODO: check for keywords
 735                     return syms.errSymbol;
 736                 tree = (tree == null) ? make.Ident(names.fromString(s))
 737                                       : make.Select(tree, names.fromString(s));
 738             }
 739             JCCompilationUnit toplevel =
 740                 make.TopLevel(List.nil());
 741             toplevel.modle = msym;
 742             toplevel.packge = msym.unnamedPackage;
 743             return attr.attribIdent(tree, toplevel);
 744         } finally {
 745             log.useSource(prev);
 746         }
 747     }
 748 
 749     /** Generate code and emit a class file for a given class
 750      *  @param env    The attribution environment of the outermost class
 751      *                containing this class.
 752      *  @param cdef   The class definition from which code is generated.
 753      */
 754     JavaFileObject genCode(Env&lt;AttrContext&gt; env, JCClassDecl cdef) throws IOException {
 755         try {
 756             if (gen.genClass(env, cdef) &amp;&amp; (errorCount() == 0))
 757                 return writer.writeClass(cdef.sym);
 758         } catch (ClassWriter.PoolOverflow ex) {
 759             log.error(cdef.pos(), Errors.LimitPool);
 760         } catch (ClassWriter.StringOverflow ex) {
 761             log.error(cdef.pos(),
 762                       Errors.LimitStringOverflow(ex.value.substring(0, 20)));
 763         } catch (CompletionFailure ex) {
 764             chk.completionError(cdef.pos(), ex);
 765         }
 766         return null;
 767     }
 768 
 769     /** Emit plain Java source for a class.
 770      *  @param env    The attribution environment of the outermost class
 771      *                containing this class.
 772      *  @param cdef   The class definition to be printed.
 773      */
 774     JavaFileObject printSource(Env&lt;AttrContext&gt; env, JCClassDecl cdef) throws IOException {
 775         JavaFileObject outFile
 776            = fileManager.getJavaFileForOutput(CLASS_OUTPUT,
 777                                                cdef.sym.flatname.toString(),
 778                                                JavaFileObject.Kind.SOURCE,
 779                                                null);
 780         if (inputFiles.contains(outFile)) {
 781             log.error(cdef.pos(), Errors.SourceCantOverwriteInputFile(outFile));
 782             return null;
 783         } else {
 784             try (BufferedWriter out = new BufferedWriter(outFile.openWriter())) {
 785                 new Pretty(out, true).printUnit(env.toplevel, cdef);
 786                 if (verbose)
 787                     log.printVerbose(&quot;wrote.file&quot;, outFile.getName());
 788             }
 789             return outFile;
 790         }
 791     }
 792 
 793     /** Compile a source file that has been accessed by the class finder.
 794      *  @param c          The class the source file of which needs to be compiled.
 795      */
 796     private void readSourceFile(ClassSymbol c) throws CompletionFailure {
 797         readSourceFile(null, c);
 798     }
 799 
 800     /** Compile a ClassSymbol from source, optionally using the given compilation unit as
 801      *  the source tree.
 802      *  @param tree the compilation unit in which the given ClassSymbol resides,
 803      *              or null if should be parsed from source
 804      *  @param c    the ClassSymbol to complete
 805      */
 806     public void readSourceFile(JCCompilationUnit tree, ClassSymbol c) throws CompletionFailure {
 807         if (completionFailureName == c.fullname) {
 808             throw new CompletionFailure(
 809                 c, () -&gt; diagFactory.fragment(Fragments.UserSelectedCompletionFailure), dcfh);
 810         }
 811         JavaFileObject filename = c.classfile;
 812         JavaFileObject prev = log.useSource(filename);
 813 
 814         if (tree == null) {
 815             try {
 816                 tree = parse(filename, filename.getCharContent(false));
 817             } catch (IOException e) {
 818                 log.error(Errors.ErrorReadingFile(filename, JavacFileManager.getMessage(e)));
 819                 tree = make.TopLevel(List.&lt;JCTree&gt;nil());
 820             } finally {
 821                 log.useSource(prev);
 822             }
 823         }
 824 
 825         if (!taskListener.isEmpty()) {
 826             TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, tree);
 827             taskListener.started(e);
 828         }
 829 
 830         // Process module declarations.
 831         // If module resolution fails, ignore trees, and if trying to
 832         // complete a specific symbol, throw CompletionFailure.
 833         // Note that if module resolution failed, we may not even
 834         // have enough modules available to access java.lang, and
 835         // so risk getting FatalError(&quot;no.java.lang&quot;) from MemberEnter.
 836         if (!modules.enter(List.of(tree), c)) {
 837             throw new CompletionFailure(c, () -&gt; diags.fragment(Fragments.CantResolveModules), dcfh);
 838         }
 839 
 840         enter.complete(List.of(tree), c);
 841 
 842         if (!taskListener.isEmpty()) {
 843             TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, tree);
 844             taskListener.finished(e);
 845         }
 846 
 847         if (enter.getEnv(c) == null) {
 848             boolean isPkgInfo =
 849                 tree.sourcefile.isNameCompatible(&quot;package-info&quot;,
 850                                                  JavaFileObject.Kind.SOURCE);
 851             boolean isModuleInfo =
 852                 tree.sourcefile.isNameCompatible(&quot;module-info&quot;,
 853                                                  JavaFileObject.Kind.SOURCE);
 854             if (isModuleInfo) {
 855                 if (enter.getEnv(tree.modle) == null) {
 856                     JCDiagnostic diag =
 857                         diagFactory.fragment(Fragments.FileDoesNotContainModule);
 858                     throw new ClassFinder.BadClassFile(c, filename, diag, diagFactory, dcfh);
 859                 }
 860             } else if (isPkgInfo) {
 861                 if (enter.getEnv(tree.packge) == null) {
 862                     JCDiagnostic diag =
 863                         diagFactory.fragment(Fragments.FileDoesNotContainPackage(c.location()));
 864                     throw new ClassFinder.BadClassFile(c, filename, diag, diagFactory, dcfh);
 865                 }
 866             } else {
 867                 JCDiagnostic diag =
 868                         diagFactory.fragment(Fragments.FileDoesntContainClass(c.getQualifiedName()));
 869                 throw new ClassFinder.BadClassFile(c, filename, diag, diagFactory, dcfh);
 870             }
 871         }
 872 
 873         implicitSourceFilesRead = true;
 874     }
 875 
 876     /** Track when the JavaCompiler has been used to compile something. */
 877     private boolean hasBeenUsed = false;
 878     private long start_msec = 0;
 879     public long elapsed_msec = 0;
 880 
 881     public void compile(List&lt;JavaFileObject&gt; sourceFileObject)
 882         throws Throwable {
 883         compile(sourceFileObject, List.nil(), null, List.nil());
 884     }
 885 
 886     /**
 887      * Main method: compile a list of files, return all compiled classes
 888      *
 889      * @param sourceFileObjects file objects to be compiled
 890      * @param classnames class names to process for annotations
 891      * @param processors user provided annotation processors to bypass
 892      * discovery, {@code null} means that no processors were provided
 893      * @param addModules additional root modules to be used during
 894      * module resolution.
 895      */
 896     public void compile(Collection&lt;JavaFileObject&gt; sourceFileObjects,
 897                         Collection&lt;String&gt; classnames,
 898                         Iterable&lt;? extends Processor&gt; processors,
 899                         Collection&lt;String&gt; addModules)
 900     {
 901         if (!taskListener.isEmpty()) {
 902             taskListener.started(new TaskEvent(TaskEvent.Kind.COMPILATION));
 903         }
 904 
 905         if (processors != null &amp;&amp; processors.iterator().hasNext())
 906             explicitAnnotationProcessingRequested = true;
 907         // as a JavaCompiler can only be used once, throw an exception if
 908         // it has been used before.
 909         if (hasBeenUsed)
 910             checkReusable();
 911         hasBeenUsed = true;
 912 
 913         // forcibly set the equivalent of -Xlint:-options, so that no further
 914         // warnings about command line options are generated from this point on
 915         options.put(XLINT_CUSTOM.primaryName + &quot;-&quot; + LintCategory.OPTIONS.option, &quot;true&quot;);
 916         options.remove(XLINT_CUSTOM.primaryName + LintCategory.OPTIONS.option);
 917 
 918         start_msec = now();
 919 
 920         try {
 921             initProcessAnnotations(processors, sourceFileObjects, classnames);
 922 
 923             for (String className : classnames) {
 924                 int sep = className.indexOf(&#39;/&#39;);
 925                 if (sep != -1) {
 926                     modules.addExtraAddModules(className.substring(0, sep));
 927                 }
 928             }
 929 
 930             for (String moduleName : addModules) {
 931                 modules.addExtraAddModules(moduleName);
 932             }
 933 
 934             // These method calls must be chained to avoid memory leaks
 935             processAnnotations(
 936                 enterTrees(
 937                         stopIfError(CompileState.ENTER,
 938                                 initModules(stopIfError(CompileState.ENTER, parseFiles(sourceFileObjects))))
 939                 ),
 940                 classnames
 941             );
 942 
 943             // If it&#39;s safe to do so, skip attr / flow / gen for implicit classes
 944             if (taskListener.isEmpty() &amp;&amp;
 945                     implicitSourcePolicy == ImplicitSourcePolicy.NONE) {
 946                 todo.retainFiles(inputFiles);
 947             }
 948 
 949             if (!CompileState.ATTR.isAfter(shouldStopPolicyIfNoError)) {
 950                 switch (compilePolicy) {
 951                 case ATTR_ONLY:
 952                     attribute(todo);
 953                     break;
 954 
 955                 case CHECK_ONLY:
 956                     flow(attribute(todo));
 957                     break;
 958 
 959                 case SIMPLE:
 960                     generate(desugar(flow(attribute(todo))));
 961                     break;
 962 
 963                 case BY_FILE: {
 964                         Queue&lt;Queue&lt;Env&lt;AttrContext&gt;&gt;&gt; q = todo.groupByFile();
 965                         while (!q.isEmpty() &amp;&amp; !shouldStop(CompileState.ATTR)) {
 966                             generate(desugar(flow(attribute(q.remove()))));
 967                         }
 968                     }
 969                     break;
 970 
 971                 case BY_TODO:
 972                     while (!todo.isEmpty())
 973                         generate(desugar(flow(attribute(todo.remove()))));
 974                     break;
 975 
 976                 default:
 977                     Assert.error(&quot;unknown compile policy&quot;);
 978                 }
 979             }
 980         } catch (Abort ex) {
 981             if (devVerbose)
 982                 ex.printStackTrace(System.err);
 983         } finally {
 984             if (verbose) {
 985                 elapsed_msec = elapsed(start_msec);
 986                 log.printVerbose(&quot;total&quot;, Long.toString(elapsed_msec));
 987             }
 988 
 989             reportDeferredDiagnostics();
 990 
 991             if (!log.hasDiagnosticListener()) {
 992                 printCount(&quot;error&quot;, errorCount());
 993                 printCount(&quot;warn&quot;, warningCount());
 994                 printSuppressedCount(errorCount(), log.nsuppressederrors, &quot;count.error.recompile&quot;);
 995                 printSuppressedCount(warningCount(), log.nsuppressedwarns, &quot;count.warn.recompile&quot;);
 996             }
 997             if (!taskListener.isEmpty()) {
 998                 taskListener.finished(new TaskEvent(TaskEvent.Kind.COMPILATION));
 999             }
1000             close();
1001             if (procEnvImpl != null)
1002                 procEnvImpl.close();
1003         }
1004     }
1005 
1006     protected void checkReusable() {
1007         throw new AssertionError(&quot;attempt to reuse JavaCompiler&quot;);
1008     }
1009 
1010     /**
1011      * The list of classes explicitly supplied on the command line for compilation.
1012      * Not always populated.
1013      */
1014     private List&lt;JCClassDecl&gt; rootClasses;
1015 
1016     /**
1017      * Parses a list of files.
1018      */
1019    public List&lt;JCCompilationUnit&gt; parseFiles(Iterable&lt;JavaFileObject&gt; fileObjects) {
1020        return parseFiles(fileObjects, false);
1021    }
1022 
1023    public List&lt;JCCompilationUnit&gt; parseFiles(Iterable&lt;JavaFileObject&gt; fileObjects, boolean force) {
1024        if (!force &amp;&amp; shouldStop(CompileState.PARSE))
1025            return List.nil();
1026 
1027         //parse all files
1028         ListBuffer&lt;JCCompilationUnit&gt; trees = new ListBuffer&lt;&gt;();
1029         Set&lt;JavaFileObject&gt; filesSoFar = new HashSet&lt;&gt;();
1030         for (JavaFileObject fileObject : fileObjects) {
1031             if (!filesSoFar.contains(fileObject)) {
1032                 filesSoFar.add(fileObject);
1033                 trees.append(parse(fileObject));
1034             }
1035         }
1036         return trees.toList();
1037     }
1038 
1039    /**
1040     * Returns true iff the compilation will continue after annotation processing
1041     * is done.
1042     */
1043     public boolean continueAfterProcessAnnotations() {
1044         return !shouldStop(CompileState.ATTR);
1045     }
1046 
1047     public List&lt;JCCompilationUnit&gt; initModules(List&lt;JCCompilationUnit&gt; roots) {
1048         modules.initModules(roots);
1049         if (roots.isEmpty()) {
1050             enterDone();
1051         }
1052         return roots;
1053     }
1054 
1055     /**
1056      * Enter the symbols found in a list of parse trees.
1057      * As a side-effect, this puts elements on the &quot;todo&quot; list.
1058      * Also stores a list of all top level classes in rootClasses.
1059      */
1060     public List&lt;JCCompilationUnit&gt; enterTrees(List&lt;JCCompilationUnit&gt; roots) {
1061         //enter symbols for all files
1062         if (!taskListener.isEmpty()) {
1063             for (JCCompilationUnit unit: roots) {
1064                 TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, unit);
1065                 taskListener.started(e);
1066             }
1067         }
1068 
1069         enter.main(roots);
1070 
1071         enterDone();
1072 
1073         if (!taskListener.isEmpty()) {
1074             for (JCCompilationUnit unit: roots) {
1075                 TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, unit);
1076                 taskListener.finished(e);
1077             }
1078         }
1079 
1080         // If generating source, or if tracking public apis,
1081         // then remember the classes declared in
1082         // the original compilation units listed on the command line.
1083         if (sourceOutput) {
1084             ListBuffer&lt;JCClassDecl&gt; cdefs = new ListBuffer&lt;&gt;();
1085             for (JCCompilationUnit unit : roots) {
1086                 for (List&lt;JCTree&gt; defs = unit.defs;
1087                      defs.nonEmpty();
1088                      defs = defs.tail) {
1089                     if (defs.head instanceof JCClassDecl)
1090                         cdefs.append((JCClassDecl)defs.head);
1091                 }
1092             }
1093             rootClasses = cdefs.toList();
1094         }
1095 
1096         // Ensure the input files have been recorded. Although this is normally
1097         // done by readSource, it may not have been done if the trees were read
1098         // in a prior round of annotation processing, and the trees have been
1099         // cleaned and are being reused.
1100         for (JCCompilationUnit unit : roots) {
1101             inputFiles.add(unit.sourcefile);
1102         }
1103 
1104         return roots;
1105     }
1106 
1107     /**
1108      * Set to true to enable skeleton annotation processing code.
1109      * Currently, we assume this variable will be replaced more
1110      * advanced logic to figure out if annotation processing is
1111      * needed.
1112      */
1113     boolean processAnnotations = false;
1114 
1115     Log.DeferredDiagnosticHandler deferredDiagnosticHandler;
1116 
1117     /**
1118      * Object to handle annotation processing.
1119      */
1120     private JavacProcessingEnvironment procEnvImpl = null;
1121 
1122     /**
1123      * Check if we should process annotations.
1124      * If so, and if no scanner is yet registered, then set up the DocCommentScanner
1125      * to catch doc comments, and set keepComments so the parser records them in
1126      * the compilation unit.
1127      *
1128      * @param processors user provided annotation processors to bypass
1129      * discovery, {@code null} means that no processors were provided
1130      */
1131     public void initProcessAnnotations(Iterable&lt;? extends Processor&gt; processors,
1132                                        Collection&lt;? extends JavaFileObject&gt; initialFiles,
1133                                        Collection&lt;String&gt; initialClassNames) {
1134         // Process annotations if processing is not disabled and there
1135         // is at least one Processor available.
1136         if (options.isSet(PROC, &quot;none&quot;)) {
1137             processAnnotations = false;
1138         } else if (procEnvImpl == null) {
1139             procEnvImpl = JavacProcessingEnvironment.instance(context);
1140             procEnvImpl.setProcessors(processors);
1141             processAnnotations = procEnvImpl.atLeastOneProcessor();
1142 
1143             if (processAnnotations) {
1144                 options.put(&quot;parameters&quot;, &quot;parameters&quot;);
1145                 reader.saveParameterNames = true;
1146                 keepComments = true;
1147                 genEndPos = true;
1148                 if (!taskListener.isEmpty())
1149                     taskListener.started(new TaskEvent(TaskEvent.Kind.ANNOTATION_PROCESSING));
1150                 deferredDiagnosticHandler = new Log.DeferredDiagnosticHandler(log);
1151                 procEnvImpl.getFiler().setInitialState(initialFiles, initialClassNames);
1152             } else { // free resources
1153                 procEnvImpl.close();
1154             }
1155         }
1156     }
1157 
1158     // TODO: called by JavacTaskImpl
1159     public void processAnnotations(List&lt;JCCompilationUnit&gt; roots) {
1160         processAnnotations(roots, List.nil());
1161     }
1162 
1163     /**
1164      * Process any annotations found in the specified compilation units.
1165      * @param roots a list of compilation units
1166      */
1167     // Implementation note: when this method is called, log.deferredDiagnostics
1168     // will have been set true by initProcessAnnotations, meaning that any diagnostics
1169     // that are reported will go into the log.deferredDiagnostics queue.
1170     // By the time this method exits, log.deferDiagnostics must be set back to false,
1171     // and all deferredDiagnostics must have been handled: i.e. either reported
1172     // or determined to be transient, and therefore suppressed.
1173     public void processAnnotations(List&lt;JCCompilationUnit&gt; roots,
1174                                    Collection&lt;String&gt; classnames) {
1175         if (shouldStop(CompileState.PROCESS)) {
1176             // Errors were encountered.
1177             // Unless all the errors are resolve errors, the errors were parse errors
1178             // or other errors during enter which cannot be fixed by running
1179             // any annotation processors.
1180             if (processAnnotations) {
1181                 deferredDiagnosticHandler.reportDeferredDiagnostics();
1182                 log.popDiagnosticHandler(deferredDiagnosticHandler);
1183                 return ;
1184             }
1185         }
1186 
1187         // ASSERT: processAnnotations and procEnvImpl should have been set up by
1188         // by initProcessAnnotations
1189 
1190         // NOTE: The !classnames.isEmpty() checks should be refactored to Main.
1191 
1192         if (!processAnnotations) {
1193             // If there are no annotation processors present, and
1194             // annotation processing is to occur with compilation,
1195             // emit a warning.
1196             if (options.isSet(PROC, &quot;only&quot;)) {
1197                 log.warning(Warnings.ProcProcOnlyRequestedNoProcs);
1198                 todo.clear();
1199             }
1200             // If not processing annotations, classnames must be empty
1201             if (!classnames.isEmpty()) {
1202                 log.error(Errors.ProcNoExplicitAnnotationProcessingRequested(classnames));
1203             }
1204             Assert.checkNull(deferredDiagnosticHandler);
1205             return ; // continue regular compilation
1206         }
1207 
1208         Assert.checkNonNull(deferredDiagnosticHandler);
1209 
1210         try {
1211             List&lt;ClassSymbol&gt; classSymbols = List.nil();
1212             List&lt;PackageSymbol&gt; pckSymbols = List.nil();
1213             if (!classnames.isEmpty()) {
1214                  // Check for explicit request for annotation
1215                  // processing
1216                 if (!explicitAnnotationProcessingRequested()) {
1217                     log.error(Errors.ProcNoExplicitAnnotationProcessingRequested(classnames));
1218                     deferredDiagnosticHandler.reportDeferredDiagnostics();
1219                     log.popDiagnosticHandler(deferredDiagnosticHandler);
1220                     return ; // TODO: Will this halt compilation?
1221                 } else {
1222                     boolean errors = false;
1223                     for (String nameStr : classnames) {
1224                         Symbol sym = resolveBinaryNameOrIdent(nameStr);
1225                         if (sym == null ||
1226                             (sym.kind == PCK &amp;&amp; !processPcks) ||
1227                             sym.kind == ABSENT_TYP) {
1228                             if (sym != silentFail)
1229                                 log.error(Errors.ProcCantFindClass(nameStr));
1230                             errors = true;
1231                             continue;
1232                         }
1233                         try {
1234                             if (sym.kind == PCK)
1235                                 sym.complete();
1236                             if (sym.exists()) {
1237                                 if (sym.kind == PCK)
1238                                     pckSymbols = pckSymbols.prepend((PackageSymbol)sym);
1239                                 else
1240                                     classSymbols = classSymbols.prepend((ClassSymbol)sym);
1241                                 continue;
1242                             }
1243                             Assert.check(sym.kind == PCK);
1244                             log.warning(Warnings.ProcPackageDoesNotExist(nameStr));
1245                             pckSymbols = pckSymbols.prepend((PackageSymbol)sym);
1246                         } catch (CompletionFailure e) {
1247                             log.error(Errors.ProcCantFindClass(nameStr));
1248                             errors = true;
1249                             continue;
1250                         }
1251                     }
1252                     if (errors) {
1253                         deferredDiagnosticHandler.reportDeferredDiagnostics();
1254                         log.popDiagnosticHandler(deferredDiagnosticHandler);
1255                         return ;
1256                     }
1257                 }
1258             }
1259             try {
1260                 annotationProcessingOccurred =
1261                         procEnvImpl.doProcessing(roots,
1262                                                  classSymbols,
1263                                                  pckSymbols,
1264                                                  deferredDiagnosticHandler);
1265                 // doProcessing will have handled deferred diagnostics
1266             } finally {
1267                 procEnvImpl.close();
1268             }
1269         } catch (CompletionFailure ex) {
1270             log.error(Errors.CantAccess(ex.sym, ex.getDetailValue()));
1271             if (deferredDiagnosticHandler != null) {
1272                 deferredDiagnosticHandler.reportDeferredDiagnostics();
1273                 log.popDiagnosticHandler(deferredDiagnosticHandler);
1274             }
1275         }
1276     }
1277 
1278     private boolean unrecoverableError() {
1279         if (deferredDiagnosticHandler != null) {
1280             for (JCDiagnostic d: deferredDiagnosticHandler.getDiagnostics()) {
1281                 if (d.getKind() == JCDiagnostic.Kind.ERROR &amp;&amp; !d.isFlagSet(RECOVERABLE))
1282                     return true;
1283             }
1284         }
1285         return false;
1286     }
1287 
1288     boolean explicitAnnotationProcessingRequested() {
1289         return
1290             explicitAnnotationProcessingRequested ||
1291             explicitAnnotationProcessingRequested(options);
1292     }
1293 
1294     static boolean explicitAnnotationProcessingRequested(Options options) {
1295         return
1296             options.isSet(PROCESSOR) ||
1297             options.isSet(PROCESSOR_PATH) ||
1298             options.isSet(PROCESSOR_MODULE_PATH) ||
1299             options.isSet(PROC, &quot;only&quot;) ||
1300             options.isSet(XPRINT);
1301     }
1302 
1303     public void setDeferredDiagnosticHandler(Log.DeferredDiagnosticHandler deferredDiagnosticHandler) {
1304         this.deferredDiagnosticHandler = deferredDiagnosticHandler;
1305     }
1306 
1307     /**
1308      * Attribute a list of parse trees, such as found on the &quot;todo&quot; list.
1309      * Note that attributing classes may cause additional files to be
1310      * parsed and entered via the SourceCompleter.
1311      * Attribution of the entries in the list does not stop if any errors occur.
1312      * @return a list of environments for attribute classes.
1313      */
1314     public Queue&lt;Env&lt;AttrContext&gt;&gt; attribute(Queue&lt;Env&lt;AttrContext&gt;&gt; envs) {
1315         ListBuffer&lt;Env&lt;AttrContext&gt;&gt; results = new ListBuffer&lt;&gt;();
1316         while (!envs.isEmpty())
1317             results.append(attribute(envs.remove()));
1318         return stopIfError(CompileState.ATTR, results);
1319     }
1320 
1321     /**
1322      * Attribute a parse tree.
1323      * @return the attributed parse tree
1324      */
1325     public Env&lt;AttrContext&gt; attribute(Env&lt;AttrContext&gt; env) {
1326         if (compileStates.isDone(env, CompileState.ATTR))
1327             return env;
1328 
1329         if (verboseCompilePolicy)
1330             printNote(&quot;[attribute &quot; + env.enclClass.sym + &quot;]&quot;);
1331         if (verbose)
1332             log.printVerbose(&quot;checking.attribution&quot;, env.enclClass.sym);
1333 
1334         if (!taskListener.isEmpty()) {
1335             TaskEvent e = new TaskEvent(TaskEvent.Kind.ANALYZE, env.toplevel, env.enclClass.sym);
1336             taskListener.started(e);
1337         }
1338 
1339         JavaFileObject prev = log.useSource(
1340                                   env.enclClass.sym.sourcefile != null ?
1341                                   env.enclClass.sym.sourcefile :
1342                                   env.toplevel.sourcefile);
1343         try {
1344             attr.attrib(env);
1345             if (errorCount() &gt; 0 &amp;&amp; !shouldStop(CompileState.ATTR)) {
1346                 //if in fail-over mode, ensure that AST expression nodes
1347                 //are correctly initialized (e.g. they have a type/symbol)
1348                 attr.postAttr(env.tree);
1349             }
1350             compileStates.put(env, CompileState.ATTR);
1351         }
1352         finally {
1353             log.useSource(prev);
1354         }
1355 
1356         return env;
1357     }
1358 
1359     /**
1360      * Perform dataflow checks on attributed parse trees.
1361      * These include checks for definite assignment and unreachable statements.
1362      * If any errors occur, an empty list will be returned.
1363      * @return the list of attributed parse trees
1364      */
1365     public Queue&lt;Env&lt;AttrContext&gt;&gt; flow(Queue&lt;Env&lt;AttrContext&gt;&gt; envs) {
1366         ListBuffer&lt;Env&lt;AttrContext&gt;&gt; results = new ListBuffer&lt;&gt;();
1367         for (Env&lt;AttrContext&gt; env: envs) {
1368             flow(env, results);
1369         }
1370         return stopIfError(CompileState.FLOW, results);
1371     }
1372 
1373     /**
1374      * Perform dataflow checks on an attributed parse tree.
1375      */
1376     public Queue&lt;Env&lt;AttrContext&gt;&gt; flow(Env&lt;AttrContext&gt; env) {
1377         ListBuffer&lt;Env&lt;AttrContext&gt;&gt; results = new ListBuffer&lt;&gt;();
1378         flow(env, results);
1379         return stopIfError(CompileState.FLOW, results);
1380     }
1381 
1382     /**
1383      * Perform dataflow checks on an attributed parse tree.
1384      */
1385     protected void flow(Env&lt;AttrContext&gt; env, Queue&lt;Env&lt;AttrContext&gt;&gt; results) {
1386         if (compileStates.isDone(env, CompileState.FLOW)) {
1387             results.add(env);
1388             return;
1389         }
1390 
1391         try {
1392             if (shouldStop(CompileState.FLOW))
1393                 return;
1394 
1395             if (verboseCompilePolicy)
1396                 printNote(&quot;[flow &quot; + env.enclClass.sym + &quot;]&quot;);
1397             JavaFileObject prev = log.useSource(
1398                                                 env.enclClass.sym.sourcefile != null ?
1399                                                 env.enclClass.sym.sourcefile :
1400                                                 env.toplevel.sourcefile);
1401             try {
1402                 make.at(Position.FIRSTPOS);
1403                 TreeMaker localMake = make.forToplevel(env.toplevel);
1404                 flow.analyzeTree(env, localMake);
1405                 compileStates.put(env, CompileState.FLOW);
1406 
1407                 if (shouldStop(CompileState.FLOW))
1408                     return;
1409 
1410                 analyzer.flush(env);
1411 
1412                 results.add(env);
1413             }
1414             finally {
1415                 log.useSource(prev);
1416             }
1417         }
1418         finally {
1419             if (!taskListener.isEmpty()) {
1420                 TaskEvent e = new TaskEvent(TaskEvent.Kind.ANALYZE, env.toplevel, env.enclClass.sym);
1421                 taskListener.finished(e);
1422             }
1423         }
1424     }
1425 
1426     /**
1427      * Prepare attributed parse trees, in conjunction with their attribution contexts,
1428      * for source or code generation.
1429      * If any errors occur, an empty list will be returned.
1430      * @return a list containing the classes to be generated
1431      */
1432     public Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; desugar(Queue&lt;Env&lt;AttrContext&gt;&gt; envs) {
1433         ListBuffer&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; results = new ListBuffer&lt;&gt;();
1434         for (Env&lt;AttrContext&gt; env: envs)
1435             desugar(env, results);
1436         return stopIfError(CompileState.FLOW, results);
1437     }
1438 
1439     HashMap&lt;Env&lt;AttrContext&gt;, Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt;&gt; desugaredEnvs = new HashMap&lt;&gt;();
1440 
1441     /**
1442      * Prepare attributed parse trees, in conjunction with their attribution contexts,
1443      * for source or code generation. If the file was not listed on the command line,
1444      * the current implicitSourcePolicy is taken into account.
1445      * The preparation stops as soon as an error is found.
1446      */
1447     protected void desugar(final Env&lt;AttrContext&gt; env, Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; results) {
1448         if (shouldStop(CompileState.TRANSTYPES))
1449             return;
1450 
1451         if (implicitSourcePolicy == ImplicitSourcePolicy.NONE
1452                 &amp;&amp; !inputFiles.contains(env.toplevel.sourcefile)) {
1453             return;
1454         }
1455 
1456         if (!modules.multiModuleMode &amp;&amp; env.toplevel.modle != modules.getDefaultModule()) {
1457             //can only generate classfiles for a single module:
1458             return;
1459         }
1460 
1461         if (compileStates.isDone(env, CompileState.LOWER)) {
1462             results.addAll(desugaredEnvs.get(env));
1463             return;
1464         }
1465 
1466         /**
1467          * Ensure that superclasses of C are desugared before C itself. This is
1468          * required for two reasons: (i) as erasure (TransTypes) destroys
1469          * information needed in flow analysis and (ii) as some checks carried
1470          * out during lowering require that all synthetic fields/methods have
1471          * already been added to C and its superclasses.
1472          */
1473         class ScanNested extends TreeScanner {
1474             Set&lt;Env&lt;AttrContext&gt;&gt; dependencies = new LinkedHashSet&lt;&gt;();
1475             protected boolean hasLambdas;
1476             @Override
1477             public void visitClassDef(JCClassDecl node) {
1478                 Type st = types.supertype(node.sym.type);
1479                 boolean envForSuperTypeFound = false;
1480                 while (!envForSuperTypeFound &amp;&amp; st.hasTag(CLASS)) {
1481                     ClassSymbol c = st.tsym.outermostClass();
1482                     Env&lt;AttrContext&gt; stEnv = enter.getEnv(c);
1483                     if (stEnv != null &amp;&amp; env != stEnv) {
1484                         if (dependencies.add(stEnv)) {
1485                             boolean prevHasLambdas = hasLambdas;
1486                             try {
1487                                 scan(stEnv.tree);
1488                             } finally {
1489                                 /*
1490                                  * ignore any updates to hasLambdas made during
1491                                  * the nested scan, this ensures an initialized
1492                                  * LambdaToMethod is available only to those
1493                                  * classes that contain lambdas
1494                                  */
1495                                 hasLambdas = prevHasLambdas;
1496                             }
1497                         }
1498                         envForSuperTypeFound = true;
1499                     }
1500                     st = types.supertype(st);
1501                 }
1502                 super.visitClassDef(node);
1503             }
1504             @Override
1505             public void visitLambda(JCLambda tree) {
1506                 hasLambdas = true;
1507                 super.visitLambda(tree);
1508             }
1509             @Override
1510             public void visitReference(JCMemberReference tree) {
1511                 hasLambdas = true;
1512                 super.visitReference(tree);
1513             }
1514         }
1515         ScanNested scanner = new ScanNested();
1516         scanner.scan(env.tree);
1517         for (Env&lt;AttrContext&gt; dep: scanner.dependencies) {
1518         if (!compileStates.isDone(dep, CompileState.FLOW))
1519             desugaredEnvs.put(dep, desugar(flow(attribute(dep))));
1520         }
1521 
1522         //We need to check for error another time as more classes might
1523         //have been attributed and analyzed at this stage
1524         if (shouldStop(CompileState.TRANSTYPES))
1525             return;
1526 
1527         if (verboseCompilePolicy)
1528             printNote(&quot;[desugar &quot; + env.enclClass.sym + &quot;]&quot;);
1529 
1530         JavaFileObject prev = log.useSource(env.enclClass.sym.sourcefile != null ?
1531                                   env.enclClass.sym.sourcefile :
1532                                   env.toplevel.sourcefile);
1533         try {
1534             //save tree prior to rewriting
1535             JCTree untranslated = env.tree;
1536 
1537             make.at(Position.FIRSTPOS);
1538             TreeMaker localMake = make.forToplevel(env.toplevel);
1539 
1540             if (env.tree.hasTag(JCTree.Tag.PACKAGEDEF) || env.tree.hasTag(JCTree.Tag.MODULEDEF)) {
1541                 if (!(sourceOutput)) {
1542                     if (shouldStop(CompileState.LOWER))
1543                         return;
1544                     List&lt;JCTree&gt; def = lower.translateTopLevelClass(env, env.tree, localMake);
1545                     if (def.head != null) {
1546                         Assert.check(def.tail.isEmpty());
1547                         results.add(new Pair&lt;&gt;(env, (JCClassDecl)def.head));
1548                     }
1549                 }
1550                 return;
1551             }
1552 
1553             if (shouldStop(CompileState.TRANSTYPES))
1554                 return;
1555 
1556             env.tree = transTypes.translateTopLevelClass(env.tree, localMake);
1557             compileStates.put(env, CompileState.TRANSTYPES);
1558 
1559             if (shouldStop(CompileState.TRANSPATTERNS))
1560                 return;
1561 
1562             env.tree = TransPatterns.instance(context).translateTopLevelClass(env, env.tree, localMake);
1563             compileStates.put(env, CompileState.TRANSPATTERNS);
1564 
1565             if (Feature.LAMBDA.allowedInSource(source) &amp;&amp; scanner.hasLambdas) {
1566                 if (shouldStop(CompileState.UNLAMBDA))
1567                     return;
1568 
1569                 env.tree = LambdaToMethod.instance(context).translateTopLevelClass(env, env.tree, localMake);
1570                 compileStates.put(env, CompileState.UNLAMBDA);
1571             }
1572 
1573             if (shouldStop(CompileState.LOWER))
1574                 return;
1575 
1576             if (sourceOutput) {
1577                 //emit standard Java source file, only for compilation
1578                 //units enumerated explicitly on the command line
1579                 JCClassDecl cdef = (JCClassDecl)env.tree;
1580                 if (untranslated instanceof JCClassDecl &amp;&amp;
1581                     rootClasses.contains((JCClassDecl)untranslated)) {
1582                     results.add(new Pair&lt;&gt;(env, cdef));
1583                 }
1584                 return;
1585             }
1586 
1587             //translate out inner classes
1588             List&lt;JCTree&gt; cdefs = lower.translateTopLevelClass(env, env.tree, localMake);
1589             compileStates.put(env, CompileState.LOWER);
1590 
1591             if (shouldStop(CompileState.LOWER))
1592                 return;
1593 
1594             //generate code for each class
1595             for (List&lt;JCTree&gt; l = cdefs; l.nonEmpty(); l = l.tail) {
1596                 JCClassDecl cdef = (JCClassDecl)l.head;
1597                 results.add(new Pair&lt;&gt;(env, cdef));
1598             }
1599         }
1600         finally {
1601             log.useSource(prev);
1602         }
1603 
1604     }
1605 
1606     /** Generates the source or class file for a list of classes.
1607      * The decision to generate a source file or a class file is
1608      * based upon the compiler&#39;s options.
1609      * Generation stops if an error occurs while writing files.
1610      */
1611     public void generate(Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; queue) {
1612         generate(queue, null);
1613     }
1614 
1615     public void generate(Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; queue, Queue&lt;JavaFileObject&gt; results) {
1616         if (shouldStop(CompileState.GENERATE))
1617             return;
1618 
1619         for (Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt; x: queue) {
1620             Env&lt;AttrContext&gt; env = x.fst;
1621             JCClassDecl cdef = x.snd;
1622 
1623             if (verboseCompilePolicy) {
1624                 printNote(&quot;[generate &quot; + (sourceOutput ? &quot; source&quot; : &quot;code&quot;) + &quot; &quot; + cdef.sym + &quot;]&quot;);
1625             }
1626 
1627             if (!taskListener.isEmpty()) {
1628                 TaskEvent e = new TaskEvent(TaskEvent.Kind.GENERATE, env.toplevel, cdef.sym);
1629                 taskListener.started(e);
1630             }
1631 
1632             JavaFileObject prev = log.useSource(env.enclClass.sym.sourcefile != null ?
1633                                       env.enclClass.sym.sourcefile :
1634                                       env.toplevel.sourcefile);
1635             try {
1636                 JavaFileObject file;
1637                 if (sourceOutput) {
1638                     file = printSource(env, cdef);
1639                 } else {
1640                     if (fileManager.hasLocation(StandardLocation.NATIVE_HEADER_OUTPUT)
1641                             &amp;&amp; jniWriter.needsHeader(cdef.sym)) {
1642                         jniWriter.write(cdef.sym);
1643                     }
1644                     file = genCode(env, cdef);
1645                 }
1646                 if (results != null &amp;&amp; file != null)
1647                     results.add(file);
1648             } catch (IOException ex) {
1649                 log.error(cdef.pos(),
1650                           Errors.ClassCantWrite(cdef.sym, ex.getMessage()));
1651                 return;
1652             } finally {
1653                 log.useSource(prev);
1654             }
1655 
1656             if (!taskListener.isEmpty()) {
1657                 TaskEvent e = new TaskEvent(TaskEvent.Kind.GENERATE, env.toplevel, cdef.sym);
1658                 taskListener.finished(e);
1659             }
1660         }
1661     }
1662 
1663         // where
1664         Map&lt;JCCompilationUnit, Queue&lt;Env&lt;AttrContext&gt;&gt;&gt; groupByFile(Queue&lt;Env&lt;AttrContext&gt;&gt; envs) {
1665             // use a LinkedHashMap to preserve the order of the original list as much as possible
1666             Map&lt;JCCompilationUnit, Queue&lt;Env&lt;AttrContext&gt;&gt;&gt; map = new LinkedHashMap&lt;&gt;();
1667             for (Env&lt;AttrContext&gt; env: envs) {
1668                 Queue&lt;Env&lt;AttrContext&gt;&gt; sublist = map.get(env.toplevel);
1669                 if (sublist == null) {
1670                     sublist = new ListBuffer&lt;&gt;();
1671                     map.put(env.toplevel, sublist);
1672                 }
1673                 sublist.add(env);
1674             }
1675             return map;
1676         }
1677 
1678         JCClassDecl removeMethodBodies(JCClassDecl cdef) {
1679             final boolean isInterface = (cdef.mods.flags &amp; Flags.INTERFACE) != 0;
1680             class MethodBodyRemover extends TreeTranslator {
1681                 @Override
1682                 public void visitMethodDef(JCMethodDecl tree) {
1683                     tree.mods.flags &amp;= ~Flags.SYNCHRONIZED;
1684                     for (JCVariableDecl vd : tree.params)
1685                         vd.mods.flags &amp;= ~Flags.FINAL;
1686                     tree.body = null;
1687                     super.visitMethodDef(tree);
1688                 }
1689                 @Override
1690                 public void visitVarDef(JCVariableDecl tree) {
1691                     if (tree.init != null &amp;&amp; tree.init.type.constValue() == null)
1692                         tree.init = null;
1693                     super.visitVarDef(tree);
1694                 }
1695                 @Override
1696                 public void visitClassDef(JCClassDecl tree) {
1697                     ListBuffer&lt;JCTree&gt; newdefs = new ListBuffer&lt;&gt;();
1698                     for (List&lt;JCTree&gt; it = tree.defs; it.tail != null; it = it.tail) {
1699                         JCTree t = it.head;
1700                         switch (t.getTag()) {
1701                         case CLASSDEF:
1702                             if (isInterface ||
1703                                 (((JCClassDecl) t).mods.flags &amp; (Flags.PROTECTED|Flags.PUBLIC)) != 0 ||
1704                                 (((JCClassDecl) t).mods.flags &amp; (Flags.PRIVATE)) == 0 &amp;&amp; ((JCClassDecl) t).sym.packge().getQualifiedName() == names.java_lang)
1705                                 newdefs.append(t);
1706                             break;
1707                         case METHODDEF:
1708                             if (isInterface ||
1709                                 (((JCMethodDecl) t).mods.flags &amp; (Flags.PROTECTED|Flags.PUBLIC)) != 0 ||
1710                                 ((JCMethodDecl) t).sym.name == names.init ||
1711                                 (((JCMethodDecl) t).mods.flags &amp; (Flags.PRIVATE)) == 0 &amp;&amp; ((JCMethodDecl) t).sym.packge().getQualifiedName() == names.java_lang)
1712                                 newdefs.append(t);
1713                             break;
1714                         case VARDEF:
1715                             if (isInterface || (((JCVariableDecl) t).mods.flags &amp; (Flags.PROTECTED|Flags.PUBLIC)) != 0 ||
1716                                 (((JCVariableDecl) t).mods.flags &amp; (Flags.PRIVATE)) == 0 &amp;&amp; ((JCVariableDecl) t).sym.packge().getQualifiedName() == names.java_lang)
1717                                 newdefs.append(t);
1718                             break;
1719                         default:
1720                             break;
1721                         }
1722                     }
1723                     tree.defs = newdefs.toList();
1724                     super.visitClassDef(tree);
1725                 }
1726             }
1727             MethodBodyRemover r = new MethodBodyRemover();
1728             return r.translate(cdef);
1729         }
1730 
1731     public void reportDeferredDiagnostics() {
1732         if (errorCount() == 0
1733                 &amp;&amp; annotationProcessingOccurred
1734                 &amp;&amp; implicitSourceFilesRead
1735                 &amp;&amp; implicitSourcePolicy == ImplicitSourcePolicy.UNSET) {
1736             if (explicitAnnotationProcessingRequested())
1737                 log.warning(Warnings.ProcUseImplicit);
1738             else
1739                 log.warning(Warnings.ProcUseProcOrImplicit);
1740         }
1741         chk.reportDeferredDiagnostics();
1742         preview.reportDeferredDiagnostics();
1743         if (log.compressedOutput) {
1744             log.mandatoryNote(null, Notes.CompressedDiags);
1745         }
1746     }
1747 
1748     public void enterDone() {
1749         enterDone = true;
1750         annotate.enterDone();
1751     }
1752 
1753     public boolean isEnterDone() {
1754         return enterDone;
1755     }
1756 
1757     private Name readModuleName(JavaFileObject fo) {
1758         return parseAndGetName(fo, t -&gt; {
1759             JCModuleDecl md = t.getModuleDecl();
1760 
1761             return md != null ? TreeInfo.fullName(md.getName()) : null;
1762         });
1763     }
1764 
1765     private Name findPackageInFile(JavaFileObject fo) {
1766         return parseAndGetName(fo, t -&gt; t.getPackage() != null ?
1767                                         TreeInfo.fullName(t.getPackage().getPackageName()) : null);
1768     }
1769 
1770     private Name parseAndGetName(JavaFileObject fo,
1771                                  Function&lt;JCTree.JCCompilationUnit, Name&gt; tree2Name) {
1772         DiagnosticHandler dh = new DiscardDiagnosticHandler(log);
1773         JavaFileObject prevSource = log.useSource(fo);
1774         try {
1775             JCTree.JCCompilationUnit t = parse(fo, fo.getCharContent(false));
1776             return tree2Name.apply(t);
1777         } catch (IOException e) {
1778             return null;
1779         } finally {
1780             log.popDiagnosticHandler(dh);
1781             log.useSource(prevSource);
1782         }
1783     }
1784 
1785     /** Close the compiler, flushing the logs
1786      */
1787     public void close() {
1788         rootClasses = null;
1789         finder = null;
1790         reader = null;
1791         make = null;
1792         writer = null;
1793         enter = null;
1794         if (todo != null)
1795             todo.clear();
1796         todo = null;
1797         parserFactory = null;
1798         syms = null;
1799         source = null;
1800         attr = null;
1801         chk = null;
1802         gen = null;
1803         flow = null;
1804         transTypes = null;
1805         lower = null;
1806         annotate = null;
1807         types = null;
1808 
1809         log.flush();
1810         try {
1811             fileManager.flush();
1812         } catch (IOException e) {
1813             throw new Abort(e);
1814         } finally {
1815             if (names != null)
1816                 names.dispose();
1817             names = null;
1818 
1819             for (Closeable c: closeables) {
1820                 try {
1821                     c.close();
1822                 } catch (IOException e) {
1823                     // When javac uses JDK 7 as a baseline, this code would be
1824                     // better written to set any/all exceptions from all the
1825                     // Closeables as suppressed exceptions on the FatalError
1826                     // that is thrown.
1827                     JCDiagnostic msg = diagFactory.fragment(Fragments.FatalErrCantClose);
1828                     throw new FatalError(msg, e);
1829                 }
1830             }
1831             closeables = List.nil();
1832         }
1833     }
1834 
1835     protected void printNote(String lines) {
1836         log.printRawLines(Log.WriterKind.NOTICE, lines);
1837     }
1838 
1839     /** Print numbers of errors and warnings.
1840      */
1841     public void printCount(String kind, int count) {
1842         if (count != 0) {
1843             String key;
1844             if (count == 1)
1845                 key = &quot;count.&quot; + kind;
1846             else
1847                 key = &quot;count.&quot; + kind + &quot;.plural&quot;;
1848             log.printLines(WriterKind.ERROR, key, String.valueOf(count));
1849             log.flush(Log.WriterKind.ERROR);
1850         }
1851     }
1852 
1853     private void printSuppressedCount(int shown, int suppressed, String diagKey) {
1854         if (suppressed &gt; 0) {
1855             int total = shown + suppressed;
1856             log.printLines(WriterKind.ERROR, diagKey,
1857                     String.valueOf(shown), String.valueOf(total));
1858             log.flush(Log.WriterKind.ERROR);
1859         }
1860     }
1861 
1862     private static long now() {
1863         return System.currentTimeMillis();
1864     }
1865 
1866     private static long elapsed(long then) {
1867         return now() - then;
1868     }
1869 
1870     public void newRound() {
1871         inputFiles.clear();
1872         todo.clear();
1873     }
1874 }
    </pre>
  </body>
</html>
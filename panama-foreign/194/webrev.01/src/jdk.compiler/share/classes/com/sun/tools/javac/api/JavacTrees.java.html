<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/api/JavacTrees.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.api;
  27 
  28 import java.io.FileNotFoundException;
  29 import java.io.IOException;
  30 import java.text.BreakIterator;
  31 import java.util.HashMap;
  32 import java.util.HashSet;
  33 import java.util.Map;
  34 import java.util.Map.Entry;
  35 import java.util.Set;
  36 import java.util.WeakHashMap;
  37 
  38 import javax.annotation.processing.ProcessingEnvironment;
  39 import javax.lang.model.element.AnnotationMirror;
  40 import javax.lang.model.element.AnnotationValue;
  41 import javax.lang.model.element.Element;
  42 import javax.lang.model.element.ElementKind;
  43 import javax.lang.model.element.ExecutableElement;
  44 import javax.lang.model.element.Modifier;
  45 import javax.lang.model.element.NestingKind;
  46 import javax.lang.model.element.PackageElement;
  47 import javax.lang.model.element.TypeElement;
  48 import javax.lang.model.type.DeclaredType;
  49 import javax.lang.model.type.TypeKind;
  50 import javax.lang.model.type.TypeMirror;
  51 import javax.tools.Diagnostic;
  52 import javax.tools.FileObject;
  53 import javax.tools.ForwardingFileObject;
  54 import javax.tools.JavaCompiler;
  55 import javax.tools.JavaFileManager;
  56 import javax.tools.JavaFileObject;
  57 import javax.tools.JavaFileObject.Kind;
  58 import javax.tools.StandardLocation;
  59 
  60 import com.sun.source.doctree.DocCommentTree;
  61 import com.sun.source.doctree.DocTree;
  62 import com.sun.source.tree.CatchTree;
  63 import com.sun.source.tree.ClassTree;
  64 import com.sun.source.tree.CompilationUnitTree;
  65 import com.sun.source.tree.Scope;
  66 import com.sun.source.tree.Tree;
  67 import com.sun.source.util.DocSourcePositions;
  68 import com.sun.source.util.DocTreePath;
  69 import com.sun.source.util.DocTreeScanner;
  70 import com.sun.source.util.DocTrees;
  71 import com.sun.source.util.JavacTask;
  72 import com.sun.source.util.TreePath;
  73 import com.sun.tools.javac.code.Flags;
  74 import com.sun.tools.javac.code.Scope.NamedImportScope;
  75 import com.sun.tools.javac.code.Scope.StarImportScope;
  76 import com.sun.tools.javac.code.Scope.WriteableScope;
  77 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  78 import com.sun.tools.javac.code.Symbol.MethodSymbol;
  79 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  80 import com.sun.tools.javac.code.Symbol.PackageSymbol;
  81 import com.sun.tools.javac.code.Symbol.TypeSymbol;
  82 import com.sun.tools.javac.code.Symbol.VarSymbol;
  83 import com.sun.tools.javac.code.Symtab;
  84 import com.sun.tools.javac.code.Type;
  85 import com.sun.tools.javac.code.Type.ArrayType;
  86 import com.sun.tools.javac.code.Type.ClassType;
  87 import com.sun.tools.javac.code.Type.ErrorType;
  88 import com.sun.tools.javac.code.Type.UnionClassType;
  89 import com.sun.tools.javac.code.Types;
  90 import com.sun.tools.javac.code.Types.TypeRelation;
  91 import com.sun.tools.javac.comp.Attr;
  92 import com.sun.tools.javac.comp.AttrContext;
  93 import com.sun.tools.javac.comp.Check;
  94 import com.sun.tools.javac.comp.Enter;
  95 import com.sun.tools.javac.comp.Env;
  96 import com.sun.tools.javac.comp.MemberEnter;
  97 import com.sun.tools.javac.comp.Modules;
  98 import com.sun.tools.javac.comp.Resolve;
  99 import com.sun.tools.javac.code.Symbol;
 100 import com.sun.tools.javac.file.BaseFileManager;
 101 import com.sun.tools.javac.model.JavacElements;
 102 import com.sun.tools.javac.parser.DocCommentParser;
 103 import com.sun.tools.javac.parser.ParserFactory;
 104 import com.sun.tools.javac.parser.Tokens.Comment;
 105 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
 106 import com.sun.tools.javac.processing.JavacProcessingEnvironment;
 107 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 108 import com.sun.tools.javac.resources.CompilerProperties.Notes;
 109 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
 110 import com.sun.tools.javac.tree.DCTree;
 111 import com.sun.tools.javac.tree.DCTree.DCBlockTag;
 112 import com.sun.tools.javac.tree.DCTree.DCComment;
 113 import com.sun.tools.javac.tree.DCTree.DCDocComment;
 114 import com.sun.tools.javac.tree.DCTree.DCEndPosTree;
 115 import com.sun.tools.javac.tree.DCTree.DCEntity;
 116 import com.sun.tools.javac.tree.DCTree.DCErroneous;
 117 import com.sun.tools.javac.tree.DCTree.DCIdentifier;
 118 import com.sun.tools.javac.tree.DCTree.DCParam;
 119 import com.sun.tools.javac.tree.DCTree.DCReference;
 120 import com.sun.tools.javac.tree.DCTree.DCText;
 121 import com.sun.tools.javac.tree.DocCommentTable;
 122 import com.sun.tools.javac.tree.DocTreeMaker;
 123 import com.sun.tools.javac.tree.EndPosTable;
 124 import com.sun.tools.javac.tree.JCTree;
 125 import com.sun.tools.javac.tree.JCTree.JCBlock;
 126 import com.sun.tools.javac.tree.JCTree.JCCatch;
 127 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 128 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 129 import com.sun.tools.javac.tree.JCTree.JCExpression;
 130 import com.sun.tools.javac.tree.JCTree.JCIdent;
 131 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 132 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 133 import com.sun.tools.javac.tree.TreeCopier;
 134 import com.sun.tools.javac.tree.TreeInfo;
 135 import com.sun.tools.javac.tree.TreeMaker;
 136 import com.sun.tools.javac.tree.TreeScanner;
 137 import com.sun.tools.javac.util.Abort;
 138 import com.sun.tools.javac.util.Assert;
 139 import com.sun.tools.javac.util.Context;
 140 import com.sun.tools.javac.util.DefinedBy;
 141 import com.sun.tools.javac.util.DefinedBy.Api;
 142 import com.sun.tools.javac.util.DiagnosticSource;
 143 import com.sun.tools.javac.util.JCDiagnostic;
 144 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
 145 import com.sun.tools.javac.util.List;
 146 import com.sun.tools.javac.util.ListBuffer;
 147 import com.sun.tools.javac.util.Log;
 148 import com.sun.tools.javac.util.Name;
 149 import com.sun.tools.javac.util.Names;
 150 import com.sun.tools.javac.util.Pair;
 151 import com.sun.tools.javac.util.Position;
 152 
 153 import static com.sun.tools.javac.code.Kinds.Kind.*;
 154 import static com.sun.tools.javac.code.TypeTag.*;
 155 
 156 /**
 157  * Provides an implementation of Trees.
 158  *
 159  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 160  * If you write code that depends on this, you do so at your own
 161  * risk.  This code and its internal interfaces are subject to change
 162  * or deletion without notice.&lt;/b&gt;&lt;/p&gt;
 163  *
 164  * @author Peter von der Ah&amp;eacute;
 165  */
 166 public class JavacTrees extends DocTrees {
 167 
 168     // in a world of a single context per compilation, these would all be final
 169     private Modules modules;
 170     private Resolve resolve;
 171     private Enter enter;
 172     private Log log;
 173     private MemberEnter memberEnter;
 174     private Attr attr;
 175     private Check chk;
 176     private TreeMaker treeMaker;
 177     private JavacElements elements;
 178     private JavacTaskImpl javacTaskImpl;
 179     private Names names;
 180     private Types types;
 181     private DocTreeMaker docTreeMaker;
 182     private BreakIterator breakIterator;
 183     private JavaFileManager fileManager;
 184     private ParserFactory parser;
 185     private Symtab syms;
 186 
 187     private final Map&lt;Type, Type&gt; extraType2OriginalMap = new WeakHashMap&lt;&gt;();
 188 
 189     // called reflectively from Trees.instance(CompilationTask task)
 190     public static JavacTrees instance(JavaCompiler.CompilationTask task) {
 191         if (!(task instanceof BasicJavacTask))
 192             throw new IllegalArgumentException();
 193         return instance(((BasicJavacTask)task).getContext());
 194     }
 195 
 196     // called reflectively from Trees.instance(ProcessingEnvironment env)
 197     public static JavacTrees instance(ProcessingEnvironment env) {
 198         if (!(env instanceof JavacProcessingEnvironment))
 199             throw new IllegalArgumentException();
 200         return instance(((JavacProcessingEnvironment)env).getContext());
 201     }
 202 
 203     public static JavacTrees instance(Context context) {
 204         JavacTrees instance = context.get(JavacTrees.class);
 205         if (instance == null)
 206             instance = new JavacTrees(context);
 207         return instance;
 208     }
 209 
 210     protected JavacTrees(Context context) {
 211         this.breakIterator = null;
 212         context.put(JavacTrees.class, this);
 213         init(context);
 214     }
 215 
 216     public void updateContext(Context context) {
 217         init(context);
 218     }
 219 
 220     private void init(Context context) {
 221         modules = Modules.instance(context);
 222         attr = Attr.instance(context);
 223         chk = Check.instance(context);
 224         enter = Enter.instance(context);
 225         elements = JavacElements.instance(context);
 226         log = Log.instance(context);
 227         resolve = Resolve.instance(context);
 228         treeMaker = TreeMaker.instance(context);
 229         memberEnter = MemberEnter.instance(context);
 230         names = Names.instance(context);
 231         types = Types.instance(context);
 232         docTreeMaker = DocTreeMaker.instance(context);
 233         parser = ParserFactory.instance(context);
 234         syms = Symtab.instance(context);
 235         fileManager = context.get(JavaFileManager.class);
 236         JavacTask t = context.get(JavacTask.class);
 237         if (t instanceof JavacTaskImpl)
 238             javacTaskImpl = (JavacTaskImpl) t;
 239     }
 240 
 241     @Override @DefinedBy(Api.COMPILER_TREE)
 242     public BreakIterator getBreakIterator() {
 243         return breakIterator;
 244     }
 245 
 246     @Override @DefinedBy(Api.COMPILER_TREE)
 247     public DocSourcePositions getSourcePositions() {
 248         return new DocSourcePositions() {
 249                 @Override @DefinedBy(Api.COMPILER_TREE)
 250                 public long getStartPosition(CompilationUnitTree file, Tree tree) {
 251                     return TreeInfo.getStartPos((JCTree) tree);
 252                 }
 253 
 254                 @Override @DefinedBy(Api.COMPILER_TREE)
 255                 public long getEndPosition(CompilationUnitTree file, Tree tree) {
 256                     EndPosTable endPosTable = ((JCCompilationUnit) file).endPositions;
 257                     return TreeInfo.getEndPos((JCTree) tree, endPosTable);
 258                 }
 259 
 260                 @Override @DefinedBy(Api.COMPILER_TREE)
 261                 public long getStartPosition(CompilationUnitTree file, DocCommentTree comment, DocTree tree) {
 262                     return ((DCTree) tree).getSourcePosition((DCDocComment) comment);
 263                 }
 264                 @Override  @DefinedBy(Api.COMPILER_TREE) @SuppressWarnings(&quot;fallthrough&quot;)
 265                 public long getEndPosition(CompilationUnitTree file, DocCommentTree comment, DocTree tree) {
 266                     DCDocComment dcComment = (DCDocComment) comment;
 267                     if (tree instanceof DCEndPosTree) {
 268                         int endPos = ((DCEndPosTree) tree).getEndPos(dcComment);
 269 
 270                         if (endPos != Position.NOPOS) {
 271                             return endPos;
 272                         }
 273                     }
 274                     int correction = 0;
 275                     switch (tree.getKind()) {
 276                         case TEXT:
 277                             DCText text = (DCText) tree;
 278 
 279                             return dcComment.comment.getSourcePos(text.pos + text.text.length());
 280                         case ERRONEOUS:
 281                             DCErroneous err = (DCErroneous) tree;
 282 
 283                             return dcComment.comment.getSourcePos(err.pos + err.body.length());
 284                         case IDENTIFIER:
 285                             DCIdentifier ident = (DCIdentifier) tree;
 286 
 287                             return dcComment.comment.getSourcePos(ident.pos + (ident.name != names.error ? ident.name.length() : 0));
 288                         case PARAM:
 289                             DCParam param = (DCParam) tree;
 290 
 291                             if (param.isTypeParameter &amp;&amp; param.getDescription().isEmpty()) {
 292                                 correction = 1;
 293                             }
 294                         case AUTHOR: case DEPRECATED: case RETURN: case SEE:
 295                         case SERIAL: case SERIAL_DATA: case SERIAL_FIELD: case SINCE:
 296                         case THROWS: case UNKNOWN_BLOCK_TAG: case VERSION: {
 297                             DocTree last = getLastChild(tree);
 298 
 299                             if (last != null) {
 300                                 return getEndPosition(file, comment, last) + correction;
 301                             }
 302 
 303                             DCBlockTag block = (DCBlockTag) tree;
 304 
 305                             return dcComment.comment.getSourcePos(block.pos + block.getTagName().length() + 1);
 306                         }
 307                         case ENTITY: {
 308                             DCEntity endEl = (DCEntity) tree;
 309                             return dcComment.comment.getSourcePos(endEl.pos + (endEl.name != names.error ? endEl.name.length() : 0) + 2);
 310                         }
 311                         case COMMENT: {
 312                             DCComment endEl = (DCComment) tree;
 313                             return dcComment.comment.getSourcePos(endEl.pos + endEl.body.length());
 314                         }
 315                         default:
 316                             DocTree last = getLastChild(tree);
 317 
 318                             if (last != null) {
 319                                 return getEndPosition(file, comment, last);
 320                             }
 321                             break;
 322                     }
 323 
 324                     return Position.NOPOS;
 325                 }
 326             };
 327     }
 328 
 329     @Override @DefinedBy(Api.COMPILER_TREE)
 330     public DocTreeMaker getDocTreeFactory() {
 331         return docTreeMaker;
 332     }
 333 
 334     private DocTree getLastChild(DocTree tree) {
 335         final DocTree[] last = new DocTree[] {null};
 336 
 337         tree.accept(new DocTreeScanner&lt;Void, Void&gt;() {
 338             @Override @DefinedBy(Api.COMPILER_TREE)
 339             public Void scan(DocTree node, Void p) {
 340                 if (node != null) last[0] = node;
 341                 return null;
 342             }
 343         }, null);
 344 
 345         return last[0];
 346     }
 347 
 348     @Override @DefinedBy(Api.COMPILER_TREE)
 349     public JCClassDecl getTree(TypeElement element) {
 350         return (JCClassDecl) getTree((Element) element);
 351     }
 352 
 353     @Override @DefinedBy(Api.COMPILER_TREE)
 354     public JCMethodDecl getTree(ExecutableElement method) {
 355         return (JCMethodDecl) getTree((Element) method);
 356     }
 357 
 358     @Override @DefinedBy(Api.COMPILER_TREE)
 359     public JCTree getTree(Element element) {
 360         return getTree(element, null);
 361     }
 362 
 363     @Override @DefinedBy(Api.COMPILER_TREE)
 364     public JCTree getTree(Element e, AnnotationMirror a) {
 365         return getTree(e, a, null);
 366     }
 367 
 368     @Override @DefinedBy(Api.COMPILER_TREE)
 369     public JCTree getTree(Element e, AnnotationMirror a, AnnotationValue v) {
 370         Pair&lt;JCTree, JCCompilationUnit&gt; treeTopLevel = elements.getTreeAndTopLevel(e, a, v);
 371         if (treeTopLevel == null)
 372             return null;
 373         return treeTopLevel.fst;
 374     }
 375 
 376     @Override @DefinedBy(Api.COMPILER_TREE)
 377     public TreePath getPath(CompilationUnitTree unit, Tree node) {
 378         return TreePath.getPath(unit, node);
 379     }
 380 
 381     @Override @DefinedBy(Api.COMPILER_TREE)
 382     public TreePath getPath(Element e) {
 383         return getPath(e, null, null);
 384     }
 385 
 386     @Override @DefinedBy(Api.COMPILER_TREE)
 387     public TreePath getPath(Element e, AnnotationMirror a) {
 388         return getPath(e, a, null);
 389     }
 390 
 391     @Override @DefinedBy(Api.COMPILER_TREE)
 392     public TreePath getPath(Element e, AnnotationMirror a, AnnotationValue v) {
 393         final Pair&lt;JCTree, JCCompilationUnit&gt; treeTopLevel = elements.getTreeAndTopLevel(e, a, v);
 394         if (treeTopLevel == null)
 395             return null;
 396         return TreePath.getPath(treeTopLevel.snd, treeTopLevel.fst);
 397     }
 398 
 399     @Override @DefinedBy(Api.COMPILER_TREE)
 400     public Symbol getElement(TreePath path) {
 401         JCTree tree = (JCTree) path.getLeaf();
 402         Symbol sym = TreeInfo.symbolFor(tree);
 403         if (sym == null) {
 404             for (TreePath p = path; p != null; p = p.getParentPath()) {
 405                 JCTree t = (JCTree) p.getLeaf();
 406                 if (t.hasTag(JCTree.Tag.CLASSDEF)) {
 407                     JCClassDecl ct = (JCClassDecl) t;
 408                     if (ct.sym != null) {
 409                         if ((ct.sym.flags_field &amp; Flags.UNATTRIBUTED) != 0) {
 410                             attr.attribClass(ct.pos(), ct.sym);
 411                             sym = TreeInfo.symbolFor(tree);
 412                         }
 413                         break;
 414                     }
 415                 }
 416             }
 417         }
 418         return sym;
 419     }
 420 
 421     @Override @DefinedBy(Api.COMPILER_TREE)
 422     public Element getElement(DocTreePath path) {
 423         DocTree tree = path.getLeaf();
 424         if (tree instanceof DCReference)
 425             return attributeDocReference(path.getTreePath(), ((DCReference) tree));
 426         if (tree instanceof DCIdentifier) {
 427             if (path.getParentPath().getLeaf() instanceof DCParam) {
 428                 return attributeParamIdentifier(path.getTreePath(), (DCParam) path.getParentPath().getLeaf());
 429             }
 430         }
 431         return null;
 432     }
 433 
 434     @Override @DefinedBy(Api.COMPILER_TREE)
 435     public TypeMirror getType(DocTreePath path) {
 436         DocTree tree = path.getLeaf();
 437         if (tree instanceof DCReference) {
 438             JCTree qexpr = ((DCReference)tree).qualifierExpression;
 439             if (qexpr != null) {
 440                 Log.DeferredDiagnosticHandler deferredDiagnosticHandler =
 441                         new Log.DeferredDiagnosticHandler(log);
 442                 try {
 443                     Env&lt;AttrContext&gt; env = getAttrContext(path.getTreePath());
 444                     Type t = attr.attribType(((DCReference) tree).qualifierExpression, env);
 445                     if (t != null &amp;&amp; !t.isErroneous()) {
 446                         return t;
 447                     }
 448                 } catch (Abort e) { // may be thrown by Check.completionError in case of bad class file
 449                     return null;
 450                 } finally {
 451                     log.popDiagnosticHandler(deferredDiagnosticHandler);
 452                 }
 453             }
 454         }
 455         Element e = getElement(path);
 456         return e == null ? null : e.asType();
 457     }
 458 
 459     @Override @DefinedBy(Api.COMPILER_TREE)
 460     public java.util.List&lt;DocTree&gt; getFirstSentence(java.util.List&lt;? extends DocTree&gt; list) {
 461         return docTreeMaker.getFirstSentence(list);
 462     }
 463 
 464     private Symbol attributeDocReference(TreePath path, DCReference ref) {
 465         Env&lt;AttrContext&gt; env = getAttrContext(path);
 466         if (env == null) return null;
 467 
 468         Log.DeferredDiagnosticHandler deferredDiagnosticHandler =
 469                 new Log.DeferredDiagnosticHandler(log);
 470         try {
 471             final TypeSymbol tsym;
 472             final Name memberName;
 473             if (ref.qualifierExpression == null) {
 474                 tsym = env.enclClass.sym;
 475                 memberName = (Name) ref.memberName;
 476             } else {
 477                 // newSeeTree if the qualifierExpression is a type or package name.
 478                 // javac does not provide the exact method required, so
 479                 // we first check if qualifierExpression identifies a type,
 480                 // and if not, then we check to see if it identifies a package.
 481                 Type t = attr.attribType(ref.qualifierExpression, env);
 482                 if (t.isErroneous()) {
 483                     JCCompilationUnit toplevel =
 484                         treeMaker.TopLevel(List.nil());
 485                     final ModuleSymbol msym = modules.getDefaultModule();
 486                     toplevel.modle = msym;
 487                     toplevel.packge = msym.unnamedPackage;
 488                     Symbol sym = attr.attribIdent(ref.qualifierExpression, toplevel);
 489 
 490                     if (sym == null)
 491                         return null;
 492 
 493                     sym.complete();
 494 
 495                     if ((sym.kind == PCK || sym.kind == TYP) &amp;&amp; sym.exists()) {
 496                         tsym = (TypeSymbol) sym;
 497                         memberName = (Name) ref.memberName;
 498                         if (sym.kind == PCK &amp;&amp; memberName != null) {
 499                             //cannot refer to a package &quot;member&quot;
 500                             return null;
 501                         }
 502                     } else {
 503                         if (ref.qualifierExpression.hasTag(JCTree.Tag.IDENT)) {
 504                             // fixup:  allow &quot;identifier&quot; instead of &quot;#identifier&quot;
 505                             // for compatibility with javadoc
 506                             tsym = env.enclClass.sym;
 507                             memberName = ((JCIdent) ref.qualifierExpression).name;
 508                         } else {
 509                             return null;
 510                         }
 511                     }
 512                 } else {
 513                     Type e = t;
 514                     // If this is an array type convert to element type
 515                     while (e instanceof ArrayType)
 516                         e = ((ArrayType)e).elemtype;
 517                     tsym = e.tsym;
 518                     memberName = (Name) ref.memberName;
 519                 }
 520             }
 521 
 522             if (memberName == null)
 523                 return tsym;
 524 
 525             final List&lt;Type&gt; paramTypes;
 526             if (ref.paramTypes == null)
 527                 paramTypes = null;
 528             else {
 529                 ListBuffer&lt;Type&gt; lb = new ListBuffer&lt;&gt;();
 530                 for (List&lt;JCTree&gt; l = (List&lt;JCTree&gt;) ref.paramTypes; l.nonEmpty(); l = l.tail) {
 531                     JCTree tree = l.head;
 532                     Type t = attr.attribType(tree, env);
 533                     lb.add(t);
 534                 }
 535                 paramTypes = lb.toList();
 536             }
 537 
 538             ClassSymbol sym = (ClassSymbol) types.skipTypeVars(tsym.type, false).tsym;
 539 
 540             Symbol msym = (memberName == sym.name)
 541                     ? findConstructor(sym, paramTypes)
 542                     : findMethod(sym, memberName, paramTypes);
 543             if (paramTypes != null) {
 544                 // explicit (possibly empty) arg list given, so cannot be a field
 545                 return msym;
 546             }
 547 
 548             VarSymbol vsym = (ref.paramTypes != null) ? null : findField(sym, memberName);
 549             // prefer a field over a method with no parameters
 550             if (vsym != null &amp;&amp;
 551                     (msym == null ||
 552                         types.isSubtypeUnchecked(vsym.enclClass().asType(), msym.enclClass().asType()))) {
 553                 return vsym;
 554             } else {
 555                 return msym;
 556             }
 557         } catch (Abort e) { // may be thrown by Check.completionError in case of bad class file
 558             return null;
 559         } finally {
 560             log.popDiagnosticHandler(deferredDiagnosticHandler);
 561         }
 562     }
 563 
 564     private Symbol attributeParamIdentifier(TreePath path, DCParam paramTag) {
 565         Symbol javadocSymbol = getElement(path);
 566         if (javadocSymbol == null)
 567             return null;
 568         ElementKind kind = javadocSymbol.getKind();
 569         List&lt;? extends Symbol&gt; params = List.nil();
 570         if (kind == ElementKind.METHOD || kind == ElementKind.CONSTRUCTOR) {
 571             MethodSymbol ee = (MethodSymbol) javadocSymbol;
 572             params = paramTag.isTypeParameter()
 573                     ? ee.getTypeParameters()
 574                     : ee.getParameters();
 575         } else if (kind.isClass() || kind.isInterface()) {
 576             ClassSymbol te = (ClassSymbol) javadocSymbol;
 577             params = paramTag.isTypeParameter()
 578                     ? te.getTypeParameters()
 579                     : te.getRecordComponents();
 580         }
 581 
 582         for (Symbol param : params) {
 583             if (param.getSimpleName() == paramTag.getName().getName()) {
 584                 return param;
 585             }
 586         }
 587         return null;
 588     }
 589 
 590     /** @see com.sun.tools.javadoc.ClassDocImpl#findField */
 591     private VarSymbol findField(ClassSymbol tsym, Name fieldName) {
 592         return searchField(tsym, fieldName, new HashSet&lt;&gt;());
 593     }
 594 
 595     /** @see com.sun.tools.javadoc.ClassDocImpl#searchField */
 596     private VarSymbol searchField(ClassSymbol tsym, Name fieldName, Set&lt;ClassSymbol&gt; searched) {
 597         if (searched.contains(tsym)) {
 598             return null;
 599         }
 600         searched.add(tsym);
 601 
 602         for (Symbol sym : tsym.members().getSymbolsByName(fieldName)) {
 603             if (sym.kind == VAR) {
 604                 return (VarSymbol)sym;
 605             }
 606         }
 607 
 608         //### If we found a VarSymbol above, but which did not pass
 609         //### the modifier filter, we should return failure here!
 610 
 611         ClassSymbol encl = tsym.owner.enclClass();
 612         if (encl != null) {
 613             VarSymbol vsym = searchField(encl, fieldName, searched);
 614             if (vsym != null) {
 615                 return vsym;
 616             }
 617         }
 618 
 619         // search superclass
 620         Type superclass = tsym.getSuperclass();
 621         if (superclass.tsym != null) {
 622             VarSymbol vsym = searchField((ClassSymbol) superclass.tsym, fieldName, searched);
 623             if (vsym != null) {
 624                 return vsym;
 625             }
 626         }
 627 
 628         // search interfaces
 629         List&lt;Type&gt; intfs = tsym.getInterfaces();
 630         for (List&lt;Type&gt; l = intfs; l.nonEmpty(); l = l.tail) {
 631             Type intf = l.head;
 632             if (intf.isErroneous()) continue;
 633             VarSymbol vsym = searchField((ClassSymbol) intf.tsym, fieldName, searched);
 634             if (vsym != null) {
 635                 return vsym;
 636             }
 637         }
 638 
 639         return null;
 640     }
 641 
 642     /** @see com.sun.tools.javadoc.ClassDocImpl#findConstructor */
 643     MethodSymbol findConstructor(ClassSymbol tsym, List&lt;Type&gt; paramTypes) {
 644         for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {
 645             if (sym.kind == MTH) {
 646                 if (hasParameterTypes((MethodSymbol) sym, paramTypes)) {
 647                     return (MethodSymbol) sym;
 648                 }
 649             }
 650         }
 651         return null;
 652     }
 653 
 654     /** @see com.sun.tools.javadoc.ClassDocImpl#findMethod */
 655     private MethodSymbol findMethod(ClassSymbol tsym, Name methodName, List&lt;Type&gt; paramTypes) {
 656         return searchMethod(tsym, methodName, paramTypes, new HashSet&lt;&gt;());
 657     }
 658 
 659     /** @see com.sun.tools.javadoc.ClassDocImpl#searchMethod */
 660     private MethodSymbol searchMethod(ClassSymbol tsym, Name methodName,
 661                                        List&lt;Type&gt; paramTypes, Set&lt;ClassSymbol&gt; searched) {
 662         //### Note that this search is not necessarily what the compiler would do!
 663 
 664         // do not match constructors
 665         if (methodName == names.init)
 666             return null;
 667 
 668         if (searched.contains(tsym))
 669             return null;
 670         searched.add(tsym);
 671 
 672         // search current class
 673 
 674         //### Using modifier filter here isn&#39;t really correct,
 675         //### but emulates the old behavior.  Instead, we should
 676         //### apply the normal rules of visibility and inheritance.
 677 
 678         if (paramTypes == null) {
 679             // If no parameters specified, we are allowed to return
 680             // any method with a matching name.  In practice, the old
 681             // code returned the first method, which is now the last!
 682             // In order to provide textually identical results, we
 683             // attempt to emulate the old behavior.
 684             MethodSymbol lastFound = null;
 685             for (Symbol sym : tsym.members().getSymbolsByName(methodName)) {
 686                 if (sym.kind == MTH) {
 687                     if (sym.name == methodName) {
 688                         lastFound = (MethodSymbol)sym;
 689                     }
 690                 }
 691             }
 692             if (lastFound != null) {
 693                 return lastFound;
 694             }
 695         } else {
 696             for (Symbol sym : tsym.members().getSymbolsByName(methodName)) {
 697                 if (sym != null &amp;&amp;
 698                     sym.kind == MTH) {
 699                     if (hasParameterTypes((MethodSymbol) sym, paramTypes)) {
 700                         return (MethodSymbol) sym;
 701                     }
 702                 }
 703             }
 704         }
 705 
 706         //### If we found a MethodSymbol above, but which did not pass
 707         //### the modifier filter, we should return failure here!
 708 
 709         // search superclass
 710         Type superclass = tsym.getSuperclass();
 711         if (superclass.tsym != null) {
 712             MethodSymbol msym = searchMethod((ClassSymbol) superclass.tsym, methodName, paramTypes, searched);
 713             if (msym != null) {
 714                 return msym;
 715             }
 716         }
 717 
 718         // search interfaces
 719         List&lt;Type&gt; intfs = tsym.getInterfaces();
 720         for (List&lt;Type&gt; l = intfs; l.nonEmpty(); l = l.tail) {
 721             Type intf = l.head;
 722             if (intf.isErroneous()) continue;
 723             MethodSymbol msym = searchMethod((ClassSymbol) intf.tsym, methodName, paramTypes, searched);
 724             if (msym != null) {
 725                 return msym;
 726             }
 727         }
 728 
 729         // search enclosing class
 730         ClassSymbol encl = tsym.owner.enclClass();
 731         if (encl != null) {
 732             MethodSymbol msym = searchMethod(encl, methodName, paramTypes, searched);
 733             if (msym != null) {
 734                 return msym;
 735             }
 736         }
 737 
 738         return null;
 739     }
 740 
 741     /** @see com.sun.tools.javadoc.ClassDocImpl */
 742     private boolean hasParameterTypes(MethodSymbol method, List&lt;Type&gt; paramTypes) {
 743         if (paramTypes == null)
 744             return true;
 745 
 746         if (method.params().size() != paramTypes.size())
 747             return false;
 748 
 749         List&lt;Type&gt; methodParamTypes = method.asType().getParameterTypes();
 750         if (!Type.isErroneous(paramTypes) &amp;&amp; types.isSubtypes(paramTypes, methodParamTypes)) {
 751             return true;
 752         }
 753 
 754         methodParamTypes = types.erasureRecursive(methodParamTypes);
 755         return types.isSameTypes(paramTypes, methodParamTypes);
 756     }
 757 
 758     @Override @DefinedBy(Api.COMPILER_TREE)
 759     public TypeMirror getTypeMirror(TreePath path) {
 760         Tree t = path.getLeaf();
 761         Type ty = ((JCTree)t).type;
 762         return ty == null ? null : ty.stripMetadataIfNeeded();
 763     }
 764 
 765     @Override @DefinedBy(Api.COMPILER_TREE)
 766     public JavacScope getScope(TreePath path) {
 767         return JavacScope.create(getAttrContext(path));
 768     }
 769 
 770     @Override @DefinedBy(Api.COMPILER_TREE)
 771     public String getDocComment(TreePath path) {
 772         CompilationUnitTree t = path.getCompilationUnit();
 773         Tree leaf = path.getLeaf();
 774         if (t instanceof JCTree.JCCompilationUnit &amp;&amp; leaf instanceof JCTree) {
 775             JCCompilationUnit cu = (JCCompilationUnit) t;
 776             if (cu.docComments != null) {
 777                 return cu.docComments.getCommentText((JCTree) leaf);
 778             }
 779         }
 780         return null;
 781     }
 782 
 783     @Override @DefinedBy(Api.COMPILER_TREE)
 784     public DocCommentTree getDocCommentTree(TreePath path) {
 785         CompilationUnitTree t = path.getCompilationUnit();
 786         Tree leaf = path.getLeaf();
 787         if (t instanceof JCTree.JCCompilationUnit &amp;&amp; leaf instanceof JCTree) {
 788             JCCompilationUnit cu = (JCCompilationUnit) t;
 789             if (cu.docComments != null) {
 790                 return cu.docComments.getCommentTree((JCTree) leaf);
 791             }
 792         }
 793         return null;
 794     }
 795 
 796     @Override @DefinedBy(Api.COMPILER_TREE)
 797     public DocCommentTree getDocCommentTree(Element e) {
 798         TreePath path = getPath(e);
 799         if (path == null) {
 800             return null;
 801         }
 802         return getDocCommentTree(path);
 803     }
 804 
 805     @Override @DefinedBy(Api.COMPILER_TREE)
 806     public DocCommentTree getDocCommentTree(Element e, String relativeFileName) throws IOException {
 807         PackageElement pkg = elements.getPackageOf(e);
 808         FileObject fileForInput = fileManager.getFileForInput(StandardLocation.SOURCE_PATH,
 809                 pkg.getQualifiedName().toString(), relativeFileName);
 810 
 811         if (fileForInput == null) {
 812             throw new FileNotFoundException(relativeFileName);
 813         }
 814         return getDocCommentTree(fileForInput);
 815     }
 816 
 817     @Override @DefinedBy(Api.COMPILER_TREE)
 818     public boolean isAccessible(Scope scope, TypeElement type) {
 819         if (scope instanceof JavacScope &amp;&amp; type instanceof ClassSymbol) {
 820             Env&lt;AttrContext&gt; env = ((JavacScope) scope).env;
 821             return resolve.isAccessible(env, (ClassSymbol)type, true);
 822         } else
 823             return false;
 824     }
 825 
 826     @Override @DefinedBy(Api.COMPILER_TREE)
 827     public boolean isAccessible(Scope scope, Element member, DeclaredType type) {
 828         if (scope instanceof JavacScope
 829                 &amp;&amp; member instanceof Symbol
 830                 &amp;&amp; type instanceof com.sun.tools.javac.code.Type) {
 831             Env&lt;AttrContext&gt; env = ((JavacScope) scope).env;
 832             return resolve.isAccessible(env, (com.sun.tools.javac.code.Type)type, (Symbol)member, true);
 833         } else
 834             return false;
 835     }
 836 
 837     private Env&lt;AttrContext&gt; getAttrContext(TreePath path) {
 838         if (!(path.getLeaf() instanceof JCTree))  // implicit null-check
 839             throw new IllegalArgumentException();
 840 
 841         // if we&#39;re being invoked from a Tree API client via parse/enter/analyze,
 842         // we need to make sure all the classes have been entered;
 843         // if we&#39;re being invoked from JSR 199 or JSR 269, then the classes
 844         // will already have been entered.
 845         if (javacTaskImpl != null) {
 846             javacTaskImpl.enter(null);
 847         }
 848 
 849         JCCompilationUnit unit = (JCCompilationUnit) path.getCompilationUnit();
 850         Copier copier = createCopier(treeMaker.forToplevel(unit));
 851 
 852         Env&lt;AttrContext&gt; env = null;
 853         JCMethodDecl method = null;
 854         JCVariableDecl field = null;
 855 
 856         List&lt;Tree&gt; l = List.nil();
 857         TreePath p = path;
 858         while (p != null) {
 859             l = l.prepend(p.getLeaf());
 860             p = p.getParentPath();
 861         }
 862 
 863         for ( ; l.nonEmpty(); l = l.tail) {
 864             Tree tree = l.head;
 865             switch (tree.getKind()) {
 866                 case COMPILATION_UNIT:
 867 //                    System.err.println(&quot;COMP: &quot; + ((JCCompilationUnit)tree).sourcefile);
 868                     env = enter.getTopLevelEnv((JCCompilationUnit)tree);
 869                     break;
 870                 case ANNOTATION_TYPE:
 871                 case CLASS:
 872                 case ENUM:
 873                 case INTERFACE:
 874                 case RECORD:
 875 //                    System.err.println(&quot;CLASS: &quot; + ((JCClassDecl)tree).sym.getSimpleName());
 876                     env = enter.getClassEnv(((JCClassDecl)tree).sym);
 877                     if (env == null) return null;
 878                     break;
 879                 case METHOD:
 880 //                    System.err.println(&quot;METHOD: &quot; + ((JCMethodDecl)tree).sym.getSimpleName());
 881                     method = (JCMethodDecl)tree;
 882                     env = memberEnter.getMethodEnv(method, env);
 883                     break;
 884                 case VARIABLE:
 885 //                    System.err.println(&quot;FIELD: &quot; + ((JCVariableDecl)tree).sym.getSimpleName());
 886                     field = (JCVariableDecl)tree;
 887                     break;
 888                 case BLOCK: {
 889 //                    System.err.println(&quot;BLOCK: &quot;);
 890                     if (method != null) {
 891                         try {
 892                             Assert.check(method.body == tree);
 893                             method.body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
 894                             env = attribStatToTree(method.body, env, copier.leafCopy, copier.copiedClasses);
 895                         } finally {
 896                             method.body = (JCBlock) tree;
 897                         }
 898                     } else {
 899                         JCBlock body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
 900                         env = attribStatToTree(body, env, copier.leafCopy, copier.copiedClasses);
 901                     }
 902                     return env;
 903                 }
 904                 default:
 905 //                    System.err.println(&quot;DEFAULT: &quot; + tree.getKind());
 906                     if (field != null &amp;&amp; field.getInitializer() == tree) {
 907                         env = memberEnter.getInitEnv(field, env);
 908                         JCExpression expr = copier.copy((JCExpression)tree, (JCTree) path.getLeaf());
 909                         env = attribExprToTree(expr, env, copier.leafCopy, copier.copiedClasses);
 910                         return env;
 911                     }
 912             }
 913         }
 914         return (field != null) ? memberEnter.getInitEnv(field, env) : env;
 915     }
 916 
 917     private Env&lt;AttrContext&gt; attribStatToTree(JCTree stat, Env&lt;AttrContext&gt;env,
 918                                               JCTree tree, Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses) {
 919         Env&lt;AttrContext&gt; result = attr.attribStatToTree(stat, env, tree);
 920 
 921         fixLocalClassNames(copiedClasses, env);
 922 
 923         return result;
 924     }
 925 
 926     private Env&lt;AttrContext&gt; attribExprToTree(JCExpression expr, Env&lt;AttrContext&gt;env,
 927                                               JCTree tree, Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses) {
 928         Env&lt;AttrContext&gt; result = attr.attribExprToTree(expr, env, tree);
 929 
 930         fixLocalClassNames(copiedClasses, env);
 931 
 932         return result;
 933     }
 934 
 935     /* Change the flatnames of the local and anonymous classes in the Scope to
 936      * the names they would have if the whole file was attributed normally.
 937      */
 938     private void fixLocalClassNames(Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses,
 939                                     Env&lt;AttrContext&gt; lastEnv) {
 940         Map&lt;JCClassDecl, Name&gt; flatnameForClass = null;
 941 
 942         for (Entry&lt;JCClassDecl, JCClassDecl&gt; e : copiedClasses.entrySet()) {
 943             if (e.getKey().sym != null) {
 944                 Name origName;
 945                 if (e.getValue().sym != null) {
 946                     //if the source tree was already attributed, use the flatname
 947                     //from the source tree&#39;s Symbol:
 948                     origName = e.getValue().sym.flatname;
 949                 } else {
 950                     //otherwise, compute the flatnames (for source trees) as
 951                     //if the full source code would be attributed:
 952                     if (flatnameForClass == null) {
 953                         flatnameForClass = prepareFlatnameForClass(lastEnv);
 954                     }
 955                     origName = flatnameForClass.get(e.getValue());
 956                 }
 957                 if (origName != null) {
 958                     e.getKey().sym.flatname = origName;
 959                 }
 960             }
 961         }
 962     }
 963 
 964     /* This method computes and assigns flatnames to trees, as if they would be
 965      * normally assigned during attribution of the full source code.
 966      */
 967     private Map&lt;JCTree.JCClassDecl, Name&gt; prepareFlatnameForClass(Env&lt;AttrContext&gt; env) {
 968         Map&lt;JCClassDecl, Name&gt; flatNameForClass = new HashMap&lt;&gt;();
 969         Symbol enclClass = env.enclClass.sym;
 970 
 971         if (enclClass != null &amp;&amp; (enclClass.flags_field &amp; Flags.UNATTRIBUTED) != 0) {
 972             ListBuffer&lt;ClassSymbol&gt; toClear = new ListBuffer&lt;&gt;();
 973             new TreeScanner() {
 974                 Symbol owner;
 975                 boolean localContext;
 976                 @Override
 977                 public void visitClassDef(JCClassDecl tree) {
 978                     //compute the name (and ClassSymbol) which would be used
 979                     //for this class for full attribution
 980                     Symbol prevOwner = owner;
 981                     try {
 982                         ClassSymbol c;
 983                         if (tree.sym != null) {
 984                             //already entered:
 985                             c = tree.sym;
 986                         } else {
 987                             c = syms.defineClass(tree.name, owner);
 988                             if (owner.kind != TYP) {
 989                                 //for local classes, assign the flatname
 990                                 c.flatname = chk.localClassName(c);
 991                                 chk.putCompiled(c);
 992                                 toClear.add(c);
 993                             }
 994                             flatNameForClass.put(tree, c.flatname);
 995                         }
 996                         owner = c;
 997                         super.visitClassDef(tree);
 998                     } finally {
 999                         owner = prevOwner;
1000                     }
1001                 }
1002 
1003                 @Override
1004                 public void visitBlock(JCBlock tree) {
1005                     Symbol prevOwner = owner;
1006                     try {
1007                         owner = new MethodSymbol(0, names.empty, Type.noType, owner);
1008                         super.visitBlock(tree);
1009                     } finally {
1010                         owner = prevOwner;
1011                     }
1012                 }
1013                 @Override
1014                 public void visitVarDef(JCVariableDecl tree) {
1015                     Symbol prevOwner = owner;
1016                     try {
1017                         owner = new MethodSymbol(0, names.empty, Type.noType, owner);
1018                         super.visitVarDef(tree);
1019                     } finally {
1020                         owner = prevOwner;
1021                     }
1022                 }
1023             }.scan(env.enclClass);
1024             //revert changes done by the visitor:
1025             toClear.stream().forEach(c -&gt; {
1026                 chk.clearLocalClassNameIndexes(c);
1027                 chk.removeCompiled(c);
1028             });
1029         }
1030 
1031         return flatNameForClass;
1032     }
1033 
1034     static JavaFileObject asJavaFileObject(FileObject fileObject) {
1035         JavaFileObject jfo = null;
1036 
1037         if (fileObject instanceof JavaFileObject) {
1038             jfo = (JavaFileObject) fileObject;
1039             checkHtmlKind(fileObject, Kind.HTML);
1040             return jfo;
1041         }
1042 
1043         checkHtmlKind(fileObject);
1044         jfo = new HtmlFileObject(fileObject);
1045         return jfo;
1046     }
1047 
1048     private static void checkHtmlKind(FileObject fileObject) {
1049         checkHtmlKind(fileObject, BaseFileManager.getKind(fileObject.getName()));
1050     }
1051 
1052     private static void checkHtmlKind(FileObject fileObject, JavaFileObject.Kind kind) {
1053         if (kind != JavaFileObject.Kind.HTML) {
1054             throw new IllegalArgumentException(&quot;HTML file expected:&quot; + fileObject.getName());
1055         }
1056     }
1057 
1058     private static class HtmlFileObject extends ForwardingFileObject&lt;FileObject&gt;
1059             implements JavaFileObject {
1060 
1061         public HtmlFileObject(FileObject fileObject) {
1062             super(fileObject);
1063         }
1064 
1065         @Override @DefinedBy(Api.COMPILER)
1066         public Kind getKind() {
1067             return BaseFileManager.getKind(fileObject.getName());
1068         }
1069 
1070         @Override @DefinedBy(Api.COMPILER)
1071         public boolean isNameCompatible(String simpleName, Kind kind) {
1072             return false;
1073         }
1074 
1075         @Override @DefinedBy(Api.COMPILER)
1076         public NestingKind getNestingKind() {
1077             return null;
1078         }
1079 
1080         @Override @DefinedBy(Api.COMPILER)
1081         public Modifier getAccessLevel() {
1082             return null;
1083         }
1084     }
1085 
1086     @Override @DefinedBy(Api.COMPILER_TREE)
1087     public DocCommentTree getDocCommentTree(FileObject fileObject) {
1088         JavaFileObject jfo = asJavaFileObject(fileObject);
1089         DiagnosticSource diagSource = new DiagnosticSource(jfo, log);
1090 
1091         final Comment comment = new Comment() {
1092             int offset = 0;
1093             @Override
1094             public String getText() {
1095                 try {
1096                     CharSequence rawDoc = fileObject.getCharContent(true);
1097                     return rawDoc.toString();
1098                 } catch (IOException ignore) {
1099                     // do nothing
1100                 }
1101                 return &quot;&quot;;
1102             }
1103 
1104             @Override
1105             public int getSourcePos(int index) {
1106                 return offset + index;
1107             }
1108 
1109             @Override
1110             public CommentStyle getStyle() {
1111                 throw new UnsupportedOperationException();
1112             }
1113 
1114             @Override
1115             public boolean isDeprecated() {
1116                 throw new UnsupportedOperationException();
1117             }
1118         };
1119 
1120         return new DocCommentParser(parser, diagSource, comment, true).parse();
1121     }
1122 
1123     @Override @DefinedBy(Api.COMPILER_TREE)
1124     public DocTreePath getDocTreePath(FileObject fileObject, PackageElement packageElement) {
1125         JavaFileObject jfo = asJavaFileObject(fileObject);
1126         DocCommentTree docCommentTree = getDocCommentTree(jfo);
1127         if (docCommentTree == null)
1128             return null;
1129         TreePath treePath = makeTreePath((PackageSymbol)packageElement, jfo, docCommentTree);
1130         return new DocTreePath(treePath, docCommentTree);
1131     }
1132 
1133     @Override @DefinedBy(Api.COMPILER_TREE)
1134     public void setBreakIterator(BreakIterator breakiterator) {
1135         this.breakIterator = breakiterator;
1136     }
1137 
1138     /**
1139      * Makes a copy of a tree, noting the value resulting from copying a particular leaf.
1140      **/
1141     protected static class Copier extends TreeCopier&lt;JCTree&gt; {
1142         JCTree leafCopy = null;
1143         private Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses = new HashMap&lt;&gt;();
1144 
1145         protected Copier(TreeMaker M) {
1146             super(M);
1147         }
1148 
1149         @Override
1150         public &lt;T extends JCTree&gt; T copy(T t, JCTree leaf) {
1151             T t2 = super.copy(t, leaf);
1152             if (t == leaf)
1153                 leafCopy = t2;
1154             return t2;
1155         }
1156 
1157         @Override
1158         public JCTree visitClass(ClassTree node, JCTree p) {
1159             JCTree nue = super.visitClass(node, p);
1160             copiedClasses.put((JCClassDecl) nue, (JCClassDecl) node);
1161             return nue;
1162         }
1163 
1164     }
1165 
1166     protected Copier createCopier(TreeMaker maker) {
1167         return new Copier(maker);
1168     }
1169 
1170     /**
1171      * Returns the original type from the ErrorType object.
1172      * @param errorType The errorType for which we want to get the original type.
1173      * @return TypeMirror corresponding to the original type, replaced by the ErrorType.
1174      *         noType (type.tag == NONE) is returned if there is no original type.
1175      */
1176     @Override @DefinedBy(Api.COMPILER_TREE)
1177     public TypeMirror getOriginalType(javax.lang.model.type.ErrorType errorType) {
1178         if (errorType instanceof com.sun.tools.javac.code.Type.ErrorType) {
1179             return ((com.sun.tools.javac.code.Type.ErrorType)errorType).getOriginalType();
1180         }
1181         if (errorType instanceof com.sun.tools.javac.code.Type.ClassType &amp;&amp;
1182             errorType.getKind() == TypeKind.ERROR) {
1183             ClassType ct = (ClassType) errorType;
1184             return extraType2OriginalMap.computeIfAbsent(ct, tt -&gt;
1185                     new ClassType(ct.getEnclosingType(), ct.typarams_field,
1186                                   ct.tsym, ct.getMetadata()) {
1187                         @Override
1188                         public Type baseType() { return ct; }
1189                         @Override
1190                         public TypeKind getKind() {
1191                             return TypeKind.DECLARED;
1192                         }
1193                     });
1194         }
1195 
1196         return com.sun.tools.javac.code.Type.noType;
1197     }
1198 
1199     /**
1200      * Prints a message of the specified kind at the location of the
1201      * tree within the provided compilation unit
1202      *
1203      * @param kind the kind of message
1204      * @param msg  the message, or an empty string if none
1205      * @param t    the tree to use as a position hint
1206      * @param root the compilation unit that contains tree
1207      */
1208     @Override @DefinedBy(Api.COMPILER_TREE)
1209     public void printMessage(Diagnostic.Kind kind, CharSequence msg,
1210             com.sun.source.tree.Tree t,
1211             com.sun.source.tree.CompilationUnitTree root) {
1212         printMessage(kind, msg, ((JCTree) t).pos(), root);
1213     }
1214 
1215     @Override @DefinedBy(Api.COMPILER_TREE)
1216     public void printMessage(Diagnostic.Kind kind, CharSequence msg,
1217             com.sun.source.doctree.DocTree t,
1218             com.sun.source.doctree.DocCommentTree c,
1219             com.sun.source.tree.CompilationUnitTree root) {
1220         printMessage(kind, msg, ((DCTree) t).pos((DCDocComment) c), root);
1221     }
1222 
1223     private void printMessage(Diagnostic.Kind kind, CharSequence msg,
1224             JCDiagnostic.DiagnosticPosition pos,
1225             com.sun.source.tree.CompilationUnitTree root) {
1226         JavaFileObject oldSource = null;
1227         JavaFileObject newSource = null;
1228 
1229         newSource = root.getSourceFile();
1230         if (newSource == null) {
1231             pos = null;
1232         } else {
1233             oldSource = log.useSource(newSource);
1234         }
1235 
1236         try {
1237             switch (kind) {
1238             case ERROR:
1239                 log.error(DiagnosticFlag.API, pos, Errors.ProcMessager(msg.toString()));
1240                 break;
1241 
1242             case WARNING:
1243                 log.warning(pos, Warnings.ProcMessager(msg.toString()));
1244                 break;
1245 
1246             case MANDATORY_WARNING:
1247                 log.mandatoryWarning(pos, Warnings.ProcMessager(msg.toString()));
1248                 break;
1249 
1250             default:
1251                 log.note(pos, Notes.ProcMessager(msg.toString()));
1252             }
1253         } finally {
1254             if (oldSource != null)
1255                 log.useSource(oldSource);
1256         }
1257     }
1258 
1259     @Override @DefinedBy(Api.COMPILER_TREE)
1260     public TypeMirror getLub(CatchTree tree) {
1261         JCCatch ct = (JCCatch) tree;
1262         JCVariableDecl v = ct.param;
1263         if (v.type != null &amp;&amp; v.type.getKind() == TypeKind.UNION) {
1264             UnionClassType ut = (UnionClassType) v.type;
1265             return ut.getLub();
1266         } else {
1267             return v.type;
1268         }
1269     }
1270 
1271     private TreePath makeTreePath(final PackageSymbol psym, final JavaFileObject jfo,
1272             DocCommentTree dcTree) {
1273         JCCompilationUnit jcCompilationUnit = new JCCompilationUnit(List.nil()) {
1274             public int getPos() {
1275                 return Position.FIRSTPOS;
1276             }
1277 
1278             public JavaFileObject getSourcefile() {
1279                 return jfo;
1280             }
1281 
1282             @Override @DefinedBy(Api.COMPILER_TREE)
1283             public Position.LineMap getLineMap() {
1284                 try {
1285                     CharSequence content = jfo.getCharContent(true);
1286                     String s = content.toString();
1287                     return Position.makeLineMap(s.toCharArray(), s.length(), true);
1288                 } catch (IOException ignore) {}
1289                 return null;
1290             }
1291         };
1292 
1293         jcCompilationUnit.docComments = new DocCommentTable() {
1294             @Override
1295             public boolean hasComment(JCTree tree) {
1296                 return false;
1297             }
1298 
1299             @Override
1300             public Comment getComment(JCTree tree) {
1301                 throw new UnsupportedOperationException();
1302             }
1303 
1304             @Override
1305             public String getCommentText(JCTree tree) {
1306                 throw new UnsupportedOperationException();
1307             }
1308 
1309             @Override
1310             public DCDocComment getCommentTree(JCTree tree) {
1311                 return (DCDocComment)dcTree;
1312             }
1313 
1314             @Override
1315             public void putComment(JCTree tree, Comment c) {
1316                 throw new UnsupportedOperationException();
1317             }
1318 
1319         };
1320         jcCompilationUnit.lineMap = jcCompilationUnit.getLineMap();
1321         jcCompilationUnit.modle = psym.modle;
1322         jcCompilationUnit.sourcefile = jfo;
1323         jcCompilationUnit.namedImportScope = new NamedImportScope(psym);
1324         jcCompilationUnit.packge = psym;
1325         jcCompilationUnit.starImportScope = new StarImportScope(psym);
1326         jcCompilationUnit.toplevelScope = WriteableScope.create(psym);
1327         return new TreePath(jcCompilationUnit);
1328     }
1329 }
    </pre>
  </body>
</html>
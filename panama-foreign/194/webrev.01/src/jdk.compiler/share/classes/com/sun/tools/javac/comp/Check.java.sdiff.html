<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Modules.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 143         preview = Preview.instance(context);
 144 
 145         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 146         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 147         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 148         boolean enforceMandatoryWarnings = true;
 149 
 150         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 151                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 152         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 153                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 154         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 155                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 156         sunApiHandler = new MandatoryWarningHandler(log, false,
 157                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 158 
 159         deferredLintHandler = DeferredLintHandler.instance(context);
 160 
 161         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 162                 Feature.RECORDS.allowedInSource(source);


 163     }
 164 
 165     /** Character for synthetic names
 166      */
 167     char syntheticNameChar;
 168 
 169     /** A table mapping flat names of all compiled classes for each module in this run
 170      *  to their symbols; maintained from outside.
 171      */
 172     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 173 
 174     /** A handler for messages about deprecated usage.
 175      */
 176     private MandatoryWarningHandler deprecationHandler;
 177 
 178     /** A handler for messages about deprecated-for-removal usage.
 179      */
 180     private MandatoryWarningHandler removalHandler;
 181 
 182     /** A handler for messages about unchecked or unsafe usage.
 183      */
 184     private MandatoryWarningHandler uncheckedHandler;
 185 
 186     /** A handler for messages about using proprietary API.
 187      */
 188     private MandatoryWarningHandler sunApiHandler;
 189 
 190     /** A handler for deferred lint warnings.
 191      */
 192     private DeferredLintHandler deferredLintHandler;
 193 
 194     /** Are records allowed
 195      */
 196     private final boolean allowRecords;
 197 




 198 /* *************************************************************************
 199  * Errors and Warnings
 200  **************************************************************************/
 201 
 202     Lint setLint(Lint newLint) {
 203         Lint prev = lint;
 204         lint = newLint;
 205         return prev;
 206     }
 207 
 208     MethodSymbol setMethod(MethodSymbol newMethod) {
 209         MethodSymbol prev = method;
 210         method = newMethod;
 211         return prev;
 212     }
 213 
 214     /** Warn about deprecated symbol.
 215      *  @param pos        Position to be used for error reporting.
 216      *  @param sym        The deprecated symbol.
 217      */
</pre>
<hr />
<pre>
1205                 mask = MethodFlags;
1206             }
1207             // Imply STRICTFP if owner has STRICTFP set.
1208             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1209                 ((flags) &amp; Flags.DEFAULT) != 0)
1210                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1211             break;
1212         case TYP:
1213             if (sym.isLocal()) {
1214                 boolean implicitlyStatic = !sym.isAnonymous() &amp;&amp;
1215                         ((flags &amp; RECORD) != 0 || (flags &amp; ENUM) != 0 || (flags &amp; INTERFACE) != 0);
1216                 boolean staticOrImplicitlyStatic = (flags &amp; STATIC) != 0 || implicitlyStatic;
1217                 mask = staticOrImplicitlyStatic &amp;&amp; allowRecords ? StaticLocalFlags : LocalClassFlags;
1218                 implicit = implicitlyStatic ? STATIC : implicit;
1219                 if (staticOrImplicitlyStatic) {
1220                     if (sym.owner.kind == TYP) {
1221                         log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1222                     }
1223                 }
1224             } else if (sym.owner.kind == TYP) {
<span class="line-modified">1225                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : MemberClassFlags;</span>
1226                 if (sym.owner.owner.kind == PCK ||
1227                     (sym.owner.flags_field &amp; STATIC) != 0)
1228                     mask |= STATIC;
1229                 else if ((flags &amp; ENUM) != 0 || (flags &amp; RECORD) != 0) {
1230                     log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1231                 }
1232                 // Nested interfaces and enums are always STATIC (Spec ???)
1233                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1234             } else {
<span class="line-modified">1235                 mask = ClassFlags;</span>
1236             }
1237             // Interfaces are always ABSTRACT
1238             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1239 
1240             if ((flags &amp; ENUM) != 0) {
<span class="line-modified">1241                 // enums can&#39;t be declared abstract or final</span>
<span class="line-modified">1242                 mask &amp;= ~(ABSTRACT | FINAL);</span>
1243                 implicit |= implicitEnumFinalFlag(tree);
1244             }
1245             if ((flags &amp; RECORD) != 0) {
1246                 // records can&#39;t be declared abstract
1247                 mask &amp;= ~ABSTRACT;
1248                 implicit |= FINAL;
1249             }
1250             // Imply STRICTFP if owner has STRICTFP set.
1251             implicit |= sym.owner.flags_field &amp; STRICTFP;
1252             break;
1253         default:
1254             throw new AssertionError();
1255         }
1256         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1257         if (illegal != 0) {
1258             if ((illegal &amp; INTERFACE) != 0) {
1259                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1260                 mask |= INTERFACE;
1261             }
1262             else {
</pre>
<hr />
<pre>
1277                  &amp;&amp;
1278                  checkDisjoint(pos, flags,
1279                                ABSTRACT | INTERFACE,
1280                                FINAL | NATIVE | SYNCHRONIZED)
1281                  &amp;&amp;
1282                  checkDisjoint(pos, flags,
1283                                PUBLIC,
1284                                PRIVATE | PROTECTED)
1285                  &amp;&amp;
1286                  checkDisjoint(pos, flags,
1287                                PRIVATE,
1288                                PUBLIC | PROTECTED)
1289                  &amp;&amp;
1290                  checkDisjoint(pos, flags,
1291                                FINAL,
1292                                VOLATILE)
1293                  &amp;&amp;
1294                  (sym.kind == TYP ||
1295                   checkDisjoint(pos, flags,
1296                                 ABSTRACT | NATIVE,
<span class="line-modified">1297                                 STRICTFP))) {</span>






1298             // skip
1299         }
1300         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1301     }
1302 
1303 
1304     /** Determine if this enum should be implicitly final.
1305      *
1306      *  If the enum has no specialized enum constants, it is final.
1307      *
1308      *  If the enum does have specialized enum constants, it is
1309      *  &lt;i&gt;not&lt;/i&gt; final.
1310      */
1311     private long implicitEnumFinalFlag(JCTree tree) {
1312         if (!tree.hasTag(CLASSDEF)) return 0;
1313         class SpecialTreeVisitor extends JCTree.Visitor {
1314             boolean specialized;
1315             SpecialTreeVisitor() {
1316                 this.specialized = false;
1317             }
1318 
1319             @Override
1320             public void visitTree(JCTree tree) { /* no-op */ }
1321 
1322             @Override
1323             public void visitVarDef(JCVariableDecl tree) {
1324                 if ((tree.mods.flags &amp; ENUM) != 0) {
1325                     if (tree.init instanceof JCNewClass &amp;&amp;
1326                         ((JCNewClass) tree.init).def != null) {
1327                         specialized = true;
1328                     }
1329                 }
1330             }
1331         }
1332 
1333         SpecialTreeVisitor sts = new SpecialTreeVisitor();
1334         JCClassDecl cdef = (JCClassDecl) tree;
1335         for (JCTree defs: cdef.defs) {
1336             defs.accept(sts);
<span class="line-modified">1337             if (sts.specialized) return 0;</span>
1338         }
1339         return FINAL;
1340     }
1341 
1342 /* *************************************************************************
1343  * Type Validation
1344  **************************************************************************/
1345 
1346     /** Validate a type expression. That is,
1347      *  check that all type arguments of a parametric type are within
1348      *  their bounds. This must be done in a second phase after type attribution
1349      *  since a class might have a subclass as type parameter bound. E.g:
1350      *
1351      *  &lt;pre&gt;{@code
1352      *  class B&lt;A extends C&gt; { ... }
1353      *  class C extends B&lt;C&gt; { ... }
1354      *  }&lt;/pre&gt;
1355      *
1356      *  and we can&#39;t make sure that the bound is already attributed because
1357      *  of possible cycles.
</pre>
</td>
<td>
<hr />
<pre>
 143         preview = Preview.instance(context);
 144 
 145         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 146         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 147         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 148         boolean enforceMandatoryWarnings = true;
 149 
 150         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 151                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 152         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 153                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 154         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 155                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 156         sunApiHandler = new MandatoryWarningHandler(log, false,
 157                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 158 
 159         deferredLintHandler = DeferredLintHandler.instance(context);
 160 
 161         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 162                 Feature.RECORDS.allowedInSource(source);
<span class="line-added"> 163         allowSealed = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 164                 Feature.SEALED_CLASSES.allowedInSource(source);</span>
 165     }
 166 
 167     /** Character for synthetic names
 168      */
 169     char syntheticNameChar;
 170 
 171     /** A table mapping flat names of all compiled classes for each module in this run
 172      *  to their symbols; maintained from outside.
 173      */
 174     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 175 
 176     /** A handler for messages about deprecated usage.
 177      */
 178     private MandatoryWarningHandler deprecationHandler;
 179 
 180     /** A handler for messages about deprecated-for-removal usage.
 181      */
 182     private MandatoryWarningHandler removalHandler;
 183 
 184     /** A handler for messages about unchecked or unsafe usage.
 185      */
 186     private MandatoryWarningHandler uncheckedHandler;
 187 
 188     /** A handler for messages about using proprietary API.
 189      */
 190     private MandatoryWarningHandler sunApiHandler;
 191 
 192     /** A handler for deferred lint warnings.
 193      */
 194     private DeferredLintHandler deferredLintHandler;
 195 
 196     /** Are records allowed
 197      */
 198     private final boolean allowRecords;
 199 
<span class="line-added"> 200     /** Are sealed classes allowed</span>
<span class="line-added"> 201      */</span>
<span class="line-added"> 202     private final boolean allowSealed;</span>
<span class="line-added"> 203 </span>
 204 /* *************************************************************************
 205  * Errors and Warnings
 206  **************************************************************************/
 207 
 208     Lint setLint(Lint newLint) {
 209         Lint prev = lint;
 210         lint = newLint;
 211         return prev;
 212     }
 213 
 214     MethodSymbol setMethod(MethodSymbol newMethod) {
 215         MethodSymbol prev = method;
 216         method = newMethod;
 217         return prev;
 218     }
 219 
 220     /** Warn about deprecated symbol.
 221      *  @param pos        Position to be used for error reporting.
 222      *  @param sym        The deprecated symbol.
 223      */
</pre>
<hr />
<pre>
1211                 mask = MethodFlags;
1212             }
1213             // Imply STRICTFP if owner has STRICTFP set.
1214             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1215                 ((flags) &amp; Flags.DEFAULT) != 0)
1216                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1217             break;
1218         case TYP:
1219             if (sym.isLocal()) {
1220                 boolean implicitlyStatic = !sym.isAnonymous() &amp;&amp;
1221                         ((flags &amp; RECORD) != 0 || (flags &amp; ENUM) != 0 || (flags &amp; INTERFACE) != 0);
1222                 boolean staticOrImplicitlyStatic = (flags &amp; STATIC) != 0 || implicitlyStatic;
1223                 mask = staticOrImplicitlyStatic &amp;&amp; allowRecords ? StaticLocalFlags : LocalClassFlags;
1224                 implicit = implicitlyStatic ? STATIC : implicit;
1225                 if (staticOrImplicitlyStatic) {
1226                     if (sym.owner.kind == TYP) {
1227                         log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1228                     }
1229                 }
1230             } else if (sym.owner.kind == TYP) {
<span class="line-modified">1231                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : ExtendedMemberClassFlags;</span>
1232                 if (sym.owner.owner.kind == PCK ||
1233                     (sym.owner.flags_field &amp; STATIC) != 0)
1234                     mask |= STATIC;
1235                 else if ((flags &amp; ENUM) != 0 || (flags &amp; RECORD) != 0) {
1236                     log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1237                 }
1238                 // Nested interfaces and enums are always STATIC (Spec ???)
1239                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1240             } else {
<span class="line-modified">1241                 mask = ExtendedClassFlags;</span>
1242             }
1243             // Interfaces are always ABSTRACT
1244             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1245 
1246             if ((flags &amp; ENUM) != 0) {
<span class="line-modified">1247                 // enums can&#39;t be declared abstract, final, sealed or non-sealed</span>
<span class="line-modified">1248                 mask &amp;= ~(ABSTRACT | FINAL | SEALED | NON_SEALED);</span>
1249                 implicit |= implicitEnumFinalFlag(tree);
1250             }
1251             if ((flags &amp; RECORD) != 0) {
1252                 // records can&#39;t be declared abstract
1253                 mask &amp;= ~ABSTRACT;
1254                 implicit |= FINAL;
1255             }
1256             // Imply STRICTFP if owner has STRICTFP set.
1257             implicit |= sym.owner.flags_field &amp; STRICTFP;
1258             break;
1259         default:
1260             throw new AssertionError();
1261         }
1262         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1263         if (illegal != 0) {
1264             if ((illegal &amp; INTERFACE) != 0) {
1265                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1266                 mask |= INTERFACE;
1267             }
1268             else {
</pre>
<hr />
<pre>
1283                  &amp;&amp;
1284                  checkDisjoint(pos, flags,
1285                                ABSTRACT | INTERFACE,
1286                                FINAL | NATIVE | SYNCHRONIZED)
1287                  &amp;&amp;
1288                  checkDisjoint(pos, flags,
1289                                PUBLIC,
1290                                PRIVATE | PROTECTED)
1291                  &amp;&amp;
1292                  checkDisjoint(pos, flags,
1293                                PRIVATE,
1294                                PUBLIC | PROTECTED)
1295                  &amp;&amp;
1296                  checkDisjoint(pos, flags,
1297                                FINAL,
1298                                VOLATILE)
1299                  &amp;&amp;
1300                  (sym.kind == TYP ||
1301                   checkDisjoint(pos, flags,
1302                                 ABSTRACT | NATIVE,
<span class="line-modified">1303                                 STRICTFP))</span>
<span class="line-added">1304                  &amp;&amp; checkDisjoint(pos, flags,</span>
<span class="line-added">1305                                 FINAL,</span>
<span class="line-added">1306                            SEALED | NON_SEALED)</span>
<span class="line-added">1307                  &amp;&amp; checkDisjoint(pos, flags,</span>
<span class="line-added">1308                                 SEALED,</span>
<span class="line-added">1309                            FINAL | NON_SEALED)) {</span>
1310             // skip
1311         }
1312         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1313     }
1314 
1315 
1316     /** Determine if this enum should be implicitly final.
1317      *
1318      *  If the enum has no specialized enum constants, it is final.
1319      *
1320      *  If the enum does have specialized enum constants, it is
1321      *  &lt;i&gt;not&lt;/i&gt; final.
1322      */
1323     private long implicitEnumFinalFlag(JCTree tree) {
1324         if (!tree.hasTag(CLASSDEF)) return 0;
1325         class SpecialTreeVisitor extends JCTree.Visitor {
1326             boolean specialized;
1327             SpecialTreeVisitor() {
1328                 this.specialized = false;
1329             }
1330 
1331             @Override
1332             public void visitTree(JCTree tree) { /* no-op */ }
1333 
1334             @Override
1335             public void visitVarDef(JCVariableDecl tree) {
1336                 if ((tree.mods.flags &amp; ENUM) != 0) {
1337                     if (tree.init instanceof JCNewClass &amp;&amp;
1338                         ((JCNewClass) tree.init).def != null) {
1339                         specialized = true;
1340                     }
1341                 }
1342             }
1343         }
1344 
1345         SpecialTreeVisitor sts = new SpecialTreeVisitor();
1346         JCClassDecl cdef = (JCClassDecl) tree;
1347         for (JCTree defs: cdef.defs) {
1348             defs.accept(sts);
<span class="line-modified">1349             if (sts.specialized) return allowSealed ? SEALED : 0;</span>
1350         }
1351         return FINAL;
1352     }
1353 
1354 /* *************************************************************************
1355  * Type Validation
1356  **************************************************************************/
1357 
1358     /** Validate a type expression. That is,
1359      *  check that all type arguments of a parametric type are within
1360      *  their bounds. This must be done in a second phase after type attribution
1361      *  since a class might have a subclass as type parameter bound. E.g:
1362      *
1363      *  &lt;pre&gt;{@code
1364      *  class B&lt;A extends C&gt; { ... }
1365      *  class C extends B&lt;C&gt; { ... }
1366      *  }&lt;/pre&gt;
1367      *
1368      *  and we can&#39;t make sure that the bound is already attributed because
1369      *  of possible cycles.
</pre>
</td>
</tr>
</table>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Modules.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
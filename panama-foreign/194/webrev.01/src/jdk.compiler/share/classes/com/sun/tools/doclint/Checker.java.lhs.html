<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.doclint;
  27 
  28 import java.io.IOException;
  29 import java.io.StringWriter;
  30 import java.net.URI;
  31 import java.net.URISyntaxException;
  32 import java.util.Deque;
  33 import java.util.EnumSet;
  34 import java.util.HashMap;
  35 import java.util.HashSet;
  36 import java.util.LinkedList;
  37 import java.util.List;
  38 import java.util.Map;
  39 import java.util.Set;
  40 import java.util.regex.Matcher;
  41 import java.util.regex.Pattern;
  42 
  43 import javax.lang.model.element.Element;
  44 import javax.lang.model.element.ElementKind;
  45 import javax.lang.model.element.ExecutableElement;
  46 import javax.lang.model.element.Name;
  47 import javax.lang.model.element.VariableElement;
  48 import javax.lang.model.type.TypeKind;
  49 import javax.lang.model.type.TypeMirror;
  50 import javax.tools.Diagnostic.Kind;
  51 import javax.tools.JavaFileObject;
  52 
  53 import com.sun.source.doctree.AttributeTree;
  54 import com.sun.source.doctree.AuthorTree;
  55 import com.sun.source.doctree.DocCommentTree;
  56 import com.sun.source.doctree.DocRootTree;
  57 import com.sun.source.doctree.DocTree;
  58 import com.sun.source.doctree.EndElementTree;
  59 import com.sun.source.doctree.EntityTree;
  60 import com.sun.source.doctree.ErroneousTree;
  61 import com.sun.source.doctree.IdentifierTree;
  62 import com.sun.source.doctree.IndexTree;
  63 import com.sun.source.doctree.InheritDocTree;
  64 import com.sun.source.doctree.LinkTree;
  65 import com.sun.source.doctree.LiteralTree;
  66 import com.sun.source.doctree.ParamTree;
  67 import com.sun.source.doctree.ProvidesTree;
  68 import com.sun.source.doctree.ReferenceTree;
  69 import com.sun.source.doctree.ReturnTree;
  70 import com.sun.source.doctree.SerialDataTree;
  71 import com.sun.source.doctree.SerialFieldTree;
  72 import com.sun.source.doctree.SinceTree;
  73 import com.sun.source.doctree.StartElementTree;
  74 import com.sun.source.doctree.SummaryTree;
  75 import com.sun.source.doctree.SystemPropertyTree;
  76 import com.sun.source.doctree.TextTree;
  77 import com.sun.source.doctree.ThrowsTree;
  78 import com.sun.source.doctree.UnknownBlockTagTree;
  79 import com.sun.source.doctree.UnknownInlineTagTree;
  80 import com.sun.source.doctree.UsesTree;
  81 import com.sun.source.doctree.ValueTree;
  82 import com.sun.source.doctree.VersionTree;
  83 import com.sun.source.tree.Tree;
  84 import com.sun.source.util.DocTreePath;
  85 import com.sun.source.util.DocTreePathScanner;
  86 import com.sun.source.util.TreePath;
  87 import com.sun.tools.doclint.HtmlTag.AttrKind;
  88 import com.sun.tools.javac.tree.DocPretty;
  89 import com.sun.tools.javac.util.Assert;
  90 import com.sun.tools.javac.util.DefinedBy;
  91 import com.sun.tools.javac.util.DefinedBy.Api;
  92 import com.sun.tools.javac.util.StringUtils;
  93 
  94 import static com.sun.tools.doclint.Messages.Group.*;
  95 
  96 
  97 /**
  98  * Validate a doc comment.
  99  *
 100  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 101  * If you write code that depends on this, you do so at your own
 102  * risk.  This code and its internal interfaces are subject to change
 103  * or deletion without notice.&lt;/b&gt;&lt;/p&gt;
 104  */
 105 public class Checker extends DocTreePathScanner&lt;Void, Void&gt; {
 106     final Env env;
 107 
 108     Set&lt;Element&gt; foundParams = new HashSet&lt;&gt;();
 109     Set&lt;TypeMirror&gt; foundThrows = new HashSet&lt;&gt;();
 110     Map&lt;Element, Set&lt;String&gt;&gt; foundAnchors = new HashMap&lt;&gt;();
 111     boolean foundInheritDoc = false;
 112     boolean foundReturn = false;
 113     boolean hasNonWhitespaceText = false;
 114 
 115     public enum Flag {
 116         TABLE_HAS_CAPTION,
 117         HAS_ELEMENT,
 118         HAS_HEADING,
 119         HAS_INLINE_TAG,
 120         HAS_TEXT,
 121         REPORTED_BAD_INLINE
 122     }
 123 
 124     static class TagStackItem {
 125         final DocTree tree; // typically, but not always, StartElementTree
 126         final HtmlTag tag;
 127         final Set&lt;HtmlTag.Attr&gt; attrs;
 128         final Set&lt;Flag&gt; flags;
 129         TagStackItem(DocTree tree, HtmlTag tag) {
 130             this.tree = tree;
 131             this.tag = tag;
 132             attrs = EnumSet.noneOf(HtmlTag.Attr.class);
 133             flags = EnumSet.noneOf(Flag.class);
 134         }
 135         @Override
 136         public String toString() {
 137             return String.valueOf(tag);
 138         }
 139     }
 140 
 141     private final Deque&lt;TagStackItem&gt; tagStack; // TODO: maybe want to record starting tree as well
 142     private HtmlTag currHeadingTag;
 143 
 144     private int implicitHeadingRank;
 145 
 146     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Top level&quot;&gt;
 147 
 148     Checker(Env env) {
 149         this.env = Assert.checkNonNull(env);
 150         tagStack = new LinkedList&lt;&gt;();
 151     }
 152 
 153     public Void scan(DocCommentTree tree, TreePath p) {
 154         env.initTypes();
 155         env.setCurrent(p, tree);
 156 
 157         boolean isOverridingMethod = !env.currOverriddenMethods.isEmpty();
 158         JavaFileObject fo = p.getCompilationUnit().getSourceFile();
 159 
 160         if (p.getLeaf().getKind() == Tree.Kind.PACKAGE) {
 161             // If p points to a package, the implied declaration is the
 162             // package declaration (if any) for the compilation unit.
 163             // Handle this case specially, because doc comments are only
 164             // expected in package-info files.
 165             boolean isPkgInfo = fo.isNameCompatible(&quot;package-info&quot;, JavaFileObject.Kind.SOURCE);
 166             if (tree == null) {
 167                 if (isPkgInfo)
 168                     reportMissing(&quot;dc.missing.comment&quot;);
 169                 return null;
 170             } else {
 171                 if (!isPkgInfo)
 172                     reportReference(&quot;dc.unexpected.comment&quot;);
 173             }
 174         } else if (tree != null &amp;&amp; fo.isNameCompatible(&quot;package&quot;, JavaFileObject.Kind.HTML)) {
 175             // a package.html file with a DocCommentTree
 176             if (tree.getFullBody().isEmpty()) {
 177                 reportMissing(&quot;dc.missing.comment&quot;);
 178                 return null;
 179             }
 180         } else {
 181             if (tree == null) {
 182                 if (!isSynthetic() &amp;&amp; !isOverridingMethod)
 183                     reportMissing(&quot;dc.missing.comment&quot;);
 184                 return null;
 185             }
 186         }
 187 
 188         tagStack.clear();
 189         currHeadingTag = null;
 190 
 191         foundParams.clear();
 192         foundThrows.clear();
 193         foundInheritDoc = false;
 194         foundReturn = false;
 195         hasNonWhitespaceText = false;
 196 
 197         switch (p.getLeaf().getKind()) {
 198             // the following are for declarations that have their own top-level page,
 199             // and so the doc comment comes after the &lt;h1&gt; page title.
 200             case MODULE:
 201             case PACKAGE:
 202             case CLASS:
 203             case INTERFACE:
 204             case ENUM:
 205             case ANNOTATION_TYPE:
 206             case RECORD:
 207                 implicitHeadingRank = 1;
 208                 break;
 209 
 210             // this is for html files
 211             // ... if it is a legacy package.html, the doc comment comes after the &lt;h1&gt; page title
 212             // ... otherwise, (e.g. overview file and doc-files/*.html files) no additional headings are inserted
 213             case COMPILATION_UNIT:
 214                 implicitHeadingRank = fo.isNameCompatible(&quot;package&quot;, JavaFileObject.Kind.HTML) ? 1 : 0;
 215                 break;
 216 
 217             // the following are for member declarations, which appear in the page
 218             // for the enclosing type, and so appear after the &lt;h2&gt; &quot;Members&quot;
 219             // aggregate heading and the specific &lt;h3&gt; &quot;Member signature&quot; heading.
 220             case METHOD:
 221             case VARIABLE:
 222                 implicitHeadingRank = 3;
 223                 break;
 224 
 225             default:
 226                 Assert.error(&quot;unexpected tree kind: &quot; + p.getLeaf().getKind() + &quot; &quot; + fo);
 227         }
 228 
 229         scan(new DocTreePath(p, tree), null);
 230 
 231         if (!isOverridingMethod) {
 232             switch (env.currElement.getKind()) {
 233                 case METHOD:
 234                 case CONSTRUCTOR: {
 235                     ExecutableElement ee = (ExecutableElement) env.currElement;
 236                     checkParamsDocumented(ee.getTypeParameters());
 237                     checkParamsDocumented(ee.getParameters());
 238                     switch (ee.getReturnType().getKind()) {
 239                         case VOID:
 240                         case NONE:
 241                             break;
 242                         default:
 243                             if (!foundReturn
 244                                     &amp;&amp; !foundInheritDoc
 245                                     &amp;&amp; !env.types.isSameType(ee.getReturnType(), env.java_lang_Void)) {
 246                                 reportMissing(&quot;dc.missing.return&quot;);
 247                             }
 248                     }
 249                     checkThrowsDocumented(ee.getThrownTypes());
 250                 }
 251             }
 252         }
 253 
 254         return null;
 255     }
 256 
 257     private void reportMissing(String code, Object... args) {
 258         env.messages.report(MISSING, Kind.WARNING, env.currPath.getLeaf(), code, args);
 259     }
 260 
 261     private void reportReference(String code, Object... args) {
 262         env.messages.report(REFERENCE, Kind.WARNING, env.currPath.getLeaf(), code, args);
 263     }
 264 
 265     @Override @DefinedBy(Api.COMPILER_TREE)
 266     public Void visitDocComment(DocCommentTree tree, Void ignore) {
 267         super.visitDocComment(tree, ignore);
 268         for (TagStackItem tsi: tagStack) {
 269             warnIfEmpty(tsi, null);
 270             if (tsi.tree.getKind() == DocTree.Kind.START_ELEMENT
 271                     &amp;&amp; tsi.tag.endKind == HtmlTag.EndKind.REQUIRED) {
 272                 StartElementTree t = (StartElementTree) tsi.tree;
 273                 env.messages.error(HTML, t, &quot;dc.tag.not.closed&quot;, t.getName());
 274             }
 275         }
 276         return null;
 277     }
 278     // &lt;/editor-fold&gt;
 279 
 280     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Text and entities.&quot;&gt;
 281 
 282     @Override @DefinedBy(Api.COMPILER_TREE)
 283     public Void visitText(TextTree tree, Void ignore) {
 284         hasNonWhitespaceText = hasNonWhitespace(tree);
 285         if (hasNonWhitespaceText) {
 286             checkAllowsText(tree);
 287             markEnclosingTag(Flag.HAS_TEXT);
 288         }
 289         return null;
 290     }
 291 
 292     @Override @DefinedBy(Api.COMPILER_TREE)
 293     public Void visitEntity(EntityTree tree, Void ignore) {
 294         checkAllowsText(tree);
 295         markEnclosingTag(Flag.HAS_TEXT);
 296         String name = tree.getName().toString();
 297         if (name.startsWith(&quot;#&quot;)) {
 298             int v = StringUtils.toLowerCase(name).startsWith(&quot;#x&quot;)
 299                     ? Integer.parseInt(name.substring(2), 16)
 300                     : Integer.parseInt(name.substring(1), 10);
 301             if (!Entity.isValid(v)) {
 302                 env.messages.error(HTML, tree, &quot;dc.entity.invalid&quot;, name);
 303             }
 304         } else if (!Entity.isValid(name)) {
 305             env.messages.error(HTML, tree, &quot;dc.entity.invalid&quot;, name);
 306         }
 307         return null;
 308     }
 309 
 310     void checkAllowsText(DocTree tree) {
 311         TagStackItem top = tagStack.peek();
 312         if (top != null
 313                 &amp;&amp; top.tree.getKind() == DocTree.Kind.START_ELEMENT
 314                 &amp;&amp; !top.tag.acceptsText()) {
 315             if (top.flags.add(Flag.REPORTED_BAD_INLINE)) {
 316                 env.messages.error(HTML, tree, &quot;dc.text.not.allowed&quot;,
 317                         ((StartElementTree) top.tree).getName());
 318             }
 319         }
 320     }
 321 
 322     // &lt;/editor-fold&gt;
 323 
 324     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;HTML elements&quot;&gt;
 325 
 326     @Override @DefinedBy(Api.COMPILER_TREE)
 327     public Void visitStartElement(StartElementTree tree, Void ignore) {
 328         final Name treeName = tree.getName();
 329         final HtmlTag t = HtmlTag.get(treeName);
 330         if (t == null) {
 331             env.messages.error(HTML, tree, &quot;dc.tag.unknown&quot;, treeName);
 332         } else if (t.allowedVersion != HtmlVersion.ALL &amp;&amp; t.allowedVersion != env.htmlVersion) {
 333             env.messages.error(HTML, tree, &quot;dc.tag.not.supported&quot;, treeName);
 334         } else {
 335             boolean done = false;
 336             for (TagStackItem tsi: tagStack) {
 337                 if (tsi.tag.accepts(t)) {
 338                     while (tagStack.peek() != tsi) {
 339                         warnIfEmpty(tagStack.peek(), null);
 340                         tagStack.pop();
 341                     }
 342                     done = true;
 343                     break;
 344                 } else if (tsi.tag.endKind != HtmlTag.EndKind.OPTIONAL) {
 345                     done = true;
 346                     break;
 347                 }
 348             }
 349             if (!done &amp;&amp; HtmlTag.BODY.accepts(t)) {
 350                 while (!tagStack.isEmpty()) {
 351                     warnIfEmpty(tagStack.peek(), null);
 352                     tagStack.pop();
 353                 }
 354             }
 355 
 356             markEnclosingTag(Flag.HAS_ELEMENT);
 357             checkStructure(tree, t);
 358 
 359             // tag specific checks
 360             switch (t) {
 361                 // check for out of sequence headings, such as &lt;h1&gt;...&lt;/h1&gt;  &lt;h3&gt;...&lt;/h3&gt;
 362                 case H1: case H2: case H3: case H4: case H5: case H6:
 363                     checkHeading(tree, t);
 364                     break;
 365             }
 366 
 367             if (t.flags.contains(HtmlTag.Flag.NO_NEST)) {
 368                 for (TagStackItem i: tagStack) {
 369                     if (t == i.tag) {
 370                         env.messages.warning(HTML, tree, &quot;dc.tag.nested.not.allowed&quot;, treeName);
 371                         break;
 372                     }
 373                 }
 374             }
 375         }
 376 
 377         // check for self closing tags, such as &lt;a id=&quot;name&quot;/&gt;
 378         if (tree.isSelfClosing()) {
 379             env.messages.error(HTML, tree, &quot;dc.tag.self.closing&quot;, treeName);
 380         }
 381 
 382         try {
 383             TagStackItem parent = tagStack.peek();
 384             TagStackItem top = new TagStackItem(tree, t);
 385             tagStack.push(top);
 386 
 387             super.visitStartElement(tree, ignore);
 388 
 389             // handle attributes that may or may not have been found in start element
 390             if (t != null) {
 391                 switch (t) {
 392                     case CAPTION:
 393                         if (parent != null &amp;&amp; parent.tag == HtmlTag.TABLE)
 394                             parent.flags.add(Flag.TABLE_HAS_CAPTION);
 395                         break;
 396 
 397                     case H1: case H2: case H3: case H4: case H5: case H6:
 398                         if (parent != null &amp;&amp; (parent.tag == HtmlTag.SECTION || parent.tag == HtmlTag.ARTICLE)) {
 399                             parent.flags.add(Flag.HAS_HEADING);
 400                         }
 401                         break;
 402 
 403                     case IMG:
 404                         if (!top.attrs.contains(HtmlTag.Attr.ALT))
 405                             env.messages.error(ACCESSIBILITY, tree, &quot;dc.no.alt.attr.for.image&quot;);
 406                         break;
 407                 }
 408             }
 409 
 410             return null;
 411         } finally {
 412 
 413             if (t == null || t.endKind == HtmlTag.EndKind.NONE)
 414                 tagStack.pop();
 415         }
 416     }
 417 
 418     private void checkStructure(StartElementTree tree, HtmlTag t) {
 419         Name treeName = tree.getName();
 420         TagStackItem top = tagStack.peek();
 421         switch (t.blockType) {
 422             case BLOCK:
 423                 if (top == null || top.tag.accepts(t))
 424                     return;
 425 
 426                 switch (top.tree.getKind()) {
 427                     case START_ELEMENT: {
 428                         if (top.tag.blockType == HtmlTag.BlockType.INLINE) {
 429                             Name name = ((StartElementTree) top.tree).getName();
 430                             env.messages.error(HTML, tree, &quot;dc.tag.not.allowed.inline.element&quot;,
 431                                     treeName, name);
 432                             return;
 433                         }
 434                     }
 435                     break;
 436 
 437                     case LINK:
 438                     case LINK_PLAIN: {
 439                         String name = top.tree.getKind().tagName;
 440                         env.messages.error(HTML, tree, &quot;dc.tag.not.allowed.inline.tag&quot;,
 441                                 treeName, name);
 442                         return;
 443                     }
 444                 }
 445                 break;
 446 
 447             case INLINE:
 448                 if (top == null || top.tag.accepts(t))
 449                     return;
 450                 break;
 451 
 452             case LIST_ITEM:
 453             case TABLE_ITEM:
 454                 if (top != null) {
 455                     // reset this flag so subsequent bad inline content gets reported
 456                     top.flags.remove(Flag.REPORTED_BAD_INLINE);
 457                     if (top.tag.accepts(t))
 458                         return;
 459                 }
 460                 break;
 461 
 462             case OTHER:
 463                 switch (t) {
 464                     case SCRIPT:
 465                         // &lt;script&gt; may or may not be allowed, depending on --allow-script-in-comments
 466                         // but we allow it here, and rely on a separate scanner to detect all uses
 467                         // of JavaScript, including &lt;script&gt; tags, and use in attributes, etc.
 468                         break;
 469 
 470                     default:
 471                         env.messages.error(HTML, tree, &quot;dc.tag.not.allowed&quot;, treeName);
 472                 }
 473                 return;
 474         }
 475 
 476         env.messages.error(HTML, tree, &quot;dc.tag.not.allowed.here&quot;, treeName);
 477     }
 478 
 479     private void checkHeading(StartElementTree tree, HtmlTag tag) {
 480         // verify the new tag
 481         if (getHeadingRank(tag) &gt; getHeadingRank(currHeadingTag) + 1) {
 482             if (currHeadingTag == null) {
 483                 env.messages.error(ACCESSIBILITY, tree, &quot;dc.tag.heading.sequence.1&quot;,
 484                         tag, implicitHeadingRank);
 485             } else {
 486                 env.messages.error(ACCESSIBILITY, tree, &quot;dc.tag.heading.sequence.2&quot;,
 487                     tag, currHeadingTag);
 488             }
 489         } else if (getHeadingRank(tag) &lt;= implicitHeadingRank) {
 490             env.messages.error(ACCESSIBILITY, tree, &quot;dc.tag.heading.sequence.3&quot;,
 491                     tag, implicitHeadingRank);
 492         }
 493 
 494         currHeadingTag = tag;
 495     }
 496 
 497     private int getHeadingRank(HtmlTag tag) {
 498         if (tag == null)
 499             return implicitHeadingRank;
 500         switch (tag) {
 501             case H1: return 1;
 502             case H2: return 2;
 503             case H3: return 3;
 504             case H4: return 4;
 505             case H5: return 5;
 506             case H6: return 6;
 507             default: throw new IllegalArgumentException();
 508         }
 509     }
 510 
 511     @Override @DefinedBy(Api.COMPILER_TREE)
 512     public Void visitEndElement(EndElementTree tree, Void ignore) {
 513         final Name treeName = tree.getName();
 514         final HtmlTag t = HtmlTag.get(treeName);
 515         if (t == null) {
 516             env.messages.error(HTML, tree, &quot;dc.tag.unknown&quot;, treeName);
 517         } else if (t.endKind == HtmlTag.EndKind.NONE) {
 518             env.messages.error(HTML, tree, &quot;dc.tag.end.not.permitted&quot;, treeName);
 519         } else {
 520             boolean done = false;
 521             while (!tagStack.isEmpty()) {
 522                 TagStackItem top = tagStack.peek();
 523                 if (t == top.tag) {
 524                     switch (t) {
 525                         case TABLE:
 526                             if (!top.attrs.contains(HtmlTag.Attr.SUMMARY)
 527                                     &amp;&amp; !top.flags.contains(Flag.TABLE_HAS_CAPTION)) {
 528                                 env.messages.error(ACCESSIBILITY, tree,
 529                                         &quot;dc.no.summary.or.caption.for.table&quot;);
 530                             }
 531                             break;
 532 
 533                         case SECTION:
 534                         case ARTICLE:
 535                             if (env.htmlVersion == HtmlVersion.HTML5 &amp;&amp; !top.flags.contains(Flag.HAS_HEADING)) {
 536                                 env.messages.error(HTML, tree, &quot;dc.tag.requires.heading&quot;, treeName);
 537                             }
 538                             break;
 539                     }
 540                     warnIfEmpty(top, tree);
 541                     tagStack.pop();
 542                     done = true;
 543                     break;
 544                 } else if (top.tag == null || top.tag.endKind != HtmlTag.EndKind.REQUIRED) {
 545                     tagStack.pop();
 546                 } else {
 547                     boolean found = false;
 548                     for (TagStackItem si: tagStack) {
 549                         if (si.tag == t) {
 550                             found = true;
 551                             break;
 552                         }
 553                     }
 554                     if (found &amp;&amp; top.tree.getKind() == DocTree.Kind.START_ELEMENT) {
 555                         env.messages.error(HTML, top.tree, &quot;dc.tag.start.unmatched&quot;,
 556                                 ((StartElementTree) top.tree).getName());
 557                         tagStack.pop();
 558                     } else {
 559                         env.messages.error(HTML, tree, &quot;dc.tag.end.unexpected&quot;, treeName);
 560                         done = true;
 561                         break;
 562                     }
 563                 }
 564             }
 565 
 566             if (!done &amp;&amp; tagStack.isEmpty()) {
 567                 env.messages.error(HTML, tree, &quot;dc.tag.end.unexpected&quot;, treeName);
 568             }
 569         }
 570 
 571         return super.visitEndElement(tree, ignore);
 572     }
 573 
 574     void warnIfEmpty(TagStackItem tsi, DocTree endTree) {
 575         if (tsi.tag != null &amp;&amp; tsi.tree instanceof StartElementTree) {
 576             if (tsi.tag.flags.contains(HtmlTag.Flag.EXPECT_CONTENT)
 577                     &amp;&amp; !tsi.flags.contains(Flag.HAS_TEXT)
 578                     &amp;&amp; !tsi.flags.contains(Flag.HAS_ELEMENT)
 579                     &amp;&amp; !tsi.flags.contains(Flag.HAS_INLINE_TAG)) {
 580                 DocTree tree = (endTree != null) ? endTree : tsi.tree;
 581                 Name treeName = ((StartElementTree) tsi.tree).getName();
 582                 env.messages.warning(HTML, tree, &quot;dc.tag.empty&quot;, treeName);
 583             }
 584         }
 585     }
 586 
 587     // &lt;/editor-fold&gt;
 588 
 589     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;HTML attributes&quot;&gt;
 590 
 591     @Override @DefinedBy(Api.COMPILER_TREE) @SuppressWarnings(&quot;fallthrough&quot;)
 592     public Void visitAttribute(AttributeTree tree, Void ignore) {
 593         HtmlTag currTag = tagStack.peek().tag;
 594         if (currTag != null) {
 595             Name name = tree.getName();
 596             HtmlTag.Attr attr = currTag.getAttr(name);
 597             if (attr != null) {
 598                 if (env.htmlVersion == HtmlVersion.HTML4 &amp;&amp; attr.name().contains(&quot;-&quot;)) {
 599                     env.messages.error(HTML, tree, &quot;dc.attr.not.supported.html4&quot;, name);
 600                 }
 601                 boolean first = tagStack.peek().attrs.add(attr);
 602                 if (!first)
 603                     env.messages.error(HTML, tree, &quot;dc.attr.repeated&quot;, name);
 604             }
 605             // for now, doclint allows all attribute names beginning with &quot;on&quot; as event handler names,
 606             // without checking the validity or applicability of the name
 607             if (!name.toString().startsWith(&quot;on&quot;)) {
 608                 AttrKind k = currTag.getAttrKind(name);
 609                 switch (env.htmlVersion) {
 610                     case HTML4:
 611                         validateHtml4Attrs(tree, name, k);
 612                         break;
 613 
 614                     case HTML5:
 615                         validateHtml5Attrs(tree, name, k);
 616                         break;
 617                 }
 618             }
 619 
 620             if (attr != null) {
 621                 switch (attr) {
 622                     case NAME:
 623                         if (currTag != HtmlTag.A) {
 624                             break;
 625                         }
 626                         // fallthrough
 627                     case ID:
 628                         String value = getAttrValue(tree);
 629                         if (value == null) {
 630                             env.messages.error(HTML, tree, &quot;dc.anchor.value.missing&quot;);
 631                         } else {
 632                             if (!validName.matcher(value).matches()) {
 633                                 env.messages.error(HTML, tree, &quot;dc.invalid.anchor&quot;, value);
 634                             }
 635                             if (!checkAnchor(value)) {
 636                                 env.messages.error(HTML, tree, &quot;dc.anchor.already.defined&quot;, value);
 637                             }
 638                         }
 639                         break;
 640 
 641                     case HREF:
 642                         if (currTag == HtmlTag.A) {
 643                             String v = getAttrValue(tree);
 644                             if (v == null || v.isEmpty()) {
 645                                 env.messages.error(HTML, tree, &quot;dc.attr.lacks.value&quot;);
 646                             } else {
 647                                 Matcher m = docRoot.matcher(v);
 648                                 if (m.matches()) {
 649                                     String rest = m.group(2);
 650                                     if (!rest.isEmpty())
 651                                         checkURI(tree, rest);
 652                                 } else {
 653                                     checkURI(tree, v);
 654                                 }
 655                             }
 656                         }
 657                         break;
 658 
 659                     case VALUE:
 660                         if (currTag == HtmlTag.LI) {
 661                             String v = getAttrValue(tree);
 662                             if (v == null || v.isEmpty()) {
 663                                 env.messages.error(HTML, tree, &quot;dc.attr.lacks.value&quot;);
 664                             } else if (!validNumber.matcher(v).matches()) {
 665                                 env.messages.error(HTML, tree, &quot;dc.attr.not.number&quot;);
 666                             }
 667                         }
 668                         break;
 669 
 670                     case BORDER:
 671                         if (currTag == HtmlTag.TABLE) {
 672                             String v = getAttrValue(tree);
 673                             try {
 674                                 if (env.htmlVersion == HtmlVersion.HTML5
 675                                         &amp;&amp; (v == null || (!v.isEmpty() &amp;&amp; Integer.parseInt(v) != 1))) {
 676                                     env.messages.error(HTML, tree, &quot;dc.attr.table.border.html5&quot;, attr);
 677                                 }
 678                             } catch (NumberFormatException ex) {
 679                                 env.messages.error(HTML, tree, &quot;dc.attr.table.border.html5&quot;, attr);
 680                             }
 681                         }
 682                         break;
 683                 }
 684             }
 685         }
 686 
 687         // TODO: basic check on value
 688 
 689         return null;
 690     }
 691 
 692     private void validateHtml4Attrs(AttributeTree tree, Name name, AttrKind k) {
 693         switch (k) {
 694             case ALL:
 695             case HTML4:
 696                 break;
 697 
 698             case INVALID:
 699                 env.messages.error(HTML, tree, &quot;dc.attr.unknown&quot;, name);
 700                 break;
 701 
 702             case OBSOLETE:
 703                 env.messages.warning(HTML, tree, &quot;dc.attr.obsolete&quot;, name);
 704                 break;
 705 
 706             case USE_CSS:
 707                 env.messages.warning(HTML, tree, &quot;dc.attr.obsolete.use.css&quot;, name);
 708                 break;
 709 
 710             case HTML5:
 711                 env.messages.error(HTML, tree, &quot;dc.attr.not.supported.html4&quot;, name);
 712                 break;
 713         }
 714     }
 715 
 716     private void validateHtml5Attrs(AttributeTree tree, Name name, AttrKind k) {
 717         switch (k) {
 718             case ALL:
 719             case HTML5:
 720                 break;
 721 
 722             case INVALID:
 723             case OBSOLETE:
 724             case USE_CSS:
 725             case HTML4:
 726                 env.messages.error(HTML, tree, &quot;dc.attr.not.supported.html5&quot;, name);
 727                 break;
 728         }
 729     }
 730 
 731     private boolean checkAnchor(String name) {
 732         Element e = getEnclosingPackageOrClass(env.currElement);
 733         if (e == null)
 734             return true;
 735         Set&lt;String&gt; set = foundAnchors.get(e);
 736         if (set == null)
 737             foundAnchors.put(e, set = new HashSet&lt;&gt;());
 738         return set.add(name);
 739     }
 740 
 741     private Element getEnclosingPackageOrClass(Element e) {
 742         while (e != null) {
 743             switch (e.getKind()) {
 744                 case CLASS:
 745                 case ENUM:
 746                 case INTERFACE:
 747                 case PACKAGE:
 748                     return e;
 749                 default:
 750                     e = e.getEnclosingElement();
 751             }
 752         }
 753         return e;
 754     }
 755 
 756     // http://www.w3.org/TR/html401/types.html#type-name
 757     private static final Pattern validName = Pattern.compile(&quot;[A-Za-z][A-Za-z0-9-_:.]*&quot;);
 758 
 759     private static final Pattern validNumber = Pattern.compile(&quot;-?[0-9]+&quot;);
 760 
 761     // pattern to remove leading {@docRoot}/?
 762     private static final Pattern docRoot = Pattern.compile(&quot;(?i)(\\{@docRoot *\\}/?)?(.*)&quot;);
 763 
 764     private String getAttrValue(AttributeTree tree) {
 765         if (tree.getValue() == null)
 766             return null;
 767 
 768         StringWriter sw = new StringWriter();
 769         try {
 770             new DocPretty(sw).print(tree.getValue());
 771         } catch (IOException e) {
 772             // cannot happen
 773         }
 774         // ignore potential use of entities for now
 775         return sw.toString();
 776     }
 777 
 778     private void checkURI(AttributeTree tree, String uri) {
 779         // allow URIs beginning with javascript:, which would otherwise be rejected by the URI API.
 780         if (uri.startsWith(&quot;javascript:&quot;))
 781             return;
 782         try {
 783             URI u = new URI(uri);
 784         } catch (URISyntaxException e) {
 785             env.messages.error(HTML, tree, &quot;dc.invalid.uri&quot;, uri);
 786         }
 787     }
 788     // &lt;/editor-fold&gt;
 789 
 790     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;javadoc tags&quot;&gt;
 791 
 792     @Override @DefinedBy(Api.COMPILER_TREE)
 793     public Void visitAuthor(AuthorTree tree, Void ignore) {
 794         warnIfEmpty(tree, tree.getName());
 795         return super.visitAuthor(tree, ignore);
 796     }
 797 
 798     @Override @DefinedBy(Api.COMPILER_TREE)
 799     public Void visitDocRoot(DocRootTree tree, Void ignore) {
 800         markEnclosingTag(Flag.HAS_INLINE_TAG);
 801         return super.visitDocRoot(tree, ignore);
 802     }
 803 
 804     @Override @DefinedBy(Api.COMPILER_TREE)
 805     public Void visitIndex(IndexTree tree, Void ignore) {
 806         for (TagStackItem tsi : tagStack) {
 807             if (tsi.tag == HtmlTag.A) {
 808                 env.messages.warning(HTML, tree, &quot;dc.tag.a.within.a&quot;,
 809                         &quot;{@&quot; + tree.getTagName() + &quot;}&quot;);
 810                 break;
 811             }
 812         }
 813         return super.visitIndex(tree, ignore);
 814     }
 815 
 816     @Override @DefinedBy(Api.COMPILER_TREE)
 817     public Void visitInheritDoc(InheritDocTree tree, Void ignore) {
 818         markEnclosingTag(Flag.HAS_INLINE_TAG);
 819         // TODO: verify on overridden method
 820         foundInheritDoc = true;
 821         return super.visitInheritDoc(tree, ignore);
 822     }
 823 
 824     @Override @DefinedBy(Api.COMPILER_TREE)
 825     public Void visitLink(LinkTree tree, Void ignore) {
 826         markEnclosingTag(Flag.HAS_INLINE_TAG);
 827         // simulate inline context on tag stack
 828         HtmlTag t = (tree.getKind() == DocTree.Kind.LINK)
 829                 ? HtmlTag.CODE : HtmlTag.SPAN;
 830         tagStack.push(new TagStackItem(tree, t));
 831         try {
 832             return super.visitLink(tree, ignore);
 833         } finally {
 834             tagStack.pop();
 835         }
 836     }
 837 
 838     @Override @DefinedBy(Api.COMPILER_TREE)
 839     public Void visitLiteral(LiteralTree tree, Void ignore) {
 840         markEnclosingTag(Flag.HAS_INLINE_TAG);
 841         if (tree.getKind() == DocTree.Kind.CODE) {
 842             for (TagStackItem tsi: tagStack) {
 843                 if (tsi.tag == HtmlTag.CODE) {
 844                     env.messages.warning(HTML, tree, &quot;dc.tag.code.within.code&quot;);
 845                     break;
 846                 }
 847             }
 848         }
 849         return super.visitLiteral(tree, ignore);
 850     }
 851 
 852     @Override @DefinedBy(Api.COMPILER_TREE)
 853     @SuppressWarnings(&quot;fallthrough&quot;)
 854     public Void visitParam(ParamTree tree, Void ignore) {
 855         boolean typaram = tree.isTypeParameter();
 856         IdentifierTree nameTree = tree.getName();
 857         Element paramElement = nameTree != null ? env.trees.getElement(new DocTreePath(getCurrentPath(), nameTree)) : null;
 858 
 859         if (paramElement == null) {
 860             switch (env.currElement.getKind()) {
 861                 case CLASS: case INTERFACE: {
 862                     if (!typaram) {
 863                         env.messages.error(REFERENCE, tree, &quot;dc.invalid.param&quot;);
 864                         break;
 865                     }
 866                 }
 867                 case METHOD: case CONSTRUCTOR: {
 868                     env.messages.error(REFERENCE, nameTree, &quot;dc.param.name.not.found&quot;);
 869                     break;
 870                 }
 871 
 872                 default:
 873                     env.messages.error(REFERENCE, tree, &quot;dc.invalid.param&quot;);
 874                     break;
 875             }
 876         } else {
 877             boolean unique = foundParams.add(paramElement);
 878 
 879             if (!unique) {
 880                 env.messages.warning(REFERENCE, tree, &quot;dc.exists.param&quot;, nameTree);
 881             }
 882         }
 883 
 884         warnIfEmpty(tree, tree.getDescription());
 885         return super.visitParam(tree, ignore);
 886     }
 887 
 888     private void checkParamsDocumented(List&lt;? extends Element&gt; list) {
 889         if (foundInheritDoc)
 890             return;
 891 
 892         for (Element e: list) {
 893             if (!foundParams.contains(e)) {
 894                 CharSequence paramName = (e.getKind() == ElementKind.TYPE_PARAMETER)
 895                         ? &quot;&lt;&quot; + e.getSimpleName() + &quot;&gt;&quot;
 896                         : e.getSimpleName();
 897                 reportMissing(&quot;dc.missing.param&quot;, paramName);
 898             }
 899         }
 900     }
 901 
 902     @Override @DefinedBy(Api.COMPILER_TREE)
 903     public Void visitProvides(ProvidesTree tree, Void ignore) {
 904         Element e = env.trees.getElement(env.currPath);
 905         if (e.getKind() != ElementKind.MODULE) {
 906             env.messages.error(REFERENCE, tree, &quot;dc.invalid.provides&quot;);
 907         }
 908         ReferenceTree serviceType = tree.getServiceType();
 909         Element se = env.trees.getElement(new DocTreePath(getCurrentPath(), serviceType));
 910         if (se == null) {
 911             env.messages.error(REFERENCE, tree, &quot;dc.service.not.found&quot;);
 912         }
 913         return super.visitProvides(tree, ignore);
 914     }
 915 
 916     @Override @DefinedBy(Api.COMPILER_TREE)
 917     public Void visitReference(ReferenceTree tree, Void ignore) {
<a name="1" id="anc1"></a><span class="line-modified"> 918         String sig = tree.getSignature();</span>
<span class="line-modified"> 919         if (sig.contains(&quot;&lt;&quot;) || sig.contains(&quot;&gt;&quot;)) {</span>
<span class="line-modified"> 920             env.messages.error(REFERENCE, tree, &quot;dc.type.arg.not.allowed&quot;);</span>
<span class="line-removed"> 921         } else {</span>
<span class="line-removed"> 922             Element e = env.trees.getElement(getCurrentPath());</span>
<span class="line-removed"> 923             if (e == null)</span>
<span class="line-removed"> 924                 env.messages.error(REFERENCE, tree, &quot;dc.ref.not.found&quot;);</span>
<span class="line-removed"> 925         }</span>
 926         return super.visitReference(tree, ignore);
 927     }
 928 
 929     @Override @DefinedBy(Api.COMPILER_TREE)
 930     public Void visitReturn(ReturnTree tree, Void ignore) {
 931         if (foundReturn) {
 932             env.messages.warning(REFERENCE, tree, &quot;dc.exists.return&quot;);
 933         }
 934 
 935         Element e = env.trees.getElement(env.currPath);
 936         if (e.getKind() != ElementKind.METHOD
 937                 || ((ExecutableElement) e).getReturnType().getKind() == TypeKind.VOID)
 938             env.messages.error(REFERENCE, tree, &quot;dc.invalid.return&quot;);
 939         foundReturn = true;
 940         warnIfEmpty(tree, tree.getDescription());
 941         return super.visitReturn(tree, ignore);
 942     }
 943 
 944     @Override @DefinedBy(Api.COMPILER_TREE)
 945     public Void visitSerialData(SerialDataTree tree, Void ignore) {
 946         warnIfEmpty(tree, tree.getDescription());
 947         return super.visitSerialData(tree, ignore);
 948     }
 949 
 950     @Override @DefinedBy(Api.COMPILER_TREE)
 951     public Void visitSerialField(SerialFieldTree tree, Void ignore) {
 952         warnIfEmpty(tree, tree.getDescription());
 953         return super.visitSerialField(tree, ignore);
 954     }
 955 
 956     @Override @DefinedBy(Api.COMPILER_TREE)
 957     public Void visitSince(SinceTree tree, Void ignore) {
 958         warnIfEmpty(tree, tree.getBody());
 959         return super.visitSince(tree, ignore);
 960     }
 961 
 962     @Override @DefinedBy(Api.COMPILER_TREE)
 963     public Void visitSummary(SummaryTree node, Void aVoid) {
 964         int idx = env.currDocComment.getFullBody().indexOf(node);
 965         // Warn if the node is preceded by non-whitespace characters,
 966         // or other non-text nodes.
 967         if ((idx == 1 &amp;&amp; hasNonWhitespaceText) || idx &gt; 1) {
 968             env.messages.warning(SYNTAX, node, &quot;dc.invalid.summary&quot;, node.getTagName());
 969         }
 970         return super.visitSummary(node, aVoid);
 971     }
 972 
 973     @Override @DefinedBy(Api.COMPILER_TREE)
 974     public Void visitSystemProperty(SystemPropertyTree tree, Void ignore) {
 975         for (TagStackItem tsi : tagStack) {
 976             if (tsi.tag == HtmlTag.A) {
 977                 env.messages.warning(HTML, tree, &quot;dc.tag.a.within.a&quot;,
 978                         &quot;{@&quot; + tree.getTagName() + &quot;}&quot;);
 979                 break;
 980             }
 981         }
 982         return super.visitSystemProperty(tree, ignore);
 983     }
 984 
 985     @Override @DefinedBy(Api.COMPILER_TREE)
 986     public Void visitThrows(ThrowsTree tree, Void ignore) {
 987         ReferenceTree exName = tree.getExceptionName();
 988         Element ex = env.trees.getElement(new DocTreePath(getCurrentPath(), exName));
 989         if (ex == null) {
 990             env.messages.error(REFERENCE, tree, &quot;dc.ref.not.found&quot;);
 991         } else if (isThrowable(ex.asType())) {
 992             switch (env.currElement.getKind()) {
 993                 case CONSTRUCTOR:
 994                 case METHOD:
 995                     if (isCheckedException(ex.asType())) {
 996                         ExecutableElement ee = (ExecutableElement) env.currElement;
 997                         checkThrowsDeclared(exName, ex.asType(), ee.getThrownTypes());
 998                     }
 999                     break;
1000                 default:
1001                     env.messages.error(REFERENCE, tree, &quot;dc.invalid.throws&quot;);
1002             }
1003         } else {
1004             env.messages.error(REFERENCE, tree, &quot;dc.invalid.throws&quot;);
1005         }
1006         warnIfEmpty(tree, tree.getDescription());
1007         return scan(tree.getDescription(), ignore);
1008     }
1009 
1010     private boolean isThrowable(TypeMirror tm) {
1011         switch (tm.getKind()) {
1012             case DECLARED:
1013             case TYPEVAR:
1014                 return env.types.isAssignable(tm, env.java_lang_Throwable);
1015         }
1016         return false;
1017     }
1018 
1019     private void checkThrowsDeclared(ReferenceTree tree, TypeMirror t, List&lt;? extends TypeMirror&gt; list) {
1020         boolean found = false;
1021         for (TypeMirror tl : list) {
1022             if (env.types.isAssignable(t, tl)) {
1023                 foundThrows.add(tl);
1024                 found = true;
1025             }
1026         }
1027         if (!found)
1028             env.messages.error(REFERENCE, tree, &quot;dc.exception.not.thrown&quot;, t);
1029     }
1030 
1031     private void checkThrowsDocumented(List&lt;? extends TypeMirror&gt; list) {
1032         if (foundInheritDoc)
1033             return;
1034 
1035         for (TypeMirror tl: list) {
1036             if (isCheckedException(tl) &amp;&amp; !foundThrows.contains(tl))
1037                 reportMissing(&quot;dc.missing.throws&quot;, tl);
1038         }
1039     }
1040 
1041     @Override @DefinedBy(Api.COMPILER_TREE)
1042     public Void visitUnknownBlockTag(UnknownBlockTagTree tree, Void ignore) {
1043         checkUnknownTag(tree, tree.getTagName());
1044         return super.visitUnknownBlockTag(tree, ignore);
1045     }
1046 
1047     @Override @DefinedBy(Api.COMPILER_TREE)
1048     public Void visitUnknownInlineTag(UnknownInlineTagTree tree, Void ignore) {
1049         checkUnknownTag(tree, tree.getTagName());
1050         return super.visitUnknownInlineTag(tree, ignore);
1051     }
1052 
1053     private void checkUnknownTag(DocTree tree, String tagName) {
1054         if (env.customTags != null &amp;&amp; !env.customTags.contains(tagName))
1055             env.messages.error(SYNTAX, tree, &quot;dc.tag.unknown&quot;, tagName);
1056     }
1057 
1058     @Override @DefinedBy(Api.COMPILER_TREE)
1059     public Void visitUses(UsesTree tree, Void ignore) {
1060         Element e = env.trees.getElement(env.currPath);
1061         if (e.getKind() != ElementKind.MODULE) {
1062             env.messages.error(REFERENCE, tree, &quot;dc.invalid.uses&quot;);
1063         }
1064         ReferenceTree serviceType = tree.getServiceType();
1065         Element se = env.trees.getElement(new DocTreePath(getCurrentPath(), serviceType));
1066         if (se == null) {
1067             env.messages.error(REFERENCE, tree, &quot;dc.service.not.found&quot;);
1068         }
1069         return super.visitUses(tree, ignore);
1070     }
1071 
1072     @Override @DefinedBy(Api.COMPILER_TREE)
1073     public Void visitValue(ValueTree tree, Void ignore) {
1074         ReferenceTree ref = tree.getReference();
1075         if (ref == null || ref.getSignature().isEmpty()) {
1076             if (!isConstant(env.currElement))
1077                 env.messages.error(REFERENCE, tree, &quot;dc.value.not.allowed.here&quot;);
1078         } else {
1079             Element e = env.trees.getElement(new DocTreePath(getCurrentPath(), ref));
1080             if (!isConstant(e))
1081                 env.messages.error(REFERENCE, tree, &quot;dc.value.not.a.constant&quot;);
1082         }
1083 
1084         markEnclosingTag(Flag.HAS_INLINE_TAG);
1085         return super.visitValue(tree, ignore);
1086     }
1087 
1088     private boolean isConstant(Element e) {
1089         if (e == null)
1090             return false;
1091 
1092         switch (e.getKind()) {
1093             case FIELD:
1094                 Object value = ((VariableElement) e).getConstantValue();
1095                 return (value != null); // can&#39;t distinguish &quot;not a constant&quot; from &quot;constant is null&quot;
1096             default:
1097                 return false;
1098         }
1099     }
1100 
1101     @Override @DefinedBy(Api.COMPILER_TREE)
1102     public Void visitVersion(VersionTree tree, Void ignore) {
1103         warnIfEmpty(tree, tree.getBody());
1104         return super.visitVersion(tree, ignore);
1105     }
1106 
1107     @Override @DefinedBy(Api.COMPILER_TREE)
1108     public Void visitErroneous(ErroneousTree tree, Void ignore) {
1109         env.messages.error(SYNTAX, tree, null, tree.getDiagnostic().getMessage(null));
1110         return null;
1111     }
1112     // &lt;/editor-fold&gt;
1113 
1114     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Utility methods&quot;&gt;
1115 
1116     private boolean isCheckedException(TypeMirror t) {
1117         return !(env.types.isAssignable(t, env.java_lang_Error)
1118                 || env.types.isAssignable(t, env.java_lang_RuntimeException));
1119     }
1120 
1121     private boolean isSynthetic() {
1122         switch (env.currElement.getKind()) {
1123             case CONSTRUCTOR:
1124                 // A synthetic default constructor has the same pos as the
1125                 // enclosing class
1126                 TreePath p = env.currPath;
1127                 return env.getPos(p) == env.getPos(p.getParentPath());
1128         }
1129         return false;
1130     }
1131 
1132     void markEnclosingTag(Flag flag) {
1133         TagStackItem top = tagStack.peek();
1134         if (top != null)
1135             top.flags.add(flag);
1136     }
1137 
1138     String toString(TreePath p) {
1139         StringBuilder sb = new StringBuilder(&quot;TreePath[&quot;);
1140         toString(p, sb);
1141         sb.append(&quot;]&quot;);
1142         return sb.toString();
1143     }
1144 
1145     void toString(TreePath p, StringBuilder sb) {
1146         TreePath parent = p.getParentPath();
1147         if (parent != null) {
1148             toString(parent, sb);
1149             sb.append(&quot;,&quot;);
1150         }
1151        sb.append(p.getLeaf().getKind()).append(&quot;:&quot;).append(env.getPos(p)).append(&quot;:S&quot;).append(env.getStartPos(p));
1152     }
1153 
1154     void warnIfEmpty(DocTree tree, List&lt;? extends DocTree&gt; list) {
1155         for (DocTree d: list) {
1156             switch (d.getKind()) {
1157                 case TEXT:
1158                     if (hasNonWhitespace((TextTree) d))
1159                         return;
1160                     break;
1161                 default:
1162                     return;
1163             }
1164         }
1165         env.messages.warning(SYNTAX, tree, &quot;dc.empty&quot;, tree.getKind().tagName);
1166     }
1167 
1168     boolean hasNonWhitespace(TextTree tree) {
1169         String s = tree.getBody();
1170         for (int i = 0; i &lt; s.length(); i++) {
1171             Character c = s.charAt(i);
1172             if (!Character.isWhitespace(s.charAt(i)))
1173                 return true;
1174         }
1175         return false;
1176     }
1177 
1178     // &lt;/editor-fold&gt;
1179 
1180 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
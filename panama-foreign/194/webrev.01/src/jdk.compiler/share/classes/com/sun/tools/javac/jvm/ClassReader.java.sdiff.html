<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../comp/TypeEnter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ClassWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 




 108     /** Switch: allow records
 109      */
 110     boolean allowRecords;
 111 
 112    /** Lint option: warn about classfile issues
 113      */
 114     boolean lintClassfile;
 115 
 116     /** Switch: preserve parameter names from the variable table.
 117      */
 118     public boolean saveParameterNames;
 119 
 120     /**
 121      * The currently selected profile.
 122      */
 123     public final Profile profile;
 124 
 125     /** The log to use for verbose output
 126      */
 127     final Log log;
</pre>
<hr />
<pre>
 253         annotate = Annotate.instance(context);
 254         names = Names.instance(context);
 255         syms = Symtab.instance(context);
 256         types = Types.instance(context);
 257         fileManager = context.get(JavaFileManager.class);
 258         if (fileManager == null)
 259             throw new AssertionError(&quot;FileManager initialization error&quot;);
 260         diagFactory = JCDiagnostic.Factory.instance(context);
 261         dcfh = DeferredCompletionFailureHandler.instance(context);
 262 
 263         log = Log.instance(context);
 264 
 265         Options options = Options.instance(context);
 266         verbose         = options.isSet(Option.VERBOSE);
 267 
 268         Source source = Source.instance(context);
 269         preview = Preview.instance(context);
 270         allowModules     = Feature.MODULES.allowedInSource(source);
 271         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 272                 Feature.RECORDS.allowedInSource(source);


 273 
 274         saveParameterNames = options.isSet(PARAMETERS);
 275 
 276         profile = Profile.instance(context);
 277 
 278         typevars = WriteableScope.create(syms.noSymbol);
 279 
 280         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 281 
 282         initAttributeReaders();
 283     }
 284 
 285     /** Add member to class unless it is synthetic.
 286      */
 287     private void enterMember(ClassSymbol c, Symbol sym) {
 288         // Synthetic members are not entered -- reason lost to history (optimization?).
 289         // Lambda methods must be entered because they may have inner classes (which reference them)
 290         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))
 291             c.members_field.enter(sym);
 292     }
</pre>
<hr />
<pre>
1185                 }
1186                 protected void read(Symbol sym, int attrLen) {
1187                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1188                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1189                         msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
1190                     }
1191                 }
1192             },
1193 
1194             new AttributeReader(names.Record, V58, CLASS_ATTRIBUTE) {
1195                 @Override
1196                 protected boolean accepts(AttributeKind kind) {
1197                     return super.accepts(kind) &amp;&amp; allowRecords;
1198                 }
1199                 protected void read(Symbol sym, int attrLen) {
1200                     if (sym.kind == TYP) {
1201                         sym.flags_field |= RECORD;
1202                     }
1203                     bp = bp + attrLen;
1204                 }
<span class="line-modified">1205             }</span>
















1206         };
1207 
1208         for (AttributeReader r: readers)
1209             attributeReaders.put(r.name, r);
1210     }
1211 
1212     protected void readEnclosingMethodAttr(Symbol sym) {
1213         // sym is a nested class with an &quot;Enclosing Method&quot; attribute
1214         // remove sym from it&#39;s current owners scope and place it in
1215         // the scope specified by the attribute
1216         sym.owner.members().remove(sym);
1217         ClassSymbol self = (ClassSymbol)sym;
1218         ClassSymbol c = poolReader.getClass(nextChar());
1219         NameAndType nt = optPoolEntry(nextChar(), poolReader::getNameAndType, null);
1220 
1221         if (c.members_field == null || c.kind != TYP)
1222             throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
1223 
1224         MethodSymbol m = findMethod(nt, c.members_field, self.flags());
1225         if (nt != null &amp;&amp; m == null)
</pre>
<hr />
<pre>
2453                         Integer.toString(minorVersion));
2454             }
2455             c.flags_field = flags;
2456             currentModule = (ModuleSymbol) c.owner;
2457             int this_class = nextChar();
2458             // temp, no check on this_class
2459         }
2460 
2461         // class attributes must be read before class
2462         // skip ahead to read class attributes
2463         int startbp = bp;
2464         nextChar();
2465         char interfaceCount = nextChar();
2466         bp += interfaceCount * 2;
2467         char fieldCount = nextChar();
2468         for (int i = 0; i &lt; fieldCount; i++) skipMember();
2469         char methodCount = nextChar();
2470         for (int i = 0; i &lt; methodCount; i++) skipMember();
2471         readClassAttrs(c);
2472 




2473         // reset and read rest of classinfo
2474         bp = startbp;
2475         int n = nextChar();
2476         if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
2477             throw badClassFile(&quot;module.info.invalid.super.class&quot;);
2478         }
2479         if (ct.supertype_field == null)
2480             ct.supertype_field =
2481                     optPoolEntry(n, idx -&gt; poolReader.getClass(idx).erasure(types), Type.noType);
2482         n = nextChar();
2483         List&lt;Type&gt; is = List.nil();
2484         for (int i = 0; i &lt; n; i++) {
2485             Type _inter = poolReader.getClass(nextChar()).erasure(types);
2486             is = is.prepend(_inter);
2487         }
2488         if (ct.interfaces_field == null)
2489             ct.interfaces_field = is.reverse();
2490 
2491         Assert.check(fieldCount == nextChar());
2492         for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 
<span class="line-added"> 108     /** Switch: allow sealed</span>
<span class="line-added"> 109      */</span>
<span class="line-added"> 110     boolean allowSealedTypes;</span>
<span class="line-added"> 111 </span>
 112     /** Switch: allow records
 113      */
 114     boolean allowRecords;
 115 
 116    /** Lint option: warn about classfile issues
 117      */
 118     boolean lintClassfile;
 119 
 120     /** Switch: preserve parameter names from the variable table.
 121      */
 122     public boolean saveParameterNames;
 123 
 124     /**
 125      * The currently selected profile.
 126      */
 127     public final Profile profile;
 128 
 129     /** The log to use for verbose output
 130      */
 131     final Log log;
</pre>
<hr />
<pre>
 257         annotate = Annotate.instance(context);
 258         names = Names.instance(context);
 259         syms = Symtab.instance(context);
 260         types = Types.instance(context);
 261         fileManager = context.get(JavaFileManager.class);
 262         if (fileManager == null)
 263             throw new AssertionError(&quot;FileManager initialization error&quot;);
 264         diagFactory = JCDiagnostic.Factory.instance(context);
 265         dcfh = DeferredCompletionFailureHandler.instance(context);
 266 
 267         log = Log.instance(context);
 268 
 269         Options options = Options.instance(context);
 270         verbose         = options.isSet(Option.VERBOSE);
 271 
 272         Source source = Source.instance(context);
 273         preview = Preview.instance(context);
 274         allowModules     = Feature.MODULES.allowedInSource(source);
 275         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 276                 Feature.RECORDS.allowedInSource(source);
<span class="line-added"> 277         allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 278                 Feature.SEALED_CLASSES.allowedInSource(source);</span>
 279 
 280         saveParameterNames = options.isSet(PARAMETERS);
 281 
 282         profile = Profile.instance(context);
 283 
 284         typevars = WriteableScope.create(syms.noSymbol);
 285 
 286         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 287 
 288         initAttributeReaders();
 289     }
 290 
 291     /** Add member to class unless it is synthetic.
 292      */
 293     private void enterMember(ClassSymbol c, Symbol sym) {
 294         // Synthetic members are not entered -- reason lost to history (optimization?).
 295         // Lambda methods must be entered because they may have inner classes (which reference them)
 296         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))
 297             c.members_field.enter(sym);
 298     }
</pre>
<hr />
<pre>
1191                 }
1192                 protected void read(Symbol sym, int attrLen) {
1193                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1194                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1195                         msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
1196                     }
1197                 }
1198             },
1199 
1200             new AttributeReader(names.Record, V58, CLASS_ATTRIBUTE) {
1201                 @Override
1202                 protected boolean accepts(AttributeKind kind) {
1203                     return super.accepts(kind) &amp;&amp; allowRecords;
1204                 }
1205                 protected void read(Symbol sym, int attrLen) {
1206                     if (sym.kind == TYP) {
1207                         sym.flags_field |= RECORD;
1208                     }
1209                     bp = bp + attrLen;
1210                 }
<span class="line-modified">1211             },</span>
<span class="line-added">1212             new AttributeReader(names.PermittedSubclasses, V59, CLASS_ATTRIBUTE) {</span>
<span class="line-added">1213                 @Override</span>
<span class="line-added">1214                 protected boolean accepts(AttributeKind kind) {</span>
<span class="line-added">1215                     return super.accepts(kind) &amp;&amp; allowSealedTypes;</span>
<span class="line-added">1216                 }</span>
<span class="line-added">1217                 protected void read(Symbol sym, int attrLen) {</span>
<span class="line-added">1218                     if (sym.kind == TYP) {</span>
<span class="line-added">1219                         ListBuffer&lt;Symbol&gt; subtypes = new ListBuffer&lt;&gt;();</span>
<span class="line-added">1220                         int numberOfPermittedSubtypes = nextChar();</span>
<span class="line-added">1221                         for (int i = 0; i &lt; numberOfPermittedSubtypes; i++) {</span>
<span class="line-added">1222                             subtypes.add(poolReader.getClass(nextChar()));</span>
<span class="line-added">1223                         }</span>
<span class="line-added">1224                         ((ClassSymbol)sym).permitted = subtypes.toList();</span>
<span class="line-added">1225                     }</span>
<span class="line-added">1226                 }</span>
<span class="line-added">1227             },</span>
1228         };
1229 
1230         for (AttributeReader r: readers)
1231             attributeReaders.put(r.name, r);
1232     }
1233 
1234     protected void readEnclosingMethodAttr(Symbol sym) {
1235         // sym is a nested class with an &quot;Enclosing Method&quot; attribute
1236         // remove sym from it&#39;s current owners scope and place it in
1237         // the scope specified by the attribute
1238         sym.owner.members().remove(sym);
1239         ClassSymbol self = (ClassSymbol)sym;
1240         ClassSymbol c = poolReader.getClass(nextChar());
1241         NameAndType nt = optPoolEntry(nextChar(), poolReader::getNameAndType, null);
1242 
1243         if (c.members_field == null || c.kind != TYP)
1244             throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
1245 
1246         MethodSymbol m = findMethod(nt, c.members_field, self.flags());
1247         if (nt != null &amp;&amp; m == null)
</pre>
<hr />
<pre>
2475                         Integer.toString(minorVersion));
2476             }
2477             c.flags_field = flags;
2478             currentModule = (ModuleSymbol) c.owner;
2479             int this_class = nextChar();
2480             // temp, no check on this_class
2481         }
2482 
2483         // class attributes must be read before class
2484         // skip ahead to read class attributes
2485         int startbp = bp;
2486         nextChar();
2487         char interfaceCount = nextChar();
2488         bp += interfaceCount * 2;
2489         char fieldCount = nextChar();
2490         for (int i = 0; i &lt; fieldCount; i++) skipMember();
2491         char methodCount = nextChar();
2492         for (int i = 0; i &lt; methodCount; i++) skipMember();
2493         readClassAttrs(c);
2494 
<span class="line-added">2495         if (c.permitted != null &amp;&amp; !c.permitted.isEmpty()) {</span>
<span class="line-added">2496             c.flags_field |= SEALED;</span>
<span class="line-added">2497         }</span>
<span class="line-added">2498 </span>
2499         // reset and read rest of classinfo
2500         bp = startbp;
2501         int n = nextChar();
2502         if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
2503             throw badClassFile(&quot;module.info.invalid.super.class&quot;);
2504         }
2505         if (ct.supertype_field == null)
2506             ct.supertype_field =
2507                     optPoolEntry(n, idx -&gt; poolReader.getClass(idx).erasure(types), Type.noType);
2508         n = nextChar();
2509         List&lt;Type&gt; is = List.nil();
2510         for (int i = 0; i &lt; n; i++) {
2511             Type _inter = poolReader.getClass(nextChar()).erasure(types);
2512             is = is.prepend(_inter);
2513         }
2514         if (ct.interfaces_field == null)
2515             ct.interfaces_field = is.reverse();
2516 
2517         Assert.check(fieldCount == nextChar());
2518         for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
</pre>
</td>
</tr>
</table>
<center><a href="../comp/TypeEnter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ClassWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Source.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Types.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 405     public boolean isInterface() {
 406         return (flags() &amp; INTERFACE) != 0;
 407     }
 408 
 409     public boolean isAbstract() {
 410         return (flags_field &amp; ABSTRACT) != 0;
 411     }
 412 
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 
 417     public boolean isPublic() {
 418         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 419     }
 420 
 421     public boolean isEnum() {
 422         return (flags() &amp; ENUM) != 0;
 423     }
 424 








 425     public boolean isFinal() {
 426         return (flags_field &amp; FINAL) != 0;
 427     }
 428 
 429    /** Is this symbol declared (directly or indirectly) local
 430      *  to a method or variable initializer?
 431      *  Also includes fields of inner classes which are in
 432      *  turn local to a method or variable initializer.
 433      */
 434     public boolean isLocal() {
 435         return
 436             (owner.kind.matches(KindSelector.VAL_MTH) ||
 437              (owner.kind == TYP &amp;&amp; owner.isLocal()));
 438     }
 439 
 440     /** Has this symbol an empty name? This includes anonymous
 441      *  inner classes.
 442      */
 443     public boolean isAnonymous() {
 444         return name.isEmpty();
</pre>
<hr />
<pre>
1268         public JavaFileObject sourcefile;
1269 
1270         /** the classfile from where to load this class
1271          *  this will have extension .class or .java
1272          */
1273         public JavaFileObject classfile;
1274 
1275         /** the list of translated local classes (used for generating
1276          * InnerClasses attribute)
1277          */
1278         public List&lt;ClassSymbol&gt; trans_local;
1279 
1280         /** the annotation metadata attached to this class */
1281         private AnnotationTypeMetadata annotationTypeMetadata;
1282 
1283         /* the list of any of record components, only non empty if the class is a record
1284          * and it has at least one record component
1285          */
1286         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1287 







1288         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1289             super(TYP, flags, name, type, owner);
1290             this.members_field = null;
1291             this.fullname = formFullName(name, owner);
1292             this.flatname = formFlatName(name, owner);
1293             this.sourcefile = null;
1294             this.classfile = null;
1295             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();

1296         }
1297 
1298         public ClassSymbol(long flags, Name name, Symbol owner) {
1299             this(
1300                 flags,
1301                 name,
1302                 new ClassType(Type.noType, null, null),
1303                 owner);
1304             this.type.tsym = this;
1305         }
1306 
1307         /** The Java source which this symbol represents.
1308          */
1309         public String toString() {
1310             return className();
1311         }
1312 
1313         public long flags() {
1314             complete();
1315             return flags_field;
</pre>
<hr />
<pre>
1584 
1585         @Override
1586         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1587             return annotationTypeMetadata;
1588         }
1589 
1590         @Override
1591         public boolean isAnnotationType() {
1592             return (flags_field &amp; Flags.ANNOTATION) != 0;
1593         }
1594 
1595         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1596             Assert.checkNonNull(a);
1597             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1598             this.annotationTypeMetadata = a;
1599         }
1600 
1601         public boolean isRecord() {
1602             return (flags_field &amp; RECORD) != 0;
1603         }





1604     }
1605 
1606 
1607     /** A class for variable symbols
1608      */
1609     public static class VarSymbol extends Symbol implements VariableElement {
1610 
1611         /** The variable&#39;s declaration position.
1612          */
1613         public int pos = Position.NOPOS;
1614 
1615         /** The variable&#39;s address. Used for different purposes during
1616          *  flow analysis, translation and code generation.
1617          *  Flow analysis:
1618          *    If this is a blank final or local variable, its sequence number.
1619          *  Translation:
1620          *    If this is a private field, its access number.
1621          *  Code generation:
1622          *    If this is a local variable, its logical slot number.
1623          */
</pre>
</td>
<td>
<hr />
<pre>
 405     public boolean isInterface() {
 406         return (flags() &amp; INTERFACE) != 0;
 407     }
 408 
 409     public boolean isAbstract() {
 410         return (flags_field &amp; ABSTRACT) != 0;
 411     }
 412 
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 
 417     public boolean isPublic() {
 418         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 419     }
 420 
 421     public boolean isEnum() {
 422         return (flags() &amp; ENUM) != 0;
 423     }
 424 
<span class="line-added"> 425     public boolean isSealed() {</span>
<span class="line-added"> 426         return (flags_field &amp; SEALED) != 0;</span>
<span class="line-added"> 427     }</span>
<span class="line-added"> 428 </span>
<span class="line-added"> 429     public boolean isNonSealed() {</span>
<span class="line-added"> 430         return (flags_field &amp; NON_SEALED) != 0;</span>
<span class="line-added"> 431     }</span>
<span class="line-added"> 432 </span>
 433     public boolean isFinal() {
 434         return (flags_field &amp; FINAL) != 0;
 435     }
 436 
 437    /** Is this symbol declared (directly or indirectly) local
 438      *  to a method or variable initializer?
 439      *  Also includes fields of inner classes which are in
 440      *  turn local to a method or variable initializer.
 441      */
 442     public boolean isLocal() {
 443         return
 444             (owner.kind.matches(KindSelector.VAL_MTH) ||
 445              (owner.kind == TYP &amp;&amp; owner.isLocal()));
 446     }
 447 
 448     /** Has this symbol an empty name? This includes anonymous
 449      *  inner classes.
 450      */
 451     public boolean isAnonymous() {
 452         return name.isEmpty();
</pre>
<hr />
<pre>
1276         public JavaFileObject sourcefile;
1277 
1278         /** the classfile from where to load this class
1279          *  this will have extension .class or .java
1280          */
1281         public JavaFileObject classfile;
1282 
1283         /** the list of translated local classes (used for generating
1284          * InnerClasses attribute)
1285          */
1286         public List&lt;ClassSymbol&gt; trans_local;
1287 
1288         /** the annotation metadata attached to this class */
1289         private AnnotationTypeMetadata annotationTypeMetadata;
1290 
1291         /* the list of any of record components, only non empty if the class is a record
1292          * and it has at least one record component
1293          */
1294         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1295 
<span class="line-added">1296         // sealed classes related fields</span>
<span class="line-added">1297         /** The classes, or interfaces, permitted to extend this class, or interface</span>
<span class="line-added">1298          */</span>
<span class="line-added">1299         public List&lt;Symbol&gt; permitted;</span>
<span class="line-added">1300 </span>
<span class="line-added">1301         public boolean isPermittedExplicit = false;</span>
<span class="line-added">1302 </span>
1303         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1304             super(TYP, flags, name, type, owner);
1305             this.members_field = null;
1306             this.fullname = formFullName(name, owner);
1307             this.flatname = formFlatName(name, owner);
1308             this.sourcefile = null;
1309             this.classfile = null;
1310             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
<span class="line-added">1311             this.permitted = List.nil();</span>
1312         }
1313 
1314         public ClassSymbol(long flags, Name name, Symbol owner) {
1315             this(
1316                 flags,
1317                 name,
1318                 new ClassType(Type.noType, null, null),
1319                 owner);
1320             this.type.tsym = this;
1321         }
1322 
1323         /** The Java source which this symbol represents.
1324          */
1325         public String toString() {
1326             return className();
1327         }
1328 
1329         public long flags() {
1330             complete();
1331             return flags_field;
</pre>
<hr />
<pre>
1600 
1601         @Override
1602         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1603             return annotationTypeMetadata;
1604         }
1605 
1606         @Override
1607         public boolean isAnnotationType() {
1608             return (flags_field &amp; Flags.ANNOTATION) != 0;
1609         }
1610 
1611         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1612             Assert.checkNonNull(a);
1613             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1614             this.annotationTypeMetadata = a;
1615         }
1616 
1617         public boolean isRecord() {
1618             return (flags_field &amp; RECORD) != 0;
1619         }
<span class="line-added">1620 </span>
<span class="line-added">1621         @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="line-added">1622         public List&lt;Type&gt; getPermittedSubclasses() {</span>
<span class="line-added">1623             return permitted.map(s -&gt; s.type);</span>
<span class="line-added">1624         }</span>
1625     }
1626 
1627 
1628     /** A class for variable symbols
1629      */
1630     public static class VarSymbol extends Symbol implements VariableElement {
1631 
1632         /** The variable&#39;s declaration position.
1633          */
1634         public int pos = Position.NOPOS;
1635 
1636         /** The variable&#39;s address. Used for different purposes during
1637          *  flow analysis, translation and code generation.
1638          *  Flow analysis:
1639          *    If this is a blank final or local variable, its sequence number.
1640          *  Translation:
1641          *    If this is a private field, its access number.
1642          *  Code generation:
1643          *    If this is a local variable, its logical slot number.
1644          */
</pre>
</td>
</tr>
</table>
<center><a href="Source.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Types.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import java.io.*;
  29 import java.util.LinkedHashMap;
  30 import java.util.Map;
  31 import java.util.Set;
  32 import java.util.LinkedHashSet;
  33 import java.util.function.ToIntFunction;
  34 
  35 import javax.tools.JavaFileManager;
  36 import javax.tools.FileObject;
  37 import javax.tools.JavaFileManager.Location;
  38 import javax.tools.JavaFileObject;
  39 
  40 import com.sun.tools.javac.code.*;
  41 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  42 import com.sun.tools.javac.code.Directive.*;
  43 import com.sun.tools.javac.code.Symbol.*;
  44 import com.sun.tools.javac.code.Type.*;
  45 import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;
  46 import com.sun.tools.javac.comp.Check;
  47 import com.sun.tools.javac.file.PathFileObject;
  48 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
  49 import com.sun.tools.javac.jvm.PoolConstant.Dynamic.BsmKey;
  50 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  51 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  52 import com.sun.tools.javac.util.*;
  53 import com.sun.tools.javac.util.List;
  54 
  55 import static com.sun.tools.javac.code.Flags.*;
  56 import static com.sun.tools.javac.code.Kinds.Kind.*;
  57 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  58 import static com.sun.tools.javac.code.TypeTag.*;
  59 import static com.sun.tools.javac.main.Option.*;
  60 
  61 import static javax.tools.StandardLocation.CLASS_OUTPUT;
  62 
  63 /** This class provides operations to map an internal symbol table graph
  64  *  rooted in a ClassSymbol into a classfile.
  65  *
  66  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  67  *  If you write code that depends on this, you do so at your own risk.
  68  *  This code and its internal interfaces are subject to change or
  69  *  deletion without notice.&lt;/b&gt;
  70  */
  71 public class ClassWriter extends ClassFile {
  72     protected static final Context.Key&lt;ClassWriter&gt; classWriterKey = new Context.Key&lt;&gt;();
  73 
  74     private final Options options;
  75 
  76     /** Switch: verbose output.
  77      */
  78     private boolean verbose;
  79 
  80     /** Switch: emit source file attribute.
  81      */
  82     private boolean emitSourceFile;
  83 
  84     /** Switch: generate CharacterRangeTable attribute.
  85      */
  86     private boolean genCrt;
  87 
  88     /** Switch: describe the generated stackmap.
  89      */
  90     private boolean debugstackmap;
  91 
  92     /** Preview language level.
  93      */
  94     private Preview preview;
  95 
  96     /**
  97      * Target class version.
  98      */
  99     private Target target;
 100 
 101     /**
 102      * Source language version.
 103      */
 104     private Source source;
 105 
 106     /** Type utilities. */
 107     private Types types;
 108 
 109     private Check check;
 110 
 111     /**
 112      * If true, class files will be written in module-specific subdirectories
 113      * of the CLASS_OUTPUT location.
 114      */
 115     public boolean multiModuleMode;
 116 
 117     private List&lt;ToIntFunction&lt;Symbol&gt;&gt; extraAttributeHooks = List.nil();
 118 
 119     /** The initial sizes of the data and constant pool buffers.
 120      *  Sizes are increased when buffers get full.
 121      */
 122     static final int DATA_BUF_SIZE = 0x0fff0;
 123     static final int CLASS_BUF_SIZE = 0x1fff0;
 124 
 125     /** An output buffer for member info.
 126      */
 127     public ByteBuffer databuf = new ByteBuffer(DATA_BUF_SIZE);
 128 
 129     /** An output buffer for the constant pool.
 130      */
 131     ByteBuffer poolbuf = new ByteBuffer(CLASS_BUF_SIZE);
 132 
 133     /** The constant pool writer.
 134      */
 135     final PoolWriter poolWriter;
 136 
 137     /** The log to use for verbose output.
 138      */
 139     private final Log log;
 140 
 141     /** The name table. */
 142     private final Names names;
 143 
 144     /** Access to files. */
 145     private final JavaFileManager fileManager;
 146 
 147     /** The tags and constants used in compressed stackmap. */
 148     static final int SAME_FRAME_SIZE = 64;
 149     static final int SAME_LOCALS_1_STACK_ITEM_EXTENDED = 247;
 150     static final int SAME_FRAME_EXTENDED = 251;
 151     static final int FULL_FRAME = 255;
 152     static final int MAX_LOCAL_LENGTH_DIFF = 4;
 153 
 154     /** Get the ClassWriter instance for this context. */
 155     public static ClassWriter instance(Context context) {
 156         ClassWriter instance = context.get(classWriterKey);
 157         if (instance == null)
 158             instance = new ClassWriter(context);
 159         return instance;
 160     }
 161 
 162     /** Construct a class writer, given an options table.
 163      */
 164     protected ClassWriter(Context context) {
 165         context.put(classWriterKey, this);
 166 
 167         log = Log.instance(context);
 168         names = Names.instance(context);
 169         options = Options.instance(context);
 170         preview = Preview.instance(context);
 171         target = Target.instance(context);
 172         source = Source.instance(context);
 173         types = Types.instance(context);
 174         check = Check.instance(context);
 175         fileManager = context.get(JavaFileManager.class);
 176         poolWriter = Gen.instance(context).poolWriter;
 177 
 178         verbose        = options.isSet(VERBOSE);
 179         genCrt         = options.isSet(XJCOV);
 180         debugstackmap = options.isSet(&quot;debug.stackmap&quot;);
 181 
 182         emitSourceFile = options.isUnset(G_CUSTOM) ||
 183                             options.isSet(G_CUSTOM, &quot;source&quot;);
 184 
 185         String modifierFlags = options.get(&quot;debug.dumpmodifiers&quot;);
 186         if (modifierFlags != null) {
 187             dumpClassModifiers = modifierFlags.indexOf(&#39;c&#39;) != -1;
 188             dumpFieldModifiers = modifierFlags.indexOf(&#39;f&#39;) != -1;
 189             dumpInnerClassModifiers = modifierFlags.indexOf(&#39;i&#39;) != -1;
 190             dumpMethodModifiers = modifierFlags.indexOf(&#39;m&#39;) != -1;
 191         }
 192     }
 193 
 194     public void addExtraAttributes(ToIntFunction&lt;Symbol&gt; addExtraAttributes) {
 195         extraAttributeHooks = extraAttributeHooks.prepend(addExtraAttributes);
 196     }
 197 
 198 /******************************************************************
 199  * Diagnostics: dump generated class names and modifiers
 200  ******************************************************************/
 201 
 202     /** Value of option &#39;dumpmodifiers&#39; is a string
 203      *  indicating which modifiers should be dumped for debugging:
 204      *    &#39;c&#39; -- classes
 205      *    &#39;f&#39; -- fields
 206      *    &#39;i&#39; -- innerclass attributes
 207      *    &#39;m&#39; -- methods
 208      *  For example, to dump everything:
 209      *    javac -XDdumpmodifiers=cifm MyProg.java
 210      */
 211     private boolean dumpClassModifiers; // -XDdumpmodifiers=c
 212     private boolean dumpFieldModifiers; // -XDdumpmodifiers=f
 213     private boolean dumpInnerClassModifiers; // -XDdumpmodifiers=i
 214     private boolean dumpMethodModifiers; // -XDdumpmodifiers=m
 215 
 216 
 217     /** Return flags as a string, separated by &quot; &quot;.
 218      */
 219     public static String flagNames(long flags) {
 220         StringBuilder sbuf = new StringBuilder();
 221         int i = 0;
 222         long f = flags &amp; StandardFlags;
 223         while (f != 0) {
 224             if ((f &amp; 1) != 0) {
 225                 sbuf.append(&quot; &quot;);
 226                 sbuf.append(flagName[i]);
 227             }
 228             f = f &gt;&gt; 1;
 229             i++;
 230         }
 231         return sbuf.toString();
 232     }
 233     //where
 234         private final static String[] flagName = {
 235             &quot;PUBLIC&quot;, &quot;PRIVATE&quot;, &quot;PROTECTED&quot;, &quot;STATIC&quot;, &quot;FINAL&quot;,
 236             &quot;SUPER&quot;, &quot;VOLATILE&quot;, &quot;TRANSIENT&quot;, &quot;NATIVE&quot;, &quot;INTERFACE&quot;,
 237             &quot;ABSTRACT&quot;, &quot;STRICTFP&quot;};
 238 
 239 /******************************************************************
 240  * Output routines
 241  ******************************************************************/
 242 
 243     /** Write a character into given byte buffer;
 244      *  byte buffer will not be grown.
 245      */
 246     void putChar(ByteBuffer buf, int op, int x) {
 247         buf.elems[op  ] = (byte)((x &gt;&gt;  8) &amp; 0xFF);
 248         buf.elems[op+1] = (byte)((x      ) &amp; 0xFF);
 249     }
 250 
 251     /** Write an integer into given byte buffer;
 252      *  byte buffer will not be grown.
 253      */
 254     void putInt(ByteBuffer buf, int adr, int x) {
 255         buf.elems[adr  ] = (byte)((x &gt;&gt; 24) &amp; 0xFF);
 256         buf.elems[adr+1] = (byte)((x &gt;&gt; 16) &amp; 0xFF);
 257         buf.elems[adr+2] = (byte)((x &gt;&gt;  8) &amp; 0xFF);
 258         buf.elems[adr+3] = (byte)((x      ) &amp; 0xFF);
 259     }
 260 
 261 /******************************************************************
 262  * Writing the Constant Pool
 263  ******************************************************************/
 264 
 265     /** Thrown when the constant pool is over full.
 266      */
 267     public static class PoolOverflow extends RuntimeException {
 268         private static final long serialVersionUID = 0;
 269         public PoolOverflow() {}
 270     }
 271     public static class StringOverflow extends RuntimeException {
 272         private static final long serialVersionUID = 0;
 273         public final String value;
 274         public StringOverflow(String s) {
 275             value = s;
 276         }
 277     }
 278 
 279 /******************************************************************
 280  * Writing Attributes
 281  ******************************************************************/
 282 
 283     /** Write header for an attribute to data buffer and return
 284      *  position past attribute length index.
 285      */
 286     public int writeAttr(Name attrName) {
 287         int index = poolWriter.putName(attrName);
 288         databuf.appendChar(index);
 289         databuf.appendInt(0);
 290         return databuf.length;
 291     }
 292 
 293     /** Fill in attribute length.
 294      */
 295     public void endAttr(int index) {
 296         putInt(databuf, index - 4, databuf.length - index);
 297     }
 298 
 299     /** Leave space for attribute count and return index for
 300      *  number of attributes field.
 301      */
 302     int beginAttrs() {
 303         databuf.appendChar(0);
 304         return databuf.length;
 305     }
 306 
 307     /** Fill in number of attributes.
 308      */
 309     void endAttrs(int index, int count) {
 310         putChar(databuf, index - 2, count);
 311     }
 312 
 313     /** Write the EnclosingMethod attribute if needed.
 314      *  Returns the number of attributes written (0 or 1).
 315      */
 316     int writeEnclosingMethodAttribute(ClassSymbol c) {
 317         return writeEnclosingMethodAttribute(names.EnclosingMethod, c);
 318     }
 319 
 320     /** Write the EnclosingMethod attribute with a specified name.
 321      *  Returns the number of attributes written (0 or 1).
 322      */
 323     protected int writeEnclosingMethodAttribute(Name attributeName, ClassSymbol c) {
 324         if (c.owner.kind != MTH &amp;&amp; // neither a local class
 325             c.name != names.empty) // nor anonymous
 326             return 0;
 327 
 328         int alenIdx = writeAttr(attributeName);
 329         ClassSymbol enclClass = c.owner.enclClass();
 330         MethodSymbol enclMethod =
 331             (c.owner.type == null // local to init block
 332              || c.owner.kind != MTH) // or member init
 333             ? null
 334             : ((MethodSymbol)c.owner).originalEnclosingMethod();
 335         databuf.appendChar(poolWriter.putClass(enclClass));
 336         databuf.appendChar(enclMethod == null ? 0 : poolWriter.putNameAndType(enclMethod));
 337         endAttr(alenIdx);
 338         return 1;
 339     }
 340 
 341     /** Write flag attributes; return number of attributes written.
 342      */
 343     int writeFlagAttrs(long flags) {
 344         int acount = 0;
 345         if ((flags &amp; DEPRECATED) != 0) {
 346             int alenIdx = writeAttr(names.Deprecated);
 347             endAttr(alenIdx);
 348             acount++;
 349         }
 350         return acount;
 351     }
 352 
 353     /** Write member (field or method) attributes;
 354      *  return number of attributes written.
 355      */
 356     int writeMemberAttrs(Symbol sym, boolean isRecordComponent) {
 357         int acount = 0;
 358         if (!isRecordComponent) {
 359             acount = writeFlagAttrs(sym.flags());
 360         }
 361         long flags = sym.flags();
 362         if ((flags &amp; (SYNTHETIC | BRIDGE)) != SYNTHETIC &amp;&amp;
 363             (flags &amp; ANONCONSTR) == 0 &amp;&amp;
 364             (!types.isSameType(sym.type, sym.erasure(types)) ||
 365              poolWriter.signatureGen.hasTypeVar(sym.type.getThrownTypes()))) {
 366             // note that a local class with captured variables
 367             // will get a signature attribute
 368             int alenIdx = writeAttr(names.Signature);
 369             databuf.appendChar(poolWriter.putSignature(sym));
 370             endAttr(alenIdx);
 371             acount++;
 372         }
 373         acount += writeJavaAnnotations(sym.getRawAttributes());
 374         acount += writeTypeAnnotations(sym.getRawTypeAttributes(), false);
 375         return acount;
 376     }
 377 
 378     /**
 379      * Write method parameter names attribute.
 380      */
 381     int writeMethodParametersAttr(MethodSymbol m) {
 382         MethodType ty = m.externalType(types).asMethodType();
 383         final int allparams = ty.argtypes.size();
 384         if (m.params != null &amp;&amp; allparams != 0) {
 385             final int attrIndex = writeAttr(names.MethodParameters);
 386             databuf.appendByte(allparams);
 387             // Write extra parameters first
 388             for (VarSymbol s : m.extraParams) {
 389                 final int flags =
 390                     ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
 391                     ((int) m.flags() &amp; SYNTHETIC);
 392                 databuf.appendChar(poolWriter.putName(s.name));
 393                 databuf.appendChar(flags);
 394             }
 395             // Now write the real parameters
 396             for (VarSymbol s : m.params) {
 397                 final int flags =
 398                     ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
 399                     ((int) m.flags() &amp; SYNTHETIC);
 400                 databuf.appendChar(poolWriter.putName(s.name));
 401                 databuf.appendChar(flags);
 402             }
 403             // Now write the captured locals
 404             for (VarSymbol s : m.capturedLocals) {
 405                 final int flags =
 406                     ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
 407                     ((int) m.flags() &amp; SYNTHETIC);
 408                 databuf.appendChar(poolWriter.putName(s.name));
 409                 databuf.appendChar(flags);
 410             }
 411             endAttr(attrIndex);
 412             return 1;
 413         } else
 414             return 0;
 415     }
 416 
 417     private void writeParamAnnotations(List&lt;VarSymbol&gt; params,
 418                                        RetentionPolicy retention) {
 419         databuf.appendByte(params.length());
 420         for (VarSymbol s : params) {
 421             ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();
 422             for (Attribute.Compound a : s.getRawAttributes())
 423                 if (types.getRetention(a) == retention)
 424                     buf.append(a);
 425             databuf.appendChar(buf.length());
 426             for (Attribute.Compound a : buf)
 427                 writeCompoundAttribute(a);
 428         }
 429 
 430     }
 431 
 432     private void writeParamAnnotations(MethodSymbol m,
 433                                        RetentionPolicy retention) {
 434         databuf.appendByte(m.params.length());
 435         writeParamAnnotations(m.params, retention);
 436     }
 437 
 438     /** Write method parameter annotations;
 439      *  return number of attributes written.
 440      */
 441     int writeParameterAttrs(List&lt;VarSymbol&gt; vars) {
 442         boolean hasVisible = false;
 443         boolean hasInvisible = false;
 444         if (vars != null) {
 445             for (VarSymbol s : vars) {
 446                 for (Attribute.Compound a : s.getRawAttributes()) {
 447                     switch (types.getRetention(a)) {
 448                     case SOURCE: break;
 449                     case CLASS: hasInvisible = true; break;
 450                     case RUNTIME: hasVisible = true; break;
 451                     default: // /* fail soft */ throw new AssertionError(vis);
 452                     }
 453                 }
 454             }
 455         }
 456 
 457         int attrCount = 0;
 458         if (hasVisible) {
 459             int attrIndex = writeAttr(names.RuntimeVisibleParameterAnnotations);
 460             writeParamAnnotations(vars, RetentionPolicy.RUNTIME);
 461             endAttr(attrIndex);
 462             attrCount++;
 463         }
 464         if (hasInvisible) {
 465             int attrIndex = writeAttr(names.RuntimeInvisibleParameterAnnotations);
 466             writeParamAnnotations(vars, RetentionPolicy.CLASS);
 467             endAttr(attrIndex);
 468             attrCount++;
 469         }
 470         return attrCount;
 471     }
 472 
 473 /**********************************************************************
 474  * Writing Java-language annotations (aka metadata, attributes)
 475  **********************************************************************/
 476 
 477     /** Write Java-language annotations; return number of JVM
 478      *  attributes written (zero or one).
 479      */
 480     int writeJavaAnnotations(List&lt;Attribute.Compound&gt; attrs) {
 481         if (attrs.isEmpty()) return 0;
 482         ListBuffer&lt;Attribute.Compound&gt; visibles = new ListBuffer&lt;&gt;();
 483         ListBuffer&lt;Attribute.Compound&gt; invisibles = new ListBuffer&lt;&gt;();
 484         for (Attribute.Compound a : attrs) {
 485             switch (types.getRetention(a)) {
 486             case SOURCE: break;
 487             case CLASS: invisibles.append(a); break;
 488             case RUNTIME: visibles.append(a); break;
 489             default: // /* fail soft */ throw new AssertionError(vis);
 490             }
 491         }
 492 
 493         int attrCount = 0;
 494         if (visibles.length() != 0) {
 495             int attrIndex = writeAttr(names.RuntimeVisibleAnnotations);
 496             databuf.appendChar(visibles.length());
 497             for (Attribute.Compound a : visibles)
 498                 writeCompoundAttribute(a);
 499             endAttr(attrIndex);
 500             attrCount++;
 501         }
 502         if (invisibles.length() != 0) {
 503             int attrIndex = writeAttr(names.RuntimeInvisibleAnnotations);
 504             databuf.appendChar(invisibles.length());
 505             for (Attribute.Compound a : invisibles)
 506                 writeCompoundAttribute(a);
 507             endAttr(attrIndex);
 508             attrCount++;
 509         }
 510         return attrCount;
 511     }
 512 
 513     int writeTypeAnnotations(List&lt;Attribute.TypeCompound&gt; typeAnnos, boolean inCode) {
 514         if (typeAnnos.isEmpty()) return 0;
 515 
 516         ListBuffer&lt;Attribute.TypeCompound&gt; visibles = new ListBuffer&lt;&gt;();
 517         ListBuffer&lt;Attribute.TypeCompound&gt; invisibles = new ListBuffer&lt;&gt;();
 518 
 519         for (Attribute.TypeCompound tc : typeAnnos) {
 520             if (tc.hasUnknownPosition()) {
 521                 boolean fixed = tc.tryFixPosition();
 522 
 523                 // Could we fix it?
 524                 if (!fixed) {
 525                     // This happens for nested types like @A Outer. @B Inner.
 526                     // For method parameters we get the annotation twice! Once with
 527                     // a valid position, once unknown.
 528                     // TODO: find a cleaner solution.
 529                     PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
 530                     pw.println(&quot;ClassWriter: Position UNKNOWN in type annotation: &quot; + tc);
 531                     continue;
 532                 }
 533             }
 534 
 535             if (tc.position.type.isLocal() != inCode)
 536                 continue;
 537             if (!tc.position.emitToClassfile())
 538                 continue;
 539             switch (types.getRetention(tc)) {
 540             case SOURCE: break;
 541             case CLASS: invisibles.append(tc); break;
 542             case RUNTIME: visibles.append(tc); break;
 543             default: // /* fail soft */ throw new AssertionError(vis);
 544             }
 545         }
 546 
 547         int attrCount = 0;
 548         if (visibles.length() != 0) {
 549             int attrIndex = writeAttr(names.RuntimeVisibleTypeAnnotations);
 550             databuf.appendChar(visibles.length());
 551             for (Attribute.TypeCompound p : visibles)
 552                 writeTypeAnnotation(p);
 553             endAttr(attrIndex);
 554             attrCount++;
 555         }
 556 
 557         if (invisibles.length() != 0) {
 558             int attrIndex = writeAttr(names.RuntimeInvisibleTypeAnnotations);
 559             databuf.appendChar(invisibles.length());
 560             for (Attribute.TypeCompound p : invisibles)
 561                 writeTypeAnnotation(p);
 562             endAttr(attrIndex);
 563             attrCount++;
 564         }
 565 
 566         return attrCount;
 567     }
 568 
 569     /** A visitor to write an attribute including its leading
 570      *  single-character marker.
 571      */
 572     class AttributeWriter implements Attribute.Visitor {
 573         public void visitConstant(Attribute.Constant _value) {
 574             if (_value.type.getTag() == CLASS) {
 575                 Assert.check(_value.value instanceof String);
 576                 String s = (String)_value.value;
 577                 databuf.appendByte(&#39;s&#39;);
 578                 databuf.appendChar(poolWriter.putName(names.fromString(s)));
 579             } else {
 580                 switch (_value.type.getTag()) {
 581                     case BYTE:
 582                         databuf.appendByte(&#39;B&#39;);
 583                         break;
 584                     case CHAR:
 585                         databuf.appendByte(&#39;C&#39;);
 586                         break;
 587                     case SHORT:
 588                         databuf.appendByte(&#39;S&#39;);
 589                         break;
 590                     case INT:
 591                         databuf.appendByte(&#39;I&#39;);
 592                         break;
 593                     case LONG:
 594                         databuf.appendByte(&#39;J&#39;);
 595                         break;
 596                     case FLOAT:
 597                         databuf.appendByte(&#39;F&#39;);
 598                         break;
 599                     case DOUBLE:
 600                         databuf.appendByte(&#39;D&#39;);
 601                         break;
 602                     case BOOLEAN:
 603                         databuf.appendByte(&#39;Z&#39;);
 604                         break;
 605                     default:
 606                         throw new AssertionError(_value.type);
 607                 }
 608                 databuf.appendChar(poolWriter.putConstant(_value.value));
 609             }
 610         }
 611         public void visitEnum(Attribute.Enum e) {
 612             databuf.appendByte(&#39;e&#39;);
 613             databuf.appendChar(poolWriter.putDescriptor(e.value.type));
 614             databuf.appendChar(poolWriter.putName(e.value.name));
 615         }
 616         public void visitClass(Attribute.Class clazz) {
 617             databuf.appendByte(&#39;c&#39;);
 618             databuf.appendChar(poolWriter.putDescriptor(clazz.classType));
 619         }
 620         public void visitCompound(Attribute.Compound compound) {
 621             databuf.appendByte(&#39;@&#39;);
 622             writeCompoundAttribute(compound);
 623         }
 624         public void visitError(Attribute.Error x) {
 625             throw new AssertionError(x);
 626         }
 627         public void visitArray(Attribute.Array array) {
 628             databuf.appendByte(&#39;[&#39;);
 629             databuf.appendChar(array.values.length);
 630             for (Attribute a : array.values) {
 631                 a.accept(this);
 632             }
 633         }
 634     }
 635     AttributeWriter awriter = new AttributeWriter();
 636 
 637     /** Write a compound attribute excluding the &#39;@&#39; marker. */
 638     void writeCompoundAttribute(Attribute.Compound c) {
 639         databuf.appendChar(poolWriter.putDescriptor(c.type));
 640         databuf.appendChar(c.values.length());
 641         for (Pair&lt;Symbol.MethodSymbol,Attribute&gt; p : c.values) {
 642             databuf.appendChar(poolWriter.putName(p.fst.name));
 643             p.snd.accept(awriter);
 644         }
 645     }
 646 
 647     void writeTypeAnnotation(Attribute.TypeCompound c) {
 648         writePosition(c.position);
 649         writeCompoundAttribute(c);
 650     }
 651 
 652     void writePosition(TypeAnnotationPosition p) {
 653         databuf.appendByte(p.type.targetTypeValue()); // TargetType tag is a byte
 654         switch (p.type) {
 655         // instanceof
 656         case INSTANCEOF:
 657         // new expression
 658         case NEW:
 659         // constructor/method reference receiver
 660         case CONSTRUCTOR_REFERENCE:
 661         case METHOD_REFERENCE:
 662             databuf.appendChar(p.offset);
 663             break;
 664         // local variable
 665         case LOCAL_VARIABLE:
 666         // resource variable
 667         case RESOURCE_VARIABLE:
 668             databuf.appendChar(p.lvarOffset.length);  // for table length
 669             for (int i = 0; i &lt; p.lvarOffset.length; ++i) {
 670                 databuf.appendChar(p.lvarOffset[i]);
 671                 databuf.appendChar(p.lvarLength[i]);
 672                 databuf.appendChar(p.lvarIndex[i]);
 673             }
 674             break;
 675         // exception parameter
 676         case EXCEPTION_PARAMETER:
 677             databuf.appendChar(p.getExceptionIndex());
 678             break;
 679         // method receiver
 680         case METHOD_RECEIVER:
 681             // Do nothing
 682             break;
 683         // type parameter
 684         case CLASS_TYPE_PARAMETER:
 685         case METHOD_TYPE_PARAMETER:
 686             databuf.appendByte(p.parameter_index);
 687             break;
 688         // type parameter bound
 689         case CLASS_TYPE_PARAMETER_BOUND:
 690         case METHOD_TYPE_PARAMETER_BOUND:
 691             databuf.appendByte(p.parameter_index);
 692             databuf.appendByte(p.bound_index);
 693             break;
 694         // class extends or implements clause
 695         case CLASS_EXTENDS:
 696             databuf.appendChar(p.type_index);
 697             break;
 698         // throws
 699         case THROWS:
 700             databuf.appendChar(p.type_index);
 701             break;
 702         // method parameter
 703         case METHOD_FORMAL_PARAMETER:
 704             databuf.appendByte(p.parameter_index);
 705             break;
 706         // type cast
 707         case CAST:
 708         // method/constructor/reference type argument
 709         case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
 710         case METHOD_INVOCATION_TYPE_ARGUMENT:
 711         case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
 712         case METHOD_REFERENCE_TYPE_ARGUMENT:
 713             databuf.appendChar(p.offset);
 714             databuf.appendByte(p.type_index);
 715             break;
 716         // We don&#39;t need to worry about these
 717         case METHOD_RETURN:
 718         case FIELD:
 719             break;
 720         case UNKNOWN:
 721             throw new AssertionError(&quot;jvm.ClassWriter: UNKNOWN target type should never occur!&quot;);
 722         default:
 723             throw new AssertionError(&quot;jvm.ClassWriter: Unknown target type for position: &quot; + p);
 724         }
 725 
 726         { // Append location data for generics/arrays.
 727             databuf.appendByte(p.location.size());
 728             java.util.List&lt;Integer&gt; loc = TypeAnnotationPosition.getBinaryFromTypePath(p.location);
 729             for (int i : loc)
 730                 databuf.appendByte((byte)i);
 731         }
 732     }
 733 
 734 /**********************************************************************
 735  * Writing module attributes
 736  **********************************************************************/
 737 
 738     /** Write the Module attribute if needed.
 739      *  Returns the number of attributes written (0 or 1).
 740      */
 741     int writeModuleAttribute(ClassSymbol c) {
 742         ModuleSymbol m = (ModuleSymbol) c.owner;
 743 
 744         int alenIdx = writeAttr(names.Module);
 745 
 746         databuf.appendChar(poolWriter.putModule(m));
 747         databuf.appendChar(ModuleFlags.value(m.flags)); // module_flags
 748         databuf.appendChar(m.version != null ? poolWriter.putName(m.version) : 0);
 749 
 750         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
 751         for (RequiresDirective r: m.requires) {
 752             if (!r.flags.contains(RequiresFlag.EXTRA))
 753                 requires.add(r);
 754         }
 755         databuf.appendChar(requires.size());
 756         for (RequiresDirective r: requires) {
 757             databuf.appendChar(poolWriter.putModule(r.module));
 758             databuf.appendChar(RequiresFlag.value(r.flags));
 759             databuf.appendChar(r.module.version != null ? poolWriter.putName(r.module.version) : 0);
 760         }
 761 
 762         List&lt;ExportsDirective&gt; exports = m.exports;
 763         databuf.appendChar(exports.size());
 764         for (ExportsDirective e: exports) {
 765             databuf.appendChar(poolWriter.putPackage(e.packge));
 766             databuf.appendChar(ExportsFlag.value(e.flags));
 767             if (e.modules == null) {
 768                 databuf.appendChar(0);
 769             } else {
 770                 databuf.appendChar(e.modules.size());
 771                 for (ModuleSymbol msym: e.modules) {
 772                     databuf.appendChar(poolWriter.putModule(msym));
 773                 }
 774             }
 775         }
 776 
 777         List&lt;OpensDirective&gt; opens = m.opens;
 778         databuf.appendChar(opens.size());
 779         for (OpensDirective o: opens) {
 780             databuf.appendChar(poolWriter.putPackage(o.packge));
 781             databuf.appendChar(OpensFlag.value(o.flags));
 782             if (o.modules == null) {
 783                 databuf.appendChar(0);
 784             } else {
 785                 databuf.appendChar(o.modules.size());
 786                 for (ModuleSymbol msym: o.modules) {
 787                     databuf.appendChar(poolWriter.putModule(msym));
 788                 }
 789             }
 790         }
 791 
 792         List&lt;UsesDirective&gt; uses = m.uses;
 793         databuf.appendChar(uses.size());
 794         for (UsesDirective s: uses) {
 795             databuf.appendChar(poolWriter.putClass(s.service));
 796         }
 797 
 798         // temporary fix to merge repeated provides clause for same service;
 799         // eventually this should be disallowed when analyzing the module,
 800         // so that each service type only appears once.
 801         Map&lt;ClassSymbol, Set&lt;ClassSymbol&gt;&gt; mergedProvides = new LinkedHashMap&lt;&gt;();
 802         for (ProvidesDirective p : m.provides) {
 803             mergedProvides.computeIfAbsent(p.service, s -&gt; new LinkedHashSet&lt;&gt;()).addAll(p.impls);
 804         }
 805         databuf.appendChar(mergedProvides.size());
 806         mergedProvides.forEach((srvc, impls) -&gt; {
 807             databuf.appendChar(poolWriter.putClass(srvc));
 808             databuf.appendChar(impls.size());
 809             impls.forEach(impl -&gt; databuf.appendChar(poolWriter.putClass(impl)));
 810         });
 811 
 812         endAttr(alenIdx);
 813         return 1;
 814     }
 815 
 816 /**********************************************************************
 817  * Writing Objects
 818  **********************************************************************/
 819 
 820     /** Write &quot;inner classes&quot; attribute.
 821      */
 822     void writeInnerClasses() {
 823         int alenIdx = writeAttr(names.InnerClasses);
 824         databuf.appendChar(poolWriter.innerClasses.size());
 825         for (ClassSymbol inner : poolWriter.innerClasses) {
 826             inner.markAbstractIfNeeded(types);
 827             char flags = (char) adjustFlags(inner.flags_field);
 828             if ((flags &amp; INTERFACE) != 0) flags |= ABSTRACT; // Interfaces are always ABSTRACT
 829             flags &amp;= ~STRICTFP; //inner classes should not have the strictfp flag set.
 830             if (dumpInnerClassModifiers) {
 831                 PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
 832                 pw.println(&quot;INNERCLASS  &quot; + inner.name);
 833                 pw.println(&quot;---&quot; + flagNames(flags));
 834             }
 835             databuf.appendChar(poolWriter.putClass(inner));
 836             databuf.appendChar(
 837                 inner.owner.kind == TYP &amp;&amp; !inner.name.isEmpty() ? poolWriter.putClass((ClassSymbol)inner.owner) : 0);
 838             databuf.appendChar(
 839                 !inner.name.isEmpty() ? poolWriter.putName(inner.name) : 0);
 840             databuf.appendChar(flags);
 841         }
 842         endAttr(alenIdx);
 843     }
 844 
 845     int writeRecordAttribute(ClassSymbol csym) {
 846         int alenIdx = writeAttr(names.Record);
 847         Scope s = csym.members();
 848         databuf.appendChar(csym.getRecordComponents().size());
 849         for (VarSymbol v: csym.getRecordComponents()) {
 850             //databuf.appendChar(poolWriter.putMember(v.accessor.head.snd));
 851             databuf.appendChar(poolWriter.putName(v.name));
 852             databuf.appendChar(poolWriter.putDescriptor(v));
 853             int acountIdx = beginAttrs();
 854             int acount = 0;
 855             acount += writeMemberAttrs(v, true);
 856             endAttrs(acountIdx, acount);
 857         }
 858         endAttr(alenIdx);
 859         return 1;
 860     }
 861 
 862     /**
 863      * Write NestMembers attribute (if needed)
 864      */
 865     int writeNestMembersIfNeeded(ClassSymbol csym) {
 866         ListBuffer&lt;ClassSymbol&gt; nested = new ListBuffer&lt;&gt;();
 867         listNested(csym, nested);
 868         Set&lt;ClassSymbol&gt; nestedUnique = new LinkedHashSet&lt;&gt;(nested);
 869         if (csym.owner.kind == PCK &amp;&amp; !nestedUnique.isEmpty()) {
 870             int alenIdx = writeAttr(names.NestMembers);
 871             databuf.appendChar(nestedUnique.size());
 872             for (ClassSymbol s : nestedUnique) {
 873                 databuf.appendChar(poolWriter.putClass(s));
 874             }
 875             endAttr(alenIdx);
 876             return 1;
 877         }
 878         return 0;
 879     }
 880 
 881     /**
 882      * Write NestHost attribute (if needed)
 883      */
 884     int writeNestHostIfNeeded(ClassSymbol csym) {
 885         if (csym.owner.kind != PCK) {
 886             int alenIdx = writeAttr(names.NestHost);
 887             databuf.appendChar(poolWriter.putClass(csym.outermostClass()));
 888             endAttr(alenIdx);
 889             return 1;
 890         }
 891         return 0;
 892     }
 893 
 894     private void listNested(Symbol sym, ListBuffer&lt;ClassSymbol&gt; seen) {
 895         if (sym.kind != TYP) return;
 896         ClassSymbol csym = (ClassSymbol)sym;
 897         if (csym.owner.kind != PCK) {
 898             seen.add(csym);
 899         }
 900         if (csym.members() != null) {
 901             for (Symbol s : sym.members().getSymbols()) {
 902                 listNested(s, seen);
 903             }
 904         }
 905         if (csym.trans_local != null) {
 906             for (Symbol s : csym.trans_local) {
 907                 listNested(s, seen);
 908             }
 909         }
 910     }
 911 
<a name="2" id="anc2"></a><span class="line-added"> 912     /** Write &quot;PermittedSubclasses&quot; attribute.</span>
<span class="line-added"> 913      */</span>
<span class="line-added"> 914     int writePermittedSubclassesIfNeeded(ClassSymbol csym) {</span>
<span class="line-added"> 915         if (csym.permitted.nonEmpty()) {</span>
<span class="line-added"> 916             int alenIdx = writeAttr(names.PermittedSubclasses);</span>
<span class="line-added"> 917             databuf.appendChar(csym.permitted.size());</span>
<span class="line-added"> 918             for (Symbol c : csym.permitted) {</span>
<span class="line-added"> 919                 databuf.appendChar(poolWriter.putClass((ClassSymbol) c));</span>
<span class="line-added"> 920             }</span>
<span class="line-added"> 921             endAttr(alenIdx);</span>
<span class="line-added"> 922             return 1;</span>
<span class="line-added"> 923         }</span>
<span class="line-added"> 924         return 0;</span>
<span class="line-added"> 925     }</span>
<span class="line-added"> 926 </span>
 927     /** Write &quot;bootstrapMethods&quot; attribute.
 928      */
 929     void writeBootstrapMethods() {
 930         int alenIdx = writeAttr(names.BootstrapMethods);
 931         databuf.appendChar(poolWriter.bootstrapMethods.size());
 932         for (BsmKey bsmKey : poolWriter.bootstrapMethods.keySet()) {
 933             //write BSM handle
 934             databuf.appendChar(poolWriter.putConstant(bsmKey.bsm));
 935             LoadableConstant[] uniqueArgs = bsmKey.staticArgs;
 936             //write static args length
 937             databuf.appendChar(uniqueArgs.length);
 938             //write static args array
 939             for (LoadableConstant arg : uniqueArgs) {
 940                 databuf.appendChar(poolWriter.putConstant(arg));
 941             }
 942         }
 943         endAttr(alenIdx);
 944     }
 945 
 946     /** Write field symbol, entering all references into constant pool.
 947      */
 948     void writeField(VarSymbol v) {
 949         int flags = adjustFlags(v.flags());
 950         databuf.appendChar(flags);
 951         if (dumpFieldModifiers) {
 952             PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
 953             pw.println(&quot;FIELD  &quot; + v.name);
 954             pw.println(&quot;---&quot; + flagNames(v.flags()));
 955         }
 956         databuf.appendChar(poolWriter.putName(v.name));
 957         databuf.appendChar(poolWriter.putDescriptor(v));
 958         int acountIdx = beginAttrs();
 959         int acount = 0;
 960         if (v.getConstValue() != null) {
 961             int alenIdx = writeAttr(names.ConstantValue);
 962             databuf.appendChar(poolWriter.putConstant(v.getConstValue()));
 963             endAttr(alenIdx);
 964             acount++;
 965         }
 966         acount += writeMemberAttrs(v, false);
 967         acount += writeExtraAttributes(v);
 968         endAttrs(acountIdx, acount);
 969     }
 970 
 971     /** Write method symbol, entering all references into constant pool.
 972      */
 973     void writeMethod(MethodSymbol m) {
 974         int flags = adjustFlags(m.flags());
 975         databuf.appendChar(flags);
 976         if (dumpMethodModifiers) {
 977             PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
 978             pw.println(&quot;METHOD  &quot; + m.name);
 979             pw.println(&quot;---&quot; + flagNames(m.flags()));
 980         }
 981         databuf.appendChar(poolWriter.putName(m.name));
 982         databuf.appendChar(poolWriter.putDescriptor(m));
 983         int acountIdx = beginAttrs();
 984         int acount = 0;
 985         if (m.code != null) {
 986             int alenIdx = writeAttr(names.Code);
 987             writeCode(m.code);
 988             m.code = null; // to conserve space
 989             endAttr(alenIdx);
 990             acount++;
 991         }
 992         List&lt;Type&gt; thrown = m.erasure(types).getThrownTypes();
 993         if (thrown.nonEmpty()) {
 994             int alenIdx = writeAttr(names.Exceptions);
 995             databuf.appendChar(thrown.length());
 996             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
 997                 databuf.appendChar(poolWriter.putClass(l.head));
 998             endAttr(alenIdx);
 999             acount++;
1000         }
1001         if (m.defaultValue != null) {
1002             int alenIdx = writeAttr(names.AnnotationDefault);
1003             m.defaultValue.accept(awriter);
1004             endAttr(alenIdx);
1005             acount++;
1006         }
1007         if (target.hasMethodParameters() &amp;&amp; (options.isSet(PARAMETERS) || m.isConstructor() &amp;&amp; (m.flags_field &amp; RECORD) != 0)) {
1008             if (!m.isLambdaMethod()) // Per JDK-8138729, do not emit parameters table for lambda bodies.
1009                 acount += writeMethodParametersAttr(m);
1010         }
1011         acount += writeMemberAttrs(m, false);
1012         if (!m.isLambdaMethod())
1013             acount += writeParameterAttrs(m.params);
1014         acount += writeExtraAttributes(m);
1015         endAttrs(acountIdx, acount);
1016     }
1017 
1018     /** Write code attribute of method.
1019      */
1020     void writeCode(Code code) {
1021         databuf.appendChar(code.max_stack);
1022         databuf.appendChar(code.max_locals);
1023         databuf.appendInt(code.cp);
1024         databuf.appendBytes(code.code, 0, code.cp);
1025         databuf.appendChar(code.catchInfo.length());
1026         for (List&lt;char[]&gt; l = code.catchInfo.toList();
1027              l.nonEmpty();
1028              l = l.tail) {
1029             for (int i = 0; i &lt; l.head.length; i++)
1030                 databuf.appendChar(l.head[i]);
1031         }
1032         int acountIdx = beginAttrs();
1033         int acount = 0;
1034 
1035         if (code.lineInfo.nonEmpty()) {
1036             int alenIdx = writeAttr(names.LineNumberTable);
1037             databuf.appendChar(code.lineInfo.length());
1038             for (List&lt;char[]&gt; l = code.lineInfo.reverse();
1039                  l.nonEmpty();
1040                  l = l.tail)
1041                 for (int i = 0; i &lt; l.head.length; i++)
1042                     databuf.appendChar(l.head[i]);
1043             endAttr(alenIdx);
1044             acount++;
1045         }
1046 
1047         if (genCrt &amp;&amp; (code.crt != null)) {
1048             CRTable crt = code.crt;
1049             int alenIdx = writeAttr(names.CharacterRangeTable);
1050             int crtIdx = beginAttrs();
1051             int crtEntries = crt.writeCRT(databuf, code.lineMap, log);
1052             endAttrs(crtIdx, crtEntries);
1053             endAttr(alenIdx);
1054             acount++;
1055         }
1056 
1057         // counter for number of generic local variables
1058         if (code.varDebugInfo &amp;&amp; code.varBufferSize &gt; 0) {
1059             int nGenericVars = 0;
1060             int alenIdx = writeAttr(names.LocalVariableTable);
1061             databuf.appendChar(code.getLVTSize());
1062             for (int i=0; i&lt;code.varBufferSize; i++) {
1063                 Code.LocalVar var = code.varBuffer[i];
1064 
1065                 for (Code.LocalVar.Range r: var.aliveRanges) {
1066                     // write variable info
1067                     Assert.check(r.start_pc &gt;= 0
1068                             &amp;&amp; r.start_pc &lt;= code.cp);
1069                     databuf.appendChar(r.start_pc);
1070                     Assert.check(r.length &gt; 0
1071                             &amp;&amp; (r.start_pc + r.length) &lt;= code.cp);
1072                     databuf.appendChar(r.length);
1073                     VarSymbol sym = var.sym;
1074                     databuf.appendChar(poolWriter.putName(sym.name));
1075                     databuf.appendChar(poolWriter.putDescriptor(sym));
1076                     databuf.appendChar(var.reg);
1077                     if (needsLocalVariableTypeEntry(var.sym.type)) {
1078                         nGenericVars++;
1079                     }
1080                 }
1081             }
1082             endAttr(alenIdx);
1083             acount++;
1084 
1085             if (nGenericVars &gt; 0) {
1086                 alenIdx = writeAttr(names.LocalVariableTypeTable);
1087                 databuf.appendChar(nGenericVars);
1088                 int count = 0;
1089 
1090                 for (int i=0; i&lt;code.varBufferSize; i++) {
1091                     Code.LocalVar var = code.varBuffer[i];
1092                     VarSymbol sym = var.sym;
1093                     if (!needsLocalVariableTypeEntry(sym.type))
1094                         continue;
1095                     for (Code.LocalVar.Range r : var.aliveRanges) {
1096                         // write variable info
1097                         databuf.appendChar(r.start_pc);
1098                         databuf.appendChar(r.length);
1099                         databuf.appendChar(poolWriter.putName(sym.name));
1100                         databuf.appendChar(poolWriter.putSignature(sym));
1101                         databuf.appendChar(var.reg);
1102                         count++;
1103                     }
1104                 }
1105                 Assert.check(count == nGenericVars);
1106                 endAttr(alenIdx);
1107                 acount++;
1108             }
1109         }
1110 
1111         if (code.stackMapBufferSize &gt; 0) {
1112             if (debugstackmap) System.out.println(&quot;Stack map for &quot; + code.meth);
1113             int alenIdx = writeAttr(code.stackMap.getAttributeName(names));
1114             writeStackMap(code);
1115             endAttr(alenIdx);
1116             acount++;
1117         }
1118 
1119         acount += writeTypeAnnotations(code.meth.getRawTypeAttributes(), true);
1120 
1121         endAttrs(acountIdx, acount);
1122     }
1123     //where
1124     private boolean needsLocalVariableTypeEntry(Type t) {
1125         //a local variable needs a type-entry if its type T is generic
1126         //(i.e. |T| != T) and if it&#39;s not an non-denotable type (non-denotable
1127         // types are not supported in signature attribute grammar!)
1128         return !types.isSameType(t, types.erasure(t)) &amp;&amp;
1129                 check.checkDenotable(t);
1130     }
1131 
1132     void writeStackMap(Code code) {
1133         int nframes = code.stackMapBufferSize;
1134         if (debugstackmap) System.out.println(&quot; nframes = &quot; + nframes);
1135         databuf.appendChar(nframes);
1136 
1137         switch (code.stackMap) {
1138         case CLDC:
1139             for (int i=0; i&lt;nframes; i++) {
1140                 if (debugstackmap) System.out.print(&quot;  &quot; + i + &quot;:&quot;);
1141                 Code.StackMapFrame frame = code.stackMapBuffer[i];
1142 
1143                 // output PC
1144                 if (debugstackmap) System.out.print(&quot; pc=&quot; + frame.pc);
1145                 databuf.appendChar(frame.pc);
1146 
1147                 // output locals
1148                 int localCount = 0;
1149                 for (int j=0; j&lt;frame.locals.length;
1150                      j += Code.width(frame.locals[j])) {
1151                     localCount++;
1152                 }
1153                 if (debugstackmap) System.out.print(&quot; nlocals=&quot; +
1154                                                     localCount);
1155                 databuf.appendChar(localCount);
1156                 for (int j=0; j&lt;frame.locals.length;
1157                      j += Code.width(frame.locals[j])) {
1158                     if (debugstackmap) System.out.print(&quot; local[&quot; + j + &quot;]=&quot;);
1159                     writeStackMapType(frame.locals[j]);
1160                 }
1161 
1162                 // output stack
1163                 int stackCount = 0;
1164                 for (int j=0; j&lt;frame.stack.length;
1165                      j += Code.width(frame.stack[j])) {
1166                     stackCount++;
1167                 }
1168                 if (debugstackmap) System.out.print(&quot; nstack=&quot; +
1169                                                     stackCount);
1170                 databuf.appendChar(stackCount);
1171                 for (int j=0; j&lt;frame.stack.length;
1172                      j += Code.width(frame.stack[j])) {
1173                     if (debugstackmap) System.out.print(&quot; stack[&quot; + j + &quot;]=&quot;);
1174                     writeStackMapType(frame.stack[j]);
1175                 }
1176                 if (debugstackmap) System.out.println();
1177             }
1178             break;
1179         case JSR202: {
1180             Assert.checkNull(code.stackMapBuffer);
1181             for (int i=0; i&lt;nframes; i++) {
1182                 if (debugstackmap) System.out.print(&quot;  &quot; + i + &quot;:&quot;);
1183                 StackMapTableFrame frame = code.stackMapTableBuffer[i];
1184                 frame.write(this);
1185                 if (debugstackmap) System.out.println();
1186             }
1187             break;
1188         }
1189         default:
1190             throw new AssertionError(&quot;Unexpected stackmap format value&quot;);
1191         }
1192     }
1193 
1194         //where
1195         void writeStackMapType(Type t) {
1196             if (t == null) {
1197                 if (debugstackmap) System.out.print(&quot;empty&quot;);
1198                 databuf.appendByte(0);
1199             }
1200             else switch(t.getTag()) {
1201             case BYTE:
1202             case CHAR:
1203             case SHORT:
1204             case INT:
1205             case BOOLEAN:
1206                 if (debugstackmap) System.out.print(&quot;int&quot;);
1207                 databuf.appendByte(1);
1208                 break;
1209             case FLOAT:
1210                 if (debugstackmap) System.out.print(&quot;float&quot;);
1211                 databuf.appendByte(2);
1212                 break;
1213             case DOUBLE:
1214                 if (debugstackmap) System.out.print(&quot;double&quot;);
1215                 databuf.appendByte(3);
1216                 break;
1217             case LONG:
1218                 if (debugstackmap) System.out.print(&quot;long&quot;);
1219                 databuf.appendByte(4);
1220                 break;
1221             case BOT: // null
1222                 if (debugstackmap) System.out.print(&quot;null&quot;);
1223                 databuf.appendByte(5);
1224                 break;
1225             case CLASS:
1226             case ARRAY:
1227             case TYPEVAR:
1228                 if (debugstackmap) System.out.print(&quot;object(&quot; + types.erasure(t).tsym + &quot;)&quot;);
1229                 databuf.appendByte(7);
1230                 databuf.appendChar(poolWriter.putClass(types.erasure(t)));
1231                 break;
1232             case UNINITIALIZED_THIS:
1233                 if (debugstackmap) System.out.print(&quot;uninit_this&quot;);
1234                 databuf.appendByte(6);
1235                 break;
1236             case UNINITIALIZED_OBJECT:
1237                 { UninitializedType uninitType = (UninitializedType)t;
1238                 databuf.appendByte(8);
1239                 if (debugstackmap) System.out.print(&quot;uninit_object@&quot; + uninitType.offset);
1240                 databuf.appendChar(uninitType.offset);
1241                 }
1242                 break;
1243             default:
1244                 throw new AssertionError();
1245             }
1246         }
1247 
1248     /** An entry in the JSR202 StackMapTable */
1249     abstract static class StackMapTableFrame {
1250         abstract int getFrameType();
1251 
1252         void write(ClassWriter writer) {
1253             int frameType = getFrameType();
1254             writer.databuf.appendByte(frameType);
1255             if (writer.debugstackmap) System.out.print(&quot; frame_type=&quot; + frameType);
1256         }
1257 
1258         static class SameFrame extends StackMapTableFrame {
1259             final int offsetDelta;
1260             SameFrame(int offsetDelta) {
1261                 this.offsetDelta = offsetDelta;
1262             }
1263             int getFrameType() {
1264                 return (offsetDelta &lt; SAME_FRAME_SIZE) ? offsetDelta : SAME_FRAME_EXTENDED;
1265             }
1266             @Override
1267             void write(ClassWriter writer) {
1268                 super.write(writer);
1269                 if (getFrameType() == SAME_FRAME_EXTENDED) {
1270                     writer.databuf.appendChar(offsetDelta);
1271                     if (writer.debugstackmap){
1272                         System.out.print(&quot; offset_delta=&quot; + offsetDelta);
1273                     }
1274                 }
1275             }
1276         }
1277 
1278         static class SameLocals1StackItemFrame extends StackMapTableFrame {
1279             final int offsetDelta;
1280             final Type stack;
1281             SameLocals1StackItemFrame(int offsetDelta, Type stack) {
1282                 this.offsetDelta = offsetDelta;
1283                 this.stack = stack;
1284             }
1285             int getFrameType() {
1286                 return (offsetDelta &lt; SAME_FRAME_SIZE) ?
1287                        (SAME_FRAME_SIZE + offsetDelta) :
1288                        SAME_LOCALS_1_STACK_ITEM_EXTENDED;
1289             }
1290             @Override
1291             void write(ClassWriter writer) {
1292                 super.write(writer);
1293                 if (getFrameType() == SAME_LOCALS_1_STACK_ITEM_EXTENDED) {
1294                     writer.databuf.appendChar(offsetDelta);
1295                     if (writer.debugstackmap) {
1296                         System.out.print(&quot; offset_delta=&quot; + offsetDelta);
1297                     }
1298                 }
1299                 if (writer.debugstackmap) {
1300                     System.out.print(&quot; stack[&quot; + 0 + &quot;]=&quot;);
1301                 }
1302                 writer.writeStackMapType(stack);
1303             }
1304         }
1305 
1306         static class ChopFrame extends StackMapTableFrame {
1307             final int frameType;
1308             final int offsetDelta;
1309             ChopFrame(int frameType, int offsetDelta) {
1310                 this.frameType = frameType;
1311                 this.offsetDelta = offsetDelta;
1312             }
1313             int getFrameType() { return frameType; }
1314             @Override
1315             void write(ClassWriter writer) {
1316                 super.write(writer);
1317                 writer.databuf.appendChar(offsetDelta);
1318                 if (writer.debugstackmap) {
1319                     System.out.print(&quot; offset_delta=&quot; + offsetDelta);
1320                 }
1321             }
1322         }
1323 
1324         static class AppendFrame extends StackMapTableFrame {
1325             final int frameType;
1326             final int offsetDelta;
1327             final Type[] locals;
1328             AppendFrame(int frameType, int offsetDelta, Type[] locals) {
1329                 this.frameType = frameType;
1330                 this.offsetDelta = offsetDelta;
1331                 this.locals = locals;
1332             }
1333             int getFrameType() { return frameType; }
1334             @Override
1335             void write(ClassWriter writer) {
1336                 super.write(writer);
1337                 writer.databuf.appendChar(offsetDelta);
1338                 if (writer.debugstackmap) {
1339                     System.out.print(&quot; offset_delta=&quot; + offsetDelta);
1340                 }
1341                 for (int i=0; i&lt;locals.length; i++) {
1342                      if (writer.debugstackmap) System.out.print(&quot; locals[&quot; + i + &quot;]=&quot;);
1343                      writer.writeStackMapType(locals[i]);
1344                 }
1345             }
1346         }
1347 
1348         static class FullFrame extends StackMapTableFrame {
1349             final int offsetDelta;
1350             final Type[] locals;
1351             final Type[] stack;
1352             FullFrame(int offsetDelta, Type[] locals, Type[] stack) {
1353                 this.offsetDelta = offsetDelta;
1354                 this.locals = locals;
1355                 this.stack = stack;
1356             }
1357             int getFrameType() { return FULL_FRAME; }
1358             @Override
1359             void write(ClassWriter writer) {
1360                 super.write(writer);
1361                 writer.databuf.appendChar(offsetDelta);
1362                 writer.databuf.appendChar(locals.length);
1363                 if (writer.debugstackmap) {
1364                     System.out.print(&quot; offset_delta=&quot; + offsetDelta);
1365                     System.out.print(&quot; nlocals=&quot; + locals.length);
1366                 }
1367                 for (int i=0; i&lt;locals.length; i++) {
1368                     if (writer.debugstackmap) System.out.print(&quot; locals[&quot; + i + &quot;]=&quot;);
1369                     writer.writeStackMapType(locals[i]);
1370                 }
1371 
1372                 writer.databuf.appendChar(stack.length);
1373                 if (writer.debugstackmap) { System.out.print(&quot; nstack=&quot; + stack.length); }
1374                 for (int i=0; i&lt;stack.length; i++) {
1375                     if (writer.debugstackmap) System.out.print(&quot; stack[&quot; + i + &quot;]=&quot;);
1376                     writer.writeStackMapType(stack[i]);
1377                 }
1378             }
1379         }
1380 
1381        /** Compare this frame with the previous frame and produce
1382         *  an entry of compressed stack map frame. */
1383         static StackMapTableFrame getInstance(Code.StackMapFrame this_frame,
1384                                               int prev_pc,
1385                                               Type[] prev_locals,
1386                                               Types types) {
1387             Type[] locals = this_frame.locals;
1388             Type[] stack = this_frame.stack;
1389             int offset_delta = this_frame.pc - prev_pc - 1;
1390             if (stack.length == 1) {
1391                 if (locals.length == prev_locals.length
1392                     &amp;&amp; compare(prev_locals, locals, types) == 0) {
1393                     return new SameLocals1StackItemFrame(offset_delta, stack[0]);
1394                 }
1395             } else if (stack.length == 0) {
1396                 int diff_length = compare(prev_locals, locals, types);
1397                 if (diff_length == 0) {
1398                     return new SameFrame(offset_delta);
1399                 } else if (-MAX_LOCAL_LENGTH_DIFF &lt; diff_length &amp;&amp; diff_length &lt; 0) {
1400                     // APPEND
1401                     Type[] local_diff = new Type[-diff_length];
1402                     for (int i=prev_locals.length, j=0; i&lt;locals.length; i++,j++) {
1403                         local_diff[j] = locals[i];
1404                     }
1405                     return new AppendFrame(SAME_FRAME_EXTENDED - diff_length,
1406                                            offset_delta,
1407                                            local_diff);
1408                 } else if (0 &lt; diff_length &amp;&amp; diff_length &lt; MAX_LOCAL_LENGTH_DIFF) {
1409                     // CHOP
1410                     return new ChopFrame(SAME_FRAME_EXTENDED - diff_length,
1411                                          offset_delta);
1412                 }
1413             }
1414             // FULL_FRAME
1415             return new FullFrame(offset_delta, locals, stack);
1416         }
1417 
1418         static boolean isInt(Type t) {
1419             return (t.getTag().isStrictSubRangeOf(INT)  || t.hasTag(BOOLEAN));
1420         }
1421 
1422         static boolean isSameType(Type t1, Type t2, Types types) {
1423             if (t1 == null) { return t2 == null; }
1424             if (t2 == null) { return false; }
1425 
1426             if (isInt(t1) &amp;&amp; isInt(t2)) { return true; }
1427 
1428             if (t1.hasTag(UNINITIALIZED_THIS)) {
1429                 return t2.hasTag(UNINITIALIZED_THIS);
1430             } else if (t1.hasTag(UNINITIALIZED_OBJECT)) {
1431                 if (t2.hasTag(UNINITIALIZED_OBJECT)) {
1432                     return ((UninitializedType)t1).offset == ((UninitializedType)t2).offset;
1433                 } else {
1434                     return false;
1435                 }
1436             } else if (t2.hasTag(UNINITIALIZED_THIS) || t2.hasTag(UNINITIALIZED_OBJECT)) {
1437                 return false;
1438             }
1439 
1440             return types.isSameType(t1, t2);
1441         }
1442 
1443         static int compare(Type[] arr1, Type[] arr2, Types types) {
1444             int diff_length = arr1.length - arr2.length;
1445             if (diff_length &gt; MAX_LOCAL_LENGTH_DIFF || diff_length &lt; -MAX_LOCAL_LENGTH_DIFF) {
1446                 return Integer.MAX_VALUE;
1447             }
1448             int len = (diff_length &gt; 0) ? arr2.length : arr1.length;
1449             for (int i=0; i&lt;len; i++) {
1450                 if (!isSameType(arr1[i], arr2[i], types)) {
1451                     return Integer.MAX_VALUE;
1452                 }
1453             }
1454             return diff_length;
1455         }
1456     }
1457 
1458     void writeFields(Scope s) {
1459         // process them in reverse sibling order;
1460         // i.e., process them in declaration order.
1461         List&lt;VarSymbol&gt; vars = List.nil();
1462         for (Symbol sym : s.getSymbols(NON_RECURSIVE)) {
1463             if (sym.kind == VAR) vars = vars.prepend((VarSymbol)sym);
1464         }
1465         while (vars.nonEmpty()) {
1466             writeField(vars.head);
1467             vars = vars.tail;
1468         }
1469     }
1470 
1471     void writeMethods(Scope s) {
1472         List&lt;MethodSymbol&gt; methods = List.nil();
1473         for (Symbol sym : s.getSymbols(NON_RECURSIVE)) {
1474             if (sym.kind == MTH &amp;&amp; (sym.flags() &amp; HYPOTHETICAL) == 0)
1475                 methods = methods.prepend((MethodSymbol)sym);
1476         }
1477         while (methods.nonEmpty()) {
1478             writeMethod(methods.head);
1479             methods = methods.tail;
1480         }
1481     }
1482 
1483     /** Emit a class file for a given class.
1484      *  @param c      The class from which a class file is generated.
1485      */
1486     public JavaFileObject writeClass(ClassSymbol c)
1487         throws IOException, PoolOverflow, StringOverflow
1488     {
1489         String name = (c.owner.kind == MDL ? c.name : c.flatname).toString();
1490         Location outLocn;
1491         if (multiModuleMode) {
1492             ModuleSymbol msym = c.owner.kind == MDL ? (ModuleSymbol) c.owner : c.packge().modle;
1493             outLocn = fileManager.getLocationForModule(CLASS_OUTPUT, msym.name.toString());
1494         } else {
1495             outLocn = CLASS_OUTPUT;
1496         }
1497         JavaFileObject outFile
1498             = fileManager.getJavaFileForOutput(outLocn,
1499                                                name,
1500                                                JavaFileObject.Kind.CLASS,
1501                                                c.sourcefile);
1502         OutputStream out = outFile.openOutputStream();
1503         try {
1504             writeClassFile(out, c);
1505             if (verbose)
1506                 log.printVerbose(&quot;wrote.file&quot;, outFile.getName());
1507             out.close();
1508             out = null;
1509         } catch (InvalidSignatureException ex) {
1510             log.error(Errors.CannotGenerateClass(c, Fragments.IllegalSignature(c, ex.type())));
1511         } finally {
1512             if (out != null) {
1513                 // if we are propagating an exception, delete the file
1514                 out.close();
1515                 outFile.delete();
1516                 outFile = null;
1517             }
1518         }
1519         return outFile; // may be null if write failed
1520     }
1521 
1522     /** Write class `c&#39; to outstream `out&#39;.
1523      */
1524     public void writeClassFile(OutputStream out, ClassSymbol c)
1525         throws IOException, PoolOverflow, StringOverflow {
1526         Assert.check((c.flags() &amp; COMPOUND) == 0);
1527         databuf.reset();
1528         poolbuf.reset();
1529 
1530         Type supertype = types.supertype(c.type);
1531         List&lt;Type&gt; interfaces = types.interfaces(c.type);
1532         List&lt;Type&gt; typarams = c.type.getTypeArguments();
1533 
1534         int flags;
1535         if (c.owner.kind == MDL) {
1536             flags = ACC_MODULE;
1537         } else {
1538             flags = adjustFlags(c.flags() &amp; ~DEFAULT);
1539             if ((flags &amp; PROTECTED) != 0) flags |= PUBLIC;
1540             flags = flags &amp; ClassFlags &amp; ~STRICTFP;
1541             if ((flags &amp; INTERFACE) == 0) flags |= ACC_SUPER;
1542         }
1543 
1544         if (dumpClassModifiers) {
1545             PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
1546             pw.println();
1547             pw.println(&quot;CLASSFILE  &quot; + c.getQualifiedName());
1548             pw.println(&quot;---&quot; + flagNames(flags));
1549         }
1550         databuf.appendChar(flags);
1551 
1552         if (c.owner.kind == MDL) {
1553             PackageSymbol unnamed = ((ModuleSymbol) c.owner).unnamedPackage;
1554             databuf.appendChar(poolWriter.putClass(new ClassSymbol(0, names.module_info, unnamed)));
1555         } else {
1556             databuf.appendChar(poolWriter.putClass(c));
1557         }
1558         databuf.appendChar(supertype.hasTag(CLASS) ? poolWriter.putClass((ClassSymbol)supertype.tsym) : 0);
1559         databuf.appendChar(interfaces.length());
1560         for (List&lt;Type&gt; l = interfaces; l.nonEmpty(); l = l.tail)
1561             databuf.appendChar(poolWriter.putClass((ClassSymbol)l.head.tsym));
1562         int fieldsCount = 0;
1563         int methodsCount = 0;
1564         for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {
1565             switch (sym.kind) {
1566             case VAR: fieldsCount++; break;
1567             case MTH: if ((sym.flags() &amp; HYPOTHETICAL) == 0) methodsCount++;
1568                       break;
1569             case TYP: poolWriter.enterInner((ClassSymbol)sym); break;
1570             default : Assert.error();
1571             }
1572         }
1573 
1574         if (c.trans_local != null) {
1575             for (ClassSymbol local : c.trans_local) {
1576                 poolWriter.enterInner(local);
1577             }
1578         }
1579 
1580         databuf.appendChar(fieldsCount);
1581         writeFields(c.members());
1582         databuf.appendChar(methodsCount);
1583         writeMethods(c.members());
1584 
1585         int acountIdx = beginAttrs();
1586         int acount = 0;
1587 
1588         boolean sigReq =
1589             typarams.length() != 0 || supertype.allparams().length() != 0;
1590         for (List&lt;Type&gt; l = interfaces; !sigReq &amp;&amp; l.nonEmpty(); l = l.tail)
1591             sigReq = l.head.allparams().length() != 0;
1592         if (sigReq) {
1593             int alenIdx = writeAttr(names.Signature);
1594             databuf.appendChar(poolWriter.putSignature(c));
1595             endAttr(alenIdx);
1596             acount++;
1597         }
1598 
1599         if (c.sourcefile != null &amp;&amp; emitSourceFile) {
1600             int alenIdx = writeAttr(names.SourceFile);
1601             // WHM 6/29/1999: Strip file path prefix.  We do it here at
1602             // the last possible moment because the sourcefile may be used
1603             // elsewhere in error diagnostics. Fixes 4241573.
1604             String simpleName = PathFileObject.getSimpleName(c.sourcefile);
1605             databuf.appendChar(poolWriter.putName(names.fromString(simpleName)));
1606             endAttr(alenIdx);
1607             acount++;
1608         }
1609 
1610         if (genCrt) {
1611             // Append SourceID attribute
1612             int alenIdx = writeAttr(names.SourceID);
1613             databuf.appendChar(poolWriter.putName(names.fromString(Long.toString(getLastModified(c.sourcefile)))));
1614             endAttr(alenIdx);
1615             acount++;
1616             // Append CompilationID attribute
1617             alenIdx = writeAttr(names.CompilationID);
1618             databuf.appendChar(poolWriter.putName(names.fromString(Long.toString(System.currentTimeMillis()))));
1619             endAttr(alenIdx);
1620             acount++;
1621         }
1622 
1623         acount += writeFlagAttrs(c.flags());
1624         acount += writeJavaAnnotations(c.getRawAttributes());
1625         acount += writeTypeAnnotations(c.getRawTypeAttributes(), false);
1626         acount += writeEnclosingMethodAttribute(c);
1627         if (c.owner.kind == MDL) {
1628             acount += writeModuleAttribute(c);
1629             acount += writeFlagAttrs(c.owner.flags() &amp; ~DEPRECATED);
1630         }
1631         acount += writeExtraClassAttributes(c);
1632         acount += writeExtraAttributes(c);
1633 
1634         poolbuf.appendInt(JAVA_MAGIC);
1635         if (preview.isEnabled()) {
1636             poolbuf.appendChar(ClassFile.PREVIEW_MINOR_VERSION);
1637         } else {
1638             poolbuf.appendChar(target.minorVersion);
1639         }
1640         poolbuf.appendChar(target.majorVersion);
1641 
1642         if (c.owner.kind != MDL) {
1643             if (target.hasNestmateAccess()) {
1644                 acount += writeNestMembersIfNeeded(c);
1645                 acount += writeNestHostIfNeeded(c);
1646             }
1647         }
1648 
1649         if (c.isRecord()) {
1650             acount += writeRecordAttribute(c);
1651         }
1652 
<a name="3" id="anc3"></a><span class="line-added">1653         if (target.hasSealedClasses()) {</span>
<span class="line-added">1654             acount += writePermittedSubclassesIfNeeded(c);</span>
<span class="line-added">1655         }</span>
<span class="line-added">1656 </span>
1657         if (!poolWriter.bootstrapMethods.isEmpty()) {
1658             writeBootstrapMethods();
1659             acount++;
1660         }
1661 
1662         if (!poolWriter.innerClasses.isEmpty()) {
1663             writeInnerClasses();
1664             acount++;
1665         }
1666 
1667         endAttrs(acountIdx, acount);
1668 
1669         out.write(poolbuf.elems, 0, poolbuf.length);
1670 
1671         poolWriter.writePool(out);
1672         poolWriter.reset(); // to save space
1673 
1674         out.write(databuf.elems, 0, databuf.length);
1675     }
1676 
1677      /**Allows subclasses to write additional class attributes
1678       *
1679       * @return the number of attributes written
1680       */
1681     protected int writeExtraClassAttributes(ClassSymbol c) {
1682         return 0;
1683     }
1684 
1685     /**Allows friends to write additional attributes
1686      *
1687      * @return the number of attributes written
1688      */
1689     protected int writeExtraAttributes(Symbol sym) {
1690         int i = 0;
1691         for (ToIntFunction&lt;Symbol&gt; hook : extraAttributeHooks) {
1692             i += hook.applyAsInt(sym);
1693         }
1694         return i;
1695     }
1696 
1697     int adjustFlags(final long flags) {
1698         int result = (int)flags;
1699 
1700         if ((flags &amp; BRIDGE) != 0)
1701             result |= ACC_BRIDGE;
1702         if ((flags &amp; VARARGS) != 0)
1703             result |= ACC_VARARGS;
1704         if ((flags &amp; DEFAULT) != 0)
1705             result &amp;= ~ABSTRACT;
1706         return result;
1707     }
1708 
1709     long getLastModified(FileObject filename) {
1710         long mod = 0;
1711         try {
1712             mod = filename.getLastModified();
1713         } catch (SecurityException e) {
1714             throw new AssertionError(&quot;CRT: couldn&#39;t get source file modification date: &quot; + e.getMessage());
1715         }
1716         return mod;
1717     }
1718 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
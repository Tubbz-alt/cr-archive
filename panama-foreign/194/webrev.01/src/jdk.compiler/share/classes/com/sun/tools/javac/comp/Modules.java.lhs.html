<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 
  27 package com.sun.tools.javac.comp;
  28 
  29 import java.io.IOException;
  30 import java.util.Arrays;
  31 import java.util.Collection;
  32 import java.util.Collections;
  33 import java.util.EnumSet;
  34 import java.util.HashMap;
  35 import java.util.HashSet;
  36 import java.util.LinkedHashMap;
  37 import java.util.LinkedHashSet;
  38 import java.util.Map;
  39 import java.util.Set;
  40 import java.util.function.Consumer;
  41 import java.util.function.Predicate;
  42 import java.util.regex.Matcher;
  43 import java.util.regex.Pattern;
  44 import java.util.stream.Collectors;
  45 import java.util.stream.Stream;
  46 
  47 import javax.lang.model.SourceVersion;
  48 import javax.tools.JavaFileManager;
  49 import javax.tools.JavaFileManager.Location;
  50 import javax.tools.JavaFileObject;
  51 import javax.tools.JavaFileObject.Kind;
  52 import javax.tools.StandardLocation;
  53 
  54 import com.sun.source.tree.ModuleTree.ModuleKind;
  55 import com.sun.tools.javac.code.ClassFinder;
  56 import com.sun.tools.javac.code.DeferredLintHandler;
  57 import com.sun.tools.javac.code.Directive;
  58 import com.sun.tools.javac.code.Directive.ExportsDirective;
  59 import com.sun.tools.javac.code.Directive.ExportsFlag;
  60 import com.sun.tools.javac.code.Directive.OpensDirective;
  61 import com.sun.tools.javac.code.Directive.OpensFlag;
  62 import com.sun.tools.javac.code.Directive.RequiresDirective;
  63 import com.sun.tools.javac.code.Directive.RequiresFlag;
  64 import com.sun.tools.javac.code.Directive.UsesDirective;
  65 import com.sun.tools.javac.code.Flags;
  66 import com.sun.tools.javac.code.Flags.Flag;
  67 import com.sun.tools.javac.code.Lint.LintCategory;
  68 import com.sun.tools.javac.code.ModuleFinder;
  69 import com.sun.tools.javac.code.Source;
  70 import com.sun.tools.javac.code.Source.Feature;
  71 import com.sun.tools.javac.code.Symbol;
  72 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  73 import com.sun.tools.javac.code.Symbol.Completer;
  74 import com.sun.tools.javac.code.Symbol.CompletionFailure;
  75 import com.sun.tools.javac.code.Symbol.MethodSymbol;
  76 import com.sun.tools.javac.code.Symbol.ModuleFlags;
  77 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  78 import com.sun.tools.javac.code.Symbol.PackageSymbol;
  79 import com.sun.tools.javac.code.Symtab;
  80 import com.sun.tools.javac.code.Type;
  81 import com.sun.tools.javac.code.Types;
  82 import com.sun.tools.javac.jvm.ClassWriter;
  83 import com.sun.tools.javac.jvm.JNIWriter;
  84 import com.sun.tools.javac.jvm.Target;
  85 import com.sun.tools.javac.main.Option;
  86 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  87 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  88 import com.sun.tools.javac.tree.JCTree;
  89 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
  90 import com.sun.tools.javac.tree.JCTree.JCDirective;
  91 import com.sun.tools.javac.tree.JCTree.JCExports;
  92 import com.sun.tools.javac.tree.JCTree.JCExpression;
  93 import com.sun.tools.javac.tree.JCTree.JCModuleDecl;
  94 import com.sun.tools.javac.tree.JCTree.JCOpens;
  95 import com.sun.tools.javac.tree.JCTree.JCProvides;
  96 import com.sun.tools.javac.tree.JCTree.JCRequires;
  97 import com.sun.tools.javac.tree.JCTree.JCUses;
  98 import com.sun.tools.javac.tree.JCTree.Tag;
  99 import com.sun.tools.javac.tree.TreeInfo;
 100 import com.sun.tools.javac.util.Assert;
 101 import com.sun.tools.javac.util.Context;
 102 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 103 import com.sun.tools.javac.util.List;
 104 import com.sun.tools.javac.util.ListBuffer;
 105 import com.sun.tools.javac.util.Log;
 106 import com.sun.tools.javac.util.Name;
 107 import com.sun.tools.javac.util.Names;
 108 import com.sun.tools.javac.util.Options;
 109 
 110 import static com.sun.tools.javac.code.Flags.ABSTRACT;
 111 import static com.sun.tools.javac.code.Flags.ENUM;
 112 import static com.sun.tools.javac.code.Flags.PUBLIC;
 113 import static com.sun.tools.javac.code.Flags.UNATTRIBUTED;
 114 
 115 import com.sun.tools.javac.code.Kinds;
 116 
 117 import static com.sun.tools.javac.code.Kinds.Kind.ERR;
 118 import static com.sun.tools.javac.code.Kinds.Kind.MDL;
 119 import static com.sun.tools.javac.code.Kinds.Kind.MTH;
 120 
 121 import com.sun.tools.javac.code.Symbol.ModuleResolutionFlags;
 122 
 123 import static com.sun.tools.javac.code.TypeTag.CLASS;
 124 
 125 /**
 126  *  TODO: fill in
 127  *
 128  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 129  *  If you write code that depends on this, you do so at your own risk.
 130  *  This code and its internal interfaces are subject to change or
 131  *  deletion without notice.&lt;/b&gt;
 132  */
 133 public class Modules extends JCTree.Visitor {
 134     private static final String ALL_SYSTEM = &quot;ALL-SYSTEM&quot;;
 135     private static final String ALL_MODULE_PATH = &quot;ALL-MODULE-PATH&quot;;
 136 
 137     private final Log log;
 138     private final Names names;
 139     private final Symtab syms;
 140     private final Attr attr;
 141     private final Check chk;
 142     private final DeferredLintHandler deferredLintHandler;
 143     private final TypeEnvs typeEnvs;
 144     private final Types types;
 145     private final JavaFileManager fileManager;
 146     private final ModuleFinder moduleFinder;
 147     private final Source source;
 148     private final Target target;
 149     private final boolean allowModules;
 150     private final boolean allowAccessIntoSystem;
 151 
 152     public final boolean multiModuleMode;
 153 
 154     private final Name java_se;
 155     private final Name java_;
 156 
 157     ModuleSymbol defaultModule;
 158 
 159     private final String addExportsOpt;
 160     private Map&lt;ModuleSymbol, Set&lt;ExportsDirective&gt;&gt; addExports;
 161     private final String addReadsOpt;
 162     private Map&lt;ModuleSymbol, Set&lt;RequiresDirective&gt;&gt; addReads;
 163     private final String addModsOpt;
 164     private final Set&lt;String&gt; extraAddMods = new HashSet&lt;&gt;();
 165     private final String limitModsOpt;
 166     private final Set&lt;String&gt; extraLimitMods = new HashSet&lt;&gt;();
 167     private final String moduleVersionOpt;
 168 
 169     private final boolean lintOptions;
 170 
 171     private Set&lt;ModuleSymbol&gt; rootModules = null;
 172     private final Set&lt;ModuleSymbol&gt; warnedMissing = new HashSet&lt;&gt;();
 173 
 174     public PackageNameFinder findPackageInFile;
 175 
 176     public static Modules instance(Context context) {
 177         Modules instance = context.get(Modules.class);
 178         if (instance == null)
 179             instance = new Modules(context);
 180         return instance;
 181     }
 182 
 183     protected Modules(Context context) {
 184         context.put(Modules.class, this);
 185         log = Log.instance(context);
 186         names = Names.instance(context);
 187         syms = Symtab.instance(context);
 188         attr = Attr.instance(context);
 189         chk = Check.instance(context);
 190         deferredLintHandler = DeferredLintHandler.instance(context);
 191         typeEnvs = TypeEnvs.instance(context);
 192         moduleFinder = ModuleFinder.instance(context);
 193         types = Types.instance(context);
 194         fileManager = context.get(JavaFileManager.class);
 195         source = Source.instance(context);
 196         target = Target.instance(context);
 197         allowModules = Feature.MODULES.allowedInSource(source);
 198         Options options = Options.instance(context);
 199 
 200         allowAccessIntoSystem = options.isUnset(Option.RELEASE);
 201         lintOptions = options.isUnset(Option.XLINT_CUSTOM, &quot;-&quot; + LintCategory.OPTIONS.option);
 202 
 203         multiModuleMode = fileManager.hasLocation(StandardLocation.MODULE_SOURCE_PATH);
 204         ClassWriter classWriter = ClassWriter.instance(context);
 205         classWriter.multiModuleMode = multiModuleMode;
 206         JNIWriter jniWriter = JNIWriter.instance(context);
 207         jniWriter.multiModuleMode = multiModuleMode;
 208 
 209         java_se = names.fromString(&quot;java.se&quot;);
 210         java_ = names.fromString(&quot;java.&quot;);
 211 
 212         addExportsOpt = options.get(Option.ADD_EXPORTS);
 213         addReadsOpt = options.get(Option.ADD_READS);
 214         addModsOpt = options.get(Option.ADD_MODULES);
 215         limitModsOpt = options.get(Option.LIMIT_MODULES);
 216         moduleVersionOpt = options.get(Option.MODULE_VERSION);
 217     }
 218 
 219     int depth = -1;
 220 
 221     public void addExtraAddModules(String... extras) {
 222         extraAddMods.addAll(Arrays.asList(extras));
 223     }
 224 
 225     boolean inInitModules;
 226     public void initModules(List&lt;JCCompilationUnit&gt; trees) {
 227         Assert.check(!inInitModules);
 228         try {
 229             inInitModules = true;
 230             Assert.checkNull(rootModules);
 231             enter(trees, modules -&gt; {
 232                 Assert.checkNull(rootModules);
 233                 Assert.checkNull(allModules);
 234                 this.rootModules = modules;
 235                 setupAllModules(); //initialize the module graph
 236                 Assert.checkNonNull(allModules);
 237                 inInitModules = false;
 238             }, null);
 239         } finally {
 240             inInitModules = false;
 241         }
 242     }
 243 
 244     public boolean enter(List&lt;JCCompilationUnit&gt; trees, ClassSymbol c) {
 245         Assert.check(rootModules != null || inInitModules || !allowModules);
 246         return enter(trees, modules -&gt; {}, c);
 247     }
 248 
 249     private boolean enter(List&lt;JCCompilationUnit&gt; trees, Consumer&lt;Set&lt;ModuleSymbol&gt;&gt; init, ClassSymbol c) {
 250         if (!allowModules) {
 251             for (JCCompilationUnit tree: trees) {
 252                 tree.modle = syms.noModule;
 253             }
 254             defaultModule = syms.noModule;
 255             return true;
 256         }
 257 
 258         int startErrors = log.nerrors;
 259 
 260         depth++;
 261         try {
 262             // scan trees for module defs
 263             Set&lt;ModuleSymbol&gt; roots = enterModules(trees, c);
 264 
 265             setCompilationUnitModules(trees, roots, c);
 266 
 267             init.accept(roots);
 268 
 269             for (ModuleSymbol msym: roots) {
 270                 msym.complete();
 271             }
 272         } catch (CompletionFailure ex) {
 273             chk.completionError(null, ex);
 274         } finally {
 275             depth--;
 276         }
 277 
 278         return (log.nerrors == startErrors);
 279     }
 280 
 281     public Completer getCompleter() {
 282         return mainCompleter;
 283     }
 284 
 285     public ModuleSymbol getDefaultModule() {
 286         return defaultModule;
 287     }
 288 
 289     public boolean modulesInitialized() {
 290         return allModules != null;
 291     }
 292 
 293     private Set&lt;ModuleSymbol&gt; enterModules(List&lt;JCCompilationUnit&gt; trees, ClassSymbol c) {
 294         Set&lt;ModuleSymbol&gt; modules = new LinkedHashSet&lt;&gt;();
 295         for (JCCompilationUnit tree : trees) {
 296             JavaFileObject prev = log.useSource(tree.sourcefile);
 297             try {
 298                 enterModule(tree, c, modules);
 299             } finally {
 300                 log.useSource(prev);
 301             }
 302         }
 303         return modules;
 304     }
 305 
 306 
 307     private void enterModule(JCCompilationUnit toplevel, ClassSymbol c, Set&lt;ModuleSymbol&gt; modules) {
 308         boolean isModuleInfo = toplevel.sourcefile.isNameCompatible(&quot;module-info&quot;, Kind.SOURCE);
 309         boolean isModuleDecl = toplevel.getModuleDecl() != null;
 310         if (isModuleDecl) {
 311             JCModuleDecl decl = toplevel.getModuleDecl();
 312             if (!isModuleInfo) {
 313                 log.error(decl.pos(), Errors.ModuleDeclSbInModuleInfoJava);
 314             }
 315             Name name = TreeInfo.fullName(decl.qualId);
 316             ModuleSymbol sym;
 317             if (c != null) {
 318                 sym = (ModuleSymbol) c.owner;
 319                 Assert.checkNonNull(sym.name);
 320                 Name treeName = TreeInfo.fullName(decl.qualId);
 321                 if (sym.name != treeName) {
 322                     log.error(decl.pos(), Errors.ModuleNameMismatch(name, sym.name));
 323                 }
 324             } else {
 325                 sym = syms.enterModule(name);
 326                 if (sym.module_info.sourcefile != null &amp;&amp; sym.module_info.sourcefile != toplevel.sourcefile) {
 327                     log.error(decl.pos(), Errors.DuplicateModule(sym));
 328                     return;
 329                 }
 330             }
 331             sym.completer = getSourceCompleter(toplevel);
 332             sym.module_info.sourcefile = toplevel.sourcefile;
 333             decl.sym = sym;
 334 
 335             if (multiModuleMode || modules.isEmpty()) {
 336                 modules.add(sym);
 337             } else {
 338                 log.error(toplevel.pos(), Errors.TooManyModules);
 339             }
 340 
 341             Env&lt;AttrContext&gt; provisionalEnv = new Env&lt;&gt;(decl, null);
 342 
 343             provisionalEnv.toplevel = toplevel;
 344             typeEnvs.put(sym, provisionalEnv);
 345         } else if (isModuleInfo) {
 346             if (multiModuleMode) {
 347                 JCTree tree = toplevel.defs.isEmpty() ? toplevel : toplevel.defs.head;
 348                 log.error(tree.pos(), Errors.ExpectedModule);
 349             }
 350         }
 351     }
 352 
 353     private void setCompilationUnitModules(List&lt;JCCompilationUnit&gt; trees, Set&lt;ModuleSymbol&gt; rootModules, ClassSymbol c) {
 354         // update the module for each compilation unit
 355         if (multiModuleMode) {
 356             boolean patchesAutomaticModules = false;
 357             for (JCCompilationUnit tree: trees) {
 358                 if (tree.defs.isEmpty()) {
 359                     tree.modle = syms.unnamedModule;
 360                     continue;
 361                 }
 362 
 363                 JavaFileObject prev = log.useSource(tree.sourcefile);
 364                 try {
 365                     Location msplocn = getModuleLocation(tree);
 366                     Location plocn = fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH) ?
 367                             fileManager.getLocationForModule(StandardLocation.PATCH_MODULE_PATH,
 368                                                              tree.sourcefile) :
 369                             null;
 370 
 371                     if (plocn != null) {
 372                         Name name = names.fromString(fileManager.inferModuleName(plocn));
 373                         ModuleSymbol msym = moduleFinder.findModule(name);
 374                         tree.modle = msym;
 375                         rootModules.add(msym);
 376                         patchesAutomaticModules |= (msym.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0;
 377 
 378                         if (msplocn != null) {
 379                             Name mspname = names.fromString(fileManager.inferModuleName(msplocn));
 380                             if (name != mspname) {
 381                                 log.error(tree.pos(), Errors.FilePatchedAndMsp(name, mspname));
 382                             }
 383                         }
 384                     } else if (msplocn != null) {
 385                         if (tree.getModuleDecl() != null) {
 386                             JavaFileObject canonical =
 387                                     fileManager.getJavaFileForInput(msplocn, &quot;module-info&quot;, Kind.SOURCE);
 388                             if (canonical == null || !fileManager.isSameFile(canonical, tree.sourcefile)) {
 389                                 log.error(tree.pos(), Errors.ModuleNotFoundOnModuleSourcePath);
 390                             }
 391                         }
 392                         Name name = names.fromString(fileManager.inferModuleName(msplocn));
 393                         ModuleSymbol msym;
 394                         JCModuleDecl decl = tree.getModuleDecl();
 395                         if (decl != null) {
 396                             msym = decl.sym;
 397                             if (msym.name != name) {
 398                                 log.error(decl.qualId, Errors.ModuleNameMismatch(msym.name, name));
 399                             }
 400                         } else {
 401                             if (tree.getPackage() == null) {
 402                                 log.error(tree.pos(), Errors.UnnamedPkgNotAllowedNamedModules);
 403                             }
 404                             msym = syms.enterModule(name);
 405                         }
 406                         if (msym.sourceLocation == null) {
 407                             msym.sourceLocation = msplocn;
 408                             if (fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH)) {
 409                                 msym.patchLocation = fileManager.getLocationForModule(
 410                                         StandardLocation.PATCH_MODULE_PATH, msym.name.toString());
 411                             }
 412                             if (fileManager.hasLocation(StandardLocation.CLASS_OUTPUT)) {
 413                                 Location outputLocn = fileManager.getLocationForModule(
 414                                         StandardLocation.CLASS_OUTPUT, msym.name.toString());
 415                                 if (msym.patchLocation == null) {
 416                                     msym.classLocation = outputLocn;
 417                                 } else {
 418                                     msym.patchOutputLocation = outputLocn;
 419                                 }
 420                             }
 421                         }
 422                         tree.modle = msym;
 423                         rootModules.add(msym);
 424                     } else if (c != null &amp;&amp; c.packge().modle == syms.unnamedModule) {
 425                         tree.modle = syms.unnamedModule;
 426                     } else {
 427                         if (tree.getModuleDecl() != null) {
 428                             log.error(tree.pos(), Errors.ModuleNotFoundOnModuleSourcePath);
 429                         } else {
 430                             log.error(tree.pos(), Errors.NotInModuleOnModuleSourcePath);
 431                         }
 432                         tree.modle = syms.errModule;
 433                     }
 434                 } catch (IOException e) {
 435                     throw new Error(e); // FIXME
 436                 } finally {
 437                     log.useSource(prev);
 438                 }
 439             }
 440             if (!patchesAutomaticModules) {
 441                 checkNoAllModulePath();
 442             }
 443             if (syms.unnamedModule.sourceLocation == null) {
 444                 syms.unnamedModule.completer = getUnnamedModuleCompleter();
 445                 syms.unnamedModule.sourceLocation = StandardLocation.SOURCE_PATH;
 446                 syms.unnamedModule.classLocation = StandardLocation.CLASS_PATH;
 447             }
 448             defaultModule = syms.unnamedModule;
 449         } else {
 450             ModuleSymbol module = null;
 451             if (defaultModule == null) {
 452                 String moduleOverride = singleModuleOverride(trees);
 453                 switch (rootModules.size()) {
 454                     case 0:
 455                         try {
 456                             defaultModule = moduleFinder.findSingleModule();
 457                         } catch (CompletionFailure cf) {
 458                             chk.completionError(null, cf);
 459                             defaultModule = syms.unnamedModule;
 460                         }
 461                         if (defaultModule == syms.unnamedModule) {
 462                             if (moduleOverride != null) {
 463                                 defaultModule = moduleFinder.findModule(names.fromString(moduleOverride));
 464                                 defaultModule.patchOutputLocation = StandardLocation.CLASS_OUTPUT;
 465                                 if ((defaultModule.flags_field &amp; Flags.AUTOMATIC_MODULE) == 0) {
 466                                     checkNoAllModulePath();
 467                                 }
 468                             } else {
 469                                 // Question: why not do findAllModules and initVisiblePackages here?
 470                                 // i.e. body of unnamedModuleCompleter
 471                                 defaultModule.completer = getUnnamedModuleCompleter();
 472                                 defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
 473                                 defaultModule.classLocation = StandardLocation.CLASS_PATH;
 474                             }
 475                         } else {
 476                             checkNoAllModulePath();
 477                             defaultModule.complete();
 478                             // Question: why not do completeModule here?
 479                             defaultModule.completer = sym -&gt; completeModule((ModuleSymbol) sym);
 480                             defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
 481                         }
 482                         rootModules.add(defaultModule);
 483                         break;
 484                     case 1:
 485                         checkNoAllModulePath();
 486                         defaultModule = rootModules.iterator().next();
 487                         defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
 488                         if (fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH)) {
 489                             try {
 490                                 defaultModule.patchLocation = fileManager.getLocationForModule(
 491                                         StandardLocation.PATCH_MODULE_PATH, defaultModule.name.toString());
 492                             } catch (IOException ex) {
 493                                 throw new Error(ex);
 494                             }
 495                         }
 496                         if (defaultModule.patchLocation == null) {
 497                             defaultModule.classLocation = StandardLocation.CLASS_OUTPUT;
 498                         } else {
 499                             defaultModule.patchOutputLocation = StandardLocation.CLASS_OUTPUT;
 500                         }
 501                         break;
 502                     default:
 503                         Assert.error(&quot;too many modules&quot;);
 504                 }
 505             } else if (rootModules.size() == 1) {
 506                 module = rootModules.iterator().next();
 507                 module.complete();
 508                 module.completer = sym -&gt; completeModule((ModuleSymbol) sym);
 509             } else {
 510                 Assert.check(rootModules.isEmpty());
 511                 Assert.checkNonNull(c);
 512                 module = c.packge().modle;
 513                 rootModules.add(module);
 514             }
 515 
 516             if (defaultModule != syms.unnamedModule) {
 517                 syms.unnamedModule.completer = getUnnamedModuleCompleter();
 518                 syms.unnamedModule.classLocation = StandardLocation.CLASS_PATH;
 519             }
 520 
 521             if (module == null) {
 522                 module = defaultModule;
 523             }
 524 
 525             for (JCCompilationUnit tree : trees) {
 526                 if (defaultModule != syms.unnamedModule
 527                         &amp;&amp; defaultModule.sourceLocation == StandardLocation.SOURCE_PATH
 528                         &amp;&amp; fileManager.hasLocation(StandardLocation.SOURCE_PATH)) {
 529                     checkSourceLocation(tree, module);
 530                 }
 531                 tree.modle = module;
 532             }
 533         }
 534     }
 535 
 536     private void checkSourceLocation(JCCompilationUnit tree, ModuleSymbol msym) {
 537         try {
 538             JavaFileObject fo = tree.sourcefile;
 539             if (fileManager.contains(msym.sourceLocation, fo)) {
 540                 return;
 541             }
 542             if (msym.patchLocation != null &amp;&amp; fileManager.contains(msym.patchLocation, fo)) {
 543                 return;
 544             }
 545             if (fileManager.hasLocation(StandardLocation.SOURCE_OUTPUT)) {
 546                 if (fileManager.contains(StandardLocation.SOURCE_OUTPUT, fo)) {
 547                     return;
 548                 }
 549             } else {
 550                 if (fileManager.contains(StandardLocation.CLASS_OUTPUT, fo)) {
 551                     return;
 552                 }
 553             }
 554         } catch (IOException e) {
 555             throw new Error(e);
 556         }
 557 
 558         JavaFileObject prev = log.useSource(tree.sourcefile);
 559         try {
 560             log.error(tree.pos(), Errors.FileSbOnSourceOrPatchPathForModule);
 561         } finally {
 562             log.useSource(prev);
 563         }
 564     }
 565 
 566     private String singleModuleOverride(List&lt;JCCompilationUnit&gt; trees) {
 567         if (!fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH)) {
 568             return null;
 569         }
 570 
 571         Set&lt;String&gt; override = new LinkedHashSet&lt;&gt;();
 572         for (JCCompilationUnit tree : trees) {
 573             JavaFileObject fo = tree.sourcefile;
 574 
 575             try {
 576                 Location loc =
 577                         fileManager.getLocationForModule(StandardLocation.PATCH_MODULE_PATH, fo);
 578 
 579                 if (loc != null) {
 580                     override.add(fileManager.inferModuleName(loc));
 581                 }
 582             } catch (IOException ex) {
 583                 throw new Error(ex);
 584             }
 585         }
 586 
 587         switch (override.size()) {
 588             case 0: return null;
 589             case 1: return override.iterator().next();
 590             default:
 591                 log.error(Errors.TooManyPatchedModules(override));
 592                 return null;
 593         }
 594     }
 595 
 596     /**
 597      * Determine the location for the module on the module source path
 598      * or source output directory which contains a given CompilationUnit.
 599      * If the source output directory is unset, the class output directory
 600      * will be checked instead.
 601      * {@code null} is returned if no such module can be found.
 602      * @param tree the compilation unit tree
 603      * @return the location for the enclosing module
 604      * @throws IOException if there is a problem while searching for the module.
 605      */
 606     private Location getModuleLocation(JCCompilationUnit tree) throws IOException {
 607         JavaFileObject fo = tree.sourcefile;
 608 
 609         Location loc =
 610                 fileManager.getLocationForModule(StandardLocation.MODULE_SOURCE_PATH, fo);
 611         if (loc == null) {
 612             Location sourceOutput = fileManager.hasLocation(StandardLocation.SOURCE_OUTPUT) ?
 613                     StandardLocation.SOURCE_OUTPUT : StandardLocation.CLASS_OUTPUT;
 614             loc =
 615                 fileManager.getLocationForModule(sourceOutput, fo);
 616         }
 617         return loc;
 618     }
 619 
 620     private void checkNoAllModulePath() {
 621         if (addModsOpt != null &amp;&amp; Arrays.asList(addModsOpt.split(&quot;,&quot;)).contains(ALL_MODULE_PATH)) {
 622             log.error(Errors.AddmodsAllModulePathInvalid);
 623         }
 624     }
 625 
 626     private final Completer mainCompleter = new Completer() {
 627         @Override
 628         public void complete(Symbol sym) throws CompletionFailure {
 629             ModuleSymbol msym = moduleFinder.findModule((ModuleSymbol) sym);
 630 
 631             if (msym.kind == ERR) {
 632                 //make sure the module is initialized:
<a name="1" id="anc1"></a><span class="line-modified"> 633                 msym.directives = List.nil();</span>
<span class="line-removed"> 634                 msym.exports = List.nil();</span>
<span class="line-removed"> 635                 msym.provides = List.nil();</span>
<span class="line-removed"> 636                 msym.requires = List.nil();</span>
<span class="line-removed"> 637                 msym.uses = List.nil();</span>
 638             } else if ((msym.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0) {
 639                 setupAutomaticModule(msym);
 640             } else {
<a name="2" id="anc2"></a><span class="line-modified"> 641                 msym.module_info.complete();</span>








 642             }
 643 
 644             // If module-info comes from a .java file, the underlying
 645             // call of classFinder.fillIn will have called through the
 646             // source completer, to Enter, and then to Modules.enter,
 647             // which will call completeModule.
 648             // But, if module-info comes from a .class file, the underlying
 649             // call of classFinder.fillIn will just call ClassReader to read
 650             // the .class file, and so we call completeModule here.
 651             if (msym.module_info.classfile == null || msym.module_info.classfile.getKind() == Kind.CLASS) {
 652                 completeModule(msym);
 653             }
 654         }
 655 
<a name="3" id="anc3"></a>







 656         @Override
 657         public String toString() {
 658             return &quot;mainCompleter&quot;;
 659         }
 660     };
 661 
 662     private void setupAutomaticModule(ModuleSymbol msym) throws CompletionFailure {
 663         try {
 664             ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
 665             ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
 666             Set&lt;String&gt; seenPackages = new HashSet&lt;&gt;();
 667 
 668             for (JavaFileObject clazz : fileManager.list(msym.classLocation, &quot;&quot;, EnumSet.of(Kind.CLASS), true)) {
 669                 String binName = fileManager.inferBinaryName(msym.classLocation, clazz);
 670                 String pack = binName.lastIndexOf(&#39;.&#39;) != (-1) ? binName.substring(0, binName.lastIndexOf(&#39;.&#39;)) : &quot;&quot;; //unnamed package????
 671                 if (seenPackages.add(pack)) {
 672                     ExportsDirective d = new ExportsDirective(syms.enterPackage(msym, names.fromString(pack)), null);
 673                     //TODO: opens?
 674                     directives.add(d);
 675                     exports.add(d);
 676                 }
 677             }
 678 
 679             msym.exports = exports.toList();
 680             msym.provides = List.nil();
 681             msym.requires = List.nil();
 682             msym.uses = List.nil();
 683             msym.directives = directives.toList();
 684         } catch (IOException ex) {
 685             throw new IllegalStateException(ex);
 686         }
 687     }
 688 
 689     private void completeAutomaticModule(ModuleSymbol msym) throws CompletionFailure {
 690         ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
 691 
 692         directives.addAll(msym.directives);
 693 
 694         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
 695 
 696         for (ModuleSymbol ms : allModules()) {
 697             if (ms == syms.unnamedModule || ms == msym)
 698                 continue;
 699             Set&lt;RequiresFlag&gt; flags = (ms.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0 ?
 700                     EnumSet.of(RequiresFlag.TRANSITIVE) : EnumSet.noneOf(RequiresFlag.class);
 701             RequiresDirective d = new RequiresDirective(ms, flags);
 702             directives.add(d);
 703             requires.add(d);
 704         }
 705 
 706         RequiresDirective requiresUnnamed = new RequiresDirective(syms.unnamedModule);
 707         directives.add(requiresUnnamed);
 708         requires.add(requiresUnnamed);
 709 
 710         msym.requires = requires.toList();
 711         msym.directives = directives.toList();
 712     }
 713 
 714     private Completer getSourceCompleter(JCCompilationUnit tree) {
 715         return new Completer() {
 716             @Override
 717             public void complete(Symbol sym) throws CompletionFailure {
 718                 ModuleSymbol msym = (ModuleSymbol) sym;
 719                 msym.flags_field |= UNATTRIBUTED;
 720                 ModuleVisitor v = new ModuleVisitor();
 721                 JavaFileObject prev = log.useSource(tree.sourcefile);
 722                 JCModuleDecl moduleDecl = tree.getModuleDecl();
 723                 DiagnosticPosition prevLintPos = deferredLintHandler.setPos(moduleDecl.pos());
 724 
 725                 try {
 726                     moduleDecl.accept(v);
 727                     completeModule(msym);
 728                     checkCyclicDependencies(moduleDecl);
 729                 } finally {
 730                     log.useSource(prev);
 731                     deferredLintHandler.setPos(prevLintPos);
 732                     msym.flags_field &amp;= ~UNATTRIBUTED;
 733                 }
 734             }
 735 
 736             @Override
 737             public String toString() {
 738                 return &quot;SourceCompleter: &quot; + tree.sourcefile.getName();
 739             }
 740 
 741         };
 742     }
 743 
 744     public boolean isRootModule(ModuleSymbol module) {
 745         Assert.checkNonNull(rootModules);
 746         return rootModules.contains(module);
 747     }
 748 
 749     public Set&lt;ModuleSymbol&gt; getRootModules() {
 750         Assert.checkNonNull(rootModules);
 751         return rootModules;
 752     }
 753 
 754     class ModuleVisitor extends JCTree.Visitor {
 755         private ModuleSymbol sym;
 756         private final Set&lt;ModuleSymbol&gt; allRequires = new HashSet&lt;&gt;();
 757         private final Map&lt;PackageSymbol,List&lt;ExportsDirective&gt;&gt; allExports = new HashMap&lt;&gt;();
 758         private final Map&lt;PackageSymbol,List&lt;OpensDirective&gt;&gt; allOpens = new HashMap&lt;&gt;();
 759 
 760         @Override
 761         public void visitModuleDef(JCModuleDecl tree) {
 762             sym = Assert.checkNonNull(tree.sym);
 763 
 764             if (tree.getModuleType() == ModuleKind.OPEN) {
 765                 sym.flags.add(ModuleFlags.OPEN);
 766             }
 767             sym.flags_field |= (tree.mods.flags &amp; Flags.DEPRECATED);
 768 
 769             sym.requires = List.nil();
 770             sym.exports = List.nil();
 771             sym.opens = List.nil();
 772             tree.directives.forEach(t -&gt; t.accept(this));
 773             sym.requires = sym.requires.reverse();
 774             sym.exports = sym.exports.reverse();
 775             sym.opens = sym.opens.reverse();
 776             ensureJavaBase();
 777         }
 778 
 779         @Override
 780         public void visitRequires(JCRequires tree) {
 781             ModuleSymbol msym = lookupModule(tree.moduleName);
 782             if (msym.kind != MDL) {
 783                 log.error(tree.moduleName.pos(), Errors.ModuleNotFound(msym));
 784                 warnedMissing.add(msym);
 785             } else if (allRequires.contains(msym)) {
 786                 log.error(tree.moduleName.pos(), Errors.DuplicateRequires(msym));
 787             } else {
 788                 allRequires.add(msym);
 789                 Set&lt;RequiresFlag&gt; flags = EnumSet.noneOf(RequiresFlag.class);
 790                 if (tree.isTransitive) {
 791                     if (msym == syms.java_base &amp;&amp; source.compareTo(Source.JDK10) &gt;= 0) {
 792                         log.error(tree.pos(), Errors.ModifierNotAllowedHere(names.transitive));
 793                     } else {
 794                         flags.add(RequiresFlag.TRANSITIVE);
 795                     }
 796                 }
 797                 if (tree.isStaticPhase) {
 798                     if (msym == syms.java_base &amp;&amp; source.compareTo(Source.JDK10) &gt;= 0) {
 799                         log.error(tree.pos(), Errors.ModNotAllowedHere(EnumSet.of(Flag.STATIC)));
 800                     } else {
 801                         flags.add(RequiresFlag.STATIC_PHASE);
 802                     }
 803                 }
 804                 RequiresDirective d = new RequiresDirective(msym, flags);
 805                 tree.directive = d;
 806                 sym.requires = sym.requires.prepend(d);
 807             }
 808         }
 809 
 810         @Override
 811         public void visitExports(JCExports tree) {
 812             Name name = TreeInfo.fullName(tree.qualid);
 813             PackageSymbol packge = syms.enterPackage(sym, name);
 814             attr.setPackageSymbols(tree.qualid, packge);
 815 
 816             List&lt;ExportsDirective&gt; exportsForPackage = allExports.computeIfAbsent(packge, p -&gt; List.nil());
 817             for (ExportsDirective d : exportsForPackage) {
 818                 reportExportsConflict(tree, packge);
 819             }
 820 
 821             List&lt;ModuleSymbol&gt; toModules = null;
 822             if (tree.moduleNames != null) {
 823                 Set&lt;ModuleSymbol&gt; to = new LinkedHashSet&lt;&gt;();
 824                 for (JCExpression n: tree.moduleNames) {
 825                     ModuleSymbol msym = lookupModule(n);
 826                     chk.checkModuleExists(n.pos(), msym);
 827                     for (ExportsDirective d : exportsForPackage) {
 828                         checkDuplicateExportsToModule(n, msym, d);
 829                     }
 830                     if (!to.add(msym)) {
 831                         reportExportsConflictToModule(n, msym);
 832                     }
 833                 }
 834                 toModules = List.from(to);
 835             }
 836 
 837             if (toModules == null || !toModules.isEmpty()) {
 838                 Set&lt;ExportsFlag&gt; flags = EnumSet.noneOf(ExportsFlag.class);
 839                 ExportsDirective d = new ExportsDirective(packge, toModules, flags);
 840                 sym.exports = sym.exports.prepend(d);
 841                 tree.directive = d;
 842 
 843                 allExports.put(packge, exportsForPackage.prepend(d));
 844             }
 845         }
 846 
 847         private void reportExportsConflict(JCExports tree, PackageSymbol packge) {
 848             log.error(tree.qualid.pos(), Errors.ConflictingExports(packge));
 849         }
 850 
 851         private void checkDuplicateExportsToModule(JCExpression name, ModuleSymbol msym,
 852                 ExportsDirective d) {
 853             if (d.modules != null) {
 854                 for (ModuleSymbol other : d.modules) {
 855                     if (msym == other) {
 856                         reportExportsConflictToModule(name, msym);
 857                     }
 858                 }
 859             }
 860         }
 861 
 862         private void reportExportsConflictToModule(JCExpression name, ModuleSymbol msym) {
 863             log.error(name.pos(), Errors.ConflictingExportsToModule(msym));
 864         }
 865 
 866         @Override
 867         public void visitOpens(JCOpens tree) {
 868             Name name = TreeInfo.fullName(tree.qualid);
 869             PackageSymbol packge = syms.enterPackage(sym, name);
 870             attr.setPackageSymbols(tree.qualid, packge);
 871 
 872             if (sym.flags.contains(ModuleFlags.OPEN)) {
 873                 log.error(tree.pos(), Errors.NoOpensUnlessStrong);
 874             }
 875             List&lt;OpensDirective&gt; opensForPackage = allOpens.computeIfAbsent(packge, p -&gt; List.nil());
 876             for (OpensDirective d : opensForPackage) {
 877                 reportOpensConflict(tree, packge);
 878             }
 879 
 880             List&lt;ModuleSymbol&gt; toModules = null;
 881             if (tree.moduleNames != null) {
 882                 Set&lt;ModuleSymbol&gt; to = new LinkedHashSet&lt;&gt;();
 883                 for (JCExpression n: tree.moduleNames) {
 884                     ModuleSymbol msym = lookupModule(n);
 885                     chk.checkModuleExists(n.pos(), msym);
 886                     for (OpensDirective d : opensForPackage) {
 887                         checkDuplicateOpensToModule(n, msym, d);
 888                     }
 889                     if (!to.add(msym)) {
 890                         reportOpensConflictToModule(n, msym);
 891                     }
 892                 }
 893                 toModules = List.from(to);
 894             }
 895 
 896             if (toModules == null || !toModules.isEmpty()) {
 897                 Set&lt;OpensFlag&gt; flags = EnumSet.noneOf(OpensFlag.class);
 898                 OpensDirective d = new OpensDirective(packge, toModules, flags);
 899                 sym.opens = sym.opens.prepend(d);
 900                 tree.directive = d;
 901 
 902                 allOpens.put(packge, opensForPackage.prepend(d));
 903             }
 904         }
 905 
 906         private void reportOpensConflict(JCOpens tree, PackageSymbol packge) {
 907             log.error(tree.qualid.pos(), Errors.ConflictingOpens(packge));
 908         }
 909 
 910         private void checkDuplicateOpensToModule(JCExpression name, ModuleSymbol msym,
 911                 OpensDirective d) {
 912             if (d.modules != null) {
 913                 for (ModuleSymbol other : d.modules) {
 914                     if (msym == other) {
 915                         reportOpensConflictToModule(name, msym);
 916                     }
 917                 }
 918             }
 919         }
 920 
 921         private void reportOpensConflictToModule(JCExpression name, ModuleSymbol msym) {
 922             log.error(name.pos(), Errors.ConflictingOpensToModule(msym));
 923         }
 924 
 925         @Override
 926         public void visitProvides(JCProvides tree) { }
 927 
 928         @Override
 929         public void visitUses(JCUses tree) { }
 930 
 931         private void ensureJavaBase() {
 932             if (sym.name == names.java_base)
 933                 return;
 934 
 935             for (RequiresDirective d: sym.requires) {
 936                 if (d.module.name == names.java_base)
 937                     return;
 938             }
 939 
 940             ModuleSymbol java_base = syms.enterModule(names.java_base);
 941             Directive.RequiresDirective d =
 942                     new Directive.RequiresDirective(java_base,
 943                             EnumSet.of(Directive.RequiresFlag.MANDATED));
 944             sym.requires = sym.requires.prepend(d);
 945         }
 946 
 947         private ModuleSymbol lookupModule(JCExpression moduleName) {
 948             Name name = TreeInfo.fullName(moduleName);
 949             ModuleSymbol msym = moduleFinder.findModule(name);
 950             TreeInfo.setSymbol(moduleName, msym);
 951             return msym;
 952         }
 953     }
 954 
 955     public Completer getUsesProvidesCompleter() {
 956         return sym -&gt; {
 957             ModuleSymbol msym = (ModuleSymbol) sym;
 958 
 959             msym.complete();
 960 
 961             Env&lt;AttrContext&gt; env = typeEnvs.get(msym);
 962             UsesProvidesVisitor v = new UsesProvidesVisitor(msym, env);
 963             JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 964             JCModuleDecl decl = env.toplevel.getModuleDecl();
 965             DiagnosticPosition prevLintPos = deferredLintHandler.setPos(decl.pos());
 966 
 967             try {
 968                 decl.accept(v);
 969             } finally {
 970                 log.useSource(prev);
 971                 deferredLintHandler.setPos(prevLintPos);
 972             }
 973         };
 974     }
 975 
 976     class UsesProvidesVisitor extends JCTree.Visitor {
 977         private final ModuleSymbol msym;
 978         private final Env&lt;AttrContext&gt; env;
 979 
 980         private final Set&lt;ClassSymbol&gt; allUses = new HashSet&lt;&gt;();
 981         private final Map&lt;ClassSymbol, Set&lt;ClassSymbol&gt;&gt; allProvides = new HashMap&lt;&gt;();
 982 
 983         public UsesProvidesVisitor(ModuleSymbol msym, Env&lt;AttrContext&gt; env) {
 984             this.msym = msym;
 985             this.env = env;
 986         }
 987 
 988         @Override @SuppressWarnings(&quot;unchecked&quot;)
 989         public void visitModuleDef(JCModuleDecl tree) {
 990             msym.directives = List.nil();
 991             msym.provides = List.nil();
 992             msym.uses = List.nil();
 993             tree.directives.forEach(t -&gt; t.accept(this));
 994             msym.directives = msym.directives.reverse();
 995             msym.provides = msym.provides.reverse();
 996             msym.uses = msym.uses.reverse();
 997 
 998             if (msym.requires.nonEmpty() &amp;&amp; msym.requires.head.flags.contains(RequiresFlag.MANDATED))
 999                 msym.directives = msym.directives.prepend(msym.requires.head);
1000 
1001             msym.directives = msym.directives.appendList(List.from(addReads.getOrDefault(msym, Collections.emptySet())));
1002 
1003             checkForCorrectness();
1004         }
1005 
1006         @Override
1007         public void visitExports(JCExports tree) {
1008             Iterable&lt;Symbol&gt; packageContent = tree.directive.packge.members().getSymbols();
1009             List&lt;JavaFileObject&gt; filesToCheck = List.nil();
1010             boolean packageNotEmpty = false;
1011             for (Symbol sym : packageContent) {
1012                 if (sym.kind != Kinds.Kind.TYP)
1013                     continue;
1014                 ClassSymbol csym = (ClassSymbol) sym;
1015                 if (sym.completer.isTerminal() ||
1016                     csym.classfile.getKind() == Kind.CLASS) {
1017                     packageNotEmpty = true;
1018                     filesToCheck = List.nil();
1019                     break;
1020                 }
1021                 if (csym.classfile.getKind() == Kind.SOURCE) {
1022                     filesToCheck = filesToCheck.prepend(csym.classfile);
1023                 }
1024             }
1025             for (JavaFileObject jfo : filesToCheck) {
1026                 if (findPackageInFile.findPackageNameOf(jfo) == tree.directive.packge.fullname) {
1027                     packageNotEmpty = true;
1028                     break;
1029                 }
1030             }
1031             if (!packageNotEmpty) {
1032                 log.error(tree.qualid.pos(), Errors.PackageEmptyOrNotFound(tree.directive.packge));
1033             }
1034             msym.directives = msym.directives.prepend(tree.directive);
1035         }
1036 
1037         @Override
1038         public void visitOpens(JCOpens tree) {
1039             chk.checkPackageExistsForOpens(tree.qualid, tree.directive.packge);
1040             msym.directives = msym.directives.prepend(tree.directive);
1041         }
1042 
1043         MethodSymbol noArgsConstructor(ClassSymbol tsym) {
1044             for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {
1045                 MethodSymbol mSym = (MethodSymbol)sym;
1046                 if (mSym.params().isEmpty()) {
1047                     return mSym;
1048                 }
1049             }
1050             return null;
1051         }
1052 
1053         MethodSymbol factoryMethod(ClassSymbol tsym) {
1054             for (Symbol sym : tsym.members().getSymbolsByName(names.provider, sym -&gt; sym.kind == MTH)) {
1055                 MethodSymbol mSym = (MethodSymbol)sym;
1056                 if (mSym.isStatic() &amp;&amp; (mSym.flags() &amp; Flags.PUBLIC) != 0 &amp;&amp; mSym.params().isEmpty()) {
1057                     return mSym;
1058                 }
1059             }
1060             return null;
1061         }
1062 
1063         Map&lt;Directive.ProvidesDirective, JCProvides&gt; directiveToTreeMap = new HashMap&lt;&gt;();
1064 
1065         @Override
1066         public void visitProvides(JCProvides tree) {
1067             Type st = attr.attribType(tree.serviceName, env, syms.objectType);
1068             ClassSymbol service = (ClassSymbol) st.tsym;
1069             if (allProvides.containsKey(service)) {
1070                 log.error(tree.serviceName.pos(), Errors.RepeatedProvidesForService(service));
1071             }
1072             ListBuffer&lt;ClassSymbol&gt; impls = new ListBuffer&lt;&gt;();
1073             for (JCExpression implName : tree.implNames) {
1074                 Type it;
1075                 boolean prevVisitingServiceImplementation = env.info.visitingServiceImplementation;
1076                 try {
1077                     env.info.visitingServiceImplementation = true;
1078                     it = attr.attribType(implName, env, syms.objectType);
1079                 } finally {
1080                     env.info.visitingServiceImplementation = prevVisitingServiceImplementation;
1081                 }
1082                 ClassSymbol impl = (ClassSymbol) it.tsym;
1083                 if ((impl.flags_field &amp; PUBLIC) == 0) {
1084                     log.error(implName.pos(), Errors.NotDefPublic(impl, impl.location()));
1085                 }
1086                 //find provider factory:
1087                 MethodSymbol factory = factoryMethod(impl);
1088                 if (factory != null) {
1089                     Type returnType = factory.type.getReturnType();
1090                     if (!types.isSubtype(returnType, st)) {
1091                         log.error(implName.pos(), Errors.ServiceImplementationProviderReturnMustBeSubtypeOfServiceInterface);
1092                     }
1093                 } else {
1094                     if (!types.isSubtype(it, st)) {
1095                         log.error(implName.pos(), Errors.ServiceImplementationMustBeSubtypeOfServiceInterface);
1096                     } else if ((impl.flags() &amp; ABSTRACT) != 0) {
1097                         log.error(implName.pos(), Errors.ServiceImplementationIsAbstract(impl));
1098                     } else if (impl.isInner()) {
1099                         log.error(implName.pos(), Errors.ServiceImplementationIsInner(impl));
1100                     } else {
1101                         MethodSymbol constr = noArgsConstructor(impl);
1102                         if (constr == null) {
1103                             log.error(implName.pos(), Errors.ServiceImplementationDoesntHaveANoArgsConstructor(impl));
1104                         } else if ((constr.flags() &amp; PUBLIC) == 0) {
1105                             log.error(implName.pos(), Errors.ServiceImplementationNoArgsConstructorNotPublic(impl));
1106                         }
1107                     }
1108                 }
1109                 if (it.hasTag(CLASS)) {
1110                     if (allProvides.computeIfAbsent(service, s -&gt; new HashSet&lt;&gt;()).add(impl)) {
1111                         impls.append(impl);
1112                     } else {
1113                         log.error(implName.pos(), Errors.DuplicateProvides(service, impl));
1114                     }
1115                 }
1116             }
1117             if (st.hasTag(CLASS) &amp;&amp; !impls.isEmpty()) {
1118                 Directive.ProvidesDirective d = new Directive.ProvidesDirective(service, impls.toList());
1119                 msym.provides = msym.provides.prepend(d);
1120                 msym.directives = msym.directives.prepend(d);
1121                 directiveToTreeMap.put(d, tree);
1122             }
1123         }
1124 
1125         @Override
1126         public void visitRequires(JCRequires tree) {
1127             if (tree.directive != null &amp;&amp; allModules().contains(tree.directive.module)) {
1128                 chk.checkDeprecated(tree.moduleName.pos(), msym, tree.directive.module);
1129                 chk.checkModuleRequires(tree.moduleName.pos(), tree.directive);
1130                 msym.directives = msym.directives.prepend(tree.directive);
1131             }
1132         }
1133 
1134         @Override
1135         public void visitUses(JCUses tree) {
1136             Type st = attr.attribType(tree.qualid, env, syms.objectType);
1137             Symbol sym = TreeInfo.symbol(tree.qualid);
1138             if ((sym.flags() &amp; ENUM) != 0) {
1139                 log.error(tree.qualid.pos(), Errors.ServiceDefinitionIsEnum(st.tsym));
1140             } else if (st.hasTag(CLASS)) {
1141                 ClassSymbol service = (ClassSymbol) st.tsym;
1142                 if (allUses.add(service)) {
1143                     Directive.UsesDirective d = new Directive.UsesDirective(service);
1144                     msym.uses = msym.uses.prepend(d);
1145                     msym.directives = msym.directives.prepend(d);
1146                 } else {
1147                     log.error(tree.pos(), Errors.DuplicateUses(service));
1148                 }
1149             }
1150         }
1151 
1152         private void checkForCorrectness() {
1153             for (Directive.ProvidesDirective provides : msym.provides) {
1154                 JCProvides tree = directiveToTreeMap.get(provides);
1155                 for (ClassSymbol impl : provides.impls) {
1156                     /* The implementation must be defined in the same module as the provides directive
1157                      * (else, error)
1158                      */
1159                     PackageSymbol implementationDefiningPackage = impl.packge();
1160                     if (implementationDefiningPackage.modle != msym) {
1161                         // TODO: should use tree for the implementation name, not the entire provides tree
1162                         // TODO: should improve error message to identify the implementation type
1163                         log.error(tree.pos(), Errors.ServiceImplementationNotInRightModule(implementationDefiningPackage.modle));
1164                     }
1165 
1166                     /* There is no inherent requirement that module that provides a service should actually
1167                      * use it itself. However, it is a pointless declaration if the service package is not
1168                      * exported and there is no uses for the service.
1169                      */
1170                     PackageSymbol interfaceDeclaringPackage = provides.service.packge();
1171                     boolean isInterfaceDeclaredInCurrentModule = interfaceDeclaringPackage.modle == msym;
1172                     boolean isInterfaceExportedFromAReadableModule =
1173                             msym.visiblePackages.get(interfaceDeclaringPackage.fullname) == interfaceDeclaringPackage;
1174                     if (isInterfaceDeclaredInCurrentModule &amp;&amp; !isInterfaceExportedFromAReadableModule) {
1175                         // ok the interface is declared in this module. Let&#39;s check if it&#39;s exported
1176                         boolean warn = true;
1177                         for (ExportsDirective export : msym.exports) {
1178                             if (interfaceDeclaringPackage == export.packge) {
1179                                 warn = false;
1180                                 break;
1181                             }
1182                         }
1183                         if (warn) {
1184                             for (UsesDirective uses : msym.uses) {
1185                                 if (provides.service == uses.service) {
1186                                     warn = false;
1187                                     break;
1188                                 }
1189                             }
1190                         }
1191                         if (warn) {
1192                             log.warning(tree.pos(), Warnings.ServiceProvidedButNotExportedOrUsed(provides.service));
1193                         }
1194                     }
1195                 }
1196             }
1197         }
1198     }
1199 
1200     private Set&lt;ModuleSymbol&gt; allModules;
1201 
1202     public Set&lt;ModuleSymbol&gt; allModules() {
1203         Assert.checkNonNull(allModules);
1204         return allModules;
1205     }
1206 
1207     private void setupAllModules() {
1208         Assert.checkNonNull(rootModules);
1209         Assert.checkNull(allModules);
1210 
1211         Set&lt;ModuleSymbol&gt; observable;
1212 
1213         if (limitModsOpt == null &amp;&amp; extraLimitMods.isEmpty()) {
1214             observable = null;
1215         } else {
1216             Set&lt;ModuleSymbol&gt; limitMods = new HashSet&lt;&gt;();
1217             if (limitModsOpt != null) {
1218                 for (String limit : limitModsOpt.split(&quot;,&quot;)) {
1219                     if (!isValidName(limit))
1220                         continue;
1221                     limitMods.add(syms.enterModule(names.fromString(limit)));
1222                 }
1223             }
1224             for (String limit : extraLimitMods) {
1225                 limitMods.add(syms.enterModule(names.fromString(limit)));
1226             }
1227             observable = computeTransitiveClosure(limitMods, rootModules, null);
1228             observable.addAll(rootModules);
1229             if (lintOptions) {
1230                 for (ModuleSymbol msym : limitMods) {
1231                     if (!observable.contains(msym)) {
1232                         log.warning(LintCategory.OPTIONS,
1233                                 Warnings.ModuleForOptionNotFound(Option.LIMIT_MODULES, msym));
1234                     }
1235                 }
1236             }
1237         }
1238 
1239         Predicate&lt;ModuleSymbol&gt; observablePred = sym -&gt;
1240              (observable == null) ? (moduleFinder.findModule(sym).kind != ERR) : observable.contains(sym);
1241         Predicate&lt;ModuleSymbol&gt; systemModulePred = sym -&gt; (sym.flags() &amp; Flags.SYSTEM_MODULE) != 0;
1242         Set&lt;ModuleSymbol&gt; enabledRoot = new LinkedHashSet&lt;&gt;();
1243 
1244         if (rootModules.contains(syms.unnamedModule)) {
1245             Predicate&lt;ModuleSymbol&gt; jdkModulePred;
1246             if (target.allApiModulesAreRoots()) {
1247                 jdkModulePred = sym -&gt; {
1248                     sym.complete();
1249                     return sym.exports.stream().anyMatch(e -&gt; e.modules == null);
1250                 };
1251             } else {
1252                 ModuleSymbol javaSE = syms.getModule(java_se);
1253                 if (javaSE != null &amp;&amp; (observable == null || observable.contains(javaSE))) {
1254                     jdkModulePred = sym -&gt; {
1255                         sym.complete();
1256                         return !sym.name.startsWith(java_)
1257                             &amp;&amp; sym.exports.stream().anyMatch(e -&gt; e.modules == null);
1258                     };
1259                     enabledRoot.add(javaSE);
1260                 } else {
1261                     jdkModulePred = sym -&gt; true;
1262                 }
1263             }
1264 
1265             Predicate&lt;ModuleSymbol&gt; noIncubatorPred = sym -&gt; {
1266                 sym.complete();
1267                 return !sym.resolutionFlags.contains(ModuleResolutionFlags.DO_NOT_RESOLVE_BY_DEFAULT);
1268             };
1269 
1270             for (ModuleSymbol sym : new HashSet&lt;&gt;(syms.getAllModules())) {
1271                 try {
1272                     if (systemModulePred.test(sym) &amp;&amp; observablePred.test(sym) &amp;&amp; jdkModulePred.test(sym) &amp;&amp; noIncubatorPred.test(sym)) {
1273                         enabledRoot.add(sym);
1274                     }
1275                 } catch (CompletionFailure ex) {
1276                     chk.completionError(null, ex);
1277                 }
1278             }
1279         }
1280 
1281         enabledRoot.addAll(rootModules);
1282 
1283         if (addModsOpt != null || !extraAddMods.isEmpty()) {
1284             Set&lt;String&gt; fullAddMods = new HashSet&lt;&gt;();
1285             fullAddMods.addAll(extraAddMods);
1286 
1287             if (addModsOpt != null) {
1288                 fullAddMods.addAll(Arrays.asList(addModsOpt.split(&quot;,&quot;)));
1289             }
1290 
1291             for (String added : fullAddMods) {
1292                 Stream&lt;ModuleSymbol&gt; modules;
1293                 switch (added) {
1294                     case ALL_SYSTEM:
1295                         modules = new HashSet&lt;&gt;(syms.getAllModules())
1296                                 .stream()
1297                                 .filter(systemModulePred.and(observablePred));
1298                         break;
1299                     case ALL_MODULE_PATH:
1300                         modules = new HashSet&lt;&gt;(syms.getAllModules())
1301                                 .stream()
1302                                 .filter(systemModulePred.negate().and(observablePred));
1303                         break;
1304                     default:
1305                         if (!isValidName(added))
1306                             continue;
1307                         modules = Stream.of(syms.enterModule(names.fromString(added)));
1308                         break;
1309                 }
1310                 modules.forEach(sym -&gt; {
1311                     enabledRoot.add(sym);
1312                     if (observable != null)
1313                         observable.add(sym);
1314                 });
1315             }
1316         }
1317 
1318         Set&lt;ModuleSymbol&gt; result = computeTransitiveClosure(enabledRoot, rootModules, observable);
1319 
1320         result.add(syms.unnamedModule);
1321 
1322         boolean hasAutomatic = result.stream().anyMatch(IS_AUTOMATIC);
1323 
1324         if (hasAutomatic) {
1325             syms.getAllModules()
1326                 .stream()
1327                 .filter(IS_AUTOMATIC)
1328                 .forEach(result::add);
1329         }
1330 
1331         String incubatingModules = result.stream()
1332                 .filter(msym -&gt; msym.resolutionFlags.contains(ModuleResolutionFlags.WARN_INCUBATING))
1333                 .map(msym -&gt; msym.name.toString())
1334                 .collect(Collectors.joining(&quot;,&quot;));
1335 
1336         if (!incubatingModules.isEmpty()) {
1337             log.warning(Warnings.IncubatingModules(incubatingModules));
1338         }
1339 
1340         allModules = result;
1341 
1342         //add module versions from options, if any:
1343         if (moduleVersionOpt != null) {
1344             Name version = names.fromString(moduleVersionOpt);
1345             rootModules.forEach(m -&gt; m.version = version);
1346         }
1347     }
1348     //where:
1349         private static final Predicate&lt;ModuleSymbol&gt; IS_AUTOMATIC =
1350                 m -&gt; (m.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0;
1351 
1352     public boolean isInModuleGraph(ModuleSymbol msym) {
1353         return allModules == null || allModules.contains(msym);
1354     }
1355 
1356     private Set&lt;ModuleSymbol&gt; computeTransitiveClosure(Set&lt;? extends ModuleSymbol&gt; base,
1357                                                        Set&lt;? extends ModuleSymbol&gt; rootModules,
1358                                                        Set&lt;ModuleSymbol&gt; observable) {
1359         List&lt;ModuleSymbol&gt; primaryTodo = List.nil();
1360         List&lt;ModuleSymbol&gt; secondaryTodo = List.nil();
1361 
1362         for (ModuleSymbol ms : base) {
1363             if (rootModules.contains(ms)) {
1364                 primaryTodo = primaryTodo.prepend(ms);
1365             } else {
1366                 secondaryTodo = secondaryTodo.prepend(ms);
1367             }
1368         }
1369 
1370         Set&lt;ModuleSymbol&gt; result = new LinkedHashSet&lt;&gt;();
1371         result.add(syms.java_base);
1372 
1373         while (primaryTodo.nonEmpty() || secondaryTodo.nonEmpty()) {
1374             try {
1375                 ModuleSymbol current;
1376                 boolean isPrimaryTodo;
1377                 if (primaryTodo.nonEmpty()) {
1378                     current = primaryTodo.head;
1379                     primaryTodo = primaryTodo.tail;
1380                     isPrimaryTodo = true;
1381                 } else {
1382                     current = secondaryTodo.head;
1383                     secondaryTodo = secondaryTodo.tail;
1384                     isPrimaryTodo = false;
1385                 }
1386                 if (observable != null &amp;&amp; !observable.contains(current))
1387                     continue;
1388                 if (!result.add(current) || current == syms.unnamedModule || ((current.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0))
1389                     continue;
1390                 current.complete();
1391                 if (current.kind == ERR &amp;&amp; (isPrimaryTodo || base.contains(current)) &amp;&amp; warnedMissing.add(current)) {
1392                     log.error(Errors.ModuleNotFound(current));
1393                 }
1394                 for (RequiresDirective rd : current.requires) {
1395                     if (rd.module == syms.java_base) continue;
1396                     if ((rd.isTransitive() &amp;&amp; isPrimaryTodo) || rootModules.contains(current)) {
1397                         primaryTodo = primaryTodo.prepend(rd.module);
1398                     } else {
1399                         secondaryTodo = secondaryTodo.prepend(rd.module);
1400                     }
1401                 }
1402             } catch (CompletionFailure ex) {
1403                 chk.completionError(null, ex);
1404             }
1405         }
1406 
1407         return result;
1408     }
1409 
1410     public ModuleSymbol getObservableModule(Name name) {
1411         ModuleSymbol mod = syms.getModule(name);
1412 
1413         if (allModules().contains(mod)) {
1414             return mod;
1415         }
1416 
1417         return null;
1418     }
1419 
1420     private Completer getUnnamedModuleCompleter() {
1421         moduleFinder.findAllModules();
1422         return new Symbol.Completer() {
1423             @Override
1424             public void complete(Symbol sym) throws CompletionFailure {
1425                 if (inInitModules) {
1426                     sym.completer = this;
1427                     return ;
1428                 }
1429                 ModuleSymbol msym = (ModuleSymbol) sym;
1430                 Set&lt;ModuleSymbol&gt; allModules = new HashSet&lt;&gt;(allModules());
1431                 allModules.remove(syms.unnamedModule);
1432                 for (ModuleSymbol m : allModules) {
1433                     m.complete();
1434                 }
1435                 initVisiblePackages(msym, allModules);
1436             }
1437 
1438             @Override
1439             public String toString() {
1440                 return &quot;unnamedModule Completer&quot;;
1441             }
1442         };
1443     }
1444 
1445     private final Map&lt;ModuleSymbol, Set&lt;ModuleSymbol&gt;&gt; requiresTransitiveCache = new HashMap&lt;&gt;();
1446 
1447     private void completeModule(ModuleSymbol msym) {
1448         if (inInitModules) {
1449             msym.completer = sym -&gt; completeModule(msym);
1450             return ;
1451         }
1452 
1453         if ((msym.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0) {
1454             completeAutomaticModule(msym);
1455         }
1456 
1457         Assert.checkNonNull(msym.requires);
1458 
1459         initAddReads();
1460 
1461         msym.requires = msym.requires.appendList(List.from(addReads.getOrDefault(msym, Collections.emptySet())));
1462 
1463         List&lt;RequiresDirective&gt; requires = msym.requires;
1464 
1465         while (requires.nonEmpty()) {
1466             if (!allModules().contains(requires.head.module)) {
1467                 Env&lt;AttrContext&gt; env = typeEnvs.get(msym);
1468                 if (env != null) {
1469                     JavaFileObject origSource = log.useSource(env.toplevel.sourcefile);
1470                     try {
1471                         log.error(/*XXX*/env.tree, Errors.ModuleNotFound(requires.head.module));
1472                     } finally {
1473                         log.useSource(origSource);
1474                     }
1475                 } else {
1476                     Assert.check((msym.flags() &amp; Flags.AUTOMATIC_MODULE) == 0);
1477                 }
1478                 msym.requires = List.filter(msym.requires, requires.head);
1479             }
1480             requires = requires.tail;
1481         }
1482 
1483         Set&lt;ModuleSymbol&gt; readable = new LinkedHashSet&lt;&gt;();
1484         Set&lt;ModuleSymbol&gt; requiresTransitive = new HashSet&lt;&gt;();
1485 
1486         for (RequiresDirective d : msym.requires) {
1487             d.module.complete();
1488             readable.add(d.module);
1489             Set&lt;ModuleSymbol&gt; s = retrieveRequiresTransitive(d.module);
1490             Assert.checkNonNull(s, () -&gt; &quot;no entry in cache for &quot; + d.module);
1491             readable.addAll(s);
1492             if (d.flags.contains(RequiresFlag.TRANSITIVE)) {
1493                 requiresTransitive.add(d.module);
1494                 requiresTransitive.addAll(s);
1495             }
1496         }
1497 
1498         requiresTransitiveCache.put(msym, requiresTransitive);
1499         initVisiblePackages(msym, readable);
1500         for (ExportsDirective d: msym.exports) {
1501             if (d.packge != null) {
1502                 d.packge.modle = msym;
1503             }
1504         }
1505     }
1506 
1507     private Set&lt;ModuleSymbol&gt; retrieveRequiresTransitive(ModuleSymbol msym) {
1508         Set&lt;ModuleSymbol&gt; requiresTransitive = requiresTransitiveCache.get(msym);
1509 
1510         if (requiresTransitive == null) {
1511             //the module graph may contain cycles involving automatic modules or --add-reads edges
1512             requiresTransitive = new HashSet&lt;&gt;();
1513 
1514             Set&lt;ModuleSymbol&gt; seen = new HashSet&lt;&gt;();
1515             List&lt;ModuleSymbol&gt; todo = List.of(msym);
1516 
1517             while (todo.nonEmpty()) {
1518                 ModuleSymbol current = todo.head;
1519                 todo = todo.tail;
1520                 if (!seen.add(current))
1521                     continue;
1522                 requiresTransitive.add(current);
1523                 current.complete();
1524                 Iterable&lt;? extends RequiresDirective&gt; requires;
1525                 if (current != syms.unnamedModule) {
1526                     Assert.checkNonNull(current.requires, () -&gt; current + &quot;.requires == null; &quot; + msym);
1527                     requires = current.requires;
1528                     for (RequiresDirective rd : requires) {
1529                         if (rd.isTransitive())
1530                             todo = todo.prepend(rd.module);
1531                     }
1532                 } else {
1533                     for (ModuleSymbol mod : allModules()) {
1534                         todo = todo.prepend(mod);
1535                     }
1536                 }
1537             }
1538 
1539             requiresTransitive.remove(msym);
1540         }
1541 
1542         return requiresTransitive;
1543     }
1544 
1545     private void initVisiblePackages(ModuleSymbol msym, Collection&lt;ModuleSymbol&gt; readable) {
1546         initAddExports();
1547 
1548         msym.visiblePackages = new LinkedHashMap&lt;&gt;();
1549         msym.readModules = new HashSet&lt;&gt;(readable);
1550 
1551         Map&lt;Name, ModuleSymbol&gt; seen = new HashMap&lt;&gt;();
1552 
1553         for (ModuleSymbol rm : readable) {
1554             if (rm == syms.unnamedModule)
1555                 continue;
1556             addVisiblePackages(msym, seen, rm, rm.exports);
1557         }
1558 
1559         addExports.forEach((exportsFrom, exports) -&gt; {
1560             if (msym.readModules.contains(exportsFrom)) {
1561                 addVisiblePackages(msym, seen, exportsFrom, exports);
1562             }
1563         });
1564     }
1565 
1566     private void addVisiblePackages(ModuleSymbol msym,
1567                                     Map&lt;Name, ModuleSymbol&gt; seenPackages,
1568                                     ModuleSymbol exportsFrom,
1569                                     Collection&lt;ExportsDirective&gt; exports) {
1570         for (ExportsDirective d : exports) {
1571             if (d.modules == null || d.modules.contains(msym)) {
1572                 Name packageName = d.packge.fullname;
1573                 ModuleSymbol previousModule = seenPackages.get(packageName);
1574 
1575                 if (previousModule != null &amp;&amp; previousModule != exportsFrom) {
1576                     Env&lt;AttrContext&gt; env = typeEnvs.get(msym);
1577                     JavaFileObject origSource = env != null ? log.useSource(env.toplevel.sourcefile)
1578                                                             : null;
1579                     DiagnosticPosition pos = env != null ? env.tree.pos() : null;
1580                     try {
1581                         if (msym.isUnnamed()) {
1582                             log.error(pos, Errors.PackageClashFromRequiresInUnnamed(packageName,
1583                                                                                     previousModule, exportsFrom));
1584                         } else {
1585                             log.error(pos, Errors.PackageClashFromRequires(msym, packageName,
1586                                                                            previousModule, exportsFrom));
1587                         }
1588                     } finally {
1589                         if (env != null)
1590                             log.useSource(origSource);
1591                     }
1592                     continue;
1593                 }
1594 
1595                 seenPackages.put(packageName, exportsFrom);
1596                 msym.visiblePackages.put(d.packge.fullname, d.packge);
1597             }
1598         }
1599     }
1600 
1601     private void initAddExports() {
1602         if (addExports != null)
1603             return;
1604 
1605         addExports = new LinkedHashMap&lt;&gt;();
1606         Set&lt;ModuleSymbol&gt; unknownModules = new HashSet&lt;&gt;();
1607 
1608         if (addExportsOpt == null)
1609             return;
1610 
1611         Pattern ep = Pattern.compile(&quot;([^/]+)/([^=]+)=(.*)&quot;);
1612         for (String s: addExportsOpt.split(&quot;\0+&quot;)) {
1613             if (s.isEmpty())
1614                 continue;
1615             Matcher em = ep.matcher(s);
1616             if (!em.matches()) {
1617                 continue;
1618             }
1619 
1620             // Terminology comes from
1621             //  --add-exports module/package=target,...
1622             // Compare to
1623             //  module module { exports package to target, ... }
1624             String moduleName = em.group(1);
1625             String packageName = em.group(2);
1626             String targetNames = em.group(3);
1627 
1628             if (!isValidName(moduleName))
1629                 continue;
1630 
1631             ModuleSymbol msym = syms.enterModule(names.fromString(moduleName));
1632             if (!isKnownModule(msym, unknownModules))
1633                 continue;
1634 
1635             if (!isValidName(packageName))
1636                 continue;
1637 
1638             if (!allowAccessIntoSystem &amp;&amp; (msym.flags() &amp; Flags.SYSTEM_MODULE) != 0) {
1639                 log.error(Errors.AddExportsWithRelease(msym));
1640                 continue;
1641             }
1642 
1643             PackageSymbol p = syms.enterPackage(msym, names.fromString(packageName));
1644             p.modle = msym;  // TODO: do we need this?
1645 
1646             List&lt;ModuleSymbol&gt; targetModules = List.nil();
1647             for (String toModule : targetNames.split(&quot;[ ,]+&quot;)) {
1648                 ModuleSymbol m;
1649                 if (toModule.equals(&quot;ALL-UNNAMED&quot;)) {
1650                     m = syms.unnamedModule;
1651                 } else {
1652                     if (!isValidName(toModule))
1653                         continue;
1654                     m = syms.enterModule(names.fromString(toModule));
1655                     if (!isKnownModule(m, unknownModules))
1656                         continue;
1657                 }
1658                 targetModules = targetModules.prepend(m);
1659             }
1660 
1661             Set&lt;ExportsDirective&gt; extra = addExports.computeIfAbsent(msym, _x -&gt; new LinkedHashSet&lt;&gt;());
1662             ExportsDirective d = new ExportsDirective(p, targetModules);
1663             extra.add(d);
1664         }
1665     }
1666 
1667     private boolean isKnownModule(ModuleSymbol msym, Set&lt;ModuleSymbol&gt; unknownModules) {
1668         if (allModules.contains(msym)) {
1669             return true;
1670         }
1671 
1672         if (!unknownModules.contains(msym)) {
1673             if (lintOptions) {
1674                 log.warning(LintCategory.OPTIONS,
1675                         Warnings.ModuleForOptionNotFound(Option.ADD_EXPORTS, msym));
1676             }
1677             unknownModules.add(msym);
1678         }
1679         return false;
1680     }
1681 
1682     private void initAddReads() {
1683         if (addReads != null)
1684             return;
1685 
1686         addReads = new LinkedHashMap&lt;&gt;();
1687 
1688         if (addReadsOpt == null)
1689             return;
1690 
1691         Pattern rp = Pattern.compile(&quot;([^=]+)=(.*)&quot;);
1692         for (String s : addReadsOpt.split(&quot;\0+&quot;)) {
1693             if (s.isEmpty())
1694                 continue;
1695             Matcher rm = rp.matcher(s);
1696             if (!rm.matches()) {
1697                 continue;
1698             }
1699 
1700             // Terminology comes from
1701             //  --add-reads source-module=target-module,...
1702             // Compare to
1703             //  module source-module { requires target-module; ... }
1704             String sourceName = rm.group(1);
1705             String targetNames = rm.group(2);
1706 
1707             if (!isValidName(sourceName))
1708                 continue;
1709 
1710             ModuleSymbol msym = syms.enterModule(names.fromString(sourceName));
1711             if (!allModules.contains(msym)) {
1712                 if (lintOptions) {
1713                     log.warning(Warnings.ModuleForOptionNotFound(Option.ADD_READS, msym));
1714                 }
1715                 continue;
1716             }
1717 
1718             if (!allowAccessIntoSystem &amp;&amp; (msym.flags() &amp; Flags.SYSTEM_MODULE) != 0) {
1719                 log.error(Errors.AddReadsWithRelease(msym));
1720                 continue;
1721             }
1722 
1723             for (String targetName : targetNames.split(&quot;[ ,]+&quot;, -1)) {
1724                 ModuleSymbol targetModule;
1725                 if (targetName.equals(&quot;ALL-UNNAMED&quot;)) {
1726                     targetModule = syms.unnamedModule;
1727                 } else {
1728                     if (!isValidName(targetName))
1729                         continue;
1730                     targetModule = syms.enterModule(names.fromString(targetName));
1731                     if (!allModules.contains(targetModule)) {
1732                         if (lintOptions) {
1733                             log.warning(LintCategory.OPTIONS, Warnings.ModuleForOptionNotFound(Option.ADD_READS, targetModule));
1734                         }
1735                         continue;
1736                     }
1737                 }
1738                 addReads.computeIfAbsent(msym, m -&gt; new HashSet&lt;&gt;())
1739                         .add(new RequiresDirective(targetModule, EnumSet.of(RequiresFlag.EXTRA)));
1740             }
1741         }
1742     }
1743 
1744     private void checkCyclicDependencies(JCModuleDecl mod) {
1745         for (JCDirective d : mod.directives) {
1746             JCRequires rd;
1747             if (!d.hasTag(Tag.REQUIRES) || (rd = (JCRequires) d).directive == null)
1748                 continue;
1749             Set&lt;ModuleSymbol&gt; nonSyntheticDeps = new HashSet&lt;&gt;();
1750             List&lt;ModuleSymbol&gt; queue = List.of(rd.directive.module);
1751             while (queue.nonEmpty()) {
1752                 ModuleSymbol current = queue.head;
1753                 queue = queue.tail;
1754                 if (!nonSyntheticDeps.add(current))
1755                     continue;
1756                 current.complete();
1757                 if ((current.flags() &amp; Flags.AUTOMATIC_MODULE) != 0)
1758                     continue;
1759                 Assert.checkNonNull(current.requires, current::toString);
1760                 for (RequiresDirective dep : current.requires) {
1761                     if (!dep.flags.contains(RequiresFlag.EXTRA))
1762                         queue = queue.prepend(dep.module);
1763                 }
1764             }
1765             if (nonSyntheticDeps.contains(mod.sym)) {
1766                 log.error(rd.moduleName.pos(), Errors.CyclicRequires(rd.directive.module));
1767             }
1768         }
1769     }
1770 
1771     private boolean isValidName(CharSequence name) {
1772         return SourceVersion.isName(name, Source.toSourceVersion(source));
1773     }
1774 
1775     // DEBUG
1776     private String toString(ModuleSymbol msym) {
1777         return msym.name + &quot;[&quot;
1778                 + &quot;kind:&quot; + msym.kind + &quot;;&quot;
1779                 + &quot;locn:&quot; + toString(msym.sourceLocation) + &quot;,&quot; + toString(msym.classLocation) + &quot;;&quot;
1780                 + &quot;info:&quot; + toString(msym.module_info.sourcefile) + &quot;,&quot;
1781                             + toString(msym.module_info.classfile) + &quot;,&quot;
1782                             + msym.module_info.completer
1783                 + &quot;]&quot;;
1784     }
1785 
1786     // DEBUG
1787     String toString(Location locn) {
1788         return (locn == null) ? &quot;--&quot; : locn.getName();
1789     }
1790 
1791     // DEBUG
1792     String toString(JavaFileObject fo) {
1793         return (fo == null) ? &quot;--&quot; : fo.getName();
1794     }
1795 
1796     public void newRound() {
1797         allModules = null;
1798         rootModules = null;
1799         defaultModule = null;
1800         warnedMissing.clear();
1801     }
1802 
1803     public interface PackageNameFinder {
1804         public Name findPackageNameOf(JavaFileObject jfo);
1805     }
1806 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
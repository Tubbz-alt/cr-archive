<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import java.io.*;
  29 import java.net.URI;
  30 import java.net.URISyntaxException;
  31 import java.nio.CharBuffer;
  32 import java.nio.file.ClosedFileSystemException;
  33 import java.util.Arrays;
  34 import java.util.EnumSet;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Map;
  38 import java.util.Set;
  39 import java.util.function.IntFunction;
  40 
  41 import javax.lang.model.element.Modifier;
  42 import javax.lang.model.element.NestingKind;
  43 import javax.tools.JavaFileManager;
  44 import javax.tools.JavaFileObject;
  45 
  46 import com.sun.tools.javac.code.Source.Feature;
  47 import com.sun.tools.javac.comp.Annotate;
  48 import com.sun.tools.javac.comp.Annotate.AnnotationTypeCompleter;
  49 import com.sun.tools.javac.code.*;
  50 import com.sun.tools.javac.code.Directive.*;
  51 import com.sun.tools.javac.code.Lint.LintCategory;
  52 import com.sun.tools.javac.code.Scope.WriteableScope;
  53 import com.sun.tools.javac.code.Symbol.*;
  54 import com.sun.tools.javac.code.Symtab;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  57 import com.sun.tools.javac.file.BaseFileManager;
  58 import com.sun.tools.javac.file.PathFileObject;
  59 import com.sun.tools.javac.jvm.ClassFile.Version;
  60 import com.sun.tools.javac.jvm.PoolConstant.NameAndType;
  61 import com.sun.tools.javac.main.Option;
  62 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  63 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  64 import com.sun.tools.javac.util.*;
  65 import com.sun.tools.javac.util.DefinedBy.Api;
  66 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  67 
  68 import static com.sun.tools.javac.code.Flags.*;
  69 import static com.sun.tools.javac.code.Kinds.Kind.*;
  70 
  71 import com.sun.tools.javac.code.Scope.LookupKind;
  72 
  73 import static com.sun.tools.javac.code.TypeTag.ARRAY;
  74 import static com.sun.tools.javac.code.TypeTag.CLASS;
  75 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  76 import static com.sun.tools.javac.jvm.ClassFile.*;
  77 import static com.sun.tools.javac.jvm.ClassFile.Version.*;
  78 
  79 import static com.sun.tools.javac.main.Option.PARAMETERS;
  80 
  81 /** This class provides operations to read a classfile into an internal
  82  *  representation. The internal representation is anchored in a
  83  *  ClassSymbol which contains in its scope symbol representations
  84  *  for all other definitions in the classfile. Top-level Classes themselves
  85  *  appear as members of the scopes of PackageSymbols.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 
<a name="2" id="anc2"></a>



 108     /** Switch: allow records
 109      */
 110     boolean allowRecords;
 111 
 112    /** Lint option: warn about classfile issues
 113      */
 114     boolean lintClassfile;
 115 
 116     /** Switch: preserve parameter names from the variable table.
 117      */
 118     public boolean saveParameterNames;
 119 
 120     /**
 121      * The currently selected profile.
 122      */
 123     public final Profile profile;
 124 
 125     /** The log to use for verbose output
 126      */
 127     final Log log;
 128 
 129     /** The symbol table. */
 130     Symtab syms;
 131 
 132     Types types;
 133 
 134     /** The name table. */
 135     final Names names;
 136 
 137     /** Access to files
 138      */
 139     private final JavaFileManager fileManager;
 140 
 141     /** Factory for diagnostics
 142      */
 143     JCDiagnostic.Factory diagFactory;
 144 
 145     DeferredCompletionFailureHandler dcfh;
 146 
 147     /**
 148      * Support for preview language features.
 149      */
 150     Preview preview;
 151 
 152     /** The current scope where type variables are entered.
 153      */
 154     protected WriteableScope typevars;
 155 
 156     private List&lt;InterimUsesDirective&gt; interimUses = List.nil();
 157     private List&lt;InterimProvidesDirective&gt; interimProvides = List.nil();
 158 
 159     /** The path name of the class file currently being read.
 160      */
 161     protected JavaFileObject currentClassFile = null;
 162 
 163     /** The class or method currently being read.
 164      */
 165     protected Symbol currentOwner = null;
 166 
 167     /** The module containing the class currently being read.
 168      */
 169     protected ModuleSymbol currentModule = null;
 170 
 171     /** The buffer containing the currently read class file.
 172      */
 173     ByteBuffer buf = new ByteBuffer(INITIAL_BUFFER_SIZE);
 174 
 175     /** The current input pointer.
 176      */
 177     protected int bp;
 178 
 179     /** The pool reader.
 180      */
 181     PoolReader poolReader;
 182 
 183     /** The major version number of the class file being read. */
 184     int majorVersion;
 185     /** The minor version number of the class file being read. */
 186     int minorVersion;
 187 
 188     /** A table to hold the constant pool indices for method parameter
 189      * names, as given in LocalVariableTable attributes.
 190      */
 191     int[] parameterNameIndices;
 192 
 193     /**
 194      * A table to hold annotations for method parameters.
 195      */
 196     ParameterAnnotations[] parameterAnnotations;
 197 
 198     /**
 199      * A holder for parameter annotations.
 200      */
 201     static class ParameterAnnotations {
 202         List&lt;CompoundAnnotationProxy&gt; proxies;
 203 
 204         void add(List&lt;CompoundAnnotationProxy&gt; newAnnotations) {
 205             if (proxies == null) {
 206                 proxies = newAnnotations;
 207             } else {
 208                 proxies = proxies.prependList(newAnnotations);
 209             }
 210         }
 211     }
 212 
 213     /**
 214      * Whether or not any parameter names have been found.
 215      */
 216     boolean haveParameterNameIndices;
 217 
 218     /** Set this to false every time we start reading a method
 219      * and are saving parameter names.  Set it to true when we see
 220      * MethodParameters, if it&#39;s set when we see a LocalVariableTable,
 221      * then we ignore the parameter names from the LVT.
 222      */
 223     boolean sawMethodParameters;
 224 
 225     /**
 226      * The set of attribute names for which warnings have been generated for the current class
 227      */
 228     Set&lt;Name&gt; warnedAttrs = new HashSet&lt;&gt;();
 229 
 230     /**
 231      * The prototype @Target Attribute.Compound if this class is an annotation annotated with
 232      * @Target
 233      */
 234     CompoundAnnotationProxy target;
 235 
 236     /**
 237      * The prototype @Repeatable Attribute.Compound if this class is an annotation annotated with
 238      * @Repeatable
 239      */
 240     CompoundAnnotationProxy repeatable;
 241 
 242     /** Get the ClassReader instance for this invocation. */
 243     public static ClassReader instance(Context context) {
 244         ClassReader instance = context.get(classReaderKey);
 245         if (instance == null)
 246             instance = new ClassReader(context);
 247         return instance;
 248     }
 249 
 250     /** Construct a new class reader. */
 251     protected ClassReader(Context context) {
 252         context.put(classReaderKey, this);
 253         annotate = Annotate.instance(context);
 254         names = Names.instance(context);
 255         syms = Symtab.instance(context);
 256         types = Types.instance(context);
 257         fileManager = context.get(JavaFileManager.class);
 258         if (fileManager == null)
 259             throw new AssertionError(&quot;FileManager initialization error&quot;);
 260         diagFactory = JCDiagnostic.Factory.instance(context);
 261         dcfh = DeferredCompletionFailureHandler.instance(context);
 262 
 263         log = Log.instance(context);
 264 
 265         Options options = Options.instance(context);
 266         verbose         = options.isSet(Option.VERBOSE);
 267 
 268         Source source = Source.instance(context);
 269         preview = Preview.instance(context);
 270         allowModules     = Feature.MODULES.allowedInSource(source);
 271         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 272                 Feature.RECORDS.allowedInSource(source);
<a name="3" id="anc3"></a>

 273 
 274         saveParameterNames = options.isSet(PARAMETERS);
 275 
 276         profile = Profile.instance(context);
 277 
 278         typevars = WriteableScope.create(syms.noSymbol);
 279 
 280         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 281 
 282         initAttributeReaders();
 283     }
 284 
 285     /** Add member to class unless it is synthetic.
 286      */
 287     private void enterMember(ClassSymbol c, Symbol sym) {
 288         // Synthetic members are not entered -- reason lost to history (optimization?).
 289         // Lambda methods must be entered because they may have inner classes (which reference them)
 290         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))
 291             c.members_field.enter(sym);
 292     }
 293 
 294 /************************************************************************
 295  * Error Diagnoses
 296  ***********************************************************************/
 297 
 298     public ClassFinder.BadClassFile badClassFile(String key, Object... args) {
 299         return new ClassFinder.BadClassFile (
 300             currentOwner.enclClass(),
 301             currentClassFile,
 302             diagFactory.fragment(key, args),
 303             diagFactory,
 304             dcfh);
 305     }
 306 
 307     public ClassFinder.BadEnclosingMethodAttr badEnclosingMethod(Symbol sym) {
 308         return new ClassFinder.BadEnclosingMethodAttr (
 309             currentOwner.enclClass(),
 310             currentClassFile,
 311             diagFactory.fragment(Fragments.BadEnclosingMethod(sym)),
 312             diagFactory,
 313             dcfh);
 314     }
 315 
 316 /************************************************************************
 317  * Buffer Access
 318  ***********************************************************************/
 319 
 320     /** Read a character.
 321      */
 322     char nextChar() {
 323         char res = buf.getChar(bp);
 324         bp += 2;
 325         return res;
 326     }
 327 
 328     /** Read a byte.
 329      */
 330     int nextByte() {
 331         return buf.getByte(bp++) &amp; 0xFF;
 332     }
 333 
 334     /** Read an integer.
 335      */
 336     int nextInt() {
 337         int res = buf.getInt(bp);
 338         bp += 4;
 339         return res;
 340     }
 341 
 342 /************************************************************************
 343  * Constant Pool Access
 344  ***********************************************************************/
 345 
 346     /** Read module_flags.
 347      */
 348     Set&lt;ModuleFlags&gt; readModuleFlags(int flags) {
 349         Set&lt;ModuleFlags&gt; set = EnumSet.noneOf(ModuleFlags.class);
 350         for (ModuleFlags f : ModuleFlags.values()) {
 351             if ((flags &amp; f.value) != 0)
 352                 set.add(f);
 353         }
 354         return set;
 355     }
 356 
 357     /** Read resolution_flags.
 358      */
 359     Set&lt;ModuleResolutionFlags&gt; readModuleResolutionFlags(int flags) {
 360         Set&lt;ModuleResolutionFlags&gt; set = EnumSet.noneOf(ModuleResolutionFlags.class);
 361         for (ModuleResolutionFlags f : ModuleResolutionFlags.values()) {
 362             if ((flags &amp; f.value) != 0)
 363                 set.add(f);
 364         }
 365         return set;
 366     }
 367 
 368     /** Read exports_flags.
 369      */
 370     Set&lt;ExportsFlag&gt; readExportsFlags(int flags) {
 371         Set&lt;ExportsFlag&gt; set = EnumSet.noneOf(ExportsFlag.class);
 372         for (ExportsFlag f: ExportsFlag.values()) {
 373             if ((flags &amp; f.value) != 0)
 374                 set.add(f);
 375         }
 376         return set;
 377     }
 378 
 379     /** Read opens_flags.
 380      */
 381     Set&lt;OpensFlag&gt; readOpensFlags(int flags) {
 382         Set&lt;OpensFlag&gt; set = EnumSet.noneOf(OpensFlag.class);
 383         for (OpensFlag f: OpensFlag.values()) {
 384             if ((flags &amp; f.value) != 0)
 385                 set.add(f);
 386         }
 387         return set;
 388     }
 389 
 390     /** Read requires_flags.
 391      */
 392     Set&lt;RequiresFlag&gt; readRequiresFlags(int flags) {
 393         Set&lt;RequiresFlag&gt; set = EnumSet.noneOf(RequiresFlag.class);
 394         for (RequiresFlag f: RequiresFlag.values()) {
 395             if ((flags &amp; f.value) != 0)
 396                 set.add(f);
 397         }
 398         return set;
 399     }
 400 
 401 /************************************************************************
 402  * Reading Types
 403  ***********************************************************************/
 404 
 405     /** The unread portion of the currently read type is
 406      *  signature[sigp..siglimit-1].
 407      */
 408     byte[] signature;
 409     int sigp;
 410     int siglimit;
 411     boolean sigEnterPhase = false;
 412 
 413     /** Convert signature to type, where signature is a byte array segment.
 414      */
 415     Type sigToType(byte[] sig, int offset, int len) {
 416         signature = sig;
 417         sigp = offset;
 418         siglimit = offset + len;
 419         return sigToType();
 420     }
 421 
 422     /** Convert signature to type, where signature is implicit.
 423      */
 424     Type sigToType() {
 425         switch ((char) signature[sigp]) {
 426         case &#39;T&#39;:
 427             sigp++;
 428             int start = sigp;
 429             while (signature[sigp] != &#39;;&#39;) sigp++;
 430             sigp++;
 431             return sigEnterPhase
 432                 ? Type.noType
 433                 : findTypeVar(names.fromUtf(signature, start, sigp - 1 - start));
 434         case &#39;+&#39;: {
 435             sigp++;
 436             Type t = sigToType();
 437             return new WildcardType(t, BoundKind.EXTENDS, syms.boundClass);
 438         }
 439         case &#39;*&#39;:
 440             sigp++;
 441             return new WildcardType(syms.objectType, BoundKind.UNBOUND,
 442                                     syms.boundClass);
 443         case &#39;-&#39;: {
 444             sigp++;
 445             Type t = sigToType();
 446             return new WildcardType(t, BoundKind.SUPER, syms.boundClass);
 447         }
 448         case &#39;B&#39;:
 449             sigp++;
 450             return syms.byteType;
 451         case &#39;C&#39;:
 452             sigp++;
 453             return syms.charType;
 454         case &#39;D&#39;:
 455             sigp++;
 456             return syms.doubleType;
 457         case &#39;F&#39;:
 458             sigp++;
 459             return syms.floatType;
 460         case &#39;I&#39;:
 461             sigp++;
 462             return syms.intType;
 463         case &#39;J&#39;:
 464             sigp++;
 465             return syms.longType;
 466         case &#39;L&#39;:
 467             {
 468                 // int oldsigp = sigp;
 469                 Type t = classSigToType();
 470                 if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;)
 471                     throw badClassFile(&quot;deprecated inner class signature syntax &quot; +
 472                                        &quot;(please recompile from source)&quot;);
 473                 /*
 474                 System.err.println(&quot; decoded &quot; +
 475                                    new String(signature, oldsigp, sigp-oldsigp) +
 476                                    &quot; =&gt; &quot; + t + &quot; outer &quot; + t.outer());
 477                 */
 478                 return t;
 479             }
 480         case &#39;S&#39;:
 481             sigp++;
 482             return syms.shortType;
 483         case &#39;V&#39;:
 484             sigp++;
 485             return syms.voidType;
 486         case &#39;Z&#39;:
 487             sigp++;
 488             return syms.booleanType;
 489         case &#39;[&#39;:
 490             sigp++;
 491             return new ArrayType(sigToType(), syms.arrayClass);
 492         case &#39;(&#39;:
 493             sigp++;
 494             List&lt;Type&gt; argtypes = sigToTypes(&#39;)&#39;);
 495             Type restype = sigToType();
 496             List&lt;Type&gt; thrown = List.nil();
 497             while (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;^&#39;) {
 498                 sigp++;
 499                 thrown = thrown.prepend(sigToType());
 500             }
 501             // if there is a typevar in the throws clause we should state it.
 502             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail) {
 503                 if (l.head.hasTag(TYPEVAR)) {
 504                     l.head.tsym.flags_field |= THROWS;
 505                 }
 506             }
 507             return new MethodType(argtypes,
 508                                   restype,
 509                                   thrown.reverse(),
 510                                   syms.methodClass);
 511         case &#39;&lt;&#39;:
 512             typevars = typevars.dup(currentOwner);
 513             Type poly = new ForAll(sigToTypeParams(), sigToType());
 514             typevars = typevars.leave();
 515             return poly;
 516         default:
 517             throw badClassFile(&quot;bad.signature&quot;,
 518                                Convert.utf2string(signature, sigp, 10));
 519         }
 520     }
 521 
 522     byte[] signatureBuffer = new byte[0];
 523     int sbp = 0;
 524     /** Convert class signature to type, where signature is implicit.
 525      */
 526     Type classSigToType() {
 527         if (signature[sigp] != &#39;L&#39;)
 528             throw badClassFile(&quot;bad.class.signature&quot;,
 529                                Convert.utf2string(signature, sigp, 10));
 530         sigp++;
 531         Type outer = Type.noType;
 532         int startSbp = sbp;
 533 
 534         while (true) {
 535             final byte c = signature[sigp++];
 536             switch (c) {
 537 
 538             case &#39;;&#39;: {         // end
 539                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 540                                                          startSbp,
 541                                                          sbp - startSbp));
 542 
 543                 try {
 544                     return (outer == Type.noType) ?
 545                             t.erasure(types) :
 546                         new ClassType(outer, List.nil(), t);
 547                 } finally {
 548                     sbp = startSbp;
 549                 }
 550             }
 551 
 552             case &#39;&lt;&#39;:           // generic arguments
 553                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 554                                                          startSbp,
 555                                                          sbp - startSbp));
 556                 outer = new ClassType(outer, sigToTypes(&#39;&gt;&#39;), t) {
 557                         boolean completed = false;
 558                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 559                         public Type getEnclosingType() {
 560                             if (!completed) {
 561                                 completed = true;
 562                                 tsym.complete();
 563                                 Type enclosingType = tsym.type.getEnclosingType();
 564                                 if (enclosingType != Type.noType) {
 565                                     List&lt;Type&gt; typeArgs =
 566                                         super.getEnclosingType().allparams();
 567                                     List&lt;Type&gt; typeParams =
 568                                         enclosingType.allparams();
 569                                     if (typeParams.length() != typeArgs.length()) {
 570                                         // no &quot;rare&quot; types
 571                                         super.setEnclosingType(types.erasure(enclosingType));
 572                                     } else {
 573                                         super.setEnclosingType(types.subst(enclosingType,
 574                                                                            typeParams,
 575                                                                            typeArgs));
 576                                     }
 577                                 } else {
 578                                     super.setEnclosingType(Type.noType);
 579                                 }
 580                             }
 581                             return super.getEnclosingType();
 582                         }
 583                         @Override
 584                         public void setEnclosingType(Type outer) {
 585                             throw new UnsupportedOperationException();
 586                         }
 587                     };
 588                 switch (signature[sigp++]) {
 589                 case &#39;;&#39;:
 590                     if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;) {
 591                         // support old-style GJC signatures
 592                         // The signature produced was
 593                         // Lfoo/Outer&lt;Lfoo/X;&gt;;.Lfoo/Outer$Inner&lt;Lfoo/Y;&gt;;
 594                         // rather than say
 595                         // Lfoo/Outer&lt;Lfoo/X;&gt;.Inner&lt;Lfoo/Y;&gt;;
 596                         // so we skip past &quot;.Lfoo/Outer$&quot;
 597                         sigp += (sbp - startSbp) + // &quot;foo/Outer&quot;
 598                             3;  // &quot;.L&quot; and &quot;$&quot;
 599                         signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 600                         break;
 601                     } else {
 602                         sbp = startSbp;
 603                         return outer;
 604                     }
 605                 case &#39;.&#39;:
 606                     signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 607                     break;
 608                 default:
 609                     throw new AssertionError(signature[sigp-1]);
 610                 }
 611                 continue;
 612 
 613             case &#39;.&#39;:
 614                 //we have seen an enclosing non-generic class
 615                 if (outer != Type.noType) {
 616                     t = enterClass(names.fromUtf(signatureBuffer,
 617                                                  startSbp,
 618                                                  sbp - startSbp));
 619                     outer = new ClassType(outer, List.nil(), t);
 620                 }
 621                 signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 622                 continue;
 623             case &#39;/&#39;:
 624                 signatureBuffer[sbp++] = (byte)&#39;.&#39;;
 625                 continue;
 626             default:
 627                 signatureBuffer[sbp++] = c;
 628                 continue;
 629             }
 630         }
 631     }
 632 
 633     /** Convert (implicit) signature to list of types
 634      *  until `terminator&#39; is encountered.
 635      */
 636     List&lt;Type&gt; sigToTypes(char terminator) {
 637         List&lt;Type&gt; head = List.of(null);
 638         List&lt;Type&gt; tail = head;
 639         while (signature[sigp] != terminator)
 640             tail = tail.setTail(List.of(sigToType()));
 641         sigp++;
 642         return head.tail;
 643     }
 644 
 645     /** Convert signature to type parameters, where signature is a byte
 646      *  array segment.
 647      */
 648     List&lt;Type&gt; sigToTypeParams(byte[] sig, int offset, int len) {
 649         signature = sig;
 650         sigp = offset;
 651         siglimit = offset + len;
 652         return sigToTypeParams();
 653     }
 654 
 655     /** Convert signature to type parameters, where signature is implicit.
 656      */
 657     List&lt;Type&gt; sigToTypeParams() {
 658         List&lt;Type&gt; tvars = List.nil();
 659         if (signature[sigp] == &#39;&lt;&#39;) {
 660             sigp++;
 661             int start = sigp;
 662             sigEnterPhase = true;
 663             while (signature[sigp] != &#39;&gt;&#39;)
 664                 tvars = tvars.prepend(sigToTypeParam());
 665             sigEnterPhase = false;
 666             sigp = start;
 667             while (signature[sigp] != &#39;&gt;&#39;)
 668                 sigToTypeParam();
 669             sigp++;
 670         }
 671         return tvars.reverse();
 672     }
 673 
 674     /** Convert (implicit) signature to type parameter.
 675      */
 676     Type sigToTypeParam() {
 677         int start = sigp;
 678         while (signature[sigp] != &#39;:&#39;) sigp++;
 679         Name name = names.fromUtf(signature, start, sigp - start);
 680         TypeVar tvar;
 681         if (sigEnterPhase) {
 682             tvar = new TypeVar(name, currentOwner, syms.botType);
 683             typevars.enter(tvar.tsym);
 684         } else {
 685             tvar = (TypeVar)findTypeVar(name);
 686         }
 687         List&lt;Type&gt; bounds = List.nil();
 688         boolean allInterfaces = false;
 689         if (signature[sigp] == &#39;:&#39; &amp;&amp; signature[sigp+1] == &#39;:&#39;) {
 690             sigp++;
 691             allInterfaces = true;
 692         }
 693         while (signature[sigp] == &#39;:&#39;) {
 694             sigp++;
 695             bounds = bounds.prepend(sigToType());
 696         }
 697         if (!sigEnterPhase) {
 698             types.setBounds(tvar, bounds.reverse(), allInterfaces);
 699         }
 700         return tvar;
 701     }
 702 
 703     /** Find type variable with given name in `typevars&#39; scope.
 704      */
 705     Type findTypeVar(Name name) {
 706         Symbol s = typevars.findFirst(name);
 707         if (s != null) {
 708             return s.type;
 709         } else {
 710             if (readingClassAttr) {
 711                 // While reading the class attribute, the supertypes
 712                 // might refer to a type variable from an enclosing element
 713                 // (method or class).
 714                 // If the type variable is defined in the enclosing class,
 715                 // we can actually find it in
 716                 // currentOwner.owner.type.getTypeArguments()
 717                 // However, until we have read the enclosing method attribute
 718                 // we don&#39;t know for sure if this owner is correct.  It could
 719                 // be a method and there is no way to tell before reading the
 720                 // enclosing method attribute.
 721                 TypeVar t = new TypeVar(name, currentOwner, syms.botType);
 722                 missingTypeVariables = missingTypeVariables.prepend(t);
 723                 // System.err.println(&quot;Missing type var &quot; + name);
 724                 return t;
 725             }
 726             throw badClassFile(&quot;undecl.type.var&quot;, name);
 727         }
 728     }
 729 
 730 /************************************************************************
 731  * Reading Attributes
 732  ***********************************************************************/
 733 
 734     protected enum AttributeKind { CLASS, MEMBER }
 735 
 736     protected abstract class AttributeReader {
 737         protected AttributeReader(Name name, ClassFile.Version version, Set&lt;AttributeKind&gt; kinds) {
 738             this.name = name;
 739             this.version = version;
 740             this.kinds = kinds;
 741         }
 742 
 743         protected boolean accepts(AttributeKind kind) {
 744             if (kinds.contains(kind)) {
 745                 if (majorVersion &gt; version.major || (majorVersion == version.major &amp;&amp; minorVersion &gt;= version.minor))
 746                     return true;
 747 
 748                 if (lintClassfile &amp;&amp; !warnedAttrs.contains(name)) {
 749                     JavaFileObject prev = log.useSource(currentClassFile);
 750                     try {
 751                         log.warning(LintCategory.CLASSFILE, (DiagnosticPosition) null,
 752                                     Warnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));
 753                     } finally {
 754                         log.useSource(prev);
 755                     }
 756                     warnedAttrs.add(name);
 757                 }
 758             }
 759             return false;
 760         }
 761 
 762         protected abstract void read(Symbol sym, int attrLen);
 763 
 764         protected final Name name;
 765         protected final ClassFile.Version version;
 766         protected final Set&lt;AttributeKind&gt; kinds;
 767     }
 768 
 769     protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
 770             EnumSet.of(AttributeKind.CLASS);
 771     protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
 772             EnumSet.of(AttributeKind.MEMBER);
 773     protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
 774             EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);
 775 
 776     protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
 777 
 778     private void initAttributeReaders() {
 779         AttributeReader[] readers = {
 780             // v45.3 attributes
 781 
 782             new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
 783                 protected void read(Symbol sym, int attrLen) {
 784                     if (saveParameterNames)
 785                         ((MethodSymbol)sym).code = readCode(sym);
 786                     else
 787                         bp = bp + attrLen;
 788                 }
 789             },
 790 
 791             new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
 792                 protected void read(Symbol sym, int attrLen) {
 793                     Object v = poolReader.getConstant(nextChar());
 794                     // Ignore ConstantValue attribute if field not final.
 795                     if ((sym.flags() &amp; FINAL) == 0) {
 796                         return;
 797                     }
 798                     VarSymbol var = (VarSymbol) sym;
 799                     switch (var.type.getTag()) {
 800                        case BOOLEAN:
 801                        case BYTE:
 802                        case CHAR:
 803                        case SHORT:
 804                        case INT:
 805                            checkType(var, Integer.class, v);
 806                            break;
 807                        case LONG:
 808                            checkType(var, Long.class, v);
 809                            break;
 810                        case FLOAT:
 811                            checkType(var, Float.class, v);
 812                            break;
 813                        case DOUBLE:
 814                            checkType(var, Double.class, v);
 815                            break;
 816                        case CLASS:
 817                            if (var.type.tsym == syms.stringType.tsym) {
 818                                checkType(var, String.class, v);
 819                            } else {
 820                                throw badClassFile(&quot;bad.constant.value.type&quot;, var.type);
 821                            }
 822                            break;
 823                        default:
 824                            // ignore ConstantValue attribute if type is not primitive or String
 825                            return;
 826                     }
 827                     if (v instanceof Integer &amp;&amp; !var.type.getTag().checkRange((Integer) v)) {
 828                         throw badClassFile(&quot;bad.constant.range&quot;, v, var, var.type);
 829                     }
 830                     var.setData(v);
 831                 }
 832 
 833                 void checkType(Symbol var, Class&lt;?&gt; clazz, Object value) {
 834                     if (!clazz.isInstance(value)) {
 835                         throw badClassFile(&quot;bad.constant.value&quot;, value, var, clazz.getSimpleName());
 836                     }
 837                 }
 838             },
 839 
 840             new AttributeReader(names.Deprecated, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 841                 protected void read(Symbol sym, int attrLen) {
 842                     Symbol s = sym.owner.kind == MDL ? sym.owner : sym;
 843 
 844                     s.flags_field |= DEPRECATED;
 845                 }
 846             },
 847 
 848             new AttributeReader(names.Exceptions, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 849                 protected void read(Symbol sym, int attrLen) {
 850                     int nexceptions = nextChar();
 851                     List&lt;Type&gt; thrown = List.nil();
 852                     for (int j = 0; j &lt; nexceptions; j++)
 853                         thrown = thrown.prepend(poolReader.getClass(nextChar()).type);
 854                     if (sym.type.getThrownTypes().isEmpty())
 855                         sym.type.asMethodType().thrown = thrown.reverse();
 856                 }
 857             },
 858 
 859             new AttributeReader(names.InnerClasses, V45_3, CLASS_ATTRIBUTE) {
 860                 protected void read(Symbol sym, int attrLen) {
 861                     ClassSymbol c = (ClassSymbol) sym;
 862                     if (currentModule.module_info == c) {
 863                         //prevent entering the classes too soon:
 864                         skipInnerClasses();
 865                     } else {
 866                         readInnerClasses(c);
 867                     }
 868                 }
 869             },
 870 
 871             new AttributeReader(names.LocalVariableTable, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 872                 protected void read(Symbol sym, int attrLen) {
 873                     int newbp = bp + attrLen;
 874                     if (saveParameterNames &amp;&amp; !sawMethodParameters) {
 875                         // Pick up parameter names from the variable table.
 876                         // Parameter names are not explicitly identified as such,
 877                         // but all parameter name entries in the LocalVariableTable
 878                         // have a start_pc of 0.  Therefore, we record the name
 879                         // indices of all slots with a start_pc of zero in the
 880                         // parameterNameIndices array.
 881                         // Note that this implicitly honors the JVMS spec that
 882                         // there may be more than one LocalVariableTable, and that
 883                         // there is no specified ordering for the entries.
 884                         int numEntries = nextChar();
 885                         for (int i = 0; i &lt; numEntries; i++) {
 886                             int start_pc = nextChar();
 887                             int length = nextChar();
 888                             int nameIndex = nextChar();
 889                             int sigIndex = nextChar();
 890                             int register = nextChar();
 891                             if (start_pc == 0) {
 892                                 // ensure array large enough
 893                                 if (register &gt;= parameterNameIndices.length) {
 894                                     int newSize =
 895                                             Math.max(register + 1, parameterNameIndices.length + 8);
 896                                     parameterNameIndices =
 897                                             Arrays.copyOf(parameterNameIndices, newSize);
 898                                 }
 899                                 parameterNameIndices[register] = nameIndex;
 900                                 haveParameterNameIndices = true;
 901                             }
 902                         }
 903                     }
 904                     bp = newbp;
 905                 }
 906             },
 907 
 908             new AttributeReader(names.SourceFile, V45_3, CLASS_ATTRIBUTE) {
 909                 protected void read(Symbol sym, int attrLen) {
 910                     ClassSymbol c = (ClassSymbol) sym;
 911                     Name n = poolReader.getName(nextChar());
 912                     c.sourcefile = new SourceFileObject(n);
 913                     // If the class is a toplevel class, originating from a Java source file,
 914                     // but the class name does not match the file name, then it is
 915                     // an auxiliary class.
 916                     String sn = n.toString();
 917                     if (c.owner.kind == PCK &amp;&amp;
 918                         sn.endsWith(&quot;.java&quot;) &amp;&amp;
 919                         !sn.equals(c.name.toString()+&quot;.java&quot;)) {
 920                         c.flags_field |= AUXILIARY;
 921                     }
 922                 }
 923             },
 924 
 925             new AttributeReader(names.Synthetic, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 926                 protected void read(Symbol sym, int attrLen) {
 927                     sym.flags_field |= SYNTHETIC;
 928                 }
 929             },
 930 
 931             // standard v49 attributes
 932 
 933             new AttributeReader(names.EnclosingMethod, V49, CLASS_ATTRIBUTE) {
 934                 protected void read(Symbol sym, int attrLen) {
 935                     int newbp = bp + attrLen;
 936                     readEnclosingMethodAttr(sym);
 937                     bp = newbp;
 938                 }
 939             },
 940 
 941             new AttributeReader(names.Signature, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 942                 protected void read(Symbol sym, int attrLen) {
 943                     if (sym.kind == TYP) {
 944                         ClassSymbol c = (ClassSymbol) sym;
 945                         readingClassAttr = true;
 946                         try {
 947                             ClassType ct1 = (ClassType)c.type;
 948                             Assert.check(c == currentOwner);
 949                             ct1.typarams_field = poolReader.getName(nextChar())
 950                                     .map(ClassReader.this::sigToTypeParams);
 951                             ct1.supertype_field = sigToType();
 952                             ListBuffer&lt;Type&gt; is = new ListBuffer&lt;&gt;();
 953                             while (sigp != siglimit) is.append(sigToType());
 954                             ct1.interfaces_field = is.toList();
 955                         } finally {
 956                             readingClassAttr = false;
 957                         }
 958                     } else {
 959                         List&lt;Type&gt; thrown = sym.type.getThrownTypes();
 960                         sym.type = poolReader.getType(nextChar());
 961                         //- System.err.println(&quot; # &quot; + sym.type);
 962                         if (sym.kind == MTH &amp;&amp; sym.type.getThrownTypes().isEmpty())
 963                             sym.type.asMethodType().thrown = thrown;
 964 
 965                     }
 966                 }
 967             },
 968 
 969             // v49 annotation attributes
 970 
 971             new AttributeReader(names.AnnotationDefault, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 972                 protected void read(Symbol sym, int attrLen) {
 973                     attachAnnotationDefault(sym);
 974                 }
 975             },
 976 
 977             new AttributeReader(names.RuntimeInvisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 978                 protected void read(Symbol sym, int attrLen) {
 979                     attachAnnotations(sym);
 980                 }
 981             },
 982 
 983             new AttributeReader(names.RuntimeInvisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 984                 protected void read(Symbol sym, int attrLen) {
 985                     readParameterAnnotations(sym);
 986                 }
 987             },
 988 
 989             new AttributeReader(names.RuntimeVisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 990                 protected void read(Symbol sym, int attrLen) {
 991                     attachAnnotations(sym);
 992                 }
 993             },
 994 
 995             new AttributeReader(names.RuntimeVisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 996                 protected void read(Symbol sym, int attrLen) {
 997                     readParameterAnnotations(sym);
 998                 }
 999             },
1000 
1001             // additional &quot;legacy&quot; v49 attributes, superseded by flags
1002 
1003             new AttributeReader(names.Annotation, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1004                 protected void read(Symbol sym, int attrLen) {
1005                     sym.flags_field |= ANNOTATION;
1006                 }
1007             },
1008 
1009             new AttributeReader(names.Bridge, V49, MEMBER_ATTRIBUTE) {
1010                 protected void read(Symbol sym, int attrLen) {
1011                     sym.flags_field |= BRIDGE;
1012                 }
1013             },
1014 
1015             new AttributeReader(names.Enum, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1016                 protected void read(Symbol sym, int attrLen) {
1017                     sym.flags_field |= ENUM;
1018                 }
1019             },
1020 
1021             new AttributeReader(names.Varargs, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1022                 protected void read(Symbol sym, int attrLen) {
1023                     sym.flags_field |= VARARGS;
1024                 }
1025             },
1026 
1027             new AttributeReader(names.RuntimeVisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1028                 protected void read(Symbol sym, int attrLen) {
1029                     attachTypeAnnotations(sym);
1030                 }
1031             },
1032 
1033             new AttributeReader(names.RuntimeInvisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1034                 protected void read(Symbol sym, int attrLen) {
1035                     attachTypeAnnotations(sym);
1036                 }
1037             },
1038 
1039             // The following attributes for a Code attribute are not currently handled
1040             // StackMapTable
1041             // SourceDebugExtension
1042             // LineNumberTable
1043             // LocalVariableTypeTable
1044 
1045             // standard v52 attributes
1046 
1047             new AttributeReader(names.MethodParameters, V52, MEMBER_ATTRIBUTE) {
1048                 protected void read(Symbol sym, int attrlen) {
1049                     int newbp = bp + attrlen;
1050                     if (saveParameterNames) {
1051                         sawMethodParameters = true;
1052                         int numEntries = nextByte();
1053                         parameterNameIndices = new int[numEntries];
1054                         haveParameterNameIndices = true;
1055                         int index = 0;
1056                         for (int i = 0; i &lt; numEntries; i++) {
1057                             int nameIndex = nextChar();
1058                             int flags = nextChar();
1059                             if ((flags &amp; (Flags.MANDATED | Flags.SYNTHETIC)) != 0) {
1060                                 continue;
1061                             }
1062                             parameterNameIndices[index++] = nameIndex;
1063                         }
1064                     }
1065                     bp = newbp;
1066                 }
1067             },
1068 
1069             // standard v53 attributes
1070 
1071             new AttributeReader(names.Module, V53, CLASS_ATTRIBUTE) {
1072                 @Override
1073                 protected boolean accepts(AttributeKind kind) {
1074                     return super.accepts(kind) &amp;&amp; allowModules;
1075                 }
1076                 protected void read(Symbol sym, int attrLen) {
1077                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1078                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1079                         ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
1080 
1081                         Name moduleName = poolReader.peekModuleName(nextChar(), names::fromUtf);
1082                         if (currentModule.name != moduleName) {
1083                             throw badClassFile(&quot;module.name.mismatch&quot;, moduleName, currentModule.name);
1084                         }
1085 
1086                         Set&lt;ModuleFlags&gt; moduleFlags = readModuleFlags(nextChar());
1087                         msym.flags.addAll(moduleFlags);
1088                         msym.version = optPoolEntry(nextChar(), poolReader::getName, null);
1089 
1090                         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
1091                         int nrequires = nextChar();
1092                         for (int i = 0; i &lt; nrequires; i++) {
1093                             ModuleSymbol rsym = poolReader.getModule(nextChar());
1094                             Set&lt;RequiresFlag&gt; flags = readRequiresFlags(nextChar());
1095                             if (rsym == syms.java_base &amp;&amp; majorVersion &gt;= V54.major) {
1096                                 if (flags.contains(RequiresFlag.TRANSITIVE)) {
1097                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.TRANSITIVE);
1098                                 }
1099                                 if (flags.contains(RequiresFlag.STATIC_PHASE)) {
1100                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.STATIC_PHASE);
1101                                 }
1102                             }
1103                             nextChar(); // skip compiled version
1104                             requires.add(new RequiresDirective(rsym, flags));
1105                         }
1106                         msym.requires = requires.toList();
1107                         directives.addAll(msym.requires);
1108 
1109                         ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
1110                         int nexports = nextChar();
1111                         for (int i = 0; i &lt; nexports; i++) {
1112                             PackageSymbol p = poolReader.getPackage(nextChar());
1113                             Set&lt;ExportsFlag&gt; flags = readExportsFlags(nextChar());
1114                             int nto = nextChar();
1115                             List&lt;ModuleSymbol&gt; to;
1116                             if (nto == 0) {
1117                                 to = null;
1118                             } else {
1119                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1120                                 for (int t = 0; t &lt; nto; t++)
1121                                     lb.append(poolReader.getModule(nextChar()));
1122                                 to = lb.toList();
1123                             }
1124                             exports.add(new ExportsDirective(p, to, flags));
1125                         }
1126                         msym.exports = exports.toList();
1127                         directives.addAll(msym.exports);
1128                         ListBuffer&lt;OpensDirective&gt; opens = new ListBuffer&lt;&gt;();
1129                         int nopens = nextChar();
1130                         if (nopens != 0 &amp;&amp; msym.flags.contains(ModuleFlags.OPEN)) {
1131                             throw badClassFile(&quot;module.non.zero.opens&quot;, currentModule.name);
1132                         }
1133                         for (int i = 0; i &lt; nopens; i++) {
1134                             PackageSymbol p = poolReader.getPackage(nextChar());
1135                             Set&lt;OpensFlag&gt; flags = readOpensFlags(nextChar());
1136                             int nto = nextChar();
1137                             List&lt;ModuleSymbol&gt; to;
1138                             if (nto == 0) {
1139                                 to = null;
1140                             } else {
1141                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1142                                 for (int t = 0; t &lt; nto; t++)
1143                                     lb.append(poolReader.getModule(nextChar()));
1144                                 to = lb.toList();
1145                             }
1146                             opens.add(new OpensDirective(p, to, flags));
1147                         }
1148                         msym.opens = opens.toList();
1149                         directives.addAll(msym.opens);
1150 
1151                         msym.directives = directives.toList();
1152 
1153                         ListBuffer&lt;InterimUsesDirective&gt; uses = new ListBuffer&lt;&gt;();
1154                         int nuses = nextChar();
1155                         for (int i = 0; i &lt; nuses; i++) {
1156                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1157                             uses.add(new InterimUsesDirective(srvc));
1158                         }
1159                         interimUses = uses.toList();
1160 
1161                         ListBuffer&lt;InterimProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
1162                         int nprovides = nextChar();
1163                         for (int p = 0; p &lt; nprovides; p++) {
1164                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1165                             int nimpls = nextChar();
1166                             ListBuffer&lt;Name&gt; impls = new ListBuffer&lt;&gt;();
1167                             for (int i = 0; i &lt; nimpls; i++) {
1168                                 impls.append(poolReader.peekClassName(nextChar(), this::classNameMapper));
1169                             provides.add(new InterimProvidesDirective(srvc, impls.toList()));
1170                             }
1171                         }
1172                         interimProvides = provides.toList();
1173                     }
1174                 }
1175 
1176                 private Name classNameMapper(byte[] arr, int offset, int length) {
1177                     return names.fromUtf(ClassFile.internalize(arr, offset, length));
1178                 }
1179             },
1180 
1181             new AttributeReader(names.ModuleResolution, V53, CLASS_ATTRIBUTE) {
1182                 @Override
1183                 protected boolean accepts(AttributeKind kind) {
1184                     return super.accepts(kind) &amp;&amp; allowModules;
1185                 }
1186                 protected void read(Symbol sym, int attrLen) {
1187                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1188                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1189                         msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
1190                     }
1191                 }
1192             },
1193 
1194             new AttributeReader(names.Record, V58, CLASS_ATTRIBUTE) {
1195                 @Override
1196                 protected boolean accepts(AttributeKind kind) {
1197                     return super.accepts(kind) &amp;&amp; allowRecords;
1198                 }
1199                 protected void read(Symbol sym, int attrLen) {
1200                     if (sym.kind == TYP) {
1201                         sym.flags_field |= RECORD;
1202                     }
1203                     bp = bp + attrLen;
1204                 }
<a name="4" id="anc4"></a><span class="line-modified">1205             }</span>
















1206         };
1207 
1208         for (AttributeReader r: readers)
1209             attributeReaders.put(r.name, r);
1210     }
1211 
1212     protected void readEnclosingMethodAttr(Symbol sym) {
1213         // sym is a nested class with an &quot;Enclosing Method&quot; attribute
1214         // remove sym from it&#39;s current owners scope and place it in
1215         // the scope specified by the attribute
1216         sym.owner.members().remove(sym);
1217         ClassSymbol self = (ClassSymbol)sym;
1218         ClassSymbol c = poolReader.getClass(nextChar());
1219         NameAndType nt = optPoolEntry(nextChar(), poolReader::getNameAndType, null);
1220 
1221         if (c.members_field == null || c.kind != TYP)
1222             throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
1223 
1224         MethodSymbol m = findMethod(nt, c.members_field, self.flags());
1225         if (nt != null &amp;&amp; m == null)
1226             throw badEnclosingMethod(self);
1227 
1228         self.name = simpleBinaryName(self.flatname, c.flatname) ;
1229         self.owner = m != null ? m : c;
1230         if (self.name.isEmpty())
1231             self.fullname = names.empty;
1232         else
1233             self.fullname = ClassSymbol.formFullName(self.name, self.owner);
1234 
1235         if (m != null) {
1236             ((ClassType)sym.type).setEnclosingType(m.type);
1237         } else if ((self.flags_field &amp; STATIC) == 0) {
1238             ((ClassType)sym.type).setEnclosingType(c.type);
1239         } else {
1240             ((ClassType)sym.type).setEnclosingType(Type.noType);
1241         }
1242         enterTypevars(self, self.type);
1243         if (!missingTypeVariables.isEmpty()) {
1244             ListBuffer&lt;Type&gt; typeVars =  new ListBuffer&lt;&gt;();
1245             for (Type typevar : missingTypeVariables) {
1246                 typeVars.append(findTypeVar(typevar.tsym.name));
1247             }
1248             foundTypeVariables = typeVars.toList();
1249         } else {
1250             foundTypeVariables = List.nil();
1251         }
1252     }
1253 
1254     // See java.lang.Class
1255     private Name simpleBinaryName(Name self, Name enclosing) {
1256         if (!self.startsWith(enclosing)) {
1257             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1258         }
1259 
1260         String simpleBinaryName = self.toString().substring(enclosing.toString().length());
1261         if (simpleBinaryName.length() &lt; 1 || simpleBinaryName.charAt(0) != &#39;$&#39;)
1262             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1263         int index = 1;
1264         while (index &lt; simpleBinaryName.length() &amp;&amp;
1265                isAsciiDigit(simpleBinaryName.charAt(index)))
1266             index++;
1267         return names.fromString(simpleBinaryName.substring(index));
1268     }
1269 
1270     private MethodSymbol findMethod(NameAndType nt, Scope scope, long flags) {
1271         if (nt == null)
1272             return null;
1273 
1274         MethodType type = nt.type.asMethodType();
1275 
1276         for (Symbol sym : scope.getSymbolsByName(nt.name)) {
1277             if (sym.kind == MTH &amp;&amp; isSameBinaryType(sym.type.asMethodType(), type))
1278                 return (MethodSymbol)sym;
1279         }
1280 
1281         if (nt.name != names.init)
1282             // not a constructor
1283             return null;
1284         if ((flags &amp; INTERFACE) != 0)
1285             // no enclosing instance
1286             return null;
1287         if (nt.type.getParameterTypes().isEmpty())
1288             // no parameters
1289             return null;
1290 
1291         // A constructor of an inner class.
1292         // Remove the first argument (the enclosing instance)
1293         nt = new NameAndType(nt.name, new MethodType(nt.type.getParameterTypes().tail,
1294                                  nt.type.getReturnType(),
1295                                  nt.type.getThrownTypes(),
1296                                  syms.methodClass));
1297         // Try searching again
1298         return findMethod(nt, scope, flags);
1299     }
1300 
1301     /** Similar to Types.isSameType but avoids completion */
1302     private boolean isSameBinaryType(MethodType mt1, MethodType mt2) {
1303         List&lt;Type&gt; types1 = types.erasure(mt1.getParameterTypes())
1304             .prepend(types.erasure(mt1.getReturnType()));
1305         List&lt;Type&gt; types2 = mt2.getParameterTypes().prepend(mt2.getReturnType());
1306         while (!types1.isEmpty() &amp;&amp; !types2.isEmpty()) {
1307             if (types1.head.tsym != types2.head.tsym)
1308                 return false;
1309             types1 = types1.tail;
1310             types2 = types2.tail;
1311         }
1312         return types1.isEmpty() &amp;&amp; types2.isEmpty();
1313     }
1314 
1315     /**
1316      * Character.isDigit answers &lt;tt&gt;true&lt;/tt&gt; to some non-ascii
1317      * digits.  This one does not.  &lt;b&gt;copied from java.lang.Class&lt;/b&gt;
1318      */
1319     private static boolean isAsciiDigit(char c) {
1320         return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;;
1321     }
1322 
1323     /** Read member attributes.
1324      */
1325     void readMemberAttrs(Symbol sym) {
1326         readAttrs(sym, AttributeKind.MEMBER);
1327     }
1328 
1329     void readAttrs(Symbol sym, AttributeKind kind) {
1330         char ac = nextChar();
1331         for (int i = 0; i &lt; ac; i++) {
1332             Name attrName = poolReader.getName(nextChar());
1333             int attrLen = nextInt();
1334             AttributeReader r = attributeReaders.get(attrName);
1335             if (r != null &amp;&amp; r.accepts(kind))
1336                 r.read(sym, attrLen);
1337             else  {
1338                 bp = bp + attrLen;
1339             }
1340         }
1341     }
1342 
1343     private boolean readingClassAttr = false;
1344     private List&lt;Type&gt; missingTypeVariables = List.nil();
1345     private List&lt;Type&gt; foundTypeVariables = List.nil();
1346 
1347     /** Read class attributes.
1348      */
1349     void readClassAttrs(ClassSymbol c) {
1350         readAttrs(c, AttributeKind.CLASS);
1351     }
1352 
1353     /** Read code block.
1354      */
1355     Code readCode(Symbol owner) {
1356         nextChar(); // max_stack
1357         nextChar(); // max_locals
1358         final int  code_length = nextInt();
1359         bp += code_length;
1360         final char exception_table_length = nextChar();
1361         bp += exception_table_length * 8;
1362         readMemberAttrs(owner);
1363         return null;
1364     }
1365 
1366 /************************************************************************
1367  * Reading Java-language annotations
1368  ***********************************************************************/
1369 
1370     /**
1371      * Save annotations.
1372      */
1373     List&lt;CompoundAnnotationProxy&gt; readAnnotations() {
1374         int numAttributes = nextChar();
1375         ListBuffer&lt;CompoundAnnotationProxy&gt; annotations = new ListBuffer&lt;&gt;();
1376         for (int i = 0; i &lt; numAttributes; i++) {
1377             annotations.append(readCompoundAnnotation());
1378         }
1379         return annotations.toList();
1380     }
1381 
1382     /** Attach annotations.
1383      */
1384     void attachAnnotations(final Symbol sym) {
1385         attachAnnotations(sym, readAnnotations());
1386     }
1387 
1388     /**
1389      * Attach annotations.
1390      */
1391     void attachAnnotations(final Symbol sym, List&lt;CompoundAnnotationProxy&gt; annotations) {
1392         if (annotations.isEmpty()) {
1393             return;
1394         }
1395         ListBuffer&lt;CompoundAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1396         for (CompoundAnnotationProxy proxy : annotations) {
1397             if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName())
1398                 sym.flags_field |= PROPRIETARY;
1399             else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {
1400                 if (profile != Profile.DEFAULT) {
1401                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1402                         if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {
1403                             Attribute.Constant c = (Attribute.Constant)v.snd;
1404                             if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
1405                                 sym.flags_field |= NOT_IN_PROFILE;
1406                             }
1407                         }
1408                     }
1409                 }
1410             } else {
1411                 if (proxy.type.tsym == syms.annotationTargetType.tsym) {
1412                     target = proxy;
1413                 } else if (proxy.type.tsym == syms.repeatableType.tsym) {
1414                     repeatable = proxy;
1415                 } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
1416                     sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
1417                     setFlagIfAttributeTrue(proxy, sym, names.forRemoval, DEPRECATED_REMOVAL);
1418                 }  else if (proxy.type.tsym == syms.previewFeatureType.tsym) {
1419                     sym.flags_field |= PREVIEW_API;
1420                     setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1421                 }
1422                 proxies.append(proxy);
1423             }
1424         }
1425         annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
1426     }
1427     //where:
1428         private void setFlagIfAttributeTrue(CompoundAnnotationProxy proxy, Symbol sym, Name attribute, long flag) {
1429             for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1430                 if (v.fst == attribute &amp;&amp; v.snd instanceof Attribute.Constant) {
1431                     Attribute.Constant c = (Attribute.Constant)v.snd;
1432                     if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {
1433                         sym.flags_field |= flag;
1434                     }
1435                 }
1436             }
1437         }
1438 
1439     /** Read parameter annotations.
1440      */
1441     void readParameterAnnotations(Symbol meth) {
1442         int numParameters = buf.getByte(bp++) &amp; 0xFF;
1443         if (parameterAnnotations == null) {
1444             parameterAnnotations = new ParameterAnnotations[numParameters];
1445         } else if (parameterAnnotations.length != numParameters) {
1446             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, meth);
1447         }
1448         for (int pnum = 0; pnum &lt; numParameters; pnum++) {
1449             if (parameterAnnotations[pnum] == null) {
1450                 parameterAnnotations[pnum] = new ParameterAnnotations();
1451             }
1452             parameterAnnotations[pnum].add(readAnnotations());
1453         }
1454     }
1455 
1456     void attachTypeAnnotations(final Symbol sym) {
1457         int numAttributes = nextChar();
1458         if (numAttributes != 0) {
1459             ListBuffer&lt;TypeAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1460             for (int i = 0; i &lt; numAttributes; i++)
1461                 proxies.append(readTypeAnnotation());
1462             annotate.normal(new TypeAnnotationCompleter(sym, proxies.toList()));
1463         }
1464     }
1465 
1466     /** Attach the default value for an annotation element.
1467      */
1468     void attachAnnotationDefault(final Symbol sym) {
1469         final MethodSymbol meth = (MethodSymbol)sym; // only on methods
1470         final Attribute value = readAttributeValue();
1471 
1472         // The default value is set later during annotation. It might
1473         // be the case that the Symbol sym is annotated _after_ the
1474         // repeating instances that depend on this default value,
1475         // because of this we set an interim value that tells us this
1476         // element (most likely) has a default.
1477         //
1478         // Set interim value for now, reset just before we do this
1479         // properly at annotate time.
1480         meth.defaultValue = value;
1481         annotate.normal(new AnnotationDefaultCompleter(meth, value));
1482     }
1483 
1484     Type readTypeOrClassSymbol(int i) {
1485         // support preliminary jsr175-format class files
1486         if (poolReader.hasTag(i, CONSTANT_Class))
1487             return poolReader.getClass(i).type;
1488         return readTypeToProxy(i);
1489     }
1490     Type readTypeToProxy(int i) {
1491         if (currentModule.module_info == currentOwner) {
1492             return new ProxyType(i);
1493         } else {
1494             return poolReader.getType(i);
1495         }
1496     }
1497 
1498     CompoundAnnotationProxy readCompoundAnnotation() {
1499         Type t;
1500         if (currentModule.module_info == currentOwner) {
1501             int cpIndex = nextChar();
1502             t = new ProxyType(cpIndex);
1503         } else {
1504             t = readTypeOrClassSymbol(nextChar());
1505         }
1506         int numFields = nextChar();
1507         ListBuffer&lt;Pair&lt;Name,Attribute&gt;&gt; pairs = new ListBuffer&lt;&gt;();
1508         for (int i=0; i&lt;numFields; i++) {
1509             Name name = poolReader.getName(nextChar());
1510             Attribute value = readAttributeValue();
1511             pairs.append(new Pair&lt;&gt;(name, value));
1512         }
1513         return new CompoundAnnotationProxy(t, pairs.toList());
1514     }
1515 
1516     TypeAnnotationProxy readTypeAnnotation() {
1517         TypeAnnotationPosition position = readPosition();
1518         CompoundAnnotationProxy proxy = readCompoundAnnotation();
1519 
1520         return new TypeAnnotationProxy(proxy, position);
1521     }
1522 
1523     TypeAnnotationPosition readPosition() {
1524         int tag = nextByte(); // TargetType tag is a byte
1525 
1526         if (!TargetType.isValidTargetTypeValue(tag))
1527             throw badClassFile(&quot;bad.type.annotation.value&quot;, String.format(&quot;0x%02X&quot;, tag));
1528 
1529         TargetType type = TargetType.fromTargetTypeValue(tag);
1530 
1531         switch (type) {
1532         // instanceof
1533         case INSTANCEOF: {
1534             final int offset = nextChar();
1535             final TypeAnnotationPosition position =
1536                 TypeAnnotationPosition.instanceOf(readTypePath());
1537             position.offset = offset;
1538             return position;
1539         }
1540         // new expression
1541         case NEW: {
1542             final int offset = nextChar();
1543             final TypeAnnotationPosition position =
1544                 TypeAnnotationPosition.newObj(readTypePath());
1545             position.offset = offset;
1546             return position;
1547         }
1548         // constructor/method reference receiver
1549         case CONSTRUCTOR_REFERENCE: {
1550             final int offset = nextChar();
1551             final TypeAnnotationPosition position =
1552                 TypeAnnotationPosition.constructorRef(readTypePath());
1553             position.offset = offset;
1554             return position;
1555         }
1556         case METHOD_REFERENCE: {
1557             final int offset = nextChar();
1558             final TypeAnnotationPosition position =
1559                 TypeAnnotationPosition.methodRef(readTypePath());
1560             position.offset = offset;
1561             return position;
1562         }
1563         // local variable
1564         case LOCAL_VARIABLE: {
1565             final int table_length = nextChar();
1566             final int[] newLvarOffset = new int[table_length];
1567             final int[] newLvarLength = new int[table_length];
1568             final int[] newLvarIndex = new int[table_length];
1569 
1570             for (int i = 0; i &lt; table_length; ++i) {
1571                 newLvarOffset[i] = nextChar();
1572                 newLvarLength[i] = nextChar();
1573                 newLvarIndex[i] = nextChar();
1574             }
1575 
1576             final TypeAnnotationPosition position =
1577                     TypeAnnotationPosition.localVariable(readTypePath());
1578             position.lvarOffset = newLvarOffset;
1579             position.lvarLength = newLvarLength;
1580             position.lvarIndex = newLvarIndex;
1581             return position;
1582         }
1583         // resource variable
1584         case RESOURCE_VARIABLE: {
1585             final int table_length = nextChar();
1586             final int[] newLvarOffset = new int[table_length];
1587             final int[] newLvarLength = new int[table_length];
1588             final int[] newLvarIndex = new int[table_length];
1589 
1590             for (int i = 0; i &lt; table_length; ++i) {
1591                 newLvarOffset[i] = nextChar();
1592                 newLvarLength[i] = nextChar();
1593                 newLvarIndex[i] = nextChar();
1594             }
1595 
1596             final TypeAnnotationPosition position =
1597                     TypeAnnotationPosition.resourceVariable(readTypePath());
1598             position.lvarOffset = newLvarOffset;
1599             position.lvarLength = newLvarLength;
1600             position.lvarIndex = newLvarIndex;
1601             return position;
1602         }
1603         // exception parameter
1604         case EXCEPTION_PARAMETER: {
1605             final int exception_index = nextChar();
1606             final TypeAnnotationPosition position =
1607                 TypeAnnotationPosition.exceptionParameter(readTypePath());
1608             position.setExceptionIndex(exception_index);
1609             return position;
1610         }
1611         // method receiver
1612         case METHOD_RECEIVER:
1613             return TypeAnnotationPosition.methodReceiver(readTypePath());
1614         // type parameter
1615         case CLASS_TYPE_PARAMETER: {
1616             final int parameter_index = nextByte();
1617             return TypeAnnotationPosition
1618                 .typeParameter(readTypePath(), parameter_index);
1619         }
1620         case METHOD_TYPE_PARAMETER: {
1621             final int parameter_index = nextByte();
1622             return TypeAnnotationPosition
1623                 .methodTypeParameter(readTypePath(), parameter_index);
1624         }
1625         // type parameter bound
1626         case CLASS_TYPE_PARAMETER_BOUND: {
1627             final int parameter_index = nextByte();
1628             final int bound_index = nextByte();
1629             return TypeAnnotationPosition
1630                 .typeParameterBound(readTypePath(), parameter_index,
1631                                     bound_index);
1632         }
1633         case METHOD_TYPE_PARAMETER_BOUND: {
1634             final int parameter_index = nextByte();
1635             final int bound_index = nextByte();
1636             return TypeAnnotationPosition
1637                 .methodTypeParameterBound(readTypePath(), parameter_index,
1638                                           bound_index);
1639         }
1640         // class extends or implements clause
1641         case CLASS_EXTENDS: {
1642             final int type_index = nextChar();
1643             return TypeAnnotationPosition.classExtends(readTypePath(),
1644                                                        type_index);
1645         }
1646         // throws
1647         case THROWS: {
1648             final int type_index = nextChar();
1649             return TypeAnnotationPosition.methodThrows(readTypePath(),
1650                                                        type_index);
1651         }
1652         // method parameter
1653         case METHOD_FORMAL_PARAMETER: {
1654             final int parameter_index = nextByte();
1655             return TypeAnnotationPosition.methodParameter(readTypePath(),
1656                                                           parameter_index);
1657         }
1658         // type cast
1659         case CAST: {
1660             final int offset = nextChar();
1661             final int type_index = nextByte();
1662             final TypeAnnotationPosition position =
1663                 TypeAnnotationPosition.typeCast(readTypePath(), type_index);
1664             position.offset = offset;
1665             return position;
1666         }
1667         // method/constructor/reference type argument
1668         case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT: {
1669             final int offset = nextChar();
1670             final int type_index = nextByte();
1671             final TypeAnnotationPosition position = TypeAnnotationPosition
1672                 .constructorInvocationTypeArg(readTypePath(), type_index);
1673             position.offset = offset;
1674             return position;
1675         }
1676         case METHOD_INVOCATION_TYPE_ARGUMENT: {
1677             final int offset = nextChar();
1678             final int type_index = nextByte();
1679             final TypeAnnotationPosition position = TypeAnnotationPosition
1680                 .methodInvocationTypeArg(readTypePath(), type_index);
1681             position.offset = offset;
1682             return position;
1683         }
1684         case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT: {
1685             final int offset = nextChar();
1686             final int type_index = nextByte();
1687             final TypeAnnotationPosition position = TypeAnnotationPosition
1688                 .constructorRefTypeArg(readTypePath(), type_index);
1689             position.offset = offset;
1690             return position;
1691         }
1692         case METHOD_REFERENCE_TYPE_ARGUMENT: {
1693             final int offset = nextChar();
1694             final int type_index = nextByte();
1695             final TypeAnnotationPosition position = TypeAnnotationPosition
1696                 .methodRefTypeArg(readTypePath(), type_index);
1697             position.offset = offset;
1698             return position;
1699         }
1700         // We don&#39;t need to worry about these
1701         case METHOD_RETURN:
1702             return TypeAnnotationPosition.methodReturn(readTypePath());
1703         case FIELD:
1704             return TypeAnnotationPosition.field(readTypePath());
1705         case UNKNOWN:
1706             throw new AssertionError(&quot;jvm.ClassReader: UNKNOWN target type should never occur!&quot;);
1707         default:
1708             throw new AssertionError(&quot;jvm.ClassReader: Unknown target type for position: &quot; + type);
1709         }
1710     }
1711 
1712     List&lt;TypeAnnotationPosition.TypePathEntry&gt; readTypePath() {
1713         int len = nextByte();
1714         ListBuffer&lt;Integer&gt; loc = new ListBuffer&lt;&gt;();
1715         for (int i = 0; i &lt; len * TypeAnnotationPosition.TypePathEntry.bytesPerEntry; ++i)
1716             loc = loc.append(nextByte());
1717 
1718         return TypeAnnotationPosition.getTypePathFromBinary(loc.toList());
1719 
1720     }
1721 
1722     /**
1723      * Helper function to read an optional pool entry (with given function); this is used while parsing
1724      * InnerClasses and EnclosingMethod attributes, as well as when parsing supertype descriptor,
1725      * as per JVMS.
1726      */
1727     &lt;Z&gt; Z optPoolEntry(int index, IntFunction&lt;Z&gt; poolFunc, Z defaultValue) {
1728         return (index == 0) ?
1729                 defaultValue :
1730                 poolFunc.apply(index);
1731     }
1732 
1733     Attribute readAttributeValue() {
1734         char c = (char) buf.getByte(bp++);
1735         switch (c) {
1736         case &#39;B&#39;:
1737             return new Attribute.Constant(syms.byteType, poolReader.getConstant(nextChar()));
1738         case &#39;C&#39;:
1739             return new Attribute.Constant(syms.charType, poolReader.getConstant(nextChar()));
1740         case &#39;D&#39;:
1741             return new Attribute.Constant(syms.doubleType, poolReader.getConstant(nextChar()));
1742         case &#39;F&#39;:
1743             return new Attribute.Constant(syms.floatType, poolReader.getConstant(nextChar()));
1744         case &#39;I&#39;:
1745             return new Attribute.Constant(syms.intType, poolReader.getConstant(nextChar()));
1746         case &#39;J&#39;:
1747             return new Attribute.Constant(syms.longType, poolReader.getConstant(nextChar()));
1748         case &#39;S&#39;:
1749             return new Attribute.Constant(syms.shortType, poolReader.getConstant(nextChar()));
1750         case &#39;Z&#39;:
1751             return new Attribute.Constant(syms.booleanType, poolReader.getConstant(nextChar()));
1752         case &#39;s&#39;:
1753             return new Attribute.Constant(syms.stringType, poolReader.getName(nextChar()).toString());
1754         case &#39;e&#39;:
1755             return new EnumAttributeProxy(readTypeToProxy(nextChar()), poolReader.getName(nextChar()));
1756         case &#39;c&#39;:
1757             return new ClassAttributeProxy(readTypeOrClassSymbol(nextChar()));
1758         case &#39;[&#39;: {
1759             int n = nextChar();
1760             ListBuffer&lt;Attribute&gt; l = new ListBuffer&lt;&gt;();
1761             for (int i=0; i&lt;n; i++)
1762                 l.append(readAttributeValue());
1763             return new ArrayAttributeProxy(l.toList());
1764         }
1765         case &#39;@&#39;:
1766             return readCompoundAnnotation();
1767         default:
1768             throw new AssertionError(&quot;unknown annotation tag &#39;&quot; + c + &quot;&#39;&quot;);
1769         }
1770     }
1771 
1772     interface ProxyVisitor extends Attribute.Visitor {
1773         void visitEnumAttributeProxy(EnumAttributeProxy proxy);
1774         void visitClassAttributeProxy(ClassAttributeProxy proxy);
1775         void visitArrayAttributeProxy(ArrayAttributeProxy proxy);
1776         void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy);
1777     }
1778 
1779     static class EnumAttributeProxy extends Attribute {
1780         Type enumType;
1781         Name enumerator;
1782         public EnumAttributeProxy(Type enumType, Name enumerator) {
1783             super(null);
1784             this.enumType = enumType;
1785             this.enumerator = enumerator;
1786         }
1787         public void accept(Visitor v) { ((ProxyVisitor)v).visitEnumAttributeProxy(this); }
1788         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1789         public String toString() {
1790             return &quot;/*proxy enum*/&quot; + enumType + &quot;.&quot; + enumerator;
1791         }
1792     }
1793 
1794     static class ClassAttributeProxy extends Attribute {
1795         Type classType;
1796         public ClassAttributeProxy(Type classType) {
1797             super(null);
1798             this.classType = classType;
1799         }
1800         public void accept(Visitor v) { ((ProxyVisitor)v).visitClassAttributeProxy(this); }
1801         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1802         public String toString() {
1803             return &quot;/*proxy class*/&quot; + classType + &quot;.class&quot;;
1804         }
1805     }
1806 
1807     static class ArrayAttributeProxy extends Attribute {
1808         List&lt;Attribute&gt; values;
1809         ArrayAttributeProxy(List&lt;Attribute&gt; values) {
1810             super(null);
1811             this.values = values;
1812         }
1813         public void accept(Visitor v) { ((ProxyVisitor)v).visitArrayAttributeProxy(this); }
1814         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1815         public String toString() {
1816             return &quot;{&quot; + values + &quot;}&quot;;
1817         }
1818     }
1819 
1820     /** A temporary proxy representing a compound attribute.
1821      */
1822     static class CompoundAnnotationProxy extends Attribute {
1823         final List&lt;Pair&lt;Name,Attribute&gt;&gt; values;
1824         public CompoundAnnotationProxy(Type type,
1825                                       List&lt;Pair&lt;Name,Attribute&gt;&gt; values) {
1826             super(type);
1827             this.values = values;
1828         }
1829         public void accept(Visitor v) { ((ProxyVisitor)v).visitCompoundAnnotationProxy(this); }
1830         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1831         public String toString() {
1832             StringBuilder buf = new StringBuilder();
1833             buf.append(&quot;@&quot;);
1834             buf.append(type.tsym.getQualifiedName());
1835             buf.append(&quot;/*proxy*/{&quot;);
1836             boolean first = true;
1837             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; v = values;
1838                  v.nonEmpty(); v = v.tail) {
1839                 Pair&lt;Name,Attribute&gt; value = v.head;
1840                 if (!first) buf.append(&quot;,&quot;);
1841                 first = false;
1842                 buf.append(value.fst);
1843                 buf.append(&quot;=&quot;);
1844                 buf.append(value.snd);
1845             }
1846             buf.append(&quot;}&quot;);
1847             return buf.toString();
1848         }
1849     }
1850 
1851     /** A temporary proxy representing a type annotation.
1852      */
1853     static class TypeAnnotationProxy {
1854         final CompoundAnnotationProxy compound;
1855         final TypeAnnotationPosition position;
1856         public TypeAnnotationProxy(CompoundAnnotationProxy compound,
1857                 TypeAnnotationPosition position) {
1858             this.compound = compound;
1859             this.position = position;
1860         }
1861     }
1862 
1863     class AnnotationDeproxy implements ProxyVisitor {
1864         private ClassSymbol requestingOwner;
1865 
1866         AnnotationDeproxy(ClassSymbol owner) {
1867             this.requestingOwner = owner;
1868         }
1869 
1870         List&lt;Attribute.Compound&gt; deproxyCompoundList(List&lt;CompoundAnnotationProxy&gt; pl) {
1871             // also must fill in types!!!!
1872             ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();
1873             for (List&lt;CompoundAnnotationProxy&gt; l = pl; l.nonEmpty(); l=l.tail) {
1874                 buf.append(deproxyCompound(l.head));
1875             }
1876             return buf.toList();
1877         }
1878 
1879         Attribute.Compound deproxyCompound(CompoundAnnotationProxy a) {
1880             Type annotationType = resolvePossibleProxyType(a.type);
1881             ListBuffer&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; buf = new ListBuffer&lt;&gt;();
1882             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; l = a.values;
1883                  l.nonEmpty();
1884                  l = l.tail) {
1885                 MethodSymbol meth = findAccessMethod(annotationType, l.head.fst);
1886                 buf.append(new Pair&lt;&gt;(meth, deproxy(meth.type.getReturnType(), l.head.snd)));
1887             }
1888             return new Attribute.Compound(annotationType, buf.toList());
1889         }
1890 
1891         MethodSymbol findAccessMethod(Type container, Name name) {
1892             CompletionFailure failure = null;
1893             try {
1894                 for (Symbol sym : container.tsym.members().getSymbolsByName(name)) {
1895                     if (sym.kind == MTH &amp;&amp; sym.type.getParameterTypes().length() == 0)
1896                         return (MethodSymbol) sym;
1897                 }
1898             } catch (CompletionFailure ex) {
1899                 failure = ex;
1900             }
1901             // The method wasn&#39;t found: emit a warning and recover
1902             JavaFileObject prevSource = log.useSource(requestingOwner.classfile);
1903             try {
1904                 if (lintClassfile) {
1905                     if (failure == null) {
1906                         log.warning(Warnings.AnnotationMethodNotFound(container, name));
1907                     } else {
1908                         log.warning(Warnings.AnnotationMethodNotFoundReason(container,
1909                                                                             name,
1910                                                                             failure.getDetailValue()));//diagnostic, if present
1911                     }
1912                 }
1913             } finally {
1914                 log.useSource(prevSource);
1915             }
1916             // Construct a new method type and symbol.  Use bottom
1917             // type (typeof null) as return type because this type is
1918             // a subtype of all reference types and can be converted
1919             // to primitive types by unboxing.
1920             MethodType mt = new MethodType(List.nil(),
1921                                            syms.botType,
1922                                            List.nil(),
1923                                            syms.methodClass);
1924             return new MethodSymbol(PUBLIC | ABSTRACT, name, mt, container.tsym);
1925         }
1926 
1927         Attribute result;
1928         Type type;
1929         Attribute deproxy(Type t, Attribute a) {
1930             Type oldType = type;
1931             try {
1932                 type = t;
1933                 a.accept(this);
1934                 return result;
1935             } finally {
1936                 type = oldType;
1937             }
1938         }
1939 
1940         // implement Attribute.Visitor below
1941 
1942         public void visitConstant(Attribute.Constant value) {
1943             // assert value.type == type;
1944             result = value;
1945         }
1946 
1947         public void visitClass(Attribute.Class clazz) {
1948             result = clazz;
1949         }
1950 
1951         public void visitEnum(Attribute.Enum e) {
1952             throw new AssertionError(); // shouldn&#39;t happen
1953         }
1954 
1955         public void visitCompound(Attribute.Compound compound) {
1956             throw new AssertionError(); // shouldn&#39;t happen
1957         }
1958 
1959         public void visitArray(Attribute.Array array) {
1960             throw new AssertionError(); // shouldn&#39;t happen
1961         }
1962 
1963         public void visitError(Attribute.Error e) {
1964             throw new AssertionError(); // shouldn&#39;t happen
1965         }
1966 
1967         public void visitEnumAttributeProxy(EnumAttributeProxy proxy) {
1968             // type.tsym.flatName() should == proxy.enumFlatName
1969             Type enumType = resolvePossibleProxyType(proxy.enumType);
1970             TypeSymbol enumTypeSym = enumType.tsym;
1971             VarSymbol enumerator = null;
1972             CompletionFailure failure = null;
1973             try {
1974                 for (Symbol sym : enumTypeSym.members().getSymbolsByName(proxy.enumerator)) {
1975                     if (sym.kind == VAR) {
1976                         enumerator = (VarSymbol)sym;
1977                         break;
1978                     }
1979                 }
1980             }
1981             catch (CompletionFailure ex) {
1982                 failure = ex;
1983             }
1984             if (enumerator == null) {
1985                 if (failure != null) {
1986                     log.warning(Warnings.UnknownEnumConstantReason(currentClassFile,
1987                                                                    enumTypeSym,
1988                                                                    proxy.enumerator,
1989                                                                    failure.getDiagnostic()));
1990                 } else {
1991                     log.warning(Warnings.UnknownEnumConstant(currentClassFile,
1992                                                              enumTypeSym,
1993                                                              proxy.enumerator));
1994                 }
1995                 result = new Attribute.Enum(enumTypeSym.type,
1996                         new VarSymbol(0, proxy.enumerator, syms.botType, enumTypeSym));
1997             } else {
1998                 result = new Attribute.Enum(enumTypeSym.type, enumerator);
1999             }
2000         }
2001 
2002         @Override
2003         public void visitClassAttributeProxy(ClassAttributeProxy proxy) {
2004             Type classType = resolvePossibleProxyType(proxy.classType);
2005             result = new Attribute.Class(types, classType);
2006         }
2007 
2008         public void visitArrayAttributeProxy(ArrayAttributeProxy proxy) {
2009             int length = proxy.values.length();
2010             Attribute[] ats = new Attribute[length];
2011             Type elemtype = types.elemtype(type);
2012             int i = 0;
2013             for (List&lt;Attribute&gt; p = proxy.values; p.nonEmpty(); p = p.tail) {
2014                 ats[i++] = deproxy(elemtype, p.head);
2015             }
2016             result = new Attribute.Array(type, ats);
2017         }
2018 
2019         public void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy) {
2020             result = deproxyCompound(proxy);
2021         }
2022 
2023         Type resolvePossibleProxyType(Type t) {
2024             if (t instanceof ProxyType) {
2025                 Assert.check(requestingOwner.owner.kind == MDL);
2026                 ModuleSymbol prevCurrentModule = currentModule;
2027                 currentModule = (ModuleSymbol) requestingOwner.owner;
2028                 try {
2029                     return ((ProxyType) t).resolve();
2030                 } finally {
2031                     currentModule = prevCurrentModule;
2032                 }
2033             } else {
2034                 return t;
2035             }
2036         }
2037     }
2038 
2039     class AnnotationDefaultCompleter extends AnnotationDeproxy implements Runnable {
2040         final MethodSymbol sym;
2041         final Attribute value;
2042         final JavaFileObject classFile = currentClassFile;
2043 
2044         AnnotationDefaultCompleter(MethodSymbol sym, Attribute value) {
2045             super(currentOwner.kind == MTH
2046                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2047             this.sym = sym;
2048             this.value = value;
2049         }
2050 
2051         @Override
2052         public void run() {
2053             JavaFileObject previousClassFile = currentClassFile;
2054             try {
2055                 // Reset the interim value set earlier in
2056                 // attachAnnotationDefault().
2057                 sym.defaultValue = null;
2058                 currentClassFile = classFile;
2059                 sym.defaultValue = deproxy(sym.type.getReturnType(), value);
2060             } finally {
2061                 currentClassFile = previousClassFile;
2062             }
2063         }
2064 
2065         @Override
2066         public String toString() {
2067             return &quot; ClassReader store default for &quot; + sym.owner + &quot;.&quot; + sym + &quot; is &quot; + value;
2068         }
2069     }
2070 
2071     class AnnotationCompleter extends AnnotationDeproxy implements Runnable {
2072         final Symbol sym;
2073         final List&lt;CompoundAnnotationProxy&gt; l;
2074         final JavaFileObject classFile;
2075 
2076         AnnotationCompleter(Symbol sym, List&lt;CompoundAnnotationProxy&gt; l) {
2077             super(currentOwner.kind == MTH
2078                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2079             if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
2080                 this.sym = sym.owner;
2081             } else {
2082                 this.sym = sym;
2083             }
2084             this.l = l;
2085             this.classFile = currentClassFile;
2086         }
2087 
2088         @Override
2089         public void run() {
2090             JavaFileObject previousClassFile = currentClassFile;
2091             try {
2092                 currentClassFile = classFile;
2093                 List&lt;Attribute.Compound&gt; newList = deproxyCompoundList(l);
2094                 for (Attribute.Compound attr : newList) {
2095                     if (attr.type.tsym == syms.deprecatedType.tsym) {
2096                         sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
2097                         Attribute forRemoval = attr.member(names.forRemoval);
2098                         if (forRemoval instanceof Attribute.Constant) {
2099                             Attribute.Constant c = (Attribute.Constant) forRemoval;
2100                             if (c.type == syms.booleanType &amp;&amp; ((Integer) c.value) != 0) {
2101                                 sym.flags_field |= DEPRECATED_REMOVAL;
2102                             }
2103                         }
2104                     }
2105                 }
2106                 if (sym.annotationsPendingCompletion()) {
2107                     sym.setDeclarationAttributes(newList);
2108                 } else {
2109                     sym.appendAttributes(newList);
2110                 }
2111             } finally {
2112                 currentClassFile = previousClassFile;
2113             }
2114         }
2115 
2116         @Override
2117         public String toString() {
2118             return &quot; ClassReader annotate &quot; + sym.owner + &quot;.&quot; + sym + &quot; with &quot; + l;
2119         }
2120     }
2121 
2122     class TypeAnnotationCompleter extends AnnotationCompleter {
2123 
2124         List&lt;TypeAnnotationProxy&gt; proxies;
2125 
2126         TypeAnnotationCompleter(Symbol sym,
2127                 List&lt;TypeAnnotationProxy&gt; proxies) {
2128             super(sym, List.nil());
2129             this.proxies = proxies;
2130         }
2131 
2132         List&lt;Attribute.TypeCompound&gt; deproxyTypeCompoundList(List&lt;TypeAnnotationProxy&gt; proxies) {
2133             ListBuffer&lt;Attribute.TypeCompound&gt; buf = new ListBuffer&lt;&gt;();
2134             for (TypeAnnotationProxy proxy: proxies) {
2135                 Attribute.Compound compound = deproxyCompound(proxy.compound);
2136                 Attribute.TypeCompound typeCompound = new Attribute.TypeCompound(compound, proxy.position);
2137                 buf.add(typeCompound);
2138             }
2139             return buf.toList();
2140         }
2141 
2142         @Override
2143         public void run() {
2144             JavaFileObject previousClassFile = currentClassFile;
2145             try {
2146                 currentClassFile = classFile;
2147                 List&lt;Attribute.TypeCompound&gt; newList = deproxyTypeCompoundList(proxies);
2148                 sym.setTypeAttributes(newList.prependList(sym.getRawTypeAttributes()));
2149             } finally {
2150                 currentClassFile = previousClassFile;
2151             }
2152         }
2153     }
2154 
2155 
2156 /************************************************************************
2157  * Reading Symbols
2158  ***********************************************************************/
2159 
2160     /** Read a field.
2161      */
2162     VarSymbol readField() {
2163         long flags = adjustFieldFlags(nextChar());
2164         Name name = poolReader.getName(nextChar());
2165         Type type = poolReader.getType(nextChar());
2166         VarSymbol v = new VarSymbol(flags, name, type, currentOwner);
2167         readMemberAttrs(v);
2168         return v;
2169     }
2170 
2171     /** Read a method.
2172      */
2173     MethodSymbol readMethod() {
2174         long flags = adjustMethodFlags(nextChar());
2175         Name name = poolReader.getName(nextChar());
2176         Type type = poolReader.getType(nextChar());
2177         if (currentOwner.isInterface() &amp;&amp;
2178                 (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
2179             if (majorVersion &gt; Version.V52.major ||
2180                     (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
2181                 if ((flags &amp; (STATIC | PRIVATE)) == 0) {
2182                     currentOwner.flags_field |= DEFAULT;
2183                     flags |= DEFAULT | ABSTRACT;
2184                 }
2185             } else {
2186                 //protect against ill-formed classfiles
2187                 throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
2188                                    Integer.toString(majorVersion),
2189                                    Integer.toString(minorVersion));
2190             }
2191         }
2192         if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2193             // Sometimes anonymous classes don&#39;t have an outer
2194             // instance, however, there is no reliable way to tell so
2195             // we never strip this$n
2196             // ditto for local classes. Local classes that have an enclosing method set
2197             // won&#39;t pass the &quot;hasOuterInstance&quot; check above, but those that don&#39;t have an
2198             // enclosing method (i.e. from initializers) will pass that check.
2199             boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);
2200             if (!currentOwner.name.isEmpty() &amp;&amp; !local)
2201                 type = new MethodType(adjustMethodParams(flags, type.getParameterTypes()),
2202                                       type.getReturnType(),
2203                                       type.getThrownTypes(),
2204                                       syms.methodClass);
2205         }
2206         MethodSymbol m = new MethodSymbol(flags, name, type, currentOwner);
2207         if (types.isSignaturePolymorphic(m)) {
2208             m.flags_field |= SIGNATURE_POLYMORPHIC;
2209         }
2210         if (saveParameterNames)
2211             initParameterNames(m);
2212         Symbol prevOwner = currentOwner;
2213         currentOwner = m;
2214         try {
2215             readMemberAttrs(m);
2216         } finally {
2217             currentOwner = prevOwner;
2218         }
2219         setParameters(m, type);
2220 
2221         if ((flags &amp; VARARGS) != 0) {
2222             final Type last = type.getParameterTypes().last();
2223             if (last == null || !last.hasTag(ARRAY)) {
2224                 m.flags_field &amp;= ~VARARGS;
2225                 throw badClassFile(&quot;malformed.vararg.method&quot;, m);
2226             }
2227         }
2228 
2229         return m;
2230     }
2231 
2232     private List&lt;Type&gt; adjustMethodParams(long flags, List&lt;Type&gt; args) {
2233         if (args.isEmpty()) {
2234             return args;
2235         }
2236         boolean isVarargs = (flags &amp; VARARGS) != 0;
2237         if (isVarargs) {
2238             Type varargsElem = args.last();
2239             ListBuffer&lt;Type&gt; adjustedArgs = new ListBuffer&lt;&gt;();
2240             for (Type t : args) {
2241                 adjustedArgs.append(t != varargsElem ?
2242                     t :
2243                     ((ArrayType)t).makeVarargs());
2244             }
2245             args = adjustedArgs.toList();
2246         }
2247         return args.tail;
2248     }
2249 
2250     /**
2251      * Init the parameter names array.
2252      * Parameter names are currently inferred from the names in the
2253      * LocalVariableTable attributes of a Code attribute.
2254      * (Note: this means parameter names are currently not available for
2255      * methods without a Code attribute.)
2256      * This method initializes an array in which to store the name indexes
2257      * of parameter names found in LocalVariableTable attributes. It is
2258      * slightly supersized to allow for additional slots with a start_pc of 0.
2259      */
2260     void initParameterNames(MethodSymbol sym) {
2261         // make allowance for synthetic parameters.
2262         final int excessSlots = 4;
2263         int expectedParameterSlots =
2264                 Code.width(sym.type.getParameterTypes()) + excessSlots;
2265         if (parameterNameIndices == null
2266                 || parameterNameIndices.length &lt; expectedParameterSlots) {
2267             parameterNameIndices = new int[expectedParameterSlots];
2268         } else
2269             Arrays.fill(parameterNameIndices, 0);
2270         haveParameterNameIndices = false;
2271         sawMethodParameters = false;
2272     }
2273 
2274     /**
2275      * Set the parameters for a method symbol, including any names and
2276      * annotations that were read.
2277      *
2278      * &lt;p&gt;The type of the symbol may have changed while reading the
2279      * method attributes (see the Signature attribute). This may be
2280      * because of generic information or because anonymous synthetic
2281      * parameters were added.   The original type (as read from the
2282      * method descriptor) is used to help guess the existence of
2283      * anonymous synthetic parameters.
2284      */
2285     void setParameters(MethodSymbol sym, Type jvmType) {
2286         // If we get parameter names from MethodParameters, then we
2287         // don&#39;t need to skip.
2288         int firstParam = 0;
2289         if (!sawMethodParameters) {
2290             firstParam = ((sym.flags() &amp; STATIC) == 0) ? 1 : 0;
2291             // the code in readMethod may have skipped the first
2292             // parameter when setting up the MethodType. If so, we
2293             // make a corresponding allowance here for the position of
2294             // the first parameter.  Note that this assumes the
2295             // skipped parameter has a width of 1 -- i.e. it is not
2296             // a double width type (long or double.)
2297             if (sym.name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2298                 // Sometimes anonymous classes don&#39;t have an outer
2299                 // instance, however, there is no reliable way to tell so
2300                 // we never strip this$n
2301                 if (!currentOwner.name.isEmpty())
2302                     firstParam += 1;
2303             }
2304 
2305             if (sym.type != jvmType) {
2306                 // reading the method attributes has caused the
2307                 // symbol&#39;s type to be changed. (i.e. the Signature
2308                 // attribute.)  This may happen if there are hidden
2309                 // (synthetic) parameters in the descriptor, but not
2310                 // in the Signature.  The position of these hidden
2311                 // parameters is unspecified; for now, assume they are
2312                 // at the beginning, and so skip over them. The
2313                 // primary case for this is two hidden parameters
2314                 // passed into Enum constructors.
2315                 int skip = Code.width(jvmType.getParameterTypes())
2316                         - Code.width(sym.type.getParameterTypes());
2317                 firstParam += skip;
2318             }
2319         }
2320         Set&lt;Name&gt; paramNames = new HashSet&lt;&gt;();
2321         ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
2322         int nameIndex = firstParam;
2323         int annotationIndex = 0;
2324         for (Type t: sym.type.getParameterTypes()) {
2325             VarSymbol param = parameter(nameIndex, t, sym, paramNames);
2326             params.append(param);
2327             if (parameterAnnotations != null) {
2328                 ParameterAnnotations annotations = parameterAnnotations[annotationIndex];
2329                 if (annotations != null &amp;&amp; annotations.proxies != null
2330                         &amp;&amp; !annotations.proxies.isEmpty()) {
2331                     annotate.normal(new AnnotationCompleter(param, annotations.proxies));
2332                 }
2333             }
2334             nameIndex += sawMethodParameters ? 1 : Code.width(t);
2335             annotationIndex++;
2336         }
2337         if (parameterAnnotations != null &amp;&amp; parameterAnnotations.length != annotationIndex) {
2338             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, sym);
2339         }
2340         Assert.checkNull(sym.params);
2341         sym.params = params.toList();
2342         parameterAnnotations = null;
2343         parameterNameIndices = null;
2344     }
2345 
2346 
2347     // Returns the name for the parameter at position &#39;index&#39;, either using
2348     // names read from the MethodParameters, or by synthesizing a name that
2349     // is not on the &#39;exclude&#39; list.
2350     private VarSymbol parameter(int index, Type t, MethodSymbol owner, Set&lt;Name&gt; exclude) {
2351         long flags = PARAMETER;
2352         Name argName;
2353         if (parameterNameIndices != null &amp;&amp; index &lt; parameterNameIndices.length
2354                 &amp;&amp; parameterNameIndices[index] != 0) {
2355             argName = optPoolEntry(parameterNameIndices[index], poolReader::getName, names.empty);
2356             flags |= NAME_FILLED;
2357         } else {
2358             String prefix = &quot;arg&quot;;
2359             while (true) {
2360                 argName = names.fromString(prefix + exclude.size());
2361                 if (!exclude.contains(argName))
2362                     break;
2363                 prefix += &quot;$&quot;;
2364             }
2365         }
2366         exclude.add(argName);
2367         return new ParamSymbol(flags, argName, t, owner);
2368     }
2369 
2370     /**
2371      * skip n bytes
2372      */
2373     void skipBytes(int n) {
2374         bp = bp + n;
2375     }
2376 
2377     /** Skip a field or method
2378      */
2379     void skipMember() {
2380         bp = bp + 6;
2381         char ac = nextChar();
2382         for (int i = 0; i &lt; ac; i++) {
2383             bp = bp + 2;
2384             int attrLen = nextInt();
2385             bp = bp + attrLen;
2386         }
2387     }
2388 
2389     void skipInnerClasses() {
2390         int n = nextChar();
2391         for (int i = 0; i &lt; n; i++) {
2392             nextChar();
2393             nextChar();
2394             nextChar();
2395             nextChar();
2396         }
2397     }
2398 
2399     /** Enter type variables of this classtype and all enclosing ones in
2400      *  `typevars&#39;.
2401      */
2402     protected void enterTypevars(Symbol sym, Type t) {
2403         if (t.getEnclosingType() != null) {
2404             if (!t.getEnclosingType().hasTag(TypeTag.NONE)) {
2405                 enterTypevars(sym.owner, t.getEnclosingType());
2406             }
2407         } else if (sym.kind == MTH &amp;&amp; !sym.isStatic()) {
2408             enterTypevars(sym.owner, sym.owner.type);
2409         }
2410         for (List&lt;Type&gt; xs = t.getTypeArguments(); xs.nonEmpty(); xs = xs.tail) {
2411             typevars.enter(xs.head.tsym);
2412         }
2413     }
2414 
2415     protected ClassSymbol enterClass(Name name) {
2416         return syms.enterClass(currentModule, name);
2417     }
2418 
2419     protected ClassSymbol enterClass(Name name, TypeSymbol owner) {
2420         return syms.enterClass(currentModule, name, owner);
2421     }
2422 
2423     /** Read contents of a given class symbol `c&#39;. Both external and internal
2424      *  versions of an inner class are read.
2425      */
2426     void readClass(ClassSymbol c) {
2427         ClassType ct = (ClassType)c.type;
2428 
2429         // allocate scope for members
2430         c.members_field = WriteableScope.create(c);
2431 
2432         // prepare type variable table
2433         typevars = typevars.dup(currentOwner);
2434         if (ct.getEnclosingType().hasTag(CLASS))
2435             enterTypevars(c.owner, ct.getEnclosingType());
2436 
2437         // read flags, or skip if this is an inner class
2438         long f = nextChar();
2439         long flags = adjustClassFlags(f);
2440         if ((flags &amp; MODULE) == 0) {
2441             if (c.owner.kind == PCK || c.owner.kind == ERR) c.flags_field = flags;
2442             // read own class name and check that it matches
2443             currentModule = c.packge().modle;
2444             ClassSymbol self = poolReader.getClass(nextChar());
2445             if (c != self) {
2446                 throw badClassFile(&quot;class.file.wrong.class&quot;,
2447                                    self.flatname);
2448             }
2449         } else {
2450             if (majorVersion &lt; Version.V53.major) {
2451                 throw badClassFile(&quot;anachronistic.module.info&quot;,
2452                         Integer.toString(majorVersion),
2453                         Integer.toString(minorVersion));
2454             }
2455             c.flags_field = flags;
2456             currentModule = (ModuleSymbol) c.owner;
2457             int this_class = nextChar();
2458             // temp, no check on this_class
2459         }
2460 
2461         // class attributes must be read before class
2462         // skip ahead to read class attributes
2463         int startbp = bp;
2464         nextChar();
2465         char interfaceCount = nextChar();
2466         bp += interfaceCount * 2;
2467         char fieldCount = nextChar();
2468         for (int i = 0; i &lt; fieldCount; i++) skipMember();
2469         char methodCount = nextChar();
2470         for (int i = 0; i &lt; methodCount; i++) skipMember();
2471         readClassAttrs(c);
2472 
<a name="5" id="anc5"></a>



2473         // reset and read rest of classinfo
2474         bp = startbp;
2475         int n = nextChar();
2476         if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
2477             throw badClassFile(&quot;module.info.invalid.super.class&quot;);
2478         }
2479         if (ct.supertype_field == null)
2480             ct.supertype_field =
2481                     optPoolEntry(n, idx -&gt; poolReader.getClass(idx).erasure(types), Type.noType);
2482         n = nextChar();
2483         List&lt;Type&gt; is = List.nil();
2484         for (int i = 0; i &lt; n; i++) {
2485             Type _inter = poolReader.getClass(nextChar()).erasure(types);
2486             is = is.prepend(_inter);
2487         }
2488         if (ct.interfaces_field == null)
2489             ct.interfaces_field = is.reverse();
2490 
2491         Assert.check(fieldCount == nextChar());
2492         for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
2493         Assert.check(methodCount == nextChar());
2494         for (int i = 0; i &lt; methodCount; i++) enterMember(c, readMethod());
2495 
2496         typevars = typevars.leave();
2497     }
2498 
2499     /** Read inner class info. For each inner/outer pair allocate a
2500      *  member class.
2501      */
2502     void readInnerClasses(ClassSymbol c) {
2503         int n = nextChar();
2504         for (int i = 0; i &lt; n; i++) {
2505             nextChar(); // skip inner class symbol
2506             int outerIdx = nextChar();
2507             int nameIdx = nextChar();
2508             ClassSymbol outer = optPoolEntry(outerIdx, poolReader::getClass, null);
2509             Name name = optPoolEntry(nameIdx, poolReader::getName, names.empty);
2510             if (name == null) name = names.empty;
2511             long flags = adjustClassFlags(nextChar());
2512             if (outer != null) { // we have a member class
2513                 if (name == names.empty)
2514                     name = names.one;
2515                 ClassSymbol member = enterClass(name, outer);
2516                 if ((flags &amp; STATIC) == 0) {
2517                     ((ClassType)member.type).setEnclosingType(outer.type);
2518                     if (member.erasure_field != null)
2519                         ((ClassType)member.erasure_field).setEnclosingType(types.erasure(outer.type));
2520                 }
2521                 if (c == outer) {
2522                     member.flags_field = flags;
2523                     enterMember(c, member);
2524                 }
2525             }
2526         }
2527     }
2528 
2529     /** Read a class definition from the bytes in buf.
2530      */
2531     private void readClassBuffer(ClassSymbol c) throws IOException {
2532         int magic = nextInt();
2533         if (magic != JAVA_MAGIC)
2534             throw badClassFile(&quot;illegal.start.of.class.file&quot;);
2535 
2536         minorVersion = nextChar();
2537         majorVersion = nextChar();
2538         int maxMajor = Version.MAX().major;
2539         int maxMinor = Version.MAX().minor;
2540         if (majorVersion &gt; maxMajor ||
2541             majorVersion * 1000 + minorVersion &lt;
2542             Version.MIN().major * 1000 + Version.MIN().minor) {
2543             if (majorVersion == (maxMajor + 1))
2544                 log.warning(Warnings.BigMajorVersion(currentClassFile,
2545                                                      majorVersion,
2546                                                      maxMajor));
2547             else
2548                 throw badClassFile(&quot;wrong.version&quot;,
2549                                    Integer.toString(majorVersion),
2550                                    Integer.toString(minorVersion),
2551                                    Integer.toString(maxMajor),
2552                                    Integer.toString(maxMinor));
2553         }
2554 
2555         if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {
2556             if (!preview.isEnabled()) {
2557                 log.error(preview.disabledError(currentClassFile, majorVersion));
2558             } else {
2559                 preview.warnPreview(c.classfile, majorVersion);
2560             }
2561         }
2562 
2563         poolReader = new PoolReader(this, names, syms);
2564         bp = poolReader.readPool(buf, bp);
2565         if (signatureBuffer.length &lt; bp) {
2566             int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
2567             signatureBuffer = new byte[ns];
2568         }
2569         readClass(c);
2570     }
2571 
2572     public void readClassFile(ClassSymbol c) {
2573         currentOwner = c;
2574         currentClassFile = c.classfile;
2575         warnedAttrs.clear();
2576         filling = true;
2577         target = null;
2578         repeatable = null;
2579         try {
2580             bp = 0;
2581             buf.reset();
2582             buf.appendStream(c.classfile.openInputStream());
2583             readClassBuffer(c);
2584             if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
2585                 List&lt;Type&gt; missing = missingTypeVariables;
2586                 List&lt;Type&gt; found = foundTypeVariables;
2587                 missingTypeVariables = List.nil();
2588                 foundTypeVariables = List.nil();
2589                 interimUses = List.nil();
2590                 interimProvides = List.nil();
2591                 filling = false;
2592                 ClassType ct = (ClassType)currentOwner.type;
2593                 ct.supertype_field =
2594                     types.subst(ct.supertype_field, missing, found);
2595                 ct.interfaces_field =
2596                     types.subst(ct.interfaces_field, missing, found);
2597                 ct.typarams_field =
2598                     types.substBounds(ct.typarams_field, missing, found);
2599                 for (List&lt;Type&gt; types = ct.typarams_field; types.nonEmpty(); types = types.tail) {
2600                     types.head.tsym.type = types.head;
2601                 }
2602             } else if (missingTypeVariables.isEmpty() !=
2603                        foundTypeVariables.isEmpty()) {
2604                 Name name = missingTypeVariables.head.tsym.name;
2605                 throw badClassFile(&quot;undecl.type.var&quot;, name);
2606             }
2607 
2608             if ((c.flags_field &amp; Flags.ANNOTATION) != 0) {
2609                 c.setAnnotationTypeMetadata(new AnnotationTypeMetadata(c, new CompleterDeproxy(c, target, repeatable)));
2610             } else {
2611                 c.setAnnotationTypeMetadata(AnnotationTypeMetadata.notAnAnnotationType());
2612             }
2613 
2614             if (c == currentModule.module_info) {
2615                 if (interimUses.nonEmpty() || interimProvides.nonEmpty()) {
2616                     Assert.check(currentModule.isCompleted());
2617                     currentModule.usesProvidesCompleter =
2618                             new UsesProvidesCompleter(currentModule, interimUses, interimProvides);
2619                 } else {
2620                     currentModule.uses = List.nil();
2621                     currentModule.provides = List.nil();
2622                 }
2623             }
2624         } catch (IOException | ClosedFileSystemException ex) {
2625             throw badClassFile(&quot;unable.to.access.file&quot;, ex.toString());
2626         } catch (ArrayIndexOutOfBoundsException ex) {
2627             throw badClassFile(&quot;bad.class.file&quot;, c.flatname);
2628         } finally {
2629             interimUses = List.nil();
2630             interimProvides = List.nil();
2631             missingTypeVariables = List.nil();
2632             foundTypeVariables = List.nil();
2633             filling = false;
2634         }
2635     }
2636 
2637     /** We can only read a single class file at a time; this
2638      *  flag keeps track of when we are currently reading a class
2639      *  file.
2640      */
2641     public boolean filling = false;
2642 
2643 /************************************************************************
2644  * Adjusting flags
2645  ***********************************************************************/
2646 
2647     long adjustFieldFlags(long flags) {
2648         return flags;
2649     }
2650 
2651     long adjustMethodFlags(long flags) {
2652         if ((flags &amp; ACC_BRIDGE) != 0) {
2653             flags &amp;= ~ACC_BRIDGE;
2654             flags |= BRIDGE;
2655         }
2656         if ((flags &amp; ACC_VARARGS) != 0) {
2657             flags &amp;= ~ACC_VARARGS;
2658             flags |= VARARGS;
2659         }
2660         return flags;
2661     }
2662 
2663     long adjustClassFlags(long flags) {
2664         if ((flags &amp; ACC_MODULE) != 0) {
2665             flags &amp;= ~ACC_MODULE;
2666             flags |= MODULE;
2667         }
2668         return flags &amp; ~ACC_SUPER; // SUPER and SYNCHRONIZED bits overloaded
2669     }
2670 
2671     /**
2672      * A subclass of JavaFileObject for the sourcefile attribute found in a classfile.
2673      * The attribute is only the last component of the original filename, so is unlikely
2674      * to be valid as is, so operations other than those to access the name throw
2675      * UnsupportedOperationException
2676      */
2677     private static class SourceFileObject implements JavaFileObject {
2678 
2679         /** The file&#39;s name.
2680          */
2681         private final Name name;
2682 
2683         public SourceFileObject(Name name) {
2684             this.name = name;
2685         }
2686 
2687         @Override @DefinedBy(Api.COMPILER)
2688         public URI toUri() {
2689             try {
2690                 return new URI(null, name.toString(), null);
2691             } catch (URISyntaxException e) {
2692                 throw new PathFileObject.CannotCreateUriError(name.toString(), e);
2693             }
2694         }
2695 
2696         @Override @DefinedBy(Api.COMPILER)
2697         public String getName() {
2698             return name.toString();
2699         }
2700 
2701         @Override @DefinedBy(Api.COMPILER)
2702         public JavaFileObject.Kind getKind() {
2703             return BaseFileManager.getKind(getName());
2704         }
2705 
2706         @Override @DefinedBy(Api.COMPILER)
2707         public InputStream openInputStream() {
2708             throw new UnsupportedOperationException();
2709         }
2710 
2711         @Override @DefinedBy(Api.COMPILER)
2712         public OutputStream openOutputStream() {
2713             throw new UnsupportedOperationException();
2714         }
2715 
2716         @Override @DefinedBy(Api.COMPILER)
2717         public CharBuffer getCharContent(boolean ignoreEncodingErrors) {
2718             throw new UnsupportedOperationException();
2719         }
2720 
2721         @Override @DefinedBy(Api.COMPILER)
2722         public Reader openReader(boolean ignoreEncodingErrors) {
2723             throw new UnsupportedOperationException();
2724         }
2725 
2726         @Override @DefinedBy(Api.COMPILER)
2727         public Writer openWriter() {
2728             throw new UnsupportedOperationException();
2729         }
2730 
2731         @Override @DefinedBy(Api.COMPILER)
2732         public long getLastModified() {
2733             throw new UnsupportedOperationException();
2734         }
2735 
2736         @Override @DefinedBy(Api.COMPILER)
2737         public boolean delete() {
2738             throw new UnsupportedOperationException();
2739         }
2740 
2741         @Override @DefinedBy(Api.COMPILER)
2742         public boolean isNameCompatible(String simpleName, JavaFileObject.Kind kind) {
2743             return true; // fail-safe mode
2744         }
2745 
2746         @Override @DefinedBy(Api.COMPILER)
2747         public NestingKind getNestingKind() {
2748             return null;
2749         }
2750 
2751         @Override @DefinedBy(Api.COMPILER)
2752         public Modifier getAccessLevel() {
2753             return null;
2754         }
2755 
2756         /**
2757          * Check if two file objects are equal.
2758          * SourceFileObjects are just placeholder objects for the value of a
2759          * SourceFile attribute, and do not directly represent specific files.
2760          * Two SourceFileObjects are equal if their names are equal.
2761          */
2762         @Override
2763         public boolean equals(Object other) {
2764             if (this == other)
2765                 return true;
2766 
2767             if (!(other instanceof SourceFileObject))
2768                 return false;
2769 
2770             SourceFileObject o = (SourceFileObject) other;
2771             return name.equals(o.name);
2772         }
2773 
2774         @Override
2775         public int hashCode() {
2776             return name.hashCode();
2777         }
2778     }
2779 
2780     private class CompleterDeproxy implements AnnotationTypeCompleter {
2781         ClassSymbol proxyOn;
2782         CompoundAnnotationProxy target;
2783         CompoundAnnotationProxy repeatable;
2784 
2785         public CompleterDeproxy(ClassSymbol c, CompoundAnnotationProxy target,
2786                 CompoundAnnotationProxy repeatable)
2787         {
2788             this.proxyOn = c;
2789             this.target = target;
2790             this.repeatable = repeatable;
2791         }
2792 
2793         @Override
2794         public void complete(ClassSymbol sym) {
2795             Assert.check(proxyOn == sym);
2796             Attribute.Compound theTarget = null, theRepeatable = null;
2797             AnnotationDeproxy deproxy;
2798 
2799             try {
2800                 if (target != null) {
2801                     deproxy = new AnnotationDeproxy(proxyOn);
2802                     theTarget = deproxy.deproxyCompound(target);
2803                 }
2804 
2805                 if (repeatable != null) {
2806                     deproxy = new AnnotationDeproxy(proxyOn);
2807                     theRepeatable = deproxy.deproxyCompound(repeatable);
2808                 }
2809             } catch (Exception e) {
2810                 throw new CompletionFailure(sym,
2811                                             () -&gt; ClassReader.this.diagFactory.fragment(Fragments.ExceptionMessage(e.getMessage())),
2812                                             dcfh);
2813             }
2814 
2815             sym.getAnnotationTypeMetadata().setTarget(theTarget);
2816             sym.getAnnotationTypeMetadata().setRepeatable(theRepeatable);
2817         }
2818     }
2819 
2820     private class ProxyType extends Type {
2821 
2822         private final Name name;
2823 
2824         public ProxyType(int index) {
2825             super(syms.noSymbol, TypeMetadata.EMPTY);
2826             this.name = poolReader.getName(index);
2827         }
2828 
2829         @Override
2830         public TypeTag getTag() {
2831             return TypeTag.NONE;
2832         }
2833 
2834         @Override
2835         public Type cloneWithMetadata(TypeMetadata metadata) {
2836             throw new UnsupportedOperationException();
2837         }
2838 
2839         public Type resolve() {
2840             return name.map(ClassReader.this::sigToType);
2841         }
2842 
2843         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2844         public String toString() {
2845             return &quot;&lt;ProxyType&gt;&quot;;
2846         }
2847 
2848     }
2849 
2850     private static final class InterimUsesDirective {
2851         public final Name service;
2852 
2853         public InterimUsesDirective(Name service) {
2854             this.service = service;
2855         }
2856 
2857     }
2858 
2859     private static final class InterimProvidesDirective {
2860         public final Name service;
2861         public final List&lt;Name&gt; impls;
2862 
2863         public InterimProvidesDirective(Name service, List&lt;Name&gt; impls) {
2864             this.service = service;
2865             this.impls = impls;
2866         }
2867 
2868     }
2869 
2870     private final class UsesProvidesCompleter implements Completer {
2871         private final ModuleSymbol currentModule;
2872         private final List&lt;InterimUsesDirective&gt; interimUsesCopy;
2873         private final List&lt;InterimProvidesDirective&gt; interimProvidesCopy;
2874 
2875         public UsesProvidesCompleter(ModuleSymbol currentModule, List&lt;InterimUsesDirective&gt; interimUsesCopy, List&lt;InterimProvidesDirective&gt; interimProvidesCopy) {
2876             this.currentModule = currentModule;
2877             this.interimUsesCopy = interimUsesCopy;
2878             this.interimProvidesCopy = interimProvidesCopy;
2879         }
2880 
2881         @Override
2882         public void complete(Symbol sym) throws CompletionFailure {
2883             ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
2884             directives.addAll(currentModule.directives);
2885             ListBuffer&lt;UsesDirective&gt; uses = new ListBuffer&lt;&gt;();
2886             for (InterimUsesDirective interim : interimUsesCopy) {
2887                 UsesDirective d = new UsesDirective(syms.enterClass(currentModule, interim.service));
2888                 uses.add(d);
2889                 directives.add(d);
2890             }
2891             currentModule.uses = uses.toList();
2892             ListBuffer&lt;ProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
2893             for (InterimProvidesDirective interim : interimProvidesCopy) {
2894                 ListBuffer&lt;ClassSymbol&gt; impls = new ListBuffer&lt;&gt;();
2895                 for (Name impl : interim.impls) {
2896                     impls.append(syms.enterClass(currentModule, impl));
2897                 }
2898                 ProvidesDirective d = new ProvidesDirective(syms.enterClass(currentModule, interim.service),
2899                                                             impls.toList());
2900                 provides.add(d);
2901                 directives.add(d);
2902             }
2903             currentModule.provides = provides.toList();
2904             currentModule.directives = directives.toList();
2905         }
2906     }
2907 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
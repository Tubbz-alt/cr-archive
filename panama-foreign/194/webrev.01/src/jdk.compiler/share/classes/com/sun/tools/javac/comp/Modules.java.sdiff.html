<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Check.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeEnter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 613                     StandardLocation.SOURCE_OUTPUT : StandardLocation.CLASS_OUTPUT;
 614             loc =
 615                 fileManager.getLocationForModule(sourceOutput, fo);
 616         }
 617         return loc;
 618     }
 619 
 620     private void checkNoAllModulePath() {
 621         if (addModsOpt != null &amp;&amp; Arrays.asList(addModsOpt.split(&quot;,&quot;)).contains(ALL_MODULE_PATH)) {
 622             log.error(Errors.AddmodsAllModulePathInvalid);
 623         }
 624     }
 625 
 626     private final Completer mainCompleter = new Completer() {
 627         @Override
 628         public void complete(Symbol sym) throws CompletionFailure {
 629             ModuleSymbol msym = moduleFinder.findModule((ModuleSymbol) sym);
 630 
 631             if (msym.kind == ERR) {
 632                 //make sure the module is initialized:
<span class="line-modified"> 633                 msym.directives = List.nil();</span>
<span class="line-removed"> 634                 msym.exports = List.nil();</span>
<span class="line-removed"> 635                 msym.provides = List.nil();</span>
<span class="line-removed"> 636                 msym.requires = List.nil();</span>
<span class="line-removed"> 637                 msym.uses = List.nil();</span>
 638             } else if ((msym.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0) {
 639                 setupAutomaticModule(msym);
 640             } else {
<span class="line-modified"> 641                 msym.module_info.complete();</span>








 642             }
 643 
 644             // If module-info comes from a .java file, the underlying
 645             // call of classFinder.fillIn will have called through the
 646             // source completer, to Enter, and then to Modules.enter,
 647             // which will call completeModule.
 648             // But, if module-info comes from a .class file, the underlying
 649             // call of classFinder.fillIn will just call ClassReader to read
 650             // the .class file, and so we call completeModule here.
 651             if (msym.module_info.classfile == null || msym.module_info.classfile.getKind() == Kind.CLASS) {
 652                 completeModule(msym);
 653             }
 654         }
 655 








 656         @Override
 657         public String toString() {
 658             return &quot;mainCompleter&quot;;
 659         }
 660     };
 661 
 662     private void setupAutomaticModule(ModuleSymbol msym) throws CompletionFailure {
 663         try {
 664             ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
 665             ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
 666             Set&lt;String&gt; seenPackages = new HashSet&lt;&gt;();
 667 
 668             for (JavaFileObject clazz : fileManager.list(msym.classLocation, &quot;&quot;, EnumSet.of(Kind.CLASS), true)) {
 669                 String binName = fileManager.inferBinaryName(msym.classLocation, clazz);
 670                 String pack = binName.lastIndexOf(&#39;.&#39;) != (-1) ? binName.substring(0, binName.lastIndexOf(&#39;.&#39;)) : &quot;&quot;; //unnamed package????
 671                 if (seenPackages.add(pack)) {
 672                     ExportsDirective d = new ExportsDirective(syms.enterPackage(msym, names.fromString(pack)), null);
 673                     //TODO: opens?
 674                     directives.add(d);
 675                     exports.add(d);
</pre>
</td>
<td>
<hr />
<pre>
 613                     StandardLocation.SOURCE_OUTPUT : StandardLocation.CLASS_OUTPUT;
 614             loc =
 615                 fileManager.getLocationForModule(sourceOutput, fo);
 616         }
 617         return loc;
 618     }
 619 
 620     private void checkNoAllModulePath() {
 621         if (addModsOpt != null &amp;&amp; Arrays.asList(addModsOpt.split(&quot;,&quot;)).contains(ALL_MODULE_PATH)) {
 622             log.error(Errors.AddmodsAllModulePathInvalid);
 623         }
 624     }
 625 
 626     private final Completer mainCompleter = new Completer() {
 627         @Override
 628         public void complete(Symbol sym) throws CompletionFailure {
 629             ModuleSymbol msym = moduleFinder.findModule((ModuleSymbol) sym);
 630 
 631             if (msym.kind == ERR) {
 632                 //make sure the module is initialized:
<span class="line-modified"> 633                 initErrModule(msym);</span>




 634             } else if ((msym.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0) {
 635                 setupAutomaticModule(msym);
 636             } else {
<span class="line-modified"> 637                 try {</span>
<span class="line-added"> 638                     msym.module_info.complete();</span>
<span class="line-added"> 639                 } catch (CompletionFailure cf) {</span>
<span class="line-added"> 640                     msym.kind = ERR;</span>
<span class="line-added"> 641                     //make sure the module is initialized:</span>
<span class="line-added"> 642                     initErrModule(msym);</span>
<span class="line-added"> 643                     completeModule(msym);</span>
<span class="line-added"> 644                     throw cf;</span>
<span class="line-added"> 645                 }</span>
 646             }
 647 
 648             // If module-info comes from a .java file, the underlying
 649             // call of classFinder.fillIn will have called through the
 650             // source completer, to Enter, and then to Modules.enter,
 651             // which will call completeModule.
 652             // But, if module-info comes from a .class file, the underlying
 653             // call of classFinder.fillIn will just call ClassReader to read
 654             // the .class file, and so we call completeModule here.
 655             if (msym.module_info.classfile == null || msym.module_info.classfile.getKind() == Kind.CLASS) {
 656                 completeModule(msym);
 657             }
 658         }
 659 
<span class="line-added"> 660         private void initErrModule(ModuleSymbol msym) {</span>
<span class="line-added"> 661             msym.directives = List.nil();</span>
<span class="line-added"> 662             msym.exports = List.nil();</span>
<span class="line-added"> 663             msym.provides = List.nil();</span>
<span class="line-added"> 664             msym.requires = List.nil();</span>
<span class="line-added"> 665             msym.uses = List.nil();</span>
<span class="line-added"> 666         }</span>
<span class="line-added"> 667 </span>
 668         @Override
 669         public String toString() {
 670             return &quot;mainCompleter&quot;;
 671         }
 672     };
 673 
 674     private void setupAutomaticModule(ModuleSymbol msym) throws CompletionFailure {
 675         try {
 676             ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
 677             ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
 678             Set&lt;String&gt; seenPackages = new HashSet&lt;&gt;();
 679 
 680             for (JavaFileObject clazz : fileManager.list(msym.classLocation, &quot;&quot;, EnumSet.of(Kind.CLASS), true)) {
 681                 String binName = fileManager.inferBinaryName(msym.classLocation, clazz);
 682                 String pack = binName.lastIndexOf(&#39;.&#39;) != (-1) ? binName.substring(0, binName.lastIndexOf(&#39;.&#39;)) : &quot;&quot;; //unnamed package????
 683                 if (seenPackages.add(pack)) {
 684                     ExportsDirective d = new ExportsDirective(syms.enterPackage(msym, names.fromString(pack)), null);
 685                     //TODO: opens?
 686                     directives.add(d);
 687                     exports.add(d);
</pre>
</td>
</tr>
</table>
<center><a href="Check.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeEnter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
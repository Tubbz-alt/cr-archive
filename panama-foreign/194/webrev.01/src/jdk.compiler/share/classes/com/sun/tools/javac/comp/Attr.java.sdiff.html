<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../code/Types.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Check.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
5010         Type st = types.supertype(c.type);
5011         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5012             // First, attribute superclass.
5013             if (st.hasTag(CLASS))
5014                 attribClass((ClassSymbol)st.tsym);
5015 
5016             // Next attribute owner, if it is a class.
5017             if (c.owner.kind == TYP &amp;&amp; c.owner.type.hasTag(CLASS))
5018                 attribClass((ClassSymbol)c.owner);
5019         }
5020 
5021         // The previous operations might have attributed the current class
5022         // if there was a cycle. So we test first whether the class is still
5023         // UNATTRIBUTED.
5024         if ((c.flags_field &amp; UNATTRIBUTED) != 0) {
5025             c.flags_field &amp;= ~UNATTRIBUTED;
5026 
5027             // Get environment current at the point of class definition.
5028             Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5029 




















































































5030             // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
5031             // because the annotations were not available at the time the env was created. Therefore,
5032             // we look up the environment chain for the first enclosing environment for which the
5033             // lint value is set. Typically, this is the parent env, but might be further if there
5034             // are any envs created as a result of TypeParameter nodes.
5035             Env&lt;AttrContext&gt; lintEnv = env;
5036             while (lintEnv.info.lint == null)
5037                 lintEnv = lintEnv.next;
5038 
5039             // Having found the enclosing lint value, we can initialize the lint value for this class
5040             env.info.lint = lintEnv.info.lint.augment(c);
5041 
5042             Lint prevLint = chk.setLint(env.info.lint);
5043             JavaFileObject prev = log.useSource(c.sourcefile);
5044             ResultInfo prevReturnRes = env.info.returnResult;
5045 
5046             try {
5047                 deferredLintHandler.flush(env.tree);
5048                 env.info.returnResult = null;
5049                 // java.lang.Enum may not be subclassed by a non-enum
</pre>
</td>
<td>
<hr />
<pre>
5010         Type st = types.supertype(c.type);
5011         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5012             // First, attribute superclass.
5013             if (st.hasTag(CLASS))
5014                 attribClass((ClassSymbol)st.tsym);
5015 
5016             // Next attribute owner, if it is a class.
5017             if (c.owner.kind == TYP &amp;&amp; c.owner.type.hasTag(CLASS))
5018                 attribClass((ClassSymbol)c.owner);
5019         }
5020 
5021         // The previous operations might have attributed the current class
5022         // if there was a cycle. So we test first whether the class is still
5023         // UNATTRIBUTED.
5024         if ((c.flags_field &amp; UNATTRIBUTED) != 0) {
5025             c.flags_field &amp;= ~UNATTRIBUTED;
5026 
5027             // Get environment current at the point of class definition.
5028             Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5029 
<span class="line-added">5030             if (c.isSealed() &amp;&amp;</span>
<span class="line-added">5031                     !c.isEnum() &amp;&amp;</span>
<span class="line-added">5032                     !c.isPermittedExplicit &amp;&amp;</span>
<span class="line-added">5033                     c.permitted.isEmpty()) {</span>
<span class="line-added">5034                 log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.SealedClassMustHaveSubclasses);</span>
<span class="line-added">5035             }</span>
<span class="line-added">5036 </span>
<span class="line-added">5037             if (c.isSealed()) {</span>
<span class="line-added">5038                 Set&lt;Symbol&gt; permittedTypes = new HashSet&lt;&gt;();</span>
<span class="line-added">5039                 boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;</span>
<span class="line-added">5040                 for (Symbol subTypeSym : c.permitted) {</span>
<span class="line-added">5041                     boolean isTypeVar = false;</span>
<span class="line-added">5042                     if (subTypeSym.type.getTag() == TYPEVAR) {</span>
<span class="line-added">5043                         isTypeVar = true; //error recovery</span>
<span class="line-added">5044                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),</span>
<span class="line-added">5045                                 Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));</span>
<span class="line-added">5046                     }</span>
<span class="line-added">5047                     if (subTypeSym.isAnonymous() &amp;&amp; !c.isEnum()) {</span>
<span class="line-added">5048                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));</span>
<span class="line-added">5049                     }</span>
<span class="line-added">5050                     if (permittedTypes.contains(subTypeSym)) {</span>
<span class="line-added">5051                         DiagnosticPosition pos =</span>
<span class="line-added">5052                                 env.enclClass.permitting.stream()</span>
<span class="line-added">5053                                         .filter(permittedExpr -&gt; TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)</span>
<span class="line-added">5054                                         .limit(2).collect(List.collector()).get(1);</span>
<span class="line-added">5055                         log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));</span>
<span class="line-added">5056                     } else {</span>
<span class="line-added">5057                         permittedTypes.add(subTypeSym);</span>
<span class="line-added">5058                     }</span>
<span class="line-added">5059                     if (sealedInUnnamed) {</span>
<span class="line-added">5060                         if (subTypeSym.packge() != c.packge()) {</span>
<span class="line-added">5061                             log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));</span>
<span class="line-added">5062                         }</span>
<span class="line-added">5063                     } else if (subTypeSym.packge().modle != c.packge().modle) {</span>
<span class="line-added">5064                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));</span>
<span class="line-added">5065                     }</span>
<span class="line-added">5066                     if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {</span>
<span class="line-added">5067                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),</span>
<span class="line-added">5068                                 Errors.InvalidPermitsClause(</span>
<span class="line-added">5069                                         subTypeSym == c.type.tsym ?</span>
<span class="line-added">5070                                                 Fragments.MustNotBeSameClass :</span>
<span class="line-added">5071                                                 Fragments.MustNotBeSupertype(subTypeSym.type)</span>
<span class="line-added">5072                                 )</span>
<span class="line-added">5073                         );</span>
<span class="line-added">5074                     } else if (!isTypeVar) {</span>
<span class="line-added">5075                         boolean thisIsASuper = types.directSupertypes(subTypeSym.type)</span>
<span class="line-added">5076                                                     .stream()</span>
<span class="line-added">5077                                                     .anyMatch(d -&gt; d.tsym == c);</span>
<span class="line-added">5078                         if (!thisIsASuper) {</span>
<span class="line-added">5079                             log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),</span>
<span class="line-added">5080                                     Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));</span>
<span class="line-added">5081                         }</span>
<span class="line-added">5082                     }</span>
<span class="line-added">5083                 }</span>
<span class="line-added">5084             }</span>
<span class="line-added">5085 </span>
<span class="line-added">5086             List&lt;ClassSymbol&gt; sealedSupers = types.directSupertypes(c.type)</span>
<span class="line-added">5087                                                   .stream()</span>
<span class="line-added">5088                                                   .filter(s -&gt; s.tsym.isSealed())</span>
<span class="line-added">5089                                                   .map(s -&gt; (ClassSymbol) s.tsym)</span>
<span class="line-added">5090                                                   .collect(List.collector());</span>
<span class="line-added">5091 </span>
<span class="line-added">5092             if (sealedSupers.isEmpty()) {</span>
<span class="line-added">5093                 if ((c.flags_field &amp; Flags.NON_SEALED) != 0) {</span>
<span class="line-added">5094                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype(c));</span>
<span class="line-added">5095                 }</span>
<span class="line-added">5096             } else {</span>
<span class="line-added">5097                 if (c.isLocal() &amp;&amp; !c.isEnum()) {</span>
<span class="line-added">5098                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed);</span>
<span class="line-added">5099                 }</span>
<span class="line-added">5100 </span>
<span class="line-added">5101                 for (ClassSymbol supertypeSym : sealedSupers) {</span>
<span class="line-added">5102                     if (!supertypeSym.permitted.contains(c.type.tsym)) {</span>
<span class="line-added">5103                         log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));</span>
<span class="line-added">5104                     }</span>
<span class="line-added">5105                 }</span>
<span class="line-added">5106                 if (!c.isNonSealed() &amp;&amp; !c.isFinal() &amp;&amp; !c.isSealed()) {</span>
<span class="line-added">5107                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree),</span>
<span class="line-added">5108                             c.isInterface() ?</span>
<span class="line-added">5109                                     Errors.NonSealedOrSealedExpected :</span>
<span class="line-added">5110                                     Errors.NonSealedSealedOrFinalExpected);</span>
<span class="line-added">5111                 }</span>
<span class="line-added">5112             }</span>
<span class="line-added">5113 </span>
5114             // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
5115             // because the annotations were not available at the time the env was created. Therefore,
5116             // we look up the environment chain for the first enclosing environment for which the
5117             // lint value is set. Typically, this is the parent env, but might be further if there
5118             // are any envs created as a result of TypeParameter nodes.
5119             Env&lt;AttrContext&gt; lintEnv = env;
5120             while (lintEnv.info.lint == null)
5121                 lintEnv = lintEnv.next;
5122 
5123             // Having found the enclosing lint value, we can initialize the lint value for this class
5124             env.info.lint = lintEnv.info.lint.augment(c);
5125 
5126             Lint prevLint = chk.setLint(env.info.lint);
5127             JavaFileObject prev = log.useSource(c.sourcefile);
5128             ResultInfo prevReturnRes = env.info.returnResult;
5129 
5130             try {
5131                 deferredLintHandler.flush(env.tree);
5132                 env.info.returnResult = null;
5133                 // java.lang.Enum may not be subclassed by a non-enum
</pre>
</td>
</tr>
</table>
<center><a href="../code/Types.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Check.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
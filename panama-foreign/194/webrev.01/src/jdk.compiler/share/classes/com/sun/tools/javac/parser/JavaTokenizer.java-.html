<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavaTokenizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import com.sun.tools.javac.code.Lint;
  29 import com.sun.tools.javac.code.Lint.LintCategory;
  30 import com.sun.tools.javac.code.Preview;
  31 import com.sun.tools.javac.code.Source;
  32 import com.sun.tools.javac.code.Source.Feature;
  33 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  34 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  35 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  36 import com.sun.tools.javac.util.*;
  37 import com.sun.tools.javac.util.JCDiagnostic.*;
  38 
  39 import java.lang.reflect.InvocationTargetException;
  40 import java.lang.reflect.Method;
  41 import java.nio.CharBuffer;
  42 import java.util.HashSet;
  43 import java.util.Set;
  44 
  45 import static com.sun.tools.javac.parser.Tokens.*;
  46 import static com.sun.tools.javac.util.LayoutCharacters.*;
  47 
  48 /** The lexical analyzer maps an input stream consisting of
  49  *  ASCII characters and Unicode escapes into a token sequence.
  50  *
  51  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  52  *  If you write code that depends on this, you do so at your own risk.
  53  *  This code and its internal interfaces are subject to change or
  54  *  deletion without notice.&lt;/b&gt;
  55  */
  56 public class JavaTokenizer {
  57 
  58     private static final boolean scannerDebug = false;
  59 
  60     /** The source language setting.
  61      */
  62     private Source source;
  63 
  64     /** The preview language setting. */
  65     private Preview preview;
  66 
  67     /** The log to be used for error reporting.
  68      */
  69     private final Log log;
  70 
  71     /** The token factory. */
  72     private final Tokens tokens;
  73 
  74     /** The token kind, set by nextToken().
  75      */
  76     protected TokenKind tk;
  77 
  78     /** The token&#39;s radix, set by nextToken().
  79      */
  80     protected int radix;
  81 
  82     /** The token&#39;s name, set by nextToken().
  83      */
  84     protected Name name;
  85 
  86     /** The position where a lexical error occurred;
  87      */
  88     protected int errPos = Position.NOPOS;
  89 
  90     /** The Unicode reader (low-level stream reader).
  91      */
  92     protected UnicodeReader reader;
  93 
  94     /** If is a text block
  95      */
  96     protected boolean isTextBlock;
  97 
  98     /** If contains escape sequences
  99      */
 100     protected boolean hasEscapeSequences;
 101 
 102     protected ScannerFactory fac;
 103 
 104     // The set of lint options currently in effect. It is initialized
 105     // from the context, and then is set/reset as needed by Attr as it
 106     // visits all the various parts of the trees during attribution.
 107     protected Lint lint;
 108 
 109     private static final boolean hexFloatsWork = hexFloatsWork();
 110     private static boolean hexFloatsWork() {
 111         try {
 112             Float.valueOf(&quot;0x1.0p1&quot;);
 113             return true;
 114         } catch (NumberFormatException ex) {
 115             return false;
 116         }
 117     }
 118 
 119     /**
 120      * Create a scanner from the input array.  This method might
 121      * modify the array.  To avoid copying the input array, ensure
 122      * that {@code inputLength &lt; input.length} or
 123      * {@code input[input.length -1]} is a white space character.
 124      *
 125      * @param fac the factory which created this Scanner
 126      * @param buf the input, might be modified
 127      * Must be positive and less than or equal to input.length.
 128      */
 129     protected JavaTokenizer(ScannerFactory fac, CharBuffer buf) {
 130         this(fac, new UnicodeReader(fac, buf));
 131     }
 132 
 133     protected JavaTokenizer(ScannerFactory fac, char[] buf, int inputLength) {
 134         this(fac, new UnicodeReader(fac, buf, inputLength));
 135     }
 136 
 137     protected JavaTokenizer(ScannerFactory fac, UnicodeReader reader) {
 138         this.fac = fac;
 139         this.log = fac.log;
 140         this.tokens = fac.tokens;
 141         this.source = fac.source;
 142         this.preview = fac.preview;
 143         this.reader = reader;
 144         this.lint = fac.lint;
 145     }
 146 
 147     protected void checkSourceLevel(int pos, Feature feature) {
 148         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
 149             //preview feature without --preview flag, error
 150             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
 151         } else if (!feature.allowedInSource(source)) {
 152             //incompatible source level, error
 153             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
 154         } else if (preview.isPreview(feature)) {
 155             //use of preview feature, warn
 156             preview.warnPreview(pos, feature);
 157         }
 158     }
 159 
 160     /** Report an error at the given position using the provided arguments.
 161      */
 162     protected void lexError(int pos, JCDiagnostic.Error key) {
 163         log.error(pos, key);
 164         tk = TokenKind.ERROR;
 165         errPos = pos;
 166     }
 167 
 168     protected void lexError(DiagnosticFlag flags, int pos, JCDiagnostic.Error key) {
 169         log.error(flags, pos, key);
 170         tk = TokenKind.ERROR;
 171         errPos = pos;
 172     }
 173 
 174     protected void lexWarning(LintCategory lc, int pos, JCDiagnostic.Warning key) {
 175         DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;
 176         log.warning(lc, dp, key);
 177     }
 178 
 179     /** Read next character in character or string literal and copy into sbuf.
 180      *      pos - start of literal offset
 181      *      translateEscapesNow - true if String::translateEscapes is not available
 182      *                            in the java.base libs. Occurs during bootstrapping.
 183      *      multiline - true if scanning a text block. Allows newlines to be embedded
 184      *                  in the result.
 185      */
 186     private void scanLitChar(int pos, boolean translateEscapesNow, boolean multiline) {
 187          if (reader.ch == &#39;\\&#39;) {
 188             if (reader.peekChar() == &#39;\\&#39; &amp;&amp; !reader.isUnicode()) {
 189                 reader.skipChar();
 190                 if (!translateEscapesNow) {
 191                     reader.putChar(false);
 192                 }
 193                 reader.putChar(true);
 194             } else {
 195                 reader.nextChar(translateEscapesNow);
 196                 switch (reader.ch) {
 197                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:
 198                 case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:
 199                     char leadch = reader.ch;
 200                     int oct = reader.digit(pos, 8);
 201                     reader.nextChar(translateEscapesNow);
 202                     if (&#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {
 203                         oct = oct * 8 + reader.digit(pos, 8);
 204                         reader.nextChar(translateEscapesNow);
 205                         if (leadch &lt;= &#39;3&#39; &amp;&amp; &#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {
 206                             oct = oct * 8 + reader.digit(pos, 8);
 207                             reader.nextChar(translateEscapesNow);
 208                         }
 209                     }
 210                     if (translateEscapesNow) {
 211                         reader.putChar((char)oct);
 212                     }
 213                     break;
 214                 case &#39;b&#39;:
 215                     reader.putChar(translateEscapesNow ? &#39;\b&#39; : &#39;b&#39;, true); break;
 216                 case &#39;t&#39;:
 217                     reader.putChar(translateEscapesNow ? &#39;\t&#39; : &#39;t&#39;, true); break;
 218                 case &#39;n&#39;:
 219                     reader.putChar(translateEscapesNow ? &#39;\n&#39; : &#39;n&#39;, true); break;
 220                 case &#39;f&#39;:
 221                     reader.putChar(translateEscapesNow ? &#39;\f&#39; : &#39;f&#39;, true); break;
 222                 case &#39;r&#39;:
 223                     reader.putChar(translateEscapesNow ? &#39;\r&#39; : &#39;r&#39;, true); break;
 224                 case &#39;\&#39;&#39;:
 225                 case &#39;\&quot;&#39;:
 226                 case &#39;\\&#39;:
 227                     reader.putChar(true); break;
 228                 case &#39;s&#39;:
 229                     checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);
 230                     reader.putChar(translateEscapesNow ? &#39; &#39; : &#39;s&#39;, true); break;
 231                 case &#39;\n&#39;:
 232                 case &#39;\r&#39;:
 233                     if (!multiline) {
 234                         lexError(reader.bp, Errors.IllegalEscChar);
 235                     } else {
 236                         checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);
 237                         int start = reader.bp;
 238                         if (reader.ch == &#39;\r&#39; &amp;&amp; reader.peekChar() == &#39;\n&#39;) {
 239                            reader.nextChar(translateEscapesNow);
 240                         }
 241                         reader.nextChar(translateEscapesNow);
 242                         processLineTerminator(start, reader.bp);
 243                     }
 244                     break;
 245                 default:
 246                     lexError(reader.bp, Errors.IllegalEscChar);
 247                 }
 248             }
 249         } else if (reader.bp != reader.buflen) {
 250             reader.putChar(true);
 251         }
 252     }
 253 
 254     /** Interim access to String methods used to support text blocks.
 255      *  Required to handle bootstrapping with pre-text block jdks.
 256      *  Should be replaced with direct calls in the &#39;next&#39; jdk.
 257      */
 258     static class TextBlockSupport {
 259         /** Reflection method to remove incidental indentation.
 260          */
 261         private static final Method stripIndent;
 262 
 263         /** Reflection method to translate escape sequences.
 264          */
 265         private static final Method translateEscapes;
 266 
 267         /** true if stripIndent and translateEscapes are available in the bootstrap jdk.
 268          */
 269         private static final boolean hasSupport;
 270 
 271         /** Get a string method via refection or null if not available.
 272          */
 273         private static Method getStringMethodOrNull(String name) {
 274             try {
 275                 return String.class.getMethod(name);
 276             } catch (Exception ex) {
 277                 // Method not available, return null.
 278             }
 279             return null;
 280         }
 281 
 282         static {
 283             // Get text block string methods.
 284             stripIndent = getStringMethodOrNull(&quot;stripIndent&quot;);
 285             translateEscapes = getStringMethodOrNull(&quot;translateEscapes&quot;);
 286             // true if stripIndent and translateEscapes are available in the bootstrap jdk.
 287             hasSupport = stripIndent != null &amp;&amp; translateEscapes != null;
 288         }
 289 
 290         /** Return true if stripIndent and translateEscapes are available in the bootstrap jdk.
 291          */
 292         static boolean hasSupport() {
 293             return hasSupport;
 294         }
 295 
 296         /** Return the leading whitespace count (indentation) of the line.
 297          */
 298         private static int indent(String line) {
 299             return line.length() - line.stripLeading().length();
 300         }
 301 
 302         enum WhitespaceChecks {
 303             INCONSISTENT,
 304             TRAILING
 305         };
 306 
 307         /** Check that the use of white space in content is not problematic.
 308          */
 309         static Set&lt;WhitespaceChecks&gt; checkWhitespace(String string) {
 310             // Start with empty result set.
 311             Set&lt;WhitespaceChecks&gt; checks = new HashSet&lt;&gt;();
 312             // No need to check empty strings.
 313             if (string.isEmpty()) {
 314                 return checks;
 315             }
 316             // Maximum common indentation.
 317             int outdent = 0;
 318             // No need to check indentation if opting out (last line is empty.)
 319             char lastChar = string.charAt(string.length() - 1);
 320             boolean optOut = lastChar == &#39;\n&#39; || lastChar == &#39;\r&#39;;
 321             // Split string based at line terminators.
 322             String[] lines = string.split(&quot;\\R&quot;);
 323             int length = lines.length;
 324             // Extract last line.
 325             String lastLine = length == 0 ? &quot;&quot; : lines[length - 1];
 326              if (!optOut) {
 327                 // Prime with the last line indentation (may be blank.)
 328                 outdent = indent(lastLine);
 329                 for (String line : lines) {
 330                     // Blanks lines have no influence (last line accounted for.)
 331                     if (!line.isBlank()) {
 332                         outdent = Integer.min(outdent, indent(line));
 333                         if (outdent == 0) {
 334                             break;
 335                         }
 336                     }
 337                 }
 338             }
 339             // Last line is representative.
 340             String start = lastLine.substring(0, outdent);
 341             for (String line : lines) {
 342                 // Fail if a line does not have the same indentation.
 343                 if (!line.isBlank() &amp;&amp; !line.startsWith(start)) {
 344                     // Mix of different white space
 345                     checks.add(WhitespaceChecks.INCONSISTENT);
 346                 }
 347                 // Line has content even after indent is removed.
 348                 if (outdent &lt; line.length()) {
 349                     // Is the last character a white space.
 350                     lastChar = line.charAt(line.length() - 1);
 351                     if (Character.isWhitespace(lastChar)) {
 352                         // Has trailing white space.
 353                         checks.add(WhitespaceChecks.TRAILING);
 354                     }
 355                 }
 356             }
 357             return checks;
 358         }
 359 
 360         /** Invoke String::stripIndent through reflection.
 361          */
 362         static String stripIndent(String string) {
 363             try {
 364                 string = (String)stripIndent.invoke(string);
 365             } catch (InvocationTargetException | IllegalAccessException ex) {
 366                 throw new RuntimeException(ex);
 367             }
 368             return string;
 369         }
 370 
 371         /** Invoke String::translateEscapes through reflection.
 372          */
 373         static String translateEscapes(String string) {
 374             try {
 375                 string = (String)translateEscapes.invoke(string);
 376             } catch (InvocationTargetException | IllegalAccessException ex) {
 377                 throw new RuntimeException(ex);
 378             }
 379             return string;
 380         }
 381     }
 382 
 383     /** Test for EOLN.
 384      */
 385     private boolean isEOLN() {
 386         return reader.ch == LF || reader.ch == CR;
 387     }
 388 
 389     /** Test for CRLF.
 390      */
 391     private boolean isCRLF() {
 392         return reader.ch == CR &amp;&amp; reader.peekChar() == LF;
 393     }
 394 
 395     /** Count and skip repeated occurrences of the specified character.
 396      */
 397     private int countChar(char ch, int max) {
 398         int count = 0;
 399         for ( ; count &lt; max &amp;&amp; reader.bp &lt; reader.buflen &amp;&amp; reader.ch == ch; count++) {
 400             reader.scanChar();
 401         }
 402         return count;
 403     }
 404 
 405     /** Skip and process a line terminator.
 406      */
 407     private void skipLineTerminator() {
 408         int start = reader.bp;
 409         if (isCRLF()) {
 410             reader.scanChar();
 411         }
 412         reader.scanChar();
 413         processLineTerminator(start, reader.bp);
 414     }
 415 
 416     /** Scan a string literal or text block.
 417      */
 418     private void scanString(int pos) {
 419         // Clear flags.
 420         isTextBlock = false;
 421         hasEscapeSequences = false;
 422         // Track the end of first line for error recovery.
 423         int firstEOLN = -1;
 424         // Attempt to scan for up to 3 double quotes.
 425         int openCount = countChar(&#39;\&quot;&#39;, 3);
 426         switch (openCount) {
 427         case 1: // Starting a string literal.
 428             break;
 429         case 2: // Starting an empty string literal.
 430             // Start again but only consume one quote.
 431             reader.reset(pos);
 432             openCount = countChar(&#39;\&quot;&#39;, 1);
 433             break;
 434         case 3: // Starting a text block.
 435             // Check if preview feature is enabled for text blocks.
 436             checkSourceLevel(pos, Feature.TEXT_BLOCKS);
 437             isTextBlock = true;
 438             // Verify the open delimiter sequence.
 439             while (reader.bp &lt; reader.buflen) {
 440                 char ch = reader.ch;
 441                 if (ch != &#39; &#39; &amp;&amp; ch != &#39;\t&#39; &amp;&amp; ch != FF) {
 442                     break;
 443                 }
 444                 reader.scanChar();
 445             }
 446             if (isEOLN()) {
 447                 skipLineTerminator();
 448             } else {
 449                 // Error if the open delimiter sequence is not
 450                 //     &quot;&quot;&quot;&lt;white space&gt;*&lt;LineTerminator&gt;.
 451                 lexError(reader.bp, Errors.IllegalTextBlockOpen);
 452                 return;
 453             }
 454             break;
 455         }
 456         // While characters are available.
 457         while (reader.bp &lt; reader.buflen) {
 458             // If possible close delimiter sequence.
 459             if (reader.ch == &#39;\&quot;&#39;) {
 460                 // Check to see if enough double quotes are present.
 461                 int closeCount = countChar(&#39;\&quot;&#39;, openCount);
 462                 if (openCount == closeCount) {
 463                     // Good result.
 464                     tk = Tokens.TokenKind.STRINGLITERAL;
 465                     return;
 466                 }
 467                 // False alarm, add double quotes to string buffer.
 468                 reader.repeat(&#39;\&quot;&#39;, closeCount);
 469             } else if (isEOLN()) {
 470                 // Line terminator in string literal is an error.
 471                 // Fall out to unclosed string literal error.
 472                 if (openCount == 1) {
 473                     break;
 474                 }
 475                 skipLineTerminator();
 476                 // Add line terminator to string buffer.
 477                 reader.putChar(&#39;\n&#39;, false);
 478                 // Record first line terminator for error recovery.
 479                 if (firstEOLN == -1) {
 480                     firstEOLN = reader.bp;
 481                 }
 482             } else if (reader.ch == &#39;\\&#39;) {
 483                 // Handle escape sequences.
 484                 hasEscapeSequences = true;
 485                 // Translate escapes immediately if TextBlockSupport is not available
 486                 // during bootstrapping.
 487                 boolean translateEscapesNow = !TextBlockSupport.hasSupport();
 488                 scanLitChar(pos, translateEscapesNow, openCount != 1);
 489             } else {
 490                 // Add character to string buffer.
 491                 reader.putChar(true);
 492             }
 493         }
 494         // String ended without close delimiter sequence.
 495         lexError(pos, openCount == 1 ? Errors.UnclosedStrLit : Errors.UnclosedTextBlock);
 496         if (firstEOLN  != -1) {
 497             // Reset recovery position to point after open delimiter sequence.
 498             reader.reset(firstEOLN);
 499         }
 500     }
 501 
 502     private void scanDigits(int pos, int digitRadix) {
 503         char saveCh;
 504         int savePos;
 505         do {
 506             if (reader.ch != &#39;_&#39;) {
 507                 reader.putChar(false);
 508             }
 509             saveCh = reader.ch;
 510             savePos = reader.bp;
 511             reader.scanChar();
 512         } while (reader.digit(pos, digitRadix) &gt;= 0 || reader.ch == &#39;_&#39;);
 513         if (saveCh == &#39;_&#39;)
 514             lexError(savePos, Errors.IllegalUnderscore);
 515     }
 516 
 517     /** Read fractional part of hexadecimal floating point number.
 518      */
 519     private void scanHexExponentAndSuffix(int pos) {
 520         if (reader.ch == &#39;p&#39; || reader.ch == &#39;P&#39;) {
 521             reader.putChar(true);
 522             skipIllegalUnderscores();
 523             if (reader.ch == &#39;+&#39; || reader.ch == &#39;-&#39;) {
 524                 reader.putChar(true);
 525             }
 526             skipIllegalUnderscores();
 527             if (reader.digit(pos, 10) &gt;= 0) {
 528                 scanDigits(pos, 10);
 529                 if (!hexFloatsWork)
 530                     lexError(pos, Errors.UnsupportedCrossFpLit);
 531             } else
 532                 lexError(pos, Errors.MalformedFpLit);
 533         } else {
 534             lexError(pos, Errors.MalformedFpLit);
 535         }
 536         if (reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39;) {
 537             reader.putChar(true);
 538             tk = TokenKind.FLOATLITERAL;
 539             radix = 16;
 540         } else {
 541             if (reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;) {
 542                 reader.putChar(true);
 543             }
 544             tk = TokenKind.DOUBLELITERAL;
 545             radix = 16;
 546         }
 547     }
 548 
 549     /** Read fractional part of floating point number.
 550      */
 551     private void scanFraction(int pos) {
 552         skipIllegalUnderscores();
 553         if (reader.digit(pos, 10) &gt;= 0) {
 554             scanDigits(pos, 10);
 555         }
 556         int sp1 = reader.sp;
 557         if (reader.ch == &#39;e&#39; || reader.ch == &#39;E&#39;) {
 558             reader.putChar(true);
 559             skipIllegalUnderscores();
 560             if (reader.ch == &#39;+&#39; || reader.ch == &#39;-&#39;) {
 561                 reader.putChar(true);
 562             }
 563             skipIllegalUnderscores();
 564             if (reader.digit(pos, 10) &gt;= 0) {
 565                 scanDigits(pos, 10);
 566                 return;
 567             }
 568             lexError(pos, Errors.MalformedFpLit);
 569             reader.sp = sp1;
 570         }
 571     }
 572 
 573     /** Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of floating point number.
 574      */
 575     private void scanFractionAndSuffix(int pos) {
 576         radix = 10;
 577         scanFraction(pos);
 578         if (reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39;) {
 579             reader.putChar(true);
 580             tk = TokenKind.FLOATLITERAL;
 581         } else {
 582             if (reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;) {
 583                 reader.putChar(true);
 584             }
 585             tk = TokenKind.DOUBLELITERAL;
 586         }
 587     }
 588 
 589     /** Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of floating point number.
 590      */
 591     private void scanHexFractionAndSuffix(int pos, boolean seendigit) {
 592         radix = 16;
 593         Assert.check(reader.ch == &#39;.&#39;);
 594         reader.putChar(true);
 595         skipIllegalUnderscores();
 596         if (reader.digit(pos, 16) &gt;= 0) {
 597             seendigit = true;
 598             scanDigits(pos, 16);
 599         }
 600         if (!seendigit)
 601             lexError(pos, Errors.InvalidHexNumber);
 602         else
 603             scanHexExponentAndSuffix(pos);
 604     }
 605 
 606     private void skipIllegalUnderscores() {
 607         if (reader.ch == &#39;_&#39;) {
 608             lexError(reader.bp, Errors.IllegalUnderscore);
 609             while (reader.ch == &#39;_&#39;)
 610                 reader.scanChar();
 611         }
 612     }
 613 
 614     /** Read a number.
 615      *  @param radix  The radix of the number; one of 2, 8, 10, 16.
 616      */
 617     private void scanNumber(int pos, int radix) {
 618         // for octal, allow base-10 digit in case it&#39;s a float literal
 619         this.radix = radix;
 620         int digitRadix = (radix == 8 ? 10 : radix);
 621         int firstDigit = reader.digit(pos, Math.max(10, digitRadix));
 622         boolean seendigit = firstDigit &gt;= 0;
 623         boolean seenValidDigit = firstDigit &gt;= 0 &amp;&amp; firstDigit &lt; digitRadix;
 624         if (seendigit) {
 625             scanDigits(pos, digitRadix);
 626         }
 627         if (radix == 16 &amp;&amp; reader.ch == &#39;.&#39;) {
 628             scanHexFractionAndSuffix(pos, seendigit);
 629         } else if (seendigit &amp;&amp; radix == 16 &amp;&amp; (reader.ch == &#39;p&#39; || reader.ch == &#39;P&#39;)) {
 630             scanHexExponentAndSuffix(pos);
 631         } else if (digitRadix == 10 &amp;&amp; reader.ch == &#39;.&#39;) {
 632             reader.putChar(true);
 633             scanFractionAndSuffix(pos);
 634         } else if (digitRadix == 10 &amp;&amp;
 635                    (reader.ch == &#39;e&#39; || reader.ch == &#39;E&#39; ||
 636                     reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39; ||
 637                     reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;)) {
 638             scanFractionAndSuffix(pos);
 639         } else {
 640             if (!seenValidDigit) {
 641                 switch (radix) {
 642                 case 2:
 643                     lexError(pos, Errors.InvalidBinaryNumber);
 644                     break;
 645                 case 16:
 646                     lexError(pos, Errors.InvalidHexNumber);
 647                     break;
 648                 }
 649             }
 650             if (reader.ch == &#39;l&#39; || reader.ch == &#39;L&#39;) {
 651                 reader.scanChar();
 652                 tk = TokenKind.LONGLITERAL;
 653             } else {
 654                 tk = TokenKind.INTLITERAL;
 655             }
 656         }
 657     }
 658 
 659     /** Read an identifier.
 660      */
 661     private void scanIdent() {
 662         boolean isJavaIdentifierPart;
 663         char high;
 664         reader.putChar(true);
 665         do {
 666             switch (reader.ch) {
 667             case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
 668             case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
 669             case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
 670             case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
 671             case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
 672             case &#39;Z&#39;:
 673             case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;:
 674             case &#39;f&#39;: case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;:
 675             case &#39;k&#39;: case &#39;l&#39;: case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;:
 676             case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;:
 677             case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;:
 678             case &#39;z&#39;:
 679             case &#39;$&#39;: case &#39;_&#39;:
 680             case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
 681             case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
 682                 break;
 683             case &#39;\u0000&#39;: case &#39;\u0001&#39;: case &#39;\u0002&#39;: case &#39;\u0003&#39;:
 684             case &#39;\u0004&#39;: case &#39;\u0005&#39;: case &#39;\u0006&#39;: case &#39;\u0007&#39;:
 685             case &#39;\u0008&#39;: case &#39;\u000E&#39;: case &#39;\u000F&#39;: case &#39;\u0010&#39;:
 686             case &#39;\u0011&#39;: case &#39;\u0012&#39;: case &#39;\u0013&#39;: case &#39;\u0014&#39;:
 687             case &#39;\u0015&#39;: case &#39;\u0016&#39;: case &#39;\u0017&#39;:
 688             case &#39;\u0018&#39;: case &#39;\u0019&#39;: case &#39;\u001B&#39;:
 689             case &#39;\u007F&#39;:
 690                 reader.scanChar();
 691                 continue;
 692             case &#39;\u001A&#39;: // EOI is also a legal identifier part
 693                 if (reader.bp &gt;= reader.buflen) {
 694                     name = reader.name();
 695                     tk = tokens.lookupKind(name);
 696                     return;
 697                 }
 698                 reader.scanChar();
 699                 continue;
 700             default:
 701                 if (reader.ch &lt; &#39;\u0080&#39;) {
 702                     // all ASCII range chars already handled, above
 703                     isJavaIdentifierPart = false;
 704                 } else {
 705                     if (Character.isIdentifierIgnorable(reader.ch)) {
 706                         reader.scanChar();
 707                         continue;
 708                     } else {
 709                         int codePoint = reader.peekSurrogates();
 710                         if (codePoint &gt;= 0) {
 711                             if (isJavaIdentifierPart = Character.isJavaIdentifierPart(codePoint)) {
 712                                 reader.putChar(true);
 713                             }
 714                         } else {
 715                             isJavaIdentifierPart = Character.isJavaIdentifierPart(reader.ch);
 716                         }
 717                     }
 718                 }
 719                 if (!isJavaIdentifierPart) {
 720                     name = reader.name();
 721                     tk = tokens.lookupKind(name);
 722                     return;
 723                 }
 724             }
 725             reader.putChar(true);
 726         } while (true);
 727     }
 728 
 729     /** Return true if reader.ch can be part of an operator.
 730      */
 731     private boolean isSpecial(char ch) {
 732         switch (ch) {
 733         case &#39;!&#39;: case &#39;%&#39;: case &#39;&amp;&#39;: case &#39;*&#39;: case &#39;?&#39;:
 734         case &#39;+&#39;: case &#39;-&#39;: case &#39;:&#39;: case &#39;&lt;&#39;: case &#39;=&#39;:
 735         case &#39;&gt;&#39;: case &#39;^&#39;: case &#39;|&#39;: case &#39;~&#39;:
 736         case &#39;@&#39;:
 737             return true;
 738         default:
 739             return false;
 740         }
 741     }
 742 
 743     /** Read longest possible sequence of special characters and convert
 744      *  to token.
 745      */
 746     private void scanOperator() {
 747         while (true) {
 748             reader.putChar(false);
 749             Name newname = reader.name();
 750             TokenKind tk1 = tokens.lookupKind(newname);
 751             if (tk1 == TokenKind.IDENTIFIER) {
 752                 reader.sp--;
 753                 break;
 754             }
 755             tk = tk1;
 756             reader.scanChar();
 757             if (!isSpecial(reader.ch)) break;
 758         }
 759     }
 760 
 761     /** Read token.
 762      */
 763     public Token readToken() {
 764 
 765         reader.sp = 0;
 766         name = null;
 767         radix = 0;
 768 
 769         int pos = 0;
 770         int endPos = 0;
 771         List&lt;Comment&gt; comments = null;
 772 
 773         try {
 774             loop: while (true) {
 775                 pos = reader.bp;
 776                 switch (reader.ch) {
 777                 case &#39; &#39;: // (Spec 3.6)
 778                 case &#39;\t&#39;: // (Spec 3.6)
 779                 case FF: // (Spec 3.6)
 780                     do {
 781                         reader.scanChar();
 782                     } while (reader.ch == &#39; &#39; || reader.ch == &#39;\t&#39; || reader.ch == FF);
 783                     processWhiteSpace(pos, reader.bp);
 784                     break;
 785                 case LF: // (Spec 3.4)
 786                     reader.scanChar();
 787                     processLineTerminator(pos, reader.bp);
 788                     break;
 789                 case CR: // (Spec 3.4)
 790                     reader.scanChar();
 791                     if (reader.ch == LF) {
 792                         reader.scanChar();
 793                     }
 794                     processLineTerminator(pos, reader.bp);
 795                     break;
 796                 case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
 797                 case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
 798                 case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
 799                 case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
 800                 case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
 801                 case &#39;Z&#39;:
 802                 case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;:
 803                 case &#39;f&#39;: case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;:
 804                 case &#39;k&#39;: case &#39;l&#39;: case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;:
 805                 case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;:
 806                 case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;:
 807                 case &#39;z&#39;:
 808                 case &#39;$&#39;: case &#39;_&#39;:
 809                     scanIdent();
 810                     break loop;
 811                 case &#39;0&#39;:
 812                     reader.scanChar();
 813                     if (reader.ch == &#39;x&#39; || reader.ch == &#39;X&#39;) {
 814                         reader.scanChar();
 815                         skipIllegalUnderscores();
 816                         scanNumber(pos, 16);
 817                     } else if (reader.ch == &#39;b&#39; || reader.ch == &#39;B&#39;) {
 818                         reader.scanChar();
 819                         skipIllegalUnderscores();
 820                         scanNumber(pos, 2);
 821                     } else {
 822                         reader.putChar(&#39;0&#39;);
 823                         if (reader.ch == &#39;_&#39;) {
 824                             int savePos = reader.bp;
 825                             do {
 826                                 reader.scanChar();
 827                             } while (reader.ch == &#39;_&#39;);
 828                             if (reader.digit(pos, 10) &lt; 0) {
 829                                 lexError(savePos, Errors.IllegalUnderscore);
 830                             }
 831                         }
 832                         scanNumber(pos, 8);
 833                     }
 834                     break loop;
 835                 case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
 836                 case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
 837                     scanNumber(pos, 10);
 838                     break loop;
 839                 case &#39;.&#39;:
 840                     reader.scanChar();
 841                     if (reader.digit(pos, 10) &gt;= 0) {
 842                         reader.putChar(&#39;.&#39;);
 843                         scanFractionAndSuffix(pos);
 844                     } else if (reader.ch == &#39;.&#39;) {
 845                         int savePos = reader.bp;
 846                         reader.putChar(&#39;.&#39;); reader.putChar(&#39;.&#39;, true);
 847                         if (reader.ch == &#39;.&#39;) {
 848                             reader.scanChar();
 849                             reader.putChar(&#39;.&#39;);
 850                             tk = TokenKind.ELLIPSIS;
 851                         } else {
 852                             lexError(savePos, Errors.IllegalDot);
 853                         }
 854                     } else {
 855                         tk = TokenKind.DOT;
 856                     }
 857                     break loop;
 858                 case &#39;,&#39;:
 859                     reader.scanChar(); tk = TokenKind.COMMA; break loop;
 860                 case &#39;;&#39;:
 861                     reader.scanChar(); tk = TokenKind.SEMI; break loop;
 862                 case &#39;(&#39;:
 863                     reader.scanChar(); tk = TokenKind.LPAREN; break loop;
 864                 case &#39;)&#39;:
 865                     reader.scanChar(); tk = TokenKind.RPAREN; break loop;
 866                 case &#39;[&#39;:
 867                     reader.scanChar(); tk = TokenKind.LBRACKET; break loop;
 868                 case &#39;]&#39;:
 869                     reader.scanChar(); tk = TokenKind.RBRACKET; break loop;
 870                 case &#39;{&#39;:
 871                     reader.scanChar(); tk = TokenKind.LBRACE; break loop;
 872                 case &#39;}&#39;:
 873                     reader.scanChar(); tk = TokenKind.RBRACE; break loop;
 874                 case &#39;/&#39;:
 875                     reader.scanChar();
 876                     if (reader.ch == &#39;/&#39;) {
 877                         do {
 878                             reader.scanCommentChar();
 879                         } while (reader.ch != CR &amp;&amp; reader.ch != LF &amp;&amp; reader.bp &lt; reader.buflen);
 880                         if (reader.bp &lt; reader.buflen) {
 881                             comments = addComment(comments, processComment(pos, reader.bp, CommentStyle.LINE));
 882                         }
 883                         break;
 884                     } else if (reader.ch == &#39;*&#39;) {
 885                         boolean isEmpty = false;
 886                         reader.scanChar();
 887                         CommentStyle style;
 888                         if (reader.ch == &#39;*&#39;) {
 889                             style = CommentStyle.JAVADOC;
 890                             reader.scanCommentChar();
 891                             if (reader.ch == &#39;/&#39;) {
 892                                 isEmpty = true;
 893                             }
 894                         } else {
 895                             style = CommentStyle.BLOCK;
 896                         }
 897                         while (!isEmpty &amp;&amp; reader.bp &lt; reader.buflen) {
 898                             if (reader.ch == &#39;*&#39;) {
 899                                 reader.scanChar();
 900                                 if (reader.ch == &#39;/&#39;) break;
 901                             } else {
 902                                 reader.scanCommentChar();
 903                             }
 904                         }
 905                         if (reader.ch == &#39;/&#39;) {
 906                             reader.scanChar();
 907                             comments = addComment(comments, processComment(pos, reader.bp, style));
 908                             break;
 909                         } else {
 910                             lexError(pos, Errors.UnclosedComment);
 911                             break loop;
 912                         }
 913                     } else if (reader.ch == &#39;=&#39;) {
 914                         tk = TokenKind.SLASHEQ;
 915                         reader.scanChar();
 916                     } else {
 917                         tk = TokenKind.SLASH;
 918                     }
 919                     break loop;
 920                 case &#39;\&#39;&#39;:
 921                     reader.scanChar();
 922                     if (reader.ch == &#39;\&#39;&#39;) {
 923                         lexError(pos, Errors.EmptyCharLit);
 924                         reader.scanChar();
 925                     } else {
 926                         if (isEOLN())
 927                             lexError(pos, Errors.IllegalLineEndInCharLit);
 928                         scanLitChar(pos, true, false);
 929                         if (reader.ch == &#39;\&#39;&#39;) {
 930                             reader.scanChar();
 931                             tk = TokenKind.CHARLITERAL;
 932                         } else {
 933                             lexError(pos, Errors.UnclosedCharLit);
 934                         }
 935                     }
 936                     break loop;
 937                 case &#39;\&quot;&#39;:
 938                     scanString(pos);
 939                     break loop;
 940                 default:
 941                     if (isSpecial(reader.ch)) {
 942                         scanOperator();
 943                     } else {
 944                         boolean isJavaIdentifierStart;
 945                         int codePoint = -1;
 946                         if (reader.ch &lt; &#39;\u0080&#39;) {
 947                             // all ASCII range chars already handled, above
 948                             isJavaIdentifierStart = false;
 949                         } else {
 950                             codePoint = reader.peekSurrogates();
 951                             if (codePoint &gt;= 0) {
 952                                 if (isJavaIdentifierStart = Character.isJavaIdentifierStart(codePoint)) {
 953                                     reader.putChar(true);
 954                                 }
 955                             } else {
 956                                 isJavaIdentifierStart = Character.isJavaIdentifierStart(reader.ch);
 957                             }
 958                         }
 959                         if (isJavaIdentifierStart) {
 960                             scanIdent();
 961                         } else if (reader.digit(pos, 10) &gt;= 0) {
 962                             scanNumber(pos, 10);
 963                         } else if (reader.bp == reader.buflen || reader.ch == EOI &amp;&amp; reader.bp + 1 == reader.buflen) { // JLS 3.5
 964                             tk = TokenKind.EOF;
 965                             pos = reader.realLength;
 966                         } else {
 967                             String arg;
 968 
 969                             if (codePoint &gt;= 0) {
 970                                 char high = reader.ch;
 971                                 reader.scanChar();
 972                                 arg = String.format(&quot;\\u%04x\\u%04x&quot;, (int) high, (int)reader.ch);
 973                             } else {
 974                                 arg = (32 &lt; reader.ch &amp;&amp; reader.ch &lt; 127) ?
 975                                                 String.format(&quot;%s&quot;, reader.ch) :
 976                                                 String.format(&quot;\\u%04x&quot;, (int)reader.ch);
 977                             }
 978                             lexError(pos, Errors.IllegalChar(arg));
 979                             reader.scanChar();
 980                         }
 981                     }
 982                     break loop;
 983                 }
 984             }
 985             endPos = reader.bp;
 986             switch (tk.tag) {
 987                 case DEFAULT: return new Token(tk, pos, endPos, comments);
 988                 case NAMED: return new NamedToken(tk, pos, endPos, name, comments);
 989                 case STRING: {
 990                     // Get characters from string buffer.
 991                     String string = reader.chars();
 992                     // If a text block.
 993                     if (isTextBlock &amp;&amp; TextBlockSupport.hasSupport()) {
 994                         // Verify that the incidental indentation is consistent.
 995                         if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {
 996                             Set&lt;TextBlockSupport.WhitespaceChecks&gt; checks =
 997                                     TextBlockSupport.checkWhitespace(string);
 998                             if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {
 999                                 lexWarning(LintCategory.TEXT_BLOCKS, pos,
1000                                         Warnings.InconsistentWhiteSpaceIndentation);
1001                             }
1002                             if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {
1003                                 lexWarning(LintCategory.TEXT_BLOCKS, pos,
1004                                         Warnings.TrailingWhiteSpaceWillBeRemoved);
1005                             }
1006                         }
1007                         // Remove incidental indentation.
1008                         try {
1009                             string = TextBlockSupport.stripIndent(string);
1010                         } catch (Exception ex) {
1011                             // Error already reported, just use unstripped string.
1012                         }
1013                     }
1014                     // Translate escape sequences if present.
1015                     if (hasEscapeSequences &amp;&amp; TextBlockSupport.hasSupport()) {
1016                         try {
1017                             string = TextBlockSupport.translateEscapes(string);
1018                         } catch (Exception ex) {
1019                             // Error already reported, just use untranslated string.
1020                         }
1021                     }
1022                     // Build string token.
1023                     return new StringToken(tk, pos, endPos, string, comments);
1024                 }
1025                 case NUMERIC: return new NumericToken(tk, pos, endPos, reader.chars(), radix, comments);
1026                 default: throw new AssertionError();
1027             }
1028         }
1029         finally {
1030             if (scannerDebug) {
1031                     System.out.println(&quot;nextToken(&quot; + pos
1032                                        + &quot;,&quot; + endPos + &quot;)=|&quot; +
1033                                        new String(reader.getRawCharacters(pos, endPos))
1034                                        + &quot;|&quot;);
1035             }
1036         }
1037     }
1038     //where
1039         List&lt;Comment&gt; addComment(List&lt;Comment&gt; comments, Comment comment) {
1040             return comments == null ?
1041                     List.of(comment) :
1042                     comments.prepend(comment);
1043         }
1044 
1045     /** Return the position where a lexical error occurred;
1046      */
1047     public int errPos() {
1048         return errPos;
1049     }
1050 
1051     /** Set the position where a lexical error occurred;
1052      */
1053     public void errPos(int pos) {
1054         errPos = pos;
1055     }
1056 
1057     /**
1058      * Called when a complete comment has been scanned. pos and endPos
1059      * will mark the comment boundary.
1060      */
1061     protected Tokens.Comment processComment(int pos, int endPos, CommentStyle style) {
1062         if (scannerDebug)
1063             System.out.println(&quot;processComment(&quot; + pos
1064                                + &quot;,&quot; + endPos + &quot;,&quot; + style + &quot;)=|&quot;
1065                                + new String(reader.getRawCharacters(pos, endPos))
1066                                + &quot;|&quot;);
1067         char[] buf = reader.getRawCharacters(pos, endPos);
1068         return new BasicComment&lt;&gt;(new UnicodeReader(fac, buf, buf.length), style);
1069     }
1070 
1071     /**
1072      * Called when a complete whitespace run has been scanned. pos and endPos
1073      * will mark the whitespace boundary.
1074      */
1075     protected void processWhiteSpace(int pos, int endPos) {
1076         if (scannerDebug)
1077             System.out.println(&quot;processWhitespace(&quot; + pos
1078                                + &quot;,&quot; + endPos + &quot;)=|&quot; +
1079                                new String(reader.getRawCharacters(pos, endPos))
1080                                + &quot;|&quot;);
1081     }
1082 
1083     /**
1084      * Called when a line terminator has been processed.
1085      */
1086     protected void processLineTerminator(int pos, int endPos) {
1087         if (scannerDebug)
1088             System.out.println(&quot;processTerminator(&quot; + pos
1089                                + &quot;,&quot; + endPos + &quot;)=|&quot; +
1090                                new String(reader.getRawCharacters(pos, endPos))
1091                                + &quot;|&quot;);
1092     }
1093 
1094     /** Build a map for translating between line numbers and
1095      * positions in the input.
1096      *
1097      * @return a LineMap */
1098     public Position.LineMap getLineMap() {
1099         return Position.makeLineMap(reader.getRawCharacters(), reader.buflen, false);
1100     }
1101 
1102 
1103     /**
1104     * Scan a documentation comment; determine if a deprecated tag is present.
1105     * Called once the initial /, * have been skipped, positioned at the second *
1106     * (which is treated as the beginning of the first line).
1107     * Stops positioned at the closing &#39;/&#39;.
1108     */
1109     protected static class BasicComment&lt;U extends UnicodeReader&gt; implements Comment {
1110 
1111         CommentStyle cs;
1112         U comment_reader;
1113 
1114         protected boolean deprecatedFlag = false;
1115         protected boolean scanned = false;
1116 
1117         protected BasicComment(U comment_reader, CommentStyle cs) {
1118             this.comment_reader = comment_reader;
1119             this.cs = cs;
1120         }
1121 
1122         public String getText() {
1123             return null;
1124         }
1125 
1126         public int getSourcePos(int pos) {
1127             return -1;
1128         }
1129 
1130         public CommentStyle getStyle() {
1131             return cs;
1132         }
1133 
1134         public boolean isDeprecated() {
1135             if (!scanned &amp;&amp; cs == CommentStyle.JAVADOC) {
1136                 scanDocComment();
1137             }
1138             return deprecatedFlag;
1139         }
1140 
1141         @SuppressWarnings(&quot;fallthrough&quot;)
1142         protected void scanDocComment() {
1143             try {
1144                 boolean deprecatedPrefix = false;
1145 
1146                 comment_reader.bp += 3; // &#39;/**&#39;
1147                 comment_reader.ch = comment_reader.buf[comment_reader.bp];
1148 
1149                 forEachLine:
1150                 while (comment_reader.bp &lt; comment_reader.buflen) {
1151 
1152                     // Skip optional WhiteSpace at beginning of line
1153                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; (comment_reader.ch == &#39; &#39; || comment_reader.ch == &#39;\t&#39; || comment_reader.ch == FF)) {
1154                         comment_reader.scanCommentChar();
1155                     }
1156 
1157                     // Skip optional consecutive Stars
1158                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; comment_reader.ch == &#39;*&#39;) {
1159                         comment_reader.scanCommentChar();
1160                         if (comment_reader.ch == &#39;/&#39;) {
1161                             return;
1162                         }
1163                     }
1164 
1165                     // Skip optional WhiteSpace after Stars
1166                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; (comment_reader.ch == &#39; &#39; || comment_reader.ch == &#39;\t&#39; || comment_reader.ch == FF)) {
1167                         comment_reader.scanCommentChar();
1168                     }
1169 
1170                     deprecatedPrefix = false;
1171                     // At beginning of line in the JavaDoc sense.
1172                     if (!deprecatedFlag) {
1173                         String deprecated = &quot;@deprecated&quot;;
1174                         int i = 0;
1175                         while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; comment_reader.ch == deprecated.charAt(i)) {
1176                             comment_reader.scanCommentChar();
1177                             i++;
1178                             if (i == deprecated.length()) {
1179                                 deprecatedPrefix = true;
1180                                 break;
1181                             }
1182                         }
1183                     }
1184 
1185                     if (deprecatedPrefix &amp;&amp; comment_reader.bp &lt; comment_reader.buflen) {
1186                         if (Character.isWhitespace(comment_reader.ch)) {
1187                             deprecatedFlag = true;
1188                         } else if (comment_reader.ch == &#39;*&#39;) {
1189                             comment_reader.scanCommentChar();
1190                             if (comment_reader.ch == &#39;/&#39;) {
1191                                 deprecatedFlag = true;
1192                                 return;
1193                             }
1194                         }
1195                     }
1196 
1197                     // Skip rest of line
1198                     while (comment_reader.bp &lt; comment_reader.buflen) {
1199                         switch (comment_reader.ch) {
1200                             case &#39;*&#39;:
1201                                 comment_reader.scanCommentChar();
1202                                 if (comment_reader.ch == &#39;/&#39;) {
1203                                     return;
1204                                 }
1205                                 break;
1206                             case CR: // (Spec 3.4)
1207                                 comment_reader.scanCommentChar();
1208                                 if (comment_reader.ch != LF) {
1209                                     continue forEachLine;
1210                                 }
1211                             /* fall through to LF case */
1212                             case LF: // (Spec 3.4)
1213                                 comment_reader.scanCommentChar();
1214                                 continue forEachLine;
1215                             default:
1216                                 comment_reader.scanCommentChar();
1217                         }
1218                     } // rest of line
1219                 } // forEachLine
1220                 return;
1221             } finally {
1222                 scanned = true;
1223             }
1224         }
1225     }
1226 }
    </pre>
  </body>
</html>
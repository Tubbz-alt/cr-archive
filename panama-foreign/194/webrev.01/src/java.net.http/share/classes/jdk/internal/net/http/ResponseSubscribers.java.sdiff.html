<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.net.http/share/classes/jdk/internal/net/http/ResponseSubscribers.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ResponseBodyHandlers.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../java.security.jgss/share/classes/sun/security/krb5/KrbKdcRep.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.net.http/share/classes/jdk/internal/net/http/ResponseSubscribers.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.net.http;
  27 
  28 import java.io.BufferedReader;
  29 import java.io.FilePermission;
  30 import java.io.IOException;
  31 import java.io.InputStream;
  32 import java.io.InputStreamReader;
  33 import java.nio.ByteBuffer;
  34 import java.nio.channels.FileChannel;
  35 import java.nio.charset.Charset;
  36 import java.nio.file.OpenOption;
  37 import java.nio.file.Path;

  38 import java.security.AccessController;

  39 import java.security.PrivilegedActionException;
  40 import java.security.PrivilegedExceptionAction;
  41 import java.util.ArrayList;
  42 import java.util.Iterator;
  43 import java.util.List;
  44 import java.util.Objects;
  45 import java.util.Optional;
  46 import java.util.concurrent.ArrayBlockingQueue;
  47 import java.util.concurrent.BlockingQueue;
  48 import java.util.concurrent.CompletableFuture;
  49 import java.util.concurrent.CompletionStage;
  50 import java.util.concurrent.Executor;
  51 import java.util.concurrent.Flow;
  52 import java.util.concurrent.Flow.Subscriber;
  53 import java.util.concurrent.Flow.Subscription;
  54 import java.util.concurrent.atomic.AtomicBoolean;
  55 import java.util.concurrent.atomic.AtomicReference;
  56 import java.util.function.Consumer;
  57 import java.util.function.Function;
  58 import java.util.stream.Stream;
</pre>
<hr />
<pre>
 155         public void onComplete() {
 156             consumer.accept(Optional.empty());
 157             result.complete(null);
 158         }
 159 
 160     }
 161 
 162     /**
 163      * A Subscriber that writes the flow of data to a given file.
 164      *
 165      * Privileged actions are performed within a limited doPrivileged that only
 166      * asserts the specific, write, file permissions that were checked during
 167      * the construction of this PathSubscriber.
 168      */
 169     public static class PathSubscriber implements TrustedSubscriber&lt;Path&gt; {
 170 
 171         private static final FilePermission[] EMPTY_FILE_PERMISSIONS = new FilePermission[0];
 172 
 173         private final Path file;
 174         private final OpenOption[] options;

 175         private final FilePermission[] filePermissions;

 176         private final CompletableFuture&lt;Path&gt; result = new MinimalFuture&lt;&gt;();
 177 
 178         private final AtomicBoolean subscribed = new AtomicBoolean();
 179         private volatile Flow.Subscription subscription;
 180         private volatile FileChannel out;
 181 
 182         private static final String pathForSecurityCheck(Path path) {
 183             return path.toFile().getPath();
 184         }
 185 
 186         /**
 187          * Factory for creating PathSubscriber.
 188          *
 189          * Permission checks are performed here before construction of the
 190          * PathSubscriber. Permission checking and construction are deliberately
 191          * and tightly co-located.
 192          */
 193         public static PathSubscriber create(Path file,
 194                                             List&lt;OpenOption&gt; options) {
<span class="line-removed"> 195             FilePermission filePermission = null;</span>
 196             SecurityManager sm = System.getSecurityManager();

 197             if (sm != null) {
<span class="line-modified"> 198                 String fn = pathForSecurityCheck(file);</span>
<span class="line-modified"> 199                 FilePermission writePermission = new FilePermission(fn, &quot;write&quot;);</span>
<span class="line-modified"> 200                 sm.checkPermission(writePermission);</span>
<span class="line-modified"> 201                 filePermission = writePermission;</span>




 202             }
<span class="line-modified"> 203             return new PathSubscriber(file, options, filePermission);</span>



 204         }
 205 
 206         // pp so handler implementations in the same package can construct
 207         /*package-private*/ PathSubscriber(Path file,
 208                                            List&lt;OpenOption&gt; options,

 209                                            FilePermission... filePermissions) {
 210             this.file = file;
 211             this.options = options.stream().toArray(OpenOption[]::new);
<span class="line-modified"> 212             this.filePermissions =</span>
<span class="line-modified"> 213                     filePermissions == null ? EMPTY_FILE_PERMISSIONS : filePermissions;</span>











 214         }
 215 
 216         @Override
 217         public void onSubscribe(Flow.Subscription subscription) {
 218             Objects.requireNonNull(subscription);
 219             if (!subscribed.compareAndSet(false, true)) {
 220                 subscription.cancel();
 221                 return;
 222             }
 223 
 224             this.subscription = subscription;
<span class="line-modified"> 225             if (System.getSecurityManager() == null) {</span>
 226                 try {
 227                     out = FileChannel.open(file, options);
 228                 } catch (IOException ioe) {
 229                     result.completeExceptionally(ioe);

 230                     return;
 231                 }
 232             } else {
 233                 try {
 234                     PrivilegedExceptionAction&lt;FileChannel&gt; pa =
 235                             () -&gt; FileChannel.open(file, options);
<span class="line-modified"> 236                     out = AccessController.doPrivileged(pa, null, filePermissions);</span>


 237                 } catch (PrivilegedActionException pae) {
 238                     Throwable t = pae.getCause() != null ? pae.getCause() : pae;
 239                     result.completeExceptionally(t);
 240                     subscription.cancel();
 241                     return;




 242                 }
 243             }
 244             subscription.request(1);
 245         }
 246 
 247         @Override
 248         public void onNext(List&lt;ByteBuffer&gt; items) {
 249             try {
 250                 out.write(items.toArray(Utils.EMPTY_BB_ARRAY));
 251             } catch (IOException ex) {
<span class="line-modified"> 252                 Utils.close(out);</span>
 253                 subscription.cancel();
 254                 result.completeExceptionally(ex);
 255             }
 256             subscription.request(1);
 257         }
 258 
 259         @Override
 260         public void onError(Throwable e) {
 261             result.completeExceptionally(e);
<span class="line-modified"> 262             Utils.close(out);</span>
 263         }
 264 
 265         @Override
 266         public void onComplete() {
<span class="line-modified"> 267             Utils.close(out);</span>
 268             result.complete(file);
 269         }
 270 
 271         @Override
 272         public CompletionStage&lt;Path&gt; getBody() {
 273             return result;
 274         }
















 275     }
 276 
 277     public static class ByteArraySubscriber&lt;T&gt; implements TrustedSubscriber&lt;T&gt; {
 278         private final Function&lt;byte[], T&gt; finisher;
 279         private final CompletableFuture&lt;T&gt; result = new MinimalFuture&lt;&gt;();
 280         private final List&lt;ByteBuffer&gt; received = new ArrayList&lt;&gt;();
 281 
 282         private volatile Flow.Subscription subscription;
 283 
 284         public ByteArraySubscriber(Function&lt;byte[],T&gt; finisher) {
 285             this.finisher = finisher;
 286         }
 287 
 288         @Override
 289         public void onSubscribe(Flow.Subscription subscription) {
 290             if (this.subscription != null) {
 291                 subscription.cancel();
 292                 return;
 293             }
 294             this.subscription = subscription;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.net.http;
  27 
  28 import java.io.BufferedReader;
  29 import java.io.FilePermission;
  30 import java.io.IOException;
  31 import java.io.InputStream;
  32 import java.io.InputStreamReader;
  33 import java.nio.ByteBuffer;
  34 import java.nio.channels.FileChannel;
  35 import java.nio.charset.Charset;
  36 import java.nio.file.OpenOption;
  37 import java.nio.file.Path;
<span class="line-added">  38 import java.security.AccessControlContext;</span>
  39 import java.security.AccessController;
<span class="line-added">  40 import java.security.PrivilegedAction;</span>
  41 import java.security.PrivilegedActionException;
  42 import java.security.PrivilegedExceptionAction;
  43 import java.util.ArrayList;
  44 import java.util.Iterator;
  45 import java.util.List;
  46 import java.util.Objects;
  47 import java.util.Optional;
  48 import java.util.concurrent.ArrayBlockingQueue;
  49 import java.util.concurrent.BlockingQueue;
  50 import java.util.concurrent.CompletableFuture;
  51 import java.util.concurrent.CompletionStage;
  52 import java.util.concurrent.Executor;
  53 import java.util.concurrent.Flow;
  54 import java.util.concurrent.Flow.Subscriber;
  55 import java.util.concurrent.Flow.Subscription;
  56 import java.util.concurrent.atomic.AtomicBoolean;
  57 import java.util.concurrent.atomic.AtomicReference;
  58 import java.util.function.Consumer;
  59 import java.util.function.Function;
  60 import java.util.stream.Stream;
</pre>
<hr />
<pre>
 157         public void onComplete() {
 158             consumer.accept(Optional.empty());
 159             result.complete(null);
 160         }
 161 
 162     }
 163 
 164     /**
 165      * A Subscriber that writes the flow of data to a given file.
 166      *
 167      * Privileged actions are performed within a limited doPrivileged that only
 168      * asserts the specific, write, file permissions that were checked during
 169      * the construction of this PathSubscriber.
 170      */
 171     public static class PathSubscriber implements TrustedSubscriber&lt;Path&gt; {
 172 
 173         private static final FilePermission[] EMPTY_FILE_PERMISSIONS = new FilePermission[0];
 174 
 175         private final Path file;
 176         private final OpenOption[] options;
<span class="line-added"> 177         private final AccessControlContext acc;</span>
 178         private final FilePermission[] filePermissions;
<span class="line-added"> 179         private final boolean isDefaultFS;</span>
 180         private final CompletableFuture&lt;Path&gt; result = new MinimalFuture&lt;&gt;();
 181 
 182         private final AtomicBoolean subscribed = new AtomicBoolean();
 183         private volatile Flow.Subscription subscription;
 184         private volatile FileChannel out;
 185 
 186         private static final String pathForSecurityCheck(Path path) {
 187             return path.toFile().getPath();
 188         }
 189 
 190         /**
 191          * Factory for creating PathSubscriber.
 192          *
 193          * Permission checks are performed here before construction of the
 194          * PathSubscriber. Permission checking and construction are deliberately
 195          * and tightly co-located.
 196          */
 197         public static PathSubscriber create(Path file,
 198                                             List&lt;OpenOption&gt; options) {

 199             SecurityManager sm = System.getSecurityManager();
<span class="line-added"> 200             FilePermission filePermission = null;</span>
 201             if (sm != null) {
<span class="line-modified"> 202                 try {</span>
<span class="line-modified"> 203                     String fn = pathForSecurityCheck(file);</span>
<span class="line-modified"> 204                     FilePermission writePermission = new FilePermission(fn, &quot;write&quot;);</span>
<span class="line-modified"> 205                     sm.checkPermission(writePermission);</span>
<span class="line-added"> 206                     filePermission = writePermission;</span>
<span class="line-added"> 207                 } catch (UnsupportedOperationException ignored) {</span>
<span class="line-added"> 208                     // path not associated with the default file system provider</span>
<span class="line-added"> 209                 }</span>
 210             }
<span class="line-modified"> 211 </span>
<span class="line-added"> 212             assert filePermission == null || filePermission.getActions().equals(&quot;write&quot;);</span>
<span class="line-added"> 213             AccessControlContext acc = sm != null ? AccessController.getContext() : null;</span>
<span class="line-added"> 214             return new PathSubscriber(file, options, acc, filePermission);</span>
 215         }
 216 
 217         // pp so handler implementations in the same package can construct
 218         /*package-private*/ PathSubscriber(Path file,
 219                                            List&lt;OpenOption&gt; options,
<span class="line-added"> 220                                            AccessControlContext acc,</span>
 221                                            FilePermission... filePermissions) {
 222             this.file = file;
 223             this.options = options.stream().toArray(OpenOption[]::new);
<span class="line-modified"> 224             this.acc = acc;</span>
<span class="line-modified"> 225             this.filePermissions = filePermissions == null || filePermissions[0] == null</span>
<span class="line-added"> 226                             ? EMPTY_FILE_PERMISSIONS : filePermissions;</span>
<span class="line-added"> 227             this.isDefaultFS = isDefaultFS(file);</span>
<span class="line-added"> 228         }</span>
<span class="line-added"> 229 </span>
<span class="line-added"> 230         private static boolean isDefaultFS(Path file) {</span>
<span class="line-added"> 231             try {</span>
<span class="line-added"> 232                 file.toFile();</span>
<span class="line-added"> 233                 return true;</span>
<span class="line-added"> 234             } catch (UnsupportedOperationException uoe) {</span>
<span class="line-added"> 235                 return false;</span>
<span class="line-added"> 236             }</span>
 237         }
 238 
 239         @Override
 240         public void onSubscribe(Flow.Subscription subscription) {
 241             Objects.requireNonNull(subscription);
 242             if (!subscribed.compareAndSet(false, true)) {
 243                 subscription.cancel();
 244                 return;
 245             }
 246 
 247             this.subscription = subscription;
<span class="line-modified"> 248             if (acc == null) {</span>
 249                 try {
 250                     out = FileChannel.open(file, options);
 251                 } catch (IOException ioe) {
 252                     result.completeExceptionally(ioe);
<span class="line-added"> 253                     subscription.cancel();</span>
 254                     return;
 255                 }
 256             } else {
 257                 try {
 258                     PrivilegedExceptionAction&lt;FileChannel&gt; pa =
 259                             () -&gt; FileChannel.open(file, options);
<span class="line-modified"> 260                     out = isDefaultFS</span>
<span class="line-added"> 261                             ? AccessController.doPrivileged(pa, acc, filePermissions)</span>
<span class="line-added"> 262                             : AccessController.doPrivileged(pa, acc);</span>
 263                 } catch (PrivilegedActionException pae) {
 264                     Throwable t = pae.getCause() != null ? pae.getCause() : pae;
 265                     result.completeExceptionally(t);
 266                     subscription.cancel();
 267                     return;
<span class="line-added"> 268                 } catch (Exception e) {</span>
<span class="line-added"> 269                     result.completeExceptionally(e);</span>
<span class="line-added"> 270                     subscription.cancel();</span>
<span class="line-added"> 271                     return;</span>
 272                 }
 273             }
 274             subscription.request(1);
 275         }
 276 
 277         @Override
 278         public void onNext(List&lt;ByteBuffer&gt; items) {
 279             try {
 280                 out.write(items.toArray(Utils.EMPTY_BB_ARRAY));
 281             } catch (IOException ex) {
<span class="line-modified"> 282                 close();</span>
 283                 subscription.cancel();
 284                 result.completeExceptionally(ex);
 285             }
 286             subscription.request(1);
 287         }
 288 
 289         @Override
 290         public void onError(Throwable e) {
 291             result.completeExceptionally(e);
<span class="line-modified"> 292             close();</span>
 293         }
 294 
 295         @Override
 296         public void onComplete() {
<span class="line-modified"> 297             close();</span>
 298             result.complete(file);
 299         }
 300 
 301         @Override
 302         public CompletionStage&lt;Path&gt; getBody() {
 303             return result;
 304         }
<span class="line-added"> 305 </span>
<span class="line-added"> 306         private void close() {</span>
<span class="line-added"> 307             if (acc == null) {</span>
<span class="line-added"> 308                 Utils.close(out);</span>
<span class="line-added"> 309             } else {</span>
<span class="line-added"> 310                 PrivilegedAction&lt;Void&gt; pa = () -&gt; {</span>
<span class="line-added"> 311                     Utils.close(out);</span>
<span class="line-added"> 312                     return null;</span>
<span class="line-added"> 313                 };</span>
<span class="line-added"> 314                 if (isDefaultFS) {</span>
<span class="line-added"> 315                     AccessController.doPrivileged(pa, acc, filePermissions);</span>
<span class="line-added"> 316                 } else {</span>
<span class="line-added"> 317                     AccessController.doPrivileged(pa, acc);</span>
<span class="line-added"> 318                 }</span>
<span class="line-added"> 319             }</span>
<span class="line-added"> 320         }</span>
 321     }
 322 
 323     public static class ByteArraySubscriber&lt;T&gt; implements TrustedSubscriber&lt;T&gt; {
 324         private final Function&lt;byte[], T&gt; finisher;
 325         private final CompletableFuture&lt;T&gt; result = new MinimalFuture&lt;&gt;();
 326         private final List&lt;ByteBuffer&gt; received = new ArrayList&lt;&gt;();
 327 
 328         private volatile Flow.Subscription subscription;
 329 
 330         public ByteArraySubscriber(Function&lt;byte[],T&gt; finisher) {
 331             this.finisher = finisher;
 332         }
 333 
 334         @Override
 335         public void onSubscribe(Flow.Subscription subscription) {
 336             if (this.subscription != null) {
 337                 subscription.cancel();
 338                 return;
 339             }
 340             this.subscription = subscription;
</pre>
</td>
</tr>
</table>
<center><a href="ResponseBodyHandlers.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../java.security.jgss/share/classes/sun/security/krb5/KrbKdcRep.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
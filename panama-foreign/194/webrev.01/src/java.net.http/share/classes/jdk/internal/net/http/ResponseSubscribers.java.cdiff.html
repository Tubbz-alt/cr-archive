<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.net.http/share/classes/jdk/internal/net/http/ResponseSubscribers.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ResponseBodyHandlers.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../java.security.jgss/share/classes/sun/security/krb5/KrbKdcRep.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.net.http/share/classes/jdk/internal/net/http/ResponseSubscribers.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 33,11 ***</span>
<span class="line-new-header">--- 33,13 ---</span>
  import java.nio.ByteBuffer;
  import java.nio.channels.FileChannel;
  import java.nio.charset.Charset;
  import java.nio.file.OpenOption;
  import java.nio.file.Path;
<span class="line-added">+ import java.security.AccessControlContext;</span>
  import java.security.AccessController;
<span class="line-added">+ import java.security.PrivilegedAction;</span>
  import java.security.PrivilegedActionException;
  import java.security.PrivilegedExceptionAction;
  import java.util.ArrayList;
  import java.util.Iterator;
  import java.util.List;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 170,11 ***</span>
<span class="line-new-header">--- 172,13 ---</span>
  
          private static final FilePermission[] EMPTY_FILE_PERMISSIONS = new FilePermission[0];
  
          private final Path file;
          private final OpenOption[] options;
<span class="line-added">+         private final AccessControlContext acc;</span>
          private final FilePermission[] filePermissions;
<span class="line-added">+         private final boolean isDefaultFS;</span>
          private final CompletableFuture&lt;Path&gt; result = new MinimalFuture&lt;&gt;();
  
          private final AtomicBoolean subscribed = new AtomicBoolean();
          private volatile Flow.Subscription subscription;
          private volatile FileChannel out;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,29 ***</span>
           * PathSubscriber. Permission checking and construction are deliberately
           * and tightly co-located.
           */
          public static PathSubscriber create(Path file,
                                              List&lt;OpenOption&gt; options) {
<span class="line-removed">-             FilePermission filePermission = null;</span>
              SecurityManager sm = System.getSecurityManager();
              if (sm != null) {
<span class="line-modified">!                 String fn = pathForSecurityCheck(file);</span>
<span class="line-modified">!                 FilePermission writePermission = new FilePermission(fn, &quot;write&quot;);</span>
<span class="line-modified">!                 sm.checkPermission(writePermission);</span>
<span class="line-modified">!                 filePermission = writePermission;</span>
              }
<span class="line-modified">!             return new PathSubscriber(file, options, filePermission);</span>
          }
  
          // pp so handler implementations in the same package can construct
          /*package-private*/ PathSubscriber(Path file,
                                             List&lt;OpenOption&gt; options,
                                             FilePermission... filePermissions) {
              this.file = file;
              this.options = options.stream().toArray(OpenOption[]::new);
<span class="line-modified">!             this.filePermissions =</span>
<span class="line-modified">!                     filePermissions == null ? EMPTY_FILE_PERMISSIONS : filePermissions;</span>
          }
  
          @Override
          public void onSubscribe(Flow.Subscription subscription) {
              Objects.requireNonNull(subscription);
<span class="line-new-header">--- 194,48 ---</span>
           * PathSubscriber. Permission checking and construction are deliberately
           * and tightly co-located.
           */
          public static PathSubscriber create(Path file,
                                              List&lt;OpenOption&gt; options) {
              SecurityManager sm = System.getSecurityManager();
<span class="line-added">+             FilePermission filePermission = null;</span>
              if (sm != null) {
<span class="line-modified">!                 try {</span>
<span class="line-modified">!                     String fn = pathForSecurityCheck(file);</span>
<span class="line-modified">!                     FilePermission writePermission = new FilePermission(fn, &quot;write&quot;);</span>
<span class="line-modified">!                     sm.checkPermission(writePermission);</span>
<span class="line-added">+                     filePermission = writePermission;</span>
<span class="line-added">+                 } catch (UnsupportedOperationException ignored) {</span>
<span class="line-added">+                     // path not associated with the default file system provider</span>
<span class="line-added">+                 }</span>
              }
<span class="line-modified">! </span>
<span class="line-added">+             assert filePermission == null || filePermission.getActions().equals(&quot;write&quot;);</span>
<span class="line-added">+             AccessControlContext acc = sm != null ? AccessController.getContext() : null;</span>
<span class="line-added">+             return new PathSubscriber(file, options, acc, filePermission);</span>
          }
  
          // pp so handler implementations in the same package can construct
          /*package-private*/ PathSubscriber(Path file,
                                             List&lt;OpenOption&gt; options,
<span class="line-added">+                                            AccessControlContext acc,</span>
                                             FilePermission... filePermissions) {
              this.file = file;
              this.options = options.stream().toArray(OpenOption[]::new);
<span class="line-modified">!             this.acc = acc;</span>
<span class="line-modified">!             this.filePermissions = filePermissions == null || filePermissions[0] == null</span>
<span class="line-added">+                             ? EMPTY_FILE_PERMISSIONS : filePermissions;</span>
<span class="line-added">+             this.isDefaultFS = isDefaultFS(file);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private static boolean isDefaultFS(Path file) {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 file.toFile();</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             } catch (UnsupportedOperationException uoe) {</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             }</span>
          }
  
          @Override
          public void onSubscribe(Flow.Subscription subscription) {
              Objects.requireNonNull(subscription);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,60 ***</span>
                  subscription.cancel();
                  return;
              }
  
              this.subscription = subscription;
<span class="line-modified">!             if (System.getSecurityManager() == null) {</span>
                  try {
                      out = FileChannel.open(file, options);
                  } catch (IOException ioe) {
                      result.completeExceptionally(ioe);
                      return;
                  }
              } else {
                  try {
                      PrivilegedExceptionAction&lt;FileChannel&gt; pa =
                              () -&gt; FileChannel.open(file, options);
<span class="line-modified">!                     out = AccessController.doPrivileged(pa, null, filePermissions);</span>
                  } catch (PrivilegedActionException pae) {
                      Throwable t = pae.getCause() != null ? pae.getCause() : pae;
                      result.completeExceptionally(t);
                      subscription.cancel();
                      return;
                  }
              }
              subscription.request(1);
          }
  
          @Override
          public void onNext(List&lt;ByteBuffer&gt; items) {
              try {
                  out.write(items.toArray(Utils.EMPTY_BB_ARRAY));
              } catch (IOException ex) {
<span class="line-modified">!                 Utils.close(out);</span>
                  subscription.cancel();
                  result.completeExceptionally(ex);
              }
              subscription.request(1);
          }
  
          @Override
          public void onError(Throwable e) {
              result.completeExceptionally(e);
<span class="line-modified">!             Utils.close(out);</span>
          }
  
          @Override
          public void onComplete() {
<span class="line-modified">!             Utils.close(out);</span>
              result.complete(file);
          }
  
          @Override
          public CompletionStage&lt;Path&gt; getBody() {
              return result;
          }
      }
  
      public static class ByteArraySubscriber&lt;T&gt; implements TrustedSubscriber&lt;T&gt; {
          private final Function&lt;byte[], T&gt; finisher;
          private final CompletableFuture&lt;T&gt; result = new MinimalFuture&lt;&gt;();
<span class="line-new-header">--- 243,83 ---</span>
                  subscription.cancel();
                  return;
              }
  
              this.subscription = subscription;
<span class="line-modified">!             if (acc == null) {</span>
                  try {
                      out = FileChannel.open(file, options);
                  } catch (IOException ioe) {
                      result.completeExceptionally(ioe);
<span class="line-added">+                     subscription.cancel();</span>
                      return;
                  }
              } else {
                  try {
                      PrivilegedExceptionAction&lt;FileChannel&gt; pa =
                              () -&gt; FileChannel.open(file, options);
<span class="line-modified">!                     out = isDefaultFS</span>
<span class="line-added">+                             ? AccessController.doPrivileged(pa, acc, filePermissions)</span>
<span class="line-added">+                             : AccessController.doPrivileged(pa, acc);</span>
                  } catch (PrivilegedActionException pae) {
                      Throwable t = pae.getCause() != null ? pae.getCause() : pae;
                      result.completeExceptionally(t);
                      subscription.cancel();
                      return;
<span class="line-added">+                 } catch (Exception e) {</span>
<span class="line-added">+                     result.completeExceptionally(e);</span>
<span class="line-added">+                     subscription.cancel();</span>
<span class="line-added">+                     return;</span>
                  }
              }
              subscription.request(1);
          }
  
          @Override
          public void onNext(List&lt;ByteBuffer&gt; items) {
              try {
                  out.write(items.toArray(Utils.EMPTY_BB_ARRAY));
              } catch (IOException ex) {
<span class="line-modified">!                 close();</span>
                  subscription.cancel();
                  result.completeExceptionally(ex);
              }
              subscription.request(1);
          }
  
          @Override
          public void onError(Throwable e) {
              result.completeExceptionally(e);
<span class="line-modified">!             close();</span>
          }
  
          @Override
          public void onComplete() {
<span class="line-modified">!             close();</span>
              result.complete(file);
          }
  
          @Override
          public CompletionStage&lt;Path&gt; getBody() {
              return result;
          }
<span class="line-added">+ </span>
<span class="line-added">+         private void close() {</span>
<span class="line-added">+             if (acc == null) {</span>
<span class="line-added">+                 Utils.close(out);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 PrivilegedAction&lt;Void&gt; pa = () -&gt; {</span>
<span class="line-added">+                     Utils.close(out);</span>
<span class="line-added">+                     return null;</span>
<span class="line-added">+                 };</span>
<span class="line-added">+                 if (isDefaultFS) {</span>
<span class="line-added">+                     AccessController.doPrivileged(pa, acc, filePermissions);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     AccessController.doPrivileged(pa, acc);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
      }
  
      public static class ByteArraySubscriber&lt;T&gt; implements TrustedSubscriber&lt;T&gt; {
          private final Function&lt;byte[], T&gt; finisher;
          private final CompletableFuture&lt;T&gt; result = new MinimalFuture&lt;&gt;();
</pre>
<center><a href="ResponseBodyHandlers.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../java.security.jgss/share/classes/sun/security/krb5/KrbKdcRep.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
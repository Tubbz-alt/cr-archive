<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.net.http/share/classes/jdk/internal/net/http/ResponseBodyHandlers.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../java/net/http/HttpResponse.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ResponseSubscribers.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.net.http/share/classes/jdk/internal/net/http/ResponseBodyHandlers.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.net.http;
 27 
 28 import java.io.File;
 29 import java.io.FilePermission;
 30 import java.io.IOException;
 31 import java.io.UncheckedIOException;
 32 import java.net.URI;
 33 import java.nio.file.Files;
 34 import java.nio.file.OpenOption;
 35 import java.nio.file.Path;
 36 import java.nio.file.Paths;


 37 import java.util.List;
 38 import java.util.concurrent.CompletableFuture;
 39 import java.util.concurrent.ConcurrentMap;
 40 import java.util.function.Function;
<span class="line-removed"> 41 import java.net.http.HttpHeaders;</span>
 42 import java.net.http.HttpRequest;
 43 import java.net.http.HttpResponse;
 44 import java.net.http.HttpResponse.BodyHandler;
 45 import java.net.http.HttpResponse.ResponseInfo;
 46 import java.net.http.HttpResponse.BodySubscriber;
 47 import java.util.regex.Matcher;
 48 import java.util.regex.Pattern;
 49 import jdk.internal.net.http.ResponseSubscribers.PathSubscriber;
 50 import static java.util.regex.Pattern.CASE_INSENSITIVE;
 51 
 52 public final class ResponseBodyHandlers {
 53 
 54     private ResponseBodyHandlers() { }
 55 
 56     private static final String pathForSecurityCheck(Path path) {
 57         return path.toFile().getPath();
 58     }
 59 
 60     /**
 61      * A Path body handler.
 62      */
 63     public static class PathBodyHandler implements BodyHandler&lt;Path&gt;{
 64         private final Path file;
 65         private final List&lt;OpenOption&gt; openOptions;  // immutable list

 66         private final FilePermission filePermission;
 67 
 68         /**
 69          * Factory for creating PathBodyHandler.
 70          *
 71          * Permission checks are performed here before construction of the
 72          * PathBodyHandler. Permission checking and construction are
 73          * deliberately and tightly co-located.
 74          */
 75         public static PathBodyHandler create(Path file,
 76                                              List&lt;OpenOption&gt; openOptions) {
 77             FilePermission filePermission = null;
 78             SecurityManager sm = System.getSecurityManager();
 79             if (sm != null) {
<span class="line-modified"> 80                 String fn = pathForSecurityCheck(file);</span>
<span class="line-modified"> 81                 FilePermission writePermission = new FilePermission(fn, &quot;write&quot;);</span>
<span class="line-modified"> 82                 sm.checkPermission(writePermission);</span>
<span class="line-modified"> 83                 filePermission = writePermission;</span>




 84             }
<span class="line-modified"> 85             return new PathBodyHandler(file, openOptions, filePermission);</span>



 86         }
 87 
 88         private PathBodyHandler(Path file,
 89                                 List&lt;OpenOption&gt; openOptions,

 90                                 FilePermission filePermission) {
 91             this.file = file;
 92             this.openOptions = openOptions;

 93             this.filePermission = filePermission;
 94         }
 95 
 96         @Override
 97         public BodySubscriber&lt;Path&gt; apply(ResponseInfo responseInfo) {
<span class="line-modified"> 98             return new PathSubscriber(file, openOptions, filePermission);</span>
 99         }
100     }
101 
102     /** With push promise Map implementation */
103     public static class PushPromisesHandlerWithMap&lt;T&gt;
104         implements HttpResponse.PushPromiseHandler&lt;T&gt;
105     {
106         private final ConcurrentMap&lt;HttpRequest,CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;&gt; pushPromisesMap;
107         private final Function&lt;HttpRequest,BodyHandler&lt;T&gt;&gt; pushPromiseHandler;
108 
109         public PushPromisesHandlerWithMap(Function&lt;HttpRequest,BodyHandler&lt;T&gt;&gt; pushPromiseHandler,
110                                           ConcurrentMap&lt;HttpRequest,CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;&gt; pushPromisesMap) {
111             this.pushPromiseHandler = pushPromiseHandler;
112             this.pushPromisesMap = pushPromisesMap;
113         }
114 
115         @Override
116         public void applyPushPromise(
117                 HttpRequest initiatingRequest, HttpRequest pushRequest,
118                 Function&lt;BodyHandler&lt;T&gt;,CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;&gt; acceptor)
</pre>
<hr />
<pre>
132             int pushPort = pushRequestURI.getPort();
133             if (pushPort == -1 ) {
134                 if (&quot;https&quot;.equalsIgnoreCase(pushRequestURI.getScheme()))
135                     pushPort = 443;
136                 else
137                     pushPort = 80;
138             }
139             if (initiatingPort != pushPort)
140                 return;
141 
142             CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; cf =
143                     acceptor.apply(pushPromiseHandler.apply(pushRequest));
144             pushPromisesMap.put(pushRequest, cf);
145         }
146     }
147 
148     // Similar to Path body handler, but for file download.
149     public static class FileDownloadBodyHandler implements BodyHandler&lt;Path&gt; {
150         private final Path directory;
151         private final List&lt;OpenOption&gt; openOptions;

152         private final FilePermission[] filePermissions;  // may be null
153 
154         /**
155          * Factory for creating FileDownloadBodyHandler.
156          *
157          * Permission checks are performed here before construction of the
158          * FileDownloadBodyHandler. Permission checking and construction are
159          * deliberately and tightly co-located.
160          */
161         public static FileDownloadBodyHandler create(Path directory,
162                                                      List&lt;OpenOption&gt; openOptions) {








163             FilePermission filePermissions[] = null;
164             SecurityManager sm = System.getSecurityManager();
165             if (sm != null) {
<span class="line-removed">166                 String fn = pathForSecurityCheck(directory);</span>
167                 FilePermission writePermission = new FilePermission(fn, &quot;write&quot;);
168                 String writePathPerm = fn + File.separatorChar + &quot;*&quot;;
169                 FilePermission writeInDirPermission = new FilePermission(writePathPerm, &quot;write&quot;);
170                 sm.checkPermission(writeInDirPermission);
171                 FilePermission readPermission = new FilePermission(fn, &quot;read&quot;);
172                 sm.checkPermission(readPermission);
173 
174                 // read permission is only needed before determine the below checks
175                 // only write permission is required when downloading to the file
176                 filePermissions = new FilePermission[] { writePermission, writeInDirPermission };
177             }
178 
179             // existence, etc, checks must be after permission checks
180             if (Files.notExists(directory))
181                 throw new IllegalArgumentException(&quot;non-existent directory: &quot; + directory);
182             if (!Files.isDirectory(directory))
183                 throw new IllegalArgumentException(&quot;not a directory: &quot; + directory);
184             if (!Files.isWritable(directory))
185                 throw new IllegalArgumentException(&quot;non-writable directory: &quot; + directory);
186 
<span class="line-modified">187             return new FileDownloadBodyHandler(directory, openOptions, filePermissions);</span>
<span class="line-modified">188 </span>


189         }
190 
191         private FileDownloadBodyHandler(Path directory,
192                                        List&lt;OpenOption&gt; openOptions,

193                                        FilePermission... filePermissions) {
194             this.directory = directory;
195             this.openOptions = openOptions;

196             this.filePermissions = filePermissions;
197         }
198 
199         /** The &quot;attachment&quot; disposition-type and separator. */
200         static final String DISPOSITION_TYPE = &quot;attachment;&quot;;
201 
202         /** The &quot;filename&quot; parameter. */
203         static final Pattern FILENAME = Pattern.compile(&quot;filename\\s*=&quot;, CASE_INSENSITIVE);
204 
205         static final List&lt;String&gt; PROHIBITED = List.of(&quot;.&quot;, &quot;..&quot;, &quot;&quot;, &quot;~&quot; , &quot;|&quot;);
206 
207         static final UncheckedIOException unchecked(ResponseInfo rinfo,
208                                                     String msg) {
209             String s = String.format(&quot;%s in response [%d, %s]&quot;, msg, rinfo.statusCode(), rinfo.headers());
210             return new UncheckedIOException(new IOException(s));
211         }
212 
213         @Override
214         public BodySubscriber&lt;Path&gt; apply(ResponseInfo responseInfo) {
215             String dispoHeader = responseInfo.headers().firstValue(&quot;Content-Disposition&quot;)
</pre>
<hr />
<pre>
256             } else {  // token,
257                 if (filenameParam.contains(&quot; &quot;)) {  // space disallowed
258                     throw unchecked(responseInfo,
259                             &quot;unquoted space in Content-Disposition filename parameter&quot;);
260                 }
261             }
262 
263             if (PROHIBITED.contains(filenameParam)) {
264                 throw unchecked(responseInfo,
265                         &quot;Prohibited Content-Disposition filename parameter:&quot;
266                                 + filenameParam);
267             }
268 
269             Path file = Paths.get(directory.toString(), filenameParam);
270 
271             if (!file.startsWith(directory)) {
272                 throw unchecked(responseInfo,
273                         &quot;Resulting file, &quot; + file.toString() + &quot;, outside of given directory&quot;);
274             }
275 
<span class="line-modified">276             return new PathSubscriber(file, openOptions, filePermissions);</span>
277         }
278     }
279 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.net.http;
 27 
 28 import java.io.File;
 29 import java.io.FilePermission;
 30 import java.io.IOException;
 31 import java.io.UncheckedIOException;
 32 import java.net.URI;
 33 import java.nio.file.Files;
 34 import java.nio.file.OpenOption;
 35 import java.nio.file.Path;
 36 import java.nio.file.Paths;
<span class="line-added"> 37 import java.security.AccessControlContext;</span>
<span class="line-added"> 38 import java.security.AccessController;</span>
 39 import java.util.List;
 40 import java.util.concurrent.CompletableFuture;
 41 import java.util.concurrent.ConcurrentMap;
 42 import java.util.function.Function;

 43 import java.net.http.HttpRequest;
 44 import java.net.http.HttpResponse;
 45 import java.net.http.HttpResponse.BodyHandler;
 46 import java.net.http.HttpResponse.ResponseInfo;
 47 import java.net.http.HttpResponse.BodySubscriber;
 48 import java.util.regex.Matcher;
 49 import java.util.regex.Pattern;
 50 import jdk.internal.net.http.ResponseSubscribers.PathSubscriber;
 51 import static java.util.regex.Pattern.CASE_INSENSITIVE;
 52 
 53 public final class ResponseBodyHandlers {
 54 
 55     private ResponseBodyHandlers() { }
 56 
 57     private static final String pathForSecurityCheck(Path path) {
 58         return path.toFile().getPath();
 59     }
 60 
 61     /**
 62      * A Path body handler.
 63      */
 64     public static class PathBodyHandler implements BodyHandler&lt;Path&gt;{
 65         private final Path file;
 66         private final List&lt;OpenOption&gt; openOptions;  // immutable list
<span class="line-added"> 67         private final AccessControlContext acc;</span>
 68         private final FilePermission filePermission;
 69 
 70         /**
 71          * Factory for creating PathBodyHandler.
 72          *
 73          * Permission checks are performed here before construction of the
 74          * PathBodyHandler. Permission checking and construction are
 75          * deliberately and tightly co-located.
 76          */
 77         public static PathBodyHandler create(Path file,
 78                                              List&lt;OpenOption&gt; openOptions) {
 79             FilePermission filePermission = null;
 80             SecurityManager sm = System.getSecurityManager();
 81             if (sm != null) {
<span class="line-modified"> 82                 try {</span>
<span class="line-modified"> 83                     String fn = pathForSecurityCheck(file);</span>
<span class="line-modified"> 84                     FilePermission writePermission = new FilePermission(fn, &quot;write&quot;);</span>
<span class="line-modified"> 85                     sm.checkPermission(writePermission);</span>
<span class="line-added"> 86                     filePermission = writePermission;</span>
<span class="line-added"> 87                 } catch (UnsupportedOperationException ignored) {</span>
<span class="line-added"> 88                     // path not associated with the default file system provider</span>
<span class="line-added"> 89                 }</span>
 90             }
<span class="line-modified"> 91 </span>
<span class="line-added"> 92             assert filePermission == null || filePermission.getActions().equals(&quot;write&quot;);</span>
<span class="line-added"> 93             var acc = sm != null ? AccessController.getContext() : null;</span>
<span class="line-added"> 94             return new PathBodyHandler(file, openOptions, acc, filePermission);</span>
 95         }
 96 
 97         private PathBodyHandler(Path file,
 98                                 List&lt;OpenOption&gt; openOptions,
<span class="line-added"> 99                                 AccessControlContext acc,</span>
100                                 FilePermission filePermission) {
101             this.file = file;
102             this.openOptions = openOptions;
<span class="line-added">103             this.acc = acc;</span>
104             this.filePermission = filePermission;
105         }
106 
107         @Override
108         public BodySubscriber&lt;Path&gt; apply(ResponseInfo responseInfo) {
<span class="line-modified">109             return new PathSubscriber(file, openOptions, acc, filePermission);</span>
110         }
111     }
112 
113     /** With push promise Map implementation */
114     public static class PushPromisesHandlerWithMap&lt;T&gt;
115         implements HttpResponse.PushPromiseHandler&lt;T&gt;
116     {
117         private final ConcurrentMap&lt;HttpRequest,CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;&gt; pushPromisesMap;
118         private final Function&lt;HttpRequest,BodyHandler&lt;T&gt;&gt; pushPromiseHandler;
119 
120         public PushPromisesHandlerWithMap(Function&lt;HttpRequest,BodyHandler&lt;T&gt;&gt; pushPromiseHandler,
121                                           ConcurrentMap&lt;HttpRequest,CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;&gt; pushPromisesMap) {
122             this.pushPromiseHandler = pushPromiseHandler;
123             this.pushPromisesMap = pushPromisesMap;
124         }
125 
126         @Override
127         public void applyPushPromise(
128                 HttpRequest initiatingRequest, HttpRequest pushRequest,
129                 Function&lt;BodyHandler&lt;T&gt;,CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;&gt; acceptor)
</pre>
<hr />
<pre>
143             int pushPort = pushRequestURI.getPort();
144             if (pushPort == -1 ) {
145                 if (&quot;https&quot;.equalsIgnoreCase(pushRequestURI.getScheme()))
146                     pushPort = 443;
147                 else
148                     pushPort = 80;
149             }
150             if (initiatingPort != pushPort)
151                 return;
152 
153             CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; cf =
154                     acceptor.apply(pushPromiseHandler.apply(pushRequest));
155             pushPromisesMap.put(pushRequest, cf);
156         }
157     }
158 
159     // Similar to Path body handler, but for file download.
160     public static class FileDownloadBodyHandler implements BodyHandler&lt;Path&gt; {
161         private final Path directory;
162         private final List&lt;OpenOption&gt; openOptions;
<span class="line-added">163         private final AccessControlContext acc;</span>
164         private final FilePermission[] filePermissions;  // may be null
165 
166         /**
167          * Factory for creating FileDownloadBodyHandler.
168          *
169          * Permission checks are performed here before construction of the
170          * FileDownloadBodyHandler. Permission checking and construction are
171          * deliberately and tightly co-located.
172          */
173         public static FileDownloadBodyHandler create(Path directory,
174                                                      List&lt;OpenOption&gt; openOptions) {
<span class="line-added">175             String fn;</span>
<span class="line-added">176             try {</span>
<span class="line-added">177                 fn = pathForSecurityCheck(directory);</span>
<span class="line-added">178             } catch (UnsupportedOperationException uoe) {</span>
<span class="line-added">179                 // directory not associated with the default file system provider</span>
<span class="line-added">180                 throw new IllegalArgumentException(&quot;invalid path: &quot; + directory, uoe);</span>
<span class="line-added">181             }</span>
<span class="line-added">182 </span>
183             FilePermission filePermissions[] = null;
184             SecurityManager sm = System.getSecurityManager();
185             if (sm != null) {

186                 FilePermission writePermission = new FilePermission(fn, &quot;write&quot;);
187                 String writePathPerm = fn + File.separatorChar + &quot;*&quot;;
188                 FilePermission writeInDirPermission = new FilePermission(writePathPerm, &quot;write&quot;);
189                 sm.checkPermission(writeInDirPermission);
190                 FilePermission readPermission = new FilePermission(fn, &quot;read&quot;);
191                 sm.checkPermission(readPermission);
192 
193                 // read permission is only needed before determine the below checks
194                 // only write permission is required when downloading to the file
195                 filePermissions = new FilePermission[] { writePermission, writeInDirPermission };
196             }
197 
198             // existence, etc, checks must be after permission checks
199             if (Files.notExists(directory))
200                 throw new IllegalArgumentException(&quot;non-existent directory: &quot; + directory);
201             if (!Files.isDirectory(directory))
202                 throw new IllegalArgumentException(&quot;not a directory: &quot; + directory);
203             if (!Files.isWritable(directory))
204                 throw new IllegalArgumentException(&quot;non-writable directory: &quot; + directory);
205 
<span class="line-modified">206             assert filePermissions == null || (filePermissions[0].getActions().equals(&quot;write&quot;)</span>
<span class="line-modified">207                     &amp;&amp; filePermissions[1].getActions().equals(&quot;write&quot;));</span>
<span class="line-added">208             var acc = sm != null ? AccessController.getContext() : null;</span>
<span class="line-added">209             return new FileDownloadBodyHandler(directory, openOptions, acc, filePermissions);</span>
210         }
211 
212         private FileDownloadBodyHandler(Path directory,
213                                        List&lt;OpenOption&gt; openOptions,
<span class="line-added">214                                        AccessControlContext acc,</span>
215                                        FilePermission... filePermissions) {
216             this.directory = directory;
217             this.openOptions = openOptions;
<span class="line-added">218             this.acc = acc;</span>
219             this.filePermissions = filePermissions;
220         }
221 
222         /** The &quot;attachment&quot; disposition-type and separator. */
223         static final String DISPOSITION_TYPE = &quot;attachment;&quot;;
224 
225         /** The &quot;filename&quot; parameter. */
226         static final Pattern FILENAME = Pattern.compile(&quot;filename\\s*=&quot;, CASE_INSENSITIVE);
227 
228         static final List&lt;String&gt; PROHIBITED = List.of(&quot;.&quot;, &quot;..&quot;, &quot;&quot;, &quot;~&quot; , &quot;|&quot;);
229 
230         static final UncheckedIOException unchecked(ResponseInfo rinfo,
231                                                     String msg) {
232             String s = String.format(&quot;%s in response [%d, %s]&quot;, msg, rinfo.statusCode(), rinfo.headers());
233             return new UncheckedIOException(new IOException(s));
234         }
235 
236         @Override
237         public BodySubscriber&lt;Path&gt; apply(ResponseInfo responseInfo) {
238             String dispoHeader = responseInfo.headers().firstValue(&quot;Content-Disposition&quot;)
</pre>
<hr />
<pre>
279             } else {  // token,
280                 if (filenameParam.contains(&quot; &quot;)) {  // space disallowed
281                     throw unchecked(responseInfo,
282                             &quot;unquoted space in Content-Disposition filename parameter&quot;);
283                 }
284             }
285 
286             if (PROHIBITED.contains(filenameParam)) {
287                 throw unchecked(responseInfo,
288                         &quot;Prohibited Content-Disposition filename parameter:&quot;
289                                 + filenameParam);
290             }
291 
292             Path file = Paths.get(directory.toString(), filenameParam);
293 
294             if (!file.startsWith(directory)) {
295                 throw unchecked(responseInfo,
296                         &quot;Resulting file, &quot; + file.toString() + &quot;, outside of given directory&quot;);
297             }
298 
<span class="line-modified">299             return new PathSubscriber(file, openOptions, acc, filePermissions);</span>
300         }
301     }
302 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../java/net/http/HttpResponse.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ResponseSubscribers.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.net.http/share/classes/jdk/internal/net/http/ResponseSubscribers.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.net.http;
  27 
  28 import java.io.BufferedReader;
  29 import java.io.FilePermission;
  30 import java.io.IOException;
  31 import java.io.InputStream;
  32 import java.io.InputStreamReader;
  33 import java.nio.ByteBuffer;
  34 import java.nio.channels.FileChannel;
  35 import java.nio.charset.Charset;
  36 import java.nio.file.OpenOption;
  37 import java.nio.file.Path;
  38 import java.security.AccessControlContext;
  39 import java.security.AccessController;
  40 import java.security.PrivilegedAction;
  41 import java.security.PrivilegedActionException;
  42 import java.security.PrivilegedExceptionAction;
  43 import java.util.ArrayList;
  44 import java.util.Iterator;
  45 import java.util.List;
  46 import java.util.Objects;
  47 import java.util.Optional;
  48 import java.util.concurrent.ArrayBlockingQueue;
  49 import java.util.concurrent.BlockingQueue;
  50 import java.util.concurrent.CompletableFuture;
  51 import java.util.concurrent.CompletionStage;
  52 import java.util.concurrent.Executor;
  53 import java.util.concurrent.Flow;
  54 import java.util.concurrent.Flow.Subscriber;
  55 import java.util.concurrent.Flow.Subscription;
  56 import java.util.concurrent.atomic.AtomicBoolean;
  57 import java.util.concurrent.atomic.AtomicReference;
  58 import java.util.function.Consumer;
  59 import java.util.function.Function;
  60 import java.util.stream.Stream;
  61 import java.net.http.HttpResponse.BodySubscriber;
  62 import jdk.internal.net.http.common.Log;
  63 import jdk.internal.net.http.common.Logger;
  64 import jdk.internal.net.http.common.MinimalFuture;
  65 import jdk.internal.net.http.common.Utils;
  66 import static java.nio.charset.StandardCharsets.UTF_8;
  67 
  68 public class ResponseSubscribers {
  69 
  70     /**
  71      * This interface is used by our BodySubscriber implementations to
  72      * declare whether calling getBody() inline is safe, or whether
  73      * it needs to be called asynchronously in an executor thread.
  74      * Calling getBody() inline is usually safe except when it
  75      * might block - which can be the case if the BodySubscriber
  76      * is provided by custom code, or if it uses a finisher that
  77      * might be called and might block before the last bit is
  78      * received (for instance, if a mapping subscriber is used with
  79      * a mapper function that maps an InputStream to a GZIPInputStream,
  80      * as the the constructor of GZIPInputStream calls read()).
  81      * @param &lt;T&gt; The response type.
  82      */
  83     public interface TrustedSubscriber&lt;T&gt; extends BodySubscriber&lt;T&gt; {
  84         /**
  85          * Returns true if getBody() should be called asynchronously.
  86          * @implSpec The default implementation of this method returns
  87          *           false.
  88          * @return true if getBody() should be called asynchronously.
  89          */
  90         default boolean needsExecutor() { return false;}
  91 
  92         /**
  93          * Returns true if calling {@code bs::getBody} might block
  94          * and requires an executor.
  95          *
  96          * @implNote
  97          * In particular this method returns
  98          * true if {@code bs} is not a {@code TrustedSubscriber}.
  99          * If it is a {@code TrustedSubscriber}, it returns
 100          * {@code ((TrustedSubscriber) bs).needsExecutor()}.
 101          *
 102          * @param bs A BodySubscriber.
 103          * @return true if calling {@code bs::getBody} requires using
 104          *         an executor.
 105          */
 106         static boolean needsExecutor(BodySubscriber&lt;?&gt; bs) {
 107             if (bs instanceof TrustedSubscriber) {
 108                 return ((TrustedSubscriber) bs).needsExecutor();
 109             } else return true;
 110         }
 111     }
 112 
 113     public static class ConsumerSubscriber implements TrustedSubscriber&lt;Void&gt; {
 114         private final Consumer&lt;Optional&lt;byte[]&gt;&gt; consumer;
 115         private Flow.Subscription subscription;
 116         private final CompletableFuture&lt;Void&gt; result = new MinimalFuture&lt;&gt;();
 117         private final AtomicBoolean subscribed = new AtomicBoolean();
 118 
 119         public ConsumerSubscriber(Consumer&lt;Optional&lt;byte[]&gt;&gt; consumer) {
 120             this.consumer = Objects.requireNonNull(consumer);
 121         }
 122 
 123         @Override
 124         public CompletionStage&lt;Void&gt; getBody() {
 125             return result;
 126         }
 127 
 128         @Override
 129         public void onSubscribe(Flow.Subscription subscription) {
 130             Objects.requireNonNull(subscription);
 131             if (!subscribed.compareAndSet(false, true)) {
 132                 subscription.cancel();
 133             } else {
 134                 this.subscription = subscription;
 135                 subscription.request(1);
 136             }
 137         }
 138 
 139         @Override
 140         public void onNext(List&lt;ByteBuffer&gt; items) {
 141             Objects.requireNonNull(items);
 142             for (ByteBuffer item : items) {
 143                 byte[] buf = new byte[item.remaining()];
 144                 item.get(buf);
 145                 consumer.accept(Optional.of(buf));
 146             }
 147             subscription.request(1);
 148         }
 149 
 150         @Override
 151         public void onError(Throwable throwable) {
 152             Objects.requireNonNull(throwable);
 153             result.completeExceptionally(throwable);
 154         }
 155 
 156         @Override
 157         public void onComplete() {
 158             consumer.accept(Optional.empty());
 159             result.complete(null);
 160         }
 161 
 162     }
 163 
 164     /**
 165      * A Subscriber that writes the flow of data to a given file.
 166      *
 167      * Privileged actions are performed within a limited doPrivileged that only
 168      * asserts the specific, write, file permissions that were checked during
 169      * the construction of this PathSubscriber.
 170      */
 171     public static class PathSubscriber implements TrustedSubscriber&lt;Path&gt; {
 172 
 173         private static final FilePermission[] EMPTY_FILE_PERMISSIONS = new FilePermission[0];
 174 
 175         private final Path file;
 176         private final OpenOption[] options;
 177         private final AccessControlContext acc;
 178         private final FilePermission[] filePermissions;
 179         private final boolean isDefaultFS;
 180         private final CompletableFuture&lt;Path&gt; result = new MinimalFuture&lt;&gt;();
 181 
 182         private final AtomicBoolean subscribed = new AtomicBoolean();
 183         private volatile Flow.Subscription subscription;
 184         private volatile FileChannel out;
 185 
 186         private static final String pathForSecurityCheck(Path path) {
 187             return path.toFile().getPath();
 188         }
 189 
 190         /**
 191          * Factory for creating PathSubscriber.
 192          *
 193          * Permission checks are performed here before construction of the
 194          * PathSubscriber. Permission checking and construction are deliberately
 195          * and tightly co-located.
 196          */
 197         public static PathSubscriber create(Path file,
 198                                             List&lt;OpenOption&gt; options) {
 199             SecurityManager sm = System.getSecurityManager();
 200             FilePermission filePermission = null;
 201             if (sm != null) {
 202                 try {
 203                     String fn = pathForSecurityCheck(file);
 204                     FilePermission writePermission = new FilePermission(fn, &quot;write&quot;);
 205                     sm.checkPermission(writePermission);
 206                     filePermission = writePermission;
 207                 } catch (UnsupportedOperationException ignored) {
 208                     // path not associated with the default file system provider
 209                 }
 210             }
 211 
 212             assert filePermission == null || filePermission.getActions().equals(&quot;write&quot;);
 213             AccessControlContext acc = sm != null ? AccessController.getContext() : null;
 214             return new PathSubscriber(file, options, acc, filePermission);
 215         }
 216 
 217         // pp so handler implementations in the same package can construct
 218         /*package-private*/ PathSubscriber(Path file,
 219                                            List&lt;OpenOption&gt; options,
 220                                            AccessControlContext acc,
 221                                            FilePermission... filePermissions) {
 222             this.file = file;
 223             this.options = options.stream().toArray(OpenOption[]::new);
 224             this.acc = acc;
 225             this.filePermissions = filePermissions == null || filePermissions[0] == null
 226                             ? EMPTY_FILE_PERMISSIONS : filePermissions;
 227             this.isDefaultFS = isDefaultFS(file);
 228         }
 229 
 230         private static boolean isDefaultFS(Path file) {
 231             try {
 232                 file.toFile();
 233                 return true;
 234             } catch (UnsupportedOperationException uoe) {
 235                 return false;
 236             }
 237         }
 238 
 239         @Override
 240         public void onSubscribe(Flow.Subscription subscription) {
 241             Objects.requireNonNull(subscription);
 242             if (!subscribed.compareAndSet(false, true)) {
 243                 subscription.cancel();
 244                 return;
 245             }
 246 
 247             this.subscription = subscription;
 248             if (acc == null) {
 249                 try {
 250                     out = FileChannel.open(file, options);
 251                 } catch (IOException ioe) {
 252                     result.completeExceptionally(ioe);
 253                     subscription.cancel();
 254                     return;
 255                 }
 256             } else {
 257                 try {
 258                     PrivilegedExceptionAction&lt;FileChannel&gt; pa =
 259                             () -&gt; FileChannel.open(file, options);
 260                     out = isDefaultFS
 261                             ? AccessController.doPrivileged(pa, acc, filePermissions)
 262                             : AccessController.doPrivileged(pa, acc);
 263                 } catch (PrivilegedActionException pae) {
 264                     Throwable t = pae.getCause() != null ? pae.getCause() : pae;
 265                     result.completeExceptionally(t);
 266                     subscription.cancel();
 267                     return;
 268                 } catch (Exception e) {
 269                     result.completeExceptionally(e);
 270                     subscription.cancel();
 271                     return;
 272                 }
 273             }
 274             subscription.request(1);
 275         }
 276 
 277         @Override
 278         public void onNext(List&lt;ByteBuffer&gt; items) {
 279             try {
 280                 out.write(items.toArray(Utils.EMPTY_BB_ARRAY));
 281             } catch (IOException ex) {
 282                 close();
 283                 subscription.cancel();
 284                 result.completeExceptionally(ex);
 285             }
 286             subscription.request(1);
 287         }
 288 
 289         @Override
 290         public void onError(Throwable e) {
 291             result.completeExceptionally(e);
 292             close();
 293         }
 294 
 295         @Override
 296         public void onComplete() {
 297             close();
 298             result.complete(file);
 299         }
 300 
 301         @Override
 302         public CompletionStage&lt;Path&gt; getBody() {
 303             return result;
 304         }
 305 
 306         private void close() {
 307             if (acc == null) {
 308                 Utils.close(out);
 309             } else {
 310                 PrivilegedAction&lt;Void&gt; pa = () -&gt; {
 311                     Utils.close(out);
 312                     return null;
 313                 };
 314                 if (isDefaultFS) {
 315                     AccessController.doPrivileged(pa, acc, filePermissions);
 316                 } else {
 317                     AccessController.doPrivileged(pa, acc);
 318                 }
 319             }
 320         }
 321     }
 322 
 323     public static class ByteArraySubscriber&lt;T&gt; implements TrustedSubscriber&lt;T&gt; {
 324         private final Function&lt;byte[], T&gt; finisher;
 325         private final CompletableFuture&lt;T&gt; result = new MinimalFuture&lt;&gt;();
 326         private final List&lt;ByteBuffer&gt; received = new ArrayList&lt;&gt;();
 327 
 328         private volatile Flow.Subscription subscription;
 329 
 330         public ByteArraySubscriber(Function&lt;byte[],T&gt; finisher) {
 331             this.finisher = finisher;
 332         }
 333 
 334         @Override
 335         public void onSubscribe(Flow.Subscription subscription) {
 336             if (this.subscription != null) {
 337                 subscription.cancel();
 338                 return;
 339             }
 340             this.subscription = subscription;
 341             // We can handle whatever you&#39;ve got
 342             subscription.request(Long.MAX_VALUE);
 343         }
 344 
 345         @Override
 346         public void onNext(List&lt;ByteBuffer&gt; items) {
 347             // incoming buffers are allocated by http client internally,
 348             // and won&#39;t be used anywhere except this place.
 349             // So it&#39;s free simply to store them for further processing.
 350             assert Utils.hasRemaining(items);
 351             received.addAll(items);
 352         }
 353 
 354         @Override
 355         public void onError(Throwable throwable) {
 356             received.clear();
 357             result.completeExceptionally(throwable);
 358         }
 359 
 360         static private byte[] join(List&lt;ByteBuffer&gt; bytes) {
 361             int size = Utils.remaining(bytes, Integer.MAX_VALUE);
 362             byte[] res = new byte[size];
 363             int from = 0;
 364             for (ByteBuffer b : bytes) {
 365                 int l = b.remaining();
 366                 b.get(res, from, l);
 367                 from += l;
 368             }
 369             return res;
 370         }
 371 
 372         @Override
 373         public void onComplete() {
 374             try {
 375                 result.complete(finisher.apply(join(received)));
 376                 received.clear();
 377             } catch (IllegalArgumentException e) {
 378                 result.completeExceptionally(e);
 379             }
 380         }
 381 
 382         @Override
 383         public CompletionStage&lt;T&gt; getBody() {
 384             return result;
 385         }
 386     }
 387 
 388     /**
 389      * An InputStream built on top of the Flow API.
 390      */
 391     public static class HttpResponseInputStream extends InputStream
 392         implements TrustedSubscriber&lt;InputStream&gt;
 393     {
 394         final static int MAX_BUFFERS_IN_QUEUE = 1;  // lock-step with the producer
 395 
 396         // An immutable ByteBuffer sentinel to mark that the last byte was received.
 397         private static final ByteBuffer LAST_BUFFER = ByteBuffer.wrap(new byte[0]);
 398         private static final List&lt;ByteBuffer&gt; LAST_LIST = List.of(LAST_BUFFER);
 399         private static final Logger debug =
 400                 Utils.getDebugLogger(&quot;HttpResponseInputStream&quot;::toString, Utils.DEBUG);
 401 
 402         // A queue of yet unprocessed ByteBuffers received from the flow API.
 403         private final BlockingQueue&lt;List&lt;ByteBuffer&gt;&gt; buffers;
 404         private volatile Flow.Subscription subscription;
 405         private volatile boolean closed;
 406         private volatile Throwable failed;
 407         private volatile Iterator&lt;ByteBuffer&gt; currentListItr;
 408         private volatile ByteBuffer currentBuffer;
 409         private final AtomicBoolean subscribed = new AtomicBoolean();
 410 
 411         public HttpResponseInputStream() {
 412             this(MAX_BUFFERS_IN_QUEUE);
 413         }
 414 
 415         HttpResponseInputStream(int maxBuffers) {
 416             int capacity = (maxBuffers &lt;= 0 ? MAX_BUFFERS_IN_QUEUE : maxBuffers);
 417             // 1 additional slot needed for LAST_LIST added by onComplete
 418             this.buffers = new ArrayBlockingQueue&lt;&gt;(capacity + 1);
 419         }
 420 
 421         @Override
 422         public CompletionStage&lt;InputStream&gt; getBody() {
 423             // Returns the stream immediately, before the
 424             // response body is received.
 425             // This makes it possible for sendAsync().get().body()
 426             // to complete before the response body is received.
 427             return CompletableFuture.completedStage(this);
 428         }
 429 
 430         // Returns the current byte buffer to read from.
 431         // If the current buffer has no remaining data, this method will take the
 432         // next buffer from the buffers queue, possibly blocking until
 433         // a new buffer is made available through the Flow API, or the
 434         // end of the flow has been reached.
 435         private ByteBuffer current() throws IOException {
 436             while (currentBuffer == null || !currentBuffer.hasRemaining()) {
 437                 // Check whether the stream is closed or exhausted
 438                 if (closed || failed != null) {
 439                     throw new IOException(&quot;closed&quot;, failed);
 440                 }
 441                 if (currentBuffer == LAST_BUFFER) break;
 442 
 443                 try {
 444                     if (currentListItr == null || !currentListItr.hasNext()) {
 445                         // Take a new list of buffers from the queue, blocking
 446                         // if none is available yet...
 447 
 448                         if (debug.on()) debug.log(&quot;Taking list of Buffers&quot;);
 449                         List&lt;ByteBuffer&gt; lb = buffers.take();
 450                         currentListItr = lb.iterator();
 451                         if (debug.on()) debug.log(&quot;List of Buffers Taken&quot;);
 452 
 453                         // Check whether an exception was encountered upstream
 454                         if (closed || failed != null)
 455                             throw new IOException(&quot;closed&quot;, failed);
 456 
 457                         // Check whether we&#39;re done.
 458                         if (lb == LAST_LIST) {
 459                             currentListItr = null;
 460                             currentBuffer = LAST_BUFFER;
 461                             break;
 462                         }
 463 
 464                         // Request another upstream item ( list of buffers )
 465                         Flow.Subscription s = subscription;
 466                         if (s != null) {
 467                             if (debug.on()) debug.log(&quot;Increased demand by 1&quot;);
 468                             s.request(1);
 469                         }
 470                         assert currentListItr != null;
 471                         if (lb.isEmpty()) continue;
 472                     }
 473                     assert currentListItr != null;
 474                     assert currentListItr.hasNext();
 475                     if (debug.on()) debug.log(&quot;Next Buffer&quot;);
 476                     currentBuffer = currentListItr.next();
 477                 } catch (InterruptedException ex) {
 478                     // continue
 479                 }
 480             }
 481             assert currentBuffer == LAST_BUFFER || currentBuffer.hasRemaining();
 482             return currentBuffer;
 483         }
 484 
 485         @Override
 486         public int read(byte[] bytes, int off, int len) throws IOException {
 487             Objects.checkFromIndexSize(off, len, bytes.length);
 488             if (len == 0) {
 489                 return 0;
 490             }
 491             // get the buffer to read from, possibly blocking if
 492             // none is available
 493             ByteBuffer buffer;
 494             if ((buffer = current()) == LAST_BUFFER) return -1;
 495 
 496             // don&#39;t attempt to read more than what is available
 497             // in the current buffer.
 498             int read = Math.min(buffer.remaining(), len);
 499             assert read &gt; 0 &amp;&amp; read &lt;= buffer.remaining();
 500 
 501             // buffer.get() will do the boundary check for us.
 502             buffer.get(bytes, off, read);
 503             return read;
 504         }
 505 
 506         @Override
 507         public int read() throws IOException {
 508             ByteBuffer buffer;
 509             if ((buffer = current()) == LAST_BUFFER) return -1;
 510             return buffer.get() &amp; 0xFF;
 511         }
 512 
 513         @Override
 514         public int available() throws IOException {
 515             // best effort: returns the number of remaining bytes in
 516             // the current buffer if any, or 1 if the current buffer
 517             // is null or empty but the queue or current buffer list
 518             // are not empty. Returns 0 otherwise.
 519             if (closed) return 0;
 520             int available = 0;
 521             ByteBuffer current = currentBuffer;
 522             if (current == LAST_BUFFER) return 0;
 523             if (current != null) available = current.remaining();
 524             if (available != 0) return available;
 525             Iterator&lt;?&gt; iterator = currentListItr;
 526             if (iterator != null &amp;&amp; iterator.hasNext()) return 1;
 527             if (buffers.isEmpty()) return 0;
 528             return 1;
 529         }
 530 
 531         @Override
 532         public void onSubscribe(Flow.Subscription s) {
 533             Objects.requireNonNull(s);
 534             try {
 535                 if (!subscribed.compareAndSet(false, true)) {
 536                     s.cancel();
 537                 } else {
 538                     // check whether the stream is already closed.
 539                     // if so, we should cancel the subscription
 540                     // immediately.
 541                     boolean closed;
 542                     synchronized (this) {
 543                         closed = this.closed;
 544                         if (!closed) {
 545                             this.subscription = s;
 546                         }
 547                     }
 548                     if (closed) {
 549                         s.cancel();
 550                         return;
 551                     }
 552                     assert buffers.remainingCapacity() &gt; 1; // should contain at least 2
 553                     if (debug.on())
 554                         debug.log(&quot;onSubscribe: requesting &quot;
 555                                   + Math.max(1, buffers.remainingCapacity() - 1));
 556                     s.request(Math.max(1, buffers.remainingCapacity() - 1));
 557                 }
 558             } catch (Throwable t) {
 559                 failed = t;
 560                 try {
 561                     close();
 562                 } catch (IOException x) {
 563                     // OK
 564                 } finally {
 565                     onError(t);
 566                 }
 567             }
 568         }
 569 
 570         @Override
 571         public void onNext(List&lt;ByteBuffer&gt; t) {
 572             Objects.requireNonNull(t);
 573             try {
 574                 if (debug.on()) debug.log(&quot;next item received&quot;);
 575                 if (!buffers.offer(t)) {
 576                     throw new IllegalStateException(&quot;queue is full&quot;);
 577                 }
 578                 if (debug.on()) debug.log(&quot;item offered&quot;);
 579             } catch (Throwable ex) {
 580                 failed = ex;
 581                 try {
 582                     close();
 583                 } catch (IOException ex1) {
 584                     // OK
 585                 } finally {
 586                     onError(ex);
 587                 }
 588             }
 589         }
 590 
 591         @Override
 592         public void onError(Throwable thrwbl) {
 593             subscription = null;
 594             failed = Objects.requireNonNull(thrwbl);
 595             // The client process that reads the input stream might
 596             // be blocked in queue.take().
 597             // Tries to offer LAST_LIST to the queue. If the queue is
 598             // full we don&#39;t care if we can&#39;t insert this buffer, as
 599             // the client can&#39;t be blocked in queue.take() in that case.
 600             // Adding LAST_LIST to the queue is harmless, as the client
 601             // should find failed != null before handling LAST_LIST.
 602             buffers.offer(LAST_LIST);
 603         }
 604 
 605         @Override
 606         public void onComplete() {
 607             subscription = null;
 608             onNext(LAST_LIST);
 609         }
 610 
 611         @Override
 612         public void close() throws IOException {
 613             Flow.Subscription s;
 614             synchronized (this) {
 615                 if (closed) return;
 616                 closed = true;
 617                 s = subscription;
 618                 subscription = null;
 619             }
 620             // s will be null if already completed
 621             try {
 622                 if (s != null) {
 623                     s.cancel();
 624                 }
 625             } finally {
 626                 buffers.offer(LAST_LIST);
 627                 super.close();
 628             }
 629         }
 630 
 631     }
 632 
 633     public static BodySubscriber&lt;Stream&lt;String&gt;&gt; createLineStream() {
 634         return createLineStream(UTF_8);
 635     }
 636 
 637     public static BodySubscriber&lt;Stream&lt;String&gt;&gt; createLineStream(Charset charset) {
 638         Objects.requireNonNull(charset);
 639         BodySubscriber&lt;InputStream&gt; s = new HttpResponseInputStream();
 640         // Creates a MappingSubscriber with a trusted finisher that is
 641         // trusted not to block.
 642         return new MappingSubscriber&lt;InputStream,Stream&lt;String&gt;&gt;(s,
 643             (InputStream stream) -&gt; {
 644                 return new BufferedReader(new InputStreamReader(stream, charset))
 645                             .lines().onClose(() -&gt; Utils.close(stream));
 646             }, true);
 647     }
 648 
 649     /**
 650      * Currently this consumes all of the data and ignores it
 651      */
 652     public static class NullSubscriber&lt;T&gt; implements TrustedSubscriber&lt;T&gt; {
 653 
 654         private final CompletableFuture&lt;T&gt; cf = new MinimalFuture&lt;&gt;();
 655         private final Optional&lt;T&gt; result;
 656         private final AtomicBoolean subscribed = new AtomicBoolean();
 657 
 658         public NullSubscriber(Optional&lt;T&gt; result) {
 659             this.result = result;
 660         }
 661 
 662         @Override
 663         public void onSubscribe(Flow.Subscription subscription) {
 664             Objects.requireNonNull(subscription);
 665             if (!subscribed.compareAndSet(false, true)) {
 666                 subscription.cancel();
 667             } else {
 668                 subscription.request(Long.MAX_VALUE);
 669             }
 670         }
 671 
 672         @Override
 673         public void onNext(List&lt;ByteBuffer&gt; items) {
 674             Objects.requireNonNull(items);
 675         }
 676 
 677         @Override
 678         public void onError(Throwable throwable) {
 679             Objects.requireNonNull(throwable);
 680             cf.completeExceptionally(throwable);
 681         }
 682 
 683         @Override
 684         public void onComplete() {
 685             if (result.isPresent()) {
 686                 cf.complete(result.get());
 687             } else {
 688                 cf.complete(null);
 689             }
 690         }
 691 
 692         @Override
 693         public CompletionStage&lt;T&gt; getBody() {
 694             return cf;
 695         }
 696     }
 697 
 698     /** An adapter between {@code BodySubscriber} and {@code Flow.Subscriber}. */
 699     public static final class SubscriberAdapter&lt;S extends Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt;,R&gt;
 700         implements TrustedSubscriber&lt;R&gt;
 701     {
 702         private final CompletableFuture&lt;R&gt; cf = new MinimalFuture&lt;&gt;();
 703         private final S subscriber;
 704         private final Function&lt;? super S,? extends R&gt; finisher;
 705         private volatile Subscription subscription;
 706 
 707         // The finisher isn&#39;t called until all bytes have been received,
 708         // and so shouldn&#39;t need an executor. No need to override
 709         // TrustedSubscriber::needsExecutor
 710         public SubscriberAdapter(S subscriber, Function&lt;? super S,? extends R&gt; finisher) {
 711             this.subscriber = Objects.requireNonNull(subscriber);
 712             this.finisher = Objects.requireNonNull(finisher);
 713         }
 714 
 715         @Override
 716         public void onSubscribe(Subscription subscription) {
 717             Objects.requireNonNull(subscription);
 718             if (this.subscription != null) {
 719                 subscription.cancel();
 720             } else {
 721                 this.subscription = subscription;
 722                 subscriber.onSubscribe(subscription);
 723             }
 724         }
 725 
 726         @Override
 727         public void onNext(List&lt;ByteBuffer&gt; item) {
 728             Objects.requireNonNull(item);
 729             try {
 730                 subscriber.onNext(item);
 731             } catch (Throwable throwable) {
 732                 subscription.cancel();
 733                 onError(throwable);
 734             }
 735         }
 736 
 737         @Override
 738         public void onError(Throwable throwable) {
 739             Objects.requireNonNull(throwable);
 740             try {
 741                 subscriber.onError(throwable);
 742             } finally {
 743                 cf.completeExceptionally(throwable);
 744             }
 745         }
 746 
 747         @Override
 748         public void onComplete() {
 749             try {
 750                 subscriber.onComplete();
 751             } finally {
 752                 try {
 753                     cf.complete(finisher.apply(subscriber));
 754                 } catch (Throwable throwable) {
 755                     cf.completeExceptionally(throwable);
 756                 }
 757             }
 758         }
 759 
 760         @Override
 761         public CompletionStage&lt;R&gt; getBody() {
 762             return cf;
 763         }
 764     }
 765 
 766     /**
 767      * A body subscriber which receives input from an upstream subscriber
 768      * and maps that subscriber&#39;s body type to a new type. The upstream subscriber
 769      * delegates all flow operations directly to this object. The
 770      * {@link CompletionStage} returned by {@link #getBody()}} takes the output
 771      * of the upstream {@code getBody()} and applies the mapper function to
 772      * obtain the new {@code CompletionStage} type.
 773      *
 774      * @param &lt;T&gt; the upstream body type
 775      * @param &lt;U&gt; this subscriber&#39;s body type
 776      */
 777     public static class MappingSubscriber&lt;T,U&gt; implements TrustedSubscriber&lt;U&gt; {
 778         private final BodySubscriber&lt;T&gt; upstream;
 779         private final Function&lt;? super T,? extends U&gt; mapper;
 780         private final boolean trusted;
 781 
 782         public MappingSubscriber(BodySubscriber&lt;T&gt; upstream,
 783                                  Function&lt;? super T,? extends U&gt; mapper) {
 784             this(upstream, mapper, false);
 785         }
 786 
 787         // creates a MappingSubscriber with a mapper that is trusted
 788         // to not block when called.
 789         MappingSubscriber(BodySubscriber&lt;T&gt; upstream,
 790                           Function&lt;? super T,? extends U&gt; mapper,
 791                           boolean trusted) {
 792             this.upstream = Objects.requireNonNull(upstream);
 793             this.mapper = Objects.requireNonNull(mapper);
 794             this.trusted = trusted;
 795         }
 796 
 797         // There is no way to know whether a custom mapper function
 798         // might block or not - so we should return true unless the
 799         // mapper is implemented and trusted by our own code not to
 800         // block.
 801         @Override
 802         public boolean needsExecutor() {
 803             return !trusted || TrustedSubscriber.needsExecutor(upstream);
 804         }
 805 
 806         // If upstream.getBody() is already completed (case of InputStream),
 807         // then calling upstream.getBody().thenApply(mapper) might block
 808         // if the mapper blocks. We should probably add a variant of
 809         // MappingSubscriber that calls thenApplyAsync instead, but this
 810         // needs a new public API point. See needsExecutor() above.
 811         @Override
 812         public CompletionStage&lt;U&gt; getBody() {
 813             return upstream.getBody().thenApply(mapper);
 814         }
 815 
 816         @Override
 817         public void onSubscribe(Flow.Subscription subscription) {
 818             upstream.onSubscribe(subscription);
 819         }
 820 
 821         @Override
 822         public void onNext(List&lt;ByteBuffer&gt; item) {
 823             upstream.onNext(item);
 824         }
 825 
 826         @Override
 827         public void onError(Throwable throwable) {
 828             upstream.onError(throwable);
 829         }
 830 
 831         @Override
 832         public void onComplete() {
 833             upstream.onComplete();
 834         }
 835     }
 836 
 837     // A BodySubscriber that returns a Publisher&lt;List&lt;ByteBuffer&gt;&gt;
 838     static class PublishingBodySubscriber
 839             implements TrustedSubscriber&lt;Flow.Publisher&lt;List&lt;ByteBuffer&gt;&gt;&gt; {
 840         private final MinimalFuture&lt;Flow.Subscription&gt;
 841                 subscriptionCF = new MinimalFuture&lt;&gt;();
 842         private final MinimalFuture&lt;SubscriberRef&gt;
 843                 subscribedCF = new MinimalFuture&lt;&gt;();
 844         private AtomicReference&lt;SubscriberRef&gt;
 845                 subscriberRef = new AtomicReference&lt;&gt;();
 846         private final CompletionStage&lt;Flow.Publisher&lt;List&lt;ByteBuffer&gt;&gt;&gt; body =
 847                 subscriptionCF.thenCompose(
 848                         (s) -&gt; MinimalFuture.completedFuture(this::subscribe));
 849 
 850         // We use the completionCF to ensure that only one of
 851         // onError or onComplete is ever called.
 852         private final MinimalFuture&lt;Void&gt; completionCF;
 853         private PublishingBodySubscriber() {
 854             completionCF = new MinimalFuture&lt;&gt;();
 855             completionCF.whenComplete(
 856                     (r,t) -&gt; subscribedCF.thenAccept( s -&gt; complete(s, t)));
 857         }
 858 
 859         // An object that holds a reference to a Flow.Subscriber.
 860         // The reference is cleared when the subscriber is completed - either
 861         // normally or exceptionally, or when the subscription is cancelled.
 862         static final class SubscriberRef {
 863             volatile Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; ref;
 864             SubscriberRef(Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; subscriber) {
 865                 ref = subscriber;
 866             }
 867             Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; get() {
 868                 return ref;
 869             }
 870             Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; clear() {
 871                 Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; res = ref;
 872                 ref = null;
 873                 return res;
 874             }
 875         }
 876 
 877         // A subscription that wraps an upstream subscription and
 878         // holds a reference to a subscriber. The subscriber reference
 879         // is cleared when the subscription is cancelled
 880         final static class SubscriptionRef implements Flow.Subscription {
 881             final Flow.Subscription subscription;
 882             final SubscriberRef subscriberRef;
 883             SubscriptionRef(Flow.Subscription subscription,
 884                             SubscriberRef subscriberRef) {
 885                 this.subscription = subscription;
 886                 this.subscriberRef = subscriberRef;
 887             }
 888             @Override
 889             public void request(long n) {
 890                 if (subscriberRef.get() != null) {
 891                     subscription.request(n);
 892                 }
 893             }
 894             @Override
 895             public void cancel() {
 896                 subscription.cancel();
 897                 subscriberRef.clear();
 898             }
 899 
 900             void subscribe() {
 901                 Subscriber&lt;?&gt; subscriber = subscriberRef.get();
 902                 if (subscriber != null) {
 903                     subscriber.onSubscribe(this);
 904                 }
 905             }
 906 
 907             @Override
 908             public String toString() {
 909                 return &quot;SubscriptionRef/&quot;
 910                         + subscription.getClass().getName()
 911                         + &quot;@&quot;
 912                         + System.identityHashCode(subscription);
 913             }
 914         }
 915 
 916         // This is a callback for the subscribedCF.
 917         // Do not call directly!
 918         private void complete(SubscriberRef ref, Throwable t) {
 919             assert ref != null;
 920             Subscriber&lt;?&gt; s = ref.clear();
 921             // maybe null if subscription was cancelled
 922             if (s == null) return;
 923             if (t == null) {
 924                 try {
 925                     s.onComplete();
 926                 } catch (Throwable x) {
 927                     s.onError(x);
 928                 }
 929             } else {
 930                 s.onError(t);
 931             }
 932         }
 933 
 934         private void signalError(Throwable err) {
 935             if (err == null) {
 936                 err = new NullPointerException(&quot;null throwable&quot;);
 937             }
 938             completionCF.completeExceptionally(err);
 939         }
 940 
 941         private void signalComplete() {
 942             completionCF.complete(null);
 943         }
 944 
 945         private void subscribe(Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; subscriber) {
 946             Objects.requireNonNull(subscriber, &quot;subscriber must not be null&quot;);
 947             SubscriberRef ref = new SubscriberRef(subscriber);
 948             if (subscriberRef.compareAndSet(null, ref)) {
 949                 subscriptionCF.thenAccept((s) -&gt; {
 950                     SubscriptionRef subscription = new SubscriptionRef(s,ref);
 951                     try {
 952                         subscription.subscribe();
 953                         subscribedCF.complete(ref);
 954                     } catch (Throwable t) {
 955                         if (Log.errors()) {
 956                             Log.logError(&quot;Failed to call onSubscribe: &quot; +
 957                                     &quot;cancelling subscription: &quot; + t);
 958                             Log.logError(t);
 959                         }
 960                         subscription.cancel();
 961                     }
 962                 });
 963             } else {
 964                 subscriber.onSubscribe(new Flow.Subscription() {
 965                     @Override public void request(long n) { }
 966                     @Override public void cancel() { }
 967                 });
 968                 subscriber.onError(new IllegalStateException(
 969                         &quot;This publisher has already one subscriber&quot;));
 970             }
 971         }
 972 
 973         private final AtomicBoolean subscribed = new AtomicBoolean();
 974 
 975         @Override
 976         public void onSubscribe(Flow.Subscription subscription) {
 977             Objects.requireNonNull(subscription);
 978             if (!subscribed.compareAndSet(false, true)) {
 979                 subscription.cancel();
 980             } else {
 981                 subscriptionCF.complete(subscription);
 982             }
 983         }
 984 
 985         @Override
 986         public void onNext(List&lt;ByteBuffer&gt; item) {
 987             Objects.requireNonNull(item);
 988             try {
 989                 // cannot be called before onSubscribe()
 990                 assert subscriptionCF.isDone();
 991                 SubscriberRef ref = subscriberRef.get();
 992                 // cannot be called before subscriber calls request(1)
 993                 assert ref != null;
 994                 Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt;
 995                         subscriber = ref.get();
 996                 if (subscriber != null) {
 997                     // may be null if subscription was cancelled.
 998                     subscriber.onNext(item);
 999                 }
1000             } catch (Throwable err) {
1001                 signalError(err);
1002                 subscriptionCF.thenAccept(s -&gt; s.cancel());
1003             }
1004         }
1005 
1006         @Override
1007         public void onError(Throwable throwable) {
1008             // cannot be called before onSubscribe();
1009             assert suppress(subscriptionCF.isDone(),
1010                     &quot;onError called before onSubscribe&quot;,
1011                     throwable);
1012             // onError can be called before request(1), and therefore can
1013             // be called before subscriberRef is set.
1014             signalError(throwable);
1015             Objects.requireNonNull(throwable);
1016         }
1017 
1018         @Override
1019         public void onComplete() {
1020             // cannot be called before onSubscribe()
1021             if (!subscriptionCF.isDone()) {
1022                 signalError(new InternalError(
1023                         &quot;onComplete called before onSubscribed&quot;));
1024             } else {
1025                 // onComplete can be called before request(1),
1026                 // and therefore can be called before subscriberRef
1027                 // is set.
1028                 signalComplete();
1029             }
1030         }
1031 
1032         @Override
1033         public CompletionStage&lt;Flow.Publisher&lt;List&lt;ByteBuffer&gt;&gt;&gt; getBody() {
1034             return body;
1035         }
1036 
1037         private boolean suppress(boolean condition,
1038                                  String assertion,
1039                                  Throwable carrier) {
1040             if (!condition) {
1041                 if (carrier != null) {
1042                     carrier.addSuppressed(new AssertionError(assertion));
1043                 } else if (Log.errors()) {
1044                     Log.logError(new AssertionError(assertion));
1045                 }
1046             }
1047             return true;
1048         }
1049 
1050     }
1051 
1052     public static BodySubscriber&lt;Flow.Publisher&lt;List&lt;ByteBuffer&gt;&gt;&gt;
1053     createPublisher() {
1054         return new PublishingBodySubscriber();
1055     }
1056 
1057 
1058     /**
1059      * Tries to determine whether bs::getBody must be invoked asynchronously,
1060      * and if so, uses the provided executor to do it.
1061      * If the executor is a {@link HttpClientImpl.DelegatingExecutor},
1062      * uses the executor&#39;s delegate.
1063      * @param e    The executor to use if an executor is required.
1064      * @param bs   The BodySubscriber (trusted or not)
1065      * @param &lt;T&gt;  The type of the response.
1066      * @return A completion stage that completes when the completion
1067      *         stage returned by bs::getBody completes. This may, or
1068      *         may not, be the same completion stage.
1069      */
1070     public static &lt;T&gt; CompletionStage&lt;T&gt; getBodyAsync(Executor e, BodySubscriber&lt;T&gt; bs) {
1071         if (TrustedSubscriber.needsExecutor(bs)) {
1072             // getBody must be called in the executor
1073             return getBodyAsync(e, bs, new MinimalFuture&lt;&gt;());
1074         } else {
1075             // No executor needed
1076             return bs.getBody();
1077         }
1078     }
1079 
1080     /**
1081      * Invokes bs::getBody using the provided executor.
1082      * If invoking bs::getBody requires an executor, and the given executor
1083      * is a {@link HttpClientImpl.DelegatingExecutor}, then the executor&#39;s
1084      * delegate is used. If an error occurs anywhere then the given {code cf}
1085      * is completed exceptionally (this method does not throw).
1086      * @param e   The executor that should be used to call bs::getBody
1087      * @param bs  The BodySubscriber
1088      * @param cf  A completable future that this function will set up
1089      *            to complete when the completion stage returned by
1090      *            bs::getBody completes.
1091      *            In case of any error while trying to set up the
1092      *            completion chain, {@code cf} will be completed
1093      *            exceptionally with that error.
1094      * @param &lt;T&gt; The response type.
1095      * @return The provided {@code cf}.
1096      */
1097     public static &lt;T&gt; CompletableFuture&lt;T&gt; getBodyAsync(Executor e,
1098                                                       BodySubscriber&lt;T&gt; bs,
1099                                                       CompletableFuture&lt;T&gt; cf) {
1100         return getBodyAsync(e, bs, cf, cf::completeExceptionally);
1101     }
1102 
1103     /**
1104      * Invokes bs::getBody using the provided executor.
1105      * If invoking bs::getBody requires an executor, and the given executor
1106      * is a {@link HttpClientImpl.DelegatingExecutor}, then the executor&#39;s
1107      * delegate is used.
1108      * The provided {@code cf} is completed with the result (exceptional
1109      * or not) of the completion stage returned by bs::getBody.
1110      * If an error occurs when trying to set up the
1111      * completion chain, the provided {@code errorHandler} is invoked,
1112      * but {@code cf} is not necessarily affected.
1113      * This method does not throw.
1114      * @param e   The executor that should be used to call bs::getBody
1115      * @param bs  The BodySubscriber
1116      * @param cf  A completable future that this function will set up
1117      *            to complete when the completion stage returned by
1118      *            bs::getBody completes.
1119      *            In case of any error while trying to set up the
1120      *            completion chain, {@code cf} will be completed
1121      *            exceptionally with that error.
1122      * @param errorHandler The handler to invoke if an error is raised
1123      *                     while trying to set up the completion chain.
1124      * @param &lt;T&gt; The response type.
1125      * @return The provide {@code cf}. If the {@code errorHandler} is
1126      * invoked, it is the responsibility of the {@code errorHandler} to
1127      * complete the {@code cf}, if needed.
1128      */
1129     public static &lt;T&gt; CompletableFuture&lt;T&gt; getBodyAsync(Executor e,
1130                                                       BodySubscriber&lt;T&gt; bs,
1131                                                       CompletableFuture&lt;T&gt; cf,
1132                                                       Consumer&lt;Throwable&gt; errorHandler) {
1133         assert errorHandler != null;
1134         try {
1135             assert e != null;
1136             assert cf != null;
1137 
1138             if (TrustedSubscriber.needsExecutor(bs)) {
1139                 e = (e instanceof HttpClientImpl.DelegatingExecutor)
1140                         ? ((HttpClientImpl.DelegatingExecutor) e).delegate() : e;
1141             }
1142 
1143             e.execute(() -&gt; {
1144                 try {
1145                     bs.getBody().whenComplete((r, t) -&gt; {
1146                         if (t != null) {
1147                             cf.completeExceptionally(t);
1148                         } else {
1149                             cf.complete(r);
1150                         }
1151                     });
1152                 } catch (Throwable t) {
1153                     errorHandler.accept(t);
1154                 }
1155             });
1156             return cf;
1157 
1158         } catch (Throwable t) {
1159             errorHandler.accept(t);
1160         }
1161         return cf;
1162     }
1163 }
    </pre>
  </body>
</html>
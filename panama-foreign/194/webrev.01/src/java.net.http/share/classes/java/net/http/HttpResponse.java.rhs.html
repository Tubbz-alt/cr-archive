<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.net.http/share/classes/java/net/http/HttpResponse.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net.http;
  27 
  28 import java.io.BufferedReader;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.net.URI;
  32 import java.nio.ByteBuffer;
  33 import java.nio.charset.Charset;
  34 import java.nio.channels.FileChannel;
  35 import java.nio.charset.StandardCharsets;
  36 import java.nio.file.OpenOption;
  37 import java.nio.file.Path;
  38 import java.util.List;
  39 import java.util.Objects;
  40 import java.util.Optional;
  41 import java.util.concurrent.CompletableFuture;
  42 import java.util.concurrent.CompletionStage;
  43 import java.util.concurrent.ConcurrentMap;
  44 import java.util.concurrent.Flow;
  45 import java.util.concurrent.Flow.Subscriber;
  46 import java.util.concurrent.Flow.Publisher;
  47 import java.util.concurrent.Flow.Subscription;
  48 import java.util.function.Consumer;
  49 import java.util.function.Function;
  50 import java.util.function.Supplier;
  51 import java.util.stream.Stream;
  52 import javax.net.ssl.SSLSession;
  53 import jdk.internal.net.http.BufferingSubscriber;
  54 import jdk.internal.net.http.LineSubscriberAdapter;
  55 import jdk.internal.net.http.ResponseBodyHandlers.FileDownloadBodyHandler;
  56 import jdk.internal.net.http.ResponseBodyHandlers.PathBodyHandler;
  57 import jdk.internal.net.http.ResponseBodyHandlers.PushPromisesHandlerWithMap;
  58 import jdk.internal.net.http.ResponseSubscribers;
  59 import jdk.internal.net.http.ResponseSubscribers.PathSubscriber;
  60 import static java.nio.file.StandardOpenOption.*;
  61 import static jdk.internal.net.http.common.Utils.charsetFrom;
  62 
  63 /**
  64  * An HTTP response.
  65  *
  66  * &lt;p&gt; An {@code HttpResponse} is not created directly, but rather returned as
  67  * a result of sending an {@link HttpRequest}. An {@code HttpResponse} is
  68  * made available when the response status code and headers have been received,
  69  * and typically after the response body has also been completely received.
  70  * Whether or not the {@code HttpResponse} is made available before the response
  71  * body has been completely received depends on the {@link BodyHandler
  72  * BodyHandler} provided when sending the {@code HttpRequest}.
  73  *
  74  * &lt;p&gt; This class provides methods for accessing the response status code,
  75  * headers, the response body, and the {@code HttpRequest} corresponding
  76  * to this response.
  77  *
  78  * &lt;p&gt; The following is an example of retrieving a response as a String:
  79  *
  80  * &lt;pre&gt;{@code    HttpResponse&lt;String&gt; response = client
  81  *     .send(request, BodyHandlers.ofString()); }&lt;/pre&gt;
  82  *
  83  * &lt;p&gt; The class {@link BodyHandlers BodyHandlers} provides implementations
  84  * of many common response handlers. Alternatively, a custom {@code BodyHandler}
  85  * implementation can be used.
  86  *
  87  * @param &lt;T&gt; the response body type
  88  * @since 11
  89  */
  90 public interface HttpResponse&lt;T&gt; {
  91 
  92 
  93     /**
  94      * Returns the status code for this response.
  95      *
  96      * @return the response code
  97      */
  98     public int statusCode();
  99 
 100     /**
 101      * Returns the {@link HttpRequest} corresponding to this response.
 102      *
 103      * &lt;p&gt; The returned {@code HttpRequest} may not be the initiating request
 104      * provided when {@linkplain HttpClient#send(HttpRequest, BodyHandler)
 105      * sending}. For example, if the initiating request was redirected, then the
 106      * request returned by this method will have the redirected URI, which will
 107      * be different from the initiating request URI.
 108      *
 109      * @see #previousResponse()
 110      *
 111      * @return the request
 112      */
 113     public HttpRequest request();
 114 
 115     /**
 116      * Returns an {@code Optional} containing the previous intermediate response
 117      * if one was received. An intermediate response is one that is received
 118      * as a result of redirection or authentication. If no previous response
 119      * was received then an empty {@code Optional} is returned.
 120      *
 121      * @return an Optional containing the HttpResponse, if any.
 122      */
 123     public Optional&lt;HttpResponse&lt;T&gt;&gt; previousResponse();
 124 
 125     /**
 126      * Returns the received response headers.
 127      *
 128      * @return the response headers
 129      */
 130     public HttpHeaders headers();
 131 
 132     /**
 133      * Returns the body. Depending on the type of {@code T}, the returned body
 134      * may represent the body after it was read (such as {@code byte[]}, or
 135      * {@code String}, or {@code Path}) or it may represent an object with
 136      * which the body is read, such as an {@link java.io.InputStream}.
 137      *
 138      * &lt;p&gt; If this {@code HttpResponse} was returned from an invocation of
 139      * {@link #previousResponse()} then this method returns {@code null}
 140      *
 141      * @return the body
 142      */
 143     public T body();
 144 
 145     /**
 146      * Returns an {@link Optional} containing the {@link SSLSession} in effect
 147      * for this response. Returns an empty {@code Optional} if this is not a
 148      * &lt;i&gt;HTTPS&lt;/i&gt; response.
 149      *
 150      * @return an {@code Optional} containing the {@code SSLSession} associated
 151      *         with the response
 152      */
 153     public Optional&lt;SSLSession&gt; sslSession();
 154 
 155     /**
 156      * Returns the {@code URI} that the response was received from. This may be
 157      * different from the request {@code URI} if redirection occurred.
 158      *
 159      * @return the URI of the response
 160      */
 161      public URI uri();
 162 
 163     /**
 164      * Returns the HTTP protocol version that was used for this response.
 165      *
 166      * @return HTTP protocol version
 167      */
 168     public HttpClient.Version version();
 169 
 170 
 171     /**
 172      * Initial response information supplied to a {@link BodyHandler BodyHandler}
 173      * when a response is initially received and before the body is processed.
 174      */
 175     public interface ResponseInfo {
 176         /**
 177          * Provides the response status code.
 178          * @return the response status code
 179          */
 180         public int statusCode();
 181 
 182         /**
 183          * Provides the response headers.
 184          * @return the response headers
 185          */
 186         public HttpHeaders headers();
 187 
 188         /**
 189          * Provides the response protocol version.
 190          * @return the response protocol version
 191          */
 192         public HttpClient.Version version();
 193     }
 194 
 195     /**
 196      * A handler for response bodies.  The class {@link BodyHandlers BodyHandlers}
 197      * provides implementations of many common body handlers.
 198      *
 199      * &lt;p&gt; The {@code BodyHandler} interface allows inspection of the response
 200      * code and headers, before the actual response body is received, and is
 201      * responsible for creating the response {@link BodySubscriber
 202      * BodySubscriber}. The {@code BodySubscriber} consumes the actual response
 203      * body bytes and, typically, converts them into a higher-level Java type.
 204      *
 205      * &lt;p&gt; A {@code BodyHandler} is a function that takes a {@link ResponseInfo
 206      * ResponseInfo} object; and which returns a {@code BodySubscriber}. The
 207      * {@code BodyHandler} is invoked when the response status code and headers
 208      * are available, but before the response  body bytes are received.
 209      *
 210      * &lt;p&gt; The following example uses one of the {@linkplain BodyHandlers
 211      * predefined body handlers} that always process the response body in the
 212      * same way ( streams the response body to a file ).
 213      *
 214      * &lt;pre&gt;{@code   HttpRequest request = HttpRequest.newBuilder()
 215      *        .uri(URI.create(&quot;http://www.foo.com/&quot;))
 216      *        .build();
 217      *  client.sendAsync(request, BodyHandlers.ofFile(Paths.get(&quot;/tmp/f&quot;)))
 218      *        .thenApply(HttpResponse::body)
 219      *        .thenAccept(System.out::println); }&lt;/pre&gt;
 220      *
 221      * Note, that even though the pre-defined handlers do not examine the
 222      * response code, the response code and headers are always retrievable from
 223      * the {@link HttpResponse}, when it is returned.
 224      *
 225      * &lt;p&gt; In the second example, the function returns a different subscriber
 226      * depending on the status code.
 227      * &lt;pre&gt;{@code   HttpRequest request = HttpRequest.newBuilder()
 228      *        .uri(URI.create(&quot;http://www.foo.com/&quot;))
 229      *        .build();
 230      *  BodyHandler&lt;Path&gt; bodyHandler = (rspInfo) -&gt; rspInfo.statusCode() == 200
 231      *                      ? BodySubscribers.ofFile(Paths.get(&quot;/tmp/f&quot;))
 232      *                      : BodySubscribers.replacing(Paths.get(&quot;/NULL&quot;));
 233      *  client.sendAsync(request, bodyHandler)
 234      *        .thenApply(HttpResponse::body)
 235      *        .thenAccept(System.out::println); }&lt;/pre&gt;
 236      *
 237      * @param &lt;T&gt; the response body type
 238      * @see BodyHandlers
 239      * @since 11
 240      */
 241     @FunctionalInterface
 242     public interface BodyHandler&lt;T&gt; {
 243 
 244         /**
 245          * Returns a {@link BodySubscriber BodySubscriber} considering the
 246          * given response status code and headers. This method is invoked before
 247          * the actual response body bytes are read and its implementation must
 248          * return a {@link BodySubscriber BodySubscriber} to consume the response
 249          * body bytes.
 250          *
 251          * &lt;p&gt; The response body can be discarded using one of {@link
 252          * BodyHandlers#discarding() discarding} or {@link
 253          * BodyHandlers#replacing(Object) replacing}.
 254          *
 255          * @param responseInfo the response info
 256          * @return a body subscriber
 257          */
 258         public BodySubscriber&lt;T&gt; apply(ResponseInfo responseInfo);
 259     }
 260 
 261     /**
 262      * Implementations of {@link BodyHandler BodyHandler} that implement various
 263      * useful handlers, such as handling the response body as a String, or
 264      * streaming the response body to a file.
 265      *
 266      * &lt;p&gt; These implementations do not examine the status code, meaning the
 267      * body is always accepted. They typically return an equivalently named
 268      * {@code BodySubscriber}. Alternatively, a custom handler can be used to
 269      * examine the status code and headers, and return a different body
 270      * subscriber, of the same type, as appropriate.
 271      *
 272      * &lt;p&gt;The following are examples of using the predefined body handlers to
 273      * convert a flow of response body data into common high-level Java objects:
 274      *
 275      * &lt;pre&gt;{@code    // Receives the response body as a String
 276      *   HttpResponse&lt;String&gt; response = client
 277      *     .send(request, BodyHandlers.ofString());
 278      *
 279      *   // Receives the response body as a file
 280      *   HttpResponse&lt;Path&gt; response = client
 281      *     .send(request, BodyHandlers.ofFile(Paths.get(&quot;example.html&quot;)));
 282      *
 283      *   // Receives the response body as an InputStream
 284      *   HttpResponse&lt;InputStream&gt; response = client
 285      *     .send(request, BodyHandlers.ofInputStream());
 286      *
 287      *   // Discards the response body
 288      *   HttpResponse&lt;Void&gt; response = client
 289      *     .send(request, BodyHandlers.discarding());  }&lt;/pre&gt;
 290      *
 291      * @since 11
 292      */
 293     public static class BodyHandlers {
 294 
 295         private BodyHandlers() { }
 296 
 297         /**
 298          * Returns a response body handler that returns a {@link BodySubscriber
 299          * BodySubscriber}{@code &lt;Void&gt;} obtained from {@link
 300          * BodySubscribers#fromSubscriber(Subscriber)}, with the given
 301          * {@code subscriber}.
 302          *
 303          * &lt;p&gt; The response body is not available through this, or the {@code
 304          * HttpResponse} API, but instead all response body is forwarded to the
 305          * given {@code subscriber}, which should make it available, if
 306          * appropriate, through some other mechanism, e.g. an entry in a
 307          * database, etc.
 308          *
 309          * @apiNote This method can be used as an adapter between {@code
 310          * BodySubscriber} and {@code Flow.Subscriber}.
 311          *
 312          * &lt;p&gt; For example:
 313          * &lt;pre&gt; {@code  TextSubscriber subscriber = new TextSubscriber();
 314          *  HttpResponse&lt;Void&gt; response = client.sendAsync(request,
 315          *      BodyHandlers.fromSubscriber(subscriber)).join();
 316          *  System.out.println(response.statusCode()); }&lt;/pre&gt;
 317          *
 318          * @param subscriber the subscriber
 319          * @return a response body handler
 320          */
 321         public static BodyHandler&lt;Void&gt;
 322         fromSubscriber(Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; subscriber) {
 323             Objects.requireNonNull(subscriber);
 324             return (responseInfo) -&gt; BodySubscribers.fromSubscriber(subscriber,
 325                                                                        s -&gt; null);
 326         }
 327 
 328         /**
 329          * Returns a response body handler that returns a {@link BodySubscriber
 330          * BodySubscriber}{@code &lt;T&gt;} obtained from {@link
 331          * BodySubscribers#fromSubscriber(Subscriber, Function)}, with the
 332          * given {@code subscriber} and {@code finisher} function.
 333          *
 334          * &lt;p&gt; The given {@code finisher} function is applied after the given
 335          * subscriber&#39;s {@code onComplete} has been invoked. The {@code finisher}
 336          * function is invoked with the given subscriber, and returns a value
 337          * that is set as the response&#39;s body.
 338          *
 339          * @apiNote This method can be used as an adapter between {@code
 340          * BodySubscriber} and {@code Flow.Subscriber}.
 341          *
 342          * &lt;p&gt; For example:
 343          * &lt;pre&gt; {@code  TextSubscriber subscriber = ...;  // accumulates bytes and transforms them into a String
 344          *  HttpResponse&lt;String&gt; response = client.sendAsync(request,
 345          *      BodyHandlers.fromSubscriber(subscriber, TextSubscriber::getTextResult)).join();
 346          *  String text = response.body(); }&lt;/pre&gt;
 347          *
 348          * @param &lt;S&gt; the type of the Subscriber
 349          * @param &lt;T&gt; the type of the response body
 350          * @param subscriber the subscriber
 351          * @param finisher a function to be applied after the subscriber has completed
 352          * @return a response body handler
 353          */
 354         public static &lt;S extends Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt;,T&gt; BodyHandler&lt;T&gt;
 355         fromSubscriber(S subscriber, Function&lt;? super S,? extends T&gt; finisher) {
 356             Objects.requireNonNull(subscriber);
 357             Objects.requireNonNull(finisher);
 358             return (responseInfo) -&gt; BodySubscribers.fromSubscriber(subscriber,
 359                                                                       finisher);
 360         }
 361 
 362         /**
 363          * Returns a response body handler that returns a {@link BodySubscriber
 364          * BodySubscriber}{@code &lt;Void&gt;} obtained from {@link
 365          * BodySubscribers#fromLineSubscriber(Subscriber, Function, Charset, String)
 366          * BodySubscribers.fromLineSubscriber(subscriber, s -&gt; null, charset, null)},
 367          * with the given {@code subscriber}.
 368          * The {@link Charset charset} used to decode the response body bytes is
 369          * obtained from the HTTP response headers as specified by {@link #ofString()},
 370          * and lines are delimited in the manner of {@link BufferedReader#readLine()}.
 371          *
 372          * &lt;p&gt; The response body is not available through this, or the {@code
 373          * HttpResponse} API, but instead all response body is forwarded to the
 374          * given {@code subscriber}, which should make it available, if
 375          * appropriate, through some other mechanism, e.g. an entry in a
 376          * database, etc.
 377          *
 378          * @apiNote This method can be used as an adapter between a {@code
 379          * BodySubscriber} and a text based {@code Flow.Subscriber} that parses
 380          * text line by line.
 381          *
 382          * &lt;p&gt; For example:
 383          * &lt;pre&gt; {@code  // A PrintSubscriber that implements Flow.Subscriber&lt;String&gt;
 384          *  // and print lines received by onNext() on System.out
 385          *  PrintSubscriber subscriber = new PrintSubscriber(System.out);
 386          *  client.sendAsync(request, BodyHandlers.fromLineSubscriber(subscriber))
 387          *      .thenApply(HttpResponse::statusCode)
 388          *      .thenAccept((status) -&gt; {
 389          *          if (status != 200) {
 390          *              System.err.printf(&quot;ERROR: %d status received%n&quot;, status);
 391          *          }
 392          *      }); }&lt;/pre&gt;
 393          *
 394          * @param subscriber the subscriber
 395          * @return a response body handler
 396          */
 397         public static BodyHandler&lt;Void&gt;
 398         fromLineSubscriber(Subscriber&lt;? super String&gt; subscriber) {
 399             Objects.requireNonNull(subscriber);
 400             return (responseInfo) -&gt;
 401                         BodySubscribers.fromLineSubscriber(subscriber,
 402                                                            s -&gt; null,
 403                                                            charsetFrom(responseInfo.headers()),
 404                                                            null);
 405         }
 406 
 407         /**
 408          * Returns a response body handler that returns a {@link BodySubscriber
 409          * BodySubscriber}{@code &lt;T&gt;} obtained from {@link
 410          * BodySubscribers#fromLineSubscriber(Subscriber, Function, Charset, String)
 411          * BodySubscribers.fromLineSubscriber(subscriber, finisher, charset, lineSeparator)},
 412          * with the given {@code subscriber}, {@code finisher} function, and line separator.
 413          * The {@link Charset charset} used to decode the response body bytes is
 414          * obtained from the HTTP response headers as specified by {@link #ofString()}.
 415          *
 416          * &lt;p&gt; The given {@code finisher} function is applied after the given
 417          * subscriber&#39;s {@code onComplete} has been invoked. The {@code finisher}
 418          * function is invoked with the given subscriber, and returns a value
 419          * that is set as the response&#39;s body.
 420          *
 421          * @apiNote This method can be used as an adapter between a {@code
 422          * BodySubscriber} and a text based {@code Flow.Subscriber} that parses
 423          * text line by line.
 424          *
 425          * &lt;p&gt; For example:
 426          * &lt;pre&gt; {@code  // A LineParserSubscriber that implements Flow.Subscriber&lt;String&gt;
 427          *  // and accumulates lines that match a particular pattern
 428          *  Pattern pattern = ...;
 429          *  LineParserSubscriber subscriber = new LineParserSubscriber(pattern);
 430          *  HttpResponse&lt;List&lt;String&gt;&gt; response = client.send(request,
 431          *      BodyHandlers.fromLineSubscriber(subscriber, s -&gt; s.getMatchingLines(), &quot;\n&quot;));
 432          *  if (response.statusCode() != 200) {
 433          *      System.err.printf(&quot;ERROR: %d status received%n&quot;, response.statusCode());
 434          *  } }&lt;/pre&gt;
 435          *
 436          *
 437          * @param &lt;S&gt; the type of the Subscriber
 438          * @param &lt;T&gt; the type of the response body
 439          * @param subscriber the subscriber
 440          * @param finisher a function to be applied after the subscriber has completed
 441          * @param lineSeparator an optional line separator: can be {@code null},
 442          *                      in which case lines will be delimited in the manner of
 443          *                      {@link BufferedReader#readLine()}.
 444          * @return a response body handler
 445          * @throws IllegalArgumentException if the supplied {@code lineSeparator}
 446          *         is the empty string
 447          */
 448         public static &lt;S extends Subscriber&lt;? super String&gt;,T&gt; BodyHandler&lt;T&gt;
 449         fromLineSubscriber(S subscriber,
 450                            Function&lt;? super S,? extends T&gt; finisher,
 451                            String lineSeparator) {
 452             Objects.requireNonNull(subscriber);
 453             Objects.requireNonNull(finisher);
 454             // implicit null check
 455             if (lineSeparator != null &amp;&amp; lineSeparator.isEmpty())
 456                 throw new IllegalArgumentException(&quot;empty line separator&quot;);
 457             return (responseInfo) -&gt;
 458                         BodySubscribers.fromLineSubscriber(subscriber,
 459                                                            finisher,
 460                                                            charsetFrom(responseInfo.headers()),
 461                                                            lineSeparator);
 462         }
 463 
 464         /**
 465          * Returns a response body handler that discards the response body.
 466          *
 467          * @return a response body handler
 468          */
 469         public static BodyHandler&lt;Void&gt; discarding() {
 470             return (responseInfo) -&gt; BodySubscribers.discarding();
 471         }
 472 
 473         /**
 474          * Returns a response body handler that returns the given replacement
 475          * value, after discarding the response body.
 476          *
 477          * @param &lt;U&gt; the response body type
 478          * @param value the value of U to return as the body, may be {@code null}
 479          * @return a response body handler
 480          */
 481         public static &lt;U&gt; BodyHandler&lt;U&gt; replacing(U value) {
 482             return (responseInfo) -&gt; BodySubscribers.replacing(value);
 483         }
 484 
 485         /**
 486          * Returns a {@code BodyHandler&lt;String&gt;} that returns a
 487          * {@link BodySubscriber BodySubscriber}{@code &lt;String&gt;} obtained from
 488          * {@link BodySubscribers#ofString(Charset) BodySubscribers.ofString(Charset)}.
 489          * The body is decoded using the given character set.
 490          *
 491          * @param charset the character set to convert the body with
 492          * @return a response body handler
 493          */
 494         public static BodyHandler&lt;String&gt; ofString(Charset charset) {
 495             Objects.requireNonNull(charset);
 496             return (responseInfo) -&gt; BodySubscribers.ofString(charset);
 497         }
 498 
 499         /**
 500          * Returns a {@code BodyHandler&lt;Path&gt;} that returns a
 501          * {@link BodySubscriber BodySubscriber}{@code &lt;Path&gt;} obtained from
 502          * {@link BodySubscribers#ofFile(Path, OpenOption...)
 503          * BodySubscribers.ofFile(Path,OpenOption...)}.
 504          *
 505          * &lt;p&gt; When the {@code HttpResponse} object is returned, the body has
 506          * been completely written to the file, and {@link #body()} returns a
 507          * reference to its {@link Path}.
 508          *
<a name="1" id="anc1"></a><span class="line-modified"> 509          * &lt;p&gt; In the case of the default file system provider, security manager</span>
<span class="line-modified"> 510          * permission checks are performed in this factory method, when the</span>
<span class="line-modified"> 511          * {@code BodyHandler} is created. Otherwise,</span>
<span class="line-modified"> 512          * {@linkplain FileChannel#open(Path, OpenOption...) permission checks}</span>
<span class="line-modified"> 513          * may be performed asynchronously against the caller&#39;s context</span>
<span class="line-modified"> 514          * at file access time.</span>
<span class="line-added"> 515          * Care must be taken that the {@code BodyHandler} is not shared with</span>
<span class="line-added"> 516          * untrusted code.</span>
<span class="line-added"> 517          *</span>
<span class="line-added"> 518          * @param  file the file to store the body in</span>
<span class="line-added"> 519          * @param  openOptions any options to use when opening/creating the file</span>
 520          * @return a response body handler
 521          * @throws IllegalArgumentException if an invalid set of open options
<a name="2" id="anc2"></a><span class="line-modified"> 522          *         are specified</span>
<span class="line-modified"> 523          * @throws SecurityException in the case of the default file system</span>
<span class="line-modified"> 524          *         provider, and a security manager is installed,</span>
<span class="line-modified"> 525          *         {@link SecurityManager#checkWrite(String) checkWrite}</span>
<span class="line-added"> 526          *         is invoked to check write access to the given file</span>
 527          */
 528         public static BodyHandler&lt;Path&gt; ofFile(Path file, OpenOption... openOptions) {
 529             Objects.requireNonNull(file);
 530             List&lt;OpenOption&gt; opts = List.of(openOptions);
 531             if (opts.contains(DELETE_ON_CLOSE) || opts.contains(READ)) {
 532                 // these options make no sense, since the FileChannel is not exposed
 533                 throw new IllegalArgumentException(&quot;invalid openOptions: &quot; + opts);
 534             }
 535             return PathBodyHandler.create(file, opts);
 536         }
 537 
 538         /**
 539          * Returns a {@code BodyHandler&lt;Path&gt;} that returns a
 540          * {@link BodySubscriber BodySubscriber}{@code &lt;Path&gt;}.
 541          *
 542          * &lt;p&gt; Equivalent to: {@code ofFile(file, CREATE, WRITE)}
 543          *
<a name="3" id="anc3"></a><span class="line-modified"> 544          * &lt;p&gt; In the case of the default file system provider, security manager</span>
<span class="line-modified"> 545          * permission checks are performed in this factory method, when the</span>
<span class="line-modified"> 546          * {@code BodyHandler} is created. Otherwise,</span>
<span class="line-added"> 547          * {@linkplain FileChannel#open(Path, OpenOption...) permission checks}</span>
<span class="line-added"> 548          * may be performed asynchronously against the caller&#39;s context</span>
<span class="line-added"> 549          * at file access time.</span>
<span class="line-added"> 550          * Care must be taken that the {@code BodyHandler} is not shared with</span>
<span class="line-added"> 551          * untrusted code.</span>
 552          *
<a name="4" id="anc4"></a><span class="line-modified"> 553          * @param  file the file to store the body in</span>
 554          * @return a response body handler
<a name="5" id="anc5"></a><span class="line-modified"> 555          * @throws SecurityException in the case of the default file system</span>
<span class="line-modified"> 556          *         provider, and a security manager is installed,</span>
<span class="line-modified"> 557          *         {@link SecurityManager#checkWrite(String) checkWrite}</span>
<span class="line-added"> 558          *         is invoked to check write access to the given file</span>
 559          */
 560         public static BodyHandler&lt;Path&gt; ofFile(Path file) {
 561             return BodyHandlers.ofFile(file, CREATE, WRITE);
 562         }
 563 
 564         /**
 565          * Returns a {@code BodyHandler&lt;Path&gt;} that returns a
 566          * {@link BodySubscriber BodySubscriber}&amp;lt;{@link Path}&amp;gt;
 567          * where the download directory is specified, but the filename is
 568          * obtained from the {@code Content-Disposition} response header. The
 569          * {@code Content-Disposition} header must specify the &lt;i&gt;attachment&lt;/i&gt;
 570          * type and must also contain a &lt;i&gt;filename&lt;/i&gt; parameter. If the
 571          * filename specifies multiple path components only the final component
 572          * is used as the filename (with the given directory name).
 573          *
 574          * &lt;p&gt; When the {@code HttpResponse} object is returned, the body has
 575          * been completely written to the file and {@link #body()} returns a
 576          * {@code Path} object for the file. The returned {@code Path} is the
 577          * combination of the supplied directory name and the file name supplied
 578          * by the server. If the destination directory does not exist or cannot
 579          * be written to, then the response will fail with an {@link IOException}.
 580          *
 581          * &lt;p&gt; Security manager permission checks are performed in this factory
 582          * method, when the {@code BodyHandler} is created. Care must be taken
 583          * that the {@code BodyHandler} is not shared with untrusted code.
 584          *
<a name="6" id="anc6"></a><span class="line-modified"> 585          * @param  directory the directory to store the file in</span>
<span class="line-modified"> 586          * @param  openOptions open options used when opening the file</span>
 587          * @return a response body handler
 588          * @throws IllegalArgumentException if the given path does not exist,
<a name="7" id="anc7"></a><span class="line-modified"> 589          *         is not of the default file system, is not a directory,</span>
<span class="line-modified"> 590          *         is not writable, or if an invalid set of open options</span>
<span class="line-modified"> 591          *         are specified</span>
<span class="line-modified"> 592          * @throws SecurityException in the case of the default file system</span>
<span class="line-modified"> 593          *         provider and a security manager has been installed,</span>
<span class="line-modified"> 594          *         and it denies</span>
<span class="line-modified"> 595          *         {@linkplain SecurityManager#checkRead(String) read access}</span>
<span class="line-modified"> 596          *         to the directory, or it denies</span>
<span class="line-modified"> 597          *         {@linkplain SecurityManager#checkWrite(String) write access}</span>
<span class="line-modified"> 598          *         to the directory, or it denies</span>
<span class="line-added"> 599          *         {@linkplain SecurityManager#checkWrite(String) write access}</span>
<span class="line-added"> 600          *         to the files within the directory.</span>
 601          */
 602         public static BodyHandler&lt;Path&gt; ofFileDownload(Path directory,
 603                                                        OpenOption... openOptions) {
 604             Objects.requireNonNull(directory);
 605             List&lt;OpenOption&gt; opts = List.of(openOptions);
 606             if (opts.contains(DELETE_ON_CLOSE)) {
 607                 throw new IllegalArgumentException(&quot;invalid option: &quot; + DELETE_ON_CLOSE);
 608             }
 609             return FileDownloadBodyHandler.create(directory, opts);
 610         }
 611 
 612         /**
 613          * Returns a {@code BodyHandler&lt;InputStream&gt;} that returns a
 614          * {@link BodySubscriber BodySubscriber}{@code &lt;InputStream&gt;} obtained from
 615          * {@link BodySubscribers#ofInputStream() BodySubscribers.ofInputStream}.
 616          *
 617          * &lt;p&gt; When the {@code HttpResponse} object is returned, the response
 618          * headers will have been completely read, but the body may not have
 619          * been fully received yet. The {@link #body()} method returns an
 620          * {@link InputStream} from which the body can be read as it is received.
 621          *
 622          * @apiNote See {@link BodySubscribers#ofInputStream()} for more
 623          * information.
 624          *
 625          * @return a response body handler
 626          */
 627         public static BodyHandler&lt;InputStream&gt; ofInputStream() {
 628             return (responseInfo) -&gt; BodySubscribers.ofInputStream();
 629         }
 630 
 631         /**
 632          * Returns a {@code BodyHandler&lt;Stream&lt;String&gt;&gt;} that returns a
 633          * {@link BodySubscriber BodySubscriber}{@code &lt;Stream&lt;String&gt;&gt;} obtained
 634          * from {@link BodySubscribers#ofLines(Charset) BodySubscribers.ofLines(charset)}.
 635          * The {@link Charset charset} used to decode the response body bytes is
 636          * obtained from the HTTP response headers as specified by {@link #ofString()},
 637          * and lines are delimited in the manner of {@link BufferedReader#readLine()}.
 638          *
 639          * &lt;p&gt; When the {@code HttpResponse} object is returned, the body may
 640          * not have been completely received.
 641          *
 642          * @return a response body handler
 643          */
 644         public static BodyHandler&lt;Stream&lt;String&gt;&gt; ofLines() {
 645             return (responseInfo) -&gt;
 646                     BodySubscribers.ofLines(charsetFrom(responseInfo.headers()));
 647         }
 648 
 649         /**
 650          * Returns a {@code BodyHandler&lt;Void&gt;} that returns a
 651          * {@link BodySubscriber BodySubscriber}{@code &lt;Void&gt;} obtained from
 652          * {@link BodySubscribers#ofByteArrayConsumer(Consumer)
 653          * BodySubscribers.ofByteArrayConsumer(Consumer)}.
 654          *
 655          * &lt;p&gt; When the {@code HttpResponse} object is returned, the body has
 656          * been completely written to the consumer.
 657          *
 658          * @apiNote
 659          * The subscriber returned by this handler is not flow controlled.
 660          * Therefore, the supplied consumer must be able to process whatever
 661          * amount of data is delivered in a timely fashion.
 662          *
 663          * @param consumer a Consumer to accept the response body
 664          * @return a response body handler
 665          */
 666         public static BodyHandler&lt;Void&gt;
 667         ofByteArrayConsumer(Consumer&lt;Optional&lt;byte[]&gt;&gt; consumer) {
 668             Objects.requireNonNull(consumer);
 669             return (responseInfo) -&gt; BodySubscribers.ofByteArrayConsumer(consumer);
 670         }
 671 
 672         /**
 673          * Returns a {@code BodyHandler&lt;byte[]&gt;} that returns a
 674          * {@link BodySubscriber BodySubscriber}{@code &lt;byte[]&gt;} obtained
 675          * from {@link BodySubscribers#ofByteArray() BodySubscribers.ofByteArray()}.
 676          *
 677          * &lt;p&gt; When the {@code HttpResponse} object is returned, the body has
 678          * been completely written to the byte array.
 679          *
 680          * @return a response body handler
 681          */
 682         public static BodyHandler&lt;byte[]&gt; ofByteArray() {
 683             return (responseInfo) -&gt; BodySubscribers.ofByteArray();
 684         }
 685 
 686         /**
 687          * Returns a {@code BodyHandler&lt;String&gt;} that returns a
 688          * {@link BodySubscriber BodySubscriber}{@code &lt;String&gt;} obtained from
 689          * {@link BodySubscribers#ofString(Charset) BodySubscribers.ofString(Charset)}.
 690          * The body is decoded using the character set specified in
 691          * the {@code Content-Type} response header. If there is no such
 692          * header, or the character set is not supported, then
 693          * {@link StandardCharsets#UTF_8 UTF_8} is used.
 694          *
 695          * &lt;p&gt; When the {@code HttpResponse} object is returned, the body has
 696          * been completely written to the string.
 697          *
 698          * @return a response body handler
 699          */
 700         public static BodyHandler&lt;String&gt; ofString() {
 701             return (responseInfo) -&gt; BodySubscribers.ofString(charsetFrom(responseInfo.headers()));
 702         }
 703 
 704         /**
 705          * Returns a {@code BodyHandler&lt;Publisher&lt;List&lt;ByteBuffer&gt;&gt;&gt;} that creates a
 706          * {@link BodySubscriber BodySubscriber}{@code &lt;Publisher&lt;List&lt;ByteBuffer&gt;&gt;&gt;}
 707          * obtained from {@link BodySubscribers#ofPublisher()
 708          * BodySubscribers.ofPublisher()}.
 709          *
 710          * &lt;p&gt; When the {@code HttpResponse} object is returned, the response
 711          * headers will have been completely read, but the body may not have
 712          * been fully received yet. The {@link #body()} method returns a
 713          * {@link Publisher Publisher}{@code &lt;List&lt;ByteBuffer&gt;&gt;} from which the body
 714          * response bytes can be obtained as they are received. The publisher
 715          * can and must be subscribed to only once.
 716          *
 717          * @apiNote See {@link BodySubscribers#ofPublisher()} for more
 718          * information.
 719          *
 720          * @return a response body handler
 721          */
 722         public static BodyHandler&lt;Publisher&lt;List&lt;ByteBuffer&gt;&gt;&gt; ofPublisher() {
 723             return (responseInfo) -&gt; BodySubscribers.ofPublisher();
 724         }
 725 
 726         /**
 727          * Returns a {@code BodyHandler} which, when invoked, returns a {@linkplain
 728          * BodySubscribers#buffering(BodySubscriber,int) buffering BodySubscriber}
 729          * that buffers data before delivering it to the downstream subscriber.
 730          * These {@code BodySubscriber} instances are created by calling
 731          * {@link BodySubscribers#buffering(BodySubscriber,int)
 732          * BodySubscribers.buffering} with a subscriber obtained from the given
 733          * downstream handler and the {@code bufferSize} parameter.
 734          *
 735          * @param &lt;T&gt; the response body type
 736          * @param downstreamHandler the downstream handler
 737          * @param bufferSize the buffer size parameter passed to {@link
 738          *        BodySubscribers#buffering(BodySubscriber,int) BodySubscribers.buffering}
 739          * @return a body handler
 740          * @throws IllegalArgumentException if {@code bufferSize &lt;= 0}
 741          */
 742          public static &lt;T&gt; BodyHandler&lt;T&gt; buffering(BodyHandler&lt;T&gt; downstreamHandler,
 743                                                     int bufferSize) {
 744              Objects.requireNonNull(downstreamHandler);
 745              if (bufferSize &lt;= 0)
 746                  throw new IllegalArgumentException(&quot;must be greater than 0&quot;);
 747              return (responseInfo) -&gt; BodySubscribers
 748                      .buffering(downstreamHandler.apply(responseInfo),
 749                                 bufferSize);
 750          }
 751     }
 752 
 753     /**
 754      * A handler for push promises.
 755      *
 756      * &lt;p&gt; A &lt;i&gt;push promise&lt;/i&gt; is a synthetic request sent by an HTTP/2 server
 757      * when retrieving an initiating client-sent request. The server has
 758      * determined, possibly through inspection of the initiating request, that
 759      * the client will likely need the promised resource, and hence pushes a
 760      * synthetic push request, in the form of a push promise, to the client. The
 761      * client can choose to accept or reject the push promise request.
 762      *
 763      * &lt;p&gt; A push promise request may be received up to the point where the
 764      * response body of the initiating client-sent request has been fully
 765      * received. The delivery of a push promise response, however, is not
 766      * coordinated with the delivery of the response to the initiating
 767      * client-sent request.
 768      *
 769      * @param &lt;T&gt; the push promise response body type
 770      * @since 11
 771      */
 772     public interface PushPromiseHandler&lt;T&gt; {
 773 
 774         /**
 775          * Notification of an incoming push promise.
 776          *
 777          * &lt;p&gt; This method is invoked once for each push promise received, up
 778          * to the point where the response body of the initiating client-sent
 779          * request has been fully received.
 780          *
 781          * &lt;p&gt; A push promise is accepted by invoking the given {@code acceptor}
 782          * function. The {@code acceptor} function must be passed a non-null
 783          * {@code BodyHandler}, that is to be used to handle the promise&#39;s
 784          * response body. The acceptor function will return a {@code
 785          * CompletableFuture} that completes with the promise&#39;s response.
 786          *
 787          * &lt;p&gt; If the {@code acceptor} function is not successfully invoked,
 788          * then the push promise is rejected. The {@code acceptor} function will
 789          * throw an {@code IllegalStateException} if invoked more than once.
 790          *
 791          * @param initiatingRequest the initiating client-send request
 792          * @param pushPromiseRequest the synthetic push request
 793          * @param acceptor the acceptor function that must be successfully
 794          *                 invoked to accept the push promise
 795          */
 796         public void applyPushPromise(
 797             HttpRequest initiatingRequest,
 798             HttpRequest pushPromiseRequest,
 799             Function&lt;HttpResponse.BodyHandler&lt;T&gt;,CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;&gt; acceptor
 800         );
 801 
 802 
 803         /**
 804          * Returns a push promise handler that accumulates push promises, and
 805          * their responses, into the given map.
 806          *
 807          * &lt;p&gt; Entries are added to the given map for each push promise accepted.
 808          * The entry&#39;s key is the push request, and the entry&#39;s value is a
 809          * {@code CompletableFuture} that completes with the response
 810          * corresponding to the key&#39;s push request. A push request is rejected /
 811          * cancelled if there is already an entry in the map whose key is
 812          * {@linkplain HttpRequest#equals equal} to it. A push request is
 813          * rejected / cancelled if it  does not have the same origin as its
 814          * initiating request.
 815          *
 816          * &lt;p&gt; Entries are added to the given map as soon as practically
 817          * possible when a push promise is received and accepted. That way code,
 818          * using such a map like a cache, can determine if a push promise has
 819          * been issued by the server and avoid making, possibly, unnecessary
 820          * requests.
 821          *
 822          * &lt;p&gt; The delivery of a push promise response is not coordinated with
 823          * the delivery of the response to the initiating client-sent request.
 824          * However, when the response body for the initiating client-sent
 825          * request has been fully received, the map is guaranteed to be fully
 826          * populated, that is, no more entries will be added. The individual
 827          * {@code CompletableFutures} contained in the map may or may not
 828          * already be completed at this point.
 829          *
 830          * @param &lt;T&gt; the push promise response body type
 831          * @param pushPromiseHandler t he body handler to use for push promises
 832          * @param pushPromisesMap a map to accumulate push promises into
 833          * @return a push promise handler
 834          */
 835         public static &lt;T&gt; PushPromiseHandler&lt;T&gt;
 836         of(Function&lt;HttpRequest,BodyHandler&lt;T&gt;&gt; pushPromiseHandler,
 837            ConcurrentMap&lt;HttpRequest,CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;&gt; pushPromisesMap) {
 838             return new PushPromisesHandlerWithMap&lt;&gt;(pushPromiseHandler, pushPromisesMap);
 839         }
 840     }
 841 
 842     /**
 843      * A {@code BodySubscriber} consumes response body bytes and converts them
 844      * into a higher-level Java type.  The class {@link BodySubscribers
 845      * BodySubscribers} provides implementations of many common body subscribers.
 846      *
 847      * &lt;p&gt; The object acts as a {@link Flow.Subscriber}&amp;lt;{@link List}&amp;lt;{@link
 848      * ByteBuffer}&amp;gt;&amp;gt; to the HTTP Client implementation, which publishes
 849      * lists of ByteBuffers containing the response body. The Flow of data, as
 850      * well as the order of ByteBuffers in the Flow lists, is a strictly ordered
 851      * representation of the response body. Both the Lists and the ByteBuffers,
 852      * once passed to the subscriber, are no longer used by the HTTP Client. The
 853      * subscriber converts the incoming buffers of data to some higher-level
 854      * Java type {@code T}.
 855      *
 856      * &lt;p&gt; The {@link #getBody()} method returns a
 857      * {@link CompletionStage}{@code &lt;T&gt;} that provides the response body
 858      * object. The {@code CompletionStage} must be obtainable at any time. When
 859      * it completes depends on the nature of type {@code T}. In many cases,
 860      * when {@code T} represents the entire body after being consumed then
 861      * the {@code CompletionStage} completes after the body has been consumed.
 862      * If  {@code T} is a streaming type, such as {@link java.io.InputStream
 863      * InputStream}, then it completes before the body has been read, because
 864      * the calling code uses the {@code InputStream} to consume the data.
 865      *
 866      * @apiNote To ensure that all resources associated with the corresponding
 867      * HTTP exchange are properly released, an implementation of {@code
 868      * BodySubscriber} should ensure to {@linkplain Flow.Subscription#request
 869      * request} more data until one of {@link #onComplete() onComplete} or
 870      * {@link #onError(Throwable) onError} are signalled, or {@link
 871      * Flow.Subscription#request cancel} its {@linkplain
 872      * #onSubscribe(Flow.Subscription) subscription} if unable or unwilling to
 873      * do so. Calling {@code cancel} before exhausting the response body data
 874      * may cause the underlying HTTP connection to be closed and prevent it
 875      * from being reused for subsequent operations.
 876      *
 877      * @implNote The flow of data containing the response body is immutable.
 878      * Specifically, it is a flow of unmodifiable lists of read-only ByteBuffers.
 879      *
 880      * @param &lt;T&gt; the response body type
 881      * @see BodySubscribers
 882      * @since 11
 883      */
 884     public interface BodySubscriber&lt;T&gt;
 885             extends Flow.Subscriber&lt;List&lt;ByteBuffer&gt;&gt; {
 886 
 887         /**
 888          * Returns a {@code CompletionStage} which when completed will return
 889          * the response body object. This method can be called at any time
 890          * relative to the other {@link Flow.Subscriber} methods and is invoked
 891          * using the client&#39;s {@link HttpClient#executor() executor}.
 892          *
 893          * @return a CompletionStage for the response body
 894          */
 895         public CompletionStage&lt;T&gt; getBody();
 896     }
 897 
 898     /**
 899      * Implementations of {@link BodySubscriber BodySubscriber} that implement
 900      * various useful subscribers, such as converting the response body bytes
 901      * into a String, or streaming the bytes to a file.
 902      *
 903      * &lt;p&gt;The following are examples of using the predefined body subscribers
 904      * to convert a flow of response body data into common high-level Java
 905      * objects:
 906      *
 907      * &lt;pre&gt;{@code    // Streams the response body to a File
 908      *   HttpResponse&lt;Path&gt; response = client
 909      *     .send(request, responseInfo -&gt; BodySubscribers.ofFile(Paths.get(&quot;example.html&quot;));
 910      *
 911      *   // Accumulates the response body and returns it as a byte[]
 912      *   HttpResponse&lt;byte[]&gt; response = client
 913      *     .send(request, responseInfo -&gt; BodySubscribers.ofByteArray());
 914      *
 915      *   // Discards the response body
 916      *   HttpResponse&lt;Void&gt; response = client
 917      *     .send(request, responseInfo -&gt; BodySubscribers.discarding());
 918      *
 919      *   // Accumulates the response body as a String then maps it to its bytes
 920      *   HttpResponse&lt;byte[]&gt; response = client
 921      *     .send(request, responseInfo -&gt;
 922      *        BodySubscribers.mapping(BodySubscribers.ofString(UTF_8), String::getBytes));
 923      * }&lt;/pre&gt;
 924      *
 925      * @since 11
 926      */
 927     public static class BodySubscribers {
 928 
 929         private BodySubscribers() { }
 930 
 931         /**
 932          * Returns a body subscriber that forwards all response body to the
 933          * given {@code Flow.Subscriber}. The {@linkplain BodySubscriber#getBody()
 934          * completion stage} of the returned body subscriber completes after one
 935          * of the given subscribers {@code onComplete} or {@code onError} has
 936          * been invoked.
 937          *
 938          * @apiNote This method can be used as an adapter between {@code
 939          * BodySubscriber} and {@code Flow.Subscriber}.
 940          *
 941          * @param subscriber the subscriber
 942          * @return a body subscriber
 943          */
 944         public static BodySubscriber&lt;Void&gt;
 945         fromSubscriber(Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; subscriber) {
 946             return new ResponseSubscribers.SubscriberAdapter&lt;&gt;(subscriber, s -&gt; null);
 947         }
 948 
 949         /**
 950          * Returns a body subscriber that forwards all response body to the
 951          * given {@code Flow.Subscriber}. The {@linkplain BodySubscriber#getBody()
 952          * completion stage} of the returned body subscriber completes after one
 953          * of the given subscribers {@code onComplete} or {@code onError} has
 954          * been invoked.
 955          *
 956          * &lt;p&gt; The given {@code finisher} function is applied after the given
 957          * subscriber&#39;s {@code onComplete} has been invoked. The {@code finisher}
 958          * function is invoked with the given subscriber, and returns a value
 959          * that is set as the response&#39;s body.
 960          *
 961          * @apiNote This method can be used as an adapter between {@code
 962          * BodySubscriber} and {@code Flow.Subscriber}.
 963          *
 964          * @param &lt;S&gt; the type of the Subscriber
 965          * @param &lt;T&gt; the type of the response body
 966          * @param subscriber the subscriber
 967          * @param finisher a function to be applied after the subscriber has
 968          *                 completed
 969          * @return a body subscriber
 970          */
 971         public static &lt;S extends Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt;,T&gt; BodySubscriber&lt;T&gt;
 972         fromSubscriber(S subscriber,
 973                        Function&lt;? super S,? extends T&gt; finisher) {
 974             return new ResponseSubscribers.SubscriberAdapter&lt;&gt;(subscriber, finisher);
 975         }
 976 
 977         /**
 978          * Returns a body subscriber that forwards all response body to the
 979          * given {@code Flow.Subscriber}, line by line.
 980          * The {@linkplain BodySubscriber#getBody() completion
 981          * stage} of the returned body subscriber completes after one of the
 982          * given subscribers {@code onComplete} or {@code onError} has been
 983          * invoked.
 984          * Bytes are decoded using the {@link StandardCharsets#UTF_8
 985          * UTF-8} charset, and lines are delimited in the manner of
 986          * {@link BufferedReader#readLine()}.
 987          *
 988          * @apiNote This method can be used as an adapter between {@code
 989          * BodySubscriber} and {@code Flow.Subscriber}.
 990          *
 991          * @implNote This is equivalent to calling &lt;pre&gt;{@code
 992          *      fromLineSubscriber(subscriber, s -&gt; null, StandardCharsets.UTF_8, null)
 993          * }&lt;/pre&gt;
 994          *
 995          * @param subscriber the subscriber
 996          * @return a body subscriber
 997          */
 998         public static BodySubscriber&lt;Void&gt;
 999         fromLineSubscriber(Subscriber&lt;? super String&gt; subscriber) {
1000             return fromLineSubscriber(subscriber,  s -&gt; null,
1001                     StandardCharsets.UTF_8, null);
1002         }
1003 
1004         /**
1005          * Returns a body subscriber that forwards all response body to the
1006          * given {@code Flow.Subscriber}, line by line. The {@linkplain
1007          * BodySubscriber#getBody() completion stage} of the returned body
1008          * subscriber completes after one of the given subscribers
1009          * {@code onComplete} or {@code onError} has been invoked.
1010          *
1011          * &lt;p&gt; The given {@code finisher} function is applied after the given
1012          * subscriber&#39;s {@code onComplete} has been invoked. The {@code finisher}
1013          * function is invoked with the given subscriber, and returns a value
1014          * that is set as the response&#39;s body.
1015          *
1016          * @apiNote This method can be used as an adapter between {@code
1017          * BodySubscriber} and {@code Flow.Subscriber}.
1018          *
1019          * @param &lt;S&gt; the type of the Subscriber
1020          * @param &lt;T&gt; the type of the response body
1021          * @param subscriber the subscriber
1022          * @param finisher a function to be applied after the subscriber has
1023          *                 completed
1024          * @param charset a {@link Charset} to decode the bytes
1025          * @param lineSeparator an optional line separator: can be {@code null},
1026          *                      in which case lines will be delimited in the manner of
1027          *                      {@link BufferedReader#readLine()}.
1028          * @return a body subscriber
1029          * @throws IllegalArgumentException if the supplied {@code lineSeparator}
1030          *         is the empty string
1031          */
1032         public static &lt;S extends Subscriber&lt;? super String&gt;,T&gt; BodySubscriber&lt;T&gt;
1033         fromLineSubscriber(S subscriber,
1034                            Function&lt;? super S,? extends T&gt; finisher,
1035                            Charset charset,
1036                            String lineSeparator) {
1037             return LineSubscriberAdapter.create(subscriber,
1038                     finisher, charset, lineSeparator);
1039         }
1040 
1041         /**
1042          * Returns a body subscriber which stores the response body as a {@code
1043          * String} converted using the given {@code Charset}.
1044          *
1045          * &lt;p&gt; The {@link HttpResponse} using this subscriber is available after
1046          * the entire response has been read.
1047          *
1048          * @param charset the character set to convert the String with
1049          * @return a body subscriber
1050          */
1051         public static BodySubscriber&lt;String&gt; ofString(Charset charset) {
1052             Objects.requireNonNull(charset);
1053             return new ResponseSubscribers.ByteArraySubscriber&lt;&gt;(
1054                     bytes -&gt; new String(bytes, charset)
1055             );
1056         }
1057 
1058         /**
1059          * Returns a {@code BodySubscriber} which stores the response body as a
1060          * byte array.
1061          *
1062          * &lt;p&gt; The {@link HttpResponse} using this subscriber is available after
1063          * the entire response has been read.
1064          *
1065          * @return a body subscriber
1066          */
1067         public static BodySubscriber&lt;byte[]&gt; ofByteArray() {
1068             return new ResponseSubscribers.ByteArraySubscriber&lt;&gt;(
1069                     Function.identity() // no conversion
1070             );
1071         }
1072 
1073         /**
1074          * Returns a {@code BodySubscriber} which stores the response body in a
1075          * file opened with the given options and name. The file will be opened
1076          * with the given options using {@link FileChannel#open(Path,OpenOption...)
1077          * FileChannel.open} just before the body is read. Any exception thrown
1078          * will be returned or thrown from {@link HttpClient#send(HttpRequest,
1079          * BodyHandler) HttpClient::send} or {@link HttpClient#sendAsync(HttpRequest,
1080          * BodyHandler) HttpClient::sendAsync} as appropriate.
1081          *
1082          * &lt;p&gt; The {@link HttpResponse} using this subscriber is available after
1083          * the entire response has been read.
1084          *
<a name="8" id="anc8"></a><span class="line-modified">1085          * &lt;p&gt; In the case of the default file system provider, security manager</span>
<span class="line-modified">1086          * permission checks are performed in this factory method, when the</span>
<span class="line-modified">1087          * {@code BodySubscriber} is created. Otherwise,</span>
<span class="line-modified">1088          * {@linkplain FileChannel#open(Path, OpenOption...) permission checks}</span>
<span class="line-modified">1089          * may be performed asynchronously against the caller&#39;s context</span>
<span class="line-modified">1090          * at file access time.</span>
<span class="line-added">1091          * Care must be taken that the {@code BodySubscriber} is not shared with</span>
<span class="line-added">1092          * untrusted code.</span>
<span class="line-added">1093          *</span>
<span class="line-added">1094          * @param  file the file to store the body in</span>
<span class="line-added">1095          * @param  openOptions the list of options to open the file with</span>
1096          * @return a body subscriber
1097          * @throws IllegalArgumentException if an invalid set of open options
<a name="9" id="anc9"></a><span class="line-modified">1098          *         are specified</span>
<span class="line-modified">1099          * @throws SecurityException in the case of the default file system</span>
<span class="line-modified">1100          *         provider, and a security manager is installed,</span>
<span class="line-modified">1101          *         {@link SecurityManager#checkWrite(String) checkWrite}</span>
<span class="line-added">1102          *         is invoked to check write access to the given file</span>
1103          */
1104         public static BodySubscriber&lt;Path&gt; ofFile(Path file, OpenOption... openOptions) {
1105             Objects.requireNonNull(file);
1106             List&lt;OpenOption&gt; opts = List.of(openOptions);
1107             if (opts.contains(DELETE_ON_CLOSE) || opts.contains(READ)) {
1108                 // these options make no sense, since the FileChannel is not exposed
1109                 throw new IllegalArgumentException(&quot;invalid openOptions: &quot; + opts);
1110             }
1111             return PathSubscriber.create(file, opts);
1112         }
1113 
1114         /**
1115          * Returns a {@code BodySubscriber} which stores the response body in a
1116          * file opened with the given name.
1117          *
1118          * &lt;p&gt; Equivalent to: {@code ofFile(file, CREATE, WRITE)}
1119          *
<a name="10" id="anc10"></a><span class="line-modified">1120          * &lt;p&gt; In the case of the default file system provider, security manager</span>
<span class="line-modified">1121          * permission checks are performed in this factory method, when the</span>
<span class="line-modified">1122          * {@code BodySubscriber} is created. Otherwise,</span>
<span class="line-added">1123          * {@linkplain FileChannel#open(Path, OpenOption...) permission checks}</span>
<span class="line-added">1124          * may be performed asynchronously against the caller&#39;s context</span>
<span class="line-added">1125          * at file access time.</span>
<span class="line-added">1126          * Care must be taken that the {@code BodySubscriber} is not shared with</span>
<span class="line-added">1127          * untrusted code.</span>
1128          *
<a name="11" id="anc11"></a><span class="line-modified">1129          * @param  file the file to store the body in</span>
1130          * @return a body subscriber
<a name="12" id="anc12"></a><span class="line-modified">1131          * @throws SecurityException in the case of the default file system</span>
<span class="line-modified">1132          *         provider, and a security manager is installed,</span>
<span class="line-modified">1133          *         {@link SecurityManager#checkWrite(String) checkWrite}</span>
<span class="line-added">1134          *         is invoked to check write access to the given file</span>
1135          */
1136         public static BodySubscriber&lt;Path&gt; ofFile(Path file) {
1137             return ofFile(file, CREATE, WRITE);
1138         }
1139 
1140         /**
1141          * Returns a {@code BodySubscriber} which provides the incoming body
1142          * data to the provided Consumer of {@code Optional&lt;byte[]&gt;}. Each
1143          * call to {@link Consumer#accept(java.lang.Object) Consumer.accept()}
1144          * will contain a non empty {@code Optional}, except for the final
1145          * invocation after all body data has been read, when the {@code
1146          * Optional} will be empty.
1147          *
1148          * &lt;p&gt; The {@link HttpResponse} using this subscriber is available after
1149          * the entire response has been read.
1150          *
1151          * @apiNote
1152          * This subscriber is not flow controlled.
1153          * Therefore, the supplied consumer must be able to process whatever
1154          * amount of data is delivered in a timely fashion.
1155          *
1156          * @param consumer a Consumer of byte arrays
1157          * @return a BodySubscriber
1158          */
1159         public static BodySubscriber&lt;Void&gt;
1160         ofByteArrayConsumer(Consumer&lt;Optional&lt;byte[]&gt;&gt; consumer) {
1161             return new ResponseSubscribers.ConsumerSubscriber(consumer);
1162         }
1163 
1164         /**
1165          * Returns a {@code BodySubscriber} which streams the response body as
1166          * an {@link InputStream}.
1167          *
1168          * &lt;p&gt; The {@link HttpResponse} using this subscriber is available
1169          * immediately after the response headers have been read, without
1170          * requiring to wait for the entire body to be processed. The response
1171          * body can then be read directly from the {@link InputStream}.
1172          *
1173          * @apiNote To ensure that all resources associated with the
1174          * corresponding exchange are properly released the caller must
1175          * ensure to either read all bytes until EOF is reached, or call
1176          * {@link InputStream#close} if it is unable or unwilling to do so.
1177          * Calling {@code close} before exhausting the stream may cause
1178          * the underlying HTTP connection to be closed and prevent it
1179          * from being reused for subsequent operations.
1180          *
1181          * @return a body subscriber that streams the response body as an
1182          *         {@link InputStream}.
1183          */
1184         public static BodySubscriber&lt;InputStream&gt; ofInputStream() {
1185             return new ResponseSubscribers.HttpResponseInputStream();
1186         }
1187 
1188         /**
1189          * Returns a {@code BodySubscriber} which streams the response body as
1190          * a {@link Stream Stream}{@code &lt;String&gt;}, where each string in the stream
1191          * corresponds to a line as defined by {@link BufferedReader#lines()}.
1192          *
1193          * &lt;p&gt; The {@link HttpResponse} using this subscriber is available
1194          * immediately after the response headers have been read, without
1195          * requiring to wait for the entire body to be processed. The response
1196          * body can then be read directly from the {@link Stream}.
1197          *
1198          * @apiNote To ensure that all resources associated with the
1199          * corresponding exchange are properly released the caller must
1200          * ensure to either read all lines until the stream is exhausted,
1201          * or call {@link Stream#close} if it is unable or unwilling to do so.
1202          * Calling {@code close} before exhausting the stream may cause
1203          * the underlying HTTP connection to be closed and prevent it
1204          * from being reused for subsequent operations.
1205          *
1206          * @param charset the character set to use when converting bytes to characters
1207          * @return a body subscriber that streams the response body as a
1208          *         {@link Stream Stream}{@code &lt;String&gt;}.
1209          *
1210          * @see BufferedReader#lines()
1211          */
1212         public static BodySubscriber&lt;Stream&lt;String&gt;&gt; ofLines(Charset charset) {
1213             return ResponseSubscribers.createLineStream(charset);
1214         }
1215 
1216         /**
1217          * Returns a response subscriber which publishes the response body
1218          * through a {@code Publisher&lt;List&lt;ByteBuffer&gt;&gt;}.
1219          *
1220          * &lt;p&gt; The {@link HttpResponse} using this subscriber is available
1221          * immediately after the response headers have been read, without
1222          * requiring to wait for the entire body to be processed. The response
1223          * body bytes can then be obtained by subscribing to the publisher
1224          * returned by the {@code HttpResponse} {@link HttpResponse#body() body}
1225          * method.
1226          *
1227          * &lt;p&gt;The publisher returned by the {@link HttpResponse#body() body}
1228          * method can be subscribed to only once. The first subscriber will
1229          * receive the body response bytes if successfully subscribed, or will
1230          * cause the subscription to be cancelled otherwise.
1231          * If more subscriptions are attempted, the subsequent subscribers will
1232          * be immediately subscribed with an empty subscription and their
1233          * {@link Subscriber#onError(Throwable) onError} method
1234          * will be invoked with an {@code IllegalStateException}.
1235          *
1236          * @apiNote To ensure that all resources associated with the
1237          * corresponding exchange are properly released the caller must
1238          * ensure that the provided publisher is subscribed once, and either
1239          * {@linkplain Subscription#request(long) requests} all bytes
1240          * until {@link Subscriber#onComplete() onComplete} or
1241          * {@link Subscriber#onError(Throwable) onError} are invoked, or
1242          * cancel the provided {@linkplain Subscriber#onSubscribe(Subscription)
1243          * subscription} if it is unable or unwilling to do so.
1244          * Note that depending on the actual HTTP protocol {@linkplain
1245          * HttpClient.Version version} used for the exchange, cancelling the
1246          * subscription instead of exhausting the flow may cause the underlying
1247          * HTTP connection to be closed and prevent it from being reused for
1248          * subsequent operations.
1249          *
1250          * @return A {@code BodySubscriber} which publishes the response body
1251          *         through a {@code Publisher&lt;List&lt;ByteBuffer&gt;&gt;}.
1252          */
1253         public static BodySubscriber&lt;Publisher&lt;List&lt;ByteBuffer&gt;&gt;&gt; ofPublisher() {
1254             return ResponseSubscribers.createPublisher();
1255         }
1256 
1257         /**
1258          * Returns a response subscriber which discards the response body. The
1259          * supplied value is the value that will be returned from
1260          * {@link HttpResponse#body()}.
1261          *
1262          * @param &lt;U&gt; the type of the response body
1263          * @param value the value to return from HttpResponse.body(), may be {@code null}
1264          * @return a {@code BodySubscriber}
1265          */
1266         public static &lt;U&gt; BodySubscriber&lt;U&gt; replacing(U value) {
1267             return new ResponseSubscribers.NullSubscriber&lt;&gt;(Optional.ofNullable(value));
1268         }
1269 
1270         /**
1271          * Returns a response subscriber which discards the response body.
1272          *
1273          * @return a response body subscriber
1274          */
1275         public static BodySubscriber&lt;Void&gt; discarding() {
1276             return new ResponseSubscribers.NullSubscriber&lt;&gt;(Optional.ofNullable(null));
1277         }
1278 
1279         /**
1280          * Returns a {@code BodySubscriber} which buffers data before delivering
1281          * it to the given downstream subscriber. The subscriber guarantees to
1282          * deliver {@code bufferSize} bytes of data to each invocation of the
1283          * downstream&#39;s {@link BodySubscriber#onNext(Object) onNext} method,
1284          * except for the final invocation, just before
1285          * {@link BodySubscriber#onComplete() onComplete} is invoked. The final
1286          * invocation of {@code onNext} may contain fewer than {@code bufferSize}
1287          * bytes.
1288          *
1289          * &lt;p&gt; The returned subscriber delegates its {@link BodySubscriber#getBody()
1290          * getBody()} method to the downstream subscriber.
1291          *
1292          * @param &lt;T&gt; the type of the response body
1293          * @param downstream the downstream subscriber
1294          * @param bufferSize the buffer size
1295          * @return a buffering body subscriber
1296          * @throws IllegalArgumentException if {@code bufferSize &lt;= 0}
1297          */
1298          public static &lt;T&gt; BodySubscriber&lt;T&gt; buffering(BodySubscriber&lt;T&gt; downstream,
1299                                                        int bufferSize) {
1300              if (bufferSize &lt;= 0)
1301                  throw new IllegalArgumentException(&quot;must be greater than 0&quot;);
1302              return new BufferingSubscriber&lt;&gt;(downstream, bufferSize);
1303          }
1304 
1305         /**
1306          * Returns a {@code BodySubscriber} whose response body value is that of
1307          * the result of applying the given function to the body object of the
1308          * given {@code upstream} {@code BodySubscriber}.
1309          *
1310          * &lt;p&gt; The mapping function is executed using the client&#39;s {@linkplain
1311          * HttpClient#executor() executor}, and can therefore be used to map any
1312          * response body type, including blocking {@link InputStream}.
1313          * However, performing any blocking operation in the mapper function
1314          * runs the risk of blocking the executor&#39;s thread for an unknown
1315          * amount of time (at least until the blocking operation finishes),
1316          * which may end up starving the executor of available threads.
1317          * Therefore, in the case where mapping to the desired type might
1318          * block (e.g. by reading on the {@code InputStream}), then mapping
1319          * to a {@link java.util.function.Supplier Supplier} of the desired
1320          * type and deferring the blocking operation until {@link Supplier#get()
1321          * Supplier::get} is invoked by the caller&#39;s thread should be preferred,
1322          * as shown in the following example which uses a well-known JSON parser to
1323          * convert an {@code InputStream} into any annotated Java type.
1324          *
1325          * &lt;p&gt;For example:
1326          * &lt;pre&gt; {@code  public static &lt;W&gt; BodySubscriber&lt;Supplier&lt;W&gt;&gt; asJSON(Class&lt;W&gt; targetType) {
1327          *     BodySubscriber&lt;InputStream&gt; upstream = BodySubscribers.ofInputStream();
1328          *
1329          *     BodySubscriber&lt;Supplier&lt;W&gt;&gt; downstream = BodySubscribers.mapping(
1330          *           upstream,
1331          *           (InputStream is) -&gt; () -&gt; {
1332          *               try (InputStream stream = is) {
1333          *                   ObjectMapper objectMapper = new ObjectMapper();
1334          *                   return objectMapper.readValue(stream, targetType);
1335          *               } catch (IOException e) {
1336          *                   throw new UncheckedIOException(e);
1337          *               }
1338          *           });
1339          *    return downstream;
1340          *  } }&lt;/pre&gt;
1341          *
1342          * @param &lt;T&gt; the upstream body type
1343          * @param &lt;U&gt; the type of the body subscriber returned
1344          * @param upstream the body subscriber to be mapped
1345          * @param mapper the mapping function
1346          * @return a mapping body subscriber
1347          */
1348         public static &lt;T,U&gt; BodySubscriber&lt;U&gt; mapping(BodySubscriber&lt;T&gt; upstream,
1349                                                       Function&lt;? super T, ? extends U&gt; mapper)
1350         {
1351             return new ResponseSubscribers.MappingSubscriber&lt;&gt;(upstream, mapper);
1352         }
1353     }
1354 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
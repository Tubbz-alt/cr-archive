diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -72,11 +72,11 @@
  * depending on the characteristics of the byte buffer instance the segment is associated with. For instance, a buffer memory
  * segment obtained from a byte buffer created with the {@link ByteBuffer#allocateDirect(int)} method will be backed
  * by native memory.
  * <p>
  * Finally, it is also possible to obtain a memory segment backed by a memory-mapped file using the factory method
- * {@link MemorySegment#mapFromPath(Path, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments</em>
+ * {@link MemorySegment#mapFromPath(Path, long, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments</em>
  * (see {@link MappedMemorySegment}).
  *
  * <h2>Closing a memory segment</h2>
  *
  * Memory segments are closed explicitly (see {@link MemorySegment#close()}). In general when a segment is closed, all off-heap
@@ -290,16 +290,18 @@
      * Fills a value into this memory segment.
      * <p>
      * More specifically, the given value is filled into each address of this
      * segment. Equivalent to (but likely more efficient than) the following code:
      *
-     * <blockquote><pre>
-     * byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
-     *         .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
-     * for (long l = 0; l < segment.byteSize(); l++) {
-     *     byteHandle.set(segment.baseAddress(), l, value);
-     * }</pre></blockquote>
+     * <pre>{@code
+byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
+         .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
+for (long l = 0; l < segment.byteSize(); l++) {
+     byteHandle.set(segment.baseAddress(), l, value);
+}
+     * }</pre>
+     *
      * without any regard or guarantees on the ordering of particular memory
      * elements being set.
      * <p>
      * Fill can be useful to initialize or reset the memory of a segment.
      *
@@ -323,11 +325,11 @@
      * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment
      * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.
      * For example, this may occur if the same file is {@link MemorySegment#mapFromPath mapped} to two segments.
      *
      * @param src the source segment.
-     * @throws IndexOutOfBoundsException if {src.byteSize() > this.byteSize()}.
+     * @throws IndexOutOfBoundsException if {@code src.byteSize() > this.byteSize()}.
      * @throws IllegalStateException if either the source segment or this segment have been already closed,
      * or if access occurs from a thread other than the thread owning either segment.
      * @throws UnsupportedOperationException if either the source segment or this segment do not feature required access modes;
      * more specifically, {@code src} should feature at least the {@link MemorySegment#READ} access mode,
      * while this segment should feature at least the {@link MemorySegment#WRITE} access mode.

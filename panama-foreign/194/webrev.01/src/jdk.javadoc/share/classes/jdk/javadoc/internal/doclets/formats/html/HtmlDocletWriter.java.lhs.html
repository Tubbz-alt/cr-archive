<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.formats.html;
  27 
  28 import java.util.ArrayList;
  29 import java.util.Collections;
  30 import java.util.HashMap;
  31 import java.util.LinkedList;
  32 import java.util.List;
  33 import java.util.ListIterator;
  34 import java.util.Locale;
  35 import java.util.Map;
  36 import java.util.Set;
  37 import java.util.regex.Matcher;
  38 import java.util.regex.Pattern;
  39 
  40 import javax.lang.model.element.AnnotationMirror;
  41 import javax.lang.model.element.AnnotationValue;
  42 import javax.lang.model.element.Element;
  43 import javax.lang.model.element.ElementKind;
  44 import javax.lang.model.element.ExecutableElement;
  45 import javax.lang.model.element.ModuleElement;
  46 import javax.lang.model.element.Name;
  47 import javax.lang.model.element.PackageElement;
  48 import javax.lang.model.element.QualifiedNameable;
  49 import javax.lang.model.element.TypeElement;
  50 import javax.lang.model.element.VariableElement;
  51 import javax.lang.model.type.DeclaredType;
  52 import javax.lang.model.type.TypeMirror;
  53 import javax.lang.model.util.SimpleAnnotationValueVisitor9;
  54 import javax.lang.model.util.SimpleElementVisitor14;
  55 import javax.lang.model.util.SimpleTypeVisitor9;
  56 
  57 import com.sun.source.doctree.AttributeTree;
  58 import com.sun.source.doctree.AttributeTree.ValueKind;
  59 import com.sun.source.doctree.CommentTree;
  60 import com.sun.source.doctree.DocRootTree;
  61 import com.sun.source.doctree.DocTree;
  62 import com.sun.source.doctree.DocTree.Kind;
  63 import com.sun.source.doctree.EndElementTree;
  64 import com.sun.source.doctree.EntityTree;
  65 import com.sun.source.doctree.ErroneousTree;
  66 import com.sun.source.doctree.IndexTree;
  67 import com.sun.source.doctree.InheritDocTree;
  68 import com.sun.source.doctree.LinkTree;
  69 import com.sun.source.doctree.LiteralTree;
  70 import com.sun.source.doctree.SeeTree;
  71 import com.sun.source.doctree.StartElementTree;
  72 import com.sun.source.doctree.SummaryTree;
  73 import com.sun.source.doctree.SystemPropertyTree;
  74 import com.sun.source.doctree.TextTree;
  75 import com.sun.source.util.SimpleDocTreeVisitor;
  76 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
  77 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
  78 import jdk.javadoc.internal.doclets.formats.html.markup.FixedStringContent;
  79 import jdk.javadoc.internal.doclets.formats.html.markup.Head;
  80 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  81 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
  82 import jdk.javadoc.internal.doclets.formats.html.markup.TagName;
  83 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  84 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  85 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  86 import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  87 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
  88 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
  89 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  90 import jdk.javadoc.internal.doclets.toolkit.Content;
  91 import jdk.javadoc.internal.doclets.toolkit.Messages;
  92 import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
  93 import jdk.javadoc.internal.doclets.toolkit.Resources;
  94 import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;
  95 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;
  96 import jdk.javadoc.internal.doclets.toolkit.util.Comparators;
  97 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  98 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
  99 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 100 import jdk.javadoc.internal.doclets.toolkit.util.DocLink;
 101 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 102 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
 103 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 104 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 105 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 106 
 107 import static com.sun.source.doctree.DocTree.Kind.CODE;
 108 import static com.sun.source.doctree.DocTree.Kind.COMMENT;
 109 import static com.sun.source.doctree.DocTree.Kind.LINK;
 110 import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;
 111 import static com.sun.source.doctree.DocTree.Kind.SEE;
 112 import static com.sun.source.doctree.DocTree.Kind.TEXT;
 113 import static jdk.javadoc.internal.doclets.toolkit.util.CommentHelper.SPACER;
 114 
 115 
 116 /**
 117  * Class for the Html Format Code Generation specific to JavaDoc.
 118  * This Class contains methods related to the Html Code Generation which
 119  * are used extensively while generating the entire documentation.
 120  *
 121  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 122  *  If you write code that depends on this, you do so at your own risk.
 123  *  This code and its internal interfaces are subject to change or
 124  *  deletion without notice.&lt;/b&gt;
 125  */
 126 public class HtmlDocletWriter {
 127 
 128     /**
 129      * Relative path from the file getting generated to the destination
 130      * directory. For example, if the file getting generated is
 131      * &quot;java/lang/Object.html&quot;, then the path to the root is &quot;../..&quot;.
 132      * This string can be empty if the file getting generated is in
 133      * the destination directory.
 134      */
 135     public final DocPath pathToRoot;
 136 
 137     /**
 138      * Platform-independent path from the current or the
 139      * destination directory to the file getting generated.
 140      * Used when creating the file.
 141      */
 142     public final DocPath path;
 143 
 144     /**
 145      * Name of the file getting generated. If the file getting generated is
 146      * &quot;java/lang/Object.html&quot;, then the filename is &quot;Object.html&quot;.
 147      */
 148     public final DocPath filename;
 149 
 150     /**
 151      * The global configuration information for this run.
 152      */
 153     public final HtmlConfiguration configuration;
 154 
 155     protected final SearchIndexItems searchItems;
 156 
 157     protected final HtmlOptions options;
 158 
 159     protected final Utils utils;
 160 
 161     protected final Contents contents;
 162 
 163     protected final Messages messages;
 164 
 165     protected final Resources resources;
 166 
 167     protected final Links links;
 168 
 169     protected final DocPaths docPaths;
 170 
 171     protected final Comparators comparators;
 172 
 173     /**
 174      * To check whether annotation heading is printed or not.
 175      */
 176     protected boolean printedAnnotationHeading = false;
 177 
 178     /**
 179      * To check whether annotation field heading is printed or not.
 180      */
 181     protected boolean printedAnnotationFieldHeading = false;
 182 
 183     /**
 184      * To check whether the repeated annotations is documented or not.
 185      */
 186     private boolean isAnnotationDocumented = false;
 187 
 188     /**
 189      * To check whether the container annotations is documented or not.
 190      */
 191     private boolean isContainerDocumented = false;
 192 
 193     /**
 194      * The window title of this file.
 195      */
 196     protected String winTitle;
 197 
 198     protected Script mainBodyScript;
 199 
 200     /**
 201      * A table of the anchors used for at-index and related tags,
 202      * so that they can be made unique by appending a suitable suffix.
 203      * (Ideally, javadoc should be tracking all id&#39;s generated in a file
 204      * to avoid generating duplicates.)
 205      */
 206     Map&lt;String, Integer&gt; indexAnchorTable = new HashMap&lt;&gt;();
 207 
 208     /**
 209      * Creates an {@code HtmlDocletWriter}.
 210      *
 211      * @param configuration the configuration for this doclet
 212      * @param path the file to be generated.
 213      */
 214     public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path) {
 215         this.configuration = configuration;
 216         this.searchItems = configuration.searchItems;
 217         this.options = configuration.getOptions();
 218         this.contents = configuration.contents;
 219         this.messages = configuration.messages;
 220         this.resources = configuration.docResources;
 221         this.links = new Links(path);
 222         this.utils = configuration.utils;
 223         this.comparators = utils.comparators;
 224         this.path = path;
 225         this.pathToRoot = path.parent().invert();
 226         this.filename = path.basename();
 227         this.docPaths = configuration.docPaths;
 228         this.mainBodyScript = new Script();
 229 
 230         messages.notice(&quot;doclet.Generating_0&quot;,
 231             DocFile.createFileForOutput(configuration, path).getPath());
 232     }
 233 
 234     /**
 235      * Replace {&amp;#064;docRoot} tag used in options that accept HTML text, such
 236      * as -header, -footer, -top and -bottom, and when converting a relative
 237      * HREF where commentTagsToString inserts a {&amp;#064;docRoot} where one was
 238      * missing.  (Also see DocRootTaglet for {&amp;#064;docRoot} tags in doc
 239      * comments.)
 240      * &lt;p&gt;
 241      * Replace {&amp;#064;docRoot} tag in htmlstr with the relative path to the
 242      * destination directory from the directory where the file is being
 243      * written, looping to handle all such tags in htmlstr.
 244      * &lt;p&gt;
 245      * For example, for &quot;-d docs&quot; and -header containing {&amp;#064;docRoot}, when
 246      * the HTML page for source file p/C1.java is being generated, the
 247      * {&amp;#064;docRoot} tag would be inserted into the header as &quot;../&quot;,
 248      * the relative path from docs/p/ to docs/ (the document root).
 249      * &lt;p&gt;
 250      * Note: This doc comment was written with &#39;&amp;amp;#064;&#39; representing &#39;@&#39;
 251      * to prevent the inline tag from being interpreted.
 252      */
 253     public String replaceDocRootDir(String htmlstr) {
 254         // Return if no inline tags exist
 255         int index = htmlstr.indexOf(&quot;{@&quot;);
 256         if (index &lt; 0) {
 257             return htmlstr;
 258         }
 259         Matcher docrootMatcher = docrootPattern.matcher(htmlstr);
 260         if (!docrootMatcher.find()) {
 261             return htmlstr;
 262         }
 263         StringBuilder buf = new StringBuilder();
 264         int prevEnd = 0;
 265         do {
 266             int match = docrootMatcher.start();
 267             // append htmlstr up to start of next {@docroot}
 268             buf.append(htmlstr.substring(prevEnd, match));
 269             prevEnd = docrootMatcher.end();
 270             if (options.docrootParent().length() &gt; 0 &amp;&amp; htmlstr.startsWith(&quot;/..&quot;, prevEnd)) {
 271                 // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
 272                 buf.append(options.docrootParent());
 273                 prevEnd += 3;
 274             } else {
 275                 // Insert relative path where {@docRoot} was located
 276                 buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
 277             }
 278             // Append slash if next character is not a slash
 279             if (prevEnd &lt; htmlstr.length() &amp;&amp; htmlstr.charAt(prevEnd) != &#39;/&#39;) {
 280                 buf.append(&#39;/&#39;);
 281             }
 282         } while (docrootMatcher.find());
 283         buf.append(htmlstr.substring(prevEnd));
 284         return buf.toString();
 285     }
 286     //where:
 287         // Note: {@docRoot} is not case sensitive when passed in with a command-line option:
 288         private static final Pattern docrootPattern =
 289                 Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
 290 
 291 
 292     /**
 293      * Add method information.
 294      *
 295      * @param method the method to be documented
 296      * @param dl the content tree to which the method information will be added
 297      */
 298     private void addMethodInfo(ExecutableElement method, Content dl) {
 299         TypeElement enclosing = utils.getEnclosingTypeElement(method);
 300         List&lt;? extends TypeMirror&gt; intfacs = enclosing.getInterfaces();
 301         ExecutableElement overriddenMethod = utils.overriddenMethod(method);
 302         VisibleMemberTable vmt = configuration.getVisibleMemberTable(enclosing);
 303         // Check whether there is any implementation or overridden info to be
 304         // printed. If no overridden or implementation info needs to be
 305         // printed, do not print this section.
 306         if ((!intfacs.isEmpty()
 307                 &amp;&amp; vmt.getImplementedMethods(method).isEmpty() == false)
 308                 || overriddenMethod != null) {
 309             MethodWriterImpl.addImplementsInfo(this, method, dl);
 310             if (overriddenMethod != null) {
 311                 MethodWriterImpl.addOverridden(this,
 312                         utils.overriddenType(method),
 313                         overriddenMethod,
 314                         dl);
 315             }
 316         }
 317     }
 318 
 319     /**
 320      * Adds the tags information.
 321      *
 322      * @param e the Element for which the tags will be generated
 323      * @param htmlTree the documentation tree to which the tags will be added
 324      */
 325     protected void addTagsInfo(Element e, Content htmlTree) {
 326         if (options.noComment()) {
 327             return;
 328         }
 329         HtmlTree dl = HtmlTree.DL(HtmlStyle.notes);
 330         if (utils.isExecutableElement(e) &amp;&amp; !utils.isConstructor(e)) {
 331             addMethodInfo((ExecutableElement)e, dl);
 332         }
 333         Content output = new ContentBuilder();
 334         TagletWriter.genTagOutput(configuration.tagletManager, e,
 335             configuration.tagletManager.getBlockTaglets(e),
 336                 getTagletWriterInstance(false), output);
 337         dl.add(output);
 338         htmlTree.add(dl);
 339     }
 340 
 341     /**
 342      * Check whether there are any tags for Serialization Overview
 343      * section to be printed.
 344      *
 345      * @param field the VariableElement object to check for tags.
 346      * @return true if there are tags to be printed else return false.
 347      */
 348     protected boolean hasSerializationOverviewTags(VariableElement field) {
 349         Content output = new ContentBuilder();
 350         TagletWriter.genTagOutput(configuration.tagletManager, field,
 351                 configuration.tagletManager.getBlockTaglets(field),
 352                 getTagletWriterInstance(false), output);
 353         return !output.isEmpty();
 354     }
 355 
 356     /**
 357      * Returns a TagletWriter that knows how to write HTML.
 358      *
 359      * @param isFirstSentence  true if we want to write the first sentence
 360      * @return a TagletWriter that knows how to write HTML.
 361      */
 362     public TagletWriter getTagletWriterInstance(boolean isFirstSentence) {
 363         return new TagletWriterImpl(this, isFirstSentence);
 364     }
 365 
 366     /**
 367      * Returns a TagletWriter that knows how to write HTML.
 368      *
 369      * @param isFirstSentence  true if we want to write the first sentence
 370      * @param inSummary  true if tags are to be added in a summary section
 371      * @return a TagletWriter
 372      */
 373     public TagletWriter getTagletWriterInstance(boolean isFirstSentence, boolean inSummary) {
 374         return new TagletWriterImpl(this, isFirstSentence, inSummary);
 375     }
 376 
 377     /**
 378      * Generates the HTML document tree and prints it out.
 379      *
 380      * @param metakeywords Array of String keywords for META tag. Each element
 381      *                     of the array is assigned to a separate META tag.
 382      *                     Pass in null for no array
 383      * @param description the content for the description META tag.
 384      * @param body the body htmltree to be included in the document
 385      * @throws DocFileIOException if there is a problem writing the file
 386      */
 387     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 388                                   String description,
 389                                   Content body)
 390             throws DocFileIOException {
 391         printHtmlDocument(metakeywords, description, new ContentBuilder(), Collections.emptyList(), body);
 392     }
 393 
 394     /**
 395      * Generates the HTML document tree and prints it out.
 396      *
 397      * @param metakeywords Array of String keywords for META tag. Each element
 398      *                     of the array is assigned to a separate META tag.
 399      *                     Pass in null for no array
 400      * @param description the content for the description META tag.
 401      * @param localStylesheets local stylesheets to be included in the HEAD element
 402      * @param body the body htmltree to be included in the document
 403      * @throws DocFileIOException if there is a problem writing the file
 404      */
 405     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 406                                   String description,
 407                                   List&lt;DocPath&gt; localStylesheets,
 408                                   Content body)
 409             throws DocFileIOException {
 410         printHtmlDocument(metakeywords, description, new ContentBuilder(), localStylesheets, body);
 411     }
 412 
 413     /**
 414      * Generates the HTML document tree and prints it out.
 415      *
 416      * @param metakeywords Array of String keywords for META tag. Each element
 417      *                     of the array is assigned to a separate META tag.
 418      *                     Pass in null for no array
 419      * @param description the content for the description META tag.
 420      * @param extraHeadContent any additional content to be included in the HEAD element
 421      * @param localStylesheets local stylesheets to be included in the HEAD element
 422      * @param body the body htmltree to be included in the document
 423      * @throws DocFileIOException if there is a problem writing the file
 424      */
 425     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 426                                   String description,
 427                                   Content extraHeadContent,
 428                                   List&lt;DocPath&gt; localStylesheets,
 429                                   Content body)
 430             throws DocFileIOException {
 431         Content htmlComment = contents.newPage;
 432         List&lt;DocPath&gt; additionalStylesheets = configuration.getAdditionalStylesheets();
 433         additionalStylesheets.addAll(localStylesheets);
 434         Head head = new Head(path, configuration.docletVersion, configuration.startTime)
 435                 .setTimestamp(!options.noTimestamp())
 436                 .setDescription(description)
 437                 .setGenerator(getGenerator(getClass()))
 438                 .setTitle(winTitle)
 439                 .setCharset(options.charset())
 440                 .addKeywords(metakeywords)
 441                 .setStylesheets(configuration.getMainStylesheet(), additionalStylesheets)
 442                 .setIndex(options.createIndex(), mainBodyScript)
 443                 .addContent(extraHeadContent);
 444 
 445         Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head, body);
 446         HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
 447         htmlDocument.write(DocFile.createFileForOutput(configuration, path));
 448     }
 449 
 450     /**
 451      * Get the window title.
 452      *
 453      * @param title the title string to construct the complete window title
 454      * @return the window title string
 455      */
 456     public String getWindowTitle(String title) {
 457         if (options.windowTitle().length() &gt; 0) {
 458             title += &quot; (&quot; + options.windowTitle() + &quot;)&quot;;
 459         }
 460         return title;
 461     }
 462 
 463     /**
 464      * Get user specified header and the footer.
 465      *
 466      * @param header if true print the user provided header else print the
 467      * user provided footer.
 468      */
 469     public Content getUserHeaderFooter(boolean header) {
 470         String content;
 471         if (header) {
 472             content = replaceDocRootDir(options.header());
 473         } else {
 474             if (options.footer().length() != 0) {
 475                 content = replaceDocRootDir(options.footer());
 476             } else {
 477                 content = replaceDocRootDir(options.header());
 478             }
 479         }
 480         Content rawContent = new RawHtml(content);
 481         return rawContent;
 482     }
 483 
 484     /**
 485      * Adds the user specified top.
 486      *
 487      * @param htmlTree the content tree to which user specified top will be added
 488      */
 489     public void addTop(Content htmlTree) {
 490         Content top = new RawHtml(replaceDocRootDir(options.top()));
 491         htmlTree.add(top);
 492     }
 493 
 494     /**
 495      * Adds the user specified bottom.
 496      *
 497      * @param htmlTree the content tree to which user specified bottom will be added
 498      */
 499     public void addBottom(Content htmlTree) {
 500         Content bottom = new RawHtml(replaceDocRootDir(options.bottom()));
 501         Content small = HtmlTree.SMALL(bottom);
 502         Content p = HtmlTree.P(HtmlStyle.legalCopy, small);
 503         htmlTree.add(p);
 504     }
 505 
 506     /**
 507      * Get the overview tree link for the main tree.
 508      *
 509      * @param label the label for the link
 510      * @return a content tree for the link
 511      */
 512     protected Content getNavLinkMainTree(String label) {
 513         Content mainTreeContent = links.createLink(pathToRoot.resolve(DocPaths.OVERVIEW_TREE),
 514                 new StringContent(label));
 515         Content li = HtmlTree.LI(mainTreeContent);
 516         return li;
 517     }
 518 
 519     /**
 520      * Returns a packagename content.
 521      *
 522      * @param packageElement the package to check
 523      * @return package name content
 524      */
 525     public Content getPackageName(PackageElement packageElement) {
 526         return packageElement == null || packageElement.isUnnamed()
 527                 ? contents.defaultPackageLabel
 528                 : getPackageLabel(packageElement.getQualifiedName());
 529     }
 530 
 531     /**
 532      * Returns a package name label.
 533      *
 534      * @param packageName the package name
 535      * @return the package name content
 536      */
 537     public Content getPackageLabel(CharSequence packageName) {
 538         return new StringContent(packageName);
 539     }
 540 
 541     /**
 542      * Return the path to the class page for a typeElement.
 543      *
 544      * @param te   TypeElement for which the path is requested.
 545      * @param name Name of the file(doesn&#39;t include path).
 546      */
 547     protected DocPath pathString(TypeElement te, DocPath name) {
 548         return pathString(utils.containingPackage(te), name);
 549     }
 550 
 551     /**
 552      * Return path to the given file name in the given package. So if the name
 553      * passed is &quot;Object.html&quot; and the name of the package is &quot;java.lang&quot;, and
 554      * if the relative path is &quot;../..&quot; then returned string will be
 555      * &quot;../../java/lang/Object.html&quot;
 556      *
 557      * @param packageElement Package in which the file name is assumed to be.
 558      * @param name File name, to which path string is.
 559      */
 560     protected DocPath pathString(PackageElement packageElement, DocPath name) {
 561         return pathToRoot.resolve(docPaths.forPackage(packageElement).resolve(name));
 562     }
 563 
 564     /**
 565      * Given a package, return the name to be used in HTML anchor tag.
 566      * @param packageElement the package.
 567      * @return the name to be used in HTML anchor tag.
 568      */
 569     public String getPackageAnchorName(PackageElement packageElement) {
 570         return packageElement == null || packageElement.isUnnamed()
 571                 ? SectionName.UNNAMED_PACKAGE_ANCHOR.getName()
 572                 : utils.getPackageName(packageElement);
 573     }
 574 
 575     /**
 576      * Return the link to the given package.
 577      *
 578      * @param packageElement the package to link to.
 579      * @param label the label for the link.
 580      * @return a content tree for the package link.
 581      */
 582     public Content getPackageLink(PackageElement packageElement, CharSequence label) {
 583         return getPackageLink(packageElement, new StringContent(label));
 584     }
 585 
 586     public Content getPackageLink(PackageElement packageElement) {
 587         StringContent content =  packageElement.isUnnamed()
 588                 ? new StringContent()
 589                 : new StringContent(utils.getPackageName(packageElement));
 590         return getPackageLink(packageElement, content);
 591     }
 592 
 593     /**
 594      * Return the link to the given package.
 595      *
 596      * @param packageElement the package to link to.
 597      * @param label the label for the link.
 598      * @return a content tree for the package link.
 599      */
 600     public Content getPackageLink(PackageElement packageElement, Content label) {
 601         boolean included = packageElement != null &amp;&amp; utils.isIncluded(packageElement);
 602         if (!included) {
 603             for (PackageElement p : configuration.packages) {
 604                 if (p.equals(packageElement)) {
 605                     included = true;
 606                     break;
 607                 }
 608             }
 609         }
 610         if (included || packageElement == null) {
 611             return links.createLink(pathString(packageElement, DocPaths.PACKAGE_SUMMARY),
 612                     label);
 613         } else {
 614             DocLink crossPkgLink = getCrossPackageLink(packageElement);
 615             if (crossPkgLink != null) {
 616                 return links.createLink(crossPkgLink, label);
 617             } else {
 618                 return label;
 619             }
 620         }
 621     }
 622 
 623     /**
 624      * Get Module link.
 625      *
 626      * @param mdle the module being documented
 627      * @param label tag for the link
 628      * @return a content for the module link
 629      */
 630     public Content getModuleLink(ModuleElement mdle, Content label) {
 631         boolean included = utils.isIncluded(mdle);
 632         return (included)
 633                 ? links.createLink(pathToRoot.resolve(docPaths.moduleSummary(mdle)), label, &quot;&quot;, &quot;&quot;)
 634                 : label;
 635     }
 636 
 637     public Content interfaceName(TypeElement typeElement, boolean qual) {
 638         Content name = new StringContent((qual)
 639                 ? typeElement.getQualifiedName()
 640                 : utils.getSimpleName(typeElement));
 641         return (utils.isInterface(typeElement)) ?  HtmlTree.SPAN(HtmlStyle.interfaceName, name) : name;
 642     }
 643 
 644     /**
 645      * Add the link to the content tree.
 646      *
 647      * @param element program element for which the link will be added
 648      * @param label label for the link
 649      * @param htmltree the content tree to which the link will be added
 650      */
 651     public void addSrcLink(Element element, Content label, Content htmltree) {
 652         if (element == null) {
 653             return;
 654         }
 655         TypeElement te = utils.getEnclosingTypeElement(element);
 656         if (te == null) {
 657             // must be a typeElement since in has no containing class.
 658             te = (TypeElement) element;
 659         }
 660         if (utils.isIncluded(te)) {
 661             DocPath href = pathToRoot
 662                     .resolve(DocPaths.SOURCE_OUTPUT)
 663                     .resolve(docPaths.forClass(te));
 664             Content content = links.createLink(href
 665                     .fragment(SourceToHTMLConverter.getAnchorName(utils, element)), label, &quot;&quot;, &quot;&quot;);
 666             htmltree.add(content);
 667         } else {
 668             htmltree.add(label);
 669         }
 670     }
 671 
 672     /**
 673      * Return the link to the given class.
 674      *
 675      * @param linkInfo the information about the link.
 676      *
 677      * @return the link for the given class.
 678      */
 679     public Content getLink(LinkInfoImpl linkInfo) {
 680         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 681         return factory.getLink(linkInfo);
 682     }
 683 
 684     /**
 685      * Return the type parameters for the given class.
 686      *
 687      * @param linkInfo the information about the link.
 688      * @return the type for the given class.
 689      */
 690     public Content getTypeParameterLinks(LinkInfoImpl linkInfo) {
 691         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 692         return factory.getTypeParameterLinks(linkInfo, false);
 693     }
 694 
 695     /*************************************************************
 696      * Return a class cross link to external class documentation.
 697      * The -link option does not allow users to
 698      * link to external classes in the &quot;default&quot; package.
 699      *
 700      * @param classElement the class element
 701      * @param refMemName the name of the member being referenced.  This should
 702      * be null or empty string if no member is being referenced.
 703      * @param label the label for the external link.
 704      * @param strong true if the link should be strong.
 705      * @param code true if the label should be code font.
 706      * @return the link
 707      */
 708     public Content getCrossClassLink(TypeElement classElement, String refMemName,
 709                                     Content label, boolean strong, boolean code) {
 710         if (classElement != null) {
 711             String className = utils.getSimpleName(classElement);
 712             PackageElement packageElement = utils.containingPackage(classElement);
 713             Content defaultLabel = new StringContent(className);
 714             if (code)
 715                 defaultLabel = HtmlTree.CODE(defaultLabel);
 716             if (getCrossPackageLink(packageElement) != null) {
 717                 /*
 718                 The package exists in external documentation, so link to the external
 719                 class (assuming that it exists).  This is definitely a limitation of
 720                 the -link option.  There are ways to determine if an external package
 721                 exists, but no way to determine if the external class exists.  We just
 722                 have to assume that it does.
 723                 */
 724                 DocLink link = configuration.extern.getExternalLink(packageElement, pathToRoot,
 725                                 className + &quot;.html&quot;, refMemName);
 726                 return links.createLink(link,
 727                     (label == null) || label.isEmpty() ? defaultLabel : label,
 728                     strong,
 729                     resources.getText(&quot;doclet.Href_Class_Or_Interface_Title&quot;,
 730                         utils.getPackageName(packageElement)), &quot;&quot;, true);
 731             }
 732         }
 733         return null;
 734     }
 735 
 736     public boolean isClassLinkable(TypeElement typeElement) {
 737         if (utils.isIncluded(typeElement)) {
 738             return configuration.isGeneratedDoc(typeElement);
 739         }
 740         return configuration.extern.isExternal(typeElement);
 741     }
 742 
 743     public DocLink getCrossPackageLink(PackageElement element) {
 744         return configuration.extern.getExternalLink(element, pathToRoot,
 745             DocPaths.PACKAGE_SUMMARY.getPath());
 746     }
 747 
 748     public DocLink getCrossModuleLink(ModuleElement element) {
 749         return configuration.extern.getExternalLink(element, pathToRoot,
 750             docPaths.moduleSummary(utils.getModuleName(element)).getPath());
 751     }
 752 
 753     /**
 754      * Get the class link.
 755      *
 756      * @param context the id of the context where the link will be added
 757      * @param element to link to
 758      * @return a content tree for the link
 759      */
 760     public Content getQualifiedClassLink(LinkInfoImpl.Kind context, Element element) {
 761         LinkInfoImpl linkInfoImpl = new LinkInfoImpl(configuration, context, (TypeElement)element);
 762         return getLink(linkInfoImpl.label(utils.getFullyQualifiedName(element)));
 763     }
 764 
 765     /**
 766      * Add the class link.
 767      *
 768      * @param context the id of the context where the link will be added
 769      * @param typeElement to link to
 770      * @param contentTree the content tree to which the link will be added
 771      */
 772     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 773         addPreQualifiedClassLink(context, typeElement, false, contentTree);
 774     }
 775 
 776     /**
 777      * Retrieve the class link with the package portion of the label in
 778      * plain text.  If the qualifier is excluded, it will not be included in the
 779      * link label.
 780      *
 781      * @param typeElement the class to link to.
 782      * @param isStrong true if the link should be strong.
 783      * @return the link with the package portion of the label in plain text.
 784      */
 785     public Content getPreQualifiedClassLink(LinkInfoImpl.Kind context,
 786             TypeElement typeElement, boolean isStrong) {
 787         ContentBuilder classlink = new ContentBuilder();
 788         PackageElement pkg = utils.containingPackage(typeElement);
 789         if (pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 790             classlink.add(getEnclosingPackageName(typeElement));
 791         }
 792         classlink.add(getLink(new LinkInfoImpl(configuration,
 793                 context, typeElement).label(utils.getSimpleName(typeElement)).strong(isStrong)));
 794         return classlink;
 795     }
 796 
 797     /**
 798      * Add the class link with the package portion of the label in
 799      * plain text. If the qualifier is excluded, it will not be included in the
 800      * link label.
 801      *
 802      * @param context the id of the context where the link will be added
 803      * @param typeElement the class to link to
 804      * @param isStrong true if the link should be strong
 805      * @param contentTree the content tree to which the link with be added
 806      */
 807     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context,
 808             TypeElement typeElement, boolean isStrong, Content contentTree) {
 809         PackageElement pkg = utils.containingPackage(typeElement);
 810         if(pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 811             contentTree.add(getEnclosingPackageName(typeElement));
 812         }
 813         LinkInfoImpl linkinfo = new LinkInfoImpl(configuration, context, typeElement)
 814                 .label(utils.getSimpleName(typeElement))
 815                 .strong(isStrong);
 816         Content link = getLink(linkinfo);
 817         contentTree.add(link);
 818     }
 819 
 820     /**
 821      * Get the enclosed name of the package
 822      *
 823      * @param te  TypeElement
 824      * @return the name
 825      */
 826     public String getEnclosingPackageName(TypeElement te) {
 827 
 828         PackageElement encl = configuration.utils.containingPackage(te);
 829         return (encl.isUnnamed()) ? &quot;&quot; : (encl.getQualifiedName() + &quot;.&quot;);
 830     }
 831 
 832     /**
 833      * Return the main type element of the current page or null for pages that don&#39;t have one.
 834      *
 835      * @return the type element of the current page.
 836      */
 837     protected TypeElement getCurrentPageElement() {
 838         return null;
 839     }
 840 
 841     /**
 842      * Add the class link, with only class name as the strong link and prefixing
 843      * plain package name.
 844      *
 845      * @param context the id of the context where the link will be added
 846      * @param typeElement the class to link to
 847      * @param contentTree the content tree to which the link with be added
 848      */
 849     public void addPreQualifiedStrongClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 850         addPreQualifiedClassLink(context, typeElement, true, contentTree);
 851     }
 852 
 853     /**
 854      * Get the link for the given member.
 855      *
 856      * @param context the id of the context where the link will be added
 857      * @param element the member being linked to
 858      * @param label the label for the link
 859      * @return a content tree for the element link
 860      */
 861     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label) {
 862         return getDocLink(context, utils.getEnclosingTypeElement(element), element,
 863                 new StringContent(label));
 864     }
 865 
 866     /**
 867      * Return the link for the given member.
 868      *
 869      * @param context the id of the context where the link will be printed.
 870      * @param element the member being linked to.
 871      * @param label the label for the link.
 872      * @param strong true if the link should be strong.
 873      * @return the link for the given member.
 874      */
 875     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label,
 876             boolean strong) {
 877         return getDocLink(context, utils.getEnclosingTypeElement(element), element, label, strong);
 878     }
 879 
 880     /**
 881      * Return the link for the given member.
 882      *
 883      * @param context the id of the context where the link will be printed.
 884      * @param typeElement the typeElement that we should link to.  This is not
 885                  necessarily equal to element.containingClass().  We may be
 886                  inheriting comments.
 887      * @param element the member being linked to.
 888      * @param label the label for the link.
 889      * @param strong true if the link should be strong.
 890      * @return the link for the given member.
 891      */
 892     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 893             CharSequence label, boolean strong) {
 894         return getDocLink(context, typeElement, element, label, strong, false);
 895     }
 896 
 897     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 898             Content label, boolean strong) {
 899         return getDocLink(context, typeElement, element, label, strong, false);
 900     }
 901 
 902     /**
 903      * Return the link for the given member.
 904      *
 905      * @param context the id of the context where the link will be printed.
 906      * @param typeElement the typeElement that we should link to.  This is not
 907                  necessarily equal to element.containingClass().  We may be
 908                  inheriting comments.
 909      * @param element the member being linked to.
 910      * @param label the label for the link.
 911      * @param strong true if the link should be strong.
 912      * @param isProperty true if the element parameter is a JavaFX property.
 913      * @return the link for the given member.
 914      */
 915     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 916             CharSequence label, boolean strong, boolean isProperty) {
 917         return getDocLink(context, typeElement, element, new StringContent(label), strong, isProperty);
 918     }
 919 
 920     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 921             Content label, boolean strong, boolean isProperty) {
 922         if (!utils.isLinkable(typeElement, element)) {
 923             return label;
 924         }
 925 
 926         if (utils.isExecutableElement(element)) {
 927             ExecutableElement ee = (ExecutableElement)element;
 928             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 929                 .label(label)
 930                 .where(links.getName(getAnchor(ee, isProperty)))
 931                 .strong(strong));
 932         }
 933 
 934         if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 935             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 936                 .label(label)
 937                 .where(links.getName(element.getSimpleName().toString()))
 938                 .strong(strong));
 939         }
 940 
 941         return label;
 942     }
 943 
 944     /**
 945      * Return the link for the given member.
 946      *
 947      * @param context the id of the context where the link will be added
 948      * @param typeElement the typeElement that we should link to.  This is not
 949                  necessarily equal to element.containingClass().  We may be
 950                  inheriting comments
 951      * @param element the member being linked to
 952      * @param label the label for the link
 953      * @return the link for the given member
 954      */
 955     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 956             Content label) {
 957         if (! (utils.isIncluded(element) || utils.isLinkable(typeElement))) {
 958             return label;
 959         } else if (utils.isExecutableElement(element)) {
 960             ExecutableElement emd = (ExecutableElement) element;
 961             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 962                 .label(label)
 963                 .where(links.getName(getAnchor(emd))));
 964         } else if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 965             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 966                 .label(label).where(links.getName(element.getSimpleName().toString())));
 967         } else {
 968             return label;
 969         }
 970     }
 971 
 972     public String getAnchor(ExecutableElement executableElement) {
 973         return getAnchor(executableElement, false);
 974     }
 975 
 976     public String getAnchor(ExecutableElement executableElement, boolean isProperty) {
 977         if (isProperty) {
 978             return executableElement.getSimpleName().toString();
 979         }
 980         String member = anchorName(executableElement);
 981         String erasedSignature = utils.makeSignature(executableElement, null, true, true);
 982         return member + erasedSignature;
 983     }
 984 
 985     public String anchorName(Element member) {
 986         if (member.getKind() == ElementKind.CONSTRUCTOR) {
 987             return &quot;&lt;init&gt;&quot;;
 988         } else {
 989             return utils.getSimpleName(member);
 990         }
 991     }
 992 
 993     public Content seeTagToContent(Element element, DocTree see) {
 994         Kind kind = see.getKind();
 995         if (!(kind == LINK || kind == SEE || kind == LINK_PLAIN)) {
 996             return new ContentBuilder();
 997         }
 998 
 999         CommentHelper ch = utils.getCommentHelper(element);
1000         String tagName = ch.getTagName(see);
1001         String seetext = replaceDocRootDir(utils.normalizeNewlines(ch.getText(see)).toString());
1002         // Check if @see is an href or &quot;string&quot;
1003         if (seetext.startsWith(&quot;&lt;&quot;) || seetext.startsWith(&quot;\&quot;&quot;)) {
1004             return new RawHtml(seetext);
1005         }
1006         boolean isLinkPlain = kind == LINK_PLAIN;
1007         Content label = plainOrCode(isLinkPlain, new RawHtml(ch.getLabel(see)));
1008 
1009         //The text from the @see tag.  We will output this text when a label is not specified.
1010         Content text = plainOrCode(kind == LINK_PLAIN, new RawHtml(seetext));
1011 
1012         TypeElement refClass = ch.getReferencedClass(see);
1013         String refClassName =  ch.getReferencedClassName(see);
1014         Element refMem =       ch.getReferencedMember(see);
1015         String refMemName =    ch.getReferencedMemberName(see);
1016 
1017         if (refMemName == null &amp;&amp; refMem != null) {
1018             refMemName = refMem.toString();
1019         }
1020         if (refClass == null) {
1021             //@see is not referencing an included class
1022             PackageElement refPackage = ch.getReferencedPackage(see);
1023             if (refPackage != null &amp;&amp; utils.isIncluded(refPackage)) {
1024                 //@see is referencing an included package
1025                 if (label.isEmpty())
1026                     label = plainOrCode(isLinkPlain,
1027                             new StringContent(refPackage.getQualifiedName()));
1028                 return getPackageLink(refPackage, label);
1029             } else {
1030                 // @see is not referencing an included class, module or package. Check for cross links.
1031                 DocLink elementCrossLink = (configuration.extern.isModule(refClassName))
1032                         ? getCrossModuleLink(utils.elementUtils.getModuleElement(refClassName)) :
1033                         (refPackage != null) ? getCrossPackageLink(refPackage) : null;
1034                 if (elementCrossLink != null) {
1035                     // Element cross link found
1036                     return links.createLink(elementCrossLink,
1037                             (label.isEmpty() ? text : label), true);
1038                 } else {
1039                     // No cross link found so print warning
1040                     messages.warning(ch.getDocTreePath(see),
1041                             &quot;doclet.see.class_or_package_not_found&quot;,
1042                             &quot;@&quot; + tagName,
1043                             seetext);
1044                     return (label.isEmpty() ? text: label);
1045                 }
1046             }
1047         } else if (refMemName == null) {
1048             // Must be a class reference since refClass is not null and refMemName is null.
1049             if (label.isEmpty()) {
<a name="1" id="anc1"></a><span class="line-modified">1050                 /*</span>
<span class="line-modified">1051                  * it seems to me this is the right thing to do, but it causes comparator failures.</span>
<span class="line-modified">1052                  */</span>
<span class="line-modified">1053                 if (!configuration.backwardCompatibility) {</span>
<span class="line-modified">1054                     StringContent content = utils.isEnclosingPackageIncluded(refClass)</span>
<span class="line-modified">1055                             ? new StringContent(utils.getSimpleName(refClass))</span>
<span class="line-modified">1056                             : new StringContent(utils.getFullyQualifiedName(refClass));</span>
<span class="line-removed">1057                     label = plainOrCode(isLinkPlain, content);</span>
<span class="line-removed">1058                 } else {</span>
<span class="line-removed">1059                     label = plainOrCode(isLinkPlain,</span>
<span class="line-removed">1060                             new StringContent(utils.getSimpleName(refClass)));</span>
1061                 }
<a name="2" id="anc2"></a><span class="line-modified">1062 </span>
1063             }
1064             return getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.DEFAULT, refClass)
1065                     .label(label));
1066         } else if (refMem == null) {
1067             // Must be a member reference since refClass is not null and refMemName is not null.
1068             // However, refMem is null, so this referenced member does not exist.
1069             return (label.isEmpty() ? text: label);
1070         } else {
1071             // Must be a member reference since refClass is not null and refMemName is not null.
1072             // refMem is not null, so this @see tag must be referencing a valid member.
1073             TypeElement containing = utils.getEnclosingTypeElement(refMem);
1074 
1075             // Find the enclosing type where the method is actually visible
1076             // in the inheritance hierarchy.
1077             ExecutableElement overriddenMethod = null;
1078             if (refMem.getKind() == ElementKind.METHOD) {
1079                 VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);
1080                 overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);
1081 
1082                 if (overriddenMethod != null)
1083                     containing = utils.getEnclosingTypeElement(overriddenMethod);
1084             }
1085             if (ch.getText(see).trim().startsWith(&quot;#&quot;) &amp;&amp;
1086                 ! (utils.isPublic(containing) || utils.isLinkable(containing))) {
1087                 // Since the link is relative and the holder is not even being
1088                 // documented, this must be an inherited link.  Redirect it.
1089                 // The current class either overrides the referenced member or
1090                 // inherits it automatically.
1091                 if (this instanceof ClassWriterImpl) {
1092                     containing = ((ClassWriterImpl) this).getTypeElement();
1093                 } else if (!utils.isPublic(containing)) {
1094                     messages.warning(
1095                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_accessible&quot;,
1096                         tagName, utils.getFullyQualifiedName(containing));
1097                 } else {
1098                     messages.warning(
1099                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_found&quot;,
1100                         tagName, seetext);
1101                 }
1102             }
1103             if (configuration.currentTypeElement != containing) {
1104                 refMemName = (utils.isConstructor(refMem))
1105                         ? refMemName
1106                         : utils.getSimpleName(containing) + &quot;.&quot; + refMemName;
1107             }
1108             if (utils.isExecutableElement(refMem)) {
1109                 if (refMemName.indexOf(&#39;(&#39;) &lt; 0) {
1110                     refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);
1111                 }
1112                 if (overriddenMethod != null) {
1113                     // The method to actually link.
1114                     refMem = overriddenMethod;
1115                 }
1116             }
1117 
1118             text = plainOrCode(kind == LINK_PLAIN, new StringContent(refMemName));
1119 
1120             return getDocLink(LinkInfoImpl.Kind.SEE_TAG, containing,
1121                     refMem, (label.isEmpty() ? text: label), false);
1122         }
1123     }
1124 
1125     private Content plainOrCode(boolean plain, Content body) {
1126         return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);
1127     }
1128 
1129     /**
1130      * Add the inline comment.
1131      *
1132      * @param element the Element for which the inline comment will be added
1133      * @param tag the inline tag to be added
1134      * @param htmltree the content tree to which the comment will be added
1135      */
1136     public void addInlineComment(Element element, DocTree tag, Content htmltree) {
1137         CommentHelper ch = utils.getCommentHelper(element);
1138         List&lt;? extends DocTree&gt; description = ch.getDescription(tag);
1139         addCommentTags(element, tag, description, false, false, false, htmltree);
1140     }
1141 
1142     /**
1143      * Get the deprecated phrase as content.
1144      *
1145      * @param e the Element for which the inline deprecated comment will be added
1146      * @return a content tree for the deprecated phrase.
1147      */
1148     public Content getDeprecatedPhrase(Element e) {
1149         return (utils.isDeprecatedForRemoval(e))
1150                 ? contents.deprecatedForRemovalPhrase
1151                 : contents.deprecatedPhrase;
1152     }
1153 
1154     /**
1155      * Add the inline deprecated comment.
1156      *
1157      * @param e the Element for which the inline deprecated comment will be added
1158      * @param tag the inline tag to be added
1159      * @param htmltree the content tree to which the comment will be added
1160      */
1161     public void addInlineDeprecatedComment(Element e, DocTree tag, Content htmltree) {
1162         CommentHelper ch = utils.getCommentHelper(e);
1163         addCommentTags(e, ch.getBody(tag), true, false, false, htmltree);
1164     }
1165 
1166     /**
1167      * Adds the summary content.
1168      *
1169      * @param element the Element for which the summary will be generated
1170      * @param htmltree the documentation tree to which the summary will be added
1171      */
1172     public void addSummaryComment(Element element, Content htmltree) {
1173         addSummaryComment(element, utils.getFirstSentenceTrees(element), htmltree);
1174     }
1175 
1176     /**
1177      * Adds the summary content.
1178      *
1179      * @param element the Element for which the summary will be generated
1180      * @param firstSentenceTags the first sentence tags for the doc
1181      * @param htmltree the documentation tree to which the summary will be added
1182      */
1183     public void addSummaryComment(Element element, List&lt;? extends DocTree&gt; firstSentenceTags, Content htmltree) {
1184         addCommentTags(element, firstSentenceTags, false, true, true, htmltree);
1185     }
1186 
1187     public void addSummaryDeprecatedComment(Element element, DocTree tag, Content htmltree) {
1188         CommentHelper ch = utils.getCommentHelper(element);
1189         List&lt;? extends DocTree&gt; body = ch.getBody(tag);
1190         addCommentTags(element, ch.getFirstSentenceTrees(body), true, true, true, htmltree);
1191     }
1192 
1193     /**
1194      * Adds the inline comment.
1195      *
1196      * @param element the Element for which the inline comments will be generated
1197      * @param htmltree the documentation tree to which the inline comments will be added
1198      */
1199     public void addInlineComment(Element element, Content htmltree) {
1200         addCommentTags(element, utils.getFullBody(element), false, false, false, htmltree);
1201     }
1202 
1203     /**
1204      * Adds the comment tags.
1205      *
1206      * @param element the Element for which the comment tags will be generated
1207      * @param tags the first sentence tags for the doc
1208      * @param depr true if it is deprecated
1209      * @param first true if the first sentence tags should be added
1210      * @param inSummary true if the comment tags are added into the summary section
1211      * @param htmltree the documentation tree to which the comment tags will be added
1212      */
1213     private void addCommentTags(Element element, List&lt;? extends DocTree&gt; tags, boolean depr,
1214             boolean first, boolean inSummary, Content htmltree) {
1215         addCommentTags(element, null, tags, depr, first, inSummary, htmltree);
1216     }
1217 
1218     /**
1219      * Adds the comment tags.
1220      *
1221      * @param element for which the comment tags will be generated
1222      * @param holderTag the block tag context for the inline tags
1223      * @param tags the first sentence tags for the doc
1224      * @param depr true if it is deprecated
1225      * @param first true if the first sentence tags should be added
1226      * @param inSummary true if the comment tags are added into the summary section
1227      * @param htmltree the documentation tree to which the comment tags will be added
1228      */
1229     private void addCommentTags(Element element, DocTree holderTag, List&lt;? extends DocTree&gt; tags, boolean depr,
1230             boolean first, boolean inSummary, Content htmltree) {
1231         if (options.noComment()){
1232             return;
1233         }
1234         Content div;
1235         Content result = commentTagsToContent(null, element, tags, first, inSummary);
1236         if (depr) {
1237             div = HtmlTree.DIV(HtmlStyle.deprecationComment, result);
1238             htmltree.add(div);
1239         }
1240         else {
1241             div = HtmlTree.DIV(HtmlStyle.block, result);
1242             htmltree.add(div);
1243         }
1244         if (tags.isEmpty()) {
1245             htmltree.add(Entity.NO_BREAK_SPACE);
1246         }
1247     }
1248 
1249     boolean ignoreNonInlineTag(DocTree dtree) {
1250         Name name = null;
1251         if (dtree.getKind() == Kind.START_ELEMENT) {
1252             StartElementTree setree = (StartElementTree)dtree;
1253             name = setree.getName();
1254         } else if (dtree.getKind() == Kind.END_ELEMENT) {
1255             EndElementTree eetree = (EndElementTree)dtree;
1256             name = eetree.getName();
1257         }
1258 
1259         if (name != null) {
1260             com.sun.tools.doclint.HtmlTag htmlTag = com.sun.tools.doclint.HtmlTag.get(name);
1261             if (htmlTag != null &amp;&amp;
1262                     htmlTag.blockType != com.sun.tools.doclint.HtmlTag.BlockType.INLINE) {
1263                 return true;
1264             }
1265         }
1266         return false;
1267     }
1268 
1269     boolean isAllWhiteSpace(String body) {
1270         for (int i = 0 ; i &lt; body.length(); i++) {
1271             if (!Character.isWhitespace(body.charAt(i)))
1272                 return false;
1273         }
1274         return true;
1275     }
1276 
1277     // Notify the next DocTree handler to take necessary action
1278     private boolean commentRemoved = false;
1279 
1280     /**
1281      * Converts inline tags and text to Content, expanding the
1282      * inline tags along the way.  Called wherever text can contain
1283      * an inline tag, such as in comments or in free-form text arguments
1284      * to block tags.
1285      *
1286      * @param holderTag    specific tag where comment resides
1287      * @param element    specific element where comment resides
1288      * @param tags   array of text tags and inline tags (often alternating)
1289                present in the text of interest for this element
1290      * @param isFirstSentence  true if text is first sentence
1291      * @return a Content object
1292      */
1293     public Content commentTagsToContent(DocTree holderTag,
1294                                         Element element,
1295                                         List&lt;? extends DocTree&gt; tags,
1296                                         boolean isFirstSentence)
1297     {
1298         return commentTagsToContent(holderTag, element, tags, isFirstSentence, false);
1299     }
1300 
1301     /**
1302      * Converts inline tags and text to text strings, expanding the
1303      * inline tags along the way.  Called wherever text can contain
1304      * an inline tag, such as in comments or in free-form text arguments
1305      * to block tags.
1306      *
1307      * @param holderTag       specific tag where comment resides
1308      * @param element         specific element where comment resides
1309      * @param trees           array of text tags and inline tags (often alternating)
1310      *                        present in the text of interest for this element
1311      * @param isFirstSentence true if text is first sentence
1312      * @param inSummary       if the comment tags are added into the summary section
1313      * @return a Content object
1314      */
1315     public Content commentTagsToContent(DocTree holderTag,
1316                                         Element element,
1317                                         List&lt;? extends DocTree&gt; trees,
1318                                         boolean isFirstSentence,
1319                                         boolean inSummary)
1320     {
1321         final Content result = new ContentBuilder() {
1322             @Override
1323             public ContentBuilder add(CharSequence text) {
1324                 return super.add(utils.normalizeNewlines(text));
1325             }
1326         };
1327         CommentHelper ch = utils.getCommentHelper(element);
1328         // Array of all possible inline tags for this javadoc run
1329         configuration.tagletManager.checkTags(element, trees, true);
1330         commentRemoved = false;
1331 
1332         for (ListIterator&lt;? extends DocTree&gt; iterator = trees.listIterator(); iterator.hasNext();) {
1333             boolean isFirstNode = !iterator.hasPrevious();
1334             DocTree tag = iterator.next();
1335             boolean isLastNode  = !iterator.hasNext();
1336 
1337             if (isFirstSentence) {
1338                 // Ignore block tags
1339                 if (ignoreNonInlineTag(tag))
1340                     continue;
1341 
1342                 // Ignore any trailing whitespace OR whitespace after removed html comment
1343                 if ((isLastNode || commentRemoved)
1344                         &amp;&amp; tag.getKind() == TEXT
1345                         &amp;&amp; isAllWhiteSpace(ch.getText(tag)))
1346                     continue;
1347 
1348                 // Ignore any leading html comments
1349                 if ((isFirstNode || commentRemoved) &amp;&amp; tag.getKind() == COMMENT) {
1350                     commentRemoved = true;
1351                     continue;
1352                 }
1353             }
1354 
1355             boolean allDone = new SimpleDocTreeVisitor&lt;Boolean, Content&gt;() {
1356 
1357                 private boolean inAnAtag() {
1358                     if (utils.isStartElement(tag)) {
1359                         StartElementTree st = (StartElementTree)tag;
1360                         Name name = st.getName();
1361                         if (name != null) {
1362                             com.sun.tools.doclint.HtmlTag htag =
1363                                     com.sun.tools.doclint.HtmlTag.get(name);
1364                             return htag != null &amp;&amp; htag.equals(com.sun.tools.doclint.HtmlTag.A);
1365                         }
1366                     }
1367                     return false;
1368                 }
1369 
1370                 @Override
1371                 public Boolean visitAttribute(AttributeTree node, Content c) {
1372                     StringBuilder sb = new StringBuilder(SPACER).append(node.getName());
1373                     if (node.getValueKind() == ValueKind.EMPTY) {
1374                         result.add(sb);
1375                         return false;
1376                     }
1377                     sb.append(&quot;=&quot;);
1378                     String quote;
1379                     switch (node.getValueKind()) {
1380                         case DOUBLE:
1381                             quote = &quot;\&quot;&quot;;
1382                             break;
1383                         case SINGLE:
1384                             quote = &quot;&#39;&quot;;
1385                             break;
1386                         default:
1387                             quote = &quot;&quot;;
1388                             break;
1389                     }
1390                     sb.append(quote);
1391                     result.add(sb);
1392                     Content docRootContent = new ContentBuilder();
1393 
1394                     boolean isHRef = inAnAtag() &amp;&amp; node.getName().toString().equalsIgnoreCase(&quot;href&quot;);
1395                     for (DocTree dt : node.getValue()) {
1396                         if (utils.isText(dt) &amp;&amp; isHRef) {
1397                             String text = ((TextTree) dt).getBody();
1398                             if (text.startsWith(&quot;/..&quot;) &amp;&amp; !options.docrootParent().isEmpty()) {
1399                                 result.add(options.docrootParent());
1400                                 docRootContent = new ContentBuilder();
1401                                 result.add(textCleanup(text.substring(3), isLastNode));
1402                             } else {
1403                                 if (!docRootContent.isEmpty()) {
1404                                     docRootContent = copyDocRootContent(docRootContent);
1405                                 } else {
1406                                     text = redirectRelativeLinks(element, (TextTree) dt);
1407                                 }
1408                                 result.add(textCleanup(text, isLastNode));
1409                             }
1410                         } else {
1411                             docRootContent = copyDocRootContent(docRootContent);
1412                             dt.accept(this, docRootContent);
1413                         }
1414                     }
1415                     copyDocRootContent(docRootContent);
1416                     result.add(quote);
1417                     return false;
1418                 }
1419 
1420                 @Override
1421                 public Boolean visitComment(CommentTree node, Content c) {
1422                     result.add(new RawHtml(node.getBody()));
1423                     return false;
1424                 }
1425 
1426                 private Content copyDocRootContent(Content content) {
1427                     if (!content.isEmpty()) {
1428                         result.add(content);
1429                         return new ContentBuilder();
1430                     }
1431                     return content;
1432                 }
1433 
1434                 @Override
1435                 public Boolean visitDocRoot(DocRootTree node, Content c) {
1436                     Content docRootContent = TagletWriter.getInlineTagOutput(element,
1437                             configuration.tagletManager,
1438                             holderTag,
1439                             node,
1440                             getTagletWriterInstance(isFirstSentence));
1441                     if (c != null) {
1442                         c.add(docRootContent);
1443                     } else {
1444                         result.add(docRootContent);
1445                     }
1446                     return false;
1447                 }
1448 
1449                 @Override
1450                 public Boolean visitEndElement(EndElementTree node, Content c) {
1451                     RawHtml rawHtml = new RawHtml(&quot;&lt;/&quot; + node.getName() + &quot;&gt;&quot;);
1452                     result.add(rawHtml);
1453                     return false;
1454                 }
1455 
1456                 @Override
1457                 public Boolean visitEntity(EntityTree node, Content c) {
1458                     result.add(new RawHtml(node.toString()));
1459                     return false;
1460                 }
1461 
1462                 @Override
1463                 public Boolean visitErroneous(ErroneousTree node, Content c) {
1464                     messages.warning(ch.getDocTreePath(node),
1465                             &quot;doclet.tag.invalid_usage&quot;, node);
1466                     result.add(new RawHtml(node.toString()));
1467                     return false;
1468                 }
1469 
1470                 @Override
1471                 public Boolean visitInheritDoc(InheritDocTree node, Content c) {
1472                     Content output = TagletWriter.getInlineTagOutput(element,
1473                             configuration.tagletManager, holderTag,
1474                             tag, getTagletWriterInstance(isFirstSentence));
1475                     result.add(output);
1476                     // if we obtained the first sentence successfully, nothing more to do
1477                     return (isFirstSentence &amp;&amp; !output.isEmpty());
1478                 }
1479 
1480                 @Override
1481                 public Boolean visitIndex(IndexTree node, Content p) {
1482                     Content output = TagletWriter.getInlineTagOutput(element,
1483                             configuration.tagletManager, holderTag, tag,
1484                             getTagletWriterInstance(isFirstSentence, inSummary));
1485                     if (output != null) {
1486                         result.add(output);
1487                     }
1488                     return false;
1489                 }
1490 
1491                 @Override
1492                 public Boolean visitLink(LinkTree node, Content c) {
1493                     // we need to pass the DocTreeImpl here, so ignore node
1494                     Content content = seeTagToContent(element, tag);
1495                     result.add(content);
1496                     return false;
1497                 }
1498 
1499                 @Override
1500                 public Boolean visitLiteral(LiteralTree node, Content c) {
1501                     String s = node.getBody().getBody();
1502                     Content content = new StringContent(utils.normalizeNewlines(s));
1503                     if (node.getKind() == CODE)
1504                         content = HtmlTree.CODE(content);
1505                     result.add(content);
1506                     return false;
1507                 }
1508 
1509                 @Override
1510                 public Boolean visitSee(SeeTree node, Content c) {
1511                     // we need to pass the DocTreeImpl here, so ignore node
1512                     result.add(seeTagToContent(element, tag));
1513                     return false;
1514                 }
1515 
1516                 @Override
1517                 public Boolean visitStartElement(StartElementTree node, Content c) {
1518                     String text = &quot;&lt;&quot; + node.getName();
1519                     RawHtml rawHtml = new RawHtml(utils.normalizeNewlines(text));
1520                     result.add(rawHtml);
1521 
1522                     for (DocTree dt : node.getAttributes()) {
1523                         dt.accept(this, null);
1524                     }
1525                     result.add(new RawHtml(node.isSelfClosing() ? &quot;/&gt;&quot; : &quot;&gt;&quot;));
1526                     return false;
1527                 }
1528 
1529                 @Override
1530                 public Boolean visitSummary(SummaryTree node, Content c) {
1531                     Content output = TagletWriter.getInlineTagOutput(element,
1532                             configuration.tagletManager, holderTag, tag,
1533                             getTagletWriterInstance(isFirstSentence));
1534                     result.add(output);
1535                     return false;
1536                 }
1537 
1538                 @Override
1539                 public Boolean visitSystemProperty(SystemPropertyTree node, Content p) {
1540                     Content output = TagletWriter.getInlineTagOutput(element,
1541                             configuration.tagletManager, holderTag, tag,
1542                             getTagletWriterInstance(isFirstSentence, inSummary));
1543                     if (output != null) {
1544                         result.add(output);
1545                     }
1546                     return false;
1547                 }
1548 
1549                 private CharSequence textCleanup(String text, boolean isLast) {
1550                     return textCleanup(text, isLast, false);
1551                 }
1552 
1553                 private CharSequence textCleanup(String text, boolean isLast, boolean stripLeading) {
1554                     boolean stripTrailing = isFirstSentence &amp;&amp; isLast;
1555                     if (stripLeading &amp;&amp; stripTrailing) {
1556                         text = text.strip();
1557                     } else if (stripLeading) {
1558                         text = text.stripLeading();
1559                     } else if (stripTrailing) {
1560                         text = text.stripTrailing();
1561                     }
1562                     text = utils.replaceTabs(text);
1563                     return utils.normalizeNewlines(text);
1564                 }
1565 
1566                 @Override
1567                 public Boolean visitText(TextTree node, Content c) {
1568                     String text = node.getBody();
1569                     result.add(new RawHtml(textCleanup(text, isLastNode, commentRemoved)));
1570                     return false;
1571                 }
1572 
1573                 @Override
1574                 protected Boolean defaultAction(DocTree node, Content c) {
1575                     Content output = TagletWriter.getInlineTagOutput(element,
1576                             configuration.tagletManager, holderTag, tag,
1577                             getTagletWriterInstance(isFirstSentence));
1578                     if (output != null) {
1579                         result.add(output);
1580                     }
1581                     return false;
1582                 }
1583 
1584             }.visit(tag, null);
1585             commentRemoved = false;
1586             if (allDone)
1587                 break;
1588         }
1589         return result;
1590     }
1591 
1592     /**
1593      * Return true if relative links should not be redirected.
1594      *
1595      * @return Return true if a relative link should not be redirected.
1596      */
1597     private boolean shouldNotRedirectRelativeLinks() {
1598         return  this instanceof ClassWriter ||
1599                 this instanceof PackageSummaryWriter;
1600     }
1601 
1602     /**
1603      * Suppose a piece of documentation has a relative link.  When you copy
1604      * that documentation to another place such as the index or class-use page,
1605      * that relative link will no longer work.  We should redirect those links
1606      * so that they will work again.
1607      * &lt;p&gt;
1608      * Here is the algorithm used to fix the link:
1609      * &lt;p&gt;
1610      * {@literal &lt;relative link&gt; =&gt; docRoot + &lt;relative path to file&gt; + &lt;relative link&gt; }
1611      * &lt;p&gt;
1612      * For example, suppose DocletEnvironment has this link:
1613      * {@literal &lt;a href=&quot;package-summary.html&quot;&gt;The package Page&lt;/a&gt; }
1614      * &lt;p&gt;
1615      * If this link appeared in the index, we would redirect
1616      * the link like this:
1617      *
1618      * {@literal &lt;a href=&quot;./jdk/javadoc/doclet/package-summary.html&quot;&gt;The package Page&lt;/a&gt;}
1619      *
1620      * @param element the Element object whose documentation is being written.
1621      * @param tt the text being written.
1622      *
1623      * @return the text, with all the relative links redirected to work.
1624      */
1625     @SuppressWarnings(&quot;preview&quot;)
1626     private String redirectRelativeLinks(Element element, TextTree tt) {
1627         String text = tt.getBody();
1628         if (element == null || utils.isOverviewElement(element) || shouldNotRedirectRelativeLinks()) {
1629             return text;
1630         }
1631 
1632         DocPath redirectPathFromRoot = new SimpleElementVisitor14&lt;DocPath, Void&gt;() {
1633             @Override
1634             public DocPath visitType(TypeElement e, Void p) {
1635                 return docPaths.forPackage(utils.containingPackage(e));
1636             }
1637 
1638             @Override
1639             public DocPath visitPackage(PackageElement e, Void p) {
1640                 return docPaths.forPackage(e);
1641             }
1642 
1643             @Override
1644             public DocPath visitVariable(VariableElement e, Void p) {
1645                 return docPaths.forPackage(utils.containingPackage(e));
1646             }
1647 
1648             @Override
1649             public DocPath visitExecutable(ExecutableElement e, Void p) {
1650                 return docPaths.forPackage(utils.containingPackage(e));
1651             }
1652 
1653             @Override
1654             protected DocPath defaultAction(Element e, Void p) {
1655                 return null;
1656             }
1657         }.visit(element);
1658         if (redirectPathFromRoot == null) {
1659             return text;
1660         }
1661         String lower = Utils.toLowerCase(text);
1662         if (!(lower.startsWith(&quot;mailto:&quot;)
1663                 || lower.startsWith(&quot;http:&quot;)
1664                 || lower.startsWith(&quot;https:&quot;)
1665                 || lower.startsWith(&quot;file:&quot;))) {
1666             text = &quot;{@&quot; + (new DocRootTaglet()).getName() + &quot;}/&quot;
1667                     + redirectPathFromRoot.resolve(text).getPath();
1668             text = replaceDocRootDir(text);
1669         }
1670         return text;
1671     }
1672 
1673     /**
1674      * According to
1675      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
1676      * all the outer classes and static nested classes are core classes.
1677      */
1678     public boolean isCoreClass(TypeElement typeElement) {
1679         return utils.getEnclosingTypeElement(typeElement) == null || utils.isStatic(typeElement);
1680     }
1681 
1682     /**
1683      * Adds the annotation types for the given packageElement.
1684      *
1685      * @param packageElement the package to write annotations for.
1686      * @param htmltree the documentation tree to which the annotation info will be
1687      *        added
1688      */
1689     public void addAnnotationInfo(PackageElement packageElement, Content htmltree) {
1690         addAnnotationInfo(packageElement.getAnnotationMirrors(), htmltree);
1691     }
1692 
1693     /*
1694      * this is a hack to delay dealing with Annotations in the writers, the assumption
1695      * is that all necessary checks have been made to get here.
1696      */
1697     public void addReceiverAnnotationInfo(ExecutableElement method, TypeMirror rcvrTypeMirror,
1698             List&lt;? extends AnnotationMirror&gt; annotationMirrors, Content htmltree) {
1699         TypeMirror rcvrType = method.getReceiverType();
1700         List&lt;? extends AnnotationMirror&gt; annotationMirrors1 = rcvrType.getAnnotationMirrors();
1701         htmltree.add(getAnnotationInfo(annotationMirrors1, false));
1702     }
1703 
1704     /**
1705      * Adds the annotation types for the given element.
1706      *
1707      * @param element the package to write annotations for
1708      * @param htmltree the content tree to which the annotation types will be added
1709      */
1710     public void addAnnotationInfo(Element element, Content htmltree) {
1711         addAnnotationInfo(element.getAnnotationMirrors(), htmltree);
1712     }
1713 
1714     /**
1715      * Add the annotation types for the given element and parameter.
1716      *
1717      * @param param the parameter to write annotations for.
1718      * @param tree the content tree to which the annotation types will be added
1719      */
1720     public boolean addAnnotationInfo(VariableElement param, Content tree) {
1721         Content annotationInfo = getAnnotationInfo(param.getAnnotationMirrors(), false);
1722         if (annotationInfo.isEmpty()) {
1723             return false;
1724         }
1725         tree.add(annotationInfo);
1726         return true;
1727     }
1728 
1729     /**
1730      * Adds the annotation types for the given Element.
1731      *
1732      * @param descList a list of annotation mirrors.
1733      * @param htmltree the documentation tree to which the annotation info will be
1734      *        added
1735      */
1736     private void addAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, Content htmltree) {
1737         htmltree.add(getAnnotationInfo(descList, true));
1738     }
1739 
1740     /**
1741      * Return a content tree containing the annotation types for the given element.
1742      *
1743      * @param descList a list of annotation mirrors.
1744      * @return the documentation tree containing the annotation info.
1745      */
1746     Content getAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, boolean lineBreak) {
1747         List&lt;Content&gt; annotations = getAnnotations(descList, lineBreak);
1748         String sep = &quot;&quot;;
1749         ContentBuilder builder = new ContentBuilder();
1750         for (Content annotation: annotations) {
1751             builder.add(sep);
1752             builder.add(annotation);
1753             if (!lineBreak) {
1754                 sep = &quot; &quot;;
1755             }
1756         }
1757         return builder;
1758     }
1759 
1760     /**
1761      * Return the string representations of the annotation types for
1762      * the given doc.
1763      *
1764      * @param descList a list of annotation mirrors.
1765      * @param linkBreak if true, add new line between each member value.
1766      * @return a list of strings representing the annotations being
1767      *         documented.
1768      */
1769     public List&lt;Content&gt; getAnnotations(List&lt;? extends AnnotationMirror&gt; descList, boolean linkBreak) {
1770         List&lt;Content&gt; results = new ArrayList&lt;&gt;();
1771         ContentBuilder annotation;
1772         for (AnnotationMirror aDesc : descList) {
1773             TypeElement annotationElement = (TypeElement)aDesc.getAnnotationType().asElement();
1774             // If an annotation is not documented, do not add it to the list. If
1775             // the annotation is of a repeatable type, and if it is not documented
1776             // and also if its container annotation is not documented, do not add it
1777             // to the list. If an annotation of a repeatable type is not documented
1778             // but its container is documented, it will be added to the list.
1779             if (!utils.isDocumentedAnnotation(annotationElement) &amp;&amp;
1780                 (!isAnnotationDocumented &amp;&amp; !isContainerDocumented)) {
1781                 continue;
1782             }
1783             annotation = new ContentBuilder();
1784             isAnnotationDocumented = false;
1785             LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
1786                                                      LinkInfoImpl.Kind.ANNOTATION, annotationElement);
1787             Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = aDesc.getElementValues();
1788             // If the annotation is synthesized, do not print the container.
1789             if (utils.configuration.workArounds.isSynthesized(aDesc)) {
1790                 for (ExecutableElement ee : pairs.keySet()) {
1791                     AnnotationValue annotationValue = pairs.get(ee);
1792                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1793 
1794                     new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1795                         @Override
1796                         public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; p) {
1797                             p.addAll(vals);
1798                             return null;
1799                         }
1800 
1801                         @Override
1802                         protected Void defaultAction(Object o, List&lt;AnnotationValue&gt; p) {
1803                             p.add(annotationValue);
1804                             return null;
1805                         }
1806                     }.visit(annotationValue, annotationTypeValues);
1807 
1808                     String sep = &quot;&quot;;
1809                     for (AnnotationValue av : annotationTypeValues) {
1810                         annotation.add(sep);
1811                         annotation.add(annotationValueToContent(av));
1812                         sep = &quot; &quot;;
1813                     }
1814                 }
1815             } else if (isAnnotationArray(pairs)) {
1816                 // If the container has 1 or more value defined and if the
1817                 // repeatable type annotation is not documented, do not print
1818                 // the container.
1819                 if (pairs.size() == 1 &amp;&amp; isAnnotationDocumented) {
1820                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1821                     for (AnnotationValue a :  pairs.values()) {
1822                         new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1823                             @Override
1824                             public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; annotationTypeValues) {
1825                                annotationTypeValues.addAll(vals);
1826                                return null;
1827                             }
1828                         }.visit(a, annotationTypeValues);
1829                     }
1830                     String sep = &quot;&quot;;
1831                     for (AnnotationValue av : annotationTypeValues) {
1832                         annotation.add(sep);
1833                         annotation.add(annotationValueToContent(av));
1834                         sep = &quot; &quot;;
1835                     }
1836                 }
1837                 // If the container has 1 or more value defined and if the
1838                 // repeatable type annotation is not documented, print the container.
1839                 else {
1840                     addAnnotations(annotationElement, linkInfo, annotation, pairs, false);
1841                 }
1842             }
1843             else {
1844                 addAnnotations(annotationElement, linkInfo, annotation, pairs, linkBreak);
1845             }
1846             annotation.add(linkBreak ? DocletConstants.NL : &quot;&quot;);
1847             results.add(annotation);
1848         }
1849         return results;
1850     }
1851 
1852     /**
1853      * Add annotation to the annotation string.
1854      *
1855      * @param annotationDoc the annotation being documented
1856      * @param linkInfo the information about the link
1857      * @param annotation the annotation string to which the annotation will be added
1858      * @param map annotation type element to annotation value pairs
1859      * @param linkBreak if true, add new line between each member value
1860      */
1861     private void addAnnotations(TypeElement annotationDoc, LinkInfoImpl linkInfo,
1862                                 ContentBuilder annotation,
1863                                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; map,
1864                                 boolean linkBreak) {
1865         linkInfo.label = new StringContent(&quot;@&quot;);
1866         linkInfo.label.add(annotationDoc.getSimpleName());
1867         annotation.add(getLink(linkInfo));
1868         if (!map.isEmpty()) {
1869             annotation.add(&quot;(&quot;);
1870             boolean isFirst = true;
1871             Set&lt;? extends ExecutableElement&gt; keys = map.keySet();
1872             boolean multipleValues = keys.size() &gt; 1;
1873             for (ExecutableElement element : keys) {
1874                 if (isFirst) {
1875                     isFirst = false;
1876                 } else {
1877                     annotation.add(&quot;,&quot;);
1878                     if (linkBreak) {
1879                         annotation.add(DocletConstants.NL);
1880                         int spaces = annotationDoc.getSimpleName().length() + 2;
1881                         for (int k = 0; k &lt; (spaces); k++) {
1882                             annotation.add(&quot; &quot;);
1883                         }
1884                     }
1885                 }
1886                 String simpleName = element.getSimpleName().toString();
1887                 if (multipleValues || !&quot;value&quot;.equals(simpleName)) { // Omit &quot;value=&quot; where unnecessary
1888                     annotation.add(getDocLink(LinkInfoImpl.Kind.ANNOTATION,
1889                                                      element, simpleName, false));
1890                     annotation.add(&quot;=&quot;);
1891                 }
1892                 AnnotationValue annotationValue = map.get(element);
1893                 List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1894                 new SimpleAnnotationValueVisitor9&lt;Void, AnnotationValue&gt;() {
1895                     @Override
1896                     public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, AnnotationValue p) {
1897                         annotationTypeValues.addAll(vals);
1898                         return null;
1899                     }
1900                     @Override
1901                     protected Void defaultAction(Object o, AnnotationValue p) {
1902                         annotationTypeValues.add(p);
1903                         return null;
1904                     }
1905                 }.visit(annotationValue, annotationValue);
1906                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;{&quot;);
1907                 String sep = &quot;&quot;;
1908                 for (AnnotationValue av : annotationTypeValues) {
1909                     annotation.add(sep);
1910                     annotation.add(annotationValueToContent(av));
1911                     sep = &quot;,&quot;;
1912                 }
1913                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;}&quot;);
1914                 isContainerDocumented = false;
1915             }
1916             annotation.add(&quot;)&quot;);
1917         }
1918     }
1919 
1920     /**
1921      * Check if the annotation contains an array of annotation as a value. This
1922      * check is to verify if a repeatable type annotation is present or not.
1923      *
1924      * @param pairs annotation type element and value pairs
1925      *
1926      * @return true if the annotation contains an array of annotation as a value.
1927      */
1928     private boolean isAnnotationArray(Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs) {
1929         AnnotationValue annotationValue;
1930         for (ExecutableElement ee : pairs.keySet()) {
1931             annotationValue = pairs.get(ee);
1932             boolean rvalue = new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
1933                 @Override
1934                 public Boolean visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
1935                     if (vals.size() &gt; 1) {
1936                         if (vals.get(0) instanceof AnnotationMirror) {
1937                             isContainerDocumented = true;
1938                             return new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
1939                                 @Override
1940                                 public Boolean visitAnnotation(AnnotationMirror a, Void p) {
1941                                     isContainerDocumented = true;
1942                                     Element asElement = a.getAnnotationType().asElement();
1943                                     if (utils.isDocumentedAnnotation((TypeElement)asElement)) {
1944                                         isAnnotationDocumented = true;
1945                                     }
1946                                     return true;
1947                                 }
1948                                 @Override
1949                                 protected Boolean defaultAction(Object o, Void p) {
1950                                     return false;
1951                                 }
1952                             }.visit(vals.get(0));
1953                         }
1954                     }
1955                     return false;
1956                 }
1957 
1958                 @Override
1959                 protected Boolean defaultAction(Object o, Void p) {
1960                     return false;
1961                 }
1962             }.visit(annotationValue);
1963             if (rvalue) {
1964                 return true;
1965             }
1966         }
1967         return false;
1968     }
1969 
1970     private Content annotationValueToContent(AnnotationValue annotationValue) {
1971         return new SimpleAnnotationValueVisitor9&lt;Content, Void&gt;() {
1972 
1973             @Override
1974             public Content visitType(TypeMirror t, Void p) {
1975                 return new SimpleTypeVisitor9&lt;Content, Void&gt;() {
1976                     @Override
1977                     public Content visitDeclared(DeclaredType t, Void p) {
1978                         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
1979                                 LinkInfoImpl.Kind.ANNOTATION, t);
1980                         String name = utils.isIncluded(t.asElement())
1981                                 ? t.asElement().getSimpleName().toString()
1982                                 : utils.getFullyQualifiedName(t.asElement());
1983                         linkInfo.label = new StringContent(name + utils.getDimension(t) + &quot;.class&quot;);
1984                         return getLink(linkInfo);
1985                     }
1986                     @Override
1987                     protected Content defaultAction(TypeMirror e, Void p) {
1988                         return new StringContent(t + utils.getDimension(t) + &quot;.class&quot;);
1989                     }
1990                 }.visit(t);
1991             }
1992             @Override
1993             public Content visitAnnotation(AnnotationMirror a, Void p) {
1994                 List&lt;Content&gt; list = getAnnotations(List.of(a), false);
1995                 ContentBuilder buf = new ContentBuilder();
1996                 for (Content c : list) {
1997                     buf.add(c);
1998                 }
1999                 return buf;
2000             }
2001             @Override
2002             public Content visitEnumConstant(VariableElement c, Void p) {
2003                 return getDocLink(LinkInfoImpl.Kind.ANNOTATION,
2004                         c, c.getSimpleName(), false);
2005             }
2006             @Override
2007             public Content visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
2008                 ContentBuilder buf = new ContentBuilder();
2009                 String sep = &quot;&quot;;
2010                 for (AnnotationValue av : vals) {
2011                     buf.add(sep);
2012                     buf.add(visit(av));
2013                     sep = &quot; &quot;;
2014                 }
2015                 return buf;
2016             }
2017             @Override
2018             protected Content defaultAction(Object o, Void p) {
2019                 return new StringContent(annotationValue.toString());
2020             }
2021         }.visit(annotationValue);
2022     }
2023 
2024     protected TableHeader getPackageTableHeader() {
2025         return new TableHeader(contents.packageLabel, contents.descriptionLabel);
2026     }
2027 
2028     /**
2029      * Generates a string for use in a description meta element,
2030      * based on an element and its enclosing elements
2031      * @param prefix a prefix for the string
2032      * @param elem the element
2033      * @return the description
2034      */
2035     static String getDescription(String prefix, Element elem) {
2036         LinkedList&lt;Element&gt; chain = new LinkedList&lt;&gt;();
2037         for (Element e = elem; e != null; e = e.getEnclosingElement()) {
2038             // ignore unnamed enclosing elements
2039             if (e.getSimpleName().length() == 0 &amp;&amp; e != elem) {
2040                 break;
2041             }
2042             chain.addFirst(e);
2043         }
2044         StringBuilder sb = new StringBuilder();
2045         for (Element e: chain) {
2046             CharSequence name;
2047             switch (e.getKind()) {
2048                 case MODULE:
2049                 case PACKAGE:
2050                     name = ((QualifiedNameable) e).getQualifiedName();
2051                     if (name.length() == 0) {
2052                         name = &quot;&lt;unnamed&gt;&quot;;
2053                     }
2054                     break;
2055 
2056                 default:
2057                     name = e.getSimpleName();
2058                     break;
2059             }
2060 
2061             if (sb.length() == 0) {
2062                 sb.append(prefix).append(&quot;: &quot;);
2063             } else {
2064                 sb.append(&quot;, &quot;);
2065             }
2066             sb.append(e.getKind().toString().toLowerCase(Locale.US).replace(&quot;_&quot;, &quot; &quot;))
2067                     .append(&quot;: &quot;)
2068                     .append(name);
2069         }
2070         return sb.toString();
2071     }
2072 
2073     static String getGenerator(Class&lt;?&gt; clazz) {
2074         return &quot;javadoc/&quot; + clazz.getSimpleName();
2075     }
2076 
2077     /**
2078      * Returns an HtmlTree for the BODY tag.
2079      *
2080      * @param title title for the window
2081      * @return an HtmlTree for the BODY tag
2082      */
2083     public HtmlTree getBody(String title) {
2084         HtmlTree body = new HtmlTree(TagName.BODY).setStyle(getBodyStyle());
2085 
2086         this.winTitle = title;
2087         // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
2088         // and package-frame
2089         body.add(mainBodyScript.asContent());
2090         Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));
2091         body.add(noScript);
2092         return body;
2093     }
2094 
2095     public HtmlStyle getBodyStyle() {
2096         String kind = getClass().getSimpleName()
2097                 .replaceAll(&quot;(Writer)?(Impl)?$&quot;, &quot;&quot;)
2098                 .replaceAll(&quot;AnnotationType&quot;, &quot;Class&quot;)
2099                 .replaceAll(&quot;^(Module|Package|Class)$&quot;, &quot;$1Declaration&quot;);
2100         String page = kind.substring(0, 1).toLowerCase(Locale.US) + kind.substring(1) + &quot;Page&quot;;
2101         return HtmlStyle.valueOf(page);
2102     }
2103 
2104     Script getMainBodyScript() {
2105         return mainBodyScript;
2106     }
2107 
2108     /**
2109      * Returns the path of module/package specific stylesheets for the element.
2110      * @param element module/Package element
2111      * @return list of path of module/package specific stylesheets
2112      * @throws DocFileIOException
2113      */
2114     List&lt;DocPath&gt; getLocalStylesheets(Element element) throws DocFileIOException {
2115         List&lt;DocPath&gt; stylesheets = new ArrayList&lt;&gt;();
2116         DocPath basePath = null;
2117         if (element instanceof PackageElement) {
2118             stylesheets.addAll(getModuleStylesheets((PackageElement)element));
2119             basePath = docPaths.forPackage((PackageElement)element);
2120         } else if (element instanceof ModuleElement) {
2121             basePath = DocPaths.forModule((ModuleElement)element);
2122         }
2123         for (DocPath stylesheet : getStylesheets(element)) {
2124             stylesheets.add(basePath.resolve(stylesheet.getPath()));
2125         }
2126         return stylesheets;
2127     }
2128 
2129     private List&lt;DocPath&gt; getModuleStylesheets(PackageElement pkgElement) throws
2130             DocFileIOException {
2131         List&lt;DocPath&gt; moduleStylesheets = new ArrayList&lt;&gt;();
2132         ModuleElement moduleElement = utils.containingModule(pkgElement);
2133         if (moduleElement != null &amp;&amp; !moduleElement.isUnnamed()) {
2134             List&lt;DocPath&gt; localStylesheets = getStylesheets(moduleElement);
2135             DocPath basePath = DocPaths.forModule(moduleElement);
2136             for (DocPath stylesheet : localStylesheets) {
2137                 moduleStylesheets.add(basePath.resolve(stylesheet));
2138             }
2139         }
2140         return moduleStylesheets;
2141     }
2142 
2143     private List&lt;DocPath&gt; getStylesheets(Element element) throws DocFileIOException {
2144         List&lt;DocPath&gt; localStylesheets = configuration.localStylesheetMap.get(element);
2145         if (localStylesheets == null) {
2146             DocFilesHandlerImpl docFilesHandler = (DocFilesHandlerImpl)configuration
2147                     .getWriterFactory().getDocFilesHandler(element);
2148             localStylesheets = docFilesHandler.getStylesheets();
2149             configuration.localStylesheetMap.put(element, localStylesheets);
2150         }
2151         return localStylesheets;
2152     }
2153 
2154     Content getVerticalSeparator() {
2155         return HtmlTree.SPAN(HtmlStyle.verticalSeparator, new FixedStringContent(&quot;|&quot;));
2156     }
2157 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.formats.html;
  27 
  28 import java.util.ArrayList;
  29 import java.util.Collections;
  30 import java.util.HashMap;
  31 import java.util.LinkedList;
  32 import java.util.List;
  33 import java.util.ListIterator;
  34 import java.util.Locale;
  35 import java.util.Map;
  36 import java.util.Set;
  37 import java.util.regex.Matcher;
  38 import java.util.regex.Pattern;
  39 
  40 import javax.lang.model.element.AnnotationMirror;
  41 import javax.lang.model.element.AnnotationValue;
  42 import javax.lang.model.element.Element;
  43 import javax.lang.model.element.ElementKind;
  44 import javax.lang.model.element.ExecutableElement;
  45 import javax.lang.model.element.ModuleElement;
  46 import javax.lang.model.element.Name;
  47 import javax.lang.model.element.PackageElement;
  48 import javax.lang.model.element.QualifiedNameable;
  49 import javax.lang.model.element.TypeElement;
  50 import javax.lang.model.element.VariableElement;
  51 import javax.lang.model.type.DeclaredType;
  52 import javax.lang.model.type.TypeMirror;
  53 import javax.lang.model.util.SimpleAnnotationValueVisitor9;
  54 import javax.lang.model.util.SimpleElementVisitor14;
  55 import javax.lang.model.util.SimpleTypeVisitor9;
  56 
  57 import com.sun.source.doctree.AttributeTree;
  58 import com.sun.source.doctree.AttributeTree.ValueKind;
  59 import com.sun.source.doctree.CommentTree;
  60 import com.sun.source.doctree.DocRootTree;
  61 import com.sun.source.doctree.DocTree;
  62 import com.sun.source.doctree.DocTree.Kind;
  63 import com.sun.source.doctree.EndElementTree;
  64 import com.sun.source.doctree.EntityTree;
  65 import com.sun.source.doctree.ErroneousTree;
  66 import com.sun.source.doctree.IndexTree;
  67 import com.sun.source.doctree.InheritDocTree;
  68 import com.sun.source.doctree.LinkTree;
  69 import com.sun.source.doctree.LiteralTree;
  70 import com.sun.source.doctree.SeeTree;
  71 import com.sun.source.doctree.StartElementTree;
  72 import com.sun.source.doctree.SummaryTree;
  73 import com.sun.source.doctree.SystemPropertyTree;
  74 import com.sun.source.doctree.TextTree;
  75 import com.sun.source.util.SimpleDocTreeVisitor;
  76 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
  77 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
  78 import jdk.javadoc.internal.doclets.formats.html.markup.FixedStringContent;
  79 import jdk.javadoc.internal.doclets.formats.html.markup.Head;
  80 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  81 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
  82 import jdk.javadoc.internal.doclets.formats.html.markup.TagName;
  83 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  84 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  85 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  86 import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  87 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
  88 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
  89 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  90 import jdk.javadoc.internal.doclets.toolkit.Content;
  91 import jdk.javadoc.internal.doclets.toolkit.Messages;
  92 import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
  93 import jdk.javadoc.internal.doclets.toolkit.Resources;
  94 import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;
  95 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;
  96 import jdk.javadoc.internal.doclets.toolkit.util.Comparators;
  97 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  98 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
  99 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 100 import jdk.javadoc.internal.doclets.toolkit.util.DocLink;
 101 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 102 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
 103 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 104 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 105 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 106 
 107 import static com.sun.source.doctree.DocTree.Kind.CODE;
 108 import static com.sun.source.doctree.DocTree.Kind.COMMENT;
 109 import static com.sun.source.doctree.DocTree.Kind.LINK;
 110 import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;
 111 import static com.sun.source.doctree.DocTree.Kind.SEE;
 112 import static com.sun.source.doctree.DocTree.Kind.TEXT;
 113 import static jdk.javadoc.internal.doclets.toolkit.util.CommentHelper.SPACER;
 114 
 115 
 116 /**
 117  * Class for the Html Format Code Generation specific to JavaDoc.
 118  * This Class contains methods related to the Html Code Generation which
 119  * are used extensively while generating the entire documentation.
 120  *
 121  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 122  *  If you write code that depends on this, you do so at your own risk.
 123  *  This code and its internal interfaces are subject to change or
 124  *  deletion without notice.&lt;/b&gt;
 125  */
 126 public class HtmlDocletWriter {
 127 
 128     /**
 129      * Relative path from the file getting generated to the destination
 130      * directory. For example, if the file getting generated is
 131      * &quot;java/lang/Object.html&quot;, then the path to the root is &quot;../..&quot;.
 132      * This string can be empty if the file getting generated is in
 133      * the destination directory.
 134      */
 135     public final DocPath pathToRoot;
 136 
 137     /**
 138      * Platform-independent path from the current or the
 139      * destination directory to the file getting generated.
 140      * Used when creating the file.
 141      */
 142     public final DocPath path;
 143 
 144     /**
 145      * Name of the file getting generated. If the file getting generated is
 146      * &quot;java/lang/Object.html&quot;, then the filename is &quot;Object.html&quot;.
 147      */
 148     public final DocPath filename;
 149 
 150     /**
 151      * The global configuration information for this run.
 152      */
 153     public final HtmlConfiguration configuration;
 154 
 155     protected final SearchIndexItems searchItems;
 156 
 157     protected final HtmlOptions options;
 158 
 159     protected final Utils utils;
 160 
 161     protected final Contents contents;
 162 
 163     protected final Messages messages;
 164 
 165     protected final Resources resources;
 166 
 167     protected final Links links;
 168 
 169     protected final DocPaths docPaths;
 170 
 171     protected final Comparators comparators;
 172 
 173     /**
 174      * To check whether annotation heading is printed or not.
 175      */
 176     protected boolean printedAnnotationHeading = false;
 177 
 178     /**
 179      * To check whether annotation field heading is printed or not.
 180      */
 181     protected boolean printedAnnotationFieldHeading = false;
 182 
 183     /**
 184      * To check whether the repeated annotations is documented or not.
 185      */
 186     private boolean isAnnotationDocumented = false;
 187 
 188     /**
 189      * To check whether the container annotations is documented or not.
 190      */
 191     private boolean isContainerDocumented = false;
 192 
 193     /**
 194      * The window title of this file.
 195      */
 196     protected String winTitle;
 197 
 198     protected Script mainBodyScript;
 199 
 200     /**
 201      * A table of the anchors used for at-index and related tags,
 202      * so that they can be made unique by appending a suitable suffix.
 203      * (Ideally, javadoc should be tracking all id&#39;s generated in a file
 204      * to avoid generating duplicates.)
 205      */
 206     Map&lt;String, Integer&gt; indexAnchorTable = new HashMap&lt;&gt;();
 207 
 208     /**
 209      * Creates an {@code HtmlDocletWriter}.
 210      *
 211      * @param configuration the configuration for this doclet
 212      * @param path the file to be generated.
 213      */
 214     public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path) {
 215         this.configuration = configuration;
 216         this.searchItems = configuration.searchItems;
 217         this.options = configuration.getOptions();
 218         this.contents = configuration.contents;
 219         this.messages = configuration.messages;
 220         this.resources = configuration.docResources;
 221         this.links = new Links(path);
 222         this.utils = configuration.utils;
 223         this.comparators = utils.comparators;
 224         this.path = path;
 225         this.pathToRoot = path.parent().invert();
 226         this.filename = path.basename();
 227         this.docPaths = configuration.docPaths;
 228         this.mainBodyScript = new Script();
 229 
 230         messages.notice(&quot;doclet.Generating_0&quot;,
 231             DocFile.createFileForOutput(configuration, path).getPath());
 232     }
 233 
 234     /**
 235      * Replace {&amp;#064;docRoot} tag used in options that accept HTML text, such
 236      * as -header, -footer, -top and -bottom, and when converting a relative
 237      * HREF where commentTagsToString inserts a {&amp;#064;docRoot} where one was
 238      * missing.  (Also see DocRootTaglet for {&amp;#064;docRoot} tags in doc
 239      * comments.)
 240      * &lt;p&gt;
 241      * Replace {&amp;#064;docRoot} tag in htmlstr with the relative path to the
 242      * destination directory from the directory where the file is being
 243      * written, looping to handle all such tags in htmlstr.
 244      * &lt;p&gt;
 245      * For example, for &quot;-d docs&quot; and -header containing {&amp;#064;docRoot}, when
 246      * the HTML page for source file p/C1.java is being generated, the
 247      * {&amp;#064;docRoot} tag would be inserted into the header as &quot;../&quot;,
 248      * the relative path from docs/p/ to docs/ (the document root).
 249      * &lt;p&gt;
 250      * Note: This doc comment was written with &#39;&amp;amp;#064;&#39; representing &#39;@&#39;
 251      * to prevent the inline tag from being interpreted.
 252      */
 253     public String replaceDocRootDir(String htmlstr) {
 254         // Return if no inline tags exist
 255         int index = htmlstr.indexOf(&quot;{@&quot;);
 256         if (index &lt; 0) {
 257             return htmlstr;
 258         }
 259         Matcher docrootMatcher = docrootPattern.matcher(htmlstr);
 260         if (!docrootMatcher.find()) {
 261             return htmlstr;
 262         }
 263         StringBuilder buf = new StringBuilder();
 264         int prevEnd = 0;
 265         do {
 266             int match = docrootMatcher.start();
 267             // append htmlstr up to start of next {@docroot}
 268             buf.append(htmlstr.substring(prevEnd, match));
 269             prevEnd = docrootMatcher.end();
 270             if (options.docrootParent().length() &gt; 0 &amp;&amp; htmlstr.startsWith(&quot;/..&quot;, prevEnd)) {
 271                 // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
 272                 buf.append(options.docrootParent());
 273                 prevEnd += 3;
 274             } else {
 275                 // Insert relative path where {@docRoot} was located
 276                 buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
 277             }
 278             // Append slash if next character is not a slash
 279             if (prevEnd &lt; htmlstr.length() &amp;&amp; htmlstr.charAt(prevEnd) != &#39;/&#39;) {
 280                 buf.append(&#39;/&#39;);
 281             }
 282         } while (docrootMatcher.find());
 283         buf.append(htmlstr.substring(prevEnd));
 284         return buf.toString();
 285     }
 286     //where:
 287         // Note: {@docRoot} is not case sensitive when passed in with a command-line option:
 288         private static final Pattern docrootPattern =
 289                 Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
 290 
 291 
 292     /**
 293      * Add method information.
 294      *
 295      * @param method the method to be documented
 296      * @param dl the content tree to which the method information will be added
 297      */
 298     private void addMethodInfo(ExecutableElement method, Content dl) {
 299         TypeElement enclosing = utils.getEnclosingTypeElement(method);
 300         List&lt;? extends TypeMirror&gt; intfacs = enclosing.getInterfaces();
 301         ExecutableElement overriddenMethod = utils.overriddenMethod(method);
 302         VisibleMemberTable vmt = configuration.getVisibleMemberTable(enclosing);
 303         // Check whether there is any implementation or overridden info to be
 304         // printed. If no overridden or implementation info needs to be
 305         // printed, do not print this section.
 306         if ((!intfacs.isEmpty()
 307                 &amp;&amp; vmt.getImplementedMethods(method).isEmpty() == false)
 308                 || overriddenMethod != null) {
 309             MethodWriterImpl.addImplementsInfo(this, method, dl);
 310             if (overriddenMethod != null) {
 311                 MethodWriterImpl.addOverridden(this,
 312                         utils.overriddenType(method),
 313                         overriddenMethod,
 314                         dl);
 315             }
 316         }
 317     }
 318 
 319     /**
 320      * Adds the tags information.
 321      *
 322      * @param e the Element for which the tags will be generated
 323      * @param htmlTree the documentation tree to which the tags will be added
 324      */
 325     protected void addTagsInfo(Element e, Content htmlTree) {
 326         if (options.noComment()) {
 327             return;
 328         }
 329         HtmlTree dl = HtmlTree.DL(HtmlStyle.notes);
 330         if (utils.isExecutableElement(e) &amp;&amp; !utils.isConstructor(e)) {
 331             addMethodInfo((ExecutableElement)e, dl);
 332         }
 333         Content output = new ContentBuilder();
 334         TagletWriter.genTagOutput(configuration.tagletManager, e,
 335             configuration.tagletManager.getBlockTaglets(e),
 336                 getTagletWriterInstance(false), output);
 337         dl.add(output);
 338         htmlTree.add(dl);
 339     }
 340 
 341     /**
 342      * Check whether there are any tags for Serialization Overview
 343      * section to be printed.
 344      *
 345      * @param field the VariableElement object to check for tags.
 346      * @return true if there are tags to be printed else return false.
 347      */
 348     protected boolean hasSerializationOverviewTags(VariableElement field) {
 349         Content output = new ContentBuilder();
 350         TagletWriter.genTagOutput(configuration.tagletManager, field,
 351                 configuration.tagletManager.getBlockTaglets(field),
 352                 getTagletWriterInstance(false), output);
 353         return !output.isEmpty();
 354     }
 355 
 356     /**
 357      * Returns a TagletWriter that knows how to write HTML.
 358      *
 359      * @param isFirstSentence  true if we want to write the first sentence
 360      * @return a TagletWriter that knows how to write HTML.
 361      */
 362     public TagletWriter getTagletWriterInstance(boolean isFirstSentence) {
 363         return new TagletWriterImpl(this, isFirstSentence);
 364     }
 365 
 366     /**
 367      * Returns a TagletWriter that knows how to write HTML.
 368      *
 369      * @param isFirstSentence  true if we want to write the first sentence
 370      * @param inSummary  true if tags are to be added in a summary section
 371      * @return a TagletWriter
 372      */
 373     public TagletWriter getTagletWriterInstance(boolean isFirstSentence, boolean inSummary) {
 374         return new TagletWriterImpl(this, isFirstSentence, inSummary);
 375     }
 376 
 377     /**
 378      * Generates the HTML document tree and prints it out.
 379      *
 380      * @param metakeywords Array of String keywords for META tag. Each element
 381      *                     of the array is assigned to a separate META tag.
 382      *                     Pass in null for no array
 383      * @param description the content for the description META tag.
 384      * @param body the body htmltree to be included in the document
 385      * @throws DocFileIOException if there is a problem writing the file
 386      */
 387     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 388                                   String description,
 389                                   Content body)
 390             throws DocFileIOException {
 391         printHtmlDocument(metakeywords, description, new ContentBuilder(), Collections.emptyList(), body);
 392     }
 393 
 394     /**
 395      * Generates the HTML document tree and prints it out.
 396      *
 397      * @param metakeywords Array of String keywords for META tag. Each element
 398      *                     of the array is assigned to a separate META tag.
 399      *                     Pass in null for no array
 400      * @param description the content for the description META tag.
 401      * @param localStylesheets local stylesheets to be included in the HEAD element
 402      * @param body the body htmltree to be included in the document
 403      * @throws DocFileIOException if there is a problem writing the file
 404      */
 405     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 406                                   String description,
 407                                   List&lt;DocPath&gt; localStylesheets,
 408                                   Content body)
 409             throws DocFileIOException {
 410         printHtmlDocument(metakeywords, description, new ContentBuilder(), localStylesheets, body);
 411     }
 412 
 413     /**
 414      * Generates the HTML document tree and prints it out.
 415      *
 416      * @param metakeywords Array of String keywords for META tag. Each element
 417      *                     of the array is assigned to a separate META tag.
 418      *                     Pass in null for no array
 419      * @param description the content for the description META tag.
 420      * @param extraHeadContent any additional content to be included in the HEAD element
 421      * @param localStylesheets local stylesheets to be included in the HEAD element
 422      * @param body the body htmltree to be included in the document
 423      * @throws DocFileIOException if there is a problem writing the file
 424      */
 425     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 426                                   String description,
 427                                   Content extraHeadContent,
 428                                   List&lt;DocPath&gt; localStylesheets,
 429                                   Content body)
 430             throws DocFileIOException {
 431         Content htmlComment = contents.newPage;
 432         List&lt;DocPath&gt; additionalStylesheets = configuration.getAdditionalStylesheets();
 433         additionalStylesheets.addAll(localStylesheets);
 434         Head head = new Head(path, configuration.docletVersion, configuration.startTime)
 435                 .setTimestamp(!options.noTimestamp())
 436                 .setDescription(description)
 437                 .setGenerator(getGenerator(getClass()))
 438                 .setTitle(winTitle)
 439                 .setCharset(options.charset())
 440                 .addKeywords(metakeywords)
 441                 .setStylesheets(configuration.getMainStylesheet(), additionalStylesheets)
 442                 .setIndex(options.createIndex(), mainBodyScript)
 443                 .addContent(extraHeadContent);
 444 
 445         Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head, body);
 446         HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
 447         htmlDocument.write(DocFile.createFileForOutput(configuration, path));
 448     }
 449 
 450     /**
 451      * Get the window title.
 452      *
 453      * @param title the title string to construct the complete window title
 454      * @return the window title string
 455      */
 456     public String getWindowTitle(String title) {
 457         if (options.windowTitle().length() &gt; 0) {
 458             title += &quot; (&quot; + options.windowTitle() + &quot;)&quot;;
 459         }
 460         return title;
 461     }
 462 
 463     /**
 464      * Get user specified header and the footer.
 465      *
 466      * @param header if true print the user provided header else print the
 467      * user provided footer.
 468      */
 469     public Content getUserHeaderFooter(boolean header) {
 470         String content;
 471         if (header) {
 472             content = replaceDocRootDir(options.header());
 473         } else {
 474             if (options.footer().length() != 0) {
 475                 content = replaceDocRootDir(options.footer());
 476             } else {
 477                 content = replaceDocRootDir(options.header());
 478             }
 479         }
 480         Content rawContent = new RawHtml(content);
 481         return rawContent;
 482     }
 483 
 484     /**
 485      * Adds the user specified top.
 486      *
 487      * @param htmlTree the content tree to which user specified top will be added
 488      */
 489     public void addTop(Content htmlTree) {
 490         Content top = new RawHtml(replaceDocRootDir(options.top()));
 491         htmlTree.add(top);
 492     }
 493 
 494     /**
 495      * Adds the user specified bottom.
 496      *
 497      * @param htmlTree the content tree to which user specified bottom will be added
 498      */
 499     public void addBottom(Content htmlTree) {
 500         Content bottom = new RawHtml(replaceDocRootDir(options.bottom()));
 501         Content small = HtmlTree.SMALL(bottom);
 502         Content p = HtmlTree.P(HtmlStyle.legalCopy, small);
 503         htmlTree.add(p);
 504     }
 505 
 506     /**
 507      * Get the overview tree link for the main tree.
 508      *
 509      * @param label the label for the link
 510      * @return a content tree for the link
 511      */
 512     protected Content getNavLinkMainTree(String label) {
 513         Content mainTreeContent = links.createLink(pathToRoot.resolve(DocPaths.OVERVIEW_TREE),
 514                 new StringContent(label));
 515         Content li = HtmlTree.LI(mainTreeContent);
 516         return li;
 517     }
 518 
 519     /**
 520      * Returns a packagename content.
 521      *
 522      * @param packageElement the package to check
 523      * @return package name content
 524      */
 525     public Content getPackageName(PackageElement packageElement) {
 526         return packageElement == null || packageElement.isUnnamed()
 527                 ? contents.defaultPackageLabel
 528                 : getPackageLabel(packageElement.getQualifiedName());
 529     }
 530 
 531     /**
 532      * Returns a package name label.
 533      *
 534      * @param packageName the package name
 535      * @return the package name content
 536      */
 537     public Content getPackageLabel(CharSequence packageName) {
 538         return new StringContent(packageName);
 539     }
 540 
 541     /**
 542      * Return the path to the class page for a typeElement.
 543      *
 544      * @param te   TypeElement for which the path is requested.
 545      * @param name Name of the file(doesn&#39;t include path).
 546      */
 547     protected DocPath pathString(TypeElement te, DocPath name) {
 548         return pathString(utils.containingPackage(te), name);
 549     }
 550 
 551     /**
 552      * Return path to the given file name in the given package. So if the name
 553      * passed is &quot;Object.html&quot; and the name of the package is &quot;java.lang&quot;, and
 554      * if the relative path is &quot;../..&quot; then returned string will be
 555      * &quot;../../java/lang/Object.html&quot;
 556      *
 557      * @param packageElement Package in which the file name is assumed to be.
 558      * @param name File name, to which path string is.
 559      */
 560     protected DocPath pathString(PackageElement packageElement, DocPath name) {
 561         return pathToRoot.resolve(docPaths.forPackage(packageElement).resolve(name));
 562     }
 563 
 564     /**
 565      * Given a package, return the name to be used in HTML anchor tag.
 566      * @param packageElement the package.
 567      * @return the name to be used in HTML anchor tag.
 568      */
 569     public String getPackageAnchorName(PackageElement packageElement) {
 570         return packageElement == null || packageElement.isUnnamed()
 571                 ? SectionName.UNNAMED_PACKAGE_ANCHOR.getName()
 572                 : utils.getPackageName(packageElement);
 573     }
 574 
 575     /**
 576      * Return the link to the given package.
 577      *
 578      * @param packageElement the package to link to.
 579      * @param label the label for the link.
 580      * @return a content tree for the package link.
 581      */
 582     public Content getPackageLink(PackageElement packageElement, CharSequence label) {
 583         return getPackageLink(packageElement, new StringContent(label));
 584     }
 585 
 586     public Content getPackageLink(PackageElement packageElement) {
 587         StringContent content =  packageElement.isUnnamed()
 588                 ? new StringContent()
 589                 : new StringContent(utils.getPackageName(packageElement));
 590         return getPackageLink(packageElement, content);
 591     }
 592 
 593     /**
 594      * Return the link to the given package.
 595      *
 596      * @param packageElement the package to link to.
 597      * @param label the label for the link.
 598      * @return a content tree for the package link.
 599      */
 600     public Content getPackageLink(PackageElement packageElement, Content label) {
 601         boolean included = packageElement != null &amp;&amp; utils.isIncluded(packageElement);
 602         if (!included) {
 603             for (PackageElement p : configuration.packages) {
 604                 if (p.equals(packageElement)) {
 605                     included = true;
 606                     break;
 607                 }
 608             }
 609         }
 610         if (included || packageElement == null) {
 611             return links.createLink(pathString(packageElement, DocPaths.PACKAGE_SUMMARY),
 612                     label);
 613         } else {
 614             DocLink crossPkgLink = getCrossPackageLink(packageElement);
 615             if (crossPkgLink != null) {
 616                 return links.createLink(crossPkgLink, label);
 617             } else {
 618                 return label;
 619             }
 620         }
 621     }
 622 
 623     /**
 624      * Get Module link.
 625      *
 626      * @param mdle the module being documented
 627      * @param label tag for the link
 628      * @return a content for the module link
 629      */
 630     public Content getModuleLink(ModuleElement mdle, Content label) {
 631         boolean included = utils.isIncluded(mdle);
 632         return (included)
 633                 ? links.createLink(pathToRoot.resolve(docPaths.moduleSummary(mdle)), label, &quot;&quot;, &quot;&quot;)
 634                 : label;
 635     }
 636 
 637     public Content interfaceName(TypeElement typeElement, boolean qual) {
 638         Content name = new StringContent((qual)
 639                 ? typeElement.getQualifiedName()
 640                 : utils.getSimpleName(typeElement));
 641         return (utils.isInterface(typeElement)) ?  HtmlTree.SPAN(HtmlStyle.interfaceName, name) : name;
 642     }
 643 
 644     /**
 645      * Add the link to the content tree.
 646      *
 647      * @param element program element for which the link will be added
 648      * @param label label for the link
 649      * @param htmltree the content tree to which the link will be added
 650      */
 651     public void addSrcLink(Element element, Content label, Content htmltree) {
 652         if (element == null) {
 653             return;
 654         }
 655         TypeElement te = utils.getEnclosingTypeElement(element);
 656         if (te == null) {
 657             // must be a typeElement since in has no containing class.
 658             te = (TypeElement) element;
 659         }
 660         if (utils.isIncluded(te)) {
 661             DocPath href = pathToRoot
 662                     .resolve(DocPaths.SOURCE_OUTPUT)
 663                     .resolve(docPaths.forClass(te));
 664             Content content = links.createLink(href
 665                     .fragment(SourceToHTMLConverter.getAnchorName(utils, element)), label, &quot;&quot;, &quot;&quot;);
 666             htmltree.add(content);
 667         } else {
 668             htmltree.add(label);
 669         }
 670     }
 671 
 672     /**
 673      * Return the link to the given class.
 674      *
 675      * @param linkInfo the information about the link.
 676      *
 677      * @return the link for the given class.
 678      */
 679     public Content getLink(LinkInfoImpl linkInfo) {
 680         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 681         return factory.getLink(linkInfo);
 682     }
 683 
 684     /**
 685      * Return the type parameters for the given class.
 686      *
 687      * @param linkInfo the information about the link.
 688      * @return the type for the given class.
 689      */
 690     public Content getTypeParameterLinks(LinkInfoImpl linkInfo) {
 691         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 692         return factory.getTypeParameterLinks(linkInfo, false);
 693     }
 694 
 695     /*************************************************************
 696      * Return a class cross link to external class documentation.
 697      * The -link option does not allow users to
 698      * link to external classes in the &quot;default&quot; package.
 699      *
 700      * @param classElement the class element
 701      * @param refMemName the name of the member being referenced.  This should
 702      * be null or empty string if no member is being referenced.
 703      * @param label the label for the external link.
 704      * @param strong true if the link should be strong.
 705      * @param code true if the label should be code font.
 706      * @return the link
 707      */
 708     public Content getCrossClassLink(TypeElement classElement, String refMemName,
 709                                     Content label, boolean strong, boolean code) {
 710         if (classElement != null) {
 711             String className = utils.getSimpleName(classElement);
 712             PackageElement packageElement = utils.containingPackage(classElement);
 713             Content defaultLabel = new StringContent(className);
 714             if (code)
 715                 defaultLabel = HtmlTree.CODE(defaultLabel);
 716             if (getCrossPackageLink(packageElement) != null) {
 717                 /*
 718                 The package exists in external documentation, so link to the external
 719                 class (assuming that it exists).  This is definitely a limitation of
 720                 the -link option.  There are ways to determine if an external package
 721                 exists, but no way to determine if the external class exists.  We just
 722                 have to assume that it does.
 723                 */
 724                 DocLink link = configuration.extern.getExternalLink(packageElement, pathToRoot,
 725                                 className + &quot;.html&quot;, refMemName);
 726                 return links.createLink(link,
 727                     (label == null) || label.isEmpty() ? defaultLabel : label,
 728                     strong,
 729                     resources.getText(&quot;doclet.Href_Class_Or_Interface_Title&quot;,
 730                         utils.getPackageName(packageElement)), &quot;&quot;, true);
 731             }
 732         }
 733         return null;
 734     }
 735 
 736     public boolean isClassLinkable(TypeElement typeElement) {
 737         if (utils.isIncluded(typeElement)) {
 738             return configuration.isGeneratedDoc(typeElement);
 739         }
 740         return configuration.extern.isExternal(typeElement);
 741     }
 742 
 743     public DocLink getCrossPackageLink(PackageElement element) {
 744         return configuration.extern.getExternalLink(element, pathToRoot,
 745             DocPaths.PACKAGE_SUMMARY.getPath());
 746     }
 747 
 748     public DocLink getCrossModuleLink(ModuleElement element) {
 749         return configuration.extern.getExternalLink(element, pathToRoot,
 750             docPaths.moduleSummary(utils.getModuleName(element)).getPath());
 751     }
 752 
 753     /**
 754      * Get the class link.
 755      *
 756      * @param context the id of the context where the link will be added
 757      * @param element to link to
 758      * @return a content tree for the link
 759      */
 760     public Content getQualifiedClassLink(LinkInfoImpl.Kind context, Element element) {
 761         LinkInfoImpl linkInfoImpl = new LinkInfoImpl(configuration, context, (TypeElement)element);
 762         return getLink(linkInfoImpl.label(utils.getFullyQualifiedName(element)));
 763     }
 764 
 765     /**
 766      * Add the class link.
 767      *
 768      * @param context the id of the context where the link will be added
 769      * @param typeElement to link to
 770      * @param contentTree the content tree to which the link will be added
 771      */
 772     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 773         addPreQualifiedClassLink(context, typeElement, false, contentTree);
 774     }
 775 
 776     /**
 777      * Retrieve the class link with the package portion of the label in
 778      * plain text.  If the qualifier is excluded, it will not be included in the
 779      * link label.
 780      *
 781      * @param typeElement the class to link to.
 782      * @param isStrong true if the link should be strong.
 783      * @return the link with the package portion of the label in plain text.
 784      */
 785     public Content getPreQualifiedClassLink(LinkInfoImpl.Kind context,
 786             TypeElement typeElement, boolean isStrong) {
 787         ContentBuilder classlink = new ContentBuilder();
 788         PackageElement pkg = utils.containingPackage(typeElement);
 789         if (pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 790             classlink.add(getEnclosingPackageName(typeElement));
 791         }
 792         classlink.add(getLink(new LinkInfoImpl(configuration,
 793                 context, typeElement).label(utils.getSimpleName(typeElement)).strong(isStrong)));
 794         return classlink;
 795     }
 796 
 797     /**
 798      * Add the class link with the package portion of the label in
 799      * plain text. If the qualifier is excluded, it will not be included in the
 800      * link label.
 801      *
 802      * @param context the id of the context where the link will be added
 803      * @param typeElement the class to link to
 804      * @param isStrong true if the link should be strong
 805      * @param contentTree the content tree to which the link with be added
 806      */
 807     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context,
 808             TypeElement typeElement, boolean isStrong, Content contentTree) {
 809         PackageElement pkg = utils.containingPackage(typeElement);
 810         if(pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 811             contentTree.add(getEnclosingPackageName(typeElement));
 812         }
 813         LinkInfoImpl linkinfo = new LinkInfoImpl(configuration, context, typeElement)
 814                 .label(utils.getSimpleName(typeElement))
 815                 .strong(isStrong);
 816         Content link = getLink(linkinfo);
 817         contentTree.add(link);
 818     }
 819 
 820     /**
 821      * Get the enclosed name of the package
 822      *
 823      * @param te  TypeElement
 824      * @return the name
 825      */
 826     public String getEnclosingPackageName(TypeElement te) {
 827 
 828         PackageElement encl = configuration.utils.containingPackage(te);
 829         return (encl.isUnnamed()) ? &quot;&quot; : (encl.getQualifiedName() + &quot;.&quot;);
 830     }
 831 
 832     /**
 833      * Return the main type element of the current page or null for pages that don&#39;t have one.
 834      *
 835      * @return the type element of the current page.
 836      */
 837     protected TypeElement getCurrentPageElement() {
 838         return null;
 839     }
 840 
 841     /**
 842      * Add the class link, with only class name as the strong link and prefixing
 843      * plain package name.
 844      *
 845      * @param context the id of the context where the link will be added
 846      * @param typeElement the class to link to
 847      * @param contentTree the content tree to which the link with be added
 848      */
 849     public void addPreQualifiedStrongClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 850         addPreQualifiedClassLink(context, typeElement, true, contentTree);
 851     }
 852 
 853     /**
 854      * Get the link for the given member.
 855      *
 856      * @param context the id of the context where the link will be added
 857      * @param element the member being linked to
 858      * @param label the label for the link
 859      * @return a content tree for the element link
 860      */
 861     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label) {
 862         return getDocLink(context, utils.getEnclosingTypeElement(element), element,
 863                 new StringContent(label));
 864     }
 865 
 866     /**
 867      * Return the link for the given member.
 868      *
 869      * @param context the id of the context where the link will be printed.
 870      * @param element the member being linked to.
 871      * @param label the label for the link.
 872      * @param strong true if the link should be strong.
 873      * @return the link for the given member.
 874      */
 875     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label,
 876             boolean strong) {
 877         return getDocLink(context, utils.getEnclosingTypeElement(element), element, label, strong);
 878     }
 879 
 880     /**
 881      * Return the link for the given member.
 882      *
 883      * @param context the id of the context where the link will be printed.
 884      * @param typeElement the typeElement that we should link to.  This is not
 885                  necessarily equal to element.containingClass().  We may be
 886                  inheriting comments.
 887      * @param element the member being linked to.
 888      * @param label the label for the link.
 889      * @param strong true if the link should be strong.
 890      * @return the link for the given member.
 891      */
 892     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 893             CharSequence label, boolean strong) {
 894         return getDocLink(context, typeElement, element, label, strong, false);
 895     }
 896 
 897     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 898             Content label, boolean strong) {
 899         return getDocLink(context, typeElement, element, label, strong, false);
 900     }
 901 
 902     /**
 903      * Return the link for the given member.
 904      *
 905      * @param context the id of the context where the link will be printed.
 906      * @param typeElement the typeElement that we should link to.  This is not
 907                  necessarily equal to element.containingClass().  We may be
 908                  inheriting comments.
 909      * @param element the member being linked to.
 910      * @param label the label for the link.
 911      * @param strong true if the link should be strong.
 912      * @param isProperty true if the element parameter is a JavaFX property.
 913      * @return the link for the given member.
 914      */
 915     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 916             CharSequence label, boolean strong, boolean isProperty) {
 917         return getDocLink(context, typeElement, element, new StringContent(label), strong, isProperty);
 918     }
 919 
 920     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 921             Content label, boolean strong, boolean isProperty) {
 922         if (!utils.isLinkable(typeElement, element)) {
 923             return label;
 924         }
 925 
 926         if (utils.isExecutableElement(element)) {
 927             ExecutableElement ee = (ExecutableElement)element;
 928             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 929                 .label(label)
 930                 .where(links.getName(getAnchor(ee, isProperty)))
 931                 .strong(strong));
 932         }
 933 
 934         if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 935             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 936                 .label(label)
 937                 .where(links.getName(element.getSimpleName().toString()))
 938                 .strong(strong));
 939         }
 940 
 941         return label;
 942     }
 943 
 944     /**
 945      * Return the link for the given member.
 946      *
 947      * @param context the id of the context where the link will be added
 948      * @param typeElement the typeElement that we should link to.  This is not
 949                  necessarily equal to element.containingClass().  We may be
 950                  inheriting comments
 951      * @param element the member being linked to
 952      * @param label the label for the link
 953      * @return the link for the given member
 954      */
 955     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 956             Content label) {
 957         if (! (utils.isIncluded(element) || utils.isLinkable(typeElement))) {
 958             return label;
 959         } else if (utils.isExecutableElement(element)) {
 960             ExecutableElement emd = (ExecutableElement) element;
 961             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 962                 .label(label)
 963                 .where(links.getName(getAnchor(emd))));
 964         } else if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 965             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 966                 .label(label).where(links.getName(element.getSimpleName().toString())));
 967         } else {
 968             return label;
 969         }
 970     }
 971 
 972     public String getAnchor(ExecutableElement executableElement) {
 973         return getAnchor(executableElement, false);
 974     }
 975 
 976     public String getAnchor(ExecutableElement executableElement, boolean isProperty) {
 977         if (isProperty) {
 978             return executableElement.getSimpleName().toString();
 979         }
 980         String member = anchorName(executableElement);
 981         String erasedSignature = utils.makeSignature(executableElement, null, true, true);
 982         return member + erasedSignature;
 983     }
 984 
 985     public String anchorName(Element member) {
 986         if (member.getKind() == ElementKind.CONSTRUCTOR) {
 987             return &quot;&lt;init&gt;&quot;;
 988         } else {
 989             return utils.getSimpleName(member);
 990         }
 991     }
 992 
 993     public Content seeTagToContent(Element element, DocTree see) {
 994         Kind kind = see.getKind();
 995         if (!(kind == LINK || kind == SEE || kind == LINK_PLAIN)) {
 996             return new ContentBuilder();
 997         }
 998 
 999         CommentHelper ch = utils.getCommentHelper(element);
1000         String tagName = ch.getTagName(see);
1001         String seetext = replaceDocRootDir(utils.normalizeNewlines(ch.getText(see)).toString());
1002         // Check if @see is an href or &quot;string&quot;
1003         if (seetext.startsWith(&quot;&lt;&quot;) || seetext.startsWith(&quot;\&quot;&quot;)) {
1004             return new RawHtml(seetext);
1005         }
1006         boolean isLinkPlain = kind == LINK_PLAIN;
1007         Content label = plainOrCode(isLinkPlain, new RawHtml(ch.getLabel(see)));
1008 
1009         //The text from the @see tag.  We will output this text when a label is not specified.
1010         Content text = plainOrCode(kind == LINK_PLAIN, new RawHtml(seetext));
1011 
1012         TypeElement refClass = ch.getReferencedClass(see);
1013         String refClassName =  ch.getReferencedClassName(see);
1014         Element refMem =       ch.getReferencedMember(see);
1015         String refMemName =    ch.getReferencedMemberName(see);
1016 
1017         if (refMemName == null &amp;&amp; refMem != null) {
1018             refMemName = refMem.toString();
1019         }
1020         if (refClass == null) {
1021             //@see is not referencing an included class
1022             PackageElement refPackage = ch.getReferencedPackage(see);
1023             if (refPackage != null &amp;&amp; utils.isIncluded(refPackage)) {
1024                 //@see is referencing an included package
1025                 if (label.isEmpty())
1026                     label = plainOrCode(isLinkPlain,
1027                             new StringContent(refPackage.getQualifiedName()));
1028                 return getPackageLink(refPackage, label);
1029             } else {
1030                 // @see is not referencing an included class, module or package. Check for cross links.
1031                 DocLink elementCrossLink = (configuration.extern.isModule(refClassName))
1032                         ? getCrossModuleLink(utils.elementUtils.getModuleElement(refClassName)) :
1033                         (refPackage != null) ? getCrossPackageLink(refPackage) : null;
1034                 if (elementCrossLink != null) {
1035                     // Element cross link found
1036                     return links.createLink(elementCrossLink,
1037                             (label.isEmpty() ? text : label), true);
1038                 } else {
1039                     // No cross link found so print warning
1040                     messages.warning(ch.getDocTreePath(see),
1041                             &quot;doclet.see.class_or_package_not_found&quot;,
1042                             &quot;@&quot; + tagName,
1043                             seetext);
1044                     return (label.isEmpty() ? text: label);
1045                 }
1046             }
1047         } else if (refMemName == null) {
1048             // Must be a class reference since refClass is not null and refMemName is null.
1049             if (label.isEmpty()) {
<a name="1" id="anc1"></a><span class="line-modified">1050                 if (!refClass.getTypeParameters().isEmpty() &amp;&amp; seetext.contains(&quot;&lt;&quot;)) {</span>
<span class="line-modified">1051                     // If this is a generic type link try to use the TypeMirror representation.</span>
<span class="line-modified">1052                     TypeMirror refType = ch.getReferencedType(see);</span>
<span class="line-modified">1053                     if (refType != null) {</span>
<span class="line-modified">1054                         return plainOrCode(isLinkPlain, getLink(</span>
<span class="line-modified">1055                                 new LinkInfoImpl(configuration, LinkInfoImpl.Kind.DEFAULT, refType)));</span>
<span class="line-modified">1056                     }</span>




1057                 }
<a name="2" id="anc2"></a><span class="line-modified">1058                 label = plainOrCode(isLinkPlain, new StringContent(utils.getSimpleName(refClass)));</span>
1059             }
1060             return getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.DEFAULT, refClass)
1061                     .label(label));
1062         } else if (refMem == null) {
1063             // Must be a member reference since refClass is not null and refMemName is not null.
1064             // However, refMem is null, so this referenced member does not exist.
1065             return (label.isEmpty() ? text: label);
1066         } else {
1067             // Must be a member reference since refClass is not null and refMemName is not null.
1068             // refMem is not null, so this @see tag must be referencing a valid member.
1069             TypeElement containing = utils.getEnclosingTypeElement(refMem);
1070 
1071             // Find the enclosing type where the method is actually visible
1072             // in the inheritance hierarchy.
1073             ExecutableElement overriddenMethod = null;
1074             if (refMem.getKind() == ElementKind.METHOD) {
1075                 VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);
1076                 overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);
1077 
1078                 if (overriddenMethod != null)
1079                     containing = utils.getEnclosingTypeElement(overriddenMethod);
1080             }
1081             if (ch.getText(see).trim().startsWith(&quot;#&quot;) &amp;&amp;
1082                 ! (utils.isPublic(containing) || utils.isLinkable(containing))) {
1083                 // Since the link is relative and the holder is not even being
1084                 // documented, this must be an inherited link.  Redirect it.
1085                 // The current class either overrides the referenced member or
1086                 // inherits it automatically.
1087                 if (this instanceof ClassWriterImpl) {
1088                     containing = ((ClassWriterImpl) this).getTypeElement();
1089                 } else if (!utils.isPublic(containing)) {
1090                     messages.warning(
1091                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_accessible&quot;,
1092                         tagName, utils.getFullyQualifiedName(containing));
1093                 } else {
1094                     messages.warning(
1095                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_found&quot;,
1096                         tagName, seetext);
1097                 }
1098             }
1099             if (configuration.currentTypeElement != containing) {
1100                 refMemName = (utils.isConstructor(refMem))
1101                         ? refMemName
1102                         : utils.getSimpleName(containing) + &quot;.&quot; + refMemName;
1103             }
1104             if (utils.isExecutableElement(refMem)) {
1105                 if (refMemName.indexOf(&#39;(&#39;) &lt; 0) {
1106                     refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);
1107                 }
1108                 if (overriddenMethod != null) {
1109                     // The method to actually link.
1110                     refMem = overriddenMethod;
1111                 }
1112             }
1113 
1114             text = plainOrCode(kind == LINK_PLAIN, new StringContent(refMemName));
1115 
1116             return getDocLink(LinkInfoImpl.Kind.SEE_TAG, containing,
1117                     refMem, (label.isEmpty() ? text: label), false);
1118         }
1119     }
1120 
1121     private Content plainOrCode(boolean plain, Content body) {
1122         return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);
1123     }
1124 
1125     /**
1126      * Add the inline comment.
1127      *
1128      * @param element the Element for which the inline comment will be added
1129      * @param tag the inline tag to be added
1130      * @param htmltree the content tree to which the comment will be added
1131      */
1132     public void addInlineComment(Element element, DocTree tag, Content htmltree) {
1133         CommentHelper ch = utils.getCommentHelper(element);
1134         List&lt;? extends DocTree&gt; description = ch.getDescription(tag);
1135         addCommentTags(element, tag, description, false, false, false, htmltree);
1136     }
1137 
1138     /**
1139      * Get the deprecated phrase as content.
1140      *
1141      * @param e the Element for which the inline deprecated comment will be added
1142      * @return a content tree for the deprecated phrase.
1143      */
1144     public Content getDeprecatedPhrase(Element e) {
1145         return (utils.isDeprecatedForRemoval(e))
1146                 ? contents.deprecatedForRemovalPhrase
1147                 : contents.deprecatedPhrase;
1148     }
1149 
1150     /**
1151      * Add the inline deprecated comment.
1152      *
1153      * @param e the Element for which the inline deprecated comment will be added
1154      * @param tag the inline tag to be added
1155      * @param htmltree the content tree to which the comment will be added
1156      */
1157     public void addInlineDeprecatedComment(Element e, DocTree tag, Content htmltree) {
1158         CommentHelper ch = utils.getCommentHelper(e);
1159         addCommentTags(e, ch.getBody(tag), true, false, false, htmltree);
1160     }
1161 
1162     /**
1163      * Adds the summary content.
1164      *
1165      * @param element the Element for which the summary will be generated
1166      * @param htmltree the documentation tree to which the summary will be added
1167      */
1168     public void addSummaryComment(Element element, Content htmltree) {
1169         addSummaryComment(element, utils.getFirstSentenceTrees(element), htmltree);
1170     }
1171 
1172     /**
1173      * Adds the summary content.
1174      *
1175      * @param element the Element for which the summary will be generated
1176      * @param firstSentenceTags the first sentence tags for the doc
1177      * @param htmltree the documentation tree to which the summary will be added
1178      */
1179     public void addSummaryComment(Element element, List&lt;? extends DocTree&gt; firstSentenceTags, Content htmltree) {
1180         addCommentTags(element, firstSentenceTags, false, true, true, htmltree);
1181     }
1182 
1183     public void addSummaryDeprecatedComment(Element element, DocTree tag, Content htmltree) {
1184         CommentHelper ch = utils.getCommentHelper(element);
1185         List&lt;? extends DocTree&gt; body = ch.getBody(tag);
1186         addCommentTags(element, ch.getFirstSentenceTrees(body), true, true, true, htmltree);
1187     }
1188 
1189     /**
1190      * Adds the inline comment.
1191      *
1192      * @param element the Element for which the inline comments will be generated
1193      * @param htmltree the documentation tree to which the inline comments will be added
1194      */
1195     public void addInlineComment(Element element, Content htmltree) {
1196         addCommentTags(element, utils.getFullBody(element), false, false, false, htmltree);
1197     }
1198 
1199     /**
1200      * Adds the comment tags.
1201      *
1202      * @param element the Element for which the comment tags will be generated
1203      * @param tags the first sentence tags for the doc
1204      * @param depr true if it is deprecated
1205      * @param first true if the first sentence tags should be added
1206      * @param inSummary true if the comment tags are added into the summary section
1207      * @param htmltree the documentation tree to which the comment tags will be added
1208      */
1209     private void addCommentTags(Element element, List&lt;? extends DocTree&gt; tags, boolean depr,
1210             boolean first, boolean inSummary, Content htmltree) {
1211         addCommentTags(element, null, tags, depr, first, inSummary, htmltree);
1212     }
1213 
1214     /**
1215      * Adds the comment tags.
1216      *
1217      * @param element for which the comment tags will be generated
1218      * @param holderTag the block tag context for the inline tags
1219      * @param tags the first sentence tags for the doc
1220      * @param depr true if it is deprecated
1221      * @param first true if the first sentence tags should be added
1222      * @param inSummary true if the comment tags are added into the summary section
1223      * @param htmltree the documentation tree to which the comment tags will be added
1224      */
1225     private void addCommentTags(Element element, DocTree holderTag, List&lt;? extends DocTree&gt; tags, boolean depr,
1226             boolean first, boolean inSummary, Content htmltree) {
1227         if (options.noComment()){
1228             return;
1229         }
1230         Content div;
1231         Content result = commentTagsToContent(null, element, tags, first, inSummary);
1232         if (depr) {
1233             div = HtmlTree.DIV(HtmlStyle.deprecationComment, result);
1234             htmltree.add(div);
1235         }
1236         else {
1237             div = HtmlTree.DIV(HtmlStyle.block, result);
1238             htmltree.add(div);
1239         }
1240         if (tags.isEmpty()) {
1241             htmltree.add(Entity.NO_BREAK_SPACE);
1242         }
1243     }
1244 
1245     boolean ignoreNonInlineTag(DocTree dtree) {
1246         Name name = null;
1247         if (dtree.getKind() == Kind.START_ELEMENT) {
1248             StartElementTree setree = (StartElementTree)dtree;
1249             name = setree.getName();
1250         } else if (dtree.getKind() == Kind.END_ELEMENT) {
1251             EndElementTree eetree = (EndElementTree)dtree;
1252             name = eetree.getName();
1253         }
1254 
1255         if (name != null) {
1256             com.sun.tools.doclint.HtmlTag htmlTag = com.sun.tools.doclint.HtmlTag.get(name);
1257             if (htmlTag != null &amp;&amp;
1258                     htmlTag.blockType != com.sun.tools.doclint.HtmlTag.BlockType.INLINE) {
1259                 return true;
1260             }
1261         }
1262         return false;
1263     }
1264 
1265     boolean isAllWhiteSpace(String body) {
1266         for (int i = 0 ; i &lt; body.length(); i++) {
1267             if (!Character.isWhitespace(body.charAt(i)))
1268                 return false;
1269         }
1270         return true;
1271     }
1272 
1273     // Notify the next DocTree handler to take necessary action
1274     private boolean commentRemoved = false;
1275 
1276     /**
1277      * Converts inline tags and text to Content, expanding the
1278      * inline tags along the way.  Called wherever text can contain
1279      * an inline tag, such as in comments or in free-form text arguments
1280      * to block tags.
1281      *
1282      * @param holderTag    specific tag where comment resides
1283      * @param element    specific element where comment resides
1284      * @param tags   array of text tags and inline tags (often alternating)
1285                present in the text of interest for this element
1286      * @param isFirstSentence  true if text is first sentence
1287      * @return a Content object
1288      */
1289     public Content commentTagsToContent(DocTree holderTag,
1290                                         Element element,
1291                                         List&lt;? extends DocTree&gt; tags,
1292                                         boolean isFirstSentence)
1293     {
1294         return commentTagsToContent(holderTag, element, tags, isFirstSentence, false);
1295     }
1296 
1297     /**
1298      * Converts inline tags and text to text strings, expanding the
1299      * inline tags along the way.  Called wherever text can contain
1300      * an inline tag, such as in comments or in free-form text arguments
1301      * to block tags.
1302      *
1303      * @param holderTag       specific tag where comment resides
1304      * @param element         specific element where comment resides
1305      * @param trees           array of text tags and inline tags (often alternating)
1306      *                        present in the text of interest for this element
1307      * @param isFirstSentence true if text is first sentence
1308      * @param inSummary       if the comment tags are added into the summary section
1309      * @return a Content object
1310      */
1311     public Content commentTagsToContent(DocTree holderTag,
1312                                         Element element,
1313                                         List&lt;? extends DocTree&gt; trees,
1314                                         boolean isFirstSentence,
1315                                         boolean inSummary)
1316     {
1317         final Content result = new ContentBuilder() {
1318             @Override
1319             public ContentBuilder add(CharSequence text) {
1320                 return super.add(utils.normalizeNewlines(text));
1321             }
1322         };
1323         CommentHelper ch = utils.getCommentHelper(element);
1324         // Array of all possible inline tags for this javadoc run
1325         configuration.tagletManager.checkTags(element, trees, true);
1326         commentRemoved = false;
1327 
1328         for (ListIterator&lt;? extends DocTree&gt; iterator = trees.listIterator(); iterator.hasNext();) {
1329             boolean isFirstNode = !iterator.hasPrevious();
1330             DocTree tag = iterator.next();
1331             boolean isLastNode  = !iterator.hasNext();
1332 
1333             if (isFirstSentence) {
1334                 // Ignore block tags
1335                 if (ignoreNonInlineTag(tag))
1336                     continue;
1337 
1338                 // Ignore any trailing whitespace OR whitespace after removed html comment
1339                 if ((isLastNode || commentRemoved)
1340                         &amp;&amp; tag.getKind() == TEXT
1341                         &amp;&amp; isAllWhiteSpace(ch.getText(tag)))
1342                     continue;
1343 
1344                 // Ignore any leading html comments
1345                 if ((isFirstNode || commentRemoved) &amp;&amp; tag.getKind() == COMMENT) {
1346                     commentRemoved = true;
1347                     continue;
1348                 }
1349             }
1350 
1351             boolean allDone = new SimpleDocTreeVisitor&lt;Boolean, Content&gt;() {
1352 
1353                 private boolean inAnAtag() {
1354                     if (utils.isStartElement(tag)) {
1355                         StartElementTree st = (StartElementTree)tag;
1356                         Name name = st.getName();
1357                         if (name != null) {
1358                             com.sun.tools.doclint.HtmlTag htag =
1359                                     com.sun.tools.doclint.HtmlTag.get(name);
1360                             return htag != null &amp;&amp; htag.equals(com.sun.tools.doclint.HtmlTag.A);
1361                         }
1362                     }
1363                     return false;
1364                 }
1365 
1366                 @Override
1367                 public Boolean visitAttribute(AttributeTree node, Content c) {
1368                     StringBuilder sb = new StringBuilder(SPACER).append(node.getName());
1369                     if (node.getValueKind() == ValueKind.EMPTY) {
1370                         result.add(sb);
1371                         return false;
1372                     }
1373                     sb.append(&quot;=&quot;);
1374                     String quote;
1375                     switch (node.getValueKind()) {
1376                         case DOUBLE:
1377                             quote = &quot;\&quot;&quot;;
1378                             break;
1379                         case SINGLE:
1380                             quote = &quot;&#39;&quot;;
1381                             break;
1382                         default:
1383                             quote = &quot;&quot;;
1384                             break;
1385                     }
1386                     sb.append(quote);
1387                     result.add(sb);
1388                     Content docRootContent = new ContentBuilder();
1389 
1390                     boolean isHRef = inAnAtag() &amp;&amp; node.getName().toString().equalsIgnoreCase(&quot;href&quot;);
1391                     for (DocTree dt : node.getValue()) {
1392                         if (utils.isText(dt) &amp;&amp; isHRef) {
1393                             String text = ((TextTree) dt).getBody();
1394                             if (text.startsWith(&quot;/..&quot;) &amp;&amp; !options.docrootParent().isEmpty()) {
1395                                 result.add(options.docrootParent());
1396                                 docRootContent = new ContentBuilder();
1397                                 result.add(textCleanup(text.substring(3), isLastNode));
1398                             } else {
1399                                 if (!docRootContent.isEmpty()) {
1400                                     docRootContent = copyDocRootContent(docRootContent);
1401                                 } else {
1402                                     text = redirectRelativeLinks(element, (TextTree) dt);
1403                                 }
1404                                 result.add(textCleanup(text, isLastNode));
1405                             }
1406                         } else {
1407                             docRootContent = copyDocRootContent(docRootContent);
1408                             dt.accept(this, docRootContent);
1409                         }
1410                     }
1411                     copyDocRootContent(docRootContent);
1412                     result.add(quote);
1413                     return false;
1414                 }
1415 
1416                 @Override
1417                 public Boolean visitComment(CommentTree node, Content c) {
1418                     result.add(new RawHtml(node.getBody()));
1419                     return false;
1420                 }
1421 
1422                 private Content copyDocRootContent(Content content) {
1423                     if (!content.isEmpty()) {
1424                         result.add(content);
1425                         return new ContentBuilder();
1426                     }
1427                     return content;
1428                 }
1429 
1430                 @Override
1431                 public Boolean visitDocRoot(DocRootTree node, Content c) {
1432                     Content docRootContent = TagletWriter.getInlineTagOutput(element,
1433                             configuration.tagletManager,
1434                             holderTag,
1435                             node,
1436                             getTagletWriterInstance(isFirstSentence));
1437                     if (c != null) {
1438                         c.add(docRootContent);
1439                     } else {
1440                         result.add(docRootContent);
1441                     }
1442                     return false;
1443                 }
1444 
1445                 @Override
1446                 public Boolean visitEndElement(EndElementTree node, Content c) {
1447                     RawHtml rawHtml = new RawHtml(&quot;&lt;/&quot; + node.getName() + &quot;&gt;&quot;);
1448                     result.add(rawHtml);
1449                     return false;
1450                 }
1451 
1452                 @Override
1453                 public Boolean visitEntity(EntityTree node, Content c) {
1454                     result.add(new RawHtml(node.toString()));
1455                     return false;
1456                 }
1457 
1458                 @Override
1459                 public Boolean visitErroneous(ErroneousTree node, Content c) {
1460                     messages.warning(ch.getDocTreePath(node),
1461                             &quot;doclet.tag.invalid_usage&quot;, node);
1462                     result.add(new RawHtml(node.toString()));
1463                     return false;
1464                 }
1465 
1466                 @Override
1467                 public Boolean visitInheritDoc(InheritDocTree node, Content c) {
1468                     Content output = TagletWriter.getInlineTagOutput(element,
1469                             configuration.tagletManager, holderTag,
1470                             tag, getTagletWriterInstance(isFirstSentence));
1471                     result.add(output);
1472                     // if we obtained the first sentence successfully, nothing more to do
1473                     return (isFirstSentence &amp;&amp; !output.isEmpty());
1474                 }
1475 
1476                 @Override
1477                 public Boolean visitIndex(IndexTree node, Content p) {
1478                     Content output = TagletWriter.getInlineTagOutput(element,
1479                             configuration.tagletManager, holderTag, tag,
1480                             getTagletWriterInstance(isFirstSentence, inSummary));
1481                     if (output != null) {
1482                         result.add(output);
1483                     }
1484                     return false;
1485                 }
1486 
1487                 @Override
1488                 public Boolean visitLink(LinkTree node, Content c) {
1489                     // we need to pass the DocTreeImpl here, so ignore node
1490                     Content content = seeTagToContent(element, tag);
1491                     result.add(content);
1492                     return false;
1493                 }
1494 
1495                 @Override
1496                 public Boolean visitLiteral(LiteralTree node, Content c) {
1497                     String s = node.getBody().getBody();
1498                     Content content = new StringContent(utils.normalizeNewlines(s));
1499                     if (node.getKind() == CODE)
1500                         content = HtmlTree.CODE(content);
1501                     result.add(content);
1502                     return false;
1503                 }
1504 
1505                 @Override
1506                 public Boolean visitSee(SeeTree node, Content c) {
1507                     // we need to pass the DocTreeImpl here, so ignore node
1508                     result.add(seeTagToContent(element, tag));
1509                     return false;
1510                 }
1511 
1512                 @Override
1513                 public Boolean visitStartElement(StartElementTree node, Content c) {
1514                     String text = &quot;&lt;&quot; + node.getName();
1515                     RawHtml rawHtml = new RawHtml(utils.normalizeNewlines(text));
1516                     result.add(rawHtml);
1517 
1518                     for (DocTree dt : node.getAttributes()) {
1519                         dt.accept(this, null);
1520                     }
1521                     result.add(new RawHtml(node.isSelfClosing() ? &quot;/&gt;&quot; : &quot;&gt;&quot;));
1522                     return false;
1523                 }
1524 
1525                 @Override
1526                 public Boolean visitSummary(SummaryTree node, Content c) {
1527                     Content output = TagletWriter.getInlineTagOutput(element,
1528                             configuration.tagletManager, holderTag, tag,
1529                             getTagletWriterInstance(isFirstSentence));
1530                     result.add(output);
1531                     return false;
1532                 }
1533 
1534                 @Override
1535                 public Boolean visitSystemProperty(SystemPropertyTree node, Content p) {
1536                     Content output = TagletWriter.getInlineTagOutput(element,
1537                             configuration.tagletManager, holderTag, tag,
1538                             getTagletWriterInstance(isFirstSentence, inSummary));
1539                     if (output != null) {
1540                         result.add(output);
1541                     }
1542                     return false;
1543                 }
1544 
1545                 private CharSequence textCleanup(String text, boolean isLast) {
1546                     return textCleanup(text, isLast, false);
1547                 }
1548 
1549                 private CharSequence textCleanup(String text, boolean isLast, boolean stripLeading) {
1550                     boolean stripTrailing = isFirstSentence &amp;&amp; isLast;
1551                     if (stripLeading &amp;&amp; stripTrailing) {
1552                         text = text.strip();
1553                     } else if (stripLeading) {
1554                         text = text.stripLeading();
1555                     } else if (stripTrailing) {
1556                         text = text.stripTrailing();
1557                     }
1558                     text = utils.replaceTabs(text);
1559                     return utils.normalizeNewlines(text);
1560                 }
1561 
1562                 @Override
1563                 public Boolean visitText(TextTree node, Content c) {
1564                     String text = node.getBody();
1565                     result.add(new RawHtml(textCleanup(text, isLastNode, commentRemoved)));
1566                     return false;
1567                 }
1568 
1569                 @Override
1570                 protected Boolean defaultAction(DocTree node, Content c) {
1571                     Content output = TagletWriter.getInlineTagOutput(element,
1572                             configuration.tagletManager, holderTag, tag,
1573                             getTagletWriterInstance(isFirstSentence));
1574                     if (output != null) {
1575                         result.add(output);
1576                     }
1577                     return false;
1578                 }
1579 
1580             }.visit(tag, null);
1581             commentRemoved = false;
1582             if (allDone)
1583                 break;
1584         }
1585         return result;
1586     }
1587 
1588     /**
1589      * Return true if relative links should not be redirected.
1590      *
1591      * @return Return true if a relative link should not be redirected.
1592      */
1593     private boolean shouldNotRedirectRelativeLinks() {
1594         return  this instanceof ClassWriter ||
1595                 this instanceof PackageSummaryWriter;
1596     }
1597 
1598     /**
1599      * Suppose a piece of documentation has a relative link.  When you copy
1600      * that documentation to another place such as the index or class-use page,
1601      * that relative link will no longer work.  We should redirect those links
1602      * so that they will work again.
1603      * &lt;p&gt;
1604      * Here is the algorithm used to fix the link:
1605      * &lt;p&gt;
1606      * {@literal &lt;relative link&gt; =&gt; docRoot + &lt;relative path to file&gt; + &lt;relative link&gt; }
1607      * &lt;p&gt;
1608      * For example, suppose DocletEnvironment has this link:
1609      * {@literal &lt;a href=&quot;package-summary.html&quot;&gt;The package Page&lt;/a&gt; }
1610      * &lt;p&gt;
1611      * If this link appeared in the index, we would redirect
1612      * the link like this:
1613      *
1614      * {@literal &lt;a href=&quot;./jdk/javadoc/doclet/package-summary.html&quot;&gt;The package Page&lt;/a&gt;}
1615      *
1616      * @param element the Element object whose documentation is being written.
1617      * @param tt the text being written.
1618      *
1619      * @return the text, with all the relative links redirected to work.
1620      */
1621     @SuppressWarnings(&quot;preview&quot;)
1622     private String redirectRelativeLinks(Element element, TextTree tt) {
1623         String text = tt.getBody();
1624         if (element == null || utils.isOverviewElement(element) || shouldNotRedirectRelativeLinks()) {
1625             return text;
1626         }
1627 
1628         DocPath redirectPathFromRoot = new SimpleElementVisitor14&lt;DocPath, Void&gt;() {
1629             @Override
1630             public DocPath visitType(TypeElement e, Void p) {
1631                 return docPaths.forPackage(utils.containingPackage(e));
1632             }
1633 
1634             @Override
1635             public DocPath visitPackage(PackageElement e, Void p) {
1636                 return docPaths.forPackage(e);
1637             }
1638 
1639             @Override
1640             public DocPath visitVariable(VariableElement e, Void p) {
1641                 return docPaths.forPackage(utils.containingPackage(e));
1642             }
1643 
1644             @Override
1645             public DocPath visitExecutable(ExecutableElement e, Void p) {
1646                 return docPaths.forPackage(utils.containingPackage(e));
1647             }
1648 
1649             @Override
1650             protected DocPath defaultAction(Element e, Void p) {
1651                 return null;
1652             }
1653         }.visit(element);
1654         if (redirectPathFromRoot == null) {
1655             return text;
1656         }
1657         String lower = Utils.toLowerCase(text);
1658         if (!(lower.startsWith(&quot;mailto:&quot;)
1659                 || lower.startsWith(&quot;http:&quot;)
1660                 || lower.startsWith(&quot;https:&quot;)
1661                 || lower.startsWith(&quot;file:&quot;))) {
1662             text = &quot;{@&quot; + (new DocRootTaglet()).getName() + &quot;}/&quot;
1663                     + redirectPathFromRoot.resolve(text).getPath();
1664             text = replaceDocRootDir(text);
1665         }
1666         return text;
1667     }
1668 
1669     /**
1670      * According to
1671      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
1672      * all the outer classes and static nested classes are core classes.
1673      */
1674     public boolean isCoreClass(TypeElement typeElement) {
1675         return utils.getEnclosingTypeElement(typeElement) == null || utils.isStatic(typeElement);
1676     }
1677 
1678     /**
1679      * Adds the annotation types for the given packageElement.
1680      *
1681      * @param packageElement the package to write annotations for.
1682      * @param htmltree the documentation tree to which the annotation info will be
1683      *        added
1684      */
1685     public void addAnnotationInfo(PackageElement packageElement, Content htmltree) {
1686         addAnnotationInfo(packageElement.getAnnotationMirrors(), htmltree);
1687     }
1688 
1689     /*
1690      * this is a hack to delay dealing with Annotations in the writers, the assumption
1691      * is that all necessary checks have been made to get here.
1692      */
1693     public void addReceiverAnnotationInfo(ExecutableElement method, TypeMirror rcvrTypeMirror,
1694             List&lt;? extends AnnotationMirror&gt; annotationMirrors, Content htmltree) {
1695         TypeMirror rcvrType = method.getReceiverType();
1696         List&lt;? extends AnnotationMirror&gt; annotationMirrors1 = rcvrType.getAnnotationMirrors();
1697         htmltree.add(getAnnotationInfo(annotationMirrors1, false));
1698     }
1699 
1700     /**
1701      * Adds the annotation types for the given element.
1702      *
1703      * @param element the package to write annotations for
1704      * @param htmltree the content tree to which the annotation types will be added
1705      */
1706     public void addAnnotationInfo(Element element, Content htmltree) {
1707         addAnnotationInfo(element.getAnnotationMirrors(), htmltree);
1708     }
1709 
1710     /**
1711      * Add the annotation types for the given element and parameter.
1712      *
1713      * @param param the parameter to write annotations for.
1714      * @param tree the content tree to which the annotation types will be added
1715      */
1716     public boolean addAnnotationInfo(VariableElement param, Content tree) {
1717         Content annotationInfo = getAnnotationInfo(param.getAnnotationMirrors(), false);
1718         if (annotationInfo.isEmpty()) {
1719             return false;
1720         }
1721         tree.add(annotationInfo);
1722         return true;
1723     }
1724 
1725     /**
1726      * Adds the annotation types for the given Element.
1727      *
1728      * @param descList a list of annotation mirrors.
1729      * @param htmltree the documentation tree to which the annotation info will be
1730      *        added
1731      */
1732     private void addAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, Content htmltree) {
1733         htmltree.add(getAnnotationInfo(descList, true));
1734     }
1735 
1736     /**
1737      * Return a content tree containing the annotation types for the given element.
1738      *
1739      * @param descList a list of annotation mirrors.
1740      * @return the documentation tree containing the annotation info.
1741      */
1742     Content getAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, boolean lineBreak) {
1743         List&lt;Content&gt; annotations = getAnnotations(descList, lineBreak);
1744         String sep = &quot;&quot;;
1745         ContentBuilder builder = new ContentBuilder();
1746         for (Content annotation: annotations) {
1747             builder.add(sep);
1748             builder.add(annotation);
1749             if (!lineBreak) {
1750                 sep = &quot; &quot;;
1751             }
1752         }
1753         return builder;
1754     }
1755 
1756     /**
1757      * Return the string representations of the annotation types for
1758      * the given doc.
1759      *
1760      * @param descList a list of annotation mirrors.
1761      * @param linkBreak if true, add new line between each member value.
1762      * @return a list of strings representing the annotations being
1763      *         documented.
1764      */
1765     public List&lt;Content&gt; getAnnotations(List&lt;? extends AnnotationMirror&gt; descList, boolean linkBreak) {
1766         List&lt;Content&gt; results = new ArrayList&lt;&gt;();
1767         ContentBuilder annotation;
1768         for (AnnotationMirror aDesc : descList) {
1769             TypeElement annotationElement = (TypeElement)aDesc.getAnnotationType().asElement();
1770             // If an annotation is not documented, do not add it to the list. If
1771             // the annotation is of a repeatable type, and if it is not documented
1772             // and also if its container annotation is not documented, do not add it
1773             // to the list. If an annotation of a repeatable type is not documented
1774             // but its container is documented, it will be added to the list.
1775             if (!utils.isDocumentedAnnotation(annotationElement) &amp;&amp;
1776                 (!isAnnotationDocumented &amp;&amp; !isContainerDocumented)) {
1777                 continue;
1778             }
1779             annotation = new ContentBuilder();
1780             isAnnotationDocumented = false;
1781             LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
1782                                                      LinkInfoImpl.Kind.ANNOTATION, annotationElement);
1783             Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = aDesc.getElementValues();
1784             // If the annotation is synthesized, do not print the container.
1785             if (utils.configuration.workArounds.isSynthesized(aDesc)) {
1786                 for (ExecutableElement ee : pairs.keySet()) {
1787                     AnnotationValue annotationValue = pairs.get(ee);
1788                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1789 
1790                     new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1791                         @Override
1792                         public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; p) {
1793                             p.addAll(vals);
1794                             return null;
1795                         }
1796 
1797                         @Override
1798                         protected Void defaultAction(Object o, List&lt;AnnotationValue&gt; p) {
1799                             p.add(annotationValue);
1800                             return null;
1801                         }
1802                     }.visit(annotationValue, annotationTypeValues);
1803 
1804                     String sep = &quot;&quot;;
1805                     for (AnnotationValue av : annotationTypeValues) {
1806                         annotation.add(sep);
1807                         annotation.add(annotationValueToContent(av));
1808                         sep = &quot; &quot;;
1809                     }
1810                 }
1811             } else if (isAnnotationArray(pairs)) {
1812                 // If the container has 1 or more value defined and if the
1813                 // repeatable type annotation is not documented, do not print
1814                 // the container.
1815                 if (pairs.size() == 1 &amp;&amp; isAnnotationDocumented) {
1816                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1817                     for (AnnotationValue a :  pairs.values()) {
1818                         new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1819                             @Override
1820                             public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; annotationTypeValues) {
1821                                annotationTypeValues.addAll(vals);
1822                                return null;
1823                             }
1824                         }.visit(a, annotationTypeValues);
1825                     }
1826                     String sep = &quot;&quot;;
1827                     for (AnnotationValue av : annotationTypeValues) {
1828                         annotation.add(sep);
1829                         annotation.add(annotationValueToContent(av));
1830                         sep = &quot; &quot;;
1831                     }
1832                 }
1833                 // If the container has 1 or more value defined and if the
1834                 // repeatable type annotation is not documented, print the container.
1835                 else {
1836                     addAnnotations(annotationElement, linkInfo, annotation, pairs, false);
1837                 }
1838             }
1839             else {
1840                 addAnnotations(annotationElement, linkInfo, annotation, pairs, linkBreak);
1841             }
1842             annotation.add(linkBreak ? DocletConstants.NL : &quot;&quot;);
1843             results.add(annotation);
1844         }
1845         return results;
1846     }
1847 
1848     /**
1849      * Add annotation to the annotation string.
1850      *
1851      * @param annotationDoc the annotation being documented
1852      * @param linkInfo the information about the link
1853      * @param annotation the annotation string to which the annotation will be added
1854      * @param map annotation type element to annotation value pairs
1855      * @param linkBreak if true, add new line between each member value
1856      */
1857     private void addAnnotations(TypeElement annotationDoc, LinkInfoImpl linkInfo,
1858                                 ContentBuilder annotation,
1859                                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; map,
1860                                 boolean linkBreak) {
1861         linkInfo.label = new StringContent(&quot;@&quot;);
1862         linkInfo.label.add(annotationDoc.getSimpleName());
1863         annotation.add(getLink(linkInfo));
1864         if (!map.isEmpty()) {
1865             annotation.add(&quot;(&quot;);
1866             boolean isFirst = true;
1867             Set&lt;? extends ExecutableElement&gt; keys = map.keySet();
1868             boolean multipleValues = keys.size() &gt; 1;
1869             for (ExecutableElement element : keys) {
1870                 if (isFirst) {
1871                     isFirst = false;
1872                 } else {
1873                     annotation.add(&quot;,&quot;);
1874                     if (linkBreak) {
1875                         annotation.add(DocletConstants.NL);
1876                         int spaces = annotationDoc.getSimpleName().length() + 2;
1877                         for (int k = 0; k &lt; (spaces); k++) {
1878                             annotation.add(&quot; &quot;);
1879                         }
1880                     }
1881                 }
1882                 String simpleName = element.getSimpleName().toString();
1883                 if (multipleValues || !&quot;value&quot;.equals(simpleName)) { // Omit &quot;value=&quot; where unnecessary
1884                     annotation.add(getDocLink(LinkInfoImpl.Kind.ANNOTATION,
1885                                                      element, simpleName, false));
1886                     annotation.add(&quot;=&quot;);
1887                 }
1888                 AnnotationValue annotationValue = map.get(element);
1889                 List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1890                 new SimpleAnnotationValueVisitor9&lt;Void, AnnotationValue&gt;() {
1891                     @Override
1892                     public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, AnnotationValue p) {
1893                         annotationTypeValues.addAll(vals);
1894                         return null;
1895                     }
1896                     @Override
1897                     protected Void defaultAction(Object o, AnnotationValue p) {
1898                         annotationTypeValues.add(p);
1899                         return null;
1900                     }
1901                 }.visit(annotationValue, annotationValue);
1902                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;{&quot;);
1903                 String sep = &quot;&quot;;
1904                 for (AnnotationValue av : annotationTypeValues) {
1905                     annotation.add(sep);
1906                     annotation.add(annotationValueToContent(av));
1907                     sep = &quot;,&quot;;
1908                 }
1909                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;}&quot;);
1910                 isContainerDocumented = false;
1911             }
1912             annotation.add(&quot;)&quot;);
1913         }
1914     }
1915 
1916     /**
1917      * Check if the annotation contains an array of annotation as a value. This
1918      * check is to verify if a repeatable type annotation is present or not.
1919      *
1920      * @param pairs annotation type element and value pairs
1921      *
1922      * @return true if the annotation contains an array of annotation as a value.
1923      */
1924     private boolean isAnnotationArray(Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs) {
1925         AnnotationValue annotationValue;
1926         for (ExecutableElement ee : pairs.keySet()) {
1927             annotationValue = pairs.get(ee);
1928             boolean rvalue = new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
1929                 @Override
1930                 public Boolean visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
1931                     if (vals.size() &gt; 1) {
1932                         if (vals.get(0) instanceof AnnotationMirror) {
1933                             isContainerDocumented = true;
1934                             return new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
1935                                 @Override
1936                                 public Boolean visitAnnotation(AnnotationMirror a, Void p) {
1937                                     isContainerDocumented = true;
1938                                     Element asElement = a.getAnnotationType().asElement();
1939                                     if (utils.isDocumentedAnnotation((TypeElement)asElement)) {
1940                                         isAnnotationDocumented = true;
1941                                     }
1942                                     return true;
1943                                 }
1944                                 @Override
1945                                 protected Boolean defaultAction(Object o, Void p) {
1946                                     return false;
1947                                 }
1948                             }.visit(vals.get(0));
1949                         }
1950                     }
1951                     return false;
1952                 }
1953 
1954                 @Override
1955                 protected Boolean defaultAction(Object o, Void p) {
1956                     return false;
1957                 }
1958             }.visit(annotationValue);
1959             if (rvalue) {
1960                 return true;
1961             }
1962         }
1963         return false;
1964     }
1965 
1966     private Content annotationValueToContent(AnnotationValue annotationValue) {
1967         return new SimpleAnnotationValueVisitor9&lt;Content, Void&gt;() {
1968 
1969             @Override
1970             public Content visitType(TypeMirror t, Void p) {
1971                 return new SimpleTypeVisitor9&lt;Content, Void&gt;() {
1972                     @Override
1973                     public Content visitDeclared(DeclaredType t, Void p) {
1974                         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
1975                                 LinkInfoImpl.Kind.ANNOTATION, t);
1976                         String name = utils.isIncluded(t.asElement())
1977                                 ? t.asElement().getSimpleName().toString()
1978                                 : utils.getFullyQualifiedName(t.asElement());
1979                         linkInfo.label = new StringContent(name + utils.getDimension(t) + &quot;.class&quot;);
1980                         return getLink(linkInfo);
1981                     }
1982                     @Override
1983                     protected Content defaultAction(TypeMirror e, Void p) {
1984                         return new StringContent(t + utils.getDimension(t) + &quot;.class&quot;);
1985                     }
1986                 }.visit(t);
1987             }
1988             @Override
1989             public Content visitAnnotation(AnnotationMirror a, Void p) {
1990                 List&lt;Content&gt; list = getAnnotations(List.of(a), false);
1991                 ContentBuilder buf = new ContentBuilder();
1992                 for (Content c : list) {
1993                     buf.add(c);
1994                 }
1995                 return buf;
1996             }
1997             @Override
1998             public Content visitEnumConstant(VariableElement c, Void p) {
1999                 return getDocLink(LinkInfoImpl.Kind.ANNOTATION,
2000                         c, c.getSimpleName(), false);
2001             }
2002             @Override
2003             public Content visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
2004                 ContentBuilder buf = new ContentBuilder();
2005                 String sep = &quot;&quot;;
2006                 for (AnnotationValue av : vals) {
2007                     buf.add(sep);
2008                     buf.add(visit(av));
2009                     sep = &quot; &quot;;
2010                 }
2011                 return buf;
2012             }
2013             @Override
2014             protected Content defaultAction(Object o, Void p) {
2015                 return new StringContent(annotationValue.toString());
2016             }
2017         }.visit(annotationValue);
2018     }
2019 
2020     protected TableHeader getPackageTableHeader() {
2021         return new TableHeader(contents.packageLabel, contents.descriptionLabel);
2022     }
2023 
2024     /**
2025      * Generates a string for use in a description meta element,
2026      * based on an element and its enclosing elements
2027      * @param prefix a prefix for the string
2028      * @param elem the element
2029      * @return the description
2030      */
2031     static String getDescription(String prefix, Element elem) {
2032         LinkedList&lt;Element&gt; chain = new LinkedList&lt;&gt;();
2033         for (Element e = elem; e != null; e = e.getEnclosingElement()) {
2034             // ignore unnamed enclosing elements
2035             if (e.getSimpleName().length() == 0 &amp;&amp; e != elem) {
2036                 break;
2037             }
2038             chain.addFirst(e);
2039         }
2040         StringBuilder sb = new StringBuilder();
2041         for (Element e: chain) {
2042             CharSequence name;
2043             switch (e.getKind()) {
2044                 case MODULE:
2045                 case PACKAGE:
2046                     name = ((QualifiedNameable) e).getQualifiedName();
2047                     if (name.length() == 0) {
2048                         name = &quot;&lt;unnamed&gt;&quot;;
2049                     }
2050                     break;
2051 
2052                 default:
2053                     name = e.getSimpleName();
2054                     break;
2055             }
2056 
2057             if (sb.length() == 0) {
2058                 sb.append(prefix).append(&quot;: &quot;);
2059             } else {
2060                 sb.append(&quot;, &quot;);
2061             }
2062             sb.append(e.getKind().toString().toLowerCase(Locale.US).replace(&quot;_&quot;, &quot; &quot;))
2063                     .append(&quot;: &quot;)
2064                     .append(name);
2065         }
2066         return sb.toString();
2067     }
2068 
2069     static String getGenerator(Class&lt;?&gt; clazz) {
2070         return &quot;javadoc/&quot; + clazz.getSimpleName();
2071     }
2072 
2073     /**
2074      * Returns an HtmlTree for the BODY tag.
2075      *
2076      * @param title title for the window
2077      * @return an HtmlTree for the BODY tag
2078      */
2079     public HtmlTree getBody(String title) {
2080         HtmlTree body = new HtmlTree(TagName.BODY).setStyle(getBodyStyle());
2081 
2082         this.winTitle = title;
2083         // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
2084         // and package-frame
2085         body.add(mainBodyScript.asContent());
2086         Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));
2087         body.add(noScript);
2088         return body;
2089     }
2090 
2091     public HtmlStyle getBodyStyle() {
2092         String kind = getClass().getSimpleName()
2093                 .replaceAll(&quot;(Writer)?(Impl)?$&quot;, &quot;&quot;)
2094                 .replaceAll(&quot;AnnotationType&quot;, &quot;Class&quot;)
2095                 .replaceAll(&quot;^(Module|Package|Class)$&quot;, &quot;$1Declaration&quot;);
2096         String page = kind.substring(0, 1).toLowerCase(Locale.US) + kind.substring(1) + &quot;Page&quot;;
2097         return HtmlStyle.valueOf(page);
2098     }
2099 
2100     Script getMainBodyScript() {
2101         return mainBodyScript;
2102     }
2103 
2104     /**
2105      * Returns the path of module/package specific stylesheets for the element.
2106      * @param element module/Package element
2107      * @return list of path of module/package specific stylesheets
2108      * @throws DocFileIOException
2109      */
2110     List&lt;DocPath&gt; getLocalStylesheets(Element element) throws DocFileIOException {
2111         List&lt;DocPath&gt; stylesheets = new ArrayList&lt;&gt;();
2112         DocPath basePath = null;
2113         if (element instanceof PackageElement) {
2114             stylesheets.addAll(getModuleStylesheets((PackageElement)element));
2115             basePath = docPaths.forPackage((PackageElement)element);
2116         } else if (element instanceof ModuleElement) {
2117             basePath = DocPaths.forModule((ModuleElement)element);
2118         }
2119         for (DocPath stylesheet : getStylesheets(element)) {
2120             stylesheets.add(basePath.resolve(stylesheet.getPath()));
2121         }
2122         return stylesheets;
2123     }
2124 
2125     private List&lt;DocPath&gt; getModuleStylesheets(PackageElement pkgElement) throws
2126             DocFileIOException {
2127         List&lt;DocPath&gt; moduleStylesheets = new ArrayList&lt;&gt;();
2128         ModuleElement moduleElement = utils.containingModule(pkgElement);
2129         if (moduleElement != null &amp;&amp; !moduleElement.isUnnamed()) {
2130             List&lt;DocPath&gt; localStylesheets = getStylesheets(moduleElement);
2131             DocPath basePath = DocPaths.forModule(moduleElement);
2132             for (DocPath stylesheet : localStylesheets) {
2133                 moduleStylesheets.add(basePath.resolve(stylesheet));
2134             }
2135         }
2136         return moduleStylesheets;
2137     }
2138 
2139     private List&lt;DocPath&gt; getStylesheets(Element element) throws DocFileIOException {
2140         List&lt;DocPath&gt; localStylesheets = configuration.localStylesheetMap.get(element);
2141         if (localStylesheets == null) {
2142             DocFilesHandlerImpl docFilesHandler = (DocFilesHandlerImpl)configuration
2143                     .getWriterFactory().getDocFilesHandler(element);
2144             localStylesheets = docFilesHandler.getStylesheets();
2145             configuration.localStylesheetMap.put(element, localStylesheets);
2146         }
2147         return localStylesheets;
2148     }
2149 
2150     Content getVerticalSeparator() {
2151         return HtmlTree.SPAN(HtmlStyle.verticalSeparator, new FixedStringContent(&quot;|&quot;));
2152     }
2153 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/graphKit.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="library_call.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/graphKit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
3969 
3970 void GraphKit::sync_kit(IdealKit&amp; ideal) {
3971   set_all_memory(ideal.merged_memory());
3972   set_i_o(ideal.i_o());
3973   set_control(ideal.ctrl());
3974 }
3975 
3976 void GraphKit::final_sync(IdealKit&amp; ideal) {
3977   // Final sync IdealKit and graphKit.
3978   sync_kit(ideal);
3979 }
3980 
3981 Node* GraphKit::load_String_length(Node* str, bool set_ctrl) {
3982   Node* len = load_array_length(load_String_value(str, set_ctrl));
3983   Node* coder = load_String_coder(str, set_ctrl);
3984   // Divide length by 2 if coder is UTF16
3985   return _gvn.transform(new RShiftINode(len, coder));
3986 }
3987 
3988 Node* GraphKit::load_String_value(Node* str, bool set_ctrl) {
<span class="line-modified">3989   int value_offset = java_lang_String::value_offset_in_bytes();</span>
3990   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
3991                                                      false, NULL, 0);
3992   const TypePtr* value_field_type = string_type-&gt;add_offset(value_offset);
3993   const TypeAryPtr* value_type = TypeAryPtr::make(TypePtr::NotNull,
3994                                                   TypeAry::make(TypeInt::BYTE, TypeInt::POS),
3995                                                   ciTypeArrayKlass::make(T_BYTE), true, 0);
3996   Node* p = basic_plus_adr(str, str, value_offset);
3997   Node* load = access_load_at(str, p, value_field_type, value_type, T_OBJECT,
3998                               IN_HEAP | (set_ctrl ? C2_CONTROL_DEPENDENT_LOAD : 0) | MO_UNORDERED);
3999   return load;
4000 }
4001 
4002 Node* GraphKit::load_String_coder(Node* str, bool set_ctrl) {
4003   if (!CompactStrings) {
4004     return intcon(java_lang_String::CODER_UTF16);
4005   }
<span class="line-modified">4006   int coder_offset = java_lang_String::coder_offset_in_bytes();</span>
4007   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
4008                                                      false, NULL, 0);
4009   const TypePtr* coder_field_type = string_type-&gt;add_offset(coder_offset);
4010 
4011   Node* p = basic_plus_adr(str, str, coder_offset);
4012   Node* load = access_load_at(str, p, coder_field_type, TypeInt::BYTE, T_BYTE,
4013                               IN_HEAP | (set_ctrl ? C2_CONTROL_DEPENDENT_LOAD : 0) | MO_UNORDERED);
4014   return load;
4015 }
4016 
4017 void GraphKit::store_String_value(Node* str, Node* value) {
<span class="line-modified">4018   int value_offset = java_lang_String::value_offset_in_bytes();</span>
4019   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
4020                                                      false, NULL, 0);
4021   const TypePtr* value_field_type = string_type-&gt;add_offset(value_offset);
4022 
4023   access_store_at(str,  basic_plus_adr(str, value_offset), value_field_type,
4024                   value, TypeAryPtr::BYTES, T_OBJECT, IN_HEAP | MO_UNORDERED);
4025 }
4026 
4027 void GraphKit::store_String_coder(Node* str, Node* value) {
<span class="line-modified">4028   int coder_offset = java_lang_String::coder_offset_in_bytes();</span>
4029   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
4030                                                      false, NULL, 0);
4031   const TypePtr* coder_field_type = string_type-&gt;add_offset(coder_offset);
4032 
4033   access_store_at(str, basic_plus_adr(str, coder_offset), coder_field_type,
4034                   value, TypeInt::BYTE, T_BYTE, IN_HEAP | MO_UNORDERED);
4035 }
4036 
4037 // Capture src and dst memory state with a MergeMemNode
4038 Node* GraphKit::capture_memory(const TypePtr* src_type, const TypePtr* dst_type) {
4039   if (src_type == dst_type) {
4040     // Types are equal, we don&#39;t need a MergeMemNode
4041     return memory(src_type);
4042   }
4043   MergeMemNode* merge = MergeMemNode::make(map()-&gt;memory());
4044   record_for_igvn(merge); // fold it up later, if possible
4045   int src_idx = C-&gt;get_alias_index(src_type);
4046   int dst_idx = C-&gt;get_alias_index(dst_type);
4047   merge-&gt;set_memory_at(src_idx, memory(src_idx));
4048   merge-&gt;set_memory_at(dst_idx, memory(dst_idx));
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
3969 
3970 void GraphKit::sync_kit(IdealKit&amp; ideal) {
3971   set_all_memory(ideal.merged_memory());
3972   set_i_o(ideal.i_o());
3973   set_control(ideal.ctrl());
3974 }
3975 
3976 void GraphKit::final_sync(IdealKit&amp; ideal) {
3977   // Final sync IdealKit and graphKit.
3978   sync_kit(ideal);
3979 }
3980 
3981 Node* GraphKit::load_String_length(Node* str, bool set_ctrl) {
3982   Node* len = load_array_length(load_String_value(str, set_ctrl));
3983   Node* coder = load_String_coder(str, set_ctrl);
3984   // Divide length by 2 if coder is UTF16
3985   return _gvn.transform(new RShiftINode(len, coder));
3986 }
3987 
3988 Node* GraphKit::load_String_value(Node* str, bool set_ctrl) {
<span class="line-modified">3989   int value_offset = java_lang_String::value_offset();</span>
3990   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
3991                                                      false, NULL, 0);
3992   const TypePtr* value_field_type = string_type-&gt;add_offset(value_offset);
3993   const TypeAryPtr* value_type = TypeAryPtr::make(TypePtr::NotNull,
3994                                                   TypeAry::make(TypeInt::BYTE, TypeInt::POS),
3995                                                   ciTypeArrayKlass::make(T_BYTE), true, 0);
3996   Node* p = basic_plus_adr(str, str, value_offset);
3997   Node* load = access_load_at(str, p, value_field_type, value_type, T_OBJECT,
3998                               IN_HEAP | (set_ctrl ? C2_CONTROL_DEPENDENT_LOAD : 0) | MO_UNORDERED);
3999   return load;
4000 }
4001 
4002 Node* GraphKit::load_String_coder(Node* str, bool set_ctrl) {
4003   if (!CompactStrings) {
4004     return intcon(java_lang_String::CODER_UTF16);
4005   }
<span class="line-modified">4006   int coder_offset = java_lang_String::coder_offset();</span>
4007   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
4008                                                      false, NULL, 0);
4009   const TypePtr* coder_field_type = string_type-&gt;add_offset(coder_offset);
4010 
4011   Node* p = basic_plus_adr(str, str, coder_offset);
4012   Node* load = access_load_at(str, p, coder_field_type, TypeInt::BYTE, T_BYTE,
4013                               IN_HEAP | (set_ctrl ? C2_CONTROL_DEPENDENT_LOAD : 0) | MO_UNORDERED);
4014   return load;
4015 }
4016 
4017 void GraphKit::store_String_value(Node* str, Node* value) {
<span class="line-modified">4018   int value_offset = java_lang_String::value_offset();</span>
4019   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
4020                                                      false, NULL, 0);
4021   const TypePtr* value_field_type = string_type-&gt;add_offset(value_offset);
4022 
4023   access_store_at(str,  basic_plus_adr(str, value_offset), value_field_type,
4024                   value, TypeAryPtr::BYTES, T_OBJECT, IN_HEAP | MO_UNORDERED);
4025 }
4026 
4027 void GraphKit::store_String_coder(Node* str, Node* value) {
<span class="line-modified">4028   int coder_offset = java_lang_String::coder_offset();</span>
4029   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
4030                                                      false, NULL, 0);
4031   const TypePtr* coder_field_type = string_type-&gt;add_offset(coder_offset);
4032 
4033   access_store_at(str, basic_plus_adr(str, coder_offset), coder_field_type,
4034                   value, TypeInt::BYTE, T_BYTE, IN_HEAP | MO_UNORDERED);
4035 }
4036 
4037 // Capture src and dst memory state with a MergeMemNode
4038 Node* GraphKit::capture_memory(const TypePtr* src_type, const TypePtr* dst_type) {
4039   if (src_type == dst_type) {
4040     // Types are equal, we don&#39;t need a MergeMemNode
4041     return memory(src_type);
4042   }
4043   MergeMemNode* merge = MergeMemNode::make(map()-&gt;memory());
4044   record_for_igvn(merge); // fold it up later, if possible
4045   int src_idx = C-&gt;get_alias_index(src_type);
4046   int dst_idx = C-&gt;get_alias_index(dst_type);
4047   merge-&gt;set_memory_at(src_idx, memory(src_idx));
4048   merge-&gt;set_memory_at(dst_idx, memory(dst_idx));
</pre>
</td>
</tr>
</table>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="library_call.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
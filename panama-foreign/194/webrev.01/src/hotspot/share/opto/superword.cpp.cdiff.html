<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/superword.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stringopts.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="superword.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/superword.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 613,11 ***</span>
  
      // Create initial pack pairs of memory operations for which
      // alignment is set and vectors will be aligned.
      bool create_pack = true;
      if (memory_alignment(mem_ref, best_iv_adjustment) == 0 || _do_vector_loop) {
<span class="line-modified">!       if (!Matcher::misaligned_vectors_ok() || AlignVector) {</span>
          int vw = vector_width(mem_ref);
          int vw_best = vector_width(best_align_to_mem_ref);
          if (vw &gt; vw_best) {
            // Do not vectorize a memory access with more elements per vector
            // if unaligned memory access is not allowed because number of
<span class="line-new-header">--- 613,11 ---</span>
  
      // Create initial pack pairs of memory operations for which
      // alignment is set and vectors will be aligned.
      bool create_pack = true;
      if (memory_alignment(mem_ref, best_iv_adjustment) == 0 || _do_vector_loop) {
<span class="line-modified">!       if (vectors_should_be_aligned()) {</span>
          int vw = vector_width(mem_ref);
          int vw_best = vector_width(best_align_to_mem_ref);
          if (vw &gt; vw_best) {
            // Do not vectorize a memory access with more elements per vector
            // if unaligned memory access is not allowed because number of
</pre>
<hr />
<pre>
<span class="line-old-header">*** 638,11 ***</span>
          // same type since it could be overlapped accesses to the same array.
          create_pack = false;
        } else {
          // Allow independent (different type) unaligned memory operations
          // if HW supports them.
<span class="line-modified">!         if (!Matcher::misaligned_vectors_ok() || AlignVector) {</span>
            create_pack = false;
          } else {
            // Check if packs of the same memory type but
            // with a different alignment were created before.
            for (uint i = 0; i &lt; align_to_refs.size(); i++) {
<span class="line-new-header">--- 638,11 ---</span>
          // same type since it could be overlapped accesses to the same array.
          create_pack = false;
        } else {
          // Allow independent (different type) unaligned memory operations
          // if HW supports them.
<span class="line-modified">!         if (vectors_should_be_aligned()) {</span>
            create_pack = false;
          } else {
            // Check if packs of the same memory type but
            // with a different alignment were created before.
            for (uint i = 0; i &lt; align_to_refs.size(); i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 774,12 ***</span>
  
    // Count number of comparable memory ops
    for (uint i = 0; i &lt; memops.size(); i++) {
      MemNode* s1 = memops.at(i)-&gt;as_Mem();
      SWPointer p1(s1, this, NULL, false);
<span class="line-modified">!     // Discard if pre loop can&#39;t align this reference</span>
<span class="line-modified">!     if (!ref_is_alignable(p1)) {</span>
        *cmp_ct.adr_at(i) = 0;
        continue;
      }
      for (uint j = i+1; j &lt; memops.size(); j++) {
        MemNode* s2 = memops.at(j)-&gt;as_Mem();
<span class="line-new-header">--- 774,13 ---</span>
  
    // Count number of comparable memory ops
    for (uint i = 0; i &lt; memops.size(); i++) {
      MemNode* s1 = memops.at(i)-&gt;as_Mem();
      SWPointer p1(s1, this, NULL, false);
<span class="line-modified">!     // Only discard unalignable memory references if vector memory references</span>
<span class="line-modified">!     // should be aligned on this platform.</span>
<span class="line-added">+     if (vectors_should_be_aligned() &amp;&amp; !ref_is_alignable(p1)) {</span>
        *cmp_ct.adr_at(i) = 0;
        continue;
      }
      for (uint j = i+1; j &lt; memops.size(); j++) {
        MemNode* s2 = memops.at(j)-&gt;as_Mem();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 996,11 ***</span>
      int stride_sign = (scale * iv_stride()) &gt; 0 ? 1 : -1;
      // At least one iteration is executed in pre-loop by default. As result
      // several iterations are needed to align memory operations in main-loop even
      // if offset is 0.
      int iv_adjustment_in_bytes = (stride_sign * vw - (offset % vw));
<span class="line-modified">!     assert(((ABS(iv_adjustment_in_bytes) % elt_size) == 0),</span>
             &quot;(%d) should be divisible by (%d)&quot;, iv_adjustment_in_bytes, elt_size);
      iv_adjustment = iv_adjustment_in_bytes/elt_size;
    } else {
      // This memory op is not dependent on iv (scale == 0)
      iv_adjustment = 0;
<span class="line-new-header">--- 997,13 ---</span>
      int stride_sign = (scale * iv_stride()) &gt; 0 ? 1 : -1;
      // At least one iteration is executed in pre-loop by default. As result
      // several iterations are needed to align memory operations in main-loop even
      // if offset is 0.
      int iv_adjustment_in_bytes = (stride_sign * vw - (offset % vw));
<span class="line-modified">!     // iv_adjustment_in_bytes must be a multiple of elt_size if vector memory</span>
<span class="line-added">+     // references should be aligned on this platform.</span>
<span class="line-added">+     assert((ABS(iv_adjustment_in_bytes) % elt_size) == 0 || !vectors_should_be_aligned(),</span>
             &quot;(%d) should be divisible by (%d)&quot;, iv_adjustment_in_bytes, elt_size);
      iv_adjustment = iv_adjustment_in_bytes/elt_size;
    } else {
      // This memory op is not dependent on iv (scale == 0)
      iv_adjustment = 0;
</pre>
<center><a href="stringopts.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="superword.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
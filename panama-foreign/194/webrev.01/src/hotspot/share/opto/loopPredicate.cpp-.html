<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/loopPredicate.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;opto/loopnode.hpp&quot;
  27 #include &quot;opto/addnode.hpp&quot;
  28 #include &quot;opto/callnode.hpp&quot;
  29 #include &quot;opto/connode.hpp&quot;
  30 #include &quot;opto/convertnode.hpp&quot;
  31 #include &quot;opto/loopnode.hpp&quot;
  32 #include &quot;opto/matcher.hpp&quot;
  33 #include &quot;opto/mulnode.hpp&quot;
  34 #include &quot;opto/opaquenode.hpp&quot;
  35 #include &quot;opto/rootnode.hpp&quot;
  36 #include &quot;opto/subnode.hpp&quot;
  37 #include &lt;fenv.h&gt;
  38 #include &lt;math.h&gt;
  39 
  40 /*
  41  * The general idea of Loop Predication is to insert a predicate on the entry
  42  * path to a loop, and raise a uncommon trap if the check of the condition fails.
  43  * The condition checks are promoted from inside the loop body, and thus
  44  * the checks inside the loop could be eliminated. Currently, loop predication
  45  * optimization has been applied to remove array range check and loop invariant
  46  * checks (such as null checks).
  47  *
  48  * There are at least 3 kinds of predicates: a place holder inserted
  49  * at parse time, the tests added by predication above the place
  50  * holder (referred to as concrete predicates), skeleton predicates
  51  * that are added between main loop and pre loop to protect C2 from
  52  * inconsistencies in some rare cases of over unrolling. Skeleton
  53  * predicates themselves are expanded and updated as unrolling
  54  * proceeds. They don&#39;t compile to any code.
  55  *
  56 */
  57 
  58 //-------------------------------register_control-------------------------
  59 void PhaseIdealLoop::register_control(Node* n, IdealLoopTree *loop, Node* pred, bool update_body) {
  60   assert(n-&gt;is_CFG(), &quot;msust be control node&quot;);
  61   _igvn.register_new_node_with_optimizer(n);
  62   if (update_body) {
  63     loop-&gt;_body.push(n);
  64   }
  65   set_loop(n, loop);
  66   // When called from beautify_loops() idom is not constructed yet.
  67   if (_idom != NULL) {
  68     set_idom(n, pred, dom_depth(pred));
  69   }
  70 }
  71 
  72 //------------------------------create_new_if_for_predicate------------------------
  73 // create a new if above the uct_if_pattern for the predicate to be promoted.
  74 //
  75 //          before                                after
  76 //        ----------                           ----------
  77 //           ctrl                                 ctrl
  78 //            |                                     |
  79 //            |                                     |
  80 //            v                                     v
  81 //           iff                                 new_iff
  82 //          /    \                                /      \
  83 //         /      \                              /        \
  84 //        v        v                            v          v
  85 //  uncommon_proj cont_proj                   if_uct     if_cont
  86 // \      |        |                           |          |
  87 //  \     |        |                           |          |
  88 //   v    v        v                           |          v
  89 //     rgn       loop                          |         iff
  90 //      |                                      |        /     \
  91 //      |                                      |       /       \
  92 //      v                                      |      v         v
  93 // uncommon_trap                               | uncommon_proj cont_proj
  94 //                                           \  \    |           |
  95 //                                            \  \   |           |
  96 //                                             v  v  v           v
  97 //                                               rgn           loop
  98 //                                                |
  99 //                                                |
 100 //                                                v
 101 //                                           uncommon_trap
 102 //
 103 //
 104 // We will create a region to guard the uct call if there is no one there.
 105 // The continuation projection (if_cont) of the new_iff is returned which
 106 // is by default a true projection if &#39;if_cont_is_true_proj&#39; is true.
 107 // Otherwise, the continuation projection is set up to be the false
 108 // projection. This code is also used to clone predicates to cloned loops.
 109 ProjNode* PhaseIdealLoop::create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,
 110                                                       Deoptimization::DeoptReason reason,
 111                                                       int opcode, bool if_cont_is_true_proj) {
 112   assert(cont_proj-&gt;is_uncommon_trap_if_pattern(reason), &quot;must be a uct if pattern!&quot;);
 113   IfNode* iff = cont_proj-&gt;in(0)-&gt;as_If();
 114 
 115   ProjNode *uncommon_proj = iff-&gt;proj_out(1 - cont_proj-&gt;_con);
 116   Node     *rgn   = uncommon_proj-&gt;unique_ctrl_out();
 117   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 118 
 119   uint proj_index = 1; // region&#39;s edge corresponding to uncommon_proj
 120   if (!rgn-&gt;is_Region()) { // create a region to guard the call
 121     assert(rgn-&gt;is_Call(), &quot;must be call uct&quot;);
 122     CallNode* call = rgn-&gt;as_Call();
 123     IdealLoopTree* loop = get_loop(call);
 124     rgn = new RegionNode(1);
 125     rgn-&gt;add_req(uncommon_proj);
 126     register_control(rgn, loop, uncommon_proj);
 127     _igvn.replace_input_of(call, 0, rgn);
 128     // When called from beautify_loops() idom is not constructed yet.
 129     if (_idom != NULL) {
 130       set_idom(call, rgn, dom_depth(rgn));
 131     }
 132     for (DUIterator_Fast imax, i = uncommon_proj-&gt;fast_outs(imax); i &lt; imax; i++) {
 133       Node* n = uncommon_proj-&gt;fast_out(i);
 134       if (n-&gt;is_Load() || n-&gt;is_Store()) {
 135         _igvn.replace_input_of(n, 0, rgn);
 136         --i; --imax;
 137       }
 138     }
 139   } else {
 140     // Find region&#39;s edge corresponding to uncommon_proj
 141     for (; proj_index &lt; rgn-&gt;req(); proj_index++)
 142       if (rgn-&gt;in(proj_index) == uncommon_proj) break;
 143     assert(proj_index &lt; rgn-&gt;req(), &quot;sanity&quot;);
 144   }
 145 
 146   Node* entry = iff-&gt;in(0);
 147   if (new_entry != NULL) {
 148     // Clonning the predicate to new location.
 149     entry = new_entry;
 150   }
 151   // Create new_iff
 152   IdealLoopTree* lp = get_loop(entry);
 153   IfNode* new_iff = NULL;
 154   if (opcode == Op_If) {
 155     new_iff = new IfNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 156   } else {
 157     assert(opcode == Op_RangeCheck, &quot;no other if variant here&quot;);
 158     new_iff = new RangeCheckNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 159   }
 160   register_control(new_iff, lp, entry);
 161   Node* if_cont;
 162   Node* if_uct;
 163   if (if_cont_is_true_proj) {
 164     if_cont = new IfTrueNode(new_iff);
 165     if_uct  = new IfFalseNode(new_iff);
 166   } else {
 167     if_uct  = new IfTrueNode(new_iff);
 168     if_cont = new IfFalseNode(new_iff);
 169   }
 170 
 171   if (cont_proj-&gt;is_IfFalse()) {
 172     // Swap
 173     Node* tmp = if_uct; if_uct = if_cont; if_cont = tmp;
 174   }
 175   register_control(if_cont, lp, new_iff);
 176   register_control(if_uct, get_loop(rgn), new_iff);
 177 
 178   // if_uct to rgn
 179   _igvn.hash_delete(rgn);
 180   rgn-&gt;add_req(if_uct);
 181   // When called from beautify_loops() idom is not constructed yet.
 182   if (_idom != NULL) {
 183     Node* ridom = idom(rgn);
 184     Node* nrdom = dom_lca_internal(ridom, new_iff);
 185     set_idom(rgn, nrdom, dom_depth(rgn));
 186   }
 187 
 188   // If rgn has phis add new edges which has the same
 189   // value as on original uncommon_proj pass.
 190   assert(rgn-&gt;in(rgn-&gt;req() -1) == if_uct, &quot;new edge should be last&quot;);
 191   bool has_phi = false;
 192   for (DUIterator_Fast imax, i = rgn-&gt;fast_outs(imax); i &lt; imax; i++) {
 193     Node* use = rgn-&gt;fast_out(i);
 194     if (use-&gt;is_Phi() &amp;&amp; use-&gt;outcnt() &gt; 0) {
 195       assert(use-&gt;in(0) == rgn, &quot;&quot;);
 196       _igvn.rehash_node_delayed(use);
 197       use-&gt;add_req(use-&gt;in(proj_index));
 198       has_phi = true;
 199     }
 200   }
 201   assert(!has_phi || rgn-&gt;req() &gt; 3, &quot;no phis when region is created&quot;);
 202 
 203   if (new_entry == NULL) {
 204     // Attach if_cont to iff
 205     _igvn.replace_input_of(iff, 0, if_cont);
 206     if (_idom != NULL) {
 207       set_idom(iff, if_cont, dom_depth(iff));
 208     }
 209   }
 210   return if_cont-&gt;as_Proj();
 211 }
 212 
 213 //--------------------------clone_predicate-----------------------
 214 ProjNode* PhaseIdealLoop::clone_loop_predicate(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason,
 215                                                bool is_slow_loop, uint idx_before_clone, Node_List &amp;old_new) {
 216   ProjNode* new_predicate_proj = create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_If);
 217   IfNode* iff = new_predicate_proj-&gt;in(0)-&gt;as_If();
 218   Node* ctrl  = iff-&gt;in(0);
 219 
 220   // Match original condition since predicate&#39;s projections could be swapped.
 221   assert(predicate_proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode()==Op_Opaque1, &quot;must be&quot;);
 222   Node* opq = new Opaque1Node(C, predicate_proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1));
 223   C-&gt;add_predicate_opaq(opq);
 224   Node* bol = new Conv2BNode(opq);
 225   register_new_node(opq, ctrl);
 226   register_new_node(bol, ctrl);
 227   _igvn.hash_delete(iff);
 228   iff-&gt;set_req(1, bol);
 229   clone_concrete_loop_predicates(reason, predicate_proj, new_predicate_proj, is_slow_loop, idx_before_clone, old_new);
 230   return new_predicate_proj;
 231 }
 232 
 233 // Clones all non-empty loop predicates (including skeleton predicates) starting at &#39;old_predicate_proj&#39; to &#39;new_predicate_proj&#39;
 234 // and rewires the control edges of data nodes in the loop to the old predicates to the new cloned predicates.
 235 void PhaseIdealLoop::clone_concrete_loop_predicates(Deoptimization::DeoptReason reason, ProjNode* old_predicate_proj,
 236                                                     ProjNode* new_predicate_proj, bool is_slow_loop, uint idx_before_clone,
 237                                                     Node_List &amp;old_new) {
 238   assert(old_predicate_proj-&gt;is_Proj(), &quot;must be projection&quot;);
 239   IfNode* iff = old_predicate_proj-&gt;in(0)-&gt;as_If();
 240   ProjNode* uncommon_proj = iff-&gt;proj_out(1 - old_predicate_proj-&gt;as_Proj()-&gt;_con);
 241   Node* rgn = uncommon_proj-&gt;unique_ctrl_out();
 242   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 243   assert(iff-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_Opaque1, &quot;unexpected predicate shape&quot;);
 244   Node* predicate = iff-&gt;in(0);
 245   Node* current_proj = old_predicate_proj;
 246   Node* prev_proj = current_proj;
 247   Unique_Node_List list;
 248   while (predicate != NULL &amp;&amp; predicate-&gt;is_Proj() &amp;&amp; predicate-&gt;in(0)-&gt;is_If()) {
 249     iff = predicate-&gt;in(0)-&gt;as_If();
 250     uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);
 251     if (uncommon_proj-&gt;unique_ctrl_out() != rgn)
 252       break;
 253     if (iff-&gt;is_RangeCheck()) {
 254       // Only need to clone range check predicates as those can be changed and duplicated by inserting pre/main/post loops
 255       // and doing loop unrolling. Push the original predicates on a list to later process them in reverse order to keep the
 256       // original predicate order.
 257       list.push(predicate);
 258 #ifdef ASSERT
 259     } else {
 260       // All other If predicates should not have a control input to nodes belonging to the original loop
 261       for (DUIterator i = predicate-&gt;outs(); predicate-&gt;has_out(i); i++) {
 262         Node* old_node = predicate-&gt;out(i);
 263         Node* new_node = old_new[old_node-&gt;_idx];
 264         if (!old_node-&gt;is_CFG() &amp;&amp; new_node != NULL &amp;&amp; old_node-&gt;_idx &gt;= idx_before_clone) {
 265           assert(false, &quot;should not be part of the original loop&quot;);
 266         }
 267       }
 268 #endif
 269     }
 270     predicate = predicate-&gt;in(0)-&gt;in(0);
 271   }
 272 
 273   // Process in reverse order such that &#39;create_new_if_for_predicate&#39; can be used and the original order is maintained
 274   for (int i = list.size()-1; i &gt;= 0; i--) {
 275     predicate = list.at(i);
 276     assert(predicate-&gt;in(0)-&gt;is_If(), &quot;must be If node&quot;);
 277     iff = predicate-&gt;in(0)-&gt;as_If();
 278     assert(predicate-&gt;is_Proj() &amp;&amp; predicate-&gt;as_Proj()-&gt;is_IfProj() &amp;&amp; iff-&gt;is_RangeCheck(), &quot;predicate must be a projection of a range check&quot;);
 279     IfProjNode* predicate_proj = predicate-&gt;as_IfProj();
 280 
 281     // cloned_proj is the same type of projection as the original predicate projection (IfTrue or IfFalse)
 282     ProjNode* cloned_proj = create_new_if_for_predicate(new_predicate_proj, NULL, reason, Op_RangeCheck, predicate_proj-&gt;is_IfTrue());
 283 
 284     // Replace bool input by input from original predicate
 285     _igvn.replace_input_of(cloned_proj-&gt;in(0), 1, iff-&gt;in(1));
 286 
 287     if (is_slow_loop) {
 288       for (DUIterator i = predicate-&gt;outs(); predicate-&gt;has_out(i); i++) {
 289         Node* slow_node = predicate-&gt;out(i);
 290         Node* fast_node = old_new[slow_node-&gt;_idx];
 291         if (!slow_node-&gt;is_CFG() &amp;&amp; fast_node != NULL &amp;&amp; slow_node-&gt;_idx &gt; idx_before_clone) {
 292           // &#39;slow_node&#39; is a data node and part of the slow loop. This is a clone of the fast loop node
 293           // which was temporarily added below in order to verify that &#39;slow_node&#39; is a clone of &#39;fast_node&#39;.
 294           // Update the control input and reset the mapping for &#39;slow_node&#39; back to NULL.
 295           _igvn.replace_input_of(slow_node, 0, cloned_proj);
 296           old_new.map(slow_node-&gt;_idx, NULL);
 297           --i;
 298         }
 299         assert(slow_node-&gt;_idx &lt;= idx_before_clone || old_new[slow_node-&gt;_idx] == NULL, &quot;mapping of cloned nodes must be null&quot;);
 300       }
 301 
 302       // Let old predicates before unswitched loops which were cloned die if all their control edges were rewired
 303       // to the cloned predicates in the unswitched loops.
 304       if (predicate-&gt;outcnt() == 1) {
 305         _igvn.replace_input_of(iff, 1, _igvn.intcon(predicate_proj-&gt;_con));
 306       }
 307     } else {
 308       // Fast loop
 309       for (DUIterator i = predicate-&gt;outs(); predicate-&gt;has_out(i); i++) {
 310         Node* fast_node = predicate-&gt;out(i);
 311         Node* slow_node = old_new[fast_node-&gt;_idx];
 312         if (!fast_node-&gt;is_CFG() &amp;&amp; slow_node != NULL &amp;&amp; slow_node-&gt;_idx &gt; idx_before_clone) {
 313           // &#39;fast_node&#39; is a data node and part of the fast loop. Add the clone of the fast loop node
 314           // to the &#39;old_new&#39; mapping in order to verify later when cloning the predicates for the slow loop
 315           // that &#39;slow_node&#39; is a clone of &#39;fast_node&#39;. Update the control input for &#39;fast_node&#39;.
 316           _igvn.replace_input_of(fast_node, 0, cloned_proj);
 317           assert(old_new[slow_node-&gt;_idx] == NULL, &quot;mapping must be null for cloned nodes&quot;);
 318           old_new.map(slow_node-&gt;_idx, fast_node);
 319           --i;
 320         }
 321       }
 322     }
 323   }
 324 }
 325 
 326 //--------------------------clone_loop_predicates-----------------------
 327 // Clone loop predicates to cloned loops when unswitching a loop.
 328 Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check,
 329                                             bool is_slow_loop, uint idx_before_clone, Node_List &amp;old_new) {
 330 #ifdef ASSERT
 331   assert(LoopUnswitching, &quot;sanity - only called when unswitching a loop&quot;);
 332   if (new_entry == NULL || !(new_entry-&gt;is_Proj() || new_entry-&gt;is_Region() || new_entry-&gt;is_SafePoint())) {
 333     if (new_entry != NULL)
 334       new_entry-&gt;dump();
 335     assert(false, &quot;not IfTrue, IfFalse, Region or SafePoint&quot;);
 336   }
 337 #endif
 338   // Search original predicates
 339   Node* entry = old_entry;
 340   ProjNode* limit_check_proj = NULL;
 341   limit_check_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 342   if (limit_check_proj != NULL) {
 343     entry = skip_loop_predicates(entry);
 344   }
 345   ProjNode* profile_predicate_proj = NULL;
 346   ProjNode* predicate_proj = NULL;
 347   if (UseProfiledLoopPredicate) {
 348     profile_predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 349     if (profile_predicate_proj != NULL) {
 350       entry = skip_loop_predicates(entry);
 351     }
 352   }
 353   if (UseLoopPredicate) {
 354     predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 355   }
 356   if (predicate_proj != NULL) { // right pattern that can be used by loop predication
 357     // clone predicate
 358     new_entry = clone_loop_predicate(predicate_proj, new_entry, Deoptimization::Reason_predicate, is_slow_loop,
 359                                      idx_before_clone, old_new);
 360     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);
 361     if (TraceLoopPredicate) {
 362       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 363       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 364     }
 365   }
 366   if (profile_predicate_proj != NULL) { // right pattern that can be used by loop predication
 367     // clone predicate
 368     new_entry = clone_loop_predicate(profile_predicate_proj, new_entry,Deoptimization::Reason_profile_predicate,
 369                                      is_slow_loop, idx_before_clone, old_new);
 370     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);
 371     if (TraceLoopPredicate) {
 372       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 373       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 374     }
 375   }
 376   if (limit_check_proj != NULL &amp;&amp; clone_limit_check) {
 377     // Clone loop limit check last to insert it before loop.
 378     // Don&#39;t clone a limit check which was already finalized
 379     // for this counted loop (only one limit check is needed).
 380     new_entry = clone_loop_predicate(limit_check_proj, new_entry, Deoptimization::Reason_loop_limit_check,
 381                                      is_slow_loop, idx_before_clone, old_new);
 382     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone limit check&quot;);
 383     if (TraceLoopLimitCheck) {
 384       tty-&gt;print(&quot;Loop Limit Check cloned: &quot;);
 385       debug_only( new_entry-&gt;in(0)-&gt;dump(); )
 386     }
 387   }
 388   return new_entry;
 389 }
 390 
 391 //--------------------------skip_loop_predicates------------------------------
 392 // Skip related predicates.
 393 Node* PhaseIdealLoop::skip_loop_predicates(Node* entry) {
 394   IfNode* iff = entry-&gt;in(0)-&gt;as_If();
 395   ProjNode* uncommon_proj = iff-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
 396   Node* rgn = uncommon_proj-&gt;unique_ctrl_out();
 397   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 398   entry = entry-&gt;in(0)-&gt;in(0);
 399   while (entry != NULL &amp;&amp; entry-&gt;is_Proj() &amp;&amp; entry-&gt;in(0)-&gt;is_If()) {
 400     uncommon_proj = entry-&gt;in(0)-&gt;as_If()-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
 401     if (uncommon_proj-&gt;unique_ctrl_out() != rgn)
 402       break;
 403     entry = entry-&gt;in(0)-&gt;in(0);
 404   }
 405   return entry;
 406 }
 407 
 408 Node* PhaseIdealLoop::skip_all_loop_predicates(Node* entry) {
 409   Node* predicate = NULL;
 410   predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 411   if (predicate != NULL) {
 412     entry = skip_loop_predicates(entry);
 413   }
 414   if (UseProfiledLoopPredicate) {
 415     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 416     if (predicate != NULL) { // right pattern that can be used by loop predication
 417       entry = skip_loop_predicates(entry);
 418     }
 419   }
 420   if (UseLoopPredicate) {
 421     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 422     if (predicate != NULL) { // right pattern that can be used by loop predication
 423       entry = skip_loop_predicates(entry);
 424     }
 425   }
 426   return entry;
 427 }
 428 
 429 //--------------------------find_predicate_insertion_point-------------------
 430 // Find a good location to insert a predicate
 431 ProjNode* PhaseIdealLoop::find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason) {
 432   if (start_c == NULL || !start_c-&gt;is_Proj())
 433     return NULL;
 434   if (start_c-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(reason)) {
 435     return start_c-&gt;as_Proj();
 436   }
 437   return NULL;
 438 }
 439 
 440 //--------------------------find_predicate------------------------------------
 441 // Find a predicate
 442 Node* PhaseIdealLoop::find_predicate(Node* entry) {
 443   Node* predicate = NULL;
 444   predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 445   if (predicate != NULL) { // right pattern that can be used by loop predication
 446     return entry;
 447   }
 448   if (UseLoopPredicate) {
 449     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 450     if (predicate != NULL) { // right pattern that can be used by loop predication
 451       return entry;
 452     }
 453   }
 454   if (UseProfiledLoopPredicate) {
 455     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 456     if (predicate != NULL) { // right pattern that can be used by loop predication
 457       return entry;
 458     }
 459   }
 460   return NULL;
 461 }
 462 
 463 //------------------------------Invariance-----------------------------------
 464 // Helper class for loop_predication_impl to compute invariance on the fly and
 465 // clone invariants.
 466 class Invariance : public StackObj {
 467   VectorSet _visited, _invariant;
 468   Node_Stack _stack;
 469   VectorSet _clone_visited;
 470   Node_List _old_new; // map of old to new (clone)
 471   IdealLoopTree* _lpt;
 472   PhaseIdealLoop* _phase;
 473 
 474   // Helper function to set up the invariance for invariance computation
 475   // If n is a known invariant, set up directly. Otherwise, look up the
 476   // the possibility to push n onto the stack for further processing.
 477   void visit(Node* use, Node* n) {
 478     if (_lpt-&gt;is_invariant(n)) { // known invariant
 479       _invariant.set(n-&gt;_idx);
 480     } else if (!n-&gt;is_CFG()) {
 481       Node *n_ctrl = _phase-&gt;ctrl_or_self(n);
 482       Node *u_ctrl = _phase-&gt;ctrl_or_self(use); // self if use is a CFG
 483       if (_phase-&gt;is_dominator(n_ctrl, u_ctrl)) {
 484         _stack.push(n, n-&gt;in(0) == NULL ? 1 : 0);
 485       }
 486     }
 487   }
 488 
 489   // Compute invariance for &quot;the_node&quot; and (possibly) all its inputs recursively
 490   // on the fly
 491   void compute_invariance(Node* n) {
 492     assert(_visited.test(n-&gt;_idx), &quot;must be&quot;);
 493     visit(n, n);
 494     while (_stack.is_nonempty()) {
 495       Node*  n = _stack.node();
 496       uint idx = _stack.index();
 497       if (idx == n-&gt;req()) { // all inputs are processed
 498         _stack.pop();
 499         // n is invariant if it&#39;s inputs are all invariant
 500         bool all_inputs_invariant = true;
 501         for (uint i = 0; i &lt; n-&gt;req(); i++) {
 502           Node* in = n-&gt;in(i);
 503           if (in == NULL) continue;
 504           assert(_visited.test(in-&gt;_idx), &quot;must have visited input&quot;);
 505           if (!_invariant.test(in-&gt;_idx)) { // bad guy
 506             all_inputs_invariant = false;
 507             break;
 508           }
 509         }
 510         if (all_inputs_invariant) {
 511           // If n&#39;s control is a predicate that was moved out of the
 512           // loop, it was marked invariant but n is only invariant if
 513           // it depends only on that test. Otherwise, unless that test
 514           // is out of the loop, it&#39;s not invariant.
 515           if (n-&gt;is_CFG() || n-&gt;depends_only_on_test() || n-&gt;in(0) == NULL || !_phase-&gt;is_member(_lpt, n-&gt;in(0))) {
 516             _invariant.set(n-&gt;_idx); // I am a invariant too
 517           }
 518         }
 519       } else { // process next input
 520         _stack.set_index(idx + 1);
 521         Node* m = n-&gt;in(idx);
 522         if (m != NULL &amp;&amp; !_visited.test_set(m-&gt;_idx)) {
 523           visit(n, m);
 524         }
 525       }
 526     }
 527   }
 528 
 529   // Helper function to set up _old_new map for clone_nodes.
 530   // If n is a known invariant, set up directly (&quot;clone&quot; of n == n).
 531   // Otherwise, push n onto the stack for real cloning.
 532   void clone_visit(Node* n) {
 533     assert(_invariant.test(n-&gt;_idx), &quot;must be invariant&quot;);
 534     if (_lpt-&gt;is_invariant(n)) { // known invariant
 535       _old_new.map(n-&gt;_idx, n);
 536     } else { // to be cloned
 537       assert(!n-&gt;is_CFG(), &quot;should not see CFG here&quot;);
 538       _stack.push(n, n-&gt;in(0) == NULL ? 1 : 0);
 539     }
 540   }
 541 
 542   // Clone &quot;n&quot; and (possibly) all its inputs recursively
 543   void clone_nodes(Node* n, Node* ctrl) {
 544     clone_visit(n);
 545     while (_stack.is_nonempty()) {
 546       Node*  n = _stack.node();
 547       uint idx = _stack.index();
 548       if (idx == n-&gt;req()) { // all inputs processed, clone n!
 549         _stack.pop();
 550         // clone invariant node
 551         Node* n_cl = n-&gt;clone();
 552         _old_new.map(n-&gt;_idx, n_cl);
 553         _phase-&gt;register_new_node(n_cl, ctrl);
 554         for (uint i = 0; i &lt; n-&gt;req(); i++) {
 555           Node* in = n_cl-&gt;in(i);
 556           if (in == NULL) continue;
 557           n_cl-&gt;set_req(i, _old_new[in-&gt;_idx]);
 558         }
 559       } else { // process next input
 560         _stack.set_index(idx + 1);
 561         Node* m = n-&gt;in(idx);
 562         if (m != NULL &amp;&amp; !_clone_visited.test_set(m-&gt;_idx)) {
 563           clone_visit(m); // visit the input
 564         }
 565       }
 566     }
 567   }
 568 
 569  public:
 570   Invariance(Arena* area, IdealLoopTree* lpt) :
 571     _visited(area), _invariant(area),
 572     _stack(area, 10 /* guess */),
 573     _clone_visited(area), _old_new(area),
 574     _lpt(lpt), _phase(lpt-&gt;_phase)
 575   {
 576     LoopNode* head = _lpt-&gt;_head-&gt;as_Loop();
 577     Node* entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
 578     if (entry-&gt;outcnt() != 1) {
 579       // If a node is pinned between the predicates and the loop
 580       // entry, we won&#39;t be able to move any node in the loop that
 581       // depends on it above it in a predicate. Mark all those nodes
 582       // as non loop invariatnt.
 583       Unique_Node_List wq;
 584       wq.push(entry);
 585       for (uint next = 0; next &lt; wq.size(); ++next) {
 586         Node *n = wq.at(next);
 587         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
 588           Node* u = n-&gt;fast_out(i);
 589           if (!u-&gt;is_CFG()) {
 590             Node* c = _phase-&gt;get_ctrl(u);
 591             if (_lpt-&gt;is_member(_phase-&gt;get_loop(c)) || _phase-&gt;is_dominator(c, head)) {
 592               _visited.set(u-&gt;_idx);
 593               wq.push(u);
 594             }
 595           }
 596         }
 597       }
 598     }
 599   }
 600 
 601   // Map old to n for invariance computation and clone
 602   void map_ctrl(Node* old, Node* n) {
 603     assert(old-&gt;is_CFG() &amp;&amp; n-&gt;is_CFG(), &quot;must be&quot;);
 604     _old_new.map(old-&gt;_idx, n); // &quot;clone&quot; of old is n
 605     _invariant.set(old-&gt;_idx);  // old is invariant
 606     _clone_visited.set(old-&gt;_idx);
 607   }
 608 
 609   // Driver function to compute invariance
 610   bool is_invariant(Node* n) {
 611     if (!_visited.test_set(n-&gt;_idx))
 612       compute_invariance(n);
 613     return (_invariant.test(n-&gt;_idx) != 0);
 614   }
 615 
 616   // Driver function to clone invariant
 617   Node* clone(Node* n, Node* ctrl) {
 618     assert(ctrl-&gt;is_CFG(), &quot;must be&quot;);
 619     assert(_invariant.test(n-&gt;_idx), &quot;must be an invariant&quot;);
 620     if (!_clone_visited.test(n-&gt;_idx))
 621       clone_nodes(n, ctrl);
 622     return _old_new[n-&gt;_idx];
 623   }
 624 };
 625 
 626 //------------------------------is_range_check_if -----------------------------------
 627 // Returns true if the predicate of iff is in &quot;scale*iv + offset u&lt; load_range(ptr)&quot; format
 628 // Note: this function is particularly designed for loop predication. We require load_range
 629 //       and offset to be loop invariant computed on the fly by &quot;invar&quot;
 630 bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance&amp; invar) const {
 631   if (!is_loop_exit(iff)) {
 632     return false;
 633   }
 634   if (!iff-&gt;in(1)-&gt;is_Bool()) {
 635     return false;
 636   }
 637   const BoolNode *bol = iff-&gt;in(1)-&gt;as_Bool();
 638   if (bol-&gt;_test._test != BoolTest::lt) {
 639     return false;
 640   }
 641   if (!bol-&gt;in(1)-&gt;is_Cmp()) {
 642     return false;
 643   }
 644   const CmpNode *cmp = bol-&gt;in(1)-&gt;as_Cmp();
 645   if (cmp-&gt;Opcode() != Op_CmpU) {
 646     return false;
 647   }
 648   Node* range = cmp-&gt;in(2);
 649   if (range-&gt;Opcode() != Op_LoadRange &amp;&amp; !iff-&gt;is_RangeCheck()) {
 650     const TypeInt* tint = phase-&gt;_igvn.type(range)-&gt;isa_int();
 651     if (tint == NULL || tint-&gt;empty() || tint-&gt;_lo &lt; 0) {
 652       // Allow predication on positive values that aren&#39;t LoadRanges.
 653       // This allows optimization of loops where the length of the
 654       // array is a known value and doesn&#39;t need to be loaded back
 655       // from the array.
 656       return false;
 657     }
 658   }
 659   if (!invar.is_invariant(range)) {
 660     return false;
 661   }
 662   Node *iv     = _head-&gt;as_CountedLoop()-&gt;phi();
 663   int   scale  = 0;
 664   Node *offset = NULL;
 665   if (!phase-&gt;is_scaled_iv_plus_offset(cmp-&gt;in(1), iv, &amp;scale, &amp;offset)) {
 666     return false;
 667   }
 668   if (offset &amp;&amp; !invar.is_invariant(offset)) { // offset must be invariant
 669     return false;
 670   }
 671   return true;
 672 }
 673 
 674 //------------------------------rc_predicate-----------------------------------
 675 // Create a range check predicate
 676 //
 677 // for (i = init; i &lt; limit; i += stride) {
 678 //    a[scale*i+offset]
 679 // }
 680 //
 681 // Compute max(scale*i + offset) for init &lt;= i &lt; limit and build the predicate
 682 // as &quot;max(scale*i + offset) u&lt; a.length&quot;.
 683 //
 684 // There are two cases for max(scale*i + offset):
 685 // (1) stride*scale &gt; 0
 686 //   max(scale*i + offset) = scale*(limit-stride) + offset
 687 // (2) stride*scale &lt; 0
 688 //   max(scale*i + offset) = scale*init + offset
 689 BoolNode* PhaseIdealLoop::rc_predicate(IdealLoopTree *loop, Node* ctrl,
 690                                        int scale, Node* offset,
 691                                        Node* init, Node* limit, jint stride,
 692                                        Node* range, bool upper, bool &amp;overflow) {
 693   jint con_limit  = (limit != NULL &amp;&amp; limit-&gt;is_Con())  ? limit-&gt;get_int()  : 0;
 694   jint con_init   = init-&gt;is_Con()   ? init-&gt;get_int()   : 0;
 695   jint con_offset = offset-&gt;is_Con() ? offset-&gt;get_int() : 0;
 696 
 697   stringStream* predString = NULL;
 698   if (TraceLoopPredicate) {
 699     predString = new stringStream();
 700     predString-&gt;print(&quot;rc_predicate &quot;);
 701   }
 702 
 703   overflow = false;
 704   Node* max_idx_expr = NULL;
 705   const TypeInt* idx_type = TypeInt::INT;
 706   if ((stride &gt; 0) == (scale &gt; 0) == upper) {
 707     guarantee(limit != NULL, &quot;sanity&quot;);
 708     if (TraceLoopPredicate) {
 709       if (limit-&gt;is_Con()) {
 710         predString-&gt;print(&quot;(%d &quot;, con_limit);
 711       } else {
 712         predString-&gt;print(&quot;(limit &quot;);
 713       }
 714       predString-&gt;print(&quot;- %d) &quot;, stride);
 715     }
 716     // Check if (limit - stride) may overflow
 717     const TypeInt* limit_type = _igvn.type(limit)-&gt;isa_int();
 718     jint limit_lo = limit_type-&gt;_lo;
 719     jint limit_hi = limit_type-&gt;_hi;
 720     if ((stride &gt; 0 &amp;&amp; (java_subtract(limit_lo, stride) &lt; limit_lo)) ||
 721         (stride &lt; 0 &amp;&amp; (java_subtract(limit_hi, stride) &gt; limit_hi))) {
 722       // No overflow possible
 723       ConINode* con_stride = _igvn.intcon(stride);
 724       set_ctrl(con_stride, C-&gt;root());
 725       max_idx_expr = new SubINode(limit, con_stride);
 726       idx_type = TypeInt::make(limit_lo - stride, limit_hi - stride, limit_type-&gt;_widen);
 727     } else {
 728       // May overflow
 729       overflow = true;
 730       limit = new ConvI2LNode(limit);
 731       register_new_node(limit, ctrl);
 732       ConLNode* con_stride = _igvn.longcon(stride);
 733       set_ctrl(con_stride, C-&gt;root());
 734       max_idx_expr = new SubLNode(limit, con_stride);
 735     }
 736     register_new_node(max_idx_expr, ctrl);
 737   } else {
 738     if (TraceLoopPredicate) {
 739       if (init-&gt;is_Con()) {
 740         predString-&gt;print(&quot;%d &quot;, con_init);
 741       } else {
 742         predString-&gt;print(&quot;init &quot;);
 743       }
 744     }
 745     idx_type = _igvn.type(init)-&gt;isa_int();
 746     max_idx_expr = init;
 747   }
 748 
 749   if (scale != 1) {
 750     ConNode* con_scale = _igvn.intcon(scale);
 751     set_ctrl(con_scale, C-&gt;root());
 752     if (TraceLoopPredicate) {
 753       predString-&gt;print(&quot;* %d &quot;, scale);
 754     }
 755     // Check if (scale * max_idx_expr) may overflow
 756     const TypeInt* scale_type = TypeInt::make(scale);
 757     MulINode* mul = new MulINode(max_idx_expr, con_scale);
 758     idx_type = (TypeInt*)mul-&gt;mul_ring(idx_type, scale_type);
 759     if (overflow || TypeInt::INT-&gt;higher_equal(idx_type)) {
 760       // May overflow
 761       mul-&gt;destruct();
 762       if (!overflow) {
 763         max_idx_expr = new ConvI2LNode(max_idx_expr);
 764         register_new_node(max_idx_expr, ctrl);
 765       }
 766       overflow = true;
 767       con_scale = _igvn.longcon(scale);
 768       set_ctrl(con_scale, C-&gt;root());
 769       max_idx_expr = new MulLNode(max_idx_expr, con_scale);
 770     } else {
 771       // No overflow possible
 772       max_idx_expr = mul;
 773     }
 774     register_new_node(max_idx_expr, ctrl);
 775   }
 776 
 777   if (offset &amp;&amp; (!offset-&gt;is_Con() || con_offset != 0)){
 778     if (TraceLoopPredicate) {
 779       if (offset-&gt;is_Con()) {
 780         predString-&gt;print(&quot;+ %d &quot;, con_offset);
 781       } else {
 782         predString-&gt;print(&quot;+ offset&quot;);
 783       }
 784     }
 785     // Check if (max_idx_expr + offset) may overflow
 786     const TypeInt* offset_type = _igvn.type(offset)-&gt;isa_int();
 787     jint lo = java_add(idx_type-&gt;_lo, offset_type-&gt;_lo);
 788     jint hi = java_add(idx_type-&gt;_hi, offset_type-&gt;_hi);
 789     if (overflow || (lo &gt; hi) ||
 790         ((idx_type-&gt;_lo &amp; offset_type-&gt;_lo) &lt; 0 &amp;&amp; lo &gt;= 0) ||
 791         ((~(idx_type-&gt;_hi | offset_type-&gt;_hi)) &lt; 0 &amp;&amp; hi &lt; 0)) {
 792       // May overflow
 793       if (!overflow) {
 794         max_idx_expr = new ConvI2LNode(max_idx_expr);
 795         register_new_node(max_idx_expr, ctrl);
 796       }
 797       overflow = true;
 798       offset = new ConvI2LNode(offset);
 799       register_new_node(offset, ctrl);
 800       max_idx_expr = new AddLNode(max_idx_expr, offset);
 801     } else {
 802       // No overflow possible
 803       max_idx_expr = new AddINode(max_idx_expr, offset);
 804     }
 805     register_new_node(max_idx_expr, ctrl);
 806   }
 807 
 808   CmpNode* cmp = NULL;
 809   if (overflow) {
 810     // Integer expressions may overflow, do long comparison
 811     range = new ConvI2LNode(range);
 812     register_new_node(range, ctrl);
 813     cmp = new CmpULNode(max_idx_expr, range);
 814   } else {
 815     cmp = new CmpUNode(max_idx_expr, range);
 816   }
 817   register_new_node(cmp, ctrl);
 818   BoolNode* bol = new BoolNode(cmp, BoolTest::lt);
 819   register_new_node(bol, ctrl);
 820 
 821   if (TraceLoopPredicate) {
 822     predString-&gt;print_cr(&quot;&lt;u range&quot;);
 823     tty-&gt;print(&quot;%s&quot;, predString-&gt;base());
 824     predString-&gt;~stringStream();
 825   }
 826   return bol;
 827 }
 828 
 829 // Should loop predication look not only in the path from tail to head
 830 // but also in branches of the loop body?
 831 bool PhaseIdealLoop::loop_predication_should_follow_branches(IdealLoopTree *loop, ProjNode *predicate_proj, float&amp; loop_trip_cnt) {
 832   if (!UseProfiledLoopPredicate) {
 833     return false;
 834   }
 835 
 836   if (predicate_proj == NULL) {
 837     return false;
 838   }
 839 
 840   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
 841   bool follow_branches = true;
 842   IdealLoopTree* l = loop-&gt;_child;
 843   // For leaf loops and loops with a single inner loop
 844   while (l != NULL &amp;&amp; follow_branches) {
 845     IdealLoopTree* child = l;
 846     if (child-&gt;_child != NULL &amp;&amp;
 847         child-&gt;_head-&gt;is_OuterStripMinedLoop()) {
 848       assert(child-&gt;_child-&gt;_next == NULL, &quot;only one inner loop for strip mined loop&quot;);
 849       assert(child-&gt;_child-&gt;_head-&gt;is_CountedLoop() &amp;&amp; child-&gt;_child-&gt;_head-&gt;as_CountedLoop()-&gt;is_strip_mined(), &quot;inner loop should be strip mined&quot;);
 850       child = child-&gt;_child;
 851     }
 852     if (child-&gt;_child != NULL || child-&gt;_irreducible) {
 853       follow_branches = false;
 854     }
 855     l = l-&gt;_next;
 856   }
 857   if (follow_branches) {
 858     loop-&gt;compute_profile_trip_cnt(this);
 859     if (head-&gt;is_profile_trip_failed()) {
 860       follow_branches = false;
 861     } else {
 862       loop_trip_cnt = head-&gt;profile_trip_cnt();
 863       if (head-&gt;is_CountedLoop()) {
 864         CountedLoopNode* cl = head-&gt;as_CountedLoop();
 865         if (cl-&gt;phi() != NULL) {
 866           const TypeInt* t = _igvn.type(cl-&gt;phi())-&gt;is_int();
 867           float worst_case_trip_cnt = ((float)t-&gt;_hi - t-&gt;_lo) / ABS(cl-&gt;stride_con());
 868           if (worst_case_trip_cnt &lt; loop_trip_cnt) {
 869             loop_trip_cnt = worst_case_trip_cnt;
 870           }
 871         }
 872       }
 873     }
 874   }
 875   return follow_branches;
 876 }
 877 
 878 // Compute probability of reaching some CFG node from a fixed
 879 // dominating CFG node
 880 class PathFrequency {
 881 private:
 882   Node* _dom; // frequencies are computed relative to this node
 883   Node_Stack _stack;
 884   GrowableArray&lt;float&gt; _freqs_stack; // keep track of intermediate result at regions
 885   GrowableArray&lt;float&gt; _freqs; // cache frequencies
 886   PhaseIdealLoop* _phase;
 887 
 888   void set_rounding(int mode) {
 889     // fesetround is broken on windows
 890     NOT_WINDOWS(fesetround(mode);)
 891   }
 892 
 893   void check_frequency(float f) {
 894     NOT_WINDOWS(assert(f &lt;= 1 &amp;&amp; f &gt;= 0, &quot;Incorrect frequency&quot;);)
 895   }
 896 
 897 public:
 898   PathFrequency(Node* dom, PhaseIdealLoop* phase)
 899     : _dom(dom), _stack(0), _phase(phase) {
 900   }
 901 
 902   float to(Node* n) {
 903     // post order walk on the CFG graph from n to _dom
 904     set_rounding(FE_TOWARDZERO); // make sure rounding doesn&#39;t push frequency above 1
 905     IdealLoopTree* loop = _phase-&gt;get_loop(_dom);
 906     Node* c = n;
 907     for (;;) {
 908       assert(_phase-&gt;get_loop(c) == loop, &quot;have to be in the same loop&quot;);
 909       if (c == _dom || _freqs.at_grow(c-&gt;_idx, -1) &gt;= 0) {
 910         float f = c == _dom ? 1 : _freqs.at(c-&gt;_idx);
 911         Node* prev = c;
 912         while (_stack.size() &gt; 0 &amp;&amp; prev == c) {
 913           Node* n = _stack.node();
 914           if (!n-&gt;is_Region()) {
 915             if (_phase-&gt;get_loop(n) != _phase-&gt;get_loop(n-&gt;in(0))) {
 916               // Found an inner loop: compute frequency of reaching this
 917               // exit from the loop head by looking at the number of
 918               // times each loop exit was taken
 919               IdealLoopTree* inner_loop = _phase-&gt;get_loop(n-&gt;in(0));
 920               LoopNode* inner_head = inner_loop-&gt;_head-&gt;as_Loop();
 921               assert(_phase-&gt;get_loop(n) == loop, &quot;only 1 inner loop&quot;);
 922               if (inner_head-&gt;is_OuterStripMinedLoop()) {
 923                 inner_head-&gt;verify_strip_mined(1);
 924                 if (n-&gt;in(0) == inner_head-&gt;in(LoopNode::LoopBackControl)-&gt;in(0)) {
 925                   n = n-&gt;in(0)-&gt;in(0)-&gt;in(0);
 926                 }
 927                 inner_loop = inner_loop-&gt;_child;
 928                 inner_head = inner_loop-&gt;_head-&gt;as_Loop();
 929                 inner_head-&gt;verify_strip_mined(1);
 930               }
 931               set_rounding(FE_UPWARD);  // make sure rounding doesn&#39;t push frequency above 1
 932               float loop_exit_cnt = 0.0f;
 933               for (uint i = 0; i &lt; inner_loop-&gt;_body.size(); i++) {
 934                 Node *n = inner_loop-&gt;_body[i];
 935                 float c = inner_loop-&gt;compute_profile_trip_cnt_helper(n);
 936                 loop_exit_cnt += c;
 937               }
 938               set_rounding(FE_TOWARDZERO);
 939               float cnt = -1;
 940               if (n-&gt;in(0)-&gt;is_If()) {
 941                 IfNode* iff = n-&gt;in(0)-&gt;as_If();
 942                 float p = n-&gt;in(0)-&gt;as_If()-&gt;_prob;
 943                 if (n-&gt;Opcode() == Op_IfFalse) {
 944                   p = 1 - p;
 945                 }
 946                 if (p &gt; PROB_MIN) {
 947                   cnt = p * iff-&gt;_fcnt;
 948                 } else {
 949                   cnt = 0;
 950                 }
 951               } else {
 952                 assert(n-&gt;in(0)-&gt;is_Jump(), &quot;unsupported node kind&quot;);
 953                 JumpNode* jmp = n-&gt;in(0)-&gt;as_Jump();
 954                 float p = n-&gt;in(0)-&gt;as_Jump()-&gt;_probs[n-&gt;as_JumpProj()-&gt;_con];
 955                 cnt = p * jmp-&gt;_fcnt;
 956               }
 957               float this_exit_f = cnt &gt; 0 ? cnt / loop_exit_cnt : 0;
 958               check_frequency(this_exit_f);
 959               f = f * this_exit_f;
 960               check_frequency(f);
 961             } else {
 962               float p = -1;
 963               if (n-&gt;in(0)-&gt;is_If()) {
 964                 p = n-&gt;in(0)-&gt;as_If()-&gt;_prob;
 965                 if (n-&gt;Opcode() == Op_IfFalse) {
 966                   p = 1 - p;
 967                 }
 968               } else {
 969                 assert(n-&gt;in(0)-&gt;is_Jump(), &quot;unsupported node kind&quot;);
 970                 p = n-&gt;in(0)-&gt;as_Jump()-&gt;_probs[n-&gt;as_JumpProj()-&gt;_con];
 971               }
 972               f = f * p;
 973               check_frequency(f);
 974             }
 975             _freqs.at_put_grow(n-&gt;_idx, (float)f, -1);
 976             _stack.pop();
 977           } else {
 978             float prev_f = _freqs_stack.pop();
 979             float new_f = f;
 980             f = new_f + prev_f;
 981             check_frequency(f);
 982             uint i = _stack.index();
 983             if (i &lt; n-&gt;req()) {
 984               c = n-&gt;in(i);
 985               _stack.set_index(i+1);
 986               _freqs_stack.push(f);
 987             } else {
 988               _freqs.at_put_grow(n-&gt;_idx, f, -1);
 989               _stack.pop();
 990             }
 991           }
 992         }
 993         if (_stack.size() == 0) {
 994           set_rounding(FE_TONEAREST);
 995           check_frequency(f);
 996           return f;
 997         }
 998       } else if (c-&gt;is_Loop()) {
 999         ShouldNotReachHere();
1000         c = c-&gt;in(LoopNode::EntryControl);
1001       } else if (c-&gt;is_Region()) {
1002         _freqs_stack.push(0);
1003         _stack.push(c, 2);
1004         c = c-&gt;in(1);
1005       } else {
1006         if (c-&gt;is_IfProj()) {
1007           IfNode* iff = c-&gt;in(0)-&gt;as_If();
1008           if (iff-&gt;_prob == PROB_UNKNOWN) {
1009             // assume never taken
1010             _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1011           } else if (_phase-&gt;get_loop(c) != _phase-&gt;get_loop(iff)) {
1012             if (iff-&gt;_fcnt == COUNT_UNKNOWN) {
1013               // assume never taken
1014               _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1015             } else {
1016               // skip over loop
1017               _stack.push(c, 1);
1018               c = _phase-&gt;get_loop(c-&gt;in(0))-&gt;_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1019             }
1020           } else {
1021             _stack.push(c, 1);
1022             c = iff;
1023           }
1024         } else if (c-&gt;is_JumpProj()) {
1025           JumpNode* jmp = c-&gt;in(0)-&gt;as_Jump();
1026           if (_phase-&gt;get_loop(c) != _phase-&gt;get_loop(jmp)) {
1027             if (jmp-&gt;_fcnt == COUNT_UNKNOWN) {
1028               // assume never taken
1029               _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1030             } else {
1031               // skip over loop
1032               _stack.push(c, 1);
1033               c = _phase-&gt;get_loop(c-&gt;in(0))-&gt;_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1034             }
1035           } else {
1036             _stack.push(c, 1);
1037             c = jmp;
1038           }
1039         } else if (c-&gt;Opcode() == Op_CatchProj &amp;&amp;
1040                    c-&gt;in(0)-&gt;Opcode() == Op_Catch &amp;&amp;
1041                    c-&gt;in(0)-&gt;in(0)-&gt;is_Proj() &amp;&amp;
1042                    c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;is_Call()) {
1043           // assume exceptions are never thrown
1044           uint con = c-&gt;as_Proj()-&gt;_con;
1045           if (con == CatchProjNode::fall_through_index) {
1046             Node* call = c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;in(0);
1047             if (_phase-&gt;get_loop(call) != _phase-&gt;get_loop(c)) {
1048               _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1049             } else {
1050               c = call;
1051             }
1052           } else {
1053             assert(con &gt;= CatchProjNode::catch_all_index, &quot;what else?&quot;);
1054             _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1055           }
1056         } else if (c-&gt;unique_ctrl_out() == NULL &amp;&amp; !c-&gt;is_If() &amp;&amp; !c-&gt;is_Jump()) {
1057           ShouldNotReachHere();
1058         } else {
1059           c = c-&gt;in(0);
1060         }
1061       }
1062     }
1063     ShouldNotReachHere();
1064     return -1;
1065   }
1066 };
1067 
1068 void PhaseIdealLoop::loop_predication_follow_branches(Node *n, IdealLoopTree *loop, float loop_trip_cnt,
1069                                                       PathFrequency&amp; pf, Node_Stack&amp; stack, VectorSet&amp; seen,
1070                                                       Node_List&amp; if_proj_list) {
1071   assert(n-&gt;is_Region(), &quot;start from a region&quot;);
1072   Node* tail = loop-&gt;tail();
1073   stack.push(n, 1);
1074   do {
1075     Node* c = stack.node();
1076     assert(c-&gt;is_Region() || c-&gt;is_IfProj(), &quot;only region here&quot;);
1077     uint i = stack.index();
1078 
1079     if (i &lt; c-&gt;req()) {
1080       stack.set_index(i+1);
1081       Node* in = c-&gt;in(i);
1082       while (!is_dominator(in, tail) &amp;&amp; !seen.test_set(in-&gt;_idx)) {
1083         IdealLoopTree* in_loop = get_loop(in);
1084         if (in_loop != loop) {
1085           in = in_loop-&gt;_head-&gt;in(LoopNode::EntryControl);
1086         } else if (in-&gt;is_Region()) {
1087           stack.push(in, 1);
1088           break;
1089         } else if (in-&gt;is_IfProj() &amp;&amp;
1090                    in-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1091                    (in-&gt;in(0)-&gt;Opcode() == Op_If ||
1092                     in-&gt;in(0)-&gt;Opcode() == Op_RangeCheck)) {
1093           if (pf.to(in) * loop_trip_cnt &gt;= 1) {
1094             stack.push(in, 1);
1095           }
1096           in = in-&gt;in(0);
1097         } else {
1098           in = in-&gt;in(0);
1099         }
1100       }
1101     } else {
1102       if (c-&gt;is_IfProj()) {
1103         if_proj_list.push(c);
1104       }
1105       stack.pop();
1106     }
1107 
1108   } while (stack.size() &gt; 0);
1109 }
1110 
1111 
1112 bool PhaseIdealLoop::loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* proj, ProjNode *predicate_proj,
1113                                                   CountedLoopNode *cl, ConNode* zero, Invariance&amp; invar,
1114                                                   Deoptimization::DeoptReason reason) {
1115   // Following are changed to nonnull when a predicate can be hoisted
1116   ProjNode* new_predicate_proj = NULL;
1117   IfNode*   iff  = proj-&gt;in(0)-&gt;as_If();
1118   Node*     test = iff-&gt;in(1);
1119   if (!test-&gt;is_Bool()){ //Conv2B, ...
1120     return false;
1121   }
1122   BoolNode* bol = test-&gt;as_Bool();
1123   if (invar.is_invariant(bol)) {
1124     // Invariant test
1125     new_predicate_proj = create_new_if_for_predicate(predicate_proj, NULL,
1126                                                      reason,
1127                                                      iff-&gt;Opcode());
1128     Node* ctrl = new_predicate_proj-&gt;in(0)-&gt;as_If()-&gt;in(0);
1129     BoolNode* new_predicate_bol = invar.clone(bol, ctrl)-&gt;as_Bool();
1130 
1131     // Negate test if necessary
1132     bool negated = false;
1133     if (proj-&gt;_con != predicate_proj-&gt;_con) {
1134       new_predicate_bol = new BoolNode(new_predicate_bol-&gt;in(1), new_predicate_bol-&gt;_test.negate());
1135       register_new_node(new_predicate_bol, ctrl);
1136       negated = true;
1137     }
1138     IfNode* new_predicate_iff = new_predicate_proj-&gt;in(0)-&gt;as_If();
1139     _igvn.hash_delete(new_predicate_iff);
1140     new_predicate_iff-&gt;set_req(1, new_predicate_bol);
1141 #ifndef PRODUCT
1142     if (TraceLoopPredicate) {
1143       tty-&gt;print(&quot;Predicate invariant if%s: %d &quot;, negated ? &quot; negated&quot; : &quot;&quot;, new_predicate_iff-&gt;_idx);
1144       loop-&gt;dump_head();
1145     } else if (TraceLoopOpts) {
1146       tty-&gt;print(&quot;Predicate IC &quot;);
1147       loop-&gt;dump_head();
1148     }
1149 #endif
1150   } else if (cl != NULL &amp;&amp; loop-&gt;is_range_check_if(iff, this, invar)) {
1151     // Range check for counted loops
1152     const Node*    cmp    = bol-&gt;in(1)-&gt;as_Cmp();
1153     Node*          idx    = cmp-&gt;in(1);
1154     assert(!invar.is_invariant(idx), &quot;index is variant&quot;);
1155     Node* rng = cmp-&gt;in(2);
1156     assert(rng-&gt;Opcode() == Op_LoadRange || iff-&gt;is_RangeCheck() || _igvn.type(rng)-&gt;is_int()-&gt;_lo &gt;= 0, &quot;must be&quot;);
1157     assert(invar.is_invariant(rng), &quot;range must be invariant&quot;);
1158     int scale    = 1;
1159     Node* offset = zero;
1160     bool ok = is_scaled_iv_plus_offset(idx, cl-&gt;phi(), &amp;scale, &amp;offset);
1161     assert(ok, &quot;must be index expression&quot;);
1162 
1163     Node* init    = cl-&gt;init_trip();
1164     // Limit is not exact.
1165     // Calculate exact limit here.
1166     // Note, counted loop&#39;s test is &#39;&lt;&#39; or &#39;&gt;&#39;.
1167     Node* limit   = exact_limit(loop);
1168     int  stride   = cl-&gt;stride()-&gt;get_int();
1169 
1170     // Build if&#39;s for the upper and lower bound tests.  The
1171     // lower_bound test will dominate the upper bound test and all
1172     // cloned or created nodes will use the lower bound test as
1173     // their declared control.
1174 
1175     // Perform cloning to keep Invariance state correct since the
1176     // late schedule will place invariant things in the loop.
1177     Node *ctrl = predicate_proj-&gt;in(0)-&gt;as_If()-&gt;in(0);
1178     rng = invar.clone(rng, ctrl);
1179     if (offset &amp;&amp; offset != zero) {
1180       assert(invar.is_invariant(offset), &quot;offset must be loop invariant&quot;);
1181       offset = invar.clone(offset, ctrl);
1182     }
1183     // If predicate expressions may overflow in the integer range, longs are used.
1184     bool overflow = false;
1185 
1186     // Test the lower bound
1187     BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow);
1188     // Negate test if necessary
1189     bool negated = false;
1190     if (proj-&gt;_con != predicate_proj-&gt;_con) {
1191       lower_bound_bol = new BoolNode(lower_bound_bol-&gt;in(1), lower_bound_bol-&gt;_test.negate());
1192       register_new_node(lower_bound_bol, ctrl);
1193       negated = true;
1194     }
1195     ProjNode* lower_bound_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1196     IfNode* lower_bound_iff = lower_bound_proj-&gt;in(0)-&gt;as_If();
1197     _igvn.hash_delete(lower_bound_iff);
1198     lower_bound_iff-&gt;set_req(1, lower_bound_bol);
1199     if (TraceLoopPredicate) tty-&gt;print_cr(&quot;lower bound check if: %s %d &quot;, negated ? &quot; negated&quot; : &quot;&quot;, lower_bound_iff-&gt;_idx);
1200 
1201     // Test the upper bound
1202     BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow);
1203     negated = false;
1204     if (proj-&gt;_con != predicate_proj-&gt;_con) {
1205       upper_bound_bol = new BoolNode(upper_bound_bol-&gt;in(1), upper_bound_bol-&gt;_test.negate());
1206       register_new_node(upper_bound_bol, ctrl);
1207       negated = true;
1208     }
1209     ProjNode* upper_bound_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1210     assert(upper_bound_proj-&gt;in(0)-&gt;as_If()-&gt;in(0) == lower_bound_proj, &quot;should dominate&quot;);
1211     IfNode* upper_bound_iff = upper_bound_proj-&gt;in(0)-&gt;as_If();
1212     _igvn.hash_delete(upper_bound_iff);
1213     upper_bound_iff-&gt;set_req(1, upper_bound_bol);
1214     if (TraceLoopPredicate) tty-&gt;print_cr(&quot;upper bound check if: %s %d &quot;, negated ? &quot; negated&quot; : &quot;&quot;, lower_bound_iff-&gt;_idx);
1215 
1216     // Fall through into rest of the clean up code which will move
1217     // any dependent nodes onto the upper bound test.
1218     new_predicate_proj = upper_bound_proj;
1219 
1220     if (iff-&gt;is_RangeCheck()) {
1221       new_predicate_proj = insert_initial_skeleton_predicate(iff, loop, proj, predicate_proj, upper_bound_proj, scale, offset, init, limit, stride, rng, overflow, reason);
1222     }
1223 
1224 #ifndef PRODUCT
1225     if (TraceLoopOpts &amp;&amp; !TraceLoopPredicate) {
1226       tty-&gt;print(&quot;Predicate RC &quot;);
1227       loop-&gt;dump_head();
1228     }
1229 #endif
1230   } else {
1231     // Loop variant check (for example, range check in non-counted loop)
1232     // with uncommon trap.
1233     return false;
1234   }
1235   assert(new_predicate_proj != NULL, &quot;sanity&quot;);
1236   // Success - attach condition (new_predicate_bol) to predicate if
1237   invar.map_ctrl(proj, new_predicate_proj); // so that invariance test can be appropriate
1238 
1239   // Eliminate the old If in the loop body
1240   dominated_by( new_predicate_proj, iff, proj-&gt;_con != new_predicate_proj-&gt;_con );
1241 
1242   C-&gt;set_major_progress();
1243   return true;
1244 }
1245 
1246 
1247 // After pre/main/post loops are created, we&#39;ll put a copy of some
1248 // range checks between the pre and main loop to validate the value
1249 // of the main loop induction variable. Make a copy of the predicates
1250 // here with an opaque node as a place holder for the value (will be
1251 // updated by PhaseIdealLoop::clone_skeleton_predicate()).
1252 ProjNode* PhaseIdealLoop::insert_initial_skeleton_predicate(IfNode* iff, IdealLoopTree *loop,
1253                                                             ProjNode* proj, ProjNode *predicate_proj,
1254                                                             ProjNode* upper_bound_proj,
1255                                                             int scale, Node* offset,
1256                                                             Node* init, Node* limit, jint stride,
1257                                                             Node* rng, bool &amp;overflow,
1258                                                             Deoptimization::DeoptReason reason) {
1259   assert(proj-&gt;_con &amp;&amp; predicate_proj-&gt;_con, &quot;not a range check?&quot;);
1260   Node* opaque_init = new Opaque1Node(C, init);
1261   register_new_node(opaque_init, upper_bound_proj);
1262   BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng, (stride &gt; 0) != (scale &gt; 0), overflow);
1263   Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1)); // This will go away once loop opts are over
1264   register_new_node(opaque_bol, upper_bound_proj);
1265   ProjNode* new_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1266   _igvn.replace_input_of(new_proj-&gt;in(0), 1, opaque_bol);
1267   assert(opaque_init-&gt;outcnt() &gt; 0, &quot;should be used&quot;);
1268   return new_proj;
1269 }
1270 
1271 //------------------------------ loop_predication_impl--------------------------
1272 // Insert loop predicates for null checks and range checks
1273 bool PhaseIdealLoop::loop_predication_impl(IdealLoopTree *loop) {
1274   if (!UseLoopPredicate) return false;
1275 
1276   if (!loop-&gt;_head-&gt;is_Loop()) {
1277     // Could be a simple region when irreducible loops are present.
1278     return false;
1279   }
1280   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
1281 
1282   if (head-&gt;unique_ctrl_out()-&gt;Opcode() == Op_NeverBranch) {
1283     // do nothing for infinite loops
1284     return false;
1285   }
1286 
1287   if (head-&gt;is_OuterStripMinedLoop()) {
1288     return false;
1289   }
1290 
1291   CountedLoopNode *cl = NULL;
1292   if (head-&gt;is_valid_counted_loop()) {
1293     cl = head-&gt;as_CountedLoop();
1294     // do nothing for iteration-splitted loops
1295     if (!cl-&gt;is_normal_loop()) return false;
1296     // Avoid RCE if Counted loop&#39;s test is &#39;!=&#39;.
1297     BoolTest::mask bt = cl-&gt;loopexit()-&gt;test_trip();
1298     if (bt != BoolTest::lt &amp;&amp; bt != BoolTest::gt)
1299       cl = NULL;
1300   }
1301 
1302   Node* entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1303   ProjNode *loop_limit_proj = NULL;
1304   ProjNode *predicate_proj = NULL;
1305   ProjNode *profile_predicate_proj = NULL;
1306   // Loop limit check predicate should be near the loop.
1307   loop_limit_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
1308   if (loop_limit_proj != NULL) {
1309     entry = skip_loop_predicates(loop_limit_proj);
1310   }
1311   bool has_profile_predicates = false;
1312   profile_predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
1313   if (profile_predicate_proj != NULL) {
1314     Node* n = skip_loop_predicates(entry);
1315     // Check if predicates were already added to the profile predicate
1316     // block
1317     if (n != entry-&gt;in(0)-&gt;in(0) || n-&gt;outcnt() != 1) {
1318       has_profile_predicates = true;
1319     }
1320     entry = n;
1321   }
1322   predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
1323 
1324   float loop_trip_cnt = -1;
1325   bool follow_branches = loop_predication_should_follow_branches(loop, profile_predicate_proj, loop_trip_cnt);
1326   assert(!follow_branches || loop_trip_cnt &gt;= 0, &quot;negative trip count?&quot;);
1327 
1328   if (predicate_proj == NULL &amp;&amp; !follow_branches) {
1329 #ifndef PRODUCT
1330     if (TraceLoopPredicate) {
1331       tty-&gt;print(&quot;missing predicate:&quot;);
1332       loop-&gt;dump_head();
1333       head-&gt;dump(1);
1334     }
1335 #endif
1336     return false;
1337   }
1338   ConNode* zero = _igvn.intcon(0);
1339   set_ctrl(zero, C-&gt;root());
1340 
1341   ResourceArea *area = Thread::current()-&gt;resource_area();
1342   Invariance invar(area, loop);
1343 
1344   // Create list of if-projs such that a newer proj dominates all older
1345   // projs in the list, and they all dominate loop-&gt;tail()
1346   Node_List if_proj_list(area);
1347   Node_List regions(area);
1348   Node *current_proj = loop-&gt;tail(); //start from tail
1349 
1350 
1351   Node_List controls(area);
1352   while (current_proj != head) {
1353     if (loop == get_loop(current_proj) &amp;&amp; // still in the loop ?
1354         current_proj-&gt;is_Proj()        &amp;&amp; // is a projection  ?
1355         (current_proj-&gt;in(0)-&gt;Opcode() == Op_If ||
1356          current_proj-&gt;in(0)-&gt;Opcode() == Op_RangeCheck)) { // is a if projection ?
1357       if_proj_list.push(current_proj);
1358     }
1359     if (follow_branches &amp;&amp;
1360         current_proj-&gt;Opcode() == Op_Region &amp;&amp;
1361         loop == get_loop(current_proj)) {
1362       regions.push(current_proj);
1363     }
1364     current_proj = idom(current_proj);
1365   }
1366 
1367   bool hoisted = false; // true if at least one proj is promoted
1368 
1369   if (!has_profile_predicates) {
1370     while (if_proj_list.size() &gt; 0) {
1371       Node* n = if_proj_list.pop();
1372 
1373       ProjNode* proj = n-&gt;as_Proj();
1374       IfNode*   iff  = proj-&gt;in(0)-&gt;as_If();
1375 
1376       CallStaticJavaNode* call = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1377       if (call == NULL) {
1378         if (loop-&gt;is_loop_exit(iff)) {
1379           // stop processing the remaining projs in the list because the execution of them
1380           // depends on the condition of &quot;iff&quot; (iff-&gt;in(1)).
1381           break;
1382         } else {
1383           // Both arms are inside the loop. There are two cases:
1384           // (1) there is one backward branch. In this case, any remaining proj
1385           //     in the if_proj list post-dominates &quot;iff&quot;. So, the condition of &quot;iff&quot;
1386           //     does not determine the execution the remining projs directly, and we
1387           //     can safely continue.
1388           // (2) both arms are forwarded, i.e. a diamond shape. In this case, &quot;proj&quot;
1389           //     does not dominate loop-&gt;tail(), so it can not be in the if_proj list.
1390           continue;
1391         }
1392       }
1393       Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(call-&gt;uncommon_trap_request());
1394       if (reason == Deoptimization::Reason_predicate) {
1395         break;
1396       }
1397 
1398       if (predicate_proj != NULL) {
1399         hoisted = loop_predication_impl_helper(loop, proj, predicate_proj, cl, zero, invar, Deoptimization::Reason_predicate) | hoisted;
1400       }
1401     } // end while
1402   }
1403 
1404   if (follow_branches) {
1405     PathFrequency pf(loop-&gt;_head, this);
1406 
1407     // Some projections were skipped by regular predicates because of
1408     // an early loop exit. Try them with profile data.
1409     while (if_proj_list.size() &gt; 0) {
1410       Node* proj = if_proj_list.pop();
1411       float f = pf.to(proj);
1412       if (proj-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1413           f * loop_trip_cnt &gt;= 1) {
1414         hoisted = loop_predication_impl_helper(loop, proj-&gt;as_Proj(), profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;
1415       }
1416     }
1417 
1418     // And look into all branches
1419     Node_Stack stack(0);
1420     VectorSet seen(Thread::current()-&gt;resource_area());
1421     Node_List if_proj_list_freq(area);
1422     while (regions.size() &gt; 0) {
1423       Node* c = regions.pop();
1424       loop_predication_follow_branches(c, loop, loop_trip_cnt, pf, stack, seen, if_proj_list_freq);
1425     }
1426 
1427     for (uint i = 0; i &lt; if_proj_list_freq.size(); i++) {
1428       ProjNode* proj = if_proj_list_freq.at(i)-&gt;as_Proj();
1429       hoisted = loop_predication_impl_helper(loop, proj, profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;
1430     }
1431   }
1432 
1433 #ifndef PRODUCT
1434   // report that the loop predication has been actually performed
1435   // for this loop
1436   if (TraceLoopPredicate &amp;&amp; hoisted) {
1437     tty-&gt;print(&quot;Loop Predication Performed:&quot;);
1438     loop-&gt;dump_head();
1439   }
1440 #endif
1441 
1442   head-&gt;verify_strip_mined(1);
1443 
1444   return hoisted;
1445 }
1446 
1447 //------------------------------loop_predication--------------------------------
1448 // driver routine for loop predication optimization
1449 bool IdealLoopTree::loop_predication( PhaseIdealLoop *phase) {
1450   bool hoisted = false;
1451   // Recursively promote predicates
1452   if (_child) {
1453     hoisted = _child-&gt;loop_predication( phase);
1454   }
1455 
1456   // self
1457   if (!_irreducible &amp;&amp; !tail()-&gt;is_top()) {
1458     hoisted |= phase-&gt;loop_predication_impl(this);
1459   }
1460 
1461   if (_next) { //sibling
1462     hoisted |= _next-&gt;loop_predication( phase);
1463   }
1464 
1465   return hoisted;
1466 }
    </pre>
  </body>
</html>
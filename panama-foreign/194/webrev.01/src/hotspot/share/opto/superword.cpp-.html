<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/superword.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;compiler/compileLog.hpp&quot;
  26 #include &quot;libadt/vectset.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;opto/addnode.hpp&quot;
  30 #include &quot;opto/callnode.hpp&quot;
  31 #include &quot;opto/castnode.hpp&quot;
  32 #include &quot;opto/convertnode.hpp&quot;
  33 #include &quot;opto/divnode.hpp&quot;
  34 #include &quot;opto/matcher.hpp&quot;
  35 #include &quot;opto/memnode.hpp&quot;
  36 #include &quot;opto/mulnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/opaquenode.hpp&quot;
  39 #include &quot;opto/superword.hpp&quot;
  40 #include &quot;opto/vectornode.hpp&quot;
  41 #include &quot;opto/movenode.hpp&quot;
  42 #include &quot;utilities/powerOfTwo.hpp&quot;
  43 
  44 //
  45 //                  S U P E R W O R D   T R A N S F O R M
  46 //=============================================================================
  47 
  48 //------------------------------SuperWord---------------------------
  49 SuperWord::SuperWord(PhaseIdealLoop* phase) :
  50   _phase(phase),
  51   _arena(phase-&gt;C-&gt;comp_arena()),
  52   _igvn(phase-&gt;_igvn),
  53   _packset(arena(), 8,  0, NULL),         // packs for the current block
  54   _bb_idx(arena(), (int)(1.10 * phase-&gt;C-&gt;unique()), 0, 0), // node idx to index in bb
  55   _block(arena(), 8,  0, NULL),           // nodes in current block
  56   _post_block(arena(), 8, 0, NULL),       // nodes common to current block which are marked as post loop vectorizable
  57   _data_entry(arena(), 8,  0, NULL),      // nodes with all inputs from outside
  58   _mem_slice_head(arena(), 8,  0, NULL),  // memory slice heads
  59   _mem_slice_tail(arena(), 8,  0, NULL),  // memory slice tails
  60   _node_info(arena(), 8,  0, SWNodeInfo::initial), // info needed per node
  61   _clone_map(phase-&gt;C-&gt;clone_map()),      // map of nodes created in cloning
  62   _cmovev_kit(_arena, this),              // map to facilitate CMoveV creation
  63   _align_to_ref(NULL),                    // memory reference to align vectors to
  64   _disjoint_ptrs(arena(), 8,  0, OrderedPair::initial), // runtime disambiguated pointer pairs
  65   _dg(_arena),                            // dependence graph
  66   _visited(arena()),                      // visited node set
  67   _post_visited(arena()),                 // post visited node set
  68   _n_idx_list(arena(), 8),                // scratch list of (node,index) pairs
  69   _nlist(arena(), 8, 0, NULL),            // scratch list of nodes
  70   _stk(arena(), 8, 0, NULL),              // scratch stack of nodes
  71   _lpt(NULL),                             // loop tree node
  72   _lp(NULL),                              // LoopNode
  73   _bb(NULL),                              // basic block
  74   _iv(NULL),                              // induction var
  75   _race_possible(false),                  // cases where SDMU is true
  76   _early_return(true),                    // analysis evaluations routine
  77   _do_vector_loop(phase-&gt;C-&gt;do_vector_loop()),  // whether to do vectorization/simd style
  78   _do_reserve_copy(DoReserveCopyInSuperWord),
  79   _num_work_vecs(0),                      // amount of vector work we have
  80   _num_reductions(0),                     // amount of reduction work we have
  81   _ii_first(-1),                          // first loop generation index - only if do_vector_loop()
  82   _ii_last(-1),                           // last loop generation index - only if do_vector_loop()
  83   _ii_order(arena(), 8, 0, 0)
  84 {
  85 #ifndef PRODUCT
  86   _vector_loop_debug = 0;
  87   if (_phase-&gt;C-&gt;method() != NULL) {
  88     _vector_loop_debug = phase-&gt;C-&gt;directive()-&gt;VectorizeDebugOption;
  89   }
  90 
  91 #endif
  92 }
  93 
  94 //------------------------------transform_loop---------------------------
  95 void SuperWord::transform_loop(IdealLoopTree* lpt, bool do_optimization) {
  96   assert(UseSuperWord, &quot;should be&quot;);
  97   // Do vectors exist on this architecture?
  98   if (Matcher::vector_width_in_bytes(T_BYTE) &lt; 2) return;
  99 
 100   assert(lpt-&gt;_head-&gt;is_CountedLoop(), &quot;must be&quot;);
 101   CountedLoopNode *cl = lpt-&gt;_head-&gt;as_CountedLoop();
 102 
 103   if (!cl-&gt;is_valid_counted_loop()) return; // skip malformed counted loop
 104 
 105   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 106   if (post_loop_allowed) {
 107     if (cl-&gt;is_reduction_loop()) return; // no predication mapping
 108     Node *limit = cl-&gt;limit();
 109     if (limit-&gt;is_Con()) return; // non constant limits only
 110     // Now check the limit for expressions we do not handle
 111     if (limit-&gt;is_Add()) {
 112       Node *in2 = limit-&gt;in(2);
 113       if (in2-&gt;is_Con()) {
 114         int val = in2-&gt;get_int();
 115         // should not try to program these cases
 116         if (val &lt; 0) return;
 117       }
 118     }
 119   }
 120 
 121   // skip any loop that has not been assigned max unroll by analysis
 122   if (do_optimization) {
 123     if (SuperWordLoopUnrollAnalysis &amp;&amp; cl-&gt;slp_max_unroll() == 0) return;
 124   }
 125 
 126   // Check for no control flow in body (other than exit)
 127   Node *cl_exit = cl-&gt;loopexit();
 128   if (cl-&gt;is_main_loop() &amp;&amp; (cl_exit-&gt;in(0) != lpt-&gt;_head)) {
 129     #ifndef PRODUCT
 130       if (TraceSuperWord) {
 131         tty-&gt;print_cr(&quot;SuperWord::transform_loop: loop too complicated, cl_exit-&gt;in(0) != lpt-&gt;_head&quot;);
 132         tty-&gt;print(&quot;cl_exit %d&quot;, cl_exit-&gt;_idx); cl_exit-&gt;dump();
 133         tty-&gt;print(&quot;cl_exit-&gt;in(0) %d&quot;, cl_exit-&gt;in(0)-&gt;_idx); cl_exit-&gt;in(0)-&gt;dump();
 134         tty-&gt;print(&quot;lpt-&gt;_head %d&quot;, lpt-&gt;_head-&gt;_idx); lpt-&gt;_head-&gt;dump();
 135         lpt-&gt;dump_head();
 136       }
 137     #endif
 138     return;
 139   }
 140 
 141   // Make sure the are no extra control users of the loop backedge
 142   if (cl-&gt;back_control()-&gt;outcnt() != 1) {
 143     return;
 144   }
 145 
 146   // Skip any loops already optimized by slp
 147   if (cl-&gt;is_vectorized_loop()) return;
 148 
 149   if (cl-&gt;is_unroll_only()) return;
 150 
 151   if (cl-&gt;is_main_loop()) {
 152     // Check for pre-loop ending with CountedLoopEnd(Bool(Cmp(x,Opaque1(limit))))
 153     CountedLoopEndNode* pre_end = get_pre_loop_end(cl);
 154     if (pre_end == NULL) return;
 155     Node *pre_opaq1 = pre_end-&gt;limit();
 156     if (pre_opaq1-&gt;Opcode() != Op_Opaque1) return;
 157   }
 158 
 159   init(); // initialize data structures
 160 
 161   set_lpt(lpt);
 162   set_lp(cl);
 163 
 164   // For now, define one block which is the entire loop body
 165   set_bb(cl);
 166 
 167   if (do_optimization) {
 168     assert(_packset.length() == 0, &quot;packset must be empty&quot;);
 169     SLP_extract();
 170     if (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors()) {
 171       if (cl-&gt;is_vectorized_loop() &amp;&amp; cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_reduction_loop()) {
 172         IdealLoopTree *lpt_next = lpt-&gt;_next;
 173         CountedLoopNode *cl_next = lpt_next-&gt;_head-&gt;as_CountedLoop();
 174         _phase-&gt;has_range_checks(lpt_next);
 175         if (cl_next-&gt;is_post_loop() &amp;&amp; !cl_next-&gt;range_checks_present()) {
 176           if (!cl_next-&gt;is_vectorized_loop()) {
 177             int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 178             cl_next-&gt;set_slp_max_unroll(slp_max_unroll_factor);
 179           }
 180         }
 181       }
 182     }
 183   }
 184 }
 185 
 186 //------------------------------early unrolling analysis------------------------------
 187 void SuperWord::unrolling_analysis(int &amp;local_loop_unroll_factor) {
 188   bool is_slp = true;
 189   ResourceMark rm;
 190   size_t ignored_size = lpt()-&gt;_body.size();
 191   int *ignored_loop_nodes = NEW_RESOURCE_ARRAY(int, ignored_size);
 192   Node_Stack nstack((int)ignored_size);
 193   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
 194   Node *cl_exit = cl-&gt;loopexit_or_null();
 195   int rpo_idx = _post_block.length();
 196 
 197   assert(rpo_idx == 0, &quot;post loop block is empty&quot;);
 198 
 199   // First clear the entries
 200   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 201     ignored_loop_nodes[i] = -1;
 202   }
 203 
 204   int max_vector = Matcher::max_vector_size(T_BYTE);
 205   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 206 
 207   // Process the loop, some/all of the stack entries will not be in order, ergo
 208   // need to preprocess the ignored initial state before we process the loop
 209   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 210     Node* n = lpt()-&gt;_body.at(i);
 211     if (n == cl-&gt;incr() ||
 212       n-&gt;is_reduction() ||
 213       n-&gt;is_AddP() ||
 214       n-&gt;is_Cmp() ||
 215       n-&gt;is_IfTrue() ||
 216       n-&gt;is_CountedLoop() ||
 217       (n == cl_exit)) {
 218       ignored_loop_nodes[i] = n-&gt;_idx;
 219       continue;
 220     }
 221 
 222     if (n-&gt;is_If()) {
 223       IfNode *iff = n-&gt;as_If();
 224       if (iff-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp; iff-&gt;_prob != PROB_UNKNOWN) {
 225         if (lpt()-&gt;is_loop_exit(iff)) {
 226           ignored_loop_nodes[i] = n-&gt;_idx;
 227           continue;
 228         }
 229       }
 230     }
 231 
 232     if (n-&gt;is_Phi() &amp;&amp; (n-&gt;bottom_type() == Type::MEMORY)) {
 233       Node* n_tail = n-&gt;in(LoopNode::LoopBackControl);
 234       if (n_tail != n-&gt;in(LoopNode::EntryControl)) {
 235         if (!n_tail-&gt;is_Mem()) {
 236           is_slp = false;
 237           break;
 238         }
 239       }
 240     }
 241 
 242     // This must happen after check of phi/if
 243     if (n-&gt;is_Phi() || n-&gt;is_If()) {
 244       ignored_loop_nodes[i] = n-&gt;_idx;
 245       continue;
 246     }
 247 
 248     if (n-&gt;is_LoadStore() || n-&gt;is_MergeMem() ||
 249       (n-&gt;is_Proj() &amp;&amp; !n-&gt;as_Proj()-&gt;is_CFG())) {
 250       is_slp = false;
 251       break;
 252     }
 253 
 254     // Ignore nodes with non-primitive type.
 255     BasicType bt;
 256     if (n-&gt;is_Mem()) {
 257       bt = n-&gt;as_Mem()-&gt;memory_type();
 258     } else {
 259       bt = n-&gt;bottom_type()-&gt;basic_type();
 260     }
 261     if (is_java_primitive(bt) == false) {
 262       ignored_loop_nodes[i] = n-&gt;_idx;
 263       continue;
 264     }
 265 
 266     if (n-&gt;is_Mem()) {
 267       MemNode* current = n-&gt;as_Mem();
 268       Node* adr = n-&gt;in(MemNode::Address);
 269       Node* n_ctrl = _phase-&gt;get_ctrl(adr);
 270 
 271       // save a queue of post process nodes
 272       if (n_ctrl != NULL &amp;&amp; lpt()-&gt;is_member(_phase-&gt;get_loop(n_ctrl))) {
 273         // Process the memory expression
 274         int stack_idx = 0;
 275         bool have_side_effects = true;
 276         if (adr-&gt;is_AddP() == false) {
 277           nstack.push(adr, stack_idx++);
 278         } else {
 279           // Mark the components of the memory operation in nstack
 280           SWPointer p1(current, this, &amp;nstack, true);
 281           have_side_effects = p1.node_stack()-&gt;is_nonempty();
 282         }
 283 
 284         // Process the pointer stack
 285         while (have_side_effects) {
 286           Node* pointer_node = nstack.node();
 287           for (uint j = 0; j &lt; lpt()-&gt;_body.size(); j++) {
 288             Node* cur_node = lpt()-&gt;_body.at(j);
 289             if (cur_node == pointer_node) {
 290               ignored_loop_nodes[j] = cur_node-&gt;_idx;
 291               break;
 292             }
 293           }
 294           nstack.pop();
 295           have_side_effects = nstack.is_nonempty();
 296         }
 297       }
 298     }
 299   }
 300 
 301   if (is_slp) {
 302     // Now we try to find the maximum supported consistent vector which the machine
 303     // description can use
 304     bool small_basic_type = false;
 305     bool flag_small_bt = false;
 306     for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 307       if (ignored_loop_nodes[i] != -1) continue;
 308 
 309       BasicType bt;
 310       Node* n = lpt()-&gt;_body.at(i);
 311       if (n-&gt;is_Mem()) {
 312         bt = n-&gt;as_Mem()-&gt;memory_type();
 313       } else {
 314         bt = n-&gt;bottom_type()-&gt;basic_type();
 315       }
 316 
 317       if (post_loop_allowed) {
 318         if (!small_basic_type) {
 319           switch (bt) {
 320           case T_CHAR:
 321           case T_BYTE:
 322           case T_SHORT:
 323             small_basic_type = true;
 324             break;
 325 
 326           case T_LONG:
 327             // TODO: Remove when support completed for mask context with LONG.
 328             //       Support needs to be augmented for logical qword operations, currently we map to dword
 329             //       buckets for vectors on logicals as these were legacy.
 330             small_basic_type = true;
 331             break;
 332 
 333           default:
 334             break;
 335           }
 336         }
 337       }
 338 
 339       if (is_java_primitive(bt) == false) continue;
 340 
 341          int cur_max_vector = Matcher::max_vector_size(bt);
 342 
 343       // If a max vector exists which is not larger than _local_loop_unroll_factor
 344       // stop looking, we already have the max vector to map to.
 345       if (cur_max_vector &lt; local_loop_unroll_factor) {
 346         is_slp = false;
 347         if (TraceSuperWordLoopUnrollAnalysis) {
 348           tty-&gt;print_cr(&quot;slp analysis fails: unroll limit greater than max vector\n&quot;);
 349         }
 350         break;
 351       }
 352 
 353       // Map the maximal common vector
 354       if (VectorNode::implemented(n-&gt;Opcode(), cur_max_vector, bt)) {
 355         if (cur_max_vector &lt; max_vector &amp;&amp; !flag_small_bt) {
 356           max_vector = cur_max_vector;
 357         } else if (cur_max_vector &gt; max_vector &amp;&amp; UseSubwordForMaxVector) {
 358           // Analyse subword in the loop to set maximum vector size to take advantage of full vector width for subword types.
 359           // Here we analyze if narrowing is likely to happen and if it is we set vector size more aggressively.
 360           // We check for possibility of narrowing by looking through chain operations using subword types.
 361           if (is_subword_type(bt)) {
 362             uint start, end;
 363             VectorNode::vector_operands(n, &amp;start, &amp;end);
 364 
 365             for (uint j = start; j &lt; end; j++) {
 366               Node* in = n-&gt;in(j);
 367               // Don&#39;t propagate through a memory
 368               if (!in-&gt;is_Mem() &amp;&amp; in_bb(in) &amp;&amp; in-&gt;bottom_type()-&gt;basic_type() == T_INT) {
 369                 bool same_type = true;
 370                 for (DUIterator_Fast kmax, k = in-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 371                   Node *use = in-&gt;fast_out(k);
 372                   if (!in_bb(use) &amp;&amp; use-&gt;bottom_type()-&gt;basic_type() != bt) {
 373                     same_type = false;
 374                     break;
 375                   }
 376                 }
 377                 if (same_type) {
 378                   max_vector = cur_max_vector;
 379                   flag_small_bt = true;
 380                   cl-&gt;mark_subword_loop();
 381                 }
 382               }
 383             }
 384           }
 385         }
 386         // We only process post loops on predicated targets where we want to
 387         // mask map the loop to a single iteration
 388         if (post_loop_allowed) {
 389           _post_block.at_put_grow(rpo_idx++, n);
 390         }
 391       }
 392     }
 393     if (is_slp) {
 394       local_loop_unroll_factor = max_vector;
 395       cl-&gt;mark_passed_slp();
 396     }
 397     cl-&gt;mark_was_slp();
 398     if (cl-&gt;is_main_loop()) {
 399       cl-&gt;set_slp_max_unroll(local_loop_unroll_factor);
 400     } else if (post_loop_allowed) {
 401       if (!small_basic_type) {
 402         // avoid replication context for small basic types in programmable masked loops
 403         cl-&gt;set_slp_max_unroll(local_loop_unroll_factor);
 404       }
 405     }
 406   }
 407 }
 408 
 409 //------------------------------SLP_extract---------------------------
 410 // Extract the superword level parallelism
 411 //
 412 // 1) A reverse post-order of nodes in the block is constructed.  By scanning
 413 //    this list from first to last, all definitions are visited before their uses.
 414 //
 415 // 2) A point-to-point dependence graph is constructed between memory references.
 416 //    This simplies the upcoming &quot;independence&quot; checker.
 417 //
 418 // 3) The maximum depth in the node graph from the beginning of the block
 419 //    to each node is computed.  This is used to prune the graph search
 420 //    in the independence checker.
 421 //
 422 // 4) For integer types, the necessary bit width is propagated backwards
 423 //    from stores to allow packed operations on byte, char, and short
 424 //    integers.  This reverses the promotion to type &quot;int&quot; that javac
 425 //    did for operations like: char c1,c2,c3;  c1 = c2 + c3.
 426 //
 427 // 5) One of the memory references is picked to be an aligned vector reference.
 428 //    The pre-loop trip count is adjusted to align this reference in the
 429 //    unrolled body.
 430 //
 431 // 6) The initial set of pack pairs is seeded with memory references.
 432 //
 433 // 7) The set of pack pairs is extended by following use-&gt;def and def-&gt;use links.
 434 //
 435 // 8) The pairs are combined into vector sized packs.
 436 //
 437 // 9) Reorder the memory slices to co-locate members of the memory packs.
 438 //
 439 // 10) Generate ideal vector nodes for the final set of packs and where necessary,
 440 //    inserting scalar promotion, vector creation from multiple scalars, and
 441 //    extraction of scalar values from vectors.
 442 //
 443 void SuperWord::SLP_extract() {
 444 
 445 #ifndef PRODUCT
 446   if (_do_vector_loop &amp;&amp; TraceSuperWord) {
 447     tty-&gt;print(&quot;SuperWord::SLP_extract\n&quot;);
 448     tty-&gt;print(&quot;input loop\n&quot;);
 449     _lpt-&gt;dump_head();
 450     _lpt-&gt;dump();
 451     for (uint i = 0; i &lt; _lpt-&gt;_body.size(); i++) {
 452       _lpt-&gt;_body.at(i)-&gt;dump();
 453     }
 454   }
 455 #endif
 456   // Ready the block
 457   if (!construct_bb()) {
 458     return; // Exit if no interesting nodes or complex graph.
 459   }
 460 
 461   // build    _dg, _disjoint_ptrs
 462   dependence_graph();
 463 
 464   // compute function depth(Node*)
 465   compute_max_depth();
 466 
 467   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
 468   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 469   if (cl-&gt;is_main_loop()) {
 470     if (_do_vector_loop) {
 471       if (mark_generations() != -1) {
 472         hoist_loads_in_graph(); // this only rebuild the graph; all basic structs need rebuild explicitly
 473 
 474         if (!construct_bb()) {
 475           return; // Exit if no interesting nodes or complex graph.
 476         }
 477         dependence_graph();
 478         compute_max_depth();
 479       }
 480 
 481 #ifndef PRODUCT
 482       if (TraceSuperWord) {
 483         tty-&gt;print_cr(&quot;\nSuperWord::_do_vector_loop: graph after hoist_loads_in_graph&quot;);
 484         _lpt-&gt;dump_head();
 485         for (int j = 0; j &lt; _block.length(); j++) {
 486           Node* n = _block.at(j);
 487           int d = depth(n);
 488           for (int i = 0; i &lt; d; i++) tty-&gt;print(&quot;%s&quot;, &quot;  &quot;);
 489           tty-&gt;print(&quot;%d :&quot;, d);
 490           n-&gt;dump();
 491         }
 492       }
 493 #endif
 494     }
 495 
 496     compute_vector_element_type();
 497 
 498     // Attempt vectorization
 499 
 500     find_adjacent_refs();
 501 
 502     extend_packlist();
 503 
 504     if (_do_vector_loop) {
 505       if (_packset.length() == 0) {
 506         if (TraceSuperWord) {
 507           tty-&gt;print_cr(&quot;\nSuperWord::_do_vector_loop DFA could not build packset, now trying to build anyway&quot;);
 508         }
 509         pack_parallel();
 510       }
 511     }
 512 
 513     combine_packs();
 514 
 515     construct_my_pack_map();
 516     if (UseVectorCmov) {
 517       merge_packs_to_cmovd();
 518     }
 519 
 520     filter_packs();
 521 
 522     schedule();
 523   } else if (post_loop_allowed) {
 524     int saved_mapped_unroll_factor = cl-&gt;slp_max_unroll();
 525     if (saved_mapped_unroll_factor) {
 526       int vector_mapped_unroll_factor = saved_mapped_unroll_factor;
 527 
 528       // now reset the slp_unroll_factor so that we can check the analysis mapped
 529       // what the vector loop was mapped to
 530       cl-&gt;set_slp_max_unroll(0);
 531 
 532       // do the analysis on the post loop
 533       unrolling_analysis(vector_mapped_unroll_factor);
 534 
 535       // if our analyzed loop is a canonical fit, start processing it
 536       if (vector_mapped_unroll_factor == saved_mapped_unroll_factor) {
 537         // now add the vector nodes to packsets
 538         for (int i = 0; i &lt; _post_block.length(); i++) {
 539           Node* n = _post_block.at(i);
 540           Node_List* singleton = new Node_List();
 541           singleton-&gt;push(n);
 542           _packset.append(singleton);
 543           set_my_pack(n, singleton);
 544         }
 545 
 546         // map base types for vector usage
 547         compute_vector_element_type();
 548       } else {
 549         return;
 550       }
 551     } else {
 552       // for some reason we could not map the slp analysis state of the vectorized loop
 553       return;
 554     }
 555   }
 556 
 557   output();
 558 }
 559 
 560 //------------------------------find_adjacent_refs---------------------------
 561 // Find the adjacent memory references and create pack pairs for them.
 562 // This is the initial set of packs that will then be extended by
 563 // following use-&gt;def and def-&gt;use links.  The align positions are
 564 // assigned relative to the reference &quot;align_to_ref&quot;
 565 void SuperWord::find_adjacent_refs() {
 566   // Get list of memory operations
 567   Node_List memops;
 568   for (int i = 0; i &lt; _block.length(); i++) {
 569     Node* n = _block.at(i);
 570     if (n-&gt;is_Mem() &amp;&amp; !n-&gt;is_LoadStore() &amp;&amp; in_bb(n) &amp;&amp;
 571         is_java_primitive(n-&gt;as_Mem()-&gt;memory_type())) {
 572       int align = memory_alignment(n-&gt;as_Mem(), 0);
 573       if (align != bottom_align) {
 574         memops.push(n);
 575       }
 576     }
 577   }
 578 
 579   Node_List align_to_refs;
 580   int max_idx;
 581   int best_iv_adjustment = 0;
 582   MemNode* best_align_to_mem_ref = NULL;
 583 
 584   while (memops.size() != 0) {
 585     // Find a memory reference to align to.
 586     MemNode* mem_ref = find_align_to_ref(memops, max_idx);
 587     if (mem_ref == NULL) break;
 588     align_to_refs.push(mem_ref);
 589     int iv_adjustment = get_iv_adjustment(mem_ref);
 590 
 591     if (best_align_to_mem_ref == NULL) {
 592       // Set memory reference which is the best from all memory operations
 593       // to be used for alignment. The pre-loop trip count is modified to align
 594       // this reference to a vector-aligned address.
 595       best_align_to_mem_ref = mem_ref;
 596       best_iv_adjustment = iv_adjustment;
 597       NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 598     }
 599 
 600     SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 601     // Set alignment relative to &quot;align_to_ref&quot; for all related memory operations.
 602     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 603       MemNode* s = memops.at(i)-&gt;as_Mem();
 604       if (isomorphic(s, mem_ref) &amp;&amp;
 605            (!_do_vector_loop || same_origin_idx(s, mem_ref))) {
 606         SWPointer p2(s, this, NULL, false);
 607         if (p2.comparable(align_to_ref_p)) {
 608           int align = memory_alignment(s, iv_adjustment);
 609           set_alignment(s, align);
 610         }
 611       }
 612     }
 613 
 614     // Create initial pack pairs of memory operations for which
 615     // alignment is set and vectors will be aligned.
 616     bool create_pack = true;
 617     if (memory_alignment(mem_ref, best_iv_adjustment) == 0 || _do_vector_loop) {
 618       if (!Matcher::misaligned_vectors_ok() || AlignVector) {
 619         int vw = vector_width(mem_ref);
 620         int vw_best = vector_width(best_align_to_mem_ref);
 621         if (vw &gt; vw_best) {
 622           // Do not vectorize a memory access with more elements per vector
 623           // if unaligned memory access is not allowed because number of
 624           // iterations in pre-loop will be not enough to align it.
 625           create_pack = false;
 626         } else {
 627           SWPointer p2(best_align_to_mem_ref, this, NULL, false);
 628           if (align_to_ref_p.invar() != p2.invar()) {
 629             // Do not vectorize memory accesses with different invariants
 630             // if unaligned memory accesses are not allowed.
 631             create_pack = false;
 632           }
 633         }
 634       }
 635     } else {
 636       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 637         // Can&#39;t allow vectorization of unaligned memory accesses with the
 638         // same type since it could be overlapped accesses to the same array.
 639         create_pack = false;
 640       } else {
 641         // Allow independent (different type) unaligned memory operations
 642         // if HW supports them.
 643         if (!Matcher::misaligned_vectors_ok() || AlignVector) {
 644           create_pack = false;
 645         } else {
 646           // Check if packs of the same memory type but
 647           // with a different alignment were created before.
 648           for (uint i = 0; i &lt; align_to_refs.size(); i++) {
 649             MemNode* mr = align_to_refs.at(i)-&gt;as_Mem();
 650             if (mr == mem_ref) {
 651               // Skip when we are looking at same memory operation.
 652               continue;
 653             }
 654             if (same_velt_type(mr, mem_ref) &amp;&amp;
 655                 memory_alignment(mr, iv_adjustment) != 0)
 656               create_pack = false;
 657           }
 658         }
 659       }
 660     }
 661     if (create_pack) {
 662       for (uint i = 0; i &lt; memops.size(); i++) {
 663         Node* s1 = memops.at(i);
 664         int align = alignment(s1);
 665         if (align == top_align) continue;
 666         for (uint j = 0; j &lt; memops.size(); j++) {
 667           Node* s2 = memops.at(j);
 668           if (alignment(s2) == top_align) continue;
 669           if (s1 != s2 &amp;&amp; are_adjacent_refs(s1, s2)) {
 670             if (stmts_can_pack(s1, s2, align)) {
 671               Node_List* pair = new Node_List();
 672               pair-&gt;push(s1);
 673               pair-&gt;push(s2);
 674               if (!_do_vector_loop || same_origin_idx(s1, s2)) {
 675                 _packset.append(pair);
 676               }
 677             }
 678           }
 679         }
 680       }
 681     } else { // Don&#39;t create unaligned pack
 682       // First, remove remaining memory ops of the same type from the list.
 683       for (int i = memops.size() - 1; i &gt;= 0; i--) {
 684         MemNode* s = memops.at(i)-&gt;as_Mem();
 685         if (same_velt_type(s, mem_ref)) {
 686           memops.remove(i);
 687         }
 688       }
 689 
 690       // Second, remove already constructed packs of the same type.
 691       for (int i = _packset.length() - 1; i &gt;= 0; i--) {
 692         Node_List* p = _packset.at(i);
 693         MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 694         if (same_velt_type(s, mem_ref)) {
 695           remove_pack_at(i);
 696         }
 697       }
 698 
 699       // If needed find the best memory reference for loop alignment again.
 700       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 701         // Put memory ops from remaining packs back on memops list for
 702         // the best alignment search.
 703         uint orig_msize = memops.size();
 704         for (int i = 0; i &lt; _packset.length(); i++) {
 705           Node_List* p = _packset.at(i);
 706           MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 707           assert(!same_velt_type(s, mem_ref), &quot;sanity&quot;);
 708           memops.push(s);
 709         }
 710         best_align_to_mem_ref = find_align_to_ref(memops, max_idx);
 711         if (best_align_to_mem_ref == NULL) {
 712           if (TraceSuperWord) {
 713             tty-&gt;print_cr(&quot;SuperWord::find_adjacent_refs(): best_align_to_mem_ref == NULL&quot;);
 714           }
 715           // best_align_to_mem_ref will be used for adjusting the pre-loop limit in
 716           // SuperWord::align_initial_loop_index. Find one with the biggest vector size,
 717           // smallest data size and smallest iv offset from memory ops from remaining packs.
 718           if (_packset.length() &gt; 0) {
 719             if (orig_msize == 0) {
 720               best_align_to_mem_ref = memops.at(max_idx)-&gt;as_Mem();
 721             } else {
 722               for (uint i = 0; i &lt; orig_msize; i++) {
 723                 memops.remove(0);
 724               }
 725               best_align_to_mem_ref = find_align_to_ref(memops, max_idx);
 726               assert(best_align_to_mem_ref == NULL, &quot;sanity&quot;);
 727               best_align_to_mem_ref = memops.at(max_idx)-&gt;as_Mem();
 728             }
 729             assert(best_align_to_mem_ref != NULL, &quot;sanity&quot;);
 730           }
 731           break;
 732         }
 733         best_iv_adjustment = get_iv_adjustment(best_align_to_mem_ref);
 734         NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 735         // Restore list.
 736         while (memops.size() &gt; orig_msize)
 737           (void)memops.pop();
 738       }
 739     } // unaligned memory accesses
 740 
 741     // Remove used mem nodes.
 742     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 743       MemNode* m = memops.at(i)-&gt;as_Mem();
 744       if (alignment(m) != top_align) {
 745         memops.remove(i);
 746       }
 747     }
 748 
 749   } // while (memops.size() != 0
 750   set_align_to_ref(best_align_to_mem_ref);
 751 
 752   if (TraceSuperWord) {
 753     tty-&gt;print_cr(&quot;\nAfter find_adjacent_refs&quot;);
 754     print_packset();
 755   }
 756 }
 757 
 758 #ifndef PRODUCT
 759 void SuperWord::find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment) {
 760   if (is_trace_adjacent()) {
 761     tty-&gt;print(&quot;SuperWord::find_adjacent_refs best_align_to_mem_ref = %d, best_iv_adjustment = %d&quot;,
 762        best_align_to_mem_ref-&gt;_idx, best_iv_adjustment);
 763        best_align_to_mem_ref-&gt;dump();
 764   }
 765 }
 766 #endif
 767 
 768 //------------------------------find_align_to_ref---------------------------
 769 // Find a memory reference to align the loop induction variable to.
 770 // Looks first at stores then at loads, looking for a memory reference
 771 // with the largest number of references similar to it.
 772 MemNode* SuperWord::find_align_to_ref(Node_List &amp;memops, int &amp;idx) {
 773   GrowableArray&lt;int&gt; cmp_ct(arena(), memops.size(), memops.size(), 0);
 774 
 775   // Count number of comparable memory ops
 776   for (uint i = 0; i &lt; memops.size(); i++) {
 777     MemNode* s1 = memops.at(i)-&gt;as_Mem();
 778     SWPointer p1(s1, this, NULL, false);
 779     // Discard if pre loop can&#39;t align this reference
 780     if (!ref_is_alignable(p1)) {
 781       *cmp_ct.adr_at(i) = 0;
 782       continue;
 783     }
 784     for (uint j = i+1; j &lt; memops.size(); j++) {
 785       MemNode* s2 = memops.at(j)-&gt;as_Mem();
 786       if (isomorphic(s1, s2)) {
 787         SWPointer p2(s2, this, NULL, false);
 788         if (p1.comparable(p2)) {
 789           (*cmp_ct.adr_at(i))++;
 790           (*cmp_ct.adr_at(j))++;
 791         }
 792       }
 793     }
 794   }
 795 
 796   // Find Store (or Load) with the greatest number of &quot;comparable&quot; references,
 797   // biggest vector size, smallest data size and smallest iv offset.
 798   int max_ct        = 0;
 799   int max_vw        = 0;
 800   int max_idx       = -1;
 801   int min_size      = max_jint;
 802   int min_iv_offset = max_jint;
 803   for (uint j = 0; j &lt; memops.size(); j++) {
 804     MemNode* s = memops.at(j)-&gt;as_Mem();
 805     if (s-&gt;is_Store()) {
 806       int vw = vector_width_in_bytes(s);
 807       assert(vw &gt; 1, &quot;sanity&quot;);
 808       SWPointer p(s, this, NULL, false);
 809       if ( cmp_ct.at(j) &gt;  max_ct ||
 810           (cmp_ct.at(j) == max_ct &amp;&amp;
 811             ( vw &gt;  max_vw ||
 812              (vw == max_vw &amp;&amp;
 813               ( data_size(s) &lt;  min_size ||
 814                (data_size(s) == min_size &amp;&amp;
 815                 p.offset_in_bytes() &lt; min_iv_offset)))))) {
 816         max_ct = cmp_ct.at(j);
 817         max_vw = vw;
 818         max_idx = j;
 819         min_size = data_size(s);
 820         min_iv_offset = p.offset_in_bytes();
 821       }
 822     }
 823   }
 824   // If no stores, look at loads
 825   if (max_ct == 0) {
 826     for (uint j = 0; j &lt; memops.size(); j++) {
 827       MemNode* s = memops.at(j)-&gt;as_Mem();
 828       if (s-&gt;is_Load()) {
 829         int vw = vector_width_in_bytes(s);
 830         assert(vw &gt; 1, &quot;sanity&quot;);
 831         SWPointer p(s, this, NULL, false);
 832         if ( cmp_ct.at(j) &gt;  max_ct ||
 833             (cmp_ct.at(j) == max_ct &amp;&amp;
 834               ( vw &gt;  max_vw ||
 835                (vw == max_vw &amp;&amp;
 836                 ( data_size(s) &lt;  min_size ||
 837                  (data_size(s) == min_size &amp;&amp;
 838                   p.offset_in_bytes() &lt; min_iv_offset)))))) {
 839           max_ct = cmp_ct.at(j);
 840           max_vw = vw;
 841           max_idx = j;
 842           min_size = data_size(s);
 843           min_iv_offset = p.offset_in_bytes();
 844         }
 845       }
 846     }
 847   }
 848 
 849 #ifdef ASSERT
 850   if (TraceSuperWord &amp;&amp; Verbose) {
 851     tty-&gt;print_cr(&quot;\nVector memops after find_align_to_ref&quot;);
 852     for (uint i = 0; i &lt; memops.size(); i++) {
 853       MemNode* s = memops.at(i)-&gt;as_Mem();
 854       s-&gt;dump();
 855     }
 856   }
 857 #endif
 858 
 859   idx = max_idx;
 860   if (max_ct &gt; 0) {
 861 #ifdef ASSERT
 862     if (TraceSuperWord) {
 863       tty-&gt;print(&quot;\nVector align to node: &quot;);
 864       memops.at(max_idx)-&gt;as_Mem()-&gt;dump();
 865     }
 866 #endif
 867     return memops.at(max_idx)-&gt;as_Mem();
 868   }
 869   return NULL;
 870 }
 871 
 872 //------------------span_works_for_memory_size-----------------------------
 873 static bool span_works_for_memory_size(MemNode* mem, int span, int mem_size, int offset) {
 874   bool span_matches_memory = false;
 875   if ((mem_size == type2aelembytes(T_BYTE) || mem_size == type2aelembytes(T_SHORT))
 876     &amp;&amp; ABS(span) == type2aelembytes(T_INT)) {
 877     // There is a mismatch on span size compared to memory.
 878     for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 879       Node* use = mem-&gt;fast_out(j);
 880       if (!VectorNode::is_type_transition_to_int(use)) {
 881         return false;
 882       }
 883     }
 884     // If all uses transition to integer, it means that we can successfully align even on mismatch.
 885     return true;
 886   }
 887   else {
 888     span_matches_memory = ABS(span) == mem_size;
 889   }
 890   return span_matches_memory &amp;&amp; (ABS(offset) % mem_size) == 0;
 891 }
 892 
 893 //------------------------------ref_is_alignable---------------------------
 894 // Can the preloop align the reference to position zero in the vector?
 895 bool SuperWord::ref_is_alignable(SWPointer&amp; p) {
 896   if (!p.has_iv()) {
 897     return true;   // no induction variable
 898   }
 899   CountedLoopEndNode* pre_end = get_pre_loop_end(lp()-&gt;as_CountedLoop());
 900   assert(pre_end != NULL, &quot;we must have a correct pre-loop&quot;);
 901   assert(pre_end-&gt;stride_is_con(), &quot;pre loop stride is constant&quot;);
 902   int preloop_stride = pre_end-&gt;stride_con();
 903 
 904   int span = preloop_stride * p.scale_in_bytes();
 905   int mem_size = p.memory_size();
 906   int offset   = p.offset_in_bytes();
 907   // Stride one accesses are alignable if offset is aligned to memory operation size.
 908   // Offset can be unaligned when UseUnalignedAccesses is used.
 909   if (span_works_for_memory_size(p.mem(), span, mem_size, offset)) {
 910     return true;
 911   }
 912   // If the initial offset from start of the object is computable,
 913   // check if the pre-loop can align the final offset accordingly.
 914   //
 915   // In other words: Can we find an i such that the offset
 916   // after i pre-loop iterations is aligned to vw?
 917   //   (init_offset + pre_loop) % vw == 0              (1)
 918   // where
 919   //   pre_loop = i * span
 920   // is the number of bytes added to the offset by i pre-loop iterations.
 921   //
 922   // For this to hold we need pre_loop to increase init_offset by
 923   //   pre_loop = vw - (init_offset % vw)
 924   //
 925   // This is only possible if pre_loop is divisible by span because each
 926   // pre-loop iteration increases the initial offset by &#39;span&#39; bytes:
 927   //   (vw - (init_offset % vw)) % span == 0
 928   //
 929   int vw = vector_width_in_bytes(p.mem());
 930   assert(vw &gt; 1, &quot;sanity&quot;);
 931   Node* init_nd = pre_end-&gt;init_trip();
 932   if (init_nd-&gt;is_Con() &amp;&amp; p.invar() == NULL) {
 933     int init = init_nd-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
 934     int init_offset = init * p.scale_in_bytes() + offset;
 935     if (init_offset &lt; 0) { // negative offset from object start?
 936       return false;        // may happen in dead loop
 937     }
 938     if (vw % span == 0) {
 939       // If vm is a multiple of span, we use formula (1).
 940       if (span &gt; 0) {
 941         return (vw - (init_offset % vw)) % span == 0;
 942       } else {
 943         assert(span &lt; 0, &quot;nonzero stride * scale&quot;);
 944         return (init_offset % vw) % -span == 0;
 945       }
 946     } else if (span % vw == 0) {
 947       // If span is a multiple of vw, we can simplify formula (1) to:
 948       //   (init_offset + i * span) % vw == 0
 949       //     =&gt;
 950       //   (init_offset % vw) + ((i * span) % vw) == 0
 951       //     =&gt;
 952       //   init_offset % vw == 0
 953       //
 954       // Because we add a multiple of vw to the initial offset, the final
 955       // offset is a multiple of vw if and only if init_offset is a multiple.
 956       //
 957       return (init_offset % vw) == 0;
 958     }
 959   }
 960   return false;
 961 }
 962 //---------------------------get_vw_bytes_special------------------------
 963 int SuperWord::get_vw_bytes_special(MemNode* s) {
 964   // Get the vector width in bytes.
 965   int vw = vector_width_in_bytes(s);
 966 
 967   // Check for special case where there is an MulAddS2I usage where short vectors are going to need combined.
 968   BasicType btype = velt_basic_type(s);
 969   if (type2aelembytes(btype) == 2) {
 970     bool should_combine_adjacent = true;
 971     for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); i &lt; imax; i++) {
 972       Node* user = s-&gt;fast_out(i);
 973       if (!VectorNode::is_muladds2i(user)) {
 974         should_combine_adjacent = false;
 975       }
 976     }
 977     if (should_combine_adjacent) {
 978       vw = MIN2(Matcher::max_vector_size(btype)*type2aelembytes(btype), vw * 2);
 979     }
 980   }
 981 
 982   return vw;
 983 }
 984 
 985 //---------------------------get_iv_adjustment---------------------------
 986 // Calculate loop&#39;s iv adjustment for this memory ops.
 987 int SuperWord::get_iv_adjustment(MemNode* mem_ref) {
 988   SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 989   int offset = align_to_ref_p.offset_in_bytes();
 990   int scale  = align_to_ref_p.scale_in_bytes();
 991   int elt_size = align_to_ref_p.memory_size();
 992   int vw       = get_vw_bytes_special(mem_ref);
 993   assert(vw &gt; 1, &quot;sanity&quot;);
 994   int iv_adjustment;
 995   if (scale != 0) {
 996     int stride_sign = (scale * iv_stride()) &gt; 0 ? 1 : -1;
 997     // At least one iteration is executed in pre-loop by default. As result
 998     // several iterations are needed to align memory operations in main-loop even
 999     // if offset is 0.
1000     int iv_adjustment_in_bytes = (stride_sign * vw - (offset % vw));
1001     assert(((ABS(iv_adjustment_in_bytes) % elt_size) == 0),
1002            &quot;(%d) should be divisible by (%d)&quot;, iv_adjustment_in_bytes, elt_size);
1003     iv_adjustment = iv_adjustment_in_bytes/elt_size;
1004   } else {
1005     // This memory op is not dependent on iv (scale == 0)
1006     iv_adjustment = 0;
1007   }
1008 
1009 #ifndef PRODUCT
1010   if (TraceSuperWord) {
1011     tty-&gt;print(&quot;SuperWord::get_iv_adjustment: n = %d, noffset = %d iv_adjust = %d elt_size = %d scale = %d iv_stride = %d vect_size %d: &quot;,
1012       mem_ref-&gt;_idx, offset, iv_adjustment, elt_size, scale, iv_stride(), vw);
1013     mem_ref-&gt;dump();
1014   }
1015 #endif
1016   return iv_adjustment;
1017 }
1018 
1019 //---------------------------dependence_graph---------------------------
1020 // Construct dependency graph.
1021 // Add dependence edges to load/store nodes for memory dependence
1022 //    A.out()-&gt;DependNode.in(1) and DependNode.out()-&gt;B.prec(x)
1023 void SuperWord::dependence_graph() {
1024   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
1025   // First, assign a dependence node to each memory node
1026   for (int i = 0; i &lt; _block.length(); i++ ) {
1027     Node *n = _block.at(i);
1028     if (n-&gt;is_Mem() || (n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY)) {
1029       _dg.make_node(n);
1030     }
1031   }
1032 
1033   // For each memory slice, create the dependences
1034   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
1035     Node* n      = _mem_slice_head.at(i);
1036     Node* n_tail = _mem_slice_tail.at(i);
1037 
1038     // Get slice in predecessor order (last is first)
1039     if (cl-&gt;is_main_loop()) {
1040       mem_slice_preds(n_tail, n, _nlist);
1041     }
1042 
1043 #ifndef PRODUCT
1044     if(TraceSuperWord &amp;&amp; Verbose) {
1045       tty-&gt;print_cr(&quot;SuperWord::dependence_graph: built a new mem slice&quot;);
1046       for (int j = _nlist.length() - 1; j &gt;= 0 ; j--) {
1047         _nlist.at(j)-&gt;dump();
1048       }
1049     }
1050 #endif
1051     // Make the slice dependent on the root
1052     DepMem* slice = _dg.dep(n);
1053     _dg.make_edge(_dg.root(), slice);
1054 
1055     // Create a sink for the slice
1056     DepMem* slice_sink = _dg.make_node(NULL);
1057     _dg.make_edge(slice_sink, _dg.tail());
1058 
1059     // Now visit each pair of memory ops, creating the edges
1060     for (int j = _nlist.length() - 1; j &gt;= 0 ; j--) {
1061       Node* s1 = _nlist.at(j);
1062 
1063       // If no dependency yet, use slice
1064       if (_dg.dep(s1)-&gt;in_cnt() == 0) {
1065         _dg.make_edge(slice, s1);
1066       }
1067       SWPointer p1(s1-&gt;as_Mem(), this, NULL, false);
1068       bool sink_dependent = true;
1069       for (int k = j - 1; k &gt;= 0; k--) {
1070         Node* s2 = _nlist.at(k);
1071         if (s1-&gt;is_Load() &amp;&amp; s2-&gt;is_Load())
1072           continue;
1073         SWPointer p2(s2-&gt;as_Mem(), this, NULL, false);
1074 
1075         int cmp = p1.cmp(p2);
1076         if (SuperWordRTDepCheck &amp;&amp;
1077             p1.base() != p2.base() &amp;&amp; p1.valid() &amp;&amp; p2.valid()) {
1078           // Create a runtime check to disambiguate
1079           OrderedPair pp(p1.base(), p2.base());
1080           _disjoint_ptrs.append_if_missing(pp);
1081         } else if (!SWPointer::not_equal(cmp)) {
1082           // Possibly same address
1083           _dg.make_edge(s1, s2);
1084           sink_dependent = false;
1085         }
1086       }
1087       if (sink_dependent) {
1088         _dg.make_edge(s1, slice_sink);
1089       }
1090     }
1091 
1092     if (TraceSuperWord) {
1093       tty-&gt;print_cr(&quot;\nDependence graph for slice: %d&quot;, n-&gt;_idx);
1094       for (int q = 0; q &lt; _nlist.length(); q++) {
1095         _dg.print(_nlist.at(q));
1096       }
1097       tty-&gt;cr();
1098     }
1099 
1100     _nlist.clear();
1101   }
1102 
1103   if (TraceSuperWord) {
1104     tty-&gt;print_cr(&quot;\ndisjoint_ptrs: %s&quot;, _disjoint_ptrs.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
1105     for (int r = 0; r &lt; _disjoint_ptrs.length(); r++) {
1106       _disjoint_ptrs.at(r).print();
1107       tty-&gt;cr();
1108     }
1109     tty-&gt;cr();
1110   }
1111 
1112 }
1113 
1114 //---------------------------mem_slice_preds---------------------------
1115 // Return a memory slice (node list) in predecessor order starting at &quot;start&quot;
1116 void SuperWord::mem_slice_preds(Node* start, Node* stop, GrowableArray&lt;Node*&gt; &amp;preds) {
1117   assert(preds.length() == 0, &quot;start empty&quot;);
1118   Node* n = start;
1119   Node* prev = NULL;
1120   while (true) {
1121     NOT_PRODUCT( if(is_trace_mem_slice()) tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: n %d&quot;, n-&gt;_idx);)
1122     assert(in_bb(n), &quot;must be in block&quot;);
1123     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1124       Node* out = n-&gt;fast_out(i);
1125       if (out-&gt;is_Load()) {
1126         if (in_bb(out)) {
1127           preds.push(out);
1128           if (TraceSuperWord &amp;&amp; Verbose) {
1129             tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: added pred(%d)&quot;, out-&gt;_idx);
1130           }
1131         }
1132       } else {
1133         // FIXME
1134         if (out-&gt;is_MergeMem() &amp;&amp; !in_bb(out)) {
1135           // Either unrolling is causing a memory edge not to disappear,
1136           // or need to run igvn.optimize() again before SLP
1137         } else if (out-&gt;is_Phi() &amp;&amp; out-&gt;bottom_type() == Type::MEMORY &amp;&amp; !in_bb(out)) {
1138           // Ditto.  Not sure what else to check further.
1139         } else if (out-&gt;Opcode() == Op_StoreCM &amp;&amp; out-&gt;in(MemNode::OopStore) == n) {
1140           // StoreCM has an input edge used as a precedence edge.
1141           // Maybe an issue when oop stores are vectorized.
1142         } else {
1143           assert(out == prev || prev == NULL, &quot;no branches off of store slice&quot;);
1144         }
1145       }//else
1146     }//for
1147     if (n == stop) break;
1148     preds.push(n);
1149     if (TraceSuperWord &amp;&amp; Verbose) {
1150       tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: added pred(%d)&quot;, n-&gt;_idx);
1151     }
1152     prev = n;
1153     assert(n-&gt;is_Mem(), &quot;unexpected node %s&quot;, n-&gt;Name());
1154     n = n-&gt;in(MemNode::Memory);
1155   }
1156 }
1157 
1158 //------------------------------stmts_can_pack---------------------------
1159 // Can s1 and s2 be in a pack with s1 immediately preceding s2 and
1160 // s1 aligned at &quot;align&quot;
1161 bool SuperWord::stmts_can_pack(Node* s1, Node* s2, int align) {
1162 
1163   // Do not use superword for non-primitives
1164   BasicType bt1 = velt_basic_type(s1);
1165   BasicType bt2 = velt_basic_type(s2);
1166   if(!is_java_primitive(bt1) || !is_java_primitive(bt2))
1167     return false;
1168   if (Matcher::max_vector_size(bt1) &lt; 2) {
1169     return false; // No vectors for this type
1170   }
1171 
1172   if (isomorphic(s1, s2)) {
1173     if ((independent(s1, s2) &amp;&amp; have_similar_inputs(s1, s2)) || reduction(s1, s2)) {
1174       if (!exists_at(s1, 0) &amp;&amp; !exists_at(s2, 1)) {
1175         if (!s1-&gt;is_Mem() || are_adjacent_refs(s1, s2)) {
1176           int s1_align = alignment(s1);
1177           int s2_align = alignment(s2);
1178           if (s1_align == top_align || s1_align == align) {
1179             if (s2_align == top_align || s2_align == align + data_size(s1)) {
1180               return true;
1181             }
1182           }
1183         }
1184       }
1185     }
1186   }
1187   return false;
1188 }
1189 
1190 //------------------------------exists_at---------------------------
1191 // Does s exist in a pack at position pos?
1192 bool SuperWord::exists_at(Node* s, uint pos) {
1193   for (int i = 0; i &lt; _packset.length(); i++) {
1194     Node_List* p = _packset.at(i);
1195     if (p-&gt;at(pos) == s) {
1196       return true;
1197     }
1198   }
1199   return false;
1200 }
1201 
1202 //------------------------------are_adjacent_refs---------------------------
1203 // Is s1 immediately before s2 in memory?
1204 bool SuperWord::are_adjacent_refs(Node* s1, Node* s2) {
1205   if (!s1-&gt;is_Mem() || !s2-&gt;is_Mem()) return false;
1206   if (!in_bb(s1)    || !in_bb(s2))    return false;
1207 
1208   // Do not use superword for non-primitives
1209   if (!is_java_primitive(s1-&gt;as_Mem()-&gt;memory_type()) ||
1210       !is_java_primitive(s2-&gt;as_Mem()-&gt;memory_type())) {
1211     return false;
1212   }
1213 
1214   // FIXME - co_locate_pack fails on Stores in different mem-slices, so
1215   // only pack memops that are in the same alias set until that&#39;s fixed.
1216   if (_phase-&gt;C-&gt;get_alias_index(s1-&gt;as_Mem()-&gt;adr_type()) !=
1217       _phase-&gt;C-&gt;get_alias_index(s2-&gt;as_Mem()-&gt;adr_type()))
1218     return false;
1219   SWPointer p1(s1-&gt;as_Mem(), this, NULL, false);
1220   SWPointer p2(s2-&gt;as_Mem(), this, NULL, false);
1221   if (p1.base() != p2.base() || !p1.comparable(p2)) return false;
1222   int diff = p2.offset_in_bytes() - p1.offset_in_bytes();
1223   return diff == data_size(s1);
1224 }
1225 
1226 //------------------------------isomorphic---------------------------
1227 // Are s1 and s2 similar?
1228 bool SuperWord::isomorphic(Node* s1, Node* s2) {
1229   if (s1-&gt;Opcode() != s2-&gt;Opcode()) return false;
1230   if (s1-&gt;req() != s2-&gt;req()) return false;
1231   if (!same_velt_type(s1, s2)) return false;
1232   Node* s1_ctrl = s1-&gt;in(0);
1233   Node* s2_ctrl = s2-&gt;in(0);
1234   // If the control nodes are equivalent, no further checks are required to test for isomorphism.
1235   if (s1_ctrl == s2_ctrl) {
1236     return true;
1237   } else {
1238     bool s1_ctrl_inv = ((s1_ctrl == NULL) ? true : lpt()-&gt;is_invariant(s1_ctrl));
1239     bool s2_ctrl_inv = ((s2_ctrl == NULL) ? true : lpt()-&gt;is_invariant(s2_ctrl));
1240     // If the control nodes are not invariant for the loop, fail isomorphism test.
1241     if (!s1_ctrl_inv || !s2_ctrl_inv) {
1242       return false;
1243     }
1244     if(s1_ctrl != NULL &amp;&amp; s2_ctrl != NULL) {
1245       if (s1_ctrl-&gt;is_Proj()) {
1246         s1_ctrl = s1_ctrl-&gt;in(0);
1247         assert(lpt()-&gt;is_invariant(s1_ctrl), &quot;must be invariant&quot;);
1248       }
1249       if (s2_ctrl-&gt;is_Proj()) {
1250         s2_ctrl = s2_ctrl-&gt;in(0);
1251         assert(lpt()-&gt;is_invariant(s2_ctrl), &quot;must be invariant&quot;);
1252       }
1253       if (!s1_ctrl-&gt;is_RangeCheck() || !s2_ctrl-&gt;is_RangeCheck()) {
1254         return false;
1255       }
1256     }
1257     // Control nodes are invariant. However, we have no way of checking whether they resolve
1258     // in an equivalent manner. But, we know that invariant range checks are guaranteed to
1259     // throw before the loop (if they would have thrown). Thus, the loop would not have been reached.
1260     // Therefore, if the control nodes for both are range checks, we accept them to be isomorphic.
1261     for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1262       Node* t1 = s1-&gt;fast_out(i);
1263       for (DUIterator_Fast jmax, j = s2-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1264         Node* t2 = s2-&gt;fast_out(j);
1265         if (VectorNode::is_muladds2i(t1) &amp;&amp; VectorNode::is_muladds2i(t2)) {
1266           return true;
1267         }
1268       }
1269     }
1270   }
1271   return false;
1272 }
1273 
1274 //------------------------------independent---------------------------
1275 // Is there no data path from s1 to s2 or s2 to s1?
1276 bool SuperWord::independent(Node* s1, Node* s2) {
1277   //  assert(s1-&gt;Opcode() == s2-&gt;Opcode(), &quot;check isomorphic first&quot;);
1278   int d1 = depth(s1);
1279   int d2 = depth(s2);
1280   if (d1 == d2) return s1 != s2;
1281   Node* deep    = d1 &gt; d2 ? s1 : s2;
1282   Node* shallow = d1 &gt; d2 ? s2 : s1;
1283 
1284   visited_clear();
1285 
1286   return independent_path(shallow, deep);
1287 }
1288 
1289 //--------------------------have_similar_inputs-----------------------
1290 // For a node pair (s1, s2) which is isomorphic and independent,
1291 // do s1 and s2 have similar input edges?
1292 bool SuperWord::have_similar_inputs(Node* s1, Node* s2) {
1293   // assert(isomorphic(s1, s2) == true, &quot;check isomorphic&quot;);
1294   // assert(independent(s1, s2) == true, &quot;check independent&quot;);
1295   if (s1-&gt;req() &gt; 1 &amp;&amp; !s1-&gt;is_Store() &amp;&amp; !s1-&gt;is_Load()) {
1296     for (uint i = 1; i &lt; s1-&gt;req(); i++) {
1297       if (s1-&gt;in(i)-&gt;Opcode() != s2-&gt;in(i)-&gt;Opcode()) return false;
1298     }
1299   }
1300   return true;
1301 }
1302 
1303 //------------------------------reduction---------------------------
1304 // Is there a data path between s1 and s2 and the nodes reductions?
1305 bool SuperWord::reduction(Node* s1, Node* s2) {
1306   bool retValue = false;
1307   int d1 = depth(s1);
1308   int d2 = depth(s2);
1309   if (d1 + 1 == d2) {
1310     if (s1-&gt;is_reduction() &amp;&amp; s2-&gt;is_reduction()) {
1311       // This is an ordered set, so s1 should define s2
1312       for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1313         Node* t1 = s1-&gt;fast_out(i);
1314         if (t1 == s2) {
1315           // both nodes are reductions and connected
1316           retValue = true;
1317         }
1318       }
1319     }
1320   }
1321 
1322   return retValue;
1323 }
1324 
1325 //------------------------------independent_path------------------------------
1326 // Helper for independent
1327 bool SuperWord::independent_path(Node* shallow, Node* deep, uint dp) {
1328   if (dp &gt;= 1000) return false; // stop deep recursion
1329   visited_set(deep);
1330   int shal_depth = depth(shallow);
1331   assert(shal_depth &lt;= depth(deep), &quot;must be&quot;);
1332   for (DepPreds preds(deep, _dg); !preds.done(); preds.next()) {
1333     Node* pred = preds.current();
1334     if (in_bb(pred) &amp;&amp; !visited_test(pred)) {
1335       if (shallow == pred) {
1336         return false;
1337       }
1338       if (shal_depth &lt; depth(pred) &amp;&amp; !independent_path(shallow, pred, dp+1)) {
1339         return false;
1340       }
1341     }
1342   }
1343   return true;
1344 }
1345 
1346 //------------------------------set_alignment---------------------------
1347 void SuperWord::set_alignment(Node* s1, Node* s2, int align) {
1348   set_alignment(s1, align);
1349   if (align == top_align || align == bottom_align) {
1350     set_alignment(s2, align);
1351   } else {
1352     set_alignment(s2, align + data_size(s1));
1353   }
1354 }
1355 
1356 //------------------------------data_size---------------------------
1357 int SuperWord::data_size(Node* s) {
1358   Node* use = NULL; //test if the node is a candidate for CMoveV optimization, then return the size of CMov
1359   if (UseVectorCmov) {
1360     use = _cmovev_kit.is_Bool_candidate(s);
1361     if (use != NULL) {
1362       return data_size(use);
1363     }
1364     use = _cmovev_kit.is_CmpD_candidate(s);
1365     if (use != NULL) {
1366       return data_size(use);
1367     }
1368   }
1369 
1370   int bsize = type2aelembytes(velt_basic_type(s));
1371   assert(bsize != 0, &quot;valid size&quot;);
1372   return bsize;
1373 }
1374 
1375 //------------------------------extend_packlist---------------------------
1376 // Extend packset by following use-&gt;def and def-&gt;use links from pack members.
1377 void SuperWord::extend_packlist() {
1378   bool changed;
1379   do {
1380     packset_sort(_packset.length());
1381     changed = false;
1382     for (int i = 0; i &lt; _packset.length(); i++) {
1383       Node_List* p = _packset.at(i);
1384       changed |= follow_use_defs(p);
1385       changed |= follow_def_uses(p);
1386     }
1387   } while (changed);
1388 
1389   if (_race_possible) {
1390     for (int i = 0; i &lt; _packset.length(); i++) {
1391       Node_List* p = _packset.at(i);
1392       order_def_uses(p);
1393     }
1394   }
1395 
1396   if (TraceSuperWord) {
1397     tty-&gt;print_cr(&quot;\nAfter extend_packlist&quot;);
1398     print_packset();
1399   }
1400 }
1401 
1402 //------------------------------follow_use_defs---------------------------
1403 // Extend the packset by visiting operand definitions of nodes in pack p
1404 bool SuperWord::follow_use_defs(Node_List* p) {
1405   assert(p-&gt;size() == 2, &quot;just checking&quot;);
1406   Node* s1 = p-&gt;at(0);
1407   Node* s2 = p-&gt;at(1);
1408   assert(s1-&gt;req() == s2-&gt;req(), &quot;just checking&quot;);
1409   assert(alignment(s1) + data_size(s1) == alignment(s2), &quot;just checking&quot;);
1410 
1411   if (s1-&gt;is_Load()) return false;
1412 
1413   int align = alignment(s1);
1414   NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_use_defs: s1 %d, align %d&quot;, s1-&gt;_idx, align);)
1415   bool changed = false;
1416   int start = s1-&gt;is_Store() ? MemNode::ValueIn   : 1;
1417   int end   = s1-&gt;is_Store() ? MemNode::ValueIn+1 : s1-&gt;req();
1418   for (int j = start; j &lt; end; j++) {
1419     Node* t1 = s1-&gt;in(j);
1420     Node* t2 = s2-&gt;in(j);
1421     if (!in_bb(t1) || !in_bb(t2))
1422       continue;
1423     if (stmts_can_pack(t1, t2, align)) {
1424       if (est_savings(t1, t2) &gt;= 0) {
1425         Node_List* pair = new Node_List();
1426         pair-&gt;push(t1);
1427         pair-&gt;push(t2);
1428         _packset.append(pair);
1429         NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_use_defs: set_alignment(%d, %d, %d)&quot;, t1-&gt;_idx, t2-&gt;_idx, align);)
1430         set_alignment(t1, t2, align);
1431         changed = true;
1432       }
1433     }
1434   }
1435   return changed;
1436 }
1437 
1438 //------------------------------follow_def_uses---------------------------
1439 // Extend the packset by visiting uses of nodes in pack p
1440 bool SuperWord::follow_def_uses(Node_List* p) {
1441   bool changed = false;
1442   Node* s1 = p-&gt;at(0);
1443   Node* s2 = p-&gt;at(1);
1444   assert(p-&gt;size() == 2, &quot;just checking&quot;);
1445   assert(s1-&gt;req() == s2-&gt;req(), &quot;just checking&quot;);
1446   assert(alignment(s1) + data_size(s1) == alignment(s2), &quot;just checking&quot;);
1447 
1448   if (s1-&gt;is_Store()) return false;
1449 
1450   int align = alignment(s1);
1451   NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_def_uses: s1 %d, align %d&quot;, s1-&gt;_idx, align);)
1452   int savings = -1;
1453   int num_s1_uses = 0;
1454   Node* u1 = NULL;
1455   Node* u2 = NULL;
1456   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1457     Node* t1 = s1-&gt;fast_out(i);
1458     num_s1_uses++;
1459     if (!in_bb(t1)) continue;
1460     for (DUIterator_Fast jmax, j = s2-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1461       Node* t2 = s2-&gt;fast_out(j);
1462       if (!in_bb(t2)) continue;
1463       if (t2-&gt;Opcode() == Op_AddI &amp;&amp; t2 == _lp-&gt;as_CountedLoop()-&gt;incr()) continue; // don&#39;t mess with the iv
1464       if (!opnd_positions_match(s1, t1, s2, t2))
1465         continue;
1466       if (stmts_can_pack(t1, t2, align)) {
1467         int my_savings = est_savings(t1, t2);
1468         if (my_savings &gt; savings) {
1469           savings = my_savings;
1470           u1 = t1;
1471           u2 = t2;
1472         }
1473       }
1474     }
1475   }
1476   if (num_s1_uses &gt; 1) {
1477     _race_possible = true;
1478   }
1479   if (savings &gt;= 0) {
1480     Node_List* pair = new Node_List();
1481     pair-&gt;push(u1);
1482     pair-&gt;push(u2);
1483     _packset.append(pair);
1484     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_def_uses: set_alignment(%d, %d, %d)&quot;, u1-&gt;_idx, u2-&gt;_idx, align);)
1485     set_alignment(u1, u2, align);
1486     changed = true;
1487   }
1488   return changed;
1489 }
1490 
1491 //------------------------------order_def_uses---------------------------
1492 // For extended packsets, ordinally arrange uses packset by major component
1493 void SuperWord::order_def_uses(Node_List* p) {
1494   Node* s1 = p-&gt;at(0);
1495 
1496   if (s1-&gt;is_Store()) return;
1497 
1498   // reductions are always managed beforehand
1499   if (s1-&gt;is_reduction()) return;
1500 
1501   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1502     Node* t1 = s1-&gt;fast_out(i);
1503 
1504     // Only allow operand swap on commuting operations
1505     if (!t1-&gt;is_Add() &amp;&amp; !t1-&gt;is_Mul() &amp;&amp; !VectorNode::is_muladds2i(t1)) {
1506       break;
1507     }
1508 
1509     // Now find t1&#39;s packset
1510     Node_List* p2 = NULL;
1511     for (int j = 0; j &lt; _packset.length(); j++) {
1512       p2 = _packset.at(j);
1513       Node* first = p2-&gt;at(0);
1514       if (t1 == first) {
1515         break;
1516       }
1517       p2 = NULL;
1518     }
1519     // Arrange all sub components by the major component
1520     if (p2 != NULL) {
1521       for (uint j = 1; j &lt; p-&gt;size(); j++) {
1522         Node* d1 = p-&gt;at(j);
1523         Node* u1 = p2-&gt;at(j);
1524         opnd_positions_match(s1, t1, d1, u1);
1525       }
1526     }
1527   }
1528 }
1529 
1530 //---------------------------opnd_positions_match-------------------------
1531 // Is the use of d1 in u1 at the same operand position as d2 in u2?
1532 bool SuperWord::opnd_positions_match(Node* d1, Node* u1, Node* d2, Node* u2) {
1533   // check reductions to see if they are marshalled to represent the reduction
1534   // operator in a specified opnd
1535   if (u1-&gt;is_reduction() &amp;&amp; u2-&gt;is_reduction()) {
1536     // ensure reductions have phis and reduction definitions feeding the 1st operand
1537     Node* first = u1-&gt;in(2);
1538     if (first-&gt;is_Phi() || first-&gt;is_reduction()) {
1539       u1-&gt;swap_edges(1, 2);
1540     }
1541     // ensure reductions have phis and reduction definitions feeding the 1st operand
1542     first = u2-&gt;in(2);
1543     if (first-&gt;is_Phi() || first-&gt;is_reduction()) {
1544       u2-&gt;swap_edges(1, 2);
1545     }
1546     return true;
1547   }
1548 
1549   uint ct = u1-&gt;req();
1550   if (ct != u2-&gt;req()) return false;
1551   uint i1 = 0;
1552   uint i2 = 0;
1553   do {
1554     for (i1++; i1 &lt; ct; i1++) if (u1-&gt;in(i1) == d1) break;
1555     for (i2++; i2 &lt; ct; i2++) if (u2-&gt;in(i2) == d2) break;
1556     if (i1 != i2) {
1557       if ((i1 == (3-i2)) &amp;&amp; (u2-&gt;is_Add() || u2-&gt;is_Mul())) {
1558         // Further analysis relies on operands position matching.
1559         u2-&gt;swap_edges(i1, i2);
1560       } else if (VectorNode::is_muladds2i(u2) &amp;&amp; u1 != u2) {
1561         if (i1 == 5 - i2) { // ((i1 == 3 &amp;&amp; i2 == 2) || (i1 == 2 &amp;&amp; i2 == 3) || (i1 == 1 &amp;&amp; i2 == 4) || (i1 == 4 &amp;&amp; i2 == 1))
1562           u2-&gt;swap_edges(1, 2);
1563           u2-&gt;swap_edges(3, 4);
1564         }
1565         if (i1 == 3 - i2 || i1 == 7 - i2) { // ((i1 == 1 &amp;&amp; i2 == 2) || (i1 == 2 &amp;&amp; i2 == 1) || (i1 == 3 &amp;&amp; i2 == 4) || (i1 == 4 &amp;&amp; i2 == 3))
1566           u2-&gt;swap_edges(2, 3);
1567           u2-&gt;swap_edges(1, 4);
1568         }
1569         return false; // Just swap the edges, the muladds2i nodes get packed in follow_use_defs
1570       } else {
1571         return false;
1572       }
1573     } else if (i1 == i2 &amp;&amp; VectorNode::is_muladds2i(u2) &amp;&amp; u1 != u2) {
1574       u2-&gt;swap_edges(1, 3);
1575       u2-&gt;swap_edges(2, 4);
1576       return false; // Just swap the edges, the muladds2i nodes get packed in follow_use_defs
1577     }
1578   } while (i1 &lt; ct);
1579   return true;
1580 }
1581 
1582 //------------------------------est_savings---------------------------
1583 // Estimate the savings from executing s1 and s2 as a pack
1584 int SuperWord::est_savings(Node* s1, Node* s2) {
1585   int save_in = 2 - 1; // 2 operations per instruction in packed form
1586 
1587   // inputs
1588   for (uint i = 1; i &lt; s1-&gt;req(); i++) {
1589     Node* x1 = s1-&gt;in(i);
1590     Node* x2 = s2-&gt;in(i);
1591     if (x1 != x2) {
1592       if (are_adjacent_refs(x1, x2)) {
1593         save_in += adjacent_profit(x1, x2);
1594       } else if (!in_packset(x1, x2)) {
1595         save_in -= pack_cost(2);
1596       } else {
1597         save_in += unpack_cost(2);
1598       }
1599     }
1600   }
1601 
1602   // uses of result
1603   uint ct = 0;
1604   int save_use = 0;
1605   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1606     Node* s1_use = s1-&gt;fast_out(i);
1607     for (int j = 0; j &lt; _packset.length(); j++) {
1608       Node_List* p = _packset.at(j);
1609       if (p-&gt;at(0) == s1_use) {
1610         for (DUIterator_Fast kmax, k = s2-&gt;fast_outs(kmax); k &lt; kmax; k++) {
1611           Node* s2_use = s2-&gt;fast_out(k);
1612           if (p-&gt;at(p-&gt;size()-1) == s2_use) {
1613             ct++;
1614             if (are_adjacent_refs(s1_use, s2_use)) {
1615               save_use += adjacent_profit(s1_use, s2_use);
1616             }
1617           }
1618         }
1619       }
1620     }
1621   }
1622 
1623   if (ct &lt; s1-&gt;outcnt()) save_use += unpack_cost(1);
1624   if (ct &lt; s2-&gt;outcnt()) save_use += unpack_cost(1);
1625 
1626   return MAX2(save_in, save_use);
1627 }
1628 
1629 //------------------------------costs---------------------------
1630 int SuperWord::adjacent_profit(Node* s1, Node* s2) { return 2; }
1631 int SuperWord::pack_cost(int ct)   { return ct; }
1632 int SuperWord::unpack_cost(int ct) { return ct; }
1633 
1634 //------------------------------combine_packs---------------------------
1635 // Combine packs A and B with A.last == B.first into A.first..,A.last,B.second,..B.last
1636 void SuperWord::combine_packs() {
1637   bool changed = true;
1638   // Combine packs regardless max vector size.
1639   while (changed) {
1640     changed = false;
1641     for (int i = 0; i &lt; _packset.length(); i++) {
1642       Node_List* p1 = _packset.at(i);
1643       if (p1 == NULL) continue;
1644       // Because of sorting we can start at i + 1
1645       for (int j = i + 1; j &lt; _packset.length(); j++) {
1646         Node_List* p2 = _packset.at(j);
1647         if (p2 == NULL) continue;
1648         if (i == j) continue;
1649         if (p1-&gt;at(p1-&gt;size()-1) == p2-&gt;at(0)) {
1650           for (uint k = 1; k &lt; p2-&gt;size(); k++) {
1651             p1-&gt;push(p2-&gt;at(k));
1652           }
1653           _packset.at_put(j, NULL);
1654           changed = true;
1655         }
1656       }
1657     }
1658   }
1659 
1660   // Split packs which have size greater then max vector size.
1661   for (int i = 0; i &lt; _packset.length(); i++) {
1662     Node_List* p1 = _packset.at(i);
1663     if (p1 != NULL) {
1664       BasicType bt = velt_basic_type(p1-&gt;at(0));
1665       uint max_vlen = Matcher::max_vector_size(bt); // Max elements in vector
1666       assert(is_power_of_2(max_vlen), &quot;sanity&quot;);
1667       uint psize = p1-&gt;size();
1668       if (!is_power_of_2(psize)) {
1669         // Skip pack which can&#39;t be vector.
1670         // case1: for(...) { a[i] = i; }    elements values are different (i+x)
1671         // case2: for(...) { a[i] = b[i+1]; }  can&#39;t align both, load and store
1672         _packset.at_put(i, NULL);
1673         continue;
1674       }
1675       if (psize &gt; max_vlen) {
1676         Node_List* pack = new Node_List();
1677         for (uint j = 0; j &lt; psize; j++) {
1678           pack-&gt;push(p1-&gt;at(j));
1679           if (pack-&gt;size() &gt;= max_vlen) {
1680             assert(is_power_of_2(pack-&gt;size()), &quot;sanity&quot;);
1681             _packset.append(pack);
1682             pack = new Node_List();
1683           }
1684         }
1685         _packset.at_put(i, NULL);
1686       }
1687     }
1688   }
1689 
1690   // Compress list.
1691   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1692     Node_List* p1 = _packset.at(i);
1693     if (p1 == NULL) {
1694       _packset.remove_at(i);
1695     }
1696   }
1697 
1698   if (TraceSuperWord) {
1699     tty-&gt;print_cr(&quot;\nAfter combine_packs&quot;);
1700     print_packset();
1701   }
1702 }
1703 
1704 //-----------------------------construct_my_pack_map--------------------------
1705 // Construct the map from nodes to packs.  Only valid after the
1706 // point where a node is only in one pack (after combine_packs).
1707 void SuperWord::construct_my_pack_map() {
1708   Node_List* rslt = NULL;
1709   for (int i = 0; i &lt; _packset.length(); i++) {
1710     Node_List* p = _packset.at(i);
1711     for (uint j = 0; j &lt; p-&gt;size(); j++) {
1712       Node* s = p-&gt;at(j);
1713       assert(my_pack(s) == NULL, &quot;only in one pack&quot;);
1714       set_my_pack(s, p);
1715     }
1716   }
1717 }
1718 
1719 //------------------------------filter_packs---------------------------
1720 // Remove packs that are not implemented or not profitable.
1721 void SuperWord::filter_packs() {
1722   // Remove packs that are not implemented
1723   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1724     Node_List* pk = _packset.at(i);
1725     bool impl = implemented(pk);
1726     if (!impl) {
1727 #ifndef PRODUCT
1728       if (TraceSuperWord &amp;&amp; Verbose) {
1729         tty-&gt;print_cr(&quot;Unimplemented&quot;);
1730         pk-&gt;at(0)-&gt;dump();
1731       }
1732 #endif
1733       remove_pack_at(i);
1734     }
1735     Node *n = pk-&gt;at(0);
1736     if (n-&gt;is_reduction()) {
1737       _num_reductions++;
1738     } else {
1739       _num_work_vecs++;
1740     }
1741   }
1742 
1743   // Remove packs that are not profitable
1744   bool changed;
1745   do {
1746     changed = false;
1747     for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1748       Node_List* pk = _packset.at(i);
1749       bool prof = profitable(pk);
1750       if (!prof) {
1751 #ifndef PRODUCT
1752         if (TraceSuperWord &amp;&amp; Verbose) {
1753           tty-&gt;print_cr(&quot;Unprofitable&quot;);
1754           pk-&gt;at(0)-&gt;dump();
1755         }
1756 #endif
1757         remove_pack_at(i);
1758         changed = true;
1759       }
1760     }
1761   } while (changed);
1762 
1763 #ifndef PRODUCT
1764   if (TraceSuperWord) {
1765     tty-&gt;print_cr(&quot;\nAfter filter_packs&quot;);
1766     print_packset();
1767     tty-&gt;cr();
1768   }
1769 #endif
1770 }
1771 
1772 //------------------------------merge_packs_to_cmovd---------------------------
1773 // Merge CMoveD into new vector-nodes
1774 // We want to catch this pattern and subsume CmpD and Bool into CMoveD
1775 //
1776 //                   SubD             ConD
1777 //                  /  |               /
1778 //                 /   |           /   /
1779 //                /    |       /      /
1780 //               /     |   /         /
1781 //              /      /            /
1782 //             /    /  |           /
1783 //            v /      |          /
1784 //         CmpD        |         /
1785 //          |          |        /
1786 //          v          |       /
1787 //         Bool        |      /
1788 //           \         |     /
1789 //             \       |    /
1790 //               \     |   /
1791 //                 \   |  /
1792 //                   \ v /
1793 //                   CMoveD
1794 //
1795 
1796 void SuperWord::merge_packs_to_cmovd() {
1797   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1798     _cmovev_kit.make_cmovevd_pack(_packset.at(i));
1799   }
1800   #ifndef PRODUCT
1801     if (TraceSuperWord) {
1802       tty-&gt;print_cr(&quot;\nSuperWord::merge_packs_to_cmovd(): After merge&quot;);
1803       print_packset();
1804       tty-&gt;cr();
1805     }
1806   #endif
1807 }
1808 
1809 Node* CMoveKit::is_Bool_candidate(Node* def) const {
1810   Node* use = NULL;
1811   if (!def-&gt;is_Bool() || def-&gt;in(0) != NULL || def-&gt;outcnt() != 1) {
1812     return NULL;
1813   }
1814   for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1815     use = def-&gt;fast_out(j);
1816     if (!_sw-&gt;same_generation(def, use) || !use-&gt;is_CMove()) {
1817       return NULL;
1818     }
1819   }
1820   return use;
1821 }
1822 
1823 Node* CMoveKit::is_CmpD_candidate(Node* def) const {
1824   Node* use = NULL;
1825   if (!def-&gt;is_Cmp() || def-&gt;in(0) != NULL || def-&gt;outcnt() != 1) {
1826     return NULL;
1827   }
1828   for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1829     use = def-&gt;fast_out(j);
1830     if (!_sw-&gt;same_generation(def, use) || (use = is_Bool_candidate(use)) == NULL || !_sw-&gt;same_generation(def, use)) {
1831       return NULL;
1832     }
1833   }
1834   return use;
1835 }
1836 
1837 Node_List* CMoveKit::make_cmovevd_pack(Node_List* cmovd_pk) {
1838   Node *cmovd = cmovd_pk-&gt;at(0);
1839   if (!cmovd-&gt;is_CMove()) {
1840     return NULL;
1841   }
1842   if (cmovd-&gt;Opcode() != Op_CMoveF &amp;&amp; cmovd-&gt;Opcode() != Op_CMoveD) {
1843     return NULL;
1844   }
1845   if (pack(cmovd) != NULL) { // already in the cmov pack
1846     return NULL;
1847   }
1848   if (cmovd-&gt;in(0) != NULL) {
1849     NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: CMoveD %d has control flow, escaping...&quot;, cmovd-&gt;_idx); cmovd-&gt;dump();})
1850     return NULL;
1851   }
1852 
1853   Node* bol = cmovd-&gt;as_CMove()-&gt;in(CMoveNode::Condition);
1854   if (!bol-&gt;is_Bool()
1855       || bol-&gt;outcnt() != 1
1856       || !_sw-&gt;same_generation(bol, cmovd)
1857       || bol-&gt;in(0) != NULL  // BoolNode has control flow!!
1858       || _sw-&gt;my_pack(bol) == NULL) {
1859       NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: Bool %d does not fit CMoveD %d for building vector, escaping...&quot;, bol-&gt;_idx, cmovd-&gt;_idx); bol-&gt;dump();})
1860       return NULL;
1861   }
1862   Node_List* bool_pk = _sw-&gt;my_pack(bol);
1863   if (bool_pk-&gt;size() != cmovd_pk-&gt;size() ) {
1864     return NULL;
1865   }
1866 
1867   Node* cmpd = bol-&gt;in(1);
1868   if (!cmpd-&gt;is_Cmp()
1869       || cmpd-&gt;outcnt() != 1
1870       || !_sw-&gt;same_generation(cmpd, cmovd)
1871       || cmpd-&gt;in(0) != NULL  // CmpDNode has control flow!!
1872       || _sw-&gt;my_pack(cmpd) == NULL) {
1873       NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: CmpD %d does not fit CMoveD %d for building vector, escaping...&quot;, cmpd-&gt;_idx, cmovd-&gt;_idx); cmpd-&gt;dump();})
1874       return NULL;
1875   }
1876   Node_List* cmpd_pk = _sw-&gt;my_pack(cmpd);
1877   if (cmpd_pk-&gt;size() != cmovd_pk-&gt;size() ) {
1878     return NULL;
1879   }
1880 
1881   if (!test_cmpd_pack(cmpd_pk, cmovd_pk)) {
1882     NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: cmpd pack for CmpD %d failed vectorization test&quot;, cmpd-&gt;_idx); cmpd-&gt;dump();})
1883     return NULL;
1884   }
1885 
1886   Node_List* new_cmpd_pk = new Node_List();
1887   uint sz = cmovd_pk-&gt;size() - 1;
1888   for (uint i = 0; i &lt;= sz; ++i) {
1889     Node* cmov = cmovd_pk-&gt;at(i);
1890     Node* bol  = bool_pk-&gt;at(i);
1891     Node* cmp  = cmpd_pk-&gt;at(i);
1892 
1893     new_cmpd_pk-&gt;insert(i, cmov);
1894 
1895     map(cmov, new_cmpd_pk);
1896     map(bol, new_cmpd_pk);
1897     map(cmp, new_cmpd_pk);
1898 
1899     _sw-&gt;set_my_pack(cmov, new_cmpd_pk); // and keep old packs for cmp and bool
1900   }
1901   _sw-&gt;_packset.remove(cmovd_pk);
1902   _sw-&gt;_packset.remove(bool_pk);
1903   _sw-&gt;_packset.remove(cmpd_pk);
1904   _sw-&gt;_packset.append(new_cmpd_pk);
1905   NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print_cr(&quot;CMoveKit::make_cmovevd_pack: added syntactic CMoveD pack&quot;); _sw-&gt;print_pack(new_cmpd_pk);})
1906   return new_cmpd_pk;
1907 }
1908 
1909 bool CMoveKit::test_cmpd_pack(Node_List* cmpd_pk, Node_List* cmovd_pk) {
1910   Node* cmpd0 = cmpd_pk-&gt;at(0);
1911   assert(cmpd0-&gt;is_Cmp(), &quot;CMoveKit::test_cmpd_pack: should be CmpDNode&quot;);
1912   assert(cmovd_pk-&gt;at(0)-&gt;is_CMove(), &quot;CMoveKit::test_cmpd_pack: should be CMoveD&quot;);
1913   assert(cmpd_pk-&gt;size() == cmovd_pk-&gt;size(), &quot;CMoveKit::test_cmpd_pack: should be same size&quot;);
1914   Node* in1 = cmpd0-&gt;in(1);
1915   Node* in2 = cmpd0-&gt;in(2);
1916   Node_List* in1_pk = _sw-&gt;my_pack(in1);
1917   Node_List* in2_pk = _sw-&gt;my_pack(in2);
1918 
1919   if (  (in1_pk != NULL &amp;&amp; in1_pk-&gt;size() != cmpd_pk-&gt;size())
1920      || (in2_pk != NULL &amp;&amp; in2_pk-&gt;size() != cmpd_pk-&gt;size()) ) {
1921     return false;
1922   }
1923 
1924   // test if &quot;all&quot; in1 are in the same pack or the same node
1925   if (in1_pk == NULL) {
1926     for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1927       if (cmpd_pk-&gt;at(j)-&gt;in(1) != in1) {
1928         return false;
1929       }
1930     }//for: in1_pk is not pack but all CmpD nodes in the pack have the same in(1)
1931   }
1932   // test if &quot;all&quot; in2 are in the same pack or the same node
1933   if (in2_pk == NULL) {
1934     for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1935       if (cmpd_pk-&gt;at(j)-&gt;in(2) != in2) {
1936         return false;
1937       }
1938     }//for: in2_pk is not pack but all CmpD nodes in the pack have the same in(2)
1939   }
1940   //now check if cmpd_pk may be subsumed in vector built for cmovd_pk
1941   int cmovd_ind1, cmovd_ind2;
1942   if (cmpd_pk-&gt;at(0)-&gt;in(1) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfFalse)
1943    &amp;&amp; cmpd_pk-&gt;at(0)-&gt;in(2) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfTrue)) {
1944       cmovd_ind1 = CMoveNode::IfFalse;
1945       cmovd_ind2 = CMoveNode::IfTrue;
1946   } else if (cmpd_pk-&gt;at(0)-&gt;in(2) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfFalse)
1947           &amp;&amp; cmpd_pk-&gt;at(0)-&gt;in(1) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfTrue)) {
1948       cmovd_ind2 = CMoveNode::IfFalse;
1949       cmovd_ind1 = CMoveNode::IfTrue;
1950   }
1951   else {
1952     return false;
1953   }
1954 
1955   for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1956     if (cmpd_pk-&gt;at(j)-&gt;in(1) != cmovd_pk-&gt;at(j)-&gt;as_CMove()-&gt;in(cmovd_ind1)
1957         || cmpd_pk-&gt;at(j)-&gt;in(2) != cmovd_pk-&gt;at(j)-&gt;as_CMove()-&gt;in(cmovd_ind2)) {
1958         return false;
1959     }//if
1960   }
1961   NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) { tty-&gt;print(&quot;CMoveKit::test_cmpd_pack: cmpd pack for 1st CmpD %d is OK for vectorization: &quot;, cmpd0-&gt;_idx); cmpd0-&gt;dump(); })
1962   return true;
1963 }
1964 
1965 //------------------------------implemented---------------------------
1966 // Can code be generated for pack p?
1967 bool SuperWord::implemented(Node_List* p) {
1968   bool retValue = false;
1969   Node* p0 = p-&gt;at(0);
1970   if (p0 != NULL) {
1971     int opc = p0-&gt;Opcode();
1972     uint size = p-&gt;size();
1973     if (p0-&gt;is_reduction()) {
1974       const Type *arith_type = p0-&gt;bottom_type();
1975       // Length 2 reductions of INT/LONG do not offer performance benefits
1976       if (((arith_type-&gt;basic_type() == T_INT) || (arith_type-&gt;basic_type() == T_LONG)) &amp;&amp; (size == 2)) {
1977         retValue = false;
1978       } else {
1979         retValue = ReductionNode::implemented(opc, size, arith_type-&gt;basic_type());
1980       }
1981     } else {
1982       retValue = VectorNode::implemented(opc, size, velt_basic_type(p0));
1983     }
1984     if (!retValue) {
1985       if (is_cmov_pack(p)) {
1986         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::implemented: found cmpd pack&quot;); print_pack(p);})
1987         return true;
1988       }
1989     }
1990   }
1991   return retValue;
1992 }
1993 
1994 bool SuperWord::is_cmov_pack(Node_List* p) {
1995   return _cmovev_kit.pack(p-&gt;at(0)) != NULL;
1996 }
1997 //------------------------------same_inputs--------------------------
1998 // For pack p, are all idx operands the same?
1999 bool SuperWord::same_inputs(Node_List* p, int idx) {
2000   Node* p0 = p-&gt;at(0);
2001   uint vlen = p-&gt;size();
2002   Node* p0_def = p0-&gt;in(idx);
2003   for (uint i = 1; i &lt; vlen; i++) {
2004     Node* pi = p-&gt;at(i);
2005     Node* pi_def = pi-&gt;in(idx);
2006     if (p0_def != pi_def) {
2007       return false;
2008     }
2009   }
2010   return true;
2011 }
2012 
2013 //------------------------------profitable---------------------------
2014 // For pack p, are all operands and all uses (with in the block) vector?
2015 bool SuperWord::profitable(Node_List* p) {
2016   Node* p0 = p-&gt;at(0);
2017   uint start, end;
2018   VectorNode::vector_operands(p0, &amp;start, &amp;end);
2019 
2020   // Return false if some inputs are not vectors or vectors with different
2021   // size or alignment.
2022   // Also, for now, return false if not scalar promotion case when inputs are
2023   // the same. Later, implement PackNode and allow differing, non-vector inputs
2024   // (maybe just the ones from outside the block.)
2025   for (uint i = start; i &lt; end; i++) {
2026     if (!is_vector_use(p0, i)) {
2027       return false;
2028     }
2029   }
2030   // Check if reductions are connected
2031   if (p0-&gt;is_reduction()) {
2032     Node* second_in = p0-&gt;in(2);
2033     Node_List* second_pk = my_pack(second_in);
2034     if ((second_pk == NULL) || (_num_work_vecs == _num_reductions)) {
2035       // Remove reduction flag if no parent pack or if not enough work
2036       // to cover reduction expansion overhead
2037       p0-&gt;remove_flag(Node::Flag_is_reduction);
2038       return false;
2039     } else if (second_pk-&gt;size() != p-&gt;size()) {
2040       return false;
2041     }
2042   }
2043   if (VectorNode::is_shift(p0)) {
2044     // For now, return false if shift count is vector or not scalar promotion
2045     // case (different shift counts) because it is not supported yet.
2046     Node* cnt = p0-&gt;in(2);
2047     Node_List* cnt_pk = my_pack(cnt);
2048     if (cnt_pk != NULL)
2049       return false;
2050     if (!same_inputs(p, 2))
2051       return false;
2052   }
2053   if (!p0-&gt;is_Store()) {
2054     // For now, return false if not all uses are vector.
2055     // Later, implement ExtractNode and allow non-vector uses (maybe
2056     // just the ones outside the block.)
2057     for (uint i = 0; i &lt; p-&gt;size(); i++) {
2058       Node* def = p-&gt;at(i);
2059       if (is_cmov_pack_internal_node(p, def)) {
2060         continue;
2061       }
2062       for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2063         Node* use = def-&gt;fast_out(j);
2064         for (uint k = 0; k &lt; use-&gt;req(); k++) {
2065           Node* n = use-&gt;in(k);
2066           if (def == n) {
2067             // Reductions should only have a Phi use at the loop head or a non-phi use
2068             // outside of the loop if it is the last element of the pack (e.g. SafePoint).
2069             if (def-&gt;is_reduction() &amp;&amp;
2070                 ((use-&gt;is_Phi() &amp;&amp; use-&gt;in(0) == _lpt-&gt;_head) ||
2071                  (!_lpt-&gt;is_member(_phase-&gt;get_loop(_phase-&gt;ctrl_or_self(use))) &amp;&amp; i == p-&gt;size()-1))) {
2072               continue;
2073             }
2074             if (!is_vector_use(use, k)) {
2075               return false;
2076             }
2077           }
2078         }
2079       }
2080     }
2081   }
2082   return true;
2083 }
2084 
2085 //------------------------------schedule---------------------------
2086 // Adjust the memory graph for the packed operations
2087 void SuperWord::schedule() {
2088 
2089   // Co-locate in the memory graph the members of each memory pack
2090   for (int i = 0; i &lt; _packset.length(); i++) {
2091     co_locate_pack(_packset.at(i));
2092   }
2093 }
2094 
2095 //-------------------------------remove_and_insert-------------------
2096 // Remove &quot;current&quot; from its current position in the memory graph and insert
2097 // it after the appropriate insertion point (lip or uip).
2098 void SuperWord::remove_and_insert(MemNode *current, MemNode *prev, MemNode *lip,
2099                                   Node *uip, Unique_Node_List &amp;sched_before) {
2100   Node* my_mem = current-&gt;in(MemNode::Memory);
2101   bool sched_up = sched_before.member(current);
2102 
2103   // remove current_store from its current position in the memmory graph
2104   for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2105     Node* use = current-&gt;out(i);
2106     if (use-&gt;is_Mem()) {
2107       assert(use-&gt;in(MemNode::Memory) == current, &quot;must be&quot;);
2108       if (use == prev) { // connect prev to my_mem
2109           _igvn.replace_input_of(use, MemNode::Memory, my_mem);
2110           --i; //deleted this edge; rescan position
2111       } else if (sched_before.member(use)) {
2112         if (!sched_up) { // Will be moved together with current
2113           _igvn.replace_input_of(use, MemNode::Memory, uip);
2114           --i; //deleted this edge; rescan position
2115         }
2116       } else {
2117         if (sched_up) { // Will be moved together with current
2118           _igvn.replace_input_of(use, MemNode::Memory, lip);
2119           --i; //deleted this edge; rescan position
2120         }
2121       }
2122     }
2123   }
2124 
2125   Node *insert_pt =  sched_up ?  uip : lip;
2126 
2127   // all uses of insert_pt&#39;s memory state should use current&#39;s instead
2128   for (DUIterator i = insert_pt-&gt;outs(); insert_pt-&gt;has_out(i); i++) {
2129     Node* use = insert_pt-&gt;out(i);
2130     if (use-&gt;is_Mem()) {
2131       assert(use-&gt;in(MemNode::Memory) == insert_pt, &quot;must be&quot;);
2132       _igvn.replace_input_of(use, MemNode::Memory, current);
2133       --i; //deleted this edge; rescan position
2134     } else if (!sched_up &amp;&amp; use-&gt;is_Phi() &amp;&amp; use-&gt;bottom_type() == Type::MEMORY) {
2135       uint pos; //lip (lower insert point) must be the last one in the memory slice
2136       for (pos=1; pos &lt; use-&gt;req(); pos++) {
2137         if (use-&gt;in(pos) == insert_pt) break;
2138       }
2139       _igvn.replace_input_of(use, pos, current);
2140       --i;
2141     }
2142   }
2143 
2144   //connect current to insert_pt
2145   _igvn.replace_input_of(current, MemNode::Memory, insert_pt);
2146 }
2147 
2148 //------------------------------co_locate_pack----------------------------------
2149 // To schedule a store pack, we need to move any sandwiched memory ops either before
2150 // or after the pack, based upon dependence information:
2151 // (1) If any store in the pack depends on the sandwiched memory op, the
2152 //     sandwiched memory op must be scheduled BEFORE the pack;
2153 // (2) If a sandwiched memory op depends on any store in the pack, the
2154 //     sandwiched memory op must be scheduled AFTER the pack;
2155 // (3) If a sandwiched memory op (say, memA) depends on another sandwiched
2156 //     memory op (say memB), memB must be scheduled before memA. So, if memA is
2157 //     scheduled before the pack, memB must also be scheduled before the pack;
2158 // (4) If there is no dependence restriction for a sandwiched memory op, we simply
2159 //     schedule this store AFTER the pack
2160 // (5) We know there is no dependence cycle, so there in no other case;
2161 // (6) Finally, all memory ops in another single pack should be moved in the same direction.
2162 //
2163 // To schedule a load pack, we use the memory state of either the first or the last load in
2164 // the pack, based on the dependence constraint.
2165 void SuperWord::co_locate_pack(Node_List* pk) {
2166   if (pk-&gt;at(0)-&gt;is_Store()) {
2167     MemNode* first     = executed_first(pk)-&gt;as_Mem();
2168     MemNode* last      = executed_last(pk)-&gt;as_Mem();
2169     Unique_Node_List schedule_before_pack;
2170     Unique_Node_List memops;
2171 
2172     MemNode* current   = last-&gt;in(MemNode::Memory)-&gt;as_Mem();
2173     MemNode* previous  = last;
2174     while (true) {
2175       assert(in_bb(current), &quot;stay in block&quot;);
2176       memops.push(previous);
2177       for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2178         Node* use = current-&gt;out(i);
2179         if (use-&gt;is_Mem() &amp;&amp; use != previous)
2180           memops.push(use);
2181       }
2182       if (current == first) break;
2183       previous = current;
2184       current  = current-&gt;in(MemNode::Memory)-&gt;as_Mem();
2185     }
2186 
2187     // determine which memory operations should be scheduled before the pack
2188     for (uint i = 1; i &lt; memops.size(); i++) {
2189       Node *s1 = memops.at(i);
2190       if (!in_pack(s1, pk) &amp;&amp; !schedule_before_pack.member(s1)) {
2191         for (uint j = 0; j&lt; i; j++) {
2192           Node *s2 = memops.at(j);
2193           if (!independent(s1, s2)) {
2194             if (in_pack(s2, pk) || schedule_before_pack.member(s2)) {
2195               schedule_before_pack.push(s1); // s1 must be scheduled before
2196               Node_List* mem_pk = my_pack(s1);
2197               if (mem_pk != NULL) {
2198                 for (uint ii = 0; ii &lt; mem_pk-&gt;size(); ii++) {
2199                   Node* s = mem_pk-&gt;at(ii);  // follow partner
2200                   if (memops.member(s) &amp;&amp; !schedule_before_pack.member(s))
2201                     schedule_before_pack.push(s);
2202                 }
2203               }
2204               break;
2205             }
2206           }
2207         }
2208       }
2209     }
2210 
2211     Node*    upper_insert_pt = first-&gt;in(MemNode::Memory);
2212     // Following code moves loads connected to upper_insert_pt below aliased stores.
2213     // Collect such loads here and reconnect them back to upper_insert_pt later.
2214     memops.clear();
2215     for (DUIterator i = upper_insert_pt-&gt;outs(); upper_insert_pt-&gt;has_out(i); i++) {
2216       Node* use = upper_insert_pt-&gt;out(i);
2217       if (use-&gt;is_Mem() &amp;&amp; !use-&gt;is_Store()) {
2218         memops.push(use);
2219       }
2220     }
2221 
2222     MemNode* lower_insert_pt = last;
2223     previous                 = last; //previous store in pk
2224     current                  = last-&gt;in(MemNode::Memory)-&gt;as_Mem();
2225 
2226     // start scheduling from &quot;last&quot; to &quot;first&quot;
2227     while (true) {
2228       assert(in_bb(current), &quot;stay in block&quot;);
2229       assert(in_pack(previous, pk), &quot;previous stays in pack&quot;);
2230       Node* my_mem = current-&gt;in(MemNode::Memory);
2231 
2232       if (in_pack(current, pk)) {
2233         // Forward users of my memory state (except &quot;previous) to my input memory state
2234         for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2235           Node* use = current-&gt;out(i);
2236           if (use-&gt;is_Mem() &amp;&amp; use != previous) {
2237             assert(use-&gt;in(MemNode::Memory) == current, &quot;must be&quot;);
2238             if (schedule_before_pack.member(use)) {
2239               _igvn.replace_input_of(use, MemNode::Memory, upper_insert_pt);
2240             } else {
2241               _igvn.replace_input_of(use, MemNode::Memory, lower_insert_pt);
2242             }
2243             --i; // deleted this edge; rescan position
2244           }
2245         }
2246         previous = current;
2247       } else { // !in_pack(current, pk) ==&gt; a sandwiched store
2248         remove_and_insert(current, previous, lower_insert_pt, upper_insert_pt, schedule_before_pack);
2249       }
2250 
2251       if (current == first) break;
2252       current = my_mem-&gt;as_Mem();
2253     } // end while
2254 
2255     // Reconnect loads back to upper_insert_pt.
2256     for (uint i = 0; i &lt; memops.size(); i++) {
2257       Node *ld = memops.at(i);
2258       if (ld-&gt;in(MemNode::Memory) != upper_insert_pt) {
2259         _igvn.replace_input_of(ld, MemNode::Memory, upper_insert_pt);
2260       }
2261     }
2262   } else if (pk-&gt;at(0)-&gt;is_Load()) { // Load pack
2263     // All loads in the pack should have the same memory state. By default,
2264     // we use the memory state of the last load. However, if any load could
2265     // not be moved down due to the dependence constraint, we use the memory
2266     // state of the first load.
2267     Node* mem_input = pick_mem_state(pk);
2268     _igvn.hash_delete(mem_input);
2269     // Give each load the same memory state
2270     for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2271       LoadNode* ld = pk-&gt;at(i)-&gt;as_Load();
2272       _igvn.replace_input_of(ld, MemNode::Memory, mem_input);
2273     }
2274   }
2275 }
2276 
2277 // Finds the first and last memory state and then picks either of them by checking dependence constraints.
2278 // If a store is dependent on an earlier load then we need to pick the memory state of the first load and cannot
2279 // pick the memory state of the last load.
2280 Node* SuperWord::pick_mem_state(Node_List* pk) {
2281   Node* first_mem = find_first_mem_state(pk);
2282   Node* last_mem  = find_last_mem_state(pk, first_mem);
2283 
2284   for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2285     Node* ld = pk-&gt;at(i);
2286     for (Node* current = last_mem; current != ld-&gt;in(MemNode::Memory); current = current-&gt;in(MemNode::Memory)) {
2287       assert(current-&gt;is_Mem() &amp;&amp; in_bb(current), &quot;unexpected memory&quot;);
2288       assert(current != first_mem, &quot;corrupted memory graph&quot;);
2289       if (!independent(current, ld)) {
2290 #ifdef ASSERT
2291         // Added assertion code since no case has been observed that should pick the first memory state.
2292         // Remove the assertion code whenever we find a (valid) case that really needs the first memory state.
2293         pk-&gt;dump();
2294         first_mem-&gt;dump();
2295         last_mem-&gt;dump();
2296         current-&gt;dump();
2297         ld-&gt;dump();
2298         ld-&gt;in(MemNode::Memory)-&gt;dump();
2299         assert(false, &quot;never observed that first memory should be picked&quot;);
2300 #endif
2301         return first_mem; // A later store depends on this load, pick memory state of first load
2302       }
2303     }
2304   }
2305   return last_mem;
2306 }
2307 
2308 // Walk the memory graph from the current first load until the
2309 // start of the loop and check if nodes on the way are memory
2310 // edges of loads in the pack. The last one we encounter is the
2311 // first load.
2312 Node* SuperWord::find_first_mem_state(Node_List* pk) {
2313   Node* first_mem = pk-&gt;at(0)-&gt;in(MemNode::Memory);
2314   for (Node* current = first_mem; in_bb(current); current = current-&gt;is_Phi() ? current-&gt;in(LoopNode::EntryControl) : current-&gt;in(MemNode::Memory)) {
2315     assert(current-&gt;is_Mem() || (current-&gt;is_Phi() &amp;&amp; current-&gt;in(0) == bb()), &quot;unexpected memory&quot;);
2316     for (uint i = 1; i &lt; pk-&gt;size(); i++) {
2317       Node* ld = pk-&gt;at(i);
2318       if (ld-&gt;in(MemNode::Memory) == current) {
2319         first_mem = current;
2320         break;
2321       }
2322     }
2323   }
2324   return first_mem;
2325 }
2326 
2327 // Find the last load by going over the pack again and walking
2328 // the memory graph from the loads of the pack to the memory of
2329 // the first load. If we encounter the memory of the current last
2330 // load, then we started from further down in the memory graph and
2331 // the load we started from is the last load.
2332 Node* SuperWord::find_last_mem_state(Node_List* pk, Node* first_mem) {
2333   Node* last_mem = pk-&gt;at(0)-&gt;in(MemNode::Memory);
2334   for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2335     Node* ld = pk-&gt;at(i);
2336     for (Node* current = ld-&gt;in(MemNode::Memory); current != first_mem; current = current-&gt;in(MemNode::Memory)) {
2337       assert(current-&gt;is_Mem() &amp;&amp; in_bb(current), &quot;unexpected memory&quot;);
2338       if (current-&gt;in(MemNode::Memory) == last_mem) {
2339         last_mem = ld-&gt;in(MemNode::Memory);
2340       }
2341     }
2342   }
2343   return last_mem;
2344 }
2345 
2346 #ifndef PRODUCT
2347 void SuperWord::print_loop(bool whole) {
2348   Node_Stack stack(_arena, _phase-&gt;C-&gt;unique() &gt;&gt; 2);
2349   Node_List rpo_list;
2350   VectorSet visited(_arena);
2351   visited.set(lpt()-&gt;_head-&gt;_idx);
2352   _phase-&gt;rpo(lpt()-&gt;_head, stack, visited, rpo_list);
2353   _phase-&gt;dump(lpt(), rpo_list.size(), rpo_list );
2354   if(whole) {
2355     tty-&gt;print_cr(&quot;\n Whole loop tree&quot;);
2356     _phase-&gt;dump();
2357     tty-&gt;print_cr(&quot; End of whole loop tree\n&quot;);
2358   }
2359 }
2360 #endif
2361 
2362 //------------------------------output---------------------------
2363 // Convert packs into vector node operations
2364 void SuperWord::output() {
2365   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
2366   Compile* C = _phase-&gt;C;
2367   if (_packset.length() == 0) {
2368     if (cl-&gt;is_main_loop()) {
2369       // Instigate more unrolling for optimization when vectorization fails.
2370       C-&gt;set_major_progress();
2371       cl-&gt;set_notpassed_slp();
2372       cl-&gt;mark_do_unroll_only();
2373     }
2374     return;
2375   }
2376 
2377 #ifndef PRODUCT
2378   if (TraceLoopOpts) {
2379     tty-&gt;print(&quot;SuperWord::output    &quot;);
2380     lpt()-&gt;dump_head();
2381   }
2382 #endif
2383 
2384   if (cl-&gt;is_main_loop()) {
2385     // MUST ENSURE main loop&#39;s initial value is properly aligned:
2386     //  (iv_initial_value + min_iv_offset) % vector_width_in_bytes() == 0
2387 
2388     align_initial_loop_index(align_to_ref());
2389 
2390     // Insert extract (unpack) operations for scalar uses
2391     for (int i = 0; i &lt; _packset.length(); i++) {
2392       insert_extracts(_packset.at(i));
2393     }
2394   }
2395 
2396   uint max_vlen_in_bytes = 0;
2397   uint max_vlen = 0;
2398   bool can_process_post_loop = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
2399 
2400   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;SWPointer::output: print loop before create_reserve_version_of_loop&quot;); print_loop(true);})
2401 
2402   CountedLoopReserveKit make_reversable(_phase, _lpt, do_reserve_copy());
2403 
2404   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;SWPointer::output: print loop after create_reserve_version_of_loop&quot;); print_loop(true);})
2405 
2406   if (do_reserve_copy() &amp;&amp; !make_reversable.has_reserved()) {
2407     NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: loop was not reserved correctly, exiting SuperWord&quot;);})
2408     return;
2409   }
2410 
2411   for (int i = 0; i &lt; _block.length(); i++) {
2412     Node* n = _block.at(i);
2413     Node_List* p = my_pack(n);
2414     if (p &amp;&amp; n == executed_last(p)) {
2415       uint vlen = p-&gt;size();
2416       uint vlen_in_bytes = 0;
2417       Node* vn = NULL;
2418       Node* low_adr = p-&gt;at(0);
2419       Node* first   = executed_first(p);
2420       if (can_process_post_loop) {
2421         // override vlen with the main loops vector length
2422         vlen = cl-&gt;slp_max_unroll();
2423       }
2424       NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: %d executed first, %d executed last in pack&quot;, first-&gt;_idx, n-&gt;_idx); print_pack(p);})
2425       int   opc = n-&gt;Opcode();
2426       if (n-&gt;is_Load()) {
2427         Node* ctl = n-&gt;in(MemNode::Control);
2428         Node* mem = first-&gt;in(MemNode::Memory);
2429         SWPointer p1(n-&gt;as_Mem(), this, NULL, false);
2430         // Identify the memory dependency for the new loadVector node by
2431         // walking up through memory chain.
2432         // This is done to give flexibility to the new loadVector node so that
2433         // it can move above independent storeVector nodes.
2434         while (mem-&gt;is_StoreVector()) {
2435           SWPointer p2(mem-&gt;as_Mem(), this, NULL, false);
2436           int cmp = p1.cmp(p2);
2437           if (SWPointer::not_equal(cmp) || !SWPointer::comparable(cmp)) {
2438             mem = mem-&gt;in(MemNode::Memory);
2439           } else {
2440             break; // dependent memory
2441           }
2442         }
2443         Node* adr = low_adr-&gt;in(MemNode::Address);
2444         const TypePtr* atyp = n-&gt;adr_type();
2445         vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));
2446         vlen_in_bytes = vn-&gt;as_LoadVector()-&gt;memory_size();
2447       } else if (n-&gt;is_Store()) {
2448         // Promote value to be stored to vector
2449         Node* val = vector_opd(p, MemNode::ValueIn);
2450         if (val == NULL) {
2451           if (do_reserve_copy()) {
2452             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: val should not be NULL, exiting SuperWord&quot;);})
2453             return; //and reverse to backup IG
2454           }
2455           ShouldNotReachHere();
2456         }
2457 
2458         Node* ctl = n-&gt;in(MemNode::Control);
2459         Node* mem = first-&gt;in(MemNode::Memory);
2460         Node* adr = low_adr-&gt;in(MemNode::Address);
2461         const TypePtr* atyp = n-&gt;adr_type();
2462         vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);
2463         vlen_in_bytes = vn-&gt;as_StoreVector()-&gt;memory_size();
2464       } else if (VectorNode::is_roundopD(n)) {
2465         Node* in1 = vector_opd(p, 1);
2466         Node* in2 = low_adr-&gt;in(2);
2467         assert(in2-&gt;is_Con(), &quot;Constant rounding mode expected.&quot;);
2468         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2469         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2470       } else if (VectorNode::is_muladds2i(n)) {
2471         assert(n-&gt;req() == 5u, &quot;MulAddS2I should have 4 operands.&quot;);
2472         Node* in1 = vector_opd(p, 1);
2473         Node* in2 = vector_opd(p, 2);
2474         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2475         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2476       } else if (n-&gt;req() == 3 &amp;&amp; !is_cmov_pack(p)) {
2477         // Promote operands to vector
2478         Node* in1 = NULL;
2479         bool node_isa_reduction = n-&gt;is_reduction();
2480         if (node_isa_reduction) {
2481           // the input to the first reduction operation is retained
2482           in1 = low_adr-&gt;in(1);
2483         } else {
2484           in1 = vector_opd(p, 1);
2485           if (in1 == NULL) {
2486             if (do_reserve_copy()) {
2487               NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: in1 should not be NULL, exiting SuperWord&quot;);})
2488               return; //and reverse to backup IG
2489             }
2490             ShouldNotReachHere();
2491           }
2492         }
2493         Node* in2 = vector_opd(p, 2);
2494         if (in2 == NULL) {
2495           if (do_reserve_copy()) {
2496             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: in2 should not be NULL, exiting SuperWord&quot;);})
2497             return; //and reverse to backup IG
2498           }
2499           ShouldNotReachHere();
2500         }
2501         if (VectorNode::is_invariant_vector(in1) &amp;&amp; (node_isa_reduction == false) &amp;&amp; (n-&gt;is_Add() || n-&gt;is_Mul())) {
2502           // Move invariant vector input into second position to avoid register spilling.
2503           Node* tmp = in1;
2504           in1 = in2;
2505           in2 = tmp;
2506         }
2507         if (node_isa_reduction) {
2508           const Type *arith_type = n-&gt;bottom_type();
2509           vn = ReductionNode::make(opc, NULL, in1, in2, arith_type-&gt;basic_type());
2510           if (in2-&gt;is_Load()) {
2511             vlen_in_bytes = in2-&gt;as_LoadVector()-&gt;memory_size();
2512           } else {
2513             vlen_in_bytes = in2-&gt;as_Vector()-&gt;length_in_bytes();
2514           }
2515         } else {
2516           vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2517           vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2518         }
2519       } else if (opc == Op_SqrtF || opc == Op_SqrtD ||
2520                  opc == Op_AbsF || opc == Op_AbsD ||
2521                  opc == Op_AbsI || opc == Op_AbsL ||
2522                  opc == Op_NegF || opc == Op_NegD ||
2523                  opc == Op_PopCountI) {
2524         assert(n-&gt;req() == 2, &quot;only one input expected&quot;);
2525         Node* in = vector_opd(p, 1);
2526         vn = VectorNode::make(opc, in, NULL, vlen, velt_basic_type(n));
2527         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2528       } else if (is_cmov_pack(p)) {
2529         if (can_process_post_loop) {
2530           // do not refactor of flow in post loop context
2531           return;
2532         }
2533         if (!n-&gt;is_CMove()) {
2534           continue;
2535         }
2536         // place here CMoveVDNode
2537         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: print before CMove vectorization&quot;); print_loop(false);})
2538         Node* bol = n-&gt;in(CMoveNode::Condition);
2539         if (!bol-&gt;is_Bool() &amp;&amp; bol-&gt;Opcode() == Op_ExtractI &amp;&amp; bol-&gt;req() &gt; 1 ) {
2540           NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: %d is not Bool node, trying its in(1) node %d&quot;, bol-&gt;_idx, bol-&gt;in(1)-&gt;_idx); bol-&gt;dump(); bol-&gt;in(1)-&gt;dump();})
2541           bol = bol-&gt;in(1); //may be ExtractNode
2542         }
2543 
2544         assert(bol-&gt;is_Bool(), &quot;should be BoolNode - too late to bail out!&quot;);
2545         if (!bol-&gt;is_Bool()) {
2546           if (do_reserve_copy()) {
2547             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: expected %d bool node, exiting SuperWord&quot;, bol-&gt;_idx); bol-&gt;dump();})
2548             return; //and reverse to backup IG
2549           }
2550           ShouldNotReachHere();
2551         }
2552 
2553         int cond = (int)bol-&gt;as_Bool()-&gt;_test._test;
2554         Node* in_cc  = _igvn.intcon(cond);
2555         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created intcon in_cc node %d&quot;, in_cc-&gt;_idx); in_cc-&gt;dump();})
2556         Node* cc = bol-&gt;clone();
2557         cc-&gt;set_req(1, in_cc);
2558         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created bool cc node %d&quot;, cc-&gt;_idx); cc-&gt;dump();})
2559 
2560         Node* src1 = vector_opd(p, 2); //2=CMoveNode::IfFalse
2561         if (src1 == NULL) {
2562           if (do_reserve_copy()) {
2563             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: src1 should not be NULL, exiting SuperWord&quot;);})
2564             return; //and reverse to backup IG
2565           }
2566           ShouldNotReachHere();
2567         }
2568         Node* src2 = vector_opd(p, 3); //3=CMoveNode::IfTrue
2569         if (src2 == NULL) {
2570           if (do_reserve_copy()) {
2571             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: src2 should not be NULL, exiting SuperWord&quot;);})
2572             return; //and reverse to backup IG
2573           }
2574           ShouldNotReachHere();
2575         }
2576         BasicType bt = velt_basic_type(n);
2577         const TypeVect* vt = TypeVect::make(bt, vlen);
2578         assert(bt == T_FLOAT || bt == T_DOUBLE, &quot;Only vectorization for FP cmovs is supported&quot;);
2579         if (bt == T_FLOAT) {
2580           vn = new CMoveVFNode(cc, src1, src2, vt);
2581         } else {
2582           assert(bt == T_DOUBLE, &quot;Expected double&quot;);
2583           vn = new CMoveVDNode(cc, src1, src2, vt);
2584         }
2585         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created new CMove node %d: &quot;, vn-&gt;_idx); vn-&gt;dump();})
2586       } else if (opc == Op_FmaD || opc == Op_FmaF) {
2587         // Promote operands to vector
2588         Node* in1 = vector_opd(p, 1);
2589         Node* in2 = vector_opd(p, 2);
2590         Node* in3 = vector_opd(p, 3);
2591         vn = VectorNode::make(opc, in1, in2, in3, vlen, velt_basic_type(n));
2592         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2593       } else {
2594         if (do_reserve_copy()) {
2595           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: ShouldNotReachHere, exiting SuperWord&quot;);})
2596           return; //and reverse to backup IG
2597         }
2598         ShouldNotReachHere();
2599       }
2600 
2601       assert(vn != NULL, &quot;sanity&quot;);
2602       if (vn == NULL) {
2603         if (do_reserve_copy()){
2604           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: got NULL node, cannot proceed, exiting SuperWord&quot;);})
2605           return; //and reverse to backup IG
2606         }
2607         ShouldNotReachHere();
2608       }
2609 
2610       _block.at_put(i, vn);
2611       _igvn.register_new_node_with_optimizer(vn);
2612       _phase-&gt;set_ctrl(vn, _phase-&gt;get_ctrl(p-&gt;at(0)));
2613       for (uint j = 0; j &lt; p-&gt;size(); j++) {
2614         Node* pm = p-&gt;at(j);
2615         _igvn.replace_node(pm, vn);
2616       }
2617       _igvn._worklist.push(vn);
2618 
2619       if (can_process_post_loop) {
2620         // first check if the vector size if the maximum vector which we can use on the machine,
2621         // other vector size have reduced values for predicated data mapping.
2622         if (vlen_in_bytes != (uint)MaxVectorSize) {
2623           return;
2624         }
2625       }
2626 
2627       if (vlen_in_bytes &gt;= max_vlen_in_bytes &amp;&amp; vlen &gt; max_vlen) {
2628         max_vlen = vlen;
2629         max_vlen_in_bytes = vlen_in_bytes;
2630       }
2631 #ifdef ASSERT
2632       if (TraceNewVectors) {
2633         tty-&gt;print(&quot;new Vector node: &quot;);
2634         vn-&gt;dump();
2635       }
2636 #endif
2637     }
2638   }//for (int i = 0; i &lt; _block.length(); i++)
2639 
2640   if (max_vlen_in_bytes &gt; C-&gt;max_vector_size()) {
2641     C-&gt;set_max_vector_size(max_vlen_in_bytes);
2642   }
2643   if (max_vlen_in_bytes &gt; 0) {
2644     cl-&gt;mark_loop_vectorized();
2645   }
2646 
2647   if (SuperWordLoopUnrollAnalysis) {
2648     if (cl-&gt;has_passed_slp()) {
2649       uint slp_max_unroll_factor = cl-&gt;slp_max_unroll();
2650       if (slp_max_unroll_factor == max_vlen) {
2651         if (TraceSuperWordLoopUnrollAnalysis) {
2652           tty-&gt;print_cr(&quot;vector loop(unroll=%d, len=%d)\n&quot;, max_vlen, max_vlen_in_bytes*BitsPerByte);
2653         }
2654 
2655         // For atomic unrolled loops which are vector mapped, instigate more unrolling
2656         cl-&gt;set_notpassed_slp();
2657         if (cl-&gt;is_main_loop()) {
2658           // if vector resources are limited, do not allow additional unrolling, also
2659           // do not unroll more on pure vector loops which were not reduced so that we can
2660           // program the post loop to single iteration execution.
2661           if (FLOATPRESSURE &gt; 8) {
2662             C-&gt;set_major_progress();
2663             cl-&gt;mark_do_unroll_only();
2664           }
2665         }
2666 
2667         if (do_reserve_copy()) {
2668           if (can_process_post_loop) {
2669             // Now create the difference of trip and limit and use it as our mask index.
2670             // Note: We limited the unroll of the vectorized loop so that
2671             //       only vlen-1 size iterations can remain to be mask programmed.
2672             Node *incr = cl-&gt;incr();
2673             SubINode *index = new SubINode(cl-&gt;limit(), cl-&gt;init_trip());
2674             _igvn.register_new_node_with_optimizer(index);
2675             SetVectMaskINode  *mask = new SetVectMaskINode(_phase-&gt;get_ctrl(cl-&gt;init_trip()), index);
2676             _igvn.register_new_node_with_optimizer(mask);
2677             // make this a single iteration loop
2678             AddINode *new_incr = new AddINode(incr-&gt;in(1), mask);
2679             _igvn.register_new_node_with_optimizer(new_incr);
2680             _phase-&gt;set_ctrl(new_incr, _phase-&gt;get_ctrl(incr));
2681             _igvn.replace_node(incr, new_incr);
2682             cl-&gt;mark_is_multiversioned();
2683             cl-&gt;loopexit()-&gt;add_flag(Node::Flag_has_vector_mask_set);
2684           }
2685         }
2686       }
2687     }
2688   }
2689 
2690   if (do_reserve_copy()) {
2691     make_reversable.use_new();
2692   }
2693   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;\n Final loop after SuperWord&quot;); print_loop(true);})
2694   return;
2695 }
2696 
2697 //------------------------------vector_opd---------------------------
2698 // Create a vector operand for the nodes in pack p for operand: in(opd_idx)
2699 Node* SuperWord::vector_opd(Node_List* p, int opd_idx) {
2700   Node* p0 = p-&gt;at(0);
2701   uint vlen = p-&gt;size();
2702   Node* opd = p0-&gt;in(opd_idx);
2703   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
2704 
2705   if (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop()) {
2706     // override vlen with the main loops vector length
2707     vlen = cl-&gt;slp_max_unroll();
2708   }
2709 
2710   if (same_inputs(p, opd_idx)) {
2711     if (opd-&gt;is_Vector() || opd-&gt;is_LoadVector()) {
2712       assert(((opd_idx != 2) || !VectorNode::is_shift(p0)), &quot;shift&#39;s count can&#39;t be vector&quot;);
2713       if (opd_idx == 2 &amp;&amp; VectorNode::is_shift(p0)) {
2714         NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;shift&#39;s count can&#39;t be vector&quot;);})
2715         return NULL;
2716       }
2717       return opd; // input is matching vector
2718     }
2719     if ((opd_idx == 2) &amp;&amp; VectorNode::is_shift(p0)) {
2720       Compile* C = _phase-&gt;C;
2721       Node* cnt = opd;
2722       // Vector instructions do not mask shift count, do it here.
2723       juint mask = (p0-&gt;bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);
2724       const TypeInt* t = opd-&gt;find_int_type();
2725       if (t != NULL &amp;&amp; t-&gt;is_con()) {
2726         juint shift = t-&gt;get_con();
2727         if (shift &gt; mask) { // Unsigned cmp
2728           cnt = ConNode::make(TypeInt::make(shift &amp; mask));
2729         }
2730       } else {
2731         if (t == NULL || t-&gt;_lo &lt; 0 || t-&gt;_hi &gt; (int)mask) {
2732           cnt = ConNode::make(TypeInt::make(mask));
2733           _igvn.register_new_node_with_optimizer(cnt);
2734           cnt = new AndINode(opd, cnt);
2735           _igvn.register_new_node_with_optimizer(cnt);
2736           _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));
2737         }
2738         assert(opd-&gt;bottom_type()-&gt;isa_int(), &quot;int type only&quot;);
2739         if (!opd-&gt;bottom_type()-&gt;isa_int()) {
2740           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should be int type only&quot;);})
2741           return NULL;
2742         }
2743       }
2744       // Move shift count into vector register.
2745       cnt = VectorNode::shift_count(p0, cnt, vlen, velt_basic_type(p0));
2746       _igvn.register_new_node_with_optimizer(cnt);
2747       _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));
2748       return cnt;
2749     }
2750     assert(!opd-&gt;is_StoreVector(), &quot;such vector is not expected here&quot;);
2751     if (opd-&gt;is_StoreVector()) {
2752       NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;StoreVector is not expected here&quot;);})
2753       return NULL;
2754     }
2755     // Convert scalar input to vector with the same number of elements as
2756     // p0&#39;s vector. Use p0&#39;s type because size of operand&#39;s container in
2757     // vector should match p0&#39;s size regardless operand&#39;s size.
2758     const Type* p0_t = velt_type(p0);
2759     VectorNode* vn = VectorNode::scalar2vector(opd, vlen, p0_t);
2760 
2761     _igvn.register_new_node_with_optimizer(vn);
2762     _phase-&gt;set_ctrl(vn, _phase-&gt;get_ctrl(opd));
2763 #ifdef ASSERT
2764     if (TraceNewVectors) {
2765       tty-&gt;print(&quot;new Vector node: &quot;);
2766       vn-&gt;dump();
2767     }
2768 #endif
2769     return vn;
2770   }
2771 
2772   // Insert pack operation
2773   BasicType bt = velt_basic_type(p0);
2774   PackNode* pk = PackNode::make(opd, vlen, bt);
2775   DEBUG_ONLY( const BasicType opd_bt = opd-&gt;bottom_type()-&gt;basic_type(); )
2776 
2777   for (uint i = 1; i &lt; vlen; i++) {
2778     Node* pi = p-&gt;at(i);
2779     Node* in = pi-&gt;in(opd_idx);
2780     assert(my_pack(in) == NULL, &quot;Should already have been unpacked&quot;);
2781     if (my_pack(in) != NULL) {
2782       NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should already have been unpacked&quot;);})
2783       return NULL;
2784     }
2785     assert(opd_bt == in-&gt;bottom_type()-&gt;basic_type(), &quot;all same type&quot;);
2786     pk-&gt;add_opd(in);
2787     if (VectorNode::is_muladds2i(pi)) {
2788       Node* in2 = pi-&gt;in(opd_idx + 2);
2789       assert(my_pack(in2) == NULL, &quot;Should already have been unpacked&quot;);
2790       if (my_pack(in2) != NULL) {
2791         NOT_PRODUCT(if (is_trace_loop_reverse() || TraceLoopOpts) { tty-&gt;print_cr(&quot;Should already have been unpacked&quot;); })
2792           return NULL;
2793       }
2794       assert(opd_bt == in2-&gt;bottom_type()-&gt;basic_type(), &quot;all same type&quot;);
2795       pk-&gt;add_opd(in2);
2796     }
2797   }
2798   _igvn.register_new_node_with_optimizer(pk);
2799   _phase-&gt;set_ctrl(pk, _phase-&gt;get_ctrl(opd));
2800 #ifdef ASSERT
2801   if (TraceNewVectors) {
2802     tty-&gt;print(&quot;new Vector node: &quot;);
2803     pk-&gt;dump();
2804   }
2805 #endif
2806   return pk;
2807 }
2808 
2809 //------------------------------insert_extracts---------------------------
2810 // If a use of pack p is not a vector use, then replace the
2811 // use with an extract operation.
2812 void SuperWord::insert_extracts(Node_List* p) {
2813   if (p-&gt;at(0)-&gt;is_Store()) return;
2814   assert(_n_idx_list.is_empty(), &quot;empty (node,index) list&quot;);
2815 
2816   // Inspect each use of each pack member.  For each use that is
2817   // not a vector use, replace the use with an extract operation.
2818 
2819   for (uint i = 0; i &lt; p-&gt;size(); i++) {
2820     Node* def = p-&gt;at(i);
2821     for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2822       Node* use = def-&gt;fast_out(j);
2823       for (uint k = 0; k &lt; use-&gt;req(); k++) {
2824         Node* n = use-&gt;in(k);
2825         if (def == n) {
2826           Node_List* u_pk = my_pack(use);
2827           if ((u_pk == NULL || !is_cmov_pack(u_pk) || use-&gt;is_CMove()) &amp;&amp; !is_vector_use(use, k)) {
2828               _n_idx_list.push(use, k);
2829           }
2830         }
2831       }
2832     }
2833   }
2834 
2835   while (_n_idx_list.is_nonempty()) {
2836     Node* use = _n_idx_list.node();
2837     int   idx = _n_idx_list.index();
2838     _n_idx_list.pop();
2839     Node* def = use-&gt;in(idx);
2840 
2841     if (def-&gt;is_reduction()) continue;
2842 
2843     // Insert extract operation
2844     _igvn.hash_delete(def);
2845     int def_pos = alignment(def) / data_size(def);
2846 
2847     Node* ex = ExtractNode::make(def, def_pos, velt_basic_type(def));
2848     _igvn.register_new_node_with_optimizer(ex);
2849     _phase-&gt;set_ctrl(ex, _phase-&gt;get_ctrl(def));
2850     _igvn.replace_input_of(use, idx, ex);
2851     _igvn._worklist.push(def);
2852 
2853     bb_insert_after(ex, bb_idx(def));
2854     set_velt_type(ex, velt_type(def));
2855   }
2856 }
2857 
2858 //------------------------------is_vector_use---------------------------
2859 // Is use-&gt;in(u_idx) a vector use?
2860 bool SuperWord::is_vector_use(Node* use, int u_idx) {
2861   Node_List* u_pk = my_pack(use);
2862   if (u_pk == NULL) return false;
2863   if (use-&gt;is_reduction()) return true;
2864   Node* def = use-&gt;in(u_idx);
2865   Node_List* d_pk = my_pack(def);
2866   if (d_pk == NULL) {
2867     // check for scalar promotion
2868     Node* n = u_pk-&gt;at(0)-&gt;in(u_idx);
2869     for (uint i = 1; i &lt; u_pk-&gt;size(); i++) {
2870       if (u_pk-&gt;at(i)-&gt;in(u_idx) != n) return false;
2871     }
2872     return true;
2873   }
2874   if (VectorNode::is_muladds2i(use)) {
2875     // MulAddS2I takes shorts and produces ints - hence the special checks
2876     // on alignment and size.
2877     if (u_pk-&gt;size() * 2 != d_pk-&gt;size()) {
2878       return false;
2879     }
2880     for (uint i = 0; i &lt; MIN2(d_pk-&gt;size(), u_pk-&gt;size()); i++) {
2881       Node* ui = u_pk-&gt;at(i);
2882       Node* di = d_pk-&gt;at(i);
2883       if (alignment(ui) != alignment(di) * 2) {
2884         return false;
2885       }
2886     }
2887     return true;
2888   }
2889   if (u_pk-&gt;size() != d_pk-&gt;size())
2890     return false;
2891   for (uint i = 0; i &lt; u_pk-&gt;size(); i++) {
2892     Node* ui = u_pk-&gt;at(i);
2893     Node* di = d_pk-&gt;at(i);
2894     if (ui-&gt;in(u_idx) != di || alignment(ui) != alignment(di))
2895       return false;
2896   }
2897   return true;
2898 }
2899 
2900 //------------------------------construct_bb---------------------------
2901 // Construct reverse postorder list of block members
2902 bool SuperWord::construct_bb() {
2903   Node* entry = bb();
2904 
2905   assert(_stk.length() == 0,            &quot;stk is empty&quot;);
2906   assert(_block.length() == 0,          &quot;block is empty&quot;);
2907   assert(_data_entry.length() == 0,     &quot;data_entry is empty&quot;);
2908   assert(_mem_slice_head.length() == 0, &quot;mem_slice_head is empty&quot;);
2909   assert(_mem_slice_tail.length() == 0, &quot;mem_slice_tail is empty&quot;);
2910 
2911   // Find non-control nodes with no inputs from within block,
2912   // create a temporary map from node _idx to bb_idx for use
2913   // by the visited and post_visited sets,
2914   // and count number of nodes in block.
2915   int bb_ct = 0;
2916   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
2917     Node *n = lpt()-&gt;_body.at(i);
2918     set_bb_idx(n, i); // Create a temporary map
2919     if (in_bb(n)) {
2920       if (n-&gt;is_LoadStore() || n-&gt;is_MergeMem() ||
2921           (n-&gt;is_Proj() &amp;&amp; !n-&gt;as_Proj()-&gt;is_CFG())) {
2922         // Bailout if the loop has LoadStore, MergeMem or data Proj
2923         // nodes. Superword optimization does not work with them.
2924         return false;
2925       }
2926       bb_ct++;
2927       if (!n-&gt;is_CFG()) {
2928         bool found = false;
2929         for (uint j = 0; j &lt; n-&gt;req(); j++) {
2930           Node* def = n-&gt;in(j);
2931           if (def &amp;&amp; in_bb(def)) {
2932             found = true;
2933             break;
2934           }
2935         }
2936         if (!found) {
2937           assert(n != entry, &quot;can&#39;t be entry&quot;);
2938           _data_entry.push(n);
2939         }
2940       }
2941     }
2942   }
2943 
2944   // Find memory slices (head and tail)
2945   for (DUIterator_Fast imax, i = lp()-&gt;fast_outs(imax); i &lt; imax; i++) {
2946     Node *n = lp()-&gt;fast_out(i);
2947     if (in_bb(n) &amp;&amp; (n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY)) {
2948       Node* n_tail  = n-&gt;in(LoopNode::LoopBackControl);
2949       if (n_tail != n-&gt;in(LoopNode::EntryControl)) {
2950         if (!n_tail-&gt;is_Mem()) {
2951           assert(n_tail-&gt;is_Mem(), &quot;unexpected node for memory slice: %s&quot;, n_tail-&gt;Name());
2952           return false; // Bailout
2953         }
2954         _mem_slice_head.push(n);
2955         _mem_slice_tail.push(n_tail);
2956       }
2957     }
2958   }
2959 
2960   // Create an RPO list of nodes in block
2961 
2962   visited_clear();
2963   post_visited_clear();
2964 
2965   // Push all non-control nodes with no inputs from within block, then control entry
2966   for (int j = 0; j &lt; _data_entry.length(); j++) {
2967     Node* n = _data_entry.at(j);
2968     visited_set(n);
2969     _stk.push(n);
2970   }
2971   visited_set(entry);
2972   _stk.push(entry);
2973 
2974   // Do a depth first walk over out edges
2975   int rpo_idx = bb_ct - 1;
2976   int size;
2977   int reduction_uses = 0;
2978   while ((size = _stk.length()) &gt; 0) {
2979     Node* n = _stk.top(); // Leave node on stack
2980     if (!visited_test_set(n)) {
2981       // forward arc in graph
2982     } else if (!post_visited_test(n)) {
2983       // cross or back arc
2984       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2985         Node *use = n-&gt;fast_out(i);
2986         if (in_bb(use) &amp;&amp; !visited_test(use) &amp;&amp;
2987             // Don&#39;t go around backedge
2988             (!use-&gt;is_Phi() || n == entry)) {
2989           if (use-&gt;is_reduction()) {
2990             // First see if we can map the reduction on the given system we are on, then
2991             // make a data entry operation for each reduction we see.
2992             BasicType bt = use-&gt;bottom_type()-&gt;basic_type();
2993             if (ReductionNode::implemented(use-&gt;Opcode(), Matcher::min_vector_size(bt), bt)) {
2994               reduction_uses++;
2995             }
2996           }
2997           _stk.push(use);
2998         }
2999       }
3000       if (_stk.length() == size) {
3001         // There were no additional uses, post visit node now
3002         _stk.pop(); // Remove node from stack
3003         assert(rpo_idx &gt;= 0, &quot;&quot;);
3004         _block.at_put_grow(rpo_idx, n);
3005         rpo_idx--;
3006         post_visited_set(n);
3007         assert(rpo_idx &gt;= 0 || _stk.is_empty(), &quot;&quot;);
3008       }
3009     } else {
3010       _stk.pop(); // Remove post-visited node from stack
3011     }
3012   }//while
3013 
3014   int ii_current = -1;
3015   unsigned int load_idx = (unsigned int)-1;
3016   _ii_order.clear();
3017   // Create real map of block indices for nodes
3018   for (int j = 0; j &lt; _block.length(); j++) {
3019     Node* n = _block.at(j);
3020     set_bb_idx(n, j);
3021     if (_do_vector_loop &amp;&amp; n-&gt;is_Load()) {
3022       if (ii_current == -1) {
3023         ii_current = _clone_map.gen(n-&gt;_idx);
3024         _ii_order.push(ii_current);
3025         load_idx = _clone_map.idx(n-&gt;_idx);
3026       } else if (_clone_map.idx(n-&gt;_idx) == load_idx &amp;&amp; _clone_map.gen(n-&gt;_idx) != ii_current) {
3027         ii_current = _clone_map.gen(n-&gt;_idx);
3028         _ii_order.push(ii_current);
3029       }
3030     }
3031   }//for
3032 
3033   // Ensure extra info is allocated.
3034   initialize_bb();
3035 
3036 #ifndef PRODUCT
3037   if (_vector_loop_debug &amp;&amp; _ii_order.length() &gt; 0) {
3038     tty-&gt;print(&quot;SuperWord::construct_bb: List of generations: &quot;);
3039     for (int jj = 0; jj &lt; _ii_order.length(); ++jj) {
3040       tty-&gt;print(&quot;  %d:%d&quot;, jj, _ii_order.at(jj));
3041     }
3042     tty-&gt;print_cr(&quot; &quot;);
3043   }
3044   if (TraceSuperWord) {
3045     print_bb();
3046     tty-&gt;print_cr(&quot;\ndata entry nodes: %s&quot;, _data_entry.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
3047     for (int m = 0; m &lt; _data_entry.length(); m++) {
3048       tty-&gt;print(&quot;%3d &quot;, m);
3049       _data_entry.at(m)-&gt;dump();
3050     }
3051     tty-&gt;print_cr(&quot;\nmemory slices: %s&quot;, _mem_slice_head.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
3052     for (int m = 0; m &lt; _mem_slice_head.length(); m++) {
3053       tty-&gt;print(&quot;%3d &quot;, m); _mem_slice_head.at(m)-&gt;dump();
3054       tty-&gt;print(&quot;    &quot;);    _mem_slice_tail.at(m)-&gt;dump();
3055     }
3056   }
3057 #endif
3058   assert(rpo_idx == -1 &amp;&amp; bb_ct == _block.length(), &quot;all block members found&quot;);
3059   return (_mem_slice_head.length() &gt; 0) || (reduction_uses &gt; 0) || (_data_entry.length() &gt; 0);
3060 }
3061 
3062 //------------------------------initialize_bb---------------------------
3063 // Initialize per node info
3064 void SuperWord::initialize_bb() {
3065   Node* last = _block.at(_block.length() - 1);
3066   grow_node_info(bb_idx(last));
3067 }
3068 
3069 //------------------------------bb_insert_after---------------------------
3070 // Insert n into block after pos
3071 void SuperWord::bb_insert_after(Node* n, int pos) {
3072   int n_pos = pos + 1;
3073   // Make room
3074   for (int i = _block.length() - 1; i &gt;= n_pos; i--) {
3075     _block.at_put_grow(i+1, _block.at(i));
3076   }
3077   for (int j = _node_info.length() - 1; j &gt;= n_pos; j--) {
3078     _node_info.at_put_grow(j+1, _node_info.at(j));
3079   }
3080   // Set value
3081   _block.at_put_grow(n_pos, n);
3082   _node_info.at_put_grow(n_pos, SWNodeInfo::initial);
3083   // Adjust map from node-&gt;_idx to _block index
3084   for (int i = n_pos; i &lt; _block.length(); i++) {
3085     set_bb_idx(_block.at(i), i);
3086   }
3087 }
3088 
3089 //------------------------------compute_max_depth---------------------------
3090 // Compute max depth for expressions from beginning of block
3091 // Use to prune search paths during test for independence.
3092 void SuperWord::compute_max_depth() {
3093   int ct = 0;
3094   bool again;
3095   do {
3096     again = false;
3097     for (int i = 0; i &lt; _block.length(); i++) {
3098       Node* n = _block.at(i);
3099       if (!n-&gt;is_Phi()) {
3100         int d_orig = depth(n);
3101         int d_in   = 0;
3102         for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {
3103           Node* pred = preds.current();
3104           if (in_bb(pred)) {
3105             d_in = MAX2(d_in, depth(pred));
3106           }
3107         }
3108         if (d_in + 1 != d_orig) {
3109           set_depth(n, d_in + 1);
3110           again = true;
3111         }
3112       }
3113     }
3114     ct++;
3115   } while (again);
3116 
3117   if (TraceSuperWord &amp;&amp; Verbose) {
3118     tty-&gt;print_cr(&quot;compute_max_depth iterated: %d times&quot;, ct);
3119   }
3120 }
3121 
3122 //-------------------------compute_vector_element_type-----------------------
3123 // Compute necessary vector element type for expressions
3124 // This propagates backwards a narrower integer type when the
3125 // upper bits of the value are not needed.
3126 // Example:  char a,b,c;  a = b + c;
3127 // Normally the type of the add is integer, but for packed character
3128 // operations the type of the add needs to be char.
3129 void SuperWord::compute_vector_element_type() {
3130   if (TraceSuperWord &amp;&amp; Verbose) {
3131     tty-&gt;print_cr(&quot;\ncompute_velt_type:&quot;);
3132   }
3133 
3134   // Initial type
3135   for (int i = 0; i &lt; _block.length(); i++) {
3136     Node* n = _block.at(i);
3137     set_velt_type(n, container_type(n));
3138   }
3139 
3140   // Propagate integer narrowed type backwards through operations
3141   // that don&#39;t depend on higher order bits
3142   for (int i = _block.length() - 1; i &gt;= 0; i--) {
3143     Node* n = _block.at(i);
3144     // Only integer types need be examined
3145     const Type* vtn = velt_type(n);
3146     if (vtn-&gt;basic_type() == T_INT) {
3147       uint start, end;
3148       VectorNode::vector_operands(n, &amp;start, &amp;end);
3149 
3150       for (uint j = start; j &lt; end; j++) {
3151         Node* in  = n-&gt;in(j);
3152         // Don&#39;t propagate through a memory
3153         if (!in-&gt;is_Mem() &amp;&amp; in_bb(in) &amp;&amp; velt_type(in)-&gt;basic_type() == T_INT &amp;&amp;
3154             data_size(n) &lt; data_size(in)) {
3155           bool same_type = true;
3156           for (DUIterator_Fast kmax, k = in-&gt;fast_outs(kmax); k &lt; kmax; k++) {
3157             Node *use = in-&gt;fast_out(k);
3158             if (!in_bb(use) || !same_velt_type(use, n)) {
3159               same_type = false;
3160               break;
3161             }
3162           }
3163           if (same_type) {
3164             // For right shifts of small integer types (bool, byte, char, short)
3165             // we need precise information about sign-ness. Only Load nodes have
3166             // this information because Store nodes are the same for signed and
3167             // unsigned values. And any arithmetic operation after a load may
3168             // expand a value to signed Int so such right shifts can&#39;t be used
3169             // because vector elements do not have upper bits of Int.
3170             const Type* vt = vtn;
3171             if (VectorNode::is_shift(in)) {
3172               Node* load = in-&gt;in(1);
3173               if (load-&gt;is_Load() &amp;&amp; in_bb(load) &amp;&amp; (velt_type(load)-&gt;basic_type() == T_INT)) {
3174                 vt = velt_type(load);
3175               } else if (in-&gt;Opcode() != Op_LShiftI) {
3176                 // Widen type to Int to avoid creation of right shift vector
3177                 // (align + data_size(s1) check in stmts_can_pack() will fail).
3178                 // Note, left shifts work regardless type.
3179                 vt = TypeInt::INT;
3180               }
3181             }
3182             set_velt_type(in, vt);
3183           }
3184         }
3185       }
3186     }
3187   }
3188 #ifndef PRODUCT
3189   if (TraceSuperWord &amp;&amp; Verbose) {
3190     for (int i = 0; i &lt; _block.length(); i++) {
3191       Node* n = _block.at(i);
3192       velt_type(n)-&gt;dump();
3193       tty-&gt;print(&quot;\t&quot;);
3194       n-&gt;dump();
3195     }
3196   }
3197 #endif
3198 }
3199 
3200 //------------------------------memory_alignment---------------------------
3201 // Alignment within a vector memory reference
3202 int SuperWord::memory_alignment(MemNode* s, int iv_adjust) {
3203   #ifndef PRODUCT
3204     if(TraceSuperWord &amp;&amp; Verbose) {
3205       tty-&gt;print(&quot;SuperWord::memory_alignment within a vector memory reference for %d:  &quot;, s-&gt;_idx); s-&gt;dump();
3206     }
3207   #endif
3208   NOT_PRODUCT(SWPointer::Tracer::Depth ddd(0);)
3209   SWPointer p(s, this, NULL, false);
3210   if (!p.valid()) {
3211     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print(&quot;SWPointer::memory_alignment: SWPointer p invalid, return bottom_align&quot;);)
3212     return bottom_align;
3213   }
3214   int vw = get_vw_bytes_special(s);
3215   if (vw &lt; 2) {
3216     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SWPointer::memory_alignment: vector_width_in_bytes &lt; 2, return bottom_align&quot;);)
3217     return bottom_align; // No vectors for this type
3218   }
3219   int offset  = p.offset_in_bytes();
3220   offset     += iv_adjust*p.memory_size();
3221   int off_rem = offset % vw;
3222   int off_mod = off_rem &gt;= 0 ? off_rem : off_rem + vw;
3223   if (TraceSuperWord &amp;&amp; Verbose) {
3224     tty-&gt;print_cr(&quot;SWPointer::memory_alignment: off_rem = %d, off_mod = %d&quot;, off_rem, off_mod);
3225   }
3226   return off_mod;
3227 }
3228 
3229 //---------------------------container_type---------------------------
3230 // Smallest type containing range of values
3231 const Type* SuperWord::container_type(Node* n) {
3232   if (n-&gt;is_Mem()) {
3233     BasicType bt = n-&gt;as_Mem()-&gt;memory_type();
3234     if (n-&gt;is_Store() &amp;&amp; (bt == T_CHAR)) {
3235       // Use T_SHORT type instead of T_CHAR for stored values because any
3236       // preceding arithmetic operation extends values to signed Int.
3237       bt = T_SHORT;
3238     }
3239     if (n-&gt;Opcode() == Op_LoadUB) {
3240       // Adjust type for unsigned byte loads, it is important for right shifts.
3241       // T_BOOLEAN is used because there is no basic type representing type
3242       // TypeInt::UBYTE. Use of T_BOOLEAN for vectors is fine because only
3243       // size (one byte) and sign is important.
3244       bt = T_BOOLEAN;
3245     }
3246     return Type::get_const_basic_type(bt);
3247   }
3248   const Type* t = _igvn.type(n);
3249   if (t-&gt;basic_type() == T_INT) {
3250     // A narrow type of arithmetic operations will be determined by
3251     // propagating the type of memory operations.
3252     return TypeInt::INT;
3253   }
3254   return t;
3255 }
3256 
3257 bool SuperWord::same_velt_type(Node* n1, Node* n2) {
3258   const Type* vt1 = velt_type(n1);
3259   const Type* vt2 = velt_type(n2);
3260   if (vt1-&gt;basic_type() == T_INT &amp;&amp; vt2-&gt;basic_type() == T_INT) {
3261     // Compare vectors element sizes for integer types.
3262     return data_size(n1) == data_size(n2);
3263   }
3264   return vt1 == vt2;
3265 }
3266 
3267 //------------------------------in_packset---------------------------
3268 // Are s1 and s2 in a pack pair and ordered as s1,s2?
3269 bool SuperWord::in_packset(Node* s1, Node* s2) {
3270   for (int i = 0; i &lt; _packset.length(); i++) {
3271     Node_List* p = _packset.at(i);
3272     assert(p-&gt;size() == 2, &quot;must be&quot;);
3273     if (p-&gt;at(0) == s1 &amp;&amp; p-&gt;at(p-&gt;size()-1) == s2) {
3274       return true;
3275     }
3276   }
3277   return false;
3278 }
3279 
3280 //------------------------------in_pack---------------------------
3281 // Is s in pack p?
3282 Node_List* SuperWord::in_pack(Node* s, Node_List* p) {
3283   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3284     if (p-&gt;at(i) == s) {
3285       return p;
3286     }
3287   }
3288   return NULL;
3289 }
3290 
3291 //------------------------------remove_pack_at---------------------------
3292 // Remove the pack at position pos in the packset
3293 void SuperWord::remove_pack_at(int pos) {
3294   Node_List* p = _packset.at(pos);
3295   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3296     Node* s = p-&gt;at(i);
3297     set_my_pack(s, NULL);
3298   }
3299   _packset.remove_at(pos);
3300 }
3301 
3302 void SuperWord::packset_sort(int n) {
3303   // simple bubble sort so that we capitalize with O(n) when its already sorted
3304   while (n != 0) {
3305     bool swapped = false;
3306     for (int i = 1; i &lt; n; i++) {
3307       Node_List* q_low = _packset.at(i-1);
3308       Node_List* q_i = _packset.at(i);
3309 
3310       // only swap when we find something to swap
3311       if (alignment(q_low-&gt;at(0)) &gt; alignment(q_i-&gt;at(0))) {
3312         Node_List* t = q_i;
3313         *(_packset.adr_at(i)) = q_low;
3314         *(_packset.adr_at(i-1)) = q_i;
3315         swapped = true;
3316       }
3317     }
3318     if (swapped == false) break;
3319     n--;
3320   }
3321 }
3322 
3323 //------------------------------executed_first---------------------------
3324 // Return the node executed first in pack p.  Uses the RPO block list
3325 // to determine order.
3326 Node* SuperWord::executed_first(Node_List* p) {
3327   Node* n = p-&gt;at(0);
3328   int n_rpo = bb_idx(n);
3329   for (uint i = 1; i &lt; p-&gt;size(); i++) {
3330     Node* s = p-&gt;at(i);
3331     int s_rpo = bb_idx(s);
3332     if (s_rpo &lt; n_rpo) {
3333       n = s;
3334       n_rpo = s_rpo;
3335     }
3336   }
3337   return n;
3338 }
3339 
3340 //------------------------------executed_last---------------------------
3341 // Return the node executed last in pack p.
3342 Node* SuperWord::executed_last(Node_List* p) {
3343   Node* n = p-&gt;at(0);
3344   int n_rpo = bb_idx(n);
3345   for (uint i = 1; i &lt; p-&gt;size(); i++) {
3346     Node* s = p-&gt;at(i);
3347     int s_rpo = bb_idx(s);
3348     if (s_rpo &gt; n_rpo) {
3349       n = s;
3350       n_rpo = s_rpo;
3351     }
3352   }
3353   return n;
3354 }
3355 
3356 LoadNode::ControlDependency SuperWord::control_dependency(Node_List* p) {
3357   LoadNode::ControlDependency dep = LoadNode::DependsOnlyOnTest;
3358   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3359     Node* n = p-&gt;at(i);
3360     assert(n-&gt;is_Load(), &quot;only meaningful for loads&quot;);
3361     if (!n-&gt;depends_only_on_test()) {
3362       if (n-&gt;as_Load()-&gt;has_unknown_control_dependency() &amp;&amp;
3363           dep != LoadNode::Pinned) {
3364         // Upgrade to unknown control...
3365         dep = LoadNode::UnknownControl;
3366       } else {
3367         // Otherwise, we must pin it.
3368         dep = LoadNode::Pinned;
3369       }
3370     }
3371   }
3372   return dep;
3373 }
3374 
3375 
3376 //----------------------------align_initial_loop_index---------------------------
3377 // Adjust pre-loop limit so that in main loop, a load/store reference
3378 // to align_to_ref will be a position zero in the vector.
3379 //   (iv + k) mod vector_align == 0
3380 void SuperWord::align_initial_loop_index(MemNode* align_to_ref) {
3381   CountedLoopNode *main_head = lp()-&gt;as_CountedLoop();
3382   assert(main_head-&gt;is_main_loop(), &quot;&quot;);
3383   CountedLoopEndNode* pre_end = get_pre_loop_end(main_head);
3384   assert(pre_end != NULL, &quot;we must have a correct pre-loop&quot;);
3385   Node *pre_opaq1 = pre_end-&gt;limit();
3386   assert(pre_opaq1-&gt;Opcode() == Op_Opaque1, &quot;&quot;);
3387   Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
3388   Node *lim0 = pre_opaq-&gt;in(1);
3389 
3390   // Where we put new limit calculations
3391   Node *pre_ctrl = pre_end-&gt;loopnode()-&gt;in(LoopNode::EntryControl);
3392 
3393   // Ensure the original loop limit is available from the
3394   // pre-loop Opaque1 node.
3395   Node *orig_limit = pre_opaq-&gt;original_loop_limit();
3396   assert(orig_limit != NULL &amp;&amp; _igvn.type(orig_limit) != Type::TOP, &quot;&quot;);
3397 
3398   SWPointer align_to_ref_p(align_to_ref, this, NULL, false);
3399   assert(align_to_ref_p.valid(), &quot;sanity&quot;);
3400 
3401   // Given:
3402   //     lim0 == original pre loop limit
3403   //     V == v_align (power of 2)
3404   //     invar == extra invariant piece of the address expression
3405   //     e == offset [ +/- invar ]
3406   //
3407   // When reassociating expressions involving &#39;%&#39; the basic rules are:
3408   //     (a - b) % k == 0   =&gt;  a % k == b % k
3409   // and:
3410   //     (a + b) % k == 0   =&gt;  a % k == (k - b) % k
3411   //
3412   // For stride &gt; 0 &amp;&amp; scale &gt; 0,
3413   //   Derive the new pre-loop limit &quot;lim&quot; such that the two constraints:
3414   //     (1) lim = lim0 + N           (where N is some positive integer &lt; V)
3415   //     (2) (e + lim) % V == 0
3416   //   are true.
3417   //
3418   //   Substituting (1) into (2),
3419   //     (e + lim0 + N) % V == 0
3420   //   solve for N:
3421   //     N = (V - (e + lim0)) % V
3422   //   substitute back into (1), so that new limit
3423   //     lim = lim0 + (V - (e + lim0)) % V
3424   //
3425   // For stride &gt; 0 &amp;&amp; scale &lt; 0
3426   //   Constraints:
3427   //     lim = lim0 + N
3428   //     (e - lim) % V == 0
3429   //   Solving for lim:
3430   //     (e - lim0 - N) % V == 0
3431   //     N = (e - lim0) % V
3432   //     lim = lim0 + (e - lim0) % V
3433   //
3434   // For stride &lt; 0 &amp;&amp; scale &gt; 0
3435   //   Constraints:
3436   //     lim = lim0 - N
3437   //     (e + lim) % V == 0
3438   //   Solving for lim:
3439   //     (e + lim0 - N) % V == 0
3440   //     N = (e + lim0) % V
3441   //     lim = lim0 - (e + lim0) % V
3442   //
3443   // For stride &lt; 0 &amp;&amp; scale &lt; 0
3444   //   Constraints:
3445   //     lim = lim0 - N
3446   //     (e - lim) % V == 0
3447   //   Solving for lim:
3448   //     (e - lim0 + N) % V == 0
3449   //     N = (V - (e - lim0)) % V
3450   //     lim = lim0 - (V - (e - lim0)) % V
3451 
3452   int vw = vector_width_in_bytes(align_to_ref);
3453   int stride   = iv_stride();
3454   int scale    = align_to_ref_p.scale_in_bytes();
3455   int elt_size = align_to_ref_p.memory_size();
3456   int v_align  = vw / elt_size;
3457   assert(v_align &gt; 1, &quot;sanity&quot;);
3458   int offset   = align_to_ref_p.offset_in_bytes() / elt_size;
3459   Node *offsn  = _igvn.intcon(offset);
3460 
3461   Node *e = offsn;
3462   if (align_to_ref_p.invar() != NULL) {
3463     // incorporate any extra invariant piece producing (offset +/- invar) &gt;&gt;&gt; log2(elt)
3464     Node* log2_elt = _igvn.intcon(exact_log2(elt_size));
3465     Node* invar = align_to_ref_p.invar();
3466     if (_igvn.type(invar)-&gt;isa_long()) {
3467       // Computations are done % (vector width/element size) so it&#39;s
3468       // safe to simply convert invar to an int and loose the upper 32
3469       // bit half.
3470       invar = new ConvL2INode(invar);
3471       _igvn.register_new_node_with_optimizer(invar);
3472     }
3473     Node* aref = new URShiftINode(invar, log2_elt);
3474     _igvn.register_new_node_with_optimizer(aref);
3475     _phase-&gt;set_ctrl(aref, pre_ctrl);
3476     if (align_to_ref_p.negate_invar()) {
3477       e = new SubINode(e, aref);
3478     } else {
3479       e = new AddINode(e, aref);
3480     }
3481     _igvn.register_new_node_with_optimizer(e);
3482     _phase-&gt;set_ctrl(e, pre_ctrl);
3483   }
3484   if (vw &gt; ObjectAlignmentInBytes || align_to_ref_p.base()-&gt;is_top()) {
3485     // incorporate base e +/- base &amp;&amp; Mask &gt;&gt;&gt; log2(elt)
3486     Node* xbase = new CastP2XNode(NULL, align_to_ref_p.adr());
3487     _igvn.register_new_node_with_optimizer(xbase);
3488 #ifdef _LP64
3489     xbase  = new ConvL2INode(xbase);
3490     _igvn.register_new_node_with_optimizer(xbase);
3491 #endif
3492     Node* mask = _igvn.intcon(vw-1);
3493     Node* masked_xbase  = new AndINode(xbase, mask);
3494     _igvn.register_new_node_with_optimizer(masked_xbase);
3495     Node* log2_elt = _igvn.intcon(exact_log2(elt_size));
3496     Node* bref     = new URShiftINode(masked_xbase, log2_elt);
3497     _igvn.register_new_node_with_optimizer(bref);
3498     _phase-&gt;set_ctrl(bref, pre_ctrl);
3499     e = new AddINode(e, bref);
3500     _igvn.register_new_node_with_optimizer(e);
3501     _phase-&gt;set_ctrl(e, pre_ctrl);
3502   }
3503 
3504   // compute e +/- lim0
3505   if (scale &lt; 0) {
3506     e = new SubINode(e, lim0);
3507   } else {
3508     e = new AddINode(e, lim0);
3509   }
3510   _igvn.register_new_node_with_optimizer(e);
3511   _phase-&gt;set_ctrl(e, pre_ctrl);
3512 
3513   if (stride * scale &gt; 0) {
3514     // compute V - (e +/- lim0)
3515     Node* va  = _igvn.intcon(v_align);
3516     e = new SubINode(va, e);
3517     _igvn.register_new_node_with_optimizer(e);
3518     _phase-&gt;set_ctrl(e, pre_ctrl);
3519   }
3520   // compute N = (exp) % V
3521   Node* va_msk = _igvn.intcon(v_align - 1);
3522   Node* N = new AndINode(e, va_msk);
3523   _igvn.register_new_node_with_optimizer(N);
3524   _phase-&gt;set_ctrl(N, pre_ctrl);
3525 
3526   //   substitute back into (1), so that new limit
3527   //     lim = lim0 + N
3528   Node* lim;
3529   if (stride &lt; 0) {
3530     lim = new SubINode(lim0, N);
3531   } else {
3532     lim = new AddINode(lim0, N);
3533   }
3534   _igvn.register_new_node_with_optimizer(lim);
3535   _phase-&gt;set_ctrl(lim, pre_ctrl);
3536   Node* constrained =
3537     (stride &gt; 0) ? (Node*) new MinINode(lim, orig_limit)
3538                  : (Node*) new MaxINode(lim, orig_limit);
3539   _igvn.register_new_node_with_optimizer(constrained);
3540   _phase-&gt;set_ctrl(constrained, pre_ctrl);
3541   _igvn.replace_input_of(pre_opaq, 1, constrained);
3542 }
3543 
3544 //----------------------------get_pre_loop_end---------------------------
3545 // Find pre loop end from main loop.  Returns null if none.
3546 CountedLoopEndNode* SuperWord::get_pre_loop_end(CountedLoopNode* cl) {
3547   // The loop cannot be optimized if the graph shape at
3548   // the loop entry is inappropriate.
3549   if (!PhaseIdealLoop::is_canonical_loop_entry(cl)) {
3550     return NULL;
3551   }
3552 
3553   Node* p_f = cl-&gt;skip_predicates()-&gt;in(0)-&gt;in(0);
3554   if (!p_f-&gt;is_IfFalse()) return NULL;
3555   if (!p_f-&gt;in(0)-&gt;is_CountedLoopEnd()) return NULL;
3556   CountedLoopEndNode* pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
3557   CountedLoopNode* loop_node = pre_end-&gt;loopnode();
3558   if (loop_node == NULL || !loop_node-&gt;is_pre_loop()) return NULL;
3559   return pre_end;
3560 }
3561 
3562 //------------------------------init---------------------------
3563 void SuperWord::init() {
3564   _dg.init();
3565   _packset.clear();
3566   _disjoint_ptrs.clear();
3567   _block.clear();
3568   _post_block.clear();
3569   _data_entry.clear();
3570   _mem_slice_head.clear();
3571   _mem_slice_tail.clear();
3572   _iteration_first.clear();
3573   _iteration_last.clear();
3574   _node_info.clear();
3575   _align_to_ref = NULL;
3576   _lpt = NULL;
3577   _lp = NULL;
3578   _bb = NULL;
3579   _iv = NULL;
3580   _race_possible = 0;
3581   _early_return = false;
3582   _num_work_vecs = 0;
3583   _num_reductions = 0;
3584 }
3585 
3586 //------------------------------restart---------------------------
3587 void SuperWord::restart() {
3588   _dg.init();
3589   _packset.clear();
3590   _disjoint_ptrs.clear();
3591   _block.clear();
3592   _post_block.clear();
3593   _data_entry.clear();
3594   _mem_slice_head.clear();
3595   _mem_slice_tail.clear();
3596   _node_info.clear();
3597 }
3598 
3599 //------------------------------print_packset---------------------------
3600 void SuperWord::print_packset() {
3601 #ifndef PRODUCT
3602   tty-&gt;print_cr(&quot;packset&quot;);
3603   for (int i = 0; i &lt; _packset.length(); i++) {
3604     tty-&gt;print_cr(&quot;Pack: %d&quot;, i);
3605     Node_List* p = _packset.at(i);
3606     print_pack(p);
3607   }
3608 #endif
3609 }
3610 
3611 //------------------------------print_pack---------------------------
3612 void SuperWord::print_pack(Node_List* p) {
3613   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3614     print_stmt(p-&gt;at(i));
3615   }
3616 }
3617 
3618 //------------------------------print_bb---------------------------
3619 void SuperWord::print_bb() {
3620 #ifndef PRODUCT
3621   tty-&gt;print_cr(&quot;\nBlock&quot;);
3622   for (int i = 0; i &lt; _block.length(); i++) {
3623     Node* n = _block.at(i);
3624     tty-&gt;print(&quot;%d &quot;, i);
3625     if (n) {
3626       n-&gt;dump();
3627     }
3628   }
3629 #endif
3630 }
3631 
3632 //------------------------------print_stmt---------------------------
3633 void SuperWord::print_stmt(Node* s) {
3634 #ifndef PRODUCT
3635   tty-&gt;print(&quot; align: %d \t&quot;, alignment(s));
3636   s-&gt;dump();
3637 #endif
3638 }
3639 
3640 //------------------------------blank---------------------------
3641 char* SuperWord::blank(uint depth) {
3642   static char blanks[101];
3643   assert(depth &lt; 101, &quot;too deep&quot;);
3644   for (uint i = 0; i &lt; depth; i++) blanks[i] = &#39; &#39;;
3645   blanks[depth] = &#39;\0&#39;;
3646   return blanks;
3647 }
3648 
3649 
3650 //==============================SWPointer===========================
3651 #ifndef PRODUCT
3652 int SWPointer::Tracer::_depth = 0;
3653 #endif
3654 //----------------------------SWPointer------------------------
3655 SWPointer::SWPointer(MemNode* mem, SuperWord* slp, Node_Stack *nstack, bool analyze_only) :
3656   _mem(mem), _slp(slp),  _base(NULL),  _adr(NULL),
3657   _scale(0), _offset(0), _invar(NULL), _negate_invar(false),
3658   _nstack(nstack), _analyze_only(analyze_only),
3659   _stack_idx(0)
3660 #ifndef PRODUCT
3661   , _tracer(slp)
3662 #endif
3663 {
3664   NOT_PRODUCT(_tracer.ctor_1(mem);)
3665 
3666   Node* adr = mem-&gt;in(MemNode::Address);
3667   if (!adr-&gt;is_AddP()) {
3668     assert(!valid(), &quot;too complex&quot;);
3669     return;
3670   }
3671   // Match AddP(base, AddP(ptr, k*iv [+ invariant]), constant)
3672   Node* base = adr-&gt;in(AddPNode::Base);
3673   // The base address should be loop invariant
3674   if (!invariant(base)) {
3675     assert(!valid(), &quot;base address is loop variant&quot;);
3676     return;
3677   }
3678   // unsafe references require misaligned vector access support
3679   if (base-&gt;is_top() &amp;&amp; !Matcher::misaligned_vectors_ok()) {
3680     assert(!valid(), &quot;unsafe access&quot;);
3681     return;
3682   }
3683 
3684   NOT_PRODUCT(if(_slp-&gt;is_trace_alignment()) _tracer.store_depth();)
3685   NOT_PRODUCT(_tracer.ctor_2(adr);)
3686 
3687   int i;
3688   for (i = 0; i &lt; 3; i++) {
3689     NOT_PRODUCT(_tracer.ctor_3(adr, i);)
3690 
3691     if (!scaled_iv_plus_offset(adr-&gt;in(AddPNode::Offset))) {
3692       assert(!valid(), &quot;too complex&quot;);
3693       return;
3694     }
3695     adr = adr-&gt;in(AddPNode::Address);
3696     NOT_PRODUCT(_tracer.ctor_4(adr, i);)
3697 
3698     if (base == adr || !adr-&gt;is_AddP()) {
3699       NOT_PRODUCT(_tracer.ctor_5(adr, base, i);)
3700       break; // stop looking at addp&#39;s
3701     }
3702   }
3703   if (!invariant(adr)) {
3704     assert(!valid(), &quot;adr is loop variant&quot;);
3705     return;
3706   }
3707 
3708   if (!base-&gt;is_top() &amp;&amp; adr != base) {
3709     assert(!valid(), &quot;adr and base differ&quot;);
3710     return;
3711   }
3712 
3713   NOT_PRODUCT(if(_slp-&gt;is_trace_alignment()) _tracer.restore_depth();)
3714   NOT_PRODUCT(_tracer.ctor_6(mem);)
3715 
3716   _base = base;
3717   _adr  = adr;
3718   assert(valid(), &quot;Usable&quot;);
3719 }
3720 
3721 // Following is used to create a temporary object during
3722 // the pattern match of an address expression.
3723 SWPointer::SWPointer(SWPointer* p) :
3724   _mem(p-&gt;_mem), _slp(p-&gt;_slp),  _base(NULL),  _adr(NULL),
3725   _scale(0), _offset(0), _invar(NULL), _negate_invar(false),
3726   _nstack(p-&gt;_nstack), _analyze_only(p-&gt;_analyze_only),
3727   _stack_idx(p-&gt;_stack_idx)
3728   #ifndef PRODUCT
3729   , _tracer(p-&gt;_slp)
3730   #endif
3731 {}
3732 
3733 
3734 bool SWPointer::invariant(Node* n) {
3735   NOT_PRODUCT(Tracer::Depth dd;)
3736   Node *n_c = phase()-&gt;get_ctrl(n);
3737   NOT_PRODUCT(_tracer.invariant_1(n, n_c);)
3738   return !lpt()-&gt;is_member(phase()-&gt;get_loop(n_c));
3739 }
3740 //------------------------scaled_iv_plus_offset--------------------
3741 // Match: k*iv + offset
3742 // where: k is a constant that maybe zero, and
3743 //        offset is (k2 [+/- invariant]) where k2 maybe zero and invariant is optional
3744 bool SWPointer::scaled_iv_plus_offset(Node* n) {
3745   NOT_PRODUCT(Tracer::Depth ddd;)
3746   NOT_PRODUCT(_tracer.scaled_iv_plus_offset_1(n);)
3747 
3748   if (scaled_iv(n)) {
3749     NOT_PRODUCT(_tracer.scaled_iv_plus_offset_2(n);)
3750     return true;
3751   }
3752 
3753   if (offset_plus_k(n)) {
3754     NOT_PRODUCT(_tracer.scaled_iv_plus_offset_3(n);)
3755     return true;
3756   }
3757 
3758   int opc = n-&gt;Opcode();
3759   if (opc == Op_AddI) {
3760     if (scaled_iv(n-&gt;in(1)) &amp;&amp; offset_plus_k(n-&gt;in(2))) {
3761       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_4(n);)
3762       return true;
3763     }
3764     if (scaled_iv(n-&gt;in(2)) &amp;&amp; offset_plus_k(n-&gt;in(1))) {
3765       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_5(n);)
3766       return true;
3767     }
3768   } else if (opc == Op_SubI) {
3769     if (scaled_iv(n-&gt;in(1)) &amp;&amp; offset_plus_k(n-&gt;in(2), true)) {
3770       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_6(n);)
3771       return true;
3772     }
3773     if (scaled_iv(n-&gt;in(2)) &amp;&amp; offset_plus_k(n-&gt;in(1))) {
3774       _scale *= -1;
3775       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_7(n);)
3776       return true;
3777     }
3778   }
3779 
3780   NOT_PRODUCT(_tracer.scaled_iv_plus_offset_8(n);)
3781   return false;
3782 }
3783 
3784 //----------------------------scaled_iv------------------------
3785 // Match: k*iv where k is a constant that&#39;s not zero
3786 bool SWPointer::scaled_iv(Node* n) {
3787   NOT_PRODUCT(Tracer::Depth ddd;)
3788   NOT_PRODUCT(_tracer.scaled_iv_1(n);)
3789 
3790   if (_scale != 0) { // already found a scale
3791     NOT_PRODUCT(_tracer.scaled_iv_2(n, _scale);)
3792     return false;
3793   }
3794 
3795   if (n == iv()) {
3796     _scale = 1;
3797     NOT_PRODUCT(_tracer.scaled_iv_3(n, _scale);)
3798     return true;
3799   }
3800   if (_analyze_only &amp;&amp; (invariant(n) == false)) {
3801     _nstack-&gt;push(n, _stack_idx++);
3802   }
3803 
3804   int opc = n-&gt;Opcode();
3805   if (opc == Op_MulI) {
3806     if (n-&gt;in(1) == iv() &amp;&amp; n-&gt;in(2)-&gt;is_Con()) {
3807       _scale = n-&gt;in(2)-&gt;get_int();
3808       NOT_PRODUCT(_tracer.scaled_iv_4(n, _scale);)
3809       return true;
3810     } else if (n-&gt;in(2) == iv() &amp;&amp; n-&gt;in(1)-&gt;is_Con()) {
3811       _scale = n-&gt;in(1)-&gt;get_int();
3812       NOT_PRODUCT(_tracer.scaled_iv_5(n, _scale);)
3813       return true;
3814     }
3815   } else if (opc == Op_LShiftI) {
3816     if (n-&gt;in(1) == iv() &amp;&amp; n-&gt;in(2)-&gt;is_Con()) {
3817       _scale = 1 &lt;&lt; n-&gt;in(2)-&gt;get_int();
3818       NOT_PRODUCT(_tracer.scaled_iv_6(n, _scale);)
3819       return true;
3820     }
3821   } else if (opc == Op_ConvI2L) {
3822     if (n-&gt;in(1)-&gt;Opcode() == Op_CastII &amp;&amp;
3823         n-&gt;in(1)-&gt;as_CastII()-&gt;has_range_check()) {
3824       // Skip range check dependent CastII nodes
3825       n = n-&gt;in(1);
3826     }
3827     if (scaled_iv_plus_offset(n-&gt;in(1))) {
3828       NOT_PRODUCT(_tracer.scaled_iv_7(n);)
3829       return true;
3830     }
3831   } else if (opc == Op_LShiftL) {
3832     if (!has_iv() &amp;&amp; _invar == NULL) {
3833       // Need to preserve the current _offset value, so
3834       // create a temporary object for this expression subtree.
3835       // Hacky, so should re-engineer the address pattern match.
3836       NOT_PRODUCT(Tracer::Depth dddd;)
3837       SWPointer tmp(this);
3838       NOT_PRODUCT(_tracer.scaled_iv_8(n, &amp;tmp);)
3839 
3840       if (tmp.scaled_iv_plus_offset(n-&gt;in(1))) {
3841         if (tmp._invar == NULL || _slp-&gt;do_vector_loop()) {
3842           int mult = 1 &lt;&lt; n-&gt;in(2)-&gt;get_int();
3843           _scale   = tmp._scale  * mult;
3844           _offset += tmp._offset * mult;
3845           NOT_PRODUCT(_tracer.scaled_iv_9(n, _scale, _offset, mult);)
3846           return true;
3847         }
3848       }
3849     }
3850   }
3851   NOT_PRODUCT(_tracer.scaled_iv_10(n);)
3852   return false;
3853 }
3854 
3855 //----------------------------offset_plus_k------------------------
3856 // Match: offset is (k [+/- invariant])
3857 // where k maybe zero and invariant is optional, but not both.
3858 bool SWPointer::offset_plus_k(Node* n, bool negate) {
3859   NOT_PRODUCT(Tracer::Depth ddd;)
3860   NOT_PRODUCT(_tracer.offset_plus_k_1(n);)
3861 
3862   int opc = n-&gt;Opcode();
3863   if (opc == Op_ConI) {
3864     _offset += negate ? -(n-&gt;get_int()) : n-&gt;get_int();
3865     NOT_PRODUCT(_tracer.offset_plus_k_2(n, _offset);)
3866     return true;
3867   } else if (opc == Op_ConL) {
3868     // Okay if value fits into an int
3869     const TypeLong* t = n-&gt;find_long_type();
3870     if (t-&gt;higher_equal(TypeLong::INT)) {
3871       jlong loff = n-&gt;get_long();
3872       jint  off  = (jint)loff;
3873       _offset += negate ? -off : loff;
3874       NOT_PRODUCT(_tracer.offset_plus_k_3(n, _offset);)
3875       return true;
3876     }
3877     NOT_PRODUCT(_tracer.offset_plus_k_4(n);)
3878     return false;
3879   }
3880   if (_invar != NULL) { // already has an invariant
3881     NOT_PRODUCT(_tracer.offset_plus_k_5(n, _invar);)
3882     return false;
3883   }
3884 
3885   if (_analyze_only &amp;&amp; (invariant(n) == false)) {
3886     _nstack-&gt;push(n, _stack_idx++);
3887   }
3888   if (opc == Op_AddI) {
3889     if (n-&gt;in(2)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(1))) {
3890       _negate_invar = negate;
3891       _invar = n-&gt;in(1);
3892       _offset += negate ? -(n-&gt;in(2)-&gt;get_int()) : n-&gt;in(2)-&gt;get_int();
3893       NOT_PRODUCT(_tracer.offset_plus_k_6(n, _invar, _negate_invar, _offset);)
3894       return true;
3895     } else if (n-&gt;in(1)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(2))) {
3896       _offset += negate ? -(n-&gt;in(1)-&gt;get_int()) : n-&gt;in(1)-&gt;get_int();
3897       _negate_invar = negate;
3898       _invar = n-&gt;in(2);
3899       NOT_PRODUCT(_tracer.offset_plus_k_7(n, _invar, _negate_invar, _offset);)
3900       return true;
3901     }
3902   }
3903   if (opc == Op_SubI) {
3904     if (n-&gt;in(2)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(1))) {
3905       _negate_invar = negate;
3906       _invar = n-&gt;in(1);
3907       _offset += !negate ? -(n-&gt;in(2)-&gt;get_int()) : n-&gt;in(2)-&gt;get_int();
3908       NOT_PRODUCT(_tracer.offset_plus_k_8(n, _invar, _negate_invar, _offset);)
3909       return true;
3910     } else if (n-&gt;in(1)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(2))) {
3911       _offset += negate ? -(n-&gt;in(1)-&gt;get_int()) : n-&gt;in(1)-&gt;get_int();
3912       _negate_invar = !negate;
3913       _invar = n-&gt;in(2);
3914       NOT_PRODUCT(_tracer.offset_plus_k_9(n, _invar, _negate_invar, _offset);)
3915       return true;
3916     }
3917   }
3918   if (invariant(n)) {
3919     if (opc == Op_ConvI2L) {
3920       n = n-&gt;in(1);
3921       if (n-&gt;Opcode() == Op_CastII &amp;&amp;
3922           n-&gt;as_CastII()-&gt;has_range_check()) {
3923         // Skip range check dependent CastII nodes
3924         assert(invariant(n), &quot;sanity&quot;);
3925         n = n-&gt;in(1);
3926       }
3927     }
3928     _negate_invar = negate;
3929     _invar = n;
3930     NOT_PRODUCT(_tracer.offset_plus_k_10(n, _invar, _negate_invar, _offset);)
3931     return true;
3932   }
3933 
3934   NOT_PRODUCT(_tracer.offset_plus_k_11(n);)
3935   return false;
3936 }
3937 
3938 //----------------------------print------------------------
3939 void SWPointer::print() {
3940 #ifndef PRODUCT
3941   tty-&gt;print(&quot;base: %d  adr: %d  scale: %d  offset: %d  invar: %c%d\n&quot;,
3942              _base != NULL ? _base-&gt;_idx : 0,
3943              _adr  != NULL ? _adr-&gt;_idx  : 0,
3944              _scale, _offset,
3945              _negate_invar?&#39;-&#39;:&#39;+&#39;,
3946              _invar != NULL ? _invar-&gt;_idx : 0);
3947 #endif
3948 }
3949 
3950 //----------------------------tracing------------------------
3951 #ifndef PRODUCT
3952 void SWPointer::Tracer::print_depth() {
3953   for (int ii = 0; ii&lt;_depth; ++ii) tty-&gt;print(&quot;  &quot;);
3954 }
3955 
3956 void SWPointer::Tracer::ctor_1 (Node* mem) {
3957   if(_slp-&gt;is_trace_alignment()) {
3958     print_depth(); tty-&gt;print(&quot; %d SWPointer::SWPointer: start alignment analysis&quot;, mem-&gt;_idx); mem-&gt;dump();
3959   }
3960 }
3961 
3962 void SWPointer::Tracer::ctor_2(Node* adr) {
3963   if(_slp-&gt;is_trace_alignment()) {
3964     //store_depth();
3965     inc_depth();
3966     print_depth(); tty-&gt;print(&quot; %d (adr) SWPointer::SWPointer: &quot;, adr-&gt;_idx); adr-&gt;dump();
3967     inc_depth();
3968     print_depth(); tty-&gt;print(&quot; %d (base) SWPointer::SWPointer: &quot;, adr-&gt;in(AddPNode::Base)-&gt;_idx); adr-&gt;in(AddPNode::Base)-&gt;dump();
3969   }
3970 }
3971 
3972 void SWPointer::Tracer::ctor_3(Node* adr, int i) {
3973   if(_slp-&gt;is_trace_alignment()) {
3974     inc_depth();
3975     Node* offset = adr-&gt;in(AddPNode::Offset);
3976     print_depth(); tty-&gt;print(&quot; %d (offset) SWPointer::SWPointer: i = %d: &quot;, offset-&gt;_idx, i); offset-&gt;dump();
3977   }
3978 }
3979 
3980 void SWPointer::Tracer::ctor_4(Node* adr, int i) {
3981   if(_slp-&gt;is_trace_alignment()) {
3982     inc_depth();
3983     print_depth(); tty-&gt;print(&quot; %d (adr) SWPointer::SWPointer: i = %d: &quot;, adr-&gt;_idx, i); adr-&gt;dump();
3984   }
3985 }
3986 
3987 void SWPointer::Tracer::ctor_5(Node* adr, Node* base, int i) {
3988   if(_slp-&gt;is_trace_alignment()) {
3989     inc_depth();
3990     if (base == adr) {
3991       print_depth(); tty-&gt;print_cr(&quot;  \\ %d (adr) == %d (base) SWPointer::SWPointer: breaking analysis at i = %d&quot;, adr-&gt;_idx, base-&gt;_idx, i);
3992     } else if (!adr-&gt;is_AddP()) {
3993       print_depth(); tty-&gt;print_cr(&quot;  \\ %d (adr) is NOT Addp SWPointer::SWPointer: breaking analysis at i = %d&quot;, adr-&gt;_idx, i);
3994     }
3995   }
3996 }
3997 
3998 void SWPointer::Tracer::ctor_6(Node* mem) {
3999   if(_slp-&gt;is_trace_alignment()) {
4000     //restore_depth();
4001     print_depth(); tty-&gt;print_cr(&quot; %d (adr) SWPointer::SWPointer: stop analysis&quot;, mem-&gt;_idx);
4002   }
4003 }
4004 
4005 void SWPointer::Tracer::invariant_1(Node *n, Node *n_c) {
4006   if (_slp-&gt;do_vector_loop() &amp;&amp; _slp-&gt;is_debug() &amp;&amp; _slp-&gt;_lpt-&gt;is_member(_slp-&gt;_phase-&gt;get_loop(n_c)) != (int)_slp-&gt;in_bb(n)) {
4007     int is_member =  _slp-&gt;_lpt-&gt;is_member(_slp-&gt;_phase-&gt;get_loop(n_c));
4008     int in_bb     =  _slp-&gt;in_bb(n);
4009     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  tty-&gt;print_cr(&quot; %d SWPointer::invariant  conditions differ: n_c %d&quot;, n-&gt;_idx, n_c-&gt;_idx);
4010     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  tty-&gt;print_cr(&quot;is_member %d, in_bb %d&quot;, is_member, in_bb);
4011     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  n-&gt;dump();
4012     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  n_c-&gt;dump();
4013   }
4014 }
4015 
4016 void SWPointer::Tracer::scaled_iv_plus_offset_1(Node* n) {
4017   if(_slp-&gt;is_trace_alignment()) {
4018     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv_plus_offset testing node: &quot;, n-&gt;_idx);
4019     n-&gt;dump();
4020   }
4021 }
4022 
4023 void SWPointer::Tracer::scaled_iv_plus_offset_2(Node* n) {
4024   if(_slp-&gt;is_trace_alignment()) {
4025     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: PASSED&quot;, n-&gt;_idx);
4026   }
4027 }
4028 
4029 void SWPointer::Tracer::scaled_iv_plus_offset_3(Node* n) {
4030   if(_slp-&gt;is_trace_alignment()) {
4031     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: PASSED&quot;, n-&gt;_idx);
4032   }
4033 }
4034 
4035 void SWPointer::Tracer::scaled_iv_plus_offset_4(Node* n) {
4036   if(_slp-&gt;is_trace_alignment()) {
4037     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_AddI PASSED&quot;, n-&gt;_idx);
4038     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is scaled_iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4039     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is offset_plus_k: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4040   }
4041 }
4042 
4043 void SWPointer::Tracer::scaled_iv_plus_offset_5(Node* n) {
4044   if(_slp-&gt;is_trace_alignment()) {
4045     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_AddI PASSED&quot;, n-&gt;_idx);
4046     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is scaled_iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4047     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is offset_plus_k: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4048   }
4049 }
4050 
4051 void SWPointer::Tracer::scaled_iv_plus_offset_6(Node* n) {
4052   if(_slp-&gt;is_trace_alignment()) {
4053     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_SubI PASSED&quot;, n-&gt;_idx);
4054     print_depth(); tty-&gt;print(&quot;  \\  %d SWPointer::scaled_iv_plus_offset: in(1) is scaled_iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4055     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is offset_plus_k: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4056   }
4057 }
4058 
4059 void SWPointer::Tracer::scaled_iv_plus_offset_7(Node* n) {
4060   if(_slp-&gt;is_trace_alignment()) {
4061     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_SubI PASSED&quot;, n-&gt;_idx);
4062     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is scaled_iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4063     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is offset_plus_k: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4064   }
4065 }
4066 
4067 void SWPointer::Tracer::scaled_iv_plus_offset_8(Node* n) {
4068   if(_slp-&gt;is_trace_alignment()) {
4069     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: FAILED&quot;, n-&gt;_idx);
4070   }
4071 }
4072 
4073 void SWPointer::Tracer::scaled_iv_1(Node* n) {
4074   if(_slp-&gt;is_trace_alignment()) {
4075     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv: testing node: &quot;, n-&gt;_idx); n-&gt;dump();
4076   }
4077 }
4078 
4079 void SWPointer::Tracer::scaled_iv_2(Node* n, int scale) {
4080   if(_slp-&gt;is_trace_alignment()) {
4081     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: FAILED since another _scale has been detected before&quot;, n-&gt;_idx);
4082     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: _scale (%d) != 0&quot;, scale);
4083   }
4084 }
4085 
4086 void SWPointer::Tracer::scaled_iv_3(Node* n, int scale) {
4087   if(_slp-&gt;is_trace_alignment()) {
4088     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: is iv, setting _scale = %d&quot;, n-&gt;_idx, scale);
4089   }
4090 }
4091 
4092 void SWPointer::Tracer::scaled_iv_4(Node* n, int scale) {
4093   if(_slp-&gt;is_trace_alignment()) {
4094     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_MulI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4095     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4096     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4097   }
4098 }
4099 
4100 void SWPointer::Tracer::scaled_iv_5(Node* n, int scale) {
4101   if(_slp-&gt;is_trace_alignment()) {
4102     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_MulI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4103     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4104     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4105   }
4106 }
4107 
4108 void SWPointer::Tracer::scaled_iv_6(Node* n, int scale) {
4109   if(_slp-&gt;is_trace_alignment()) {
4110     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_LShiftI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4111     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4112     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4113   }
4114 }
4115 
4116 void SWPointer::Tracer::scaled_iv_7(Node* n) {
4117   if(_slp-&gt;is_trace_alignment()) {
4118     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_ConvI2L PASSED&quot;, n-&gt;_idx);
4119     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: in(1) %d is scaled_iv_plus_offset: &quot;, n-&gt;in(1)-&gt;_idx);
4120     inc_depth(); inc_depth();
4121     print_depth(); n-&gt;in(1)-&gt;dump();
4122     dec_depth(); dec_depth();
4123   }
4124 }
4125 
4126 void SWPointer::Tracer::scaled_iv_8(Node* n, SWPointer* tmp) {
4127   if(_slp-&gt;is_trace_alignment()) {
4128     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv: Op_LShiftL, creating tmp SWPointer: &quot;, n-&gt;_idx); tmp-&gt;print();
4129   }
4130 }
4131 
4132 void SWPointer::Tracer::scaled_iv_9(Node* n, int scale, int _offset, int mult) {
4133   if(_slp-&gt;is_trace_alignment()) {
4134     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_LShiftL PASSED, setting _scale = %d, _offset = %d&quot;, n-&gt;_idx, scale, _offset);
4135     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: in(1) %d is scaled_iv_plus_offset, in(2) %d used to get mult = %d: _scale = %d, _offset = %d&quot;,
4136     n-&gt;in(1)-&gt;_idx, n-&gt;in(2)-&gt;_idx, mult, scale, _offset);
4137     inc_depth(); inc_depth();
4138     print_depth(); n-&gt;in(1)-&gt;dump();
4139     print_depth(); n-&gt;in(2)-&gt;dump();
4140     dec_depth(); dec_depth();
4141   }
4142 }
4143 
4144 void SWPointer::Tracer::scaled_iv_10(Node* n) {
4145   if(_slp-&gt;is_trace_alignment()) {
4146     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: FAILED&quot;, n-&gt;_idx);
4147   }
4148 }
4149 
4150 void SWPointer::Tracer::offset_plus_k_1(Node* n) {
4151   if(_slp-&gt;is_trace_alignment()) {
4152     print_depth(); tty-&gt;print(&quot; %d SWPointer::offset_plus_k: testing node: &quot;, n-&gt;_idx); n-&gt;dump();
4153   }
4154 }
4155 
4156 void SWPointer::Tracer::offset_plus_k_2(Node* n, int _offset) {
4157   if(_slp-&gt;is_trace_alignment()) {
4158     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_ConI PASSED, setting _offset = %d&quot;, n-&gt;_idx, _offset);
4159   }
4160 }
4161 
4162 void SWPointer::Tracer::offset_plus_k_3(Node* n, int _offset) {
4163   if(_slp-&gt;is_trace_alignment()) {
4164     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_ConL PASSED, setting _offset = %d&quot;, n-&gt;_idx, _offset);
4165   }
4166 }
4167 
4168 void SWPointer::Tracer::offset_plus_k_4(Node* n) {
4169   if(_slp-&gt;is_trace_alignment()) {
4170     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED&quot;, n-&gt;_idx);
4171     print_depth(); tty-&gt;print_cr(&quot;  \\ &quot; JLONG_FORMAT &quot; SWPointer::offset_plus_k: Op_ConL FAILED, k is too big&quot;, n-&gt;get_long());
4172   }
4173 }
4174 
4175 void SWPointer::Tracer::offset_plus_k_5(Node* n, Node* _invar) {
4176   if(_slp-&gt;is_trace_alignment()) {
4177     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED since another invariant has been detected before&quot;, n-&gt;_idx);
4178     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: _invar != NULL: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4179   }
4180 }
4181 
4182 void SWPointer::Tracer::offset_plus_k_6(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4183   if(_slp-&gt;is_trace_alignment()) {
4184     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4185     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4186     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4187     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4188   }
4189 }
4190 
4191 void SWPointer::Tracer::offset_plus_k_7(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4192   if(_slp-&gt;is_trace_alignment()) {
4193     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4194     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4195     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4196     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4197   }
4198 }
4199 
4200 void SWPointer::Tracer::offset_plus_k_8(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4201   if(_slp-&gt;is_trace_alignment()) {
4202     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_SubI is PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4203     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4204     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4205     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4206   }
4207 }
4208 
4209 void SWPointer::Tracer::offset_plus_k_9(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4210   if(_slp-&gt;is_trace_alignment()) {
4211     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_SubI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;, n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4212     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4213     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4214   }
4215 }
4216 
4217 void SWPointer::Tracer::offset_plus_k_10(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4218   if(_slp-&gt;is_trace_alignment()) {
4219     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;, n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4220     print_depth(); tty-&gt;print_cr(&quot;  \\ %d SWPointer::offset_plus_k: is invariant&quot;, n-&gt;_idx);
4221   }
4222 }
4223 
4224 void SWPointer::Tracer::offset_plus_k_11(Node* n) {
4225   if(_slp-&gt;is_trace_alignment()) {
4226     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED&quot;, n-&gt;_idx);
4227   }
4228 }
4229 
4230 #endif
4231 // ========================= OrderedPair =====================
4232 
4233 const OrderedPair OrderedPair::initial;
4234 
4235 // ========================= SWNodeInfo =====================
4236 
4237 const SWNodeInfo SWNodeInfo::initial;
4238 
4239 
4240 // ============================ DepGraph ===========================
4241 
4242 //------------------------------make_node---------------------------
4243 // Make a new dependence graph node for an ideal node.
4244 DepMem* DepGraph::make_node(Node* node) {
4245   DepMem* m = new (_arena) DepMem(node);
4246   if (node != NULL) {
4247     assert(_map.at_grow(node-&gt;_idx) == NULL, &quot;one init only&quot;);
4248     _map.at_put_grow(node-&gt;_idx, m);
4249   }
4250   return m;
4251 }
4252 
4253 //------------------------------make_edge---------------------------
4254 // Make a new dependence graph edge from dpred -&gt; dsucc
4255 DepEdge* DepGraph::make_edge(DepMem* dpred, DepMem* dsucc) {
4256   DepEdge* e = new (_arena) DepEdge(dpred, dsucc, dsucc-&gt;in_head(), dpred-&gt;out_head());
4257   dpred-&gt;set_out_head(e);
4258   dsucc-&gt;set_in_head(e);
4259   return e;
4260 }
4261 
4262 // ========================== DepMem ========================
4263 
4264 //------------------------------in_cnt---------------------------
4265 int DepMem::in_cnt() {
4266   int ct = 0;
4267   for (DepEdge* e = _in_head; e != NULL; e = e-&gt;next_in()) ct++;
4268   return ct;
4269 }
4270 
4271 //------------------------------out_cnt---------------------------
4272 int DepMem::out_cnt() {
4273   int ct = 0;
4274   for (DepEdge* e = _out_head; e != NULL; e = e-&gt;next_out()) ct++;
4275   return ct;
4276 }
4277 
4278 //------------------------------print-----------------------------
4279 void DepMem::print() {
4280 #ifndef PRODUCT
4281   tty-&gt;print(&quot;  DepNode %d (&quot;, _node-&gt;_idx);
4282   for (DepEdge* p = _in_head; p != NULL; p = p-&gt;next_in()) {
4283     Node* pred = p-&gt;pred()-&gt;node();
4284     tty-&gt;print(&quot; %d&quot;, pred != NULL ? pred-&gt;_idx : 0);
4285   }
4286   tty-&gt;print(&quot;) [&quot;);
4287   for (DepEdge* s = _out_head; s != NULL; s = s-&gt;next_out()) {
4288     Node* succ = s-&gt;succ()-&gt;node();
4289     tty-&gt;print(&quot; %d&quot;, succ != NULL ? succ-&gt;_idx : 0);
4290   }
4291   tty-&gt;print_cr(&quot; ]&quot;);
4292 #endif
4293 }
4294 
4295 // =========================== DepEdge =========================
4296 
4297 //------------------------------DepPreds---------------------------
4298 void DepEdge::print() {
4299 #ifndef PRODUCT
4300   tty-&gt;print_cr(&quot;DepEdge: %d [ %d ]&quot;, _pred-&gt;node()-&gt;_idx, _succ-&gt;node()-&gt;_idx);
4301 #endif
4302 }
4303 
4304 // =========================== DepPreds =========================
4305 // Iterator over predecessor edges in the dependence graph.
4306 
4307 //------------------------------DepPreds---------------------------
4308 DepPreds::DepPreds(Node* n, DepGraph&amp; dg) {
4309   _n = n;
4310   _done = false;
4311   if (_n-&gt;is_Store() || _n-&gt;is_Load()) {
4312     _next_idx = MemNode::Address;
4313     _end_idx  = n-&gt;req();
4314     _dep_next = dg.dep(_n)-&gt;in_head();
4315   } else if (_n-&gt;is_Mem()) {
4316     _next_idx = 0;
4317     _end_idx  = 0;
4318     _dep_next = dg.dep(_n)-&gt;in_head();
4319   } else {
4320     _next_idx = 1;
4321     _end_idx  = _n-&gt;req();
4322     _dep_next = NULL;
4323   }
4324   next();
4325 }
4326 
4327 //------------------------------next---------------------------
4328 void DepPreds::next() {
4329   if (_dep_next != NULL) {
4330     _current  = _dep_next-&gt;pred()-&gt;node();
4331     _dep_next = _dep_next-&gt;next_in();
4332   } else if (_next_idx &lt; _end_idx) {
4333     _current  = _n-&gt;in(_next_idx++);
4334   } else {
4335     _done = true;
4336   }
4337 }
4338 
4339 // =========================== DepSuccs =========================
4340 // Iterator over successor edges in the dependence graph.
4341 
4342 //------------------------------DepSuccs---------------------------
4343 DepSuccs::DepSuccs(Node* n, DepGraph&amp; dg) {
4344   _n = n;
4345   _done = false;
4346   if (_n-&gt;is_Load()) {
4347     _next_idx = 0;
4348     _end_idx  = _n-&gt;outcnt();
4349     _dep_next = dg.dep(_n)-&gt;out_head();
4350   } else if (_n-&gt;is_Mem() || (_n-&gt;is_Phi() &amp;&amp; _n-&gt;bottom_type() == Type::MEMORY)) {
4351     _next_idx = 0;
4352     _end_idx  = 0;
4353     _dep_next = dg.dep(_n)-&gt;out_head();
4354   } else {
4355     _next_idx = 0;
4356     _end_idx  = _n-&gt;outcnt();
4357     _dep_next = NULL;
4358   }
4359   next();
4360 }
4361 
4362 //-------------------------------next---------------------------
4363 void DepSuccs::next() {
4364   if (_dep_next != NULL) {
4365     _current  = _dep_next-&gt;succ()-&gt;node();
4366     _dep_next = _dep_next-&gt;next_out();
4367   } else if (_next_idx &lt; _end_idx) {
4368     _current  = _n-&gt;raw_out(_next_idx++);
4369   } else {
4370     _done = true;
4371   }
4372 }
4373 
4374 //
4375 // --------------------------------- vectorization/simd -----------------------------------
4376 //
4377 bool SuperWord::same_origin_idx(Node* a, Node* b) const {
4378   return a != NULL &amp;&amp; b != NULL &amp;&amp; _clone_map.same_idx(a-&gt;_idx, b-&gt;_idx);
4379 }
4380 bool SuperWord::same_generation(Node* a, Node* b) const {
4381   return a != NULL &amp;&amp; b != NULL &amp;&amp; _clone_map.same_gen(a-&gt;_idx, b-&gt;_idx);
4382 }
4383 
4384 Node*  SuperWord::find_phi_for_mem_dep(LoadNode* ld) {
4385   assert(in_bb(ld), &quot;must be in block&quot;);
4386   if (_clone_map.gen(ld-&gt;_idx) == _ii_first) {
4387 #ifndef PRODUCT
4388     if (_vector_loop_debug) {
4389       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep _clone_map.gen(ld-&gt;_idx)=%d&quot;,
4390         _clone_map.gen(ld-&gt;_idx));
4391     }
4392 #endif
4393     return NULL; //we think that any ld in the first gen being vectorizable
4394   }
4395 
4396   Node* mem = ld-&gt;in(MemNode::Memory);
4397   if (mem-&gt;outcnt() &lt;= 1) {
4398     // we don&#39;t want to remove the only edge from mem node to load
4399 #ifndef PRODUCT
4400     if (_vector_loop_debug) {
4401       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep input node %d to load %d has no other outputs and edge mem-&gt;load cannot be removed&quot;,
4402         mem-&gt;_idx, ld-&gt;_idx);
4403       ld-&gt;dump();
4404       mem-&gt;dump();
4405     }
4406 #endif
4407     return NULL;
4408   }
4409   if (!in_bb(mem) || same_generation(mem, ld)) {
4410 #ifndef PRODUCT
4411     if (_vector_loop_debug) {
4412       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep _clone_map.gen(mem-&gt;_idx)=%d&quot;,
4413         _clone_map.gen(mem-&gt;_idx));
4414     }
4415 #endif
4416     return NULL; // does not depend on loop volatile node or depends on the same generation
4417   }
4418 
4419   //otherwise first node should depend on mem-phi
4420   Node* first = first_node(ld);
4421   assert(first-&gt;is_Load(), &quot;must be Load&quot;);
4422   Node* phi = first-&gt;as_Load()-&gt;in(MemNode::Memory);
4423   if (!phi-&gt;is_Phi() || phi-&gt;bottom_type() != Type::MEMORY) {
4424 #ifndef PRODUCT
4425     if (_vector_loop_debug) {
4426       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep load is not vectorizable node, since it&#39;s `first` does not take input from mem phi&quot;);
4427       ld-&gt;dump();
4428       first-&gt;dump();
4429     }
4430 #endif
4431     return NULL;
4432   }
4433 
4434   Node* tail = 0;
4435   for (int m = 0; m &lt; _mem_slice_head.length(); m++) {
4436     if (_mem_slice_head.at(m) == phi) {
4437       tail = _mem_slice_tail.at(m);
4438     }
4439   }
4440   if (tail == 0) { //test that found phi is in the list  _mem_slice_head
4441 #ifndef PRODUCT
4442     if (_vector_loop_debug) {
4443       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep load %d is not vectorizable node, its phi %d is not _mem_slice_head&quot;,
4444         ld-&gt;_idx, phi-&gt;_idx);
4445       ld-&gt;dump();
4446       phi-&gt;dump();
4447     }
4448 #endif
4449     return NULL;
4450   }
4451 
4452   // now all conditions are met
4453   return phi;
4454 }
4455 
4456 Node* SuperWord::first_node(Node* nd) {
4457   for (int ii = 0; ii &lt; _iteration_first.length(); ii++) {
4458     Node* nnn = _iteration_first.at(ii);
4459     if (same_origin_idx(nnn, nd)) {
4460 #ifndef PRODUCT
4461       if (_vector_loop_debug) {
4462         tty-&gt;print_cr(&quot;SuperWord::first_node: %d is the first iteration node for %d (_clone_map.idx(nnn-&gt;_idx) = %d)&quot;,
4463           nnn-&gt;_idx, nd-&gt;_idx, _clone_map.idx(nnn-&gt;_idx));
4464       }
4465 #endif
4466       return nnn;
4467     }
4468   }
4469 
4470 #ifndef PRODUCT
4471   if (_vector_loop_debug) {
4472     tty-&gt;print_cr(&quot;SuperWord::first_node: did not find first iteration node for %d (_clone_map.idx(nd-&gt;_idx)=%d)&quot;,
4473       nd-&gt;_idx, _clone_map.idx(nd-&gt;_idx));
4474   }
4475 #endif
4476   return 0;
4477 }
4478 
4479 Node* SuperWord::last_node(Node* nd) {
4480   for (int ii = 0; ii &lt; _iteration_last.length(); ii++) {
4481     Node* nnn = _iteration_last.at(ii);
4482     if (same_origin_idx(nnn, nd)) {
4483 #ifndef PRODUCT
4484       if (_vector_loop_debug) {
4485         tty-&gt;print_cr(&quot;SuperWord::last_node _clone_map.idx(nnn-&gt;_idx)=%d, _clone_map.idx(nd-&gt;_idx)=%d&quot;,
4486           _clone_map.idx(nnn-&gt;_idx), _clone_map.idx(nd-&gt;_idx));
4487       }
4488 #endif
4489       return nnn;
4490     }
4491   }
4492   return 0;
4493 }
4494 
4495 int SuperWord::mark_generations() {
4496   Node *ii_err = NULL, *tail_err = NULL;
4497   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
4498     Node* phi  = _mem_slice_head.at(i);
4499     assert(phi-&gt;is_Phi(), &quot;must be phi&quot;);
4500 
4501     Node* tail = _mem_slice_tail.at(i);
4502     if (_ii_last == -1) {
4503       tail_err = tail;
4504       _ii_last = _clone_map.gen(tail-&gt;_idx);
4505     }
4506     else if (_ii_last != _clone_map.gen(tail-&gt;_idx)) {
4507 #ifndef PRODUCT
4508       if (TraceSuperWord &amp;&amp; Verbose) {
4509         tty-&gt;print_cr(&quot;SuperWord::mark_generations _ii_last error - found different generations in two tail nodes &quot;);
4510         tail-&gt;dump();
4511         tail_err-&gt;dump();
4512       }
4513 #endif
4514       return -1;
4515     }
4516 
4517     // find first iteration in the loop
4518     for (DUIterator_Fast imax, i = phi-&gt;fast_outs(imax); i &lt; imax; i++) {
4519       Node* ii = phi-&gt;fast_out(i);
4520       if (in_bb(ii) &amp;&amp; ii-&gt;is_Store()) { // we speculate that normally Stores of one and one only generation have deps from mem phi
4521         if (_ii_first == -1) {
4522           ii_err = ii;
4523           _ii_first = _clone_map.gen(ii-&gt;_idx);
4524         } else if (_ii_first != _clone_map.gen(ii-&gt;_idx)) {
4525 #ifndef PRODUCT
4526           if (TraceSuperWord &amp;&amp; Verbose) {
4527             tty-&gt;print_cr(&quot;SuperWord::mark_generations: _ii_first was found before and not equal to one in this node (%d)&quot;, _ii_first);
4528             ii-&gt;dump();
4529             if (ii_err!= 0) {
4530               ii_err-&gt;dump();
4531             }
4532           }
4533 #endif
4534           return -1; // this phi has Stores from different generations of unroll and cannot be simd/vectorized
4535         }
4536       }
4537     }//for (DUIterator_Fast imax,
4538   }//for (int i...
4539 
4540   if (_ii_first == -1 || _ii_last == -1) {
4541     if (TraceSuperWord &amp;&amp; Verbose) {
4542       tty-&gt;print_cr(&quot;SuperWord::mark_generations unknown error, something vent wrong&quot;);
4543     }
4544     return -1; // something vent wrong
4545   }
4546   // collect nodes in the first and last generations
4547   assert(_iteration_first.length() == 0, &quot;_iteration_first must be empty&quot;);
4548   assert(_iteration_last.length() == 0, &quot;_iteration_last must be empty&quot;);
4549   for (int j = 0; j &lt; _block.length(); j++) {
4550     Node* n = _block.at(j);
4551     node_idx_t gen = _clone_map.gen(n-&gt;_idx);
4552     if ((signed)gen == _ii_first) {
4553       _iteration_first.push(n);
4554     } else if ((signed)gen == _ii_last) {
4555       _iteration_last.push(n);
4556     }
4557   }
4558 
4559   // building order of iterations
4560   if (_ii_order.length() == 0 &amp;&amp; ii_err != 0) {
4561     assert(in_bb(ii_err) &amp;&amp; ii_err-&gt;is_Store(), &quot;should be Store in bb&quot;);
4562     Node* nd = ii_err;
4563     while(_clone_map.gen(nd-&gt;_idx) != _ii_last) {
4564       _ii_order.push(_clone_map.gen(nd-&gt;_idx));
4565       bool found = false;
4566       for (DUIterator_Fast imax, i = nd-&gt;fast_outs(imax); i &lt; imax; i++) {
4567         Node* use = nd-&gt;fast_out(i);
4568         if (same_origin_idx(use, nd) &amp;&amp; use-&gt;as_Store()-&gt;in(MemNode::Memory) == nd) {
4569           found = true;
4570           nd = use;
4571           break;
4572         }
4573       }//for
4574 
4575       if (found == false) {
4576         if (TraceSuperWord &amp;&amp; Verbose) {
4577           tty-&gt;print_cr(&quot;SuperWord::mark_generations: Cannot build order of iterations - no dependent Store for %d&quot;, nd-&gt;_idx);
4578         }
4579         _ii_order.clear();
4580         return -1;
4581       }
4582     } //while
4583     _ii_order.push(_clone_map.gen(nd-&gt;_idx));
4584   }
4585 
4586 #ifndef PRODUCT
4587   if (_vector_loop_debug) {
4588     tty-&gt;print_cr(&quot;SuperWord::mark_generations&quot;);
4589     tty-&gt;print_cr(&quot;First generation (%d) nodes:&quot;, _ii_first);
4590     for (int ii = 0; ii &lt; _iteration_first.length(); ii++)  _iteration_first.at(ii)-&gt;dump();
4591     tty-&gt;print_cr(&quot;Last generation (%d) nodes:&quot;, _ii_last);
4592     for (int ii = 0; ii &lt; _iteration_last.length(); ii++)  _iteration_last.at(ii)-&gt;dump();
4593     tty-&gt;print_cr(&quot; &quot;);
4594 
4595     tty-&gt;print(&quot;SuperWord::List of generations: &quot;);
4596     for (int jj = 0; jj &lt; _ii_order.length(); ++jj) {
4597       tty-&gt;print(&quot;%d:%d &quot;, jj, _ii_order.at(jj));
4598     }
4599     tty-&gt;print_cr(&quot; &quot;);
4600   }
4601 #endif
4602 
4603   return _ii_first;
4604 }
4605 
4606 bool SuperWord::fix_commutative_inputs(Node* gold, Node* fix) {
4607   assert(gold-&gt;is_Add() &amp;&amp; fix-&gt;is_Add() || gold-&gt;is_Mul() &amp;&amp; fix-&gt;is_Mul(), &quot;should be only Add or Mul nodes&quot;);
4608   assert(same_origin_idx(gold, fix), &quot;should be clones of the same node&quot;);
4609   Node* gin1 = gold-&gt;in(1);
4610   Node* gin2 = gold-&gt;in(2);
4611   Node* fin1 = fix-&gt;in(1);
4612   Node* fin2 = fix-&gt;in(2);
4613   bool swapped = false;
4614 
4615   if (in_bb(gin1) &amp;&amp; in_bb(gin2) &amp;&amp; in_bb(fin1) &amp;&amp; in_bb(fin1)) {
4616     if (same_origin_idx(gin1, fin1) &amp;&amp;
4617         same_origin_idx(gin2, fin2)) {
4618       return true; // nothing to fix
4619     }
4620     if (same_origin_idx(gin1, fin2) &amp;&amp;
4621         same_origin_idx(gin2, fin1)) {
4622       fix-&gt;swap_edges(1, 2);
4623       swapped = true;
4624     }
4625   }
4626   // at least one input comes from outside of bb
4627   if (gin1-&gt;_idx == fin1-&gt;_idx)  {
4628     return true; // nothing to fix
4629   }
4630   if (!swapped &amp;&amp; (gin1-&gt;_idx == fin2-&gt;_idx || gin2-&gt;_idx == fin1-&gt;_idx))  { //swapping is expensive, check condition first
4631     fix-&gt;swap_edges(1, 2);
4632     swapped = true;
4633   }
4634 
4635   if (swapped) {
4636 #ifndef PRODUCT
4637     if (_vector_loop_debug) {
4638       tty-&gt;print_cr(&quot;SuperWord::fix_commutative_inputs: fixed node %d&quot;, fix-&gt;_idx);
4639     }
4640 #endif
4641     return true;
4642   }
4643 
4644   if (TraceSuperWord &amp;&amp; Verbose) {
4645     tty-&gt;print_cr(&quot;SuperWord::fix_commutative_inputs: cannot fix node %d&quot;, fix-&gt;_idx);
4646   }
4647 
4648   return false;
4649 }
4650 
4651 bool SuperWord::pack_parallel() {
4652 #ifndef PRODUCT
4653   if (_vector_loop_debug) {
4654     tty-&gt;print_cr(&quot;SuperWord::pack_parallel: START&quot;);
4655   }
4656 #endif
4657 
4658   _packset.clear();
4659 
4660   for (int ii = 0; ii &lt; _iteration_first.length(); ii++) {
4661     Node* nd = _iteration_first.at(ii);
4662     if (in_bb(nd) &amp;&amp; (nd-&gt;is_Load() || nd-&gt;is_Store() || nd-&gt;is_Add() || nd-&gt;is_Mul())) {
4663       Node_List* pk = new Node_List();
4664       pk-&gt;push(nd);
4665       for (int gen = 1; gen &lt; _ii_order.length(); ++gen) {
4666         for (int kk = 0; kk &lt; _block.length(); kk++) {
4667           Node* clone = _block.at(kk);
4668           if (same_origin_idx(clone, nd) &amp;&amp;
4669               _clone_map.gen(clone-&gt;_idx) == _ii_order.at(gen)) {
4670             if (nd-&gt;is_Add() || nd-&gt;is_Mul()) {
4671               fix_commutative_inputs(nd, clone);
4672             }
4673             pk-&gt;push(clone);
4674             if (pk-&gt;size() == 4) {
4675               _packset.append(pk);
4676 #ifndef PRODUCT
4677               if (_vector_loop_debug) {
4678                 tty-&gt;print_cr(&quot;SuperWord::pack_parallel: added pack &quot;);
4679                 pk-&gt;dump();
4680               }
4681 #endif
4682               if (_clone_map.gen(clone-&gt;_idx) != _ii_last) {
4683                 pk = new Node_List();
4684               }
4685             }
4686             break;
4687           }
4688         }
4689       }//for
4690     }//if
4691   }//for
4692 
4693 #ifndef PRODUCT
4694   if (_vector_loop_debug) {
4695     tty-&gt;print_cr(&quot;SuperWord::pack_parallel: END&quot;);
4696   }
4697 #endif
4698 
4699   return true;
4700 }
4701 
4702 bool SuperWord::hoist_loads_in_graph() {
4703   GrowableArray&lt;Node*&gt; loads;
4704 
4705 #ifndef PRODUCT
4706   if (_vector_loop_debug) {
4707     tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: total number _mem_slice_head.length() = %d&quot;, _mem_slice_head.length());
4708   }
4709 #endif
4710 
4711   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
4712     Node* n = _mem_slice_head.at(i);
4713     if ( !in_bb(n) || !n-&gt;is_Phi() || n-&gt;bottom_type() != Type::MEMORY) {
4714       if (TraceSuperWord &amp;&amp; Verbose) {
4715         tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: skipping unexpected node n=%d&quot;, n-&gt;_idx);
4716       }
4717       continue;
4718     }
4719 
4720 #ifndef PRODUCT
4721     if (_vector_loop_debug) {
4722       tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: processing phi %d  = _mem_slice_head.at(%d);&quot;, n-&gt;_idx, i);
4723     }
4724 #endif
4725 
4726     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
4727       Node* ld = n-&gt;fast_out(i);
4728       if (ld-&gt;is_Load() &amp;&amp; ld-&gt;as_Load()-&gt;in(MemNode::Memory) == n &amp;&amp; in_bb(ld)) {
4729         for (int i = 0; i &lt; _block.length(); i++) {
4730           Node* ld2 = _block.at(i);
4731           if (ld2-&gt;is_Load() &amp;&amp; same_origin_idx(ld, ld2) &amp;&amp;
4732               !same_generation(ld, ld2)) { // &lt;= do not collect the first generation ld
4733 #ifndef PRODUCT
4734             if (_vector_loop_debug) {
4735               tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: will try to hoist load ld2-&gt;_idx=%d, cloned from %d (ld-&gt;_idx=%d)&quot;,
4736                 ld2-&gt;_idx, _clone_map.idx(ld-&gt;_idx), ld-&gt;_idx);
4737             }
4738 #endif
4739             // could not do on-the-fly, since iterator is immutable
4740             loads.push(ld2);
4741           }
4742         }// for
4743       }//if
4744     }//for (DUIterator_Fast imax,
4745   }//for (int i = 0; i
4746 
4747   for (int i = 0; i &lt; loads.length(); i++) {
4748     LoadNode* ld = loads.at(i)-&gt;as_Load();
4749     Node* phi = find_phi_for_mem_dep(ld);
4750     if (phi != NULL) {
4751 #ifndef PRODUCT
4752       if (_vector_loop_debug) {
4753         tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph replacing MemNode::Memory(%d) edge in %d with one from %d&quot;,
4754           MemNode::Memory, ld-&gt;_idx, phi-&gt;_idx);
4755       }
4756 #endif
4757       _igvn.replace_input_of(ld, MemNode::Memory, phi);
4758     }
4759   }//for
4760 
4761   restart(); // invalidate all basic structures, since we rebuilt the graph
4762 
4763   if (TraceSuperWord &amp;&amp; Verbose) {
4764     tty-&gt;print_cr(&quot;\nSuperWord::hoist_loads_in_graph() the graph was rebuilt, all structures invalidated and need rebuild&quot;);
4765   }
4766 
4767   return true;
4768 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/superword.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;compiler/compileLog.hpp&quot;
  26 #include &quot;libadt/vectset.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;opto/addnode.hpp&quot;
  30 #include &quot;opto/callnode.hpp&quot;
  31 #include &quot;opto/castnode.hpp&quot;
  32 #include &quot;opto/convertnode.hpp&quot;
  33 #include &quot;opto/divnode.hpp&quot;
  34 #include &quot;opto/matcher.hpp&quot;
  35 #include &quot;opto/memnode.hpp&quot;
  36 #include &quot;opto/mulnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/opaquenode.hpp&quot;
  39 #include &quot;opto/superword.hpp&quot;
  40 #include &quot;opto/vectornode.hpp&quot;
  41 #include &quot;opto/movenode.hpp&quot;
  42 #include &quot;utilities/powerOfTwo.hpp&quot;
  43 
  44 //
  45 //                  S U P E R W O R D   T R A N S F O R M
  46 //=============================================================================
  47 
  48 //------------------------------SuperWord---------------------------
  49 SuperWord::SuperWord(PhaseIdealLoop* phase) :
  50   _phase(phase),
  51   _arena(phase-&gt;C-&gt;comp_arena()),
  52   _igvn(phase-&gt;_igvn),
  53   _packset(arena(), 8,  0, NULL),         // packs for the current block
  54   _bb_idx(arena(), (int)(1.10 * phase-&gt;C-&gt;unique()), 0, 0), // node idx to index in bb
  55   _block(arena(), 8,  0, NULL),           // nodes in current block
  56   _post_block(arena(), 8, 0, NULL),       // nodes common to current block which are marked as post loop vectorizable
  57   _data_entry(arena(), 8,  0, NULL),      // nodes with all inputs from outside
  58   _mem_slice_head(arena(), 8,  0, NULL),  // memory slice heads
  59   _mem_slice_tail(arena(), 8,  0, NULL),  // memory slice tails
  60   _node_info(arena(), 8,  0, SWNodeInfo::initial), // info needed per node
  61   _clone_map(phase-&gt;C-&gt;clone_map()),      // map of nodes created in cloning
  62   _cmovev_kit(_arena, this),              // map to facilitate CMoveV creation
  63   _align_to_ref(NULL),                    // memory reference to align vectors to
  64   _disjoint_ptrs(arena(), 8,  0, OrderedPair::initial), // runtime disambiguated pointer pairs
  65   _dg(_arena),                            // dependence graph
  66   _visited(arena()),                      // visited node set
  67   _post_visited(arena()),                 // post visited node set
  68   _n_idx_list(arena(), 8),                // scratch list of (node,index) pairs
  69   _nlist(arena(), 8, 0, NULL),            // scratch list of nodes
  70   _stk(arena(), 8, 0, NULL),              // scratch stack of nodes
  71   _lpt(NULL),                             // loop tree node
  72   _lp(NULL),                              // LoopNode
  73   _bb(NULL),                              // basic block
  74   _iv(NULL),                              // induction var
  75   _race_possible(false),                  // cases where SDMU is true
  76   _early_return(true),                    // analysis evaluations routine
  77   _do_vector_loop(phase-&gt;C-&gt;do_vector_loop()),  // whether to do vectorization/simd style
  78   _do_reserve_copy(DoReserveCopyInSuperWord),
  79   _num_work_vecs(0),                      // amount of vector work we have
  80   _num_reductions(0),                     // amount of reduction work we have
  81   _ii_first(-1),                          // first loop generation index - only if do_vector_loop()
  82   _ii_last(-1),                           // last loop generation index - only if do_vector_loop()
  83   _ii_order(arena(), 8, 0, 0)
  84 {
  85 #ifndef PRODUCT
  86   _vector_loop_debug = 0;
  87   if (_phase-&gt;C-&gt;method() != NULL) {
  88     _vector_loop_debug = phase-&gt;C-&gt;directive()-&gt;VectorizeDebugOption;
  89   }
  90 
  91 #endif
  92 }
  93 
  94 //------------------------------transform_loop---------------------------
  95 void SuperWord::transform_loop(IdealLoopTree* lpt, bool do_optimization) {
  96   assert(UseSuperWord, &quot;should be&quot;);
  97   // Do vectors exist on this architecture?
  98   if (Matcher::vector_width_in_bytes(T_BYTE) &lt; 2) return;
  99 
 100   assert(lpt-&gt;_head-&gt;is_CountedLoop(), &quot;must be&quot;);
 101   CountedLoopNode *cl = lpt-&gt;_head-&gt;as_CountedLoop();
 102 
 103   if (!cl-&gt;is_valid_counted_loop()) return; // skip malformed counted loop
 104 
 105   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 106   if (post_loop_allowed) {
 107     if (cl-&gt;is_reduction_loop()) return; // no predication mapping
 108     Node *limit = cl-&gt;limit();
 109     if (limit-&gt;is_Con()) return; // non constant limits only
 110     // Now check the limit for expressions we do not handle
 111     if (limit-&gt;is_Add()) {
 112       Node *in2 = limit-&gt;in(2);
 113       if (in2-&gt;is_Con()) {
 114         int val = in2-&gt;get_int();
 115         // should not try to program these cases
 116         if (val &lt; 0) return;
 117       }
 118     }
 119   }
 120 
 121   // skip any loop that has not been assigned max unroll by analysis
 122   if (do_optimization) {
 123     if (SuperWordLoopUnrollAnalysis &amp;&amp; cl-&gt;slp_max_unroll() == 0) return;
 124   }
 125 
 126   // Check for no control flow in body (other than exit)
 127   Node *cl_exit = cl-&gt;loopexit();
 128   if (cl-&gt;is_main_loop() &amp;&amp; (cl_exit-&gt;in(0) != lpt-&gt;_head)) {
 129     #ifndef PRODUCT
 130       if (TraceSuperWord) {
 131         tty-&gt;print_cr(&quot;SuperWord::transform_loop: loop too complicated, cl_exit-&gt;in(0) != lpt-&gt;_head&quot;);
 132         tty-&gt;print(&quot;cl_exit %d&quot;, cl_exit-&gt;_idx); cl_exit-&gt;dump();
 133         tty-&gt;print(&quot;cl_exit-&gt;in(0) %d&quot;, cl_exit-&gt;in(0)-&gt;_idx); cl_exit-&gt;in(0)-&gt;dump();
 134         tty-&gt;print(&quot;lpt-&gt;_head %d&quot;, lpt-&gt;_head-&gt;_idx); lpt-&gt;_head-&gt;dump();
 135         lpt-&gt;dump_head();
 136       }
 137     #endif
 138     return;
 139   }
 140 
 141   // Make sure the are no extra control users of the loop backedge
 142   if (cl-&gt;back_control()-&gt;outcnt() != 1) {
 143     return;
 144   }
 145 
 146   // Skip any loops already optimized by slp
 147   if (cl-&gt;is_vectorized_loop()) return;
 148 
 149   if (cl-&gt;is_unroll_only()) return;
 150 
 151   if (cl-&gt;is_main_loop()) {
 152     // Check for pre-loop ending with CountedLoopEnd(Bool(Cmp(x,Opaque1(limit))))
 153     CountedLoopEndNode* pre_end = get_pre_loop_end(cl);
 154     if (pre_end == NULL) return;
 155     Node *pre_opaq1 = pre_end-&gt;limit();
 156     if (pre_opaq1-&gt;Opcode() != Op_Opaque1) return;
 157   }
 158 
 159   init(); // initialize data structures
 160 
 161   set_lpt(lpt);
 162   set_lp(cl);
 163 
 164   // For now, define one block which is the entire loop body
 165   set_bb(cl);
 166 
 167   if (do_optimization) {
 168     assert(_packset.length() == 0, &quot;packset must be empty&quot;);
 169     SLP_extract();
 170     if (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors()) {
 171       if (cl-&gt;is_vectorized_loop() &amp;&amp; cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_reduction_loop()) {
 172         IdealLoopTree *lpt_next = lpt-&gt;_next;
 173         CountedLoopNode *cl_next = lpt_next-&gt;_head-&gt;as_CountedLoop();
 174         _phase-&gt;has_range_checks(lpt_next);
 175         if (cl_next-&gt;is_post_loop() &amp;&amp; !cl_next-&gt;range_checks_present()) {
 176           if (!cl_next-&gt;is_vectorized_loop()) {
 177             int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 178             cl_next-&gt;set_slp_max_unroll(slp_max_unroll_factor);
 179           }
 180         }
 181       }
 182     }
 183   }
 184 }
 185 
 186 //------------------------------early unrolling analysis------------------------------
 187 void SuperWord::unrolling_analysis(int &amp;local_loop_unroll_factor) {
 188   bool is_slp = true;
 189   ResourceMark rm;
 190   size_t ignored_size = lpt()-&gt;_body.size();
 191   int *ignored_loop_nodes = NEW_RESOURCE_ARRAY(int, ignored_size);
 192   Node_Stack nstack((int)ignored_size);
 193   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
 194   Node *cl_exit = cl-&gt;loopexit_or_null();
 195   int rpo_idx = _post_block.length();
 196 
 197   assert(rpo_idx == 0, &quot;post loop block is empty&quot;);
 198 
 199   // First clear the entries
 200   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 201     ignored_loop_nodes[i] = -1;
 202   }
 203 
 204   int max_vector = Matcher::max_vector_size(T_BYTE);
 205   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 206 
 207   // Process the loop, some/all of the stack entries will not be in order, ergo
 208   // need to preprocess the ignored initial state before we process the loop
 209   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 210     Node* n = lpt()-&gt;_body.at(i);
 211     if (n == cl-&gt;incr() ||
 212       n-&gt;is_reduction() ||
 213       n-&gt;is_AddP() ||
 214       n-&gt;is_Cmp() ||
 215       n-&gt;is_IfTrue() ||
 216       n-&gt;is_CountedLoop() ||
 217       (n == cl_exit)) {
 218       ignored_loop_nodes[i] = n-&gt;_idx;
 219       continue;
 220     }
 221 
 222     if (n-&gt;is_If()) {
 223       IfNode *iff = n-&gt;as_If();
 224       if (iff-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp; iff-&gt;_prob != PROB_UNKNOWN) {
 225         if (lpt()-&gt;is_loop_exit(iff)) {
 226           ignored_loop_nodes[i] = n-&gt;_idx;
 227           continue;
 228         }
 229       }
 230     }
 231 
 232     if (n-&gt;is_Phi() &amp;&amp; (n-&gt;bottom_type() == Type::MEMORY)) {
 233       Node* n_tail = n-&gt;in(LoopNode::LoopBackControl);
 234       if (n_tail != n-&gt;in(LoopNode::EntryControl)) {
 235         if (!n_tail-&gt;is_Mem()) {
 236           is_slp = false;
 237           break;
 238         }
 239       }
 240     }
 241 
 242     // This must happen after check of phi/if
 243     if (n-&gt;is_Phi() || n-&gt;is_If()) {
 244       ignored_loop_nodes[i] = n-&gt;_idx;
 245       continue;
 246     }
 247 
 248     if (n-&gt;is_LoadStore() || n-&gt;is_MergeMem() ||
 249       (n-&gt;is_Proj() &amp;&amp; !n-&gt;as_Proj()-&gt;is_CFG())) {
 250       is_slp = false;
 251       break;
 252     }
 253 
 254     // Ignore nodes with non-primitive type.
 255     BasicType bt;
 256     if (n-&gt;is_Mem()) {
 257       bt = n-&gt;as_Mem()-&gt;memory_type();
 258     } else {
 259       bt = n-&gt;bottom_type()-&gt;basic_type();
 260     }
 261     if (is_java_primitive(bt) == false) {
 262       ignored_loop_nodes[i] = n-&gt;_idx;
 263       continue;
 264     }
 265 
 266     if (n-&gt;is_Mem()) {
 267       MemNode* current = n-&gt;as_Mem();
 268       Node* adr = n-&gt;in(MemNode::Address);
 269       Node* n_ctrl = _phase-&gt;get_ctrl(adr);
 270 
 271       // save a queue of post process nodes
 272       if (n_ctrl != NULL &amp;&amp; lpt()-&gt;is_member(_phase-&gt;get_loop(n_ctrl))) {
 273         // Process the memory expression
 274         int stack_idx = 0;
 275         bool have_side_effects = true;
 276         if (adr-&gt;is_AddP() == false) {
 277           nstack.push(adr, stack_idx++);
 278         } else {
 279           // Mark the components of the memory operation in nstack
 280           SWPointer p1(current, this, &amp;nstack, true);
 281           have_side_effects = p1.node_stack()-&gt;is_nonempty();
 282         }
 283 
 284         // Process the pointer stack
 285         while (have_side_effects) {
 286           Node* pointer_node = nstack.node();
 287           for (uint j = 0; j &lt; lpt()-&gt;_body.size(); j++) {
 288             Node* cur_node = lpt()-&gt;_body.at(j);
 289             if (cur_node == pointer_node) {
 290               ignored_loop_nodes[j] = cur_node-&gt;_idx;
 291               break;
 292             }
 293           }
 294           nstack.pop();
 295           have_side_effects = nstack.is_nonempty();
 296         }
 297       }
 298     }
 299   }
 300 
 301   if (is_slp) {
 302     // Now we try to find the maximum supported consistent vector which the machine
 303     // description can use
 304     bool small_basic_type = false;
 305     bool flag_small_bt = false;
 306     for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 307       if (ignored_loop_nodes[i] != -1) continue;
 308 
 309       BasicType bt;
 310       Node* n = lpt()-&gt;_body.at(i);
 311       if (n-&gt;is_Mem()) {
 312         bt = n-&gt;as_Mem()-&gt;memory_type();
 313       } else {
 314         bt = n-&gt;bottom_type()-&gt;basic_type();
 315       }
 316 
 317       if (post_loop_allowed) {
 318         if (!small_basic_type) {
 319           switch (bt) {
 320           case T_CHAR:
 321           case T_BYTE:
 322           case T_SHORT:
 323             small_basic_type = true;
 324             break;
 325 
 326           case T_LONG:
 327             // TODO: Remove when support completed for mask context with LONG.
 328             //       Support needs to be augmented for logical qword operations, currently we map to dword
 329             //       buckets for vectors on logicals as these were legacy.
 330             small_basic_type = true;
 331             break;
 332 
 333           default:
 334             break;
 335           }
 336         }
 337       }
 338 
 339       if (is_java_primitive(bt) == false) continue;
 340 
 341          int cur_max_vector = Matcher::max_vector_size(bt);
 342 
 343       // If a max vector exists which is not larger than _local_loop_unroll_factor
 344       // stop looking, we already have the max vector to map to.
 345       if (cur_max_vector &lt; local_loop_unroll_factor) {
 346         is_slp = false;
 347         if (TraceSuperWordLoopUnrollAnalysis) {
 348           tty-&gt;print_cr(&quot;slp analysis fails: unroll limit greater than max vector\n&quot;);
 349         }
 350         break;
 351       }
 352 
 353       // Map the maximal common vector
 354       if (VectorNode::implemented(n-&gt;Opcode(), cur_max_vector, bt)) {
 355         if (cur_max_vector &lt; max_vector &amp;&amp; !flag_small_bt) {
 356           max_vector = cur_max_vector;
 357         } else if (cur_max_vector &gt; max_vector &amp;&amp; UseSubwordForMaxVector) {
 358           // Analyse subword in the loop to set maximum vector size to take advantage of full vector width for subword types.
 359           // Here we analyze if narrowing is likely to happen and if it is we set vector size more aggressively.
 360           // We check for possibility of narrowing by looking through chain operations using subword types.
 361           if (is_subword_type(bt)) {
 362             uint start, end;
 363             VectorNode::vector_operands(n, &amp;start, &amp;end);
 364 
 365             for (uint j = start; j &lt; end; j++) {
 366               Node* in = n-&gt;in(j);
 367               // Don&#39;t propagate through a memory
 368               if (!in-&gt;is_Mem() &amp;&amp; in_bb(in) &amp;&amp; in-&gt;bottom_type()-&gt;basic_type() == T_INT) {
 369                 bool same_type = true;
 370                 for (DUIterator_Fast kmax, k = in-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 371                   Node *use = in-&gt;fast_out(k);
 372                   if (!in_bb(use) &amp;&amp; use-&gt;bottom_type()-&gt;basic_type() != bt) {
 373                     same_type = false;
 374                     break;
 375                   }
 376                 }
 377                 if (same_type) {
 378                   max_vector = cur_max_vector;
 379                   flag_small_bt = true;
 380                   cl-&gt;mark_subword_loop();
 381                 }
 382               }
 383             }
 384           }
 385         }
 386         // We only process post loops on predicated targets where we want to
 387         // mask map the loop to a single iteration
 388         if (post_loop_allowed) {
 389           _post_block.at_put_grow(rpo_idx++, n);
 390         }
 391       }
 392     }
 393     if (is_slp) {
 394       local_loop_unroll_factor = max_vector;
 395       cl-&gt;mark_passed_slp();
 396     }
 397     cl-&gt;mark_was_slp();
 398     if (cl-&gt;is_main_loop()) {
 399       cl-&gt;set_slp_max_unroll(local_loop_unroll_factor);
 400     } else if (post_loop_allowed) {
 401       if (!small_basic_type) {
 402         // avoid replication context for small basic types in programmable masked loops
 403         cl-&gt;set_slp_max_unroll(local_loop_unroll_factor);
 404       }
 405     }
 406   }
 407 }
 408 
 409 //------------------------------SLP_extract---------------------------
 410 // Extract the superword level parallelism
 411 //
 412 // 1) A reverse post-order of nodes in the block is constructed.  By scanning
 413 //    this list from first to last, all definitions are visited before their uses.
 414 //
 415 // 2) A point-to-point dependence graph is constructed between memory references.
 416 //    This simplies the upcoming &quot;independence&quot; checker.
 417 //
 418 // 3) The maximum depth in the node graph from the beginning of the block
 419 //    to each node is computed.  This is used to prune the graph search
 420 //    in the independence checker.
 421 //
 422 // 4) For integer types, the necessary bit width is propagated backwards
 423 //    from stores to allow packed operations on byte, char, and short
 424 //    integers.  This reverses the promotion to type &quot;int&quot; that javac
 425 //    did for operations like: char c1,c2,c3;  c1 = c2 + c3.
 426 //
 427 // 5) One of the memory references is picked to be an aligned vector reference.
 428 //    The pre-loop trip count is adjusted to align this reference in the
 429 //    unrolled body.
 430 //
 431 // 6) The initial set of pack pairs is seeded with memory references.
 432 //
 433 // 7) The set of pack pairs is extended by following use-&gt;def and def-&gt;use links.
 434 //
 435 // 8) The pairs are combined into vector sized packs.
 436 //
 437 // 9) Reorder the memory slices to co-locate members of the memory packs.
 438 //
 439 // 10) Generate ideal vector nodes for the final set of packs and where necessary,
 440 //    inserting scalar promotion, vector creation from multiple scalars, and
 441 //    extraction of scalar values from vectors.
 442 //
 443 void SuperWord::SLP_extract() {
 444 
 445 #ifndef PRODUCT
 446   if (_do_vector_loop &amp;&amp; TraceSuperWord) {
 447     tty-&gt;print(&quot;SuperWord::SLP_extract\n&quot;);
 448     tty-&gt;print(&quot;input loop\n&quot;);
 449     _lpt-&gt;dump_head();
 450     _lpt-&gt;dump();
 451     for (uint i = 0; i &lt; _lpt-&gt;_body.size(); i++) {
 452       _lpt-&gt;_body.at(i)-&gt;dump();
 453     }
 454   }
 455 #endif
 456   // Ready the block
 457   if (!construct_bb()) {
 458     return; // Exit if no interesting nodes or complex graph.
 459   }
 460 
 461   // build    _dg, _disjoint_ptrs
 462   dependence_graph();
 463 
 464   // compute function depth(Node*)
 465   compute_max_depth();
 466 
 467   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
 468   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 469   if (cl-&gt;is_main_loop()) {
 470     if (_do_vector_loop) {
 471       if (mark_generations() != -1) {
 472         hoist_loads_in_graph(); // this only rebuild the graph; all basic structs need rebuild explicitly
 473 
 474         if (!construct_bb()) {
 475           return; // Exit if no interesting nodes or complex graph.
 476         }
 477         dependence_graph();
 478         compute_max_depth();
 479       }
 480 
 481 #ifndef PRODUCT
 482       if (TraceSuperWord) {
 483         tty-&gt;print_cr(&quot;\nSuperWord::_do_vector_loop: graph after hoist_loads_in_graph&quot;);
 484         _lpt-&gt;dump_head();
 485         for (int j = 0; j &lt; _block.length(); j++) {
 486           Node* n = _block.at(j);
 487           int d = depth(n);
 488           for (int i = 0; i &lt; d; i++) tty-&gt;print(&quot;%s&quot;, &quot;  &quot;);
 489           tty-&gt;print(&quot;%d :&quot;, d);
 490           n-&gt;dump();
 491         }
 492       }
 493 #endif
 494     }
 495 
 496     compute_vector_element_type();
 497 
 498     // Attempt vectorization
 499 
 500     find_adjacent_refs();
 501 
 502     extend_packlist();
 503 
 504     if (_do_vector_loop) {
 505       if (_packset.length() == 0) {
 506         if (TraceSuperWord) {
 507           tty-&gt;print_cr(&quot;\nSuperWord::_do_vector_loop DFA could not build packset, now trying to build anyway&quot;);
 508         }
 509         pack_parallel();
 510       }
 511     }
 512 
 513     combine_packs();
 514 
 515     construct_my_pack_map();
 516     if (UseVectorCmov) {
 517       merge_packs_to_cmovd();
 518     }
 519 
 520     filter_packs();
 521 
 522     schedule();
 523   } else if (post_loop_allowed) {
 524     int saved_mapped_unroll_factor = cl-&gt;slp_max_unroll();
 525     if (saved_mapped_unroll_factor) {
 526       int vector_mapped_unroll_factor = saved_mapped_unroll_factor;
 527 
 528       // now reset the slp_unroll_factor so that we can check the analysis mapped
 529       // what the vector loop was mapped to
 530       cl-&gt;set_slp_max_unroll(0);
 531 
 532       // do the analysis on the post loop
 533       unrolling_analysis(vector_mapped_unroll_factor);
 534 
 535       // if our analyzed loop is a canonical fit, start processing it
 536       if (vector_mapped_unroll_factor == saved_mapped_unroll_factor) {
 537         // now add the vector nodes to packsets
 538         for (int i = 0; i &lt; _post_block.length(); i++) {
 539           Node* n = _post_block.at(i);
 540           Node_List* singleton = new Node_List();
 541           singleton-&gt;push(n);
 542           _packset.append(singleton);
 543           set_my_pack(n, singleton);
 544         }
 545 
 546         // map base types for vector usage
 547         compute_vector_element_type();
 548       } else {
 549         return;
 550       }
 551     } else {
 552       // for some reason we could not map the slp analysis state of the vectorized loop
 553       return;
 554     }
 555   }
 556 
 557   output();
 558 }
 559 
 560 //------------------------------find_adjacent_refs---------------------------
 561 // Find the adjacent memory references and create pack pairs for them.
 562 // This is the initial set of packs that will then be extended by
 563 // following use-&gt;def and def-&gt;use links.  The align positions are
 564 // assigned relative to the reference &quot;align_to_ref&quot;
 565 void SuperWord::find_adjacent_refs() {
 566   // Get list of memory operations
 567   Node_List memops;
 568   for (int i = 0; i &lt; _block.length(); i++) {
 569     Node* n = _block.at(i);
 570     if (n-&gt;is_Mem() &amp;&amp; !n-&gt;is_LoadStore() &amp;&amp; in_bb(n) &amp;&amp;
 571         is_java_primitive(n-&gt;as_Mem()-&gt;memory_type())) {
 572       int align = memory_alignment(n-&gt;as_Mem(), 0);
 573       if (align != bottom_align) {
 574         memops.push(n);
 575       }
 576     }
 577   }
 578 
 579   Node_List align_to_refs;
 580   int max_idx;
 581   int best_iv_adjustment = 0;
 582   MemNode* best_align_to_mem_ref = NULL;
 583 
 584   while (memops.size() != 0) {
 585     // Find a memory reference to align to.
 586     MemNode* mem_ref = find_align_to_ref(memops, max_idx);
 587     if (mem_ref == NULL) break;
 588     align_to_refs.push(mem_ref);
 589     int iv_adjustment = get_iv_adjustment(mem_ref);
 590 
 591     if (best_align_to_mem_ref == NULL) {
 592       // Set memory reference which is the best from all memory operations
 593       // to be used for alignment. The pre-loop trip count is modified to align
 594       // this reference to a vector-aligned address.
 595       best_align_to_mem_ref = mem_ref;
 596       best_iv_adjustment = iv_adjustment;
 597       NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 598     }
 599 
 600     SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 601     // Set alignment relative to &quot;align_to_ref&quot; for all related memory operations.
 602     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 603       MemNode* s = memops.at(i)-&gt;as_Mem();
 604       if (isomorphic(s, mem_ref) &amp;&amp;
 605            (!_do_vector_loop || same_origin_idx(s, mem_ref))) {
 606         SWPointer p2(s, this, NULL, false);
 607         if (p2.comparable(align_to_ref_p)) {
 608           int align = memory_alignment(s, iv_adjustment);
 609           set_alignment(s, align);
 610         }
 611       }
 612     }
 613 
 614     // Create initial pack pairs of memory operations for which
 615     // alignment is set and vectors will be aligned.
 616     bool create_pack = true;
 617     if (memory_alignment(mem_ref, best_iv_adjustment) == 0 || _do_vector_loop) {
 618       if (vectors_should_be_aligned()) {
 619         int vw = vector_width(mem_ref);
 620         int vw_best = vector_width(best_align_to_mem_ref);
 621         if (vw &gt; vw_best) {
 622           // Do not vectorize a memory access with more elements per vector
 623           // if unaligned memory access is not allowed because number of
 624           // iterations in pre-loop will be not enough to align it.
 625           create_pack = false;
 626         } else {
 627           SWPointer p2(best_align_to_mem_ref, this, NULL, false);
 628           if (align_to_ref_p.invar() != p2.invar()) {
 629             // Do not vectorize memory accesses with different invariants
 630             // if unaligned memory accesses are not allowed.
 631             create_pack = false;
 632           }
 633         }
 634       }
 635     } else {
 636       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 637         // Can&#39;t allow vectorization of unaligned memory accesses with the
 638         // same type since it could be overlapped accesses to the same array.
 639         create_pack = false;
 640       } else {
 641         // Allow independent (different type) unaligned memory operations
 642         // if HW supports them.
 643         if (vectors_should_be_aligned()) {
 644           create_pack = false;
 645         } else {
 646           // Check if packs of the same memory type but
 647           // with a different alignment were created before.
 648           for (uint i = 0; i &lt; align_to_refs.size(); i++) {
 649             MemNode* mr = align_to_refs.at(i)-&gt;as_Mem();
 650             if (mr == mem_ref) {
 651               // Skip when we are looking at same memory operation.
 652               continue;
 653             }
 654             if (same_velt_type(mr, mem_ref) &amp;&amp;
 655                 memory_alignment(mr, iv_adjustment) != 0)
 656               create_pack = false;
 657           }
 658         }
 659       }
 660     }
 661     if (create_pack) {
 662       for (uint i = 0; i &lt; memops.size(); i++) {
 663         Node* s1 = memops.at(i);
 664         int align = alignment(s1);
 665         if (align == top_align) continue;
 666         for (uint j = 0; j &lt; memops.size(); j++) {
 667           Node* s2 = memops.at(j);
 668           if (alignment(s2) == top_align) continue;
 669           if (s1 != s2 &amp;&amp; are_adjacent_refs(s1, s2)) {
 670             if (stmts_can_pack(s1, s2, align)) {
 671               Node_List* pair = new Node_List();
 672               pair-&gt;push(s1);
 673               pair-&gt;push(s2);
 674               if (!_do_vector_loop || same_origin_idx(s1, s2)) {
 675                 _packset.append(pair);
 676               }
 677             }
 678           }
 679         }
 680       }
 681     } else { // Don&#39;t create unaligned pack
 682       // First, remove remaining memory ops of the same type from the list.
 683       for (int i = memops.size() - 1; i &gt;= 0; i--) {
 684         MemNode* s = memops.at(i)-&gt;as_Mem();
 685         if (same_velt_type(s, mem_ref)) {
 686           memops.remove(i);
 687         }
 688       }
 689 
 690       // Second, remove already constructed packs of the same type.
 691       for (int i = _packset.length() - 1; i &gt;= 0; i--) {
 692         Node_List* p = _packset.at(i);
 693         MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 694         if (same_velt_type(s, mem_ref)) {
 695           remove_pack_at(i);
 696         }
 697       }
 698 
 699       // If needed find the best memory reference for loop alignment again.
 700       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 701         // Put memory ops from remaining packs back on memops list for
 702         // the best alignment search.
 703         uint orig_msize = memops.size();
 704         for (int i = 0; i &lt; _packset.length(); i++) {
 705           Node_List* p = _packset.at(i);
 706           MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 707           assert(!same_velt_type(s, mem_ref), &quot;sanity&quot;);
 708           memops.push(s);
 709         }
 710         best_align_to_mem_ref = find_align_to_ref(memops, max_idx);
 711         if (best_align_to_mem_ref == NULL) {
 712           if (TraceSuperWord) {
 713             tty-&gt;print_cr(&quot;SuperWord::find_adjacent_refs(): best_align_to_mem_ref == NULL&quot;);
 714           }
 715           // best_align_to_mem_ref will be used for adjusting the pre-loop limit in
 716           // SuperWord::align_initial_loop_index. Find one with the biggest vector size,
 717           // smallest data size and smallest iv offset from memory ops from remaining packs.
 718           if (_packset.length() &gt; 0) {
 719             if (orig_msize == 0) {
 720               best_align_to_mem_ref = memops.at(max_idx)-&gt;as_Mem();
 721             } else {
 722               for (uint i = 0; i &lt; orig_msize; i++) {
 723                 memops.remove(0);
 724               }
 725               best_align_to_mem_ref = find_align_to_ref(memops, max_idx);
 726               assert(best_align_to_mem_ref == NULL, &quot;sanity&quot;);
 727               best_align_to_mem_ref = memops.at(max_idx)-&gt;as_Mem();
 728             }
 729             assert(best_align_to_mem_ref != NULL, &quot;sanity&quot;);
 730           }
 731           break;
 732         }
 733         best_iv_adjustment = get_iv_adjustment(best_align_to_mem_ref);
 734         NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 735         // Restore list.
 736         while (memops.size() &gt; orig_msize)
 737           (void)memops.pop();
 738       }
 739     } // unaligned memory accesses
 740 
 741     // Remove used mem nodes.
 742     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 743       MemNode* m = memops.at(i)-&gt;as_Mem();
 744       if (alignment(m) != top_align) {
 745         memops.remove(i);
 746       }
 747     }
 748 
 749   } // while (memops.size() != 0
 750   set_align_to_ref(best_align_to_mem_ref);
 751 
 752   if (TraceSuperWord) {
 753     tty-&gt;print_cr(&quot;\nAfter find_adjacent_refs&quot;);
 754     print_packset();
 755   }
 756 }
 757 
 758 #ifndef PRODUCT
 759 void SuperWord::find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment) {
 760   if (is_trace_adjacent()) {
 761     tty-&gt;print(&quot;SuperWord::find_adjacent_refs best_align_to_mem_ref = %d, best_iv_adjustment = %d&quot;,
 762        best_align_to_mem_ref-&gt;_idx, best_iv_adjustment);
 763        best_align_to_mem_ref-&gt;dump();
 764   }
 765 }
 766 #endif
 767 
 768 //------------------------------find_align_to_ref---------------------------
 769 // Find a memory reference to align the loop induction variable to.
 770 // Looks first at stores then at loads, looking for a memory reference
 771 // with the largest number of references similar to it.
 772 MemNode* SuperWord::find_align_to_ref(Node_List &amp;memops, int &amp;idx) {
 773   GrowableArray&lt;int&gt; cmp_ct(arena(), memops.size(), memops.size(), 0);
 774 
 775   // Count number of comparable memory ops
 776   for (uint i = 0; i &lt; memops.size(); i++) {
 777     MemNode* s1 = memops.at(i)-&gt;as_Mem();
 778     SWPointer p1(s1, this, NULL, false);
 779     // Only discard unalignable memory references if vector memory references
 780     // should be aligned on this platform.
 781     if (vectors_should_be_aligned() &amp;&amp; !ref_is_alignable(p1)) {
 782       *cmp_ct.adr_at(i) = 0;
 783       continue;
 784     }
 785     for (uint j = i+1; j &lt; memops.size(); j++) {
 786       MemNode* s2 = memops.at(j)-&gt;as_Mem();
 787       if (isomorphic(s1, s2)) {
 788         SWPointer p2(s2, this, NULL, false);
 789         if (p1.comparable(p2)) {
 790           (*cmp_ct.adr_at(i))++;
 791           (*cmp_ct.adr_at(j))++;
 792         }
 793       }
 794     }
 795   }
 796 
 797   // Find Store (or Load) with the greatest number of &quot;comparable&quot; references,
 798   // biggest vector size, smallest data size and smallest iv offset.
 799   int max_ct        = 0;
 800   int max_vw        = 0;
 801   int max_idx       = -1;
 802   int min_size      = max_jint;
 803   int min_iv_offset = max_jint;
 804   for (uint j = 0; j &lt; memops.size(); j++) {
 805     MemNode* s = memops.at(j)-&gt;as_Mem();
 806     if (s-&gt;is_Store()) {
 807       int vw = vector_width_in_bytes(s);
 808       assert(vw &gt; 1, &quot;sanity&quot;);
 809       SWPointer p(s, this, NULL, false);
 810       if ( cmp_ct.at(j) &gt;  max_ct ||
 811           (cmp_ct.at(j) == max_ct &amp;&amp;
 812             ( vw &gt;  max_vw ||
 813              (vw == max_vw &amp;&amp;
 814               ( data_size(s) &lt;  min_size ||
 815                (data_size(s) == min_size &amp;&amp;
 816                 p.offset_in_bytes() &lt; min_iv_offset)))))) {
 817         max_ct = cmp_ct.at(j);
 818         max_vw = vw;
 819         max_idx = j;
 820         min_size = data_size(s);
 821         min_iv_offset = p.offset_in_bytes();
 822       }
 823     }
 824   }
 825   // If no stores, look at loads
 826   if (max_ct == 0) {
 827     for (uint j = 0; j &lt; memops.size(); j++) {
 828       MemNode* s = memops.at(j)-&gt;as_Mem();
 829       if (s-&gt;is_Load()) {
 830         int vw = vector_width_in_bytes(s);
 831         assert(vw &gt; 1, &quot;sanity&quot;);
 832         SWPointer p(s, this, NULL, false);
 833         if ( cmp_ct.at(j) &gt;  max_ct ||
 834             (cmp_ct.at(j) == max_ct &amp;&amp;
 835               ( vw &gt;  max_vw ||
 836                (vw == max_vw &amp;&amp;
 837                 ( data_size(s) &lt;  min_size ||
 838                  (data_size(s) == min_size &amp;&amp;
 839                   p.offset_in_bytes() &lt; min_iv_offset)))))) {
 840           max_ct = cmp_ct.at(j);
 841           max_vw = vw;
 842           max_idx = j;
 843           min_size = data_size(s);
 844           min_iv_offset = p.offset_in_bytes();
 845         }
 846       }
 847     }
 848   }
 849 
 850 #ifdef ASSERT
 851   if (TraceSuperWord &amp;&amp; Verbose) {
 852     tty-&gt;print_cr(&quot;\nVector memops after find_align_to_ref&quot;);
 853     for (uint i = 0; i &lt; memops.size(); i++) {
 854       MemNode* s = memops.at(i)-&gt;as_Mem();
 855       s-&gt;dump();
 856     }
 857   }
 858 #endif
 859 
 860   idx = max_idx;
 861   if (max_ct &gt; 0) {
 862 #ifdef ASSERT
 863     if (TraceSuperWord) {
 864       tty-&gt;print(&quot;\nVector align to node: &quot;);
 865       memops.at(max_idx)-&gt;as_Mem()-&gt;dump();
 866     }
 867 #endif
 868     return memops.at(max_idx)-&gt;as_Mem();
 869   }
 870   return NULL;
 871 }
 872 
 873 //------------------span_works_for_memory_size-----------------------------
 874 static bool span_works_for_memory_size(MemNode* mem, int span, int mem_size, int offset) {
 875   bool span_matches_memory = false;
 876   if ((mem_size == type2aelembytes(T_BYTE) || mem_size == type2aelembytes(T_SHORT))
 877     &amp;&amp; ABS(span) == type2aelembytes(T_INT)) {
 878     // There is a mismatch on span size compared to memory.
 879     for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 880       Node* use = mem-&gt;fast_out(j);
 881       if (!VectorNode::is_type_transition_to_int(use)) {
 882         return false;
 883       }
 884     }
 885     // If all uses transition to integer, it means that we can successfully align even on mismatch.
 886     return true;
 887   }
 888   else {
 889     span_matches_memory = ABS(span) == mem_size;
 890   }
 891   return span_matches_memory &amp;&amp; (ABS(offset) % mem_size) == 0;
 892 }
 893 
 894 //------------------------------ref_is_alignable---------------------------
 895 // Can the preloop align the reference to position zero in the vector?
 896 bool SuperWord::ref_is_alignable(SWPointer&amp; p) {
 897   if (!p.has_iv()) {
 898     return true;   // no induction variable
 899   }
 900   CountedLoopEndNode* pre_end = get_pre_loop_end(lp()-&gt;as_CountedLoop());
 901   assert(pre_end != NULL, &quot;we must have a correct pre-loop&quot;);
 902   assert(pre_end-&gt;stride_is_con(), &quot;pre loop stride is constant&quot;);
 903   int preloop_stride = pre_end-&gt;stride_con();
 904 
 905   int span = preloop_stride * p.scale_in_bytes();
 906   int mem_size = p.memory_size();
 907   int offset   = p.offset_in_bytes();
 908   // Stride one accesses are alignable if offset is aligned to memory operation size.
 909   // Offset can be unaligned when UseUnalignedAccesses is used.
 910   if (span_works_for_memory_size(p.mem(), span, mem_size, offset)) {
 911     return true;
 912   }
 913   // If the initial offset from start of the object is computable,
 914   // check if the pre-loop can align the final offset accordingly.
 915   //
 916   // In other words: Can we find an i such that the offset
 917   // after i pre-loop iterations is aligned to vw?
 918   //   (init_offset + pre_loop) % vw == 0              (1)
 919   // where
 920   //   pre_loop = i * span
 921   // is the number of bytes added to the offset by i pre-loop iterations.
 922   //
 923   // For this to hold we need pre_loop to increase init_offset by
 924   //   pre_loop = vw - (init_offset % vw)
 925   //
 926   // This is only possible if pre_loop is divisible by span because each
 927   // pre-loop iteration increases the initial offset by &#39;span&#39; bytes:
 928   //   (vw - (init_offset % vw)) % span == 0
 929   //
 930   int vw = vector_width_in_bytes(p.mem());
 931   assert(vw &gt; 1, &quot;sanity&quot;);
 932   Node* init_nd = pre_end-&gt;init_trip();
 933   if (init_nd-&gt;is_Con() &amp;&amp; p.invar() == NULL) {
 934     int init = init_nd-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
 935     int init_offset = init * p.scale_in_bytes() + offset;
 936     if (init_offset &lt; 0) { // negative offset from object start?
 937       return false;        // may happen in dead loop
 938     }
 939     if (vw % span == 0) {
 940       // If vm is a multiple of span, we use formula (1).
 941       if (span &gt; 0) {
 942         return (vw - (init_offset % vw)) % span == 0;
 943       } else {
 944         assert(span &lt; 0, &quot;nonzero stride * scale&quot;);
 945         return (init_offset % vw) % -span == 0;
 946       }
 947     } else if (span % vw == 0) {
 948       // If span is a multiple of vw, we can simplify formula (1) to:
 949       //   (init_offset + i * span) % vw == 0
 950       //     =&gt;
 951       //   (init_offset % vw) + ((i * span) % vw) == 0
 952       //     =&gt;
 953       //   init_offset % vw == 0
 954       //
 955       // Because we add a multiple of vw to the initial offset, the final
 956       // offset is a multiple of vw if and only if init_offset is a multiple.
 957       //
 958       return (init_offset % vw) == 0;
 959     }
 960   }
 961   return false;
 962 }
 963 //---------------------------get_vw_bytes_special------------------------
 964 int SuperWord::get_vw_bytes_special(MemNode* s) {
 965   // Get the vector width in bytes.
 966   int vw = vector_width_in_bytes(s);
 967 
 968   // Check for special case where there is an MulAddS2I usage where short vectors are going to need combined.
 969   BasicType btype = velt_basic_type(s);
 970   if (type2aelembytes(btype) == 2) {
 971     bool should_combine_adjacent = true;
 972     for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); i &lt; imax; i++) {
 973       Node* user = s-&gt;fast_out(i);
 974       if (!VectorNode::is_muladds2i(user)) {
 975         should_combine_adjacent = false;
 976       }
 977     }
 978     if (should_combine_adjacent) {
 979       vw = MIN2(Matcher::max_vector_size(btype)*type2aelembytes(btype), vw * 2);
 980     }
 981   }
 982 
 983   return vw;
 984 }
 985 
 986 //---------------------------get_iv_adjustment---------------------------
 987 // Calculate loop&#39;s iv adjustment for this memory ops.
 988 int SuperWord::get_iv_adjustment(MemNode* mem_ref) {
 989   SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 990   int offset = align_to_ref_p.offset_in_bytes();
 991   int scale  = align_to_ref_p.scale_in_bytes();
 992   int elt_size = align_to_ref_p.memory_size();
 993   int vw       = get_vw_bytes_special(mem_ref);
 994   assert(vw &gt; 1, &quot;sanity&quot;);
 995   int iv_adjustment;
 996   if (scale != 0) {
 997     int stride_sign = (scale * iv_stride()) &gt; 0 ? 1 : -1;
 998     // At least one iteration is executed in pre-loop by default. As result
 999     // several iterations are needed to align memory operations in main-loop even
1000     // if offset is 0.
1001     int iv_adjustment_in_bytes = (stride_sign * vw - (offset % vw));
1002     // iv_adjustment_in_bytes must be a multiple of elt_size if vector memory
1003     // references should be aligned on this platform.
1004     assert((ABS(iv_adjustment_in_bytes) % elt_size) == 0 || !vectors_should_be_aligned(),
1005            &quot;(%d) should be divisible by (%d)&quot;, iv_adjustment_in_bytes, elt_size);
1006     iv_adjustment = iv_adjustment_in_bytes/elt_size;
1007   } else {
1008     // This memory op is not dependent on iv (scale == 0)
1009     iv_adjustment = 0;
1010   }
1011 
1012 #ifndef PRODUCT
1013   if (TraceSuperWord) {
1014     tty-&gt;print(&quot;SuperWord::get_iv_adjustment: n = %d, noffset = %d iv_adjust = %d elt_size = %d scale = %d iv_stride = %d vect_size %d: &quot;,
1015       mem_ref-&gt;_idx, offset, iv_adjustment, elt_size, scale, iv_stride(), vw);
1016     mem_ref-&gt;dump();
1017   }
1018 #endif
1019   return iv_adjustment;
1020 }
1021 
1022 //---------------------------dependence_graph---------------------------
1023 // Construct dependency graph.
1024 // Add dependence edges to load/store nodes for memory dependence
1025 //    A.out()-&gt;DependNode.in(1) and DependNode.out()-&gt;B.prec(x)
1026 void SuperWord::dependence_graph() {
1027   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
1028   // First, assign a dependence node to each memory node
1029   for (int i = 0; i &lt; _block.length(); i++ ) {
1030     Node *n = _block.at(i);
1031     if (n-&gt;is_Mem() || (n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY)) {
1032       _dg.make_node(n);
1033     }
1034   }
1035 
1036   // For each memory slice, create the dependences
1037   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
1038     Node* n      = _mem_slice_head.at(i);
1039     Node* n_tail = _mem_slice_tail.at(i);
1040 
1041     // Get slice in predecessor order (last is first)
1042     if (cl-&gt;is_main_loop()) {
1043       mem_slice_preds(n_tail, n, _nlist);
1044     }
1045 
1046 #ifndef PRODUCT
1047     if(TraceSuperWord &amp;&amp; Verbose) {
1048       tty-&gt;print_cr(&quot;SuperWord::dependence_graph: built a new mem slice&quot;);
1049       for (int j = _nlist.length() - 1; j &gt;= 0 ; j--) {
1050         _nlist.at(j)-&gt;dump();
1051       }
1052     }
1053 #endif
1054     // Make the slice dependent on the root
1055     DepMem* slice = _dg.dep(n);
1056     _dg.make_edge(_dg.root(), slice);
1057 
1058     // Create a sink for the slice
1059     DepMem* slice_sink = _dg.make_node(NULL);
1060     _dg.make_edge(slice_sink, _dg.tail());
1061 
1062     // Now visit each pair of memory ops, creating the edges
1063     for (int j = _nlist.length() - 1; j &gt;= 0 ; j--) {
1064       Node* s1 = _nlist.at(j);
1065 
1066       // If no dependency yet, use slice
1067       if (_dg.dep(s1)-&gt;in_cnt() == 0) {
1068         _dg.make_edge(slice, s1);
1069       }
1070       SWPointer p1(s1-&gt;as_Mem(), this, NULL, false);
1071       bool sink_dependent = true;
1072       for (int k = j - 1; k &gt;= 0; k--) {
1073         Node* s2 = _nlist.at(k);
1074         if (s1-&gt;is_Load() &amp;&amp; s2-&gt;is_Load())
1075           continue;
1076         SWPointer p2(s2-&gt;as_Mem(), this, NULL, false);
1077 
1078         int cmp = p1.cmp(p2);
1079         if (SuperWordRTDepCheck &amp;&amp;
1080             p1.base() != p2.base() &amp;&amp; p1.valid() &amp;&amp; p2.valid()) {
1081           // Create a runtime check to disambiguate
1082           OrderedPair pp(p1.base(), p2.base());
1083           _disjoint_ptrs.append_if_missing(pp);
1084         } else if (!SWPointer::not_equal(cmp)) {
1085           // Possibly same address
1086           _dg.make_edge(s1, s2);
1087           sink_dependent = false;
1088         }
1089       }
1090       if (sink_dependent) {
1091         _dg.make_edge(s1, slice_sink);
1092       }
1093     }
1094 
1095     if (TraceSuperWord) {
1096       tty-&gt;print_cr(&quot;\nDependence graph for slice: %d&quot;, n-&gt;_idx);
1097       for (int q = 0; q &lt; _nlist.length(); q++) {
1098         _dg.print(_nlist.at(q));
1099       }
1100       tty-&gt;cr();
1101     }
1102 
1103     _nlist.clear();
1104   }
1105 
1106   if (TraceSuperWord) {
1107     tty-&gt;print_cr(&quot;\ndisjoint_ptrs: %s&quot;, _disjoint_ptrs.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
1108     for (int r = 0; r &lt; _disjoint_ptrs.length(); r++) {
1109       _disjoint_ptrs.at(r).print();
1110       tty-&gt;cr();
1111     }
1112     tty-&gt;cr();
1113   }
1114 
1115 }
1116 
1117 //---------------------------mem_slice_preds---------------------------
1118 // Return a memory slice (node list) in predecessor order starting at &quot;start&quot;
1119 void SuperWord::mem_slice_preds(Node* start, Node* stop, GrowableArray&lt;Node*&gt; &amp;preds) {
1120   assert(preds.length() == 0, &quot;start empty&quot;);
1121   Node* n = start;
1122   Node* prev = NULL;
1123   while (true) {
1124     NOT_PRODUCT( if(is_trace_mem_slice()) tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: n %d&quot;, n-&gt;_idx);)
1125     assert(in_bb(n), &quot;must be in block&quot;);
1126     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1127       Node* out = n-&gt;fast_out(i);
1128       if (out-&gt;is_Load()) {
1129         if (in_bb(out)) {
1130           preds.push(out);
1131           if (TraceSuperWord &amp;&amp; Verbose) {
1132             tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: added pred(%d)&quot;, out-&gt;_idx);
1133           }
1134         }
1135       } else {
1136         // FIXME
1137         if (out-&gt;is_MergeMem() &amp;&amp; !in_bb(out)) {
1138           // Either unrolling is causing a memory edge not to disappear,
1139           // or need to run igvn.optimize() again before SLP
1140         } else if (out-&gt;is_Phi() &amp;&amp; out-&gt;bottom_type() == Type::MEMORY &amp;&amp; !in_bb(out)) {
1141           // Ditto.  Not sure what else to check further.
1142         } else if (out-&gt;Opcode() == Op_StoreCM &amp;&amp; out-&gt;in(MemNode::OopStore) == n) {
1143           // StoreCM has an input edge used as a precedence edge.
1144           // Maybe an issue when oop stores are vectorized.
1145         } else {
1146           assert(out == prev || prev == NULL, &quot;no branches off of store slice&quot;);
1147         }
1148       }//else
1149     }//for
1150     if (n == stop) break;
1151     preds.push(n);
1152     if (TraceSuperWord &amp;&amp; Verbose) {
1153       tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: added pred(%d)&quot;, n-&gt;_idx);
1154     }
1155     prev = n;
1156     assert(n-&gt;is_Mem(), &quot;unexpected node %s&quot;, n-&gt;Name());
1157     n = n-&gt;in(MemNode::Memory);
1158   }
1159 }
1160 
1161 //------------------------------stmts_can_pack---------------------------
1162 // Can s1 and s2 be in a pack with s1 immediately preceding s2 and
1163 // s1 aligned at &quot;align&quot;
1164 bool SuperWord::stmts_can_pack(Node* s1, Node* s2, int align) {
1165 
1166   // Do not use superword for non-primitives
1167   BasicType bt1 = velt_basic_type(s1);
1168   BasicType bt2 = velt_basic_type(s2);
1169   if(!is_java_primitive(bt1) || !is_java_primitive(bt2))
1170     return false;
1171   if (Matcher::max_vector_size(bt1) &lt; 2) {
1172     return false; // No vectors for this type
1173   }
1174 
1175   if (isomorphic(s1, s2)) {
1176     if ((independent(s1, s2) &amp;&amp; have_similar_inputs(s1, s2)) || reduction(s1, s2)) {
1177       if (!exists_at(s1, 0) &amp;&amp; !exists_at(s2, 1)) {
1178         if (!s1-&gt;is_Mem() || are_adjacent_refs(s1, s2)) {
1179           int s1_align = alignment(s1);
1180           int s2_align = alignment(s2);
1181           if (s1_align == top_align || s1_align == align) {
1182             if (s2_align == top_align || s2_align == align + data_size(s1)) {
1183               return true;
1184             }
1185           }
1186         }
1187       }
1188     }
1189   }
1190   return false;
1191 }
1192 
1193 //------------------------------exists_at---------------------------
1194 // Does s exist in a pack at position pos?
1195 bool SuperWord::exists_at(Node* s, uint pos) {
1196   for (int i = 0; i &lt; _packset.length(); i++) {
1197     Node_List* p = _packset.at(i);
1198     if (p-&gt;at(pos) == s) {
1199       return true;
1200     }
1201   }
1202   return false;
1203 }
1204 
1205 //------------------------------are_adjacent_refs---------------------------
1206 // Is s1 immediately before s2 in memory?
1207 bool SuperWord::are_adjacent_refs(Node* s1, Node* s2) {
1208   if (!s1-&gt;is_Mem() || !s2-&gt;is_Mem()) return false;
1209   if (!in_bb(s1)    || !in_bb(s2))    return false;
1210 
1211   // Do not use superword for non-primitives
1212   if (!is_java_primitive(s1-&gt;as_Mem()-&gt;memory_type()) ||
1213       !is_java_primitive(s2-&gt;as_Mem()-&gt;memory_type())) {
1214     return false;
1215   }
1216 
1217   // FIXME - co_locate_pack fails on Stores in different mem-slices, so
1218   // only pack memops that are in the same alias set until that&#39;s fixed.
1219   if (_phase-&gt;C-&gt;get_alias_index(s1-&gt;as_Mem()-&gt;adr_type()) !=
1220       _phase-&gt;C-&gt;get_alias_index(s2-&gt;as_Mem()-&gt;adr_type()))
1221     return false;
1222   SWPointer p1(s1-&gt;as_Mem(), this, NULL, false);
1223   SWPointer p2(s2-&gt;as_Mem(), this, NULL, false);
1224   if (p1.base() != p2.base() || !p1.comparable(p2)) return false;
1225   int diff = p2.offset_in_bytes() - p1.offset_in_bytes();
1226   return diff == data_size(s1);
1227 }
1228 
1229 //------------------------------isomorphic---------------------------
1230 // Are s1 and s2 similar?
1231 bool SuperWord::isomorphic(Node* s1, Node* s2) {
1232   if (s1-&gt;Opcode() != s2-&gt;Opcode()) return false;
1233   if (s1-&gt;req() != s2-&gt;req()) return false;
1234   if (!same_velt_type(s1, s2)) return false;
1235   Node* s1_ctrl = s1-&gt;in(0);
1236   Node* s2_ctrl = s2-&gt;in(0);
1237   // If the control nodes are equivalent, no further checks are required to test for isomorphism.
1238   if (s1_ctrl == s2_ctrl) {
1239     return true;
1240   } else {
1241     bool s1_ctrl_inv = ((s1_ctrl == NULL) ? true : lpt()-&gt;is_invariant(s1_ctrl));
1242     bool s2_ctrl_inv = ((s2_ctrl == NULL) ? true : lpt()-&gt;is_invariant(s2_ctrl));
1243     // If the control nodes are not invariant for the loop, fail isomorphism test.
1244     if (!s1_ctrl_inv || !s2_ctrl_inv) {
1245       return false;
1246     }
1247     if(s1_ctrl != NULL &amp;&amp; s2_ctrl != NULL) {
1248       if (s1_ctrl-&gt;is_Proj()) {
1249         s1_ctrl = s1_ctrl-&gt;in(0);
1250         assert(lpt()-&gt;is_invariant(s1_ctrl), &quot;must be invariant&quot;);
1251       }
1252       if (s2_ctrl-&gt;is_Proj()) {
1253         s2_ctrl = s2_ctrl-&gt;in(0);
1254         assert(lpt()-&gt;is_invariant(s2_ctrl), &quot;must be invariant&quot;);
1255       }
1256       if (!s1_ctrl-&gt;is_RangeCheck() || !s2_ctrl-&gt;is_RangeCheck()) {
1257         return false;
1258       }
1259     }
1260     // Control nodes are invariant. However, we have no way of checking whether they resolve
1261     // in an equivalent manner. But, we know that invariant range checks are guaranteed to
1262     // throw before the loop (if they would have thrown). Thus, the loop would not have been reached.
1263     // Therefore, if the control nodes for both are range checks, we accept them to be isomorphic.
1264     for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1265       Node* t1 = s1-&gt;fast_out(i);
1266       for (DUIterator_Fast jmax, j = s2-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1267         Node* t2 = s2-&gt;fast_out(j);
1268         if (VectorNode::is_muladds2i(t1) &amp;&amp; VectorNode::is_muladds2i(t2)) {
1269           return true;
1270         }
1271       }
1272     }
1273   }
1274   return false;
1275 }
1276 
1277 //------------------------------independent---------------------------
1278 // Is there no data path from s1 to s2 or s2 to s1?
1279 bool SuperWord::independent(Node* s1, Node* s2) {
1280   //  assert(s1-&gt;Opcode() == s2-&gt;Opcode(), &quot;check isomorphic first&quot;);
1281   int d1 = depth(s1);
1282   int d2 = depth(s2);
1283   if (d1 == d2) return s1 != s2;
1284   Node* deep    = d1 &gt; d2 ? s1 : s2;
1285   Node* shallow = d1 &gt; d2 ? s2 : s1;
1286 
1287   visited_clear();
1288 
1289   return independent_path(shallow, deep);
1290 }
1291 
1292 //--------------------------have_similar_inputs-----------------------
1293 // For a node pair (s1, s2) which is isomorphic and independent,
1294 // do s1 and s2 have similar input edges?
1295 bool SuperWord::have_similar_inputs(Node* s1, Node* s2) {
1296   // assert(isomorphic(s1, s2) == true, &quot;check isomorphic&quot;);
1297   // assert(independent(s1, s2) == true, &quot;check independent&quot;);
1298   if (s1-&gt;req() &gt; 1 &amp;&amp; !s1-&gt;is_Store() &amp;&amp; !s1-&gt;is_Load()) {
1299     for (uint i = 1; i &lt; s1-&gt;req(); i++) {
1300       if (s1-&gt;in(i)-&gt;Opcode() != s2-&gt;in(i)-&gt;Opcode()) return false;
1301     }
1302   }
1303   return true;
1304 }
1305 
1306 //------------------------------reduction---------------------------
1307 // Is there a data path between s1 and s2 and the nodes reductions?
1308 bool SuperWord::reduction(Node* s1, Node* s2) {
1309   bool retValue = false;
1310   int d1 = depth(s1);
1311   int d2 = depth(s2);
1312   if (d1 + 1 == d2) {
1313     if (s1-&gt;is_reduction() &amp;&amp; s2-&gt;is_reduction()) {
1314       // This is an ordered set, so s1 should define s2
1315       for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1316         Node* t1 = s1-&gt;fast_out(i);
1317         if (t1 == s2) {
1318           // both nodes are reductions and connected
1319           retValue = true;
1320         }
1321       }
1322     }
1323   }
1324 
1325   return retValue;
1326 }
1327 
1328 //------------------------------independent_path------------------------------
1329 // Helper for independent
1330 bool SuperWord::independent_path(Node* shallow, Node* deep, uint dp) {
1331   if (dp &gt;= 1000) return false; // stop deep recursion
1332   visited_set(deep);
1333   int shal_depth = depth(shallow);
1334   assert(shal_depth &lt;= depth(deep), &quot;must be&quot;);
1335   for (DepPreds preds(deep, _dg); !preds.done(); preds.next()) {
1336     Node* pred = preds.current();
1337     if (in_bb(pred) &amp;&amp; !visited_test(pred)) {
1338       if (shallow == pred) {
1339         return false;
1340       }
1341       if (shal_depth &lt; depth(pred) &amp;&amp; !independent_path(shallow, pred, dp+1)) {
1342         return false;
1343       }
1344     }
1345   }
1346   return true;
1347 }
1348 
1349 //------------------------------set_alignment---------------------------
1350 void SuperWord::set_alignment(Node* s1, Node* s2, int align) {
1351   set_alignment(s1, align);
1352   if (align == top_align || align == bottom_align) {
1353     set_alignment(s2, align);
1354   } else {
1355     set_alignment(s2, align + data_size(s1));
1356   }
1357 }
1358 
1359 //------------------------------data_size---------------------------
1360 int SuperWord::data_size(Node* s) {
1361   Node* use = NULL; //test if the node is a candidate for CMoveV optimization, then return the size of CMov
1362   if (UseVectorCmov) {
1363     use = _cmovev_kit.is_Bool_candidate(s);
1364     if (use != NULL) {
1365       return data_size(use);
1366     }
1367     use = _cmovev_kit.is_CmpD_candidate(s);
1368     if (use != NULL) {
1369       return data_size(use);
1370     }
1371   }
1372 
1373   int bsize = type2aelembytes(velt_basic_type(s));
1374   assert(bsize != 0, &quot;valid size&quot;);
1375   return bsize;
1376 }
1377 
1378 //------------------------------extend_packlist---------------------------
1379 // Extend packset by following use-&gt;def and def-&gt;use links from pack members.
1380 void SuperWord::extend_packlist() {
1381   bool changed;
1382   do {
1383     packset_sort(_packset.length());
1384     changed = false;
1385     for (int i = 0; i &lt; _packset.length(); i++) {
1386       Node_List* p = _packset.at(i);
1387       changed |= follow_use_defs(p);
1388       changed |= follow_def_uses(p);
1389     }
1390   } while (changed);
1391 
1392   if (_race_possible) {
1393     for (int i = 0; i &lt; _packset.length(); i++) {
1394       Node_List* p = _packset.at(i);
1395       order_def_uses(p);
1396     }
1397   }
1398 
1399   if (TraceSuperWord) {
1400     tty-&gt;print_cr(&quot;\nAfter extend_packlist&quot;);
1401     print_packset();
1402   }
1403 }
1404 
1405 //------------------------------follow_use_defs---------------------------
1406 // Extend the packset by visiting operand definitions of nodes in pack p
1407 bool SuperWord::follow_use_defs(Node_List* p) {
1408   assert(p-&gt;size() == 2, &quot;just checking&quot;);
1409   Node* s1 = p-&gt;at(0);
1410   Node* s2 = p-&gt;at(1);
1411   assert(s1-&gt;req() == s2-&gt;req(), &quot;just checking&quot;);
1412   assert(alignment(s1) + data_size(s1) == alignment(s2), &quot;just checking&quot;);
1413 
1414   if (s1-&gt;is_Load()) return false;
1415 
1416   int align = alignment(s1);
1417   NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_use_defs: s1 %d, align %d&quot;, s1-&gt;_idx, align);)
1418   bool changed = false;
1419   int start = s1-&gt;is_Store() ? MemNode::ValueIn   : 1;
1420   int end   = s1-&gt;is_Store() ? MemNode::ValueIn+1 : s1-&gt;req();
1421   for (int j = start; j &lt; end; j++) {
1422     Node* t1 = s1-&gt;in(j);
1423     Node* t2 = s2-&gt;in(j);
1424     if (!in_bb(t1) || !in_bb(t2))
1425       continue;
1426     if (stmts_can_pack(t1, t2, align)) {
1427       if (est_savings(t1, t2) &gt;= 0) {
1428         Node_List* pair = new Node_List();
1429         pair-&gt;push(t1);
1430         pair-&gt;push(t2);
1431         _packset.append(pair);
1432         NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_use_defs: set_alignment(%d, %d, %d)&quot;, t1-&gt;_idx, t2-&gt;_idx, align);)
1433         set_alignment(t1, t2, align);
1434         changed = true;
1435       }
1436     }
1437   }
1438   return changed;
1439 }
1440 
1441 //------------------------------follow_def_uses---------------------------
1442 // Extend the packset by visiting uses of nodes in pack p
1443 bool SuperWord::follow_def_uses(Node_List* p) {
1444   bool changed = false;
1445   Node* s1 = p-&gt;at(0);
1446   Node* s2 = p-&gt;at(1);
1447   assert(p-&gt;size() == 2, &quot;just checking&quot;);
1448   assert(s1-&gt;req() == s2-&gt;req(), &quot;just checking&quot;);
1449   assert(alignment(s1) + data_size(s1) == alignment(s2), &quot;just checking&quot;);
1450 
1451   if (s1-&gt;is_Store()) return false;
1452 
1453   int align = alignment(s1);
1454   NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_def_uses: s1 %d, align %d&quot;, s1-&gt;_idx, align);)
1455   int savings = -1;
1456   int num_s1_uses = 0;
1457   Node* u1 = NULL;
1458   Node* u2 = NULL;
1459   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1460     Node* t1 = s1-&gt;fast_out(i);
1461     num_s1_uses++;
1462     if (!in_bb(t1)) continue;
1463     for (DUIterator_Fast jmax, j = s2-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1464       Node* t2 = s2-&gt;fast_out(j);
1465       if (!in_bb(t2)) continue;
1466       if (t2-&gt;Opcode() == Op_AddI &amp;&amp; t2 == _lp-&gt;as_CountedLoop()-&gt;incr()) continue; // don&#39;t mess with the iv
1467       if (!opnd_positions_match(s1, t1, s2, t2))
1468         continue;
1469       if (stmts_can_pack(t1, t2, align)) {
1470         int my_savings = est_savings(t1, t2);
1471         if (my_savings &gt; savings) {
1472           savings = my_savings;
1473           u1 = t1;
1474           u2 = t2;
1475         }
1476       }
1477     }
1478   }
1479   if (num_s1_uses &gt; 1) {
1480     _race_possible = true;
1481   }
1482   if (savings &gt;= 0) {
1483     Node_List* pair = new Node_List();
1484     pair-&gt;push(u1);
1485     pair-&gt;push(u2);
1486     _packset.append(pair);
1487     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_def_uses: set_alignment(%d, %d, %d)&quot;, u1-&gt;_idx, u2-&gt;_idx, align);)
1488     set_alignment(u1, u2, align);
1489     changed = true;
1490   }
1491   return changed;
1492 }
1493 
1494 //------------------------------order_def_uses---------------------------
1495 // For extended packsets, ordinally arrange uses packset by major component
1496 void SuperWord::order_def_uses(Node_List* p) {
1497   Node* s1 = p-&gt;at(0);
1498 
1499   if (s1-&gt;is_Store()) return;
1500 
1501   // reductions are always managed beforehand
1502   if (s1-&gt;is_reduction()) return;
1503 
1504   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1505     Node* t1 = s1-&gt;fast_out(i);
1506 
1507     // Only allow operand swap on commuting operations
1508     if (!t1-&gt;is_Add() &amp;&amp; !t1-&gt;is_Mul() &amp;&amp; !VectorNode::is_muladds2i(t1)) {
1509       break;
1510     }
1511 
1512     // Now find t1&#39;s packset
1513     Node_List* p2 = NULL;
1514     for (int j = 0; j &lt; _packset.length(); j++) {
1515       p2 = _packset.at(j);
1516       Node* first = p2-&gt;at(0);
1517       if (t1 == first) {
1518         break;
1519       }
1520       p2 = NULL;
1521     }
1522     // Arrange all sub components by the major component
1523     if (p2 != NULL) {
1524       for (uint j = 1; j &lt; p-&gt;size(); j++) {
1525         Node* d1 = p-&gt;at(j);
1526         Node* u1 = p2-&gt;at(j);
1527         opnd_positions_match(s1, t1, d1, u1);
1528       }
1529     }
1530   }
1531 }
1532 
1533 //---------------------------opnd_positions_match-------------------------
1534 // Is the use of d1 in u1 at the same operand position as d2 in u2?
1535 bool SuperWord::opnd_positions_match(Node* d1, Node* u1, Node* d2, Node* u2) {
1536   // check reductions to see if they are marshalled to represent the reduction
1537   // operator in a specified opnd
1538   if (u1-&gt;is_reduction() &amp;&amp; u2-&gt;is_reduction()) {
1539     // ensure reductions have phis and reduction definitions feeding the 1st operand
1540     Node* first = u1-&gt;in(2);
1541     if (first-&gt;is_Phi() || first-&gt;is_reduction()) {
1542       u1-&gt;swap_edges(1, 2);
1543     }
1544     // ensure reductions have phis and reduction definitions feeding the 1st operand
1545     first = u2-&gt;in(2);
1546     if (first-&gt;is_Phi() || first-&gt;is_reduction()) {
1547       u2-&gt;swap_edges(1, 2);
1548     }
1549     return true;
1550   }
1551 
1552   uint ct = u1-&gt;req();
1553   if (ct != u2-&gt;req()) return false;
1554   uint i1 = 0;
1555   uint i2 = 0;
1556   do {
1557     for (i1++; i1 &lt; ct; i1++) if (u1-&gt;in(i1) == d1) break;
1558     for (i2++; i2 &lt; ct; i2++) if (u2-&gt;in(i2) == d2) break;
1559     if (i1 != i2) {
1560       if ((i1 == (3-i2)) &amp;&amp; (u2-&gt;is_Add() || u2-&gt;is_Mul())) {
1561         // Further analysis relies on operands position matching.
1562         u2-&gt;swap_edges(i1, i2);
1563       } else if (VectorNode::is_muladds2i(u2) &amp;&amp; u1 != u2) {
1564         if (i1 == 5 - i2) { // ((i1 == 3 &amp;&amp; i2 == 2) || (i1 == 2 &amp;&amp; i2 == 3) || (i1 == 1 &amp;&amp; i2 == 4) || (i1 == 4 &amp;&amp; i2 == 1))
1565           u2-&gt;swap_edges(1, 2);
1566           u2-&gt;swap_edges(3, 4);
1567         }
1568         if (i1 == 3 - i2 || i1 == 7 - i2) { // ((i1 == 1 &amp;&amp; i2 == 2) || (i1 == 2 &amp;&amp; i2 == 1) || (i1 == 3 &amp;&amp; i2 == 4) || (i1 == 4 &amp;&amp; i2 == 3))
1569           u2-&gt;swap_edges(2, 3);
1570           u2-&gt;swap_edges(1, 4);
1571         }
1572         return false; // Just swap the edges, the muladds2i nodes get packed in follow_use_defs
1573       } else {
1574         return false;
1575       }
1576     } else if (i1 == i2 &amp;&amp; VectorNode::is_muladds2i(u2) &amp;&amp; u1 != u2) {
1577       u2-&gt;swap_edges(1, 3);
1578       u2-&gt;swap_edges(2, 4);
1579       return false; // Just swap the edges, the muladds2i nodes get packed in follow_use_defs
1580     }
1581   } while (i1 &lt; ct);
1582   return true;
1583 }
1584 
1585 //------------------------------est_savings---------------------------
1586 // Estimate the savings from executing s1 and s2 as a pack
1587 int SuperWord::est_savings(Node* s1, Node* s2) {
1588   int save_in = 2 - 1; // 2 operations per instruction in packed form
1589 
1590   // inputs
1591   for (uint i = 1; i &lt; s1-&gt;req(); i++) {
1592     Node* x1 = s1-&gt;in(i);
1593     Node* x2 = s2-&gt;in(i);
1594     if (x1 != x2) {
1595       if (are_adjacent_refs(x1, x2)) {
1596         save_in += adjacent_profit(x1, x2);
1597       } else if (!in_packset(x1, x2)) {
1598         save_in -= pack_cost(2);
1599       } else {
1600         save_in += unpack_cost(2);
1601       }
1602     }
1603   }
1604 
1605   // uses of result
1606   uint ct = 0;
1607   int save_use = 0;
1608   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1609     Node* s1_use = s1-&gt;fast_out(i);
1610     for (int j = 0; j &lt; _packset.length(); j++) {
1611       Node_List* p = _packset.at(j);
1612       if (p-&gt;at(0) == s1_use) {
1613         for (DUIterator_Fast kmax, k = s2-&gt;fast_outs(kmax); k &lt; kmax; k++) {
1614           Node* s2_use = s2-&gt;fast_out(k);
1615           if (p-&gt;at(p-&gt;size()-1) == s2_use) {
1616             ct++;
1617             if (are_adjacent_refs(s1_use, s2_use)) {
1618               save_use += adjacent_profit(s1_use, s2_use);
1619             }
1620           }
1621         }
1622       }
1623     }
1624   }
1625 
1626   if (ct &lt; s1-&gt;outcnt()) save_use += unpack_cost(1);
1627   if (ct &lt; s2-&gt;outcnt()) save_use += unpack_cost(1);
1628 
1629   return MAX2(save_in, save_use);
1630 }
1631 
1632 //------------------------------costs---------------------------
1633 int SuperWord::adjacent_profit(Node* s1, Node* s2) { return 2; }
1634 int SuperWord::pack_cost(int ct)   { return ct; }
1635 int SuperWord::unpack_cost(int ct) { return ct; }
1636 
1637 //------------------------------combine_packs---------------------------
1638 // Combine packs A and B with A.last == B.first into A.first..,A.last,B.second,..B.last
1639 void SuperWord::combine_packs() {
1640   bool changed = true;
1641   // Combine packs regardless max vector size.
1642   while (changed) {
1643     changed = false;
1644     for (int i = 0; i &lt; _packset.length(); i++) {
1645       Node_List* p1 = _packset.at(i);
1646       if (p1 == NULL) continue;
1647       // Because of sorting we can start at i + 1
1648       for (int j = i + 1; j &lt; _packset.length(); j++) {
1649         Node_List* p2 = _packset.at(j);
1650         if (p2 == NULL) continue;
1651         if (i == j) continue;
1652         if (p1-&gt;at(p1-&gt;size()-1) == p2-&gt;at(0)) {
1653           for (uint k = 1; k &lt; p2-&gt;size(); k++) {
1654             p1-&gt;push(p2-&gt;at(k));
1655           }
1656           _packset.at_put(j, NULL);
1657           changed = true;
1658         }
1659       }
1660     }
1661   }
1662 
1663   // Split packs which have size greater then max vector size.
1664   for (int i = 0; i &lt; _packset.length(); i++) {
1665     Node_List* p1 = _packset.at(i);
1666     if (p1 != NULL) {
1667       BasicType bt = velt_basic_type(p1-&gt;at(0));
1668       uint max_vlen = Matcher::max_vector_size(bt); // Max elements in vector
1669       assert(is_power_of_2(max_vlen), &quot;sanity&quot;);
1670       uint psize = p1-&gt;size();
1671       if (!is_power_of_2(psize)) {
1672         // Skip pack which can&#39;t be vector.
1673         // case1: for(...) { a[i] = i; }    elements values are different (i+x)
1674         // case2: for(...) { a[i] = b[i+1]; }  can&#39;t align both, load and store
1675         _packset.at_put(i, NULL);
1676         continue;
1677       }
1678       if (psize &gt; max_vlen) {
1679         Node_List* pack = new Node_List();
1680         for (uint j = 0; j &lt; psize; j++) {
1681           pack-&gt;push(p1-&gt;at(j));
1682           if (pack-&gt;size() &gt;= max_vlen) {
1683             assert(is_power_of_2(pack-&gt;size()), &quot;sanity&quot;);
1684             _packset.append(pack);
1685             pack = new Node_List();
1686           }
1687         }
1688         _packset.at_put(i, NULL);
1689       }
1690     }
1691   }
1692 
1693   // Compress list.
1694   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1695     Node_List* p1 = _packset.at(i);
1696     if (p1 == NULL) {
1697       _packset.remove_at(i);
1698     }
1699   }
1700 
1701   if (TraceSuperWord) {
1702     tty-&gt;print_cr(&quot;\nAfter combine_packs&quot;);
1703     print_packset();
1704   }
1705 }
1706 
1707 //-----------------------------construct_my_pack_map--------------------------
1708 // Construct the map from nodes to packs.  Only valid after the
1709 // point where a node is only in one pack (after combine_packs).
1710 void SuperWord::construct_my_pack_map() {
1711   Node_List* rslt = NULL;
1712   for (int i = 0; i &lt; _packset.length(); i++) {
1713     Node_List* p = _packset.at(i);
1714     for (uint j = 0; j &lt; p-&gt;size(); j++) {
1715       Node* s = p-&gt;at(j);
1716       assert(my_pack(s) == NULL, &quot;only in one pack&quot;);
1717       set_my_pack(s, p);
1718     }
1719   }
1720 }
1721 
1722 //------------------------------filter_packs---------------------------
1723 // Remove packs that are not implemented or not profitable.
1724 void SuperWord::filter_packs() {
1725   // Remove packs that are not implemented
1726   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1727     Node_List* pk = _packset.at(i);
1728     bool impl = implemented(pk);
1729     if (!impl) {
1730 #ifndef PRODUCT
1731       if (TraceSuperWord &amp;&amp; Verbose) {
1732         tty-&gt;print_cr(&quot;Unimplemented&quot;);
1733         pk-&gt;at(0)-&gt;dump();
1734       }
1735 #endif
1736       remove_pack_at(i);
1737     }
1738     Node *n = pk-&gt;at(0);
1739     if (n-&gt;is_reduction()) {
1740       _num_reductions++;
1741     } else {
1742       _num_work_vecs++;
1743     }
1744   }
1745 
1746   // Remove packs that are not profitable
1747   bool changed;
1748   do {
1749     changed = false;
1750     for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1751       Node_List* pk = _packset.at(i);
1752       bool prof = profitable(pk);
1753       if (!prof) {
1754 #ifndef PRODUCT
1755         if (TraceSuperWord &amp;&amp; Verbose) {
1756           tty-&gt;print_cr(&quot;Unprofitable&quot;);
1757           pk-&gt;at(0)-&gt;dump();
1758         }
1759 #endif
1760         remove_pack_at(i);
1761         changed = true;
1762       }
1763     }
1764   } while (changed);
1765 
1766 #ifndef PRODUCT
1767   if (TraceSuperWord) {
1768     tty-&gt;print_cr(&quot;\nAfter filter_packs&quot;);
1769     print_packset();
1770     tty-&gt;cr();
1771   }
1772 #endif
1773 }
1774 
1775 //------------------------------merge_packs_to_cmovd---------------------------
1776 // Merge CMoveD into new vector-nodes
1777 // We want to catch this pattern and subsume CmpD and Bool into CMoveD
1778 //
1779 //                   SubD             ConD
1780 //                  /  |               /
1781 //                 /   |           /   /
1782 //                /    |       /      /
1783 //               /     |   /         /
1784 //              /      /            /
1785 //             /    /  |           /
1786 //            v /      |          /
1787 //         CmpD        |         /
1788 //          |          |        /
1789 //          v          |       /
1790 //         Bool        |      /
1791 //           \         |     /
1792 //             \       |    /
1793 //               \     |   /
1794 //                 \   |  /
1795 //                   \ v /
1796 //                   CMoveD
1797 //
1798 
1799 void SuperWord::merge_packs_to_cmovd() {
1800   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1801     _cmovev_kit.make_cmovevd_pack(_packset.at(i));
1802   }
1803   #ifndef PRODUCT
1804     if (TraceSuperWord) {
1805       tty-&gt;print_cr(&quot;\nSuperWord::merge_packs_to_cmovd(): After merge&quot;);
1806       print_packset();
1807       tty-&gt;cr();
1808     }
1809   #endif
1810 }
1811 
1812 Node* CMoveKit::is_Bool_candidate(Node* def) const {
1813   Node* use = NULL;
1814   if (!def-&gt;is_Bool() || def-&gt;in(0) != NULL || def-&gt;outcnt() != 1) {
1815     return NULL;
1816   }
1817   for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1818     use = def-&gt;fast_out(j);
1819     if (!_sw-&gt;same_generation(def, use) || !use-&gt;is_CMove()) {
1820       return NULL;
1821     }
1822   }
1823   return use;
1824 }
1825 
1826 Node* CMoveKit::is_CmpD_candidate(Node* def) const {
1827   Node* use = NULL;
1828   if (!def-&gt;is_Cmp() || def-&gt;in(0) != NULL || def-&gt;outcnt() != 1) {
1829     return NULL;
1830   }
1831   for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1832     use = def-&gt;fast_out(j);
1833     if (!_sw-&gt;same_generation(def, use) || (use = is_Bool_candidate(use)) == NULL || !_sw-&gt;same_generation(def, use)) {
1834       return NULL;
1835     }
1836   }
1837   return use;
1838 }
1839 
1840 Node_List* CMoveKit::make_cmovevd_pack(Node_List* cmovd_pk) {
1841   Node *cmovd = cmovd_pk-&gt;at(0);
1842   if (!cmovd-&gt;is_CMove()) {
1843     return NULL;
1844   }
1845   if (cmovd-&gt;Opcode() != Op_CMoveF &amp;&amp; cmovd-&gt;Opcode() != Op_CMoveD) {
1846     return NULL;
1847   }
1848   if (pack(cmovd) != NULL) { // already in the cmov pack
1849     return NULL;
1850   }
1851   if (cmovd-&gt;in(0) != NULL) {
1852     NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: CMoveD %d has control flow, escaping...&quot;, cmovd-&gt;_idx); cmovd-&gt;dump();})
1853     return NULL;
1854   }
1855 
1856   Node* bol = cmovd-&gt;as_CMove()-&gt;in(CMoveNode::Condition);
1857   if (!bol-&gt;is_Bool()
1858       || bol-&gt;outcnt() != 1
1859       || !_sw-&gt;same_generation(bol, cmovd)
1860       || bol-&gt;in(0) != NULL  // BoolNode has control flow!!
1861       || _sw-&gt;my_pack(bol) == NULL) {
1862       NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: Bool %d does not fit CMoveD %d for building vector, escaping...&quot;, bol-&gt;_idx, cmovd-&gt;_idx); bol-&gt;dump();})
1863       return NULL;
1864   }
1865   Node_List* bool_pk = _sw-&gt;my_pack(bol);
1866   if (bool_pk-&gt;size() != cmovd_pk-&gt;size() ) {
1867     return NULL;
1868   }
1869 
1870   Node* cmpd = bol-&gt;in(1);
1871   if (!cmpd-&gt;is_Cmp()
1872       || cmpd-&gt;outcnt() != 1
1873       || !_sw-&gt;same_generation(cmpd, cmovd)
1874       || cmpd-&gt;in(0) != NULL  // CmpDNode has control flow!!
1875       || _sw-&gt;my_pack(cmpd) == NULL) {
1876       NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: CmpD %d does not fit CMoveD %d for building vector, escaping...&quot;, cmpd-&gt;_idx, cmovd-&gt;_idx); cmpd-&gt;dump();})
1877       return NULL;
1878   }
1879   Node_List* cmpd_pk = _sw-&gt;my_pack(cmpd);
1880   if (cmpd_pk-&gt;size() != cmovd_pk-&gt;size() ) {
1881     return NULL;
1882   }
1883 
1884   if (!test_cmpd_pack(cmpd_pk, cmovd_pk)) {
1885     NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: cmpd pack for CmpD %d failed vectorization test&quot;, cmpd-&gt;_idx); cmpd-&gt;dump();})
1886     return NULL;
1887   }
1888 
1889   Node_List* new_cmpd_pk = new Node_List();
1890   uint sz = cmovd_pk-&gt;size() - 1;
1891   for (uint i = 0; i &lt;= sz; ++i) {
1892     Node* cmov = cmovd_pk-&gt;at(i);
1893     Node* bol  = bool_pk-&gt;at(i);
1894     Node* cmp  = cmpd_pk-&gt;at(i);
1895 
1896     new_cmpd_pk-&gt;insert(i, cmov);
1897 
1898     map(cmov, new_cmpd_pk);
1899     map(bol, new_cmpd_pk);
1900     map(cmp, new_cmpd_pk);
1901 
1902     _sw-&gt;set_my_pack(cmov, new_cmpd_pk); // and keep old packs for cmp and bool
1903   }
1904   _sw-&gt;_packset.remove(cmovd_pk);
1905   _sw-&gt;_packset.remove(bool_pk);
1906   _sw-&gt;_packset.remove(cmpd_pk);
1907   _sw-&gt;_packset.append(new_cmpd_pk);
1908   NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print_cr(&quot;CMoveKit::make_cmovevd_pack: added syntactic CMoveD pack&quot;); _sw-&gt;print_pack(new_cmpd_pk);})
1909   return new_cmpd_pk;
1910 }
1911 
1912 bool CMoveKit::test_cmpd_pack(Node_List* cmpd_pk, Node_List* cmovd_pk) {
1913   Node* cmpd0 = cmpd_pk-&gt;at(0);
1914   assert(cmpd0-&gt;is_Cmp(), &quot;CMoveKit::test_cmpd_pack: should be CmpDNode&quot;);
1915   assert(cmovd_pk-&gt;at(0)-&gt;is_CMove(), &quot;CMoveKit::test_cmpd_pack: should be CMoveD&quot;);
1916   assert(cmpd_pk-&gt;size() == cmovd_pk-&gt;size(), &quot;CMoveKit::test_cmpd_pack: should be same size&quot;);
1917   Node* in1 = cmpd0-&gt;in(1);
1918   Node* in2 = cmpd0-&gt;in(2);
1919   Node_List* in1_pk = _sw-&gt;my_pack(in1);
1920   Node_List* in2_pk = _sw-&gt;my_pack(in2);
1921 
1922   if (  (in1_pk != NULL &amp;&amp; in1_pk-&gt;size() != cmpd_pk-&gt;size())
1923      || (in2_pk != NULL &amp;&amp; in2_pk-&gt;size() != cmpd_pk-&gt;size()) ) {
1924     return false;
1925   }
1926 
1927   // test if &quot;all&quot; in1 are in the same pack or the same node
1928   if (in1_pk == NULL) {
1929     for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1930       if (cmpd_pk-&gt;at(j)-&gt;in(1) != in1) {
1931         return false;
1932       }
1933     }//for: in1_pk is not pack but all CmpD nodes in the pack have the same in(1)
1934   }
1935   // test if &quot;all&quot; in2 are in the same pack or the same node
1936   if (in2_pk == NULL) {
1937     for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1938       if (cmpd_pk-&gt;at(j)-&gt;in(2) != in2) {
1939         return false;
1940       }
1941     }//for: in2_pk is not pack but all CmpD nodes in the pack have the same in(2)
1942   }
1943   //now check if cmpd_pk may be subsumed in vector built for cmovd_pk
1944   int cmovd_ind1, cmovd_ind2;
1945   if (cmpd_pk-&gt;at(0)-&gt;in(1) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfFalse)
1946    &amp;&amp; cmpd_pk-&gt;at(0)-&gt;in(2) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfTrue)) {
1947       cmovd_ind1 = CMoveNode::IfFalse;
1948       cmovd_ind2 = CMoveNode::IfTrue;
1949   } else if (cmpd_pk-&gt;at(0)-&gt;in(2) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfFalse)
1950           &amp;&amp; cmpd_pk-&gt;at(0)-&gt;in(1) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfTrue)) {
1951       cmovd_ind2 = CMoveNode::IfFalse;
1952       cmovd_ind1 = CMoveNode::IfTrue;
1953   }
1954   else {
1955     return false;
1956   }
1957 
1958   for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1959     if (cmpd_pk-&gt;at(j)-&gt;in(1) != cmovd_pk-&gt;at(j)-&gt;as_CMove()-&gt;in(cmovd_ind1)
1960         || cmpd_pk-&gt;at(j)-&gt;in(2) != cmovd_pk-&gt;at(j)-&gt;as_CMove()-&gt;in(cmovd_ind2)) {
1961         return false;
1962     }//if
1963   }
1964   NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) { tty-&gt;print(&quot;CMoveKit::test_cmpd_pack: cmpd pack for 1st CmpD %d is OK for vectorization: &quot;, cmpd0-&gt;_idx); cmpd0-&gt;dump(); })
1965   return true;
1966 }
1967 
1968 //------------------------------implemented---------------------------
1969 // Can code be generated for pack p?
1970 bool SuperWord::implemented(Node_List* p) {
1971   bool retValue = false;
1972   Node* p0 = p-&gt;at(0);
1973   if (p0 != NULL) {
1974     int opc = p0-&gt;Opcode();
1975     uint size = p-&gt;size();
1976     if (p0-&gt;is_reduction()) {
1977       const Type *arith_type = p0-&gt;bottom_type();
1978       // Length 2 reductions of INT/LONG do not offer performance benefits
1979       if (((arith_type-&gt;basic_type() == T_INT) || (arith_type-&gt;basic_type() == T_LONG)) &amp;&amp; (size == 2)) {
1980         retValue = false;
1981       } else {
1982         retValue = ReductionNode::implemented(opc, size, arith_type-&gt;basic_type());
1983       }
1984     } else {
1985       retValue = VectorNode::implemented(opc, size, velt_basic_type(p0));
1986     }
1987     if (!retValue) {
1988       if (is_cmov_pack(p)) {
1989         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::implemented: found cmpd pack&quot;); print_pack(p);})
1990         return true;
1991       }
1992     }
1993   }
1994   return retValue;
1995 }
1996 
1997 bool SuperWord::is_cmov_pack(Node_List* p) {
1998   return _cmovev_kit.pack(p-&gt;at(0)) != NULL;
1999 }
2000 //------------------------------same_inputs--------------------------
2001 // For pack p, are all idx operands the same?
2002 bool SuperWord::same_inputs(Node_List* p, int idx) {
2003   Node* p0 = p-&gt;at(0);
2004   uint vlen = p-&gt;size();
2005   Node* p0_def = p0-&gt;in(idx);
2006   for (uint i = 1; i &lt; vlen; i++) {
2007     Node* pi = p-&gt;at(i);
2008     Node* pi_def = pi-&gt;in(idx);
2009     if (p0_def != pi_def) {
2010       return false;
2011     }
2012   }
2013   return true;
2014 }
2015 
2016 //------------------------------profitable---------------------------
2017 // For pack p, are all operands and all uses (with in the block) vector?
2018 bool SuperWord::profitable(Node_List* p) {
2019   Node* p0 = p-&gt;at(0);
2020   uint start, end;
2021   VectorNode::vector_operands(p0, &amp;start, &amp;end);
2022 
2023   // Return false if some inputs are not vectors or vectors with different
2024   // size or alignment.
2025   // Also, for now, return false if not scalar promotion case when inputs are
2026   // the same. Later, implement PackNode and allow differing, non-vector inputs
2027   // (maybe just the ones from outside the block.)
2028   for (uint i = start; i &lt; end; i++) {
2029     if (!is_vector_use(p0, i)) {
2030       return false;
2031     }
2032   }
2033   // Check if reductions are connected
2034   if (p0-&gt;is_reduction()) {
2035     Node* second_in = p0-&gt;in(2);
2036     Node_List* second_pk = my_pack(second_in);
2037     if ((second_pk == NULL) || (_num_work_vecs == _num_reductions)) {
2038       // Remove reduction flag if no parent pack or if not enough work
2039       // to cover reduction expansion overhead
2040       p0-&gt;remove_flag(Node::Flag_is_reduction);
2041       return false;
2042     } else if (second_pk-&gt;size() != p-&gt;size()) {
2043       return false;
2044     }
2045   }
2046   if (VectorNode::is_shift(p0)) {
2047     // For now, return false if shift count is vector or not scalar promotion
2048     // case (different shift counts) because it is not supported yet.
2049     Node* cnt = p0-&gt;in(2);
2050     Node_List* cnt_pk = my_pack(cnt);
2051     if (cnt_pk != NULL)
2052       return false;
2053     if (!same_inputs(p, 2))
2054       return false;
2055   }
2056   if (!p0-&gt;is_Store()) {
2057     // For now, return false if not all uses are vector.
2058     // Later, implement ExtractNode and allow non-vector uses (maybe
2059     // just the ones outside the block.)
2060     for (uint i = 0; i &lt; p-&gt;size(); i++) {
2061       Node* def = p-&gt;at(i);
2062       if (is_cmov_pack_internal_node(p, def)) {
2063         continue;
2064       }
2065       for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2066         Node* use = def-&gt;fast_out(j);
2067         for (uint k = 0; k &lt; use-&gt;req(); k++) {
2068           Node* n = use-&gt;in(k);
2069           if (def == n) {
2070             // Reductions should only have a Phi use at the loop head or a non-phi use
2071             // outside of the loop if it is the last element of the pack (e.g. SafePoint).
2072             if (def-&gt;is_reduction() &amp;&amp;
2073                 ((use-&gt;is_Phi() &amp;&amp; use-&gt;in(0) == _lpt-&gt;_head) ||
2074                  (!_lpt-&gt;is_member(_phase-&gt;get_loop(_phase-&gt;ctrl_or_self(use))) &amp;&amp; i == p-&gt;size()-1))) {
2075               continue;
2076             }
2077             if (!is_vector_use(use, k)) {
2078               return false;
2079             }
2080           }
2081         }
2082       }
2083     }
2084   }
2085   return true;
2086 }
2087 
2088 //------------------------------schedule---------------------------
2089 // Adjust the memory graph for the packed operations
2090 void SuperWord::schedule() {
2091 
2092   // Co-locate in the memory graph the members of each memory pack
2093   for (int i = 0; i &lt; _packset.length(); i++) {
2094     co_locate_pack(_packset.at(i));
2095   }
2096 }
2097 
2098 //-------------------------------remove_and_insert-------------------
2099 // Remove &quot;current&quot; from its current position in the memory graph and insert
2100 // it after the appropriate insertion point (lip or uip).
2101 void SuperWord::remove_and_insert(MemNode *current, MemNode *prev, MemNode *lip,
2102                                   Node *uip, Unique_Node_List &amp;sched_before) {
2103   Node* my_mem = current-&gt;in(MemNode::Memory);
2104   bool sched_up = sched_before.member(current);
2105 
2106   // remove current_store from its current position in the memmory graph
2107   for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2108     Node* use = current-&gt;out(i);
2109     if (use-&gt;is_Mem()) {
2110       assert(use-&gt;in(MemNode::Memory) == current, &quot;must be&quot;);
2111       if (use == prev) { // connect prev to my_mem
2112           _igvn.replace_input_of(use, MemNode::Memory, my_mem);
2113           --i; //deleted this edge; rescan position
2114       } else if (sched_before.member(use)) {
2115         if (!sched_up) { // Will be moved together with current
2116           _igvn.replace_input_of(use, MemNode::Memory, uip);
2117           --i; //deleted this edge; rescan position
2118         }
2119       } else {
2120         if (sched_up) { // Will be moved together with current
2121           _igvn.replace_input_of(use, MemNode::Memory, lip);
2122           --i; //deleted this edge; rescan position
2123         }
2124       }
2125     }
2126   }
2127 
2128   Node *insert_pt =  sched_up ?  uip : lip;
2129 
2130   // all uses of insert_pt&#39;s memory state should use current&#39;s instead
2131   for (DUIterator i = insert_pt-&gt;outs(); insert_pt-&gt;has_out(i); i++) {
2132     Node* use = insert_pt-&gt;out(i);
2133     if (use-&gt;is_Mem()) {
2134       assert(use-&gt;in(MemNode::Memory) == insert_pt, &quot;must be&quot;);
2135       _igvn.replace_input_of(use, MemNode::Memory, current);
2136       --i; //deleted this edge; rescan position
2137     } else if (!sched_up &amp;&amp; use-&gt;is_Phi() &amp;&amp; use-&gt;bottom_type() == Type::MEMORY) {
2138       uint pos; //lip (lower insert point) must be the last one in the memory slice
2139       for (pos=1; pos &lt; use-&gt;req(); pos++) {
2140         if (use-&gt;in(pos) == insert_pt) break;
2141       }
2142       _igvn.replace_input_of(use, pos, current);
2143       --i;
2144     }
2145   }
2146 
2147   //connect current to insert_pt
2148   _igvn.replace_input_of(current, MemNode::Memory, insert_pt);
2149 }
2150 
2151 //------------------------------co_locate_pack----------------------------------
2152 // To schedule a store pack, we need to move any sandwiched memory ops either before
2153 // or after the pack, based upon dependence information:
2154 // (1) If any store in the pack depends on the sandwiched memory op, the
2155 //     sandwiched memory op must be scheduled BEFORE the pack;
2156 // (2) If a sandwiched memory op depends on any store in the pack, the
2157 //     sandwiched memory op must be scheduled AFTER the pack;
2158 // (3) If a sandwiched memory op (say, memA) depends on another sandwiched
2159 //     memory op (say memB), memB must be scheduled before memA. So, if memA is
2160 //     scheduled before the pack, memB must also be scheduled before the pack;
2161 // (4) If there is no dependence restriction for a sandwiched memory op, we simply
2162 //     schedule this store AFTER the pack
2163 // (5) We know there is no dependence cycle, so there in no other case;
2164 // (6) Finally, all memory ops in another single pack should be moved in the same direction.
2165 //
2166 // To schedule a load pack, we use the memory state of either the first or the last load in
2167 // the pack, based on the dependence constraint.
2168 void SuperWord::co_locate_pack(Node_List* pk) {
2169   if (pk-&gt;at(0)-&gt;is_Store()) {
2170     MemNode* first     = executed_first(pk)-&gt;as_Mem();
2171     MemNode* last      = executed_last(pk)-&gt;as_Mem();
2172     Unique_Node_List schedule_before_pack;
2173     Unique_Node_List memops;
2174 
2175     MemNode* current   = last-&gt;in(MemNode::Memory)-&gt;as_Mem();
2176     MemNode* previous  = last;
2177     while (true) {
2178       assert(in_bb(current), &quot;stay in block&quot;);
2179       memops.push(previous);
2180       for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2181         Node* use = current-&gt;out(i);
2182         if (use-&gt;is_Mem() &amp;&amp; use != previous)
2183           memops.push(use);
2184       }
2185       if (current == first) break;
2186       previous = current;
2187       current  = current-&gt;in(MemNode::Memory)-&gt;as_Mem();
2188     }
2189 
2190     // determine which memory operations should be scheduled before the pack
2191     for (uint i = 1; i &lt; memops.size(); i++) {
2192       Node *s1 = memops.at(i);
2193       if (!in_pack(s1, pk) &amp;&amp; !schedule_before_pack.member(s1)) {
2194         for (uint j = 0; j&lt; i; j++) {
2195           Node *s2 = memops.at(j);
2196           if (!independent(s1, s2)) {
2197             if (in_pack(s2, pk) || schedule_before_pack.member(s2)) {
2198               schedule_before_pack.push(s1); // s1 must be scheduled before
2199               Node_List* mem_pk = my_pack(s1);
2200               if (mem_pk != NULL) {
2201                 for (uint ii = 0; ii &lt; mem_pk-&gt;size(); ii++) {
2202                   Node* s = mem_pk-&gt;at(ii);  // follow partner
2203                   if (memops.member(s) &amp;&amp; !schedule_before_pack.member(s))
2204                     schedule_before_pack.push(s);
2205                 }
2206               }
2207               break;
2208             }
2209           }
2210         }
2211       }
2212     }
2213 
2214     Node*    upper_insert_pt = first-&gt;in(MemNode::Memory);
2215     // Following code moves loads connected to upper_insert_pt below aliased stores.
2216     // Collect such loads here and reconnect them back to upper_insert_pt later.
2217     memops.clear();
2218     for (DUIterator i = upper_insert_pt-&gt;outs(); upper_insert_pt-&gt;has_out(i); i++) {
2219       Node* use = upper_insert_pt-&gt;out(i);
2220       if (use-&gt;is_Mem() &amp;&amp; !use-&gt;is_Store()) {
2221         memops.push(use);
2222       }
2223     }
2224 
2225     MemNode* lower_insert_pt = last;
2226     previous                 = last; //previous store in pk
2227     current                  = last-&gt;in(MemNode::Memory)-&gt;as_Mem();
2228 
2229     // start scheduling from &quot;last&quot; to &quot;first&quot;
2230     while (true) {
2231       assert(in_bb(current), &quot;stay in block&quot;);
2232       assert(in_pack(previous, pk), &quot;previous stays in pack&quot;);
2233       Node* my_mem = current-&gt;in(MemNode::Memory);
2234 
2235       if (in_pack(current, pk)) {
2236         // Forward users of my memory state (except &quot;previous) to my input memory state
2237         for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2238           Node* use = current-&gt;out(i);
2239           if (use-&gt;is_Mem() &amp;&amp; use != previous) {
2240             assert(use-&gt;in(MemNode::Memory) == current, &quot;must be&quot;);
2241             if (schedule_before_pack.member(use)) {
2242               _igvn.replace_input_of(use, MemNode::Memory, upper_insert_pt);
2243             } else {
2244               _igvn.replace_input_of(use, MemNode::Memory, lower_insert_pt);
2245             }
2246             --i; // deleted this edge; rescan position
2247           }
2248         }
2249         previous = current;
2250       } else { // !in_pack(current, pk) ==&gt; a sandwiched store
2251         remove_and_insert(current, previous, lower_insert_pt, upper_insert_pt, schedule_before_pack);
2252       }
2253 
2254       if (current == first) break;
2255       current = my_mem-&gt;as_Mem();
2256     } // end while
2257 
2258     // Reconnect loads back to upper_insert_pt.
2259     for (uint i = 0; i &lt; memops.size(); i++) {
2260       Node *ld = memops.at(i);
2261       if (ld-&gt;in(MemNode::Memory) != upper_insert_pt) {
2262         _igvn.replace_input_of(ld, MemNode::Memory, upper_insert_pt);
2263       }
2264     }
2265   } else if (pk-&gt;at(0)-&gt;is_Load()) { // Load pack
2266     // All loads in the pack should have the same memory state. By default,
2267     // we use the memory state of the last load. However, if any load could
2268     // not be moved down due to the dependence constraint, we use the memory
2269     // state of the first load.
2270     Node* mem_input = pick_mem_state(pk);
2271     _igvn.hash_delete(mem_input);
2272     // Give each load the same memory state
2273     for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2274       LoadNode* ld = pk-&gt;at(i)-&gt;as_Load();
2275       _igvn.replace_input_of(ld, MemNode::Memory, mem_input);
2276     }
2277   }
2278 }
2279 
2280 // Finds the first and last memory state and then picks either of them by checking dependence constraints.
2281 // If a store is dependent on an earlier load then we need to pick the memory state of the first load and cannot
2282 // pick the memory state of the last load.
2283 Node* SuperWord::pick_mem_state(Node_List* pk) {
2284   Node* first_mem = find_first_mem_state(pk);
2285   Node* last_mem  = find_last_mem_state(pk, first_mem);
2286 
2287   for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2288     Node* ld = pk-&gt;at(i);
2289     for (Node* current = last_mem; current != ld-&gt;in(MemNode::Memory); current = current-&gt;in(MemNode::Memory)) {
2290       assert(current-&gt;is_Mem() &amp;&amp; in_bb(current), &quot;unexpected memory&quot;);
2291       assert(current != first_mem, &quot;corrupted memory graph&quot;);
2292       if (!independent(current, ld)) {
2293 #ifdef ASSERT
2294         // Added assertion code since no case has been observed that should pick the first memory state.
2295         // Remove the assertion code whenever we find a (valid) case that really needs the first memory state.
2296         pk-&gt;dump();
2297         first_mem-&gt;dump();
2298         last_mem-&gt;dump();
2299         current-&gt;dump();
2300         ld-&gt;dump();
2301         ld-&gt;in(MemNode::Memory)-&gt;dump();
2302         assert(false, &quot;never observed that first memory should be picked&quot;);
2303 #endif
2304         return first_mem; // A later store depends on this load, pick memory state of first load
2305       }
2306     }
2307   }
2308   return last_mem;
2309 }
2310 
2311 // Walk the memory graph from the current first load until the
2312 // start of the loop and check if nodes on the way are memory
2313 // edges of loads in the pack. The last one we encounter is the
2314 // first load.
2315 Node* SuperWord::find_first_mem_state(Node_List* pk) {
2316   Node* first_mem = pk-&gt;at(0)-&gt;in(MemNode::Memory);
2317   for (Node* current = first_mem; in_bb(current); current = current-&gt;is_Phi() ? current-&gt;in(LoopNode::EntryControl) : current-&gt;in(MemNode::Memory)) {
2318     assert(current-&gt;is_Mem() || (current-&gt;is_Phi() &amp;&amp; current-&gt;in(0) == bb()), &quot;unexpected memory&quot;);
2319     for (uint i = 1; i &lt; pk-&gt;size(); i++) {
2320       Node* ld = pk-&gt;at(i);
2321       if (ld-&gt;in(MemNode::Memory) == current) {
2322         first_mem = current;
2323         break;
2324       }
2325     }
2326   }
2327   return first_mem;
2328 }
2329 
2330 // Find the last load by going over the pack again and walking
2331 // the memory graph from the loads of the pack to the memory of
2332 // the first load. If we encounter the memory of the current last
2333 // load, then we started from further down in the memory graph and
2334 // the load we started from is the last load.
2335 Node* SuperWord::find_last_mem_state(Node_List* pk, Node* first_mem) {
2336   Node* last_mem = pk-&gt;at(0)-&gt;in(MemNode::Memory);
2337   for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2338     Node* ld = pk-&gt;at(i);
2339     for (Node* current = ld-&gt;in(MemNode::Memory); current != first_mem; current = current-&gt;in(MemNode::Memory)) {
2340       assert(current-&gt;is_Mem() &amp;&amp; in_bb(current), &quot;unexpected memory&quot;);
2341       if (current-&gt;in(MemNode::Memory) == last_mem) {
2342         last_mem = ld-&gt;in(MemNode::Memory);
2343       }
2344     }
2345   }
2346   return last_mem;
2347 }
2348 
2349 #ifndef PRODUCT
2350 void SuperWord::print_loop(bool whole) {
2351   Node_Stack stack(_arena, _phase-&gt;C-&gt;unique() &gt;&gt; 2);
2352   Node_List rpo_list;
2353   VectorSet visited(_arena);
2354   visited.set(lpt()-&gt;_head-&gt;_idx);
2355   _phase-&gt;rpo(lpt()-&gt;_head, stack, visited, rpo_list);
2356   _phase-&gt;dump(lpt(), rpo_list.size(), rpo_list );
2357   if(whole) {
2358     tty-&gt;print_cr(&quot;\n Whole loop tree&quot;);
2359     _phase-&gt;dump();
2360     tty-&gt;print_cr(&quot; End of whole loop tree\n&quot;);
2361   }
2362 }
2363 #endif
2364 
2365 //------------------------------output---------------------------
2366 // Convert packs into vector node operations
2367 void SuperWord::output() {
2368   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
2369   Compile* C = _phase-&gt;C;
2370   if (_packset.length() == 0) {
2371     if (cl-&gt;is_main_loop()) {
2372       // Instigate more unrolling for optimization when vectorization fails.
2373       C-&gt;set_major_progress();
2374       cl-&gt;set_notpassed_slp();
2375       cl-&gt;mark_do_unroll_only();
2376     }
2377     return;
2378   }
2379 
2380 #ifndef PRODUCT
2381   if (TraceLoopOpts) {
2382     tty-&gt;print(&quot;SuperWord::output    &quot;);
2383     lpt()-&gt;dump_head();
2384   }
2385 #endif
2386 
2387   if (cl-&gt;is_main_loop()) {
2388     // MUST ENSURE main loop&#39;s initial value is properly aligned:
2389     //  (iv_initial_value + min_iv_offset) % vector_width_in_bytes() == 0
2390 
2391     align_initial_loop_index(align_to_ref());
2392 
2393     // Insert extract (unpack) operations for scalar uses
2394     for (int i = 0; i &lt; _packset.length(); i++) {
2395       insert_extracts(_packset.at(i));
2396     }
2397   }
2398 
2399   uint max_vlen_in_bytes = 0;
2400   uint max_vlen = 0;
2401   bool can_process_post_loop = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
2402 
2403   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;SWPointer::output: print loop before create_reserve_version_of_loop&quot;); print_loop(true);})
2404 
2405   CountedLoopReserveKit make_reversable(_phase, _lpt, do_reserve_copy());
2406 
2407   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;SWPointer::output: print loop after create_reserve_version_of_loop&quot;); print_loop(true);})
2408 
2409   if (do_reserve_copy() &amp;&amp; !make_reversable.has_reserved()) {
2410     NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: loop was not reserved correctly, exiting SuperWord&quot;);})
2411     return;
2412   }
2413 
2414   for (int i = 0; i &lt; _block.length(); i++) {
2415     Node* n = _block.at(i);
2416     Node_List* p = my_pack(n);
2417     if (p &amp;&amp; n == executed_last(p)) {
2418       uint vlen = p-&gt;size();
2419       uint vlen_in_bytes = 0;
2420       Node* vn = NULL;
2421       Node* low_adr = p-&gt;at(0);
2422       Node* first   = executed_first(p);
2423       if (can_process_post_loop) {
2424         // override vlen with the main loops vector length
2425         vlen = cl-&gt;slp_max_unroll();
2426       }
2427       NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: %d executed first, %d executed last in pack&quot;, first-&gt;_idx, n-&gt;_idx); print_pack(p);})
2428       int   opc = n-&gt;Opcode();
2429       if (n-&gt;is_Load()) {
2430         Node* ctl = n-&gt;in(MemNode::Control);
2431         Node* mem = first-&gt;in(MemNode::Memory);
2432         SWPointer p1(n-&gt;as_Mem(), this, NULL, false);
2433         // Identify the memory dependency for the new loadVector node by
2434         // walking up through memory chain.
2435         // This is done to give flexibility to the new loadVector node so that
2436         // it can move above independent storeVector nodes.
2437         while (mem-&gt;is_StoreVector()) {
2438           SWPointer p2(mem-&gt;as_Mem(), this, NULL, false);
2439           int cmp = p1.cmp(p2);
2440           if (SWPointer::not_equal(cmp) || !SWPointer::comparable(cmp)) {
2441             mem = mem-&gt;in(MemNode::Memory);
2442           } else {
2443             break; // dependent memory
2444           }
2445         }
2446         Node* adr = low_adr-&gt;in(MemNode::Address);
2447         const TypePtr* atyp = n-&gt;adr_type();
2448         vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));
2449         vlen_in_bytes = vn-&gt;as_LoadVector()-&gt;memory_size();
2450       } else if (n-&gt;is_Store()) {
2451         // Promote value to be stored to vector
2452         Node* val = vector_opd(p, MemNode::ValueIn);
2453         if (val == NULL) {
2454           if (do_reserve_copy()) {
2455             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: val should not be NULL, exiting SuperWord&quot;);})
2456             return; //and reverse to backup IG
2457           }
2458           ShouldNotReachHere();
2459         }
2460 
2461         Node* ctl = n-&gt;in(MemNode::Control);
2462         Node* mem = first-&gt;in(MemNode::Memory);
2463         Node* adr = low_adr-&gt;in(MemNode::Address);
2464         const TypePtr* atyp = n-&gt;adr_type();
2465         vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);
2466         vlen_in_bytes = vn-&gt;as_StoreVector()-&gt;memory_size();
2467       } else if (VectorNode::is_roundopD(n)) {
2468         Node* in1 = vector_opd(p, 1);
2469         Node* in2 = low_adr-&gt;in(2);
2470         assert(in2-&gt;is_Con(), &quot;Constant rounding mode expected.&quot;);
2471         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2472         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2473       } else if (VectorNode::is_muladds2i(n)) {
2474         assert(n-&gt;req() == 5u, &quot;MulAddS2I should have 4 operands.&quot;);
2475         Node* in1 = vector_opd(p, 1);
2476         Node* in2 = vector_opd(p, 2);
2477         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2478         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2479       } else if (n-&gt;req() == 3 &amp;&amp; !is_cmov_pack(p)) {
2480         // Promote operands to vector
2481         Node* in1 = NULL;
2482         bool node_isa_reduction = n-&gt;is_reduction();
2483         if (node_isa_reduction) {
2484           // the input to the first reduction operation is retained
2485           in1 = low_adr-&gt;in(1);
2486         } else {
2487           in1 = vector_opd(p, 1);
2488           if (in1 == NULL) {
2489             if (do_reserve_copy()) {
2490               NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: in1 should not be NULL, exiting SuperWord&quot;);})
2491               return; //and reverse to backup IG
2492             }
2493             ShouldNotReachHere();
2494           }
2495         }
2496         Node* in2 = vector_opd(p, 2);
2497         if (in2 == NULL) {
2498           if (do_reserve_copy()) {
2499             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: in2 should not be NULL, exiting SuperWord&quot;);})
2500             return; //and reverse to backup IG
2501           }
2502           ShouldNotReachHere();
2503         }
2504         if (VectorNode::is_invariant_vector(in1) &amp;&amp; (node_isa_reduction == false) &amp;&amp; (n-&gt;is_Add() || n-&gt;is_Mul())) {
2505           // Move invariant vector input into second position to avoid register spilling.
2506           Node* tmp = in1;
2507           in1 = in2;
2508           in2 = tmp;
2509         }
2510         if (node_isa_reduction) {
2511           const Type *arith_type = n-&gt;bottom_type();
2512           vn = ReductionNode::make(opc, NULL, in1, in2, arith_type-&gt;basic_type());
2513           if (in2-&gt;is_Load()) {
2514             vlen_in_bytes = in2-&gt;as_LoadVector()-&gt;memory_size();
2515           } else {
2516             vlen_in_bytes = in2-&gt;as_Vector()-&gt;length_in_bytes();
2517           }
2518         } else {
2519           vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2520           vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2521         }
2522       } else if (opc == Op_SqrtF || opc == Op_SqrtD ||
2523                  opc == Op_AbsF || opc == Op_AbsD ||
2524                  opc == Op_AbsI || opc == Op_AbsL ||
2525                  opc == Op_NegF || opc == Op_NegD ||
2526                  opc == Op_PopCountI) {
2527         assert(n-&gt;req() == 2, &quot;only one input expected&quot;);
2528         Node* in = vector_opd(p, 1);
2529         vn = VectorNode::make(opc, in, NULL, vlen, velt_basic_type(n));
2530         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2531       } else if (is_cmov_pack(p)) {
2532         if (can_process_post_loop) {
2533           // do not refactor of flow in post loop context
2534           return;
2535         }
2536         if (!n-&gt;is_CMove()) {
2537           continue;
2538         }
2539         // place here CMoveVDNode
2540         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: print before CMove vectorization&quot;); print_loop(false);})
2541         Node* bol = n-&gt;in(CMoveNode::Condition);
2542         if (!bol-&gt;is_Bool() &amp;&amp; bol-&gt;Opcode() == Op_ExtractI &amp;&amp; bol-&gt;req() &gt; 1 ) {
2543           NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: %d is not Bool node, trying its in(1) node %d&quot;, bol-&gt;_idx, bol-&gt;in(1)-&gt;_idx); bol-&gt;dump(); bol-&gt;in(1)-&gt;dump();})
2544           bol = bol-&gt;in(1); //may be ExtractNode
2545         }
2546 
2547         assert(bol-&gt;is_Bool(), &quot;should be BoolNode - too late to bail out!&quot;);
2548         if (!bol-&gt;is_Bool()) {
2549           if (do_reserve_copy()) {
2550             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: expected %d bool node, exiting SuperWord&quot;, bol-&gt;_idx); bol-&gt;dump();})
2551             return; //and reverse to backup IG
2552           }
2553           ShouldNotReachHere();
2554         }
2555 
2556         int cond = (int)bol-&gt;as_Bool()-&gt;_test._test;
2557         Node* in_cc  = _igvn.intcon(cond);
2558         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created intcon in_cc node %d&quot;, in_cc-&gt;_idx); in_cc-&gt;dump();})
2559         Node* cc = bol-&gt;clone();
2560         cc-&gt;set_req(1, in_cc);
2561         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created bool cc node %d&quot;, cc-&gt;_idx); cc-&gt;dump();})
2562 
2563         Node* src1 = vector_opd(p, 2); //2=CMoveNode::IfFalse
2564         if (src1 == NULL) {
2565           if (do_reserve_copy()) {
2566             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: src1 should not be NULL, exiting SuperWord&quot;);})
2567             return; //and reverse to backup IG
2568           }
2569           ShouldNotReachHere();
2570         }
2571         Node* src2 = vector_opd(p, 3); //3=CMoveNode::IfTrue
2572         if (src2 == NULL) {
2573           if (do_reserve_copy()) {
2574             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: src2 should not be NULL, exiting SuperWord&quot;);})
2575             return; //and reverse to backup IG
2576           }
2577           ShouldNotReachHere();
2578         }
2579         BasicType bt = velt_basic_type(n);
2580         const TypeVect* vt = TypeVect::make(bt, vlen);
2581         assert(bt == T_FLOAT || bt == T_DOUBLE, &quot;Only vectorization for FP cmovs is supported&quot;);
2582         if (bt == T_FLOAT) {
2583           vn = new CMoveVFNode(cc, src1, src2, vt);
2584         } else {
2585           assert(bt == T_DOUBLE, &quot;Expected double&quot;);
2586           vn = new CMoveVDNode(cc, src1, src2, vt);
2587         }
2588         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created new CMove node %d: &quot;, vn-&gt;_idx); vn-&gt;dump();})
2589       } else if (opc == Op_FmaD || opc == Op_FmaF) {
2590         // Promote operands to vector
2591         Node* in1 = vector_opd(p, 1);
2592         Node* in2 = vector_opd(p, 2);
2593         Node* in3 = vector_opd(p, 3);
2594         vn = VectorNode::make(opc, in1, in2, in3, vlen, velt_basic_type(n));
2595         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2596       } else {
2597         if (do_reserve_copy()) {
2598           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: ShouldNotReachHere, exiting SuperWord&quot;);})
2599           return; //and reverse to backup IG
2600         }
2601         ShouldNotReachHere();
2602       }
2603 
2604       assert(vn != NULL, &quot;sanity&quot;);
2605       if (vn == NULL) {
2606         if (do_reserve_copy()){
2607           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: got NULL node, cannot proceed, exiting SuperWord&quot;);})
2608           return; //and reverse to backup IG
2609         }
2610         ShouldNotReachHere();
2611       }
2612 
2613       _block.at_put(i, vn);
2614       _igvn.register_new_node_with_optimizer(vn);
2615       _phase-&gt;set_ctrl(vn, _phase-&gt;get_ctrl(p-&gt;at(0)));
2616       for (uint j = 0; j &lt; p-&gt;size(); j++) {
2617         Node* pm = p-&gt;at(j);
2618         _igvn.replace_node(pm, vn);
2619       }
2620       _igvn._worklist.push(vn);
2621 
2622       if (can_process_post_loop) {
2623         // first check if the vector size if the maximum vector which we can use on the machine,
2624         // other vector size have reduced values for predicated data mapping.
2625         if (vlen_in_bytes != (uint)MaxVectorSize) {
2626           return;
2627         }
2628       }
2629 
2630       if (vlen_in_bytes &gt;= max_vlen_in_bytes &amp;&amp; vlen &gt; max_vlen) {
2631         max_vlen = vlen;
2632         max_vlen_in_bytes = vlen_in_bytes;
2633       }
2634 #ifdef ASSERT
2635       if (TraceNewVectors) {
2636         tty-&gt;print(&quot;new Vector node: &quot;);
2637         vn-&gt;dump();
2638       }
2639 #endif
2640     }
2641   }//for (int i = 0; i &lt; _block.length(); i++)
2642 
2643   if (max_vlen_in_bytes &gt; C-&gt;max_vector_size()) {
2644     C-&gt;set_max_vector_size(max_vlen_in_bytes);
2645   }
2646   if (max_vlen_in_bytes &gt; 0) {
2647     cl-&gt;mark_loop_vectorized();
2648   }
2649 
2650   if (SuperWordLoopUnrollAnalysis) {
2651     if (cl-&gt;has_passed_slp()) {
2652       uint slp_max_unroll_factor = cl-&gt;slp_max_unroll();
2653       if (slp_max_unroll_factor == max_vlen) {
2654         if (TraceSuperWordLoopUnrollAnalysis) {
2655           tty-&gt;print_cr(&quot;vector loop(unroll=%d, len=%d)\n&quot;, max_vlen, max_vlen_in_bytes*BitsPerByte);
2656         }
2657 
2658         // For atomic unrolled loops which are vector mapped, instigate more unrolling
2659         cl-&gt;set_notpassed_slp();
2660         if (cl-&gt;is_main_loop()) {
2661           // if vector resources are limited, do not allow additional unrolling, also
2662           // do not unroll more on pure vector loops which were not reduced so that we can
2663           // program the post loop to single iteration execution.
2664           if (FLOATPRESSURE &gt; 8) {
2665             C-&gt;set_major_progress();
2666             cl-&gt;mark_do_unroll_only();
2667           }
2668         }
2669 
2670         if (do_reserve_copy()) {
2671           if (can_process_post_loop) {
2672             // Now create the difference of trip and limit and use it as our mask index.
2673             // Note: We limited the unroll of the vectorized loop so that
2674             //       only vlen-1 size iterations can remain to be mask programmed.
2675             Node *incr = cl-&gt;incr();
2676             SubINode *index = new SubINode(cl-&gt;limit(), cl-&gt;init_trip());
2677             _igvn.register_new_node_with_optimizer(index);
2678             SetVectMaskINode  *mask = new SetVectMaskINode(_phase-&gt;get_ctrl(cl-&gt;init_trip()), index);
2679             _igvn.register_new_node_with_optimizer(mask);
2680             // make this a single iteration loop
2681             AddINode *new_incr = new AddINode(incr-&gt;in(1), mask);
2682             _igvn.register_new_node_with_optimizer(new_incr);
2683             _phase-&gt;set_ctrl(new_incr, _phase-&gt;get_ctrl(incr));
2684             _igvn.replace_node(incr, new_incr);
2685             cl-&gt;mark_is_multiversioned();
2686             cl-&gt;loopexit()-&gt;add_flag(Node::Flag_has_vector_mask_set);
2687           }
2688         }
2689       }
2690     }
2691   }
2692 
2693   if (do_reserve_copy()) {
2694     make_reversable.use_new();
2695   }
2696   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;\n Final loop after SuperWord&quot;); print_loop(true);})
2697   return;
2698 }
2699 
2700 //------------------------------vector_opd---------------------------
2701 // Create a vector operand for the nodes in pack p for operand: in(opd_idx)
2702 Node* SuperWord::vector_opd(Node_List* p, int opd_idx) {
2703   Node* p0 = p-&gt;at(0);
2704   uint vlen = p-&gt;size();
2705   Node* opd = p0-&gt;in(opd_idx);
2706   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
2707 
2708   if (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop()) {
2709     // override vlen with the main loops vector length
2710     vlen = cl-&gt;slp_max_unroll();
2711   }
2712 
2713   if (same_inputs(p, opd_idx)) {
2714     if (opd-&gt;is_Vector() || opd-&gt;is_LoadVector()) {
2715       assert(((opd_idx != 2) || !VectorNode::is_shift(p0)), &quot;shift&#39;s count can&#39;t be vector&quot;);
2716       if (opd_idx == 2 &amp;&amp; VectorNode::is_shift(p0)) {
2717         NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;shift&#39;s count can&#39;t be vector&quot;);})
2718         return NULL;
2719       }
2720       return opd; // input is matching vector
2721     }
2722     if ((opd_idx == 2) &amp;&amp; VectorNode::is_shift(p0)) {
2723       Compile* C = _phase-&gt;C;
2724       Node* cnt = opd;
2725       // Vector instructions do not mask shift count, do it here.
2726       juint mask = (p0-&gt;bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);
2727       const TypeInt* t = opd-&gt;find_int_type();
2728       if (t != NULL &amp;&amp; t-&gt;is_con()) {
2729         juint shift = t-&gt;get_con();
2730         if (shift &gt; mask) { // Unsigned cmp
2731           cnt = ConNode::make(TypeInt::make(shift &amp; mask));
2732         }
2733       } else {
2734         if (t == NULL || t-&gt;_lo &lt; 0 || t-&gt;_hi &gt; (int)mask) {
2735           cnt = ConNode::make(TypeInt::make(mask));
2736           _igvn.register_new_node_with_optimizer(cnt);
2737           cnt = new AndINode(opd, cnt);
2738           _igvn.register_new_node_with_optimizer(cnt);
2739           _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));
2740         }
2741         assert(opd-&gt;bottom_type()-&gt;isa_int(), &quot;int type only&quot;);
2742         if (!opd-&gt;bottom_type()-&gt;isa_int()) {
2743           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should be int type only&quot;);})
2744           return NULL;
2745         }
2746       }
2747       // Move shift count into vector register.
2748       cnt = VectorNode::shift_count(p0, cnt, vlen, velt_basic_type(p0));
2749       _igvn.register_new_node_with_optimizer(cnt);
2750       _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));
2751       return cnt;
2752     }
2753     assert(!opd-&gt;is_StoreVector(), &quot;such vector is not expected here&quot;);
2754     if (opd-&gt;is_StoreVector()) {
2755       NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;StoreVector is not expected here&quot;);})
2756       return NULL;
2757     }
2758     // Convert scalar input to vector with the same number of elements as
2759     // p0&#39;s vector. Use p0&#39;s type because size of operand&#39;s container in
2760     // vector should match p0&#39;s size regardless operand&#39;s size.
2761     const Type* p0_t = velt_type(p0);
2762     VectorNode* vn = VectorNode::scalar2vector(opd, vlen, p0_t);
2763 
2764     _igvn.register_new_node_with_optimizer(vn);
2765     _phase-&gt;set_ctrl(vn, _phase-&gt;get_ctrl(opd));
2766 #ifdef ASSERT
2767     if (TraceNewVectors) {
2768       tty-&gt;print(&quot;new Vector node: &quot;);
2769       vn-&gt;dump();
2770     }
2771 #endif
2772     return vn;
2773   }
2774 
2775   // Insert pack operation
2776   BasicType bt = velt_basic_type(p0);
2777   PackNode* pk = PackNode::make(opd, vlen, bt);
2778   DEBUG_ONLY( const BasicType opd_bt = opd-&gt;bottom_type()-&gt;basic_type(); )
2779 
2780   for (uint i = 1; i &lt; vlen; i++) {
2781     Node* pi = p-&gt;at(i);
2782     Node* in = pi-&gt;in(opd_idx);
2783     assert(my_pack(in) == NULL, &quot;Should already have been unpacked&quot;);
2784     if (my_pack(in) != NULL) {
2785       NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should already have been unpacked&quot;);})
2786       return NULL;
2787     }
2788     assert(opd_bt == in-&gt;bottom_type()-&gt;basic_type(), &quot;all same type&quot;);
2789     pk-&gt;add_opd(in);
2790     if (VectorNode::is_muladds2i(pi)) {
2791       Node* in2 = pi-&gt;in(opd_idx + 2);
2792       assert(my_pack(in2) == NULL, &quot;Should already have been unpacked&quot;);
2793       if (my_pack(in2) != NULL) {
2794         NOT_PRODUCT(if (is_trace_loop_reverse() || TraceLoopOpts) { tty-&gt;print_cr(&quot;Should already have been unpacked&quot;); })
2795           return NULL;
2796       }
2797       assert(opd_bt == in2-&gt;bottom_type()-&gt;basic_type(), &quot;all same type&quot;);
2798       pk-&gt;add_opd(in2);
2799     }
2800   }
2801   _igvn.register_new_node_with_optimizer(pk);
2802   _phase-&gt;set_ctrl(pk, _phase-&gt;get_ctrl(opd));
2803 #ifdef ASSERT
2804   if (TraceNewVectors) {
2805     tty-&gt;print(&quot;new Vector node: &quot;);
2806     pk-&gt;dump();
2807   }
2808 #endif
2809   return pk;
2810 }
2811 
2812 //------------------------------insert_extracts---------------------------
2813 // If a use of pack p is not a vector use, then replace the
2814 // use with an extract operation.
2815 void SuperWord::insert_extracts(Node_List* p) {
2816   if (p-&gt;at(0)-&gt;is_Store()) return;
2817   assert(_n_idx_list.is_empty(), &quot;empty (node,index) list&quot;);
2818 
2819   // Inspect each use of each pack member.  For each use that is
2820   // not a vector use, replace the use with an extract operation.
2821 
2822   for (uint i = 0; i &lt; p-&gt;size(); i++) {
2823     Node* def = p-&gt;at(i);
2824     for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2825       Node* use = def-&gt;fast_out(j);
2826       for (uint k = 0; k &lt; use-&gt;req(); k++) {
2827         Node* n = use-&gt;in(k);
2828         if (def == n) {
2829           Node_List* u_pk = my_pack(use);
2830           if ((u_pk == NULL || !is_cmov_pack(u_pk) || use-&gt;is_CMove()) &amp;&amp; !is_vector_use(use, k)) {
2831               _n_idx_list.push(use, k);
2832           }
2833         }
2834       }
2835     }
2836   }
2837 
2838   while (_n_idx_list.is_nonempty()) {
2839     Node* use = _n_idx_list.node();
2840     int   idx = _n_idx_list.index();
2841     _n_idx_list.pop();
2842     Node* def = use-&gt;in(idx);
2843 
2844     if (def-&gt;is_reduction()) continue;
2845 
2846     // Insert extract operation
2847     _igvn.hash_delete(def);
2848     int def_pos = alignment(def) / data_size(def);
2849 
2850     Node* ex = ExtractNode::make(def, def_pos, velt_basic_type(def));
2851     _igvn.register_new_node_with_optimizer(ex);
2852     _phase-&gt;set_ctrl(ex, _phase-&gt;get_ctrl(def));
2853     _igvn.replace_input_of(use, idx, ex);
2854     _igvn._worklist.push(def);
2855 
2856     bb_insert_after(ex, bb_idx(def));
2857     set_velt_type(ex, velt_type(def));
2858   }
2859 }
2860 
2861 //------------------------------is_vector_use---------------------------
2862 // Is use-&gt;in(u_idx) a vector use?
2863 bool SuperWord::is_vector_use(Node* use, int u_idx) {
2864   Node_List* u_pk = my_pack(use);
2865   if (u_pk == NULL) return false;
2866   if (use-&gt;is_reduction()) return true;
2867   Node* def = use-&gt;in(u_idx);
2868   Node_List* d_pk = my_pack(def);
2869   if (d_pk == NULL) {
2870     // check for scalar promotion
2871     Node* n = u_pk-&gt;at(0)-&gt;in(u_idx);
2872     for (uint i = 1; i &lt; u_pk-&gt;size(); i++) {
2873       if (u_pk-&gt;at(i)-&gt;in(u_idx) != n) return false;
2874     }
2875     return true;
2876   }
2877   if (VectorNode::is_muladds2i(use)) {
2878     // MulAddS2I takes shorts and produces ints - hence the special checks
2879     // on alignment and size.
2880     if (u_pk-&gt;size() * 2 != d_pk-&gt;size()) {
2881       return false;
2882     }
2883     for (uint i = 0; i &lt; MIN2(d_pk-&gt;size(), u_pk-&gt;size()); i++) {
2884       Node* ui = u_pk-&gt;at(i);
2885       Node* di = d_pk-&gt;at(i);
2886       if (alignment(ui) != alignment(di) * 2) {
2887         return false;
2888       }
2889     }
2890     return true;
2891   }
2892   if (u_pk-&gt;size() != d_pk-&gt;size())
2893     return false;
2894   for (uint i = 0; i &lt; u_pk-&gt;size(); i++) {
2895     Node* ui = u_pk-&gt;at(i);
2896     Node* di = d_pk-&gt;at(i);
2897     if (ui-&gt;in(u_idx) != di || alignment(ui) != alignment(di))
2898       return false;
2899   }
2900   return true;
2901 }
2902 
2903 //------------------------------construct_bb---------------------------
2904 // Construct reverse postorder list of block members
2905 bool SuperWord::construct_bb() {
2906   Node* entry = bb();
2907 
2908   assert(_stk.length() == 0,            &quot;stk is empty&quot;);
2909   assert(_block.length() == 0,          &quot;block is empty&quot;);
2910   assert(_data_entry.length() == 0,     &quot;data_entry is empty&quot;);
2911   assert(_mem_slice_head.length() == 0, &quot;mem_slice_head is empty&quot;);
2912   assert(_mem_slice_tail.length() == 0, &quot;mem_slice_tail is empty&quot;);
2913 
2914   // Find non-control nodes with no inputs from within block,
2915   // create a temporary map from node _idx to bb_idx for use
2916   // by the visited and post_visited sets,
2917   // and count number of nodes in block.
2918   int bb_ct = 0;
2919   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
2920     Node *n = lpt()-&gt;_body.at(i);
2921     set_bb_idx(n, i); // Create a temporary map
2922     if (in_bb(n)) {
2923       if (n-&gt;is_LoadStore() || n-&gt;is_MergeMem() ||
2924           (n-&gt;is_Proj() &amp;&amp; !n-&gt;as_Proj()-&gt;is_CFG())) {
2925         // Bailout if the loop has LoadStore, MergeMem or data Proj
2926         // nodes. Superword optimization does not work with them.
2927         return false;
2928       }
2929       bb_ct++;
2930       if (!n-&gt;is_CFG()) {
2931         bool found = false;
2932         for (uint j = 0; j &lt; n-&gt;req(); j++) {
2933           Node* def = n-&gt;in(j);
2934           if (def &amp;&amp; in_bb(def)) {
2935             found = true;
2936             break;
2937           }
2938         }
2939         if (!found) {
2940           assert(n != entry, &quot;can&#39;t be entry&quot;);
2941           _data_entry.push(n);
2942         }
2943       }
2944     }
2945   }
2946 
2947   // Find memory slices (head and tail)
2948   for (DUIterator_Fast imax, i = lp()-&gt;fast_outs(imax); i &lt; imax; i++) {
2949     Node *n = lp()-&gt;fast_out(i);
2950     if (in_bb(n) &amp;&amp; (n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY)) {
2951       Node* n_tail  = n-&gt;in(LoopNode::LoopBackControl);
2952       if (n_tail != n-&gt;in(LoopNode::EntryControl)) {
2953         if (!n_tail-&gt;is_Mem()) {
2954           assert(n_tail-&gt;is_Mem(), &quot;unexpected node for memory slice: %s&quot;, n_tail-&gt;Name());
2955           return false; // Bailout
2956         }
2957         _mem_slice_head.push(n);
2958         _mem_slice_tail.push(n_tail);
2959       }
2960     }
2961   }
2962 
2963   // Create an RPO list of nodes in block
2964 
2965   visited_clear();
2966   post_visited_clear();
2967 
2968   // Push all non-control nodes with no inputs from within block, then control entry
2969   for (int j = 0; j &lt; _data_entry.length(); j++) {
2970     Node* n = _data_entry.at(j);
2971     visited_set(n);
2972     _stk.push(n);
2973   }
2974   visited_set(entry);
2975   _stk.push(entry);
2976 
2977   // Do a depth first walk over out edges
2978   int rpo_idx = bb_ct - 1;
2979   int size;
2980   int reduction_uses = 0;
2981   while ((size = _stk.length()) &gt; 0) {
2982     Node* n = _stk.top(); // Leave node on stack
2983     if (!visited_test_set(n)) {
2984       // forward arc in graph
2985     } else if (!post_visited_test(n)) {
2986       // cross or back arc
2987       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2988         Node *use = n-&gt;fast_out(i);
2989         if (in_bb(use) &amp;&amp; !visited_test(use) &amp;&amp;
2990             // Don&#39;t go around backedge
2991             (!use-&gt;is_Phi() || n == entry)) {
2992           if (use-&gt;is_reduction()) {
2993             // First see if we can map the reduction on the given system we are on, then
2994             // make a data entry operation for each reduction we see.
2995             BasicType bt = use-&gt;bottom_type()-&gt;basic_type();
2996             if (ReductionNode::implemented(use-&gt;Opcode(), Matcher::min_vector_size(bt), bt)) {
2997               reduction_uses++;
2998             }
2999           }
3000           _stk.push(use);
3001         }
3002       }
3003       if (_stk.length() == size) {
3004         // There were no additional uses, post visit node now
3005         _stk.pop(); // Remove node from stack
3006         assert(rpo_idx &gt;= 0, &quot;&quot;);
3007         _block.at_put_grow(rpo_idx, n);
3008         rpo_idx--;
3009         post_visited_set(n);
3010         assert(rpo_idx &gt;= 0 || _stk.is_empty(), &quot;&quot;);
3011       }
3012     } else {
3013       _stk.pop(); // Remove post-visited node from stack
3014     }
3015   }//while
3016 
3017   int ii_current = -1;
3018   unsigned int load_idx = (unsigned int)-1;
3019   _ii_order.clear();
3020   // Create real map of block indices for nodes
3021   for (int j = 0; j &lt; _block.length(); j++) {
3022     Node* n = _block.at(j);
3023     set_bb_idx(n, j);
3024     if (_do_vector_loop &amp;&amp; n-&gt;is_Load()) {
3025       if (ii_current == -1) {
3026         ii_current = _clone_map.gen(n-&gt;_idx);
3027         _ii_order.push(ii_current);
3028         load_idx = _clone_map.idx(n-&gt;_idx);
3029       } else if (_clone_map.idx(n-&gt;_idx) == load_idx &amp;&amp; _clone_map.gen(n-&gt;_idx) != ii_current) {
3030         ii_current = _clone_map.gen(n-&gt;_idx);
3031         _ii_order.push(ii_current);
3032       }
3033     }
3034   }//for
3035 
3036   // Ensure extra info is allocated.
3037   initialize_bb();
3038 
3039 #ifndef PRODUCT
3040   if (_vector_loop_debug &amp;&amp; _ii_order.length() &gt; 0) {
3041     tty-&gt;print(&quot;SuperWord::construct_bb: List of generations: &quot;);
3042     for (int jj = 0; jj &lt; _ii_order.length(); ++jj) {
3043       tty-&gt;print(&quot;  %d:%d&quot;, jj, _ii_order.at(jj));
3044     }
3045     tty-&gt;print_cr(&quot; &quot;);
3046   }
3047   if (TraceSuperWord) {
3048     print_bb();
3049     tty-&gt;print_cr(&quot;\ndata entry nodes: %s&quot;, _data_entry.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
3050     for (int m = 0; m &lt; _data_entry.length(); m++) {
3051       tty-&gt;print(&quot;%3d &quot;, m);
3052       _data_entry.at(m)-&gt;dump();
3053     }
3054     tty-&gt;print_cr(&quot;\nmemory slices: %s&quot;, _mem_slice_head.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
3055     for (int m = 0; m &lt; _mem_slice_head.length(); m++) {
3056       tty-&gt;print(&quot;%3d &quot;, m); _mem_slice_head.at(m)-&gt;dump();
3057       tty-&gt;print(&quot;    &quot;);    _mem_slice_tail.at(m)-&gt;dump();
3058     }
3059   }
3060 #endif
3061   assert(rpo_idx == -1 &amp;&amp; bb_ct == _block.length(), &quot;all block members found&quot;);
3062   return (_mem_slice_head.length() &gt; 0) || (reduction_uses &gt; 0) || (_data_entry.length() &gt; 0);
3063 }
3064 
3065 //------------------------------initialize_bb---------------------------
3066 // Initialize per node info
3067 void SuperWord::initialize_bb() {
3068   Node* last = _block.at(_block.length() - 1);
3069   grow_node_info(bb_idx(last));
3070 }
3071 
3072 //------------------------------bb_insert_after---------------------------
3073 // Insert n into block after pos
3074 void SuperWord::bb_insert_after(Node* n, int pos) {
3075   int n_pos = pos + 1;
3076   // Make room
3077   for (int i = _block.length() - 1; i &gt;= n_pos; i--) {
3078     _block.at_put_grow(i+1, _block.at(i));
3079   }
3080   for (int j = _node_info.length() - 1; j &gt;= n_pos; j--) {
3081     _node_info.at_put_grow(j+1, _node_info.at(j));
3082   }
3083   // Set value
3084   _block.at_put_grow(n_pos, n);
3085   _node_info.at_put_grow(n_pos, SWNodeInfo::initial);
3086   // Adjust map from node-&gt;_idx to _block index
3087   for (int i = n_pos; i &lt; _block.length(); i++) {
3088     set_bb_idx(_block.at(i), i);
3089   }
3090 }
3091 
3092 //------------------------------compute_max_depth---------------------------
3093 // Compute max depth for expressions from beginning of block
3094 // Use to prune search paths during test for independence.
3095 void SuperWord::compute_max_depth() {
3096   int ct = 0;
3097   bool again;
3098   do {
3099     again = false;
3100     for (int i = 0; i &lt; _block.length(); i++) {
3101       Node* n = _block.at(i);
3102       if (!n-&gt;is_Phi()) {
3103         int d_orig = depth(n);
3104         int d_in   = 0;
3105         for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {
3106           Node* pred = preds.current();
3107           if (in_bb(pred)) {
3108             d_in = MAX2(d_in, depth(pred));
3109           }
3110         }
3111         if (d_in + 1 != d_orig) {
3112           set_depth(n, d_in + 1);
3113           again = true;
3114         }
3115       }
3116     }
3117     ct++;
3118   } while (again);
3119 
3120   if (TraceSuperWord &amp;&amp; Verbose) {
3121     tty-&gt;print_cr(&quot;compute_max_depth iterated: %d times&quot;, ct);
3122   }
3123 }
3124 
3125 //-------------------------compute_vector_element_type-----------------------
3126 // Compute necessary vector element type for expressions
3127 // This propagates backwards a narrower integer type when the
3128 // upper bits of the value are not needed.
3129 // Example:  char a,b,c;  a = b + c;
3130 // Normally the type of the add is integer, but for packed character
3131 // operations the type of the add needs to be char.
3132 void SuperWord::compute_vector_element_type() {
3133   if (TraceSuperWord &amp;&amp; Verbose) {
3134     tty-&gt;print_cr(&quot;\ncompute_velt_type:&quot;);
3135   }
3136 
3137   // Initial type
3138   for (int i = 0; i &lt; _block.length(); i++) {
3139     Node* n = _block.at(i);
3140     set_velt_type(n, container_type(n));
3141   }
3142 
3143   // Propagate integer narrowed type backwards through operations
3144   // that don&#39;t depend on higher order bits
3145   for (int i = _block.length() - 1; i &gt;= 0; i--) {
3146     Node* n = _block.at(i);
3147     // Only integer types need be examined
3148     const Type* vtn = velt_type(n);
3149     if (vtn-&gt;basic_type() == T_INT) {
3150       uint start, end;
3151       VectorNode::vector_operands(n, &amp;start, &amp;end);
3152 
3153       for (uint j = start; j &lt; end; j++) {
3154         Node* in  = n-&gt;in(j);
3155         // Don&#39;t propagate through a memory
3156         if (!in-&gt;is_Mem() &amp;&amp; in_bb(in) &amp;&amp; velt_type(in)-&gt;basic_type() == T_INT &amp;&amp;
3157             data_size(n) &lt; data_size(in)) {
3158           bool same_type = true;
3159           for (DUIterator_Fast kmax, k = in-&gt;fast_outs(kmax); k &lt; kmax; k++) {
3160             Node *use = in-&gt;fast_out(k);
3161             if (!in_bb(use) || !same_velt_type(use, n)) {
3162               same_type = false;
3163               break;
3164             }
3165           }
3166           if (same_type) {
3167             // For right shifts of small integer types (bool, byte, char, short)
3168             // we need precise information about sign-ness. Only Load nodes have
3169             // this information because Store nodes are the same for signed and
3170             // unsigned values. And any arithmetic operation after a load may
3171             // expand a value to signed Int so such right shifts can&#39;t be used
3172             // because vector elements do not have upper bits of Int.
3173             const Type* vt = vtn;
3174             if (VectorNode::is_shift(in)) {
3175               Node* load = in-&gt;in(1);
3176               if (load-&gt;is_Load() &amp;&amp; in_bb(load) &amp;&amp; (velt_type(load)-&gt;basic_type() == T_INT)) {
3177                 vt = velt_type(load);
3178               } else if (in-&gt;Opcode() != Op_LShiftI) {
3179                 // Widen type to Int to avoid creation of right shift vector
3180                 // (align + data_size(s1) check in stmts_can_pack() will fail).
3181                 // Note, left shifts work regardless type.
3182                 vt = TypeInt::INT;
3183               }
3184             }
3185             set_velt_type(in, vt);
3186           }
3187         }
3188       }
3189     }
3190   }
3191 #ifndef PRODUCT
3192   if (TraceSuperWord &amp;&amp; Verbose) {
3193     for (int i = 0; i &lt; _block.length(); i++) {
3194       Node* n = _block.at(i);
3195       velt_type(n)-&gt;dump();
3196       tty-&gt;print(&quot;\t&quot;);
3197       n-&gt;dump();
3198     }
3199   }
3200 #endif
3201 }
3202 
3203 //------------------------------memory_alignment---------------------------
3204 // Alignment within a vector memory reference
3205 int SuperWord::memory_alignment(MemNode* s, int iv_adjust) {
3206   #ifndef PRODUCT
3207     if(TraceSuperWord &amp;&amp; Verbose) {
3208       tty-&gt;print(&quot;SuperWord::memory_alignment within a vector memory reference for %d:  &quot;, s-&gt;_idx); s-&gt;dump();
3209     }
3210   #endif
3211   NOT_PRODUCT(SWPointer::Tracer::Depth ddd(0);)
3212   SWPointer p(s, this, NULL, false);
3213   if (!p.valid()) {
3214     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print(&quot;SWPointer::memory_alignment: SWPointer p invalid, return bottom_align&quot;);)
3215     return bottom_align;
3216   }
3217   int vw = get_vw_bytes_special(s);
3218   if (vw &lt; 2) {
3219     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SWPointer::memory_alignment: vector_width_in_bytes &lt; 2, return bottom_align&quot;);)
3220     return bottom_align; // No vectors for this type
3221   }
3222   int offset  = p.offset_in_bytes();
3223   offset     += iv_adjust*p.memory_size();
3224   int off_rem = offset % vw;
3225   int off_mod = off_rem &gt;= 0 ? off_rem : off_rem + vw;
3226   if (TraceSuperWord &amp;&amp; Verbose) {
3227     tty-&gt;print_cr(&quot;SWPointer::memory_alignment: off_rem = %d, off_mod = %d&quot;, off_rem, off_mod);
3228   }
3229   return off_mod;
3230 }
3231 
3232 //---------------------------container_type---------------------------
3233 // Smallest type containing range of values
3234 const Type* SuperWord::container_type(Node* n) {
3235   if (n-&gt;is_Mem()) {
3236     BasicType bt = n-&gt;as_Mem()-&gt;memory_type();
3237     if (n-&gt;is_Store() &amp;&amp; (bt == T_CHAR)) {
3238       // Use T_SHORT type instead of T_CHAR for stored values because any
3239       // preceding arithmetic operation extends values to signed Int.
3240       bt = T_SHORT;
3241     }
3242     if (n-&gt;Opcode() == Op_LoadUB) {
3243       // Adjust type for unsigned byte loads, it is important for right shifts.
3244       // T_BOOLEAN is used because there is no basic type representing type
3245       // TypeInt::UBYTE. Use of T_BOOLEAN for vectors is fine because only
3246       // size (one byte) and sign is important.
3247       bt = T_BOOLEAN;
3248     }
3249     return Type::get_const_basic_type(bt);
3250   }
3251   const Type* t = _igvn.type(n);
3252   if (t-&gt;basic_type() == T_INT) {
3253     // A narrow type of arithmetic operations will be determined by
3254     // propagating the type of memory operations.
3255     return TypeInt::INT;
3256   }
3257   return t;
3258 }
3259 
3260 bool SuperWord::same_velt_type(Node* n1, Node* n2) {
3261   const Type* vt1 = velt_type(n1);
3262   const Type* vt2 = velt_type(n2);
3263   if (vt1-&gt;basic_type() == T_INT &amp;&amp; vt2-&gt;basic_type() == T_INT) {
3264     // Compare vectors element sizes for integer types.
3265     return data_size(n1) == data_size(n2);
3266   }
3267   return vt1 == vt2;
3268 }
3269 
3270 //------------------------------in_packset---------------------------
3271 // Are s1 and s2 in a pack pair and ordered as s1,s2?
3272 bool SuperWord::in_packset(Node* s1, Node* s2) {
3273   for (int i = 0; i &lt; _packset.length(); i++) {
3274     Node_List* p = _packset.at(i);
3275     assert(p-&gt;size() == 2, &quot;must be&quot;);
3276     if (p-&gt;at(0) == s1 &amp;&amp; p-&gt;at(p-&gt;size()-1) == s2) {
3277       return true;
3278     }
3279   }
3280   return false;
3281 }
3282 
3283 //------------------------------in_pack---------------------------
3284 // Is s in pack p?
3285 Node_List* SuperWord::in_pack(Node* s, Node_List* p) {
3286   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3287     if (p-&gt;at(i) == s) {
3288       return p;
3289     }
3290   }
3291   return NULL;
3292 }
3293 
3294 //------------------------------remove_pack_at---------------------------
3295 // Remove the pack at position pos in the packset
3296 void SuperWord::remove_pack_at(int pos) {
3297   Node_List* p = _packset.at(pos);
3298   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3299     Node* s = p-&gt;at(i);
3300     set_my_pack(s, NULL);
3301   }
3302   _packset.remove_at(pos);
3303 }
3304 
3305 void SuperWord::packset_sort(int n) {
3306   // simple bubble sort so that we capitalize with O(n) when its already sorted
3307   while (n != 0) {
3308     bool swapped = false;
3309     for (int i = 1; i &lt; n; i++) {
3310       Node_List* q_low = _packset.at(i-1);
3311       Node_List* q_i = _packset.at(i);
3312 
3313       // only swap when we find something to swap
3314       if (alignment(q_low-&gt;at(0)) &gt; alignment(q_i-&gt;at(0))) {
3315         Node_List* t = q_i;
3316         *(_packset.adr_at(i)) = q_low;
3317         *(_packset.adr_at(i-1)) = q_i;
3318         swapped = true;
3319       }
3320     }
3321     if (swapped == false) break;
3322     n--;
3323   }
3324 }
3325 
3326 //------------------------------executed_first---------------------------
3327 // Return the node executed first in pack p.  Uses the RPO block list
3328 // to determine order.
3329 Node* SuperWord::executed_first(Node_List* p) {
3330   Node* n = p-&gt;at(0);
3331   int n_rpo = bb_idx(n);
3332   for (uint i = 1; i &lt; p-&gt;size(); i++) {
3333     Node* s = p-&gt;at(i);
3334     int s_rpo = bb_idx(s);
3335     if (s_rpo &lt; n_rpo) {
3336       n = s;
3337       n_rpo = s_rpo;
3338     }
3339   }
3340   return n;
3341 }
3342 
3343 //------------------------------executed_last---------------------------
3344 // Return the node executed last in pack p.
3345 Node* SuperWord::executed_last(Node_List* p) {
3346   Node* n = p-&gt;at(0);
3347   int n_rpo = bb_idx(n);
3348   for (uint i = 1; i &lt; p-&gt;size(); i++) {
3349     Node* s = p-&gt;at(i);
3350     int s_rpo = bb_idx(s);
3351     if (s_rpo &gt; n_rpo) {
3352       n = s;
3353       n_rpo = s_rpo;
3354     }
3355   }
3356   return n;
3357 }
3358 
3359 LoadNode::ControlDependency SuperWord::control_dependency(Node_List* p) {
3360   LoadNode::ControlDependency dep = LoadNode::DependsOnlyOnTest;
3361   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3362     Node* n = p-&gt;at(i);
3363     assert(n-&gt;is_Load(), &quot;only meaningful for loads&quot;);
3364     if (!n-&gt;depends_only_on_test()) {
3365       if (n-&gt;as_Load()-&gt;has_unknown_control_dependency() &amp;&amp;
3366           dep != LoadNode::Pinned) {
3367         // Upgrade to unknown control...
3368         dep = LoadNode::UnknownControl;
3369       } else {
3370         // Otherwise, we must pin it.
3371         dep = LoadNode::Pinned;
3372       }
3373     }
3374   }
3375   return dep;
3376 }
3377 
3378 
3379 //----------------------------align_initial_loop_index---------------------------
3380 // Adjust pre-loop limit so that in main loop, a load/store reference
3381 // to align_to_ref will be a position zero in the vector.
3382 //   (iv + k) mod vector_align == 0
3383 void SuperWord::align_initial_loop_index(MemNode* align_to_ref) {
3384   CountedLoopNode *main_head = lp()-&gt;as_CountedLoop();
3385   assert(main_head-&gt;is_main_loop(), &quot;&quot;);
3386   CountedLoopEndNode* pre_end = get_pre_loop_end(main_head);
3387   assert(pre_end != NULL, &quot;we must have a correct pre-loop&quot;);
3388   Node *pre_opaq1 = pre_end-&gt;limit();
3389   assert(pre_opaq1-&gt;Opcode() == Op_Opaque1, &quot;&quot;);
3390   Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
3391   Node *lim0 = pre_opaq-&gt;in(1);
3392 
3393   // Where we put new limit calculations
3394   Node *pre_ctrl = pre_end-&gt;loopnode()-&gt;in(LoopNode::EntryControl);
3395 
3396   // Ensure the original loop limit is available from the
3397   // pre-loop Opaque1 node.
3398   Node *orig_limit = pre_opaq-&gt;original_loop_limit();
3399   assert(orig_limit != NULL &amp;&amp; _igvn.type(orig_limit) != Type::TOP, &quot;&quot;);
3400 
3401   SWPointer align_to_ref_p(align_to_ref, this, NULL, false);
3402   assert(align_to_ref_p.valid(), &quot;sanity&quot;);
3403 
3404   // Given:
3405   //     lim0 == original pre loop limit
3406   //     V == v_align (power of 2)
3407   //     invar == extra invariant piece of the address expression
3408   //     e == offset [ +/- invar ]
3409   //
3410   // When reassociating expressions involving &#39;%&#39; the basic rules are:
3411   //     (a - b) % k == 0   =&gt;  a % k == b % k
3412   // and:
3413   //     (a + b) % k == 0   =&gt;  a % k == (k - b) % k
3414   //
3415   // For stride &gt; 0 &amp;&amp; scale &gt; 0,
3416   //   Derive the new pre-loop limit &quot;lim&quot; such that the two constraints:
3417   //     (1) lim = lim0 + N           (where N is some positive integer &lt; V)
3418   //     (2) (e + lim) % V == 0
3419   //   are true.
3420   //
3421   //   Substituting (1) into (2),
3422   //     (e + lim0 + N) % V == 0
3423   //   solve for N:
3424   //     N = (V - (e + lim0)) % V
3425   //   substitute back into (1), so that new limit
3426   //     lim = lim0 + (V - (e + lim0)) % V
3427   //
3428   // For stride &gt; 0 &amp;&amp; scale &lt; 0
3429   //   Constraints:
3430   //     lim = lim0 + N
3431   //     (e - lim) % V == 0
3432   //   Solving for lim:
3433   //     (e - lim0 - N) % V == 0
3434   //     N = (e - lim0) % V
3435   //     lim = lim0 + (e - lim0) % V
3436   //
3437   // For stride &lt; 0 &amp;&amp; scale &gt; 0
3438   //   Constraints:
3439   //     lim = lim0 - N
3440   //     (e + lim) % V == 0
3441   //   Solving for lim:
3442   //     (e + lim0 - N) % V == 0
3443   //     N = (e + lim0) % V
3444   //     lim = lim0 - (e + lim0) % V
3445   //
3446   // For stride &lt; 0 &amp;&amp; scale &lt; 0
3447   //   Constraints:
3448   //     lim = lim0 - N
3449   //     (e - lim) % V == 0
3450   //   Solving for lim:
3451   //     (e - lim0 + N) % V == 0
3452   //     N = (V - (e - lim0)) % V
3453   //     lim = lim0 - (V - (e - lim0)) % V
3454 
3455   int vw = vector_width_in_bytes(align_to_ref);
3456   int stride   = iv_stride();
3457   int scale    = align_to_ref_p.scale_in_bytes();
3458   int elt_size = align_to_ref_p.memory_size();
3459   int v_align  = vw / elt_size;
3460   assert(v_align &gt; 1, &quot;sanity&quot;);
3461   int offset   = align_to_ref_p.offset_in_bytes() / elt_size;
3462   Node *offsn  = _igvn.intcon(offset);
3463 
3464   Node *e = offsn;
3465   if (align_to_ref_p.invar() != NULL) {
3466     // incorporate any extra invariant piece producing (offset +/- invar) &gt;&gt;&gt; log2(elt)
3467     Node* log2_elt = _igvn.intcon(exact_log2(elt_size));
3468     Node* invar = align_to_ref_p.invar();
3469     if (_igvn.type(invar)-&gt;isa_long()) {
3470       // Computations are done % (vector width/element size) so it&#39;s
3471       // safe to simply convert invar to an int and loose the upper 32
3472       // bit half.
3473       invar = new ConvL2INode(invar);
3474       _igvn.register_new_node_with_optimizer(invar);
3475     }
3476     Node* aref = new URShiftINode(invar, log2_elt);
3477     _igvn.register_new_node_with_optimizer(aref);
3478     _phase-&gt;set_ctrl(aref, pre_ctrl);
3479     if (align_to_ref_p.negate_invar()) {
3480       e = new SubINode(e, aref);
3481     } else {
3482       e = new AddINode(e, aref);
3483     }
3484     _igvn.register_new_node_with_optimizer(e);
3485     _phase-&gt;set_ctrl(e, pre_ctrl);
3486   }
3487   if (vw &gt; ObjectAlignmentInBytes || align_to_ref_p.base()-&gt;is_top()) {
3488     // incorporate base e +/- base &amp;&amp; Mask &gt;&gt;&gt; log2(elt)
3489     Node* xbase = new CastP2XNode(NULL, align_to_ref_p.adr());
3490     _igvn.register_new_node_with_optimizer(xbase);
3491 #ifdef _LP64
3492     xbase  = new ConvL2INode(xbase);
3493     _igvn.register_new_node_with_optimizer(xbase);
3494 #endif
3495     Node* mask = _igvn.intcon(vw-1);
3496     Node* masked_xbase  = new AndINode(xbase, mask);
3497     _igvn.register_new_node_with_optimizer(masked_xbase);
3498     Node* log2_elt = _igvn.intcon(exact_log2(elt_size));
3499     Node* bref     = new URShiftINode(masked_xbase, log2_elt);
3500     _igvn.register_new_node_with_optimizer(bref);
3501     _phase-&gt;set_ctrl(bref, pre_ctrl);
3502     e = new AddINode(e, bref);
3503     _igvn.register_new_node_with_optimizer(e);
3504     _phase-&gt;set_ctrl(e, pre_ctrl);
3505   }
3506 
3507   // compute e +/- lim0
3508   if (scale &lt; 0) {
3509     e = new SubINode(e, lim0);
3510   } else {
3511     e = new AddINode(e, lim0);
3512   }
3513   _igvn.register_new_node_with_optimizer(e);
3514   _phase-&gt;set_ctrl(e, pre_ctrl);
3515 
3516   if (stride * scale &gt; 0) {
3517     // compute V - (e +/- lim0)
3518     Node* va  = _igvn.intcon(v_align);
3519     e = new SubINode(va, e);
3520     _igvn.register_new_node_with_optimizer(e);
3521     _phase-&gt;set_ctrl(e, pre_ctrl);
3522   }
3523   // compute N = (exp) % V
3524   Node* va_msk = _igvn.intcon(v_align - 1);
3525   Node* N = new AndINode(e, va_msk);
3526   _igvn.register_new_node_with_optimizer(N);
3527   _phase-&gt;set_ctrl(N, pre_ctrl);
3528 
3529   //   substitute back into (1), so that new limit
3530   //     lim = lim0 + N
3531   Node* lim;
3532   if (stride &lt; 0) {
3533     lim = new SubINode(lim0, N);
3534   } else {
3535     lim = new AddINode(lim0, N);
3536   }
3537   _igvn.register_new_node_with_optimizer(lim);
3538   _phase-&gt;set_ctrl(lim, pre_ctrl);
3539   Node* constrained =
3540     (stride &gt; 0) ? (Node*) new MinINode(lim, orig_limit)
3541                  : (Node*) new MaxINode(lim, orig_limit);
3542   _igvn.register_new_node_with_optimizer(constrained);
3543   _phase-&gt;set_ctrl(constrained, pre_ctrl);
3544   _igvn.replace_input_of(pre_opaq, 1, constrained);
3545 }
3546 
3547 //----------------------------get_pre_loop_end---------------------------
3548 // Find pre loop end from main loop.  Returns null if none.
3549 CountedLoopEndNode* SuperWord::get_pre_loop_end(CountedLoopNode* cl) {
3550   // The loop cannot be optimized if the graph shape at
3551   // the loop entry is inappropriate.
3552   if (!PhaseIdealLoop::is_canonical_loop_entry(cl)) {
3553     return NULL;
3554   }
3555 
3556   Node* p_f = cl-&gt;skip_predicates()-&gt;in(0)-&gt;in(0);
3557   if (!p_f-&gt;is_IfFalse()) return NULL;
3558   if (!p_f-&gt;in(0)-&gt;is_CountedLoopEnd()) return NULL;
3559   CountedLoopEndNode* pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
3560   CountedLoopNode* loop_node = pre_end-&gt;loopnode();
3561   if (loop_node == NULL || !loop_node-&gt;is_pre_loop()) return NULL;
3562   return pre_end;
3563 }
3564 
3565 //------------------------------init---------------------------
3566 void SuperWord::init() {
3567   _dg.init();
3568   _packset.clear();
3569   _disjoint_ptrs.clear();
3570   _block.clear();
3571   _post_block.clear();
3572   _data_entry.clear();
3573   _mem_slice_head.clear();
3574   _mem_slice_tail.clear();
3575   _iteration_first.clear();
3576   _iteration_last.clear();
3577   _node_info.clear();
3578   _align_to_ref = NULL;
3579   _lpt = NULL;
3580   _lp = NULL;
3581   _bb = NULL;
3582   _iv = NULL;
3583   _race_possible = 0;
3584   _early_return = false;
3585   _num_work_vecs = 0;
3586   _num_reductions = 0;
3587 }
3588 
3589 //------------------------------restart---------------------------
3590 void SuperWord::restart() {
3591   _dg.init();
3592   _packset.clear();
3593   _disjoint_ptrs.clear();
3594   _block.clear();
3595   _post_block.clear();
3596   _data_entry.clear();
3597   _mem_slice_head.clear();
3598   _mem_slice_tail.clear();
3599   _node_info.clear();
3600 }
3601 
3602 //------------------------------print_packset---------------------------
3603 void SuperWord::print_packset() {
3604 #ifndef PRODUCT
3605   tty-&gt;print_cr(&quot;packset&quot;);
3606   for (int i = 0; i &lt; _packset.length(); i++) {
3607     tty-&gt;print_cr(&quot;Pack: %d&quot;, i);
3608     Node_List* p = _packset.at(i);
3609     print_pack(p);
3610   }
3611 #endif
3612 }
3613 
3614 //------------------------------print_pack---------------------------
3615 void SuperWord::print_pack(Node_List* p) {
3616   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3617     print_stmt(p-&gt;at(i));
3618   }
3619 }
3620 
3621 //------------------------------print_bb---------------------------
3622 void SuperWord::print_bb() {
3623 #ifndef PRODUCT
3624   tty-&gt;print_cr(&quot;\nBlock&quot;);
3625   for (int i = 0; i &lt; _block.length(); i++) {
3626     Node* n = _block.at(i);
3627     tty-&gt;print(&quot;%d &quot;, i);
3628     if (n) {
3629       n-&gt;dump();
3630     }
3631   }
3632 #endif
3633 }
3634 
3635 //------------------------------print_stmt---------------------------
3636 void SuperWord::print_stmt(Node* s) {
3637 #ifndef PRODUCT
3638   tty-&gt;print(&quot; align: %d \t&quot;, alignment(s));
3639   s-&gt;dump();
3640 #endif
3641 }
3642 
3643 //------------------------------blank---------------------------
3644 char* SuperWord::blank(uint depth) {
3645   static char blanks[101];
3646   assert(depth &lt; 101, &quot;too deep&quot;);
3647   for (uint i = 0; i &lt; depth; i++) blanks[i] = &#39; &#39;;
3648   blanks[depth] = &#39;\0&#39;;
3649   return blanks;
3650 }
3651 
3652 
3653 //==============================SWPointer===========================
3654 #ifndef PRODUCT
3655 int SWPointer::Tracer::_depth = 0;
3656 #endif
3657 //----------------------------SWPointer------------------------
3658 SWPointer::SWPointer(MemNode* mem, SuperWord* slp, Node_Stack *nstack, bool analyze_only) :
3659   _mem(mem), _slp(slp),  _base(NULL),  _adr(NULL),
3660   _scale(0), _offset(0), _invar(NULL), _negate_invar(false),
3661   _nstack(nstack), _analyze_only(analyze_only),
3662   _stack_idx(0)
3663 #ifndef PRODUCT
3664   , _tracer(slp)
3665 #endif
3666 {
3667   NOT_PRODUCT(_tracer.ctor_1(mem);)
3668 
3669   Node* adr = mem-&gt;in(MemNode::Address);
3670   if (!adr-&gt;is_AddP()) {
3671     assert(!valid(), &quot;too complex&quot;);
3672     return;
3673   }
3674   // Match AddP(base, AddP(ptr, k*iv [+ invariant]), constant)
3675   Node* base = adr-&gt;in(AddPNode::Base);
3676   // The base address should be loop invariant
3677   if (!invariant(base)) {
3678     assert(!valid(), &quot;base address is loop variant&quot;);
3679     return;
3680   }
3681   // unsafe references require misaligned vector access support
3682   if (base-&gt;is_top() &amp;&amp; !Matcher::misaligned_vectors_ok()) {
3683     assert(!valid(), &quot;unsafe access&quot;);
3684     return;
3685   }
3686 
3687   NOT_PRODUCT(if(_slp-&gt;is_trace_alignment()) _tracer.store_depth();)
3688   NOT_PRODUCT(_tracer.ctor_2(adr);)
3689 
3690   int i;
3691   for (i = 0; i &lt; 3; i++) {
3692     NOT_PRODUCT(_tracer.ctor_3(adr, i);)
3693 
3694     if (!scaled_iv_plus_offset(adr-&gt;in(AddPNode::Offset))) {
3695       assert(!valid(), &quot;too complex&quot;);
3696       return;
3697     }
3698     adr = adr-&gt;in(AddPNode::Address);
3699     NOT_PRODUCT(_tracer.ctor_4(adr, i);)
3700 
3701     if (base == adr || !adr-&gt;is_AddP()) {
3702       NOT_PRODUCT(_tracer.ctor_5(adr, base, i);)
3703       break; // stop looking at addp&#39;s
3704     }
3705   }
3706   if (!invariant(adr)) {
3707     assert(!valid(), &quot;adr is loop variant&quot;);
3708     return;
3709   }
3710 
3711   if (!base-&gt;is_top() &amp;&amp; adr != base) {
3712     assert(!valid(), &quot;adr and base differ&quot;);
3713     return;
3714   }
3715 
3716   NOT_PRODUCT(if(_slp-&gt;is_trace_alignment()) _tracer.restore_depth();)
3717   NOT_PRODUCT(_tracer.ctor_6(mem);)
3718 
3719   _base = base;
3720   _adr  = adr;
3721   assert(valid(), &quot;Usable&quot;);
3722 }
3723 
3724 // Following is used to create a temporary object during
3725 // the pattern match of an address expression.
3726 SWPointer::SWPointer(SWPointer* p) :
3727   _mem(p-&gt;_mem), _slp(p-&gt;_slp),  _base(NULL),  _adr(NULL),
3728   _scale(0), _offset(0), _invar(NULL), _negate_invar(false),
3729   _nstack(p-&gt;_nstack), _analyze_only(p-&gt;_analyze_only),
3730   _stack_idx(p-&gt;_stack_idx)
3731   #ifndef PRODUCT
3732   , _tracer(p-&gt;_slp)
3733   #endif
3734 {}
3735 
3736 
3737 bool SWPointer::invariant(Node* n) {
3738   NOT_PRODUCT(Tracer::Depth dd;)
3739   Node *n_c = phase()-&gt;get_ctrl(n);
3740   NOT_PRODUCT(_tracer.invariant_1(n, n_c);)
3741   return !lpt()-&gt;is_member(phase()-&gt;get_loop(n_c));
3742 }
3743 //------------------------scaled_iv_plus_offset--------------------
3744 // Match: k*iv + offset
3745 // where: k is a constant that maybe zero, and
3746 //        offset is (k2 [+/- invariant]) where k2 maybe zero and invariant is optional
3747 bool SWPointer::scaled_iv_plus_offset(Node* n) {
3748   NOT_PRODUCT(Tracer::Depth ddd;)
3749   NOT_PRODUCT(_tracer.scaled_iv_plus_offset_1(n);)
3750 
3751   if (scaled_iv(n)) {
3752     NOT_PRODUCT(_tracer.scaled_iv_plus_offset_2(n);)
3753     return true;
3754   }
3755 
3756   if (offset_plus_k(n)) {
3757     NOT_PRODUCT(_tracer.scaled_iv_plus_offset_3(n);)
3758     return true;
3759   }
3760 
3761   int opc = n-&gt;Opcode();
3762   if (opc == Op_AddI) {
3763     if (scaled_iv(n-&gt;in(1)) &amp;&amp; offset_plus_k(n-&gt;in(2))) {
3764       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_4(n);)
3765       return true;
3766     }
3767     if (scaled_iv(n-&gt;in(2)) &amp;&amp; offset_plus_k(n-&gt;in(1))) {
3768       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_5(n);)
3769       return true;
3770     }
3771   } else if (opc == Op_SubI) {
3772     if (scaled_iv(n-&gt;in(1)) &amp;&amp; offset_plus_k(n-&gt;in(2), true)) {
3773       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_6(n);)
3774       return true;
3775     }
3776     if (scaled_iv(n-&gt;in(2)) &amp;&amp; offset_plus_k(n-&gt;in(1))) {
3777       _scale *= -1;
3778       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_7(n);)
3779       return true;
3780     }
3781   }
3782 
3783   NOT_PRODUCT(_tracer.scaled_iv_plus_offset_8(n);)
3784   return false;
3785 }
3786 
3787 //----------------------------scaled_iv------------------------
3788 // Match: k*iv where k is a constant that&#39;s not zero
3789 bool SWPointer::scaled_iv(Node* n) {
3790   NOT_PRODUCT(Tracer::Depth ddd;)
3791   NOT_PRODUCT(_tracer.scaled_iv_1(n);)
3792 
3793   if (_scale != 0) { // already found a scale
3794     NOT_PRODUCT(_tracer.scaled_iv_2(n, _scale);)
3795     return false;
3796   }
3797 
3798   if (n == iv()) {
3799     _scale = 1;
3800     NOT_PRODUCT(_tracer.scaled_iv_3(n, _scale);)
3801     return true;
3802   }
3803   if (_analyze_only &amp;&amp; (invariant(n) == false)) {
3804     _nstack-&gt;push(n, _stack_idx++);
3805   }
3806 
3807   int opc = n-&gt;Opcode();
3808   if (opc == Op_MulI) {
3809     if (n-&gt;in(1) == iv() &amp;&amp; n-&gt;in(2)-&gt;is_Con()) {
3810       _scale = n-&gt;in(2)-&gt;get_int();
3811       NOT_PRODUCT(_tracer.scaled_iv_4(n, _scale);)
3812       return true;
3813     } else if (n-&gt;in(2) == iv() &amp;&amp; n-&gt;in(1)-&gt;is_Con()) {
3814       _scale = n-&gt;in(1)-&gt;get_int();
3815       NOT_PRODUCT(_tracer.scaled_iv_5(n, _scale);)
3816       return true;
3817     }
3818   } else if (opc == Op_LShiftI) {
3819     if (n-&gt;in(1) == iv() &amp;&amp; n-&gt;in(2)-&gt;is_Con()) {
3820       _scale = 1 &lt;&lt; n-&gt;in(2)-&gt;get_int();
3821       NOT_PRODUCT(_tracer.scaled_iv_6(n, _scale);)
3822       return true;
3823     }
3824   } else if (opc == Op_ConvI2L) {
3825     if (n-&gt;in(1)-&gt;Opcode() == Op_CastII &amp;&amp;
3826         n-&gt;in(1)-&gt;as_CastII()-&gt;has_range_check()) {
3827       // Skip range check dependent CastII nodes
3828       n = n-&gt;in(1);
3829     }
3830     if (scaled_iv_plus_offset(n-&gt;in(1))) {
3831       NOT_PRODUCT(_tracer.scaled_iv_7(n);)
3832       return true;
3833     }
3834   } else if (opc == Op_LShiftL) {
3835     if (!has_iv() &amp;&amp; _invar == NULL) {
3836       // Need to preserve the current _offset value, so
3837       // create a temporary object for this expression subtree.
3838       // Hacky, so should re-engineer the address pattern match.
3839       NOT_PRODUCT(Tracer::Depth dddd;)
3840       SWPointer tmp(this);
3841       NOT_PRODUCT(_tracer.scaled_iv_8(n, &amp;tmp);)
3842 
3843       if (tmp.scaled_iv_plus_offset(n-&gt;in(1))) {
3844         if (tmp._invar == NULL || _slp-&gt;do_vector_loop()) {
3845           int mult = 1 &lt;&lt; n-&gt;in(2)-&gt;get_int();
3846           _scale   = tmp._scale  * mult;
3847           _offset += tmp._offset * mult;
3848           NOT_PRODUCT(_tracer.scaled_iv_9(n, _scale, _offset, mult);)
3849           return true;
3850         }
3851       }
3852     }
3853   }
3854   NOT_PRODUCT(_tracer.scaled_iv_10(n);)
3855   return false;
3856 }
3857 
3858 //----------------------------offset_plus_k------------------------
3859 // Match: offset is (k [+/- invariant])
3860 // where k maybe zero and invariant is optional, but not both.
3861 bool SWPointer::offset_plus_k(Node* n, bool negate) {
3862   NOT_PRODUCT(Tracer::Depth ddd;)
3863   NOT_PRODUCT(_tracer.offset_plus_k_1(n);)
3864 
3865   int opc = n-&gt;Opcode();
3866   if (opc == Op_ConI) {
3867     _offset += negate ? -(n-&gt;get_int()) : n-&gt;get_int();
3868     NOT_PRODUCT(_tracer.offset_plus_k_2(n, _offset);)
3869     return true;
3870   } else if (opc == Op_ConL) {
3871     // Okay if value fits into an int
3872     const TypeLong* t = n-&gt;find_long_type();
3873     if (t-&gt;higher_equal(TypeLong::INT)) {
3874       jlong loff = n-&gt;get_long();
3875       jint  off  = (jint)loff;
3876       _offset += negate ? -off : loff;
3877       NOT_PRODUCT(_tracer.offset_plus_k_3(n, _offset);)
3878       return true;
3879     }
3880     NOT_PRODUCT(_tracer.offset_plus_k_4(n);)
3881     return false;
3882   }
3883   if (_invar != NULL) { // already has an invariant
3884     NOT_PRODUCT(_tracer.offset_plus_k_5(n, _invar);)
3885     return false;
3886   }
3887 
3888   if (_analyze_only &amp;&amp; (invariant(n) == false)) {
3889     _nstack-&gt;push(n, _stack_idx++);
3890   }
3891   if (opc == Op_AddI) {
3892     if (n-&gt;in(2)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(1))) {
3893       _negate_invar = negate;
3894       _invar = n-&gt;in(1);
3895       _offset += negate ? -(n-&gt;in(2)-&gt;get_int()) : n-&gt;in(2)-&gt;get_int();
3896       NOT_PRODUCT(_tracer.offset_plus_k_6(n, _invar, _negate_invar, _offset);)
3897       return true;
3898     } else if (n-&gt;in(1)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(2))) {
3899       _offset += negate ? -(n-&gt;in(1)-&gt;get_int()) : n-&gt;in(1)-&gt;get_int();
3900       _negate_invar = negate;
3901       _invar = n-&gt;in(2);
3902       NOT_PRODUCT(_tracer.offset_plus_k_7(n, _invar, _negate_invar, _offset);)
3903       return true;
3904     }
3905   }
3906   if (opc == Op_SubI) {
3907     if (n-&gt;in(2)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(1))) {
3908       _negate_invar = negate;
3909       _invar = n-&gt;in(1);
3910       _offset += !negate ? -(n-&gt;in(2)-&gt;get_int()) : n-&gt;in(2)-&gt;get_int();
3911       NOT_PRODUCT(_tracer.offset_plus_k_8(n, _invar, _negate_invar, _offset);)
3912       return true;
3913     } else if (n-&gt;in(1)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(2))) {
3914       _offset += negate ? -(n-&gt;in(1)-&gt;get_int()) : n-&gt;in(1)-&gt;get_int();
3915       _negate_invar = !negate;
3916       _invar = n-&gt;in(2);
3917       NOT_PRODUCT(_tracer.offset_plus_k_9(n, _invar, _negate_invar, _offset);)
3918       return true;
3919     }
3920   }
3921   if (invariant(n)) {
3922     if (opc == Op_ConvI2L) {
3923       n = n-&gt;in(1);
3924       if (n-&gt;Opcode() == Op_CastII &amp;&amp;
3925           n-&gt;as_CastII()-&gt;has_range_check()) {
3926         // Skip range check dependent CastII nodes
3927         assert(invariant(n), &quot;sanity&quot;);
3928         n = n-&gt;in(1);
3929       }
3930     }
3931     _negate_invar = negate;
3932     _invar = n;
3933     NOT_PRODUCT(_tracer.offset_plus_k_10(n, _invar, _negate_invar, _offset);)
3934     return true;
3935   }
3936 
3937   NOT_PRODUCT(_tracer.offset_plus_k_11(n);)
3938   return false;
3939 }
3940 
3941 //----------------------------print------------------------
3942 void SWPointer::print() {
3943 #ifndef PRODUCT
3944   tty-&gt;print(&quot;base: %d  adr: %d  scale: %d  offset: %d  invar: %c%d\n&quot;,
3945              _base != NULL ? _base-&gt;_idx : 0,
3946              _adr  != NULL ? _adr-&gt;_idx  : 0,
3947              _scale, _offset,
3948              _negate_invar?&#39;-&#39;:&#39;+&#39;,
3949              _invar != NULL ? _invar-&gt;_idx : 0);
3950 #endif
3951 }
3952 
3953 //----------------------------tracing------------------------
3954 #ifndef PRODUCT
3955 void SWPointer::Tracer::print_depth() {
3956   for (int ii = 0; ii&lt;_depth; ++ii) tty-&gt;print(&quot;  &quot;);
3957 }
3958 
3959 void SWPointer::Tracer::ctor_1 (Node* mem) {
3960   if(_slp-&gt;is_trace_alignment()) {
3961     print_depth(); tty-&gt;print(&quot; %d SWPointer::SWPointer: start alignment analysis&quot;, mem-&gt;_idx); mem-&gt;dump();
3962   }
3963 }
3964 
3965 void SWPointer::Tracer::ctor_2(Node* adr) {
3966   if(_slp-&gt;is_trace_alignment()) {
3967     //store_depth();
3968     inc_depth();
3969     print_depth(); tty-&gt;print(&quot; %d (adr) SWPointer::SWPointer: &quot;, adr-&gt;_idx); adr-&gt;dump();
3970     inc_depth();
3971     print_depth(); tty-&gt;print(&quot; %d (base) SWPointer::SWPointer: &quot;, adr-&gt;in(AddPNode::Base)-&gt;_idx); adr-&gt;in(AddPNode::Base)-&gt;dump();
3972   }
3973 }
3974 
3975 void SWPointer::Tracer::ctor_3(Node* adr, int i) {
3976   if(_slp-&gt;is_trace_alignment()) {
3977     inc_depth();
3978     Node* offset = adr-&gt;in(AddPNode::Offset);
3979     print_depth(); tty-&gt;print(&quot; %d (offset) SWPointer::SWPointer: i = %d: &quot;, offset-&gt;_idx, i); offset-&gt;dump();
3980   }
3981 }
3982 
3983 void SWPointer::Tracer::ctor_4(Node* adr, int i) {
3984   if(_slp-&gt;is_trace_alignment()) {
3985     inc_depth();
3986     print_depth(); tty-&gt;print(&quot; %d (adr) SWPointer::SWPointer: i = %d: &quot;, adr-&gt;_idx, i); adr-&gt;dump();
3987   }
3988 }
3989 
3990 void SWPointer::Tracer::ctor_5(Node* adr, Node* base, int i) {
3991   if(_slp-&gt;is_trace_alignment()) {
3992     inc_depth();
3993     if (base == adr) {
3994       print_depth(); tty-&gt;print_cr(&quot;  \\ %d (adr) == %d (base) SWPointer::SWPointer: breaking analysis at i = %d&quot;, adr-&gt;_idx, base-&gt;_idx, i);
3995     } else if (!adr-&gt;is_AddP()) {
3996       print_depth(); tty-&gt;print_cr(&quot;  \\ %d (adr) is NOT Addp SWPointer::SWPointer: breaking analysis at i = %d&quot;, adr-&gt;_idx, i);
3997     }
3998   }
3999 }
4000 
4001 void SWPointer::Tracer::ctor_6(Node* mem) {
4002   if(_slp-&gt;is_trace_alignment()) {
4003     //restore_depth();
4004     print_depth(); tty-&gt;print_cr(&quot; %d (adr) SWPointer::SWPointer: stop analysis&quot;, mem-&gt;_idx);
4005   }
4006 }
4007 
4008 void SWPointer::Tracer::invariant_1(Node *n, Node *n_c) {
4009   if (_slp-&gt;do_vector_loop() &amp;&amp; _slp-&gt;is_debug() &amp;&amp; _slp-&gt;_lpt-&gt;is_member(_slp-&gt;_phase-&gt;get_loop(n_c)) != (int)_slp-&gt;in_bb(n)) {
4010     int is_member =  _slp-&gt;_lpt-&gt;is_member(_slp-&gt;_phase-&gt;get_loop(n_c));
4011     int in_bb     =  _slp-&gt;in_bb(n);
4012     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  tty-&gt;print_cr(&quot; %d SWPointer::invariant  conditions differ: n_c %d&quot;, n-&gt;_idx, n_c-&gt;_idx);
4013     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  tty-&gt;print_cr(&quot;is_member %d, in_bb %d&quot;, is_member, in_bb);
4014     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  n-&gt;dump();
4015     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  n_c-&gt;dump();
4016   }
4017 }
4018 
4019 void SWPointer::Tracer::scaled_iv_plus_offset_1(Node* n) {
4020   if(_slp-&gt;is_trace_alignment()) {
4021     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv_plus_offset testing node: &quot;, n-&gt;_idx);
4022     n-&gt;dump();
4023   }
4024 }
4025 
4026 void SWPointer::Tracer::scaled_iv_plus_offset_2(Node* n) {
4027   if(_slp-&gt;is_trace_alignment()) {
4028     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: PASSED&quot;, n-&gt;_idx);
4029   }
4030 }
4031 
4032 void SWPointer::Tracer::scaled_iv_plus_offset_3(Node* n) {
4033   if(_slp-&gt;is_trace_alignment()) {
4034     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: PASSED&quot;, n-&gt;_idx);
4035   }
4036 }
4037 
4038 void SWPointer::Tracer::scaled_iv_plus_offset_4(Node* n) {
4039   if(_slp-&gt;is_trace_alignment()) {
4040     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_AddI PASSED&quot;, n-&gt;_idx);
4041     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is scaled_iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4042     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is offset_plus_k: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4043   }
4044 }
4045 
4046 void SWPointer::Tracer::scaled_iv_plus_offset_5(Node* n) {
4047   if(_slp-&gt;is_trace_alignment()) {
4048     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_AddI PASSED&quot;, n-&gt;_idx);
4049     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is scaled_iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4050     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is offset_plus_k: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4051   }
4052 }
4053 
4054 void SWPointer::Tracer::scaled_iv_plus_offset_6(Node* n) {
4055   if(_slp-&gt;is_trace_alignment()) {
4056     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_SubI PASSED&quot;, n-&gt;_idx);
4057     print_depth(); tty-&gt;print(&quot;  \\  %d SWPointer::scaled_iv_plus_offset: in(1) is scaled_iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4058     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is offset_plus_k: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4059   }
4060 }
4061 
4062 void SWPointer::Tracer::scaled_iv_plus_offset_7(Node* n) {
4063   if(_slp-&gt;is_trace_alignment()) {
4064     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_SubI PASSED&quot;, n-&gt;_idx);
4065     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is scaled_iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4066     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is offset_plus_k: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4067   }
4068 }
4069 
4070 void SWPointer::Tracer::scaled_iv_plus_offset_8(Node* n) {
4071   if(_slp-&gt;is_trace_alignment()) {
4072     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: FAILED&quot;, n-&gt;_idx);
4073   }
4074 }
4075 
4076 void SWPointer::Tracer::scaled_iv_1(Node* n) {
4077   if(_slp-&gt;is_trace_alignment()) {
4078     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv: testing node: &quot;, n-&gt;_idx); n-&gt;dump();
4079   }
4080 }
4081 
4082 void SWPointer::Tracer::scaled_iv_2(Node* n, int scale) {
4083   if(_slp-&gt;is_trace_alignment()) {
4084     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: FAILED since another _scale has been detected before&quot;, n-&gt;_idx);
4085     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: _scale (%d) != 0&quot;, scale);
4086   }
4087 }
4088 
4089 void SWPointer::Tracer::scaled_iv_3(Node* n, int scale) {
4090   if(_slp-&gt;is_trace_alignment()) {
4091     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: is iv, setting _scale = %d&quot;, n-&gt;_idx, scale);
4092   }
4093 }
4094 
4095 void SWPointer::Tracer::scaled_iv_4(Node* n, int scale) {
4096   if(_slp-&gt;is_trace_alignment()) {
4097     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_MulI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4098     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4099     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4100   }
4101 }
4102 
4103 void SWPointer::Tracer::scaled_iv_5(Node* n, int scale) {
4104   if(_slp-&gt;is_trace_alignment()) {
4105     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_MulI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4106     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4107     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4108   }
4109 }
4110 
4111 void SWPointer::Tracer::scaled_iv_6(Node* n, int scale) {
4112   if(_slp-&gt;is_trace_alignment()) {
4113     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_LShiftI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4114     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4115     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4116   }
4117 }
4118 
4119 void SWPointer::Tracer::scaled_iv_7(Node* n) {
4120   if(_slp-&gt;is_trace_alignment()) {
4121     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_ConvI2L PASSED&quot;, n-&gt;_idx);
4122     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: in(1) %d is scaled_iv_plus_offset: &quot;, n-&gt;in(1)-&gt;_idx);
4123     inc_depth(); inc_depth();
4124     print_depth(); n-&gt;in(1)-&gt;dump();
4125     dec_depth(); dec_depth();
4126   }
4127 }
4128 
4129 void SWPointer::Tracer::scaled_iv_8(Node* n, SWPointer* tmp) {
4130   if(_slp-&gt;is_trace_alignment()) {
4131     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv: Op_LShiftL, creating tmp SWPointer: &quot;, n-&gt;_idx); tmp-&gt;print();
4132   }
4133 }
4134 
4135 void SWPointer::Tracer::scaled_iv_9(Node* n, int scale, int _offset, int mult) {
4136   if(_slp-&gt;is_trace_alignment()) {
4137     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_LShiftL PASSED, setting _scale = %d, _offset = %d&quot;, n-&gt;_idx, scale, _offset);
4138     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: in(1) %d is scaled_iv_plus_offset, in(2) %d used to get mult = %d: _scale = %d, _offset = %d&quot;,
4139     n-&gt;in(1)-&gt;_idx, n-&gt;in(2)-&gt;_idx, mult, scale, _offset);
4140     inc_depth(); inc_depth();
4141     print_depth(); n-&gt;in(1)-&gt;dump();
4142     print_depth(); n-&gt;in(2)-&gt;dump();
4143     dec_depth(); dec_depth();
4144   }
4145 }
4146 
4147 void SWPointer::Tracer::scaled_iv_10(Node* n) {
4148   if(_slp-&gt;is_trace_alignment()) {
4149     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: FAILED&quot;, n-&gt;_idx);
4150   }
4151 }
4152 
4153 void SWPointer::Tracer::offset_plus_k_1(Node* n) {
4154   if(_slp-&gt;is_trace_alignment()) {
4155     print_depth(); tty-&gt;print(&quot; %d SWPointer::offset_plus_k: testing node: &quot;, n-&gt;_idx); n-&gt;dump();
4156   }
4157 }
4158 
4159 void SWPointer::Tracer::offset_plus_k_2(Node* n, int _offset) {
4160   if(_slp-&gt;is_trace_alignment()) {
4161     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_ConI PASSED, setting _offset = %d&quot;, n-&gt;_idx, _offset);
4162   }
4163 }
4164 
4165 void SWPointer::Tracer::offset_plus_k_3(Node* n, int _offset) {
4166   if(_slp-&gt;is_trace_alignment()) {
4167     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_ConL PASSED, setting _offset = %d&quot;, n-&gt;_idx, _offset);
4168   }
4169 }
4170 
4171 void SWPointer::Tracer::offset_plus_k_4(Node* n) {
4172   if(_slp-&gt;is_trace_alignment()) {
4173     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED&quot;, n-&gt;_idx);
4174     print_depth(); tty-&gt;print_cr(&quot;  \\ &quot; JLONG_FORMAT &quot; SWPointer::offset_plus_k: Op_ConL FAILED, k is too big&quot;, n-&gt;get_long());
4175   }
4176 }
4177 
4178 void SWPointer::Tracer::offset_plus_k_5(Node* n, Node* _invar) {
4179   if(_slp-&gt;is_trace_alignment()) {
4180     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED since another invariant has been detected before&quot;, n-&gt;_idx);
4181     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: _invar != NULL: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4182   }
4183 }
4184 
4185 void SWPointer::Tracer::offset_plus_k_6(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4186   if(_slp-&gt;is_trace_alignment()) {
4187     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4188     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4189     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4190     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4191   }
4192 }
4193 
4194 void SWPointer::Tracer::offset_plus_k_7(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4195   if(_slp-&gt;is_trace_alignment()) {
4196     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4197     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4198     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4199     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4200   }
4201 }
4202 
4203 void SWPointer::Tracer::offset_plus_k_8(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4204   if(_slp-&gt;is_trace_alignment()) {
4205     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_SubI is PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4206     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4207     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4208     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4209   }
4210 }
4211 
4212 void SWPointer::Tracer::offset_plus_k_9(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4213   if(_slp-&gt;is_trace_alignment()) {
4214     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_SubI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;, n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4215     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4216     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4217   }
4218 }
4219 
4220 void SWPointer::Tracer::offset_plus_k_10(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4221   if(_slp-&gt;is_trace_alignment()) {
4222     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;, n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4223     print_depth(); tty-&gt;print_cr(&quot;  \\ %d SWPointer::offset_plus_k: is invariant&quot;, n-&gt;_idx);
4224   }
4225 }
4226 
4227 void SWPointer::Tracer::offset_plus_k_11(Node* n) {
4228   if(_slp-&gt;is_trace_alignment()) {
4229     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED&quot;, n-&gt;_idx);
4230   }
4231 }
4232 
4233 #endif
4234 // ========================= OrderedPair =====================
4235 
4236 const OrderedPair OrderedPair::initial;
4237 
4238 // ========================= SWNodeInfo =====================
4239 
4240 const SWNodeInfo SWNodeInfo::initial;
4241 
4242 
4243 // ============================ DepGraph ===========================
4244 
4245 //------------------------------make_node---------------------------
4246 // Make a new dependence graph node for an ideal node.
4247 DepMem* DepGraph::make_node(Node* node) {
4248   DepMem* m = new (_arena) DepMem(node);
4249   if (node != NULL) {
4250     assert(_map.at_grow(node-&gt;_idx) == NULL, &quot;one init only&quot;);
4251     _map.at_put_grow(node-&gt;_idx, m);
4252   }
4253   return m;
4254 }
4255 
4256 //------------------------------make_edge---------------------------
4257 // Make a new dependence graph edge from dpred -&gt; dsucc
4258 DepEdge* DepGraph::make_edge(DepMem* dpred, DepMem* dsucc) {
4259   DepEdge* e = new (_arena) DepEdge(dpred, dsucc, dsucc-&gt;in_head(), dpred-&gt;out_head());
4260   dpred-&gt;set_out_head(e);
4261   dsucc-&gt;set_in_head(e);
4262   return e;
4263 }
4264 
4265 // ========================== DepMem ========================
4266 
4267 //------------------------------in_cnt---------------------------
4268 int DepMem::in_cnt() {
4269   int ct = 0;
4270   for (DepEdge* e = _in_head; e != NULL; e = e-&gt;next_in()) ct++;
4271   return ct;
4272 }
4273 
4274 //------------------------------out_cnt---------------------------
4275 int DepMem::out_cnt() {
4276   int ct = 0;
4277   for (DepEdge* e = _out_head; e != NULL; e = e-&gt;next_out()) ct++;
4278   return ct;
4279 }
4280 
4281 //------------------------------print-----------------------------
4282 void DepMem::print() {
4283 #ifndef PRODUCT
4284   tty-&gt;print(&quot;  DepNode %d (&quot;, _node-&gt;_idx);
4285   for (DepEdge* p = _in_head; p != NULL; p = p-&gt;next_in()) {
4286     Node* pred = p-&gt;pred()-&gt;node();
4287     tty-&gt;print(&quot; %d&quot;, pred != NULL ? pred-&gt;_idx : 0);
4288   }
4289   tty-&gt;print(&quot;) [&quot;);
4290   for (DepEdge* s = _out_head; s != NULL; s = s-&gt;next_out()) {
4291     Node* succ = s-&gt;succ()-&gt;node();
4292     tty-&gt;print(&quot; %d&quot;, succ != NULL ? succ-&gt;_idx : 0);
4293   }
4294   tty-&gt;print_cr(&quot; ]&quot;);
4295 #endif
4296 }
4297 
4298 // =========================== DepEdge =========================
4299 
4300 //------------------------------DepPreds---------------------------
4301 void DepEdge::print() {
4302 #ifndef PRODUCT
4303   tty-&gt;print_cr(&quot;DepEdge: %d [ %d ]&quot;, _pred-&gt;node()-&gt;_idx, _succ-&gt;node()-&gt;_idx);
4304 #endif
4305 }
4306 
4307 // =========================== DepPreds =========================
4308 // Iterator over predecessor edges in the dependence graph.
4309 
4310 //------------------------------DepPreds---------------------------
4311 DepPreds::DepPreds(Node* n, DepGraph&amp; dg) {
4312   _n = n;
4313   _done = false;
4314   if (_n-&gt;is_Store() || _n-&gt;is_Load()) {
4315     _next_idx = MemNode::Address;
4316     _end_idx  = n-&gt;req();
4317     _dep_next = dg.dep(_n)-&gt;in_head();
4318   } else if (_n-&gt;is_Mem()) {
4319     _next_idx = 0;
4320     _end_idx  = 0;
4321     _dep_next = dg.dep(_n)-&gt;in_head();
4322   } else {
4323     _next_idx = 1;
4324     _end_idx  = _n-&gt;req();
4325     _dep_next = NULL;
4326   }
4327   next();
4328 }
4329 
4330 //------------------------------next---------------------------
4331 void DepPreds::next() {
4332   if (_dep_next != NULL) {
4333     _current  = _dep_next-&gt;pred()-&gt;node();
4334     _dep_next = _dep_next-&gt;next_in();
4335   } else if (_next_idx &lt; _end_idx) {
4336     _current  = _n-&gt;in(_next_idx++);
4337   } else {
4338     _done = true;
4339   }
4340 }
4341 
4342 // =========================== DepSuccs =========================
4343 // Iterator over successor edges in the dependence graph.
4344 
4345 //------------------------------DepSuccs---------------------------
4346 DepSuccs::DepSuccs(Node* n, DepGraph&amp; dg) {
4347   _n = n;
4348   _done = false;
4349   if (_n-&gt;is_Load()) {
4350     _next_idx = 0;
4351     _end_idx  = _n-&gt;outcnt();
4352     _dep_next = dg.dep(_n)-&gt;out_head();
4353   } else if (_n-&gt;is_Mem() || (_n-&gt;is_Phi() &amp;&amp; _n-&gt;bottom_type() == Type::MEMORY)) {
4354     _next_idx = 0;
4355     _end_idx  = 0;
4356     _dep_next = dg.dep(_n)-&gt;out_head();
4357   } else {
4358     _next_idx = 0;
4359     _end_idx  = _n-&gt;outcnt();
4360     _dep_next = NULL;
4361   }
4362   next();
4363 }
4364 
4365 //-------------------------------next---------------------------
4366 void DepSuccs::next() {
4367   if (_dep_next != NULL) {
4368     _current  = _dep_next-&gt;succ()-&gt;node();
4369     _dep_next = _dep_next-&gt;next_out();
4370   } else if (_next_idx &lt; _end_idx) {
4371     _current  = _n-&gt;raw_out(_next_idx++);
4372   } else {
4373     _done = true;
4374   }
4375 }
4376 
4377 //
4378 // --------------------------------- vectorization/simd -----------------------------------
4379 //
4380 bool SuperWord::same_origin_idx(Node* a, Node* b) const {
4381   return a != NULL &amp;&amp; b != NULL &amp;&amp; _clone_map.same_idx(a-&gt;_idx, b-&gt;_idx);
4382 }
4383 bool SuperWord::same_generation(Node* a, Node* b) const {
4384   return a != NULL &amp;&amp; b != NULL &amp;&amp; _clone_map.same_gen(a-&gt;_idx, b-&gt;_idx);
4385 }
4386 
4387 Node*  SuperWord::find_phi_for_mem_dep(LoadNode* ld) {
4388   assert(in_bb(ld), &quot;must be in block&quot;);
4389   if (_clone_map.gen(ld-&gt;_idx) == _ii_first) {
4390 #ifndef PRODUCT
4391     if (_vector_loop_debug) {
4392       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep _clone_map.gen(ld-&gt;_idx)=%d&quot;,
4393         _clone_map.gen(ld-&gt;_idx));
4394     }
4395 #endif
4396     return NULL; //we think that any ld in the first gen being vectorizable
4397   }
4398 
4399   Node* mem = ld-&gt;in(MemNode::Memory);
4400   if (mem-&gt;outcnt() &lt;= 1) {
4401     // we don&#39;t want to remove the only edge from mem node to load
4402 #ifndef PRODUCT
4403     if (_vector_loop_debug) {
4404       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep input node %d to load %d has no other outputs and edge mem-&gt;load cannot be removed&quot;,
4405         mem-&gt;_idx, ld-&gt;_idx);
4406       ld-&gt;dump();
4407       mem-&gt;dump();
4408     }
4409 #endif
4410     return NULL;
4411   }
4412   if (!in_bb(mem) || same_generation(mem, ld)) {
4413 #ifndef PRODUCT
4414     if (_vector_loop_debug) {
4415       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep _clone_map.gen(mem-&gt;_idx)=%d&quot;,
4416         _clone_map.gen(mem-&gt;_idx));
4417     }
4418 #endif
4419     return NULL; // does not depend on loop volatile node or depends on the same generation
4420   }
4421 
4422   //otherwise first node should depend on mem-phi
4423   Node* first = first_node(ld);
4424   assert(first-&gt;is_Load(), &quot;must be Load&quot;);
4425   Node* phi = first-&gt;as_Load()-&gt;in(MemNode::Memory);
4426   if (!phi-&gt;is_Phi() || phi-&gt;bottom_type() != Type::MEMORY) {
4427 #ifndef PRODUCT
4428     if (_vector_loop_debug) {
4429       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep load is not vectorizable node, since it&#39;s `first` does not take input from mem phi&quot;);
4430       ld-&gt;dump();
4431       first-&gt;dump();
4432     }
4433 #endif
4434     return NULL;
4435   }
4436 
4437   Node* tail = 0;
4438   for (int m = 0; m &lt; _mem_slice_head.length(); m++) {
4439     if (_mem_slice_head.at(m) == phi) {
4440       tail = _mem_slice_tail.at(m);
4441     }
4442   }
4443   if (tail == 0) { //test that found phi is in the list  _mem_slice_head
4444 #ifndef PRODUCT
4445     if (_vector_loop_debug) {
4446       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep load %d is not vectorizable node, its phi %d is not _mem_slice_head&quot;,
4447         ld-&gt;_idx, phi-&gt;_idx);
4448       ld-&gt;dump();
4449       phi-&gt;dump();
4450     }
4451 #endif
4452     return NULL;
4453   }
4454 
4455   // now all conditions are met
4456   return phi;
4457 }
4458 
4459 Node* SuperWord::first_node(Node* nd) {
4460   for (int ii = 0; ii &lt; _iteration_first.length(); ii++) {
4461     Node* nnn = _iteration_first.at(ii);
4462     if (same_origin_idx(nnn, nd)) {
4463 #ifndef PRODUCT
4464       if (_vector_loop_debug) {
4465         tty-&gt;print_cr(&quot;SuperWord::first_node: %d is the first iteration node for %d (_clone_map.idx(nnn-&gt;_idx) = %d)&quot;,
4466           nnn-&gt;_idx, nd-&gt;_idx, _clone_map.idx(nnn-&gt;_idx));
4467       }
4468 #endif
4469       return nnn;
4470     }
4471   }
4472 
4473 #ifndef PRODUCT
4474   if (_vector_loop_debug) {
4475     tty-&gt;print_cr(&quot;SuperWord::first_node: did not find first iteration node for %d (_clone_map.idx(nd-&gt;_idx)=%d)&quot;,
4476       nd-&gt;_idx, _clone_map.idx(nd-&gt;_idx));
4477   }
4478 #endif
4479   return 0;
4480 }
4481 
4482 Node* SuperWord::last_node(Node* nd) {
4483   for (int ii = 0; ii &lt; _iteration_last.length(); ii++) {
4484     Node* nnn = _iteration_last.at(ii);
4485     if (same_origin_idx(nnn, nd)) {
4486 #ifndef PRODUCT
4487       if (_vector_loop_debug) {
4488         tty-&gt;print_cr(&quot;SuperWord::last_node _clone_map.idx(nnn-&gt;_idx)=%d, _clone_map.idx(nd-&gt;_idx)=%d&quot;,
4489           _clone_map.idx(nnn-&gt;_idx), _clone_map.idx(nd-&gt;_idx));
4490       }
4491 #endif
4492       return nnn;
4493     }
4494   }
4495   return 0;
4496 }
4497 
4498 int SuperWord::mark_generations() {
4499   Node *ii_err = NULL, *tail_err = NULL;
4500   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
4501     Node* phi  = _mem_slice_head.at(i);
4502     assert(phi-&gt;is_Phi(), &quot;must be phi&quot;);
4503 
4504     Node* tail = _mem_slice_tail.at(i);
4505     if (_ii_last == -1) {
4506       tail_err = tail;
4507       _ii_last = _clone_map.gen(tail-&gt;_idx);
4508     }
4509     else if (_ii_last != _clone_map.gen(tail-&gt;_idx)) {
4510 #ifndef PRODUCT
4511       if (TraceSuperWord &amp;&amp; Verbose) {
4512         tty-&gt;print_cr(&quot;SuperWord::mark_generations _ii_last error - found different generations in two tail nodes &quot;);
4513         tail-&gt;dump();
4514         tail_err-&gt;dump();
4515       }
4516 #endif
4517       return -1;
4518     }
4519 
4520     // find first iteration in the loop
4521     for (DUIterator_Fast imax, i = phi-&gt;fast_outs(imax); i &lt; imax; i++) {
4522       Node* ii = phi-&gt;fast_out(i);
4523       if (in_bb(ii) &amp;&amp; ii-&gt;is_Store()) { // we speculate that normally Stores of one and one only generation have deps from mem phi
4524         if (_ii_first == -1) {
4525           ii_err = ii;
4526           _ii_first = _clone_map.gen(ii-&gt;_idx);
4527         } else if (_ii_first != _clone_map.gen(ii-&gt;_idx)) {
4528 #ifndef PRODUCT
4529           if (TraceSuperWord &amp;&amp; Verbose) {
4530             tty-&gt;print_cr(&quot;SuperWord::mark_generations: _ii_first was found before and not equal to one in this node (%d)&quot;, _ii_first);
4531             ii-&gt;dump();
4532             if (ii_err!= 0) {
4533               ii_err-&gt;dump();
4534             }
4535           }
4536 #endif
4537           return -1; // this phi has Stores from different generations of unroll and cannot be simd/vectorized
4538         }
4539       }
4540     }//for (DUIterator_Fast imax,
4541   }//for (int i...
4542 
4543   if (_ii_first == -1 || _ii_last == -1) {
4544     if (TraceSuperWord &amp;&amp; Verbose) {
4545       tty-&gt;print_cr(&quot;SuperWord::mark_generations unknown error, something vent wrong&quot;);
4546     }
4547     return -1; // something vent wrong
4548   }
4549   // collect nodes in the first and last generations
4550   assert(_iteration_first.length() == 0, &quot;_iteration_first must be empty&quot;);
4551   assert(_iteration_last.length() == 0, &quot;_iteration_last must be empty&quot;);
4552   for (int j = 0; j &lt; _block.length(); j++) {
4553     Node* n = _block.at(j);
4554     node_idx_t gen = _clone_map.gen(n-&gt;_idx);
4555     if ((signed)gen == _ii_first) {
4556       _iteration_first.push(n);
4557     } else if ((signed)gen == _ii_last) {
4558       _iteration_last.push(n);
4559     }
4560   }
4561 
4562   // building order of iterations
4563   if (_ii_order.length() == 0 &amp;&amp; ii_err != 0) {
4564     assert(in_bb(ii_err) &amp;&amp; ii_err-&gt;is_Store(), &quot;should be Store in bb&quot;);
4565     Node* nd = ii_err;
4566     while(_clone_map.gen(nd-&gt;_idx) != _ii_last) {
4567       _ii_order.push(_clone_map.gen(nd-&gt;_idx));
4568       bool found = false;
4569       for (DUIterator_Fast imax, i = nd-&gt;fast_outs(imax); i &lt; imax; i++) {
4570         Node* use = nd-&gt;fast_out(i);
4571         if (same_origin_idx(use, nd) &amp;&amp; use-&gt;as_Store()-&gt;in(MemNode::Memory) == nd) {
4572           found = true;
4573           nd = use;
4574           break;
4575         }
4576       }//for
4577 
4578       if (found == false) {
4579         if (TraceSuperWord &amp;&amp; Verbose) {
4580           tty-&gt;print_cr(&quot;SuperWord::mark_generations: Cannot build order of iterations - no dependent Store for %d&quot;, nd-&gt;_idx);
4581         }
4582         _ii_order.clear();
4583         return -1;
4584       }
4585     } //while
4586     _ii_order.push(_clone_map.gen(nd-&gt;_idx));
4587   }
4588 
4589 #ifndef PRODUCT
4590   if (_vector_loop_debug) {
4591     tty-&gt;print_cr(&quot;SuperWord::mark_generations&quot;);
4592     tty-&gt;print_cr(&quot;First generation (%d) nodes:&quot;, _ii_first);
4593     for (int ii = 0; ii &lt; _iteration_first.length(); ii++)  _iteration_first.at(ii)-&gt;dump();
4594     tty-&gt;print_cr(&quot;Last generation (%d) nodes:&quot;, _ii_last);
4595     for (int ii = 0; ii &lt; _iteration_last.length(); ii++)  _iteration_last.at(ii)-&gt;dump();
4596     tty-&gt;print_cr(&quot; &quot;);
4597 
4598     tty-&gt;print(&quot;SuperWord::List of generations: &quot;);
4599     for (int jj = 0; jj &lt; _ii_order.length(); ++jj) {
4600       tty-&gt;print(&quot;%d:%d &quot;, jj, _ii_order.at(jj));
4601     }
4602     tty-&gt;print_cr(&quot; &quot;);
4603   }
4604 #endif
4605 
4606   return _ii_first;
4607 }
4608 
4609 bool SuperWord::fix_commutative_inputs(Node* gold, Node* fix) {
4610   assert(gold-&gt;is_Add() &amp;&amp; fix-&gt;is_Add() || gold-&gt;is_Mul() &amp;&amp; fix-&gt;is_Mul(), &quot;should be only Add or Mul nodes&quot;);
4611   assert(same_origin_idx(gold, fix), &quot;should be clones of the same node&quot;);
4612   Node* gin1 = gold-&gt;in(1);
4613   Node* gin2 = gold-&gt;in(2);
4614   Node* fin1 = fix-&gt;in(1);
4615   Node* fin2 = fix-&gt;in(2);
4616   bool swapped = false;
4617 
4618   if (in_bb(gin1) &amp;&amp; in_bb(gin2) &amp;&amp; in_bb(fin1) &amp;&amp; in_bb(fin1)) {
4619     if (same_origin_idx(gin1, fin1) &amp;&amp;
4620         same_origin_idx(gin2, fin2)) {
4621       return true; // nothing to fix
4622     }
4623     if (same_origin_idx(gin1, fin2) &amp;&amp;
4624         same_origin_idx(gin2, fin1)) {
4625       fix-&gt;swap_edges(1, 2);
4626       swapped = true;
4627     }
4628   }
4629   // at least one input comes from outside of bb
4630   if (gin1-&gt;_idx == fin1-&gt;_idx)  {
4631     return true; // nothing to fix
4632   }
4633   if (!swapped &amp;&amp; (gin1-&gt;_idx == fin2-&gt;_idx || gin2-&gt;_idx == fin1-&gt;_idx))  { //swapping is expensive, check condition first
4634     fix-&gt;swap_edges(1, 2);
4635     swapped = true;
4636   }
4637 
4638   if (swapped) {
4639 #ifndef PRODUCT
4640     if (_vector_loop_debug) {
4641       tty-&gt;print_cr(&quot;SuperWord::fix_commutative_inputs: fixed node %d&quot;, fix-&gt;_idx);
4642     }
4643 #endif
4644     return true;
4645   }
4646 
4647   if (TraceSuperWord &amp;&amp; Verbose) {
4648     tty-&gt;print_cr(&quot;SuperWord::fix_commutative_inputs: cannot fix node %d&quot;, fix-&gt;_idx);
4649   }
4650 
4651   return false;
4652 }
4653 
4654 bool SuperWord::pack_parallel() {
4655 #ifndef PRODUCT
4656   if (_vector_loop_debug) {
4657     tty-&gt;print_cr(&quot;SuperWord::pack_parallel: START&quot;);
4658   }
4659 #endif
4660 
4661   _packset.clear();
4662 
4663   for (int ii = 0; ii &lt; _iteration_first.length(); ii++) {
4664     Node* nd = _iteration_first.at(ii);
4665     if (in_bb(nd) &amp;&amp; (nd-&gt;is_Load() || nd-&gt;is_Store() || nd-&gt;is_Add() || nd-&gt;is_Mul())) {
4666       Node_List* pk = new Node_List();
4667       pk-&gt;push(nd);
4668       for (int gen = 1; gen &lt; _ii_order.length(); ++gen) {
4669         for (int kk = 0; kk &lt; _block.length(); kk++) {
4670           Node* clone = _block.at(kk);
4671           if (same_origin_idx(clone, nd) &amp;&amp;
4672               _clone_map.gen(clone-&gt;_idx) == _ii_order.at(gen)) {
4673             if (nd-&gt;is_Add() || nd-&gt;is_Mul()) {
4674               fix_commutative_inputs(nd, clone);
4675             }
4676             pk-&gt;push(clone);
4677             if (pk-&gt;size() == 4) {
4678               _packset.append(pk);
4679 #ifndef PRODUCT
4680               if (_vector_loop_debug) {
4681                 tty-&gt;print_cr(&quot;SuperWord::pack_parallel: added pack &quot;);
4682                 pk-&gt;dump();
4683               }
4684 #endif
4685               if (_clone_map.gen(clone-&gt;_idx) != _ii_last) {
4686                 pk = new Node_List();
4687               }
4688             }
4689             break;
4690           }
4691         }
4692       }//for
4693     }//if
4694   }//for
4695 
4696 #ifndef PRODUCT
4697   if (_vector_loop_debug) {
4698     tty-&gt;print_cr(&quot;SuperWord::pack_parallel: END&quot;);
4699   }
4700 #endif
4701 
4702   return true;
4703 }
4704 
4705 bool SuperWord::hoist_loads_in_graph() {
4706   GrowableArray&lt;Node*&gt; loads;
4707 
4708 #ifndef PRODUCT
4709   if (_vector_loop_debug) {
4710     tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: total number _mem_slice_head.length() = %d&quot;, _mem_slice_head.length());
4711   }
4712 #endif
4713 
4714   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
4715     Node* n = _mem_slice_head.at(i);
4716     if ( !in_bb(n) || !n-&gt;is_Phi() || n-&gt;bottom_type() != Type::MEMORY) {
4717       if (TraceSuperWord &amp;&amp; Verbose) {
4718         tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: skipping unexpected node n=%d&quot;, n-&gt;_idx);
4719       }
4720       continue;
4721     }
4722 
4723 #ifndef PRODUCT
4724     if (_vector_loop_debug) {
4725       tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: processing phi %d  = _mem_slice_head.at(%d);&quot;, n-&gt;_idx, i);
4726     }
4727 #endif
4728 
4729     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
4730       Node* ld = n-&gt;fast_out(i);
4731       if (ld-&gt;is_Load() &amp;&amp; ld-&gt;as_Load()-&gt;in(MemNode::Memory) == n &amp;&amp; in_bb(ld)) {
4732         for (int i = 0; i &lt; _block.length(); i++) {
4733           Node* ld2 = _block.at(i);
4734           if (ld2-&gt;is_Load() &amp;&amp; same_origin_idx(ld, ld2) &amp;&amp;
4735               !same_generation(ld, ld2)) { // &lt;= do not collect the first generation ld
4736 #ifndef PRODUCT
4737             if (_vector_loop_debug) {
4738               tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: will try to hoist load ld2-&gt;_idx=%d, cloned from %d (ld-&gt;_idx=%d)&quot;,
4739                 ld2-&gt;_idx, _clone_map.idx(ld-&gt;_idx), ld-&gt;_idx);
4740             }
4741 #endif
4742             // could not do on-the-fly, since iterator is immutable
4743             loads.push(ld2);
4744           }
4745         }// for
4746       }//if
4747     }//for (DUIterator_Fast imax,
4748   }//for (int i = 0; i
4749 
4750   for (int i = 0; i &lt; loads.length(); i++) {
4751     LoadNode* ld = loads.at(i)-&gt;as_Load();
4752     Node* phi = find_phi_for_mem_dep(ld);
4753     if (phi != NULL) {
4754 #ifndef PRODUCT
4755       if (_vector_loop_debug) {
4756         tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph replacing MemNode::Memory(%d) edge in %d with one from %d&quot;,
4757           MemNode::Memory, ld-&gt;_idx, phi-&gt;_idx);
4758       }
4759 #endif
4760       _igvn.replace_input_of(ld, MemNode::Memory, phi);
4761     }
4762   }//for
4763 
4764   restart(); // invalidate all basic structures, since we rebuilt the graph
4765 
4766   if (TraceSuperWord &amp;&amp; Verbose) {
4767     tty-&gt;print_cr(&quot;\nSuperWord::hoist_loads_in_graph() the graph was rebuilt, all structures invalidated and need rebuild&quot;);
4768   }
4769 
4770   return true;
4771 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/superword.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stringopts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="superword.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/superword.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 598     }
 599 
 600     SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 601     // Set alignment relative to &quot;align_to_ref&quot; for all related memory operations.
 602     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 603       MemNode* s = memops.at(i)-&gt;as_Mem();
 604       if (isomorphic(s, mem_ref) &amp;&amp;
 605            (!_do_vector_loop || same_origin_idx(s, mem_ref))) {
 606         SWPointer p2(s, this, NULL, false);
 607         if (p2.comparable(align_to_ref_p)) {
 608           int align = memory_alignment(s, iv_adjustment);
 609           set_alignment(s, align);
 610         }
 611       }
 612     }
 613 
 614     // Create initial pack pairs of memory operations for which
 615     // alignment is set and vectors will be aligned.
 616     bool create_pack = true;
 617     if (memory_alignment(mem_ref, best_iv_adjustment) == 0 || _do_vector_loop) {
<span class="line-modified"> 618       if (!Matcher::misaligned_vectors_ok() || AlignVector) {</span>
 619         int vw = vector_width(mem_ref);
 620         int vw_best = vector_width(best_align_to_mem_ref);
 621         if (vw &gt; vw_best) {
 622           // Do not vectorize a memory access with more elements per vector
 623           // if unaligned memory access is not allowed because number of
 624           // iterations in pre-loop will be not enough to align it.
 625           create_pack = false;
 626         } else {
 627           SWPointer p2(best_align_to_mem_ref, this, NULL, false);
 628           if (align_to_ref_p.invar() != p2.invar()) {
 629             // Do not vectorize memory accesses with different invariants
 630             // if unaligned memory accesses are not allowed.
 631             create_pack = false;
 632           }
 633         }
 634       }
 635     } else {
 636       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 637         // Can&#39;t allow vectorization of unaligned memory accesses with the
 638         // same type since it could be overlapped accesses to the same array.
 639         create_pack = false;
 640       } else {
 641         // Allow independent (different type) unaligned memory operations
 642         // if HW supports them.
<span class="line-modified"> 643         if (!Matcher::misaligned_vectors_ok() || AlignVector) {</span>
 644           create_pack = false;
 645         } else {
 646           // Check if packs of the same memory type but
 647           // with a different alignment were created before.
 648           for (uint i = 0; i &lt; align_to_refs.size(); i++) {
 649             MemNode* mr = align_to_refs.at(i)-&gt;as_Mem();
 650             if (mr == mem_ref) {
 651               // Skip when we are looking at same memory operation.
 652               continue;
 653             }
 654             if (same_velt_type(mr, mem_ref) &amp;&amp;
 655                 memory_alignment(mr, iv_adjustment) != 0)
 656               create_pack = false;
 657           }
 658         }
 659       }
 660     }
 661     if (create_pack) {
 662       for (uint i = 0; i &lt; memops.size(); i++) {
 663         Node* s1 = memops.at(i);
</pre>
<hr />
<pre>
 759 void SuperWord::find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment) {
 760   if (is_trace_adjacent()) {
 761     tty-&gt;print(&quot;SuperWord::find_adjacent_refs best_align_to_mem_ref = %d, best_iv_adjustment = %d&quot;,
 762        best_align_to_mem_ref-&gt;_idx, best_iv_adjustment);
 763        best_align_to_mem_ref-&gt;dump();
 764   }
 765 }
 766 #endif
 767 
 768 //------------------------------find_align_to_ref---------------------------
 769 // Find a memory reference to align the loop induction variable to.
 770 // Looks first at stores then at loads, looking for a memory reference
 771 // with the largest number of references similar to it.
 772 MemNode* SuperWord::find_align_to_ref(Node_List &amp;memops, int &amp;idx) {
 773   GrowableArray&lt;int&gt; cmp_ct(arena(), memops.size(), memops.size(), 0);
 774 
 775   // Count number of comparable memory ops
 776   for (uint i = 0; i &lt; memops.size(); i++) {
 777     MemNode* s1 = memops.at(i)-&gt;as_Mem();
 778     SWPointer p1(s1, this, NULL, false);
<span class="line-modified"> 779     // Discard if pre loop can&#39;t align this reference</span>
<span class="line-modified"> 780     if (!ref_is_alignable(p1)) {</span>

 781       *cmp_ct.adr_at(i) = 0;
 782       continue;
 783     }
 784     for (uint j = i+1; j &lt; memops.size(); j++) {
 785       MemNode* s2 = memops.at(j)-&gt;as_Mem();
 786       if (isomorphic(s1, s2)) {
 787         SWPointer p2(s2, this, NULL, false);
 788         if (p1.comparable(p2)) {
 789           (*cmp_ct.adr_at(i))++;
 790           (*cmp_ct.adr_at(j))++;
 791         }
 792       }
 793     }
 794   }
 795 
 796   // Find Store (or Load) with the greatest number of &quot;comparable&quot; references,
 797   // biggest vector size, smallest data size and smallest iv offset.
 798   int max_ct        = 0;
 799   int max_vw        = 0;
 800   int max_idx       = -1;
</pre>
<hr />
<pre>
 981 
 982   return vw;
 983 }
 984 
 985 //---------------------------get_iv_adjustment---------------------------
 986 // Calculate loop&#39;s iv adjustment for this memory ops.
 987 int SuperWord::get_iv_adjustment(MemNode* mem_ref) {
 988   SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 989   int offset = align_to_ref_p.offset_in_bytes();
 990   int scale  = align_to_ref_p.scale_in_bytes();
 991   int elt_size = align_to_ref_p.memory_size();
 992   int vw       = get_vw_bytes_special(mem_ref);
 993   assert(vw &gt; 1, &quot;sanity&quot;);
 994   int iv_adjustment;
 995   if (scale != 0) {
 996     int stride_sign = (scale * iv_stride()) &gt; 0 ? 1 : -1;
 997     // At least one iteration is executed in pre-loop by default. As result
 998     // several iterations are needed to align memory operations in main-loop even
 999     // if offset is 0.
1000     int iv_adjustment_in_bytes = (stride_sign * vw - (offset % vw));
<span class="line-modified">1001     assert(((ABS(iv_adjustment_in_bytes) % elt_size) == 0),</span>


1002            &quot;(%d) should be divisible by (%d)&quot;, iv_adjustment_in_bytes, elt_size);
1003     iv_adjustment = iv_adjustment_in_bytes/elt_size;
1004   } else {
1005     // This memory op is not dependent on iv (scale == 0)
1006     iv_adjustment = 0;
1007   }
1008 
1009 #ifndef PRODUCT
1010   if (TraceSuperWord) {
1011     tty-&gt;print(&quot;SuperWord::get_iv_adjustment: n = %d, noffset = %d iv_adjust = %d elt_size = %d scale = %d iv_stride = %d vect_size %d: &quot;,
1012       mem_ref-&gt;_idx, offset, iv_adjustment, elt_size, scale, iv_stride(), vw);
1013     mem_ref-&gt;dump();
1014   }
1015 #endif
1016   return iv_adjustment;
1017 }
1018 
1019 //---------------------------dependence_graph---------------------------
1020 // Construct dependency graph.
1021 // Add dependence edges to load/store nodes for memory dependence
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 598     }
 599 
 600     SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 601     // Set alignment relative to &quot;align_to_ref&quot; for all related memory operations.
 602     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 603       MemNode* s = memops.at(i)-&gt;as_Mem();
 604       if (isomorphic(s, mem_ref) &amp;&amp;
 605            (!_do_vector_loop || same_origin_idx(s, mem_ref))) {
 606         SWPointer p2(s, this, NULL, false);
 607         if (p2.comparable(align_to_ref_p)) {
 608           int align = memory_alignment(s, iv_adjustment);
 609           set_alignment(s, align);
 610         }
 611       }
 612     }
 613 
 614     // Create initial pack pairs of memory operations for which
 615     // alignment is set and vectors will be aligned.
 616     bool create_pack = true;
 617     if (memory_alignment(mem_ref, best_iv_adjustment) == 0 || _do_vector_loop) {
<span class="line-modified"> 618       if (vectors_should_be_aligned()) {</span>
 619         int vw = vector_width(mem_ref);
 620         int vw_best = vector_width(best_align_to_mem_ref);
 621         if (vw &gt; vw_best) {
 622           // Do not vectorize a memory access with more elements per vector
 623           // if unaligned memory access is not allowed because number of
 624           // iterations in pre-loop will be not enough to align it.
 625           create_pack = false;
 626         } else {
 627           SWPointer p2(best_align_to_mem_ref, this, NULL, false);
 628           if (align_to_ref_p.invar() != p2.invar()) {
 629             // Do not vectorize memory accesses with different invariants
 630             // if unaligned memory accesses are not allowed.
 631             create_pack = false;
 632           }
 633         }
 634       }
 635     } else {
 636       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 637         // Can&#39;t allow vectorization of unaligned memory accesses with the
 638         // same type since it could be overlapped accesses to the same array.
 639         create_pack = false;
 640       } else {
 641         // Allow independent (different type) unaligned memory operations
 642         // if HW supports them.
<span class="line-modified"> 643         if (vectors_should_be_aligned()) {</span>
 644           create_pack = false;
 645         } else {
 646           // Check if packs of the same memory type but
 647           // with a different alignment were created before.
 648           for (uint i = 0; i &lt; align_to_refs.size(); i++) {
 649             MemNode* mr = align_to_refs.at(i)-&gt;as_Mem();
 650             if (mr == mem_ref) {
 651               // Skip when we are looking at same memory operation.
 652               continue;
 653             }
 654             if (same_velt_type(mr, mem_ref) &amp;&amp;
 655                 memory_alignment(mr, iv_adjustment) != 0)
 656               create_pack = false;
 657           }
 658         }
 659       }
 660     }
 661     if (create_pack) {
 662       for (uint i = 0; i &lt; memops.size(); i++) {
 663         Node* s1 = memops.at(i);
</pre>
<hr />
<pre>
 759 void SuperWord::find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment) {
 760   if (is_trace_adjacent()) {
 761     tty-&gt;print(&quot;SuperWord::find_adjacent_refs best_align_to_mem_ref = %d, best_iv_adjustment = %d&quot;,
 762        best_align_to_mem_ref-&gt;_idx, best_iv_adjustment);
 763        best_align_to_mem_ref-&gt;dump();
 764   }
 765 }
 766 #endif
 767 
 768 //------------------------------find_align_to_ref---------------------------
 769 // Find a memory reference to align the loop induction variable to.
 770 // Looks first at stores then at loads, looking for a memory reference
 771 // with the largest number of references similar to it.
 772 MemNode* SuperWord::find_align_to_ref(Node_List &amp;memops, int &amp;idx) {
 773   GrowableArray&lt;int&gt; cmp_ct(arena(), memops.size(), memops.size(), 0);
 774 
 775   // Count number of comparable memory ops
 776   for (uint i = 0; i &lt; memops.size(); i++) {
 777     MemNode* s1 = memops.at(i)-&gt;as_Mem();
 778     SWPointer p1(s1, this, NULL, false);
<span class="line-modified"> 779     // Only discard unalignable memory references if vector memory references</span>
<span class="line-modified"> 780     // should be aligned on this platform.</span>
<span class="line-added"> 781     if (vectors_should_be_aligned() &amp;&amp; !ref_is_alignable(p1)) {</span>
 782       *cmp_ct.adr_at(i) = 0;
 783       continue;
 784     }
 785     for (uint j = i+1; j &lt; memops.size(); j++) {
 786       MemNode* s2 = memops.at(j)-&gt;as_Mem();
 787       if (isomorphic(s1, s2)) {
 788         SWPointer p2(s2, this, NULL, false);
 789         if (p1.comparable(p2)) {
 790           (*cmp_ct.adr_at(i))++;
 791           (*cmp_ct.adr_at(j))++;
 792         }
 793       }
 794     }
 795   }
 796 
 797   // Find Store (or Load) with the greatest number of &quot;comparable&quot; references,
 798   // biggest vector size, smallest data size and smallest iv offset.
 799   int max_ct        = 0;
 800   int max_vw        = 0;
 801   int max_idx       = -1;
</pre>
<hr />
<pre>
 982 
 983   return vw;
 984 }
 985 
 986 //---------------------------get_iv_adjustment---------------------------
 987 // Calculate loop&#39;s iv adjustment for this memory ops.
 988 int SuperWord::get_iv_adjustment(MemNode* mem_ref) {
 989   SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 990   int offset = align_to_ref_p.offset_in_bytes();
 991   int scale  = align_to_ref_p.scale_in_bytes();
 992   int elt_size = align_to_ref_p.memory_size();
 993   int vw       = get_vw_bytes_special(mem_ref);
 994   assert(vw &gt; 1, &quot;sanity&quot;);
 995   int iv_adjustment;
 996   if (scale != 0) {
 997     int stride_sign = (scale * iv_stride()) &gt; 0 ? 1 : -1;
 998     // At least one iteration is executed in pre-loop by default. As result
 999     // several iterations are needed to align memory operations in main-loop even
1000     // if offset is 0.
1001     int iv_adjustment_in_bytes = (stride_sign * vw - (offset % vw));
<span class="line-modified">1002     // iv_adjustment_in_bytes must be a multiple of elt_size if vector memory</span>
<span class="line-added">1003     // references should be aligned on this platform.</span>
<span class="line-added">1004     assert((ABS(iv_adjustment_in_bytes) % elt_size) == 0 || !vectors_should_be_aligned(),</span>
1005            &quot;(%d) should be divisible by (%d)&quot;, iv_adjustment_in_bytes, elt_size);
1006     iv_adjustment = iv_adjustment_in_bytes/elt_size;
1007   } else {
1008     // This memory op is not dependent on iv (scale == 0)
1009     iv_adjustment = 0;
1010   }
1011 
1012 #ifndef PRODUCT
1013   if (TraceSuperWord) {
1014     tty-&gt;print(&quot;SuperWord::get_iv_adjustment: n = %d, noffset = %d iv_adjust = %d elt_size = %d scale = %d iv_stride = %d vect_size %d: &quot;,
1015       mem_ref-&gt;_idx, offset, iv_adjustment, elt_size, scale, iv_stride(), vw);
1016     mem_ref-&gt;dump();
1017   }
1018 #endif
1019   return iv_adjustment;
1020 }
1021 
1022 //---------------------------dependence_graph---------------------------
1023 // Construct dependency graph.
1024 // Add dependence edges to load/store nodes for memory dependence
</pre>
</td>
</tr>
</table>
<center><a href="stringopts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="superword.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
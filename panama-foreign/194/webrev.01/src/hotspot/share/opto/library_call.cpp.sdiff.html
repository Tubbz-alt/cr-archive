<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/library_call.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="graphKit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopPredicate.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/library_call.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 153 
 154   // Helper functions to inline natives
 155   Node* generate_guard(Node* test, RegionNode* region, float true_prob);
 156   Node* generate_slow_guard(Node* test, RegionNode* region);
 157   Node* generate_fair_guard(Node* test, RegionNode* region);
 158   Node* generate_negative_guard(Node* index, RegionNode* region,
 159                                 // resulting CastII of index:
 160                                 Node* *pos_index = NULL);
 161   Node* generate_limit_guard(Node* offset, Node* subseq_length,
 162                              Node* array_length,
 163                              RegionNode* region);
 164   void  generate_string_range_check(Node* array, Node* offset,
 165                                     Node* length, bool char_count);
 166   Node* generate_current_thread(Node* &amp;tls_output);
 167   Node* load_mirror_from_klass(Node* klass);
 168   Node* load_klass_from_mirror_common(Node* mirror, bool never_see_null,
 169                                       RegionNode* region, int null_path,
 170                                       int offset);
 171   Node* load_klass_from_mirror(Node* mirror, bool never_see_null,
 172                                RegionNode* region, int null_path) {
<span class="line-modified"> 173     int offset = java_lang_Class::klass_offset_in_bytes();</span>
 174     return load_klass_from_mirror_common(mirror, never_see_null,
 175                                          region, null_path,
 176                                          offset);
 177   }
 178   Node* load_array_klass_from_mirror(Node* mirror, bool never_see_null,
 179                                      RegionNode* region, int null_path) {
<span class="line-modified"> 180     int offset = java_lang_Class::array_klass_offset_in_bytes();</span>
 181     return load_klass_from_mirror_common(mirror, never_see_null,
 182                                          region, null_path,
 183                                          offset);
 184   }
 185   Node* generate_access_flags_guard(Node* kls,
 186                                     int modifier_mask, int modifier_bits,
 187                                     RegionNode* region);
 188   Node* generate_interface_guard(Node* kls, RegionNode* region);
 189   Node* generate_hidden_class_guard(Node* kls, RegionNode* region);
 190   Node* generate_array_guard(Node* kls, RegionNode* region) {
 191     return generate_array_guard_common(kls, region, false, false);
 192   }
 193   Node* generate_non_array_guard(Node* kls, RegionNode* region) {
 194     return generate_array_guard_common(kls, region, false, true);
 195   }
 196   Node* generate_objArray_guard(Node* kls, RegionNode* region) {
 197     return generate_array_guard_common(kls, region, true, false);
 198   }
 199   Node* generate_non_objArray_guard(Node* kls, RegionNode* region) {
 200     return generate_array_guard_common(kls, region, true, true);
</pre>
<hr />
<pre>
3370   Node* klasses[2];             // corresponding Klasses: superk, subk
3371   klasses[0] = klasses[1] = top();
3372 
3373   enum {
3374     // A full decision tree on {superc is prim, subc is prim}:
3375     _prim_0_path = 1,           // {P,N} =&gt; false
3376                                 // {P,P} &amp; superc!=subc =&gt; false
3377     _prim_same_path,            // {P,P} &amp; superc==subc =&gt; true
3378     _prim_1_path,               // {N,P} =&gt; false
3379     _ref_subtype_path,          // {N,N} &amp; subtype check wins =&gt; true
3380     _both_ref_path,             // {N,N} &amp; subtype check loses =&gt; false
3381     PATH_LIMIT
3382   };
3383 
3384   RegionNode* region = new RegionNode(PATH_LIMIT);
3385   Node*       phi    = new PhiNode(region, TypeInt::BOOL);
3386   record_for_igvn(region);
3387 
3388   const TypePtr* adr_type = TypeRawPtr::BOTTOM;   // memory type of loads
3389   const TypeKlassPtr* kls_type = TypeKlassPtr::OBJECT_OR_NULL;
<span class="line-modified">3390   int class_klass_offset = java_lang_Class::klass_offset_in_bytes();</span>
3391 
3392   // First null-check both mirrors and load each mirror&#39;s klass metaobject.
3393   int which_arg;
3394   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3395     Node* arg = args[which_arg];
3396     arg = null_check(arg);
3397     if (stopped())  break;
3398     args[which_arg] = arg;
3399 
3400     Node* p = basic_plus_adr(arg, class_klass_offset);
3401     Node* kls = LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, adr_type, kls_type);
3402     klasses[which_arg] = _gvn.transform(kls);
3403   }
3404 
3405   // Having loaded both klasses, test each for null.
3406   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3407   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3408     Node* kls = klasses[which_arg];
3409     Node* null_ctl = top();
3410     kls = null_check_oop(kls, &amp;null_ctl, never_see_null);
</pre>
<hr />
<pre>
5663 
5664   // &#39;src_start&#39; points to src array + scaled offset
5665   Node* src_start = basic_plus_adr(top(), base, offset);
5666 
5667   // Call the stub.
5668   address stubAddr = StubRoutines::updateBytesAdler32();
5669   const char *stubName = &quot;updateBytesAdler32&quot;;
5670 
5671   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesAdler32_Type(),
5672                                  stubAddr, stubName, TypePtr::BOTTOM,
5673                                  crc, src_start, length);
5674 
5675   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5676   set_result(result);
5677   return true;
5678 }
5679 
5680 //----------------------------inline_reference_get----------------------------
5681 // public T java.lang.ref.Reference.get();
5682 bool LibraryCallKit::inline_reference_get() {
<span class="line-modified">5683   const int referent_offset = java_lang_ref_Reference::referent_offset;</span>
<span class="line-removed">5684   guarantee(referent_offset &gt; 0, &quot;should have already been set&quot;);</span>
5685 
5686   // Get the argument:
5687   Node* reference_obj = null_check_receiver();
5688   if (stopped()) return true;
5689 
5690   const TypeInstPtr* tinst = _gvn.type(reference_obj)-&gt;isa_instptr();
5691   assert(tinst != NULL, &quot;obj is null&quot;);
5692   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;obj is not loaded&quot;);
5693   ciInstanceKlass* referenceKlass = tinst-&gt;klass()-&gt;as_instance_klass();
5694   ciField* field = referenceKlass-&gt;get_field_by_name(ciSymbol::make(&quot;referent&quot;),
5695                                                      ciSymbol::make(&quot;Ljava/lang/Object;&quot;),
5696                                                      false);
5697   assert (field != NULL, &quot;undefined field&quot;);
5698 
5699   Node* adr = basic_plus_adr(reference_obj, reference_obj, referent_offset);
5700   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
5701 
5702   ciInstanceKlass* klass = env()-&gt;Object_klass();
5703   const TypeOopPtr* object_type = TypeOopPtr::make_from_klass(klass);
5704 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 153 
 154   // Helper functions to inline natives
 155   Node* generate_guard(Node* test, RegionNode* region, float true_prob);
 156   Node* generate_slow_guard(Node* test, RegionNode* region);
 157   Node* generate_fair_guard(Node* test, RegionNode* region);
 158   Node* generate_negative_guard(Node* index, RegionNode* region,
 159                                 // resulting CastII of index:
 160                                 Node* *pos_index = NULL);
 161   Node* generate_limit_guard(Node* offset, Node* subseq_length,
 162                              Node* array_length,
 163                              RegionNode* region);
 164   void  generate_string_range_check(Node* array, Node* offset,
 165                                     Node* length, bool char_count);
 166   Node* generate_current_thread(Node* &amp;tls_output);
 167   Node* load_mirror_from_klass(Node* klass);
 168   Node* load_klass_from_mirror_common(Node* mirror, bool never_see_null,
 169                                       RegionNode* region, int null_path,
 170                                       int offset);
 171   Node* load_klass_from_mirror(Node* mirror, bool never_see_null,
 172                                RegionNode* region, int null_path) {
<span class="line-modified"> 173     int offset = java_lang_Class::klass_offset();</span>
 174     return load_klass_from_mirror_common(mirror, never_see_null,
 175                                          region, null_path,
 176                                          offset);
 177   }
 178   Node* load_array_klass_from_mirror(Node* mirror, bool never_see_null,
 179                                      RegionNode* region, int null_path) {
<span class="line-modified"> 180     int offset = java_lang_Class::array_klass_offset();</span>
 181     return load_klass_from_mirror_common(mirror, never_see_null,
 182                                          region, null_path,
 183                                          offset);
 184   }
 185   Node* generate_access_flags_guard(Node* kls,
 186                                     int modifier_mask, int modifier_bits,
 187                                     RegionNode* region);
 188   Node* generate_interface_guard(Node* kls, RegionNode* region);
 189   Node* generate_hidden_class_guard(Node* kls, RegionNode* region);
 190   Node* generate_array_guard(Node* kls, RegionNode* region) {
 191     return generate_array_guard_common(kls, region, false, false);
 192   }
 193   Node* generate_non_array_guard(Node* kls, RegionNode* region) {
 194     return generate_array_guard_common(kls, region, false, true);
 195   }
 196   Node* generate_objArray_guard(Node* kls, RegionNode* region) {
 197     return generate_array_guard_common(kls, region, true, false);
 198   }
 199   Node* generate_non_objArray_guard(Node* kls, RegionNode* region) {
 200     return generate_array_guard_common(kls, region, true, true);
</pre>
<hr />
<pre>
3370   Node* klasses[2];             // corresponding Klasses: superk, subk
3371   klasses[0] = klasses[1] = top();
3372 
3373   enum {
3374     // A full decision tree on {superc is prim, subc is prim}:
3375     _prim_0_path = 1,           // {P,N} =&gt; false
3376                                 // {P,P} &amp; superc!=subc =&gt; false
3377     _prim_same_path,            // {P,P} &amp; superc==subc =&gt; true
3378     _prim_1_path,               // {N,P} =&gt; false
3379     _ref_subtype_path,          // {N,N} &amp; subtype check wins =&gt; true
3380     _both_ref_path,             // {N,N} &amp; subtype check loses =&gt; false
3381     PATH_LIMIT
3382   };
3383 
3384   RegionNode* region = new RegionNode(PATH_LIMIT);
3385   Node*       phi    = new PhiNode(region, TypeInt::BOOL);
3386   record_for_igvn(region);
3387 
3388   const TypePtr* adr_type = TypeRawPtr::BOTTOM;   // memory type of loads
3389   const TypeKlassPtr* kls_type = TypeKlassPtr::OBJECT_OR_NULL;
<span class="line-modified">3390   int class_klass_offset = java_lang_Class::klass_offset();</span>
3391 
3392   // First null-check both mirrors and load each mirror&#39;s klass metaobject.
3393   int which_arg;
3394   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3395     Node* arg = args[which_arg];
3396     arg = null_check(arg);
3397     if (stopped())  break;
3398     args[which_arg] = arg;
3399 
3400     Node* p = basic_plus_adr(arg, class_klass_offset);
3401     Node* kls = LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, adr_type, kls_type);
3402     klasses[which_arg] = _gvn.transform(kls);
3403   }
3404 
3405   // Having loaded both klasses, test each for null.
3406   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3407   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3408     Node* kls = klasses[which_arg];
3409     Node* null_ctl = top();
3410     kls = null_check_oop(kls, &amp;null_ctl, never_see_null);
</pre>
<hr />
<pre>
5663 
5664   // &#39;src_start&#39; points to src array + scaled offset
5665   Node* src_start = basic_plus_adr(top(), base, offset);
5666 
5667   // Call the stub.
5668   address stubAddr = StubRoutines::updateBytesAdler32();
5669   const char *stubName = &quot;updateBytesAdler32&quot;;
5670 
5671   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesAdler32_Type(),
5672                                  stubAddr, stubName, TypePtr::BOTTOM,
5673                                  crc, src_start, length);
5674 
5675   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5676   set_result(result);
5677   return true;
5678 }
5679 
5680 //----------------------------inline_reference_get----------------------------
5681 // public T java.lang.ref.Reference.get();
5682 bool LibraryCallKit::inline_reference_get() {
<span class="line-modified">5683   const int referent_offset = java_lang_ref_Reference::referent_offset();</span>

5684 
5685   // Get the argument:
5686   Node* reference_obj = null_check_receiver();
5687   if (stopped()) return true;
5688 
5689   const TypeInstPtr* tinst = _gvn.type(reference_obj)-&gt;isa_instptr();
5690   assert(tinst != NULL, &quot;obj is null&quot;);
5691   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;obj is not loaded&quot;);
5692   ciInstanceKlass* referenceKlass = tinst-&gt;klass()-&gt;as_instance_klass();
5693   ciField* field = referenceKlass-&gt;get_field_by_name(ciSymbol::make(&quot;referent&quot;),
5694                                                      ciSymbol::make(&quot;Ljava/lang/Object;&quot;),
5695                                                      false);
5696   assert (field != NULL, &quot;undefined field&quot;);
5697 
5698   Node* adr = basic_plus_adr(reference_obj, reference_obj, referent_offset);
5699   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
5700 
5701   ciInstanceKlass* klass = env()-&gt;Object_klass();
5702   const TypeOopPtr* object_type = TypeOopPtr::make_from_klass(klass);
5703 
</pre>
</td>
</tr>
</table>
<center><a href="graphKit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopPredicate.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
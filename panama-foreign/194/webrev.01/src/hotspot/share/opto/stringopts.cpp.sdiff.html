<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/stringopts.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="superword.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/stringopts.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
1649     byte_array = kit.new_array(__ makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_BYTE))),
1650                                length, 1);
1651   }
1652 
1653   // Mark the allocation so that zeroing is skipped since the code
1654   // below will overwrite the entire array
1655   AllocateArrayNode* byte_alloc = AllocateArrayNode::Ideal_array_allocation(byte_array, _gvn);
1656   byte_alloc-&gt;maybe_set_complete(_gvn);
1657 
1658   if (ideal != NULL) {
1659     // Sync IdealKit and graphKit.
1660     ideal-&gt;sync_kit(&amp;kit);
1661   }
1662   return byte_array;
1663 }
1664 
1665 jbyte PhaseStringOpts::get_constant_coder(GraphKit&amp; kit, Node* str) {
1666   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1667   const TypeOopPtr* str_type = kit.gvn().type(str)-&gt;isa_oopptr();
1668   ciInstance* str_instance = str_type-&gt;const_oop()-&gt;as_instance();
<span class="line-modified">1669   jbyte coder = str_instance-&gt;field_value_by_offset(java_lang_String::coder_offset_in_bytes()).as_byte();</span>
1670   assert(CompactStrings || (coder == java_lang_String::CODER_UTF16), &quot;Strings must be UTF16 encoded&quot;);
1671   return coder;
1672 }
1673 
1674 int PhaseStringOpts::get_constant_length(GraphKit&amp; kit, Node* str) {
1675   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1676   return get_constant_value(kit, str)-&gt;length();
1677 }
1678 
1679 ciTypeArray* PhaseStringOpts::get_constant_value(GraphKit&amp; kit, Node* str) {
1680   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1681   const TypeOopPtr* str_type = kit.gvn().type(str)-&gt;isa_oopptr();
1682   ciInstance* str_instance = str_type-&gt;const_oop()-&gt;as_instance();
<span class="line-modified">1683   ciObject* src_array = str_instance-&gt;field_value_by_offset(java_lang_String::value_offset_in_bytes()).as_object();</span>
1684   return src_array-&gt;as_type_array();
1685 }
1686 
1687 void PhaseStringOpts::replace_string_concat(StringConcat* sc) {
1688   // Log a little info about the transformation
1689   sc-&gt;maybe_log_transform();
1690 
1691   // pull the JVMState of the allocation into a SafePointNode to serve as
1692   // as a shim for the insertion of the new code.
1693   JVMState* jvms     = sc-&gt;begin()-&gt;jvms()-&gt;clone_shallow(C);
1694   uint size = sc-&gt;begin()-&gt;req();
1695   SafePointNode* map = new SafePointNode(size, jvms);
1696 
1697   // copy the control and memory state from the final call into our
1698   // new starting state.  This allows any preceeding tests to feed
1699   // into the new section of code.
1700   for (uint i1 = 0; i1 &lt; TypeFunc::Parms; i1++) {
1701     map-&gt;init_req(i1, sc-&gt;end()-&gt;in(i1));
1702   }
1703   // blow away old allocation arguments
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
1649     byte_array = kit.new_array(__ makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_BYTE))),
1650                                length, 1);
1651   }
1652 
1653   // Mark the allocation so that zeroing is skipped since the code
1654   // below will overwrite the entire array
1655   AllocateArrayNode* byte_alloc = AllocateArrayNode::Ideal_array_allocation(byte_array, _gvn);
1656   byte_alloc-&gt;maybe_set_complete(_gvn);
1657 
1658   if (ideal != NULL) {
1659     // Sync IdealKit and graphKit.
1660     ideal-&gt;sync_kit(&amp;kit);
1661   }
1662   return byte_array;
1663 }
1664 
1665 jbyte PhaseStringOpts::get_constant_coder(GraphKit&amp; kit, Node* str) {
1666   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1667   const TypeOopPtr* str_type = kit.gvn().type(str)-&gt;isa_oopptr();
1668   ciInstance* str_instance = str_type-&gt;const_oop()-&gt;as_instance();
<span class="line-modified">1669   jbyte coder = str_instance-&gt;field_value_by_offset(java_lang_String::coder_offset()).as_byte();</span>
1670   assert(CompactStrings || (coder == java_lang_String::CODER_UTF16), &quot;Strings must be UTF16 encoded&quot;);
1671   return coder;
1672 }
1673 
1674 int PhaseStringOpts::get_constant_length(GraphKit&amp; kit, Node* str) {
1675   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1676   return get_constant_value(kit, str)-&gt;length();
1677 }
1678 
1679 ciTypeArray* PhaseStringOpts::get_constant_value(GraphKit&amp; kit, Node* str) {
1680   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1681   const TypeOopPtr* str_type = kit.gvn().type(str)-&gt;isa_oopptr();
1682   ciInstance* str_instance = str_type-&gt;const_oop()-&gt;as_instance();
<span class="line-modified">1683   ciObject* src_array = str_instance-&gt;field_value_by_offset(java_lang_String::value_offset()).as_object();</span>
1684   return src_array-&gt;as_type_array();
1685 }
1686 
1687 void PhaseStringOpts::replace_string_concat(StringConcat* sc) {
1688   // Log a little info about the transformation
1689   sc-&gt;maybe_log_transform();
1690 
1691   // pull the JVMState of the allocation into a SafePointNode to serve as
1692   // as a shim for the insertion of the new code.
1693   JVMState* jvms     = sc-&gt;begin()-&gt;jvms()-&gt;clone_shallow(C);
1694   uint size = sc-&gt;begin()-&gt;req();
1695   SafePointNode* map = new SafePointNode(size, jvms);
1696 
1697   // copy the control and memory state from the final call into our
1698   // new starting state.  This allows any preceeding tests to feed
1699   // into the new section of code.
1700   for (uint i1 = 0; i1 &lt; TypeFunc::Parms; i1++) {
1701     map-&gt;init_req(i1, sc-&gt;end()-&gt;in(i1));
1702   }
1703   // blow away old allocation arguments
</pre>
</td>
</tr>
</table>
<center><a href="memnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="superword.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
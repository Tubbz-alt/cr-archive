<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopPredicate.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="library_call.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopPredicate.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 105 // The continuation projection (if_cont) of the new_iff is returned which
 106 // is by default a true projection if &#39;if_cont_is_true_proj&#39; is true.
 107 // Otherwise, the continuation projection is set up to be the false
 108 // projection. This code is also used to clone predicates to cloned loops.
 109 ProjNode* PhaseIdealLoop::create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,
 110                                                       Deoptimization::DeoptReason reason,
 111                                                       int opcode, bool if_cont_is_true_proj) {
 112   assert(cont_proj-&gt;is_uncommon_trap_if_pattern(reason), &quot;must be a uct if pattern!&quot;);
 113   IfNode* iff = cont_proj-&gt;in(0)-&gt;as_If();
 114 
 115   ProjNode *uncommon_proj = iff-&gt;proj_out(1 - cont_proj-&gt;_con);
 116   Node     *rgn   = uncommon_proj-&gt;unique_ctrl_out();
 117   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 118 
 119   uint proj_index = 1; // region&#39;s edge corresponding to uncommon_proj
 120   if (!rgn-&gt;is_Region()) { // create a region to guard the call
 121     assert(rgn-&gt;is_Call(), &quot;must be call uct&quot;);
 122     CallNode* call = rgn-&gt;as_Call();
 123     IdealLoopTree* loop = get_loop(call);
 124     rgn = new RegionNode(1);



 125     rgn-&gt;add_req(uncommon_proj);
 126     register_control(rgn, loop, uncommon_proj);
 127     _igvn.replace_input_of(call, 0, rgn);
 128     // When called from beautify_loops() idom is not constructed yet.
 129     if (_idom != NULL) {
 130       set_idom(call, rgn, dom_depth(rgn));
 131     }
<span class="line-modified"> 132     for (DUIterator_Fast imax, i = uncommon_proj-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified"> 133       Node* n = uncommon_proj-&gt;fast_out(i);</span>
<span class="line-modified"> 134       if (n-&gt;is_Load() || n-&gt;is_Store()) {</span>
<span class="line-removed"> 135         _igvn.replace_input_of(n, 0, rgn);</span>
<span class="line-removed"> 136         --i; --imax;</span>
<span class="line-removed"> 137       }</span>
<span class="line-removed"> 138     }</span>
 139   } else {
 140     // Find region&#39;s edge corresponding to uncommon_proj
 141     for (; proj_index &lt; rgn-&gt;req(); proj_index++)
 142       if (rgn-&gt;in(proj_index) == uncommon_proj) break;
 143     assert(proj_index &lt; rgn-&gt;req(), &quot;sanity&quot;);
 144   }
 145 
 146   Node* entry = iff-&gt;in(0);
 147   if (new_entry != NULL) {
 148     // Clonning the predicate to new location.
 149     entry = new_entry;
 150   }
 151   // Create new_iff
 152   IdealLoopTree* lp = get_loop(entry);
 153   IfNode* new_iff = NULL;
 154   if (opcode == Op_If) {
 155     new_iff = new IfNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 156   } else {
 157     assert(opcode == Op_RangeCheck, &quot;no other if variant here&quot;);
 158     new_iff = new RangeCheckNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
</pre>
</td>
<td>
<hr />
<pre>
 105 // The continuation projection (if_cont) of the new_iff is returned which
 106 // is by default a true projection if &#39;if_cont_is_true_proj&#39; is true.
 107 // Otherwise, the continuation projection is set up to be the false
 108 // projection. This code is also used to clone predicates to cloned loops.
 109 ProjNode* PhaseIdealLoop::create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,
 110                                                       Deoptimization::DeoptReason reason,
 111                                                       int opcode, bool if_cont_is_true_proj) {
 112   assert(cont_proj-&gt;is_uncommon_trap_if_pattern(reason), &quot;must be a uct if pattern!&quot;);
 113   IfNode* iff = cont_proj-&gt;in(0)-&gt;as_If();
 114 
 115   ProjNode *uncommon_proj = iff-&gt;proj_out(1 - cont_proj-&gt;_con);
 116   Node     *rgn   = uncommon_proj-&gt;unique_ctrl_out();
 117   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 118 
 119   uint proj_index = 1; // region&#39;s edge corresponding to uncommon_proj
 120   if (!rgn-&gt;is_Region()) { // create a region to guard the call
 121     assert(rgn-&gt;is_Call(), &quot;must be call uct&quot;);
 122     CallNode* call = rgn-&gt;as_Call();
 123     IdealLoopTree* loop = get_loop(call);
 124     rgn = new RegionNode(1);
<span class="line-added"> 125     Node* uncommon_proj_orig = uncommon_proj;</span>
<span class="line-added"> 126     uncommon_proj = uncommon_proj-&gt;clone()-&gt;as_Proj();</span>
<span class="line-added"> 127     register_control(uncommon_proj, loop, iff);</span>
 128     rgn-&gt;add_req(uncommon_proj);
 129     register_control(rgn, loop, uncommon_proj);
 130     _igvn.replace_input_of(call, 0, rgn);
 131     // When called from beautify_loops() idom is not constructed yet.
 132     if (_idom != NULL) {
 133       set_idom(call, rgn, dom_depth(rgn));
 134     }
<span class="line-modified"> 135     // Move nodes pinned on the projection or whose control is set to</span>
<span class="line-modified"> 136     // the projection to the region.</span>
<span class="line-modified"> 137     lazy_replace(uncommon_proj_orig, rgn);</span>




 138   } else {
 139     // Find region&#39;s edge corresponding to uncommon_proj
 140     for (; proj_index &lt; rgn-&gt;req(); proj_index++)
 141       if (rgn-&gt;in(proj_index) == uncommon_proj) break;
 142     assert(proj_index &lt; rgn-&gt;req(), &quot;sanity&quot;);
 143   }
 144 
 145   Node* entry = iff-&gt;in(0);
 146   if (new_entry != NULL) {
 147     // Clonning the predicate to new location.
 148     entry = new_entry;
 149   }
 150   // Create new_iff
 151   IdealLoopTree* lp = get_loop(entry);
 152   IfNode* new_iff = NULL;
 153   if (opcode == Op_If) {
 154     new_iff = new IfNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 155   } else {
 156     assert(opcode == Op_RangeCheck, &quot;no other if variant here&quot;);
 157     new_iff = new RangeCheckNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
</pre>
</td>
</tr>
</table>
<center><a href="library_call.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIR.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 219     case lir_shl:
 220     case lir_shr:
 221       assert(in_opr1() == result_opr() || threeOperandForm, &quot;opr1 and result must match&quot;);
 222       assert(in_opr1()-&gt;is_valid() &amp;&amp; in_opr2()-&gt;is_valid(), &quot;must be valid&quot;);
 223       break;
 224 
 225     // special handling for lir_ushr because of write barriers
 226     case lir_ushr:
 227       assert(in_opr1() == result_opr() || in_opr2()-&gt;is_constant() || threeOperandForm, &quot;opr1 and result must match or shift count is constant&quot;);
 228       assert(in_opr1()-&gt;is_valid() &amp;&amp; in_opr2()-&gt;is_valid(), &quot;must be valid&quot;);
 229       break;
 230 
 231     default:
 232       break;
 233     }
 234   }
 235 #endif
 236 }
 237 
 238 
<span class="line-modified"> 239 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, BlockBegin* block)</span>
 240   : LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 241   , _cond(cond)
<span class="line-removed"> 242   , _type(type)</span>
 243   , _label(block-&gt;label())
 244   , _block(block)
 245   , _ublock(NULL)
 246   , _stub(NULL) {
 247 }
 248 
<span class="line-modified"> 249 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, CodeStub* stub) :</span>
 250   LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 251   , _cond(cond)
<span class="line-removed"> 252   , _type(type)</span>
 253   , _label(stub-&gt;entry())
 254   , _block(NULL)
 255   , _ublock(NULL)
 256   , _stub(stub) {
 257 }
 258 
<span class="line-modified"> 259 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, BlockBegin* block, BlockBegin* ublock)</span>
 260   : LIR_Op(lir_cond_float_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 261   , _cond(cond)
<span class="line-removed"> 262   , _type(type)</span>
 263   , _label(block-&gt;label())
 264   , _block(block)
 265   , _ublock(ublock)
 266   , _stub(NULL)
 267 {
 268 }
 269 
 270 void LIR_OpBranch::change_block(BlockBegin* b) {
 271   assert(_block != NULL, &quot;must have old block&quot;);
 272   assert(_block-&gt;label() == label(), &quot;must be equal&quot;);
 273 
 274   _block = b;
 275   _label = b-&gt;label();
 276 }
 277 
 278 void LIR_OpBranch::change_ublock(BlockBegin* b) {
 279   assert(_ublock != NULL, &quot;must have old block&quot;);
 280   _ublock = b;
 281 }
 282 
</pre>
<hr />
<pre>
1386   append(c);
1387 }
1388 
1389 
1390 void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
1391                            CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci) {
1392   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, info_for_exception);
1393   if (profiled_method != NULL) {
1394     c-&gt;set_profiled_method(profiled_method);
1395     c-&gt;set_profiled_bci(profiled_bci);
1396     c-&gt;set_should_profile(true);
1397   }
1398   append(c);
1399 }
1400 
1401 void LIR_List::null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null) {
1402   if (deoptimize_on_null) {
1403     // Emit an explicit null check and deoptimize if opr is null
1404     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_null_check, Deoptimization::Action_none);
1405     cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));
<span class="line-modified">1406     branch(lir_cond_equal, T_OBJECT, deopt);</span>
1407   } else {
1408     // Emit an implicit null check
1409     append(new LIR_Op1(lir_null_check, opr, info));
1410   }
1411 }
1412 
1413 void LIR_List::cas_long(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1414                         LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1415   append(new LIR_OpCompareAndSwap(lir_cas_long, addr, cmp_value, new_value, t1, t2, result));
1416 }
1417 
1418 void LIR_List::cas_obj(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1419                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1420   append(new LIR_OpCompareAndSwap(lir_cas_obj, addr, cmp_value, new_value, t1, t2, result));
1421 }
1422 
1423 void LIR_List::cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1424                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1425   append(new LIR_OpCompareAndSwap(lir_cas_int, addr, cmp_value, new_value, t1, t2, result));
1426 }
</pre>
</td>
<td>
<hr />
<pre>
 219     case lir_shl:
 220     case lir_shr:
 221       assert(in_opr1() == result_opr() || threeOperandForm, &quot;opr1 and result must match&quot;);
 222       assert(in_opr1()-&gt;is_valid() &amp;&amp; in_opr2()-&gt;is_valid(), &quot;must be valid&quot;);
 223       break;
 224 
 225     // special handling for lir_ushr because of write barriers
 226     case lir_ushr:
 227       assert(in_opr1() == result_opr() || in_opr2()-&gt;is_constant() || threeOperandForm, &quot;opr1 and result must match or shift count is constant&quot;);
 228       assert(in_opr1()-&gt;is_valid() &amp;&amp; in_opr2()-&gt;is_valid(), &quot;must be valid&quot;);
 229       break;
 230 
 231     default:
 232       break;
 233     }
 234   }
 235 #endif
 236 }
 237 
 238 
<span class="line-modified"> 239 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BlockBegin* block)</span>
 240   : LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 241   , _cond(cond)

 242   , _label(block-&gt;label())
 243   , _block(block)
 244   , _ublock(NULL)
 245   , _stub(NULL) {
 246 }
 247 
<span class="line-modified"> 248 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, CodeStub* stub) :</span>
 249   LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 250   , _cond(cond)

 251   , _label(stub-&gt;entry())
 252   , _block(NULL)
 253   , _ublock(NULL)
 254   , _stub(stub) {
 255 }
 256 
<span class="line-modified"> 257 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BlockBegin* block, BlockBegin* ublock)</span>
 258   : LIR_Op(lir_cond_float_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 259   , _cond(cond)

 260   , _label(block-&gt;label())
 261   , _block(block)
 262   , _ublock(ublock)
 263   , _stub(NULL)
 264 {
 265 }
 266 
 267 void LIR_OpBranch::change_block(BlockBegin* b) {
 268   assert(_block != NULL, &quot;must have old block&quot;);
 269   assert(_block-&gt;label() == label(), &quot;must be equal&quot;);
 270 
 271   _block = b;
 272   _label = b-&gt;label();
 273 }
 274 
 275 void LIR_OpBranch::change_ublock(BlockBegin* b) {
 276   assert(_ublock != NULL, &quot;must have old block&quot;);
 277   _ublock = b;
 278 }
 279 
</pre>
<hr />
<pre>
1383   append(c);
1384 }
1385 
1386 
1387 void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
1388                            CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci) {
1389   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, info_for_exception);
1390   if (profiled_method != NULL) {
1391     c-&gt;set_profiled_method(profiled_method);
1392     c-&gt;set_profiled_bci(profiled_bci);
1393     c-&gt;set_should_profile(true);
1394   }
1395   append(c);
1396 }
1397 
1398 void LIR_List::null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null) {
1399   if (deoptimize_on_null) {
1400     // Emit an explicit null check and deoptimize if opr is null
1401     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_null_check, Deoptimization::Action_none);
1402     cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));
<span class="line-modified">1403     branch(lir_cond_equal, deopt);</span>
1404   } else {
1405     // Emit an implicit null check
1406     append(new LIR_Op1(lir_null_check, opr, info));
1407   }
1408 }
1409 
1410 void LIR_List::cas_long(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1411                         LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1412   append(new LIR_OpCompareAndSwap(lir_cas_long, addr, cmp_value, new_value, t1, t2, result));
1413 }
1414 
1415 void LIR_List::cas_obj(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1416                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1417   append(new LIR_OpCompareAndSwap(lir_cas_obj, addr, cmp_value, new_value, t1, t2, result));
1418 }
1419 
1420 void LIR_List::cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1421                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1422   append(new LIR_OpCompareAndSwap(lir_cas_int, addr, cmp_value, new_value, t1, t2, result));
1423 }
</pre>
</td>
</tr>
</table>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
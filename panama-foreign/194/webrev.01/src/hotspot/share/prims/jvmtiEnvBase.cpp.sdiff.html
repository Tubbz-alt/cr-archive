<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiEnvBase.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiClassFileReconstituter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRedefineClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiEnvBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 636 
 637         // see if owner of the monitor is our object
 638         if (mi-&gt;owner() != NULL &amp;&amp; mi-&gt;owner() == hobj()) {
 639           ret++;
 640         }
 641       }
 642     }
 643   }
 644   return ret;
 645 }
 646 
 647 
 648 
 649 jvmtiError
 650 JvmtiEnvBase::get_current_contended_monitor(JavaThread *java_thread, jobject *monitor_ptr) {
 651   JavaThread *current_jt = JavaThread::current();
 652   assert(current_jt == java_thread ||
 653          current_jt == java_thread-&gt;active_handshaker(),
 654          &quot;call by myself or at direct handshake&quot;);
 655   oop obj = NULL;



 656   ObjectMonitor *mon = java_thread-&gt;current_waiting_monitor();
 657   if (mon == NULL) {
 658     // thread is not doing an Object.wait() call
 659     mon = java_thread-&gt;current_pending_monitor();
 660     if (mon != NULL) {
 661       // The thread is trying to enter() an ObjectMonitor.
 662       obj = (oop)mon-&gt;object();
 663       assert(obj != NULL, &quot;ObjectMonitor should have a valid object!&quot;);
 664     }
 665     // implied else: no contended ObjectMonitor
 666   } else {
 667     // thread is doing an Object.wait() call
 668     obj = (oop)mon-&gt;object();
 669     assert(obj != NULL, &quot;Object.wait() should have an object&quot;);
 670   }
 671 
 672   if (obj == NULL) {
 673     *monitor_ptr = NULL;
 674   } else {
 675     HandleMark hm;
</pre>
<hr />
<pre>
 713   err = jmc.error();
 714 
 715   return err;
 716 }
 717 
 718 // Save JNI local handles for any objects that this frame owns.
 719 jvmtiError
 720 JvmtiEnvBase::get_locked_objects_in_frame(JavaThread* calling_thread, JavaThread* java_thread,
 721                                  javaVFrame *jvf, GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt;* owned_monitors_list, jint stack_depth) {
 722   jvmtiError err = JVMTI_ERROR_NONE;
 723   ResourceMark rm;
 724 
 725   GrowableArray&lt;MonitorInfo*&gt;* mons = jvf-&gt;monitors();
 726   if (mons-&gt;is_empty()) {
 727     return err;  // this javaVFrame holds no monitors
 728   }
 729 
 730   HandleMark hm;
 731   oop wait_obj = NULL;
 732   {
<span class="line-modified"> 733     // save object of current wait() call (if any) for later comparison</span>



 734     ObjectMonitor *mon = java_thread-&gt;current_waiting_monitor();
 735     if (mon != NULL) {
 736       wait_obj = (oop)mon-&gt;object();
 737     }
 738   }
 739   oop pending_obj = NULL;
 740   {
<span class="line-modified"> 741     // save object of current enter() call (if any) for later comparison</span>



 742     ObjectMonitor *mon = java_thread-&gt;current_pending_monitor();
 743     if (mon != NULL) {
 744       pending_obj = (oop)mon-&gt;object();
 745     }
 746   }
 747 
 748   for (int i = 0; i &lt; mons-&gt;length(); i++) {
 749     MonitorInfo *mi = mons-&gt;at(i);
 750 
 751     if (mi-&gt;owner_is_scalar_replaced()) continue;
 752 
 753     oop obj = mi-&gt;owner();
 754     if (obj == NULL) {
 755       // this monitor doesn&#39;t have an owning object so skip it
 756       continue;
 757     }
 758 
 759     if (wait_obj == obj) {
 760       // the thread is waiting on this monitor so it isn&#39;t really owned
 761       continue;
</pre>
</td>
<td>
<hr />
<pre>
 636 
 637         // see if owner of the monitor is our object
 638         if (mi-&gt;owner() != NULL &amp;&amp; mi-&gt;owner() == hobj()) {
 639           ret++;
 640         }
 641       }
 642     }
 643   }
 644   return ret;
 645 }
 646 
 647 
 648 
 649 jvmtiError
 650 JvmtiEnvBase::get_current_contended_monitor(JavaThread *java_thread, jobject *monitor_ptr) {
 651   JavaThread *current_jt = JavaThread::current();
 652   assert(current_jt == java_thread ||
 653          current_jt == java_thread-&gt;active_handshaker(),
 654          &quot;call by myself or at direct handshake&quot;);
 655   oop obj = NULL;
<span class="line-added"> 656   // The ObjectMonitor* can&#39;t be async deflated since we are either</span>
<span class="line-added"> 657   // at a safepoint or the calling thread is operating on itself so</span>
<span class="line-added"> 658   // it cannot leave the underlying wait()/enter() call.</span>
 659   ObjectMonitor *mon = java_thread-&gt;current_waiting_monitor();
 660   if (mon == NULL) {
 661     // thread is not doing an Object.wait() call
 662     mon = java_thread-&gt;current_pending_monitor();
 663     if (mon != NULL) {
 664       // The thread is trying to enter() an ObjectMonitor.
 665       obj = (oop)mon-&gt;object();
 666       assert(obj != NULL, &quot;ObjectMonitor should have a valid object!&quot;);
 667     }
 668     // implied else: no contended ObjectMonitor
 669   } else {
 670     // thread is doing an Object.wait() call
 671     obj = (oop)mon-&gt;object();
 672     assert(obj != NULL, &quot;Object.wait() should have an object&quot;);
 673   }
 674 
 675   if (obj == NULL) {
 676     *monitor_ptr = NULL;
 677   } else {
 678     HandleMark hm;
</pre>
<hr />
<pre>
 716   err = jmc.error();
 717 
 718   return err;
 719 }
 720 
 721 // Save JNI local handles for any objects that this frame owns.
 722 jvmtiError
 723 JvmtiEnvBase::get_locked_objects_in_frame(JavaThread* calling_thread, JavaThread* java_thread,
 724                                  javaVFrame *jvf, GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt;* owned_monitors_list, jint stack_depth) {
 725   jvmtiError err = JVMTI_ERROR_NONE;
 726   ResourceMark rm;
 727 
 728   GrowableArray&lt;MonitorInfo*&gt;* mons = jvf-&gt;monitors();
 729   if (mons-&gt;is_empty()) {
 730     return err;  // this javaVFrame holds no monitors
 731   }
 732 
 733   HandleMark hm;
 734   oop wait_obj = NULL;
 735   {
<span class="line-modified"> 736     // The ObjectMonitor* can&#39;t be async deflated since we are either</span>
<span class="line-added"> 737     // at a safepoint or the calling thread is operating on itself so</span>
<span class="line-added"> 738     // it cannot leave the underlying wait() call.</span>
<span class="line-added"> 739     // Save object of current wait() call (if any) for later comparison.</span>
 740     ObjectMonitor *mon = java_thread-&gt;current_waiting_monitor();
 741     if (mon != NULL) {
 742       wait_obj = (oop)mon-&gt;object();
 743     }
 744   }
 745   oop pending_obj = NULL;
 746   {
<span class="line-modified"> 747     // The ObjectMonitor* can&#39;t be async deflated since we are either</span>
<span class="line-added"> 748     // at a safepoint or the calling thread is operating on itself so</span>
<span class="line-added"> 749     // it cannot leave the underlying enter() call.</span>
<span class="line-added"> 750     // Save object of current enter() call (if any) for later comparison.</span>
 751     ObjectMonitor *mon = java_thread-&gt;current_pending_monitor();
 752     if (mon != NULL) {
 753       pending_obj = (oop)mon-&gt;object();
 754     }
 755   }
 756 
 757   for (int i = 0; i &lt; mons-&gt;length(); i++) {
 758     MonitorInfo *mi = mons-&gt;at(i);
 759 
 760     if (mi-&gt;owner_is_scalar_replaced()) continue;
 761 
 762     oop obj = mi-&gt;owner();
 763     if (obj == NULL) {
 764       // this monitor doesn&#39;t have an owning object so skip it
 765       continue;
 766     }
 767 
 768     if (wait_obj == obj) {
 769       // the thread is waiting on this monitor so it isn&#39;t really owned
 770       continue;
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiClassFileReconstituter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRedefineClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
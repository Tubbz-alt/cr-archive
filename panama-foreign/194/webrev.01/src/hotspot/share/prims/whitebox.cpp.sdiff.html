<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/whitebox.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiRedefineClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/whitebox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  60 #include &quot;prims/resolvedMethodTable.hpp&quot;
  61 #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
  62 #include &quot;prims/whitebox.inline.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/atomic.hpp&quot;
  65 #include &quot;runtime/deoptimization.hpp&quot;
  66 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  67 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  68 #include &quot;runtime/frame.inline.hpp&quot;
  69 #include &quot;runtime/handles.inline.hpp&quot;
  70 #include &quot;runtime/handshake.hpp&quot;
  71 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  72 #include &quot;runtime/javaCalls.hpp&quot;
  73 #include &quot;runtime/jniHandles.inline.hpp&quot;
  74 #include &quot;runtime/os.hpp&quot;
  75 #include &quot;runtime/sweeper.hpp&quot;

  76 #include &quot;runtime/thread.hpp&quot;
  77 #include &quot;runtime/threadSMR.hpp&quot;
  78 #include &quot;runtime/vm_version.hpp&quot;
  79 #include &quot;services/memoryService.hpp&quot;
  80 #include &quot;utilities/align.hpp&quot;
  81 #include &quot;utilities/debug.hpp&quot;
  82 #include &quot;utilities/elfFile.hpp&quot;
  83 #include &quot;utilities/exceptions.hpp&quot;
  84 #include &quot;utilities/macros.hpp&quot;
  85 #if INCLUDE_CDS
  86 #include &quot;prims/cdsoffsets.hpp&quot;
  87 #endif // INCLUDE_CDS
  88 #if INCLUDE_G1GC
  89 #include &quot;gc/g1/g1Arguments.hpp&quot;
  90 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  91 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  92 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  93 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  94 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  95 #endif // INCLUDE_G1GC
</pre>
<hr />
<pre>
 460 
 461 WB_ENTRY(jlong, WB_G1NumFreeRegions(JNIEnv* env, jobject o))
 462   if (UseG1GC) {
 463     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 464     size_t nr = g1h-&gt;num_free_regions();
 465     return (jlong)nr;
 466   }
 467   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumFreeRegions: G1 GC is not enabled&quot;);
 468 WB_END
 469 
 470 WB_ENTRY(jboolean, WB_G1InConcurrentMark(JNIEnv* env, jobject o))
 471   if (UseG1GC) {
 472     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 473     return g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
 474   }
 475   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1InConcurrentMark: G1 GC is not enabled&quot;);
 476 WB_END
 477 
 478 WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))
 479   if (UseG1GC) {






 480     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 481     if (!g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle()) {
 482       g1h-&gt;collect(GCCause::_wb_conc_mark);
 483       return true;
 484     }
 485     return false;
 486   }
 487   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1StartMarkCycle: G1 GC is not enabled&quot;);
 488 WB_END
 489 
 490 WB_ENTRY(jint, WB_G1RegionSize(JNIEnv* env, jobject o))
 491   if (UseG1GC) {
 492     return (jint)HeapRegion::GrainBytes;
 493   }
 494   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1RegionSize: G1 GC is not enabled&quot;);
 495 WB_END
 496 
 497 #endif // INCLUDE_G1GC
 498 
 499 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
</pre>
<hr />
<pre>
1431 
1432 WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
1433   MonitorLocker mo(Compilation_lock, Mutex::_no_safepoint_check_flag);
1434   WhiteBox::compilation_locked = false;
1435   mo.notify_all();
1436 WB_END
1437 
1438 WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
1439   // Force a code cache sweep and block until it finished
1440   NMethodSweeper::force_sweep();
1441 WB_END
1442 
1443 WB_ENTRY(jboolean, WB_IsInStringTable(JNIEnv* env, jobject o, jstring javaString))
1444   ResourceMark rm(THREAD);
1445   int len;
1446   jchar* name = java_lang_String::as_unicode_string(JNIHandles::resolve(javaString), len, CHECK_false);
1447   return (StringTable::lookup(name, len) != NULL);
1448 WB_END
1449 
1450 WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))






1451   Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1452   Universe::heap()-&gt;collect(GCCause::_wb_full_gc);
1453 #if INCLUDE_G1GC
1454   if (UseG1GC) {
1455     // Needs to be cleared explicitly for G1
1456     Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1457   }
1458 #endif // INCLUDE_G1GC
1459 WB_END
1460 
1461 WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))
1462   Universe::heap()-&gt;collect(GCCause::_wb_young_gc);
1463 WB_END
1464 
1465 WB_ENTRY(void, WB_ReadReservedMemory(JNIEnv* env, jobject o))
1466   // static+volatile in order to force the read to happen
1467   // (not be eliminated by the compiler)
1468   static char c;
1469   static volatile char* p;
1470 
</pre>
<hr />
<pre>
1780 WB_ENTRY(void, WB_AssertSpecialLock(JNIEnv* env, jobject o, jboolean allowVMBlock, jboolean safepointCheck))
1781   // Create a special lock violating condition in value
1782   Mutex::SafepointCheckRequired sfpt_check_required = safepointCheck ?
1783                                            Mutex::_safepoint_check_always :
1784                                            Mutex::_safepoint_check_never;
1785   Mutex::SafepointCheckFlag safepoint_check = safepointCheck ?
1786                                            Monitor::_safepoint_check_flag :
1787                                            Monitor::_no_safepoint_check_flag;
1788 
1789   MutexLocker ml(new Mutex(Mutex::special, &quot;SpecialTest_lock&quot;, allowVMBlock, sfpt_check_required), safepoint_check);
1790   // If the lock above succeeds, try to safepoint to test the NSV implied with this special lock.
1791   ThreadBlockInVM tbivm(JavaThread::current());
1792 WB_END
1793 
1794 WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
1795   oop obj_oop = JNIHandles::resolve(obj);
1796   return (jboolean) obj_oop-&gt;mark().has_monitor();
1797 WB_END
1798 
1799 WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))







1800   VM_ForceSafepoint force_safepoint_op;
1801   VMThread::execute(&amp;force_safepoint_op);
1802 WB_END
1803 
1804 WB_ENTRY(jlong, WB_GetConstantPool(JNIEnv* env, jobject wb, jclass klass))
1805   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1806   return (jlong) ik-&gt;constants();
1807 WB_END
1808 
1809 WB_ENTRY(jint, WB_GetConstantPoolCacheIndexTag(JNIEnv* env, jobject wb))
1810   return ConstantPool::CPCACHE_INDEX_TAG;
1811 WB_END
1812 
1813 WB_ENTRY(jint, WB_GetConstantPoolCacheLength(JNIEnv* env, jobject wb, jclass klass))
1814   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1815   ConstantPool* cp = ik-&gt;constants();
1816   if (cp-&gt;cache() == NULL) {
1817       return -1;
1818   }
1819   return cp-&gt;cache()-&gt;length();
</pre>
</td>
<td>
<hr />
<pre>
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  60 #include &quot;prims/resolvedMethodTable.hpp&quot;
  61 #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
  62 #include &quot;prims/whitebox.inline.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/atomic.hpp&quot;
  65 #include &quot;runtime/deoptimization.hpp&quot;
  66 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  67 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  68 #include &quot;runtime/frame.inline.hpp&quot;
  69 #include &quot;runtime/handles.inline.hpp&quot;
  70 #include &quot;runtime/handshake.hpp&quot;
  71 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  72 #include &quot;runtime/javaCalls.hpp&quot;
  73 #include &quot;runtime/jniHandles.inline.hpp&quot;
  74 #include &quot;runtime/os.hpp&quot;
  75 #include &quot;runtime/sweeper.hpp&quot;
<span class="line-added">  76 #include &quot;runtime/synchronizer.hpp&quot;</span>
  77 #include &quot;runtime/thread.hpp&quot;
  78 #include &quot;runtime/threadSMR.hpp&quot;
  79 #include &quot;runtime/vm_version.hpp&quot;
  80 #include &quot;services/memoryService.hpp&quot;
  81 #include &quot;utilities/align.hpp&quot;
  82 #include &quot;utilities/debug.hpp&quot;
  83 #include &quot;utilities/elfFile.hpp&quot;
  84 #include &quot;utilities/exceptions.hpp&quot;
  85 #include &quot;utilities/macros.hpp&quot;
  86 #if INCLUDE_CDS
  87 #include &quot;prims/cdsoffsets.hpp&quot;
  88 #endif // INCLUDE_CDS
  89 #if INCLUDE_G1GC
  90 #include &quot;gc/g1/g1Arguments.hpp&quot;
  91 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  92 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  93 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  94 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  95 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  96 #endif // INCLUDE_G1GC
</pre>
<hr />
<pre>
 461 
 462 WB_ENTRY(jlong, WB_G1NumFreeRegions(JNIEnv* env, jobject o))
 463   if (UseG1GC) {
 464     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 465     size_t nr = g1h-&gt;num_free_regions();
 466     return (jlong)nr;
 467   }
 468   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumFreeRegions: G1 GC is not enabled&quot;);
 469 WB_END
 470 
 471 WB_ENTRY(jboolean, WB_G1InConcurrentMark(JNIEnv* env, jobject o))
 472   if (UseG1GC) {
 473     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 474     return g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
 475   }
 476   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1InConcurrentMark: G1 GC is not enabled&quot;);
 477 WB_END
 478 
 479 WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))
 480   if (UseG1GC) {
<span class="line-added"> 481     if (AsyncDeflateIdleMonitors) {</span>
<span class="line-added"> 482       // AsyncDeflateIdleMonitors needs to know when System.gc() or</span>
<span class="line-added"> 483       // the equivalent is called so any special clean up can be done</span>
<span class="line-added"> 484       // at a safepoint, e.g., TestHumongousClassLoader.java.</span>
<span class="line-added"> 485       ObjectSynchronizer::set_is_special_deflation_requested(true);</span>
<span class="line-added"> 486     }</span>
 487     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 488     if (!g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle()) {
 489       g1h-&gt;collect(GCCause::_wb_conc_mark);
 490       return true;
 491     }
 492     return false;
 493   }
 494   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1StartMarkCycle: G1 GC is not enabled&quot;);
 495 WB_END
 496 
 497 WB_ENTRY(jint, WB_G1RegionSize(JNIEnv* env, jobject o))
 498   if (UseG1GC) {
 499     return (jint)HeapRegion::GrainBytes;
 500   }
 501   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1RegionSize: G1 GC is not enabled&quot;);
 502 WB_END
 503 
 504 #endif // INCLUDE_G1GC
 505 
 506 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
</pre>
<hr />
<pre>
1438 
1439 WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
1440   MonitorLocker mo(Compilation_lock, Mutex::_no_safepoint_check_flag);
1441   WhiteBox::compilation_locked = false;
1442   mo.notify_all();
1443 WB_END
1444 
1445 WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
1446   // Force a code cache sweep and block until it finished
1447   NMethodSweeper::force_sweep();
1448 WB_END
1449 
1450 WB_ENTRY(jboolean, WB_IsInStringTable(JNIEnv* env, jobject o, jstring javaString))
1451   ResourceMark rm(THREAD);
1452   int len;
1453   jchar* name = java_lang_String::as_unicode_string(JNIHandles::resolve(javaString), len, CHECK_false);
1454   return (StringTable::lookup(name, len) != NULL);
1455 WB_END
1456 
1457 WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))
<span class="line-added">1458   if (AsyncDeflateIdleMonitors) {</span>
<span class="line-added">1459     // AsyncDeflateIdleMonitors needs to know when System.gc() or</span>
<span class="line-added">1460     // the equivalent is called so any special clean up can be done</span>
<span class="line-added">1461     // at a safepoint, e.g., TestHumongousClassLoader.java.</span>
<span class="line-added">1462     ObjectSynchronizer::set_is_special_deflation_requested(true);</span>
<span class="line-added">1463   }</span>
1464   Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1465   Universe::heap()-&gt;collect(GCCause::_wb_full_gc);
1466 #if INCLUDE_G1GC
1467   if (UseG1GC) {
1468     // Needs to be cleared explicitly for G1
1469     Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1470   }
1471 #endif // INCLUDE_G1GC
1472 WB_END
1473 
1474 WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))
1475   Universe::heap()-&gt;collect(GCCause::_wb_young_gc);
1476 WB_END
1477 
1478 WB_ENTRY(void, WB_ReadReservedMemory(JNIEnv* env, jobject o))
1479   // static+volatile in order to force the read to happen
1480   // (not be eliminated by the compiler)
1481   static char c;
1482   static volatile char* p;
1483 
</pre>
<hr />
<pre>
1793 WB_ENTRY(void, WB_AssertSpecialLock(JNIEnv* env, jobject o, jboolean allowVMBlock, jboolean safepointCheck))
1794   // Create a special lock violating condition in value
1795   Mutex::SafepointCheckRequired sfpt_check_required = safepointCheck ?
1796                                            Mutex::_safepoint_check_always :
1797                                            Mutex::_safepoint_check_never;
1798   Mutex::SafepointCheckFlag safepoint_check = safepointCheck ?
1799                                            Monitor::_safepoint_check_flag :
1800                                            Monitor::_no_safepoint_check_flag;
1801 
1802   MutexLocker ml(new Mutex(Mutex::special, &quot;SpecialTest_lock&quot;, allowVMBlock, sfpt_check_required), safepoint_check);
1803   // If the lock above succeeds, try to safepoint to test the NSV implied with this special lock.
1804   ThreadBlockInVM tbivm(JavaThread::current());
1805 WB_END
1806 
1807 WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
1808   oop obj_oop = JNIHandles::resolve(obj);
1809   return (jboolean) obj_oop-&gt;mark().has_monitor();
1810 WB_END
1811 
1812 WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))
<span class="line-added">1813   if (AsyncDeflateIdleMonitors) {</span>
<span class="line-added">1814     // AsyncDeflateIdleMonitors needs to know when System.gc() or</span>
<span class="line-added">1815     // the equivalent is called so any special clean up can be done</span>
<span class="line-added">1816     // at a safepoint, e.g., TestRTMTotalCountIncrRate.java or</span>
<span class="line-added">1817     // TestUseRTMForStackLocks.java.</span>
<span class="line-added">1818     ObjectSynchronizer::set_is_special_deflation_requested(true);</span>
<span class="line-added">1819   }</span>
1820   VM_ForceSafepoint force_safepoint_op;
1821   VMThread::execute(&amp;force_safepoint_op);
1822 WB_END
1823 
1824 WB_ENTRY(jlong, WB_GetConstantPool(JNIEnv* env, jobject wb, jclass klass))
1825   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1826   return (jlong) ik-&gt;constants();
1827 WB_END
1828 
1829 WB_ENTRY(jint, WB_GetConstantPoolCacheIndexTag(JNIEnv* env, jobject wb))
1830   return ConstantPool::CPCACHE_INDEX_TAG;
1831 WB_END
1832 
1833 WB_ENTRY(jint, WB_GetConstantPoolCacheLength(JNIEnv* env, jobject wb, jclass klass))
1834   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1835   ConstantPool* cp = ik-&gt;constants();
1836   if (cp-&gt;cache() == NULL) {
1837       return -1;
1838   }
1839   return cp-&gt;cache()-&gt;length();
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiRedefineClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
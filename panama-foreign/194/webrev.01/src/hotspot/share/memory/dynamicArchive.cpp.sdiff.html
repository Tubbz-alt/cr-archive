<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/dynamicArchive.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="archiveUtils.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspace.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/dynamicArchive.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 949 
 950     return true; // keep iterating
 951   }
 952 };
 953 
 954 void DynamicArchiveBuilder::relocate_buffer_to_target() {
 955   RelocateBufferToTarget patcher(this, (address*)_alloc_bottom, _buffer_to_target_delta);
 956   ArchivePtrMarker::ptrmap()-&gt;iterate(&amp;patcher);
 957 
 958   Array&lt;u8&gt;* table = FileMapInfo::saved_shared_path_table().table();
 959   SharedPathTable runtime_table(to_target(table), FileMapInfo::shared_path_table().size());
 960   _header-&gt;set_shared_path_table(runtime_table);
 961 
 962   address relocatable_base = (address)SharedBaseAddress;
 963   address relocatable_end = (address)(current_dump_space()-&gt;top()) + _buffer_to_target_delta;
 964 
 965   intx addr_delta = MetaspaceShared::final_delta();
 966   if (addr_delta == 0) {
 967     ArchivePtrMarker::compact(relocatable_base, relocatable_end);
 968   } else {
<span class="line-modified"> 969     // The base archive is NOT mapped at Arguments::default_SharedBaseAddress() (due to ASLR).</span>
 970     // This means that the current content of the dynamic archive is based on a random
 971     // address. Let&#39;s relocate all the pointers, so that it can be mapped to
<span class="line-modified"> 972     // Arguments::default_SharedBaseAddress() without runtime relocation.</span>
 973     //
 974     // Note: both the base and dynamic archive are written with
<span class="line-modified"> 975     // FileMapHeader::_shared_base_address == Arguments::default_SharedBaseAddress()</span>
 976 
 977     // Patch all pointers that are marked by ptrmap within this region,
 978     // where we have just dumped all the metaspace data.
 979     address patch_base = (address)_alloc_bottom;
 980     address patch_end  = (address)current_dump_space()-&gt;top();
 981 
 982     // the current value of the pointers to be patched must be within this
 983     // range (i.e., must point to either the top archive (as currently mapped), or to the
 984     // (targeted address of) the top archive)
 985     address valid_old_base = relocatable_base;
 986     address valid_old_end  = relocatable_end;
 987     size_t base_plus_top_size = valid_old_end - valid_old_base;
 988     size_t top_size = patch_end - patch_base;
 989     size_t base_size = base_plus_top_size - top_size;
 990     assert(base_plus_top_size &gt; base_size, &quot;no overflow&quot;);
 991     assert(base_plus_top_size &gt; top_size, &quot;no overflow&quot;);
 992 
 993     // after patching, the pointers must point inside this range
 994     // (the requested location of the archive, as mapped at runtime).
<span class="line-modified"> 995     address valid_new_base = (address)Arguments::default_SharedBaseAddress();</span>
 996     address valid_new_end  = valid_new_base + base_plus_top_size;
 997 
 998     log_debug(cds)(&quot;Relocating archive from [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;] to &quot;
 999                    &quot;[&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;], delta = &quot; INTX_FORMAT &quot; bytes&quot;,
1000                    p2i(patch_base + base_size), p2i(patch_end),
1001                    p2i(valid_new_base + base_size), p2i(valid_new_end), addr_delta);
1002 
1003     SharedDataRelocator&lt;true&gt; patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,
1004                                       valid_new_base, valid_new_end, addr_delta, ArchivePtrMarker::ptrmap());
1005     ArchivePtrMarker::ptrmap()-&gt;iterate(&amp;patcher);
1006     ArchivePtrMarker::compact(patcher.max_non_null_offset());
1007   }
1008 }
1009 
1010 void DynamicArchiveBuilder::write_archive(char* serialized_data) {
1011   int num_klasses = _klasses-&gt;length();
1012   int num_symbols = _symbols-&gt;length();
1013 
1014   _header-&gt;set_serialized_data(to_target(serialized_data));
1015 
1016   FileMapInfo* dynamic_info = FileMapInfo::dynamic_info();
1017   assert(dynamic_info != NULL, &quot;Sanity&quot;);
1018 
1019   // Now write the archived data including the file offsets.
1020   const char* archive_name = Arguments::GetSharedDynamicArchivePath();
1021   dynamic_info-&gt;open_for_write(archive_name);
1022   MetaspaceShared::write_core_archive_regions(dynamic_info, NULL, NULL);
<span class="line-modified">1023   dynamic_info-&gt;set_final_requested_base((char*)Arguments::default_SharedBaseAddress());</span>
1024   dynamic_info-&gt;set_header_crc(dynamic_info-&gt;compute_header_crc());
1025   dynamic_info-&gt;write_header();
1026   dynamic_info-&gt;close();
1027 
1028   address base = to_target(_alloc_bottom);
1029   address top  = address(current_dump_space()-&gt;top()) + _buffer_to_target_delta;
1030   size_t file_size = pointer_delta(top, base, sizeof(char));
1031 
1032   base += MetaspaceShared::final_delta();
1033   top += MetaspaceShared::final_delta();
1034   log_info(cds, dynamic)(&quot;Written dynamic archive &quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT
1035                          &quot; [&quot; SIZE_FORMAT &quot; bytes header, &quot; SIZE_FORMAT &quot; bytes total]&quot;,
1036                          p2i(base), p2i(top), _header-&gt;header_size(), file_size);
1037   log_info(cds, dynamic)(&quot;%d klasses; %d symbols&quot;, num_klasses, num_symbols);
1038 }
1039 
1040 
1041 class VM_PopulateDynamicDumpSharedSpace: public VM_Operation {
1042   DynamicArchiveBuilder* _builder;
1043 public:
</pre>
</td>
<td>
<hr />
<pre>
 949 
 950     return true; // keep iterating
 951   }
 952 };
 953 
 954 void DynamicArchiveBuilder::relocate_buffer_to_target() {
 955   RelocateBufferToTarget patcher(this, (address*)_alloc_bottom, _buffer_to_target_delta);
 956   ArchivePtrMarker::ptrmap()-&gt;iterate(&amp;patcher);
 957 
 958   Array&lt;u8&gt;* table = FileMapInfo::saved_shared_path_table().table();
 959   SharedPathTable runtime_table(to_target(table), FileMapInfo::shared_path_table().size());
 960   _header-&gt;set_shared_path_table(runtime_table);
 961 
 962   address relocatable_base = (address)SharedBaseAddress;
 963   address relocatable_end = (address)(current_dump_space()-&gt;top()) + _buffer_to_target_delta;
 964 
 965   intx addr_delta = MetaspaceShared::final_delta();
 966   if (addr_delta == 0) {
 967     ArchivePtrMarker::compact(relocatable_base, relocatable_end);
 968   } else {
<span class="line-modified"> 969     // The base archive is NOT mapped at MetaspaceShared::requested_base_address() (due to ASLR).</span>
 970     // This means that the current content of the dynamic archive is based on a random
 971     // address. Let&#39;s relocate all the pointers, so that it can be mapped to
<span class="line-modified"> 972     // MetaspaceShared::requested_base_address() without runtime relocation.</span>
 973     //
 974     // Note: both the base and dynamic archive are written with
<span class="line-modified"> 975     // FileMapHeader::_requested_base_address == MetaspaceShared::requested_base_address()</span>
 976 
 977     // Patch all pointers that are marked by ptrmap within this region,
 978     // where we have just dumped all the metaspace data.
 979     address patch_base = (address)_alloc_bottom;
 980     address patch_end  = (address)current_dump_space()-&gt;top();
 981 
 982     // the current value of the pointers to be patched must be within this
 983     // range (i.e., must point to either the top archive (as currently mapped), or to the
 984     // (targeted address of) the top archive)
 985     address valid_old_base = relocatable_base;
 986     address valid_old_end  = relocatable_end;
 987     size_t base_plus_top_size = valid_old_end - valid_old_base;
 988     size_t top_size = patch_end - patch_base;
 989     size_t base_size = base_plus_top_size - top_size;
 990     assert(base_plus_top_size &gt; base_size, &quot;no overflow&quot;);
 991     assert(base_plus_top_size &gt; top_size, &quot;no overflow&quot;);
 992 
 993     // after patching, the pointers must point inside this range
 994     // (the requested location of the archive, as mapped at runtime).
<span class="line-modified"> 995     address valid_new_base = (address)MetaspaceShared::requested_base_address();</span>
 996     address valid_new_end  = valid_new_base + base_plus_top_size;
 997 
 998     log_debug(cds)(&quot;Relocating archive from [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;] to &quot;
 999                    &quot;[&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;], delta = &quot; INTX_FORMAT &quot; bytes&quot;,
1000                    p2i(patch_base + base_size), p2i(patch_end),
1001                    p2i(valid_new_base + base_size), p2i(valid_new_end), addr_delta);
1002 
1003     SharedDataRelocator&lt;true&gt; patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,
1004                                       valid_new_base, valid_new_end, addr_delta, ArchivePtrMarker::ptrmap());
1005     ArchivePtrMarker::ptrmap()-&gt;iterate(&amp;patcher);
1006     ArchivePtrMarker::compact(patcher.max_non_null_offset());
1007   }
1008 }
1009 
1010 void DynamicArchiveBuilder::write_archive(char* serialized_data) {
1011   int num_klasses = _klasses-&gt;length();
1012   int num_symbols = _symbols-&gt;length();
1013 
1014   _header-&gt;set_serialized_data(to_target(serialized_data));
1015 
1016   FileMapInfo* dynamic_info = FileMapInfo::dynamic_info();
1017   assert(dynamic_info != NULL, &quot;Sanity&quot;);
1018 
1019   // Now write the archived data including the file offsets.
1020   const char* archive_name = Arguments::GetSharedDynamicArchivePath();
1021   dynamic_info-&gt;open_for_write(archive_name);
1022   MetaspaceShared::write_core_archive_regions(dynamic_info, NULL, NULL);
<span class="line-modified">1023   dynamic_info-&gt;set_final_requested_base((char*)MetaspaceShared::requested_base_address());</span>
1024   dynamic_info-&gt;set_header_crc(dynamic_info-&gt;compute_header_crc());
1025   dynamic_info-&gt;write_header();
1026   dynamic_info-&gt;close();
1027 
1028   address base = to_target(_alloc_bottom);
1029   address top  = address(current_dump_space()-&gt;top()) + _buffer_to_target_delta;
1030   size_t file_size = pointer_delta(top, base, sizeof(char));
1031 
1032   base += MetaspaceShared::final_delta();
1033   top += MetaspaceShared::final_delta();
1034   log_info(cds, dynamic)(&quot;Written dynamic archive &quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT
1035                          &quot; [&quot; SIZE_FORMAT &quot; bytes header, &quot; SIZE_FORMAT &quot; bytes total]&quot;,
1036                          p2i(base), p2i(top), _header-&gt;header_size(), file_size);
1037   log_info(cds, dynamic)(&quot;%d klasses; %d symbols&quot;, num_klasses, num_symbols);
1038 }
1039 
1040 
1041 class VM_PopulateDynamicDumpSharedSpace: public VM_Operation {
1042   DynamicArchiveBuilder* _builder;
1043 public:
</pre>
</td>
</tr>
</table>
<center><a href="archiveUtils.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspace.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
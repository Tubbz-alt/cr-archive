<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspaceShared.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="metaspaceShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="universe.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspaceShared.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
166 // Class Data Sharing Support
167 class MetaspaceShared : AllStatic {
168 
169   // CDS support
170 
171   // Note: _shared_rs and _symbol_rs are only used at dump time.
172   static ReservedSpace _shared_rs;
173   static VirtualSpace _shared_vs;
174   static ReservedSpace _symbol_rs;
175   static VirtualSpace _symbol_vs;
176   static int _max_alignment;
177   static MetaspaceSharedStats _stats;
178   static bool _has_error_classes;
179   static bool _archive_loading_failed;
180   static bool _remapped_readwrite;
181   static address _i2i_entry_code_buffers;
182   static size_t  _i2i_entry_code_buffers_size;
183   static size_t  _core_spaces_size;
184   static void* _shared_metaspace_static_top;
185   static intx _relocation_delta;

186  public:
187   enum {
188     // core archive spaces
189     mc = 0,  // miscellaneous code for method trampolines
190     rw = 1,  // read-write shared space in the heap
191     ro = 2,  // read-only shared space in the heap
192     bm = 3,  // relocation bitmaps (freed after file mapping is finished)
193     num_core_region = 3,
194     num_non_heap_spaces = 4,
195 
196     // mapped java heap regions
197     first_closed_archive_heap_region = bm + 1,
198     max_closed_archive_heap_region = 2,
199     last_closed_archive_heap_region = first_closed_archive_heap_region + max_closed_archive_heap_region - 1,
200     first_open_archive_heap_region = last_closed_archive_heap_region + 1,
201     max_open_archive_heap_region = 2,
202     last_open_archive_heap_region = first_open_archive_heap_region + max_open_archive_heap_region - 1,
203 
204     last_valid_region = last_open_archive_heap_region,
205     n_regions =  last_valid_region + 1 // total number of regions
</pre>
<hr />
<pre>
336     size_t byte_size = Array&lt;T&gt;::byte_sizeof(length, sizeof(T));
337     return align_up(byte_size, BytesPerWord);
338   }
339 
340   static address i2i_entry_code_buffers(size_t total_size);
341 
342   static address i2i_entry_code_buffers() {
343     return _i2i_entry_code_buffers;
344   }
345   static size_t i2i_entry_code_buffers_size() {
346     return _i2i_entry_code_buffers_size;
347   }
348   static void relocate_klass_ptr(oop o);
349 
350   static Klass* get_relocated_klass(Klass *k, bool is_final=false);
351 
352   static void allocate_cloned_cpp_vtptrs();
353   static intptr_t* fix_cpp_vtable_for_dynamic_archive(MetaspaceObj::Type msotype, address obj);
354   static void initialize_ptr_marker(CHeapBitMap* ptrmap);
355 






356   // Non-zero if the archive(s) need to be mapped a non-default location due to ASLR.
357   static intx relocation_delta() { return _relocation_delta; }
358   static intx final_delta();
359   static bool use_windows_memory_mapping() {
360     const bool is_windows = (NOT_WINDOWS(false) WINDOWS_ONLY(true));
361     //const bool is_windows = true; // enable this to allow testing the windows mmap semantics on Linux, etc.
362     return is_windows;
363   }
364 
365   static void write_core_archive_regions(FileMapInfo* mapinfo,
366                                          GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* closed_oopmaps,
367                                          GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* open_oopmaps);
368 private:
369 #if INCLUDE_CDS
370   static void write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region,
371                            bool read_only,  bool allow_exec);
372 #endif
373   static void read_extra_data(const char* filename, TRAPS) NOT_CDS_RETURN;
374   static FileMapInfo* open_static_archive();
375   static FileMapInfo* open_dynamic_archive();
</pre>
</td>
<td>
<hr />
<pre>
166 // Class Data Sharing Support
167 class MetaspaceShared : AllStatic {
168 
169   // CDS support
170 
171   // Note: _shared_rs and _symbol_rs are only used at dump time.
172   static ReservedSpace _shared_rs;
173   static VirtualSpace _shared_vs;
174   static ReservedSpace _symbol_rs;
175   static VirtualSpace _symbol_vs;
176   static int _max_alignment;
177   static MetaspaceSharedStats _stats;
178   static bool _has_error_classes;
179   static bool _archive_loading_failed;
180   static bool _remapped_readwrite;
181   static address _i2i_entry_code_buffers;
182   static size_t  _i2i_entry_code_buffers_size;
183   static size_t  _core_spaces_size;
184   static void* _shared_metaspace_static_top;
185   static intx _relocation_delta;
<span class="line-added">186   static char* _requested_base_address;</span>
187  public:
188   enum {
189     // core archive spaces
190     mc = 0,  // miscellaneous code for method trampolines
191     rw = 1,  // read-write shared space in the heap
192     ro = 2,  // read-only shared space in the heap
193     bm = 3,  // relocation bitmaps (freed after file mapping is finished)
194     num_core_region = 3,
195     num_non_heap_spaces = 4,
196 
197     // mapped java heap regions
198     first_closed_archive_heap_region = bm + 1,
199     max_closed_archive_heap_region = 2,
200     last_closed_archive_heap_region = first_closed_archive_heap_region + max_closed_archive_heap_region - 1,
201     first_open_archive_heap_region = last_closed_archive_heap_region + 1,
202     max_open_archive_heap_region = 2,
203     last_open_archive_heap_region = first_open_archive_heap_region + max_open_archive_heap_region - 1,
204 
205     last_valid_region = last_open_archive_heap_region,
206     n_regions =  last_valid_region + 1 // total number of regions
</pre>
<hr />
<pre>
337     size_t byte_size = Array&lt;T&gt;::byte_sizeof(length, sizeof(T));
338     return align_up(byte_size, BytesPerWord);
339   }
340 
341   static address i2i_entry_code_buffers(size_t total_size);
342 
343   static address i2i_entry_code_buffers() {
344     return _i2i_entry_code_buffers;
345   }
346   static size_t i2i_entry_code_buffers_size() {
347     return _i2i_entry_code_buffers_size;
348   }
349   static void relocate_klass_ptr(oop o);
350 
351   static Klass* get_relocated_klass(Klass *k, bool is_final=false);
352 
353   static void allocate_cloned_cpp_vtptrs();
354   static intptr_t* fix_cpp_vtable_for_dynamic_archive(MetaspaceObj::Type msotype, address obj);
355   static void initialize_ptr_marker(CHeapBitMap* ptrmap);
356 
<span class="line-added">357   // This is the base address as specified by -XX:SharedBaseAddress during -Xshare:dump.</span>
<span class="line-added">358   // Both the base/top archives are written using this as their base address.</span>
<span class="line-added">359   static char* requested_base_address() {</span>
<span class="line-added">360     return _requested_base_address;</span>
<span class="line-added">361   }</span>
<span class="line-added">362 </span>
363   // Non-zero if the archive(s) need to be mapped a non-default location due to ASLR.
364   static intx relocation_delta() { return _relocation_delta; }
365   static intx final_delta();
366   static bool use_windows_memory_mapping() {
367     const bool is_windows = (NOT_WINDOWS(false) WINDOWS_ONLY(true));
368     //const bool is_windows = true; // enable this to allow testing the windows mmap semantics on Linux, etc.
369     return is_windows;
370   }
371 
372   static void write_core_archive_regions(FileMapInfo* mapinfo,
373                                          GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* closed_oopmaps,
374                                          GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* open_oopmaps);
375 private:
376 #if INCLUDE_CDS
377   static void write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region,
378                            bool read_only,  bool allow_exec);
379 #endif
380   static void read_extra_data(const char* filename, TRAPS) NOT_CDS_RETURN;
381   static FileMapInfo* open_static_archive();
382   static FileMapInfo* open_dynamic_archive();
</pre>
</td>
</tr>
</table>
<center><a href="metaspaceShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="universe.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
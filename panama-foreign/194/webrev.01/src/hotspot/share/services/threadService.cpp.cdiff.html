<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/services/threadService.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../runtime/vmThread.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="virtualMemoryTracker.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/threadService.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,23 ***</span>
  // FIXME: JVMTI should call this function
  Handle ThreadService::get_current_contended_monitor(JavaThread* thread) {
    assert(thread != NULL, &quot;should be non-NULL&quot;);
    debug_only(Thread::check_for_dangling_thread_pointer(thread);)
  
    ObjectMonitor *wait_obj = thread-&gt;current_waiting_monitor();
  
    oop obj = NULL;
    if (wait_obj != NULL) {
      // thread is doing an Object.wait() call
      obj = (oop) wait_obj-&gt;object();
<span class="line-modified">!     assert(obj != NULL, &quot;Object.wait() should have an object&quot;);</span>
    } else {
      ObjectMonitor *enter_obj = thread-&gt;current_pending_monitor();
      if (enter_obj != NULL) {
        // thread is trying to enter() an ObjectMonitor.
        obj = (oop) enter_obj-&gt;object();
<span class="line-modified">!       assert(obj != NULL, &quot;ObjectMonitor should have an associated object!&quot;);</span>
      }
    }
  
    Handle h(Thread::current(), obj);
    return h;
<span class="line-new-header">--- 206,31 ---</span>
  // FIXME: JVMTI should call this function
  Handle ThreadService::get_current_contended_monitor(JavaThread* thread) {
    assert(thread != NULL, &quot;should be non-NULL&quot;);
    debug_only(Thread::check_for_dangling_thread_pointer(thread);)
  
<span class="line-added">+   // This function can be called on a target JavaThread that is not</span>
<span class="line-added">+   // the caller and we are not at a safepoint. So it is possible for</span>
<span class="line-added">+   // the waiting or pending condition to be over/stale and for the</span>
<span class="line-added">+   // first stage of async deflation to clear the object field in</span>
<span class="line-added">+   // the ObjectMonitor. It is also possible for the object to be</span>
<span class="line-added">+   // inflated again and to be associated with a completely different</span>
<span class="line-added">+   // ObjectMonitor by the time this object reference is processed</span>
<span class="line-added">+   // by the caller.</span>
    ObjectMonitor *wait_obj = thread-&gt;current_waiting_monitor();
  
    oop obj = NULL;
    if (wait_obj != NULL) {
      // thread is doing an Object.wait() call
      obj = (oop) wait_obj-&gt;object();
<span class="line-modified">!     assert(AsyncDeflateIdleMonitors || obj != NULL, &quot;Object.wait() should have an object&quot;);</span>
    } else {
      ObjectMonitor *enter_obj = thread-&gt;current_pending_monitor();
      if (enter_obj != NULL) {
        // thread is trying to enter() an ObjectMonitor.
        obj = (oop) enter_obj-&gt;object();
<span class="line-modified">!       assert(AsyncDeflateIdleMonitors || obj != NULL, &quot;ObjectMonitor should have an associated object!&quot;);</span>
      }
    }
  
    Handle h(Thread::current(), obj);
    return h;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 389,10 ***</span>
<span class="line-new-header">--- 397,11 ---</span>
      previousThread = jt;
      currentThread = jt;
  
      cycle-&gt;reset();
  
<span class="line-added">+     // The ObjectMonitor* can&#39;t be async deflated since we are at a safepoint.</span>
      // When there is a deadlock, all the monitors involved in the dependency
      // cycle must be contended and heavyweight. So we only care about the
      // heavyweight monitor a thread is waiting to lock.
      waitingToLockMonitor = jt-&gt;current_pending_monitor();
      // JVM TI raw monitors can also be involved in deadlocks, and we can be
</pre>
<hr />
<pre>
<span class="line-old-header">*** 965,17 ***</span>
    st-&gt;cr();
    st-&gt;print_cr(&quot;Found one Java-level deadlock:&quot;);
    st-&gt;print(&quot;=============================&quot;);
  
    JavaThread* currentThread;
<span class="line-removed">-   ObjectMonitor* waitingToLockMonitor;</span>
    JvmtiRawMonitor* waitingToLockRawMonitor;
    oop waitingToLockBlocker;
    int len = _threads-&gt;length();
    for (int i = 0; i &lt; len; i++) {
      currentThread = _threads-&gt;at(i);
<span class="line-modified">!     waitingToLockMonitor = currentThread-&gt;current_pending_monitor();</span>
      waitingToLockRawMonitor = currentThread-&gt;current_pending_raw_monitor();
      waitingToLockBlocker = currentThread-&gt;current_park_blocker();
      st-&gt;cr();
      st-&gt;print_cr(&quot;\&quot;%s\&quot;:&quot;, currentThread-&gt;get_thread_name());
      const char* owner_desc = &quot;,\n  which is held by&quot;;
<span class="line-new-header">--- 974,17 ---</span>
    st-&gt;cr();
    st-&gt;print_cr(&quot;Found one Java-level deadlock:&quot;);
    st-&gt;print(&quot;=============================&quot;);
  
    JavaThread* currentThread;
    JvmtiRawMonitor* waitingToLockRawMonitor;
    oop waitingToLockBlocker;
    int len = _threads-&gt;length();
    for (int i = 0; i &lt; len; i++) {
      currentThread = _threads-&gt;at(i);
<span class="line-modified">!     // The ObjectMonitor* can&#39;t be async deflated since we are at a safepoint.</span>
<span class="line-added">+     ObjectMonitor* waitingToLockMonitor = currentThread-&gt;current_pending_monitor();</span>
      waitingToLockRawMonitor = currentThread-&gt;current_pending_raw_monitor();
      waitingToLockBlocker = currentThread-&gt;current_park_blocker();
      st-&gt;cr();
      st-&gt;print_cr(&quot;\&quot;%s\&quot;:&quot;, currentThread-&gt;get_thread_name());
      const char* owner_desc = &quot;,\n  which is held by&quot;;
</pre>
<center><a href="../runtime/vmThread.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="virtualMemoryTracker.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
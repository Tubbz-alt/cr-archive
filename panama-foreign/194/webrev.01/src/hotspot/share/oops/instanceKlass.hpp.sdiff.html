<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceRefKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 181   // attribute. If the EnclosingMethod attribute exists, it occupies the
 182   // last two shorts [class_index, method_index] of the array. If only
 183   // the InnerClasses attribute exists, the _inner_classes array length is
 184   // number_of_inner_classes * 4. If the class has both InnerClasses
 185   // and EnclosingMethod attributes the _inner_classes array length is
 186   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 187   Array&lt;jushort&gt;* _inner_classes;
 188 
 189   // The NestMembers attribute. An array of shorts, where each is a
 190   // class info index for the class that is a nest member. This data
 191   // has not been validated.
 192   Array&lt;jushort&gt;* _nest_members;
 193 
 194   // Resolved nest-host klass: either true nest-host or self if we are not
 195   // nested, or an error occurred resolving or validating the nominated
 196   // nest-host. Can also be set directly by JDK API&#39;s that establish nest
 197   // relationships.
 198   // By always being set it makes nest-member access checks simpler.
 199   InstanceKlass* _nest_host;
 200 




 201   // The contents of the Record attribute.
 202   Array&lt;RecordComponent*&gt;* _record_components;
 203 
 204   // the source debug extension for this klass, NULL if not specified.
 205   // Specified as UTF-8 string without terminating zero byte in the classfile,
 206   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 207   const char*     _source_debug_extension;
 208 
 209   // Number of heapOopSize words used by non-static fields in this klass
 210   // (including inherited fields but after header_size()).
 211   int             _nonstatic_field_size;
 212   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 213 
 214   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 215   int             _itable_len;           // length of Java itable (in words)
 216 
 217   // The NestHost attribute. The class info index for the class
 218   // that is the nest-host of this class. This data has not been validated.
 219   u2              _nest_host_index;
 220   u2              _this_class_index;              // constant pool entry
</pre>
<hr />
<pre>
 452   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 453   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 454 
 455   // nest members
 456   Array&lt;u2&gt;* nest_members() const     { return _nest_members; }
 457   void set_nest_members(Array&lt;u2&gt;* m) { _nest_members = m; }
 458 
 459   // nest-host index
 460   jushort nest_host_index() const { return _nest_host_index; }
 461   void set_nest_host_index(u2 i)  { _nest_host_index = i; }
 462   // dynamic nest member support
 463   void set_nest_host(InstanceKlass* host, TRAPS);
 464 
 465   // record components
 466   Array&lt;RecordComponent*&gt;* record_components() const { return _record_components; }
 467   void set_record_components(Array&lt;RecordComponent*&gt;* record_components) {
 468     _record_components = record_components;
 469   }
 470   bool is_record() const { return _record_components != NULL; }
 471 




 472 private:
 473   // Called to verify that k is a member of this nest - does not look at k&#39;s nest-host
 474   bool has_nest_member(InstanceKlass* k, TRAPS) const;
 475 
 476 public:
 477   // Used to construct informative IllegalAccessError messages at a higher level,
 478   // if there was an issue resolving or validating the nest host.
 479   // Returns NULL if there was no error.
 480   const char* nest_host_error(TRAPS);
 481   // Returns nest-host class, resolving and validating it if needed.
 482   // Returns NULL if resolution is not possible from the calling context.
 483   InstanceKlass* nest_host(TRAPS);
 484   // Check if this klass is a nestmate of k - resolves this nest-host and k&#39;s
 485   bool has_nestmate_access_to(InstanceKlass* k, TRAPS);
 486 



 487   enum InnerClassAttributeOffset {
 488     // From http://mirror.eng/products/jdk/1.1/docs/guide/innerclasses/spec/innerclasses.doc10.html#18814
 489     inner_class_inner_class_info_offset = 0,
 490     inner_class_outer_class_info_offset = 1,
 491     inner_class_inner_name_offset = 2,
 492     inner_class_access_flags_offset = 3,
 493     inner_class_next_offset = 4
 494   };
 495 
 496   enum EnclosingMethodAttributeOffset {
 497     enclosing_method_class_index_offset = 0,
 498     enclosing_method_method_index_offset = 1,
 499     enclosing_method_attribute_size = 2
 500   };
 501 
 502   // method override check
 503   bool is_override(const methodHandle&amp; super_method, Handle targetclassloader, Symbol* targetclassname, TRAPS);
 504 
 505   // package
 506   PackageEntry* package() const     { return _package_entry; }
</pre>
<hr />
<pre>
 524   // Find InnerClasses attribute and return outer_class_info_index &amp; inner_name_index.
 525   bool find_inner_classes_attr(int* ooff, int* noff, TRAPS) const;
 526 
 527  private:
 528   // Check prohibited package (&quot;java/&quot; only loadable by boot or platform loaders)
 529   static void check_prohibited_package(Symbol* class_name,
 530                                        ClassLoaderData* loader_data,
 531                                        TRAPS);
 532  public:
 533   // initialization state
 534   bool is_loaded() const                   { return _init_state &gt;= loaded; }
 535   bool is_linked() const                   { return _init_state &gt;= linked; }
 536   bool is_initialized() const              { return _init_state == fully_initialized; }
 537   bool is_not_initialized() const          { return _init_state &lt;  being_initialized; }
 538   bool is_being_initialized() const        { return _init_state == being_initialized; }
 539   bool is_in_error_state() const           { return _init_state == initialization_error; }
 540   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 541   ClassState  init_state()                 { return (ClassState)_init_state; }
 542   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 543 



 544   // defineClass specified verification
 545   bool should_verify_class() const         {
 546     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 547   }
 548   void set_should_verify_class(bool value) {
 549     if (value) {
 550       _misc_flags |= _misc_should_verify_class;
 551     } else {
 552       _misc_flags &amp;= ~_misc_should_verify_class;
 553     }
 554   }
 555 
 556   // marking
 557   bool is_marked_dependent() const         { return _is_marked_dependent; }
 558   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 559 
 560   // initialization (virtuals from Klass)
 561   bool should_be_initialized() const;  // means that initialize should be called
 562   void initialize(TRAPS);
 563   void link_class(TRAPS);
</pre>
</td>
<td>
<hr />
<pre>
 181   // attribute. If the EnclosingMethod attribute exists, it occupies the
 182   // last two shorts [class_index, method_index] of the array. If only
 183   // the InnerClasses attribute exists, the _inner_classes array length is
 184   // number_of_inner_classes * 4. If the class has both InnerClasses
 185   // and EnclosingMethod attributes the _inner_classes array length is
 186   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 187   Array&lt;jushort&gt;* _inner_classes;
 188 
 189   // The NestMembers attribute. An array of shorts, where each is a
 190   // class info index for the class that is a nest member. This data
 191   // has not been validated.
 192   Array&lt;jushort&gt;* _nest_members;
 193 
 194   // Resolved nest-host klass: either true nest-host or self if we are not
 195   // nested, or an error occurred resolving or validating the nominated
 196   // nest-host. Can also be set directly by JDK API&#39;s that establish nest
 197   // relationships.
 198   // By always being set it makes nest-member access checks simpler.
 199   InstanceKlass* _nest_host;
 200 
<span class="line-added"> 201   // The PermittedSubclasses attribute. An array of shorts, where each is a</span>
<span class="line-added"> 202   // class info index for the class that is a permitted subclass.</span>
<span class="line-added"> 203   Array&lt;jushort&gt;* _permitted_subclasses;</span>
<span class="line-added"> 204 </span>
 205   // The contents of the Record attribute.
 206   Array&lt;RecordComponent*&gt;* _record_components;
 207 
 208   // the source debug extension for this klass, NULL if not specified.
 209   // Specified as UTF-8 string without terminating zero byte in the classfile,
 210   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 211   const char*     _source_debug_extension;
 212 
 213   // Number of heapOopSize words used by non-static fields in this klass
 214   // (including inherited fields but after header_size()).
 215   int             _nonstatic_field_size;
 216   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 217 
 218   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 219   int             _itable_len;           // length of Java itable (in words)
 220 
 221   // The NestHost attribute. The class info index for the class
 222   // that is the nest-host of this class. This data has not been validated.
 223   u2              _nest_host_index;
 224   u2              _this_class_index;              // constant pool entry
</pre>
<hr />
<pre>
 456   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 457   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 458 
 459   // nest members
 460   Array&lt;u2&gt;* nest_members() const     { return _nest_members; }
 461   void set_nest_members(Array&lt;u2&gt;* m) { _nest_members = m; }
 462 
 463   // nest-host index
 464   jushort nest_host_index() const { return _nest_host_index; }
 465   void set_nest_host_index(u2 i)  { _nest_host_index = i; }
 466   // dynamic nest member support
 467   void set_nest_host(InstanceKlass* host, TRAPS);
 468 
 469   // record components
 470   Array&lt;RecordComponent*&gt;* record_components() const { return _record_components; }
 471   void set_record_components(Array&lt;RecordComponent*&gt;* record_components) {
 472     _record_components = record_components;
 473   }
 474   bool is_record() const { return _record_components != NULL; }
 475 
<span class="line-added"> 476   // permitted subclasses</span>
<span class="line-added"> 477   Array&lt;u2&gt;* permitted_subclasses() const     { return _permitted_subclasses; }</span>
<span class="line-added"> 478   void set_permitted_subclasses(Array&lt;u2&gt;* s) { _permitted_subclasses = s; }</span>
<span class="line-added"> 479 </span>
 480 private:
 481   // Called to verify that k is a member of this nest - does not look at k&#39;s nest-host
 482   bool has_nest_member(InstanceKlass* k, TRAPS) const;
 483 
 484 public:
 485   // Used to construct informative IllegalAccessError messages at a higher level,
 486   // if there was an issue resolving or validating the nest host.
 487   // Returns NULL if there was no error.
 488   const char* nest_host_error(TRAPS);
 489   // Returns nest-host class, resolving and validating it if needed.
 490   // Returns NULL if resolution is not possible from the calling context.
 491   InstanceKlass* nest_host(TRAPS);
 492   // Check if this klass is a nestmate of k - resolves this nest-host and k&#39;s
 493   bool has_nestmate_access_to(InstanceKlass* k, TRAPS);
 494 
<span class="line-added"> 495   // Called to verify that k is a permitted subclass of this class</span>
<span class="line-added"> 496   bool has_as_permitted_subclass(const InstanceKlass* k) const;</span>
<span class="line-added"> 497 </span>
 498   enum InnerClassAttributeOffset {
 499     // From http://mirror.eng/products/jdk/1.1/docs/guide/innerclasses/spec/innerclasses.doc10.html#18814
 500     inner_class_inner_class_info_offset = 0,
 501     inner_class_outer_class_info_offset = 1,
 502     inner_class_inner_name_offset = 2,
 503     inner_class_access_flags_offset = 3,
 504     inner_class_next_offset = 4
 505   };
 506 
 507   enum EnclosingMethodAttributeOffset {
 508     enclosing_method_class_index_offset = 0,
 509     enclosing_method_method_index_offset = 1,
 510     enclosing_method_attribute_size = 2
 511   };
 512 
 513   // method override check
 514   bool is_override(const methodHandle&amp; super_method, Handle targetclassloader, Symbol* targetclassname, TRAPS);
 515 
 516   // package
 517   PackageEntry* package() const     { return _package_entry; }
</pre>
<hr />
<pre>
 535   // Find InnerClasses attribute and return outer_class_info_index &amp; inner_name_index.
 536   bool find_inner_classes_attr(int* ooff, int* noff, TRAPS) const;
 537 
 538  private:
 539   // Check prohibited package (&quot;java/&quot; only loadable by boot or platform loaders)
 540   static void check_prohibited_package(Symbol* class_name,
 541                                        ClassLoaderData* loader_data,
 542                                        TRAPS);
 543  public:
 544   // initialization state
 545   bool is_loaded() const                   { return _init_state &gt;= loaded; }
 546   bool is_linked() const                   { return _init_state &gt;= linked; }
 547   bool is_initialized() const              { return _init_state == fully_initialized; }
 548   bool is_not_initialized() const          { return _init_state &lt;  being_initialized; }
 549   bool is_being_initialized() const        { return _init_state == being_initialized; }
 550   bool is_in_error_state() const           { return _init_state == initialization_error; }
 551   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 552   ClassState  init_state()                 { return (ClassState)_init_state; }
 553   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 554 
<span class="line-added"> 555   // is this a sealed class</span>
<span class="line-added"> 556   bool is_sealed() const;</span>
<span class="line-added"> 557 </span>
 558   // defineClass specified verification
 559   bool should_verify_class() const         {
 560     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 561   }
 562   void set_should_verify_class(bool value) {
 563     if (value) {
 564       _misc_flags |= _misc_should_verify_class;
 565     } else {
 566       _misc_flags &amp;= ~_misc_should_verify_class;
 567     }
 568   }
 569 
 570   // marking
 571   bool is_marked_dependent() const         { return _is_marked_dependent; }
 572   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 573 
 574   // initialization (virtuals from Klass)
 575   bool should_be_initialized() const;  // means that initialize should be called
 576   void initialize(TRAPS);
 577   void link_class(TRAPS);
</pre>
</td>
</tr>
</table>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceRefKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
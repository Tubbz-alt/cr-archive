<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/c1/zBarrierSetC1.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../shenandoah/shenandoahStringDedup.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../zBarrier.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/c1/zBarrierSetC1.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
132   if ((decorators &amp; ON_WEAK_OOP_REF) != 0) {
133     return _load_barrier_on_weak_oop_field_preloaded_runtime_stub;
134   } else {
135     return _load_barrier_on_oop_field_preloaded_runtime_stub;
136   }
137 }
138 
139 #ifdef ASSERT
140 #define __ access.gen()-&gt;lir(__FILE__, __LINE__)-&gt;
141 #else
142 #define __ access.gen()-&gt;lir()-&gt;
143 #endif
144 
145 void ZBarrierSetC1::load_barrier(LIRAccess&amp; access, LIR_Opr result) const {
146   // Fast path
147   __ append(new LIR_OpZLoadBarrierTest(result));
148 
149   // Slow path
150   const address runtime_stub = load_barrier_on_oop_field_preloaded_runtime_stub(access.decorators());
151   CodeStub* const stub = new ZLoadBarrierStubC1(access, result, runtime_stub);
<span class="line-modified">152   __ branch(lir_cond_notEqual, T_ADDRESS, stub);</span>
153   __ branch_destination(stub-&gt;continuation());
154 }
155 
156 LIR_Opr ZBarrierSetC1::resolve_address(LIRAccess&amp; access, bool resolve_in_register) {
157   // We must resolve in register when patching. This is to avoid
158   // having a patch area in the load barrier stub, since the call
159   // into the runtime to patch will not have the proper oop map.
160   const bool patch_before_barrier = barrier_needed(access) &amp;&amp; (access.decorators() &amp; C1_NEEDS_PATCHING) != 0;
161   return BarrierSetC1::resolve_address(access, resolve_in_register || patch_before_barrier);
162 }
163 
164 #undef __
165 
166 void ZBarrierSetC1::load_at_resolved(LIRAccess&amp; access, LIR_Opr result) {
167   BarrierSetC1::load_at_resolved(access, result);
168 
169   if (barrier_needed(access)) {
170     load_barrier(access, result);
171   }
172 }
</pre>
</td>
<td>
<hr />
<pre>
132   if ((decorators &amp; ON_WEAK_OOP_REF) != 0) {
133     return _load_barrier_on_weak_oop_field_preloaded_runtime_stub;
134   } else {
135     return _load_barrier_on_oop_field_preloaded_runtime_stub;
136   }
137 }
138 
139 #ifdef ASSERT
140 #define __ access.gen()-&gt;lir(__FILE__, __LINE__)-&gt;
141 #else
142 #define __ access.gen()-&gt;lir()-&gt;
143 #endif
144 
145 void ZBarrierSetC1::load_barrier(LIRAccess&amp; access, LIR_Opr result) const {
146   // Fast path
147   __ append(new LIR_OpZLoadBarrierTest(result));
148 
149   // Slow path
150   const address runtime_stub = load_barrier_on_oop_field_preloaded_runtime_stub(access.decorators());
151   CodeStub* const stub = new ZLoadBarrierStubC1(access, result, runtime_stub);
<span class="line-modified">152   __ branch(lir_cond_notEqual, stub);</span>
153   __ branch_destination(stub-&gt;continuation());
154 }
155 
156 LIR_Opr ZBarrierSetC1::resolve_address(LIRAccess&amp; access, bool resolve_in_register) {
157   // We must resolve in register when patching. This is to avoid
158   // having a patch area in the load barrier stub, since the call
159   // into the runtime to patch will not have the proper oop map.
160   const bool patch_before_barrier = barrier_needed(access) &amp;&amp; (access.decorators() &amp; C1_NEEDS_PATCHING) != 0;
161   return BarrierSetC1::resolve_address(access, resolve_in_register || patch_before_barrier);
162 }
163 
164 #undef __
165 
166 void ZBarrierSetC1::load_at_resolved(LIRAccess&amp; access, LIR_Opr result) {
167   BarrierSetC1::load_at_resolved(access, result);
168 
169   if (barrier_needed(access)) {
170     load_barrier(access, result);
171   }
172 }
</pre>
</td>
</tr>
</table>
<center><a href="../../shenandoah/shenandoahStringDedup.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../zBarrier.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
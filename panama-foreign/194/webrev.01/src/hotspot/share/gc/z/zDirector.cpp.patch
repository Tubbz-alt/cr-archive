diff a/src/hotspot/share/gc/z/zDirector.cpp b/src/hotspot/share/gc/z/zDirector.cpp
--- a/src/hotspot/share/gc/z/zDirector.cpp
+++ b/src/hotspot/share/gc/z/zDirector.cpp
@@ -71,14 +71,14 @@
   }
 
   // Perform GC if heap usage passes 10/20/30% and no other GC has been
   // performed yet. This allows us to get some early samples of the GC
   // duration, which is needed by the other rules.
-  const size_t max_capacity = ZHeap::heap()->soft_max_capacity();
+  const size_t soft_max_capacity = ZHeap::heap()->soft_max_capacity();
   const size_t used = ZHeap::heap()->used();
   const double used_threshold_percent = (ZStatCycle::nwarmup_cycles() + 1) * 0.1;
-  const size_t used_threshold = max_capacity * used_threshold_percent;
+  const size_t used_threshold = soft_max_capacity * used_threshold_percent;
 
   log_debug(gc, director)("Rule: Warmup %.0f%%, Used: " SIZE_FORMAT "MB, UsedThreshold: " SIZE_FORMAT "MB",
                           used_threshold_percent * 100, used / M, used_threshold / M);
 
   return used >= used_threshold;
@@ -97,14 +97,14 @@
   // allocation spikes.
 
   // Calculate amount of free memory available to Java threads. Note that
   // the heap reserve is not available to Java threads and is therefore not
   // considered part of the free memory.
-  const size_t max_capacity = ZHeap::heap()->soft_max_capacity();
+  const size_t soft_max_capacity = ZHeap::heap()->soft_max_capacity();
   const size_t max_reserve = ZHeap::heap()->max_reserve();
   const size_t used = ZHeap::heap()->used();
-  const size_t free_with_reserve = max_capacity - MIN2(max_capacity, used);
+  const size_t free_with_reserve = soft_max_capacity - MIN2(soft_max_capacity, used);
   const size_t free = free_with_reserve - MIN2(free_with_reserve, max_reserve);
 
   // Calculate time until OOM given the max allocation rate and the amount
   // of free memory. The allocation rate is a moving average and we multiply
   // that with an allocation spike tolerance factor to guard against unforeseen
@@ -181,16 +181,16 @@
   // we start a GC cycle to avoid a potential allocation stall later.
 
   // Calculate amount of free memory available to Java threads. Note that
   // the heap reserve is not available to Java threads and is therefore not
   // considered part of the free memory.
-  const size_t max_capacity = ZHeap::heap()->soft_max_capacity();
+  const size_t soft_max_capacity = ZHeap::heap()->soft_max_capacity();
   const size_t max_reserve = ZHeap::heap()->max_reserve();
   const size_t used = ZHeap::heap()->used();
-  const size_t free_with_reserve = max_capacity - used;
+  const size_t free_with_reserve = soft_max_capacity - MIN2(soft_max_capacity, used);
   const size_t free = free_with_reserve - MIN2(free_with_reserve, max_reserve);
-  const double free_percent = percent_of(free, max_capacity);
+  const double free_percent = percent_of(free, soft_max_capacity);
 
   log_debug(gc, director)("Rule: High Usage, Free: " SIZE_FORMAT "MB(%.1f%%)",
                           free / M, free_percent);
 
   return free_percent <= 5.0;

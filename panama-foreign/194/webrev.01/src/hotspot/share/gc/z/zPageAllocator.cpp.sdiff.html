<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zPageAllocator.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zNUMA.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zRuntimeWorkers.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zPageAllocator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;

 25 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 26 #include &quot;gc/z/zAddress.inline.hpp&quot;
 27 #include &quot;gc/z/zCollectedHeap.hpp&quot;
 28 #include &quot;gc/z/zFuture.inline.hpp&quot;
 29 #include &quot;gc/z/zGlobals.hpp&quot;
 30 #include &quot;gc/z/zLock.inline.hpp&quot;
 31 #include &quot;gc/z/zPage.inline.hpp&quot;
 32 #include &quot;gc/z/zPageAllocator.hpp&quot;
 33 #include &quot;gc/z/zPageCache.inline.hpp&quot;
 34 #include &quot;gc/z/zSafeDelete.inline.hpp&quot;
 35 #include &quot;gc/z/zStat.hpp&quot;
 36 #include &quot;gc/z/zTask.hpp&quot;
 37 #include &quot;gc/z/zTracer.inline.hpp&quot;
 38 #include &quot;gc/z/zWorkers.hpp&quot;
 39 #include &quot;jfr/jfrEvents.hpp&quot;
 40 #include &quot;runtime/globals.hpp&quot;
 41 #include &quot;runtime/init.hpp&quot;
 42 #include &quot;runtime/java.hpp&quot;
 43 #include &quot;utilities/debug.hpp&quot;
 44 
</pre>
<hr />
<pre>
110     _min_capacity(min_capacity),
111     _max_capacity(max_capacity),
112     _max_reserve(max_reserve),
113     _current_max_capacity(max_capacity),
114     _capacity(0),
115     _used_high(0),
116     _used_low(0),
117     _used(0),
118     _allocated(0),
119     _reclaimed(0),
120     _queue(),
121     _satisfied(),
122     _safe_delete(),
123     _uncommit(false),
124     _initialized(false) {
125 
126   if (!_virtual.is_initialized() || !_physical.is_initialized()) {
127     return;
128   }
129 
<span class="line-modified">130   log_info(gc, init)(&quot;Min Capacity: &quot; SIZE_FORMAT &quot;M&quot;, min_capacity / M);</span>
<span class="line-modified">131   log_info(gc, init)(&quot;Initial Capacity: &quot; SIZE_FORMAT &quot;M&quot;, initial_capacity / M);</span>
<span class="line-modified">132   log_info(gc, init)(&quot;Max Capacity: &quot; SIZE_FORMAT &quot;M&quot;, max_capacity / M);</span>
<span class="line-modified">133   log_info(gc, init)(&quot;Max Reserve: &quot; SIZE_FORMAT &quot;M&quot;, max_reserve / M);</span>
<span class="line-modified">134   log_info(gc, init)(&quot;Pre-touch: %s&quot;, AlwaysPreTouch ? &quot;Enabled&quot; : &quot;Disabled&quot;);</span>
135 
136   // Warn if system limits could stop us from reaching max capacity
137   _physical.warn_commit_limits(max_capacity);
138 
139   // Commit initial capacity
140   _capacity = _physical.commit(initial_capacity);
141   if (_capacity != initial_capacity) {
<span class="line-modified">142     log_error(gc)(&quot;Failed to allocate initial Java heap (&quot; SIZE_FORMAT &quot;M)&quot;, initial_capacity / M);</span>
143     return;
144   }
145 
146   // If uncommit is not explicitly disabled, max capacity is greater than
147   // min capacity, and uncommit is supported by the platform, then we will
148   // try to uncommit unused memory.
149   _uncommit = ZUncommit &amp;&amp; (max_capacity &gt; min_capacity) &amp;&amp; _physical.supports_uncommit();
150   if (_uncommit) {
151     log_info(gc, init)(&quot;Uncommit: Enabled, Delay: &quot; UINTX_FORMAT &quot;s&quot;, ZUncommitDelay);
152   } else {
153     log_info(gc, init)(&quot;Uncommit: Disabled&quot;);
154   }
155 
156   // Pre-map initial capacity
157   prime_cache(workers, initial_capacity);
158 
159   // Successfully initialized
160   _initialized = true;
161 }
162 
</pre>
<hr />
<pre>
363   size += _max_reserve;
364 
365   // Don&#39;t try to increase capacity if enough unused capacity
366   // is available or if current max capacity has been reached.
367   const size_t available = _capacity - _used;
368   if (available &lt; size &amp;&amp; _capacity &lt; _current_max_capacity) {
369     // Try to increase capacity
370     const size_t commit = MIN2(size - available, _current_max_capacity - _capacity);
371     const size_t committed = _physical.commit(commit);
372     _capacity += committed;
373 
374     log_trace(gc, heap)(&quot;Make Available: Size: &quot; SIZE_FORMAT &quot;M, NoReserve: %s, &quot;
375                         &quot;Available: &quot; SIZE_FORMAT &quot;M, Commit: &quot; SIZE_FORMAT &quot;M, &quot;
376                         &quot;Committed: &quot; SIZE_FORMAT &quot;M, Capacity: &quot; SIZE_FORMAT &quot;M&quot;,
377                         size / M, no_reserve ? &quot;True&quot; : &quot;False&quot;, available / M,
378                         commit / M, committed / M, _capacity / M);
379 
380     if (committed != commit) {
381       // Failed, or partly failed, to increase capacity. Adjust current
382       // max capacity to avoid further attempts to increase capacity.
<span class="line-modified">383       log_error(gc)(&quot;Forced to lower max Java heap size from &quot;</span>
<span class="line-modified">384                     SIZE_FORMAT &quot;M(%.0f%%) to &quot; SIZE_FORMAT &quot;M(%.0f%%)&quot;,</span>
<span class="line-modified">385                     _current_max_capacity / M, percent_of(_current_max_capacity, _max_capacity),</span>
<span class="line-modified">386                     _capacity / M, percent_of(_capacity, _max_capacity));</span>
387 
388       _current_max_capacity = _capacity;
389     }
390   }
391 
392   if (!no_reserve) {
393     size -= _max_reserve;
394   }
395 
396   const size_t new_available = _capacity - _used;
397   return new_available &gt;= size;
398 }
399 
400 void ZPageAllocator::ensure_uncached_available(size_t size) {
401   assert(_capacity - _used &gt;= size, &quot;Invalid size&quot;);
402   const size_t uncached_available = _capacity - _used - _cache.available();
403   if (size &gt; uncached_available) {
404     flush_cache_for_allocation(size - uncached_available);
405   }
406 }
</pre>
</td>
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
<span class="line-added"> 25 #include &quot;gc/shared/gcLogPrecious.hpp&quot;</span>
 26 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 27 #include &quot;gc/z/zAddress.inline.hpp&quot;
 28 #include &quot;gc/z/zCollectedHeap.hpp&quot;
 29 #include &quot;gc/z/zFuture.inline.hpp&quot;
 30 #include &quot;gc/z/zGlobals.hpp&quot;
 31 #include &quot;gc/z/zLock.inline.hpp&quot;
 32 #include &quot;gc/z/zPage.inline.hpp&quot;
 33 #include &quot;gc/z/zPageAllocator.hpp&quot;
 34 #include &quot;gc/z/zPageCache.inline.hpp&quot;
 35 #include &quot;gc/z/zSafeDelete.inline.hpp&quot;
 36 #include &quot;gc/z/zStat.hpp&quot;
 37 #include &quot;gc/z/zTask.hpp&quot;
 38 #include &quot;gc/z/zTracer.inline.hpp&quot;
 39 #include &quot;gc/z/zWorkers.hpp&quot;
 40 #include &quot;jfr/jfrEvents.hpp&quot;
 41 #include &quot;runtime/globals.hpp&quot;
 42 #include &quot;runtime/init.hpp&quot;
 43 #include &quot;runtime/java.hpp&quot;
 44 #include &quot;utilities/debug.hpp&quot;
 45 
</pre>
<hr />
<pre>
111     _min_capacity(min_capacity),
112     _max_capacity(max_capacity),
113     _max_reserve(max_reserve),
114     _current_max_capacity(max_capacity),
115     _capacity(0),
116     _used_high(0),
117     _used_low(0),
118     _used(0),
119     _allocated(0),
120     _reclaimed(0),
121     _queue(),
122     _satisfied(),
123     _safe_delete(),
124     _uncommit(false),
125     _initialized(false) {
126 
127   if (!_virtual.is_initialized() || !_physical.is_initialized()) {
128     return;
129   }
130 
<span class="line-modified">131   log_info_p(gc, init)(&quot;Min Capacity: &quot; SIZE_FORMAT &quot;M&quot;, min_capacity / M);</span>
<span class="line-modified">132   log_info_p(gc, init)(&quot;Initial Capacity: &quot; SIZE_FORMAT &quot;M&quot;, initial_capacity / M);</span>
<span class="line-modified">133   log_info_p(gc, init)(&quot;Max Capacity: &quot; SIZE_FORMAT &quot;M&quot;, max_capacity / M);</span>
<span class="line-modified">134   log_info_p(gc, init)(&quot;Max Reserve: &quot; SIZE_FORMAT &quot;M&quot;, max_reserve / M);</span>
<span class="line-modified">135   log_info_p(gc, init)(&quot;Pre-touch: %s&quot;, AlwaysPreTouch ? &quot;Enabled&quot; : &quot;Disabled&quot;);</span>
136 
137   // Warn if system limits could stop us from reaching max capacity
138   _physical.warn_commit_limits(max_capacity);
139 
140   // Commit initial capacity
141   _capacity = _physical.commit(initial_capacity);
142   if (_capacity != initial_capacity) {
<span class="line-modified">143     log_error_p(gc)(&quot;Failed to allocate initial Java heap (&quot; SIZE_FORMAT &quot;M)&quot;, initial_capacity / M);</span>
144     return;
145   }
146 
147   // If uncommit is not explicitly disabled, max capacity is greater than
148   // min capacity, and uncommit is supported by the platform, then we will
149   // try to uncommit unused memory.
150   _uncommit = ZUncommit &amp;&amp; (max_capacity &gt; min_capacity) &amp;&amp; _physical.supports_uncommit();
151   if (_uncommit) {
152     log_info(gc, init)(&quot;Uncommit: Enabled, Delay: &quot; UINTX_FORMAT &quot;s&quot;, ZUncommitDelay);
153   } else {
154     log_info(gc, init)(&quot;Uncommit: Disabled&quot;);
155   }
156 
157   // Pre-map initial capacity
158   prime_cache(workers, initial_capacity);
159 
160   // Successfully initialized
161   _initialized = true;
162 }
163 
</pre>
<hr />
<pre>
364   size += _max_reserve;
365 
366   // Don&#39;t try to increase capacity if enough unused capacity
367   // is available or if current max capacity has been reached.
368   const size_t available = _capacity - _used;
369   if (available &lt; size &amp;&amp; _capacity &lt; _current_max_capacity) {
370     // Try to increase capacity
371     const size_t commit = MIN2(size - available, _current_max_capacity - _capacity);
372     const size_t committed = _physical.commit(commit);
373     _capacity += committed;
374 
375     log_trace(gc, heap)(&quot;Make Available: Size: &quot; SIZE_FORMAT &quot;M, NoReserve: %s, &quot;
376                         &quot;Available: &quot; SIZE_FORMAT &quot;M, Commit: &quot; SIZE_FORMAT &quot;M, &quot;
377                         &quot;Committed: &quot; SIZE_FORMAT &quot;M, Capacity: &quot; SIZE_FORMAT &quot;M&quot;,
378                         size / M, no_reserve ? &quot;True&quot; : &quot;False&quot;, available / M,
379                         commit / M, committed / M, _capacity / M);
380 
381     if (committed != commit) {
382       // Failed, or partly failed, to increase capacity. Adjust current
383       // max capacity to avoid further attempts to increase capacity.
<span class="line-modified">384       log_error_p(gc)(&quot;Forced to lower max Java heap size from &quot;</span>
<span class="line-modified">385                       SIZE_FORMAT &quot;M(%.0f%%) to &quot; SIZE_FORMAT &quot;M(%.0f%%)&quot;,</span>
<span class="line-modified">386                       _current_max_capacity / M, percent_of(_current_max_capacity, _max_capacity),</span>
<span class="line-modified">387                       _capacity / M, percent_of(_capacity, _max_capacity));</span>
388 
389       _current_max_capacity = _capacity;
390     }
391   }
392 
393   if (!no_reserve) {
394     size -= _max_reserve;
395   }
396 
397   const size_t new_available = _capacity - _used;
398   return new_available &gt;= size;
399 }
400 
401 void ZPageAllocator::ensure_uncached_available(size_t size) {
402   assert(_capacity - _used &gt;= size, &quot;Invalid size&quot;);
403   const size_t uncached_available = _capacity - _used - _cache.available();
404   if (size &gt; uncached_available) {
405     flush_cache_for_allocation(size - uncached_available);
406   }
407 }
</pre>
</td>
</tr>
</table>
<center><a href="zNUMA.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zRuntimeWorkers.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
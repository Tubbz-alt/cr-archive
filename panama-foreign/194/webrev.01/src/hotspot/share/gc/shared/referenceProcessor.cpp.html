<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/shared/referenceProcessor.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/systemDictionary.hpp&quot;
  28 #include &quot;gc/shared/collectedHeap.hpp&quot;
  29 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  30 #include &quot;gc/shared/gcTimer.hpp&quot;
  31 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  32 #include &quot;gc/shared/referencePolicy.hpp&quot;
  33 #include &quot;gc/shared/referenceProcessor.inline.hpp&quot;
  34 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/access.inline.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;runtime/java.hpp&quot;
  42 
  43 ReferencePolicy* ReferenceProcessor::_always_clear_soft_ref_policy = NULL;
  44 ReferencePolicy* ReferenceProcessor::_default_soft_ref_policy      = NULL;
  45 jlong            ReferenceProcessor::_soft_ref_timestamp_clock = 0;
  46 
  47 void referenceProcessor_init() {
  48   ReferenceProcessor::init_statics();
  49 }
  50 
  51 void ReferenceProcessor::init_statics() {
  52   // We need a monotonically non-decreasing time in ms but
  53   // os::javaTimeMillis() does not guarantee monotonicity.
  54   jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
  55 
  56   // Initialize the soft ref timestamp clock.
  57   _soft_ref_timestamp_clock = now;
  58   // Also update the soft ref clock in j.l.r.SoftReference
  59   java_lang_ref_SoftReference::set_clock(_soft_ref_timestamp_clock);
  60 
  61   _always_clear_soft_ref_policy = new AlwaysClearPolicy();
  62   if (is_server_compilation_mode_vm()) {
  63     _default_soft_ref_policy = new LRUMaxHeapPolicy();
  64   } else {
  65     _default_soft_ref_policy = new LRUCurrentHeapPolicy();
  66   }
  67   guarantee(RefDiscoveryPolicy == ReferenceBasedDiscovery ||
  68             RefDiscoveryPolicy == ReferentBasedDiscovery,
  69             &quot;Unrecognized RefDiscoveryPolicy&quot;);
  70 }
  71 
  72 void ReferenceProcessor::enable_discovery(bool check_no_refs) {
  73 #ifdef ASSERT
  74   // Verify that we&#39;re not currently discovering refs
  75   assert(!_discovering_refs, &quot;nested call?&quot;);
  76 
  77   if (check_no_refs) {
  78     // Verify that the discovered lists are empty
  79     verify_no_references_recorded();
  80   }
  81 #endif // ASSERT
  82 
  83   // Someone could have modified the value of the static
  84   // field in the j.l.r.SoftReference class that holds the
  85   // soft reference timestamp clock using reflection or
  86   // Unsafe between GCs. Unconditionally update the static
  87   // field in ReferenceProcessor here so that we use the new
  88   // value during reference discovery.
  89 
  90   _soft_ref_timestamp_clock = java_lang_ref_SoftReference::clock();
  91   _discovering_refs = true;
  92 }
  93 
  94 ReferenceProcessor::ReferenceProcessor(BoolObjectClosure* is_subject_to_discovery,
  95                                        bool      mt_processing,
  96                                        uint      mt_processing_degree,
  97                                        bool      mt_discovery,
  98                                        uint      mt_discovery_degree,
  99                                        bool      atomic_discovery,
 100                                        BoolObjectClosure* is_alive_non_header,
 101                                        bool      adjust_no_of_processing_threads)  :
 102   _is_subject_to_discovery(is_subject_to_discovery),
 103   _discovering_refs(false),
 104   _enqueuing_is_done(false),
 105   _processing_is_mt(mt_processing),
 106   _next_id(0),
 107   _adjust_no_of_processing_threads(adjust_no_of_processing_threads),
 108   _is_alive_non_header(is_alive_non_header)
 109 {
 110   assert(is_subject_to_discovery != NULL, &quot;must be set&quot;);
 111 
 112   _discovery_is_atomic = atomic_discovery;
 113   _discovery_is_mt     = mt_discovery;
 114   _num_queues          = MAX2(1U, mt_processing_degree);
 115   _max_num_queues      = MAX2(_num_queues, mt_discovery_degree);
 116   _discovered_refs     = NEW_C_HEAP_ARRAY(DiscoveredList,
 117             _max_num_queues * number_of_subclasses_of_ref(), mtGC);
 118 
 119   _discoveredSoftRefs    = &amp;_discovered_refs[0];
 120   _discoveredWeakRefs    = &amp;_discoveredSoftRefs[_max_num_queues];
 121   _discoveredFinalRefs   = &amp;_discoveredWeakRefs[_max_num_queues];
 122   _discoveredPhantomRefs = &amp;_discoveredFinalRefs[_max_num_queues];
 123 
 124   // Initialize all entries to NULL
 125   for (uint i = 0; i &lt; _max_num_queues * number_of_subclasses_of_ref(); i++) {
 126     _discovered_refs[i].clear();
 127   }
 128 
 129   setup_policy(false /* default soft ref policy */);
 130 }
 131 
 132 #ifndef PRODUCT
 133 void ReferenceProcessor::verify_no_references_recorded() {
 134   guarantee(!_discovering_refs, &quot;Discovering refs?&quot;);
 135   for (uint i = 0; i &lt; _max_num_queues * number_of_subclasses_of_ref(); i++) {
 136     guarantee(_discovered_refs[i].is_empty(),
 137               &quot;Found non-empty discovered list at %u&quot;, i);
 138   }
 139 }
 140 #endif
 141 
 142 void ReferenceProcessor::weak_oops_do(OopClosure* f) {
 143   for (uint i = 0; i &lt; _max_num_queues * number_of_subclasses_of_ref(); i++) {
 144     if (UseCompressedOops) {
 145       f-&gt;do_oop((narrowOop*)_discovered_refs[i].adr_head());
 146     } else {
 147       f-&gt;do_oop((oop*)_discovered_refs[i].adr_head());
 148     }
 149   }
 150 }
 151 
 152 void ReferenceProcessor::update_soft_ref_master_clock() {
 153   // Update (advance) the soft ref master clock field. This must be done
 154   // after processing the soft ref list.
 155 
 156   // We need a monotonically non-decreasing time in ms but
 157   // os::javaTimeMillis() does not guarantee monotonicity.
 158   jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
 159   jlong soft_ref_clock = java_lang_ref_SoftReference::clock();
 160   assert(soft_ref_clock == _soft_ref_timestamp_clock, &quot;soft ref clocks out of sync&quot;);
 161 
 162   NOT_PRODUCT(
 163   if (now &lt; _soft_ref_timestamp_clock) {
 164     log_warning(gc)(&quot;time warp: &quot; JLONG_FORMAT &quot; to &quot; JLONG_FORMAT,
 165                     _soft_ref_timestamp_clock, now);
 166   }
 167   )
 168   // The values of now and _soft_ref_timestamp_clock are set using
 169   // javaTimeNanos(), which is guaranteed to be monotonically
 170   // non-decreasing provided the underlying platform provides such
 171   // a time source (and it is bug free).
 172   // In product mode, however, protect ourselves from non-monotonicity.
 173   if (now &gt; _soft_ref_timestamp_clock) {
 174     _soft_ref_timestamp_clock = now;
 175     java_lang_ref_SoftReference::set_clock(now);
 176   }
 177   // Else leave clock stalled at its old value until time progresses
 178   // past clock value.
 179 }
 180 
 181 size_t ReferenceProcessor::total_count(DiscoveredList lists[]) const {
 182   size_t total = 0;
 183   for (uint i = 0; i &lt; _max_num_queues; ++i) {
 184     total += lists[i].length();
 185   }
 186   return total;
 187 }
 188 
 189 #ifdef ASSERT
 190 void ReferenceProcessor::verify_total_count_zero(DiscoveredList lists[], const char* type) {
 191   size_t count = total_count(lists);
 192   assert(count == 0, &quot;%ss must be empty but has &quot; SIZE_FORMAT &quot; elements&quot;, type, count);
 193 }
 194 #endif
 195 
 196 ReferenceProcessorStats ReferenceProcessor::process_discovered_references(
 197   BoolObjectClosure*            is_alive,
 198   OopClosure*                   keep_alive,
 199   VoidClosure*                  complete_gc,
 200   AbstractRefProcTaskExecutor*  task_executor,
 201   ReferenceProcessorPhaseTimes* phase_times) {
 202 
 203   double start_time = os::elapsedTime();
 204 
 205   assert(!enqueuing_is_done(), &quot;If here enqueuing should not be complete&quot;);
 206   // Stop treating discovered references specially.
 207   disable_discovery();
 208 
 209   // If discovery was concurrent, someone could have modified
 210   // the value of the static field in the j.l.r.SoftReference
 211   // class that holds the soft reference timestamp clock using
 212   // reflection or Unsafe between when discovery was enabled and
 213   // now. Unconditionally update the static field in ReferenceProcessor
 214   // here so that we use the new value during processing of the
 215   // discovered soft refs.
 216 
 217   _soft_ref_timestamp_clock = java_lang_ref_SoftReference::clock();
 218 
 219   ReferenceProcessorStats stats(total_count(_discoveredSoftRefs),
 220                                 total_count(_discoveredWeakRefs),
 221                                 total_count(_discoveredFinalRefs),
 222                                 total_count(_discoveredPhantomRefs));
 223 
 224   {
 225     RefProcTotalPhaseTimesTracker tt(RefPhase1, phase_times, this);
 226     process_soft_ref_reconsider(is_alive, keep_alive, complete_gc,
 227                                 task_executor, phase_times);
 228   }
 229 
 230   update_soft_ref_master_clock();
 231 
 232   {
 233     RefProcTotalPhaseTimesTracker tt(RefPhase2, phase_times, this);
 234     process_soft_weak_final_refs(is_alive, keep_alive, complete_gc, task_executor, phase_times);
 235   }
 236 
 237   {
 238     RefProcTotalPhaseTimesTracker tt(RefPhase3, phase_times, this);
 239     process_final_keep_alive(keep_alive, complete_gc, task_executor, phase_times);
 240   }
 241 
 242   {
 243     RefProcTotalPhaseTimesTracker tt(RefPhase4, phase_times, this);
 244     process_phantom_refs(is_alive, keep_alive, complete_gc, task_executor, phase_times);
 245   }
 246 
 247   if (task_executor != NULL) {
 248     // Record the work done by the parallel workers.
 249     task_executor-&gt;set_single_threaded_mode();
 250   }
 251 
 252   phase_times-&gt;set_total_time_ms((os::elapsedTime() - start_time) * 1000);
 253 
 254   return stats;
 255 }
 256 
 257 void DiscoveredListIterator::load_ptrs(DEBUG_ONLY(bool allow_null_referent)) {
 258   _current_discovered_addr = java_lang_ref_Reference::discovered_addr_raw(_current_discovered);
 259   oop discovered = java_lang_ref_Reference::discovered(_current_discovered);
 260   assert(_current_discovered_addr &amp;&amp; oopDesc::is_oop_or_null(discovered),
 261          &quot;Expected an oop or NULL for discovered field at &quot; PTR_FORMAT, p2i(discovered));
 262   _next_discovered = discovered;
 263 
 264   _referent_addr = java_lang_ref_Reference::referent_addr_raw(_current_discovered);
 265   _referent = java_lang_ref_Reference::referent(_current_discovered);
 266   assert(Universe::heap()-&gt;is_in_or_null(_referent),
 267          &quot;Wrong oop found in java.lang.Reference object&quot;);
 268   assert(allow_null_referent ?
 269              oopDesc::is_oop_or_null(_referent)
 270            : oopDesc::is_oop(_referent),
 271          &quot;Expected an oop%s for referent field at &quot; PTR_FORMAT,
 272          (allow_null_referent ? &quot; or NULL&quot; : &quot;&quot;),
 273          p2i(_referent));
 274 }
 275 
 276 void DiscoveredListIterator::remove() {
 277   assert(oopDesc::is_oop(_current_discovered), &quot;Dropping a bad reference&quot;);
 278   RawAccess&lt;&gt;::oop_store(_current_discovered_addr, oop(NULL));
 279 
 280   // First _prev_next ref actually points into DiscoveredList (gross).
 281   oop new_next;
 282   if (_next_discovered == _current_discovered) {
 283     // At the end of the list, we should make _prev point to itself.
 284     // If _ref is the first ref, then _prev_next will be in the DiscoveredList,
 285     // and _prev will be NULL.
 286     new_next = _prev_discovered;
 287   } else {
 288     new_next = _next_discovered;
 289   }
 290   // Remove Reference object from discovered list. Note that G1 does not need a
 291   // pre-barrier here because we know the Reference has already been found/marked,
 292   // that&#39;s how it ended up in the discovered list in the first place.
 293   RawAccess&lt;&gt;::oop_store(_prev_discovered_addr, new_next);
 294   _removed++;
 295   _refs_list.dec_length(1);
 296 }
 297 
 298 void DiscoveredListIterator::clear_referent() {
 299   RawAccess&lt;&gt;::oop_store(_referent_addr, oop(NULL));
 300 }
 301 
 302 void DiscoveredListIterator::enqueue() {
 303   HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_store_at(_current_discovered,
 304                                             java_lang_ref_Reference::discovered_offset(),
 305                                             _next_discovered);
 306 }
 307 
 308 void DiscoveredListIterator::complete_enqueue() {
 309   if (_prev_discovered != NULL) {
 310     // This is the last object.
 311     // Swap refs_list into pending list and set obj&#39;s
 312     // discovered to what we read from the pending list.
 313     oop old = Universe::swap_reference_pending_list(_refs_list.head());
 314     HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_store_at(_prev_discovered, java_lang_ref_Reference::discovered_offset(), old);
 315   }
 316 }
 317 
 318 inline void log_dropped_ref(const DiscoveredListIterator&amp; iter, const char* reason) {
 319   if (log_develop_is_enabled(Trace, gc, ref)) {
 320     ResourceMark rm;
 321     log_develop_trace(gc, ref)(&quot;Dropping %s reference &quot; PTR_FORMAT &quot;: %s&quot;,
 322                                reason, p2i(iter.obj()),
 323                                iter.obj()-&gt;klass()-&gt;internal_name());
 324   }
 325 }
 326 
 327 inline void log_enqueued_ref(const DiscoveredListIterator&amp; iter, const char* reason) {
 328   if (log_develop_is_enabled(Trace, gc, ref)) {
 329     ResourceMark rm;
 330     log_develop_trace(gc, ref)(&quot;Enqueue %s reference (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
 331                                reason, p2i(iter.obj()), iter.obj()-&gt;klass()-&gt;internal_name());
 332   }
 333   assert(oopDesc::is_oop(iter.obj()), &quot;Adding a bad reference&quot;);
 334 }
 335 
 336 size_t ReferenceProcessor::process_soft_ref_reconsider_work(DiscoveredList&amp;    refs_list,
 337                                                             ReferencePolicy*   policy,
 338                                                             BoolObjectClosure* is_alive,
 339                                                             OopClosure*        keep_alive,
 340                                                             VoidClosure*       complete_gc) {
 341   assert(policy != NULL, &quot;Must have a non-NULL policy&quot;);
 342   DiscoveredListIterator iter(refs_list, keep_alive, is_alive);
 343   // Decide which softly reachable refs should be kept alive.
 344   while (iter.has_next()) {
 345     iter.load_ptrs(DEBUG_ONLY(!discovery_is_atomic() /* allow_null_referent */));
 346     bool referent_is_dead = (iter.referent() != NULL) &amp;&amp; !iter.is_referent_alive();
 347     if (referent_is_dead &amp;&amp;
 348         !policy-&gt;should_clear_reference(iter.obj(), _soft_ref_timestamp_clock)) {
 349       log_dropped_ref(iter, &quot;by policy&quot;);
 350       // Remove Reference object from list
 351       iter.remove();
 352       // keep the referent around
 353       iter.make_referent_alive();
 354       iter.move_to_next();
 355     } else {
 356       iter.next();
 357     }
 358   }
 359   // Close the reachable set
 360   complete_gc-&gt;do_void();
 361 
 362   log_develop_trace(gc, ref)(&quot; Dropped &quot; SIZE_FORMAT &quot; dead Refs out of &quot; SIZE_FORMAT &quot; discovered Refs by policy, from list &quot; INTPTR_FORMAT,
 363                              iter.removed(), iter.processed(), p2i(&amp;refs_list));
 364   return iter.removed();
 365 }
 366 
 367 size_t ReferenceProcessor::process_soft_weak_final_refs_work(DiscoveredList&amp;    refs_list,
 368                                                              BoolObjectClosure* is_alive,
 369                                                              OopClosure*        keep_alive,
 370                                                              bool               do_enqueue_and_clear) {
 371   DiscoveredListIterator iter(refs_list, keep_alive, is_alive);
 372   while (iter.has_next()) {
 373     iter.load_ptrs(DEBUG_ONLY(!discovery_is_atomic() /* allow_null_referent */));
 374     if (iter.referent() == NULL) {
 375       // Reference has been cleared since discovery; only possible if
 376       // discovery is not atomic (checked by load_ptrs).  Remove
 377       // reference from list.
 378       log_dropped_ref(iter, &quot;cleared&quot;);
 379       iter.remove();
 380       iter.move_to_next();
 381     } else if (iter.is_referent_alive()) {
 382       // The referent is reachable after all.
 383       // Remove reference from list.
 384       log_dropped_ref(iter, &quot;reachable&quot;);
 385       iter.remove();
 386       // Update the referent pointer as necessary.  Note that this
 387       // should not entail any recursive marking because the
 388       // referent must already have been traversed.
 389       iter.make_referent_alive();
 390       iter.move_to_next();
 391     } else {
 392       if (do_enqueue_and_clear) {
 393         iter.clear_referent();
 394         iter.enqueue();
 395         log_enqueued_ref(iter, &quot;cleared&quot;);
 396       }
 397       // Keep in discovered list
 398       iter.next();
 399     }
 400   }
 401   if (do_enqueue_and_clear) {
 402     iter.complete_enqueue();
 403     refs_list.clear();
 404   }
 405 
 406   log_develop_trace(gc, ref)(&quot; Dropped &quot; SIZE_FORMAT &quot; active Refs out of &quot; SIZE_FORMAT
 407                              &quot; Refs in discovered list &quot; INTPTR_FORMAT,
 408                              iter.removed(), iter.processed(), p2i(&amp;refs_list));
 409   return iter.removed();
 410 }
 411 
 412 size_t ReferenceProcessor::process_final_keep_alive_work(DiscoveredList&amp; refs_list,
 413                                                          OopClosure*     keep_alive,
 414                                                          VoidClosure*    complete_gc) {
 415   DiscoveredListIterator iter(refs_list, keep_alive, NULL);
 416   while (iter.has_next()) {
 417     iter.load_ptrs(DEBUG_ONLY(false /* allow_null_referent */));
 418     // keep the referent and followers around
 419     iter.make_referent_alive();
 420 
 421     // Self-loop next, to mark the FinalReference not active.
 422     assert(java_lang_ref_Reference::next(iter.obj()) == NULL, &quot;enqueued FinalReference&quot;);
 423     java_lang_ref_Reference::set_next_raw(iter.obj(), iter.obj());
 424 
 425     iter.enqueue();
 426     log_enqueued_ref(iter, &quot;Final&quot;);
 427     iter.next();
 428   }
 429   iter.complete_enqueue();
 430   // Close the reachable set
 431   complete_gc-&gt;do_void();
 432   refs_list.clear();
 433 
 434   assert(iter.removed() == 0, &quot;This phase does not remove anything.&quot;);
 435   return iter.removed();
 436 }
 437 
 438 size_t ReferenceProcessor::process_phantom_refs_work(DiscoveredList&amp;    refs_list,
 439                                           BoolObjectClosure* is_alive,
 440                                           OopClosure*        keep_alive,
 441                                           VoidClosure*       complete_gc) {
 442   DiscoveredListIterator iter(refs_list, keep_alive, is_alive);
 443   while (iter.has_next()) {
 444     iter.load_ptrs(DEBUG_ONLY(!discovery_is_atomic() /* allow_null_referent */));
 445 
 446     oop const referent = iter.referent();
 447 
 448     if (referent == NULL || iter.is_referent_alive()) {
 449       iter.make_referent_alive();
 450       iter.remove();
 451       iter.move_to_next();
 452     } else {
 453       iter.clear_referent();
 454       iter.enqueue();
 455       log_enqueued_ref(iter, &quot;cleared Phantom&quot;);
 456       iter.next();
 457     }
 458   }
 459   iter.complete_enqueue();
 460   // Close the reachable set; needed for collectors which keep_alive_closure do
 461   // not immediately complete their work.
 462   complete_gc-&gt;do_void();
 463   refs_list.clear();
 464 
 465   return iter.removed();
 466 }
 467 
 468 void
 469 ReferenceProcessor::clear_discovered_references(DiscoveredList&amp; refs_list) {
 470   oop obj = NULL;
 471   oop next = refs_list.head();
 472   while (next != obj) {
 473     obj = next;
 474     next = java_lang_ref_Reference::discovered(obj);
 475     java_lang_ref_Reference::set_discovered_raw(obj, NULL);
 476   }
 477   refs_list.clear();
 478 }
 479 
 480 void ReferenceProcessor::abandon_partial_discovery() {
 481   // loop over the lists
 482   for (uint i = 0; i &lt; _max_num_queues * number_of_subclasses_of_ref(); i++) {
 483     if ((i % _max_num_queues) == 0) {
 484       log_develop_trace(gc, ref)(&quot;Abandoning %s discovered list&quot;, list_name(i));
 485     }
 486     clear_discovered_references(_discovered_refs[i]);
 487   }
 488 }
 489 
 490 size_t ReferenceProcessor::total_reference_count(ReferenceType type) const {
 491   DiscoveredList* list = NULL;
 492 
 493   switch (type) {
 494     case REF_SOFT:
 495       list = _discoveredSoftRefs;
 496       break;
 497     case REF_WEAK:
 498       list = _discoveredWeakRefs;
 499       break;
 500     case REF_FINAL:
 501       list = _discoveredFinalRefs;
 502       break;
 503     case REF_PHANTOM:
 504       list = _discoveredPhantomRefs;
 505       break;
 506     case REF_OTHER:
 507     case REF_NONE:
 508     default:
 509       ShouldNotReachHere();
 510   }
 511   return total_count(list);
 512 }
 513 
 514 class RefProcPhase1Task : public AbstractRefProcTaskExecutor::ProcessTask {
 515 public:
 516   RefProcPhase1Task(ReferenceProcessor&amp;           ref_processor,
 517                     ReferenceProcessorPhaseTimes* phase_times,
 518                     ReferencePolicy*              policy)
 519     : ProcessTask(ref_processor, true /* marks_oops_alive */, phase_times),
 520       _policy(policy) { }
 521 
 522   virtual void work(uint worker_id,
 523                     BoolObjectClosure&amp; is_alive,
 524                     OopClosure&amp; keep_alive,
 525                     VoidClosure&amp; complete_gc)
 526   {
 527     RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::SoftRefSubPhase1, _phase_times, worker_id);
 528     size_t const removed = _ref_processor.process_soft_ref_reconsider_work(_ref_processor._discoveredSoftRefs[worker_id],
 529                                                                            _policy,
 530                                                                            &amp;is_alive,
 531                                                                            &amp;keep_alive,
 532                                                                            &amp;complete_gc);
 533     _phase_times-&gt;add_ref_cleared(REF_SOFT, removed);
 534   }
 535 private:
 536   ReferencePolicy* _policy;
 537 };
 538 
 539 class RefProcPhase2Task: public AbstractRefProcTaskExecutor::ProcessTask {
 540   void run_phase2(uint worker_id,
 541                   DiscoveredList list[],
 542                   BoolObjectClosure&amp; is_alive,
 543                   OopClosure&amp; keep_alive,
 544                   bool do_enqueue_and_clear,
 545                   ReferenceType ref_type) {
 546     size_t const removed = _ref_processor.process_soft_weak_final_refs_work(list[worker_id],
 547                                                                             &amp;is_alive,
 548                                                                             &amp;keep_alive,
 549                                                                             do_enqueue_and_clear);
 550     _phase_times-&gt;add_ref_cleared(ref_type, removed);
 551   }
 552 
 553 public:
 554   RefProcPhase2Task(ReferenceProcessor&amp; ref_processor,
 555                     ReferenceProcessorPhaseTimes* phase_times)
 556     : ProcessTask(ref_processor, false /* marks_oops_alive */, phase_times) { }
 557 
 558   virtual void work(uint worker_id,
 559                     BoolObjectClosure&amp; is_alive,
 560                     OopClosure&amp; keep_alive,
 561                     VoidClosure&amp; complete_gc) {
 562     RefProcWorkerTimeTracker t(_phase_times-&gt;phase2_worker_time_sec(), worker_id);
 563     {
 564       RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::SoftRefSubPhase2, _phase_times, worker_id);
 565       run_phase2(worker_id, _ref_processor._discoveredSoftRefs, is_alive, keep_alive, true /* do_enqueue_and_clear */, REF_SOFT);
 566     }
 567     {
 568       RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::WeakRefSubPhase2, _phase_times, worker_id);
 569       run_phase2(worker_id, _ref_processor._discoveredWeakRefs, is_alive, keep_alive, true /* do_enqueue_and_clear */, REF_WEAK);
 570     }
 571     {
 572       RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::FinalRefSubPhase2, _phase_times, worker_id);
 573       run_phase2(worker_id, _ref_processor._discoveredFinalRefs, is_alive, keep_alive, false /* do_enqueue_and_clear */, REF_FINAL);
 574     }
 575     // Close the reachable set; needed for collectors which keep_alive_closure do
 576     // not immediately complete their work.
 577     complete_gc.do_void();
 578   }
 579 };
 580 
 581 class RefProcPhase3Task: public AbstractRefProcTaskExecutor::ProcessTask {
 582 public:
 583   RefProcPhase3Task(ReferenceProcessor&amp;           ref_processor,
 584                     ReferenceProcessorPhaseTimes* phase_times)
 585     : ProcessTask(ref_processor, true /* marks_oops_alive */, phase_times) { }
 586 
 587   virtual void work(uint worker_id,
 588                     BoolObjectClosure&amp; is_alive,
 589                     OopClosure&amp; keep_alive,
 590                     VoidClosure&amp; complete_gc)
 591   {
 592     RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::FinalRefSubPhase3, _phase_times, worker_id);
 593     _ref_processor.process_final_keep_alive_work(_ref_processor._discoveredFinalRefs[worker_id], &amp;keep_alive, &amp;complete_gc);
 594   }
 595 };
 596 
 597 class RefProcPhase4Task: public AbstractRefProcTaskExecutor::ProcessTask {
 598 public:
 599   RefProcPhase4Task(ReferenceProcessor&amp;           ref_processor,
 600                     ReferenceProcessorPhaseTimes* phase_times)
 601     : ProcessTask(ref_processor, false /* marks_oops_alive */, phase_times) { }
 602 
 603   virtual void work(uint worker_id,
 604                     BoolObjectClosure&amp; is_alive,
 605                     OopClosure&amp; keep_alive,
 606                     VoidClosure&amp; complete_gc)
 607   {
 608     RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::PhantomRefSubPhase4, _phase_times, worker_id);
 609     size_t const removed = _ref_processor.process_phantom_refs_work(_ref_processor._discoveredPhantomRefs[worker_id],
 610                                                                     &amp;is_alive,
 611                                                                     &amp;keep_alive,
 612                                                                     &amp;complete_gc);
 613     _phase_times-&gt;add_ref_cleared(REF_PHANTOM, removed);
 614   }
 615 };
 616 
 617 void ReferenceProcessor::log_reflist(const char* prefix, DiscoveredList list[], uint num_active_queues) {
 618   LogTarget(Trace, gc, ref) lt;
 619 
 620   if (!lt.is_enabled()) {
 621     return;
 622   }
 623 
 624   size_t total = 0;
 625 
 626   LogStream ls(lt);
 627   ls.print(&quot;%s&quot;, prefix);
 628   for (uint i = 0; i &lt; num_active_queues; i++) {
 629     ls.print(SIZE_FORMAT &quot; &quot;, list[i].length());
 630     total += list[i].length();
 631   }
 632   ls.print_cr(&quot;(&quot; SIZE_FORMAT &quot;)&quot;, total);
 633 }
 634 
 635 #ifndef PRODUCT
 636 void ReferenceProcessor::log_reflist_counts(DiscoveredList ref_lists[], uint num_active_queues) {
 637   if (!log_is_enabled(Trace, gc, ref)) {
 638     return;
 639   }
 640 
 641   log_reflist(&quot;&quot;, ref_lists, num_active_queues);
 642 #ifdef ASSERT
 643   for (uint i = num_active_queues; i &lt; _max_num_queues; i++) {
 644     assert(ref_lists[i].length() == 0, SIZE_FORMAT &quot; unexpected References in %u&quot;,
 645            ref_lists[i].length(), i);
 646   }
 647 #endif
 648 }
 649 #endif
 650 
 651 void ReferenceProcessor::set_active_mt_degree(uint v) {
 652   _num_queues = v;
 653   _next_id = 0;
 654 }
 655 
 656 bool ReferenceProcessor::need_balance_queues(DiscoveredList refs_lists[]) {
 657   assert(_processing_is_mt, &quot;why balance non-mt processing?&quot;);
 658   // _num_queues is the processing degree.  Only list entries up to
 659   // _num_queues will be processed, so any non-empty lists beyond
 660   // that must be redistributed to lists in that range.  Even if not
 661   // needed for that, balancing may be desirable to eliminate poor
 662   // distribution of references among the lists.
 663   if (ParallelRefProcBalancingEnabled) {
 664     return true;                // Configuration says do it.
 665   } else {
 666     // Configuration says don&#39;t balance, but if there are non-empty
 667     // lists beyond the processing degree, then must ignore the
 668     // configuration and balance anyway.
 669     for (uint i = _num_queues; i &lt; _max_num_queues; ++i) {
 670       if (!refs_lists[i].is_empty()) {
 671         return true;            // Must balance despite configuration.
 672       }
 673     }
 674     return false;               // Safe to obey configuration and not balance.
 675   }
 676 }
 677 
 678 void ReferenceProcessor::maybe_balance_queues(DiscoveredList refs_lists[]) {
 679   assert(_processing_is_mt, &quot;Should not call this otherwise&quot;);
 680   if (need_balance_queues(refs_lists)) {
 681     balance_queues(refs_lists);
 682   }
 683 }
 684 
 685 // Balances reference queues.
 686 // Move entries from all queues[0, 1, ..., _max_num_q-1] to
 687 // queues[0, 1, ..., _num_q-1] because only the first _num_q
 688 // corresponding to the active workers will be processed.
 689 void ReferenceProcessor::balance_queues(DiscoveredList ref_lists[])
 690 {
 691   // calculate total length
 692   size_t total_refs = 0;
 693   log_develop_trace(gc, ref)(&quot;Balance ref_lists &quot;);
 694 
 695   log_reflist_counts(ref_lists, _max_num_queues);
 696 
 697   for (uint i = 0; i &lt; _max_num_queues; ++i) {
 698     total_refs += ref_lists[i].length();
 699   }
 700   size_t avg_refs = total_refs / _num_queues + 1;
 701   uint to_idx = 0;
 702   for (uint from_idx = 0; from_idx &lt; _max_num_queues; from_idx++) {
 703     bool move_all = false;
 704     if (from_idx &gt;= _num_queues) {
 705       move_all = ref_lists[from_idx].length() &gt; 0;
 706     }
 707     while ((ref_lists[from_idx].length() &gt; avg_refs) ||
 708            move_all) {
 709       assert(to_idx &lt; _num_queues, &quot;Sanity Check!&quot;);
 710       if (ref_lists[to_idx].length() &lt; avg_refs) {
 711         // move superfluous refs
 712         size_t refs_to_move;
 713         // Move all the Ref&#39;s if the from queue will not be processed.
 714         if (move_all) {
 715           refs_to_move = MIN2(ref_lists[from_idx].length(),
 716                               avg_refs - ref_lists[to_idx].length());
 717         } else {
 718           refs_to_move = MIN2(ref_lists[from_idx].length() - avg_refs,
 719                               avg_refs - ref_lists[to_idx].length());
 720         }
 721 
 722         assert(refs_to_move &gt; 0, &quot;otherwise the code below will fail&quot;);
 723 
 724         oop move_head = ref_lists[from_idx].head();
 725         oop move_tail = move_head;
 726         oop new_head  = move_head;
 727         // find an element to split the list on
 728         for (size_t j = 0; j &lt; refs_to_move; ++j) {
 729           move_tail = new_head;
 730           new_head = java_lang_ref_Reference::discovered(new_head);
 731         }
 732 
 733         // Add the chain to the to list.
 734         if (ref_lists[to_idx].head() == NULL) {
 735           // to list is empty. Make a loop at the end.
 736           java_lang_ref_Reference::set_discovered_raw(move_tail, move_tail);
 737         } else {
 738           java_lang_ref_Reference::set_discovered_raw(move_tail, ref_lists[to_idx].head());
 739         }
 740         ref_lists[to_idx].set_head(move_head);
 741         ref_lists[to_idx].inc_length(refs_to_move);
 742 
 743         // Remove the chain from the from list.
 744         if (move_tail == new_head) {
 745           // We found the end of the from list.
 746           ref_lists[from_idx].set_head(NULL);
 747         } else {
 748           ref_lists[from_idx].set_head(new_head);
 749         }
 750         ref_lists[from_idx].dec_length(refs_to_move);
 751         if (ref_lists[from_idx].length() == 0) {
 752           break;
 753         }
 754       } else {
 755         to_idx = (to_idx + 1) % _num_queues;
 756       }
 757     }
 758   }
 759 #ifdef ASSERT
 760   log_reflist_counts(ref_lists, _num_queues);
 761   size_t balanced_total_refs = 0;
 762   for (uint i = 0; i &lt; _num_queues; ++i) {
 763     balanced_total_refs += ref_lists[i].length();
 764   }
 765   assert(total_refs == balanced_total_refs, &quot;Balancing was incomplete&quot;);
 766 #endif
 767 }
 768 
 769 bool ReferenceProcessor::is_mt_processing_set_up(AbstractRefProcTaskExecutor* task_executor) const {
 770   return task_executor != NULL &amp;&amp; _processing_is_mt;
 771 }
 772 
 773 void ReferenceProcessor::process_soft_ref_reconsider(BoolObjectClosure* is_alive,
 774                                                      OopClosure* keep_alive,
 775                                                      VoidClosure* complete_gc,
 776                                                      AbstractRefProcTaskExecutor* task_executor,
 777                                                      ReferenceProcessorPhaseTimes* phase_times) {
 778   assert(!_processing_is_mt || task_executor != NULL, &quot;Task executor must not be NULL when mt processing is set.&quot;);
 779 
 780   size_t const num_soft_refs = total_count(_discoveredSoftRefs);
 781   phase_times-&gt;set_ref_discovered(REF_SOFT, num_soft_refs);
 782 
 783   phase_times-&gt;set_processing_is_mt(_processing_is_mt);
 784 
 785   if (num_soft_refs == 0) {
 786     log_debug(gc, ref)(&quot;Skipped phase 1 of Reference Processing: no references&quot;);
 787     return;
 788   }
 789 
 790   if (_current_soft_ref_policy == NULL) {
 791     log_debug(gc, ref)(&quot;Skipped phase 1 of Reference Processing: no policy&quot;);
 792     return;
 793   }
 794 
 795   RefProcMTDegreeAdjuster a(this, RefPhase1, num_soft_refs);
 796 
 797   if (_processing_is_mt) {
 798     RefProcBalanceQueuesTimeTracker tt(RefPhase1, phase_times);
 799     maybe_balance_queues(_discoveredSoftRefs);
 800   }
 801 
 802   RefProcPhaseTimeTracker tt(RefPhase1, phase_times);
 803 
 804   log_reflist(&quot;Phase 1 Soft before&quot;, _discoveredSoftRefs, _max_num_queues);
 805   if (_processing_is_mt) {
 806     RefProcPhase1Task phase1(*this, phase_times, _current_soft_ref_policy);
 807     task_executor-&gt;execute(phase1, num_queues());
 808   } else {
 809     size_t removed = 0;
 810 
 811     RefProcSubPhasesWorkerTimeTracker tt2(SoftRefSubPhase1, phase_times, 0);
 812     for (uint i = 0; i &lt; _max_num_queues; i++) {
 813       removed += process_soft_ref_reconsider_work(_discoveredSoftRefs[i], _current_soft_ref_policy,
 814                                                   is_alive, keep_alive, complete_gc);
 815     }
 816 
 817     phase_times-&gt;add_ref_cleared(REF_SOFT, removed);
 818   }
 819   log_reflist(&quot;Phase 1 Soft after&quot;, _discoveredSoftRefs, _max_num_queues);
 820 }
 821 
 822 void ReferenceProcessor::process_soft_weak_final_refs(BoolObjectClosure* is_alive,
 823                                                       OopClosure* keep_alive,
 824                                                       VoidClosure* complete_gc,
 825                                                       AbstractRefProcTaskExecutor*  task_executor,
 826                                                       ReferenceProcessorPhaseTimes* phase_times) {
 827   assert(!_processing_is_mt || task_executor != NULL, &quot;Task executor must not be NULL when mt processing is set.&quot;);
 828 
 829   size_t const num_soft_refs = total_count(_discoveredSoftRefs);
 830   size_t const num_weak_refs = total_count(_discoveredWeakRefs);
 831   size_t const num_final_refs = total_count(_discoveredFinalRefs);
 832   size_t const num_total_refs = num_soft_refs + num_weak_refs + num_final_refs;
 833   phase_times-&gt;set_ref_discovered(REF_WEAK, num_weak_refs);
 834   phase_times-&gt;set_ref_discovered(REF_FINAL, num_final_refs);
 835 
 836   phase_times-&gt;set_processing_is_mt(_processing_is_mt);
 837 
 838   if (num_total_refs == 0) {
 839     log_debug(gc, ref)(&quot;Skipped phase 2 of Reference Processing: no references&quot;);
 840     return;
 841   }
 842 
 843   RefProcMTDegreeAdjuster a(this, RefPhase2, num_total_refs);
 844 
 845   if (_processing_is_mt) {
 846     RefProcBalanceQueuesTimeTracker tt(RefPhase2, phase_times);
 847     maybe_balance_queues(_discoveredSoftRefs);
 848     maybe_balance_queues(_discoveredWeakRefs);
 849     maybe_balance_queues(_discoveredFinalRefs);
 850   }
 851 
 852   RefProcPhaseTimeTracker tt(RefPhase2, phase_times);
 853 
 854   log_reflist(&quot;Phase 2 Soft before&quot;, _discoveredSoftRefs, _max_num_queues);
 855   log_reflist(&quot;Phase 2 Weak before&quot;, _discoveredWeakRefs, _max_num_queues);
 856   log_reflist(&quot;Phase 2 Final before&quot;, _discoveredFinalRefs, _max_num_queues);
 857   if (_processing_is_mt) {
 858     RefProcPhase2Task phase2(*this, phase_times);
 859     task_executor-&gt;execute(phase2, num_queues());
 860   } else {
 861     RefProcWorkerTimeTracker t(phase_times-&gt;phase2_worker_time_sec(), 0);
 862     {
 863       size_t removed = 0;
 864 
 865       RefProcSubPhasesWorkerTimeTracker tt2(SoftRefSubPhase2, phase_times, 0);
 866       for (uint i = 0; i &lt; _max_num_queues; i++) {
 867         removed += process_soft_weak_final_refs_work(_discoveredSoftRefs[i], is_alive, keep_alive, true /* do_enqueue */);
 868       }
 869 
 870       phase_times-&gt;add_ref_cleared(REF_SOFT, removed);
 871     }
 872     {
 873       size_t removed = 0;
 874 
 875       RefProcSubPhasesWorkerTimeTracker tt2(WeakRefSubPhase2, phase_times, 0);
 876       for (uint i = 0; i &lt; _max_num_queues; i++) {
 877         removed += process_soft_weak_final_refs_work(_discoveredWeakRefs[i], is_alive, keep_alive, true /* do_enqueue */);
 878       }
 879 
 880       phase_times-&gt;add_ref_cleared(REF_WEAK, removed);
 881     }
 882     {
 883       size_t removed = 0;
 884 
 885       RefProcSubPhasesWorkerTimeTracker tt2(FinalRefSubPhase2, phase_times, 0);
 886       for (uint i = 0; i &lt; _max_num_queues; i++) {
 887         removed += process_soft_weak_final_refs_work(_discoveredFinalRefs[i], is_alive, keep_alive, false /* do_enqueue */);
 888       }
 889 
 890       phase_times-&gt;add_ref_cleared(REF_FINAL, removed);
 891     }
 892     complete_gc-&gt;do_void();
 893   }
 894   verify_total_count_zero(_discoveredSoftRefs, &quot;SoftReference&quot;);
 895   verify_total_count_zero(_discoveredWeakRefs, &quot;WeakReference&quot;);
 896   log_reflist(&quot;Phase 2 Final after&quot;, _discoveredFinalRefs, _max_num_queues);
 897 }
 898 
 899 void ReferenceProcessor::process_final_keep_alive(OopClosure* keep_alive,
 900                                                   VoidClosure* complete_gc,
 901                                                   AbstractRefProcTaskExecutor*  task_executor,
 902                                                   ReferenceProcessorPhaseTimes* phase_times) {
 903   assert(!_processing_is_mt || task_executor != NULL, &quot;Task executor must not be NULL when mt processing is set.&quot;);
 904 
 905   size_t const num_final_refs = total_count(_discoveredFinalRefs);
 906 
 907   phase_times-&gt;set_processing_is_mt(_processing_is_mt);
 908 
 909   if (num_final_refs == 0) {
 910     log_debug(gc, ref)(&quot;Skipped phase 3 of Reference Processing: no references&quot;);
 911     return;
 912   }
 913 
 914   RefProcMTDegreeAdjuster a(this, RefPhase3, num_final_refs);
 915 
 916   if (_processing_is_mt) {
 917     RefProcBalanceQueuesTimeTracker tt(RefPhase3, phase_times);
 918     maybe_balance_queues(_discoveredFinalRefs);
 919   }
 920 
 921   // Phase 3:
 922   // . Traverse referents of final references and keep them and followers alive.
 923   RefProcPhaseTimeTracker tt(RefPhase3, phase_times);
 924 
 925   if (_processing_is_mt) {
 926     RefProcPhase3Task phase3(*this, phase_times);
 927     task_executor-&gt;execute(phase3, num_queues());
 928   } else {
 929     RefProcSubPhasesWorkerTimeTracker tt2(FinalRefSubPhase3, phase_times, 0);
 930     for (uint i = 0; i &lt; _max_num_queues; i++) {
 931       process_final_keep_alive_work(_discoveredFinalRefs[i], keep_alive, complete_gc);
 932     }
 933   }
 934   verify_total_count_zero(_discoveredFinalRefs, &quot;FinalReference&quot;);
 935 }
 936 
 937 void ReferenceProcessor::process_phantom_refs(BoolObjectClosure* is_alive,
 938                                               OopClosure* keep_alive,
 939                                               VoidClosure* complete_gc,
 940                                               AbstractRefProcTaskExecutor* task_executor,
 941                                               ReferenceProcessorPhaseTimes* phase_times) {
 942   assert(!_processing_is_mt || task_executor != NULL, &quot;Task executor must not be NULL when mt processing is set.&quot;);
 943 
 944   size_t const num_phantom_refs = total_count(_discoveredPhantomRefs);
 945   phase_times-&gt;set_ref_discovered(REF_PHANTOM, num_phantom_refs);
 946 
 947   phase_times-&gt;set_processing_is_mt(_processing_is_mt);
 948 
 949   if (num_phantom_refs == 0) {
 950     log_debug(gc, ref)(&quot;Skipped phase 4 of Reference Processing: no references&quot;);
 951     return;
 952   }
 953 
 954   RefProcMTDegreeAdjuster a(this, RefPhase4, num_phantom_refs);
 955 
 956   if (_processing_is_mt) {
 957     RefProcBalanceQueuesTimeTracker tt(RefPhase4, phase_times);
 958     maybe_balance_queues(_discoveredPhantomRefs);
 959   }
 960 
 961   // Phase 4: Walk phantom references appropriately.
 962   RefProcPhaseTimeTracker tt(RefPhase4, phase_times);
 963 
 964   log_reflist(&quot;Phase 4 Phantom before&quot;, _discoveredPhantomRefs, _max_num_queues);
 965   if (_processing_is_mt) {
 966     RefProcPhase4Task phase4(*this, phase_times);
 967     task_executor-&gt;execute(phase4, num_queues());
 968   } else {
 969     size_t removed = 0;
 970 
 971     RefProcSubPhasesWorkerTimeTracker tt(PhantomRefSubPhase4, phase_times, 0);
 972     for (uint i = 0; i &lt; _max_num_queues; i++) {
 973       removed += process_phantom_refs_work(_discoveredPhantomRefs[i], is_alive, keep_alive, complete_gc);
 974     }
 975 
 976     phase_times-&gt;add_ref_cleared(REF_PHANTOM, removed);
 977   }
 978   verify_total_count_zero(_discoveredPhantomRefs, &quot;PhantomReference&quot;);
 979 }
 980 
 981 inline DiscoveredList* ReferenceProcessor::get_discovered_list(ReferenceType rt) {
 982   uint id = 0;
 983   // Determine the queue index to use for this object.
 984   if (_discovery_is_mt) {
 985     // During a multi-threaded discovery phase,
 986     // each thread saves to its &quot;own&quot; list.
 987     Thread* thr = Thread::current();
 988     id = thr-&gt;as_Worker_thread()-&gt;id();
 989   } else {
 990     // single-threaded discovery, we save in round-robin
 991     // fashion to each of the lists.
 992     if (_processing_is_mt) {
 993       id = next_id();
 994     }
 995   }
 996   assert(id &lt; _max_num_queues, &quot;Id is out of bounds id %u and max id %u)&quot;, id, _max_num_queues);
 997 
 998   // Get the discovered queue to which we will add
 999   DiscoveredList* list = NULL;
1000   switch (rt) {
1001     case REF_OTHER:
1002       // Unknown reference type, no special treatment
1003       break;
1004     case REF_SOFT:
1005       list = &amp;_discoveredSoftRefs[id];
1006       break;
1007     case REF_WEAK:
1008       list = &amp;_discoveredWeakRefs[id];
1009       break;
1010     case REF_FINAL:
1011       list = &amp;_discoveredFinalRefs[id];
1012       break;
1013     case REF_PHANTOM:
1014       list = &amp;_discoveredPhantomRefs[id];
1015       break;
1016     case REF_NONE:
1017       // we should not reach here if we are an InstanceRefKlass
1018     default:
1019       ShouldNotReachHere();
1020   }
1021   log_develop_trace(gc, ref)(&quot;Thread %d gets list &quot; INTPTR_FORMAT, id, p2i(list));
1022   return list;
1023 }
1024 
1025 inline void
1026 ReferenceProcessor::add_to_discovered_list_mt(DiscoveredList&amp; refs_list,
1027                                               oop             obj,
1028                                               HeapWord*       discovered_addr) {
1029   assert(_discovery_is_mt, &quot;!_discovery_is_mt should have been handled by caller&quot;);
1030   // First we must make sure this object is only enqueued once. CAS in a non null
1031   // discovered_addr.
1032   oop current_head = refs_list.head();
1033   // The last ref must have its discovered field pointing to itself.
1034   oop next_discovered = (current_head != NULL) ? current_head : obj;
1035 
1036   oop retest = HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_atomic_cmpxchg(discovered_addr, oop(NULL), next_discovered);
1037 
1038   if (retest == NULL) {
1039     // This thread just won the right to enqueue the object.
1040     // We have separate lists for enqueueing, so no synchronization
1041     // is necessary.
1042     refs_list.set_head(obj);
1043     refs_list.inc_length(1);
1044 
1045     log_develop_trace(gc, ref)(&quot;Discovered reference (mt) (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
1046                                p2i(obj), obj-&gt;klass()-&gt;internal_name());
1047   } else {
1048     // If retest was non NULL, another thread beat us to it:
1049     // The reference has already been discovered...
1050     log_develop_trace(gc, ref)(&quot;Already discovered reference (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
1051                                p2i(obj), obj-&gt;klass()-&gt;internal_name());
1052   }
1053 }
1054 
1055 #ifndef PRODUCT
1056 // Non-atomic (i.e. concurrent) discovery might allow us
1057 // to observe j.l.References with NULL referents, being those
1058 // cleared concurrently by mutators during (or after) discovery.
1059 void ReferenceProcessor::verify_referent(oop obj) {
1060   bool da = discovery_is_atomic();
1061   oop referent = java_lang_ref_Reference::referent(obj);
1062   assert(da ? oopDesc::is_oop(referent) : oopDesc::is_oop_or_null(referent),
1063          &quot;Bad referent &quot; INTPTR_FORMAT &quot; found in Reference &quot;
1064          INTPTR_FORMAT &quot; during %satomic discovery &quot;,
1065          p2i(referent), p2i(obj), da ? &quot;&quot; : &quot;non-&quot;);
1066 }
1067 #endif
1068 
1069 bool ReferenceProcessor::is_subject_to_discovery(oop const obj) const {
1070   return _is_subject_to_discovery-&gt;do_object_b(obj);
1071 }
1072 
1073 // We mention two of several possible choices here:
1074 // #0: if the reference object is not in the &quot;originating generation&quot;
1075 //     (or part of the heap being collected, indicated by our &quot;span&quot;
1076 //     we don&#39;t treat it specially (i.e. we scan it as we would
1077 //     a normal oop, treating its references as strong references).
1078 //     This means that references can&#39;t be discovered unless their
1079 //     referent is also in the same span. This is the simplest,
1080 //     most &quot;local&quot; and most conservative approach, albeit one
1081 //     that may cause weak references to be enqueued least promptly.
1082 //     We call this choice the &quot;ReferenceBasedDiscovery&quot; policy.
1083 // #1: the reference object may be in any generation (span), but if
1084 //     the referent is in the generation (span) being currently collected
1085 //     then we can discover the reference object, provided
1086 //     the object has not already been discovered by
1087 //     a different concurrently running collector (as may be the
1088 //     case, for instance, if the reference object is in CMS and
1089 //     the referent in DefNewGeneration), and provided the processing
1090 //     of this reference object by the current collector will
1091 //     appear atomic to every other collector in the system.
1092 //     (Thus, for instance, a concurrent collector may not
1093 //     discover references in other generations even if the
1094 //     referent is in its own generation). This policy may,
1095 //     in certain cases, enqueue references somewhat sooner than
1096 //     might Policy #0 above, but at marginally increased cost
1097 //     and complexity in processing these references.
1098 //     We call this choice the &quot;RefeferentBasedDiscovery&quot; policy.
1099 bool ReferenceProcessor::discover_reference(oop obj, ReferenceType rt) {
1100   // Make sure we are discovering refs (rather than processing discovered refs).
1101   if (!_discovering_refs || !RegisterReferences) {
1102     return false;
1103   }
1104 
1105   if ((rt == REF_FINAL) &amp;&amp; (java_lang_ref_Reference::next(obj) != NULL)) {
1106     // Don&#39;t rediscover non-active FinalReferences.
1107     return false;
1108   }
1109 
1110   if (RefDiscoveryPolicy == ReferenceBasedDiscovery &amp;&amp;
1111       !is_subject_to_discovery(obj)) {
1112     // Reference is not in the originating generation;
1113     // don&#39;t treat it specially (i.e. we want to scan it as a normal
1114     // object with strong references).
1115     return false;
1116   }
1117 
1118   // We only discover references whose referents are not (yet)
1119   // known to be strongly reachable.
1120   if (is_alive_non_header() != NULL) {
1121     verify_referent(obj);
1122     if (is_alive_non_header()-&gt;do_object_b(java_lang_ref_Reference::referent(obj))) {
1123       return false;  // referent is reachable
1124     }
1125   }
1126   if (rt == REF_SOFT) {
1127     // For soft refs we can decide now if these are not
1128     // current candidates for clearing, in which case we
1129     // can mark through them now, rather than delaying that
1130     // to the reference-processing phase. Since all current
1131     // time-stamp policies advance the soft-ref clock only
1132     // at a full collection cycle, this is always currently
1133     // accurate.
1134     if (!_current_soft_ref_policy-&gt;should_clear_reference(obj, _soft_ref_timestamp_clock)) {
1135       return false;
1136     }
1137   }
1138 
1139   ResourceMark rm;      // Needed for tracing.
1140 
1141   HeapWord* const discovered_addr = java_lang_ref_Reference::discovered_addr_raw(obj);
1142   const oop  discovered = java_lang_ref_Reference::discovered(obj);
1143   assert(oopDesc::is_oop_or_null(discovered), &quot;Expected an oop or NULL for discovered field at &quot; PTR_FORMAT, p2i(discovered));
1144   if (discovered != NULL) {
1145     // The reference has already been discovered...
1146     log_develop_trace(gc, ref)(&quot;Already discovered reference (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
1147                                p2i(obj), obj-&gt;klass()-&gt;internal_name());
1148     if (RefDiscoveryPolicy == ReferentBasedDiscovery) {
1149       // assumes that an object is not processed twice;
1150       // if it&#39;s been already discovered it must be on another
1151       // generation&#39;s discovered list; so we won&#39;t discover it.
1152       return false;
1153     } else {
1154       assert(RefDiscoveryPolicy == ReferenceBasedDiscovery,
1155              &quot;Unrecognized policy&quot;);
1156       // Check assumption that an object is not potentially
1157       // discovered twice except by concurrent collectors that potentially
1158       // trace the same Reference object twice.
1159       assert(UseG1GC || UseShenandoahGC,
1160              &quot;Only possible with a concurrent marking collector&quot;);
1161       return true;
1162     }
1163   }
1164 
1165   if (RefDiscoveryPolicy == ReferentBasedDiscovery) {
1166     verify_referent(obj);
1167     // Discover if and only if EITHER:
1168     // .. reference is in our span, OR
1169     // .. we are an atomic collector and referent is in our span
1170     if (is_subject_to_discovery(obj) ||
1171         (discovery_is_atomic() &amp;&amp;
1172          is_subject_to_discovery(java_lang_ref_Reference::referent(obj)))) {
1173     } else {
1174       return false;
1175     }
1176   } else {
1177     assert(RefDiscoveryPolicy == ReferenceBasedDiscovery &amp;&amp;
1178            is_subject_to_discovery(obj), &quot;code inconsistency&quot;);
1179   }
1180 
1181   // Get the right type of discovered queue head.
1182   DiscoveredList* list = get_discovered_list(rt);
1183   if (list == NULL) {
1184     return false;   // nothing special needs to be done
1185   }
1186 
1187   if (_discovery_is_mt) {
1188     add_to_discovered_list_mt(*list, obj, discovered_addr);
1189   } else {
1190     // We do a raw store here: the field will be visited later when processing
1191     // the discovered references.
1192     oop current_head = list-&gt;head();
1193     // The last ref must have its discovered field pointing to itself.
1194     oop next_discovered = (current_head != NULL) ? current_head : obj;
1195 
1196     assert(discovered == NULL, &quot;control point invariant&quot;);
1197     RawAccess&lt;&gt;::oop_store(discovered_addr, next_discovered);
1198     list-&gt;set_head(obj);
1199     list-&gt;inc_length(1);
1200 
1201     log_develop_trace(gc, ref)(&quot;Discovered reference (&quot; INTPTR_FORMAT &quot;: %s)&quot;, p2i(obj), obj-&gt;klass()-&gt;internal_name());
1202   }
1203   assert(oopDesc::is_oop(obj), &quot;Discovered a bad reference&quot;);
1204   verify_referent(obj);
1205   return true;
1206 }
1207 
1208 bool ReferenceProcessor::has_discovered_references() {
1209   for (uint i = 0; i &lt; _max_num_queues * number_of_subclasses_of_ref(); i++) {
1210     if (!_discovered_refs[i].is_empty()) {
1211       return true;
1212     }
1213   }
1214   return false;
1215 }
1216 
1217 void ReferenceProcessor::preclean_discovered_references(BoolObjectClosure* is_alive,
1218                                                         OopClosure* keep_alive,
1219                                                         VoidClosure* complete_gc,
1220                                                         YieldClosure* yield,
1221                                                         GCTimer* gc_timer) {
1222   // These lists can be handled here in any order and, indeed, concurrently.
1223 
1224   // Soft references
1225   {
1226     GCTraceTime(Debug, gc, ref) tm(&quot;Preclean SoftReferences&quot;, gc_timer);
1227     log_reflist(&quot;SoftRef before: &quot;, _discoveredSoftRefs, _max_num_queues);
1228     for (uint i = 0; i &lt; _max_num_queues; i++) {
1229       if (yield-&gt;should_return()) {
1230         return;
1231       }
1232       if (preclean_discovered_reflist(_discoveredSoftRefs[i], is_alive,
1233                                       keep_alive, complete_gc, yield)) {
1234         log_reflist(&quot;SoftRef abort: &quot;, _discoveredSoftRefs, _max_num_queues);
1235         return;
1236       }
1237     }
1238     log_reflist(&quot;SoftRef after: &quot;, _discoveredSoftRefs, _max_num_queues);
1239   }
1240 
1241   // Weak references
1242   {
1243     GCTraceTime(Debug, gc, ref) tm(&quot;Preclean WeakReferences&quot;, gc_timer);
1244     log_reflist(&quot;WeakRef before: &quot;, _discoveredWeakRefs, _max_num_queues);
1245     for (uint i = 0; i &lt; _max_num_queues; i++) {
1246       if (yield-&gt;should_return()) {
1247         return;
1248       }
1249       if (preclean_discovered_reflist(_discoveredWeakRefs[i], is_alive,
1250                                       keep_alive, complete_gc, yield)) {
1251         log_reflist(&quot;WeakRef abort: &quot;, _discoveredWeakRefs, _max_num_queues);
1252         return;
1253       }
1254     }
1255     log_reflist(&quot;WeakRef after: &quot;, _discoveredWeakRefs, _max_num_queues);
1256   }
1257 
1258   // Final references
1259   {
1260     GCTraceTime(Debug, gc, ref) tm(&quot;Preclean FinalReferences&quot;, gc_timer);
1261     log_reflist(&quot;FinalRef before: &quot;, _discoveredFinalRefs, _max_num_queues);
1262     for (uint i = 0; i &lt; _max_num_queues; i++) {
1263       if (yield-&gt;should_return()) {
1264         return;
1265       }
1266       if (preclean_discovered_reflist(_discoveredFinalRefs[i], is_alive,
1267                                       keep_alive, complete_gc, yield)) {
1268         log_reflist(&quot;FinalRef abort: &quot;, _discoveredFinalRefs, _max_num_queues);
1269         return;
1270       }
1271     }
1272     log_reflist(&quot;FinalRef after: &quot;, _discoveredFinalRefs, _max_num_queues);
1273   }
1274 
1275   // Phantom references
1276   {
1277     GCTraceTime(Debug, gc, ref) tm(&quot;Preclean PhantomReferences&quot;, gc_timer);
1278     log_reflist(&quot;PhantomRef before: &quot;, _discoveredPhantomRefs, _max_num_queues);
1279     for (uint i = 0; i &lt; _max_num_queues; i++) {
1280       if (yield-&gt;should_return()) {
1281         return;
1282       }
1283       if (preclean_discovered_reflist(_discoveredPhantomRefs[i], is_alive,
1284                                       keep_alive, complete_gc, yield)) {
1285         log_reflist(&quot;PhantomRef abort: &quot;, _discoveredPhantomRefs, _max_num_queues);
1286         return;
1287       }
1288     }
1289     log_reflist(&quot;PhantomRef after: &quot;, _discoveredPhantomRefs, _max_num_queues);
1290   }
1291 }
1292 
1293 // Walk the given discovered ref list, and remove all reference objects
1294 // whose referents are still alive, whose referents are NULL or which
1295 // are not active (have a non-NULL next field). NOTE: When we are
1296 // thus precleaning the ref lists (which happens single-threaded today),
1297 // we do not disable refs discovery to honor the correct semantics of
1298 // java.lang.Reference. As a result, we need to be careful below
1299 // that ref removal steps interleave safely with ref discovery steps
1300 // (in this thread).
1301 bool ReferenceProcessor::preclean_discovered_reflist(DiscoveredList&amp;    refs_list,
1302                                                      BoolObjectClosure* is_alive,
1303                                                      OopClosure*        keep_alive,
1304                                                      VoidClosure*       complete_gc,
1305                                                      YieldClosure*      yield) {
1306   DiscoveredListIterator iter(refs_list, keep_alive, is_alive);
1307   while (iter.has_next()) {
1308     if (yield-&gt;should_return_fine_grain()) {
1309       return true;
1310     }
1311     iter.load_ptrs(DEBUG_ONLY(true /* allow_null_referent */));
1312     if (iter.referent() == NULL || iter.is_referent_alive()) {
1313       // The referent has been cleared, or is alive; we need to trace
1314       // and mark its cohort.
1315       log_develop_trace(gc, ref)(&quot;Precleaning Reference (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
1316                                  p2i(iter.obj()), iter.obj()-&gt;klass()-&gt;internal_name());
1317       // Remove Reference object from list
1318       iter.remove();
1319       // Keep alive its cohort.
1320       iter.make_referent_alive();
1321       iter.move_to_next();
1322     } else {
1323       iter.next();
1324     }
1325   }
1326   // Close the reachable set
1327   complete_gc-&gt;do_void();
1328 
1329   if (iter.processed() &gt; 0) {
1330     log_develop_trace(gc, ref)(&quot; Dropped &quot; SIZE_FORMAT &quot; Refs out of &quot; SIZE_FORMAT &quot; Refs in discovered list &quot; INTPTR_FORMAT,
1331                                iter.removed(), iter.processed(), p2i(&amp;refs_list));
1332   }
1333   return false;
1334 }
1335 
1336 const char* ReferenceProcessor::list_name(uint i) {
1337    assert(i &lt;= _max_num_queues * number_of_subclasses_of_ref(),
1338           &quot;Out of bounds index&quot;);
1339 
1340    int j = i / _max_num_queues;
1341    switch (j) {
1342      case 0: return &quot;SoftRef&quot;;
1343      case 1: return &quot;WeakRef&quot;;
1344      case 2: return &quot;FinalRef&quot;;
1345      case 3: return &quot;PhantomRef&quot;;
1346    }
1347    ShouldNotReachHere();
1348    return NULL;
1349 }
1350 
1351 uint RefProcMTDegreeAdjuster::ergo_proc_thread_count(size_t ref_count,
1352                                                      uint max_threads,
1353                                                      RefProcPhases phase) const {
1354   assert(0 &lt; max_threads, &quot;must allow at least one thread&quot;);
1355 
1356   if (use_max_threads(phase) || (ReferencesPerThread == 0)) {
1357     return max_threads;
1358   }
1359 
1360   size_t thread_count = 1 + (ref_count / ReferencesPerThread);
1361   return (uint)MIN3(thread_count,
1362                     static_cast&lt;size_t&gt;(max_threads),
1363                     (size_t)os::active_processor_count());
1364 }
1365 
1366 bool RefProcMTDegreeAdjuster::use_max_threads(RefProcPhases phase) const {
1367   // Even a small number of references in either of those cases could produce large amounts of work.
1368   return (phase == ReferenceProcessor::RefPhase1 || phase == ReferenceProcessor::RefPhase3);
1369 }
1370 
1371 RefProcMTDegreeAdjuster::RefProcMTDegreeAdjuster(ReferenceProcessor* rp,
1372                                                  RefProcPhases phase,
1373                                                  size_t ref_count):
1374     _rp(rp),
1375     _saved_mt_processing(_rp-&gt;processing_is_mt()),
1376     _saved_num_queues(_rp-&gt;num_queues()) {
1377   if (!_rp-&gt;processing_is_mt() || !_rp-&gt;adjust_no_of_processing_threads() || (ReferencesPerThread == 0)) {
1378     return;
1379   }
1380 
1381   uint workers = ergo_proc_thread_count(ref_count, _rp-&gt;num_queues(), phase);
1382 
1383   _rp-&gt;set_mt_processing(workers &gt; 1);
1384   _rp-&gt;set_active_mt_degree(workers);
1385 }
1386 
1387 RefProcMTDegreeAdjuster::~RefProcMTDegreeAdjuster() {
1388   // Revert to previous status.
1389   _rp-&gt;set_mt_processing(_saved_mt_processing);
1390   _rp-&gt;set_active_mt_degree(_saved_num_queues);
1391 }
    </pre>
  </body>
</html>
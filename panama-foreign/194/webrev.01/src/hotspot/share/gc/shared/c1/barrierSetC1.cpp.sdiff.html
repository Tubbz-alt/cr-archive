<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/c1/barrierSetC1.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../parallel/parallelScavengeHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="cardTableBarrierSetC1.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/c1/barrierSetC1.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
176     __ membar();
177   }
178 
179   LIR_PatchCode patch_code = needs_patching ? lir_patch_normal : lir_patch_none;
180   if (in_native) {
181     __ move_wide(access.resolved_addr()-&gt;as_address_ptr(), result);
182   } else if (is_volatile &amp;&amp; !needs_patching) {
183     gen-&gt;volatile_field_load(access.resolved_addr()-&gt;as_address_ptr(), result, access.access_emit_info());
184   } else {
185     __ load(access.resolved_addr()-&gt;as_address_ptr(), result, access.access_emit_info(), patch_code);
186   }
187 
188   if (is_volatile) {
189     __ membar_acquire();
190   }
191 
192   /* Normalize boolean value returned by unsafe operation, i.e., value  != 0 ? value = true : value false. */
193   if (mask_boolean) {
194     LabelObj* equalZeroLabel = new LabelObj();
195     __ cmp(lir_cond_equal, result, 0);
<span class="line-modified">196     __ branch(lir_cond_equal, T_BOOLEAN, equalZeroLabel-&gt;label());</span>
197     __ move(LIR_OprFact::intConst(1), result);
198     __ branch_destination(equalZeroLabel-&gt;label());
199   }
200 }
201 
202 LIR_Opr BarrierSetC1::atomic_cmpxchg_at_resolved(LIRAccess&amp; access, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
203   LIRGenerator *gen = access.gen();
204   return gen-&gt;atomic_cmpxchg(access.type(), access.resolved_addr(), cmp_value, new_value);
205 }
206 
207 LIR_Opr BarrierSetC1::atomic_xchg_at_resolved(LIRAccess&amp; access, LIRItem&amp; value) {
208   LIRGenerator *gen = access.gen();
209   return gen-&gt;atomic_xchg(access.type(), access.resolved_addr(), value);
210 }
211 
212 LIR_Opr BarrierSetC1::atomic_add_at_resolved(LIRAccess&amp; access, LIRItem&amp; value) {
213   LIRGenerator *gen = access.gen();
214   return gen-&gt;atomic_add(access.type(), access.resolved_addr(), value);
215 }
216 
217 void BarrierSetC1::generate_referent_check(LIRAccess&amp; access, LabelObj* cont) {
218   // We might be reading the value of the referent field of a
219   // Reference object in order to attach it back to the live
220   // object graph. If G1 is enabled then we need to record
221   // the value that is being returned in an SATB log buffer.
222   //
223   // We need to generate code similar to the following...
224   //
<span class="line-modified">225   // if (offset == java_lang_ref_Reference::referent_offset) {</span>
226   //   if (src != NULL) {
227   //     if (klass(src)-&gt;reference_type() != REF_NONE) {
228   //       pre_barrier(..., value, ...);
229   //     }
230   //   }
231   // }
232 
233   bool gen_pre_barrier = true;     // Assume we need to generate pre_barrier.
234   bool gen_offset_check = true;    // Assume we need to generate the offset guard.
235   bool gen_source_check = true;    // Assume we need to check the src object for null.
236   bool gen_type_check = true;      // Assume we need to check the reference_type.
237 
238   LIRGenerator *gen = access.gen();
239 
240   LIRItem&amp; base = access.base().item();
241   LIR_Opr offset = access.offset().opr();
242 
243   if (offset-&gt;is_constant()) {
244     LIR_Const* constant = offset-&gt;as_constant_ptr();
245     jlong off_con = (constant-&gt;type() == T_INT ?
246                      (jlong)constant-&gt;as_jint() :
247                      constant-&gt;as_jlong());
248 
249 
<span class="line-modified">250     if (off_con != (jlong) java_lang_ref_Reference::referent_offset) {</span>
251       // The constant offset is something other than referent_offset.
252       // We can skip generating/checking the remaining guards and
253       // skip generation of the code stub.
254       gen_pre_barrier = false;
255     } else {
256       // The constant offset is the same as referent_offset -
257       // we do not need to generate a runtime offset check.
258       gen_offset_check = false;
259     }
260   }
261 
262   // We don&#39;t need to generate stub if the source object is an array
263   if (gen_pre_barrier &amp;&amp; base.type()-&gt;is_array()) {
264     gen_pre_barrier = false;
265   }
266 
267   if (gen_pre_barrier) {
268     // We still need to continue with the checks.
269     if (base.is_constant()) {
270       ciObject* src_con = base.get_jobject_constant();
</pre>
<hr />
<pre>
297     }
298   }
299 
300   if (gen_pre_barrier) {
301     // We can have generate one runtime check here. Let&#39;s start with
302     // the offset check.
303     // Allocate temp register to base and load it here, otherwise
304     // control flow below may confuse register allocator.
305     LIR_Opr base_reg = gen-&gt;new_register(T_OBJECT);
306     __ move(base.result(), base_reg);
307     if (gen_offset_check) {
308       // if (offset != referent_offset) -&gt; continue
309       // If offset is an int then we can do the comparison with the
310       // referent_offset constant; otherwise we need to move
311       // referent_offset into a temporary register and generate
312       // a reg-reg compare.
313 
314       LIR_Opr referent_off;
315 
316       if (offset-&gt;type() == T_INT) {
<span class="line-modified">317         referent_off = LIR_OprFact::intConst(java_lang_ref_Reference::referent_offset);</span>
318       } else {
319         assert(offset-&gt;type() == T_LONG, &quot;what else?&quot;);
320         referent_off = gen-&gt;new_register(T_LONG);
<span class="line-modified">321         __ move(LIR_OprFact::longConst(java_lang_ref_Reference::referent_offset), referent_off);</span>
322       }
323       __ cmp(lir_cond_notEqual, offset, referent_off);
<span class="line-modified">324       __ branch(lir_cond_notEqual, offset-&gt;type(), cont-&gt;label());</span>
325     }
326     if (gen_source_check) {
327       // offset is a const and equals referent offset
328       // if (source == null) -&gt; continue
329       __ cmp(lir_cond_equal, base_reg, LIR_OprFact::oopConst(NULL));
<span class="line-modified">330       __ branch(lir_cond_equal, T_OBJECT, cont-&gt;label());</span>
331     }
332     LIR_Opr src_klass = gen-&gt;new_register(T_METADATA);
333     if (gen_type_check) {
334       // We have determined that offset == referent_offset &amp;&amp; src != null.
335       // if (src-&gt;_klass-&gt;_reference_type == REF_NONE) -&gt; continue
336       __ move(new LIR_Address(base_reg, oopDesc::klass_offset_in_bytes(), T_ADDRESS), src_klass);
337       LIR_Address* reference_type_addr = new LIR_Address(src_klass, in_bytes(InstanceKlass::reference_type_offset()), T_BYTE);
338       LIR_Opr reference_type = gen-&gt;new_register(T_INT);
339       __ move(reference_type_addr, reference_type);
340       __ cmp(lir_cond_equal, reference_type, LIR_OprFact::intConst(REF_NONE));
<span class="line-modified">341       __ branch(lir_cond_equal, T_INT, cont-&gt;label());</span>
342     }
343   }
344 }
345 
346 LIR_Opr BarrierSetC1::resolve(LIRGenerator* gen, DecoratorSet decorators, LIR_Opr obj) {
347   return obj;
348 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
176     __ membar();
177   }
178 
179   LIR_PatchCode patch_code = needs_patching ? lir_patch_normal : lir_patch_none;
180   if (in_native) {
181     __ move_wide(access.resolved_addr()-&gt;as_address_ptr(), result);
182   } else if (is_volatile &amp;&amp; !needs_patching) {
183     gen-&gt;volatile_field_load(access.resolved_addr()-&gt;as_address_ptr(), result, access.access_emit_info());
184   } else {
185     __ load(access.resolved_addr()-&gt;as_address_ptr(), result, access.access_emit_info(), patch_code);
186   }
187 
188   if (is_volatile) {
189     __ membar_acquire();
190   }
191 
192   /* Normalize boolean value returned by unsafe operation, i.e., value  != 0 ? value = true : value false. */
193   if (mask_boolean) {
194     LabelObj* equalZeroLabel = new LabelObj();
195     __ cmp(lir_cond_equal, result, 0);
<span class="line-modified">196     __ branch(lir_cond_equal, equalZeroLabel-&gt;label());</span>
197     __ move(LIR_OprFact::intConst(1), result);
198     __ branch_destination(equalZeroLabel-&gt;label());
199   }
200 }
201 
202 LIR_Opr BarrierSetC1::atomic_cmpxchg_at_resolved(LIRAccess&amp; access, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
203   LIRGenerator *gen = access.gen();
204   return gen-&gt;atomic_cmpxchg(access.type(), access.resolved_addr(), cmp_value, new_value);
205 }
206 
207 LIR_Opr BarrierSetC1::atomic_xchg_at_resolved(LIRAccess&amp; access, LIRItem&amp; value) {
208   LIRGenerator *gen = access.gen();
209   return gen-&gt;atomic_xchg(access.type(), access.resolved_addr(), value);
210 }
211 
212 LIR_Opr BarrierSetC1::atomic_add_at_resolved(LIRAccess&amp; access, LIRItem&amp; value) {
213   LIRGenerator *gen = access.gen();
214   return gen-&gt;atomic_add(access.type(), access.resolved_addr(), value);
215 }
216 
217 void BarrierSetC1::generate_referent_check(LIRAccess&amp; access, LabelObj* cont) {
218   // We might be reading the value of the referent field of a
219   // Reference object in order to attach it back to the live
220   // object graph. If G1 is enabled then we need to record
221   // the value that is being returned in an SATB log buffer.
222   //
223   // We need to generate code similar to the following...
224   //
<span class="line-modified">225   // if (offset == java_lang_ref_Reference::referent_offset()) {</span>
226   //   if (src != NULL) {
227   //     if (klass(src)-&gt;reference_type() != REF_NONE) {
228   //       pre_barrier(..., value, ...);
229   //     }
230   //   }
231   // }
232 
233   bool gen_pre_barrier = true;     // Assume we need to generate pre_barrier.
234   bool gen_offset_check = true;    // Assume we need to generate the offset guard.
235   bool gen_source_check = true;    // Assume we need to check the src object for null.
236   bool gen_type_check = true;      // Assume we need to check the reference_type.
237 
238   LIRGenerator *gen = access.gen();
239 
240   LIRItem&amp; base = access.base().item();
241   LIR_Opr offset = access.offset().opr();
242 
243   if (offset-&gt;is_constant()) {
244     LIR_Const* constant = offset-&gt;as_constant_ptr();
245     jlong off_con = (constant-&gt;type() == T_INT ?
246                      (jlong)constant-&gt;as_jint() :
247                      constant-&gt;as_jlong());
248 
249 
<span class="line-modified">250     if (off_con != (jlong) java_lang_ref_Reference::referent_offset()) {</span>
251       // The constant offset is something other than referent_offset.
252       // We can skip generating/checking the remaining guards and
253       // skip generation of the code stub.
254       gen_pre_barrier = false;
255     } else {
256       // The constant offset is the same as referent_offset -
257       // we do not need to generate a runtime offset check.
258       gen_offset_check = false;
259     }
260   }
261 
262   // We don&#39;t need to generate stub if the source object is an array
263   if (gen_pre_barrier &amp;&amp; base.type()-&gt;is_array()) {
264     gen_pre_barrier = false;
265   }
266 
267   if (gen_pre_barrier) {
268     // We still need to continue with the checks.
269     if (base.is_constant()) {
270       ciObject* src_con = base.get_jobject_constant();
</pre>
<hr />
<pre>
297     }
298   }
299 
300   if (gen_pre_barrier) {
301     // We can have generate one runtime check here. Let&#39;s start with
302     // the offset check.
303     // Allocate temp register to base and load it here, otherwise
304     // control flow below may confuse register allocator.
305     LIR_Opr base_reg = gen-&gt;new_register(T_OBJECT);
306     __ move(base.result(), base_reg);
307     if (gen_offset_check) {
308       // if (offset != referent_offset) -&gt; continue
309       // If offset is an int then we can do the comparison with the
310       // referent_offset constant; otherwise we need to move
311       // referent_offset into a temporary register and generate
312       // a reg-reg compare.
313 
314       LIR_Opr referent_off;
315 
316       if (offset-&gt;type() == T_INT) {
<span class="line-modified">317         referent_off = LIR_OprFact::intConst(java_lang_ref_Reference::referent_offset());</span>
318       } else {
319         assert(offset-&gt;type() == T_LONG, &quot;what else?&quot;);
320         referent_off = gen-&gt;new_register(T_LONG);
<span class="line-modified">321         __ move(LIR_OprFact::longConst(java_lang_ref_Reference::referent_offset()), referent_off);</span>
322       }
323       __ cmp(lir_cond_notEqual, offset, referent_off);
<span class="line-modified">324       __ branch(lir_cond_notEqual, cont-&gt;label());</span>
325     }
326     if (gen_source_check) {
327       // offset is a const and equals referent offset
328       // if (source == null) -&gt; continue
329       __ cmp(lir_cond_equal, base_reg, LIR_OprFact::oopConst(NULL));
<span class="line-modified">330       __ branch(lir_cond_equal, cont-&gt;label());</span>
331     }
332     LIR_Opr src_klass = gen-&gt;new_register(T_METADATA);
333     if (gen_type_check) {
334       // We have determined that offset == referent_offset &amp;&amp; src != null.
335       // if (src-&gt;_klass-&gt;_reference_type == REF_NONE) -&gt; continue
336       __ move(new LIR_Address(base_reg, oopDesc::klass_offset_in_bytes(), T_ADDRESS), src_klass);
337       LIR_Address* reference_type_addr = new LIR_Address(src_klass, in_bytes(InstanceKlass::reference_type_offset()), T_BYTE);
338       LIR_Opr reference_type = gen-&gt;new_register(T_INT);
339       __ move(reference_type_addr, reference_type);
340       __ cmp(lir_cond_equal, reference_type, LIR_OprFact::intConst(REF_NONE));
<span class="line-modified">341       __ branch(lir_cond_equal, cont-&gt;label());</span>
342     }
343   }
344 }
345 
346 LIR_Opr BarrierSetC1::resolve(LIRGenerator* gen, DecoratorSet decorators, LIR_Opr obj) {
347   return obj;
348 }
</pre>
</td>
</tr>
</table>
<center><a href="../../parallel/parallelScavengeHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="cardTableBarrierSetC1.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
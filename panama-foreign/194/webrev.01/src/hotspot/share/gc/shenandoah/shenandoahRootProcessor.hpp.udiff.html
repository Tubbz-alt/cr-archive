<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahRootProcessor.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahRootProcessor.inline.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -224,13 +224,22 @@</span>
  };
  
  template &lt;bool CONCURRENT, bool SINGLE_THREADED&gt;
  class ShenandoahClassLoaderDataRoots {
  private:
<span class="udiff-line-added">+   ShenandoahSharedSemaphore     _semaphore;</span>
    ShenandoahPhaseTimings::Phase _phase;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static uint worker_count(uint n_workers) {</span>
<span class="udiff-line-added">+     // Limit concurrency a bit, otherwise it wastes resources when workers are tripping</span>
<span class="udiff-line-added">+     // over each other. This also leaves free workers to process other parts of the root</span>
<span class="udiff-line-added">+     // set, while admitted workers are busy with doing the CLDG walk.</span>
<span class="udiff-line-added">+     return MAX2(1u, MIN2(ShenandoahSharedSemaphore::max_tokens(), n_workers / 2));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
  public:
<span class="udiff-line-modified-removed">-   ShenandoahClassLoaderDataRoots(ShenandoahPhaseTimings::Phase phase);</span>
<span class="udiff-line-modified-added">+   ShenandoahClassLoaderDataRoots(ShenandoahPhaseTimings::Phase phase, uint n_workers);</span>
    ~ShenandoahClassLoaderDataRoots();
  
    void always_strong_cld_do(CLDClosure* clds, uint worker_id);
    void cld_do(CLDClosure* clds, uint worker_id);
  };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -248,17 +257,15 @@</span>
  
  class ShenandoahRootScanner : public ShenandoahRootProcessor {
  private:
    ShenandoahSerialRoots                                     _serial_roots;
    ShenandoahThreadRoots                                     _thread_roots;
<span class="udiff-line-removed">-   ShenandoahCodeCacheRoots                                  _code_roots;</span>
<span class="udiff-line-removed">-   ShenandoahVMRoots&lt;false /*concurrent*/ &gt;                  _vm_roots;</span>
    ShenandoahStringDedupRoots                                _dedup_roots;
<span class="udiff-line-modified-removed">-   ShenandoahClassLoaderDataRoots&lt;false /*concurrent*/, false /*single threaded*/&gt;</span>
<span class="udiff-line-removed">-                                                             _cld_roots;</span>
<span class="udiff-line-modified-added">+ </span>
  public:
    ShenandoahRootScanner(uint n_workers, ShenandoahPhaseTimings::Phase phase);
<span class="udiff-line-added">+   ~ShenandoahRootScanner();</span>
  
    // Apply oops, clds and blobs to all strongly reachable roots in the system,
    // during class unloading cycle
    void strong_roots_do(uint worker_id, OopClosure* cl);
    void strong_roots_do(uint worker_id, OopClosure* oops, CLDClosure* clds, CodeBlobClosure* code, ThreadClosure* tc = NULL);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -267,10 +274,26 @@</span>
    // roots when class unloading is disabled during this cycle
    void roots_do(uint worker_id, OopClosure* cl);
    void roots_do(uint worker_id, OopClosure* oops, CLDClosure* clds, CodeBlobClosure* code, ThreadClosure* tc = NULL);
  };
  
<span class="udiff-line-added">+ template &lt;bool CONCURRENT&gt;</span>
<span class="udiff-line-added">+ class ShenandoahConcurrentRootScanner {</span>
<span class="udiff-line-added">+ private:</span>
<span class="udiff-line-added">+   ShenandoahVMRoots&lt;CONCURRENT&gt;            _vm_roots;</span>
<span class="udiff-line-added">+   ShenandoahClassLoaderDataRoots&lt;CONCURRENT, false /* single-threaded*/&gt;</span>
<span class="udiff-line-added">+                                            _cld_roots;</span>
<span class="udiff-line-added">+   ShenandoahNMethodTableSnapshot*          _codecache_snapshot;</span>
<span class="udiff-line-added">+   ShenandoahPhaseTimings::Phase            _phase;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   ShenandoahConcurrentRootScanner(uint n_workers, ShenandoahPhaseTimings::Phase phase);</span>
<span class="udiff-line-added">+   ~ShenandoahConcurrentRootScanner();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void oops_do(OopClosure* oops, uint worker_id);</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  // This scanner is only for SH::object_iteration() and only supports single-threaded
  // root scanning
  class ShenandoahHeapIterationRootScanner : public ShenandoahRootProcessor {
  private:
    ShenandoahSerialRoots                                    _serial_roots;
</pre>
<center><a href="shenandoahRootProcessor.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahRootProcessor.inline.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
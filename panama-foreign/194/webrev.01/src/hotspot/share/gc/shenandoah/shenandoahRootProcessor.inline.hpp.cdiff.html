<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahRootProcessor.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahSharedVariables.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 120,11 ***</span>
    _jni_handle_roots.oops_do(cl, worker_id);
    _vm_global_roots.oops_do(cl, worker_id);
  }
  
  template &lt;bool CONCURRENT, bool SINGLE_THREADED&gt;
<span class="line-modified">! ShenandoahClassLoaderDataRoots&lt;CONCURRENT, SINGLE_THREADED&gt;::ShenandoahClassLoaderDataRoots(ShenandoahPhaseTimings::Phase phase) :</span>
    _phase(phase) {
    if (!SINGLE_THREADED) {
      ClassLoaderDataGraph::clear_claimed_marks();
    }
    if (CONCURRENT) {
<span class="line-new-header">--- 120,12 ---</span>
    _jni_handle_roots.oops_do(cl, worker_id);
    _vm_global_roots.oops_do(cl, worker_id);
  }
  
  template &lt;bool CONCURRENT, bool SINGLE_THREADED&gt;
<span class="line-modified">! ShenandoahClassLoaderDataRoots&lt;CONCURRENT, SINGLE_THREADED&gt;::ShenandoahClassLoaderDataRoots(ShenandoahPhaseTimings::Phase phase, uint n_workers) :</span>
<span class="line-added">+   _semaphore(worker_count(n_workers)),</span>
    _phase(phase) {
    if (!SINGLE_THREADED) {
      ClassLoaderDataGraph::clear_claimed_marks();
    }
    if (CONCURRENT) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,25 ***</span>
  void ShenandoahClassLoaderDataRoots&lt;CONCURRENT, SINGLE_THREADED&gt;::always_strong_cld_do(CLDClosure* clds, uint worker_id) {
    if (SINGLE_THREADED) {
      assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
      assert(Thread::current()-&gt;is_VM_thread(), &quot;Single threaded CLDG iteration can only be done by VM thread&quot;);
      ClassLoaderDataGraph::always_strong_cld_do(clds);
<span class="line-modified">!   } else {</span>
      ShenandoahWorkerTimingsTracker timer(_phase, ShenandoahPhaseTimings::CLDGRoots, worker_id);
      ClassLoaderDataGraph::always_strong_cld_do(clds);
    }
  }
  
  template &lt;bool CONCURRENT, bool SINGLE_THREADED&gt;
  void ShenandoahClassLoaderDataRoots&lt;CONCURRENT, SINGLE_THREADED&gt;::cld_do(CLDClosure* clds, uint worker_id) {
    if (SINGLE_THREADED) {
      assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
      assert(Thread::current()-&gt;is_VM_thread(), &quot;Single threaded CLDG iteration can only be done by VM thread&quot;);
      ClassLoaderDataGraph::cld_do(clds);
<span class="line-modified">!   } else {</span>
      ShenandoahWorkerTimingsTracker timer(_phase, ShenandoahPhaseTimings::CLDGRoots, worker_id);
      ClassLoaderDataGraph::cld_do(clds);
    }
  }
  
  class ShenandoahParallelOopsDoThreadClosure : public ThreadClosure {
  private:
<span class="line-new-header">--- 145,27 ---</span>
  void ShenandoahClassLoaderDataRoots&lt;CONCURRENT, SINGLE_THREADED&gt;::always_strong_cld_do(CLDClosure* clds, uint worker_id) {
    if (SINGLE_THREADED) {
      assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
      assert(Thread::current()-&gt;is_VM_thread(), &quot;Single threaded CLDG iteration can only be done by VM thread&quot;);
      ClassLoaderDataGraph::always_strong_cld_do(clds);
<span class="line-modified">!   } else if (_semaphore.try_acquire()) {</span>
      ShenandoahWorkerTimingsTracker timer(_phase, ShenandoahPhaseTimings::CLDGRoots, worker_id);
      ClassLoaderDataGraph::always_strong_cld_do(clds);
<span class="line-added">+     _semaphore.claim_all();</span>
    }
  }
  
  template &lt;bool CONCURRENT, bool SINGLE_THREADED&gt;
  void ShenandoahClassLoaderDataRoots&lt;CONCURRENT, SINGLE_THREADED&gt;::cld_do(CLDClosure* clds, uint worker_id) {
    if (SINGLE_THREADED) {
      assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
      assert(Thread::current()-&gt;is_VM_thread(), &quot;Single threaded CLDG iteration can only be done by VM thread&quot;);
      ClassLoaderDataGraph::cld_do(clds);
<span class="line-modified">!   } else if (_semaphore.try_acquire()) {</span>
      ShenandoahWorkerTimingsTracker timer(_phase, ShenandoahPhaseTimings::CLDGRoots, worker_id);
      ClassLoaderDataGraph::cld_do(clds);
<span class="line-added">+     _semaphore.claim_all();</span>
    }
  }
  
  class ShenandoahParallelOopsDoThreadClosure : public ThreadClosure {
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 179,28 ***</span>
      }
      t-&gt;oops_do(_f, _cf);
    }
  };
  
  template &lt;typename IsAlive, typename KeepAlive&gt;
  void ShenandoahRootUpdater::roots_do(uint worker_id, IsAlive* is_alive, KeepAlive* keep_alive) {
    CodeBlobToOopClosure update_blobs(keep_alive, CodeBlobToOopClosure::FixRelocations);
    ShenandoahCodeBlobAndDisarmClosure blobs_and_disarm_Cl(keep_alive);
    CodeBlobToOopClosure* codes_cl = ShenandoahConcurrentRoots::can_do_concurrent_class_unloading() ?
                                    static_cast&lt;CodeBlobToOopClosure*&gt;(&amp;blobs_and_disarm_Cl) :
                                    static_cast&lt;CodeBlobToOopClosure*&gt;(&amp;update_blobs);
  
    CLDToOopClosure clds(keep_alive, ClassLoaderData::_claim_strong);
  
    _serial_roots.oops_do(keep_alive, worker_id);
<span class="line-modified">!   _vm_roots.oops_do(keep_alive, worker_id);</span>
  
    _cld_roots.cld_do(&amp;clds, worker_id);
    _code_roots.code_blobs_do(codes_cl, worker_id);
    _thread_roots.oops_do(keep_alive, NULL, worker_id);
<span class="line-removed">- </span>
<span class="line-removed">-   _serial_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);</span>
<span class="line-removed">-   _weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);</span>
<span class="line-removed">-   _dedup_roots.oops_do(is_alive, keep_alive, worker_id);</span>
  }
  
  #endif // SHARE_GC_SHENANDOAH_SHENANDOAHROOTPROCESSOR_INLINE_HPP
<span class="line-new-header">--- 182,76 ---</span>
      }
      t-&gt;oops_do(_f, _cf);
    }
  };
  
<span class="line-added">+ template &lt;bool CONCURRENT&gt;</span>
<span class="line-added">+ ShenandoahConcurrentRootScanner&lt;CONCURRENT&gt;::ShenandoahConcurrentRootScanner(uint n_workers,</span>
<span class="line-added">+                                                                              ShenandoahPhaseTimings::Phase phase) :</span>
<span class="line-added">+   _vm_roots(phase),</span>
<span class="line-added">+   _cld_roots(phase, n_workers),</span>
<span class="line-added">+   _codecache_snapshot(NULL),</span>
<span class="line-added">+   _phase(phase) {</span>
<span class="line-added">+   if (!ShenandoahHeap::heap()-&gt;unload_classes()) {</span>
<span class="line-added">+     if (CONCURRENT) {</span>
<span class="line-added">+       CodeCache_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     _codecache_snapshot = ShenandoahCodeRoots::table()-&gt;snapshot_for_iteration();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(!CONCURRENT || !ShenandoahHeap::heap()-&gt;has_forwarded_objects(), &quot;Not expecting forwarded pointers during concurrent marking&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;bool CONCURRENT&gt;</span>
<span class="line-added">+ ShenandoahConcurrentRootScanner&lt;CONCURRENT&gt;::~ShenandoahConcurrentRootScanner() {</span>
<span class="line-added">+   if (!ShenandoahHeap::heap()-&gt;unload_classes()) {</span>
<span class="line-added">+     ShenandoahCodeRoots::table()-&gt;finish_iteration(_codecache_snapshot);</span>
<span class="line-added">+     if (CONCURRENT) {</span>
<span class="line-added">+       CodeCache_lock-&gt;unlock();</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;bool CONCURRENT&gt;</span>
<span class="line-added">+ void ShenandoahConcurrentRootScanner&lt;CONCURRENT&gt;::oops_do(OopClosure* oops, uint worker_id) {</span>
<span class="line-added">+   ShenandoahHeap* const heap = ShenandoahHeap::heap();</span>
<span class="line-added">+   CLDToOopClosure clds_cl(oops, CONCURRENT ? ClassLoaderData::_claim_strong : ClassLoaderData::_claim_none);</span>
<span class="line-added">+   _vm_roots.oops_do(oops, worker_id);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!heap-&gt;unload_classes()) {</span>
<span class="line-added">+     _cld_roots.cld_do(&amp;clds_cl, worker_id);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ShenandoahWorkerTimingsTracker timer(_phase, ShenandoahPhaseTimings::CodeCacheRoots, worker_id);</span>
<span class="line-added">+     CodeBlobToOopClosure blobs(oops, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-added">+     _codecache_snapshot-&gt;parallel_blobs_do(&amp;blobs);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     _cld_roots.always_strong_cld_do(&amp;clds_cl, worker_id);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  template &lt;typename IsAlive, typename KeepAlive&gt;
  void ShenandoahRootUpdater::roots_do(uint worker_id, IsAlive* is_alive, KeepAlive* keep_alive) {
    CodeBlobToOopClosure update_blobs(keep_alive, CodeBlobToOopClosure::FixRelocations);
    ShenandoahCodeBlobAndDisarmClosure blobs_and_disarm_Cl(keep_alive);
    CodeBlobToOopClosure* codes_cl = ShenandoahConcurrentRoots::can_do_concurrent_class_unloading() ?
                                    static_cast&lt;CodeBlobToOopClosure*&gt;(&amp;blobs_and_disarm_Cl) :
                                    static_cast&lt;CodeBlobToOopClosure*&gt;(&amp;update_blobs);
  
    CLDToOopClosure clds(keep_alive, ClassLoaderData::_claim_strong);
  
<span class="line-added">+   // Process serial-claiming roots first</span>
    _serial_roots.oops_do(keep_alive, worker_id);
<span class="line-modified">!   _serial_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);</span>
  
<span class="line-added">+   // Process light-weight/limited parallel roots then</span>
<span class="line-added">+   _vm_roots.oops_do(keep_alive, worker_id);</span>
<span class="line-added">+   _weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);</span>
<span class="line-added">+   _dedup_roots.oops_do(is_alive, keep_alive, worker_id);</span>
    _cld_roots.cld_do(&amp;clds, worker_id);
<span class="line-added">+ </span>
<span class="line-added">+   // Process heavy-weight/fully parallel roots the last</span>
    _code_roots.code_blobs_do(codes_cl, worker_id);
    _thread_roots.oops_do(keep_alive, NULL, worker_id);
  }
  
  #endif // SHARE_GC_SHENANDOAH_SHENANDOAHROOTPROCESSOR_INLINE_HPP
</pre>
<center><a href="shenandoahRootProcessor.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahSharedVariables.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
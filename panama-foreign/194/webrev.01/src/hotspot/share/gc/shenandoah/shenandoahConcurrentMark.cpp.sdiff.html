<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="c2/shenandoahSupport.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahConcurrentMark.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 157   TaskTerminator* _terminator;
 158 
 159 public:
 160   ShenandoahConcurrentMarkingTask(ShenandoahConcurrentMark* cm, TaskTerminator* terminator) :
 161     AbstractGangTask(&quot;Root Region Scan&quot;), _cm(cm), _terminator(terminator) {
 162   }
 163 
 164   void work(uint worker_id) {
 165     ShenandoahHeap* heap = ShenandoahHeap::heap();
 166     ShenandoahConcurrentWorkerSession worker_session(worker_id);
 167     ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
 168     ShenandoahObjToScanQueue* q = _cm-&gt;get_queue(worker_id);
 169     ReferenceProcessor* rp;
 170     if (heap-&gt;process_references()) {
 171       rp = heap-&gt;ref_processor();
 172       shenandoah_assert_rp_isalive_installed();
 173     } else {
 174       rp = NULL;
 175     }
 176 
<span class="line-removed"> 177     _cm-&gt;concurrent_scan_code_roots(worker_id, rp);</span>
 178     _cm-&gt;mark_loop(worker_id, _terminator, rp,
 179                    true, // cancellable
 180                    ShenandoahStringDedup::is_enabled()); // perform string dedup
 181   }
 182 };
 183 
 184 class ShenandoahSATBAndRemarkCodeRootsThreadsClosure : public ThreadClosure {
 185 private:
 186   ShenandoahSATBBufferClosure* _satb_cl;
 187   OopClosure*            const _cl;
 188   MarkingCodeBlobClosure*      _code_cl;
 189   uintx _claim_token;
 190 
 191 public:
 192   ShenandoahSATBAndRemarkCodeRootsThreadsClosure(ShenandoahSATBBufferClosure* satb_cl, OopClosure* cl, MarkingCodeBlobClosure* code_cl) :
 193     _satb_cl(satb_cl), _cl(cl), _code_cl(code_cl),
 194     _claim_token(Threads::thread_claim_token()) {}
 195 
 196   void do_thread(Thread* thread) {
 197     if (thread-&gt;claim_threads_do(true, _claim_token)) {
 198       ShenandoahThreadLocalData::satb_mark_queue(thread).apply_closure_and_empty(_satb_cl);
 199       if (thread-&gt;is_Java_thread()) {
 200         if (_cl != NULL) {
 201           ResourceMark rm;
 202           thread-&gt;oops_do(_cl, _code_cl);
 203         } else if (_code_cl != NULL) {
 204           // In theory it should not be neccessary to explicitly walk the nmethods to find roots for concurrent marking
 205           // however the liveness of oops reachable from nmethods have very complex lifecycles:
 206           // * Alive if on the stack of an executing method
 207           // * Weakly reachable otherwise
 208           // Some objects reachable from nmethods, such as the class loader (or klass_holder) of the receiver should be
 209           // live by the SATB invariant but other oops recorded in nmethods may behave differently.
 210           JavaThread* jt = (JavaThread*)thread;
 211           jt-&gt;nmethods_do(_code_cl);
 212         }
 213       }
 214     }
 215   }
 216 };
 217 






































 218 class ShenandoahFinalMarkingTask : public AbstractGangTask {
 219 private:
 220   ShenandoahConcurrentMark* _cm;
 221   TaskTerminator*           _terminator;
 222   bool _dedup_string;
 223 
 224 public:
 225   ShenandoahFinalMarkingTask(ShenandoahConcurrentMark* cm, TaskTerminator* terminator, bool dedup_string) :
 226     AbstractGangTask(&quot;Shenandoah Final Marking&quot;), _cm(cm), _terminator(terminator), _dedup_string(dedup_string) {
 227   }
 228 
 229   void work(uint worker_id) {
 230     ShenandoahHeap* heap = ShenandoahHeap::heap();
 231 
 232     ShenandoahParallelWorkerSession worker_session(worker_id);
 233     ReferenceProcessor* rp;
 234     if (heap-&gt;process_references()) {
 235       rp = heap-&gt;ref_processor();
 236       shenandoah_assert_rp_isalive_installed();
 237     } else {
</pre>
<hr />
<pre>
 250       SATBMarkQueueSet&amp; satb_mq_set = ShenandoahBarrierSet::satb_mark_queue_set();
 251       while (satb_mq_set.apply_closure_to_completed_buffer(&amp;cl));
 252       bool do_nmethods = heap-&gt;unload_classes() &amp;&amp; !ShenandoahConcurrentRoots::can_do_concurrent_class_unloading();
 253       if (heap-&gt;has_forwarded_objects()) {
 254         ShenandoahMarkResolveRefsClosure resolve_mark_cl(q, rp);
 255         MarkingCodeBlobClosure blobsCl(&amp;resolve_mark_cl, !CodeBlobToOopClosure::FixRelocations);
 256         ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&amp;cl,
 257                                                           ShenandoahStoreValEnqueueBarrier ? &amp;resolve_mark_cl : NULL,
 258                                                           do_nmethods ? &amp;blobsCl : NULL);
 259         Threads::threads_do(&amp;tc);
 260       } else {
 261         ShenandoahMarkRefsClosure mark_cl(q, rp);
 262         MarkingCodeBlobClosure blobsCl(&amp;mark_cl, !CodeBlobToOopClosure::FixRelocations);
 263         ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&amp;cl,
 264                                                           ShenandoahStoreValEnqueueBarrier ? &amp;mark_cl : NULL,
 265                                                           do_nmethods ? &amp;blobsCl : NULL);
 266         Threads::threads_do(&amp;tc);
 267       }
 268     }
 269 
<span class="line-removed"> 270     if (heap-&gt;is_degenerated_gc_in_progress()) {</span>
<span class="line-removed"> 271       // Degenerated cycle may bypass concurrent cycle, so code roots might not be scanned,</span>
<span class="line-removed"> 272       // let&#39;s check here.</span>
<span class="line-removed"> 273       _cm-&gt;concurrent_scan_code_roots(worker_id, rp);</span>
<span class="line-removed"> 274     }</span>
<span class="line-removed"> 275 </span>
 276     _cm-&gt;mark_loop(worker_id, _terminator, rp,
 277                    false, // not cancellable
 278                    _dedup_string);
 279 
 280     assert(_cm-&gt;task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
 281   }
 282 };
 283 
 284 void ShenandoahConcurrentMark::mark_roots(ShenandoahPhaseTimings::Phase root_phase) {
 285   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
 286   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 287 
 288   ShenandoahHeap* heap = ShenandoahHeap::heap();
 289 
 290   ShenandoahGCPhase phase(root_phase);
 291 
 292   WorkGang* workers = heap-&gt;workers();
 293   uint nworkers = workers-&gt;active_workers();
 294 
 295   assert(nworkers &lt;= task_queues()-&gt;size(), &quot;Just check&quot;);
 296 
 297   ShenandoahRootScanner root_proc(nworkers, root_phase);
 298   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
 299   task_queues()-&gt;reserve(nworkers);
 300 
 301   if (heap-&gt;has_forwarded_objects()) {
 302     ShenandoahInitMarkRootsTask&lt;RESOLVE&gt; mark_roots(&amp;root_proc);
 303     workers-&gt;run_task(&amp;mark_roots);
 304   } else {
 305     // No need to update references, which means the heap is stable.
 306     // Can save time not walking through forwarding pointers.
 307     ShenandoahInitMarkRootsTask&lt;NONE&gt; mark_roots(&amp;root_proc);
 308     workers-&gt;run_task(&amp;mark_roots);
 309   }
<span class="line-removed"> 310 </span>
<span class="line-removed"> 311   clear_claim_codecache();</span>
 312 }
 313 
 314 void ShenandoahConcurrentMark::update_roots(ShenandoahPhaseTimings::Phase root_phase) {
 315   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 316   assert(root_phase == ShenandoahPhaseTimings::full_gc_update_roots ||
 317          root_phase == ShenandoahPhaseTimings::degen_gc_update_roots,
 318          &quot;Only for these phases&quot;);
 319 
 320   ShenandoahGCPhase phase(root_phase);
 321 
 322   bool check_alive = root_phase == ShenandoahPhaseTimings::degen_gc_update_roots;
 323 
 324 #if COMPILER2_OR_JVMCI
 325   DerivedPointerTable::clear();
 326 #endif
 327 
 328   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 329 
 330   ShenandoahRootUpdater root_updater(nworkers, root_phase);
 331   ShenandoahUpdateRootsTask update_roots(&amp;root_updater, check_alive);
</pre>
<hr />
<pre>
 372 
 373 #if COMPILER2_OR_JVMCI
 374   DerivedPointerTable::update_pointers();
 375 #endif
 376 }
 377 
 378 void ShenandoahConcurrentMark::initialize(uint workers) {
 379   _heap = ShenandoahHeap::heap();
 380 
 381   uint num_queues = MAX2(workers, 1U);
 382 
 383   _task_queues = new ShenandoahObjToScanQueueSet((int) num_queues);
 384 
 385   for (uint i = 0; i &lt; num_queues; ++i) {
 386     ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();
 387     task_queue-&gt;initialize();
 388     _task_queues-&gt;register_queue(i, task_queue);
 389   }
 390 }
 391 
<span class="line-modified"> 392 void ShenandoahConcurrentMark::concurrent_scan_code_roots(uint worker_id, ReferenceProcessor* rp) {</span>
<span class="line-modified"> 393   if (claim_codecache()) {</span>
<span class="line-modified"> 394     ShenandoahObjToScanQueue* q = task_queues()-&gt;queue(worker_id);</span>
<span class="line-modified"> 395     if (!_heap-&gt;unload_classes()) {</span>
<span class="line-modified"> 396       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified"> 397       // TODO: We can not honor StringDeduplication here, due to lock ranking</span>
<span class="line-modified"> 398       // inversion. So, we may miss some deduplication candidates.</span>
<span class="line-modified"> 399       if (_heap-&gt;has_forwarded_objects()) {</span>
<span class="line-modified"> 400         ShenandoahMarkResolveRefsClosure cl(q, rp);</span>
<span class="line-modified"> 401         CodeBlobToOopClosure blobs(&amp;cl, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-modified"> 402         CodeCache::blobs_do(&amp;blobs);</span>
<span class="line-modified"> 403       } else {</span>
<span class="line-modified"> 404         ShenandoahMarkRefsClosure cl(q, rp);</span>
<span class="line-modified"> 405         CodeBlobToOopClosure blobs(&amp;cl, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-modified"> 406         CodeCache::blobs_do(&amp;blobs);</span>
<span class="line-modified"> 407       }</span>
<span class="line-modified"> 408     }</span>
<span class="line-modified"> 409   }</span>














 410 }
 411 
 412 void ShenandoahConcurrentMark::mark_from_roots() {
 413   WorkGang* workers = _heap-&gt;workers();
 414   uint nworkers = workers-&gt;active_workers();
 415 

 416   if (_heap-&gt;process_references()) {
<span class="line-modified"> 417     ReferenceProcessor* rp = _heap-&gt;ref_processor();</span>
 418     rp-&gt;set_active_mt_degree(nworkers);
 419 
 420     // enable (&quot;weak&quot;) refs discovery
 421     rp-&gt;enable_discovery(true /*verify_no_refs*/);
 422     rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
 423   }
 424 
 425   shenandoah_assert_rp_isalive_not_installed();
 426   ShenandoahIsAliveSelector is_alive;
 427   ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
 428 
 429   task_queues()-&gt;reserve(nworkers);
 430 







 431   {
 432     TaskTerminator terminator(nworkers, task_queues());
 433     ShenandoahConcurrentMarkingTask task(this, &amp;terminator);
 434     workers-&gt;run_task(&amp;task);
 435   }
 436 
 437   assert(task_queues()-&gt;is_empty() || _heap-&gt;cancelled_gc(), &quot;Should be empty when not cancelled&quot;);
 438 }
 439 
 440 void ShenandoahConcurrentMark::finish_mark_from_roots(bool full_gc) {
 441   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 442 
 443   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 444 
<span class="line-removed"> 445   // Finally mark everything else we&#39;ve got in our queues during the previous steps.</span>
<span class="line-removed"> 446   // It does two different things for concurrent vs. mark-compact GC:</span>
<span class="line-removed"> 447   // - For concurrent GC, it starts with empty task queues, drains the remaining</span>
<span class="line-removed"> 448   //   SATB buffers, and then completes the marking closure.</span>
<span class="line-removed"> 449   // - For mark-compact GC, it starts out with the task queues seeded by initial</span>
<span class="line-removed"> 450   //   root scan, and completes the closure, thus marking through all live objects</span>
<span class="line-removed"> 451   // The implementation is the same, so it&#39;s shared here.</span>
 452   {
<span class="line-removed"> 453     ShenandoahGCPhase phase(full_gc ?</span>
<span class="line-removed"> 454                             ShenandoahPhaseTimings::full_gc_mark_finish_queues :</span>
<span class="line-removed"> 455                             ShenandoahPhaseTimings::finish_queues);</span>
<span class="line-removed"> 456     task_queues()-&gt;reserve(nworkers);</span>
<span class="line-removed"> 457 </span>
 458     shenandoah_assert_rp_isalive_not_installed();
 459     ShenandoahIsAliveSelector is_alive;
 460     ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
 461 
<span class="line-modified"> 462     StrongRootsScope scope(nworkers);</span>
<span class="line-modified"> 463     TaskTerminator terminator(nworkers, task_queues());</span>
<span class="line-modified"> 464     ShenandoahFinalMarkingTask task(this, &amp;terminator, ShenandoahStringDedup::is_enabled());</span>
<span class="line-modified"> 465     _heap-&gt;workers()-&gt;run_task(&amp;task);</span>
<span class="line-modified"> 466   }</span>












 467 
<span class="line-modified"> 468   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);</span>




















 469 
 470   // When we&#39;re done marking everything, we process weak references.
 471   if (_heap-&gt;process_references()) {
 472     weak_refs_work(full_gc);
 473   }
 474 
 475   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
 476   TASKQUEUE_STATS_ONLY(task_queues()-&gt;print_taskqueue_stats());
 477   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
 478 }
 479 
 480 // Weak Reference Closures
 481 class ShenandoahCMDrainMarkingStackClosure: public VoidClosure {
 482   uint _worker_id;
 483   TaskTerminator* _terminator;
 484   bool _reset_terminator;
 485 
 486 public:
 487   ShenandoahCMDrainMarkingStackClosure(uint worker_id, TaskTerminator* t, bool reset_terminator = false):
 488     _worker_id(worker_id),
</pre>
<hr />
<pre>
 922     uint work = 0;
 923     for (uint i = 0; i &lt; stride; i++) {
 924       if (q-&gt;pop(t) ||
 925           queues-&gt;steal(worker_id, t)) {
 926         do_task&lt;T&gt;(q, cl, live_data, &amp;t);
 927         work++;
 928       } else {
 929         break;
 930       }
 931     }
 932 
 933     if (work == 0) {
 934       // No work encountered in current stride, try to terminate.
 935       // Need to leave the STS here otherwise it might block safepoints.
 936       ShenandoahSuspendibleThreadSetLeaver stsl(CANCELLABLE &amp;&amp; ShenandoahSuspendibleWorkers);
 937       ShenandoahTerminatorTerminator tt(heap);
 938       if (terminator-&gt;offer_termination(&amp;tt)) return;
 939     }
 940   }
 941 }
<span class="line-removed"> 942 </span>
<span class="line-removed"> 943 bool ShenandoahConcurrentMark::claim_codecache() {</span>
<span class="line-removed"> 944   return _claimed_codecache.try_set();</span>
<span class="line-removed"> 945 }</span>
<span class="line-removed"> 946 </span>
<span class="line-removed"> 947 void ShenandoahConcurrentMark::clear_claim_codecache() {</span>
<span class="line-removed"> 948   _claimed_codecache.unset();</span>
<span class="line-removed"> 949 }</span>
</pre>
</td>
<td>
<hr />
<pre>
 157   TaskTerminator* _terminator;
 158 
 159 public:
 160   ShenandoahConcurrentMarkingTask(ShenandoahConcurrentMark* cm, TaskTerminator* terminator) :
 161     AbstractGangTask(&quot;Root Region Scan&quot;), _cm(cm), _terminator(terminator) {
 162   }
 163 
 164   void work(uint worker_id) {
 165     ShenandoahHeap* heap = ShenandoahHeap::heap();
 166     ShenandoahConcurrentWorkerSession worker_session(worker_id);
 167     ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
 168     ShenandoahObjToScanQueue* q = _cm-&gt;get_queue(worker_id);
 169     ReferenceProcessor* rp;
 170     if (heap-&gt;process_references()) {
 171       rp = heap-&gt;ref_processor();
 172       shenandoah_assert_rp_isalive_installed();
 173     } else {
 174       rp = NULL;
 175     }
 176 

 177     _cm-&gt;mark_loop(worker_id, _terminator, rp,
 178                    true, // cancellable
 179                    ShenandoahStringDedup::is_enabled()); // perform string dedup
 180   }
 181 };
 182 
 183 class ShenandoahSATBAndRemarkCodeRootsThreadsClosure : public ThreadClosure {
 184 private:
 185   ShenandoahSATBBufferClosure* _satb_cl;
 186   OopClosure*            const _cl;
 187   MarkingCodeBlobClosure*      _code_cl;
 188   uintx _claim_token;
 189 
 190 public:
 191   ShenandoahSATBAndRemarkCodeRootsThreadsClosure(ShenandoahSATBBufferClosure* satb_cl, OopClosure* cl, MarkingCodeBlobClosure* code_cl) :
 192     _satb_cl(satb_cl), _cl(cl), _code_cl(code_cl),
 193     _claim_token(Threads::thread_claim_token()) {}
 194 
 195   void do_thread(Thread* thread) {
 196     if (thread-&gt;claim_threads_do(true, _claim_token)) {
 197       ShenandoahThreadLocalData::satb_mark_queue(thread).apply_closure_and_empty(_satb_cl);
 198       if (thread-&gt;is_Java_thread()) {
 199         if (_cl != NULL) {
 200           ResourceMark rm;
 201           thread-&gt;oops_do(_cl, _code_cl);
 202         } else if (_code_cl != NULL) {
 203           // In theory it should not be neccessary to explicitly walk the nmethods to find roots for concurrent marking
 204           // however the liveness of oops reachable from nmethods have very complex lifecycles:
 205           // * Alive if on the stack of an executing method
 206           // * Weakly reachable otherwise
 207           // Some objects reachable from nmethods, such as the class loader (or klass_holder) of the receiver should be
 208           // live by the SATB invariant but other oops recorded in nmethods may behave differently.
 209           JavaThread* jt = (JavaThread*)thread;
 210           jt-&gt;nmethods_do(_code_cl);
 211         }
 212       }
 213     }
 214   }
 215 };
 216 
<span class="line-added"> 217 // Process concurrent roots at safepoints</span>
<span class="line-added"> 218 template &lt;typename T&gt;</span>
<span class="line-added"> 219 class ShenandoahProcessConcurrentRootsTask : public AbstractGangTask {</span>
<span class="line-added"> 220 private:</span>
<span class="line-added"> 221   ShenandoahConcurrentRootScanner&lt;false /* concurrent */&gt; _rs;</span>
<span class="line-added"> 222   ShenandoahConcurrentMark* const _cm;</span>
<span class="line-added"> 223   ReferenceProcessor*             _rp;</span>
<span class="line-added"> 224 public:</span>
<span class="line-added"> 225 </span>
<span class="line-added"> 226   ShenandoahProcessConcurrentRootsTask(ShenandoahConcurrentMark* cm,</span>
<span class="line-added"> 227                                        ShenandoahPhaseTimings::Phase phase,</span>
<span class="line-added"> 228                                        uint nworkers);</span>
<span class="line-added"> 229   void work(uint worker_id);</span>
<span class="line-added"> 230 };</span>
<span class="line-added"> 231 </span>
<span class="line-added"> 232 template &lt;typename T&gt;</span>
<span class="line-added"> 233 ShenandoahProcessConcurrentRootsTask&lt;T&gt;::ShenandoahProcessConcurrentRootsTask(ShenandoahConcurrentMark* cm,</span>
<span class="line-added"> 234                                                                               ShenandoahPhaseTimings::Phase phase,</span>
<span class="line-added"> 235                                                                               uint nworkers) :</span>
<span class="line-added"> 236   AbstractGangTask(&quot;Shenandoah STW Concurrent Mark Task&quot;),</span>
<span class="line-added"> 237   _rs(nworkers, phase),</span>
<span class="line-added"> 238   _cm(cm),</span>
<span class="line-added"> 239   _rp(NULL) {</span>
<span class="line-added"> 240   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added"> 241   if (heap-&gt;process_references()) {</span>
<span class="line-added"> 242     _rp = heap-&gt;ref_processor();</span>
<span class="line-added"> 243     shenandoah_assert_rp_isalive_installed();</span>
<span class="line-added"> 244   }</span>
<span class="line-added"> 245 }</span>
<span class="line-added"> 246 </span>
<span class="line-added"> 247 template &lt;typename T&gt;</span>
<span class="line-added"> 248 void ShenandoahProcessConcurrentRootsTask&lt;T&gt;::work(uint worker_id) {</span>
<span class="line-added"> 249   ShenandoahParallelWorkerSession worker_session(worker_id);</span>
<span class="line-added"> 250   ShenandoahObjToScanQueue* q = _cm-&gt;task_queues()-&gt;queue(worker_id);</span>
<span class="line-added"> 251   T cl(q, _rp);</span>
<span class="line-added"> 252   _rs.oops_do(&amp;cl, worker_id);</span>
<span class="line-added"> 253 }</span>
<span class="line-added"> 254 </span>
 255 class ShenandoahFinalMarkingTask : public AbstractGangTask {
 256 private:
 257   ShenandoahConcurrentMark* _cm;
 258   TaskTerminator*           _terminator;
 259   bool _dedup_string;
 260 
 261 public:
 262   ShenandoahFinalMarkingTask(ShenandoahConcurrentMark* cm, TaskTerminator* terminator, bool dedup_string) :
 263     AbstractGangTask(&quot;Shenandoah Final Marking&quot;), _cm(cm), _terminator(terminator), _dedup_string(dedup_string) {
 264   }
 265 
 266   void work(uint worker_id) {
 267     ShenandoahHeap* heap = ShenandoahHeap::heap();
 268 
 269     ShenandoahParallelWorkerSession worker_session(worker_id);
 270     ReferenceProcessor* rp;
 271     if (heap-&gt;process_references()) {
 272       rp = heap-&gt;ref_processor();
 273       shenandoah_assert_rp_isalive_installed();
 274     } else {
</pre>
<hr />
<pre>
 287       SATBMarkQueueSet&amp; satb_mq_set = ShenandoahBarrierSet::satb_mark_queue_set();
 288       while (satb_mq_set.apply_closure_to_completed_buffer(&amp;cl));
 289       bool do_nmethods = heap-&gt;unload_classes() &amp;&amp; !ShenandoahConcurrentRoots::can_do_concurrent_class_unloading();
 290       if (heap-&gt;has_forwarded_objects()) {
 291         ShenandoahMarkResolveRefsClosure resolve_mark_cl(q, rp);
 292         MarkingCodeBlobClosure blobsCl(&amp;resolve_mark_cl, !CodeBlobToOopClosure::FixRelocations);
 293         ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&amp;cl,
 294                                                           ShenandoahStoreValEnqueueBarrier ? &amp;resolve_mark_cl : NULL,
 295                                                           do_nmethods ? &amp;blobsCl : NULL);
 296         Threads::threads_do(&amp;tc);
 297       } else {
 298         ShenandoahMarkRefsClosure mark_cl(q, rp);
 299         MarkingCodeBlobClosure blobsCl(&amp;mark_cl, !CodeBlobToOopClosure::FixRelocations);
 300         ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&amp;cl,
 301                                                           ShenandoahStoreValEnqueueBarrier ? &amp;mark_cl : NULL,
 302                                                           do_nmethods ? &amp;blobsCl : NULL);
 303         Threads::threads_do(&amp;tc);
 304       }
 305     }
 306 






 307     _cm-&gt;mark_loop(worker_id, _terminator, rp,
 308                    false, // not cancellable
 309                    _dedup_string);
 310 
 311     assert(_cm-&gt;task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
 312   }
 313 };
 314 
 315 void ShenandoahConcurrentMark::mark_roots(ShenandoahPhaseTimings::Phase root_phase) {
 316   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
 317   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 318 
 319   ShenandoahHeap* heap = ShenandoahHeap::heap();
 320 
 321   ShenandoahGCPhase phase(root_phase);
 322 
 323   WorkGang* workers = heap-&gt;workers();
 324   uint nworkers = workers-&gt;active_workers();
 325 
 326   assert(nworkers &lt;= task_queues()-&gt;size(), &quot;Just check&quot;);
 327 
 328   ShenandoahRootScanner root_proc(nworkers, root_phase);
 329   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
 330   task_queues()-&gt;reserve(nworkers);
 331 
 332   if (heap-&gt;has_forwarded_objects()) {
 333     ShenandoahInitMarkRootsTask&lt;RESOLVE&gt; mark_roots(&amp;root_proc);
 334     workers-&gt;run_task(&amp;mark_roots);
 335   } else {
 336     // No need to update references, which means the heap is stable.
 337     // Can save time not walking through forwarding pointers.
 338     ShenandoahInitMarkRootsTask&lt;NONE&gt; mark_roots(&amp;root_proc);
 339     workers-&gt;run_task(&amp;mark_roots);
 340   }


 341 }
 342 
 343 void ShenandoahConcurrentMark::update_roots(ShenandoahPhaseTimings::Phase root_phase) {
 344   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 345   assert(root_phase == ShenandoahPhaseTimings::full_gc_update_roots ||
 346          root_phase == ShenandoahPhaseTimings::degen_gc_update_roots,
 347          &quot;Only for these phases&quot;);
 348 
 349   ShenandoahGCPhase phase(root_phase);
 350 
 351   bool check_alive = root_phase == ShenandoahPhaseTimings::degen_gc_update_roots;
 352 
 353 #if COMPILER2_OR_JVMCI
 354   DerivedPointerTable::clear();
 355 #endif
 356 
 357   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 358 
 359   ShenandoahRootUpdater root_updater(nworkers, root_phase);
 360   ShenandoahUpdateRootsTask update_roots(&amp;root_updater, check_alive);
</pre>
<hr />
<pre>
 401 
 402 #if COMPILER2_OR_JVMCI
 403   DerivedPointerTable::update_pointers();
 404 #endif
 405 }
 406 
 407 void ShenandoahConcurrentMark::initialize(uint workers) {
 408   _heap = ShenandoahHeap::heap();
 409 
 410   uint num_queues = MAX2(workers, 1U);
 411 
 412   _task_queues = new ShenandoahObjToScanQueueSet((int) num_queues);
 413 
 414   for (uint i = 0; i &lt; num_queues; ++i) {
 415     ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();
 416     task_queue-&gt;initialize();
 417     _task_queues-&gt;register_queue(i, task_queue);
 418   }
 419 }
 420 
<span class="line-modified"> 421 // Mark concurrent roots during concurrent phases</span>
<span class="line-modified"> 422 class ShenandoahMarkConcurrentRootsTask : public AbstractGangTask {</span>
<span class="line-modified"> 423 private:</span>
<span class="line-modified"> 424   SuspendibleThreadSetJoiner         _sts_joiner;</span>
<span class="line-modified"> 425   ShenandoahConcurrentRootScanner&lt;true /* concurrent */&gt; _rs;</span>
<span class="line-modified"> 426   ShenandoahObjToScanQueueSet* const _queue_set;</span>
<span class="line-modified"> 427   ReferenceProcessor* const          _rp;</span>
<span class="line-modified"> 428 </span>
<span class="line-modified"> 429 public:</span>
<span class="line-modified"> 430   ShenandoahMarkConcurrentRootsTask(ShenandoahObjToScanQueueSet* qs,</span>
<span class="line-modified"> 431                                     ReferenceProcessor* rp,</span>
<span class="line-modified"> 432                                     ShenandoahPhaseTimings::Phase phase,</span>
<span class="line-modified"> 433                                     uint nworkers);</span>
<span class="line-modified"> 434   void work(uint worker_id);</span>
<span class="line-modified"> 435 };</span>
<span class="line-modified"> 436 </span>
<span class="line-modified"> 437 ShenandoahMarkConcurrentRootsTask::ShenandoahMarkConcurrentRootsTask(ShenandoahObjToScanQueueSet* qs,</span>
<span class="line-modified"> 438                                                                      ReferenceProcessor* rp,</span>
<span class="line-added"> 439                                                                      ShenandoahPhaseTimings::Phase phase,</span>
<span class="line-added"> 440                                                                      uint nworkers) :</span>
<span class="line-added"> 441   AbstractGangTask(&quot;Shenandoah Concurrent Mark Task&quot;),</span>
<span class="line-added"> 442   _rs(nworkers, phase),</span>
<span class="line-added"> 443   _queue_set(qs),</span>
<span class="line-added"> 444   _rp(rp) {</span>
<span class="line-added"> 445   assert(!ShenandoahHeap::heap()-&gt;has_forwarded_objects(), &quot;Not expected&quot;);</span>
<span class="line-added"> 446 }</span>
<span class="line-added"> 447 </span>
<span class="line-added"> 448 void ShenandoahMarkConcurrentRootsTask::work(uint worker_id) {</span>
<span class="line-added"> 449   ShenandoahConcurrentWorkerSession worker_session(worker_id);</span>
<span class="line-added"> 450   ShenandoahObjToScanQueue* q = _queue_set-&gt;queue(worker_id);</span>
<span class="line-added"> 451   ShenandoahMarkResolveRefsClosure cl(q, _rp);</span>
<span class="line-added"> 452   _rs.oops_do(&amp;cl, worker_id);</span>
 453 }
 454 
 455 void ShenandoahConcurrentMark::mark_from_roots() {
 456   WorkGang* workers = _heap-&gt;workers();
 457   uint nworkers = workers-&gt;active_workers();
 458 
<span class="line-added"> 459   ReferenceProcessor* rp = NULL;</span>
 460   if (_heap-&gt;process_references()) {
<span class="line-modified"> 461     rp = _heap-&gt;ref_processor();</span>
 462     rp-&gt;set_active_mt_degree(nworkers);
 463 
 464     // enable (&quot;weak&quot;) refs discovery
 465     rp-&gt;enable_discovery(true /*verify_no_refs*/);
 466     rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
 467   }
 468 
 469   shenandoah_assert_rp_isalive_not_installed();
 470   ShenandoahIsAliveSelector is_alive;
 471   ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
 472 
 473   task_queues()-&gt;reserve(nworkers);
 474 
<span class="line-added"> 475   {</span>
<span class="line-added"> 476     ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_mark_roots);</span>
<span class="line-added"> 477     // Use separate task to mark concurrent roots, since it may hold ClassLoaderData_lock and CodeCache_lock</span>
<span class="line-added"> 478     ShenandoahMarkConcurrentRootsTask task(task_queues(), rp, ShenandoahPhaseTimings::conc_mark_roots, nworkers);</span>
<span class="line-added"> 479     workers-&gt;run_task(&amp;task);</span>
<span class="line-added"> 480   }</span>
<span class="line-added"> 481 </span>
 482   {
 483     TaskTerminator terminator(nworkers, task_queues());
 484     ShenandoahConcurrentMarkingTask task(this, &amp;terminator);
 485     workers-&gt;run_task(&amp;task);
 486   }
 487 
 488   assert(task_queues()-&gt;is_empty() || _heap-&gt;cancelled_gc(), &quot;Should be empty when not cancelled&quot;);
 489 }
 490 
 491 void ShenandoahConcurrentMark::finish_mark_from_roots(bool full_gc) {
 492   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 493 
 494   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 495 







 496   {





 497     shenandoah_assert_rp_isalive_not_installed();
 498     ShenandoahIsAliveSelector is_alive;
 499     ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
 500 
<span class="line-modified"> 501     // Full GC does not execute concurrent cycle. Degenerated cycle may bypass concurrent cycle.</span>
<span class="line-modified"> 502     // In those cases, concurrent roots might not be scanned, scan them here. Ideally, this</span>
<span class="line-modified"> 503     // should piggyback to ShenandoahFinalMarkingTask, but it makes time tracking very hard.</span>
<span class="line-modified"> 504     // Given full GC and degenerated GC are rare, use a separate task.</span>
<span class="line-modified"> 505     if (_heap-&gt;is_degenerated_gc_in_progress() || _heap-&gt;is_full_gc_in_progress()) {</span>
<span class="line-added"> 506       ShenandoahPhaseTimings::Phase phase = _heap-&gt;is_full_gc_in_progress() ?</span>
<span class="line-added"> 507                                             ShenandoahPhaseTimings::full_gc_scan_conc_roots :</span>
<span class="line-added"> 508                                             ShenandoahPhaseTimings::degen_gc_scan_conc_roots;</span>
<span class="line-added"> 509       ShenandoahGCPhase gc_phase(phase);</span>
<span class="line-added"> 510       if (_heap-&gt;has_forwarded_objects()) {</span>
<span class="line-added"> 511         ShenandoahProcessConcurrentRootsTask&lt;ShenandoahMarkResolveRefsClosure&gt; task(this, phase, nworkers);</span>
<span class="line-added"> 512         _heap-&gt;workers()-&gt;run_task(&amp;task);</span>
<span class="line-added"> 513       } else {</span>
<span class="line-added"> 514         ShenandoahProcessConcurrentRootsTask&lt;ShenandoahMarkRefsClosure&gt; task(this, phase, nworkers);</span>
<span class="line-added"> 515         _heap-&gt;workers()-&gt;run_task(&amp;task);</span>
<span class="line-added"> 516       }</span>
<span class="line-added"> 517     }</span>
 518 
<span class="line-modified"> 519     // Finally mark everything else we&#39;ve got in our queues during the previous steps.</span>
<span class="line-added"> 520     // It does two different things for concurrent vs. mark-compact GC:</span>
<span class="line-added"> 521     // - For concurrent GC, it starts with empty task queues, drains the remaining</span>
<span class="line-added"> 522     //   SATB buffers, and then completes the marking closure.</span>
<span class="line-added"> 523     // - For mark-compact GC, it starts out with the task queues seeded by initial</span>
<span class="line-added"> 524     //   root scan, and completes the closure, thus marking through all live objects</span>
<span class="line-added"> 525     // The implementation is the same, so it&#39;s shared here.</span>
<span class="line-added"> 526     {</span>
<span class="line-added"> 527       ShenandoahGCPhase phase(full_gc ?</span>
<span class="line-added"> 528                               ShenandoahPhaseTimings::full_gc_mark_finish_queues :</span>
<span class="line-added"> 529                               ShenandoahPhaseTimings::finish_queues);</span>
<span class="line-added"> 530       task_queues()-&gt;reserve(nworkers);</span>
<span class="line-added"> 531 </span>
<span class="line-added"> 532       StrongRootsScope scope(nworkers);</span>
<span class="line-added"> 533       TaskTerminator terminator(nworkers, task_queues());</span>
<span class="line-added"> 534       ShenandoahFinalMarkingTask task(this, &amp;terminator, ShenandoahStringDedup::is_enabled());</span>
<span class="line-added"> 535       _heap-&gt;workers()-&gt;run_task(&amp;task);</span>
<span class="line-added"> 536     }</span>
<span class="line-added"> 537 </span>
<span class="line-added"> 538     assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);</span>
<span class="line-added"> 539   }</span>
 540 
 541   // When we&#39;re done marking everything, we process weak references.
 542   if (_heap-&gt;process_references()) {
 543     weak_refs_work(full_gc);
 544   }
 545 
 546   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
 547   TASKQUEUE_STATS_ONLY(task_queues()-&gt;print_taskqueue_stats());
 548   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
 549 }
 550 
 551 // Weak Reference Closures
 552 class ShenandoahCMDrainMarkingStackClosure: public VoidClosure {
 553   uint _worker_id;
 554   TaskTerminator* _terminator;
 555   bool _reset_terminator;
 556 
 557 public:
 558   ShenandoahCMDrainMarkingStackClosure(uint worker_id, TaskTerminator* t, bool reset_terminator = false):
 559     _worker_id(worker_id),
</pre>
<hr />
<pre>
 993     uint work = 0;
 994     for (uint i = 0; i &lt; stride; i++) {
 995       if (q-&gt;pop(t) ||
 996           queues-&gt;steal(worker_id, t)) {
 997         do_task&lt;T&gt;(q, cl, live_data, &amp;t);
 998         work++;
 999       } else {
1000         break;
1001       }
1002     }
1003 
1004     if (work == 0) {
1005       // No work encountered in current stride, try to terminate.
1006       // Need to leave the STS here otherwise it might block safepoints.
1007       ShenandoahSuspendibleThreadSetLeaver stsl(CANCELLABLE &amp;&amp; ShenandoahSuspendibleWorkers);
1008       ShenandoahTerminatorTerminator tt(heap);
1009       if (terminator-&gt;offer_termination(&amp;tt)) return;
1010     }
1011   }
1012 }








</pre>
</td>
</tr>
</table>
<center><a href="c2/shenandoahSupport.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahConcurrentMark.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
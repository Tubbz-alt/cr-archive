<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2020, Red Hat, Inc. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/stringTable.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;code/codeCache.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;code/nmethod.hpp&quot;</span>
 32 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
 35 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 36 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
 37 #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
 38 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
 39 #include &quot;jfr/jfr.hpp&quot;
 40 #include &quot;memory/iterator.hpp&quot;
 41 #include &quot;memory/resourceArea.hpp&quot;
 42 #include &quot;memory/universe.hpp&quot;
 43 #include &quot;runtime/thread.hpp&quot;
 44 #include &quot;services/management.hpp&quot;
 45 
 46 ShenandoahSerialRoot::ShenandoahSerialRoot(ShenandoahSerialRoot::OopsDo oops_do,
 47   ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase) :
 48   _oops_do(oops_do), _phase(phase), _par_phase(par_phase) {
 49 }
 50 
 51 void ShenandoahSerialRoot::oops_do(OopClosure* cl, uint worker_id) {
 52   if (_claimed.try_set()) {
 53     ShenandoahWorkerTimingsTracker timer(_phase, _par_phase, worker_id);
 54     _oops_do(cl);
 55   }
 56 }
 57 
 58 // Overwrite the second argument for SD::oops_do, don&#39;t include vm global oop storage.
 59 static void system_dictionary_oops_do(OopClosure* cl) {
 60   SystemDictionary::oops_do(cl, false);
 61 }
 62 
 63 ShenandoahSerialRoots::ShenandoahSerialRoots(ShenandoahPhaseTimings::Phase phase) :
 64   _universe_root(&amp;Universe::oops_do, phase, ShenandoahPhaseTimings::UniverseRoots),
 65   _object_synchronizer_root(&amp;ObjectSynchronizer::oops_do, phase, ShenandoahPhaseTimings::ObjectSynchronizerRoots),
 66   _management_root(&amp;Management::oops_do, phase, ShenandoahPhaseTimings::ManagementRoots),
 67   _system_dictionary_root(&amp;system_dictionary_oops_do, phase, ShenandoahPhaseTimings::SystemDictionaryRoots),
 68   _jvmti_root(&amp;JvmtiExport::oops_do, phase, ShenandoahPhaseTimings::JVMTIRoots) {
 69 }
 70 
 71 void ShenandoahSerialRoots::oops_do(OopClosure* cl, uint worker_id) {
 72   _universe_root.oops_do(cl, worker_id);
 73   _object_synchronizer_root.oops_do(cl, worker_id);
 74   _management_root.oops_do(cl, worker_id);
 75   _system_dictionary_root.oops_do(cl, worker_id);
 76   _jvmti_root.oops_do(cl, worker_id);
 77 }
 78 
 79 ShenandoahWeakSerialRoot::ShenandoahWeakSerialRoot(ShenandoahWeakSerialRoot::WeakOopsDo weak_oops_do,
 80   ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase) :
 81   _weak_oops_do(weak_oops_do), _phase(phase), _par_phase(par_phase) {
 82 }
 83 
 84 void ShenandoahWeakSerialRoot::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {
 85   if (_claimed.try_set()) {
 86     ShenandoahWorkerTimingsTracker timer(_phase, _par_phase, worker_id);
 87     _weak_oops_do(is_alive, keep_alive);
 88   }
 89 }
 90 
 91 #if INCLUDE_JVMTI
 92 ShenandoahJVMTIWeakRoot::ShenandoahJVMTIWeakRoot(ShenandoahPhaseTimings::Phase phase) :
 93   ShenandoahWeakSerialRoot(&amp;JvmtiExport::weak_oops_do, phase, ShenandoahPhaseTimings::JVMTIWeakRoots) {
 94 }
 95 #endif // INCLUDE_JVMTI
 96 
 97 #if INCLUDE_JFR
 98 ShenandoahJFRWeakRoot::ShenandoahJFRWeakRoot(ShenandoahPhaseTimings::Phase phase) :
 99   ShenandoahWeakSerialRoot(&amp;Jfr::weak_oops_do, phase, ShenandoahPhaseTimings::JFRWeakRoots) {
100 }
101 #endif // INCLUDE_JFR
102 
103 void ShenandoahSerialWeakRoots::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {
104   JVMTI_ONLY(_jvmti_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)
105   JFR_ONLY(_jfr_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)
106 }
107 
108 void ShenandoahSerialWeakRoots::weak_oops_do(OopClosure* cl, uint worker_id) {
109   AlwaysTrueClosure always_true;
110   weak_oops_do(&amp;always_true, cl, worker_id);
111 }
112 
113 ShenandoahThreadRoots::ShenandoahThreadRoots(ShenandoahPhaseTimings::Phase phase, bool is_par) :
114   _phase(phase), _is_par(is_par) {
115   Threads::change_thread_claim_token();
116 }
117 
118 void ShenandoahThreadRoots::oops_do(OopClosure* oops_cl, CodeBlobClosure* code_cl, uint worker_id) {
119   ShenandoahWorkerTimingsTracker timer(_phase, ShenandoahPhaseTimings::ThreadRoots, worker_id);
120   ResourceMark rm;
121   Threads::possibly_parallel_oops_do(_is_par, oops_cl, code_cl);
122 }
123 
124 void ShenandoahThreadRoots::threads_do(ThreadClosure* tc, uint worker_id) {
125   ShenandoahWorkerTimingsTracker timer(_phase, ShenandoahPhaseTimings::ThreadRoots, worker_id);
126   ResourceMark rm;
127   Threads::possibly_parallel_threads_do(_is_par, tc);
128 }
129 
130 ShenandoahThreadRoots::~ShenandoahThreadRoots() {
131   Threads::assert_all_threads_claimed();
132 }
133 
134 ShenandoahStringDedupRoots::ShenandoahStringDedupRoots(ShenandoahPhaseTimings::Phase phase) : _phase(phase) {
135   if (ShenandoahStringDedup::is_enabled()) {
136     StringDedup::gc_prologue(false);
137   }
138 }
139 
140 ShenandoahStringDedupRoots::~ShenandoahStringDedupRoots() {
141   if (ShenandoahStringDedup::is_enabled()) {
142     StringDedup::gc_epilogue();
143   }
144 }
145 
146 void ShenandoahStringDedupRoots::oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {
147   if (ShenandoahStringDedup::is_enabled()) {
148     ShenandoahStringDedup::parallel_oops_do(_phase, is_alive, keep_alive, worker_id);
149   }
150 }
151 
152 ShenandoahConcurrentStringDedupRoots::ShenandoahConcurrentStringDedupRoots() {
153   if (ShenandoahStringDedup::is_enabled()) {
154     StringDedupTable_lock-&gt;lock_without_safepoint_check();
155     StringDedupQueue_lock-&gt;lock_without_safepoint_check();
156     StringDedup::gc_prologue(true);
157   }
158 }
159 
160 ShenandoahConcurrentStringDedupRoots::~ShenandoahConcurrentStringDedupRoots() {
161   if (ShenandoahStringDedup::is_enabled()) {
162     StringDedup::gc_epilogue();
163     StringDedupQueue_lock-&gt;unlock();
164     StringDedupTable_lock-&gt;unlock();
165   }
166 }
167 
168 void ShenandoahConcurrentStringDedupRoots::oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {
169   if (ShenandoahStringDedup::is_enabled()) {
170     assert_locked_or_safepoint_weak(StringDedupQueue_lock);
171     assert_locked_or_safepoint_weak(StringDedupTable_lock);
172 
173     StringDedupUnlinkOrOopsDoClosure sd_cl(is_alive, keep_alive);
174     StringDedupQueue::unlink_or_oops_do(&amp;sd_cl);
175     StringDedupTable::unlink_or_oops_do(&amp;sd_cl, worker_id);
176   }
177 }
178 
179 ShenandoahCodeCacheRoots::ShenandoahCodeCacheRoots(ShenandoahPhaseTimings::Phase phase) : _phase(phase) {
180   nmethod::oops_do_marking_prologue();
181 }
182 
183 void ShenandoahCodeCacheRoots::code_blobs_do(CodeBlobClosure* blob_cl, uint worker_id) {
184   ShenandoahWorkerTimingsTracker timer(_phase, ShenandoahPhaseTimings::CodeCacheRoots, worker_id);
185   _coderoots_iterator.possibly_parallel_blobs_do(blob_cl);
186 }
187 
188 ShenandoahCodeCacheRoots::~ShenandoahCodeCacheRoots() {
189   nmethod::oops_do_marking_epilogue();
190 }
191 
192 ShenandoahRootProcessor::ShenandoahRootProcessor(ShenandoahPhaseTimings::Phase phase) :
193   _heap(ShenandoahHeap::heap()),
194   _phase(phase),
195   _worker_phase(phase) {
196   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must at safepoint&quot;);
197 }
198 
199 ShenandoahRootScanner::ShenandoahRootScanner(uint n_workers, ShenandoahPhaseTimings::Phase phase) :
200   ShenandoahRootProcessor(phase),
201   _serial_roots(phase),
202   _thread_roots(phase, n_workers &gt; 1),
<a name="2" id="anc2"></a><span class="line-modified">203   _dedup_roots(phase) {</span>
<span class="line-modified">204   nmethod::oops_do_marking_prologue();</span>
<span class="line-modified">205 }</span>
<span class="line-modified">206 </span>
<span class="line-added">207 ShenandoahRootScanner::~ShenandoahRootScanner() {</span>
<span class="line-added">208   nmethod::oops_do_marking_epilogue();</span>
209 }
210 
211 void ShenandoahRootScanner::roots_do(uint worker_id, OopClosure* oops) {
212   CLDToOopClosure clds_cl(oops, ClassLoaderData::_claim_strong);
213   MarkingCodeBlobClosure blobs_cl(oops, !CodeBlobToOopClosure::FixRelocations);
214   roots_do(worker_id, oops, &amp;clds_cl, &amp;blobs_cl);
215 }
216 
217 void ShenandoahRootScanner::strong_roots_do(uint worker_id, OopClosure* oops) {
218   CLDToOopClosure clds_cl(oops, ClassLoaderData::_claim_strong);
219   MarkingCodeBlobClosure blobs_cl(oops, !CodeBlobToOopClosure::FixRelocations);
220   strong_roots_do(worker_id, oops, &amp;clds_cl, &amp;blobs_cl);
221 }
222 
223 void ShenandoahRootScanner::roots_do(uint worker_id, OopClosure* oops, CLDClosure* clds, CodeBlobClosure* code, ThreadClosure *tc) {
224   assert(!ShenandoahSafepoint::is_at_shenandoah_safepoint() ||
225          !ShenandoahHeap::heap()-&gt;unload_classes(),
226           &quot;Expect class unloading when Shenandoah cycle is running&quot;);
<a name="3" id="anc3"></a><span class="line-added">227   assert(clds != NULL, &quot;Only possible with CLD closure&quot;);</span>
<span class="line-added">228 </span>
<span class="line-added">229   AlwaysTrueClosure always_true;</span>
<span class="line-added">230   ShenandoahParallelOopsDoThreadClosure tc_cl(oops, code, tc);</span>
<span class="line-added">231 </span>
232   ResourceMark rm;
233 
<a name="4" id="anc4"></a><span class="line-added">234   // Process serial-claiming roots first</span>
235   _serial_roots.oops_do(oops, worker_id);
<a name="5" id="anc5"></a>
236 
<a name="6" id="anc6"></a><span class="line-modified">237    // Process light-weight/limited parallel roots then</span>
<span class="line-modified">238   _dedup_roots.oops_do(&amp;always_true, oops, worker_id);</span>
239 
<a name="7" id="anc7"></a><span class="line-modified">240   // Process heavy-weight/fully parallel roots the last</span>
241   _thread_roots.threads_do(&amp;tc_cl, worker_id);
<a name="8" id="anc8"></a>


242 }
243 
244 void ShenandoahRootScanner::strong_roots_do(uint worker_id, OopClosure* oops, CLDClosure* clds, CodeBlobClosure* code, ThreadClosure* tc) {
245   assert(ShenandoahHeap::heap()-&gt;unload_classes(), &quot;Should be used during class unloading&quot;);
246   ShenandoahParallelOopsDoThreadClosure tc_cl(oops, code, tc);
<a name="9" id="anc9"></a><span class="line-added">247 </span>
248   ResourceMark rm;
249 
<a name="10" id="anc10"></a><span class="line-added">250   // Process serial-claiming roots first</span>
251   _serial_roots.oops_do(oops, worker_id);
<a name="11" id="anc11"></a><span class="line-modified">252 </span>
<span class="line-modified">253   // Process heavy-weight/fully parallel roots the last</span>
254   _thread_roots.threads_do(&amp;tc_cl, worker_id);
255 }
256 
257 ShenandoahRootEvacuator::ShenandoahRootEvacuator(uint n_workers,
258                                                  ShenandoahPhaseTimings::Phase phase,
259                                                  bool stw_roots_processing,
260                                                  bool stw_class_unloading) :
261   ShenandoahRootProcessor(phase),
262   _serial_roots(phase),
263   _vm_roots(phase),
<a name="12" id="anc12"></a><span class="line-modified">264   _cld_roots(phase, n_workers),</span>
265   _thread_roots(phase, n_workers &gt; 1),
266   _serial_weak_roots(phase),
267   _weak_roots(phase),
268   _dedup_roots(phase),
269   _code_roots(phase),
270   _stw_roots_processing(stw_roots_processing),
271   _stw_class_unloading(stw_class_unloading) {
272 }
273 
274 void ShenandoahRootEvacuator::roots_do(uint worker_id, OopClosure* oops) {
275   MarkingCodeBlobClosure blobsCl(oops, CodeBlobToOopClosure::FixRelocations);
276   ShenandoahCodeBlobAndDisarmClosure blobs_and_disarm_Cl(oops);
277   CodeBlobToOopClosure* codes_cl = ShenandoahConcurrentRoots::can_do_concurrent_class_unloading() ?
278                                    static_cast&lt;CodeBlobToOopClosure*&gt;(&amp;blobs_and_disarm_Cl) :
279                                    static_cast&lt;CodeBlobToOopClosure*&gt;(&amp;blobsCl);
280   AlwaysTrueClosure always_true;
281 
<a name="13" id="anc13"></a><span class="line-added">282   // Process serial-claiming roots first</span>
283   _serial_roots.oops_do(oops, worker_id);
284   _serial_weak_roots.weak_oops_do(oops, worker_id);
<a name="14" id="anc14"></a><span class="line-added">285 </span>
<span class="line-added">286   // Process light-weight/limited parallel roots then</span>
287   if (_stw_roots_processing) {
288     _vm_roots.oops_do&lt;OopClosure&gt;(oops, worker_id);
289     _weak_roots.oops_do&lt;OopClosure&gt;(oops, worker_id);
290     _dedup_roots.oops_do(&amp;always_true, oops, worker_id);
291   }
<a name="15" id="anc15"></a>
292   if (_stw_class_unloading) {
293     CLDToOopClosure clds(oops, ClassLoaderData::_claim_strong);
294     _cld_roots.cld_do(&amp;clds, worker_id);
<a name="16" id="anc16"></a><span class="line-added">295   }</span>
<span class="line-added">296 </span>
<span class="line-added">297   // Process heavy-weight/fully parallel roots the last</span>
<span class="line-added">298   if (_stw_class_unloading) {</span>
299     _code_roots.code_blobs_do(codes_cl, worker_id);
300     _thread_roots.oops_do(oops, NULL, worker_id);
301   } else {
302     _thread_roots.oops_do(oops, codes_cl, worker_id);
303   }
304 }
305 
306 ShenandoahRootUpdater::ShenandoahRootUpdater(uint n_workers, ShenandoahPhaseTimings::Phase phase) :
307   ShenandoahRootProcessor(phase),
308   _serial_roots(phase),
309   _vm_roots(phase),
<a name="17" id="anc17"></a><span class="line-modified">310   _cld_roots(phase, n_workers),</span>
311   _thread_roots(phase, n_workers &gt; 1),
312   _serial_weak_roots(phase),
313   _weak_roots(phase),
314   _dedup_roots(phase),
315   _code_roots(phase) {
316 }
317 
318 ShenandoahRootAdjuster::ShenandoahRootAdjuster(uint n_workers, ShenandoahPhaseTimings::Phase phase) :
319   ShenandoahRootProcessor(phase),
320   _serial_roots(phase),
321   _vm_roots(phase),
<a name="18" id="anc18"></a><span class="line-modified">322   _cld_roots(phase, n_workers),</span>
323   _thread_roots(phase, n_workers &gt; 1),
324   _serial_weak_roots(phase),
325   _weak_roots(phase),
326   _dedup_roots(phase),
327   _code_roots(phase) {
328   assert(ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;Full GC only&quot;);
329 }
330 
331 void ShenandoahRootAdjuster::roots_do(uint worker_id, OopClosure* oops) {
332   CodeBlobToOopClosure code_blob_cl(oops, CodeBlobToOopClosure::FixRelocations);
333   ShenandoahCodeBlobAndDisarmClosure blobs_and_disarm_Cl(oops);
334   CodeBlobToOopClosure* adjust_code_closure = ShenandoahConcurrentRoots::can_do_concurrent_class_unloading() ?
335                                               static_cast&lt;CodeBlobToOopClosure*&gt;(&amp;blobs_and_disarm_Cl) :
336                                               static_cast&lt;CodeBlobToOopClosure*&gt;(&amp;code_blob_cl);
337   CLDToOopClosure adjust_cld_closure(oops, ClassLoaderData::_claim_strong);
338   AlwaysTrueClosure always_true;
339 
<a name="19" id="anc19"></a><span class="line-added">340   // Process serial-claiming roots first</span>
341   _serial_roots.oops_do(oops, worker_id);
<a name="20" id="anc20"></a>





342   _serial_weak_roots.weak_oops_do(oops, worker_id);
<a name="21" id="anc21"></a><span class="line-added">343 </span>
<span class="line-added">344   // Process light-weight/limited parallel roots then</span>
<span class="line-added">345   _vm_roots.oops_do(oops, worker_id);</span>
346   _weak_roots.oops_do&lt;OopClosure&gt;(oops, worker_id);
347   _dedup_roots.oops_do(&amp;always_true, oops, worker_id);
<a name="22" id="anc22"></a><span class="line-added">348   _cld_roots.cld_do(&amp;adjust_cld_closure, worker_id);</span>
<span class="line-added">349 </span>
<span class="line-added">350   // Process heavy-weight/fully parallel roots the last</span>
<span class="line-added">351   _code_roots.code_blobs_do(adjust_code_closure, worker_id);</span>
<span class="line-added">352   _thread_roots.oops_do(oops, NULL, worker_id);</span>
353 }
354 
355 ShenandoahHeapIterationRootScanner::ShenandoahHeapIterationRootScanner() :
356    ShenandoahRootProcessor(ShenandoahPhaseTimings::heap_iteration_roots),
357    _serial_roots(ShenandoahPhaseTimings::heap_iteration_roots),
358    _thread_roots(ShenandoahPhaseTimings::heap_iteration_roots, false /*is par*/),
359    _vm_roots(ShenandoahPhaseTimings::heap_iteration_roots),
<a name="23" id="anc23"></a><span class="line-modified">360    _cld_roots(ShenandoahPhaseTimings::heap_iteration_roots, 1),</span>
361    _serial_weak_roots(ShenandoahPhaseTimings::heap_iteration_roots),
362    _weak_roots(ShenandoahPhaseTimings::heap_iteration_roots),
363    _code_roots(ShenandoahPhaseTimings::heap_iteration_roots) {
364  }
365 
366  void ShenandoahHeapIterationRootScanner::roots_do(OopClosure* oops) {
367    assert(Thread::current()-&gt;is_VM_thread(), &quot;Only by VM thread&quot;);
368    // Must use _claim_none to avoid interfering with concurrent CLDG iteration
369    CLDToOopClosure clds(oops, ClassLoaderData::_claim_none);
370    MarkingCodeBlobClosure code(oops, !CodeBlobToOopClosure::FixRelocations);
371    ShenandoahParallelOopsDoThreadClosure tc_cl(oops, &amp;code, NULL);
372    AlwaysTrueClosure always_true;
<a name="24" id="anc24"></a><span class="line-added">373 </span>
374    ResourceMark rm;
375 
<a name="25" id="anc25"></a><span class="line-added">376    // Process serial-claiming roots first</span>
377    _serial_roots.oops_do(oops, 0);
<a name="26" id="anc26"></a>




378    _serial_weak_roots.weak_oops_do(oops, 0);
<a name="27" id="anc27"></a><span class="line-added">379 </span>
<span class="line-added">380    // Process light-weight/limited parallel roots then</span>
<span class="line-added">381    _vm_roots.oops_do(oops, 0);</span>
382    _weak_roots.oops_do&lt;OopClosure&gt;(oops, 0);
383    _dedup_roots.oops_do(&amp;always_true, oops, 0);
<a name="28" id="anc28"></a><span class="line-added">384    _cld_roots.cld_do(&amp;clds, 0);</span>
<span class="line-added">385 </span>
<span class="line-added">386    // Process heavy-weight/fully parallel roots the last</span>
<span class="line-added">387    _code_roots.code_blobs_do(&amp;code, 0);</span>
<span class="line-added">388    _thread_roots.threads_do(&amp;tc_cl, 0);</span>
389  }
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
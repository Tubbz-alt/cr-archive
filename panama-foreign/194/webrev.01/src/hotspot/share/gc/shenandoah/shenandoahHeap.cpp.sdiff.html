<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahConcurrentMark.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahNMethod.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1572       if (ShenandoahVerify) {
1573         verifier()-&gt;verify_before_evacuation();
1574       }
1575 
1576       set_evacuation_in_progress(true);
1577       // From here on, we need to update references.
1578       set_has_forwarded_objects(true);
1579 
1580       if (!is_degenerated_gc_in_progress()) {
1581         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1582           ShenandoahCodeRoots::arm_nmethods();
1583         }
1584         evacuate_and_update_roots();
1585       }
1586 
1587       if (ShenandoahPacing) {
1588         pacer()-&gt;setup_for_evac();
1589       }
1590 
1591       if (ShenandoahVerify) {
<span class="line-modified">1592         ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::None;</span>
<span class="line-modified">1593         if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {</span>
<span class="line-modified">1594           types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::JNIHandleRoots, ShenandoahRootVerifier::WeakRoots);</span>
<span class="line-modified">1595           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CLDGRoots);</span>
<span class="line-modified">1596           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::StringDedupRoots);</span>








1597         }
<span class="line-removed">1598 </span>
<span class="line-removed">1599         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-removed">1600           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CodeRoots);</span>
<span class="line-removed">1601         }</span>
<span class="line-removed">1602         verifier()-&gt;verify_roots_no_forwarded_except(types);</span>
1603         verifier()-&gt;verify_during_evacuation();
1604       }
1605     } else {
1606       if (ShenandoahVerify) {
1607         verifier()-&gt;verify_after_concmark();
1608       }
1609 
1610       if (VerifyAfterGC) {
1611         Universe::verify();
1612       }
1613     }
1614 
1615   } else {
1616     // If this cycle was updating references, we need to keep the has_forwarded_objects
1617     // flag on, for subsequent phases to deal with it.
1618     concurrent_mark()-&gt;cancel();
1619     set_concurrent_mark_in_progress(false);
1620 
1621     if (process_references()) {
1622       // Abandon reference processing right away: pre-cleaning must have failed.
</pre>
<hr />
<pre>
1643 }
1644 
1645 void ShenandoahHeap::op_cleanup_early() {
1646   free_set()-&gt;recycle_trash();
1647 }
1648 
1649 void ShenandoahHeap::op_cleanup_complete() {
1650   free_set()-&gt;recycle_trash();
1651 }
1652 
1653 class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {
1654 private:
1655   ShenandoahVMRoots&lt;true /*concurrent*/&gt;        _vm_roots;
1656   ShenandoahClassLoaderDataRoots&lt;true /*concurrent*/, false /*single threaded*/&gt; _cld_roots;
1657   ShenandoahConcurrentStringDedupRoots          _dedup_roots;
1658 
1659 public:
1660   ShenandoahConcurrentRootsEvacUpdateTask(ShenandoahPhaseTimings::Phase phase) :
1661     AbstractGangTask(&quot;Shenandoah Evacuate/Update Concurrent Strong Roots Task&quot;),
1662     _vm_roots(phase),
<span class="line-modified">1663     _cld_roots(phase) {}</span>
1664 
1665   void work(uint worker_id) {
1666     ShenandoahConcurrentWorkerSession worker_session(worker_id);
1667     ShenandoahEvacOOMScope oom;
1668     {
1669       // vm_roots and weak_roots are OopStorage backed roots, concurrent iteration
1670       // may race against OopStorage::release() calls.
1671       ShenandoahEvacUpdateOopStorageRootsClosure cl;
1672       _vm_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl, worker_id);
1673     }
1674 
1675     {
1676       ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
1677       CLDToOopClosure clds(&amp;cl, ClassLoaderData::_claim_strong);
1678       _cld_roots.cld_do(&amp;clds, worker_id);
1679     }
1680 
1681     {
1682       ShenandoahForwardedIsAliveClosure is_alive;
1683       ShenandoahEvacuateUpdateRootsClosure&lt;MO_RELEASE&gt; keep_alive;
</pre>
<hr />
<pre>
1764 class ShenandoahConcurrentWeakRootsEvacUpdateTask : public AbstractGangTask {
1765 private:
1766   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _jni_roots;
1767   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _string_table_roots;
1768   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _resolved_method_table_roots;
1769   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _vm_roots;
1770 
1771   // Roots related to concurrent class unloading
1772   ShenandoahClassLoaderDataRoots&lt;true /* concurrent */, false /* single thread*/&gt;
1773                                            _cld_roots;
1774   ShenandoahConcurrentNMethodIterator      _nmethod_itr;
1775   bool                                     _concurrent_class_unloading;
1776 
1777 public:
1778   ShenandoahConcurrentWeakRootsEvacUpdateTask(ShenandoahPhaseTimings::Phase phase) :
1779     AbstractGangTask(&quot;Shenandoah Concurrent Weak Root Task&quot;),
1780     _jni_roots(OopStorageSet::jni_weak(), phase, ShenandoahPhaseTimings::JNIWeakRoots),
1781     _string_table_roots(OopStorageSet::string_table_weak(), phase, ShenandoahPhaseTimings::StringTableRoots),
1782     _resolved_method_table_roots(OopStorageSet::resolved_method_table_weak(), phase, ShenandoahPhaseTimings::ResolvedMethodTableRoots),
1783     _vm_roots(OopStorageSet::vm_weak(), phase, ShenandoahPhaseTimings::VMWeakRoots),
<span class="line-modified">1784     _cld_roots(phase),</span>
1785     _nmethod_itr(ShenandoahCodeRoots::table()),
1786     _concurrent_class_unloading(ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1787     StringTable::reset_dead_counter();
1788     ResolvedMethodTable::reset_dead_counter();
1789     if (_concurrent_class_unloading) {
1790       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1791       _nmethod_itr.nmethods_do_begin();
1792     }
1793   }
1794 
1795   ~ShenandoahConcurrentWeakRootsEvacUpdateTask() {
1796     StringTable::finish_dead_counter();
1797     ResolvedMethodTable::finish_dead_counter();
1798     if (_concurrent_class_unloading) {
1799       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1800       _nmethod_itr.nmethods_do_end();
1801     }
1802   }
1803 
1804   void work(uint worker_id) {
</pre>
</td>
<td>
<hr />
<pre>
1572       if (ShenandoahVerify) {
1573         verifier()-&gt;verify_before_evacuation();
1574       }
1575 
1576       set_evacuation_in_progress(true);
1577       // From here on, we need to update references.
1578       set_has_forwarded_objects(true);
1579 
1580       if (!is_degenerated_gc_in_progress()) {
1581         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1582           ShenandoahCodeRoots::arm_nmethods();
1583         }
1584         evacuate_and_update_roots();
1585       }
1586 
1587       if (ShenandoahPacing) {
1588         pacer()-&gt;setup_for_evac();
1589       }
1590 
1591       if (ShenandoahVerify) {
<span class="line-modified">1592         // If OOM while evacuating/updating of roots, there is no guarantee of their consistencies</span>
<span class="line-modified">1593         if (!cancelled_gc()) {</span>
<span class="line-modified">1594           ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::None;</span>
<span class="line-modified">1595           if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {</span>
<span class="line-modified">1596             types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::JNIHandleRoots, ShenandoahRootVerifier::WeakRoots);</span>
<span class="line-added">1597             types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CLDGRoots);</span>
<span class="line-added">1598             types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::StringDedupRoots);</span>
<span class="line-added">1599           }</span>
<span class="line-added">1600 </span>
<span class="line-added">1601           if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">1602             types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CodeRoots);</span>
<span class="line-added">1603           }</span>
<span class="line-added">1604           verifier()-&gt;verify_roots_no_forwarded_except(types);</span>
1605         }





1606         verifier()-&gt;verify_during_evacuation();
1607       }
1608     } else {
1609       if (ShenandoahVerify) {
1610         verifier()-&gt;verify_after_concmark();
1611       }
1612 
1613       if (VerifyAfterGC) {
1614         Universe::verify();
1615       }
1616     }
1617 
1618   } else {
1619     // If this cycle was updating references, we need to keep the has_forwarded_objects
1620     // flag on, for subsequent phases to deal with it.
1621     concurrent_mark()-&gt;cancel();
1622     set_concurrent_mark_in_progress(false);
1623 
1624     if (process_references()) {
1625       // Abandon reference processing right away: pre-cleaning must have failed.
</pre>
<hr />
<pre>
1646 }
1647 
1648 void ShenandoahHeap::op_cleanup_early() {
1649   free_set()-&gt;recycle_trash();
1650 }
1651 
1652 void ShenandoahHeap::op_cleanup_complete() {
1653   free_set()-&gt;recycle_trash();
1654 }
1655 
1656 class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {
1657 private:
1658   ShenandoahVMRoots&lt;true /*concurrent*/&gt;        _vm_roots;
1659   ShenandoahClassLoaderDataRoots&lt;true /*concurrent*/, false /*single threaded*/&gt; _cld_roots;
1660   ShenandoahConcurrentStringDedupRoots          _dedup_roots;
1661 
1662 public:
1663   ShenandoahConcurrentRootsEvacUpdateTask(ShenandoahPhaseTimings::Phase phase) :
1664     AbstractGangTask(&quot;Shenandoah Evacuate/Update Concurrent Strong Roots Task&quot;),
1665     _vm_roots(phase),
<span class="line-modified">1666     _cld_roots(phase, ShenandoahHeap::heap()-&gt;workers()-&gt;active_workers()) {}</span>
1667 
1668   void work(uint worker_id) {
1669     ShenandoahConcurrentWorkerSession worker_session(worker_id);
1670     ShenandoahEvacOOMScope oom;
1671     {
1672       // vm_roots and weak_roots are OopStorage backed roots, concurrent iteration
1673       // may race against OopStorage::release() calls.
1674       ShenandoahEvacUpdateOopStorageRootsClosure cl;
1675       _vm_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl, worker_id);
1676     }
1677 
1678     {
1679       ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
1680       CLDToOopClosure clds(&amp;cl, ClassLoaderData::_claim_strong);
1681       _cld_roots.cld_do(&amp;clds, worker_id);
1682     }
1683 
1684     {
1685       ShenandoahForwardedIsAliveClosure is_alive;
1686       ShenandoahEvacuateUpdateRootsClosure&lt;MO_RELEASE&gt; keep_alive;
</pre>
<hr />
<pre>
1767 class ShenandoahConcurrentWeakRootsEvacUpdateTask : public AbstractGangTask {
1768 private:
1769   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _jni_roots;
1770   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _string_table_roots;
1771   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _resolved_method_table_roots;
1772   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _vm_roots;
1773 
1774   // Roots related to concurrent class unloading
1775   ShenandoahClassLoaderDataRoots&lt;true /* concurrent */, false /* single thread*/&gt;
1776                                            _cld_roots;
1777   ShenandoahConcurrentNMethodIterator      _nmethod_itr;
1778   bool                                     _concurrent_class_unloading;
1779 
1780 public:
1781   ShenandoahConcurrentWeakRootsEvacUpdateTask(ShenandoahPhaseTimings::Phase phase) :
1782     AbstractGangTask(&quot;Shenandoah Concurrent Weak Root Task&quot;),
1783     _jni_roots(OopStorageSet::jni_weak(), phase, ShenandoahPhaseTimings::JNIWeakRoots),
1784     _string_table_roots(OopStorageSet::string_table_weak(), phase, ShenandoahPhaseTimings::StringTableRoots),
1785     _resolved_method_table_roots(OopStorageSet::resolved_method_table_weak(), phase, ShenandoahPhaseTimings::ResolvedMethodTableRoots),
1786     _vm_roots(OopStorageSet::vm_weak(), phase, ShenandoahPhaseTimings::VMWeakRoots),
<span class="line-modified">1787     _cld_roots(phase, ShenandoahHeap::heap()-&gt;workers()-&gt;active_workers()),</span>
1788     _nmethod_itr(ShenandoahCodeRoots::table()),
1789     _concurrent_class_unloading(ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1790     StringTable::reset_dead_counter();
1791     ResolvedMethodTable::reset_dead_counter();
1792     if (_concurrent_class_unloading) {
1793       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1794       _nmethod_itr.nmethods_do_begin();
1795     }
1796   }
1797 
1798   ~ShenandoahConcurrentWeakRootsEvacUpdateTask() {
1799     StringTable::finish_dead_counter();
1800     ResolvedMethodTable::finish_dead_counter();
1801     if (_concurrent_class_unloading) {
1802       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1803       _nmethod_itr.nmethods_do_end();
1804     }
1805   }
1806 
1807   void work(uint worker_id) {
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahConcurrentMark.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahNMethod.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
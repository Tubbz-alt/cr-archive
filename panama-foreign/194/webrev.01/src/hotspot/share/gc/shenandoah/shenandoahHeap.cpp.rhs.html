<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2013, 2020, Red Hat, Inc. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.hpp&quot;
  27 #include &quot;memory/universe.hpp&quot;
  28 
  29 #include &quot;gc/shared/gcArguments.hpp&quot;
  30 #include &quot;gc/shared/gcTimer.hpp&quot;
  31 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  32 #include &quot;gc/shared/locationPrinter.inline.hpp&quot;
  33 #include &quot;gc/shared/memAllocator.hpp&quot;
  34 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  35 #include &quot;gc/shared/plab.hpp&quot;
  36 
  37 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
  38 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
  39 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  40 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  41 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
  42 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
  43 #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
  44 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  45 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  46 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  47 #include &quot;gc/shenandoah/shenandoahHeapRegion.inline.hpp&quot;
  48 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
  49 #include &quot;gc/shenandoah/shenandoahInitLogger.hpp&quot;
  50 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  51 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  52 #include &quot;gc/shenandoah/shenandoahMemoryPool.hpp&quot;
  53 #include &quot;gc/shenandoah/shenandoahMetrics.hpp&quot;
  54 #include &quot;gc/shenandoah/shenandoahMonitoringSupport.hpp&quot;
  55 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
  56 #include &quot;gc/shenandoah/shenandoahPacer.inline.hpp&quot;
  57 #include &quot;gc/shenandoah/shenandoahPadding.hpp&quot;
  58 #include &quot;gc/shenandoah/shenandoahParallelCleaning.inline.hpp&quot;
  59 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
  60 #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
  61 #include &quot;gc/shenandoah/shenandoahTaskqueue.hpp&quot;
  62 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  63 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  64 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
  65 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  66 #include &quot;gc/shenandoah/shenandoahWorkGroup.hpp&quot;
  67 #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
  68 #include &quot;gc/shenandoah/mode/shenandoahIUMode.hpp&quot;
  69 #include &quot;gc/shenandoah/mode/shenandoahPassiveMode.hpp&quot;
  70 #include &quot;gc/shenandoah/mode/shenandoahSATBMode.hpp&quot;
  71 #if INCLUDE_JFR
  72 #include &quot;gc/shenandoah/shenandoahJfrSupport.hpp&quot;
  73 #endif
  74 
  75 #include &quot;memory/metaspace.hpp&quot;
  76 #include &quot;oops/compressedOops.inline.hpp&quot;
  77 #include &quot;runtime/atomic.hpp&quot;
  78 #include &quot;runtime/globals.hpp&quot;
  79 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  80 #include &quot;runtime/orderAccess.hpp&quot;
  81 #include &quot;runtime/safepointMechanism.hpp&quot;
  82 #include &quot;runtime/vmThread.hpp&quot;
  83 #include &quot;services/mallocTracker.hpp&quot;
  84 #include &quot;utilities/powerOfTwo.hpp&quot;
  85 
  86 ShenandoahHeap* ShenandoahHeap::_heap = NULL;
  87 
  88 #ifdef ASSERT
  89 template &lt;class T&gt;
  90 void ShenandoahAssertToSpaceClosure::do_oop_work(T* p) {
  91   T o = RawAccess&lt;&gt;::oop_load(p);
  92   if (! CompressedOops::is_null(o)) {
  93     oop obj = CompressedOops::decode_not_null(o);
  94     shenandoah_assert_not_forwarded(p, obj);
  95   }
  96 }
  97 
  98 void ShenandoahAssertToSpaceClosure::do_oop(narrowOop* p) { do_oop_work(p); }
  99 void ShenandoahAssertToSpaceClosure::do_oop(oop* p)       { do_oop_work(p); }
 100 #endif
 101 
 102 class ShenandoahPretouchHeapTask : public AbstractGangTask {
 103 private:
 104   ShenandoahRegionIterator _regions;
 105   const size_t _page_size;
 106 public:
 107   ShenandoahPretouchHeapTask(size_t page_size) :
 108     AbstractGangTask(&quot;Shenandoah Pretouch Heap&quot;),
 109     _page_size(page_size) {}
 110 
 111   virtual void work(uint worker_id) {
 112     ShenandoahHeapRegion* r = _regions.next();
 113     while (r != NULL) {
 114       if (r-&gt;is_committed()) {
 115         os::pretouch_memory(r-&gt;bottom(), r-&gt;end(), _page_size);
 116       }
 117       r = _regions.next();
 118     }
 119   }
 120 };
 121 
 122 class ShenandoahPretouchBitmapTask : public AbstractGangTask {
 123 private:
 124   ShenandoahRegionIterator _regions;
 125   char* _bitmap_base;
 126   const size_t _bitmap_size;
 127   const size_t _page_size;
 128 public:
 129   ShenandoahPretouchBitmapTask(char* bitmap_base, size_t bitmap_size, size_t page_size) :
 130     AbstractGangTask(&quot;Shenandoah Pretouch Bitmap&quot;),
 131     _bitmap_base(bitmap_base),
 132     _bitmap_size(bitmap_size),
 133     _page_size(page_size) {}
 134 
 135   virtual void work(uint worker_id) {
 136     ShenandoahHeapRegion* r = _regions.next();
 137     while (r != NULL) {
 138       size_t start = r-&gt;index()       * ShenandoahHeapRegion::region_size_bytes() / MarkBitMap::heap_map_factor();
 139       size_t end   = (r-&gt;index() + 1) * ShenandoahHeapRegion::region_size_bytes() / MarkBitMap::heap_map_factor();
 140       assert (end &lt;= _bitmap_size, &quot;end is sane: &quot; SIZE_FORMAT &quot; &lt; &quot; SIZE_FORMAT, end, _bitmap_size);
 141 
 142       if (r-&gt;is_committed()) {
 143         os::pretouch_memory(_bitmap_base + start, _bitmap_base + end, _page_size);
 144       }
 145 
 146       r = _regions.next();
 147     }
 148   }
 149 };
 150 
 151 jint ShenandoahHeap::initialize() {
 152   //
 153   // Figure out heap sizing
 154   //
 155 
 156   size_t init_byte_size = InitialHeapSize;
 157   size_t min_byte_size  = MinHeapSize;
 158   size_t max_byte_size  = MaxHeapSize;
 159   size_t heap_alignment = HeapAlignment;
 160 
 161   size_t reg_size_bytes = ShenandoahHeapRegion::region_size_bytes();
 162 
 163   Universe::check_alignment(max_byte_size,  reg_size_bytes, &quot;Shenandoah heap&quot;);
 164   Universe::check_alignment(init_byte_size, reg_size_bytes, &quot;Shenandoah heap&quot;);
 165 
 166   _num_regions = ShenandoahHeapRegion::region_count();
 167 
 168   // Now we know the number of regions, initialize the heuristics.
 169   initialize_heuristics();
 170 
 171   size_t num_committed_regions = init_byte_size / reg_size_bytes;
 172   num_committed_regions = MIN2(num_committed_regions, _num_regions);
 173   assert(num_committed_regions &lt;= _num_regions, &quot;sanity&quot;);
 174   _initial_size = num_committed_regions * reg_size_bytes;
 175 
 176   size_t num_min_regions = min_byte_size / reg_size_bytes;
 177   num_min_regions = MIN2(num_min_regions, _num_regions);
 178   assert(num_min_regions &lt;= _num_regions, &quot;sanity&quot;);
 179   _minimum_size = num_min_regions * reg_size_bytes;
 180 
 181   _committed = _initial_size;
 182 
 183   size_t heap_page_size   = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 184   size_t bitmap_page_size = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 185   size_t region_page_size = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 186 
 187   //
 188   // Reserve and commit memory for heap
 189   //
 190 
 191   ReservedHeapSpace heap_rs = Universe::reserve_heap(max_byte_size, heap_alignment);
 192   initialize_reserved_region(heap_rs);
 193   _heap_region = MemRegion((HeapWord*)heap_rs.base(), heap_rs.size() / HeapWordSize);
 194   _heap_region_special = heap_rs.special();
 195 
 196   assert((((size_t) base()) &amp; ShenandoahHeapRegion::region_size_bytes_mask()) == 0,
 197          &quot;Misaligned heap: &quot; PTR_FORMAT, p2i(base()));
 198 
 199 #if SHENANDOAH_OPTIMIZED_OBJTASK
 200   // The optimized ObjArrayChunkedTask takes some bits away from the full object bits.
 201   // Fail if we ever attempt to address more than we can.
 202   if ((uintptr_t)heap_rs.end() &gt;= ObjArrayChunkedTask::max_addressable()) {
 203     FormatBuffer&lt;512&gt; buf(&quot;Shenandoah reserved [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT&quot;) for the heap, \n&quot;
 204                           &quot;but max object address is &quot; PTR_FORMAT &quot;. Try to reduce heap size, or try other \n&quot;
 205                           &quot;VM options that allocate heap at lower addresses (HeapBaseMinAddress, AllocateHeapAt, etc).&quot;,
 206                 p2i(heap_rs.base()), p2i(heap_rs.end()), ObjArrayChunkedTask::max_addressable());
 207     vm_exit_during_initialization(&quot;Fatal Error&quot;, buf);
 208   }
 209 #endif
 210 
 211   ReservedSpace sh_rs = heap_rs.first_part(max_byte_size);
 212   if (!_heap_region_special) {
 213     os::commit_memory_or_exit(sh_rs.base(), _initial_size, heap_alignment, false,
 214                               &quot;Cannot commit heap memory&quot;);
 215   }
 216 
 217   //
 218   // Reserve and commit memory for bitmap(s)
 219   //
 220 
 221   _bitmap_size = MarkBitMap::compute_size(heap_rs.size());
 222   _bitmap_size = align_up(_bitmap_size, bitmap_page_size);
 223 
 224   size_t bitmap_bytes_per_region = reg_size_bytes / MarkBitMap::heap_map_factor();
 225 
 226   guarantee(bitmap_bytes_per_region != 0,
 227             &quot;Bitmap bytes per region should not be zero&quot;);
 228   guarantee(is_power_of_2(bitmap_bytes_per_region),
 229             &quot;Bitmap bytes per region should be power of two: &quot; SIZE_FORMAT, bitmap_bytes_per_region);
 230 
 231   if (bitmap_page_size &gt; bitmap_bytes_per_region) {
 232     _bitmap_regions_per_slice = bitmap_page_size / bitmap_bytes_per_region;
 233     _bitmap_bytes_per_slice = bitmap_page_size;
 234   } else {
 235     _bitmap_regions_per_slice = 1;
 236     _bitmap_bytes_per_slice = bitmap_bytes_per_region;
 237   }
 238 
 239   guarantee(_bitmap_regions_per_slice &gt;= 1,
 240             &quot;Should have at least one region per slice: &quot; SIZE_FORMAT,
 241             _bitmap_regions_per_slice);
 242 
 243   guarantee(((_bitmap_bytes_per_slice) % bitmap_page_size) == 0,
 244             &quot;Bitmap slices should be page-granular: bps = &quot; SIZE_FORMAT &quot;, page size = &quot; SIZE_FORMAT,
 245             _bitmap_bytes_per_slice, bitmap_page_size);
 246 
 247   ReservedSpace bitmap(_bitmap_size, bitmap_page_size);
 248   MemTracker::record_virtual_memory_type(bitmap.base(), mtGC);
 249   _bitmap_region = MemRegion((HeapWord*) bitmap.base(), bitmap.size() / HeapWordSize);
 250   _bitmap_region_special = bitmap.special();
 251 
 252   size_t bitmap_init_commit = _bitmap_bytes_per_slice *
 253                               align_up(num_committed_regions, _bitmap_regions_per_slice) / _bitmap_regions_per_slice;
 254   bitmap_init_commit = MIN2(_bitmap_size, bitmap_init_commit);
 255   if (!_bitmap_region_special) {
 256     os::commit_memory_or_exit((char *) _bitmap_region.start(), bitmap_init_commit, bitmap_page_size, false,
 257                               &quot;Cannot commit bitmap memory&quot;);
 258   }
 259 
 260   _marking_context = new ShenandoahMarkingContext(_heap_region, _bitmap_region, _num_regions);
 261 
 262   if (ShenandoahVerify) {
 263     ReservedSpace verify_bitmap(_bitmap_size, bitmap_page_size);
 264     if (!verify_bitmap.special()) {
 265       os::commit_memory_or_exit(verify_bitmap.base(), verify_bitmap.size(), bitmap_page_size, false,
 266                                 &quot;Cannot commit verification bitmap memory&quot;);
 267     }
 268     MemTracker::record_virtual_memory_type(verify_bitmap.base(), mtGC);
 269     MemRegion verify_bitmap_region = MemRegion((HeapWord *) verify_bitmap.base(), verify_bitmap.size() / HeapWordSize);
 270     _verification_bit_map.initialize(_heap_region, verify_bitmap_region);
 271     _verifier = new ShenandoahVerifier(this, &amp;_verification_bit_map);
 272   }
 273 
 274   // Reserve aux bitmap for use in object_iterate(). We don&#39;t commit it here.
 275   ReservedSpace aux_bitmap(_bitmap_size, bitmap_page_size);
 276   MemTracker::record_virtual_memory_type(aux_bitmap.base(), mtGC);
 277   _aux_bitmap_region = MemRegion((HeapWord*) aux_bitmap.base(), aux_bitmap.size() / HeapWordSize);
 278   _aux_bitmap_region_special = aux_bitmap.special();
 279   _aux_bit_map.initialize(_heap_region, _aux_bitmap_region);
 280 
 281   //
 282   // Create regions and region sets
 283   //
 284   size_t region_align = align_up(sizeof(ShenandoahHeapRegion), SHENANDOAH_CACHE_LINE_SIZE);
 285   size_t region_storage_size = align_up(region_align * _num_regions, region_page_size);
 286   region_storage_size = align_up(region_storage_size, os::vm_allocation_granularity());
 287 
 288   ReservedSpace region_storage(region_storage_size, region_page_size);
 289   MemTracker::record_virtual_memory_type(region_storage.base(), mtGC);
 290   if (!region_storage.special()) {
 291     os::commit_memory_or_exit(region_storage.base(), region_storage_size, region_page_size, false,
 292                               &quot;Cannot commit region memory&quot;);
 293   }
 294 
 295   // Try to fit the collection set bitmap at lower addresses. This optimizes code generation for cset checks.
 296   // Go up until a sensible limit (subject to encoding constraints) and try to reserve the space there.
 297   // If not successful, bite a bullet and allocate at whatever address.
 298   {
 299     size_t cset_align = MAX2&lt;size_t&gt;(os::vm_page_size(), os::vm_allocation_granularity());
 300     size_t cset_size = align_up(((size_t) sh_rs.base() + sh_rs.size()) &gt;&gt; ShenandoahHeapRegion::region_size_bytes_shift(), cset_align);
 301 
 302     uintptr_t min = round_up_power_of_2(cset_align);
 303     uintptr_t max = (1u &lt;&lt; 30u);
 304 
 305     for (uintptr_t addr = min; addr &lt;= max; addr &lt;&lt;= 1u) {
 306       char* req_addr = (char*)addr;
 307       assert(is_aligned(req_addr, cset_align), &quot;Should be aligned&quot;);
 308       ReservedSpace cset_rs(cset_size, cset_align, false, req_addr);
 309       if (cset_rs.is_reserved()) {
 310         assert(cset_rs.base() == req_addr, &quot;Allocated where requested: &quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT, p2i(cset_rs.base()), addr);
 311         _collection_set = new ShenandoahCollectionSet(this, cset_rs, sh_rs.base());
 312         break;
 313       }
 314     }
 315 
 316     if (_collection_set == NULL) {
 317       ReservedSpace cset_rs(cset_size, cset_align, false);
 318       _collection_set = new ShenandoahCollectionSet(this, cset_rs, sh_rs.base());
 319     }
 320   }
 321 
 322   _regions = NEW_C_HEAP_ARRAY(ShenandoahHeapRegion*, _num_regions, mtGC);
 323   _free_set = new ShenandoahFreeSet(this, _num_regions);
 324 
 325   {
 326     ShenandoahHeapLocker locker(lock());
 327 
 328     for (size_t i = 0; i &lt; _num_regions; i++) {
 329       HeapWord* start = (HeapWord*)sh_rs.base() + ShenandoahHeapRegion::region_size_words() * i;
 330       bool is_committed = i &lt; num_committed_regions;
 331       void* loc = region_storage.base() + i * region_align;
 332 
 333       ShenandoahHeapRegion* r = new (loc) ShenandoahHeapRegion(start, i, is_committed);
 334       assert(is_aligned(r, SHENANDOAH_CACHE_LINE_SIZE), &quot;Sanity&quot;);
 335 
 336       _marking_context-&gt;initialize_top_at_mark_start(r);
 337       _regions[i] = r;
 338       assert(!collection_set()-&gt;is_in(i), &quot;New region should not be in collection set&quot;);
 339     }
 340 
 341     // Initialize to complete
 342     _marking_context-&gt;mark_complete();
 343 
 344     _free_set-&gt;rebuild();
 345   }
 346 
 347   if (AlwaysPreTouch) {
 348     // For NUMA, it is important to pre-touch the storage under bitmaps with worker threads,
 349     // before initialize() below zeroes it with initializing thread. For any given region,
 350     // we touch the region and the corresponding bitmaps from the same thread.
 351     ShenandoahPushWorkerScope scope(workers(), _max_workers, false);
 352 
 353     _pretouch_heap_page_size = heap_page_size;
 354     _pretouch_bitmap_page_size = bitmap_page_size;
 355 
 356 #ifdef LINUX
 357     // UseTransparentHugePages would madvise that backing memory can be coalesced into huge
 358     // pages. But, the kernel needs to know that every small page is used, in order to coalesce
 359     // them into huge one. Therefore, we need to pretouch with smaller pages.
 360     if (UseTransparentHugePages) {
 361       _pretouch_heap_page_size = (size_t)os::vm_page_size();
 362       _pretouch_bitmap_page_size = (size_t)os::vm_page_size();
 363     }
 364 #endif
 365 
 366     // OS memory managers may want to coalesce back-to-back pages. Make their jobs
 367     // simpler by pre-touching continuous spaces (heap and bitmap) separately.
 368 
 369     ShenandoahPretouchBitmapTask bcl(bitmap.base(), _bitmap_size, _pretouch_bitmap_page_size);
 370     _workers-&gt;run_task(&amp;bcl);
 371 
 372     ShenandoahPretouchHeapTask hcl(_pretouch_heap_page_size);
 373     _workers-&gt;run_task(&amp;hcl);
 374   }
 375 
 376   //
 377   // Initialize the rest of GC subsystems
 378   //
 379 
 380   _liveness_cache = NEW_C_HEAP_ARRAY(ShenandoahLiveData*, _max_workers, mtGC);
 381   for (uint worker = 0; worker &lt; _max_workers; worker++) {
 382     _liveness_cache[worker] = NEW_C_HEAP_ARRAY(ShenandoahLiveData, _num_regions, mtGC);
 383     Copy::fill_to_bytes(_liveness_cache[worker], _num_regions * sizeof(ShenandoahLiveData));
 384   }
 385 
 386   // There should probably be Shenandoah-specific options for these,
 387   // just as there are G1-specific options.
 388   {
 389     ShenandoahSATBMarkQueueSet&amp; satbqs = ShenandoahBarrierSet::satb_mark_queue_set();
 390     satbqs.set_process_completed_buffers_threshold(20); // G1SATBProcessCompletedThreshold
 391     satbqs.set_buffer_enqueue_threshold_percentage(60); // G1SATBBufferEnqueueingThresholdPercent
 392   }
 393 
 394   _monitoring_support = new ShenandoahMonitoringSupport(this);
 395   _phase_timings = new ShenandoahPhaseTimings(max_workers());
 396   ShenandoahStringDedup::initialize();
 397   ShenandoahCodeRoots::initialize();
 398 
 399   if (ShenandoahPacing) {
 400     _pacer = new ShenandoahPacer(this);
 401     _pacer-&gt;setup_for_idle();
 402   } else {
 403     _pacer = NULL;
 404   }
 405 
 406   _control_thread = new ShenandoahControlThread();
 407 
 408   _ref_proc_mt_processing = ParallelRefProcEnabled &amp;&amp; (ParallelGCThreads &gt; 1);
 409   _ref_proc_mt_discovery = _max_workers &gt; 1;
 410 
 411   ShenandoahInitLogger::print();
 412 
 413   return JNI_OK;
 414 }
 415 
 416 void ShenandoahHeap::initialize_heuristics() {
 417   if (ShenandoahGCMode != NULL) {
 418     if (strcmp(ShenandoahGCMode, &quot;satb&quot;) == 0) {
 419       _gc_mode = new ShenandoahSATBMode();
 420     } else if (strcmp(ShenandoahGCMode, &quot;iu&quot;) == 0) {
 421       _gc_mode = new ShenandoahIUMode();
 422     } else if (strcmp(ShenandoahGCMode, &quot;passive&quot;) == 0) {
 423       _gc_mode = new ShenandoahPassiveMode();
 424     } else {
 425       vm_exit_during_initialization(&quot;Unknown -XX:ShenandoahGCMode option&quot;);
 426     }
 427   } else {
 428     ShouldNotReachHere();
 429   }
 430   _gc_mode-&gt;initialize_flags();
 431   if (_gc_mode-&gt;is_diagnostic() &amp;&amp; !UnlockDiagnosticVMOptions) {
 432     vm_exit_during_initialization(
 433             err_msg(&quot;GC mode \&quot;%s\&quot; is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.&quot;,
 434                     _gc_mode-&gt;name()));
 435   }
 436   if (_gc_mode-&gt;is_experimental() &amp;&amp; !UnlockExperimentalVMOptions) {
 437     vm_exit_during_initialization(
 438             err_msg(&quot;GC mode \&quot;%s\&quot; is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.&quot;,
 439                     _gc_mode-&gt;name()));
 440   }
 441 
 442   _heuristics = _gc_mode-&gt;initialize_heuristics();
 443 
 444   if (_heuristics-&gt;is_diagnostic() &amp;&amp; !UnlockDiagnosticVMOptions) {
 445     vm_exit_during_initialization(
 446             err_msg(&quot;Heuristics \&quot;%s\&quot; is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.&quot;,
 447                     _heuristics-&gt;name()));
 448   }
 449   if (_heuristics-&gt;is_experimental() &amp;&amp; !UnlockExperimentalVMOptions) {
 450     vm_exit_during_initialization(
 451             err_msg(&quot;Heuristics \&quot;%s\&quot; is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.&quot;,
 452                     _heuristics-&gt;name()));
 453   }
 454 }
 455 
 456 #ifdef _MSC_VER
 457 #pragma warning( push )
 458 #pragma warning( disable:4355 ) // &#39;this&#39; : used in base member initializer list
 459 #endif
 460 
 461 ShenandoahHeap::ShenandoahHeap(ShenandoahCollectorPolicy* policy) :
 462   CollectedHeap(),
 463   _initial_size(0),
 464   _used(0),
 465   _committed(0),
 466   _bytes_allocated_since_gc_start(0),
 467   _max_workers(MAX2(ConcGCThreads, ParallelGCThreads)),
 468   _workers(NULL),
 469   _safepoint_workers(NULL),
 470   _heap_region_special(false),
 471   _num_regions(0),
 472   _regions(NULL),
 473   _update_refs_iterator(this),
 474   _control_thread(NULL),
 475   _shenandoah_policy(policy),
 476   _heuristics(NULL),
 477   _free_set(NULL),
 478   _scm(new ShenandoahConcurrentMark()),
 479   _full_gc(new ShenandoahMarkCompact()),
 480   _pacer(NULL),
 481   _verifier(NULL),
 482   _phase_timings(NULL),
 483   _monitoring_support(NULL),
 484   _memory_pool(NULL),
 485   _stw_memory_manager(&quot;Shenandoah Pauses&quot;, &quot;end of GC pause&quot;),
 486   _cycle_memory_manager(&quot;Shenandoah Cycles&quot;, &quot;end of GC cycle&quot;),
 487   _gc_timer(new (ResourceObj::C_HEAP, mtGC) ConcurrentGCTimer()),
 488   _soft_ref_policy(),
 489   _log_min_obj_alignment_in_bytes(LogMinObjAlignmentInBytes),
 490   _ref_processor(NULL),
 491   _marking_context(NULL),
 492   _bitmap_size(0),
 493   _bitmap_regions_per_slice(0),
 494   _bitmap_bytes_per_slice(0),
 495   _bitmap_region_special(false),
 496   _aux_bitmap_region_special(false),
 497   _liveness_cache(NULL),
 498   _collection_set(NULL)
 499 {
 500   _heap = this;
 501 
 502   BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this));
 503 
 504   _max_workers = MAX2(_max_workers, 1U);
 505   _workers = new ShenandoahWorkGang(&quot;Shenandoah GC Threads&quot;, _max_workers,
 506                             /* are_GC_task_threads */ true,
 507                             /* are_ConcurrentGC_threads */ true);
 508   if (_workers == NULL) {
 509     vm_exit_during_initialization(&quot;Failed necessary allocation.&quot;);
 510   } else {
 511     _workers-&gt;initialize_workers();
 512   }
 513 
 514   if (ParallelGCThreads &gt; 1) {
 515     _safepoint_workers = new ShenandoahWorkGang(&quot;Safepoint Cleanup Thread&quot;,
 516                                                 ParallelGCThreads,
 517                       /* are_GC_task_threads */ false,
 518                  /* are_ConcurrentGC_threads */ false);
 519     _safepoint_workers-&gt;initialize_workers();
 520   }
 521 }
 522 
 523 #ifdef _MSC_VER
 524 #pragma warning( pop )
 525 #endif
 526 
 527 class ShenandoahResetBitmapTask : public AbstractGangTask {
 528 private:
 529   ShenandoahRegionIterator _regions;
 530 
 531 public:
 532   ShenandoahResetBitmapTask() :
 533     AbstractGangTask(&quot;Parallel Reset Bitmap Task&quot;) {}
 534 
 535   void work(uint worker_id) {
 536     ShenandoahHeapRegion* region = _regions.next();
 537     ShenandoahHeap* heap = ShenandoahHeap::heap();
 538     ShenandoahMarkingContext* const ctx = heap-&gt;marking_context();
 539     while (region != NULL) {
 540       if (heap-&gt;is_bitmap_slice_committed(region)) {
 541         ctx-&gt;clear_bitmap(region);
 542       }
 543       region = _regions.next();
 544     }
 545   }
 546 };
 547 
 548 void ShenandoahHeap::reset_mark_bitmap() {
 549   assert_gc_workers(_workers-&gt;active_workers());
 550   mark_incomplete_marking_context();
 551 
 552   ShenandoahResetBitmapTask task;
 553   _workers-&gt;run_task(&amp;task);
 554 }
 555 
 556 void ShenandoahHeap::print_on(outputStream* st) const {
 557   st-&gt;print_cr(&quot;Shenandoah Heap&quot;);
 558   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot;%s total, &quot; SIZE_FORMAT &quot;%s committed, &quot; SIZE_FORMAT &quot;%s used&quot;,
 559                byte_size_in_proper_unit(max_capacity()), proper_unit_for_byte_size(max_capacity()),
 560                byte_size_in_proper_unit(committed()),    proper_unit_for_byte_size(committed()),
 561                byte_size_in_proper_unit(used()),         proper_unit_for_byte_size(used()));
 562   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT&quot;%s regions&quot;,
 563                num_regions(),
 564                byte_size_in_proper_unit(ShenandoahHeapRegion::region_size_bytes()),
 565                proper_unit_for_byte_size(ShenandoahHeapRegion::region_size_bytes()));
 566 
 567   st-&gt;print(&quot;Status: &quot;);
 568   if (has_forwarded_objects())                 st-&gt;print(&quot;has forwarded objects, &quot;);
 569   if (is_concurrent_mark_in_progress())        st-&gt;print(&quot;marking, &quot;);
 570   if (is_evacuation_in_progress())             st-&gt;print(&quot;evacuating, &quot;);
 571   if (is_update_refs_in_progress())            st-&gt;print(&quot;updating refs, &quot;);
 572   if (is_degenerated_gc_in_progress())         st-&gt;print(&quot;degenerated gc, &quot;);
 573   if (is_full_gc_in_progress())                st-&gt;print(&quot;full gc, &quot;);
 574   if (is_full_gc_move_in_progress())           st-&gt;print(&quot;full gc move, &quot;);
 575   if (is_concurrent_weak_root_in_progress())   st-&gt;print(&quot;concurrent weak roots, &quot;);
 576   if (is_concurrent_strong_root_in_progress() &amp;&amp;
 577       !is_concurrent_weak_root_in_progress())  st-&gt;print(&quot;concurrent strong roots, &quot;);
 578 
 579   if (cancelled_gc()) {
 580     st-&gt;print(&quot;cancelled&quot;);
 581   } else {
 582     st-&gt;print(&quot;not cancelled&quot;);
 583   }
 584   st-&gt;cr();
 585 
 586   st-&gt;print_cr(&quot;Reserved region:&quot;);
 587   st-&gt;print_cr(&quot; - [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;,
 588                p2i(reserved_region().start()),
 589                p2i(reserved_region().end()));
 590 
 591   ShenandoahCollectionSet* cset = collection_set();
 592   st-&gt;print_cr(&quot;Collection set:&quot;);
 593   if (cset != NULL) {
 594     st-&gt;print_cr(&quot; - map (vanilla): &quot; PTR_FORMAT, p2i(cset-&gt;map_address()));
 595     st-&gt;print_cr(&quot; - map (biased):  &quot; PTR_FORMAT, p2i(cset-&gt;biased_map_address()));
 596   } else {
 597     st-&gt;print_cr(&quot; (NULL)&quot;);
 598   }
 599 
 600   st-&gt;cr();
 601   MetaspaceUtils::print_on(st);
 602 
 603   if (Verbose) {
 604     print_heap_regions_on(st);
 605   }
 606 }
 607 
 608 class ShenandoahInitWorkerGCLABClosure : public ThreadClosure {
 609 public:
 610   void do_thread(Thread* thread) {
 611     assert(thread != NULL, &quot;Sanity&quot;);
 612     assert(thread-&gt;is_Worker_thread(), &quot;Only worker thread expected&quot;);
 613     ShenandoahThreadLocalData::initialize_gclab(thread);
 614   }
 615 };
 616 
 617 void ShenandoahHeap::post_initialize() {
 618   CollectedHeap::post_initialize();
 619   MutexLocker ml(Threads_lock);
 620 
 621   ShenandoahInitWorkerGCLABClosure init_gclabs;
 622   _workers-&gt;threads_do(&amp;init_gclabs);
 623 
 624   // gclab can not be initialized early during VM startup, as it can not determinate its max_size.
 625   // Now, we will let WorkGang to initialize gclab when new worker is created.
 626   _workers-&gt;set_initialize_gclab();
 627 
 628   _scm-&gt;initialize(_max_workers);
 629   _full_gc-&gt;initialize(_gc_timer);
 630 
 631   ref_processing_init();
 632 
 633   _heuristics-&gt;initialize();
 634 
 635   JFR_ONLY(ShenandoahJFRSupport::register_jfr_type_serializers());
 636 }
 637 
 638 size_t ShenandoahHeap::used() const {
 639   return Atomic::load_acquire(&amp;_used);
 640 }
 641 
 642 size_t ShenandoahHeap::committed() const {
 643   OrderAccess::acquire();
 644   return _committed;
 645 }
 646 
 647 void ShenandoahHeap::increase_committed(size_t bytes) {
 648   shenandoah_assert_heaplocked_or_safepoint();
 649   _committed += bytes;
 650 }
 651 
 652 void ShenandoahHeap::decrease_committed(size_t bytes) {
 653   shenandoah_assert_heaplocked_or_safepoint();
 654   _committed -= bytes;
 655 }
 656 
 657 void ShenandoahHeap::increase_used(size_t bytes) {
 658   Atomic::add(&amp;_used, bytes);
 659 }
 660 
 661 void ShenandoahHeap::set_used(size_t bytes) {
 662   Atomic::release_store_fence(&amp;_used, bytes);
 663 }
 664 
 665 void ShenandoahHeap::decrease_used(size_t bytes) {
 666   assert(used() &gt;= bytes, &quot;never decrease heap size by more than we&#39;ve left&quot;);
 667   Atomic::sub(&amp;_used, bytes);
 668 }
 669 
 670 void ShenandoahHeap::increase_allocated(size_t bytes) {
 671   Atomic::add(&amp;_bytes_allocated_since_gc_start, bytes);
 672 }
 673 
 674 void ShenandoahHeap::notify_mutator_alloc_words(size_t words, bool waste) {
 675   size_t bytes = words * HeapWordSize;
 676   if (!waste) {
 677     increase_used(bytes);
 678   }
 679   increase_allocated(bytes);
 680   if (ShenandoahPacing) {
 681     control_thread()-&gt;pacing_notify_alloc(words);
 682     if (waste) {
 683       pacer()-&gt;claim_for_alloc(words, true);
 684     }
 685   }
 686 }
 687 
 688 size_t ShenandoahHeap::capacity() const {
 689   return committed();
 690 }
 691 
 692 size_t ShenandoahHeap::max_capacity() const {
 693   return _num_regions * ShenandoahHeapRegion::region_size_bytes();
 694 }
 695 
 696 size_t ShenandoahHeap::min_capacity() const {
 697   return _minimum_size;
 698 }
 699 
 700 size_t ShenandoahHeap::initial_capacity() const {
 701   return _initial_size;
 702 }
 703 
 704 bool ShenandoahHeap::is_in(const void* p) const {
 705   HeapWord* heap_base = (HeapWord*) base();
 706   HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();
 707   return p &gt;= heap_base &amp;&amp; p &lt; last_region_end;
 708 }
 709 
 710 void ShenandoahHeap::op_uncommit(double shrink_before) {
 711   assert (ShenandoahUncommit, &quot;should be enabled&quot;);
 712 
 713   // Application allocates from the beginning of the heap, and GC allocates at
 714   // the end of it. It is more efficient to uncommit from the end, so that applications
 715   // could enjoy the near committed regions. GC allocations are much less frequent,
 716   // and therefore can accept the committing costs.
 717 
 718   size_t count = 0;
 719   for (size_t i = num_regions(); i &gt; 0; i--) { // care about size_t underflow
 720     ShenandoahHeapRegion* r = get_region(i - 1);
 721     if (r-&gt;is_empty_committed() &amp;&amp; (r-&gt;empty_time() &lt; shrink_before)) {
 722       ShenandoahHeapLocker locker(lock());
 723       if (r-&gt;is_empty_committed()) {
 724         // Do not uncommit below minimal capacity
 725         if (committed() &lt; min_capacity() + ShenandoahHeapRegion::region_size_bytes()) {
 726           break;
 727         }
 728 
 729         r-&gt;make_uncommitted();
 730         count++;
 731       }
 732     }
 733     SpinPause(); // allow allocators to take the lock
 734   }
 735 
 736   if (count &gt; 0) {
 737     control_thread()-&gt;notify_heap_changed();
 738   }
 739 }
 740 
 741 HeapWord* ShenandoahHeap::allocate_from_gclab_slow(Thread* thread, size_t size) {
 742   // New object should fit the GCLAB size
 743   size_t min_size = MAX2(size, PLAB::min_size());
 744 
 745   // Figure out size of new GCLAB, looking back at heuristics. Expand aggressively.
 746   size_t new_size = ShenandoahThreadLocalData::gclab_size(thread) * 2;
 747   new_size = MIN2(new_size, PLAB::max_size());
 748   new_size = MAX2(new_size, PLAB::min_size());
 749 
 750   // Record new heuristic value even if we take any shortcut. This captures
 751   // the case when moderately-sized objects always take a shortcut. At some point,
 752   // heuristics should catch up with them.
 753   ShenandoahThreadLocalData::set_gclab_size(thread, new_size);
 754 
 755   if (new_size &lt; size) {
 756     // New size still does not fit the object. Fall back to shared allocation.
 757     // This avoids retiring perfectly good GCLABs, when we encounter a large object.
 758     return NULL;
 759   }
 760 
 761   // Retire current GCLAB, and allocate a new one.
 762   PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
 763   gclab-&gt;retire();
 764 
 765   size_t actual_size = 0;
 766   HeapWord* gclab_buf = allocate_new_gclab(min_size, new_size, &amp;actual_size);
 767   if (gclab_buf == NULL) {
 768     return NULL;
 769   }
 770 
 771   assert (size &lt;= actual_size, &quot;allocation should fit&quot;);
 772 
 773   if (ZeroTLAB) {
 774     // ..and clear it.
 775     Copy::zero_to_words(gclab_buf, actual_size);
 776   } else {
 777     // ...and zap just allocated object.
 778 #ifdef ASSERT
 779     // Skip mangling the space corresponding to the object header to
 780     // ensure that the returned space is not considered parsable by
 781     // any concurrent GC thread.
 782     size_t hdr_size = oopDesc::header_size();
 783     Copy::fill_to_words(gclab_buf + hdr_size, actual_size - hdr_size, badHeapWordVal);
 784 #endif // ASSERT
 785   }
 786   gclab-&gt;set_buf(gclab_buf, actual_size);
 787   return gclab-&gt;allocate(size);
 788 }
 789 
 790 HeapWord* ShenandoahHeap::allocate_new_tlab(size_t min_size,
 791                                             size_t requested_size,
 792                                             size_t* actual_size) {
 793   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_tlab(min_size, requested_size);
 794   HeapWord* res = allocate_memory(req);
 795   if (res != NULL) {
 796     *actual_size = req.actual_size();
 797   } else {
 798     *actual_size = 0;
 799   }
 800   return res;
 801 }
 802 
 803 HeapWord* ShenandoahHeap::allocate_new_gclab(size_t min_size,
 804                                              size_t word_size,
 805                                              size_t* actual_size) {
 806   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_gclab(min_size, word_size);
 807   HeapWord* res = allocate_memory(req);
 808   if (res != NULL) {
 809     *actual_size = req.actual_size();
 810   } else {
 811     *actual_size = 0;
 812   }
 813   return res;
 814 }
 815 
 816 HeapWord* ShenandoahHeap::allocate_memory(ShenandoahAllocRequest&amp; req) {
 817   intptr_t pacer_epoch = 0;
 818   bool in_new_region = false;
 819   HeapWord* result = NULL;
 820 
 821   if (req.is_mutator_alloc()) {
 822     if (ShenandoahPacing) {
 823       pacer()-&gt;pace_for_alloc(req.size());
 824       pacer_epoch = pacer()-&gt;epoch();
 825     }
 826 
 827     if (!ShenandoahAllocFailureALot || !should_inject_alloc_failure()) {
 828       result = allocate_memory_under_lock(req, in_new_region);
 829     }
 830 
 831     // Allocation failed, block until control thread reacted, then retry allocation.
 832     //
 833     // It might happen that one of the threads requesting allocation would unblock
 834     // way later after GC happened, only to fail the second allocation, because
 835     // other threads have already depleted the free storage. In this case, a better
 836     // strategy is to try again, as long as GC makes progress.
 837     //
 838     // Then, we need to make sure the allocation was retried after at least one
 839     // Full GC, which means we want to try more than ShenandoahFullGCThreshold times.
 840 
 841     size_t tries = 0;
 842 
 843     while (result == NULL &amp;&amp; _progress_last_gc.is_set()) {
 844       tries++;
 845       control_thread()-&gt;handle_alloc_failure(req);
 846       result = allocate_memory_under_lock(req, in_new_region);
 847     }
 848 
 849     while (result == NULL &amp;&amp; tries &lt;= ShenandoahFullGCThreshold) {
 850       tries++;
 851       control_thread()-&gt;handle_alloc_failure(req);
 852       result = allocate_memory_under_lock(req, in_new_region);
 853     }
 854 
 855   } else {
 856     assert(req.is_gc_alloc(), &quot;Can only accept GC allocs here&quot;);
 857     result = allocate_memory_under_lock(req, in_new_region);
 858     // Do not call handle_alloc_failure() here, because we cannot block.
 859     // The allocation failure would be handled by the LRB slowpath with handle_alloc_failure_evac().
 860   }
 861 
 862   if (in_new_region) {
 863     control_thread()-&gt;notify_heap_changed();
 864   }
 865 
 866   if (result != NULL) {
 867     size_t requested = req.size();
 868     size_t actual = req.actual_size();
 869 
 870     assert (req.is_lab_alloc() || (requested == actual),
 871             &quot;Only LAB allocations are elastic: %s, requested = &quot; SIZE_FORMAT &quot;, actual = &quot; SIZE_FORMAT,
 872             ShenandoahAllocRequest::alloc_type_to_string(req.type()), requested, actual);
 873 
 874     if (req.is_mutator_alloc()) {
 875       notify_mutator_alloc_words(actual, false);
 876 
 877       // If we requested more than we were granted, give the rest back to pacer.
 878       // This only matters if we are in the same pacing epoch: do not try to unpace
 879       // over the budget for the other phase.
 880       if (ShenandoahPacing &amp;&amp; (pacer_epoch &gt; 0) &amp;&amp; (requested &gt; actual)) {
 881         pacer()-&gt;unpace_for_alloc(pacer_epoch, requested - actual);
 882       }
 883     } else {
 884       increase_used(actual*HeapWordSize);
 885     }
 886   }
 887 
 888   return result;
 889 }
 890 
 891 HeapWord* ShenandoahHeap::allocate_memory_under_lock(ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
 892   ShenandoahHeapLocker locker(lock());
 893   return _free_set-&gt;allocate(req, in_new_region);
 894 }
 895 
 896 HeapWord* ShenandoahHeap::mem_allocate(size_t size,
 897                                         bool*  gc_overhead_limit_was_exceeded) {
 898   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);
 899   return allocate_memory(req);
 900 }
 901 
 902 MetaWord* ShenandoahHeap::satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
 903                                                              size_t size,
 904                                                              Metaspace::MetadataType mdtype) {
 905   MetaWord* result;
 906 
 907   // Inform metaspace OOM to GC heuristics if class unloading is possible.
 908   if (heuristics()-&gt;can_unload_classes()) {
 909     ShenandoahHeuristics* h = heuristics();
 910     h-&gt;record_metaspace_oom();
 911   }
 912 
 913   // Expand and retry allocation
 914   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 915   if (result != NULL) {
 916     return result;
 917   }
 918 
 919   // Start full GC
 920   collect(GCCause::_metadata_GC_clear_soft_refs);
 921 
 922   // Retry allocation
 923   result = loader_data-&gt;metaspace_non_null()-&gt;allocate(size, mdtype);
 924   if (result != NULL) {
 925     return result;
 926   }
 927 
 928   // Expand and retry allocation
 929   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 930   if (result != NULL) {
 931     return result;
 932   }
 933 
 934   // Out of memory
 935   return NULL;
 936 }
 937 
 938 class ShenandoahConcurrentEvacuateRegionObjectClosure : public ObjectClosure {
 939 private:
 940   ShenandoahHeap* const _heap;
 941   Thread* const _thread;
 942 public:
 943   ShenandoahConcurrentEvacuateRegionObjectClosure(ShenandoahHeap* heap) :
 944     _heap(heap), _thread(Thread::current()) {}
 945 
 946   void do_object(oop p) {
 947     shenandoah_assert_marked(NULL, p);
 948     if (!p-&gt;is_forwarded()) {
 949       _heap-&gt;evacuate_object(p, _thread);
 950     }
 951   }
 952 };
 953 
 954 class ShenandoahEvacuationTask : public AbstractGangTask {
 955 private:
 956   ShenandoahHeap* const _sh;
 957   ShenandoahCollectionSet* const _cs;
 958   bool _concurrent;
 959 public:
 960   ShenandoahEvacuationTask(ShenandoahHeap* sh,
 961                            ShenandoahCollectionSet* cs,
 962                            bool concurrent) :
 963     AbstractGangTask(&quot;Parallel Evacuation Task&quot;),
 964     _sh(sh),
 965     _cs(cs),
 966     _concurrent(concurrent)
 967   {}
 968 
 969   void work(uint worker_id) {
 970     if (_concurrent) {
 971       ShenandoahConcurrentWorkerSession worker_session(worker_id);
 972       ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
 973       ShenandoahEvacOOMScope oom_evac_scope;
 974       do_work();
 975     } else {
 976       ShenandoahParallelWorkerSession worker_session(worker_id);
 977       ShenandoahEvacOOMScope oom_evac_scope;
 978       do_work();
 979     }
 980   }
 981 
 982 private:
 983   void do_work() {
 984     ShenandoahConcurrentEvacuateRegionObjectClosure cl(_sh);
 985     ShenandoahHeapRegion* r;
 986     while ((r =_cs-&gt;claim_next()) != NULL) {
 987       assert(r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have been reclaimed early&quot;, r-&gt;index());
 988       _sh-&gt;marked_object_iterate(r, &amp;cl);
 989 
 990       if (ShenandoahPacing) {
 991         _sh-&gt;pacer()-&gt;report_evac(r-&gt;used() &gt;&gt; LogHeapWordSize);
 992       }
 993 
 994       if (_sh-&gt;check_cancelled_gc_and_yield(_concurrent)) {
 995         break;
 996       }
 997     }
 998   }
 999 };
1000 
1001 void ShenandoahHeap::trash_cset_regions() {
1002   ShenandoahHeapLocker locker(lock());
1003 
1004   ShenandoahCollectionSet* set = collection_set();
1005   ShenandoahHeapRegion* r;
1006   set-&gt;clear_current_index();
1007   while ((r = set-&gt;next()) != NULL) {
1008     r-&gt;make_trash();
1009   }
1010   collection_set()-&gt;clear();
1011 }
1012 
1013 void ShenandoahHeap::print_heap_regions_on(outputStream* st) const {
1014   st-&gt;print_cr(&quot;Heap Regions:&quot;);
1015   st-&gt;print_cr(&quot;EU=empty-uncommitted, EC=empty-committed, R=regular, H=humongous start, HC=humongous continuation, CS=collection set, T=trash, P=pinned&quot;);
1016   st-&gt;print_cr(&quot;BTE=bottom/top/end, U=used, T=TLAB allocs, G=GCLAB allocs, S=shared allocs, L=live data&quot;);
1017   st-&gt;print_cr(&quot;R=root, CP=critical pins, TAMS=top-at-mark-start, UWM=update watermark&quot;);
1018   st-&gt;print_cr(&quot;SN=alloc sequence number&quot;);
1019 
1020   for (size_t i = 0; i &lt; num_regions(); i++) {
1021     get_region(i)-&gt;print_on(st);
1022   }
1023 }
1024 
1025 void ShenandoahHeap::trash_humongous_region_at(ShenandoahHeapRegion* start) {
1026   assert(start-&gt;is_humongous_start(), &quot;reclaim regions starting with the first one&quot;);
1027 
1028   oop humongous_obj = oop(start-&gt;bottom());
1029   size_t size = humongous_obj-&gt;size();
1030   size_t required_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);
1031   size_t index = start-&gt;index() + required_regions - 1;
1032 
1033   assert(!start-&gt;has_live(), &quot;liveness must be zero&quot;);
1034 
1035   for(size_t i = 0; i &lt; required_regions; i++) {
1036     // Reclaim from tail. Otherwise, assertion fails when printing region to trace log,
1037     // as it expects that every region belongs to a humongous region starting with a humongous start region.
1038     ShenandoahHeapRegion* region = get_region(index --);
1039 
1040     assert(region-&gt;is_humongous(), &quot;expect correct humongous start or continuation&quot;);
1041     assert(!region-&gt;is_cset(), &quot;Humongous region should not be in collection set&quot;);
1042 
1043     region-&gt;make_trash_immediate();
1044   }
1045 }
1046 
1047 class ShenandoahRetireGCLABClosure : public ThreadClosure {
1048 public:
1049   void do_thread(Thread* thread) {
1050     PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
1051     assert(gclab != NULL, &quot;GCLAB should be initialized for %s&quot;, thread-&gt;name());
1052     gclab-&gt;retire();
1053   }
1054 };
1055 
1056 void ShenandoahHeap::make_parsable(bool retire_tlabs) {
1057   if (UseTLAB) {
1058     CollectedHeap::ensure_parsability(retire_tlabs);
1059   }
1060   ShenandoahRetireGCLABClosure cl;
1061   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1062     cl.do_thread(t);
1063   }
1064   workers()-&gt;threads_do(&amp;cl);
1065 }
1066 
1067 void ShenandoahHeap::resize_tlabs() {
1068   CollectedHeap::resize_all_tlabs();
1069 }
1070 
1071 class ShenandoahEvacuateUpdateRootsTask : public AbstractGangTask {
1072 private:
1073   ShenandoahRootEvacuator* _rp;
1074 
1075 public:
1076   ShenandoahEvacuateUpdateRootsTask(ShenandoahRootEvacuator* rp) :
1077     AbstractGangTask(&quot;Shenandoah evacuate and update roots&quot;),
1078     _rp(rp) {}
1079 
1080   void work(uint worker_id) {
1081     ShenandoahParallelWorkerSession worker_session(worker_id);
1082     ShenandoahEvacOOMScope oom_evac_scope;
1083     ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
1084     MarkingCodeBlobClosure blobsCl(&amp;cl, CodeBlobToOopClosure::FixRelocations);
1085     _rp-&gt;roots_do(worker_id, &amp;cl);
1086   }
1087 };
1088 
1089 void ShenandoahHeap::evacuate_and_update_roots() {
1090 #if COMPILER2_OR_JVMCI
1091   DerivedPointerTable::clear();
1092 #endif
1093   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only iterate roots while world is stopped&quot;);
1094   {
1095     // Include concurrent roots if current cycle can not process those roots concurrently
1096     ShenandoahRootEvacuator rp(workers()-&gt;active_workers(),
1097                                ShenandoahPhaseTimings::init_evac,
1098                                !ShenandoahConcurrentRoots::should_do_concurrent_roots(),
1099                                !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
1100     ShenandoahEvacuateUpdateRootsTask roots_task(&amp;rp);
1101     workers()-&gt;run_task(&amp;roots_task);
1102   }
1103 
1104 #if COMPILER2_OR_JVMCI
1105   DerivedPointerTable::update_pointers();
1106 #endif
1107 }
1108 
1109 // Returns size in bytes
1110 size_t ShenandoahHeap::unsafe_max_tlab_alloc(Thread *thread) const {
1111   if (ShenandoahElasticTLAB) {
1112     // With Elastic TLABs, return the max allowed size, and let the allocation path
1113     // figure out the safe size for current allocation.
1114     return ShenandoahHeapRegion::max_tlab_size_bytes();
1115   } else {
1116     return MIN2(_free_set-&gt;unsafe_peek_free(), ShenandoahHeapRegion::max_tlab_size_bytes());
1117   }
1118 }
1119 
1120 size_t ShenandoahHeap::max_tlab_size() const {
1121   // Returns size in words
1122   return ShenandoahHeapRegion::max_tlab_size_words();
1123 }
1124 
1125 class ShenandoahRetireAndResetGCLABClosure : public ThreadClosure {
1126 public:
1127   void do_thread(Thread* thread) {
1128     PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
1129     gclab-&gt;retire();
1130     if (ShenandoahThreadLocalData::gclab_size(thread) &gt; 0) {
1131       ShenandoahThreadLocalData::set_gclab_size(thread, 0);
1132     }
1133   }
1134 };
1135 
1136 void ShenandoahHeap::retire_and_reset_gclabs() {
1137   ShenandoahRetireAndResetGCLABClosure cl;
1138   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1139     cl.do_thread(t);
1140   }
1141   workers()-&gt;threads_do(&amp;cl);
1142 }
1143 
1144 void ShenandoahHeap::collect(GCCause::Cause cause) {
1145   control_thread()-&gt;request_gc(cause);
1146 }
1147 
1148 void ShenandoahHeap::do_full_collection(bool clear_all_soft_refs) {
1149   //assert(false, &quot;Shouldn&#39;t need to do full collections&quot;);
1150 }
1151 
1152 HeapWord* ShenandoahHeap::block_start(const void* addr) const {
1153   ShenandoahHeapRegion* r = heap_region_containing(addr);
1154   if (r != NULL) {
1155     return r-&gt;block_start(addr);
1156   }
1157   return NULL;
1158 }
1159 
1160 bool ShenandoahHeap::block_is_obj(const HeapWord* addr) const {
1161   ShenandoahHeapRegion* r = heap_region_containing(addr);
1162   return r-&gt;block_is_obj(addr);
1163 }
1164 
1165 bool ShenandoahHeap::print_location(outputStream* st, void* addr) const {
1166   return BlockLocationPrinter&lt;ShenandoahHeap&gt;::print_location(st, addr);
1167 }
1168 
1169 jlong ShenandoahHeap::millis_since_last_gc() {
1170   double v = heuristics()-&gt;time_since_last_gc() * 1000;
1171   assert(0 &lt;= v &amp;&amp; v &lt;= max_jlong, &quot;value should fit: %f&quot;, v);
1172   return (jlong)v;
1173 }
1174 
1175 void ShenandoahHeap::prepare_for_verify() {
1176   if (SafepointSynchronize::is_at_safepoint() || ! UseTLAB) {
1177     make_parsable(false);
1178   }
1179 }
1180 
1181 void ShenandoahHeap::print_gc_threads_on(outputStream* st) const {
1182   workers()-&gt;print_worker_threads_on(st);
1183   if (ShenandoahStringDedup::is_enabled()) {
1184     ShenandoahStringDedup::print_worker_threads_on(st);
1185   }
1186 }
1187 
1188 void ShenandoahHeap::gc_threads_do(ThreadClosure* tcl) const {
1189   workers()-&gt;threads_do(tcl);
1190   if (_safepoint_workers != NULL) {
1191     _safepoint_workers-&gt;threads_do(tcl);
1192   }
1193   if (ShenandoahStringDedup::is_enabled()) {
1194     ShenandoahStringDedup::threads_do(tcl);
1195   }
1196 }
1197 
1198 void ShenandoahHeap::print_tracing_info() const {
1199   LogTarget(Info, gc, stats) lt;
1200   if (lt.is_enabled()) {
1201     ResourceMark rm;
1202     LogStream ls(lt);
1203 
1204     phase_timings()-&gt;print_global_on(&amp;ls);
1205 
1206     ls.cr();
1207     ls.cr();
1208 
1209     shenandoah_policy()-&gt;print_gc_stats(&amp;ls);
1210 
1211     ls.cr();
1212     ls.cr();
1213 
1214     if (ShenandoahPacing) {
1215       pacer()-&gt;print_on(&amp;ls);
1216     }
1217 
1218     ls.cr();
1219     ls.cr();
1220   }
1221 }
1222 
1223 void ShenandoahHeap::verify(VerifyOption vo) {
1224   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
1225     if (ShenandoahVerify) {
1226       verifier()-&gt;verify_generic(vo);
1227     } else {
1228       // TODO: Consider allocating verification bitmaps on demand,
1229       // and turn this on unconditionally.
1230     }
1231   }
1232 }
1233 size_t ShenandoahHeap::tlab_capacity(Thread *thr) const {
1234   return _free_set-&gt;capacity();
1235 }
1236 
1237 class ObjectIterateScanRootClosure : public BasicOopIterateClosure {
1238 private:
1239   MarkBitMap* _bitmap;
1240   Stack&lt;oop,mtGC&gt;* _oop_stack;
1241   ShenandoahHeap* const _heap;
1242   ShenandoahMarkingContext* const _marking_context;
1243 
1244   template &lt;class T&gt;
1245   void do_oop_work(T* p) {
1246     T o = RawAccess&lt;&gt;::oop_load(p);
1247     if (!CompressedOops::is_null(o)) {
1248       oop obj = CompressedOops::decode_not_null(o);
1249       if (_heap-&gt;is_concurrent_weak_root_in_progress() &amp;&amp; !_marking_context-&gt;is_marked(obj)) {
1250         // There may be dead oops in weak roots in concurrent root phase, do not touch them.
1251         return;
1252       }
1253       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
1254 
1255       assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1256       if (!_bitmap-&gt;is_marked(obj)) {
1257         _bitmap-&gt;mark(obj);
1258         _oop_stack-&gt;push(obj);
1259       }
1260     }
1261   }
1262 public:
1263   ObjectIterateScanRootClosure(MarkBitMap* bitmap, Stack&lt;oop,mtGC&gt;* oop_stack) :
1264     _bitmap(bitmap), _oop_stack(oop_stack), _heap(ShenandoahHeap::heap()),
1265     _marking_context(_heap-&gt;marking_context()) {}
1266   void do_oop(oop* p)       { do_oop_work(p); }
1267   void do_oop(narrowOop* p) { do_oop_work(p); }
1268 };
1269 
1270 /*
1271  * This is public API, used in preparation of object_iterate().
1272  * Since we don&#39;t do linear scan of heap in object_iterate() (see comment below), we don&#39;t
1273  * need to make the heap parsable. For Shenandoah-internal linear heap scans that we can
1274  * control, we call SH::make_tlabs_parsable().
1275  */
1276 void ShenandoahHeap::ensure_parsability(bool retire_tlabs) {
1277   // No-op.
1278 }
1279 
1280 /*
1281  * Iterates objects in the heap. This is public API, used for, e.g., heap dumping.
1282  *
1283  * We cannot safely iterate objects by doing a linear scan at random points in time. Linear
1284  * scanning needs to deal with dead objects, which may have dead Klass* pointers (e.g.
1285  * calling oopDesc::size() would crash) or dangling reference fields (crashes) etc. Linear
1286  * scanning therefore depends on having a valid marking bitmap to support it. However, we only
1287  * have a valid marking bitmap after successful marking. In particular, we *don&#39;t* have a valid
1288  * marking bitmap during marking, after aborted marking or during/after cleanup (when we just
1289  * wiped the bitmap in preparation for next marking).
1290  *
1291  * For all those reasons, we implement object iteration as a single marking traversal, reporting
1292  * objects as we mark+traverse through the heap, starting from GC roots. JVMTI IterateThroughHeap
1293  * is allowed to report dead objects, but is not required to do so.
1294  */
1295 void ShenandoahHeap::object_iterate(ObjectClosure* cl) {
1296   assert(SafepointSynchronize::is_at_safepoint(), &quot;safe iteration is only available during safepoints&quot;);
1297   if (!_aux_bitmap_region_special &amp;&amp; !os::commit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), false)) {
1298     log_warning(gc)(&quot;Could not commit native memory for auxiliary marking bitmap for heap iteration&quot;);
1299     return;
1300   }
1301 
1302   // Reset bitmap
1303   _aux_bit_map.clear();
1304 
1305   Stack&lt;oop,mtGC&gt; oop_stack;
1306 
1307   // First, we process GC roots according to current GC cycle. This populates the work stack with initial objects.
1308   ShenandoahHeapIterationRootScanner rp;
1309   ObjectIterateScanRootClosure oops(&amp;_aux_bit_map, &amp;oop_stack);
1310 
1311   rp.roots_do(&amp;oops);
1312 
1313   // Work through the oop stack to traverse heap.
1314   while (! oop_stack.is_empty()) {
1315     oop obj = oop_stack.pop();
1316     assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1317     cl-&gt;do_object(obj);
1318     obj-&gt;oop_iterate(&amp;oops);
1319   }
1320 
1321   assert(oop_stack.is_empty(), &quot;should be empty&quot;);
1322 
1323   if (!_aux_bitmap_region_special &amp;&amp; !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
1324     log_warning(gc)(&quot;Could not uncommit native memory for auxiliary marking bitmap for heap iteration&quot;);
1325   }
1326 }
1327 
1328 // Keep alive an object that was loaded with AS_NO_KEEPALIVE.
1329 void ShenandoahHeap::keep_alive(oop obj) {
1330   if (is_concurrent_mark_in_progress()) {
1331     ShenandoahBarrierSet::barrier_set()-&gt;enqueue(obj);
1332   }
1333 }
1334 
1335 void ShenandoahHeap::heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
1336   for (size_t i = 0; i &lt; num_regions(); i++) {
1337     ShenandoahHeapRegion* current = get_region(i);
1338     blk-&gt;heap_region_do(current);
1339   }
1340 }
1341 
1342 class ShenandoahParallelHeapRegionTask : public AbstractGangTask {
1343 private:
1344   ShenandoahHeap* const _heap;
1345   ShenandoahHeapRegionClosure* const _blk;
1346 
1347   shenandoah_padding(0);
1348   volatile size_t _index;
1349   shenandoah_padding(1);
1350 
1351 public:
1352   ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk) :
1353           AbstractGangTask(&quot;Parallel Region Task&quot;),
1354           _heap(ShenandoahHeap::heap()), _blk(blk), _index(0) {}
1355 
1356   void work(uint worker_id) {
1357     ShenandoahParallelWorkerSession worker_session(worker_id);
1358     size_t stride = ShenandoahParallelRegionStride;
1359 
1360     size_t max = _heap-&gt;num_regions();
1361     while (_index &lt; max) {
1362       size_t cur = Atomic::fetch_and_add(&amp;_index, stride);
1363       size_t start = cur;
1364       size_t end = MIN2(cur + stride, max);
1365       if (start &gt;= max) break;
1366 
1367       for (size_t i = cur; i &lt; end; i++) {
1368         ShenandoahHeapRegion* current = _heap-&gt;get_region(i);
1369         _blk-&gt;heap_region_do(current);
1370       }
1371     }
1372   }
1373 };
1374 
1375 void ShenandoahHeap::parallel_heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
1376   assert(blk-&gt;is_thread_safe(), &quot;Only thread-safe closures here&quot;);
1377   if (num_regions() &gt; ShenandoahParallelRegionStride) {
1378     ShenandoahParallelHeapRegionTask task(blk);
1379     workers()-&gt;run_task(&amp;task);
1380   } else {
1381     heap_region_iterate(blk);
1382   }
1383 }
1384 
1385 class ShenandoahInitMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {
1386 private:
1387   ShenandoahMarkingContext* const _ctx;
1388 public:
1389   ShenandoahInitMarkUpdateRegionStateClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}
1390 
1391   void heap_region_do(ShenandoahHeapRegion* r) {
1392     assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;index());
1393     if (r-&gt;is_active()) {
1394       // Check if region needs updating its TAMS. We have updated it already during concurrent
1395       // reset, so it is very likely we don&#39;t need to do another write here.
1396       if (_ctx-&gt;top_at_mark_start(r) != r-&gt;top()) {
1397         _ctx-&gt;capture_top_at_mark_start(r);
1398       }
1399     } else {
1400       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
1401              &quot;Region &quot; SIZE_FORMAT &quot; should already have correct TAMS&quot;, r-&gt;index());
1402     }
1403   }
1404 
1405   bool is_thread_safe() { return true; }
1406 };
1407 
1408 void ShenandoahHeap::op_init_mark() {
1409   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1410   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
1411 
1412   assert(marking_context()-&gt;is_bitmap_clear(), &quot;need clear marking bitmap&quot;);
1413   assert(!marking_context()-&gt;is_complete(), &quot;should not be complete&quot;);
1414   assert(!has_forwarded_objects(), &quot;No forwarded objects on this path&quot;);
1415 
1416   if (ShenandoahVerify) {
1417     verifier()-&gt;verify_before_concmark();
1418   }
1419 
1420   if (VerifyBeforeGC) {
1421     Universe::verify();
1422   }
1423 
1424   set_concurrent_mark_in_progress(true);
1425   // We need to reset all TLABs because we&#39;d lose marks on all objects allocated in them.
1426   {
1427     ShenandoahGCPhase phase(ShenandoahPhaseTimings::make_parsable);
1428     make_parsable(true);
1429   }
1430 
1431   {
1432     ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_region_states);
1433     ShenandoahInitMarkUpdateRegionStateClosure cl;
1434     parallel_heap_region_iterate(&amp;cl);
1435   }
1436 
1437   // Make above changes visible to worker threads
1438   OrderAccess::fence();
1439 
1440   concurrent_mark()-&gt;mark_roots(ShenandoahPhaseTimings::scan_roots);
1441 
1442   if (UseTLAB) {
1443     ShenandoahGCPhase phase(ShenandoahPhaseTimings::resize_tlabs);
1444     resize_tlabs();
1445   }
1446 
1447   if (ShenandoahPacing) {
1448     pacer()-&gt;setup_for_mark();
1449   }
1450 
1451   // Arm nmethods for concurrent marking. When a nmethod is about to be executed,
1452   // we need to make sure that all its metadata are marked. alternative is to remark
1453   // thread roots at final mark pause, but it can be potential latency killer.
1454   if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1455     ShenandoahCodeRoots::arm_nmethods();
1456   }
1457 }
1458 
1459 void ShenandoahHeap::op_mark() {
1460   concurrent_mark()-&gt;mark_from_roots();
1461 }
1462 
1463 class ShenandoahFinalMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {
1464 private:
1465   ShenandoahMarkingContext* const _ctx;
1466   ShenandoahHeapLock* const _lock;
1467 
1468 public:
1469   ShenandoahFinalMarkUpdateRegionStateClosure() :
1470     _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()), _lock(ShenandoahHeap::heap()-&gt;lock()) {}
1471 
1472   void heap_region_do(ShenandoahHeapRegion* r) {
1473     if (r-&gt;is_active()) {
1474       // All allocations past TAMS are implicitly live, adjust the region data.
1475       // Bitmaps/TAMS are swapped at this point, so we need to poll complete bitmap.
1476       HeapWord *tams = _ctx-&gt;top_at_mark_start(r);
1477       HeapWord *top = r-&gt;top();
1478       if (top &gt; tams) {
1479         r-&gt;increase_live_data_alloc_words(pointer_delta(top, tams));
1480       }
1481 
1482       // We are about to select the collection set, make sure it knows about
1483       // current pinning status. Also, this allows trashing more regions that
1484       // now have their pinning status dropped.
1485       if (r-&gt;is_pinned()) {
1486         if (r-&gt;pin_count() == 0) {
1487           ShenandoahHeapLocker locker(_lock);
1488           r-&gt;make_unpinned();
1489         }
1490       } else {
1491         if (r-&gt;pin_count() &gt; 0) {
1492           ShenandoahHeapLocker locker(_lock);
1493           r-&gt;make_pinned();
1494         }
1495       }
1496 
1497       // Remember limit for updating refs. It&#39;s guaranteed that we get no
1498       // from-space-refs written from here on.
1499       r-&gt;set_update_watermark_at_safepoint(r-&gt;top());
1500     } else {
1501       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;index());
1502       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
1503              &quot;Region &quot; SIZE_FORMAT &quot; should have correct TAMS&quot;, r-&gt;index());
1504     }
1505   }
1506 
1507   bool is_thread_safe() { return true; }
1508 };
1509 
1510 void ShenandoahHeap::op_final_mark() {
1511   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1512   assert(!has_forwarded_objects(), &quot;No forwarded objects on this path&quot;);
1513 
1514   // It is critical that we
1515   // evacuate roots right after finishing marking, so that we don&#39;t
1516   // get unmarked objects in the roots.
1517 
1518   if (!cancelled_gc()) {
1519     concurrent_mark()-&gt;finish_mark_from_roots(/* full_gc = */ false);
1520 
1521     // Marking is completed, deactivate SATB barrier
1522     set_concurrent_mark_in_progress(false);
1523     mark_complete_marking_context();
1524 
1525     parallel_cleaning(false /* full gc*/);
1526 
1527     if (ShenandoahVerify) {
1528       verifier()-&gt;verify_roots_no_forwarded();
1529     }
1530 
1531     {
1532       ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_region_states);
1533       ShenandoahFinalMarkUpdateRegionStateClosure cl;
1534       parallel_heap_region_iterate(&amp;cl);
1535 
1536       assert_pinned_region_status();
1537     }
1538 
1539     // Retire the TLABs, which will force threads to reacquire their TLABs after the pause.
1540     // This is needed for two reasons. Strong one: new allocations would be with new freeset,
1541     // which would be outside the collection set, so no cset writes would happen there.
1542     // Weaker one: new allocations would happen past update watermark, and so less work would
1543     // be needed for reference updates (would update the large filler instead).
1544     {
1545       ShenandoahGCPhase phase(ShenandoahPhaseTimings::retire_tlabs);
1546       make_parsable(true);
1547     }
1548 
1549     {
1550       ShenandoahGCPhase phase(ShenandoahPhaseTimings::choose_cset);
1551       ShenandoahHeapLocker locker(lock());
1552       _collection_set-&gt;clear();
1553       heuristics()-&gt;choose_collection_set(_collection_set);
1554     }
1555 
1556     {
1557       ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_rebuild_freeset);
1558       ShenandoahHeapLocker locker(lock());
1559       _free_set-&gt;rebuild();
1560     }
1561 
1562     if (!is_degenerated_gc_in_progress()) {
1563       prepare_concurrent_roots();
1564       prepare_concurrent_unloading();
1565     }
1566 
1567     // If collection set has candidates, start evacuation.
1568     // Otherwise, bypass the rest of the cycle.
1569     if (!collection_set()-&gt;is_empty()) {
1570       ShenandoahGCPhase init_evac(ShenandoahPhaseTimings::init_evac);
1571 
1572       if (ShenandoahVerify) {
1573         verifier()-&gt;verify_before_evacuation();
1574       }
1575 
1576       set_evacuation_in_progress(true);
1577       // From here on, we need to update references.
1578       set_has_forwarded_objects(true);
1579 
1580       if (!is_degenerated_gc_in_progress()) {
1581         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1582           ShenandoahCodeRoots::arm_nmethods();
1583         }
1584         evacuate_and_update_roots();
1585       }
1586 
1587       if (ShenandoahPacing) {
1588         pacer()-&gt;setup_for_evac();
1589       }
1590 
1591       if (ShenandoahVerify) {
<a name="1" id="anc1"></a><span class="line-modified">1592         // If OOM while evacuating/updating of roots, there is no guarantee of their consistencies</span>
<span class="line-modified">1593         if (!cancelled_gc()) {</span>
<span class="line-modified">1594           ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::None;</span>
<span class="line-modified">1595           if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {</span>
<span class="line-modified">1596             types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::JNIHandleRoots, ShenandoahRootVerifier::WeakRoots);</span>
<span class="line-added">1597             types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CLDGRoots);</span>
<span class="line-added">1598             types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::StringDedupRoots);</span>
<span class="line-added">1599           }</span>
<span class="line-added">1600 </span>
<span class="line-added">1601           if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">1602             types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CodeRoots);</span>
<span class="line-added">1603           }</span>
<span class="line-added">1604           verifier()-&gt;verify_roots_no_forwarded_except(types);</span>
1605         }
<a name="2" id="anc2"></a>




1606         verifier()-&gt;verify_during_evacuation();
1607       }
1608     } else {
1609       if (ShenandoahVerify) {
1610         verifier()-&gt;verify_after_concmark();
1611       }
1612 
1613       if (VerifyAfterGC) {
1614         Universe::verify();
1615       }
1616     }
1617 
1618   } else {
1619     // If this cycle was updating references, we need to keep the has_forwarded_objects
1620     // flag on, for subsequent phases to deal with it.
1621     concurrent_mark()-&gt;cancel();
1622     set_concurrent_mark_in_progress(false);
1623 
1624     if (process_references()) {
1625       // Abandon reference processing right away: pre-cleaning must have failed.
1626       ReferenceProcessor *rp = ref_processor();
1627       rp-&gt;disable_discovery();
1628       rp-&gt;abandon_partial_discovery();
1629       rp-&gt;verify_no_references_recorded();
1630     }
1631   }
1632 }
1633 
1634 void ShenandoahHeap::op_conc_evac() {
1635   ShenandoahEvacuationTask task(this, _collection_set, true);
1636   workers()-&gt;run_task(&amp;task);
1637 }
1638 
1639 void ShenandoahHeap::op_stw_evac() {
1640   ShenandoahEvacuationTask task(this, _collection_set, false);
1641   workers()-&gt;run_task(&amp;task);
1642 }
1643 
1644 void ShenandoahHeap::op_updaterefs() {
1645   update_heap_references(true);
1646 }
1647 
1648 void ShenandoahHeap::op_cleanup_early() {
1649   free_set()-&gt;recycle_trash();
1650 }
1651 
1652 void ShenandoahHeap::op_cleanup_complete() {
1653   free_set()-&gt;recycle_trash();
1654 }
1655 
1656 class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {
1657 private:
1658   ShenandoahVMRoots&lt;true /*concurrent*/&gt;        _vm_roots;
1659   ShenandoahClassLoaderDataRoots&lt;true /*concurrent*/, false /*single threaded*/&gt; _cld_roots;
1660   ShenandoahConcurrentStringDedupRoots          _dedup_roots;
1661 
1662 public:
1663   ShenandoahConcurrentRootsEvacUpdateTask(ShenandoahPhaseTimings::Phase phase) :
1664     AbstractGangTask(&quot;Shenandoah Evacuate/Update Concurrent Strong Roots Task&quot;),
1665     _vm_roots(phase),
<a name="3" id="anc3"></a><span class="line-modified">1666     _cld_roots(phase, ShenandoahHeap::heap()-&gt;workers()-&gt;active_workers()) {}</span>
1667 
1668   void work(uint worker_id) {
1669     ShenandoahConcurrentWorkerSession worker_session(worker_id);
1670     ShenandoahEvacOOMScope oom;
1671     {
1672       // vm_roots and weak_roots are OopStorage backed roots, concurrent iteration
1673       // may race against OopStorage::release() calls.
1674       ShenandoahEvacUpdateOopStorageRootsClosure cl;
1675       _vm_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl, worker_id);
1676     }
1677 
1678     {
1679       ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
1680       CLDToOopClosure clds(&amp;cl, ClassLoaderData::_claim_strong);
1681       _cld_roots.cld_do(&amp;clds, worker_id);
1682     }
1683 
1684     {
1685       ShenandoahForwardedIsAliveClosure is_alive;
1686       ShenandoahEvacuateUpdateRootsClosure&lt;MO_RELEASE&gt; keep_alive;
1687       _dedup_roots.oops_do(&amp;is_alive, &amp;keep_alive, worker_id);
1688     }
1689   }
1690 };
1691 
1692 class ShenandoahEvacUpdateCleanupOopStorageRootsClosure : public BasicOopIterateClosure {
1693 private:
1694   ShenandoahHeap* const _heap;
1695   ShenandoahMarkingContext* const _mark_context;
1696   bool  _evac_in_progress;
1697   Thread* const _thread;
1698   size_t  _dead_counter;
1699 
1700 public:
1701   ShenandoahEvacUpdateCleanupOopStorageRootsClosure();
1702   void do_oop(oop* p);
1703   void do_oop(narrowOop* p);
1704 
1705   size_t dead_counter() const;
1706   void reset_dead_counter();
1707 };
1708 
1709 ShenandoahEvacUpdateCleanupOopStorageRootsClosure::ShenandoahEvacUpdateCleanupOopStorageRootsClosure() :
1710   _heap(ShenandoahHeap::heap()),
1711   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()),
1712   _evac_in_progress(ShenandoahHeap::heap()-&gt;is_evacuation_in_progress()),
1713   _thread(Thread::current()),
1714   _dead_counter(0) {
1715 }
1716 
1717 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::do_oop(oop* p) {
1718   const oop obj = RawAccess&lt;&gt;::oop_load(p);
1719   if (!CompressedOops::is_null(obj)) {
1720     if (!_mark_context-&gt;is_marked(obj)) {
1721       shenandoah_assert_correct(p, obj);
1722       oop old = Atomic::cmpxchg(p, obj, oop(NULL));
1723       if (obj == old) {
1724         _dead_counter ++;
1725       }
1726     } else if (_evac_in_progress &amp;&amp; _heap-&gt;in_collection_set(obj)) {
1727       oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
1728       if (resolved == obj) {
1729         resolved = _heap-&gt;evacuate_object(obj, _thread);
1730       }
1731       Atomic::cmpxchg(p, obj, resolved);
1732       assert(_heap-&gt;cancelled_gc() ||
1733              _mark_context-&gt;is_marked(resolved) &amp;&amp; !_heap-&gt;in_collection_set(resolved),
1734              &quot;Sanity&quot;);
1735     }
1736   }
1737 }
1738 
1739 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::do_oop(narrowOop* p) {
1740   ShouldNotReachHere();
1741 }
1742 
1743 size_t ShenandoahEvacUpdateCleanupOopStorageRootsClosure::dead_counter() const {
1744   return _dead_counter;
1745 }
1746 
1747 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::reset_dead_counter() {
1748   _dead_counter = 0;
1749 }
1750 
1751 class ShenandoahIsCLDAliveClosure : public CLDClosure {
1752 public:
1753   void do_cld(ClassLoaderData* cld) {
1754     cld-&gt;is_alive();
1755   }
1756 };
1757 
1758 class ShenandoahIsNMethodAliveClosure: public NMethodClosure {
1759 public:
1760   void do_nmethod(nmethod* n) {
1761     n-&gt;is_unloading();
1762   }
1763 };
1764 
1765 // This task not only evacuates/updates marked weak roots, but also &quot;NULL&quot;
1766 // dead weak roots.
1767 class ShenandoahConcurrentWeakRootsEvacUpdateTask : public AbstractGangTask {
1768 private:
1769   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _jni_roots;
1770   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _string_table_roots;
1771   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _resolved_method_table_roots;
1772   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _vm_roots;
1773 
1774   // Roots related to concurrent class unloading
1775   ShenandoahClassLoaderDataRoots&lt;true /* concurrent */, false /* single thread*/&gt;
1776                                            _cld_roots;
1777   ShenandoahConcurrentNMethodIterator      _nmethod_itr;
1778   bool                                     _concurrent_class_unloading;
1779 
1780 public:
1781   ShenandoahConcurrentWeakRootsEvacUpdateTask(ShenandoahPhaseTimings::Phase phase) :
1782     AbstractGangTask(&quot;Shenandoah Concurrent Weak Root Task&quot;),
1783     _jni_roots(OopStorageSet::jni_weak(), phase, ShenandoahPhaseTimings::JNIWeakRoots),
1784     _string_table_roots(OopStorageSet::string_table_weak(), phase, ShenandoahPhaseTimings::StringTableRoots),
1785     _resolved_method_table_roots(OopStorageSet::resolved_method_table_weak(), phase, ShenandoahPhaseTimings::ResolvedMethodTableRoots),
1786     _vm_roots(OopStorageSet::vm_weak(), phase, ShenandoahPhaseTimings::VMWeakRoots),
<a name="4" id="anc4"></a><span class="line-modified">1787     _cld_roots(phase, ShenandoahHeap::heap()-&gt;workers()-&gt;active_workers()),</span>
1788     _nmethod_itr(ShenandoahCodeRoots::table()),
1789     _concurrent_class_unloading(ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1790     StringTable::reset_dead_counter();
1791     ResolvedMethodTable::reset_dead_counter();
1792     if (_concurrent_class_unloading) {
1793       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1794       _nmethod_itr.nmethods_do_begin();
1795     }
1796   }
1797 
1798   ~ShenandoahConcurrentWeakRootsEvacUpdateTask() {
1799     StringTable::finish_dead_counter();
1800     ResolvedMethodTable::finish_dead_counter();
1801     if (_concurrent_class_unloading) {
1802       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1803       _nmethod_itr.nmethods_do_end();
1804     }
1805   }
1806 
1807   void work(uint worker_id) {
1808     ShenandoahConcurrentWorkerSession worker_session(worker_id);
1809     {
1810       ShenandoahEvacOOMScope oom;
1811       // jni_roots and weak_roots are OopStorage backed roots, concurrent iteration
1812       // may race against OopStorage::release() calls.
1813       ShenandoahEvacUpdateCleanupOopStorageRootsClosure cl;
1814       _jni_roots.oops_do(&amp;cl, worker_id);
1815       _vm_roots.oops_do(&amp;cl, worker_id);
1816 
1817       cl.reset_dead_counter();
1818       _string_table_roots.oops_do(&amp;cl, worker_id);
1819       StringTable::inc_dead_counter(cl.dead_counter());
1820 
1821       cl.reset_dead_counter();
1822       _resolved_method_table_roots.oops_do(&amp;cl, worker_id);
1823       ResolvedMethodTable::inc_dead_counter(cl.dead_counter());
1824     }
1825 
1826     // If we are going to perform concurrent class unloading later on, we need to
1827     // cleanup the weak oops in CLD and determinate nmethod&#39;s unloading state, so that we
1828     // can cleanup immediate garbage sooner.
1829     if (_concurrent_class_unloading) {
1830       // Applies ShenandoahIsCLDAlive closure to CLDs, native barrier will either NULL the
1831       // CLD&#39;s holder or evacuate it.
1832       ShenandoahIsCLDAliveClosure is_cld_alive;
1833       _cld_roots.cld_do(&amp;is_cld_alive, worker_id);
1834 
1835       // Applies ShenandoahIsNMethodAliveClosure to registered nmethods.
1836       // The closure calls nmethod-&gt;is_unloading(). The is_unloading
1837       // state is cached, therefore, during concurrent class unloading phase,
1838       // we will not touch the metadata of unloading nmethods
1839       ShenandoahIsNMethodAliveClosure is_nmethod_alive;
1840       _nmethod_itr.nmethods_do(&amp;is_nmethod_alive);
1841     }
1842   }
1843 };
1844 
1845 void ShenandoahHeap::op_weak_roots() {
1846   if (is_concurrent_weak_root_in_progress()) {
1847     // Concurrent weak root processing
1848     {
1849       ShenandoahTimingsTracker t(ShenandoahPhaseTimings::conc_weak_roots_work);
1850       ShenandoahGCWorkerPhase worker_phase(ShenandoahPhaseTimings::conc_weak_roots_work);
1851       ShenandoahConcurrentWeakRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_weak_roots_work);
1852       workers()-&gt;run_task(&amp;task);
1853       if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1854         set_concurrent_weak_root_in_progress(false);
1855       }
1856     }
1857 
1858     // Perform handshake to flush out dead oops
1859     {
1860       ShenandoahTimingsTracker t(ShenandoahPhaseTimings::conc_weak_roots_rendezvous);
1861       ShenandoahRendezvousClosure cl;
1862       Handshake::execute(&amp;cl);
1863     }
1864   }
1865 }
1866 
1867 void ShenandoahHeap::op_class_unloading() {
1868   assert (is_concurrent_weak_root_in_progress() &amp;&amp;
1869           ShenandoahConcurrentRoots::should_do_concurrent_class_unloading(),
1870           &quot;Checked by caller&quot;);
1871   _unloader.unload();
1872   set_concurrent_weak_root_in_progress(false);
1873 }
1874 
1875 void ShenandoahHeap::op_strong_roots() {
1876   assert(is_concurrent_strong_root_in_progress(), &quot;Checked by caller&quot;);
1877   ShenandoahConcurrentRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_strong_roots);
1878   workers()-&gt;run_task(&amp;task);
1879   set_concurrent_strong_root_in_progress(false);
1880 }
1881 
1882 class ShenandoahResetUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {
1883 private:
1884   ShenandoahMarkingContext* const _ctx;
1885 public:
1886   ShenandoahResetUpdateRegionStateClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}
1887 
1888   void heap_region_do(ShenandoahHeapRegion* r) {
1889     if (r-&gt;is_active()) {
1890       // Reset live data and set TAMS optimistically. We would recheck these under the pause
1891       // anyway to capture any updates that happened since now.
1892       r-&gt;clear_live_data();
1893       _ctx-&gt;capture_top_at_mark_start(r);
1894     }
1895   }
1896 
1897   bool is_thread_safe() { return true; }
1898 };
1899 
1900 void ShenandoahHeap::op_reset() {
1901   if (ShenandoahPacing) {
1902     pacer()-&gt;setup_for_reset();
1903   }
1904   reset_mark_bitmap();
1905 
1906   ShenandoahResetUpdateRegionStateClosure cl;
1907   parallel_heap_region_iterate(&amp;cl);
1908 }
1909 
1910 void ShenandoahHeap::op_preclean() {
1911   if (ShenandoahPacing) {
1912     pacer()-&gt;setup_for_preclean();
1913   }
1914   concurrent_mark()-&gt;preclean_weak_refs();
1915 }
1916 
1917 void ShenandoahHeap::op_full(GCCause::Cause cause) {
1918   ShenandoahMetricsSnapshot metrics;
1919   metrics.snap_before();
1920 
1921   full_gc()-&gt;do_it(cause);
1922   if (UseTLAB) {
1923     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_resize_tlabs);
1924     resize_all_tlabs();
1925   }
1926 
1927   metrics.snap_after();
1928 
1929   if (metrics.is_good_progress()) {
1930     _progress_last_gc.set();
1931   } else {
1932     // Nothing to do. Tell the allocation path that we have failed to make
1933     // progress, and it can finally fail.
1934     _progress_last_gc.unset();
1935   }
1936 }
1937 
1938 void ShenandoahHeap::op_degenerated(ShenandoahDegenPoint point) {
1939   // Degenerated GC is STW, but it can also fail. Current mechanics communicates
1940   // GC failure via cancelled_concgc() flag. So, if we detect the failure after
1941   // some phase, we have to upgrade the Degenerate GC to Full GC.
1942 
1943   clear_cancelled_gc();
1944 
1945   ShenandoahMetricsSnapshot metrics;
1946   metrics.snap_before();
1947 
1948   switch (point) {
1949     // The cases below form the Duff&#39;s-like device: it describes the actual GC cycle,
1950     // but enters it at different points, depending on which concurrent phase had
1951     // degenerated.
1952 
1953     case _degenerated_outside_cycle:
1954       // We have degenerated from outside the cycle, which means something is bad with
1955       // the heap, most probably heavy humongous fragmentation, or we are very low on free
1956       // space. It makes little sense to wait for Full GC to reclaim as much as it can, when
1957       // we can do the most aggressive degen cycle, which includes processing references and
1958       // class unloading, unless those features are explicitly disabled.
1959       //
1960       // Note that we can only do this for &quot;outside-cycle&quot; degens, otherwise we would risk
1961       // changing the cycle parameters mid-cycle during concurrent -&gt; degenerated handover.
1962       set_process_references(heuristics()-&gt;can_process_references());
1963       set_unload_classes(heuristics()-&gt;can_unload_classes());
1964 
1965       op_reset();
1966 
1967       op_init_mark();
1968       if (cancelled_gc()) {
1969         op_degenerated_fail();
1970         return;
1971       }
1972 
1973     case _degenerated_mark:
1974       op_final_mark();
1975       if (cancelled_gc()) {
1976         op_degenerated_fail();
1977         return;
1978       }
1979 
1980       if (!has_forwarded_objects() &amp;&amp; ShenandoahConcurrentRoots::can_do_concurrent_class_unloading()) {
1981         // Disarm nmethods that armed for concurrent mark. On normal cycle, it would
1982         // be disarmed while conc-roots phase is running.
1983         // TODO: Call op_conc_roots() here instead
1984         ShenandoahCodeRoots::disarm_nmethods();
1985       }
1986 
1987       op_cleanup_early();
1988 
1989     case _degenerated_evac:
1990       // If heuristics thinks we should do the cycle, this flag would be set,
1991       // and we can do evacuation. Otherwise, it would be the shortcut cycle.
1992       if (is_evacuation_in_progress()) {
1993 
1994         // Degeneration under oom-evac protocol might have left some objects in
1995         // collection set un-evacuated. Restart evacuation from the beginning to
1996         // capture all objects. For all the objects that are already evacuated,
1997         // it would be a simple check, which is supposed to be fast. This is also
1998         // safe to do even without degeneration, as CSet iterator is at beginning
1999         // in preparation for evacuation anyway.
2000         //
2001         // Before doing that, we need to make sure we never had any cset-pinned
2002         // regions. This may happen if allocation failure happened when evacuating
2003         // the about-to-be-pinned object, oom-evac protocol left the object in
2004         // the collection set, and then the pin reached the cset region. If we continue
2005         // the cycle here, we would trash the cset and alive objects in it. To avoid
2006         // it, we fail degeneration right away and slide into Full GC to recover.
2007 
2008         {
2009           sync_pinned_region_status();
2010           collection_set()-&gt;clear_current_index();
2011 
2012           ShenandoahHeapRegion* r;
2013           while ((r = collection_set()-&gt;next()) != NULL) {
2014             if (r-&gt;is_pinned()) {
2015               cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
2016               op_degenerated_fail();
2017               return;
2018             }
2019           }
2020 
2021           collection_set()-&gt;clear_current_index();
2022         }
2023 
2024         op_stw_evac();
2025         if (cancelled_gc()) {
2026           op_degenerated_fail();
2027           return;
2028         }
2029       }
2030 
2031       // If heuristics thinks we should do the cycle, this flag would be set,
2032       // and we need to do update-refs. Otherwise, it would be the shortcut cycle.
2033       if (has_forwarded_objects()) {
2034         op_init_updaterefs();
2035         if (cancelled_gc()) {
2036           op_degenerated_fail();
2037           return;
2038         }
2039       }
2040 
2041     case _degenerated_updaterefs:
2042       if (has_forwarded_objects()) {
2043         op_final_updaterefs();
2044         if (cancelled_gc()) {
2045           op_degenerated_fail();
2046           return;
2047         }
2048       }
2049 
2050       op_cleanup_complete();
2051       break;
2052 
2053     default:
2054       ShouldNotReachHere();
2055   }
2056 
2057   if (ShenandoahVerify) {
2058     verifier()-&gt;verify_after_degenerated();
2059   }
2060 
2061   if (VerifyAfterGC) {
2062     Universe::verify();
2063   }
2064 
2065   metrics.snap_after();
2066 
2067   // Check for futility and fail. There is no reason to do several back-to-back Degenerated cycles,
2068   // because that probably means the heap is overloaded and/or fragmented.
2069   if (!metrics.is_good_progress()) {
2070     _progress_last_gc.unset();
2071     cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
2072     op_degenerated_futile();
2073   } else {
2074     _progress_last_gc.set();
2075   }
2076 }
2077 
2078 void ShenandoahHeap::op_degenerated_fail() {
2079   log_info(gc)(&quot;Cannot finish degeneration, upgrading to Full GC&quot;);
2080   shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
2081   op_full(GCCause::_shenandoah_upgrade_to_full_gc);
2082 }
2083 
2084 void ShenandoahHeap::op_degenerated_futile() {
2085   shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
2086   op_full(GCCause::_shenandoah_upgrade_to_full_gc);
2087 }
2088 
2089 void ShenandoahHeap::force_satb_flush_all_threads() {
2090   if (!is_concurrent_mark_in_progress()) {
2091     // No need to flush SATBs
2092     return;
2093   }
2094 
2095   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
2096     ShenandoahThreadLocalData::set_force_satb_flush(t, true);
2097   }
2098   // The threads are not &quot;acquiring&quot; their thread-local data, but it does not
2099   // hurt to &quot;release&quot; the updates here anyway.
2100   OrderAccess::fence();
2101 }
2102 
2103 void ShenandoahHeap::set_gc_state_all_threads(char state) {
2104   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
2105     ShenandoahThreadLocalData::set_gc_state(t, state);
2106   }
2107 }
2108 
2109 void ShenandoahHeap::set_gc_state_mask(uint mask, bool value) {
2110   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should really be Shenandoah safepoint&quot;);
2111   _gc_state.set_cond(mask, value);
2112   set_gc_state_all_threads(_gc_state.raw_value());
2113 }
2114 
2115 void ShenandoahHeap::set_concurrent_mark_in_progress(bool in_progress) {
2116   if (has_forwarded_objects()) {
2117     set_gc_state_mask(MARKING | UPDATEREFS, in_progress);
2118   } else {
2119     set_gc_state_mask(MARKING, in_progress);
2120   }
2121   ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
2122 }
2123 
2124 void ShenandoahHeap::set_evacuation_in_progress(bool in_progress) {
2125   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only call this at safepoint&quot;);
2126   set_gc_state_mask(EVACUATION, in_progress);
2127 }
2128 
2129 void ShenandoahHeap::set_concurrent_strong_root_in_progress(bool in_progress) {
2130   assert(ShenandoahConcurrentRoots::can_do_concurrent_roots(), &quot;Why set the flag?&quot;);
2131   if (in_progress) {
2132     _concurrent_strong_root_in_progress.set();
2133   } else {
2134     _concurrent_strong_root_in_progress.unset();
2135   }
2136 }
2137 
2138 void ShenandoahHeap::set_concurrent_weak_root_in_progress(bool in_progress) {
2139   assert(ShenandoahConcurrentRoots::can_do_concurrent_roots(), &quot;Why set the flag?&quot;);
2140   if (in_progress) {
2141     _concurrent_weak_root_in_progress.set();
2142   } else {
2143     _concurrent_weak_root_in_progress.unset();
2144   }
2145 }
2146 
2147 void ShenandoahHeap::ref_processing_init() {
2148   assert(_max_workers &gt; 0, &quot;Sanity&quot;);
2149 
2150   _ref_processor =
2151     new ReferenceProcessor(&amp;_subject_to_discovery,  // is_subject_to_discovery
2152                            _ref_proc_mt_processing, // MT processing
2153                            _max_workers,            // Degree of MT processing
2154                            _ref_proc_mt_discovery,  // MT discovery
2155                            _max_workers,            // Degree of MT discovery
2156                            false,                   // Reference discovery is not atomic
2157                            NULL,                    // No closure, should be installed before use
2158                            true);                   // Scale worker threads
2159 
2160   shenandoah_assert_rp_isalive_not_installed();
2161 }
2162 
2163 GCTracer* ShenandoahHeap::tracer() {
2164   return shenandoah_policy()-&gt;tracer();
2165 }
2166 
2167 size_t ShenandoahHeap::tlab_used(Thread* thread) const {
2168   return _free_set-&gt;used();
2169 }
2170 
2171 bool ShenandoahHeap::try_cancel_gc() {
2172   while (true) {
2173     jbyte prev = _cancelled_gc.cmpxchg(CANCELLED, CANCELLABLE);
2174     if (prev == CANCELLABLE) return true;
2175     else if (prev == CANCELLED) return false;
2176     assert(ShenandoahSuspendibleWorkers, &quot;should not get here when not using suspendible workers&quot;);
2177     assert(prev == NOT_CANCELLED, &quot;must be NOT_CANCELLED&quot;);
2178     if (Thread::current()-&gt;is_Java_thread()) {
2179       // We need to provide a safepoint here, otherwise we might
2180       // spin forever if a SP is pending.
2181       ThreadBlockInVM sp(JavaThread::current());
2182       SpinPause();
2183     }
2184   }
2185 }
2186 
2187 void ShenandoahHeap::cancel_gc(GCCause::Cause cause) {
2188   if (try_cancel_gc()) {
2189     FormatBuffer&lt;&gt; msg(&quot;Cancelling GC: %s&quot;, GCCause::to_string(cause));
2190     log_info(gc)(&quot;%s&quot;, msg.buffer());
2191     Events::log(Thread::current(), &quot;%s&quot;, msg.buffer());
2192   }
2193 }
2194 
2195 uint ShenandoahHeap::max_workers() {
2196   return _max_workers;
2197 }
2198 
2199 void ShenandoahHeap::stop() {
2200   // The shutdown sequence should be able to terminate when GC is running.
2201 
2202   // Step 0. Notify policy to disable event recording.
2203   _shenandoah_policy-&gt;record_shutdown();
2204 
2205   // Step 1. Notify control thread that we are in shutdown.
2206   // Note that we cannot do that with stop(), because stop() is blocking and waits for the actual shutdown.
2207   // Doing stop() here would wait for the normal GC cycle to complete, never falling through to cancel below.
2208   control_thread()-&gt;prepare_for_graceful_shutdown();
2209 
2210   // Step 2. Notify GC workers that we are cancelling GC.
2211   cancel_gc(GCCause::_shenandoah_stop_vm);
2212 
2213   // Step 3. Wait until GC worker exits normally.
2214   control_thread()-&gt;stop();
2215 
2216   // Step 4. Stop String Dedup thread if it is active
2217   if (ShenandoahStringDedup::is_enabled()) {
2218     ShenandoahStringDedup::stop();
2219   }
2220 }
2221 
2222 void ShenandoahHeap::stw_unload_classes(bool full_gc) {
2223   if (!unload_classes()) return;
2224 
2225   // Unload classes and purge SystemDictionary.
2226   {
2227     ShenandoahGCPhase phase(full_gc ?
2228                             ShenandoahPhaseTimings::full_gc_purge_class_unload :
2229                             ShenandoahPhaseTimings::purge_class_unload);
2230     bool purged_class = SystemDictionary::do_unloading(gc_timer());
2231 
2232     ShenandoahIsAliveSelector is_alive;
2233     uint num_workers = _workers-&gt;active_workers();
2234     ShenandoahClassUnloadingTask unlink_task(is_alive.is_alive_closure(), num_workers, purged_class);
2235     _workers-&gt;run_task(&amp;unlink_task);
2236   }
2237 
2238   {
2239     ShenandoahGCPhase phase(full_gc ?
2240                             ShenandoahPhaseTimings::full_gc_purge_cldg :
2241                             ShenandoahPhaseTimings::purge_cldg);
2242     ClassLoaderDataGraph::purge();
2243   }
2244   // Resize and verify metaspace
2245   MetaspaceGC::compute_new_size();
2246   MetaspaceUtils::verify_metrics();
2247 }
2248 
2249 // Weak roots are either pre-evacuated (final mark) or updated (final updaterefs),
2250 // so they should not have forwarded oops.
2251 // However, we do need to &quot;null&quot; dead oops in the roots, if can not be done
2252 // in concurrent cycles.
2253 void ShenandoahHeap::stw_process_weak_roots(bool full_gc) {
2254   ShenandoahGCPhase root_phase(full_gc ?
2255                                ShenandoahPhaseTimings::full_gc_purge :
2256                                ShenandoahPhaseTimings::purge);
2257   uint num_workers = _workers-&gt;active_workers();
2258   ShenandoahPhaseTimings::Phase timing_phase = full_gc ?
2259                                                ShenandoahPhaseTimings::full_gc_purge_weak_par :
2260                                                ShenandoahPhaseTimings::purge_weak_par;
2261   ShenandoahGCPhase phase(timing_phase);
2262   ShenandoahGCWorkerPhase worker_phase(timing_phase);
2263 
2264   // Cleanup weak roots
2265   if (has_forwarded_objects()) {
2266     ShenandoahForwardedIsAliveClosure is_alive;
2267     ShenandoahUpdateRefsClosure keep_alive;
2268     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahUpdateRefsClosure&gt;
2269       cleaning_task(timing_phase, &amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
2270     _workers-&gt;run_task(&amp;cleaning_task);
2271   } else {
2272     ShenandoahIsAliveClosure is_alive;
2273 #ifdef ASSERT
2274     ShenandoahAssertNotForwardedClosure verify_cl;
2275     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, ShenandoahAssertNotForwardedClosure&gt;
2276       cleaning_task(timing_phase, &amp;is_alive, &amp;verify_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
2277 #else
2278     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, DoNothingClosure&gt;
2279       cleaning_task(timing_phase, &amp;is_alive, &amp;do_nothing_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
2280 #endif
2281     _workers-&gt;run_task(&amp;cleaning_task);
2282   }
2283 }
2284 
2285 void ShenandoahHeap::parallel_cleaning(bool full_gc) {
2286   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2287   stw_process_weak_roots(full_gc);
2288   if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2289     stw_unload_classes(full_gc);
2290   }
2291 }
2292 
2293 void ShenandoahHeap::set_has_forwarded_objects(bool cond) {
2294   set_gc_state_mask(HAS_FORWARDED, cond);
2295 }
2296 
2297 void ShenandoahHeap::set_process_references(bool pr) {
2298   _process_references.set_cond(pr);
2299 }
2300 
2301 void ShenandoahHeap::set_unload_classes(bool uc) {
2302   _unload_classes.set_cond(uc);
2303 }
2304 
2305 bool ShenandoahHeap::process_references() const {
2306   return _process_references.is_set();
2307 }
2308 
2309 bool ShenandoahHeap::unload_classes() const {
2310   return _unload_classes.is_set();
2311 }
2312 
2313 address ShenandoahHeap::in_cset_fast_test_addr() {
2314   ShenandoahHeap* heap = ShenandoahHeap::heap();
2315   assert(heap-&gt;collection_set() != NULL, &quot;Sanity&quot;);
2316   return (address) heap-&gt;collection_set()-&gt;biased_map_address();
2317 }
2318 
2319 address ShenandoahHeap::cancelled_gc_addr() {
2320   return (address) ShenandoahHeap::heap()-&gt;_cancelled_gc.addr_of();
2321 }
2322 
2323 address ShenandoahHeap::gc_state_addr() {
2324   return (address) ShenandoahHeap::heap()-&gt;_gc_state.addr_of();
2325 }
2326 
2327 size_t ShenandoahHeap::bytes_allocated_since_gc_start() {
2328   return Atomic::load_acquire(&amp;_bytes_allocated_since_gc_start);
2329 }
2330 
2331 void ShenandoahHeap::reset_bytes_allocated_since_gc_start() {
2332   Atomic::release_store_fence(&amp;_bytes_allocated_since_gc_start, (size_t)0);
2333 }
2334 
2335 void ShenandoahHeap::set_degenerated_gc_in_progress(bool in_progress) {
2336   _degenerated_gc_in_progress.set_cond(in_progress);
2337 }
2338 
2339 void ShenandoahHeap::set_full_gc_in_progress(bool in_progress) {
2340   _full_gc_in_progress.set_cond(in_progress);
2341 }
2342 
2343 void ShenandoahHeap::set_full_gc_move_in_progress(bool in_progress) {
2344   assert (is_full_gc_in_progress(), &quot;should be&quot;);
2345   _full_gc_move_in_progress.set_cond(in_progress);
2346 }
2347 
2348 void ShenandoahHeap::set_update_refs_in_progress(bool in_progress) {
2349   set_gc_state_mask(UPDATEREFS, in_progress);
2350 }
2351 
2352 void ShenandoahHeap::register_nmethod(nmethod* nm) {
2353   ShenandoahCodeRoots::register_nmethod(nm);
2354 }
2355 
2356 void ShenandoahHeap::unregister_nmethod(nmethod* nm) {
2357   ShenandoahCodeRoots::unregister_nmethod(nm);
2358 }
2359 
2360 void ShenandoahHeap::flush_nmethod(nmethod* nm) {
2361   ShenandoahCodeRoots::flush_nmethod(nm);
2362 }
2363 
2364 oop ShenandoahHeap::pin_object(JavaThread* thr, oop o) {
2365   heap_region_containing(o)-&gt;record_pin();
2366   return o;
2367 }
2368 
2369 void ShenandoahHeap::unpin_object(JavaThread* thr, oop o) {
2370   heap_region_containing(o)-&gt;record_unpin();
2371 }
2372 
2373 void ShenandoahHeap::sync_pinned_region_status() {
2374   ShenandoahHeapLocker locker(lock());
2375 
2376   for (size_t i = 0; i &lt; num_regions(); i++) {
2377     ShenandoahHeapRegion *r = get_region(i);
2378     if (r-&gt;is_active()) {
2379       if (r-&gt;is_pinned()) {
2380         if (r-&gt;pin_count() == 0) {
2381           r-&gt;make_unpinned();
2382         }
2383       } else {
2384         if (r-&gt;pin_count() &gt; 0) {
2385           r-&gt;make_pinned();
2386         }
2387       }
2388     }
2389   }
2390 
2391   assert_pinned_region_status();
2392 }
2393 
2394 #ifdef ASSERT
2395 void ShenandoahHeap::assert_pinned_region_status() {
2396   for (size_t i = 0; i &lt; num_regions(); i++) {
2397     ShenandoahHeapRegion* r = get_region(i);
2398     assert((r-&gt;is_pinned() &amp;&amp; r-&gt;pin_count() &gt; 0) || (!r-&gt;is_pinned() &amp;&amp; r-&gt;pin_count() == 0),
2399            &quot;Region &quot; SIZE_FORMAT &quot; pinning status is inconsistent&quot;, i);
2400   }
2401 }
2402 #endif
2403 
2404 ConcurrentGCTimer* ShenandoahHeap::gc_timer() const {
2405   return _gc_timer;
2406 }
2407 
2408 void ShenandoahHeap::prepare_concurrent_roots() {
2409   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2410   if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {
2411     set_concurrent_strong_root_in_progress(!collection_set()-&gt;is_empty());
2412     set_concurrent_weak_root_in_progress(true);
2413   }
2414 }
2415 
2416 void ShenandoahHeap::prepare_concurrent_unloading() {
2417   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2418   if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2419     _unloader.prepare();
2420   }
2421 }
2422 
2423 void ShenandoahHeap::finish_concurrent_unloading() {
2424   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2425   if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2426     _unloader.finish();
2427   }
2428 }
2429 
2430 #ifdef ASSERT
2431 void ShenandoahHeap::assert_gc_workers(uint nworkers) {
2432   assert(nworkers &gt; 0 &amp;&amp; nworkers &lt;= max_workers(), &quot;Sanity&quot;);
2433 
2434   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
2435     if (UseDynamicNumberOfGCThreads) {
2436       assert(nworkers &lt;= ParallelGCThreads, &quot;Cannot use more than it has&quot;);
2437     } else {
2438       // Use ParallelGCThreads inside safepoints
2439       assert(nworkers == ParallelGCThreads, &quot;Use ParallelGCThreads within safepoints&quot;);
2440     }
2441   } else {
2442     if (UseDynamicNumberOfGCThreads) {
2443       assert(nworkers &lt;= ConcGCThreads, &quot;Cannot use more than it has&quot;);
2444     } else {
2445       // Use ConcGCThreads outside safepoints
2446       assert(nworkers == ConcGCThreads, &quot;Use ConcGCThreads outside safepoints&quot;);
2447     }
2448   }
2449 }
2450 #endif
2451 
2452 ShenandoahVerifier* ShenandoahHeap::verifier() {
2453   guarantee(ShenandoahVerify, &quot;Should be enabled&quot;);
2454   assert (_verifier != NULL, &quot;sanity&quot;);
2455   return _verifier;
2456 }
2457 
2458 template&lt;class T&gt;
2459 class ShenandoahUpdateHeapRefsTask : public AbstractGangTask {
2460 private:
2461   T cl;
2462   ShenandoahHeap* _heap;
2463   ShenandoahRegionIterator* _regions;
2464   bool _concurrent;
2465 public:
2466   ShenandoahUpdateHeapRefsTask(ShenandoahRegionIterator* regions, bool concurrent) :
2467     AbstractGangTask(&quot;Concurrent Update References Task&quot;),
2468     cl(T()),
2469     _heap(ShenandoahHeap::heap()),
2470     _regions(regions),
2471     _concurrent(concurrent) {
2472   }
2473 
2474   void work(uint worker_id) {
2475     if (_concurrent) {
2476       ShenandoahConcurrentWorkerSession worker_session(worker_id);
2477       ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
2478       do_work();
2479     } else {
2480       ShenandoahParallelWorkerSession worker_session(worker_id);
2481       do_work();
2482     }
2483   }
2484 
2485 private:
2486   void do_work() {
2487     ShenandoahHeapRegion* r = _regions-&gt;next();
2488     ShenandoahMarkingContext* const ctx = _heap-&gt;complete_marking_context();
2489     while (r != NULL) {
2490       HeapWord* update_watermark = r-&gt;get_update_watermark();
2491       assert (update_watermark &gt;= r-&gt;bottom(), &quot;sanity&quot;);
2492       if (r-&gt;is_active() &amp;&amp; !r-&gt;is_cset()) {
2493         _heap-&gt;marked_object_oop_iterate(r, &amp;cl, update_watermark);
2494       }
2495       if (ShenandoahPacing) {
2496         _heap-&gt;pacer()-&gt;report_updaterefs(pointer_delta(update_watermark, r-&gt;bottom()));
2497       }
2498       if (_heap-&gt;check_cancelled_gc_and_yield(_concurrent)) {
2499         return;
2500       }
2501       r = _regions-&gt;next();
2502     }
2503   }
2504 };
2505 
2506 void ShenandoahHeap::update_heap_references(bool concurrent) {
2507   ShenandoahUpdateHeapRefsTask&lt;ShenandoahUpdateHeapRefsClosure&gt; task(&amp;_update_refs_iterator, concurrent);
2508   workers()-&gt;run_task(&amp;task);
2509 }
2510 
2511 void ShenandoahHeap::op_init_updaterefs() {
2512   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2513 
2514   set_evacuation_in_progress(false);
2515 
2516   {
2517     ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_retire_gclabs);
2518     retire_and_reset_gclabs();
2519   }
2520 
2521   if (ShenandoahVerify) {
2522     if (!is_degenerated_gc_in_progress()) {
2523       verifier()-&gt;verify_roots_in_to_space_except(ShenandoahRootVerifier::ThreadRoots);
2524     }
2525     verifier()-&gt;verify_before_updaterefs();
2526   }
2527 
2528   set_update_refs_in_progress(true);
2529 
2530   _update_refs_iterator.reset();
2531 
2532   if (ShenandoahPacing) {
2533     pacer()-&gt;setup_for_updaterefs();
2534   }
2535 }
2536 
2537 class ShenandoahFinalUpdateRefsUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {
2538 private:
2539   ShenandoahHeapLock* const _lock;
2540 
2541 public:
2542   ShenandoahFinalUpdateRefsUpdateRegionStateClosure() : _lock(ShenandoahHeap::heap()-&gt;lock()) {}
2543 
2544   void heap_region_do(ShenandoahHeapRegion* r) {
2545     // Drop unnecessary &quot;pinned&quot; state from regions that does not have CP marks
2546     // anymore, as this would allow trashing them.
2547 
2548     if (r-&gt;is_active()) {
2549       if (r-&gt;is_pinned()) {
2550         if (r-&gt;pin_count() == 0) {
2551           ShenandoahHeapLocker locker(_lock);
2552           r-&gt;make_unpinned();
2553         }
2554       } else {
2555         if (r-&gt;pin_count() &gt; 0) {
2556           ShenandoahHeapLocker locker(_lock);
2557           r-&gt;make_pinned();
2558         }
2559       }
2560     }
2561   }
2562 
2563   bool is_thread_safe() { return true; }
2564 };
2565 
2566 void ShenandoahHeap::op_final_updaterefs() {
2567   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2568 
2569   finish_concurrent_unloading();
2570 
2571   // Check if there is left-over work, and finish it
2572   if (_update_refs_iterator.has_next()) {
2573     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_finish_work);
2574 
2575     // Finish updating references where we left off.
2576     clear_cancelled_gc();
2577     update_heap_references(false);
2578   }
2579 
2580   // Clear cancelled GC, if set. On cancellation path, the block before would handle
2581   // everything. On degenerated paths, cancelled gc would not be set anyway.
2582   if (cancelled_gc()) {
2583     clear_cancelled_gc();
2584   }
2585   assert(!cancelled_gc(), &quot;Should have been done right before&quot;);
2586 
2587   if (ShenandoahVerify &amp;&amp; !is_degenerated_gc_in_progress()) {
2588     verifier()-&gt;verify_roots_in_to_space_except(ShenandoahRootVerifier::ThreadRoots);
2589   }
2590 
2591   if (is_degenerated_gc_in_progress()) {
2592     concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::degen_gc_update_roots);
2593   } else {
2594     concurrent_mark()-&gt;update_thread_roots(ShenandoahPhaseTimings::final_update_refs_roots);
2595   }
2596 
2597   // Has to be done before cset is clear
2598   if (ShenandoahVerify) {
2599     verifier()-&gt;verify_roots_in_to_space();
2600   }
2601 
2602   {
2603     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_update_region_states);
2604     ShenandoahFinalUpdateRefsUpdateRegionStateClosure cl;
2605     parallel_heap_region_iterate(&amp;cl);
2606 
2607     assert_pinned_region_status();
2608   }
2609 
2610   {
2611     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_trash_cset);
2612     trash_cset_regions();
2613   }
2614 
2615   set_has_forwarded_objects(false);
2616   set_update_refs_in_progress(false);
2617 
2618   if (ShenandoahVerify) {
2619     verifier()-&gt;verify_after_updaterefs();
2620   }
2621 
2622   if (VerifyAfterGC) {
2623     Universe::verify();
2624   }
2625 
2626   {
2627     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_rebuild_freeset);
2628     ShenandoahHeapLocker locker(lock());
2629     _free_set-&gt;rebuild();
2630   }
2631 }
2632 
2633 void ShenandoahHeap::print_extended_on(outputStream *st) const {
2634   print_on(st);
2635   print_heap_regions_on(st);
2636 }
2637 
2638 bool ShenandoahHeap::is_bitmap_slice_committed(ShenandoahHeapRegion* r, bool skip_self) {
2639   size_t slice = r-&gt;index() / _bitmap_regions_per_slice;
2640 
2641   size_t regions_from = _bitmap_regions_per_slice * slice;
2642   size_t regions_to   = MIN2(num_regions(), _bitmap_regions_per_slice * (slice + 1));
2643   for (size_t g = regions_from; g &lt; regions_to; g++) {
2644     assert (g / _bitmap_regions_per_slice == slice, &quot;same slice&quot;);
2645     if (skip_self &amp;&amp; g == r-&gt;index()) continue;
2646     if (get_region(g)-&gt;is_committed()) {
2647       return true;
2648     }
2649   }
2650   return false;
2651 }
2652 
2653 bool ShenandoahHeap::commit_bitmap_slice(ShenandoahHeapRegion* r) {
2654   shenandoah_assert_heaplocked();
2655 
2656   // Bitmaps in special regions do not need commits
2657   if (_bitmap_region_special) {
2658     return true;
2659   }
2660 
2661   if (is_bitmap_slice_committed(r, true)) {
2662     // Some other region from the group is already committed, meaning the bitmap
2663     // slice is already committed, we exit right away.
2664     return true;
2665   }
2666 
2667   // Commit the bitmap slice:
2668   size_t slice = r-&gt;index() / _bitmap_regions_per_slice;
2669   size_t off = _bitmap_bytes_per_slice * slice;
2670   size_t len = _bitmap_bytes_per_slice;
2671   char* start = (char*) _bitmap_region.start() + off;
2672 
2673   if (!os::commit_memory(start, len, false)) {
2674     return false;
2675   }
2676 
2677   if (AlwaysPreTouch) {
2678     os::pretouch_memory(start, start + len, _pretouch_bitmap_page_size);
2679   }
2680 
2681   return true;
2682 }
2683 
2684 bool ShenandoahHeap::uncommit_bitmap_slice(ShenandoahHeapRegion *r) {
2685   shenandoah_assert_heaplocked();
2686 
2687   // Bitmaps in special regions do not need uncommits
2688   if (_bitmap_region_special) {
2689     return true;
2690   }
2691 
2692   if (is_bitmap_slice_committed(r, true)) {
2693     // Some other region from the group is still committed, meaning the bitmap
2694     // slice is should stay committed, exit right away.
2695     return true;
2696   }
2697 
2698   // Uncommit the bitmap slice:
2699   size_t slice = r-&gt;index() / _bitmap_regions_per_slice;
2700   size_t off = _bitmap_bytes_per_slice * slice;
2701   size_t len = _bitmap_bytes_per_slice;
2702   if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len)) {
2703     return false;
2704   }
2705   return true;
2706 }
2707 
2708 void ShenandoahHeap::safepoint_synchronize_begin() {
2709   if (ShenandoahSuspendibleWorkers || UseStringDeduplication) {
2710     SuspendibleThreadSet::synchronize();
2711   }
2712 }
2713 
2714 void ShenandoahHeap::safepoint_synchronize_end() {
2715   if (ShenandoahSuspendibleWorkers || UseStringDeduplication) {
2716     SuspendibleThreadSet::desynchronize();
2717   }
2718 }
2719 
2720 void ShenandoahHeap::vmop_entry_init_mark() {
2721   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2722   ShenandoahTimingsTracker timing(ShenandoahPhaseTimings::init_mark_gross);
2723 
2724   try_inject_alloc_failure();
2725   VM_ShenandoahInitMark op;
2726   VMThread::execute(&amp;op); // jump to entry_init_mark() under safepoint
2727 }
2728 
2729 void ShenandoahHeap::vmop_entry_final_mark() {
2730   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2731   ShenandoahTimingsTracker timing(ShenandoahPhaseTimings::final_mark_gross);
2732 
2733   try_inject_alloc_failure();
2734   VM_ShenandoahFinalMarkStartEvac op;
2735   VMThread::execute(&amp;op); // jump to entry_final_mark under safepoint
2736 }
2737 
2738 void ShenandoahHeap::vmop_entry_init_updaterefs() {
2739   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2740   ShenandoahTimingsTracker timing(ShenandoahPhaseTimings::init_update_refs_gross);
2741 
2742   try_inject_alloc_failure();
2743   VM_ShenandoahInitUpdateRefs op;
2744   VMThread::execute(&amp;op);
2745 }
2746 
2747 void ShenandoahHeap::vmop_entry_final_updaterefs() {
2748   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2749   ShenandoahTimingsTracker timing(ShenandoahPhaseTimings::final_update_refs_gross);
2750 
2751   try_inject_alloc_failure();
2752   VM_ShenandoahFinalUpdateRefs op;
2753   VMThread::execute(&amp;op);
2754 }
2755 
2756 void ShenandoahHeap::vmop_entry_full(GCCause::Cause cause) {
2757   TraceCollectorStats tcs(monitoring_support()-&gt;full_stw_collection_counters());
2758   ShenandoahTimingsTracker timing(ShenandoahPhaseTimings::full_gc_gross);
2759 
2760   try_inject_alloc_failure();
2761   VM_ShenandoahFullGC op(cause);
2762   VMThread::execute(&amp;op);
2763 }
2764 
2765 void ShenandoahHeap::vmop_degenerated(ShenandoahDegenPoint point) {
2766   TraceCollectorStats tcs(monitoring_support()-&gt;full_stw_collection_counters());
2767   ShenandoahTimingsTracker timing(ShenandoahPhaseTimings::degen_gc_gross);
2768 
2769   VM_ShenandoahDegeneratedGC degenerated_gc((int)point);
2770   VMThread::execute(&amp;degenerated_gc);
2771 }
2772 
2773 void ShenandoahHeap::entry_init_mark() {
2774   const char* msg = init_mark_event_message();
2775   ShenandoahPausePhase gc_phase(msg, ShenandoahPhaseTimings::init_mark);
2776   EventMark em(&quot;%s&quot;, msg);
2777 
2778   ShenandoahWorkerScope scope(workers(),
2779                               ShenandoahWorkerPolicy::calc_workers_for_init_marking(),
2780                               &quot;init marking&quot;);
2781 
2782   op_init_mark();
2783 }
2784 
2785 void ShenandoahHeap::entry_final_mark() {
2786   const char* msg = final_mark_event_message();
2787   ShenandoahPausePhase gc_phase(msg, ShenandoahPhaseTimings::final_mark);
2788   EventMark em(&quot;%s&quot;, msg);
2789 
2790   ShenandoahWorkerScope scope(workers(),
2791                               ShenandoahWorkerPolicy::calc_workers_for_final_marking(),
2792                               &quot;final marking&quot;);
2793 
2794   op_final_mark();
2795 }
2796 
2797 void ShenandoahHeap::entry_init_updaterefs() {
2798   static const char* msg = &quot;Pause Init Update Refs&quot;;
2799   ShenandoahPausePhase gc_phase(msg, ShenandoahPhaseTimings::init_update_refs);
2800   EventMark em(&quot;%s&quot;, msg);
2801 
2802   // No workers used in this phase, no setup required
2803 
2804   op_init_updaterefs();
2805 }
2806 
2807 void ShenandoahHeap::entry_final_updaterefs() {
2808   static const char* msg = &quot;Pause Final Update Refs&quot;;
2809   ShenandoahPausePhase gc_phase(msg, ShenandoahPhaseTimings::final_update_refs);
2810   EventMark em(&quot;%s&quot;, msg);
2811 
2812   ShenandoahWorkerScope scope(workers(),
2813                               ShenandoahWorkerPolicy::calc_workers_for_final_update_ref(),
2814                               &quot;final reference update&quot;);
2815 
2816   op_final_updaterefs();
2817 }
2818 
2819 void ShenandoahHeap::entry_full(GCCause::Cause cause) {
2820   static const char* msg = &quot;Pause Full&quot;;
2821   ShenandoahPausePhase gc_phase(msg, ShenandoahPhaseTimings::full_gc, true /* log_heap_usage */);
2822   EventMark em(&quot;%s&quot;, msg);
2823 
2824   ShenandoahWorkerScope scope(workers(),
2825                               ShenandoahWorkerPolicy::calc_workers_for_fullgc(),
2826                               &quot;full gc&quot;);
2827 
2828   op_full(cause);
2829 }
2830 
2831 void ShenandoahHeap::entry_degenerated(int point) {
2832   ShenandoahDegenPoint dpoint = (ShenandoahDegenPoint)point;
2833   const char* msg = degen_event_message(dpoint);
2834   ShenandoahPausePhase gc_phase(msg, ShenandoahPhaseTimings::degen_gc, true /* log_heap_usage */);
2835   EventMark em(&quot;%s&quot;, msg);
2836 
2837   ShenandoahWorkerScope scope(workers(),
2838                               ShenandoahWorkerPolicy::calc_workers_for_stw_degenerated(),
2839                               &quot;stw degenerated gc&quot;);
2840 
2841   set_degenerated_gc_in_progress(true);
2842   op_degenerated(dpoint);
2843   set_degenerated_gc_in_progress(false);
2844 }
2845 
2846 void ShenandoahHeap::entry_mark() {
2847   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
2848 
2849   const char* msg = conc_mark_event_message();
2850   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_mark);
2851   EventMark em(&quot;%s&quot;, msg);
2852 
2853   ShenandoahWorkerScope scope(workers(),
2854                               ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),
2855                               &quot;concurrent marking&quot;);
2856 
2857   try_inject_alloc_failure();
2858   op_mark();
2859 }
2860 
2861 void ShenandoahHeap::entry_evac() {
2862   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
2863 
2864   static const char* msg = &quot;Concurrent evacuation&quot;;
2865   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_evac);
2866   EventMark em(&quot;%s&quot;, msg);
2867 
2868   ShenandoahWorkerScope scope(workers(),
2869                               ShenandoahWorkerPolicy::calc_workers_for_conc_evac(),
2870                               &quot;concurrent evacuation&quot;);
2871 
2872   try_inject_alloc_failure();
2873   op_conc_evac();
2874 }
2875 
2876 void ShenandoahHeap::entry_updaterefs() {
2877   static const char* msg = &quot;Concurrent update references&quot;;
2878   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_update_refs);
2879   EventMark em(&quot;%s&quot;, msg);
2880 
2881   ShenandoahWorkerScope scope(workers(),
2882                               ShenandoahWorkerPolicy::calc_workers_for_conc_update_ref(),
2883                               &quot;concurrent reference update&quot;);
2884 
2885   try_inject_alloc_failure();
2886   op_updaterefs();
2887 }
2888 
2889 void ShenandoahHeap::entry_weak_roots() {
2890   static const char* msg = &quot;Concurrent weak roots&quot;;
2891   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_weak_roots);
2892   EventMark em(&quot;%s&quot;, msg);
2893 
2894   ShenandoahWorkerScope scope(workers(),
2895                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2896                               &quot;concurrent weak root&quot;);
2897 
2898   try_inject_alloc_failure();
2899   op_weak_roots();
2900 }
2901 
2902 void ShenandoahHeap::entry_class_unloading() {
2903   static const char* msg = &quot;Concurrent class unloading&quot;;
2904   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_class_unload);
2905   EventMark em(&quot;%s&quot;, msg);
2906 
2907   ShenandoahWorkerScope scope(workers(),
2908                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2909                               &quot;concurrent class unloading&quot;);
2910 
2911   try_inject_alloc_failure();
2912   op_class_unloading();
2913 }
2914 
2915 void ShenandoahHeap::entry_strong_roots() {
2916   static const char* msg = &quot;Concurrent strong roots&quot;;
2917   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_strong_roots);
2918   EventMark em(&quot;%s&quot;, msg);
2919 
2920   ShenandoahGCWorkerPhase worker_phase(ShenandoahPhaseTimings::conc_strong_roots);
2921 
2922   ShenandoahWorkerScope scope(workers(),
2923                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2924                               &quot;concurrent strong root&quot;);
2925 
2926   try_inject_alloc_failure();
2927   op_strong_roots();
2928 }
2929 
2930 void ShenandoahHeap::entry_cleanup_early() {
2931   static const char* msg = &quot;Concurrent cleanup&quot;;
2932   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_cleanup_early, true /* log_heap_usage */);
2933   EventMark em(&quot;%s&quot;, msg);
2934 
2935   // This phase does not use workers, no need for setup
2936 
2937   try_inject_alloc_failure();
2938   op_cleanup_early();
2939 }
2940 
2941 void ShenandoahHeap::entry_cleanup_complete() {
2942   static const char* msg = &quot;Concurrent cleanup&quot;;
2943   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_cleanup_complete, true /* log_heap_usage */);
2944   EventMark em(&quot;%s&quot;, msg);
2945 
2946   // This phase does not use workers, no need for setup
2947 
2948   try_inject_alloc_failure();
2949   op_cleanup_complete();
2950 }
2951 
2952 void ShenandoahHeap::entry_reset() {
2953   static const char* msg = &quot;Concurrent reset&quot;;
2954   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_reset);
2955   EventMark em(&quot;%s&quot;, msg);
2956 
2957   ShenandoahWorkerScope scope(workers(),
2958                               ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),
2959                               &quot;concurrent reset&quot;);
2960 
2961   try_inject_alloc_failure();
2962   op_reset();
2963 }
2964 
2965 void ShenandoahHeap::entry_preclean() {
2966   if (ShenandoahPreclean &amp;&amp; process_references()) {
2967     static const char* msg = &quot;Concurrent precleaning&quot;;
2968     ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_preclean);
2969     EventMark em(&quot;%s&quot;, msg);
2970 
2971     ShenandoahWorkerScope scope(workers(),
2972                                 ShenandoahWorkerPolicy::calc_workers_for_conc_preclean(),
2973                                 &quot;concurrent preclean&quot;,
2974                                 /* check_workers = */ false);
2975 
2976     try_inject_alloc_failure();
2977     op_preclean();
2978   }
2979 }
2980 
2981 void ShenandoahHeap::entry_uncommit(double shrink_before) {
2982   static const char *msg = &quot;Concurrent uncommit&quot;;
2983   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_uncommit, true /* log_heap_usage */);
2984   EventMark em(&quot;%s&quot;, msg);
2985 
2986   op_uncommit(shrink_before);
2987 }
2988 
2989 void ShenandoahHeap::try_inject_alloc_failure() {
2990   if (ShenandoahAllocFailureALot &amp;&amp; !cancelled_gc() &amp;&amp; ((os::random() % 1000) &gt; 950)) {
2991     _inject_alloc_failure.set();
2992     os::naked_short_sleep(1);
2993     if (cancelled_gc()) {
2994       log_info(gc)(&quot;Allocation failure was successfully injected&quot;);
2995     }
2996   }
2997 }
2998 
2999 bool ShenandoahHeap::should_inject_alloc_failure() {
3000   return _inject_alloc_failure.is_set() &amp;&amp; _inject_alloc_failure.try_unset();
3001 }
3002 
3003 void ShenandoahHeap::initialize_serviceability() {
3004   _memory_pool = new ShenandoahMemoryPool(this);
3005   _cycle_memory_manager.add_pool(_memory_pool);
3006   _stw_memory_manager.add_pool(_memory_pool);
3007 }
3008 
3009 GrowableArray&lt;GCMemoryManager*&gt; ShenandoahHeap::memory_managers() {
3010   GrowableArray&lt;GCMemoryManager*&gt; memory_managers(2);
3011   memory_managers.append(&amp;_cycle_memory_manager);
3012   memory_managers.append(&amp;_stw_memory_manager);
3013   return memory_managers;
3014 }
3015 
3016 GrowableArray&lt;MemoryPool*&gt; ShenandoahHeap::memory_pools() {
3017   GrowableArray&lt;MemoryPool*&gt; memory_pools(1);
3018   memory_pools.append(_memory_pool);
3019   return memory_pools;
3020 }
3021 
3022 MemoryUsage ShenandoahHeap::memory_usage() {
3023   return _memory_pool-&gt;get_memory_usage();
3024 }
3025 
3026 ShenandoahRegionIterator::ShenandoahRegionIterator() :
3027   _heap(ShenandoahHeap::heap()),
3028   _index(0) {}
3029 
3030 ShenandoahRegionIterator::ShenandoahRegionIterator(ShenandoahHeap* heap) :
3031   _heap(heap),
3032   _index(0) {}
3033 
3034 void ShenandoahRegionIterator::reset() {
3035   _index = 0;
3036 }
3037 
3038 bool ShenandoahRegionIterator::has_next() const {
3039   return _index &lt; _heap-&gt;num_regions();
3040 }
3041 
3042 char ShenandoahHeap::gc_state() const {
3043   return _gc_state.raw_value();
3044 }
3045 
3046 void ShenandoahHeap::deduplicate_string(oop str) {
3047   assert(java_lang_String::is_instance(str), &quot;invariant&quot;);
3048 
3049   if (ShenandoahStringDedup::is_enabled()) {
3050     ShenandoahStringDedup::deduplicate(str);
3051   }
3052 }
3053 
3054 const char* ShenandoahHeap::init_mark_event_message() const {
3055   assert(!has_forwarded_objects(), &quot;Should not have forwarded objects here&quot;);
3056 
3057   bool proc_refs = process_references();
3058   bool unload_cls = unload_classes();
3059 
3060   if (proc_refs &amp;&amp; unload_cls) {
3061     return &quot;Pause Init Mark (process weakrefs) (unload classes)&quot;;
3062   } else if (proc_refs) {
3063     return &quot;Pause Init Mark (process weakrefs)&quot;;
3064   } else if (unload_cls) {
3065     return &quot;Pause Init Mark (unload classes)&quot;;
3066   } else {
3067     return &quot;Pause Init Mark&quot;;
3068   }
3069 }
3070 
3071 const char* ShenandoahHeap::final_mark_event_message() const {
3072   assert(!has_forwarded_objects(), &quot;Should not have forwarded objects here&quot;);
3073 
3074   bool proc_refs = process_references();
3075   bool unload_cls = unload_classes();
3076 
3077   if (proc_refs &amp;&amp; unload_cls) {
3078     return &quot;Pause Final Mark (process weakrefs) (unload classes)&quot;;
3079   } else if (proc_refs) {
3080     return &quot;Pause Final Mark (process weakrefs)&quot;;
3081   } else if (unload_cls) {
3082     return &quot;Pause Final Mark (unload classes)&quot;;
3083   } else {
3084     return &quot;Pause Final Mark&quot;;
3085   }
3086 }
3087 
3088 const char* ShenandoahHeap::conc_mark_event_message() const {
3089   assert(!has_forwarded_objects(), &quot;Should not have forwarded objects here&quot;);
3090 
3091   bool proc_refs = process_references();
3092   bool unload_cls = unload_classes();
3093 
3094   if (proc_refs &amp;&amp; unload_cls) {
3095     return &quot;Concurrent marking (process weakrefs) (unload classes)&quot;;
3096   } else if (proc_refs) {
3097     return &quot;Concurrent marking (process weakrefs)&quot;;
3098   } else if (unload_cls) {
3099     return &quot;Concurrent marking (unload classes)&quot;;
3100   } else {
3101     return &quot;Concurrent marking&quot;;
3102   }
3103 }
3104 
3105 const char* ShenandoahHeap::degen_event_message(ShenandoahDegenPoint point) const {
3106   switch (point) {
3107     case _degenerated_unset:
3108       return &quot;Pause Degenerated GC (&lt;UNSET&gt;)&quot;;
3109     case _degenerated_outside_cycle:
3110       return &quot;Pause Degenerated GC (Outside of Cycle)&quot;;
3111     case _degenerated_mark:
3112       return &quot;Pause Degenerated GC (Mark)&quot;;
3113     case _degenerated_evac:
3114       return &quot;Pause Degenerated GC (Evacuation)&quot;;
3115     case _degenerated_updaterefs:
3116       return &quot;Pause Degenerated GC (Update Refs)&quot;;
3117     default:
3118       ShouldNotReachHere();
3119       return &quot;ERROR&quot;;
3120   }
3121 }
3122 
3123 ShenandoahLiveData* ShenandoahHeap::get_liveness_cache(uint worker_id) {
3124 #ifdef ASSERT
3125   assert(_liveness_cache != NULL, &quot;sanity&quot;);
3126   assert(worker_id &lt; _max_workers, &quot;sanity&quot;);
3127   for (uint i = 0; i &lt; num_regions(); i++) {
3128     assert(_liveness_cache[worker_id][i] == 0, &quot;liveness cache should be empty&quot;);
3129   }
3130 #endif
3131   return _liveness_cache[worker_id];
3132 }
3133 
3134 void ShenandoahHeap::flush_liveness_cache(uint worker_id) {
3135   assert(worker_id &lt; _max_workers, &quot;sanity&quot;);
3136   assert(_liveness_cache != NULL, &quot;sanity&quot;);
3137   ShenandoahLiveData* ld = _liveness_cache[worker_id];
3138   for (uint i = 0; i &lt; num_regions(); i++) {
3139     ShenandoahLiveData live = ld[i];
3140     if (live &gt; 0) {
3141       ShenandoahHeapRegion* r = get_region(i);
3142       r-&gt;increase_live_data_gc_words(live);
3143       ld[i] = 0;
3144     }
3145   }
3146 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
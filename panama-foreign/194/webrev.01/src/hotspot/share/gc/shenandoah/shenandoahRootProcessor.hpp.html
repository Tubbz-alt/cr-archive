<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2020, Red Hat, Inc. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHROOTPROCESSOR_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHROOTPROCESSOR_HPP
 27 
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;gc/shared/oopStorageParState.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahSharedVariables.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 35 #include &quot;memory/iterator.hpp&quot;
 36 
 37 class ShenandoahSerialRoot {
 38 public:
 39   typedef void (*OopsDo)(OopClosure*);
 40 private:
 41   ShenandoahSharedFlag                   _claimed;
 42   const OopsDo                           _oops_do;
 43   const ShenandoahPhaseTimings::Phase    _phase;
 44   const ShenandoahPhaseTimings::ParPhase _par_phase;
 45 
 46 public:
 47   ShenandoahSerialRoot(OopsDo oops_do,
 48           ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase);
 49   void oops_do(OopClosure* cl, uint worker_id);
 50 };
 51 
 52 class ShenandoahSerialRoots {
 53 private:
 54   ShenandoahSerialRoot  _universe_root;
 55   ShenandoahSerialRoot  _object_synchronizer_root;
 56   ShenandoahSerialRoot  _management_root;
 57   ShenandoahSerialRoot  _system_dictionary_root;
 58   ShenandoahSerialRoot  _jvmti_root;
 59 public:
 60   ShenandoahSerialRoots(ShenandoahPhaseTimings::Phase phase);
 61   void oops_do(OopClosure* cl, uint worker_id);
 62 };
 63 
 64 class ShenandoahWeakSerialRoot {
 65   typedef void (*WeakOopsDo)(BoolObjectClosure*, OopClosure*);
 66 private:
 67   ShenandoahSharedFlag                   _claimed;
 68   const WeakOopsDo                       _weak_oops_do;
 69   const ShenandoahPhaseTimings::Phase    _phase;
 70   const ShenandoahPhaseTimings::ParPhase _par_phase;
 71 
 72 public:
 73   ShenandoahWeakSerialRoot(WeakOopsDo oops_do,
 74           ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase);
 75   void weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id);
 76 };
 77 
 78 #if INCLUDE_JVMTI
 79 class ShenandoahJVMTIWeakRoot : public ShenandoahWeakSerialRoot {
 80 public:
 81   ShenandoahJVMTIWeakRoot(ShenandoahPhaseTimings::Phase phase);
 82 };
 83 #endif // INCLUDE_JVMTI
 84 
 85 #if INCLUDE_JFR
 86 class ShenandoahJFRWeakRoot : public ShenandoahWeakSerialRoot {
 87 public:
 88   ShenandoahJFRWeakRoot(ShenandoahPhaseTimings::Phase phase);
 89 };
 90 #endif // INCLUDE_JFR
 91 
 92 class ShenandoahSerialWeakRoots {
 93 private:
 94   JVMTI_ONLY(ShenandoahJVMTIWeakRoot _jvmti_weak_roots;)
 95   JFR_ONLY(ShenandoahJFRWeakRoot     _jfr_weak_roots;)
 96 public:
 97   ShenandoahSerialWeakRoots(ShenandoahPhaseTimings::Phase phase) :
 98   JVMTI_ONLY(_jvmti_weak_roots(phase))
 99   JFR_ONLY(JVMTI_ONLY(COMMA)_jfr_weak_roots(phase)) {};
100   void weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id);
101   void weak_oops_do(OopClosure* cl, uint worker_id);
102 };
103 
104 template &lt;bool CONCURRENT&gt;
105 class ShenandoahVMRoot {
106 private:
107   OopStorage::ParState&lt;CONCURRENT, false /* is_const */&gt; _itr;
108   const ShenandoahPhaseTimings::Phase    _phase;
109   const ShenandoahPhaseTimings::ParPhase _par_phase;
110 public:
111   ShenandoahVMRoot(OopStorage* storage,
112           ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase);
113 
114   template &lt;typename Closure&gt;
115   void oops_do(Closure* cl, uint worker_id);
116 };
117 
118 template &lt;bool CONCURRENT&gt;
119 class ShenandoahWeakRoot : public ShenandoahVMRoot&lt;CONCURRENT&gt; {
120 public:
121   ShenandoahWeakRoot(OopStorage* storage,
122           ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase);
123 };
124 
125 template &lt;&gt;
126 class ShenandoahWeakRoot&lt;false /*concurrent*/&gt; {
127 private:
128   OopStorage::ParState&lt;false /*concurrent*/, false /*is_const*/&gt; _itr;
129   const ShenandoahPhaseTimings::Phase    _phase;
130   const ShenandoahPhaseTimings::ParPhase _par_phase;
131 
132 public:
133   ShenandoahWeakRoot(OopStorage* storage,
134           ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase);
135 
136   template &lt;typename IsAliveClosure, typename KeepAliveClosure&gt;
137   void weak_oops_do(IsAliveClosure* is_alive, KeepAliveClosure* keep_alive, uint worker_id);
138 };
139 
140 template &lt;bool CONCURRENT&gt;
141 class ShenandoahWeakRoots {
142 private:
143   ShenandoahWeakRoot&lt;CONCURRENT&gt;  _jni_roots;
144   ShenandoahWeakRoot&lt;CONCURRENT&gt;  _string_table_roots;
145   ShenandoahWeakRoot&lt;CONCURRENT&gt;  _resolved_method_table_roots;
146   ShenandoahWeakRoot&lt;CONCURRENT&gt;  _vm_roots;
147 
148 public:
149   ShenandoahWeakRoots();
150 
151   template &lt;typename Closure&gt;
152   void oops_do(Closure* cl, uint worker_id);
153 };
154 
155 template &lt;&gt;
156 class ShenandoahWeakRoots&lt;false /*concurrent */&gt; {
157 private:
158   ShenandoahWeakRoot&lt;false /*concurrent*/&gt;  _jni_roots;
159   ShenandoahWeakRoot&lt;false /*concurrent*/&gt;  _string_table_roots;
160   ShenandoahWeakRoot&lt;false /*concurrent*/&gt;  _resolved_method_table_roots;
161   ShenandoahWeakRoot&lt;false /*concurrent*/&gt;  _vm_roots;
162 public:
163   ShenandoahWeakRoots(ShenandoahPhaseTimings::Phase phase);
164 
165   template &lt;typename Closure&gt;
166   void oops_do(Closure* cl, uint worker_id);
167 
168   template &lt;typename IsAliveClosure, typename KeepAliveClosure&gt;
169   void weak_oops_do(IsAliveClosure* is_alive, KeepAliveClosure* keep_alive, uint worker_id);
170 };
171 
172 template &lt;bool CONCURRENT&gt;
173 class ShenandoahVMRoots {
174 private:
175   ShenandoahVMRoot&lt;CONCURRENT&gt;    _jni_handle_roots;
176   ShenandoahVMRoot&lt;CONCURRENT&gt;    _vm_global_roots;
177 
178 public:
179   ShenandoahVMRoots(ShenandoahPhaseTimings::Phase phase);
180 
181   template &lt;typename T&gt;
182   void oops_do(T* cl, uint worker_id);
183 };
184 
185 class ShenandoahThreadRoots {
186 private:
187   ShenandoahPhaseTimings::Phase _phase;
188   const bool _is_par;
189 public:
190   ShenandoahThreadRoots(ShenandoahPhaseTimings::Phase phase, bool is_par);
191   ~ShenandoahThreadRoots();
192 
193   void oops_do(OopClosure* oops_cl, CodeBlobClosure* code_cl, uint worker_id);
194   void threads_do(ThreadClosure* tc, uint worker_id);
195 };
196 
197 class ShenandoahStringDedupRoots {
198 private:
199   ShenandoahPhaseTimings::Phase _phase;
200 public:
201   ShenandoahStringDedupRoots(ShenandoahPhaseTimings::Phase phase);
202   ~ShenandoahStringDedupRoots();
203 
204   void oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id);
205 };
206 
207 class ShenandoahConcurrentStringDedupRoots {
208 public:
209   ShenandoahConcurrentStringDedupRoots();
210   ~ShenandoahConcurrentStringDedupRoots();
211 
212   void oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id);
213 };
214 
215 class ShenandoahCodeCacheRoots {
216 private:
217   ShenandoahPhaseTimings::Phase _phase;
218   ShenandoahCodeRootsIterator   _coderoots_iterator;
219 public:
220   ShenandoahCodeCacheRoots(ShenandoahPhaseTimings::Phase phase);
221   ~ShenandoahCodeCacheRoots();
222 
223   void code_blobs_do(CodeBlobClosure* blob_cl, uint worker_id);
224 };
225 
226 template &lt;bool CONCURRENT, bool SINGLE_THREADED&gt;
227 class ShenandoahClassLoaderDataRoots {
228 private:
229   ShenandoahSharedSemaphore     _semaphore;
230   ShenandoahPhaseTimings::Phase _phase;
231 
232   static uint worker_count(uint n_workers) {
233     // Limit concurrency a bit, otherwise it wastes resources when workers are tripping
234     // over each other. This also leaves free workers to process other parts of the root
235     // set, while admitted workers are busy with doing the CLDG walk.
236     return MAX2(1u, MIN2(ShenandoahSharedSemaphore::max_tokens(), n_workers / 2));
237   }
238 
239 public:
240   ShenandoahClassLoaderDataRoots(ShenandoahPhaseTimings::Phase phase, uint n_workers);
241   ~ShenandoahClassLoaderDataRoots();
242 
243   void always_strong_cld_do(CLDClosure* clds, uint worker_id);
244   void cld_do(CLDClosure* clds, uint worker_id);
245 };
246 
247 class ShenandoahRootProcessor : public StackObj {
248 private:
249   ShenandoahHeap* const               _heap;
250   const ShenandoahPhaseTimings::Phase _phase;
251   const ShenandoahGCWorkerPhase       _worker_phase;
252 public:
253   ShenandoahRootProcessor(ShenandoahPhaseTimings::Phase phase);
254 
255   ShenandoahHeap* heap() const { return _heap; }
256 };
257 
258 class ShenandoahRootScanner : public ShenandoahRootProcessor {
259 private:
260   ShenandoahSerialRoots                                     _serial_roots;
261   ShenandoahThreadRoots                                     _thread_roots;
262   ShenandoahStringDedupRoots                                _dedup_roots;
263 
264 public:
265   ShenandoahRootScanner(uint n_workers, ShenandoahPhaseTimings::Phase phase);
266   ~ShenandoahRootScanner();
267 
268   // Apply oops, clds and blobs to all strongly reachable roots in the system,
269   // during class unloading cycle
270   void strong_roots_do(uint worker_id, OopClosure* cl);
271   void strong_roots_do(uint worker_id, OopClosure* oops, CLDClosure* clds, CodeBlobClosure* code, ThreadClosure* tc = NULL);
272 
273   // Apply oops, clds and blobs to all strongly reachable roots and weakly reachable
274   // roots when class unloading is disabled during this cycle
275   void roots_do(uint worker_id, OopClosure* cl);
276   void roots_do(uint worker_id, OopClosure* oops, CLDClosure* clds, CodeBlobClosure* code, ThreadClosure* tc = NULL);
277 };
278 
279 template &lt;bool CONCURRENT&gt;
280 class ShenandoahConcurrentRootScanner {
281 private:
282   ShenandoahVMRoots&lt;CONCURRENT&gt;            _vm_roots;
283   ShenandoahClassLoaderDataRoots&lt;CONCURRENT, false /* single-threaded*/&gt;
284                                            _cld_roots;
285   ShenandoahNMethodTableSnapshot*          _codecache_snapshot;
286   ShenandoahPhaseTimings::Phase            _phase;
287 
288 public:
289   ShenandoahConcurrentRootScanner(uint n_workers, ShenandoahPhaseTimings::Phase phase);
290   ~ShenandoahConcurrentRootScanner();
291 
292   void oops_do(OopClosure* oops, uint worker_id);
293 };
294 
295 // This scanner is only for SH::object_iteration() and only supports single-threaded
296 // root scanning
297 class ShenandoahHeapIterationRootScanner : public ShenandoahRootProcessor {
298 private:
299   ShenandoahSerialRoots                                    _serial_roots;
300   ShenandoahThreadRoots                                    _thread_roots;
301   ShenandoahVMRoots&lt;false /*concurrent*/&gt;                  _vm_roots;
302   ShenandoahClassLoaderDataRoots&lt;false /*concurrent*/, true /*single threaded*/&gt;
303                                                            _cld_roots;
304   ShenandoahSerialWeakRoots                                _serial_weak_roots;
305   ShenandoahWeakRoots&lt;false /*concurrent*/&gt;                _weak_roots;
306   ShenandoahConcurrentStringDedupRoots                     _dedup_roots;
307   ShenandoahCodeCacheRoots                                 _code_roots;
308 
309 public:
310   ShenandoahHeapIterationRootScanner();
311 
312   void roots_do(OopClosure* cl);
313 };
314 
315 // Evacuate all roots at a safepoint
316 class ShenandoahRootEvacuator : public ShenandoahRootProcessor {
317 private:
318   ShenandoahSerialRoots                                     _serial_roots;
319   ShenandoahVMRoots&lt;false /*concurrent*/&gt;                   _vm_roots;
320   ShenandoahClassLoaderDataRoots&lt;false /*concurrent*/, false /*single threaded*/&gt;
321                                                             _cld_roots;
322   ShenandoahThreadRoots                                     _thread_roots;
323   ShenandoahSerialWeakRoots                                 _serial_weak_roots;
324   ShenandoahWeakRoots&lt;false /*concurrent*/&gt;                 _weak_roots;
325   ShenandoahStringDedupRoots                                _dedup_roots;
326   ShenandoahCodeCacheRoots                                  _code_roots;
327   bool                                                      _stw_roots_processing;
328   bool                                                      _stw_class_unloading;
329 public:
330   ShenandoahRootEvacuator(uint n_workers, ShenandoahPhaseTimings::Phase phase,
331                           bool stw_roots_processing, bool stw_class_unloading);
332 
333   void roots_do(uint worker_id, OopClosure* oops);
334 };
335 
336 // Update all roots at a safepoint
337 class ShenandoahRootUpdater : public ShenandoahRootProcessor {
338 private:
339   ShenandoahSerialRoots                                     _serial_roots;
340   ShenandoahVMRoots&lt;false /*concurrent*/&gt;                   _vm_roots;
341   ShenandoahClassLoaderDataRoots&lt;false /*concurrent*/, false /*single threaded*/&gt;
342                                                             _cld_roots;
343   ShenandoahThreadRoots                                     _thread_roots;
344   ShenandoahSerialWeakRoots                                 _serial_weak_roots;
345   ShenandoahWeakRoots&lt;false /*concurrent*/&gt;                 _weak_roots;
346   ShenandoahStringDedupRoots                                _dedup_roots;
347   ShenandoahCodeCacheRoots                                  _code_roots;
348 
349 public:
350   ShenandoahRootUpdater(uint n_workers, ShenandoahPhaseTimings::Phase phase);
351 
352   template&lt;typename IsAlive, typename KeepAlive&gt;
353   void roots_do(uint worker_id, IsAlive* is_alive, KeepAlive* keep_alive);
354 };
355 
356 // Adjuster all roots at a safepoint during full gc
357 class ShenandoahRootAdjuster : public ShenandoahRootProcessor {
358 private:
359   ShenandoahSerialRoots                                     _serial_roots;
360   ShenandoahVMRoots&lt;false /*concurrent*/&gt;                   _vm_roots;
361   ShenandoahClassLoaderDataRoots&lt;false /*concurrent*/, false /*single threaded*/&gt;
362                                                             _cld_roots;
363   ShenandoahThreadRoots                                     _thread_roots;
364   ShenandoahSerialWeakRoots                                 _serial_weak_roots;
365   ShenandoahWeakRoots&lt;false /*concurrent*/&gt;                 _weak_roots;
366   ShenandoahStringDedupRoots                                _dedup_roots;
367   ShenandoahCodeCacheRoots                                  _code_roots;
368 
369 public:
370   ShenandoahRootAdjuster(uint n_workers, ShenandoahPhaseTimings::Phase phase);
371 
372   void roots_do(uint worker_id, OopClosure* oops);
373 };
374 
375 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHROOTPROCESSOR_HPP
    </pre>
  </body>
</html>
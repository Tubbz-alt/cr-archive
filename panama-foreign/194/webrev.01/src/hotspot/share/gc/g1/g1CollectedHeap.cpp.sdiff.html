<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1CollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="c2/g1BarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../parallel/parallelScavengeHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CollectedHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2490                                        const VerifyOption vo) const {
2491   switch (vo) {
2492   case VerifyOption_G1UsePrevMarking: return is_obj_dead(obj);
2493   case VerifyOption_G1UseNextMarking: return is_obj_ill(obj);
2494   case VerifyOption_G1UseFullMarking: return is_obj_dead_full(obj);
2495   default:                            ShouldNotReachHere();
2496   }
2497   return false; // keep some compilers happy
2498 }
2499 
2500 void G1CollectedHeap::print_heap_regions() const {
2501   LogTarget(Trace, gc, heap, region) lt;
2502   if (lt.is_enabled()) {
2503     LogStream ls(lt);
2504     print_regions_on(&amp;ls);
2505   }
2506 }
2507 
2508 void G1CollectedHeap::print_on(outputStream* st) const {
2509   st-&gt;print(&quot; %-20s&quot;, &quot;garbage-first heap&quot;);
<span class="line-modified">2510   st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,</span>
<span class="line-modified">2511             capacity()/K, used_unlocked()/K);</span>
<span class="line-modified">2512   st-&gt;print(&quot; [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,</span>
<span class="line-modified">2513             p2i(_hrm-&gt;reserved().start()),</span>
<span class="line-modified">2514             p2i(_hrm-&gt;reserved().end()));</span>


2515   st-&gt;cr();
2516   st-&gt;print(&quot;  region size &quot; SIZE_FORMAT &quot;K, &quot;, HeapRegion::GrainBytes / K);
2517   uint young_regions = young_regions_count();
2518   st-&gt;print(&quot;%u young (&quot; SIZE_FORMAT &quot;K), &quot;, young_regions,
2519             (size_t) young_regions * HeapRegion::GrainBytes / K);
2520   uint survivor_regions = survivor_regions_count();
2521   st-&gt;print(&quot;%u survivors (&quot; SIZE_FORMAT &quot;K)&quot;, survivor_regions,
2522             (size_t) survivor_regions * HeapRegion::GrainBytes / K);
2523   st-&gt;cr();
2524   if (_numa-&gt;is_enabled()) {
2525     uint num_nodes = _numa-&gt;num_active_nodes();
2526     st-&gt;print(&quot;  remaining free region(s) on each NUMA node: &quot;);
2527     const int* node_ids = _numa-&gt;node_ids();
2528     for (uint node_index = 0; node_index &lt; num_nodes; node_index++) {
<span class="line-modified">2529       st-&gt;print(&quot;%d=%u &quot;, node_ids[node_index], _hrm-&gt;num_free_regions(node_index));</span>

2530     }
2531     st-&gt;cr();
2532   }
2533   MetaspaceUtils::print_on(st);
2534 }
2535 
2536 void G1CollectedHeap::print_regions_on(outputStream* st) const {




2537   st-&gt;print_cr(&quot;Heap Regions: E=young(eden), S=young(survivor), O=old, &quot;
2538                &quot;HS=humongous(starts), HC=humongous(continues), &quot;
2539                &quot;CS=collection set, F=free, &quot;
2540                &quot;OA=open archive, CA=closed archive, &quot;
2541                &quot;TAMS=top-at-mark-start (previous, next)&quot;);
2542   PrintRegionClosure blk(st);
2543   heap_region_iterate(&amp;blk);
2544 }
2545 
2546 void G1CollectedHeap::print_extended_on(outputStream* st) const {
2547   print_on(st);
2548 
2549   // Print the per-region information.
2550   print_regions_on(st);
2551 }
2552 
2553 void G1CollectedHeap::print_on_error(outputStream* st) const {
2554   this-&gt;CollectedHeap::print_on_error(st);
2555 
2556   if (_cm != NULL) {
</pre>
</td>
<td>
<hr />
<pre>
2490                                        const VerifyOption vo) const {
2491   switch (vo) {
2492   case VerifyOption_G1UsePrevMarking: return is_obj_dead(obj);
2493   case VerifyOption_G1UseNextMarking: return is_obj_ill(obj);
2494   case VerifyOption_G1UseFullMarking: return is_obj_dead_full(obj);
2495   default:                            ShouldNotReachHere();
2496   }
2497   return false; // keep some compilers happy
2498 }
2499 
2500 void G1CollectedHeap::print_heap_regions() const {
2501   LogTarget(Trace, gc, heap, region) lt;
2502   if (lt.is_enabled()) {
2503     LogStream ls(lt);
2504     print_regions_on(&amp;ls);
2505   }
2506 }
2507 
2508 void G1CollectedHeap::print_on(outputStream* st) const {
2509   st-&gt;print(&quot; %-20s&quot;, &quot;garbage-first heap&quot;);
<span class="line-modified">2510   if (_hrm != NULL) {</span>
<span class="line-modified">2511     st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,</span>
<span class="line-modified">2512               capacity()/K, used_unlocked()/K);</span>
<span class="line-modified">2513     st-&gt;print(&quot; [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,</span>
<span class="line-modified">2514               p2i(_hrm-&gt;reserved().start()),</span>
<span class="line-added">2515               p2i(_hrm-&gt;reserved().end()));</span>
<span class="line-added">2516   }</span>
2517   st-&gt;cr();
2518   st-&gt;print(&quot;  region size &quot; SIZE_FORMAT &quot;K, &quot;, HeapRegion::GrainBytes / K);
2519   uint young_regions = young_regions_count();
2520   st-&gt;print(&quot;%u young (&quot; SIZE_FORMAT &quot;K), &quot;, young_regions,
2521             (size_t) young_regions * HeapRegion::GrainBytes / K);
2522   uint survivor_regions = survivor_regions_count();
2523   st-&gt;print(&quot;%u survivors (&quot; SIZE_FORMAT &quot;K)&quot;, survivor_regions,
2524             (size_t) survivor_regions * HeapRegion::GrainBytes / K);
2525   st-&gt;cr();
2526   if (_numa-&gt;is_enabled()) {
2527     uint num_nodes = _numa-&gt;num_active_nodes();
2528     st-&gt;print(&quot;  remaining free region(s) on each NUMA node: &quot;);
2529     const int* node_ids = _numa-&gt;node_ids();
2530     for (uint node_index = 0; node_index &lt; num_nodes; node_index++) {
<span class="line-modified">2531       uint num_free_regions = (_hrm != NULL ? _hrm-&gt;num_free_regions(node_index) : 0);</span>
<span class="line-added">2532       st-&gt;print(&quot;%d=%u &quot;, node_ids[node_index], num_free_regions);</span>
2533     }
2534     st-&gt;cr();
2535   }
2536   MetaspaceUtils::print_on(st);
2537 }
2538 
2539 void G1CollectedHeap::print_regions_on(outputStream* st) const {
<span class="line-added">2540   if (_hrm == NULL) {</span>
<span class="line-added">2541     return;</span>
<span class="line-added">2542   }</span>
<span class="line-added">2543 </span>
2544   st-&gt;print_cr(&quot;Heap Regions: E=young(eden), S=young(survivor), O=old, &quot;
2545                &quot;HS=humongous(starts), HC=humongous(continues), &quot;
2546                &quot;CS=collection set, F=free, &quot;
2547                &quot;OA=open archive, CA=closed archive, &quot;
2548                &quot;TAMS=top-at-mark-start (previous, next)&quot;);
2549   PrintRegionClosure blk(st);
2550   heap_region_iterate(&amp;blk);
2551 }
2552 
2553 void G1CollectedHeap::print_extended_on(outputStream* st) const {
2554   print_on(st);
2555 
2556   // Print the per-region information.
2557   print_regions_on(st);
2558 }
2559 
2560 void G1CollectedHeap::print_on_error(outputStream* st) const {
2561   this-&gt;CollectedHeap::print_on_error(st);
2562 
2563   if (_cm != NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="c2/g1BarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../parallel/parallelScavengeHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
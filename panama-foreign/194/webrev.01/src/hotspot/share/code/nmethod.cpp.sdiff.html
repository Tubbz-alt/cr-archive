<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/nmethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="codeCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/nmethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1987   if (oops_do_try_claim_weak_done_as_strong_done(next_raw)) {
1988     // Successfully claimed &quot;weak done&quot; as &quot;strong done&quot;. Do the missing marking.
1989     p-&gt;do_remaining_strong_processing(this);
1990     return;
1991   }
1992   // Claim failed, some other thread got it.
1993 }
1994 
1995 void nmethod::oops_do_marking_prologue() {
1996   assert_at_safepoint();
1997 
1998   log_trace(gc, nmethod)(&quot;oops_do_marking_prologue&quot;);
1999   assert(_oops_do_mark_nmethods == NULL, &quot;must be empty&quot;);
2000 }
2001 
2002 void nmethod::oops_do_marking_epilogue() {
2003   assert_at_safepoint();
2004 
2005   nmethod* next = _oops_do_mark_nmethods;
2006   _oops_do_mark_nmethods = NULL;
<span class="line-modified">2007   if (next == NULL) {</span>
<span class="line-modified">2008     return;</span>













2009   }
<span class="line-removed">2010   nmethod* cur;</span>
<span class="line-removed">2011   do {</span>
<span class="line-removed">2012     cur = next;</span>
<span class="line-removed">2013     next = extract_nmethod(cur-&gt;_oops_do_mark_link);</span>
<span class="line-removed">2014     cur-&gt;_oops_do_mark_link = NULL;</span>
<span class="line-removed">2015     DEBUG_ONLY(cur-&gt;verify_oop_relocations());</span>
<span class="line-removed">2016 </span>
<span class="line-removed">2017     LogTarget(Trace, gc, nmethod) lt;</span>
<span class="line-removed">2018     if (lt.is_enabled()) {</span>
<span class="line-removed">2019       LogStream ls(lt);</span>
<span class="line-removed">2020       CompileTask::print(&amp;ls, cur, &quot;oops_do, unmark&quot;, /*short_form:*/ true);</span>
<span class="line-removed">2021     }</span>
<span class="line-removed">2022     // End if self-loop has been detected.</span>
<span class="line-removed">2023   } while (cur != next);</span>
2024   log_trace(gc, nmethod)(&quot;oops_do_marking_epilogue&quot;);
2025 }
2026 
2027 inline bool includes(void* p, void* from, void* to) {
2028   return from &lt;= p &amp;&amp; p &lt; to;
2029 }
2030 
2031 
2032 void nmethod::copy_scopes_pcs(PcDesc* pcs, int count) {
2033   assert(count &gt;= 2, &quot;must be sentinel values, at least&quot;);
2034 
2035 #ifdef ASSERT
2036   // must be sorted and unique; we do a binary search in find_pc_desc()
2037   int prev_offset = pcs[0].pc_offset();
2038   assert(prev_offset == PcDesc::lower_offset_limit,
2039          &quot;must start with a sentinel&quot;);
2040   for (int i = 1; i &lt; count; i++) {
2041     int this_offset = pcs[i].pc_offset();
2042     assert(this_offset &gt; prev_offset, &quot;offsets must be sorted&quot;);
2043     prev_offset = this_offset;
</pre>
</td>
<td>
<hr />
<pre>
1987   if (oops_do_try_claim_weak_done_as_strong_done(next_raw)) {
1988     // Successfully claimed &quot;weak done&quot; as &quot;strong done&quot;. Do the missing marking.
1989     p-&gt;do_remaining_strong_processing(this);
1990     return;
1991   }
1992   // Claim failed, some other thread got it.
1993 }
1994 
1995 void nmethod::oops_do_marking_prologue() {
1996   assert_at_safepoint();
1997 
1998   log_trace(gc, nmethod)(&quot;oops_do_marking_prologue&quot;);
1999   assert(_oops_do_mark_nmethods == NULL, &quot;must be empty&quot;);
2000 }
2001 
2002 void nmethod::oops_do_marking_epilogue() {
2003   assert_at_safepoint();
2004 
2005   nmethod* next = _oops_do_mark_nmethods;
2006   _oops_do_mark_nmethods = NULL;
<span class="line-modified">2007   if (next != NULL) {</span>
<span class="line-modified">2008     nmethod* cur;</span>
<span class="line-added">2009     do {</span>
<span class="line-added">2010       cur = next;</span>
<span class="line-added">2011       next = extract_nmethod(cur-&gt;_oops_do_mark_link);</span>
<span class="line-added">2012       cur-&gt;_oops_do_mark_link = NULL;</span>
<span class="line-added">2013       DEBUG_ONLY(cur-&gt;verify_oop_relocations());</span>
<span class="line-added">2014 </span>
<span class="line-added">2015       LogTarget(Trace, gc, nmethod) lt;</span>
<span class="line-added">2016       if (lt.is_enabled()) {</span>
<span class="line-added">2017         LogStream ls(lt);</span>
<span class="line-added">2018         CompileTask::print(&amp;ls, cur, &quot;oops_do, unmark&quot;, /*short_form:*/ true);</span>
<span class="line-added">2019       }</span>
<span class="line-added">2020       // End if self-loop has been detected.</span>
<span class="line-added">2021     } while (cur != next);</span>
2022   }














2023   log_trace(gc, nmethod)(&quot;oops_do_marking_epilogue&quot;);
2024 }
2025 
2026 inline bool includes(void* p, void* from, void* to) {
2027   return from &lt;= p &amp;&amp; p &lt; to;
2028 }
2029 
2030 
2031 void nmethod::copy_scopes_pcs(PcDesc* pcs, int count) {
2032   assert(count &gt;= 2, &quot;must be sentinel values, at least&quot;);
2033 
2034 #ifdef ASSERT
2035   // must be sorted and unique; we do a binary search in find_pc_desc()
2036   int prev_offset = pcs[0].pc_offset();
2037   assert(prev_offset == PcDesc::lower_offset_limit,
2038          &quot;must start with a sentinel&quot;);
2039   for (int i = 1; i &lt; count; i++) {
2040     int this_offset = pcs[i].pc_offset();
2041     assert(this_offset &gt; prev_offset, &quot;offsets must be sorted&quot;);
2042     prev_offset = this_offset;
</pre>
</td>
</tr>
</table>
<center><a href="codeCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
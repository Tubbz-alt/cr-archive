<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/include/jvm.h</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef _JAVASOFT_JVM_H_
  27 #define _JAVASOFT_JVM_H_
  28 
  29 #include &lt;sys/stat.h&gt;
  30 
  31 #include &quot;jni.h&quot;
  32 #include &quot;jvm_md.h&quot;
  33 
  34 #ifdef __cplusplus
  35 extern &quot;C&quot; {
  36 #endif
  37 
  38 /*
  39  * This file contains additional functions exported from the VM.
  40  * These functions are complementary to the standard JNI support.
  41  * There are three parts to this file:
  42  *
  43  * First, this file contains the VM-related functions needed by native
  44  * libraries in the standard Java API. For example, the java.lang.Object
  45  * class needs VM-level functions that wait for and notify monitors.
  46  *
  47  * Second, this file contains the functions and constant definitions
  48  * needed by the byte code verifier and class file format checker.
  49  * These functions allow the verifier and format checker to be written
  50  * in a VM-independent way.
  51  *
  52  * Third, this file contains various I/O and network operations needed
  53  * by the standard Java I/O and network APIs.
  54  */
  55 
  56 /*
  57  * Bump the version number when either of the following happens:
  58  *
  59  * 1. There is a change in JVM_* functions.
  60  *
  61  * 2. There is a change in the contract between VM and Java classes.
  62  *    For example, if the VM relies on a new private field in Thread
  63  *    class.
  64  */
  65 
  66 #define JVM_INTERFACE_VERSION 6
  67 
  68 JNIEXPORT jint JNICALL
  69 JVM_GetInterfaceVersion(void);
  70 
  71 /*************************************************************************
  72  PART 1: Functions for Native Libraries
  73  ************************************************************************/
  74 /*
  75  * java.lang.Object
  76  */
  77 JNIEXPORT jint JNICALL
  78 JVM_IHashCode(JNIEnv *env, jobject obj);
  79 
  80 JNIEXPORT void JNICALL
  81 JVM_MonitorWait(JNIEnv *env, jobject obj, jlong ms);
  82 
  83 JNIEXPORT void JNICALL
  84 JVM_MonitorNotify(JNIEnv *env, jobject obj);
  85 
  86 JNIEXPORT void JNICALL
  87 JVM_MonitorNotifyAll(JNIEnv *env, jobject obj);
  88 
  89 JNIEXPORT jobject JNICALL
  90 JVM_Clone(JNIEnv *env, jobject obj);
  91 
  92 /*
  93  * java.lang.String
  94  */
  95 JNIEXPORT jstring JNICALL
  96 JVM_InternString(JNIEnv *env, jstring str);
  97 
  98 /*
  99  * java.lang.System
 100  */
 101 JNIEXPORT jlong JNICALL
 102 JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored);
 103 
 104 JNIEXPORT jlong JNICALL
 105 JVM_NanoTime(JNIEnv *env, jclass ignored);
 106 
 107 JNIEXPORT jlong JNICALL
 108 JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs);
 109 
 110 JNIEXPORT void JNICALL
 111 JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 112               jobject dst, jint dst_pos, jint length);
 113 
 114 /*
 115  * Return an array of all properties as alternating name and value pairs.
 116  */
 117 JNIEXPORT jobjectArray JNICALL
 118 JVM_GetProperties(JNIEnv *env);
 119 
 120 /*
 121  * java.lang.Runtime
 122  */
 123 JNIEXPORT void JNICALL
 124 JVM_BeforeHalt();
 125 
 126 JNIEXPORT void JNICALL
 127 JVM_Halt(jint code);
 128 
 129 JNIEXPORT void JNICALL
 130 JVM_GC(void);
 131 
 132 /* Returns the number of real-time milliseconds that have elapsed since the
 133  * least-recently-inspected heap object was last inspected by the garbage
 134  * collector.
 135  *
 136  * For simple stop-the-world collectors this value is just the time
 137  * since the most recent collection.  For generational collectors it is the
 138  * time since the oldest generation was most recently collected.  Other
 139  * collectors are free to return a pessimistic estimate of the elapsed time, or
 140  * simply the time since the last full collection was performed.
 141  *
 142  * Note that in the presence of reference objects, a given object that is no
 143  * longer strongly reachable may have to be inspected multiple times before it
 144  * can be reclaimed.
 145  */
 146 JNIEXPORT jlong JNICALL
 147 JVM_MaxObjectInspectionAge(void);
 148 
 149 JNIEXPORT jlong JNICALL
 150 JVM_TotalMemory(void);
 151 
 152 JNIEXPORT jlong JNICALL
 153 JVM_FreeMemory(void);
 154 
 155 JNIEXPORT jlong JNICALL
 156 JVM_MaxMemory(void);
 157 
 158 JNIEXPORT jint JNICALL
 159 JVM_ActiveProcessorCount(void);
 160 
 161 JNIEXPORT void * JNICALL
 162 JVM_LoadLibrary(const char *name);
 163 
 164 JNIEXPORT void JNICALL
 165 JVM_UnloadLibrary(void * handle);
 166 
 167 JNIEXPORT void * JNICALL
 168 JVM_FindLibraryEntry(void *handle, const char *name);
 169 
 170 JNIEXPORT jboolean JNICALL
 171 JVM_IsSupportedJNIVersion(jint version);
 172 
 173 JNIEXPORT jobjectArray JNICALL
 174 JVM_GetVmArguments(JNIEnv *env);
 175 
 176 JNIEXPORT void JNICALL
 177 JVM_InitializeFromArchive(JNIEnv* env, jclass cls);
 178 
 179 JNIEXPORT jlong JNICALL
 180 JVM_GetRandomSeedForCDSDump();
 181 
 182 /*
 183  * java.lang.Throwable
 184  */
 185 JNIEXPORT void JNICALL
 186 JVM_FillInStackTrace(JNIEnv *env, jobject throwable);
 187 
 188 /*
 189  * java.lang.StackTraceElement
 190  */
 191 JNIEXPORT void JNICALL
 192 JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable);
 193 
 194 JNIEXPORT void JNICALL
 195 JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo);
 196 
 197 /*
 198  * java.lang.NullPointerException
 199  */
 200 
 201 JNIEXPORT jstring JNICALL
 202 JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable);
 203 
 204 /*
 205  * java.lang.StackWalker
 206  */
 207 enum {
 208   JVM_STACKWALK_FILL_CLASS_REFS_ONLY       = 0x2,
 209   JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,
 210   JVM_STACKWALK_SHOW_HIDDEN_FRAMES         = 0x20,
 211   JVM_STACKWALK_FILL_LIVE_STACK_FRAMES     = 0x100
 212 };
 213 
 214 JNIEXPORT jobject JNICALL
 215 JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 216                   jint skip_frames, jint frame_count, jint start_index,
 217                   jobjectArray frames);
 218 
 219 JNIEXPORT jint JNICALL
 220 JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 221                   jint frame_count, jint start_index,
 222                   jobjectArray frames);
 223 
 224 /*
 225  * java.lang.Thread
 226  */
 227 JNIEXPORT void JNICALL
 228 JVM_StartThread(JNIEnv *env, jobject thread);
 229 
 230 JNIEXPORT void JNICALL
 231 JVM_StopThread(JNIEnv *env, jobject thread, jobject exception);
 232 
 233 JNIEXPORT jboolean JNICALL
 234 JVM_IsThreadAlive(JNIEnv *env, jobject thread);
 235 
 236 JNIEXPORT void JNICALL
 237 JVM_SuspendThread(JNIEnv *env, jobject thread);
 238 
 239 JNIEXPORT void JNICALL
 240 JVM_ResumeThread(JNIEnv *env, jobject thread);
 241 
 242 JNIEXPORT void JNICALL
 243 JVM_SetThreadPriority(JNIEnv *env, jobject thread, jint prio);
 244 
 245 JNIEXPORT void JNICALL
 246 JVM_Yield(JNIEnv *env, jclass threadClass);
 247 
 248 JNIEXPORT void JNICALL
 249 JVM_Sleep(JNIEnv *env, jclass threadClass, jlong millis);
 250 
 251 JNIEXPORT jobject JNICALL
 252 JVM_CurrentThread(JNIEnv *env, jclass threadClass);
 253 
 254 JNIEXPORT void JNICALL
 255 JVM_Interrupt(JNIEnv *env, jobject thread);
 256 
 257 JNIEXPORT jboolean JNICALL
 258 JVM_HoldsLock(JNIEnv *env, jclass threadClass, jobject obj);
 259 
 260 JNIEXPORT void JNICALL
 261 JVM_DumpAllStacks(JNIEnv *env, jclass unused);
 262 
 263 JNIEXPORT jobjectArray JNICALL
 264 JVM_GetAllThreads(JNIEnv *env, jclass dummy);
 265 
 266 JNIEXPORT void JNICALL
 267 JVM_SetNativeThreadName(JNIEnv *env, jobject jthread, jstring name);
 268 
 269 /* getStackTrace() and getAllStackTraces() method */
 270 JNIEXPORT jobjectArray JNICALL
 271 JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads);
 272 
 273 /*
 274  * java.lang.SecurityManager
 275  */
 276 JNIEXPORT jobjectArray JNICALL
 277 JVM_GetClassContext(JNIEnv *env);
 278 
 279 /*
 280  * java.lang.Package
 281  */
 282 JNIEXPORT jstring JNICALL
 283 JVM_GetSystemPackage(JNIEnv *env, jstring name);
 284 
 285 JNIEXPORT jobjectArray JNICALL
 286 JVM_GetSystemPackages(JNIEnv *env);
 287 
 288 /*
 289  * java.lang.ref.Reference
 290  */
 291 JNIEXPORT jobject JNICALL
 292 JVM_GetAndClearReferencePendingList(JNIEnv *env);
 293 
 294 JNIEXPORT jboolean JNICALL
 295 JVM_HasReferencePendingList(JNIEnv *env);
 296 
 297 JNIEXPORT void JNICALL
 298 JVM_WaitForReferencePendingList(JNIEnv *env);
 299 
 300 /*
 301  * java.io.ObjectInputStream
 302  */
 303 JNIEXPORT jobject JNICALL
 304 JVM_LatestUserDefinedLoader(JNIEnv *env);
 305 
 306 /*
 307  * java.lang.reflect.Array
 308  */
 309 JNIEXPORT jint JNICALL
 310 JVM_GetArrayLength(JNIEnv *env, jobject arr);
 311 
 312 JNIEXPORT jobject JNICALL
 313 JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index);
 314 
 315 JNIEXPORT jvalue JNICALL
 316 JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode);
 317 
 318 JNIEXPORT void JNICALL
 319 JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val);
 320 
 321 JNIEXPORT void JNICALL
 322 JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v,
 323                              unsigned char vCode);
 324 
 325 JNIEXPORT jobject JNICALL
 326 JVM_NewArray(JNIEnv *env, jclass eltClass, jint length);
 327 
 328 JNIEXPORT jobject JNICALL
 329 JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim);
 330 
 331 
 332 /*
 333  * Returns the immediate caller class of the native method invoking
 334  * JVM_GetCallerClass.  The Method.invoke and other frames due to
 335  * reflection machinery are skipped.
 336  *
 337  * The caller is expected to be marked with
 338  * jdk.internal.reflect.CallerSensitive. The JVM will throw an
 339  * error if it is not marked properly.
 340  */
 341 JNIEXPORT jclass JNICALL
 342 JVM_GetCallerClass(JNIEnv *env);
 343 
 344 
 345 /*
 346  * Find primitive classes
 347  * utf: class name
 348  */
 349 JNIEXPORT jclass JNICALL
 350 JVM_FindPrimitiveClass(JNIEnv *env, const char *utf);
 351 
 352 
 353 /*
 354  * Find a class from a boot class loader. Returns NULL if class not found.
 355  */
 356 JNIEXPORT jclass JNICALL
 357 JVM_FindClassFromBootLoader(JNIEnv *env, const char *name);
 358 
 359 /*
 360  * Find a class from a given class loader.  Throws ClassNotFoundException.
 361  *  name:   name of class
 362  *  init:   whether initialization is done
 363  *  loader: class loader to look up the class. This may not be the same as the caller&#39;s
 364  *          class loader.
 365  *  caller: initiating class. The initiating class may be null when a security
 366  *          manager is not installed.
 367  */
 368 JNIEXPORT jclass JNICALL
 369 JVM_FindClassFromCaller(JNIEnv *env, const char *name, jboolean init,
 370                         jobject loader, jclass caller);
 371 
 372 /*
 373  * Find a class from a given class.
 374  */
 375 JNIEXPORT jclass JNICALL
 376 JVM_FindClassFromClass(JNIEnv *env, const char *name, jboolean init,
 377                              jclass from);
 378 
 379 /* Find a loaded class cached by the VM */
 380 JNIEXPORT jclass JNICALL
 381 JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name);
 382 
 383 /* Define a class */
 384 JNIEXPORT jclass JNICALL
 385 JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf,
 386                 jsize len, jobject pd);
 387 
 388 /* Define a class with a source (added in JDK1.5) */
 389 JNIEXPORT jclass JNICALL
 390 JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader,
 391                           const jbyte *buf, jsize len, jobject pd,
 392                           const char *source);
 393 
 394 /*
 395  * Define a class with the specified lookup class.
 396  *  lookup:  Lookup class
 397  *  name:    the name of the class
 398  *  buf:     class bytes
 399  *  len:     length of class bytes
 400  *  pd:      protection domain
 401  *  init:    initialize the class
 402  *  flags:   properties of the class
 403  *  classData: private static pre-initialized field; may be null
 404  */
 405 JNIEXPORT jclass JNICALL
 406 JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,
 407                       jsize len, jobject pd, jboolean init, int flags, jobject classData);
 408 
 409 /*
 410  * Module support funcions
 411  */
 412 
 413 /*
 414  * Define a module with the specified packages and bind the module to the
 415  * given class loader.
 416  *  module:       module to define
 417  *  is_open:      specifies if module is open (currently ignored)
 418  *  version:      the module version
 419  *  location:     the module location
 420  *  packages:     array of packages in the module
 421  */
 422 JNIEXPORT void JNICALL
 423 JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
 424                  jstring location, jobjectArray packages);
 425 
 426 /*
 427  * Set the boot loader&#39;s unnamed module.
 428  *  module: boot loader&#39;s unnamed module
 429  */
 430 JNIEXPORT void JNICALL
 431 JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module);
 432 
 433 /*
 434  * Do a qualified export of a package.
 435  *  from_module: module containing the package to export
 436  *  package:     name of the package to export
 437  *  to_module:   module to export the package to
 438  */
 439 JNIEXPORT void JNICALL
 440 JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module);
 441 
 442 /*
 443  * Do an export of a package to all unnamed modules.
 444  *  from_module: module containing the package to export
 445  *  package:     name of the package to export to all unnamed modules
 446  */
 447 JNIEXPORT void JNICALL
 448 JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package);
 449 
 450 /*
 451  * Do an unqualified export of a package.
 452  *  from_module: module containing the package to export
 453  *  package:     name of the package to export
 454  */
 455 JNIEXPORT void JNICALL
 456 JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package);
 457 
 458 /*
 459  * Add a module to the list of modules that a given module can read.
 460  *  from_module:   module requesting read access
 461  *  source_module: module that from_module wants to read
 462  */
 463 JNIEXPORT void JNICALL
 464 JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module);
 465 
 466 /*
 467  * Reflection support functions
 468  */
 469 
 470 JNIEXPORT jstring JNICALL
 471 JVM_InitClassName(JNIEnv *env, jclass cls);
 472 
 473 JNIEXPORT jobjectArray JNICALL
 474 JVM_GetClassInterfaces(JNIEnv *env, jclass cls);
 475 
 476 JNIEXPORT jboolean JNICALL
 477 JVM_IsInterface(JNIEnv *env, jclass cls);
 478 
 479 JNIEXPORT jobjectArray JNICALL
 480 JVM_GetClassSigners(JNIEnv *env, jclass cls);
 481 
 482 JNIEXPORT void JNICALL
 483 JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers);
 484 
 485 JNIEXPORT jobject JNICALL
 486 JVM_GetProtectionDomain(JNIEnv *env, jclass cls);
 487 
 488 JNIEXPORT jboolean JNICALL
 489 JVM_IsArrayClass(JNIEnv *env, jclass cls);
 490 
 491 JNIEXPORT jboolean JNICALL
 492 JVM_IsPrimitiveClass(JNIEnv *env, jclass cls);
 493 
 494 JNIEXPORT jboolean JNICALL
 495 JVM_IsHiddenClass(JNIEnv *env, jclass cls);
 496 
 497 JNIEXPORT jint JNICALL
 498 JVM_GetClassModifiers(JNIEnv *env, jclass cls);
 499 
 500 JNIEXPORT jobjectArray JNICALL
 501 JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass);
 502 
 503 JNIEXPORT jclass JNICALL
 504 JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass);
 505 
 506 JNIEXPORT jstring JNICALL
 507 JVM_GetSimpleBinaryName(JNIEnv *env, jclass ofClass);
 508 
 509 /* Generics support (JDK 1.5) */
 510 JNIEXPORT jstring JNICALL
 511 JVM_GetClassSignature(JNIEnv *env, jclass cls);
 512 
 513 /* Annotations support (JDK 1.5) */
 514 JNIEXPORT jbyteArray JNICALL
 515 JVM_GetClassAnnotations(JNIEnv *env, jclass cls);
 516 
 517 /* Type use annotations support (JDK 1.8) */
 518 
 519 JNIEXPORT jbyteArray JNICALL
 520 JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls);
 521 
 522 JNIEXPORT jbyteArray JNICALL
 523 JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field);
 524 
 525 JNIEXPORT jbyteArray JNICALL
 526 JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method);
 527 
 528 /*
 529  * New (JDK 1.4) reflection implementation
 530  */
 531 
 532 JNIEXPORT jobjectArray JNICALL
 533 JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 534 
 535 JNIEXPORT jobjectArray JNICALL
 536 JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 537 
 538 JNIEXPORT jobjectArray JNICALL
 539 JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 540 
 541 
 542 /* Differs from JVM_GetClassModifiers in treatment of inner classes.
 543    This returns the access flags for the class as specified in the
 544    class file rather than searching the InnerClasses attribute (if
 545    present) to find the source-level access flags. Only the values of
 546    the low 13 bits (i.e., a mask of 0x1FFF) are guaranteed to be
 547    valid. */
 548 JNIEXPORT jint JNICALL
 549 JVM_GetClassAccessFlags(JNIEnv *env, jclass cls);
 550 
 551 /* Nestmates - since JDK 11 */
 552 
 553 JNIEXPORT jboolean JNICALL
 554 JVM_AreNestMates(JNIEnv *env, jclass current, jclass member);
 555 
 556 JNIEXPORT jclass JNICALL
 557 JVM_GetNestHost(JNIEnv *env, jclass current);
 558 
 559 JNIEXPORT jobjectArray JNICALL
 560 JVM_GetNestMembers(JNIEnv *env, jclass current);
 561 
 562 /* Records - since JDK 14 */
 563 
 564 JNIEXPORT jboolean JNICALL
 565 JVM_IsRecord(JNIEnv *env, jclass cls);
 566 
 567 JNIEXPORT jobjectArray JNICALL
 568 JVM_GetRecordComponents(JNIEnv *env, jclass ofClass);
 569 
 570 /* The following two reflection routines are still needed due to startup time issues */
 571 /*
 572  * java.lang.reflect.Method
 573  */
 574 JNIEXPORT jobject JNICALL
 575 JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0);
 576 
 577 /*
 578  * java.lang.reflect.Constructor
 579  */
 580 JNIEXPORT jobject JNICALL
 581 JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0);
 582 
 583 /*
 584  * Constant pool access; currently used to implement reflective access to annotations (JDK 1.5)
 585  */
 586 
 587 JNIEXPORT jobject JNICALL
 588 JVM_GetClassConstantPool(JNIEnv *env, jclass cls);
 589 
 590 JNIEXPORT jint JNICALL JVM_ConstantPoolGetSize
 591 (JNIEnv *env, jobject unused, jobject jcpool);
 592 
 593 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAt
 594 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 595 
 596 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAtIfLoaded
 597 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 598 
 599 JNIEXPORT jint JNICALL JVM_ConstantPoolGetClassRefIndexAt
 600 (JNIEnv *env, jobject obj, jobject unused, jint index);
 601 
 602 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAt
 603 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 604 
 605 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAtIfLoaded
 606 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 607 
 608 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAt
 609 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 610 
 611 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAtIfLoaded
 612 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 613 
 614 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetMemberRefInfoAt
 615 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 616 
 617 JNIEXPORT jint JNICALL JVM_ConstantPoolGetNameAndTypeRefIndexAt
 618 (JNIEnv *env, jobject obj, jobject unused, jint index);
 619 
 620 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetNameAndTypeRefInfoAt
 621 (JNIEnv *env, jobject obj, jobject unused, jint index);
 622 
 623 JNIEXPORT jint JNICALL JVM_ConstantPoolGetIntAt
 624 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 625 
 626 JNIEXPORT jlong JNICALL JVM_ConstantPoolGetLongAt
 627 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 628 
 629 JNIEXPORT jfloat JNICALL JVM_ConstantPoolGetFloatAt
 630 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 631 
 632 JNIEXPORT jdouble JNICALL JVM_ConstantPoolGetDoubleAt
 633 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 634 
 635 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetStringAt
 636 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 637 
 638 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetUTF8At
 639 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 640 
 641 JNIEXPORT jbyte JNICALL JVM_ConstantPoolGetTagAt
 642 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 643 
 644 /*
 645  * Parameter reflection
 646  */
 647 
 648 JNIEXPORT jobjectArray JNICALL
 649 JVM_GetMethodParameters(JNIEnv *env, jobject method);
 650 
 651 /*
 652  * java.security.*
 653  */
 654 
 655 JNIEXPORT jobject JNICALL
 656 JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls);
 657 
 658 /*
 659  * Ensure that code doing a stackwalk and using javaVFrame::locals() to
 660  * get the value will see a materialized value and not a scalar-replaced
 661  * null value.
 662  */
 663 #define JVM_EnsureMaterializedForStackWalk(env, value) \
 664     do {} while(0) // Nothing to do.  The fact that the value escaped
 665                    // through a native method is enough.
 666 
 667 JNIEXPORT jobject JNICALL
 668 JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls);
 669 
 670 /*
 671  * Signal support, used to implement the shutdown sequence.  Every VM must
 672  * support JVM_SIGINT and JVM_SIGTERM, raising the former for user interrupts
 673  * (^C) and the latter for external termination (kill, system shutdown, etc.).
 674  * Other platform-dependent signal values may also be supported.
 675  */
 676 
 677 JNIEXPORT void * JNICALL
 678 JVM_RegisterSignal(jint sig, void *handler);
 679 
 680 JNIEXPORT jboolean JNICALL
 681 JVM_RaiseSignal(jint sig);
 682 
 683 JNIEXPORT jint JNICALL
 684 JVM_FindSignal(const char *name);
 685 
 686 /*
 687  * Retrieve the assertion directives for the specified class.
 688  */
 689 JNIEXPORT jboolean JNICALL
 690 JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls);
 691 
 692 /*
 693  * Retrieve the assertion directives from the VM.
 694  */
 695 JNIEXPORT jobject JNICALL
 696 JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused);
 697 
 698 /*
 699  * java.util.concurrent.atomic.AtomicLong
 700  */
 701 JNIEXPORT jboolean JNICALL
 702 JVM_SupportsCX8(void);
 703 
 704 /*
 705  * com.sun.dtrace.jsdt support
 706  */
 707 
 708 #define JVM_TRACING_DTRACE_VERSION 1
 709 
 710 /*
 711  * Structure to pass one probe description to JVM
 712  */
 713 typedef struct {
 714     jmethodID method;
 715     jstring   function;
 716     jstring   name;
 717     void*            reserved[4];     // for future use
 718 } JVM_DTraceProbe;
 719 
 720 /**
 721  * Encapsulates the stability ratings for a DTrace provider field
 722  */
 723 typedef struct {
 724     jint nameStability;
 725     jint dataStability;
 726     jint dependencyClass;
 727 } JVM_DTraceInterfaceAttributes;
 728 
 729 /*
 730  * Structure to pass one provider description to JVM
 731  */
 732 typedef struct {
 733     jstring                       name;
 734     JVM_DTraceProbe*              probes;
 735     jint                          probe_count;
 736     JVM_DTraceInterfaceAttributes providerAttributes;
 737     JVM_DTraceInterfaceAttributes moduleAttributes;
 738     JVM_DTraceInterfaceAttributes functionAttributes;
 739     JVM_DTraceInterfaceAttributes nameAttributes;
 740     JVM_DTraceInterfaceAttributes argsAttributes;
 741     void*                         reserved[4]; // for future use
 742 } JVM_DTraceProvider;
 743 
 744 /*
 745  * Get the version number the JVM was built with
 746  */
 747 JNIEXPORT jint JNICALL
 748 JVM_DTraceGetVersion(JNIEnv* env);
 749 
 750 /*
 751  * Register new probe with given signature, return global handle
 752  *
 753  * The version passed in is the version that the library code was
 754  * built with.
 755  */
 756 JNIEXPORT jlong JNICALL
 757 JVM_DTraceActivate(JNIEnv* env, jint version, jstring module_name,
 758   jint providers_count, JVM_DTraceProvider* providers);
 759 
 760 /*
 761  * Check JSDT probe
 762  */
 763 JNIEXPORT jboolean JNICALL
 764 JVM_DTraceIsProbeEnabled(JNIEnv* env, jmethodID method);
 765 
 766 /*
 767  * Destroy custom DOF
 768  */
 769 JNIEXPORT void JNICALL
 770 JVM_DTraceDispose(JNIEnv* env, jlong activation_handle);
 771 
 772 /*
 773  * Check to see if DTrace is supported by OS
 774  */
 775 JNIEXPORT jboolean JNICALL
 776 JVM_DTraceIsSupported(JNIEnv* env);
 777 
 778 /*************************************************************************
 779  PART 2: Support for the Verifier and Class File Format Checker
 780  ************************************************************************/
 781 /*
 782  * Return the class name in UTF format. The result is valid
 783  * until JVM_ReleaseUTf is called.
 784  *
 785  * The caller must treat the string as a constant and not modify it
 786  * in any way.
 787  */
 788 JNIEXPORT const char * JNICALL
 789 JVM_GetClassNameUTF(JNIEnv *env, jclass cb);
 790 
 791 /*
 792  * Returns the constant pool types in the buffer provided by &quot;types.&quot;
 793  */
 794 JNIEXPORT void JNICALL
 795 JVM_GetClassCPTypes(JNIEnv *env, jclass cb, unsigned char *types);
 796 
 797 /*
 798  * Returns the number of Constant Pool entries.
 799  */
 800 JNIEXPORT jint JNICALL
 801 JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cb);
 802 
 803 /*
 804  * Returns the number of *declared* fields or methods.
 805  */
 806 JNIEXPORT jint JNICALL
 807 JVM_GetClassFieldsCount(JNIEnv *env, jclass cb);
 808 
 809 JNIEXPORT jint JNICALL
 810 JVM_GetClassMethodsCount(JNIEnv *env, jclass cb);
 811 
 812 /*
 813  * Returns the CP indexes of exceptions raised by a given method.
 814  * Places the result in the given buffer.
 815  *
 816  * The method is identified by method_index.
 817  */
 818 JNIEXPORT void JNICALL
 819 JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cb, jint method_index,
 820                                 unsigned short *exceptions);
 821 /*
 822  * Returns the number of exceptions raised by a given method.
 823  * The method is identified by method_index.
 824  */
 825 JNIEXPORT jint JNICALL
 826 JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cb, jint method_index);
 827 
 828 /*
 829  * Returns the byte code sequence of a given method.
 830  * Places the result in the given buffer.
 831  *
 832  * The method is identified by method_index.
 833  */
 834 JNIEXPORT void JNICALL
 835 JVM_GetMethodIxByteCode(JNIEnv *env, jclass cb, jint method_index,
 836                         unsigned char *code);
 837 
 838 /*
 839  * Returns the length of the byte code sequence of a given method.
 840  * The method is identified by method_index.
 841  */
 842 JNIEXPORT jint JNICALL
 843 JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cb, jint method_index);
 844 
 845 /*
 846  * A structure used to a capture exception table entry in a Java method.
 847  */
 848 typedef struct {
 849     jint start_pc;
 850     jint end_pc;
 851     jint handler_pc;
 852     jint catchType;
 853 } JVM_ExceptionTableEntryType;
 854 
 855 /*
 856  * Returns the exception table entry at entry_index of a given method.
 857  * Places the result in the given buffer.
 858  *
 859  * The method is identified by method_index.
 860  */
 861 JNIEXPORT void JNICALL
 862 JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cb, jint method_index,
 863                                    jint entry_index,
 864                                    JVM_ExceptionTableEntryType *entry);
 865 
 866 /*
 867  * Returns the length of the exception table of a given method.
 868  * The method is identified by method_index.
 869  */
 870 JNIEXPORT jint JNICALL
 871 JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cb, int index);
 872 
 873 /*
 874  * Returns the modifiers of a given field.
 875  * The field is identified by field_index.
 876  */
 877 JNIEXPORT jint JNICALL
 878 JVM_GetFieldIxModifiers(JNIEnv *env, jclass cb, int index);
 879 
 880 /*
 881  * Returns the modifiers of a given method.
 882  * The method is identified by method_index.
 883  */
 884 JNIEXPORT jint JNICALL
 885 JVM_GetMethodIxModifiers(JNIEnv *env, jclass cb, int index);
 886 
 887 /*
 888  * Returns the number of local variables of a given method.
 889  * The method is identified by method_index.
 890  */
 891 JNIEXPORT jint JNICALL
 892 JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cb, int index);
 893 
 894 /*
 895  * Returns the number of arguments (including this pointer) of a given method.
 896  * The method is identified by method_index.
 897  */
 898 JNIEXPORT jint JNICALL
 899 JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cb, int index);
 900 
 901 /*
 902  * Returns the maximum amount of stack (in words) used by a given method.
 903  * The method is identified by method_index.
 904  */
 905 JNIEXPORT jint JNICALL
 906 JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cb, int index);
 907 
 908 /*
 909  * Is a given method a constructor.
 910  * The method is identified by method_index.
 911  */
 912 JNIEXPORT jboolean JNICALL
 913 JVM_IsConstructorIx(JNIEnv *env, jclass cb, int index);
 914 
 915 /*
 916  * Is the given method generated by the VM.
 917  * The method is identified by method_index.
 918  */
 919 JNIEXPORT jboolean JNICALL
 920 JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cb, int index);
 921 
 922 /*
 923  * Returns the name of a given method in UTF format.
 924  * The result remains valid until JVM_ReleaseUTF is called.
 925  *
 926  * The caller must treat the string as a constant and not modify it
 927  * in any way.
 928  */
 929 JNIEXPORT const char * JNICALL
 930 JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cb, jint index);
 931 
 932 /*
 933  * Returns the signature of a given method in UTF format.
 934  * The result remains valid until JVM_ReleaseUTF is called.
 935  *
 936  * The caller must treat the string as a constant and not modify it
 937  * in any way.
 938  */
 939 JNIEXPORT const char * JNICALL
 940 JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cb, jint index);
 941 
 942 /*
 943  * Returns the name of the field referred to at a given constant pool
 944  * index.
 945  *
 946  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 947  * is called.
 948  *
 949  * The caller must treat the string as a constant and not modify it
 950  * in any way.
 951  */
 952 JNIEXPORT const char * JNICALL
 953 JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cb, jint index);
 954 
 955 /*
 956  * Returns the name of the method referred to at a given constant pool
 957  * index.
 958  *
 959  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 960  * is called.
 961  *
 962  * The caller must treat the string as a constant and not modify it
 963  * in any way.
 964  */
 965 JNIEXPORT const char * JNICALL
 966 JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cb, jint index);
 967 
 968 /*
 969  * Returns the signature of the method referred to at a given constant pool
 970  * index.
 971  *
 972  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 973  * is called.
 974  *
 975  * The caller must treat the string as a constant and not modify it
 976  * in any way.
 977  */
 978 JNIEXPORT const char * JNICALL
 979 JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cb, jint index);
 980 
 981 /*
 982  * Returns the signature of the field referred to at a given constant pool
 983  * index.
 984  *
 985  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 986  * is called.
 987  *
 988  * The caller must treat the string as a constant and not modify it
 989  * in any way.
 990  */
 991 JNIEXPORT const char * JNICALL
 992 JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cb, jint index);
 993 
 994 /*
 995  * Returns the class name referred to at a given constant pool index.
 996  *
 997  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 998  * is called.
 999  *
1000  * The caller must treat the string as a constant and not modify it
1001  * in any way.
1002  */
1003 JNIEXPORT const char * JNICALL
1004 JVM_GetCPClassNameUTF(JNIEnv *env, jclass cb, jint index);
1005 
1006 /*
1007  * Returns the class name referred to at a given constant pool index.
1008  *
1009  * The constant pool entry must refer to a CONSTANT_Fieldref.
1010  *
1011  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1012  * is called.
1013  *
1014  * The caller must treat the string as a constant and not modify it
1015  * in any way.
1016  */
1017 JNIEXPORT const char * JNICALL
1018 JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cb, jint index);
1019 
1020 /*
1021  * Returns the class name referred to at a given constant pool index.
1022  *
1023  * The constant pool entry must refer to CONSTANT_Methodref or
1024  * CONSTANT_InterfaceMethodref.
1025  *
1026  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1027  * is called.
1028  *
1029  * The caller must treat the string as a constant and not modify it
1030  * in any way.
1031  */
1032 JNIEXPORT const char * JNICALL
1033 JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cb, jint index);
1034 
1035 /*
1036  * Returns the modifiers of a field in calledClass. The field is
1037  * referred to in class cb at constant pool entry index.
1038  *
1039  * The caller must treat the string as a constant and not modify it
1040  * in any way.
1041  *
1042  * Returns -1 if the field does not exist in calledClass.
1043  */
1044 JNIEXPORT jint JNICALL
1045 JVM_GetCPFieldModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1046 
1047 /*
1048  * Returns the modifiers of a method in calledClass. The method is
1049  * referred to in class cb at constant pool entry index.
1050  *
1051  * Returns -1 if the method does not exist in calledClass.
1052  */
1053 JNIEXPORT jint JNICALL
1054 JVM_GetCPMethodModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1055 
1056 /*
1057  * Releases the UTF string obtained from the VM.
1058  */
1059 JNIEXPORT void JNICALL
1060 JVM_ReleaseUTF(const char *utf);
1061 
1062 /*
1063  * Compare if two classes are in the same package.
1064  */
1065 JNIEXPORT jboolean JNICALL
1066 JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2);
1067 
1068 /* Get classfile constants */
1069 #include &quot;classfile_constants.h&quot;
1070 
1071 /*
1072  * Support for a VM-independent class format checker.
1073  */
1074 typedef struct {
1075     unsigned long code;    /* byte code */
1076     unsigned long excs;    /* exceptions */
1077     unsigned long etab;    /* catch table */
1078     unsigned long lnum;    /* line number */
1079     unsigned long lvar;    /* local vars */
1080 } method_size_info;
1081 
1082 typedef struct {
1083     unsigned int constants;    /* constant pool */
1084     unsigned int fields;
1085     unsigned int methods;
1086     unsigned int interfaces;
1087     unsigned int fields2;      /* number of static 2-word fields */
1088     unsigned int innerclasses; /* # of records in InnerClasses attr */
1089 
1090     method_size_info clinit;   /* memory used in clinit */
1091     method_size_info main;     /* used everywhere else */
1092 } class_size_info;
1093 
1094 #define JVM_RECOGNIZED_CLASS_MODIFIERS (JVM_ACC_PUBLIC | \
1095                                         JVM_ACC_FINAL | \
1096                                         JVM_ACC_SUPER | \
1097                                         JVM_ACC_INTERFACE | \
1098                                         JVM_ACC_ABSTRACT | \
1099                                         JVM_ACC_ANNOTATION | \
1100                                         JVM_ACC_ENUM | \
1101                                         JVM_ACC_SYNTHETIC)
1102 
1103 #define JVM_RECOGNIZED_FIELD_MODIFIERS (JVM_ACC_PUBLIC | \
1104                                         JVM_ACC_PRIVATE | \
1105                                         JVM_ACC_PROTECTED | \
1106                                         JVM_ACC_STATIC | \
1107                                         JVM_ACC_FINAL | \
1108                                         JVM_ACC_VOLATILE | \
1109                                         JVM_ACC_TRANSIENT | \
1110                                         JVM_ACC_ENUM | \
1111                                         JVM_ACC_SYNTHETIC)
1112 
1113 #define JVM_RECOGNIZED_METHOD_MODIFIERS (JVM_ACC_PUBLIC | \
1114                                          JVM_ACC_PRIVATE | \
1115                                          JVM_ACC_PROTECTED | \
1116                                          JVM_ACC_STATIC | \
1117                                          JVM_ACC_FINAL | \
1118                                          JVM_ACC_SYNCHRONIZED | \
1119                                          JVM_ACC_BRIDGE | \
1120                                          JVM_ACC_VARARGS | \
1121                                          JVM_ACC_NATIVE | \
1122                                          JVM_ACC_ABSTRACT | \
1123                                          JVM_ACC_STRICT | \
1124                                          JVM_ACC_SYNTHETIC)
1125 
1126 
1127 /*************************************************************************
1128  PART 3: I/O and Network Support
1129  ************************************************************************/
1130 
1131 /*
1132  * Convert a pathname into native format.  This function does syntactic
1133  * cleanup, such as removing redundant separator characters.  It modifies
1134  * the given pathname string in place.
1135  */
1136 JNIEXPORT char * JNICALL
1137 JVM_NativePath(char *);
1138 
1139 /*
1140  * The standard printing functions supported by the Java VM. (Should they
1141  * be renamed to JVM_* in the future?
1142  */
1143 
1144 /* jio_snprintf() and jio_vsnprintf() behave like snprintf(3) and vsnprintf(3),
1145  *  respectively, with the following differences:
1146  * - The string written to str is always zero-terminated, also in case of
1147  *   truncation (count is too small to hold the result string), unless count
1148  *   is 0. In case of truncation count-1 characters are written and &#39;\0&#39;
1149  *   appendend.
1150  * - If count is too small to hold the whole string, -1 is returned across
1151  *   all platforms. */
1152 
1153 JNIEXPORT int
1154 jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args);
1155 
1156 JNIEXPORT int
1157 jio_snprintf(char *str, size_t count, const char *fmt, ...);
1158 
1159 JNIEXPORT int
1160 jio_fprintf(FILE *, const char *fmt, ...);
1161 
1162 JNIEXPORT int
1163 jio_vfprintf(FILE *, const char *fmt, va_list args);
1164 
1165 
1166 JNIEXPORT void * JNICALL
1167 JVM_RawMonitorCreate(void);
1168 
1169 JNIEXPORT void JNICALL
1170 JVM_RawMonitorDestroy(void *mon);
1171 
1172 JNIEXPORT jint JNICALL
1173 JVM_RawMonitorEnter(void *mon);
1174 
1175 JNIEXPORT void JNICALL
1176 JVM_RawMonitorExit(void *mon);
1177 
1178 /*
1179  * java.lang.management support
1180  */
1181 JNIEXPORT void* JNICALL
1182 JVM_GetManagement(jint version);
1183 
1184 /*
1185  * com.sun.tools.attach.VirtualMachine support
1186  *
1187  * Initialize the agent properties with the properties maintained in the VM.
1188  */
1189 JNIEXPORT jobject JNICALL
1190 JVM_InitAgentProperties(JNIEnv *env, jobject agent_props);
1191 
1192 JNIEXPORT jstring JNICALL
1193 JVM_GetTemporaryDirectory(JNIEnv *env);
1194 
1195 /* Generics reflection support.
1196  *
1197  * Returns information about the given class&#39;s EnclosingMethod
1198  * attribute, if present, or null if the class had no enclosing
1199  * method.
1200  *
1201  * If non-null, the returned array contains three elements. Element 0
1202  * is the java.lang.Class of which the enclosing method is a member,
1203  * and elements 1 and 2 are the java.lang.Strings for the enclosing
1204  * method&#39;s name and descriptor, respectively.
1205  */
1206 JNIEXPORT jobjectArray JNICALL
1207 JVM_GetEnclosingMethodInfo(JNIEnv* env, jclass ofClass);
1208 
1209 /*
1210  * This structure is used by the launcher to get the default thread
1211  * stack size from the VM using JNI_GetDefaultJavaVMInitArgs() with a
1212  * version of 1.1.  As it is not supported otherwise, it has been removed
1213  * from jni.h
1214  */
1215 typedef struct JDK1_1InitArgs {
1216     jint version;
1217 
1218     char **properties;
1219     jint checkSource;
1220     jint nativeStackSize;
1221     jint javaStackSize;
1222     jint minHeapSize;
1223     jint maxHeapSize;
1224     jint verifyMode;
1225     char *classpath;
1226 
1227     jint (JNICALL *vfprintf)(FILE *fp, const char *format, va_list args);
1228     void (JNICALL *exit)(jint code);
1229     void (JNICALL *abort)(void);
1230 
1231     jint enableClassGC;
1232     jint enableVerboseGC;
1233     jint disableAsyncGC;
1234     jint verbose;
1235     jboolean debugging;
1236     jint debugPort;
1237 } JDK1_1InitArgs;
1238 
1239 
1240 #ifdef __cplusplus
1241 } /* extern &quot;C&quot; */
1242 
1243 #endif /* __cplusplus */
1244 
1245 #endif /* !_JAVASOFT_JVM_H_ */
    </pre>
  </body>
</html>
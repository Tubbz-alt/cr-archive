<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/include/jvm.h</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef _JAVASOFT_JVM_H_
  27 #define _JAVASOFT_JVM_H_
  28 
  29 #include &lt;sys/stat.h&gt;
  30 
  31 #include &quot;jni.h&quot;
  32 #include &quot;jvm_md.h&quot;
  33 
  34 #ifdef __cplusplus
  35 extern &quot;C&quot; {
  36 #endif
  37 
  38 /*
  39  * This file contains additional functions exported from the VM.
  40  * These functions are complementary to the standard JNI support.
  41  * There are three parts to this file:
  42  *
  43  * First, this file contains the VM-related functions needed by native
  44  * libraries in the standard Java API. For example, the java.lang.Object
  45  * class needs VM-level functions that wait for and notify monitors.
  46  *
  47  * Second, this file contains the functions and constant definitions
  48  * needed by the byte code verifier and class file format checker.
  49  * These functions allow the verifier and format checker to be written
  50  * in a VM-independent way.
  51  *
  52  * Third, this file contains various I/O and network operations needed
  53  * by the standard Java I/O and network APIs.
  54  */
  55 
  56 /*
  57  * Bump the version number when either of the following happens:
  58  *
  59  * 1. There is a change in JVM_* functions.
  60  *
  61  * 2. There is a change in the contract between VM and Java classes.
  62  *    For example, if the VM relies on a new private field in Thread
  63  *    class.
  64  */
  65 
  66 #define JVM_INTERFACE_VERSION 6
  67 
  68 JNIEXPORT jint JNICALL
  69 JVM_GetInterfaceVersion(void);
  70 
  71 /*************************************************************************
  72  PART 1: Functions for Native Libraries
  73  ************************************************************************/
  74 /*
  75  * java.lang.Object
  76  */
  77 JNIEXPORT jint JNICALL
  78 JVM_IHashCode(JNIEnv *env, jobject obj);
  79 
  80 JNIEXPORT void JNICALL
  81 JVM_MonitorWait(JNIEnv *env, jobject obj, jlong ms);
  82 
  83 JNIEXPORT void JNICALL
  84 JVM_MonitorNotify(JNIEnv *env, jobject obj);
  85 
  86 JNIEXPORT void JNICALL
  87 JVM_MonitorNotifyAll(JNIEnv *env, jobject obj);
  88 
  89 JNIEXPORT jobject JNICALL
  90 JVM_Clone(JNIEnv *env, jobject obj);
  91 
  92 /*
  93  * java.lang.String
  94  */
  95 JNIEXPORT jstring JNICALL
  96 JVM_InternString(JNIEnv *env, jstring str);
  97 
  98 /*
  99  * java.lang.System
 100  */
 101 JNIEXPORT jlong JNICALL
 102 JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored);
 103 
 104 JNIEXPORT jlong JNICALL
 105 JVM_NanoTime(JNIEnv *env, jclass ignored);
 106 
 107 JNIEXPORT jlong JNICALL
 108 JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs);
 109 
 110 JNIEXPORT void JNICALL
 111 JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 112               jobject dst, jint dst_pos, jint length);
 113 
 114 /*
 115  * Return an array of all properties as alternating name and value pairs.
 116  */
 117 JNIEXPORT jobjectArray JNICALL
 118 JVM_GetProperties(JNIEnv *env);
 119 
 120 /*
 121  * java.lang.Runtime
 122  */
 123 JNIEXPORT void JNICALL
 124 JVM_BeforeHalt();
 125 
 126 JNIEXPORT void JNICALL
 127 JVM_Halt(jint code);
 128 
 129 JNIEXPORT void JNICALL
 130 JVM_GC(void);
 131 
 132 /* Returns the number of real-time milliseconds that have elapsed since the
 133  * least-recently-inspected heap object was last inspected by the garbage
 134  * collector.
 135  *
 136  * For simple stop-the-world collectors this value is just the time
 137  * since the most recent collection.  For generational collectors it is the
 138  * time since the oldest generation was most recently collected.  Other
 139  * collectors are free to return a pessimistic estimate of the elapsed time, or
 140  * simply the time since the last full collection was performed.
 141  *
 142  * Note that in the presence of reference objects, a given object that is no
 143  * longer strongly reachable may have to be inspected multiple times before it
 144  * can be reclaimed.
 145  */
 146 JNIEXPORT jlong JNICALL
 147 JVM_MaxObjectInspectionAge(void);
 148 
 149 JNIEXPORT jlong JNICALL
 150 JVM_TotalMemory(void);
 151 
 152 JNIEXPORT jlong JNICALL
 153 JVM_FreeMemory(void);
 154 
 155 JNIEXPORT jlong JNICALL
 156 JVM_MaxMemory(void);
 157 
 158 JNIEXPORT jint JNICALL
 159 JVM_ActiveProcessorCount(void);
 160 
 161 JNIEXPORT void * JNICALL
 162 JVM_LoadLibrary(const char *name);
 163 
 164 JNIEXPORT void JNICALL
 165 JVM_UnloadLibrary(void * handle);
 166 
 167 JNIEXPORT void * JNICALL
 168 JVM_FindLibraryEntry(void *handle, const char *name);
 169 
 170 JNIEXPORT jboolean JNICALL
 171 JVM_IsSupportedJNIVersion(jint version);
 172 
 173 JNIEXPORT jobjectArray JNICALL
 174 JVM_GetVmArguments(JNIEnv *env);
 175 
 176 JNIEXPORT void JNICALL
 177 JVM_InitializeFromArchive(JNIEnv* env, jclass cls);
 178 
 179 JNIEXPORT jlong JNICALL
 180 JVM_GetRandomSeedForCDSDump();
 181 
 182 /*
 183  * java.lang.Throwable
 184  */
 185 JNIEXPORT void JNICALL
 186 JVM_FillInStackTrace(JNIEnv *env, jobject throwable);
 187 
 188 /*
 189  * java.lang.StackTraceElement
 190  */
 191 JNIEXPORT void JNICALL
 192 JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable);
 193 
 194 JNIEXPORT void JNICALL
 195 JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo);
 196 
 197 /*
 198  * java.lang.NullPointerException
 199  */
 200 
 201 JNIEXPORT jstring JNICALL
 202 JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable);
 203 
 204 /*
 205  * java.lang.StackWalker
 206  */
 207 enum {
 208   JVM_STACKWALK_FILL_CLASS_REFS_ONLY       = 0x2,
 209   JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,
 210   JVM_STACKWALK_SHOW_HIDDEN_FRAMES         = 0x20,
 211   JVM_STACKWALK_FILL_LIVE_STACK_FRAMES     = 0x100
 212 };
 213 
 214 JNIEXPORT jobject JNICALL
 215 JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 216                   jint skip_frames, jint frame_count, jint start_index,
 217                   jobjectArray frames);
 218 
 219 JNIEXPORT jint JNICALL
 220 JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 221                   jint frame_count, jint start_index,
 222                   jobjectArray frames);
 223 
 224 /*
 225  * java.lang.Thread
 226  */
 227 JNIEXPORT void JNICALL
 228 JVM_StartThread(JNIEnv *env, jobject thread);
 229 
 230 JNIEXPORT void JNICALL
 231 JVM_StopThread(JNIEnv *env, jobject thread, jobject exception);
 232 
 233 JNIEXPORT jboolean JNICALL
 234 JVM_IsThreadAlive(JNIEnv *env, jobject thread);
 235 
 236 JNIEXPORT void JNICALL
 237 JVM_SuspendThread(JNIEnv *env, jobject thread);
 238 
 239 JNIEXPORT void JNICALL
 240 JVM_ResumeThread(JNIEnv *env, jobject thread);
 241 
 242 JNIEXPORT void JNICALL
 243 JVM_SetThreadPriority(JNIEnv *env, jobject thread, jint prio);
 244 
 245 JNIEXPORT void JNICALL
 246 JVM_Yield(JNIEnv *env, jclass threadClass);
 247 
 248 JNIEXPORT void JNICALL
 249 JVM_Sleep(JNIEnv *env, jclass threadClass, jlong millis);
 250 
 251 JNIEXPORT jobject JNICALL
 252 JVM_CurrentThread(JNIEnv *env, jclass threadClass);
 253 
 254 JNIEXPORT void JNICALL
 255 JVM_Interrupt(JNIEnv *env, jobject thread);
 256 
 257 JNIEXPORT jboolean JNICALL
 258 JVM_HoldsLock(JNIEnv *env, jclass threadClass, jobject obj);
 259 
 260 JNIEXPORT void JNICALL
 261 JVM_DumpAllStacks(JNIEnv *env, jclass unused);
 262 
 263 JNIEXPORT jobjectArray JNICALL
 264 JVM_GetAllThreads(JNIEnv *env, jclass dummy);
 265 
 266 JNIEXPORT void JNICALL
 267 JVM_SetNativeThreadName(JNIEnv *env, jobject jthread, jstring name);
 268 
 269 /* getStackTrace() and getAllStackTraces() method */
 270 JNIEXPORT jobjectArray JNICALL
 271 JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads);
 272 
 273 /*
 274  * java.lang.SecurityManager
 275  */
 276 JNIEXPORT jobjectArray JNICALL
 277 JVM_GetClassContext(JNIEnv *env);
 278 
 279 /*
 280  * java.lang.Package
 281  */
 282 JNIEXPORT jstring JNICALL
 283 JVM_GetSystemPackage(JNIEnv *env, jstring name);
 284 
 285 JNIEXPORT jobjectArray JNICALL
 286 JVM_GetSystemPackages(JNIEnv *env);
 287 
 288 /*
 289  * java.lang.ref.Reference
 290  */
 291 JNIEXPORT jobject JNICALL
 292 JVM_GetAndClearReferencePendingList(JNIEnv *env);
 293 
 294 JNIEXPORT jboolean JNICALL
 295 JVM_HasReferencePendingList(JNIEnv *env);
 296 
 297 JNIEXPORT void JNICALL
 298 JVM_WaitForReferencePendingList(JNIEnv *env);
 299 
 300 /*
 301  * java.io.ObjectInputStream
 302  */
 303 JNIEXPORT jobject JNICALL
 304 JVM_LatestUserDefinedLoader(JNIEnv *env);
 305 
 306 /*
 307  * java.lang.reflect.Array
 308  */
 309 JNIEXPORT jint JNICALL
 310 JVM_GetArrayLength(JNIEnv *env, jobject arr);
 311 
 312 JNIEXPORT jobject JNICALL
 313 JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index);
 314 
 315 JNIEXPORT jvalue JNICALL
 316 JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode);
 317 
 318 JNIEXPORT void JNICALL
 319 JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val);
 320 
 321 JNIEXPORT void JNICALL
 322 JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v,
 323                              unsigned char vCode);
 324 
 325 JNIEXPORT jobject JNICALL
 326 JVM_NewArray(JNIEnv *env, jclass eltClass, jint length);
 327 
 328 JNIEXPORT jobject JNICALL
 329 JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim);
 330 
 331 
 332 /*
 333  * Returns the immediate caller class of the native method invoking
 334  * JVM_GetCallerClass.  The Method.invoke and other frames due to
 335  * reflection machinery are skipped.
 336  *
 337  * The caller is expected to be marked with
 338  * jdk.internal.reflect.CallerSensitive. The JVM will throw an
 339  * error if it is not marked properly.
 340  */
 341 JNIEXPORT jclass JNICALL
 342 JVM_GetCallerClass(JNIEnv *env);
 343 
 344 
 345 /*
 346  * Find primitive classes
 347  * utf: class name
 348  */
 349 JNIEXPORT jclass JNICALL
 350 JVM_FindPrimitiveClass(JNIEnv *env, const char *utf);
 351 
 352 
 353 /*
 354  * Find a class from a boot class loader. Returns NULL if class not found.
 355  */
 356 JNIEXPORT jclass JNICALL
 357 JVM_FindClassFromBootLoader(JNIEnv *env, const char *name);
 358 
 359 /*
 360  * Find a class from a given class loader.  Throws ClassNotFoundException.
 361  *  name:   name of class
 362  *  init:   whether initialization is done
 363  *  loader: class loader to look up the class. This may not be the same as the caller&#39;s
 364  *          class loader.
 365  *  caller: initiating class. The initiating class may be null when a security
 366  *          manager is not installed.
 367  */
 368 JNIEXPORT jclass JNICALL
 369 JVM_FindClassFromCaller(JNIEnv *env, const char *name, jboolean init,
 370                         jobject loader, jclass caller);
 371 
 372 /*
 373  * Find a class from a given class.
 374  */
 375 JNIEXPORT jclass JNICALL
 376 JVM_FindClassFromClass(JNIEnv *env, const char *name, jboolean init,
 377                              jclass from);
 378 
 379 /* Find a loaded class cached by the VM */
 380 JNIEXPORT jclass JNICALL
 381 JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name);
 382 
 383 /* Define a class */
 384 JNIEXPORT jclass JNICALL
 385 JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf,
 386                 jsize len, jobject pd);
 387 
 388 /* Define a class with a source (added in JDK1.5) */
 389 JNIEXPORT jclass JNICALL
 390 JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader,
 391                           const jbyte *buf, jsize len, jobject pd,
 392                           const char *source);
 393 
 394 /*
 395  * Define a class with the specified lookup class.
 396  *  lookup:  Lookup class
 397  *  name:    the name of the class
 398  *  buf:     class bytes
 399  *  len:     length of class bytes
 400  *  pd:      protection domain
 401  *  init:    initialize the class
 402  *  flags:   properties of the class
 403  *  classData: private static pre-initialized field; may be null
 404  */
 405 JNIEXPORT jclass JNICALL
 406 JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,
 407                       jsize len, jobject pd, jboolean init, int flags, jobject classData);
 408 
 409 /*
 410  * Module support funcions
 411  */
 412 
 413 /*
 414  * Define a module with the specified packages and bind the module to the
 415  * given class loader.
 416  *  module:       module to define
 417  *  is_open:      specifies if module is open (currently ignored)
 418  *  version:      the module version
 419  *  location:     the module location
 420  *  packages:     array of packages in the module
 421  */
 422 JNIEXPORT void JNICALL
 423 JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
 424                  jstring location, jobjectArray packages);
 425 
 426 /*
 427  * Set the boot loader&#39;s unnamed module.
 428  *  module: boot loader&#39;s unnamed module
 429  */
 430 JNIEXPORT void JNICALL
 431 JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module);
 432 
 433 /*
 434  * Do a qualified export of a package.
 435  *  from_module: module containing the package to export
 436  *  package:     name of the package to export
 437  *  to_module:   module to export the package to
 438  */
 439 JNIEXPORT void JNICALL
 440 JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module);
 441 
 442 /*
 443  * Do an export of a package to all unnamed modules.
 444  *  from_module: module containing the package to export
 445  *  package:     name of the package to export to all unnamed modules
 446  */
 447 JNIEXPORT void JNICALL
 448 JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package);
 449 
 450 /*
 451  * Do an unqualified export of a package.
 452  *  from_module: module containing the package to export
 453  *  package:     name of the package to export
 454  */
 455 JNIEXPORT void JNICALL
 456 JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package);
 457 
 458 /*
 459  * Add a module to the list of modules that a given module can read.
 460  *  from_module:   module requesting read access
 461  *  source_module: module that from_module wants to read
 462  */
 463 JNIEXPORT void JNICALL
 464 JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module);
 465 
 466 /*
 467  * Reflection support functions
 468  */
 469 
 470 JNIEXPORT jstring JNICALL
 471 JVM_InitClassName(JNIEnv *env, jclass cls);
 472 
 473 JNIEXPORT jobjectArray JNICALL
 474 JVM_GetClassInterfaces(JNIEnv *env, jclass cls);
 475 
 476 JNIEXPORT jboolean JNICALL
 477 JVM_IsInterface(JNIEnv *env, jclass cls);
 478 
 479 JNIEXPORT jobjectArray JNICALL
 480 JVM_GetClassSigners(JNIEnv *env, jclass cls);
 481 
 482 JNIEXPORT void JNICALL
 483 JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers);
 484 
 485 JNIEXPORT jobject JNICALL
 486 JVM_GetProtectionDomain(JNIEnv *env, jclass cls);
 487 
 488 JNIEXPORT jboolean JNICALL
 489 JVM_IsArrayClass(JNIEnv *env, jclass cls);
 490 
 491 JNIEXPORT jboolean JNICALL
 492 JVM_IsPrimitiveClass(JNIEnv *env, jclass cls);
 493 
 494 JNIEXPORT jboolean JNICALL
 495 JVM_IsHiddenClass(JNIEnv *env, jclass cls);
 496 
 497 JNIEXPORT jint JNICALL
 498 JVM_GetClassModifiers(JNIEnv *env, jclass cls);
 499 
 500 JNIEXPORT jobjectArray JNICALL
 501 JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass);
 502 
 503 JNIEXPORT jclass JNICALL
 504 JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass);
 505 
 506 JNIEXPORT jstring JNICALL
 507 JVM_GetSimpleBinaryName(JNIEnv *env, jclass ofClass);
 508 
 509 /* Generics support (JDK 1.5) */
 510 JNIEXPORT jstring JNICALL
 511 JVM_GetClassSignature(JNIEnv *env, jclass cls);
 512 
 513 /* Annotations support (JDK 1.5) */
 514 JNIEXPORT jbyteArray JNICALL
 515 JVM_GetClassAnnotations(JNIEnv *env, jclass cls);
 516 
 517 /* Type use annotations support (JDK 1.8) */
 518 
 519 JNIEXPORT jbyteArray JNICALL
 520 JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls);
 521 
 522 JNIEXPORT jbyteArray JNICALL
 523 JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field);
 524 
 525 JNIEXPORT jbyteArray JNICALL
 526 JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method);
 527 
 528 /*
 529  * New (JDK 1.4) reflection implementation
 530  */
 531 
 532 JNIEXPORT jobjectArray JNICALL
 533 JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 534 
 535 JNIEXPORT jobjectArray JNICALL
 536 JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 537 
 538 JNIEXPORT jobjectArray JNICALL
 539 JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 540 
 541 
 542 /* Differs from JVM_GetClassModifiers in treatment of inner classes.
 543    This returns the access flags for the class as specified in the
 544    class file rather than searching the InnerClasses attribute (if
 545    present) to find the source-level access flags. Only the values of
 546    the low 13 bits (i.e., a mask of 0x1FFF) are guaranteed to be
 547    valid. */
 548 JNIEXPORT jint JNICALL
 549 JVM_GetClassAccessFlags(JNIEnv *env, jclass cls);
 550 
 551 /* Nestmates - since JDK 11 */
 552 
 553 JNIEXPORT jboolean JNICALL
 554 JVM_AreNestMates(JNIEnv *env, jclass current, jclass member);
 555 
 556 JNIEXPORT jclass JNICALL
 557 JVM_GetNestHost(JNIEnv *env, jclass current);
 558 
 559 JNIEXPORT jobjectArray JNICALL
 560 JVM_GetNestMembers(JNIEnv *env, jclass current);
 561 
 562 /* Records - since JDK 14 */
 563 
 564 JNIEXPORT jboolean JNICALL
 565 JVM_IsRecord(JNIEnv *env, jclass cls);
 566 
 567 JNIEXPORT jobjectArray JNICALL
 568 JVM_GetRecordComponents(JNIEnv *env, jclass ofClass);
 569 
<a name="1" id="anc1"></a><span class="line-added"> 570 /* Sealed types - since JDK 15 */</span>
<span class="line-added"> 571 </span>
<span class="line-added"> 572 JNIEXPORT jobjectArray JNICALL</span>
<span class="line-added"> 573 JVM_GetPermittedSubclasses(JNIEnv *env, jclass current);</span>
<span class="line-added"> 574 </span>
 575 /* The following two reflection routines are still needed due to startup time issues */
 576 /*
 577  * java.lang.reflect.Method
 578  */
 579 JNIEXPORT jobject JNICALL
 580 JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0);
 581 
 582 /*
 583  * java.lang.reflect.Constructor
 584  */
 585 JNIEXPORT jobject JNICALL
 586 JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0);
 587 
 588 /*
 589  * Constant pool access; currently used to implement reflective access to annotations (JDK 1.5)
 590  */
 591 
 592 JNIEXPORT jobject JNICALL
 593 JVM_GetClassConstantPool(JNIEnv *env, jclass cls);
 594 
 595 JNIEXPORT jint JNICALL JVM_ConstantPoolGetSize
 596 (JNIEnv *env, jobject unused, jobject jcpool);
 597 
 598 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAt
 599 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 600 
 601 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAtIfLoaded
 602 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 603 
 604 JNIEXPORT jint JNICALL JVM_ConstantPoolGetClassRefIndexAt
 605 (JNIEnv *env, jobject obj, jobject unused, jint index);
 606 
 607 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAt
 608 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 609 
 610 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAtIfLoaded
 611 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 612 
 613 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAt
 614 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 615 
 616 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAtIfLoaded
 617 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 618 
 619 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetMemberRefInfoAt
 620 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 621 
 622 JNIEXPORT jint JNICALL JVM_ConstantPoolGetNameAndTypeRefIndexAt
 623 (JNIEnv *env, jobject obj, jobject unused, jint index);
 624 
 625 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetNameAndTypeRefInfoAt
 626 (JNIEnv *env, jobject obj, jobject unused, jint index);
 627 
 628 JNIEXPORT jint JNICALL JVM_ConstantPoolGetIntAt
 629 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 630 
 631 JNIEXPORT jlong JNICALL JVM_ConstantPoolGetLongAt
 632 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 633 
 634 JNIEXPORT jfloat JNICALL JVM_ConstantPoolGetFloatAt
 635 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 636 
 637 JNIEXPORT jdouble JNICALL JVM_ConstantPoolGetDoubleAt
 638 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 639 
 640 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetStringAt
 641 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 642 
 643 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetUTF8At
 644 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 645 
 646 JNIEXPORT jbyte JNICALL JVM_ConstantPoolGetTagAt
 647 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 648 
 649 /*
 650  * Parameter reflection
 651  */
 652 
 653 JNIEXPORT jobjectArray JNICALL
 654 JVM_GetMethodParameters(JNIEnv *env, jobject method);
 655 
 656 /*
 657  * java.security.*
 658  */
 659 
 660 JNIEXPORT jobject JNICALL
 661 JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls);
 662 
 663 /*
 664  * Ensure that code doing a stackwalk and using javaVFrame::locals() to
 665  * get the value will see a materialized value and not a scalar-replaced
 666  * null value.
 667  */
 668 #define JVM_EnsureMaterializedForStackWalk(env, value) \
 669     do {} while(0) // Nothing to do.  The fact that the value escaped
 670                    // through a native method is enough.
 671 
 672 JNIEXPORT jobject JNICALL
 673 JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls);
 674 
 675 /*
 676  * Signal support, used to implement the shutdown sequence.  Every VM must
 677  * support JVM_SIGINT and JVM_SIGTERM, raising the former for user interrupts
 678  * (^C) and the latter for external termination (kill, system shutdown, etc.).
 679  * Other platform-dependent signal values may also be supported.
 680  */
 681 
 682 JNIEXPORT void * JNICALL
 683 JVM_RegisterSignal(jint sig, void *handler);
 684 
 685 JNIEXPORT jboolean JNICALL
 686 JVM_RaiseSignal(jint sig);
 687 
 688 JNIEXPORT jint JNICALL
 689 JVM_FindSignal(const char *name);
 690 
 691 /*
 692  * Retrieve the assertion directives for the specified class.
 693  */
 694 JNIEXPORT jboolean JNICALL
 695 JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls);
 696 
 697 /*
 698  * Retrieve the assertion directives from the VM.
 699  */
 700 JNIEXPORT jobject JNICALL
 701 JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused);
 702 
 703 /*
 704  * java.util.concurrent.atomic.AtomicLong
 705  */
 706 JNIEXPORT jboolean JNICALL
 707 JVM_SupportsCX8(void);
 708 
 709 /*
 710  * com.sun.dtrace.jsdt support
 711  */
 712 
 713 #define JVM_TRACING_DTRACE_VERSION 1
 714 
 715 /*
 716  * Structure to pass one probe description to JVM
 717  */
 718 typedef struct {
 719     jmethodID method;
 720     jstring   function;
 721     jstring   name;
 722     void*            reserved[4];     // for future use
 723 } JVM_DTraceProbe;
 724 
 725 /**
 726  * Encapsulates the stability ratings for a DTrace provider field
 727  */
 728 typedef struct {
 729     jint nameStability;
 730     jint dataStability;
 731     jint dependencyClass;
 732 } JVM_DTraceInterfaceAttributes;
 733 
 734 /*
 735  * Structure to pass one provider description to JVM
 736  */
 737 typedef struct {
 738     jstring                       name;
 739     JVM_DTraceProbe*              probes;
 740     jint                          probe_count;
 741     JVM_DTraceInterfaceAttributes providerAttributes;
 742     JVM_DTraceInterfaceAttributes moduleAttributes;
 743     JVM_DTraceInterfaceAttributes functionAttributes;
 744     JVM_DTraceInterfaceAttributes nameAttributes;
 745     JVM_DTraceInterfaceAttributes argsAttributes;
 746     void*                         reserved[4]; // for future use
 747 } JVM_DTraceProvider;
 748 
 749 /*
 750  * Get the version number the JVM was built with
 751  */
 752 JNIEXPORT jint JNICALL
 753 JVM_DTraceGetVersion(JNIEnv* env);
 754 
 755 /*
 756  * Register new probe with given signature, return global handle
 757  *
 758  * The version passed in is the version that the library code was
 759  * built with.
 760  */
 761 JNIEXPORT jlong JNICALL
 762 JVM_DTraceActivate(JNIEnv* env, jint version, jstring module_name,
 763   jint providers_count, JVM_DTraceProvider* providers);
 764 
 765 /*
 766  * Check JSDT probe
 767  */
 768 JNIEXPORT jboolean JNICALL
 769 JVM_DTraceIsProbeEnabled(JNIEnv* env, jmethodID method);
 770 
 771 /*
 772  * Destroy custom DOF
 773  */
 774 JNIEXPORT void JNICALL
 775 JVM_DTraceDispose(JNIEnv* env, jlong activation_handle);
 776 
 777 /*
 778  * Check to see if DTrace is supported by OS
 779  */
 780 JNIEXPORT jboolean JNICALL
 781 JVM_DTraceIsSupported(JNIEnv* env);
 782 
 783 /*************************************************************************
 784  PART 2: Support for the Verifier and Class File Format Checker
 785  ************************************************************************/
 786 /*
 787  * Return the class name in UTF format. The result is valid
 788  * until JVM_ReleaseUTf is called.
 789  *
 790  * The caller must treat the string as a constant and not modify it
 791  * in any way.
 792  */
 793 JNIEXPORT const char * JNICALL
 794 JVM_GetClassNameUTF(JNIEnv *env, jclass cb);
 795 
 796 /*
 797  * Returns the constant pool types in the buffer provided by &quot;types.&quot;
 798  */
 799 JNIEXPORT void JNICALL
 800 JVM_GetClassCPTypes(JNIEnv *env, jclass cb, unsigned char *types);
 801 
 802 /*
 803  * Returns the number of Constant Pool entries.
 804  */
 805 JNIEXPORT jint JNICALL
 806 JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cb);
 807 
 808 /*
 809  * Returns the number of *declared* fields or methods.
 810  */
 811 JNIEXPORT jint JNICALL
 812 JVM_GetClassFieldsCount(JNIEnv *env, jclass cb);
 813 
 814 JNIEXPORT jint JNICALL
 815 JVM_GetClassMethodsCount(JNIEnv *env, jclass cb);
 816 
 817 /*
 818  * Returns the CP indexes of exceptions raised by a given method.
 819  * Places the result in the given buffer.
 820  *
 821  * The method is identified by method_index.
 822  */
 823 JNIEXPORT void JNICALL
 824 JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cb, jint method_index,
 825                                 unsigned short *exceptions);
 826 /*
 827  * Returns the number of exceptions raised by a given method.
 828  * The method is identified by method_index.
 829  */
 830 JNIEXPORT jint JNICALL
 831 JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cb, jint method_index);
 832 
 833 /*
 834  * Returns the byte code sequence of a given method.
 835  * Places the result in the given buffer.
 836  *
 837  * The method is identified by method_index.
 838  */
 839 JNIEXPORT void JNICALL
 840 JVM_GetMethodIxByteCode(JNIEnv *env, jclass cb, jint method_index,
 841                         unsigned char *code);
 842 
 843 /*
 844  * Returns the length of the byte code sequence of a given method.
 845  * The method is identified by method_index.
 846  */
 847 JNIEXPORT jint JNICALL
 848 JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cb, jint method_index);
 849 
 850 /*
 851  * A structure used to a capture exception table entry in a Java method.
 852  */
 853 typedef struct {
 854     jint start_pc;
 855     jint end_pc;
 856     jint handler_pc;
 857     jint catchType;
 858 } JVM_ExceptionTableEntryType;
 859 
 860 /*
 861  * Returns the exception table entry at entry_index of a given method.
 862  * Places the result in the given buffer.
 863  *
 864  * The method is identified by method_index.
 865  */
 866 JNIEXPORT void JNICALL
 867 JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cb, jint method_index,
 868                                    jint entry_index,
 869                                    JVM_ExceptionTableEntryType *entry);
 870 
 871 /*
 872  * Returns the length of the exception table of a given method.
 873  * The method is identified by method_index.
 874  */
 875 JNIEXPORT jint JNICALL
 876 JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cb, int index);
 877 
 878 /*
 879  * Returns the modifiers of a given field.
 880  * The field is identified by field_index.
 881  */
 882 JNIEXPORT jint JNICALL
 883 JVM_GetFieldIxModifiers(JNIEnv *env, jclass cb, int index);
 884 
 885 /*
 886  * Returns the modifiers of a given method.
 887  * The method is identified by method_index.
 888  */
 889 JNIEXPORT jint JNICALL
 890 JVM_GetMethodIxModifiers(JNIEnv *env, jclass cb, int index);
 891 
 892 /*
 893  * Returns the number of local variables of a given method.
 894  * The method is identified by method_index.
 895  */
 896 JNIEXPORT jint JNICALL
 897 JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cb, int index);
 898 
 899 /*
 900  * Returns the number of arguments (including this pointer) of a given method.
 901  * The method is identified by method_index.
 902  */
 903 JNIEXPORT jint JNICALL
 904 JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cb, int index);
 905 
 906 /*
 907  * Returns the maximum amount of stack (in words) used by a given method.
 908  * The method is identified by method_index.
 909  */
 910 JNIEXPORT jint JNICALL
 911 JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cb, int index);
 912 
 913 /*
 914  * Is a given method a constructor.
 915  * The method is identified by method_index.
 916  */
 917 JNIEXPORT jboolean JNICALL
 918 JVM_IsConstructorIx(JNIEnv *env, jclass cb, int index);
 919 
 920 /*
 921  * Is the given method generated by the VM.
 922  * The method is identified by method_index.
 923  */
 924 JNIEXPORT jboolean JNICALL
 925 JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cb, int index);
 926 
 927 /*
 928  * Returns the name of a given method in UTF format.
 929  * The result remains valid until JVM_ReleaseUTF is called.
 930  *
 931  * The caller must treat the string as a constant and not modify it
 932  * in any way.
 933  */
 934 JNIEXPORT const char * JNICALL
 935 JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cb, jint index);
 936 
 937 /*
 938  * Returns the signature of a given method in UTF format.
 939  * The result remains valid until JVM_ReleaseUTF is called.
 940  *
 941  * The caller must treat the string as a constant and not modify it
 942  * in any way.
 943  */
 944 JNIEXPORT const char * JNICALL
 945 JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cb, jint index);
 946 
 947 /*
 948  * Returns the name of the field referred to at a given constant pool
 949  * index.
 950  *
 951  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 952  * is called.
 953  *
 954  * The caller must treat the string as a constant and not modify it
 955  * in any way.
 956  */
 957 JNIEXPORT const char * JNICALL
 958 JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cb, jint index);
 959 
 960 /*
 961  * Returns the name of the method referred to at a given constant pool
 962  * index.
 963  *
 964  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 965  * is called.
 966  *
 967  * The caller must treat the string as a constant and not modify it
 968  * in any way.
 969  */
 970 JNIEXPORT const char * JNICALL
 971 JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cb, jint index);
 972 
 973 /*
 974  * Returns the signature of the method referred to at a given constant pool
 975  * index.
 976  *
 977  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 978  * is called.
 979  *
 980  * The caller must treat the string as a constant and not modify it
 981  * in any way.
 982  */
 983 JNIEXPORT const char * JNICALL
 984 JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cb, jint index);
 985 
 986 /*
 987  * Returns the signature of the field referred to at a given constant pool
 988  * index.
 989  *
 990  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 991  * is called.
 992  *
 993  * The caller must treat the string as a constant and not modify it
 994  * in any way.
 995  */
 996 JNIEXPORT const char * JNICALL
 997 JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cb, jint index);
 998 
 999 /*
1000  * Returns the class name referred to at a given constant pool index.
1001  *
1002  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1003  * is called.
1004  *
1005  * The caller must treat the string as a constant and not modify it
1006  * in any way.
1007  */
1008 JNIEXPORT const char * JNICALL
1009 JVM_GetCPClassNameUTF(JNIEnv *env, jclass cb, jint index);
1010 
1011 /*
1012  * Returns the class name referred to at a given constant pool index.
1013  *
1014  * The constant pool entry must refer to a CONSTANT_Fieldref.
1015  *
1016  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1017  * is called.
1018  *
1019  * The caller must treat the string as a constant and not modify it
1020  * in any way.
1021  */
1022 JNIEXPORT const char * JNICALL
1023 JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cb, jint index);
1024 
1025 /*
1026  * Returns the class name referred to at a given constant pool index.
1027  *
1028  * The constant pool entry must refer to CONSTANT_Methodref or
1029  * CONSTANT_InterfaceMethodref.
1030  *
1031  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1032  * is called.
1033  *
1034  * The caller must treat the string as a constant and not modify it
1035  * in any way.
1036  */
1037 JNIEXPORT const char * JNICALL
1038 JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cb, jint index);
1039 
1040 /*
1041  * Returns the modifiers of a field in calledClass. The field is
1042  * referred to in class cb at constant pool entry index.
1043  *
1044  * The caller must treat the string as a constant and not modify it
1045  * in any way.
1046  *
1047  * Returns -1 if the field does not exist in calledClass.
1048  */
1049 JNIEXPORT jint JNICALL
1050 JVM_GetCPFieldModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1051 
1052 /*
1053  * Returns the modifiers of a method in calledClass. The method is
1054  * referred to in class cb at constant pool entry index.
1055  *
1056  * Returns -1 if the method does not exist in calledClass.
1057  */
1058 JNIEXPORT jint JNICALL
1059 JVM_GetCPMethodModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1060 
1061 /*
1062  * Releases the UTF string obtained from the VM.
1063  */
1064 JNIEXPORT void JNICALL
1065 JVM_ReleaseUTF(const char *utf);
1066 
1067 /*
1068  * Compare if two classes are in the same package.
1069  */
1070 JNIEXPORT jboolean JNICALL
1071 JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2);
1072 
1073 /* Get classfile constants */
1074 #include &quot;classfile_constants.h&quot;
1075 
1076 /*
1077  * Support for a VM-independent class format checker.
1078  */
1079 typedef struct {
1080     unsigned long code;    /* byte code */
1081     unsigned long excs;    /* exceptions */
1082     unsigned long etab;    /* catch table */
1083     unsigned long lnum;    /* line number */
1084     unsigned long lvar;    /* local vars */
1085 } method_size_info;
1086 
1087 typedef struct {
1088     unsigned int constants;    /* constant pool */
1089     unsigned int fields;
1090     unsigned int methods;
1091     unsigned int interfaces;
1092     unsigned int fields2;      /* number of static 2-word fields */
1093     unsigned int innerclasses; /* # of records in InnerClasses attr */
1094 
1095     method_size_info clinit;   /* memory used in clinit */
1096     method_size_info main;     /* used everywhere else */
1097 } class_size_info;
1098 
1099 #define JVM_RECOGNIZED_CLASS_MODIFIERS (JVM_ACC_PUBLIC | \
1100                                         JVM_ACC_FINAL | \
1101                                         JVM_ACC_SUPER | \
1102                                         JVM_ACC_INTERFACE | \
1103                                         JVM_ACC_ABSTRACT | \
1104                                         JVM_ACC_ANNOTATION | \
1105                                         JVM_ACC_ENUM | \
1106                                         JVM_ACC_SYNTHETIC)
1107 
1108 #define JVM_RECOGNIZED_FIELD_MODIFIERS (JVM_ACC_PUBLIC | \
1109                                         JVM_ACC_PRIVATE | \
1110                                         JVM_ACC_PROTECTED | \
1111                                         JVM_ACC_STATIC | \
1112                                         JVM_ACC_FINAL | \
1113                                         JVM_ACC_VOLATILE | \
1114                                         JVM_ACC_TRANSIENT | \
1115                                         JVM_ACC_ENUM | \
1116                                         JVM_ACC_SYNTHETIC)
1117 
1118 #define JVM_RECOGNIZED_METHOD_MODIFIERS (JVM_ACC_PUBLIC | \
1119                                          JVM_ACC_PRIVATE | \
1120                                          JVM_ACC_PROTECTED | \
1121                                          JVM_ACC_STATIC | \
1122                                          JVM_ACC_FINAL | \
1123                                          JVM_ACC_SYNCHRONIZED | \
1124                                          JVM_ACC_BRIDGE | \
1125                                          JVM_ACC_VARARGS | \
1126                                          JVM_ACC_NATIVE | \
1127                                          JVM_ACC_ABSTRACT | \
1128                                          JVM_ACC_STRICT | \
1129                                          JVM_ACC_SYNTHETIC)
1130 
1131 
1132 /*************************************************************************
1133  PART 3: I/O and Network Support
1134  ************************************************************************/
1135 
1136 /*
1137  * Convert a pathname into native format.  This function does syntactic
1138  * cleanup, such as removing redundant separator characters.  It modifies
1139  * the given pathname string in place.
1140  */
1141 JNIEXPORT char * JNICALL
1142 JVM_NativePath(char *);
1143 
1144 /*
1145  * The standard printing functions supported by the Java VM. (Should they
1146  * be renamed to JVM_* in the future?
1147  */
1148 
1149 /* jio_snprintf() and jio_vsnprintf() behave like snprintf(3) and vsnprintf(3),
1150  *  respectively, with the following differences:
1151  * - The string written to str is always zero-terminated, also in case of
1152  *   truncation (count is too small to hold the result string), unless count
1153  *   is 0. In case of truncation count-1 characters are written and &#39;\0&#39;
1154  *   appendend.
1155  * - If count is too small to hold the whole string, -1 is returned across
1156  *   all platforms. */
1157 
1158 JNIEXPORT int
1159 jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args);
1160 
1161 JNIEXPORT int
1162 jio_snprintf(char *str, size_t count, const char *fmt, ...);
1163 
1164 JNIEXPORT int
1165 jio_fprintf(FILE *, const char *fmt, ...);
1166 
1167 JNIEXPORT int
1168 jio_vfprintf(FILE *, const char *fmt, va_list args);
1169 
1170 
1171 JNIEXPORT void * JNICALL
1172 JVM_RawMonitorCreate(void);
1173 
1174 JNIEXPORT void JNICALL
1175 JVM_RawMonitorDestroy(void *mon);
1176 
1177 JNIEXPORT jint JNICALL
1178 JVM_RawMonitorEnter(void *mon);
1179 
1180 JNIEXPORT void JNICALL
1181 JVM_RawMonitorExit(void *mon);
1182 
1183 /*
1184  * java.lang.management support
1185  */
1186 JNIEXPORT void* JNICALL
1187 JVM_GetManagement(jint version);
1188 
1189 /*
1190  * com.sun.tools.attach.VirtualMachine support
1191  *
1192  * Initialize the agent properties with the properties maintained in the VM.
1193  */
1194 JNIEXPORT jobject JNICALL
1195 JVM_InitAgentProperties(JNIEnv *env, jobject agent_props);
1196 
1197 JNIEXPORT jstring JNICALL
1198 JVM_GetTemporaryDirectory(JNIEnv *env);
1199 
1200 /* Generics reflection support.
1201  *
1202  * Returns information about the given class&#39;s EnclosingMethod
1203  * attribute, if present, or null if the class had no enclosing
1204  * method.
1205  *
1206  * If non-null, the returned array contains three elements. Element 0
1207  * is the java.lang.Class of which the enclosing method is a member,
1208  * and elements 1 and 2 are the java.lang.Strings for the enclosing
1209  * method&#39;s name and descriptor, respectively.
1210  */
1211 JNIEXPORT jobjectArray JNICALL
1212 JVM_GetEnclosingMethodInfo(JNIEnv* env, jclass ofClass);
1213 
1214 /*
1215  * This structure is used by the launcher to get the default thread
1216  * stack size from the VM using JNI_GetDefaultJavaVMInitArgs() with a
1217  * version of 1.1.  As it is not supported otherwise, it has been removed
1218  * from jni.h
1219  */
1220 typedef struct JDK1_1InitArgs {
1221     jint version;
1222 
1223     char **properties;
1224     jint checkSource;
1225     jint nativeStackSize;
1226     jint javaStackSize;
1227     jint minHeapSize;
1228     jint maxHeapSize;
1229     jint verifyMode;
1230     char *classpath;
1231 
1232     jint (JNICALL *vfprintf)(FILE *fp, const char *format, va_list args);
1233     void (JNICALL *exit)(jint code);
1234     void (JNICALL *abort)(void);
1235 
1236     jint enableClassGC;
1237     jint enableVerboseGC;
1238     jint disableAsyncGC;
1239     jint verbose;
1240     jboolean debugging;
1241     jint debugPort;
1242 } JDK1_1InitArgs;
1243 
1244 
1245 #ifdef __cplusplus
1246 } /* extern &quot;C&quot; */
1247 
1248 #endif /* __cplusplus */
1249 
1250 #endif /* !_JAVASOFT_JVM_H_ */
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
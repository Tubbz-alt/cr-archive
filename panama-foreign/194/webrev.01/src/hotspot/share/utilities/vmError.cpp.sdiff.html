<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/vmError.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="hashtable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/io/ObjectInputStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/vmError.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;code/codeCache.hpp&quot;
  28 #include &quot;compiler/compileBroker.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/gcConfig.hpp&quot;

  31 #include &quot;logging/logConfiguration.hpp&quot;
  32 #include &quot;memory/metaspace.hpp&quot;
  33 #include &quot;memory/metaspaceShared.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;oops/compressedOops.hpp&quot;
  37 #include &quot;prims/whitebox.hpp&quot;
  38 #include &quot;runtime/arguments.hpp&quot;
  39 #include &quot;runtime/atomic.hpp&quot;
  40 #include &quot;runtime/frame.inline.hpp&quot;
  41 #include &quot;runtime/init.hpp&quot;
  42 #include &quot;runtime/os.hpp&quot;
  43 #include &quot;runtime/safepointMechanism.hpp&quot;
  44 #include &quot;runtime/thread.inline.hpp&quot;
  45 #include &quot;runtime/threadSMR.hpp&quot;
  46 #include &quot;runtime/vmThread.hpp&quot;
  47 #include &quot;runtime/vmOperations.hpp&quot;
  48 #include &quot;runtime/vm_version.hpp&quot;
  49 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  50 #include &quot;services/memTracker.hpp&quot;
</pre>
<hr />
<pre>
 759   STEP(&quot;printing siginfo&quot;)
 760 
 761      // signal no, signal code, address that caused the fault
 762      if (_verbose &amp;&amp; _siginfo) {
 763        st-&gt;cr();
 764        os::print_siginfo(st, _siginfo);
 765        st-&gt;cr();
 766      }
 767 
 768   STEP(&quot;CDS archive access warning&quot;)
 769 
 770      // Print an explicit hint if we crashed on access to the CDS archive.
 771      if (_verbose &amp;&amp; _siginfo) {
 772        check_failing_cds_access(st, _siginfo);
 773        st-&gt;cr();
 774      }
 775 
 776   STEP(&quot;printing register info&quot;)
 777 
 778      // decode register contents if possible
<span class="line-modified"> 779      if (_verbose &amp;&amp; _context &amp;&amp; Universe::is_fully_initialized()) {</span>

 780        os::print_register_info(st, _context);
 781        st-&gt;cr();
 782      }
 783 
 784   STEP(&quot;printing registers, top of stack, instructions near pc&quot;)
 785 
 786      // registers, top of stack, instructions near pc
 787      if (_verbose &amp;&amp; _context) {
 788        os::print_context(st, _context);
 789        st-&gt;cr();
 790      }
 791 
 792   STEP(&quot;inspecting top of stack&quot;)
 793 
 794      // decode stack contents if possible
<span class="line-modified"> 795      if (_verbose &amp;&amp; _context &amp;&amp; Universe::is_fully_initialized()) {</span>
 796        frame fr = os::fetch_frame_from_context(_context);
 797        const int slots = 8;
 798        const intptr_t *start = fr.sp();
 799        const intptr_t *end = start + slots;
 800        if (is_aligned(start, sizeof(intptr_t)) &amp;&amp; os::is_readable_range(start, end)) {
 801          st-&gt;print_cr(&quot;Stack slot to memory mapping:&quot;);
 802          for (int i = 0; i &lt; slots; ++i) {
 803            st-&gt;print(&quot;stack at sp + %d slots: &quot;, i);

 804            os::print_location(st, *(start + i));
 805          }
 806        }
 807        st-&gt;cr();
 808      }
 809 
 810   STEP(&quot;printing code blob if possible&quot;)
 811 
 812      if (_verbose &amp;&amp; _context) {
 813        CodeBlob* cb = CodeCache::find_blob(_pc);
 814        if (cb != NULL) {
 815          if (Interpreter::contains(_pc)) {
 816            // The interpreter CodeBlob is very large so try to print the codelet instead.
 817            InterpreterCodelet* codelet = Interpreter::codelet_containing(_pc);
 818            if (codelet != NULL) {
 819              codelet-&gt;print_on(st);
 820              Disassembler::decode(codelet-&gt;code_begin(), codelet-&gt;code_end(), st);
 821            }
 822          } else {
 823            StubCodeDesc* desc = StubCodeDesc::desc_for(_pc);
</pre>
<hr />
<pre>
 908        Exceptions::print_exception_counts_on_error(st);
 909        st-&gt;cr();
 910      }
 911 
 912 #ifdef _LP64
 913   STEP(&quot;printing compressed oops mode&quot;)
 914 
 915      if (_verbose &amp;&amp; UseCompressedOops) {
 916        CompressedOops::print_mode(st);
 917        if (UseCompressedClassPointers) {
 918          CDS_ONLY(MetaspaceShared::print_on(st);)
 919          Metaspace::print_compressed_class_space(st);
 920          CompressedKlassPointers::print_mode(st);
 921        }
 922        st-&gt;cr();
 923      }
 924 #endif
 925 
 926   STEP(&quot;printing heap information&quot;)
 927 
<span class="line-modified"> 928      if (_verbose &amp;&amp; Universe::is_fully_initialized()) {</span>
<span class="line-modified"> 929        Universe::heap()-&gt;print_on_error(st);</span>
<span class="line-modified"> 930        st-&gt;cr();</span>
<span class="line-modified"> 931        st-&gt;print_cr(&quot;Polling page: &quot; INTPTR_FORMAT, p2i(SafepointMechanism::get_polling_page()));</span>
<span class="line-modified"> 932        st-&gt;cr();</span>







 933      }
 934 
 935   STEP(&quot;printing metaspace information&quot;)
 936 
 937      if (_verbose &amp;&amp; Universe::is_fully_initialized()) {
 938        st-&gt;print_cr(&quot;Metaspace:&quot;);
 939        MetaspaceUtils::print_basic_report(st, 0);
 940      }
 941 
 942   STEP(&quot;printing code cache information&quot;)
 943 
 944      if (_verbose &amp;&amp; Universe::is_fully_initialized()) {
 945        // print code cache information before vm abort
 946        CodeCache::print_summary(st);
 947        st-&gt;cr();
 948      }
 949 
 950   STEP(&quot;printing ring buffers&quot;)
 951 
 952      if (_verbose) {
</pre>
<hr />
<pre>
1114     st-&gt;cr();
1115   }
1116 
1117 #ifdef _LP64
1118   // STEP(&quot;printing compressed oops mode&quot;)
1119   if (UseCompressedOops) {
1120     CompressedOops::print_mode(st);
1121     if (UseCompressedClassPointers) {
1122       CDS_ONLY(MetaspaceShared::print_on(st);)
1123       Metaspace::print_compressed_class_space(st);
1124       CompressedKlassPointers::print_mode(st);
1125     }
1126     st-&gt;cr();
1127   }
1128 #endif
1129 
1130   // STEP(&quot;printing heap information&quot;)
1131 
1132   if (Universe::is_fully_initialized()) {
1133     MutexLocker hl(Heap_lock);

1134     Universe::heap()-&gt;print_on_error(st);
1135     st-&gt;cr();
1136     st-&gt;print_cr(&quot;Polling page: &quot; INTPTR_FORMAT, p2i(SafepointMechanism::get_polling_page()));
1137     st-&gt;cr();
1138   }
1139 
1140   // STEP(&quot;printing metaspace information&quot;)
1141 
1142   if (Universe::is_fully_initialized()) {
1143     st-&gt;print_cr(&quot;Metaspace:&quot;);
1144     MetaspaceUtils::print_basic_report(st, 0);
1145   }
1146 
1147   // STEP(&quot;printing code cache information&quot;)
1148 
1149   if (Universe::is_fully_initialized()) {
1150     // print code cache information before vm abort
1151     CodeCache::print_summary(st);
1152     st-&gt;cr();
1153   }
</pre>
<hr />
<pre>
1720   if (step_start_time_l &gt; 0) {
1721     // A step times out after a quarter of the total timeout. Steps are mostly fast unless they
1722     // hang for some reason, so this simple rule allows for three hanging step and still
1723     // hopefully leaves time enough for the rest of the steps to finish.
1724     const jlong end = step_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR / 4;
1725     if (end &lt;= now &amp;&amp; !_step_did_timeout) {
1726       // The step timed out and we haven&#39;t interrupted the reporting
1727       // thread yet.
1728       _step_did_timeout = true;
1729       interrupt_reporting_thread();
1730       return false; // (Not a global timeout)
1731     }
1732   }
1733 
1734   return false;
1735 
1736 }
1737 
1738 #ifndef PRODUCT
1739 typedef void (*voidfun_t)();

1740 // Crash with an authentic sigfpe

1741 static void crash_with_sigfpe() {

1742   // generate a native synchronous SIGFPE where possible;


1743   // if that did not cause a signal (e.g. on ppc), just
1744   // raise the signal.
<span class="line-removed">1745   volatile int x = 0;</span>
<span class="line-removed">1746   volatile int y = 1/x;</span>
1747 #ifndef _WIN32
1748   // OSX implements raise(sig) incorrectly so we need to
1749   // explicitly target the current thread
1750   pthread_kill(pthread_self(), SIGFPE);
1751 #endif

1752 } // end: crash_with_sigfpe
1753 
1754 // crash with sigsegv at non-null address.
1755 static void crash_with_segfault() {
1756 
1757   char* const crash_addr = (char*) VMError::get_segfault_address();
1758   *crash_addr = &#39;X&#39;;
1759 
1760 } // end: crash_with_segfault
1761 
1762 void VMError::test_error_handler() {
1763   controlled_crash(ErrorHandlerTest);
1764 }
1765 
1766 // crash in a controlled way:
1767 // how can be one of:
1768 // 1,2 - asserts
1769 // 3,4 - guarantee
1770 // 5-7 - fatal
1771 // 8 - vm_exit_out_of_memory
</pre>
</td>
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;code/codeCache.hpp&quot;
  28 #include &quot;compiler/compileBroker.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/gcConfig.hpp&quot;
<span class="line-added">  31 #include &quot;gc/shared/gcLogPrecious.hpp&quot;</span>
  32 #include &quot;logging/logConfiguration.hpp&quot;
  33 #include &quot;memory/metaspace.hpp&quot;
  34 #include &quot;memory/metaspaceShared.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;memory/universe.hpp&quot;
  37 #include &quot;oops/compressedOops.hpp&quot;
  38 #include &quot;prims/whitebox.hpp&quot;
  39 #include &quot;runtime/arguments.hpp&quot;
  40 #include &quot;runtime/atomic.hpp&quot;
  41 #include &quot;runtime/frame.inline.hpp&quot;
  42 #include &quot;runtime/init.hpp&quot;
  43 #include &quot;runtime/os.hpp&quot;
  44 #include &quot;runtime/safepointMechanism.hpp&quot;
  45 #include &quot;runtime/thread.inline.hpp&quot;
  46 #include &quot;runtime/threadSMR.hpp&quot;
  47 #include &quot;runtime/vmThread.hpp&quot;
  48 #include &quot;runtime/vmOperations.hpp&quot;
  49 #include &quot;runtime/vm_version.hpp&quot;
  50 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  51 #include &quot;services/memTracker.hpp&quot;
</pre>
<hr />
<pre>
 760   STEP(&quot;printing siginfo&quot;)
 761 
 762      // signal no, signal code, address that caused the fault
 763      if (_verbose &amp;&amp; _siginfo) {
 764        st-&gt;cr();
 765        os::print_siginfo(st, _siginfo);
 766        st-&gt;cr();
 767      }
 768 
 769   STEP(&quot;CDS archive access warning&quot;)
 770 
 771      // Print an explicit hint if we crashed on access to the CDS archive.
 772      if (_verbose &amp;&amp; _siginfo) {
 773        check_failing_cds_access(st, _siginfo);
 774        st-&gt;cr();
 775      }
 776 
 777   STEP(&quot;printing register info&quot;)
 778 
 779      // decode register contents if possible
<span class="line-modified"> 780      if (_verbose &amp;&amp; _context &amp;&amp; _thread &amp;&amp; Universe::is_fully_initialized()) {</span>
<span class="line-added"> 781        ResourceMark rm(_thread);</span>
 782        os::print_register_info(st, _context);
 783        st-&gt;cr();
 784      }
 785 
 786   STEP(&quot;printing registers, top of stack, instructions near pc&quot;)
 787 
 788      // registers, top of stack, instructions near pc
 789      if (_verbose &amp;&amp; _context) {
 790        os::print_context(st, _context);
 791        st-&gt;cr();
 792      }
 793 
 794   STEP(&quot;inspecting top of stack&quot;)
 795 
 796      // decode stack contents if possible
<span class="line-modified"> 797      if (_verbose &amp;&amp; _context &amp;&amp; _thread &amp;&amp; Universe::is_fully_initialized()) {</span>
 798        frame fr = os::fetch_frame_from_context(_context);
 799        const int slots = 8;
 800        const intptr_t *start = fr.sp();
 801        const intptr_t *end = start + slots;
 802        if (is_aligned(start, sizeof(intptr_t)) &amp;&amp; os::is_readable_range(start, end)) {
 803          st-&gt;print_cr(&quot;Stack slot to memory mapping:&quot;);
 804          for (int i = 0; i &lt; slots; ++i) {
 805            st-&gt;print(&quot;stack at sp + %d slots: &quot;, i);
<span class="line-added"> 806            ResourceMark rm(_thread);</span>
 807            os::print_location(st, *(start + i));
 808          }
 809        }
 810        st-&gt;cr();
 811      }
 812 
 813   STEP(&quot;printing code blob if possible&quot;)
 814 
 815      if (_verbose &amp;&amp; _context) {
 816        CodeBlob* cb = CodeCache::find_blob(_pc);
 817        if (cb != NULL) {
 818          if (Interpreter::contains(_pc)) {
 819            // The interpreter CodeBlob is very large so try to print the codelet instead.
 820            InterpreterCodelet* codelet = Interpreter::codelet_containing(_pc);
 821            if (codelet != NULL) {
 822              codelet-&gt;print_on(st);
 823              Disassembler::decode(codelet-&gt;code_begin(), codelet-&gt;code_end(), st);
 824            }
 825          } else {
 826            StubCodeDesc* desc = StubCodeDesc::desc_for(_pc);
</pre>
<hr />
<pre>
 911        Exceptions::print_exception_counts_on_error(st);
 912        st-&gt;cr();
 913      }
 914 
 915 #ifdef _LP64
 916   STEP(&quot;printing compressed oops mode&quot;)
 917 
 918      if (_verbose &amp;&amp; UseCompressedOops) {
 919        CompressedOops::print_mode(st);
 920        if (UseCompressedClassPointers) {
 921          CDS_ONLY(MetaspaceShared::print_on(st);)
 922          Metaspace::print_compressed_class_space(st);
 923          CompressedKlassPointers::print_mode(st);
 924        }
 925        st-&gt;cr();
 926      }
 927 #endif
 928 
 929   STEP(&quot;printing heap information&quot;)
 930 
<span class="line-modified"> 931      if (_verbose) {</span>
<span class="line-modified"> 932        GCLogPrecious::print_on_error(st);</span>
<span class="line-modified"> 933 </span>
<span class="line-modified"> 934        if (Universe::heap() != NULL) {</span>
<span class="line-modified"> 935          Universe::heap()-&gt;print_on_error(st);</span>
<span class="line-added"> 936          st-&gt;cr();</span>
<span class="line-added"> 937        }</span>
<span class="line-added"> 938 </span>
<span class="line-added"> 939        if (Universe::is_fully_initialized()) {</span>
<span class="line-added"> 940          st-&gt;print_cr(&quot;Polling page: &quot; INTPTR_FORMAT, p2i(SafepointMechanism::get_polling_page()));</span>
<span class="line-added"> 941          st-&gt;cr();</span>
<span class="line-added"> 942        }</span>
 943      }
 944 
 945   STEP(&quot;printing metaspace information&quot;)
 946 
 947      if (_verbose &amp;&amp; Universe::is_fully_initialized()) {
 948        st-&gt;print_cr(&quot;Metaspace:&quot;);
 949        MetaspaceUtils::print_basic_report(st, 0);
 950      }
 951 
 952   STEP(&quot;printing code cache information&quot;)
 953 
 954      if (_verbose &amp;&amp; Universe::is_fully_initialized()) {
 955        // print code cache information before vm abort
 956        CodeCache::print_summary(st);
 957        st-&gt;cr();
 958      }
 959 
 960   STEP(&quot;printing ring buffers&quot;)
 961 
 962      if (_verbose) {
</pre>
<hr />
<pre>
1124     st-&gt;cr();
1125   }
1126 
1127 #ifdef _LP64
1128   // STEP(&quot;printing compressed oops mode&quot;)
1129   if (UseCompressedOops) {
1130     CompressedOops::print_mode(st);
1131     if (UseCompressedClassPointers) {
1132       CDS_ONLY(MetaspaceShared::print_on(st);)
1133       Metaspace::print_compressed_class_space(st);
1134       CompressedKlassPointers::print_mode(st);
1135     }
1136     st-&gt;cr();
1137   }
1138 #endif
1139 
1140   // STEP(&quot;printing heap information&quot;)
1141 
1142   if (Universe::is_fully_initialized()) {
1143     MutexLocker hl(Heap_lock);
<span class="line-added">1144     GCLogPrecious::print_on_error(st);</span>
1145     Universe::heap()-&gt;print_on_error(st);
1146     st-&gt;cr();
1147     st-&gt;print_cr(&quot;Polling page: &quot; INTPTR_FORMAT, p2i(SafepointMechanism::get_polling_page()));
1148     st-&gt;cr();
1149   }
1150 
1151   // STEP(&quot;printing metaspace information&quot;)
1152 
1153   if (Universe::is_fully_initialized()) {
1154     st-&gt;print_cr(&quot;Metaspace:&quot;);
1155     MetaspaceUtils::print_basic_report(st, 0);
1156   }
1157 
1158   // STEP(&quot;printing code cache information&quot;)
1159 
1160   if (Universe::is_fully_initialized()) {
1161     // print code cache information before vm abort
1162     CodeCache::print_summary(st);
1163     st-&gt;cr();
1164   }
</pre>
<hr />
<pre>
1731   if (step_start_time_l &gt; 0) {
1732     // A step times out after a quarter of the total timeout. Steps are mostly fast unless they
1733     // hang for some reason, so this simple rule allows for three hanging step and still
1734     // hopefully leaves time enough for the rest of the steps to finish.
1735     const jlong end = step_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR / 4;
1736     if (end &lt;= now &amp;&amp; !_step_did_timeout) {
1737       // The step timed out and we haven&#39;t interrupted the reporting
1738       // thread yet.
1739       _step_did_timeout = true;
1740       interrupt_reporting_thread();
1741       return false; // (Not a global timeout)
1742     }
1743   }
1744 
1745   return false;
1746 
1747 }
1748 
1749 #ifndef PRODUCT
1750 typedef void (*voidfun_t)();
<span class="line-added">1751 </span>
1752 // Crash with an authentic sigfpe
<span class="line-added">1753 volatile int sigfpe_int = 0;</span>
1754 static void crash_with_sigfpe() {
<span class="line-added">1755 </span>
1756   // generate a native synchronous SIGFPE where possible;
<span class="line-added">1757   sigfpe_int = sigfpe_int/sigfpe_int;</span>
<span class="line-added">1758 </span>
1759   // if that did not cause a signal (e.g. on ppc), just
1760   // raise the signal.


1761 #ifndef _WIN32
1762   // OSX implements raise(sig) incorrectly so we need to
1763   // explicitly target the current thread
1764   pthread_kill(pthread_self(), SIGFPE);
1765 #endif
<span class="line-added">1766 </span>
1767 } // end: crash_with_sigfpe
1768 
1769 // crash with sigsegv at non-null address.
1770 static void crash_with_segfault() {
1771 
1772   char* const crash_addr = (char*) VMError::get_segfault_address();
1773   *crash_addr = &#39;X&#39;;
1774 
1775 } // end: crash_with_segfault
1776 
1777 void VMError::test_error_handler() {
1778   controlled_crash(ErrorHandlerTest);
1779 }
1780 
1781 // crash in a controlled way:
1782 // how can be one of:
1783 // 1,2 - asserts
1784 // 3,4 - guarantee
1785 // 5-7 - fatal
1786 // 8 - vm_exit_out_of_memory
</pre>
</td>
</tr>
</table>
<center><a href="hashtable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/io/ObjectInputStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
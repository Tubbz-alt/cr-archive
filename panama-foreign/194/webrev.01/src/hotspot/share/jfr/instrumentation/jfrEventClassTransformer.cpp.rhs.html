<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/instrumentation/jfrEventClassTransformer.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/moduleEntry.hpp&quot;
  31 #include &quot;classfile/modules.hpp&quot;
  32 #include &quot;classfile/stackMapTable.hpp&quot;
  33 #include &quot;classfile/symbolTable.hpp&quot;
  34 #include &quot;classfile/verificationType.hpp&quot;
  35 #include &quot;interpreter/bytecodes.hpp&quot;
  36 #include &quot;jfr/instrumentation/jfrEventClassTransformer.hpp&quot;
  37 #include &quot;jfr/jfr.hpp&quot;
  38 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
  39 #include &quot;jfr/jni/jfrUpcalls.hpp&quot;
  40 #include &quot;jfr/support/jfrEventClass.hpp&quot;
  41 #include &quot;jfr/utilities/jfrBigEndian.hpp&quot;
  42 #include &quot;jfr/writers/jfrBigEndianWriter.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/allocation.inline.hpp&quot;
  45 #include &quot;memory/resourceArea.hpp&quot;
  46 #include &quot;oops/array.hpp&quot;
  47 #include &quot;oops/instanceKlass.hpp&quot;
  48 #include &quot;oops/method.hpp&quot;
  49 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  50 #include &quot;runtime/handles.inline.hpp&quot;
  51 #include &quot;runtime/os.hpp&quot;
  52 #include &quot;runtime/thread.inline.hpp&quot;
  53 #include &quot;utilities/exceptions.hpp&quot;
  54 #include &quot;utilities/globalDefinitions.hpp&quot;
  55 #include &quot;utilities/macros.hpp&quot;
  56 
  57 static const u2 number_of_new_methods = 5;
  58 static const u2 number_of_new_fields = 3;
  59 static const int extra_stream_bytes = 0x280;
  60 static const u2 invalid_cp_index = 0;
  61 
  62 static const char* utf8_constants[] = {
  63   &quot;Code&quot;,         // 0
  64   &quot;J&quot;,            // 1
  65   &quot;commit&quot;,       // 2
  66   &quot;eventHandler&quot;, // 3
  67   &quot;duration&quot;,     // 4
  68   &quot;begin&quot;,        // 5
  69   &quot;()V&quot;,          // 6
  70   &quot;isEnabled&quot;,    // 7
  71   &quot;()Z&quot;,          // 8
  72   &quot;end&quot;,          // 9
  73   &quot;shouldCommit&quot;, // 10
  74   &quot;startTime&quot;,    // 11 // LAST_REQUIRED_UTF8
  75   &quot;Ljdk/jfr/internal/handlers/EventHandler;&quot;, // 12
  76   &quot;Ljava/lang/Object;&quot;, // 13
  77   &quot;&lt;clinit&gt;&quot;,     // 14
  78   &quot;jdk/jfr/FlightRecorder&quot;, // 15
  79   &quot;register&quot;,     // 16
  80   &quot;(Ljava/lang/Class;)V&quot;, // 17
  81   &quot;StackMapTable&quot;, // 18
  82   &quot;Exceptions&quot;, // 19
  83   &quot;LineNumberTable&quot;, // 20
  84   &quot;LocalVariableTable&quot;, // 21
  85   &quot;LocalVariableTypeTable&quot;, // 22
  86   &quot;RuntimeVisibleAnnotation&quot;, // 23
  87 };
  88 
  89 enum utf8_req_symbols {
  90   UTF8_REQ_Code,
  91   UTF8_REQ_J_FIELD_DESC,
  92   UTF8_REQ_commit,
  93   UTF8_REQ_eventHandler,
  94   UTF8_REQ_duration,
  95   UTF8_REQ_begin,
  96   UTF8_REQ_EMPTY_VOID_METHOD_DESC,
  97   UTF8_REQ_isEnabled,
  98   UTF8_REQ_EMPTY_BOOLEAN_METHOD_DESC,
  99   UTF8_REQ_end,
 100   UTF8_REQ_shouldCommit,
 101   UTF8_REQ_startTime,
 102   NOF_UTF8_REQ_SYMBOLS
 103 };
 104 
 105 enum utf8_opt_symbols {
 106   UTF8_OPT_eventHandler_FIELD_DESC = NOF_UTF8_REQ_SYMBOLS,
 107   UTF8_OPT_LjavaLangObject,
 108   UTF8_OPT_clinit,
 109   UTF8_OPT_FlightRecorder,
 110   UTF8_OPT_register,
 111   UTF8_OPT_CLASS_VOID_METHOD_DESC,
 112   UTF8_OPT_StackMapTable,
 113   UTF8_OPT_Exceptions,
 114   UTF8_OPT_LineNumberTable,
 115   UTF8_OPT_LocalVariableTable,
 116   UTF8_OPT_LocalVariableTypeTable,
 117   UTF8_OPT_RuntimeVisibleAnnotation,
 118   NOF_UTF8_SYMBOLS
 119 };
 120 
 121 static u1 empty_void_method_code_attribute[] = {
 122   0x0,
 123   0x0,
 124   0x0,
 125   0xd, // attribute len
 126   0x0,
 127   0x0, // max stack
 128   0x0,
 129   0x1, // max locals
 130   0x0,
 131   0x0,
 132   0x0,
 133   0x1, // code length
 134   Bytecodes::_return,
 135   0x0,
 136   0x0, // ex table len
 137   0x0,
 138   0x0  // attributes_count
 139 };
 140 
 141 static u1 boolean_method_code_attribute[] = {
 142   0x0,
 143   0x0,
 144   0x0,
 145   0xe,
 146   0x0,
 147   0x1, // max stack
 148   0x0,
 149   0x1, // max locals
 150   0x0,
 151   0x0,
 152   0x0,
 153   0x2,
 154   Bytecodes::_iconst_0,
 155   Bytecodes::_ireturn,
 156   0x0,
 157   0x0, // ex table len
 158   0x0,
 159   0x0, // attributes_count
 160 };
 161 
 162 // annotation processing support
 163 
 164 enum {  // initial annotation layout
 165   atype_off = 0,      // utf8 such as &#39;Ljava/lang/annotation/Retention;&#39;
 166   count_off = 2,      // u2   such as 1 (one value)
 167   member_off = 4,     // utf8 such as &#39;value&#39;
 168   tag_off = 6,        // u1   such as &#39;c&#39; (type) or &#39;e&#39; (enum)
 169   e_tag_val = &#39;e&#39;,
 170   e_type_off = 7,   // utf8 such as &#39;Ljava/lang/annotation/RetentionPolicy;&#39;
 171   e_con_off = 9,    // utf8 payload, such as &#39;SOURCE&#39;, &#39;CLASS&#39;, &#39;RUNTIME&#39;
 172   e_size = 11,     // end of &#39;e&#39; annotation
 173   c_tag_val = &#39;c&#39;,    // payload is type
 174   c_con_off = 7,    // utf8 payload, such as &#39;I&#39;
 175   c_size = 9,       // end of &#39;c&#39; annotation
 176   s_tag_val = &#39;s&#39;,    // payload is String
 177   s_con_off = 7,    // utf8 payload, such as &#39;Ljava/lang/String;&#39;
 178   s_size = 9,
 179   min_size = 6        // smallest possible size (zero members)
 180 };
 181 
 182 static int skip_annotation_value(const address, int, int); // fwd decl
 183 
 184 // Skip an annotation.  Return &gt;=limit if there is any problem.
 185 static int next_annotation_index(const address buffer, int limit, int index) {
 186   assert(buffer != NULL, &quot;invariant&quot;);
 187   index += 2;  // skip atype
 188   if ((index += 2) &gt;= limit) {
 189     return limit;
 190   }
 191   int nof_members = JfrBigEndian::read&lt;u2&gt;(buffer + index - 2);
 192   while (--nof_members &gt;= 0 &amp;&amp; index &lt; limit) {
 193     index += 2; // skip member
 194     index = skip_annotation_value(buffer, limit, index);
 195   }
 196   return index;
 197 }
 198 
 199 // Skip an annotation value.  Return &gt;=limit if there is any problem.
 200 static int skip_annotation_value(const address buffer, int limit, int index) {
 201   assert(buffer != NULL, &quot;invariant&quot;);
 202   // value := switch (tag:u1) {
 203   //   case B, C, I, S, Z, D, F, J, c: con:u2;
 204   //   case e: e_class:u2 e_name:u2;
 205   //   case s: s_con:u2;
 206   //   case [: do(nval:u2) {value};
 207   //   case @: annotation;
 208   //   case s: s_con:u2;
 209   // }
 210   if ((index += 1) &gt;= limit) {
 211     return limit;
 212   }
 213   const u1 tag = buffer[index - 1];
 214   switch (tag) {
 215     case &#39;B&#39;:
 216     case &#39;C&#39;:
 217     case &#39;I&#39;:
 218     case &#39;S&#39;:
 219     case &#39;Z&#39;:
 220     case &#39;D&#39;:
 221     case &#39;F&#39;:
 222     case &#39;J&#39;:
 223     case &#39;c&#39;:
 224     case &#39;s&#39;:
 225       index += 2;  // skip con or s_con
 226       break;
 227     case &#39;e&#39;:
 228       index += 4;  // skip e_class, e_name
 229       break;
 230     case &#39;[&#39;:
 231       {
 232         if ((index += 2) &gt;= limit) {
 233           return limit;
 234         }
 235         int nof_values = JfrBigEndian::read&lt;u2&gt;(buffer + index - 2);
 236         while (--nof_values &gt;= 0 &amp;&amp; index &lt; limit) {
 237           index = skip_annotation_value(buffer, limit, index);
 238         }
 239       }
 240       break;
 241     case &#39;@&#39;:
 242       index = next_annotation_index(buffer, limit, index);
 243       break;
 244     default:
 245       return limit;  //  bad tag byte
 246   }
 247   return index;
 248 }
 249 
 250 static const u2 number_of_elements_offset = (u2)2;
 251 static const u2 element_name_offset = (u2)(number_of_elements_offset + 2);
 252 static const u2 element_name_size = (u2)2;
 253 static const u2 value_type_relative_offset = (u2)2;
 254 static const u2 value_relative_offset = (u2)(value_type_relative_offset + 1);
 255 
 256 // see JVMS - 4.7.16. The RuntimeVisibleAnnotations Attribute
 257 
 258 class AnnotationElementIterator : public StackObj {
 259  private:
 260   const InstanceKlass* _ik;
 261   const address _buffer;
 262   const u2 _limit; // length of annotation
 263   mutable u2 _current; // element
 264   mutable u2 _next; // element
 265   u2 value_index() const {
 266     return JfrBigEndian::read&lt;u2&gt;(_buffer + _current + value_relative_offset);
 267   }
 268 
 269  public:
 270   AnnotationElementIterator(const InstanceKlass* ik, address buffer, u2 limit) : _ik(ik),
 271                                                                                  _buffer(buffer),
 272                                                                                  _limit(limit),
 273                                                                                  _current(element_name_offset),
 274                                                                                  _next(element_name_offset) {
 275     assert(_buffer != NULL, &quot;invariant&quot;);
 276     assert(_next == element_name_offset, &quot;invariant&quot;);
 277     assert(_current == element_name_offset, &quot;invariant&quot;);
 278   }
 279 
 280   bool has_next() const {
 281     return _next &lt; _limit;
 282   }
 283 
 284   void move_to_next() const {
 285     assert(has_next(), &quot;invariant&quot;);
 286     _current = _next;
 287     if (_next &lt; _limit) {
 288       _next = skip_annotation_value(_buffer, _limit, _next + element_name_size);
 289     }
 290     assert(_next &lt;= _limit, &quot;invariant&quot;);
 291     assert(_current &lt;= _limit, &quot;invariant&quot;);
 292   }
 293 
 294   u2 number_of_elements() const {
 295     return JfrBigEndian::read&lt;u2&gt;(_buffer + number_of_elements_offset);
 296   }
 297 
 298   const Symbol* name() const {
 299     assert(_current &lt; _next, &quot;invariant&quot;);
 300     return _ik-&gt;constants()-&gt;symbol_at(JfrBigEndian::read&lt;u2&gt;(_buffer + _current));
 301   }
 302 
 303   char value_type() const {
 304     return JfrBigEndian::read&lt;u1&gt;(_buffer + _current + value_type_relative_offset);
 305   }
 306 
 307   jint read_int() const {
 308     return _ik-&gt;constants()-&gt;int_at(value_index());
 309   }
 310 
 311   bool read_bool() const {
 312     return read_int() != 0;
 313   }
 314 };
 315 
 316 class AnnotationIterator : public StackObj {
 317  private:
 318   const InstanceKlass* _ik;
 319   // ensure _limit field is declared before _buffer
 320   u2 _limit; // length of annotations array
 321   const address _buffer;
 322   mutable u2 _current; // annotation
 323   mutable u2 _next; // annotation
 324 
 325  public:
 326   AnnotationIterator(const InstanceKlass* ik, AnnotationArray* ar) : _ik(ik),
 327                                                                      _limit(ar != NULL ? ar-&gt;length() : 0),
 328                                                                      _buffer(_limit &gt; 2 ? ar-&gt;adr_at(2) : NULL),
 329                                                                      _current(0),
 330                                                                      _next(0) {
 331     if (_buffer != NULL) {
 332       _limit -= 2; // subtract sizeof(u2) number of annotations field
 333     }
 334   }
 335   bool has_next() const {
 336     return _next &lt; _limit;
 337   }
 338 
 339   void move_to_next() const {
 340     assert(has_next(), &quot;invariant&quot;);
 341     _current = _next;
 342     if (_next &lt; _limit) {
 343       _next = next_annotation_index(_buffer, _limit, _next);
 344     }
 345     assert(_next &lt;= _limit, &quot;invariant&quot;);
 346     assert(_current &lt;= _limit, &quot;invariant&quot;);
 347   }
 348   const AnnotationElementIterator elements() const {
 349     assert(_current &lt; _next, &quot;invariant&quot;);
 350     return AnnotationElementIterator(_ik, _buffer + _current, _next - _current);
 351   }
 352   const Symbol* type() const {
 353     assert(_buffer != NULL, &quot;invariant&quot;);
 354     assert(_current &lt; _limit, &quot;invariant&quot;);
 355     return _ik-&gt;constants()-&gt;symbol_at(JfrBigEndian::read&lt;u2&gt;(_buffer + _current));
 356   }
 357 };
 358 
 359 static const char value_name[] = &quot;value&quot;;
 360 static bool has_annotation(const InstanceKlass* ik, const Symbol* annotation_type, bool&amp; value) {
 361   assert(annotation_type != NULL, &quot;invariant&quot;);
 362   AnnotationArray* class_annotations = ik-&gt;class_annotations();
 363   if (class_annotations == NULL) {
 364     return false;
 365   }
 366 
 367   const AnnotationIterator annotation_iterator(ik, class_annotations);
 368   while (annotation_iterator.has_next()) {
 369     annotation_iterator.move_to_next();
 370     if (annotation_iterator.type() == annotation_type) {
 371       // target annotation found
 372       static const Symbol* value_symbol =
 373         SymbolTable::probe(value_name, sizeof value_name - 1);
 374       assert(value_symbol != NULL, &quot;invariant&quot;);
 375       const AnnotationElementIterator element_iterator = annotation_iterator.elements();
 376       while (element_iterator.has_next()) {
 377         element_iterator.move_to_next();
 378         if (value_symbol == element_iterator.name()) {
 379           // &quot;value&quot; element
 380           assert(&#39;Z&#39; == element_iterator.value_type(), &quot;invariant&quot;);
 381           value = element_iterator.read_bool();
 382           return true;
 383         }
 384       }
 385     }
 386   }
 387   return false;
 388 }
 389 
 390 // Evaluate to the value of the first found Symbol* annotation type.
 391 // Searching moves upwards in the klass hierarchy in order to support
 392 // inherited annotations in addition to the ability to override.
 393 static bool annotation_value(const InstanceKlass* ik, const Symbol* annotation_type, bool&amp; value) {
 394   assert(ik != NULL, &quot;invariant&quot;);
 395   assert(annotation_type != NULL, &quot;invariant&quot;);
 396   assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
 397   if (has_annotation(ik, annotation_type, value)) {
 398     return true;
 399   }
 400   InstanceKlass* const super = InstanceKlass::cast(ik-&gt;super());
 401   return super != NULL &amp;&amp; JdkJfrEvent::is_a(super) ? annotation_value(super, annotation_type, value) : false;
 402 }
 403 
 404 static const char jdk_jfr_module_name[] = &quot;jdk.jfr&quot;;
 405 
 406 static bool java_base_can_read_jdk_jfr() {
 407   static bool can_read = false;
 408   if (can_read) {
 409     return true;
 410   }
 411   static Symbol* jdk_jfr_module_symbol = NULL;
 412   if (jdk_jfr_module_symbol == NULL) {
 413     jdk_jfr_module_symbol = SymbolTable::probe(jdk_jfr_module_name, sizeof jdk_jfr_module_name - 1);
 414     if (jdk_jfr_module_symbol == NULL) {
 415       return false;
 416     }
 417   }
 418   assert(jdk_jfr_module_symbol != NULL, &quot;invariant&quot;);
 419   ModuleEntryTable* const table = Modules::get_module_entry_table(Handle());
 420   assert(table != NULL, &quot;invariant&quot;);
 421   const ModuleEntry* const java_base_module = table-&gt;javabase_moduleEntry();
 422   if (java_base_module == NULL) {
 423     return false;
 424   }
 425   assert(java_base_module != NULL, &quot;invariant&quot;);
 426   ModuleEntry* const jdk_jfr_module = table-&gt;lookup_only(jdk_jfr_module_symbol);
 427   if (jdk_jfr_module == NULL) {
 428     return false;
 429   }
 430   assert(jdk_jfr_module != NULL, &quot;invariant&quot;);
 431   if (java_base_module-&gt;can_read(jdk_jfr_module)) {
 432     can_read = true;
 433   }
 434   return can_read;
 435 }
 436 
 437 static const char registered_constant[] = &quot;Ljdk/jfr/Registered;&quot;;
 438 
 439 // Evaluate to the value of the first found &quot;Ljdk/jfr/Registered;&quot; annotation.
 440 // Searching moves upwards in the klass hierarchy in order to support
 441 // inherited annotations in addition to the ability to override.
 442 static bool should_register_klass(const InstanceKlass* ik, bool&amp; untypedEventHandler) {
 443   assert(ik != NULL, &quot;invariant&quot;);
 444   assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
 445   assert(!untypedEventHandler, &quot;invariant&quot;);
 446   static const Symbol* registered_symbol = NULL;
 447   if (registered_symbol == NULL) {
 448     registered_symbol = SymbolTable::probe(registered_constant, sizeof registered_constant - 1);
 449     if (registered_symbol == NULL) {
 450       untypedEventHandler = true;
 451       return false;
 452     }
 453   }
 454   assert(registered_symbol != NULL, &quot;invariant&quot;);
 455   bool value = false; // to be set by annotation_value
 456   untypedEventHandler = !(annotation_value(ik, registered_symbol, value) || java_base_can_read_jdk_jfr());
 457   return value;
 458 }
 459 
 460 /*
 461  * Map an utf8 constant back to its CONSTANT_UTF8_INFO
 462  */
 463 static u2 utf8_info_index(const InstanceKlass* ik, const Symbol* const target, TRAPS) {
 464   assert(target != NULL, &quot;invariant&quot;);
 465   const ConstantPool* cp = ik-&gt;constants();
 466   const int cp_len = cp-&gt;length();
 467   for (u2 index = 1; index &lt; cp_len; ++index) {
 468     const constantTag tag = cp-&gt;tag_at(index);
 469     if (tag.is_utf8()) {
 470       const Symbol* const utf8_sym = cp-&gt;symbol_at(index);
 471       assert(utf8_sym != NULL, &quot;invariant&quot;);
 472       if (utf8_sym == target) {
 473         return index;
 474       }
 475     }
 476   }
 477   // not in constant pool
 478   return invalid_cp_index;
 479 }
 480 
 481 #ifdef ASSERT
 482 static bool is_index_within_range(u2 index, u2 orig_cp_len, u2 new_cp_entries_len) {
 483   return index &gt; 0 &amp;&amp; index &lt; orig_cp_len + new_cp_entries_len;
 484 }
 485 #endif
 486 
 487 static u2 add_utf8_info(JfrBigEndianWriter&amp; writer, const char* utf8_constant, u2 orig_cp_len, u2&amp; new_cp_entries_len) {
 488   assert(utf8_constant != NULL, &quot;invariant&quot;);
 489   writer.write&lt;u1&gt;(JVM_CONSTANT_Utf8);
 490   writer.write_utf8_u2_len(utf8_constant);
 491   assert(writer.is_valid(), &quot;invariant&quot;);
 492   // return index for the added utf8 info
 493   return orig_cp_len + new_cp_entries_len++;
 494 }
 495 
 496 static u2 add_method_ref_info(JfrBigEndianWriter&amp; writer,
 497                               u2 cls_name_index,
 498                               u2 method_index,
 499                               u2 desc_index,
 500                               u2 orig_cp_len,
 501                               u2&amp; number_of_new_constants,
 502                               TRAPS) {
 503   assert(cls_name_index != invalid_cp_index, &quot;invariant&quot;);
 504   assert(method_index != invalid_cp_index, &quot;invariant&quot;);
 505   assert(desc_index != invalid_cp_index, &quot;invariant&quot;);
 506   assert(is_index_within_range(cls_name_index, orig_cp_len, number_of_new_constants), &quot;invariant&quot;);
 507   assert(is_index_within_range(method_index, orig_cp_len, number_of_new_constants), &quot;invariant&quot;);
 508   assert(is_index_within_range(desc_index, orig_cp_len, number_of_new_constants), &quot;invariant&quot;);
 509   writer.write&lt;u1&gt;(JVM_CONSTANT_Class);
 510   writer.write&lt;u2&gt;(cls_name_index);
 511   const u2 cls_entry_index = orig_cp_len + number_of_new_constants;
 512   ++number_of_new_constants;
 513   writer.write&lt;u1&gt;(JVM_CONSTANT_NameAndType);
 514   writer.write&lt;u2&gt;(method_index);
 515   writer.write&lt;u2&gt;(desc_index);
 516   const u2 nat_entry_index = orig_cp_len + number_of_new_constants;
 517   ++number_of_new_constants;
 518   writer.write&lt;u1&gt;(JVM_CONSTANT_Methodref);
 519   writer.write&lt;u2&gt;(cls_entry_index);
 520   writer.write&lt;u2&gt;(nat_entry_index);
 521   // post-increment number_of_new_constants
 522   // value returned is the index to the added method_ref
 523   return orig_cp_len + number_of_new_constants++;
 524 }
 525 
 526 static u2 add_flr_register_method_constants(JfrBigEndianWriter&amp; writer,
 527                                             const u2* utf8_indexes,
 528                                             u2 orig_cp_len,
 529                                             u2&amp; number_of_new_constants,
 530                                             TRAPS) {
 531   assert(utf8_indexes != NULL, &quot;invariant&quot;);
 532   return add_method_ref_info(writer,
 533                              utf8_indexes[UTF8_OPT_FlightRecorder],
 534                              utf8_indexes[UTF8_OPT_register],
 535                              utf8_indexes[UTF8_OPT_CLASS_VOID_METHOD_DESC],
 536                              orig_cp_len,
 537                              number_of_new_constants,
 538                              THREAD);
 539 }
 540 
 541 /*
 542  * field_info {
 543  *   u2             access_flags;
 544  *   u2             name_index;
 545  *   u2             descriptor_index;
 546  *   u2             attributes_count;
 547  *   attribute_info attributes[attributes_count];
 548  * }
 549  */
 550 static jlong add_field_info(JfrBigEndianWriter&amp; writer, u2 name_index, u2 desc_index, bool is_static = false) {
 551   assert(name_index != invalid_cp_index, &quot;invariant&quot;);
 552   assert(desc_index != invalid_cp_index, &quot;invariant&quot;);
 553   DEBUG_ONLY(const jlong start_offset = writer.current_offset();)
 554   writer.write&lt;u2&gt;(JVM_ACC_SYNTHETIC | JVM_ACC_PRIVATE | (is_static ? JVM_ACC_STATIC : JVM_ACC_TRANSIENT)); // flags
 555   writer.write(name_index);
 556   writer.write(desc_index);
 557   writer.write((u2)0x0); // attributes_count
 558   assert(writer.is_valid(), &quot;invariant&quot;);
 559   DEBUG_ONLY(assert(start_offset + 8 == writer.current_offset(), &quot;invariant&quot;);)
 560   return writer.current_offset();
 561 }
 562 
 563 static u2 add_field_infos(JfrBigEndianWriter&amp; writer, const u2* utf8_indexes, bool untypedEventHandler) {
 564   assert(utf8_indexes != NULL, &quot;invariant&quot;);
 565   add_field_info(writer,
 566                  utf8_indexes[UTF8_REQ_eventHandler],
 567                  untypedEventHandler ? utf8_indexes[UTF8_OPT_LjavaLangObject] : utf8_indexes[UTF8_OPT_eventHandler_FIELD_DESC],
 568                  true); // static
 569 
 570   add_field_info(writer,
 571                  utf8_indexes[UTF8_REQ_startTime],
 572                  utf8_indexes[UTF8_REQ_J_FIELD_DESC]);
 573 
 574   add_field_info(writer,
 575                  utf8_indexes[UTF8_REQ_duration],
 576                  utf8_indexes[UTF8_REQ_J_FIELD_DESC]);
 577 
 578   return number_of_new_fields;
 579 }
 580 
 581 /*
 582  * method_info {
 583  *  u2             access_flags;
 584  *  u2             name_index;
 585  *  u2             descriptor_index;
 586  *  u2             attributes_count;
 587  *  attribute_info attributes[attributes_count];
 588  * }
 589  *
 590  * Code_attribute {
 591  *   u2 attribute_name_index;
 592  *   u4 attribute_length;
 593  *   u2 max_stack;
 594  *   u2 max_locals;
 595  *   u4 code_length;
 596  *   u1 code[code_length];
 597  *   u2 exception_table_length;
 598  *   {   u2 start_pc;
 599  *       u2 end_pc;
 600  *       u2 handler_pc;
 601  *       u2 catch_type;
 602  *   } exception_table[exception_table_length];
 603  *   u2 attributes_count;
 604  *   attribute_info attributes[attributes_count];
 605  * }
 606  */
 607 
 608 static jlong add_method_info(JfrBigEndianWriter&amp; writer,
 609                              u2 name_index,
 610                              u2 desc_index,
 611                              u2 code_index,
 612                              const u1* const code,
 613                              const size_t code_len) {
 614   assert(name_index &gt; 0, &quot;invariant&quot;);
 615   assert(desc_index &gt; 0, &quot;invariant&quot;);
 616   assert(code_index &gt; 0, &quot;invariant&quot;);
 617   DEBUG_ONLY(const jlong start_offset = writer.current_offset();)
 618   writer.write&lt;u2&gt;(JVM_ACC_SYNTHETIC | JVM_ACC_PUBLIC); // flags
 619   writer.write(name_index);
 620   writer.write(desc_index);
 621   writer.write&lt;u2&gt;(0x1); // attributes_count ; 1 for &quot;Code&quot; attribute
 622   assert(writer.is_valid(), &quot;invariant&quot;);
 623   DEBUG_ONLY(assert(start_offset + 8 == writer.current_offset(), &quot;invariant&quot;);)
 624   // Code attribute
 625   writer.write(code_index); // &quot;Code&quot;
 626   writer.bytes(code, code_len);
 627   DEBUG_ONLY(assert((start_offset + 8 + 2 + (jlong)code_len) == writer.current_offset(), &quot;invariant&quot;);)
 628   return writer.current_offset();
 629 }
 630 
 631 /*
 632  * On return, the passed stream will be positioned
 633  * just after the constant pool section in the classfile
 634  * and the cp length is returned.
 635  *
 636  * Stream should come in at the start position.
 637  */
 638 static u2 position_stream_after_cp(const ClassFileStream* stream) {
 639   assert(stream != NULL, &quot;invariant&quot;);
 640   assert(stream-&gt;current_offset() == 0, &quot;invariant&quot;);
 641   stream-&gt;skip_u4_fast(2);  // 8 bytes skipped
 642   const u2 cp_len = stream-&gt;get_u2_fast();
 643   assert(cp_len &gt; 0, &quot;invariant&quot;);
 644   // now spin the stream position to just after the constant pool
 645   for (u2 index = 1; index &lt; cp_len; ++index) {
 646     const u1 tag = stream-&gt;get_u1_fast(); // cp tag
 647     switch (tag) {
 648       case JVM_CONSTANT_Class:
 649       case JVM_CONSTANT_String: {
 650         stream-&gt;skip_u2_fast(1); // skip 2 bytes
 651         continue;
 652       }
 653       case JVM_CONSTANT_Fieldref:
 654       case JVM_CONSTANT_Methodref:
 655       case JVM_CONSTANT_InterfaceMethodref:
 656       case JVM_CONSTANT_Integer:
 657       case JVM_CONSTANT_Float:
 658       case JVM_CONSTANT_NameAndType:
 659       case JVM_CONSTANT_InvokeDynamic: {
 660         stream-&gt;skip_u4_fast(1); // skip 4 bytes
 661         continue;
 662       }
 663       case JVM_CONSTANT_Long:
 664       case JVM_CONSTANT_Double: {
 665         stream-&gt;skip_u4_fast(2); // skip 8 bytes
 666         // Skip entry following eigth-byte constant, see JVM book p. 98
 667         ++index;
 668         continue;
 669       }
 670       case JVM_CONSTANT_Utf8: {
 671         u2 utf8_length = stream-&gt;get_u2_fast();
 672         stream-&gt;skip_u1_fast(utf8_length); // skip 2 + len bytes
 673         continue;
 674       }
 675       case JVM_CONSTANT_MethodHandle:
 676       case JVM_CONSTANT_MethodType: {
 677         if (tag == JVM_CONSTANT_MethodHandle) {
 678           stream-&gt;skip_u1_fast(1);
 679           stream-&gt;skip_u2_fast(1); // skip 3 bytes
 680         }
 681         else if (tag == JVM_CONSTANT_MethodType) {
 682           stream-&gt;skip_u2_fast(1); // skip 3 bytes
 683         }
 684       }
 685       continue;
<a name="1" id="anc1"></a><span class="line-added"> 686       case JVM_CONSTANT_Dynamic:</span>
<span class="line-added"> 687         stream-&gt;skip_u2_fast(1);</span>
<span class="line-added"> 688         stream-&gt;skip_u2_fast(1);</span>
<span class="line-added"> 689       continue;</span>
 690       default:
 691         assert(false, &quot;error in skip logic!&quot;);
 692         break;
 693     } // end switch(tag)
 694   }
 695   return cp_len;
 696 }
 697 
 698 /*
 699 * On return, the passed stream will be positioned
 700 * just after the fields section in the classfile
 701 * and the number of fields will be returned.
 702 *
 703 * Stream should come in positioned just before fields_count
 704 */
 705 static u2 position_stream_after_fields(const ClassFileStream* stream) {
 706   assert(stream != NULL, &quot;invariant&quot;);
 707   assert(stream-&gt;current_offset() &gt; 0, &quot;invariant&quot;);
 708   // fields len
 709   const u2 orig_fields_len = stream-&gt;get_u2_fast();
 710   // fields
 711   for (u2 i = 0; i &lt; orig_fields_len; ++i) {
 712     stream-&gt;skip_u2_fast(3);
 713     const u2 attrib_info_len = stream-&gt;get_u2_fast();
 714     for (u2 j = 0; j &lt; attrib_info_len; ++j) {
 715       stream-&gt;skip_u2_fast(1);
 716       const u4 attrib_len = stream-&gt;get_u4_fast();
 717       stream-&gt;skip_u1_fast(attrib_len);
 718     }
 719   }
 720   return orig_fields_len;
 721 }
 722 
 723 /*
 724 * On return, the passed stream will be positioned
 725 * just after the methods section in the classfile
 726 * and the number of methods will be returned.
 727 *
 728 * Stream should come in positioned just before methods_count
 729 */
 730 static u2 position_stream_after_methods(JfrBigEndianWriter&amp; writer,
 731                                         const ClassFileStream* stream,
 732                                         const u2* utf8_indexes,
 733                                         bool register_klass,
 734                                         const Method* clinit_method,
 735                                         u4&amp; orig_method_len_offset) {
 736   assert(stream != NULL, &quot;invariant&quot;);
 737   assert(stream-&gt;current_offset() &gt; 0, &quot;invariant&quot;);
 738   assert(utf8_indexes != NULL, &quot;invariant&quot;);
 739   // We will come back to this location when we
 740   // know how many methods there will be.
 741   writer.reserve(sizeof(u2));
 742   const u2 orig_methods_len = stream-&gt;get_u2_fast();
 743   // Move copy position past original method_count
 744   // in order to not copy the original count
 745   orig_method_len_offset += sizeof(u2);
 746   for (u2 i = 0; i &lt; orig_methods_len; ++i) {
 747     const u4 method_offset = stream-&gt;current_offset();
 748     stream-&gt;skip_u2_fast(1); // Access Flags
 749     const u2 name_index = stream-&gt;get_u2_fast(); // Name index
 750     stream-&gt;skip_u2_fast(1); // Descriptor index
 751     const u2 attributes_count = stream-&gt;get_u2_fast();
 752     for (u2 j = 0; j &lt; attributes_count; ++j) {
 753       stream-&gt;skip_u2_fast(1);
 754       const u4 attrib_len = stream-&gt;get_u4_fast();
 755       stream-&gt;skip_u1_fast(attrib_len);
 756     }
 757     if (clinit_method != NULL &amp;&amp; name_index == clinit_method-&gt;name_index()) {
 758       // The method just parsed is an existing &lt;clinit&gt; method.
 759       // If the class has the @Registered(false) annotation, i.e. marking a class
 760       // for opting out from automatic registration, then we do not need to do anything.
 761       if (!register_klass) {
 762         continue;
 763       }
 764       // Automatic registration with the jfr system is acccomplished
 765       // by pre-pending code to the &lt;clinit&gt; method of the class.
 766       // We will need to re-create a new &lt;clinit&gt; in a later step.
 767       // For now, ensure that this method is excluded from the methods
 768       // being copied.
 769       writer.bytes(stream-&gt;buffer() + orig_method_len_offset,
 770                    method_offset - orig_method_len_offset);
 771       assert(writer.is_valid(), &quot;invariant&quot;);
 772 
 773       // Update copy position to skip copy of &lt;clinit&gt; method
 774       orig_method_len_offset = stream-&gt;current_offset();
 775     }
 776   }
 777   return orig_methods_len;
 778 }
 779 
 780 static u2 add_method_infos(JfrBigEndianWriter&amp; writer, const u2* utf8_indexes) {
 781   assert(utf8_indexes != NULL, &quot;invariant&quot;);
 782   add_method_info(writer,
 783                   utf8_indexes[UTF8_REQ_begin],
 784                   utf8_indexes[UTF8_REQ_EMPTY_VOID_METHOD_DESC],
 785                   utf8_indexes[UTF8_REQ_Code],
 786                   empty_void_method_code_attribute,
 787                   sizeof(empty_void_method_code_attribute));
 788 
 789   assert(writer.is_valid(), &quot;invariant&quot;);
 790 
 791   add_method_info(writer,
 792                   utf8_indexes[UTF8_REQ_end],
 793                   utf8_indexes[UTF8_REQ_EMPTY_VOID_METHOD_DESC],
 794                   utf8_indexes[UTF8_REQ_Code],
 795                   empty_void_method_code_attribute,
 796                   sizeof(empty_void_method_code_attribute));
 797 
 798   assert(writer.is_valid(), &quot;invariant&quot;);
 799 
 800   add_method_info(writer,
 801                   utf8_indexes[UTF8_REQ_commit],
 802                   utf8_indexes[UTF8_REQ_EMPTY_VOID_METHOD_DESC],
 803                   utf8_indexes[UTF8_REQ_Code],
 804                   empty_void_method_code_attribute,
 805                   sizeof(empty_void_method_code_attribute));
 806 
 807   assert(writer.is_valid(), &quot;invariant&quot;);
 808 
 809   add_method_info(writer,
 810                   utf8_indexes[UTF8_REQ_isEnabled],
 811                   utf8_indexes[UTF8_REQ_EMPTY_BOOLEAN_METHOD_DESC],
 812                   utf8_indexes[UTF8_REQ_Code],
 813                   boolean_method_code_attribute,
 814                   sizeof(boolean_method_code_attribute));
 815 
 816   assert(writer.is_valid(), &quot;invariant&quot;);
 817 
 818   add_method_info(writer,
 819                   utf8_indexes[UTF8_REQ_shouldCommit],
 820                   utf8_indexes[UTF8_REQ_EMPTY_BOOLEAN_METHOD_DESC],
 821                   utf8_indexes[UTF8_REQ_Code],
 822                   boolean_method_code_attribute,
 823                   sizeof(boolean_method_code_attribute));
 824   assert(writer.is_valid(), &quot;invariant&quot;);
 825   return number_of_new_methods;
 826 }
 827 
 828 static void adjust_exception_table(JfrBigEndianWriter&amp; writer, u2 bci_adjustment_offset, const Method* method, TRAPS) {
 829   const u2 ex_table_length = method != NULL ? (u2)method-&gt;exception_table_length() : 0;
 830   writer.write&lt;u2&gt;(ex_table_length); // Exception table length
 831   if (ex_table_length &gt; 0) {
 832     assert(method != NULL, &quot;invariant&quot;);
 833     const ExceptionTableElement* const ex_elements = method-&gt;exception_table_start();
 834     for (int i = 0; i &lt; ex_table_length; ++i) {
 835       assert(ex_elements != NULL, &quot;invariant&quot;);
 836       writer.write&lt;u2&gt;(ex_elements[i].start_pc + bci_adjustment_offset);
 837       writer.write&lt;u2&gt;(ex_elements[i].end_pc + bci_adjustment_offset);
 838       writer.write&lt;u2&gt;(ex_elements[i].handler_pc + bci_adjustment_offset);
 839       writer.write&lt;u2&gt;(ex_elements[i].catch_type_index); // no adjustment
 840     }
 841   }
 842 }
 843 
 844 enum StackMapFrameTypes {
 845   SAME_FRAME_BEGIN = 0,
 846   SAME_FRAME_END = 63,
 847   SAME_LOCALS_1_STACK_ITEM_FRAME_BEGIN = 64,
 848   SAME_LOCALS_1_STACK_ITEM_FRAME_END = 127,
 849   SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247,
 850   CHOP_FRAME_BEGIN = 248,
 851   CHOP_FRAME_END = 250,
 852   SAME_FRAME_EXTENDED = 251,
 853   APPEND_FRAME_BEGIN = 252,
 854   APPEND_FRAME_END = 254,
 855   FULL_FRAME = 255
 856 };
 857 
 858 static void adjust_stack_map(JfrBigEndianWriter&amp; writer,
 859                              Array&lt;u1&gt;* stack_map,
 860                              const u2* utf8_indexes,
 861                              u2 bci_adjustment_offset,
 862                              TRAPS) {
 863   assert(stack_map != NULL, &quot;invariant&quot;);
 864   assert(utf8_indexes != NULL, &quot;invariant&quot;);
 865   writer.write&lt;u2&gt;(utf8_indexes[UTF8_OPT_StackMapTable]);
 866   const jlong stack_map_attrib_len_offset = writer.current_offset();
 867   writer.reserve(sizeof(u4));
 868   StackMapStream stream(stack_map);
 869   const u2 stack_map_entries = stream.get_u2(THREAD);
 870   // number of entries
 871   writer.write&lt;u2&gt;(stack_map_entries); // new stack map entry added
 872   const u1 frame_type = stream.get_u1(THREAD);
 873   // SAME_FRAME and SAME_LOCALS_1_STACK_ITEM_FRAME encode
 874   // their offset_delta into the actual frame type itself.
 875   // If such a frame type is the first frame, then we transform
 876   // it to a SAME_FRAME_EXTENDED or a SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED frame.
 877   // This is done in order to not overflow frame types accidentally
 878   // when adjusting the offset_delta. In changing the frame types,
 879   // we can work with an explicit u2 offset_delta field (like the other frame types)
 880   if (frame_type &lt;= SAME_FRAME_END) {
 881     writer.write&lt;u1&gt;(SAME_FRAME_EXTENDED);
 882     writer.write&lt;u2&gt;(frame_type + bci_adjustment_offset);
 883   } else if (frame_type &gt;= SAME_LOCALS_1_STACK_ITEM_FRAME_BEGIN &amp;&amp;
 884              frame_type &lt;= SAME_LOCALS_1_STACK_ITEM_FRAME_END) {
 885     writer.write&lt;u1&gt;(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED);
 886     writer.write&lt;u2&gt;((frame_type - SAME_LOCALS_1_STACK_ITEM_FRAME_BEGIN) + bci_adjustment_offset);
 887   } else if (frame_type &gt;= SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
 888       // SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED to FULL_FRAME
 889       // has a u2 offset_delta field
 890       writer.write&lt;u1&gt;(frame_type);
 891       writer.write&lt;u2&gt;(stream.get_u2(THREAD) + bci_adjustment_offset);
 892   } else {
 893     assert(false, &quot;stackMapFrame type is invalid&quot;);
 894   }
 895 
 896   while (!stream.at_end()) {
 897     writer.write&lt;u1&gt;(stream.get_u1(THREAD));
 898   }
 899 
 900   u4 stack_map_attrib_len = writer.current_offset() - stack_map_attrib_len_offset;
 901   // the stack_map_table_attributes_length value is exclusive
 902   stack_map_attrib_len -= sizeof(u4);
 903   writer.write_at_offset(stack_map_attrib_len, stack_map_attrib_len_offset);
 904 }
 905 
 906 static void adjust_line_number_table(JfrBigEndianWriter&amp; writer,
 907                                      const u2* utf8_indexes,
 908                                      u4 bci_adjustement_offset,
 909                                      const Method* method,
 910                                      TRAPS) {
 911   assert(utf8_indexes != NULL, &quot;invariant&quot;);
 912   assert(method != NULL, &quot;invariant&quot;);
 913   assert(method-&gt;has_linenumber_table(), &quot;invariant&quot;);
 914   writer.write(utf8_indexes[UTF8_OPT_LineNumberTable]);
 915   const jlong lnt_attributes_length_offset = writer.current_offset();
 916   writer.reserve(sizeof(u4));
 917   const jlong lnt_attributes_entries_offset = writer.current_offset();
 918   writer.reserve(sizeof(u2));
 919   u1* lnt = method-&gt;compressed_linenumber_table();
 920   CompressedLineNumberReadStream lnt_stream(lnt);
 921   u2 line_number_table_entries = 0;
 922   while (lnt_stream.read_pair()) {
 923     ++line_number_table_entries;
 924     const u2 bci = (u2)lnt_stream.bci();
 925     writer.write&lt;u2&gt;(bci + (u2)bci_adjustement_offset);
 926     writer.write&lt;u2&gt;((u2)lnt_stream.line());
 927   }
 928   writer.write_at_offset(line_number_table_entries, lnt_attributes_entries_offset);
 929   u4 lnt_table_attributes_len = writer.current_offset() - lnt_attributes_length_offset;
 930   // the line_number_table_attributes_length value is exclusive
 931   lnt_table_attributes_len -= sizeof(u4);
 932   writer.write_at_offset(lnt_table_attributes_len, lnt_attributes_length_offset);
 933 }
 934 
 935 // returns the number of lvtt entries
 936 static u2 adjust_local_variable_table(JfrBigEndianWriter&amp; writer,
 937                                       const u2* utf8_indexes,
 938                                       u2 bci_adjustment_offset,
 939                                       const Method* method,
 940                                       TRAPS) {
 941   assert(utf8_indexes != NULL, &quot;invariant&quot;);
 942   assert(method != NULL, &quot;invariant&quot;);
 943   assert(method-&gt;has_localvariable_table(), &quot;invariant&quot;);
 944   writer.write&lt;u2&gt;(utf8_indexes[UTF8_OPT_LocalVariableTable]);
 945   const jlong lvt_attributes_length_offset = writer.current_offset();
 946   writer.reserve(sizeof(u4));
 947   const int lvt_len = method-&gt;localvariable_table_length();
 948   writer.write&lt;u2&gt;((u2)lvt_len);
 949   const LocalVariableTableElement* table = method-&gt;localvariable_table_start();
 950   assert(table != NULL, &quot;invariant&quot;);
 951   u2 num_lvtt_entries = 0;
 952   for (int i = 0; i &lt; lvt_len; ++i) {
 953     writer.write&lt;u2&gt;(table[i].start_bci + bci_adjustment_offset);
 954     writer.write&lt;u2&gt;(table[i].length);
 955     writer.write&lt;u2&gt;(table[i].name_cp_index);
 956     writer.write&lt;u2&gt;(table[i].descriptor_cp_index);
 957     writer.write&lt;u2&gt;(table[i].slot);
 958     if (table[i].signature_cp_index &gt; 0) {
 959       ++num_lvtt_entries;
 960     }
 961   }
 962   u4 lvt_table_attributes_len = writer.current_offset() - lvt_attributes_length_offset;
 963   // the lvt_table_attributes_length value is exclusive
 964   lvt_table_attributes_len -= sizeof(u4);
 965   writer.write_at_offset(lvt_table_attributes_len, lvt_attributes_length_offset);
 966   return num_lvtt_entries;
 967 }
 968 
 969 static void adjust_local_variable_type_table(JfrBigEndianWriter&amp; writer,
 970                                             const u2* utf8_indexes,
 971                                             u2 bci_adjustment_offset,
 972                                             u2 num_lvtt_entries,
 973                                             const Method* method,
 974                                             TRAPS) {
 975   assert(num_lvtt_entries &gt; 0, &quot;invariant&quot;);
 976   writer.write&lt;u2&gt;(utf8_indexes[UTF8_OPT_LocalVariableTypeTable]);
 977   const jlong lvtt_attributes_length_offset = writer.current_offset();
 978   writer.reserve(sizeof(u4));
 979   writer.write&lt;u2&gt;(num_lvtt_entries);
 980   const LocalVariableTableElement* table = method-&gt;localvariable_table_start();
 981   assert(table != NULL, &quot;invariant&quot;);
 982   const int lvt_len = method-&gt;localvariable_table_length();
 983   for (int i = 0; i &lt; lvt_len; ++i) {
 984     if (table[i].signature_cp_index &gt; 0) {
 985       writer.write&lt;u2&gt;(table[i].start_bci + bci_adjustment_offset);
 986       writer.write&lt;u2&gt;(table[i].length);
 987       writer.write&lt;u2&gt;(table[i].name_cp_index);
 988       writer.write&lt;u2&gt;(table[i].signature_cp_index);
 989       writer.write&lt;u2&gt;(table[i].slot);
 990     }
 991   }
 992   u4 lvtt_table_attributes_len = writer.current_offset() - lvtt_attributes_length_offset;
 993   // the lvtt_table_attributes_length value is exclusive
 994   lvtt_table_attributes_len -= sizeof(u4);
 995   writer.write_at_offset(lvtt_table_attributes_len, lvtt_attributes_length_offset);
 996 }
 997 
 998 static void adjust_code_attributes(JfrBigEndianWriter&amp; writer,
 999                                    const u2* utf8_indexes,
1000                                    u2 bci_adjustment_offset,
1001                                    const Method* clinit_method,
1002                                    TRAPS) {
1003   // &quot;Code&quot; attributes
1004   assert(utf8_indexes != NULL, &quot;invariant&quot;);
1005   const jlong code_attributes_offset = writer.current_offset();
1006   writer.reserve(sizeof(u2));
1007   u2 number_of_code_attributes = 0;
1008   if (clinit_method != NULL) {
1009     Array&lt;u1&gt;* stack_map = clinit_method-&gt;stackmap_data();
1010     if (stack_map != NULL) {
1011       ++number_of_code_attributes;
1012       adjust_stack_map(writer, stack_map, utf8_indexes, bci_adjustment_offset, THREAD);
1013       assert(writer.is_valid(), &quot;invariant&quot;);
1014     }
1015     if (clinit_method != NULL &amp;&amp; clinit_method-&gt;has_linenumber_table()) {
1016       ++number_of_code_attributes;
1017       adjust_line_number_table(writer, utf8_indexes, bci_adjustment_offset, clinit_method, THREAD);
1018       assert(writer.is_valid(), &quot;invariant&quot;);
1019     }
1020     if (clinit_method != NULL &amp;&amp; clinit_method-&gt;has_localvariable_table()) {
1021       ++number_of_code_attributes;
1022       const u2 num_of_lvtt_entries = adjust_local_variable_table(writer, utf8_indexes, bci_adjustment_offset, clinit_method, THREAD);
1023       assert(writer.is_valid(), &quot;invariant&quot;);
1024       if (num_of_lvtt_entries &gt; 0) {
1025         ++number_of_code_attributes;
1026         adjust_local_variable_type_table(writer, utf8_indexes, bci_adjustment_offset, num_of_lvtt_entries, clinit_method, THREAD);
1027         assert(writer.is_valid(), &quot;invariant&quot;);
1028       }
1029     }
1030   }
1031 
1032   // Store the number of code_attributes
1033   writer.write_at_offset(number_of_code_attributes, code_attributes_offset);
1034 }
1035 
1036 static jlong insert_clinit_method(const InstanceKlass* ik,
1037                                   const ClassFileParser&amp; parser,
1038                                   JfrBigEndianWriter&amp; writer,
1039                                   u2 orig_constant_pool_len,
1040                                   const u2* utf8_indexes,
1041                                   const u2 register_method_ref_index,
1042                                   const Method* clinit_method,
1043                                   TRAPS) {
1044   assert(utf8_indexes != NULL, &quot;invariant&quot;);
1045   // The injected code length is always this value.
1046   // This is to ensure that padding can be done
1047   // where needed and to simplify size calculations.
1048   static const u2 injected_code_length = 8;
1049   const u2 name_index = utf8_indexes[UTF8_OPT_clinit];
1050   assert(name_index != invalid_cp_index, &quot;invariant&quot;);
1051   const u2 desc_index = utf8_indexes[UTF8_REQ_EMPTY_VOID_METHOD_DESC];
1052   const u2 max_stack = MAX2(clinit_method != NULL ? clinit_method-&gt;verifier_max_stack() : 1, 1);
1053   const u2 max_locals = MAX2(clinit_method != NULL ? clinit_method-&gt;max_locals() : 0, 0);
1054   const u2 orig_bytecodes_length = clinit_method != NULL ? (u2)clinit_method-&gt;code_size() : 0;
1055   const address orig_bytecodes = clinit_method != NULL ? clinit_method-&gt;code_base() : NULL;
1056   const u2 new_code_length = injected_code_length + orig_bytecodes_length;
1057   DEBUG_ONLY(const jlong start_offset = writer.current_offset();)
1058   writer.write&lt;u2&gt;(JVM_ACC_STATIC); // flags
1059   writer.write&lt;u2&gt;(name_index);
1060   writer.write&lt;u2&gt;(desc_index);
1061   writer.write&lt;u2&gt;((u2)0x1); // attributes_count // &quot;Code&quot;
1062   assert(writer.is_valid(), &quot;invariant&quot;);
1063   DEBUG_ONLY(assert(start_offset + 8 == writer.current_offset(), &quot;invariant&quot;);)
1064   // &quot;Code&quot; attribute
1065   writer.write&lt;u2&gt;(utf8_indexes[UTF8_REQ_Code]); // &quot;Code&quot;
1066   const jlong code_attribute_length_offset = writer.current_offset();
1067   writer.reserve(sizeof(u4));
1068   writer.write&lt;u2&gt;(max_stack); // max stack
1069   writer.write&lt;u2&gt;(max_locals); // max locals
1070   writer.write&lt;u4&gt;((u4)new_code_length); // code length
1071 
1072   /* BEGIN CLINIT CODE */
1073 
1074   // Note the use of ldc_w here instead of ldc.
1075   // This is to handle all values of &quot;this_class_index&quot;
1076   writer.write&lt;u1&gt;((u1)Bytecodes::_ldc_w);
1077   writer.write&lt;u2&gt;((u2)parser.this_class_index()); // load constant &quot;this class&quot;
1078   writer.write&lt;u1&gt;((u1)Bytecodes::_invokestatic);
1079   // invoke &quot;FlightRecorder.register(Ljava/lang/Class;&quot;)
1080   writer.write&lt;u2&gt;(register_method_ref_index);
1081   if (clinit_method == NULL) {
1082     writer.write&lt;u1&gt;((u1)Bytecodes::_nop);
1083     writer.write&lt;u1&gt;((u1)Bytecodes::_return);
1084   } else {
1085     // If we are pre-pending to original code,
1086     // do padding to minimize disruption to the original.
1087     // It might have dependencies on 4-byte boundaries
1088     // i.e. lookupswitch and tableswitch instructions
1089     writer.write&lt;u1&gt;((u1)Bytecodes::_nop);
1090     writer.write&lt;u1&gt;((u1)Bytecodes::_nop);
1091     // insert original clinit code
1092     writer.bytes(orig_bytecodes, orig_bytecodes_length);
1093   }
1094 
1095   /* END CLINIT CODE */
1096 
1097   assert(writer.is_valid(), &quot;invariant&quot;);
1098   adjust_exception_table(writer, injected_code_length, clinit_method, THREAD);
1099   assert(writer.is_valid(), &quot;invariant&quot;);
1100   adjust_code_attributes(writer, utf8_indexes, injected_code_length, clinit_method, THREAD);
1101   assert(writer.is_valid(), &quot;invariant&quot;);
1102   u4 code_attribute_len = writer.current_offset() - code_attribute_length_offset;
1103   // the code_attribute_length value is exclusive
1104   code_attribute_len -= sizeof(u4);
1105   writer.write_at_offset(code_attribute_len, code_attribute_length_offset);
1106   return writer.current_offset();
1107 }
1108 
1109 // Caller needs ResourceMark
1110 static ClassFileStream* create_new_bytes_for_event_klass(const InstanceKlass* ik, const ClassFileParser&amp; parser, TRAPS) {
1111   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
1112   static const u2 public_final_flag_mask = JVM_ACC_PUBLIC | JVM_ACC_FINAL;
1113   const ClassFileStream* const orig_stream = parser.clone_stream();
1114   const int orig_stream_length = orig_stream-&gt;length();
1115   // allocate an identically sized buffer
1116   u1* const new_buffer = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, u1, orig_stream_length);
1117   if (new_buffer == NULL) {
1118     return NULL;
1119   }
1120   assert(new_buffer != NULL, &quot;invariant&quot;);
1121   // memcpy the entire [B
1122   memcpy(new_buffer, orig_stream-&gt;buffer(), orig_stream_length);
1123   const u2 orig_cp_len = position_stream_after_cp(orig_stream);
1124   assert(orig_cp_len &gt; 0, &quot;invariant&quot;);
1125   assert(orig_stream-&gt;current_offset() &gt; 0, &quot;invariant&quot;);
1126   orig_stream-&gt;skip_u2_fast(3); // access_flags, this_class_index, super_class_index
1127   const u2 iface_len = orig_stream-&gt;get_u2_fast();
1128   orig_stream-&gt;skip_u2_fast(iface_len);
1129   // fields len
1130   const u2 orig_fields_len = orig_stream-&gt;get_u2_fast();
1131   // fields
1132   for (u2 i = 0; i &lt; orig_fields_len; ++i) {
1133     orig_stream-&gt;skip_u2_fast(3);
1134     const u2 attrib_info_len = orig_stream-&gt;get_u2_fast();
1135     for (u2 j = 0; j &lt; attrib_info_len; ++j) {
1136       orig_stream-&gt;skip_u2_fast(1);
1137       const u4 attrib_len = orig_stream-&gt;get_u4_fast();
1138       orig_stream-&gt;skip_u1_fast(attrib_len);
1139     }
1140   }
1141   // methods
1142   const u2 orig_methods_len = orig_stream-&gt;get_u2_fast();
1143   for (u2 i = 0; i &lt; orig_methods_len; ++i) {
1144     const u4 access_flag_offset = orig_stream-&gt;current_offset();
1145     const u2 flags = orig_stream-&gt;get_u2_fast();
1146     // Rewrite JVM_ACC_FINAL -&gt; JVM_ACC_PUBLIC
1147     if (public_final_flag_mask == flags) {
1148       JfrBigEndianWriter accessflagsrewriter(new_buffer + access_flag_offset, sizeof(u2));
1149       accessflagsrewriter.write&lt;u2&gt;(JVM_ACC_PUBLIC);
1150       assert(accessflagsrewriter.is_valid(), &quot;invariant&quot;);
1151     }
1152     orig_stream-&gt;skip_u2_fast(2);
1153     const u2 attributes_count = orig_stream-&gt;get_u2_fast();
1154     for (u2 j = 0; j &lt; attributes_count; ++j) {
1155       orig_stream-&gt;skip_u2_fast(1);
1156       const u4 attrib_len = orig_stream-&gt;get_u4_fast();
1157       orig_stream-&gt;skip_u1_fast(attrib_len);
1158     }
1159   }
1160   return new ClassFileStream(new_buffer, orig_stream_length, NULL, ClassFileStream::verify);
1161 }
1162 
1163 // Attempt to locate an existing UTF8_INFO mapping the utf8_constant.
1164 // If no UTF8_INFO exists, add (append) a new one to the constant pool.
1165 static u2 find_or_add_utf8_info(JfrBigEndianWriter&amp; writer,
1166                                 const InstanceKlass* ik,
1167                                 const char* const utf8_constant,
1168                                 u2 orig_cp_len,
1169                                 u2&amp; added_cp_entries,
1170                                 TRAPS) {
1171   assert(utf8_constant != NULL, &quot;invariant&quot;);
1172   TempNewSymbol utf8_sym = SymbolTable::new_symbol(utf8_constant);
1173   // lookup existing
1174   const int utf8_orig_idx = utf8_info_index(ik, utf8_sym, THREAD);
1175   if (utf8_orig_idx != invalid_cp_index) {
1176     // existing constant pool entry found
1177     return utf8_orig_idx;
1178   }
1179   // no existing match, need to add a new utf8 cp entry
1180   assert(invalid_cp_index == utf8_orig_idx, &quot;invariant&quot;);
1181   // add / append new
1182   return add_utf8_info(writer, utf8_constant, orig_cp_len, added_cp_entries);
1183 }
1184 
1185 /*
1186  * This routine will resolve the required utf8_constants array
1187  * to their constant pool indexes (mapping to their UTF8_INFO&#39;s)
1188  * Only if a constant is actually needed and does not already exist
1189  * will it be added.
1190  *
1191  * The passed in indexes array will be populated with the resolved indexes.
1192  * The number of newly added constant pool entries is returned.
1193  */
1194 static u2 resolve_utf8_indexes(JfrBigEndianWriter&amp; writer,
1195                                const InstanceKlass* ik,
1196                                u2* const utf8_indexes,
1197                                u2 orig_cp_len,
1198                                const Method* clinit_method,
1199                                bool register_klass,
1200                                bool untypedEventHandler,
1201                                TRAPS) {
1202   assert(utf8_indexes != NULL, &quot;invariant&quot;);
1203   u2 added_cp_entries = 0;
1204   // resolve all required symbols
1205   for (u2 index = 0; index &lt; NOF_UTF8_REQ_SYMBOLS; ++index) {
1206     utf8_indexes[index] = find_or_add_utf8_info(writer, ik, utf8_constants[index], orig_cp_len, added_cp_entries, THREAD);
1207   }
1208 
1209   // resolve optional constants
1210   utf8_indexes[UTF8_OPT_eventHandler_FIELD_DESC] = untypedEventHandler ? invalid_cp_index :
1211     find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_eventHandler_FIELD_DESC], orig_cp_len, added_cp_entries, THREAD);
1212 
1213   utf8_indexes[UTF8_OPT_LjavaLangObject] = untypedEventHandler ?
1214     find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_LjavaLangObject], orig_cp_len, added_cp_entries, THREAD) : invalid_cp_index;
1215 
1216   if (register_klass) {
1217     utf8_indexes[UTF8_OPT_clinit] =
1218       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_clinit], orig_cp_len, added_cp_entries, THREAD);
1219     utf8_indexes[UTF8_OPT_FlightRecorder] =
1220       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_FlightRecorder], orig_cp_len, added_cp_entries, THREAD);
1221     utf8_indexes[UTF8_OPT_register] =
1222       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_register], orig_cp_len, added_cp_entries, THREAD);
1223     utf8_indexes[UTF8_OPT_CLASS_VOID_METHOD_DESC] =
1224       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_CLASS_VOID_METHOD_DESC], orig_cp_len, added_cp_entries, THREAD);
1225   } else {
1226     utf8_indexes[UTF8_OPT_clinit] = invalid_cp_index;
1227     utf8_indexes[UTF8_OPT_FlightRecorder] = invalid_cp_index;
1228     utf8_indexes[UTF8_OPT_register] = invalid_cp_index;
1229     utf8_indexes[UTF8_OPT_CLASS_VOID_METHOD_DESC] = invalid_cp_index;
1230   }
1231 
1232   if (clinit_method != NULL &amp;&amp; clinit_method-&gt;has_stackmap_table()) {
1233     utf8_indexes[UTF8_OPT_StackMapTable] =
1234       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_StackMapTable], orig_cp_len, added_cp_entries, THREAD);
1235   } else {
1236     utf8_indexes[UTF8_OPT_StackMapTable] = invalid_cp_index;
1237   }
1238 
1239   if (clinit_method != NULL &amp;&amp; clinit_method-&gt;has_linenumber_table()) {
1240     utf8_indexes[UTF8_OPT_LineNumberTable] =
1241       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_LineNumberTable], orig_cp_len, added_cp_entries, THREAD);
1242   } else {
1243     utf8_indexes[UTF8_OPT_LineNumberTable] = invalid_cp_index;
1244   }
1245 
1246   if (clinit_method != NULL &amp;&amp; clinit_method-&gt;has_localvariable_table()) {
1247     utf8_indexes[UTF8_OPT_LocalVariableTable] =
1248       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_LocalVariableTable], orig_cp_len, added_cp_entries, THREAD);
1249     utf8_indexes[UTF8_OPT_LocalVariableTypeTable] =
1250       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_LocalVariableTypeTable], orig_cp_len, added_cp_entries, THREAD);
1251   } else {
1252     utf8_indexes[UTF8_OPT_LocalVariableTable] = invalid_cp_index;
1253     utf8_indexes[UTF8_OPT_LocalVariableTypeTable] = invalid_cp_index;
1254   }
1255 
1256   return added_cp_entries;
1257 }
1258 
1259 static u1* new_bytes_for_lazy_instrumentation(const InstanceKlass* ik,
1260                                               const ClassFileParser&amp; parser,
1261                                               jint&amp; size_of_new_bytes,
1262                                               TRAPS) {
1263   assert(ik != NULL, &quot;invariant&quot;);
1264   // If the class already has a clinit method
1265   // we need to take that into account
1266   const Method* clinit_method = ik-&gt;class_initializer();
1267   bool untypedEventHandler = false;
1268   const bool register_klass = should_register_klass(ik, untypedEventHandler);
1269   const ClassFileStream* const orig_stream = parser.clone_stream();
1270   const int orig_stream_size = orig_stream-&gt;length();
1271   assert(orig_stream-&gt;current_offset() == 0, &quot;invariant&quot;);
1272   const u2 orig_cp_len = position_stream_after_cp(orig_stream);
1273   assert(orig_cp_len &gt; 0, &quot;invariant&quot;);
1274   assert(orig_stream-&gt;current_offset() &gt; 0, &quot;invariant&quot;);
1275   // Dimension and allocate a working byte buffer
1276   // to be used in building up a modified class [B.
1277   const jint new_buffer_size = extra_stream_bytes + orig_stream_size;
1278   u1* const new_buffer = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, u1, new_buffer_size);
1279   if (new_buffer == NULL) {
1280     log_error(jfr, system) (&quot;Thread local allocation (native) for &quot; SIZE_FORMAT
1281       &quot; bytes failed in JfrClassAdapter::on_klass_creation&quot;, (size_t)new_buffer_size);
1282     return NULL;
1283   }
1284   assert(new_buffer != NULL, &quot;invariant&quot;);
1285   // [B wrapped in a big endian writer
1286   JfrBigEndianWriter writer(new_buffer, new_buffer_size);
1287   assert(writer.current_offset() == 0, &quot;invariant&quot;);
1288   const u4 orig_access_flag_offset = orig_stream-&gt;current_offset();
1289   // Copy original stream from the beginning up to AccessFlags
1290   // This means the original constant pool contents are copied unmodified
1291   writer.bytes(orig_stream-&gt;buffer(), orig_access_flag_offset);
1292   assert(writer.is_valid(), &quot;invariant&quot;);
1293   assert(writer.current_offset() == (intptr_t)orig_access_flag_offset, &quot;invariant&quot;); // same positions
1294   // Our writer now sits just after the last original constant pool entry.
1295   // I.e. we are in a good position to append new constant pool entries
1296   // This array will contain the resolved indexes
1297   // in order to reference UTF8_INFO&#39;s needed
1298   u2 utf8_indexes[NOF_UTF8_SYMBOLS];
1299   // Resolve_utf8_indexes will be conservative in attempting to
1300   // locate an existing UTF8_INFO; it will only append constants
1301   // that is absolutely required
1302   u2 number_of_new_constants =
1303     resolve_utf8_indexes(writer, ik, utf8_indexes, orig_cp_len, clinit_method, register_klass, untypedEventHandler, THREAD);
1304   // UTF8_INFO entries now added to the constant pool
1305   // In order to invoke a method we would need additional
1306   // constants, JVM_CONSTANT_Class, JVM_CONSTANT_NameAndType
1307   // and JVM_CONSTANT_Methodref.
1308   const u2 flr_register_method_ref_index =
1309     register_klass ?
1310       add_flr_register_method_constants(writer,
1311                                         utf8_indexes,
1312                                         orig_cp_len,
1313                                         number_of_new_constants,
1314                                         THREAD) :  invalid_cp_index;
1315 
1316   // New constant pool entries added and all UTF8_INFO indexes resolved
1317   // Now update the class file constant_pool_count with an updated count
1318   writer.write_at_offset&lt;u2&gt;(orig_cp_len + number_of_new_constants, 8);
1319   assert(writer.is_valid(), &quot;invariant&quot;);
1320   orig_stream-&gt;skip_u2_fast(3); // access_flags, this_class_index, super_class_index
1321   const u2 iface_len = orig_stream-&gt;get_u2_fast(); // interfaces
1322   orig_stream-&gt;skip_u2_fast(iface_len);
1323   const u4 orig_fields_len_offset = orig_stream-&gt;current_offset();
1324   // Copy from AccessFlags up to and including interfaces
1325   writer.bytes(orig_stream-&gt;buffer() + orig_access_flag_offset,
1326                orig_fields_len_offset - orig_access_flag_offset);
1327   assert(writer.is_valid(), &quot;invariant&quot;);
1328   const jlong new_fields_len_offset = writer.current_offset();
1329   const u2 orig_fields_len = position_stream_after_fields(orig_stream);
1330   u4 orig_method_len_offset = orig_stream-&gt;current_offset();
1331   // Copy up to and including fields
1332   writer.bytes(orig_stream-&gt;buffer() + orig_fields_len_offset, orig_method_len_offset - orig_fields_len_offset);
1333   assert(writer.is_valid(), &quot;invariant&quot;);
1334   // We are sitting just after the original number of field_infos
1335   // so this is a position where we can add (append) new field_infos
1336   const u2 number_of_new_fields = add_field_infos(writer, utf8_indexes, untypedEventHandler);
1337   assert(writer.is_valid(), &quot;invariant&quot;);
1338   const jlong new_method_len_offset = writer.current_offset();
1339   // Additional field_infos added, update classfile fields_count
1340   writer.write_at_offset&lt;u2&gt;(orig_fields_len + number_of_new_fields, new_fields_len_offset);
1341   assert(writer.is_valid(), &quot;invariant&quot;);
1342   // Our current location is now at classfile methods_count
1343   const u2 orig_methods_len = position_stream_after_methods(writer,
1344                                                             orig_stream,
1345                                                             utf8_indexes,
1346                                                             register_klass,
1347                                                             clinit_method,
1348                                                             orig_method_len_offset);
1349   const u4 orig_attributes_count_offset = orig_stream-&gt;current_offset();
1350   // Copy existing methods
1351   writer.bytes(orig_stream-&gt;buffer() + orig_method_len_offset, orig_attributes_count_offset - orig_method_len_offset);
1352   assert(writer.is_valid(), &quot;invariant&quot;);
1353   // We are sitting just after the original number of method_infos
1354   // so this is a position where we can add (append) new method_infos
1355   u2 number_of_new_methods = add_method_infos(writer, utf8_indexes);
1356 
1357   // We have just added the new methods.
1358   //
1359   // What about the state of &lt;clinit&gt;?
1360   // We would need to do:
1361   // 1. Nothing (@Registered(false) annotation)
1362   // 2. Build up a new &lt;clinit&gt; - and if the original class already contains a &lt;clinit&gt;,
1363   //                              merging will be neccessary.
1364   //
1365   if (register_klass) {
1366     insert_clinit_method(ik, parser, writer, orig_cp_len, utf8_indexes, flr_register_method_ref_index, clinit_method, THREAD);
1367   }
1368   number_of_new_methods += clinit_method != NULL ? 0 : register_klass ? 1 : 0;
1369   // Update classfile methods_count
1370   writer.write_at_offset&lt;u2&gt;(orig_methods_len + number_of_new_methods, new_method_len_offset);
1371   assert(writer.is_valid(), &quot;invariant&quot;);
1372   // Copy last remaining bytes
1373   writer.bytes(orig_stream-&gt;buffer() + orig_attributes_count_offset, orig_stream_size - orig_attributes_count_offset);
1374   assert(writer.is_valid(), &quot;invariant&quot;);
1375   assert(writer.current_offset() &gt; orig_stream-&gt;length(), &quot;invariant&quot;);
1376   size_of_new_bytes = (jint)writer.current_offset();
1377   return new_buffer;
1378 }
1379 
1380 static void log_pending_exception(oop throwable) {
1381   assert(throwable != NULL, &quot;invariant&quot;);
1382   oop msg = java_lang_Throwable::message(throwable);
1383   if (msg != NULL) {
1384     char* text = java_lang_String::as_utf8_string(msg);
1385     if (text != NULL) {
1386       log_error(jfr, system) (&quot;%s&quot;, text);
1387     }
1388   }
1389 }
1390 
1391 static bool should_force_instrumentation() {
1392   return !JfrOptionSet::allow_event_retransforms() || JfrEventClassTransformer::is_force_instrumentation();
1393 }
1394 
1395 static ClassFileStream* create_new_bytes_for_subklass(const InstanceKlass* ik, const ClassFileParser&amp; parser, Thread* t) {
1396   assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
1397   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(t));
1398   jint size_of_new_bytes = 0;
1399   const u1* new_bytes = new_bytes_for_lazy_instrumentation(ik, parser, size_of_new_bytes, t);
1400   if (new_bytes == NULL) {
1401     return NULL;
1402   }
1403   assert(new_bytes != NULL, &quot;invariant&quot;);
1404   assert(size_of_new_bytes &gt; 0, &quot;invariant&quot;);
1405 
1406   bool force_instrumentation = should_force_instrumentation();
1407   if (Jfr::is_recording() || force_instrumentation) {
1408     jint size_instrumented_data = 0;
1409     unsigned char* instrumented_data = NULL;
1410     const jclass super = (jclass)JNIHandles::make_local(ik-&gt;super()-&gt;java_mirror());
1411     JfrUpcalls::new_bytes_eager_instrumentation(TRACE_ID(ik),
1412                                                 force_instrumentation,
1413                                                 super,
1414                                                 size_of_new_bytes,
1415                                                 new_bytes,
1416                                                 &amp;size_instrumented_data,
1417                                                 &amp;instrumented_data,
1418                                                 t);
1419     if (t-&gt;has_pending_exception()) {
1420       log_pending_exception(t-&gt;pending_exception());
1421       t-&gt;clear_pending_exception();
1422       return NULL;
1423     }
1424     assert(instrumented_data != NULL, &quot;invariant&quot;);
1425     assert(size_instrumented_data &gt; 0, &quot;invariant&quot;);
1426     return new ClassFileStream(instrumented_data, size_instrumented_data, NULL, ClassFileStream::verify);
1427   }
1428   return new ClassFileStream(new_bytes, size_of_new_bytes, NULL, ClassFileStream::verify);
1429 }
1430 
1431 static bool cache_bytes(InstanceKlass* ik, ClassFileStream* new_stream, InstanceKlass* new_ik, TRAPS) {
1432   assert(ik != NULL, &quot;invariant&quot;);
1433   assert(new_ik != NULL, &quot;invariant&quot;);
1434   assert(new_ik-&gt;name() != NULL, &quot;invariant&quot;);
1435   assert(new_stream != NULL, &quot;invariant&quot;);
1436   assert(!HAS_PENDING_EXCEPTION, &quot;invariant&quot;);
1437   static const bool can_retransform = JfrOptionSet::allow_retransforms();
1438   if (!can_retransform) {
1439     return true;
1440   }
1441   const jint stream_len = new_stream-&gt;length();
1442   JvmtiCachedClassFileData* p =
1443     (JvmtiCachedClassFileData*)NEW_C_HEAP_ARRAY_RETURN_NULL(u1, offset_of(JvmtiCachedClassFileData, data) + stream_len, mtInternal);
1444   if (p == NULL) {
1445     log_error(jfr, system)(&quot;Allocation using C_HEAP_ARRAY for &quot; SIZE_FORMAT
1446       &quot; bytes failed in JfrClassAdapter::on_klass_creation&quot;, (size_t)offset_of(JvmtiCachedClassFileData, data) + stream_len);
1447     return false;
1448   }
1449   p-&gt;length = stream_len;
1450   memcpy(p-&gt;data, new_stream-&gt;buffer(), stream_len);
1451   new_ik-&gt;set_cached_class_file(p);
1452   JvmtiCachedClassFileData* const cached_class_data = ik-&gt;get_cached_class_file();
1453   if (cached_class_data != NULL) {
1454     os::free(cached_class_data);
1455     ik-&gt;set_cached_class_file(NULL);
1456   }
1457   return true;
1458 }
1459 
1460 static InstanceKlass* create_new_instance_klass(InstanceKlass* ik, ClassFileStream* stream, TRAPS) {
1461   assert(stream != NULL, &quot;invariant&quot;);
1462   ResourceMark rm(THREAD);
1463   ClassLoaderData* const cld = ik-&gt;class_loader_data();
1464   Handle pd(THREAD, ik-&gt;protection_domain());
1465   Symbol* const class_name = ik-&gt;name();
1466   const char* const klass_name = class_name != NULL ? class_name-&gt;as_C_string() : &quot;&quot;;
1467   ClassLoadInfo cl_info(pd);
1468   ClassFileParser new_parser(stream,
1469                              class_name,
1470                              cld,
1471                              &amp;cl_info,
1472                              ClassFileParser::INTERNAL, // internal visibility
1473                              THREAD);
1474   if (HAS_PENDING_EXCEPTION) {
1475     log_pending_exception(PENDING_EXCEPTION);
1476     CLEAR_PENDING_EXCEPTION;
1477     return NULL;
1478   }
1479   const ClassInstanceInfo* cl_inst_info = cl_info.class_hidden_info_ptr();
1480   InstanceKlass* const new_ik = new_parser.create_instance_klass(false, *cl_inst_info, THREAD);
1481   if (HAS_PENDING_EXCEPTION) {
1482     log_pending_exception(PENDING_EXCEPTION);
1483     CLEAR_PENDING_EXCEPTION;
1484     return NULL;
1485   }
1486   assert(new_ik != NULL, &quot;invariant&quot;);
1487   assert(new_ik-&gt;name() != NULL, &quot;invariant&quot;);
1488   assert(strncmp(ik-&gt;name()-&gt;as_C_string(), new_ik-&gt;name()-&gt;as_C_string(), strlen(ik-&gt;name()-&gt;as_C_string())) == 0, &quot;invariant&quot;);
1489   return cache_bytes(ik, stream, new_ik, THREAD) ? new_ik : NULL;
1490 }
1491 
1492 static void rewrite_klass_pointer(InstanceKlass*&amp; ik, InstanceKlass* new_ik, ClassFileParser&amp; parser, TRAPS) {
1493   assert(ik != NULL, &quot;invariant&quot;);
1494   assert(new_ik != NULL, &quot;invariant&quot;);
1495   assert(new_ik-&gt;name() != NULL, &quot;invariant&quot;);
1496   assert(JdkJfrEvent::is(new_ik) || JdkJfrEvent::is_subklass(new_ik), &quot;invariant&quot;);
1497   assert(!HAS_PENDING_EXCEPTION, &quot;invariant&quot;);
1498   // assign original InstanceKlass* back onto &quot;its&quot; parser object for proper destruction
1499   parser.set_klass_to_deallocate(ik);
1500   // now rewrite original pointer to newly created InstanceKlass
1501   ik = new_ik;
1502 }
1503 
1504 static bool is_retransforming(const InstanceKlass* ik, TRAPS) {
1505   assert(ik != NULL, &quot;invariant&quot;);
1506   assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
1507   Symbol* const name = ik-&gt;name();
1508   assert(name != NULL, &quot;invariant&quot;);
1509   Handle class_loader(THREAD, ik-&gt;class_loader());
1510   Handle protection_domain(THREAD, ik-&gt;protection_domain());
1511   return SystemDictionary::find(name, class_loader, protection_domain, THREAD) != NULL;
1512 }
1513 
1514 // target for JFR_ON_KLASS_CREATION hook
1515 void JfrEventClassTransformer::on_klass_creation(InstanceKlass*&amp; ik, ClassFileParser&amp; parser, TRAPS) {
1516   assert(ik != NULL, &quot;invariant&quot;);
1517   if (JdkJfrEvent::is(ik)) {
1518     ResourceMark rm(THREAD);
1519     HandleMark hm(THREAD);
1520     ClassFileStream* new_stream = create_new_bytes_for_event_klass(ik, parser, THREAD);
1521     if (new_stream == NULL) {
1522       log_error(jfr, system)(&quot;JfrClassAdapter: unable to create ClassFileStream&quot;);
1523       return;
1524     }
1525     assert(new_stream != NULL, &quot;invariant&quot;);
1526     InstanceKlass* new_ik = create_new_instance_klass(ik, new_stream, THREAD);
1527     if (new_ik == NULL) {
1528       log_error(jfr, system)(&quot;JfrClassAdapter: unable to create InstanceKlass&quot;);
1529       return;
1530     }
1531     assert(new_ik != NULL, &quot;invariant&quot;);
1532     // We now need to explicitly tag the replaced klass as the jdk.jfr.Event klass
1533     assert(!JdkJfrEvent::is(new_ik), &quot;invariant&quot;);
1534     JdkJfrEvent::tag_as(new_ik);
1535     assert(JdkJfrEvent::is(new_ik), &quot;invariant&quot;);
1536     rewrite_klass_pointer(ik, new_ik, parser, THREAD);
1537     return;
1538   }
1539   assert(JdkJfrEvent::is_subklass(ik), &quot;invariant&quot;);
1540   if (ik-&gt;is_abstract() || is_retransforming(ik, THREAD)) {
1541     // abstract and scratch classes are not instrumented
1542     return;
1543   }
1544   ResourceMark rm(THREAD);
1545   HandleMark hm(THREAD);
1546   ClassFileStream* const new_stream = create_new_bytes_for_subklass(ik, parser, THREAD);
1547   if (NULL == new_stream) {
1548     log_error(jfr, system)(&quot;JfrClassAdapter: unable to create ClassFileStream&quot;);
1549     return;
1550   }
1551   assert(new_stream != NULL, &quot;invariant&quot;);
1552   InstanceKlass* new_ik = create_new_instance_klass(ik, new_stream, THREAD);
1553   if (new_ik == NULL) {
1554     log_error(jfr, system)(&quot;JfrClassAdapter: unable to create InstanceKlass&quot;);
1555     return;
1556   }
1557   assert(new_ik != NULL, &quot;invariant&quot;);
1558   // would have been tagged already as a subklass during the normal process of traceid assignment
1559   assert(JdkJfrEvent::is_subklass(new_ik), &quot;invariant&quot;);
1560   traceid id = ik-&gt;trace_id();
1561   ik-&gt;set_trace_id(0);
1562   new_ik-&gt;set_trace_id(id);
1563   rewrite_klass_pointer(ik, new_ik, parser, THREAD);
1564 }
1565 
1566 static bool _force_instrumentation = false;
1567 void JfrEventClassTransformer::set_force_instrumentation(bool force_instrumentation) {
1568   _force_instrumentation = force_instrumentation;
1569 }
1570 
1571 bool JfrEventClassTransformer::is_force_instrumentation() {
1572   return _force_instrumentation;
1573 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
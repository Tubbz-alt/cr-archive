diff a/src/hotspot/share/jfr/recorder/service/jfrEvent.hpp b/src/hotspot/share/jfr/recorder/service/jfrEvent.hpp
--- a/src/hotspot/share/jfr/recorder/service/jfrEvent.hpp
+++ b/src/hotspot/share/jfr/recorder/service/jfrEvent.hpp
@@ -117,10 +117,18 @@
 
   static bool is_stacktrace_enabled() {
     return JfrEventSetting::has_stacktrace(T::eventId);
   }
 
+  static bool is_large() {
+    return JfrEventSetting::is_large(T::eventId);
+  }
+
+  static void set_large() {
+    JfrEventSetting::set_large(T::eventId);
+  }
+
   static JfrEventId id() {
     return T::eventId;
   }
 
   static bool is_instant() {
@@ -158,11 +166,27 @@
     JfrBuffer* const buffer = tl->native_buffer();
     if (buffer == NULL) {
       // most likely a pending OOM
       return;
     }
+    bool large = is_large();
+    if (write_sized_event(buffer, event_thread, tl, large)) {
+      // Event written succesfully
+      return;
+    }
+    if (!large) {
+      // Try large size
+      if (write_sized_event(buffer, event_thread, tl, true)) {
+        // Event written succesfully, use large size from now on
+        set_large();
+      }
+    }
+  }
+
+  bool write_sized_event(JfrBuffer* const buffer, Thread* const event_thread, JfrThreadLocal* const tl, bool large_size) {
     JfrNativeEventWriter writer(buffer, event_thread);
+    writer.begin_event_write(large_size);
     writer.write<u8>(T::eventId);
     assert(_start_time != 0, "invariant");
     writer.write(_start_time);
     if (!(T::isInstant || T::isRequestable) || T::hasCutoff) {
       assert(_end_time != 0, "invariant");
@@ -182,20 +206,21 @@
         writer.write<traceid>(0);
       }
     }
     // payload
     static_cast<T*>(this)->writeData(writer);
+    return writer.end_event_write(large_size) > 0;
   }
 
 #ifdef ASSERT
  private:
   // verification of event fields
   JfrEventVerifier _verifier;
 
   void assert_precondition() {
-    assert(T::eventId >= (JfrEventId)NUM_RESERVED_EVENTS, "event id underflow invariant");
-    assert(T::eventId < MaxJfrEventId, "event id overflow invariant");
+    assert(T::eventId >= FIRST_EVENT_ID, "event id underflow invariant");
+    assert(T::eventId <= LAST_EVENT_ID, "event id overflow invariant");
     DEBUG_ONLY(static_cast<T*>(this)->verify());
   }
 
  protected:
   void set_field_bit(size_t field_idx) {

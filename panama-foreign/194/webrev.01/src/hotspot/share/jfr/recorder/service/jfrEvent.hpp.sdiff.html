<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/service/jfrEvent.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../repository/jfrChunkWriter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../storage/jfrStorage.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/service/jfrEvent.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
102   void set_endtime(const JfrTicks&amp; time) {
103     _end_time = time.value();
104   }
105 
106   void set_starttime(const Ticks&amp; time) {
107     _start_time = JfrTime::is_ft_enabled() ? time.ft_value() : time.value();
108   }
109 
110   void set_endtime(const Ticks&amp; time) {
111     _end_time = JfrTime::is_ft_enabled() ? time.ft_value() : time.value();
112   }
113 
114   static bool is_enabled() {
115     return JfrEventSetting::is_enabled(T::eventId);
116   }
117 
118   static bool is_stacktrace_enabled() {
119     return JfrEventSetting::has_stacktrace(T::eventId);
120   }
121 








122   static JfrEventId id() {
123     return T::eventId;
124   }
125 
126   static bool is_instant() {
127     return T::isInstant;
128   }
129 
130   static bool is_requestable() {
131     return T::isRequestable;
132   }
133 
134   static bool has_thread() {
135     return T::hasThread;
136   }
137 
138   static bool has_stacktrace() {
139     return T::hasStackTrace;
140   }
141 
</pre>
<hr />
<pre>
143     return _started;
144   }
145 
146  private:
147   bool should_write() {
148     if (T::isInstant || T::isRequestable || T::hasCutoff) {
149       return true;
150     }
151     return (_end_time - _start_time) &gt;= JfrEventSetting::threshold(T::eventId);
152   }
153 
154   void write_event() {
155     DEBUG_ONLY(assert_precondition();)
156     Thread* const event_thread = Thread::current();
157     JfrThreadLocal* const tl = event_thread-&gt;jfr_thread_local();
158     JfrBuffer* const buffer = tl-&gt;native_buffer();
159     if (buffer == NULL) {
160       // most likely a pending OOM
161       return;
162     }















163     JfrNativeEventWriter writer(buffer, event_thread);

164     writer.write&lt;u8&gt;(T::eventId);
165     assert(_start_time != 0, &quot;invariant&quot;);
166     writer.write(_start_time);
167     if (!(T::isInstant || T::isRequestable) || T::hasCutoff) {
168       assert(_end_time != 0, &quot;invariant&quot;);
169       writer.write(_end_time - _start_time);
170     }
171     if (T::hasThread) {
172       writer.write(tl-&gt;thread_id());
173     }
174     if (T::hasStackTrace) {
175       if (is_stacktrace_enabled()) {
176         if (tl-&gt;has_cached_stack_trace()) {
177           writer.write(tl-&gt;cached_stack_trace_id());
178         } else {
179           writer.write(JfrStackTraceRepository::record(event_thread));
180         }
181       } else {
182         writer.write&lt;traceid&gt;(0);
183       }
184     }
185     // payload
186     static_cast&lt;T*&gt;(this)-&gt;writeData(writer);

187   }
188 
189 #ifdef ASSERT
190  private:
191   // verification of event fields
192   JfrEventVerifier _verifier;
193 
194   void assert_precondition() {
<span class="line-modified">195     assert(T::eventId &gt;= (JfrEventId)NUM_RESERVED_EVENTS, &quot;event id underflow invariant&quot;);</span>
<span class="line-modified">196     assert(T::eventId &lt; MaxJfrEventId, &quot;event id overflow invariant&quot;);</span>
197     DEBUG_ONLY(static_cast&lt;T*&gt;(this)-&gt;verify());
198   }
199 
200  protected:
201   void set_field_bit(size_t field_idx) {
202     _verifier.set_field_bit(field_idx);
203     // it is ok to reuse an already committed event
204     // granted you provide new informational content
205     _verifier.clear_committed();
206   }
207 
208   bool verify_field_bit(size_t field_idx) const {
209     return _verifier.verify_field_bit(field_idx);
210   }
211 #endif // ASSERT
212 };
213 
214 #endif // SHARE_JFR_RECORDER_SERVICE_JFREVENT_HPP
</pre>
</td>
<td>
<hr />
<pre>
102   void set_endtime(const JfrTicks&amp; time) {
103     _end_time = time.value();
104   }
105 
106   void set_starttime(const Ticks&amp; time) {
107     _start_time = JfrTime::is_ft_enabled() ? time.ft_value() : time.value();
108   }
109 
110   void set_endtime(const Ticks&amp; time) {
111     _end_time = JfrTime::is_ft_enabled() ? time.ft_value() : time.value();
112   }
113 
114   static bool is_enabled() {
115     return JfrEventSetting::is_enabled(T::eventId);
116   }
117 
118   static bool is_stacktrace_enabled() {
119     return JfrEventSetting::has_stacktrace(T::eventId);
120   }
121 
<span class="line-added">122   static bool is_large() {</span>
<span class="line-added">123     return JfrEventSetting::is_large(T::eventId);</span>
<span class="line-added">124   }</span>
<span class="line-added">125 </span>
<span class="line-added">126   static void set_large() {</span>
<span class="line-added">127     JfrEventSetting::set_large(T::eventId);</span>
<span class="line-added">128   }</span>
<span class="line-added">129 </span>
130   static JfrEventId id() {
131     return T::eventId;
132   }
133 
134   static bool is_instant() {
135     return T::isInstant;
136   }
137 
138   static bool is_requestable() {
139     return T::isRequestable;
140   }
141 
142   static bool has_thread() {
143     return T::hasThread;
144   }
145 
146   static bool has_stacktrace() {
147     return T::hasStackTrace;
148   }
149 
</pre>
<hr />
<pre>
151     return _started;
152   }
153 
154  private:
155   bool should_write() {
156     if (T::isInstant || T::isRequestable || T::hasCutoff) {
157       return true;
158     }
159     return (_end_time - _start_time) &gt;= JfrEventSetting::threshold(T::eventId);
160   }
161 
162   void write_event() {
163     DEBUG_ONLY(assert_precondition();)
164     Thread* const event_thread = Thread::current();
165     JfrThreadLocal* const tl = event_thread-&gt;jfr_thread_local();
166     JfrBuffer* const buffer = tl-&gt;native_buffer();
167     if (buffer == NULL) {
168       // most likely a pending OOM
169       return;
170     }
<span class="line-added">171     bool large = is_large();</span>
<span class="line-added">172     if (write_sized_event(buffer, event_thread, tl, large)) {</span>
<span class="line-added">173       // Event written succesfully</span>
<span class="line-added">174       return;</span>
<span class="line-added">175     }</span>
<span class="line-added">176     if (!large) {</span>
<span class="line-added">177       // Try large size</span>
<span class="line-added">178       if (write_sized_event(buffer, event_thread, tl, true)) {</span>
<span class="line-added">179         // Event written succesfully, use large size from now on</span>
<span class="line-added">180         set_large();</span>
<span class="line-added">181       }</span>
<span class="line-added">182     }</span>
<span class="line-added">183   }</span>
<span class="line-added">184 </span>
<span class="line-added">185   bool write_sized_event(JfrBuffer* const buffer, Thread* const event_thread, JfrThreadLocal* const tl, bool large_size) {</span>
186     JfrNativeEventWriter writer(buffer, event_thread);
<span class="line-added">187     writer.begin_event_write(large_size);</span>
188     writer.write&lt;u8&gt;(T::eventId);
189     assert(_start_time != 0, &quot;invariant&quot;);
190     writer.write(_start_time);
191     if (!(T::isInstant || T::isRequestable) || T::hasCutoff) {
192       assert(_end_time != 0, &quot;invariant&quot;);
193       writer.write(_end_time - _start_time);
194     }
195     if (T::hasThread) {
196       writer.write(tl-&gt;thread_id());
197     }
198     if (T::hasStackTrace) {
199       if (is_stacktrace_enabled()) {
200         if (tl-&gt;has_cached_stack_trace()) {
201           writer.write(tl-&gt;cached_stack_trace_id());
202         } else {
203           writer.write(JfrStackTraceRepository::record(event_thread));
204         }
205       } else {
206         writer.write&lt;traceid&gt;(0);
207       }
208     }
209     // payload
210     static_cast&lt;T*&gt;(this)-&gt;writeData(writer);
<span class="line-added">211     return writer.end_event_write(large_size) &gt; 0;</span>
212   }
213 
214 #ifdef ASSERT
215  private:
216   // verification of event fields
217   JfrEventVerifier _verifier;
218 
219   void assert_precondition() {
<span class="line-modified">220     assert(T::eventId &gt;= FIRST_EVENT_ID, &quot;event id underflow invariant&quot;);</span>
<span class="line-modified">221     assert(T::eventId &lt;= LAST_EVENT_ID, &quot;event id overflow invariant&quot;);</span>
222     DEBUG_ONLY(static_cast&lt;T*&gt;(this)-&gt;verify());
223   }
224 
225  protected:
226   void set_field_bit(size_t field_idx) {
227     _verifier.set_field_bit(field_idx);
228     // it is ok to reuse an already committed event
229     // granted you provide new informational content
230     _verifier.clear_committed();
231   }
232 
233   bool verify_field_bit(size_t field_idx) const {
234     return _verifier.verify_field_bit(field_idx);
235   }
236 #endif // ASSERT
237 };
238 
239 #endif // SHARE_JFR_RECORDER_SERVICE_JFREVENT_HPP
</pre>
</td>
</tr>
</table>
<center><a href="../repository/jfrChunkWriter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../storage/jfrStorage.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/classfile/javaClasses.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_JAVACLASSES_INLINE_HPP
 26 #define SHARE_CLASSFILE_JAVACLASSES_INLINE_HPP
 27 
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;oops/access.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;oops/oopsHierarchy.hpp&quot;
 32 
 33 void java_lang_String::set_coder(oop string, jbyte coder) {
 34   string-&gt;byte_field_put(_coder_offset, coder);
 35 }
 36 
 37 void java_lang_String::set_value_raw(oop string, typeArrayOop buffer) {
 38   string-&gt;obj_field_put_raw(_value_offset, buffer);
 39 }
 40 
 41 void java_lang_String::set_value(oop string, typeArrayOop buffer) {
 42   string-&gt;obj_field_put(_value_offset, (oop)buffer);
 43 }
 44 
 45 bool java_lang_String::hash_is_set(oop java_string) {
 46   return java_string-&gt;int_field(_hash_offset) != 0 || java_string-&gt;bool_field(_hashIsZero_offset) != 0;
 47 }
 48 
 49 // Accessors
 50 bool java_lang_String::value_equals(typeArrayOop str_value1, typeArrayOop str_value2) {
 51   return ((str_value1 == str_value2) ||
 52           (str_value1-&gt;length() == str_value2-&gt;length() &amp;&amp;
 53            (!memcmp(str_value1-&gt;base(T_BYTE),
 54                     str_value2-&gt;base(T_BYTE),
 55                     str_value2-&gt;length() * sizeof(jbyte)))));
 56 }
 57 
 58 typeArrayOop java_lang_String::value(oop java_string) {
 59   assert(is_instance(java_string), &quot;must be java_string&quot;);
 60   return (typeArrayOop) java_string-&gt;obj_field(_value_offset);
 61 }
 62 
 63 typeArrayOop java_lang_String::value_no_keepalive(oop java_string) {
 64   assert(is_instance(java_string), &quot;must be java_string&quot;);
 65   return (typeArrayOop) java_string-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(_value_offset);
 66 }
 67 
 68 bool java_lang_String::is_latin1(oop java_string) {
 69   assert(is_instance(java_string), &quot;must be java_string&quot;);
 70   jbyte coder = java_string-&gt;byte_field(_coder_offset);
 71   assert(CompactStrings || coder == CODER_UTF16, &quot;Must be UTF16 without CompactStrings&quot;);
 72   return coder == CODER_LATIN1;
 73 }
 74 
 75 int java_lang_String::length(oop java_string, typeArrayOop value) {
 76   assert(_initialized, &quot;Must be initialized&quot;);
 77   assert(is_instance(java_string), &quot;must be java_string&quot;);
 78   assert(value_equals(value, java_lang_String::value(java_string)),
 79          &quot;value must be equal to java_lang_String::value(java_string)&quot;);
 80   if (value == NULL) {
 81     return 0;
 82   }
 83   int arr_length = value-&gt;length();
 84   if (!is_latin1(java_string)) {
 85     assert((arr_length &amp; 1) == 0, &quot;should be even for UTF16 string&quot;);
 86     arr_length &gt;&gt;= 1; // convert number of bytes to number of elements
 87   }
 88   return arr_length;
 89 }
 90 
 91 int java_lang_String::length(oop java_string) {
 92   assert(_initialized, &quot;Must be initialized&quot;);
 93   assert(is_instance(java_string), &quot;must be java_string&quot;);
 94   typeArrayOop value = java_lang_String::value_no_keepalive(java_string);
 95   return length(java_string, value);
 96 }
 97 
 98 bool java_lang_String::is_instance_inlined(oop obj) {
 99   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::String_klass();
100 }
101 
102 // Accessors
103 oop java_lang_ref_Reference::referent(oop ref) {
104   return ref-&gt;obj_field(_referent_offset);
105 }
106 
107 void java_lang_ref_Reference::set_referent(oop ref, oop value) {
108   ref-&gt;obj_field_put(_referent_offset, value);
109 }
110 
111 void java_lang_ref_Reference::set_referent_raw(oop ref, oop value) {
112   ref-&gt;obj_field_put_raw(_referent_offset, value);
113 }
114 
115 HeapWord* java_lang_ref_Reference::referent_addr_raw(oop ref) {
116   return ref-&gt;obj_field_addr_raw&lt;HeapWord&gt;(_referent_offset);
117 }
118 
119 oop java_lang_ref_Reference::next(oop ref) {
120   return ref-&gt;obj_field(_next_offset);
121 }
122 
123 void java_lang_ref_Reference::set_next(oop ref, oop value) {
124   ref-&gt;obj_field_put(_next_offset, value);
125 }
126 
127 void java_lang_ref_Reference::set_next_raw(oop ref, oop value) {
128   ref-&gt;obj_field_put_raw(_next_offset, value);
129 }
130 
131 HeapWord* java_lang_ref_Reference::next_addr_raw(oop ref) {
132   return ref-&gt;obj_field_addr_raw&lt;HeapWord&gt;(_next_offset);
133 }
134 
135 oop java_lang_ref_Reference::discovered(oop ref) {
136   return ref-&gt;obj_field(_discovered_offset);
137 }
138 
139 void java_lang_ref_Reference::set_discovered(oop ref, oop value) {
140   ref-&gt;obj_field_put(_discovered_offset, value);
141 }
142 
143 void java_lang_ref_Reference::set_discovered_raw(oop ref, oop value) {
144   ref-&gt;obj_field_put_raw(_discovered_offset, value);
145 }
146 
147 HeapWord* java_lang_ref_Reference::discovered_addr_raw(oop ref) {
148   return ref-&gt;obj_field_addr_raw&lt;HeapWord&gt;(_discovered_offset);
149 }
150 
151 bool java_lang_ref_Reference::is_final(oop ref) {
152   return InstanceKlass::cast(ref-&gt;klass())-&gt;reference_type() == REF_FINAL;
153 }
154 
155 bool java_lang_ref_Reference::is_phantom(oop ref) {
156   return InstanceKlass::cast(ref-&gt;klass())-&gt;reference_type() == REF_PHANTOM;
157 }
158 
159 inline void java_lang_invoke_CallSite::set_target_volatile(oop site, oop target) {
160   site-&gt;obj_field_put_volatile(_target_offset, target);
161 }
162 
163 inline oop  java_lang_invoke_CallSite::target(oop site) {
164   return site-&gt;obj_field(_target_offset);
165 }
166 
167 inline void java_lang_invoke_CallSite::set_target(oop site, oop target) {
168   site-&gt;obj_field_put(_target_offset, target);
169 }
170 
171 inline bool java_lang_invoke_CallSite::is_instance(oop obj) {
172   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
173 }
174 
175 inline jboolean java_lang_invoke_ConstantCallSite::is_frozen(oop site) {
176   return site-&gt;bool_field(_is_frozen_offset);
177 }
178 
179 inline bool java_lang_invoke_ConstantCallSite::is_instance(oop obj) {
180   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
181 }
182 
183 inline bool java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(oop obj) {
184   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
185 }
186 
187 inline bool java_lang_invoke_MemberName::is_instance(oop obj) {
188   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::MemberName_klass();
189 }
190 
191 inline bool java_lang_invoke_ResolvedMethodName::is_instance(oop obj) {
192   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::ResolvedMethodName_klass();
193 }
194 
195 inline bool java_lang_invoke_MethodType::is_instance(oop obj) {
196   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::MethodType_klass();
197 }
198 
199 inline bool java_lang_invoke_MethodHandle::is_instance(oop obj) {
200   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
201 }
202 
203 inline bool java_lang_Class::is_instance(oop obj) {
204   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::Class_klass();
205 }
206 
207 inline Klass* java_lang_Class::as_Klass(oop java_class) {
208   //%note memory_2
209   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
210   Klass* k = ((Klass*)java_class-&gt;metadata_field(_klass_offset));
211   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
212   return k;
213 }
214 
215 inline bool java_lang_Class::is_primitive(oop java_class) {
216   // should assert:
217   //assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
218   bool is_primitive = (java_class-&gt;metadata_field(_klass_offset) == NULL);
219 
220 #ifdef ASSERT
221   if (is_primitive) {
222     Klass* k = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
223     assert(k == NULL || is_java_primitive(ArrayKlass::cast(k)-&gt;element_type()),
224         &quot;Should be either the T_VOID primitive or a java primitive&quot;);
225   }
226 #endif
227 
228   return is_primitive;
229 }
230 
231 inline int java_lang_Class::oop_size_raw(oop java_class) {
232   assert(_oop_size_offset != 0, &quot;must be set&quot;);
233   int size = java_class-&gt;int_field_raw(_oop_size_offset);
234   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
235   return size;
236 }
237 
238 inline bool java_lang_invoke_DirectMethodHandle::is_instance(oop obj) {
239   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
240 }
241 
242 inline bool java_lang_Module::is_instance(oop obj) {
243   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::Module_klass();
244 }
245 
246 inline int Backtrace::merge_bci_and_version(int bci, int version) {
247   // only store u2 for version, checking for overflow.
248   if (version &gt; USHRT_MAX || version &lt; 0) version = USHRT_MAX;
249   assert((jushort)bci == bci, &quot;bci should be short&quot;);
250   return build_int_from_shorts(version, bci);
251 }
252 
253 inline int Backtrace::merge_mid_and_cpref(int mid, int cpref) {
254   // only store u2 for mid and cpref, checking for overflow.
255   assert((jushort)mid == mid, &quot;mid should be short&quot;);
256   assert((jushort)cpref == cpref, &quot;cpref should be short&quot;);
257   return build_int_from_shorts(cpref, mid);
258 }
259 
260 inline int Backtrace::bci_at(unsigned int merged) {
261   return extract_high_short_from_int(merged);
262 }
263 
264 inline int Backtrace::version_at(unsigned int merged) {
265   return extract_low_short_from_int(merged);
266 }
267 
268 inline int Backtrace::mid_at(unsigned int merged) {
269   return extract_high_short_from_int(merged);
270 }
271 
272 inline int Backtrace::cpref_at(unsigned int merged) {
273   return extract_low_short_from_int(merged);
274 }
275 
276 inline int Backtrace::get_line_number(Method* method, int bci) {
277   int line_number = 0;
278   if (method-&gt;is_native()) {
279     // Negative value different from -1 below, enabling Java code in
280     // class java.lang.StackTraceElement to distinguish &quot;native&quot; from
281     // &quot;no LineNumberTable&quot;.  JDK tests for -2.
282     line_number = -2;
283   } else {
284     // Returns -1 if no LineNumberTable, and otherwise actual line number
285     line_number = method-&gt;line_number_from_bci(bci);
286   }
287   return line_number;
288 }
289 
290 inline Symbol* Backtrace::get_source_file_name(InstanceKlass* holder, int version) {
291   // RedefineClasses() currently permits redefine operations to
292   // happen in parallel using a &quot;last one wins&quot; philosophy. That
293   // spec laxness allows the constant pool entry associated with
294   // the source_file_name_index for any older constant pool version
295   // to be unstable so we shouldn&#39;t try to use it.
296   if (holder-&gt;constants()-&gt;version() != version) {
297     return NULL;
298   } else {
299     return holder-&gt;source_file_name();
300   }
301 }
302 
303 #endif // SHARE_CLASSFILE_JAVACLASSES_INLINE_HPP
    </pre>
  </body>
</html>
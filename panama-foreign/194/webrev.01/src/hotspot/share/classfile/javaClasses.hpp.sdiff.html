<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  63   f(java_lang_reflect_Constructor) \
  64   f(java_lang_reflect_Field) \
  65   f(java_lang_reflect_RecordComponent) \
  66   f(java_nio_Buffer) \
  67   f(reflect_ConstantPool) \
  68   f(reflect_UnsafeStaticFieldAccessorImpl) \
  69   f(java_lang_reflect_Parameter) \
  70   f(java_lang_Module) \
  71   f(java_lang_StackTraceElement) \
  72   f(java_lang_StackFrameInfo) \
  73   f(java_lang_LiveStackFrameInfo) \
  74   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
  75   f(jdk_internal_misc_UnsafeConstants) \
  76   f(java_lang_boxing_object) \
  77   //end
  78 
  79 #define BASIC_JAVA_CLASSES_DO(f) \
  80         BASIC_JAVA_CLASSES_DO_PART1(f) \
  81         BASIC_JAVA_CLASSES_DO_PART2(f)
  82 


  83 // Interface to java.lang.Object objects
  84 
  85 class java_lang_Object : AllStatic {
  86  public:
  87   static void register_natives(TRAPS);
  88 };
  89 
  90 // Interface to java.lang.String objects
  91 
  92 class java_lang_String : AllStatic {
  93  private:
<span class="line-modified">  94   static int value_offset;</span>
<span class="line-modified">  95   static int hash_offset;</span>
<span class="line-modified">  96   static int hashIsZero_offset;</span>
<span class="line-modified">  97   static int coder_offset;</span>
  98 
<span class="line-modified">  99   static bool initialized;</span>
 100 
 101   static Handle basic_create(int length, bool byte_arr, TRAPS);
 102 
 103   static inline void set_coder(oop string, jbyte coder);
 104 
 105  public:
 106 
 107   // Coders
 108   enum Coder {
 109     CODER_LATIN1 =  0,
 110     CODER_UTF16  =  1
 111   };
 112 
 113   static void compute_offsets();
 114   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 115 
 116   // Instance creation
 117   static Handle create_from_unicode(const jchar* unicode, int len, TRAPS);
 118   static oop    create_oop_from_unicode(const jchar* unicode, int len, TRAPS);
 119   static Handle create_from_str(const char* utf8_str, TRAPS);
 120   static oop    create_oop_from_str(const char* utf8_str, TRAPS);
 121   static Handle create_from_symbol(Symbol* symbol, TRAPS);
 122   static Handle create_from_platform_dependent_str(const char* str, TRAPS);
 123   static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);
 124 
 125   static void set_compact_strings(bool value);
 126 
<span class="line-modified"> 127   static int value_offset_in_bytes()  {</span>
<span class="line-modified"> 128     assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);</span>
<span class="line-removed"> 129     return value_offset;</span>
<span class="line-removed"> 130   }</span>
<span class="line-removed"> 131   static int hash_offset_in_bytes()   {</span>
<span class="line-removed"> 132     assert(initialized &amp;&amp; (hash_offset &gt; 0), &quot;Must be initialized&quot;);</span>
<span class="line-removed"> 133     return hash_offset;</span>
<span class="line-removed"> 134   }</span>
<span class="line-removed"> 135   static int hashIsZero_offset_in_bytes()   {</span>
<span class="line-removed"> 136     assert(initialized &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);</span>
<span class="line-removed"> 137     return hashIsZero_offset;</span>
<span class="line-removed"> 138   }</span>
<span class="line-removed"> 139   static int coder_offset_in_bytes()   {</span>
<span class="line-removed"> 140     assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);</span>
<span class="line-removed"> 141     return coder_offset;</span>
<span class="line-removed"> 142   }</span>
 143 
 144   static inline void set_value_raw(oop string, typeArrayOop buffer);
 145   static inline void set_value(oop string, typeArrayOop buffer);
 146 
 147   // Accessors
 148   static inline typeArrayOop value(oop java_string);
 149   static inline typeArrayOop value_no_keepalive(oop java_string);
 150   static inline bool hash_is_set(oop string);
 151   static inline bool is_latin1(oop java_string);
 152   static inline int length(oop java_string);
 153   static inline int length(oop java_string, typeArrayOop string_value);
 154   static int utf8_length(oop java_string);
 155   static int utf8_length(oop java_string, typeArrayOop string_value);
 156 
 157   // String converters
 158   static char*  as_utf8_string(oop java_string);
 159   static char*  as_utf8_string(oop java_string, int&amp; length);
 160   static char*  as_utf8_string_full(oop java_string, char* buf, int buflen, int&amp; length);
 161   static char*  as_utf8_string(oop java_string, char* buf, int buflen);
 162   static char*  as_utf8_string(oop java_string, int start, int len);
</pre>
<hr />
<pre>
 220   friend class StringTable;
 221 };
 222 
 223 
 224 // Interface to java.lang.Class objects
 225 
 226 #define CLASS_INJECTED_FIELDS(macro)                                       \
 227   macro(java_lang_Class, klass,                  intptr_signature,  false) \
 228   macro(java_lang_Class, array_klass,            intptr_signature,  false) \
 229   macro(java_lang_Class, oop_size,               int_signature,     false) \
 230   macro(java_lang_Class, static_oop_field_count, int_signature,     false) \
 231   macro(java_lang_Class, protection_domain,      object_signature,  false) \
 232   macro(java_lang_Class, signers,                object_signature,  false) \
 233   macro(java_lang_Class, source_file,            object_signature,  false) \
 234 
 235 class java_lang_Class : AllStatic {
 236   friend class VMStructs;
 237   friend class JVMCIVMStructs;
 238 
 239  private:

 240   // The fake offsets are added by the class loader when java.lang.Class is loaded
 241 
 242   static int _klass_offset;
 243   static int _array_klass_offset;
 244 
 245   static int _oop_size_offset;
 246   static int _static_oop_field_count_offset;
 247 
 248   static int _protection_domain_offset;
 249   static int _init_lock_offset;
 250   static int _signers_offset;
 251   static int _class_loader_offset;
 252   static int _module_offset;
 253   static int _component_mirror_offset;
 254   static int _name_offset;
 255   static int _source_file_offset;
 256   static int _classData_offset;

 257 
<span class="line-modified"> 258   static bool offsets_computed;</span>
<span class="line-removed"> 259   static int classRedefinedCount_offset;</span>
 260 
 261   static GrowableArray&lt;Klass*&gt;* _fixup_mirror_list;
 262   static GrowableArray&lt;Klass*&gt;* _fixup_module_field_list;
 263 
 264   static void set_init_lock(oop java_class, oop init_lock);
 265   static void set_protection_domain(oop java_class, oop protection_domain);
 266   static void set_class_loader(oop java_class, oop class_loader);
 267   static void set_component_mirror(oop java_class, oop comp_mirror);
 268   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain,
 269                                        Handle classData, TRAPS);
 270   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
 271  public:
 272   static void allocate_fixup_lists();
 273   static void compute_offsets();
 274 
 275   // Instance creation
 276   static void create_mirror(Klass* k, Handle class_loader, Handle module,
 277                             Handle protection_domain, Handle classData, TRAPS);
 278   static void fixup_mirror(Klass* k, TRAPS);
 279   static oop  create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS);
</pre>
<hr />
<pre>
 293   static void fixup_module_field(Klass* k, Handle module);
 294 
 295   // Conversion
 296   static Klass* as_Klass(oop java_class);
 297   static Klass* as_Klass_raw(oop java_class);
 298   static void set_klass(oop java_class, Klass* klass);
 299   static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);
 300   static Symbol* as_signature(oop java_class, bool intern_if_not_found);
 301   static void print_signature(oop java_class, outputStream *st);
 302   static const char* as_external_name(oop java_class);
 303   // Testing
 304   static bool is_instance(oop obj);
 305 
 306   static bool is_primitive(oop java_class);
 307   static BasicType primitive_type(oop java_class);
 308   static oop primitive_mirror(BasicType t);
 309   // JVM_NewArray support
 310   static Klass* array_klass_acquire(oop java_class);
 311   static void release_set_array_klass(oop java_class, Klass* klass);
 312   // compiler support for class operations
<span class="line-modified"> 313   static int klass_offset_in_bytes()                { return _klass_offset; }</span>
<span class="line-modified"> 314   static int array_klass_offset_in_bytes()          { return _array_klass_offset; }</span>
 315   // Support for classRedefinedCount field
 316   static int classRedefinedCount(oop the_class_mirror);
 317   static void set_classRedefinedCount(oop the_class_mirror, int value);
 318 
 319   // Support for embedded per-class oops
 320   static oop  protection_domain(oop java_class);
 321   static oop  init_lock(oop java_class);



 322   static oop  component_mirror(oop java_class);
 323   static objArrayOop  signers(oop java_class);
 324   static void set_signers(oop java_class, objArrayOop signers);
 325   static oop  class_data(oop java_class);
 326   static void set_class_data(oop java_class, oop classData);
 327 
 328   static oop class_loader(oop java_class);
 329   static void set_module(oop java_class, oop module);
 330   static oop module(oop java_class);
 331 
 332   static oop name(Handle java_class, TRAPS);
 333 
 334   static oop source_file(oop java_class);
 335   static void set_source_file(oop java_class, oop source_file);
 336 
 337   static int oop_size(oop java_class);
 338   static int oop_size_raw(oop java_class);
 339   static void set_oop_size(HeapWord* java_class, int size);
 340   static int static_oop_field_count(oop java_class);
 341   static int static_oop_field_count_raw(oop java_class);
 342   static void set_static_oop_field_count(oop java_class, int size);
 343 
 344   static GrowableArray&lt;Klass*&gt;* fixup_mirror_list() {
 345     return _fixup_mirror_list;
 346   }
 347   static void set_fixup_mirror_list(GrowableArray&lt;Klass*&gt;* v) {
 348     _fixup_mirror_list = v;
 349   }
 350 
 351   static GrowableArray&lt;Klass*&gt;* fixup_module_field_list() {
 352     return _fixup_module_field_list;
 353   }
 354   static void set_fixup_module_field_list(GrowableArray&lt;Klass*&gt;* v) {
 355     _fixup_module_field_list = v;
 356   }
 357 
 358   // Debugging
 359   friend class JavaClasses;
<span class="line-removed"> 360   friend class InstanceKlass;   // verification code accesses offsets</span>
<span class="line-removed"> 361   friend class ClassFileParser; // access to number_of_fake_fields</span>
 362 };
 363 
 364 // Interface to java.lang.Thread objects
 365 
 366 class java_lang_Thread : AllStatic {
 367  private:
 368   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
 369   // so we compute the offsets at startup rather than hard-wiring them.
 370   static int _name_offset;
 371   static int _group_offset;
 372   static int _contextClassLoader_offset;
 373   static int _inheritedAccessControlContext_offset;
 374   static int _priority_offset;
 375   static int _eetop_offset;
 376   static int _interrupted_offset;
 377   static int _daemon_offset;
 378   static int _stillborn_offset;
 379   static int _stackSize_offset;
 380   static int _tid_offset;
 381   static int _thread_status_offset;
</pre>
<hr />
<pre>
 512 
 513 // Interface to java.lang.Throwable objects
 514 
 515 class java_lang_Throwable: AllStatic {
 516   friend class BacktraceBuilder;
 517   friend class BacktraceIterator;
 518 
 519  private:
 520   // Trace constants
 521   enum {
 522     trace_methods_offset = 0,
 523     trace_bcis_offset    = 1,
 524     trace_mirrors_offset = 2,
 525     trace_names_offset   = 3,
 526     trace_next_offset    = 4,
 527     trace_hidden_offset  = 5,
 528     trace_size           = 6,
 529     trace_chunk_size     = 32
 530   };
 531 
<span class="line-modified"> 532   static int backtrace_offset;</span>
<span class="line-modified"> 533   static int detailMessage_offset;</span>
<span class="line-modified"> 534   static int stackTrace_offset;</span>
<span class="line-modified"> 535   static int depth_offset;</span>
<span class="line-modified"> 536   static int static_unassigned_stacktrace_offset;</span>
 537 
 538   // StackTrace (programmatic access, new since 1.4)
 539   static void clear_stacktrace(oop throwable);
 540   // Stacktrace (post JDK 1.7.0 to allow immutability protocol to be followed)
 541   static void set_stacktrace(oop throwable, oop st_element_array);
 542   static oop unassigned_stacktrace();
 543 
 544  public:
 545   // Backtrace
 546   static oop backtrace(oop throwable);
 547   static void set_backtrace(oop throwable, oop value);
 548   static int depth(oop throwable);
 549   static void set_depth(oop throwable, int value);
<span class="line-modified"> 550   // Needed by JVMTI to filter out this internal field.</span>
<span class="line-removed"> 551   static int get_backtrace_offset() { return backtrace_offset;}</span>
<span class="line-removed"> 552   static int get_detailMessage_offset() { return detailMessage_offset;}</span>
 553   // Message
 554   static oop message(oop throwable);
 555   static void set_message(oop throwable, oop value);
 556   static Symbol* detail_message(oop throwable);
 557   static void print_stack_element(outputStream *st, Method* method, int bci);
 558   static void print_stack_usage(Handle stream);
 559 
 560   static void compute_offsets();
 561   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 562 
 563   // Allocate space for backtrace (created but stack trace not filled in)
 564   static void allocate_backtrace(Handle throwable, TRAPS);
 565   // Fill in current stack trace for throwable with preallocated backtrace (no GC)
 566   static void fill_in_stack_trace_of_preallocated_backtrace(Handle throwable);
 567   // Fill in current stack trace, can cause GC
 568   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS);
 569   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method = methodHandle());
 570   // Programmatic access to stack trace
 571   static void get_stack_trace_elements(Handle throwable, objArrayHandle stack_trace, TRAPS);
 572   // Printing
 573   static void print(oop throwable, outputStream* st);
 574   static void print_stack_trace(Handle throwable, outputStream* st);
 575   static void java_printStackTrace(Handle throwable, TRAPS);
 576   // Debugging
 577   friend class JavaClasses;
 578   // Gets the method and bci of the top frame (TOS). Returns false if this failed.
 579   static bool get_top_method_and_bci(oop throwable, Method** method, int* bci);
 580 };
 581 
 582 
 583 // Interface to java.lang.reflect.AccessibleObject objects
 584 
 585 class java_lang_reflect_AccessibleObject: AllStatic {
 586  private:
 587   // Note that to reduce dependencies on the JDK we compute these
 588   // offsets at run-time.
<span class="line-modified"> 589   static int override_offset;</span>
 590 
 591   static void compute_offsets();
 592 
 593  public:
 594   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 595 
 596   // Accessors
 597   static jboolean override(oop reflect);
 598   static void set_override(oop reflect, jboolean value);
 599 
 600   // Debugging
 601   friend class JavaClasses;
 602 };
 603 
 604 
 605 // Interface to java.lang.reflect.Method objects
 606 
 607 class java_lang_reflect_Method : public java_lang_reflect_AccessibleObject {
 608  private:
 609   // Note that to reduce dependencies on the JDK we compute these
 610   // offsets at run-time.
<span class="line-modified"> 611   static int clazz_offset;</span>
<span class="line-modified"> 612   static int name_offset;</span>
<span class="line-modified"> 613   static int returnType_offset;</span>
<span class="line-modified"> 614   static int parameterTypes_offset;</span>
<span class="line-modified"> 615   static int exceptionTypes_offset;</span>
<span class="line-modified"> 616   static int slot_offset;</span>
<span class="line-modified"> 617   static int modifiers_offset;</span>
<span class="line-modified"> 618   static int signature_offset;</span>
<span class="line-modified"> 619   static int annotations_offset;</span>
<span class="line-modified"> 620   static int parameter_annotations_offset;</span>
<span class="line-modified"> 621   static int annotation_default_offset;</span>
 622 
 623   static void compute_offsets();
 624  public:
 625   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 626 
 627   // Allocation
 628   static Handle create(TRAPS);
 629 
 630   // Accessors
 631   static oop clazz(oop reflect);
 632   static void set_clazz(oop reflect, oop value);
 633 
 634   static void set_name(oop method, oop value);
 635 
 636   static oop return_type(oop method);
 637   static void set_return_type(oop method, oop value);
 638 
 639   static oop parameter_types(oop method);
 640   static void set_parameter_types(oop method, oop value);
 641 
</pre>
<hr />
<pre>
 643   static void set_slot(oop reflect, int value);
 644 
 645   static void set_exception_types(oop method, oop value);
 646   static void set_modifiers(oop method, int value);
 647   static void set_signature(oop method, oop value);
 648   static void set_annotations(oop method, oop value);
 649   static void set_parameter_annotations(oop method, oop value);
 650   static void set_annotation_default(oop method, oop value);
 651 
 652   // Debugging
 653   friend class JavaClasses;
 654 };
 655 
 656 
 657 // Interface to java.lang.reflect.Constructor objects
 658 
 659 class java_lang_reflect_Constructor : public java_lang_reflect_AccessibleObject {
 660  private:
 661   // Note that to reduce dependencies on the JDK we compute these
 662   // offsets at run-time.
<span class="line-modified"> 663   static int clazz_offset;</span>
<span class="line-modified"> 664   static int parameterTypes_offset;</span>
<span class="line-modified"> 665   static int exceptionTypes_offset;</span>
<span class="line-modified"> 666   static int slot_offset;</span>
<span class="line-modified"> 667   static int modifiers_offset;</span>
<span class="line-modified"> 668   static int signature_offset;</span>
<span class="line-modified"> 669   static int annotations_offset;</span>
<span class="line-modified"> 670   static int parameter_annotations_offset;</span>
 671 
 672   static void compute_offsets();
 673  public:
 674   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 675 
 676   // Allocation
 677   static Handle create(TRAPS);
 678 
 679   // Accessors
 680   static oop clazz(oop reflect);
 681   static void set_clazz(oop reflect, oop value);
 682 
 683   static oop parameter_types(oop constructor);
 684   static void set_parameter_types(oop constructor, oop value);
 685 
 686   static int slot(oop reflect);
 687   static void set_slot(oop reflect, int value);
 688 
 689   static void set_exception_types(oop constructor, oop value);
 690   static void set_modifiers(oop constructor, int value);
 691   static void set_signature(oop constructor, oop value);
 692   static void set_annotations(oop constructor, oop value);
 693   static void set_parameter_annotations(oop method, oop value);
 694 
 695   // Debugging
 696   friend class JavaClasses;
 697 };
 698 
 699 
 700 // Interface to java.lang.reflect.Field objects
 701 
 702 class java_lang_reflect_Field : public java_lang_reflect_AccessibleObject {
 703  private:
 704   // Note that to reduce dependencies on the JDK we compute these
 705   // offsets at run-time.
<span class="line-modified"> 706   static int clazz_offset;</span>
<span class="line-modified"> 707   static int name_offset;</span>
<span class="line-modified"> 708   static int type_offset;</span>
<span class="line-modified"> 709   static int slot_offset;</span>
<span class="line-modified"> 710   static int modifiers_offset;</span>
<span class="line-modified"> 711   static int signature_offset;</span>
<span class="line-modified"> 712   static int annotations_offset;</span>
 713 
 714   static void compute_offsets();
 715 
 716  public:
 717   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 718 
 719   // Allocation
 720   static Handle create(TRAPS);
 721 
 722   // Accessors
 723   static oop clazz(oop reflect);
 724   static void set_clazz(oop reflect, oop value);
 725 
 726   static oop name(oop field);
 727   static void set_name(oop field, oop value);
 728 
 729   static oop type(oop field);
 730   static void set_type(oop field, oop value);
 731 
 732   static int slot(oop reflect);
 733   static void set_slot(oop reflect, int value);
 734 
 735   static int modifiers(oop field);
 736   static void set_modifiers(oop field, int value);
 737 
 738   static void set_signature(oop constructor, oop value);
 739   static void set_annotations(oop constructor, oop value);
 740   static void set_parameter_annotations(oop method, oop value);
 741   static void set_annotation_default(oop method, oop value);
 742 
 743   // Debugging
 744   friend class JavaClasses;
 745 };
 746 
 747 class java_lang_reflect_Parameter {
 748  private:
 749   // Note that to reduce dependencies on the JDK we compute these
 750   // offsets at run-time.
<span class="line-modified"> 751   static int name_offset;</span>
<span class="line-modified"> 752   static int modifiers_offset;</span>
<span class="line-modified"> 753   static int index_offset;</span>
<span class="line-modified"> 754   static int executable_offset;</span>
 755 
 756   static void compute_offsets();
 757 
 758  public:
 759   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 760 
 761   // Allocation
 762   static Handle create(TRAPS);
 763 
 764   // Accessors
 765   static oop name(oop field);
 766   static void set_name(oop field, oop value);
 767 
 768   static int index(oop reflect);
 769   static void set_index(oop reflect, int value);
 770 
 771   static int modifiers(oop reflect);
 772   static void set_modifiers(oop reflect, int value);
 773 
 774   static oop executable(oop constructor);
 775   static void set_executable(oop constructor, oop value);
 776 
 777   friend class JavaClasses;
 778 };
 779 
 780 #define MODULE_INJECTED_FIELDS(macro)                            \
 781   macro(java_lang_Module, module_entry, intptr_signature, false)
 782 
 783 class java_lang_Module {
 784   private:
<span class="line-modified"> 785     static int loader_offset;</span>
<span class="line-modified"> 786     static int name_offset;</span>
 787     static int _module_entry_offset;

 788     static void compute_offsets();
 789 
 790   public:
 791     static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 792 
 793     // Allocation
 794     static Handle create(Handle loader, Handle module_name, TRAPS);
 795 
 796     // Testers
 797     static bool is_instance(oop obj);
 798 
 799     // Accessors
 800     static oop loader(oop module);
 801     static void set_loader(oop module, oop value);
 802 
 803     static oop name(oop module);
 804     static void set_name(oop module, oop value);
 805 
 806     static ModuleEntry* module_entry(oop module);
 807     static void set_module_entry(oop module, ModuleEntry* module_entry);
</pre>
<hr />
<pre>
 809   friend class JavaClasses;
 810 };
 811 
 812 // Interface to jdk.internal.reflect.ConstantPool objects
 813 class reflect_ConstantPool {
 814  private:
 815   // Note that to reduce dependencies on the JDK we compute these
 816   // offsets at run-time.
 817   static int _oop_offset;
 818 
 819   static void compute_offsets();
 820 
 821  public:
 822   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 823 
 824   // Allocation
 825   static Handle create(TRAPS);
 826 
 827   // Accessors
 828   static void set_cp(oop reflect, ConstantPool* value);
<span class="line-modified"> 829   static int oop_offset() {</span>
<span class="line-removed"> 830     return _oop_offset;</span>
<span class="line-removed"> 831   }</span>
 832 
 833   static ConstantPool* get_cp(oop reflect);
 834 
 835   // Debugging
 836   friend class JavaClasses;
 837 };
 838 
 839 // Interface to jdk.internal.reflect.UnsafeStaticFieldAccessorImpl objects
 840 class reflect_UnsafeStaticFieldAccessorImpl {
 841  private:
 842   static int _base_offset;
 843   static void compute_offsets();
 844 
 845  public:
 846   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 847 
<span class="line-modified"> 848   static int base_offset() {</span>
<span class="line-removed"> 849     return _base_offset;</span>
<span class="line-removed"> 850   }</span>
 851 
 852   // Debugging
 853   friend class JavaClasses;
 854 };
 855 
 856 // Interface to java.lang primitive type boxing objects:
 857 //  - java.lang.Boolean
 858 //  - java.lang.Character
 859 //  - java.lang.Float
 860 //  - java.lang.Double
 861 //  - java.lang.Byte
 862 //  - java.lang.Short
 863 //  - java.lang.Integer
 864 //  - java.lang.Long
 865 
 866 // This could be separated out into 8 individual classes.
 867 
 868 class java_lang_boxing_object: AllStatic {
 869  private:
<span class="line-modified"> 870   static int value_offset;</span>
<span class="line-modified"> 871   static int long_value_offset;</span>
 872 

 873   static oop initialize_and_allocate(BasicType type, TRAPS);
 874  public:
 875   // Allocation. Returns a boxed value, or NULL for invalid type.
 876   static oop create(BasicType type, jvalue* value, TRAPS);
 877   // Accessors. Returns the basic type being boxed, or T_ILLEGAL for invalid oop.
 878   static BasicType get_value(oop box, jvalue* value);
 879   static BasicType set_value(oop box, jvalue* value);
 880   static BasicType basic_type(oop box);
 881   static bool is_instance(oop box)                 { return basic_type(box) != T_ILLEGAL; }
 882   static bool is_instance(oop box, BasicType type) { return basic_type(box) == type; }
 883   static void print(oop box, outputStream* st)     { jvalue value;  print(get_value(box, &amp;value), &amp;value, st); }
 884   static void print(BasicType type, jvalue* value, outputStream* st);
 885 
<span class="line-modified"> 886   static int value_offset_in_bytes(BasicType type) {</span>
<span class="line-modified"> 887     return ( type == T_LONG || type == T_DOUBLE ) ? long_value_offset :</span>
<span class="line-removed"> 888                                                     value_offset;</span>
 889   }
 890 
<span class="line-modified"> 891   static void compute_offsets();</span>
<span class="line-removed"> 892   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;</span>
 893 
 894   // Debugging
 895   friend class JavaClasses;
 896 };
 897 
 898 
 899 
 900 // Interface to java.lang.ref.Reference objects
 901 
 902 class java_lang_ref_Reference: AllStatic {





 903   static bool _offsets_initialized;
 904 
 905  public:
<span class="line-removed"> 906   static int referent_offset;</span>
<span class="line-removed"> 907   static int queue_offset;</span>
<span class="line-removed"> 908   static int next_offset;</span>
<span class="line-removed"> 909   static int discovered_offset;</span>
<span class="line-removed"> 910 </span>
 911   // Accessors
 912   static inline oop referent(oop ref);
 913   static inline void set_referent(oop ref, oop value);
 914   static inline void set_referent_raw(oop ref, oop value);
 915   static inline HeapWord* referent_addr_raw(oop ref);
 916   static inline oop next(oop ref);
 917   static inline void set_next(oop ref, oop value);
 918   static inline void set_next_raw(oop ref, oop value);
 919   static inline HeapWord* next_addr_raw(oop ref);
 920   static inline oop discovered(oop ref);
 921   static inline void set_discovered(oop ref, oop value);
 922   static inline void set_discovered_raw(oop ref, oop value);
 923   static inline HeapWord* discovered_addr_raw(oop ref);
 924   static inline oop queue(oop ref);
 925   static inline void set_queue(oop ref, oop value);
 926   static bool is_referent_field(oop obj, ptrdiff_t offset);
 927   static inline bool is_final(oop ref);
 928   static inline bool is_phantom(oop ref);
 929 





 930   static void compute_offsets();
 931   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 932 };
 933 
 934 
 935 // Interface to java.lang.ref.SoftReference objects
 936 
 937 class java_lang_ref_SoftReference: public java_lang_ref_Reference {
<span class="line-modified"> 938  public:</span>
<span class="line-modified"> 939   static int timestamp_offset;</span>
<span class="line-removed"> 940   static int static_clock_offset;</span>
 941 

 942   // Accessors
 943   static jlong timestamp(oop ref);
 944 
 945   // Accessors for statics
 946   static jlong clock();
 947   static void set_clock(jlong value);
 948 
 949   static void compute_offsets();
 950   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 951 };
 952 
 953 // Interface to java.lang.invoke.MethodHandle objects
 954 
 955 class MethodHandleEntry;
 956 
 957 class java_lang_invoke_MethodHandle: AllStatic {
 958   friend class JavaClasses;
 959 
 960  private:
 961   static int _type_offset;               // the MethodType of this MH
</pre>
<hr />
<pre>
 963 
 964   static void compute_offsets();
 965 
 966  public:
 967   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 968 
 969   // Accessors
 970   static oop            type(oop mh);
 971   static void       set_type(oop mh, oop mtype);
 972 
 973   static oop            form(oop mh);
 974   static void       set_form(oop mh, oop lform);
 975 
 976   // Testers
 977   static bool is_subclass(Klass* klass) {
 978     return klass-&gt;is_subclass_of(SystemDictionary::MethodHandle_klass());
 979   }
 980   static bool is_instance(oop obj);
 981 
 982   // Accessors for code generation:
<span class="line-modified"> 983   static int type_offset_in_bytes()             { return _type_offset; }</span>
<span class="line-modified"> 984   static int form_offset_in_bytes()             { return _form_offset; }</span>
 985 };
 986 
 987 // Interface to java.lang.invoke.DirectMethodHandle objects
 988 
 989 class java_lang_invoke_DirectMethodHandle: AllStatic {
 990   friend class JavaClasses;
 991 
 992  private:
 993   static int _member_offset;               // the MemberName of this DMH
 994 
 995   static void compute_offsets();
 996 
 997  public:
 998   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 999 
1000   // Accessors
1001   static oop  member(oop mh);
1002 
1003   // Testers
1004   static bool is_subclass(Klass* klass) {
1005     return klass-&gt;is_subclass_of(SystemDictionary::DirectMethodHandle_klass());
1006   }
1007   static bool is_instance(oop obj);
1008 
1009   // Accessors for code generation:
<span class="line-modified">1010   static int member_offset_in_bytes()           { return _member_offset; }</span>
1011 };
1012 
1013 // Interface to java.lang.invoke.LambdaForm objects
1014 // (These are a private interface for managing adapter code generation.)
1015 
1016 class java_lang_invoke_LambdaForm: AllStatic {
1017   friend class JavaClasses;
1018 
1019  private:
1020   static int _vmentry_offset;  // type is MemberName
1021 
1022   static void compute_offsets();
1023 
1024  public:
1025   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1026 
1027   // Accessors
1028   static oop            vmentry(oop lform);
1029   static void       set_vmentry(oop lform, oop invoker);
1030 
1031   // Testers
1032   static bool is_subclass(Klass* klass) {
1033     return SystemDictionary::LambdaForm_klass() != NULL &amp;&amp;
1034       klass-&gt;is_subclass_of(SystemDictionary::LambdaForm_klass());
1035   }
1036   static bool is_instance(oop obj);
1037 
1038   // Accessors for code generation:
<span class="line-modified">1039   static int vmentry_offset_in_bytes()          { return _vmentry_offset; }</span>
1040 };
1041 
1042 
1043 // Interface to java.lang.invoke.MemberName objects
1044 // (These are a private interface for Java code to query the class hierarchy.)
1045 
1046 #define RESOLVEDMETHOD_INJECTED_FIELDS(macro)                                   \
1047   macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \
1048   macro(java_lang_invoke_ResolvedMethodName, vmtarget, intptr_signature, false)
1049 
1050 class java_lang_invoke_ResolvedMethodName : AllStatic {
1051   friend class JavaClasses;
1052 
1053   static int _vmtarget_offset;
1054   static int _vmholder_offset;
1055 
1056   static void compute_offsets();
1057  public:
1058   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1059 
<span class="line-modified">1060   static int vmtarget_offset_in_bytes() { return _vmtarget_offset; }</span>
1061 
1062   static Method* vmtarget(oop resolved_method);
1063   static void set_vmtarget(oop resolved_method, Method* method);
1064 
1065   static void set_vmholder(oop resolved_method, oop holder);
1066 
1067   // find or create resolved member name
1068   static oop find_resolved_method(const methodHandle&amp; m, TRAPS);
1069 
1070   static bool is_instance(oop resolved_method);
1071 };
1072 
1073 
1074 #define MEMBERNAME_INJECTED_FIELDS(macro)                               \
1075   macro(java_lang_invoke_MemberName, vmindex,  intptr_signature, false)
1076 
1077 
1078 class java_lang_invoke_MemberName: AllStatic {
1079   friend class JavaClasses;
1080 
</pre>
<hr />
<pre>
1127 
1128   // Relevant integer codes (keep these in synch. with MethodHandleNatives.Constants):
1129   enum {
1130     MN_IS_METHOD             = 0x00010000, // method (not constructor)
1131     MN_IS_CONSTRUCTOR        = 0x00020000, // constructor
1132     MN_IS_FIELD              = 0x00040000, // field
1133     MN_IS_TYPE               = 0x00080000, // nested type
1134     MN_CALLER_SENSITIVE      = 0x00100000, // @CallerSensitive annotation detected
1135     MN_REFERENCE_KIND_SHIFT  = 24, // refKind
1136     MN_REFERENCE_KIND_MASK   = 0x0F000000 &gt;&gt; MN_REFERENCE_KIND_SHIFT,
1137     // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
1138     MN_SEARCH_SUPERCLASSES   = 0x00100000, // walk super classes
1139     MN_SEARCH_INTERFACES     = 0x00200000, // walk implemented interfaces
1140     MN_NESTMATE_CLASS        = 0x00000001,
1141     MN_HIDDEN_CLASS          = 0x00000002,
1142     MN_STRONG_LOADER_LINK    = 0x00000004,
1143     MN_ACCESS_VM_ANNOTATIONS = 0x00000008
1144   };
1145 
1146   // Accessors for code generation:
<span class="line-modified">1147   static int clazz_offset_in_bytes()            { return _clazz_offset; }</span>
<span class="line-modified">1148   static int type_offset_in_bytes()             { return _type_offset; }</span>
<span class="line-modified">1149   static int name_offset_in_bytes()             { return _name_offset; }</span>
<span class="line-modified">1150   static int flags_offset_in_bytes()            { return _flags_offset; }</span>
<span class="line-modified">1151   static int method_offset_in_bytes()           { return _method_offset; }</span>
<span class="line-removed">1152   static int vmindex_offset_in_bytes()          { return _vmindex_offset; }</span>
1153 };
1154 
1155 
1156 // Interface to java.lang.invoke.MethodType objects
1157 
1158 class java_lang_invoke_MethodType: AllStatic {
1159   friend class JavaClasses;
1160 
1161  private:
1162   static int _rtype_offset;
1163   static int _ptypes_offset;
1164 
1165   static void compute_offsets();
1166 
1167  public:
1168   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1169   // Accessors
1170   static oop            rtype(oop mt);
1171   static objArrayOop    ptypes(oop mt);
1172 
1173   static oop            ptype(oop mt, int index);
1174   static int            ptype_count(oop mt);
1175 
1176   static int            ptype_slot_count(oop mt);  // extra counts for long/double
1177   static int            rtype_slot_count(oop mt);  // extra counts for long/double
1178 
1179   static Symbol*        as_signature(oop mt, bool intern_if_not_found);
1180   static void           print_signature(oop mt, outputStream* st);
1181 
1182   static bool is_instance(oop obj);
1183 
1184   static bool equals(oop mt1, oop mt2);
1185 
1186   // Accessors for code generation:
<span class="line-modified">1187   static int rtype_offset_in_bytes()            { return _rtype_offset; }</span>
<span class="line-modified">1188   static int ptypes_offset_in_bytes()           { return _ptypes_offset; }</span>
1189 };
1190 
1191 
1192 // Interface to java.lang.invoke.CallSite objects
1193 
1194 class java_lang_invoke_CallSite: AllStatic {
1195   friend class JavaClasses;
1196 
1197 private:
1198   static int _target_offset;
1199   static int _context_offset;
1200 
1201   static void compute_offsets();
1202 
1203 public:
1204   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1205   // Accessors
1206   static oop              target(          oop site);
1207   static void         set_target(          oop site, oop target);
1208   static void         set_target_volatile( oop site, oop target);
1209 
1210   static oop context_no_keepalive(oop site);
1211 
1212   // Testers
1213   static bool is_subclass(Klass* klass) {
1214     return klass-&gt;is_subclass_of(SystemDictionary::CallSite_klass());
1215   }
1216   static bool is_instance(oop obj);
1217 
1218   // Accessors for code generation:
<span class="line-modified">1219   static int target_offset_in_bytes()           { return _target_offset; }</span>

1220 };
1221 
1222 // Interface to java.lang.invoke.ConstantCallSite objects
1223 
1224 class java_lang_invoke_ConstantCallSite: AllStatic {
1225   friend class JavaClasses;
1226 
1227 private:
1228   static int _is_frozen_offset;
1229 
1230   static void compute_offsets();
1231 
1232 public:
1233   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1234   // Accessors
1235   static jboolean is_frozen(oop site);
1236 
1237   // Testers
1238   static bool is_subclass(Klass* klass) {
1239     return klass-&gt;is_subclass_of(SystemDictionary::ConstantCallSite_klass());
</pre>
<hr />
<pre>
1282   static int _isAuthorized_offset;
1283 
1284   static void compute_offsets();
1285  public:
1286   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1287   static oop create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS);
1288 
1289   // Debugging/initialization
1290   friend class JavaClasses;
1291 };
1292 
1293 
1294 // Interface to java.lang.ClassLoader objects
1295 
1296 #define CLASSLOADER_INJECTED_FIELDS(macro)                            \
1297   macro(java_lang_ClassLoader, loader_data,  intptr_signature, false)
1298 
1299 class java_lang_ClassLoader : AllStatic {
1300  private:
1301   static int _loader_data_offset;
<span class="line-modified">1302   static bool offsets_computed;</span>
<span class="line-modified">1303   static int parent_offset;</span>
<span class="line-modified">1304   static int parallelCapable_offset;</span>
<span class="line-modified">1305   static int name_offset;</span>
<span class="line-modified">1306   static int nameAndId_offset;</span>
<span class="line-removed">1307   static int unnamedModule_offset;</span>
1308 
<span class="line-removed">1309  public:</span>
1310   static void compute_offsets();


1311   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1312 
1313   static ClassLoaderData* loader_data_acquire(oop loader);
1314   static ClassLoaderData* loader_data_raw(oop loader);
1315   static void release_set_loader_data(oop loader, ClassLoaderData* new_data);
1316 
1317   static oop parent(oop loader);
1318   static oop name(oop loader);
1319   static oop nameAndId(oop loader);
1320   static bool isAncestor(oop loader, oop cl);
1321 
1322   // Support for parallelCapable field
1323   static bool parallelCapable(oop the_class_mirror);
1324 
1325   static bool is_trusted_loader(oop loader);
1326 
1327   // Return true if this is one of the class loaders associated with
1328   // the generated bytecodes for reflection.
1329   static bool is_reflection_class_loader(oop loader);
1330 
1331   // Fix for 4474172
1332   static oop  non_reflection_class_loader(oop loader);
1333 
1334   // Testers
1335   static bool is_subclass(Klass* klass) {
1336     return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass());
1337   }
1338   static bool is_instance(oop obj);
1339 
1340   static oop unnamedModule(oop loader);
1341 
1342   // Debugging
1343   friend class JavaClasses;
<span class="line-removed">1344   friend class ClassFileParser; // access to number_of_fake_fields</span>
1345 };
1346 
1347 
1348 // Interface to java.lang.System objects
1349 
1350 class java_lang_System : AllStatic {
1351  private:
<span class="line-modified">1352   static int  static_in_offset;</span>
<span class="line-modified">1353   static int static_out_offset;</span>
<span class="line-modified">1354   static int static_err_offset;</span>
<span class="line-modified">1355   static int static_security_offset;</span>
1356 
1357  public:
<span class="line-modified">1358   static int  in_offset_in_bytes();</span>
<span class="line-modified">1359   static int out_offset_in_bytes();</span>
<span class="line-modified">1360   static int err_offset_in_bytes();</span>
1361 
1362   static void compute_offsets();
1363   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1364 
1365   // Debugging
1366   friend class JavaClasses;
1367 };
1368 
1369 
1370 // Interface to java.lang.StackTraceElement objects
1371 
1372 class java_lang_StackTraceElement: AllStatic {
1373  private:
<span class="line-modified">1374   static int declaringClassObject_offset;</span>
<span class="line-modified">1375   static int classLoaderName_offset;</span>
<span class="line-modified">1376   static int moduleName_offset;</span>
<span class="line-modified">1377   static int moduleVersion_offset;</span>
<span class="line-modified">1378   static int declaringClass_offset;</span>
<span class="line-modified">1379   static int methodName_offset;</span>
<span class="line-modified">1380   static int fileName_offset;</span>
<span class="line-modified">1381   static int lineNumber_offset;</span>
1382 
1383   // Setters
1384   static void set_classLoaderName(oop element, oop value);
1385   static void set_moduleName(oop element, oop value);
1386   static void set_moduleVersion(oop element, oop value);
1387   static void set_declaringClass(oop element, oop value);
1388   static void set_methodName(oop element, oop value);
1389   static void set_fileName(oop element, oop value);
1390   static void set_lineNumber(oop element, int value);
1391   static void set_declaringClassObject(oop element, oop value);
1392 
1393   static void decode_file_and_line(Handle java_mirror, InstanceKlass* holder, int version,
1394                                    const methodHandle&amp; method, int bci,
1395                                    Symbol*&amp; source, oop&amp; source_file, int&amp; line_number, TRAPS);
1396 
1397  public:
1398   // Create an instance of StackTraceElement
1399   static oop create(const methodHandle&amp; method, int bci, TRAPS);
1400 
1401   static void fill_in(Handle element, InstanceKlass* holder, const methodHandle&amp; method,
</pre>
<hr />
<pre>
1465   static int _operands_offset;
1466   static int _mode_offset;
1467 
1468  public:
1469   static void set_monitors(oop info, oop value);
1470   static void set_locals(oop info, oop value);
1471   static void set_operands(oop info, oop value);
1472   static void set_mode(oop info, int value);
1473 
1474   static void compute_offsets();
1475   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1476 
1477   // Debugging
1478   friend class JavaClasses;
1479 };
1480 
1481 // Interface to java.lang.reflect.RecordComponent objects
1482 
1483 class java_lang_reflect_RecordComponent: AllStatic {
1484  private:
<span class="line-modified">1485   static int clazz_offset;</span>
<span class="line-modified">1486   static int name_offset;</span>
<span class="line-modified">1487   static int type_offset;</span>
<span class="line-modified">1488   static int accessor_offset;</span>
<span class="line-modified">1489   static int signature_offset;</span>
<span class="line-modified">1490   static int annotations_offset;</span>
<span class="line-modified">1491   static int typeAnnotations_offset;</span>
1492 
1493   // Setters
1494   static void set_clazz(oop element, oop value);
1495   static void set_name(oop element, oop value);
1496   static void set_type(oop element, oop value);
1497   static void set_accessor(oop element, oop value);
1498   static void set_signature(oop element, oop value);
1499   static void set_annotations(oop element, oop value);
1500   static void set_typeAnnotations(oop element, oop value);
1501 
1502  public:
1503   // Create an instance of RecordComponent
1504   static oop create(InstanceKlass* holder, RecordComponent* component, TRAPS);
1505 
1506   static void compute_offsets();
1507   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1508 
1509   // Debugging
1510   friend class JavaClasses;
1511 };
1512 
1513 
1514 // Interface to java.lang.AssertionStatusDirectives objects
1515 
1516 class java_lang_AssertionStatusDirectives: AllStatic {
1517  private:
<span class="line-modified">1518   static int classes_offset;</span>
<span class="line-modified">1519   static int classEnabled_offset;</span>
<span class="line-modified">1520   static int packages_offset;</span>
<span class="line-modified">1521   static int packageEnabled_offset;</span>
<span class="line-modified">1522   static int deflt_offset;</span>
1523 
1524  public:
1525   // Setters
1526   static void set_classes(oop obj, oop val);
1527   static void set_classEnabled(oop obj, oop val);
1528   static void set_packages(oop obj, oop val);
1529   static void set_packageEnabled(oop obj, oop val);
1530   static void set_deflt(oop obj, bool val);
1531 
1532   static void compute_offsets();
1533   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1534 
1535   // Debugging
1536   friend class JavaClasses;
1537 };
1538 
1539 
1540 class java_nio_Buffer: AllStatic {
1541  private:
1542   static int _limit_offset;
1543 
1544  public:
<span class="line-modified">1545   static int  limit_offset();</span>
1546   static void compute_offsets();
1547   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1548 };
1549 
1550 class java_util_concurrent_locks_AbstractOwnableSynchronizer : AllStatic {
1551  private:
1552   static int  _owner_offset;
1553  public:
1554   static void compute_offsets();
1555   static oop  get_owner_threadObj(oop obj);
1556   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1557 };
1558 
1559  // Interface to jdk.internal.misc.UnsafeConsants
1560 
1561 class jdk_internal_misc_UnsafeConstants : AllStatic {
1562  public:
1563   static void set_unsafe_constants();
1564   static void compute_offsets() { }
1565   static void serialize_offsets(SerializeClosure* f) { }
</pre>
<hr />
<pre>
1702   static InjectedField _injected_fields[];
1703 
1704   static bool check_offset(const char *klass_name, int offset, const char *field_name, const char* field_sig) PRODUCT_RETURN0;
1705  public:
1706   enum InjectedFieldID {
1707     ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)
1708     MAX_enum
1709   };
1710 
1711   static int compute_injected_offset(InjectedFieldID id);
1712 
1713   static void compute_offsets();
1714   static void check_offsets() PRODUCT_RETURN;
1715   static void serialize_offsets(SerializeClosure* soc) NOT_CDS_RETURN;
1716   static InjectedField* get_injected(Symbol* class_name, int* field_count);
1717   static bool is_supported_for_archiving(oop obj) NOT_CDS_JAVA_HEAP_RETURN_(false);
1718 };
1719 
1720 #undef DECLARE_INJECTED_FIELD_ENUM
1721 

1722 #endif // SHARE_CLASSFILE_JAVACLASSES_HPP
</pre>
</td>
<td>
<hr />
<pre>
  63   f(java_lang_reflect_Constructor) \
  64   f(java_lang_reflect_Field) \
  65   f(java_lang_reflect_RecordComponent) \
  66   f(java_nio_Buffer) \
  67   f(reflect_ConstantPool) \
  68   f(reflect_UnsafeStaticFieldAccessorImpl) \
  69   f(java_lang_reflect_Parameter) \
  70   f(java_lang_Module) \
  71   f(java_lang_StackTraceElement) \
  72   f(java_lang_StackFrameInfo) \
  73   f(java_lang_LiveStackFrameInfo) \
  74   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
  75   f(jdk_internal_misc_UnsafeConstants) \
  76   f(java_lang_boxing_object) \
  77   //end
  78 
  79 #define BASIC_JAVA_CLASSES_DO(f) \
  80         BASIC_JAVA_CLASSES_DO_PART1(f) \
  81         BASIC_JAVA_CLASSES_DO_PART2(f)
  82 
<span class="line-added">  83 #define CHECK_INIT(offset)  assert(offset != 0, &quot;should be initialized&quot;); return offset;</span>
<span class="line-added">  84 </span>
  85 // Interface to java.lang.Object objects
  86 
  87 class java_lang_Object : AllStatic {
  88  public:
  89   static void register_natives(TRAPS);
  90 };
  91 
  92 // Interface to java.lang.String objects
  93 
  94 class java_lang_String : AllStatic {
  95  private:
<span class="line-modified">  96   static int _value_offset;</span>
<span class="line-modified">  97   static int _hash_offset;</span>
<span class="line-modified">  98   static int _hashIsZero_offset;</span>
<span class="line-modified">  99   static int _coder_offset;</span>
 100 
<span class="line-modified"> 101   static bool _initialized;</span>
 102 
 103   static Handle basic_create(int length, bool byte_arr, TRAPS);
 104 
 105   static inline void set_coder(oop string, jbyte coder);
 106 
 107  public:
 108 
 109   // Coders
 110   enum Coder {
 111     CODER_LATIN1 =  0,
 112     CODER_UTF16  =  1
 113   };
 114 
 115   static void compute_offsets();
 116   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 117 
 118   // Instance creation
 119   static Handle create_from_unicode(const jchar* unicode, int len, TRAPS);
 120   static oop    create_oop_from_unicode(const jchar* unicode, int len, TRAPS);
 121   static Handle create_from_str(const char* utf8_str, TRAPS);
 122   static oop    create_oop_from_str(const char* utf8_str, TRAPS);
 123   static Handle create_from_symbol(Symbol* symbol, TRAPS);
 124   static Handle create_from_platform_dependent_str(const char* str, TRAPS);
 125   static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);
 126 
 127   static void set_compact_strings(bool value);
 128 
<span class="line-modified"> 129   static int value_offset() { CHECK_INIT(_value_offset); }</span>
<span class="line-modified"> 130   static int coder_offset() { CHECK_INIT(_coder_offset); }</span>














 131 
 132   static inline void set_value_raw(oop string, typeArrayOop buffer);
 133   static inline void set_value(oop string, typeArrayOop buffer);
 134 
 135   // Accessors
 136   static inline typeArrayOop value(oop java_string);
 137   static inline typeArrayOop value_no_keepalive(oop java_string);
 138   static inline bool hash_is_set(oop string);
 139   static inline bool is_latin1(oop java_string);
 140   static inline int length(oop java_string);
 141   static inline int length(oop java_string, typeArrayOop string_value);
 142   static int utf8_length(oop java_string);
 143   static int utf8_length(oop java_string, typeArrayOop string_value);
 144 
 145   // String converters
 146   static char*  as_utf8_string(oop java_string);
 147   static char*  as_utf8_string(oop java_string, int&amp; length);
 148   static char*  as_utf8_string_full(oop java_string, char* buf, int buflen, int&amp; length);
 149   static char*  as_utf8_string(oop java_string, char* buf, int buflen);
 150   static char*  as_utf8_string(oop java_string, int start, int len);
</pre>
<hr />
<pre>
 208   friend class StringTable;
 209 };
 210 
 211 
 212 // Interface to java.lang.Class objects
 213 
 214 #define CLASS_INJECTED_FIELDS(macro)                                       \
 215   macro(java_lang_Class, klass,                  intptr_signature,  false) \
 216   macro(java_lang_Class, array_klass,            intptr_signature,  false) \
 217   macro(java_lang_Class, oop_size,               int_signature,     false) \
 218   macro(java_lang_Class, static_oop_field_count, int_signature,     false) \
 219   macro(java_lang_Class, protection_domain,      object_signature,  false) \
 220   macro(java_lang_Class, signers,                object_signature,  false) \
 221   macro(java_lang_Class, source_file,            object_signature,  false) \
 222 
 223 class java_lang_Class : AllStatic {
 224   friend class VMStructs;
 225   friend class JVMCIVMStructs;
 226 
 227  private:
<span class="line-added"> 228 </span>
 229   // The fake offsets are added by the class loader when java.lang.Class is loaded
 230 
 231   static int _klass_offset;
 232   static int _array_klass_offset;
 233 
 234   static int _oop_size_offset;
 235   static int _static_oop_field_count_offset;
 236 
 237   static int _protection_domain_offset;
 238   static int _init_lock_offset;
 239   static int _signers_offset;
 240   static int _class_loader_offset;
 241   static int _module_offset;
 242   static int _component_mirror_offset;
 243   static int _name_offset;
 244   static int _source_file_offset;
 245   static int _classData_offset;
<span class="line-added"> 246   static int _classRedefinedCount_offset;</span>
 247 
<span class="line-modified"> 248   static bool _offsets_computed;</span>

 249 
 250   static GrowableArray&lt;Klass*&gt;* _fixup_mirror_list;
 251   static GrowableArray&lt;Klass*&gt;* _fixup_module_field_list;
 252 
 253   static void set_init_lock(oop java_class, oop init_lock);
 254   static void set_protection_domain(oop java_class, oop protection_domain);
 255   static void set_class_loader(oop java_class, oop class_loader);
 256   static void set_component_mirror(oop java_class, oop comp_mirror);
 257   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain,
 258                                        Handle classData, TRAPS);
 259   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
 260  public:
 261   static void allocate_fixup_lists();
 262   static void compute_offsets();
 263 
 264   // Instance creation
 265   static void create_mirror(Klass* k, Handle class_loader, Handle module,
 266                             Handle protection_domain, Handle classData, TRAPS);
 267   static void fixup_mirror(Klass* k, TRAPS);
 268   static oop  create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS);
</pre>
<hr />
<pre>
 282   static void fixup_module_field(Klass* k, Handle module);
 283 
 284   // Conversion
 285   static Klass* as_Klass(oop java_class);
 286   static Klass* as_Klass_raw(oop java_class);
 287   static void set_klass(oop java_class, Klass* klass);
 288   static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);
 289   static Symbol* as_signature(oop java_class, bool intern_if_not_found);
 290   static void print_signature(oop java_class, outputStream *st);
 291   static const char* as_external_name(oop java_class);
 292   // Testing
 293   static bool is_instance(oop obj);
 294 
 295   static bool is_primitive(oop java_class);
 296   static BasicType primitive_type(oop java_class);
 297   static oop primitive_mirror(BasicType t);
 298   // JVM_NewArray support
 299   static Klass* array_klass_acquire(oop java_class);
 300   static void release_set_array_klass(oop java_class, Klass* klass);
 301   // compiler support for class operations
<span class="line-modified"> 302   static int klass_offset()                { CHECK_INIT(_klass_offset); }</span>
<span class="line-modified"> 303   static int array_klass_offset()          { CHECK_INIT(_array_klass_offset); }</span>
 304   // Support for classRedefinedCount field
 305   static int classRedefinedCount(oop the_class_mirror);
 306   static void set_classRedefinedCount(oop the_class_mirror, int value);
 307 
 308   // Support for embedded per-class oops
 309   static oop  protection_domain(oop java_class);
 310   static oop  init_lock(oop java_class);
<span class="line-added"> 311   static void clear_init_lock(oop java_class) {</span>
<span class="line-added"> 312     set_init_lock(java_class, NULL);</span>
<span class="line-added"> 313   }</span>
 314   static oop  component_mirror(oop java_class);
 315   static objArrayOop  signers(oop java_class);
 316   static void set_signers(oop java_class, objArrayOop signers);
 317   static oop  class_data(oop java_class);
 318   static void set_class_data(oop java_class, oop classData);
 319 
 320   static oop class_loader(oop java_class);
 321   static void set_module(oop java_class, oop module);
 322   static oop module(oop java_class);
 323 
 324   static oop name(Handle java_class, TRAPS);
 325 
 326   static oop source_file(oop java_class);
 327   static void set_source_file(oop java_class, oop source_file);
 328 
 329   static int oop_size(oop java_class);
 330   static int oop_size_raw(oop java_class);
 331   static void set_oop_size(HeapWord* java_class, int size);
 332   static int static_oop_field_count(oop java_class);
 333   static int static_oop_field_count_raw(oop java_class);
 334   static void set_static_oop_field_count(oop java_class, int size);
 335 
 336   static GrowableArray&lt;Klass*&gt;* fixup_mirror_list() {
 337     return _fixup_mirror_list;
 338   }
 339   static void set_fixup_mirror_list(GrowableArray&lt;Klass*&gt;* v) {
 340     _fixup_mirror_list = v;
 341   }
 342 
 343   static GrowableArray&lt;Klass*&gt;* fixup_module_field_list() {
 344     return _fixup_module_field_list;
 345   }
 346   static void set_fixup_module_field_list(GrowableArray&lt;Klass*&gt;* v) {
 347     _fixup_module_field_list = v;
 348   }
 349 
 350   // Debugging
 351   friend class JavaClasses;


 352 };
 353 
 354 // Interface to java.lang.Thread objects
 355 
 356 class java_lang_Thread : AllStatic {
 357  private:
 358   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
 359   // so we compute the offsets at startup rather than hard-wiring them.
 360   static int _name_offset;
 361   static int _group_offset;
 362   static int _contextClassLoader_offset;
 363   static int _inheritedAccessControlContext_offset;
 364   static int _priority_offset;
 365   static int _eetop_offset;
 366   static int _interrupted_offset;
 367   static int _daemon_offset;
 368   static int _stillborn_offset;
 369   static int _stackSize_offset;
 370   static int _tid_offset;
 371   static int _thread_status_offset;
</pre>
<hr />
<pre>
 502 
 503 // Interface to java.lang.Throwable objects
 504 
 505 class java_lang_Throwable: AllStatic {
 506   friend class BacktraceBuilder;
 507   friend class BacktraceIterator;
 508 
 509  private:
 510   // Trace constants
 511   enum {
 512     trace_methods_offset = 0,
 513     trace_bcis_offset    = 1,
 514     trace_mirrors_offset = 2,
 515     trace_names_offset   = 3,
 516     trace_next_offset    = 4,
 517     trace_hidden_offset  = 5,
 518     trace_size           = 6,
 519     trace_chunk_size     = 32
 520   };
 521 
<span class="line-modified"> 522   static int _backtrace_offset;</span>
<span class="line-modified"> 523   static int _detailMessage_offset;</span>
<span class="line-modified"> 524   static int _stackTrace_offset;</span>
<span class="line-modified"> 525   static int _depth_offset;</span>
<span class="line-modified"> 526   static int _static_unassigned_stacktrace_offset;</span>
 527 
 528   // StackTrace (programmatic access, new since 1.4)
 529   static void clear_stacktrace(oop throwable);
 530   // Stacktrace (post JDK 1.7.0 to allow immutability protocol to be followed)
 531   static void set_stacktrace(oop throwable, oop st_element_array);
 532   static oop unassigned_stacktrace();
 533 
 534  public:
 535   // Backtrace
 536   static oop backtrace(oop throwable);
 537   static void set_backtrace(oop throwable, oop value);
 538   static int depth(oop throwable);
 539   static void set_depth(oop throwable, int value);
<span class="line-modified"> 540   static int get_detailMessage_offset() { CHECK_INIT(_detailMessage_offset); }</span>


 541   // Message
 542   static oop message(oop throwable);
 543   static void set_message(oop throwable, oop value);
 544   static Symbol* detail_message(oop throwable);
 545   static void print_stack_element(outputStream *st, Method* method, int bci);
 546   static void print_stack_usage(Handle stream);
 547 
 548   static void compute_offsets();
 549   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 550 
 551   // Allocate space for backtrace (created but stack trace not filled in)
 552   static void allocate_backtrace(Handle throwable, TRAPS);
 553   // Fill in current stack trace for throwable with preallocated backtrace (no GC)
 554   static void fill_in_stack_trace_of_preallocated_backtrace(Handle throwable);
 555   // Fill in current stack trace, can cause GC
 556   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS);
 557   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method = methodHandle());
 558   // Programmatic access to stack trace
 559   static void get_stack_trace_elements(Handle throwable, objArrayHandle stack_trace, TRAPS);
 560   // Printing
 561   static void print(oop throwable, outputStream* st);
 562   static void print_stack_trace(Handle throwable, outputStream* st);
 563   static void java_printStackTrace(Handle throwable, TRAPS);
 564   // Debugging
 565   friend class JavaClasses;
 566   // Gets the method and bci of the top frame (TOS). Returns false if this failed.
 567   static bool get_top_method_and_bci(oop throwable, Method** method, int* bci);
 568 };
 569 
 570 
 571 // Interface to java.lang.reflect.AccessibleObject objects
 572 
 573 class java_lang_reflect_AccessibleObject: AllStatic {
 574  private:
 575   // Note that to reduce dependencies on the JDK we compute these
 576   // offsets at run-time.
<span class="line-modified"> 577   static int _override_offset;</span>
 578 
 579   static void compute_offsets();
 580 
 581  public:
 582   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 583 
 584   // Accessors
 585   static jboolean override(oop reflect);
 586   static void set_override(oop reflect, jboolean value);
 587 
 588   // Debugging
 589   friend class JavaClasses;
 590 };
 591 
 592 
 593 // Interface to java.lang.reflect.Method objects
 594 
 595 class java_lang_reflect_Method : public java_lang_reflect_AccessibleObject {
 596  private:
 597   // Note that to reduce dependencies on the JDK we compute these
 598   // offsets at run-time.
<span class="line-modified"> 599   static int _clazz_offset;</span>
<span class="line-modified"> 600   static int _name_offset;</span>
<span class="line-modified"> 601   static int _returnType_offset;</span>
<span class="line-modified"> 602   static int _parameterTypes_offset;</span>
<span class="line-modified"> 603   static int _exceptionTypes_offset;</span>
<span class="line-modified"> 604   static int _slot_offset;</span>
<span class="line-modified"> 605   static int _modifiers_offset;</span>
<span class="line-modified"> 606   static int _signature_offset;</span>
<span class="line-modified"> 607   static int _annotations_offset;</span>
<span class="line-modified"> 608   static int _parameter_annotations_offset;</span>
<span class="line-modified"> 609   static int _annotation_default_offset;</span>
 610 
 611   static void compute_offsets();
 612  public:
 613   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 614 
 615   // Allocation
 616   static Handle create(TRAPS);
 617 
 618   // Accessors
 619   static oop clazz(oop reflect);
 620   static void set_clazz(oop reflect, oop value);
 621 
 622   static void set_name(oop method, oop value);
 623 
 624   static oop return_type(oop method);
 625   static void set_return_type(oop method, oop value);
 626 
 627   static oop parameter_types(oop method);
 628   static void set_parameter_types(oop method, oop value);
 629 
</pre>
<hr />
<pre>
 631   static void set_slot(oop reflect, int value);
 632 
 633   static void set_exception_types(oop method, oop value);
 634   static void set_modifiers(oop method, int value);
 635   static void set_signature(oop method, oop value);
 636   static void set_annotations(oop method, oop value);
 637   static void set_parameter_annotations(oop method, oop value);
 638   static void set_annotation_default(oop method, oop value);
 639 
 640   // Debugging
 641   friend class JavaClasses;
 642 };
 643 
 644 
 645 // Interface to java.lang.reflect.Constructor objects
 646 
 647 class java_lang_reflect_Constructor : public java_lang_reflect_AccessibleObject {
 648  private:
 649   // Note that to reduce dependencies on the JDK we compute these
 650   // offsets at run-time.
<span class="line-modified"> 651   static int _clazz_offset;</span>
<span class="line-modified"> 652   static int _parameterTypes_offset;</span>
<span class="line-modified"> 653   static int _exceptionTypes_offset;</span>
<span class="line-modified"> 654   static int _slot_offset;</span>
<span class="line-modified"> 655   static int _modifiers_offset;</span>
<span class="line-modified"> 656   static int _signature_offset;</span>
<span class="line-modified"> 657   static int _annotations_offset;</span>
<span class="line-modified"> 658   static int _parameter_annotations_offset;</span>
 659 
 660   static void compute_offsets();
 661  public:
 662   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 663 
 664   // Allocation
 665   static Handle create(TRAPS);
 666 
 667   // Accessors
 668   static oop clazz(oop reflect);
 669   static void set_clazz(oop reflect, oop value);
 670 
 671   static oop parameter_types(oop constructor);
 672   static void set_parameter_types(oop constructor, oop value);
 673 
 674   static int slot(oop reflect);
 675   static void set_slot(oop reflect, int value);
 676 
 677   static void set_exception_types(oop constructor, oop value);
 678   static void set_modifiers(oop constructor, int value);
 679   static void set_signature(oop constructor, oop value);
 680   static void set_annotations(oop constructor, oop value);
 681   static void set_parameter_annotations(oop method, oop value);
 682 
 683   // Debugging
 684   friend class JavaClasses;
 685 };
 686 
 687 
 688 // Interface to java.lang.reflect.Field objects
 689 
 690 class java_lang_reflect_Field : public java_lang_reflect_AccessibleObject {
 691  private:
 692   // Note that to reduce dependencies on the JDK we compute these
 693   // offsets at run-time.
<span class="line-modified"> 694   static int _clazz_offset;</span>
<span class="line-modified"> 695   static int _name_offset;</span>
<span class="line-modified"> 696   static int _type_offset;</span>
<span class="line-modified"> 697   static int _slot_offset;</span>
<span class="line-modified"> 698   static int _modifiers_offset;</span>
<span class="line-modified"> 699   static int _signature_offset;</span>
<span class="line-modified"> 700   static int _annotations_offset;</span>
 701 
 702   static void compute_offsets();
 703 
 704  public:
 705   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 706 
 707   // Allocation
 708   static Handle create(TRAPS);
 709 
 710   // Accessors
 711   static oop clazz(oop reflect);
 712   static void set_clazz(oop reflect, oop value);
 713 
 714   static oop name(oop field);
 715   static void set_name(oop field, oop value);
 716 
 717   static oop type(oop field);
 718   static void set_type(oop field, oop value);
 719 
 720   static int slot(oop reflect);
 721   static void set_slot(oop reflect, int value);
 722 
 723   static int modifiers(oop field);
 724   static void set_modifiers(oop field, int value);
 725 
 726   static void set_signature(oop constructor, oop value);
 727   static void set_annotations(oop constructor, oop value);
 728   static void set_parameter_annotations(oop method, oop value);
 729   static void set_annotation_default(oop method, oop value);
 730 
 731   // Debugging
 732   friend class JavaClasses;
 733 };
 734 
 735 class java_lang_reflect_Parameter {
 736  private:
 737   // Note that to reduce dependencies on the JDK we compute these
 738   // offsets at run-time.
<span class="line-modified"> 739   static int _name_offset;</span>
<span class="line-modified"> 740   static int _modifiers_offset;</span>
<span class="line-modified"> 741   static int _index_offset;</span>
<span class="line-modified"> 742   static int _executable_offset;</span>
 743 
 744   static void compute_offsets();
 745 
 746  public:
 747   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 748 
 749   // Allocation
 750   static Handle create(TRAPS);
 751 
 752   // Accessors
 753   static oop name(oop field);
 754   static void set_name(oop field, oop value);
 755 
 756   static int index(oop reflect);
 757   static void set_index(oop reflect, int value);
 758 
 759   static int modifiers(oop reflect);
 760   static void set_modifiers(oop reflect, int value);
 761 
 762   static oop executable(oop constructor);
 763   static void set_executable(oop constructor, oop value);
 764 
 765   friend class JavaClasses;
 766 };
 767 
 768 #define MODULE_INJECTED_FIELDS(macro)                            \
 769   macro(java_lang_Module, module_entry, intptr_signature, false)
 770 
 771 class java_lang_Module {
 772   private:
<span class="line-modified"> 773     static int _loader_offset;</span>
<span class="line-modified"> 774     static int _name_offset;</span>
 775     static int _module_entry_offset;
<span class="line-added"> 776 </span>
 777     static void compute_offsets();
 778 
 779   public:
 780     static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 781 
 782     // Allocation
 783     static Handle create(Handle loader, Handle module_name, TRAPS);
 784 
 785     // Testers
 786     static bool is_instance(oop obj);
 787 
 788     // Accessors
 789     static oop loader(oop module);
 790     static void set_loader(oop module, oop value);
 791 
 792     static oop name(oop module);
 793     static void set_name(oop module, oop value);
 794 
 795     static ModuleEntry* module_entry(oop module);
 796     static void set_module_entry(oop module, ModuleEntry* module_entry);
</pre>
<hr />
<pre>
 798   friend class JavaClasses;
 799 };
 800 
 801 // Interface to jdk.internal.reflect.ConstantPool objects
 802 class reflect_ConstantPool {
 803  private:
 804   // Note that to reduce dependencies on the JDK we compute these
 805   // offsets at run-time.
 806   static int _oop_offset;
 807 
 808   static void compute_offsets();
 809 
 810  public:
 811   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 812 
 813   // Allocation
 814   static Handle create(TRAPS);
 815 
 816   // Accessors
 817   static void set_cp(oop reflect, ConstantPool* value);
<span class="line-modified"> 818   static int oop_offset() { CHECK_INIT(_oop_offset); }</span>


 819 
 820   static ConstantPool* get_cp(oop reflect);
 821 
 822   // Debugging
 823   friend class JavaClasses;
 824 };
 825 
 826 // Interface to jdk.internal.reflect.UnsafeStaticFieldAccessorImpl objects
 827 class reflect_UnsafeStaticFieldAccessorImpl {
 828  private:
 829   static int _base_offset;
 830   static void compute_offsets();
 831 
 832  public:
 833   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 834 
<span class="line-modified"> 835   static int base_offset() { CHECK_INIT(_base_offset); }</span>


 836 
 837   // Debugging
 838   friend class JavaClasses;
 839 };
 840 
 841 // Interface to java.lang primitive type boxing objects:
 842 //  - java.lang.Boolean
 843 //  - java.lang.Character
 844 //  - java.lang.Float
 845 //  - java.lang.Double
 846 //  - java.lang.Byte
 847 //  - java.lang.Short
 848 //  - java.lang.Integer
 849 //  - java.lang.Long
 850 
 851 // This could be separated out into 8 individual classes.
 852 
 853 class java_lang_boxing_object: AllStatic {
 854  private:
<span class="line-modified"> 855   static int _value_offset;</span>
<span class="line-modified"> 856   static int _long_value_offset;</span>
 857 
<span class="line-added"> 858   static void compute_offsets();</span>
 859   static oop initialize_and_allocate(BasicType type, TRAPS);
 860  public:
 861   // Allocation. Returns a boxed value, or NULL for invalid type.
 862   static oop create(BasicType type, jvalue* value, TRAPS);
 863   // Accessors. Returns the basic type being boxed, or T_ILLEGAL for invalid oop.
 864   static BasicType get_value(oop box, jvalue* value);
 865   static BasicType set_value(oop box, jvalue* value);
 866   static BasicType basic_type(oop box);
 867   static bool is_instance(oop box)                 { return basic_type(box) != T_ILLEGAL; }
 868   static bool is_instance(oop box, BasicType type) { return basic_type(box) == type; }
 869   static void print(oop box, outputStream* st)     { jvalue value;  print(get_value(box, &amp;value), &amp;value, st); }
 870   static void print(BasicType type, jvalue* value, outputStream* st);
 871 
<span class="line-modified"> 872   static int value_offset(BasicType type) {</span>
<span class="line-modified"> 873     return is_double_word_type(type) ? _long_value_offset : _value_offset;</span>

 874   }
 875 
<span class="line-modified"> 876   static void serialize_offsets(SerializeClosure* f);</span>

 877 
 878   // Debugging
 879   friend class JavaClasses;
 880 };
 881 
 882 
 883 
 884 // Interface to java.lang.ref.Reference objects
 885 
 886 class java_lang_ref_Reference: AllStatic {
<span class="line-added"> 887   static int _referent_offset;</span>
<span class="line-added"> 888   static int _queue_offset;</span>
<span class="line-added"> 889   static int _next_offset;</span>
<span class="line-added"> 890   static int _discovered_offset;</span>
<span class="line-added"> 891 </span>
 892   static bool _offsets_initialized;
 893 
 894  public:





 895   // Accessors
 896   static inline oop referent(oop ref);
 897   static inline void set_referent(oop ref, oop value);
 898   static inline void set_referent_raw(oop ref, oop value);
 899   static inline HeapWord* referent_addr_raw(oop ref);
 900   static inline oop next(oop ref);
 901   static inline void set_next(oop ref, oop value);
 902   static inline void set_next_raw(oop ref, oop value);
 903   static inline HeapWord* next_addr_raw(oop ref);
 904   static inline oop discovered(oop ref);
 905   static inline void set_discovered(oop ref, oop value);
 906   static inline void set_discovered_raw(oop ref, oop value);
 907   static inline HeapWord* discovered_addr_raw(oop ref);
 908   static inline oop queue(oop ref);
 909   static inline void set_queue(oop ref, oop value);
 910   static bool is_referent_field(oop obj, ptrdiff_t offset);
 911   static inline bool is_final(oop ref);
 912   static inline bool is_phantom(oop ref);
 913 
<span class="line-added"> 914   static int referent_offset()    { CHECK_INIT(_referent_offset); }</span>
<span class="line-added"> 915   static int queue_offset()       { CHECK_INIT(_queue_offset); }</span>
<span class="line-added"> 916   static int next_offset()        { CHECK_INIT(_next_offset); }</span>
<span class="line-added"> 917   static int discovered_offset()  { CHECK_INIT(_discovered_offset); }</span>
<span class="line-added"> 918 </span>
 919   static void compute_offsets();
 920   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 921 };
 922 
 923 
 924 // Interface to java.lang.ref.SoftReference objects
 925 
 926 class java_lang_ref_SoftReference: public java_lang_ref_Reference {
<span class="line-modified"> 927   static int _timestamp_offset;</span>
<span class="line-modified"> 928   static int _static_clock_offset;</span>

 929 
<span class="line-added"> 930  public:</span>
 931   // Accessors
 932   static jlong timestamp(oop ref);
 933 
 934   // Accessors for statics
 935   static jlong clock();
 936   static void set_clock(jlong value);
 937 
 938   static void compute_offsets();
 939   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 940 };
 941 
 942 // Interface to java.lang.invoke.MethodHandle objects
 943 
 944 class MethodHandleEntry;
 945 
 946 class java_lang_invoke_MethodHandle: AllStatic {
 947   friend class JavaClasses;
 948 
 949  private:
 950   static int _type_offset;               // the MethodType of this MH
</pre>
<hr />
<pre>
 952 
 953   static void compute_offsets();
 954 
 955  public:
 956   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 957 
 958   // Accessors
 959   static oop            type(oop mh);
 960   static void       set_type(oop mh, oop mtype);
 961 
 962   static oop            form(oop mh);
 963   static void       set_form(oop mh, oop lform);
 964 
 965   // Testers
 966   static bool is_subclass(Klass* klass) {
 967     return klass-&gt;is_subclass_of(SystemDictionary::MethodHandle_klass());
 968   }
 969   static bool is_instance(oop obj);
 970 
 971   // Accessors for code generation:
<span class="line-modified"> 972   static int type_offset()             { CHECK_INIT(_type_offset); }</span>
<span class="line-modified"> 973   static int form_offset()             { CHECK_INIT(_form_offset); }</span>
 974 };
 975 
 976 // Interface to java.lang.invoke.DirectMethodHandle objects
 977 
 978 class java_lang_invoke_DirectMethodHandle: AllStatic {
 979   friend class JavaClasses;
 980 
 981  private:
 982   static int _member_offset;               // the MemberName of this DMH
 983 
 984   static void compute_offsets();
 985 
 986  public:
 987   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 988 
 989   // Accessors
 990   static oop  member(oop mh);
 991 
 992   // Testers
 993   static bool is_subclass(Klass* klass) {
 994     return klass-&gt;is_subclass_of(SystemDictionary::DirectMethodHandle_klass());
 995   }
 996   static bool is_instance(oop obj);
 997 
 998   // Accessors for code generation:
<span class="line-modified"> 999   static int member_offset()           { CHECK_INIT(_member_offset); }</span>
1000 };
1001 
1002 // Interface to java.lang.invoke.LambdaForm objects
1003 // (These are a private interface for managing adapter code generation.)
1004 
1005 class java_lang_invoke_LambdaForm: AllStatic {
1006   friend class JavaClasses;
1007 
1008  private:
1009   static int _vmentry_offset;  // type is MemberName
1010 
1011   static void compute_offsets();
1012 
1013  public:
1014   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1015 
1016   // Accessors
1017   static oop            vmentry(oop lform);
1018   static void       set_vmentry(oop lform, oop invoker);
1019 
1020   // Testers
1021   static bool is_subclass(Klass* klass) {
1022     return SystemDictionary::LambdaForm_klass() != NULL &amp;&amp;
1023       klass-&gt;is_subclass_of(SystemDictionary::LambdaForm_klass());
1024   }
1025   static bool is_instance(oop obj);
1026 
1027   // Accessors for code generation:
<span class="line-modified">1028   static int vmentry_offset()          { CHECK_INIT(_vmentry_offset); }</span>
1029 };
1030 
1031 
1032 // Interface to java.lang.invoke.MemberName objects
1033 // (These are a private interface for Java code to query the class hierarchy.)
1034 
1035 #define RESOLVEDMETHOD_INJECTED_FIELDS(macro)                                   \
1036   macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \
1037   macro(java_lang_invoke_ResolvedMethodName, vmtarget, intptr_signature, false)
1038 
1039 class java_lang_invoke_ResolvedMethodName : AllStatic {
1040   friend class JavaClasses;
1041 
1042   static int _vmtarget_offset;
1043   static int _vmholder_offset;
1044 
1045   static void compute_offsets();
1046  public:
1047   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1048 
<span class="line-modified">1049   static int vmtarget_offset() { CHECK_INIT(_vmtarget_offset); }</span>
1050 
1051   static Method* vmtarget(oop resolved_method);
1052   static void set_vmtarget(oop resolved_method, Method* method);
1053 
1054   static void set_vmholder(oop resolved_method, oop holder);
1055 
1056   // find or create resolved member name
1057   static oop find_resolved_method(const methodHandle&amp; m, TRAPS);
1058 
1059   static bool is_instance(oop resolved_method);
1060 };
1061 
1062 
1063 #define MEMBERNAME_INJECTED_FIELDS(macro)                               \
1064   macro(java_lang_invoke_MemberName, vmindex,  intptr_signature, false)
1065 
1066 
1067 class java_lang_invoke_MemberName: AllStatic {
1068   friend class JavaClasses;
1069 
</pre>
<hr />
<pre>
1116 
1117   // Relevant integer codes (keep these in synch. with MethodHandleNatives.Constants):
1118   enum {
1119     MN_IS_METHOD             = 0x00010000, // method (not constructor)
1120     MN_IS_CONSTRUCTOR        = 0x00020000, // constructor
1121     MN_IS_FIELD              = 0x00040000, // field
1122     MN_IS_TYPE               = 0x00080000, // nested type
1123     MN_CALLER_SENSITIVE      = 0x00100000, // @CallerSensitive annotation detected
1124     MN_REFERENCE_KIND_SHIFT  = 24, // refKind
1125     MN_REFERENCE_KIND_MASK   = 0x0F000000 &gt;&gt; MN_REFERENCE_KIND_SHIFT,
1126     // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
1127     MN_SEARCH_SUPERCLASSES   = 0x00100000, // walk super classes
1128     MN_SEARCH_INTERFACES     = 0x00200000, // walk implemented interfaces
1129     MN_NESTMATE_CLASS        = 0x00000001,
1130     MN_HIDDEN_CLASS          = 0x00000002,
1131     MN_STRONG_LOADER_LINK    = 0x00000004,
1132     MN_ACCESS_VM_ANNOTATIONS = 0x00000008
1133   };
1134 
1135   // Accessors for code generation:
<span class="line-modified">1136   static int clazz_offset()   { CHECK_INIT(_clazz_offset); }</span>
<span class="line-modified">1137   static int type_offset()    { CHECK_INIT(_type_offset); }</span>
<span class="line-modified">1138   static int flags_offset()   { CHECK_INIT(_flags_offset); }</span>
<span class="line-modified">1139   static int method_offset()  { CHECK_INIT(_method_offset); }</span>
<span class="line-modified">1140   static int vmindex_offset() { CHECK_INIT(_vmindex_offset); }</span>

1141 };
1142 
1143 
1144 // Interface to java.lang.invoke.MethodType objects
1145 
1146 class java_lang_invoke_MethodType: AllStatic {
1147   friend class JavaClasses;
1148 
1149  private:
1150   static int _rtype_offset;
1151   static int _ptypes_offset;
1152 
1153   static void compute_offsets();
1154 
1155  public:
1156   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1157   // Accessors
1158   static oop            rtype(oop mt);
1159   static objArrayOop    ptypes(oop mt);
1160 
1161   static oop            ptype(oop mt, int index);
1162   static int            ptype_count(oop mt);
1163 
1164   static int            ptype_slot_count(oop mt);  // extra counts for long/double
1165   static int            rtype_slot_count(oop mt);  // extra counts for long/double
1166 
1167   static Symbol*        as_signature(oop mt, bool intern_if_not_found);
1168   static void           print_signature(oop mt, outputStream* st);
1169 
1170   static bool is_instance(oop obj);
1171 
1172   static bool equals(oop mt1, oop mt2);
1173 
1174   // Accessors for code generation:
<span class="line-modified">1175   static int rtype_offset()  { CHECK_INIT(_rtype_offset); }</span>
<span class="line-modified">1176   static int ptypes_offset() { CHECK_INIT(_ptypes_offset); }</span>
1177 };
1178 
1179 
1180 // Interface to java.lang.invoke.CallSite objects
1181 
1182 class java_lang_invoke_CallSite: AllStatic {
1183   friend class JavaClasses;
1184 
1185 private:
1186   static int _target_offset;
1187   static int _context_offset;
1188 
1189   static void compute_offsets();
1190 
1191 public:
1192   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1193   // Accessors
1194   static oop              target(          oop site);
1195   static void         set_target(          oop site, oop target);
1196   static void         set_target_volatile( oop site, oop target);
1197 
1198   static oop context_no_keepalive(oop site);
1199 
1200   // Testers
1201   static bool is_subclass(Klass* klass) {
1202     return klass-&gt;is_subclass_of(SystemDictionary::CallSite_klass());
1203   }
1204   static bool is_instance(oop obj);
1205 
1206   // Accessors for code generation:
<span class="line-modified">1207   static int target_offset()  { CHECK_INIT(_target_offset); }</span>
<span class="line-added">1208   static int context_offset() { CHECK_INIT(_context_offset); }</span>
1209 };
1210 
1211 // Interface to java.lang.invoke.ConstantCallSite objects
1212 
1213 class java_lang_invoke_ConstantCallSite: AllStatic {
1214   friend class JavaClasses;
1215 
1216 private:
1217   static int _is_frozen_offset;
1218 
1219   static void compute_offsets();
1220 
1221 public:
1222   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1223   // Accessors
1224   static jboolean is_frozen(oop site);
1225 
1226   // Testers
1227   static bool is_subclass(Klass* klass) {
1228     return klass-&gt;is_subclass_of(SystemDictionary::ConstantCallSite_klass());
</pre>
<hr />
<pre>
1271   static int _isAuthorized_offset;
1272 
1273   static void compute_offsets();
1274  public:
1275   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1276   static oop create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS);
1277 
1278   // Debugging/initialization
1279   friend class JavaClasses;
1280 };
1281 
1282 
1283 // Interface to java.lang.ClassLoader objects
1284 
1285 #define CLASSLOADER_INJECTED_FIELDS(macro)                            \
1286   macro(java_lang_ClassLoader, loader_data,  intptr_signature, false)
1287 
1288 class java_lang_ClassLoader : AllStatic {
1289  private:
1290   static int _loader_data_offset;
<span class="line-modified">1291   static int _parent_offset;</span>
<span class="line-modified">1292   static int _parallelCapable_offset;</span>
<span class="line-modified">1293   static int _name_offset;</span>
<span class="line-modified">1294   static int _nameAndId_offset;</span>
<span class="line-modified">1295   static int _unnamedModule_offset;</span>

1296 

1297   static void compute_offsets();
<span class="line-added">1298 </span>
<span class="line-added">1299  public:</span>
1300   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1301 
1302   static ClassLoaderData* loader_data_acquire(oop loader);
1303   static ClassLoaderData* loader_data_raw(oop loader);
1304   static void release_set_loader_data(oop loader, ClassLoaderData* new_data);
1305 
1306   static oop parent(oop loader);
1307   static oop name(oop loader);
1308   static oop nameAndId(oop loader);
1309   static bool isAncestor(oop loader, oop cl);
1310 
1311   // Support for parallelCapable field
1312   static bool parallelCapable(oop the_class_mirror);
1313 
1314   static bool is_trusted_loader(oop loader);
1315 
1316   // Return true if this is one of the class loaders associated with
1317   // the generated bytecodes for reflection.
1318   static bool is_reflection_class_loader(oop loader);
1319 
1320   // Fix for 4474172
1321   static oop  non_reflection_class_loader(oop loader);
1322 
1323   // Testers
1324   static bool is_subclass(Klass* klass) {
1325     return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass());
1326   }
1327   static bool is_instance(oop obj);
1328 
1329   static oop unnamedModule(oop loader);
1330 
1331   // Debugging
1332   friend class JavaClasses;

1333 };
1334 
1335 
1336 // Interface to java.lang.System objects
1337 
1338 class java_lang_System : AllStatic {
1339  private:
<span class="line-modified">1340   static int _static_in_offset;</span>
<span class="line-modified">1341   static int _static_out_offset;</span>
<span class="line-modified">1342   static int _static_err_offset;</span>
<span class="line-modified">1343   static int _static_security_offset;</span>
1344 
1345  public:
<span class="line-modified">1346   static int  in_offset() { CHECK_INIT(_static_in_offset); }</span>
<span class="line-modified">1347   static int out_offset() { CHECK_INIT(_static_out_offset); }</span>
<span class="line-modified">1348   static int err_offset() { CHECK_INIT(_static_err_offset); }</span>
1349 
1350   static void compute_offsets();
1351   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1352 
1353   // Debugging
1354   friend class JavaClasses;
1355 };
1356 
1357 
1358 // Interface to java.lang.StackTraceElement objects
1359 
1360 class java_lang_StackTraceElement: AllStatic {
1361  private:
<span class="line-modified">1362   static int _declaringClassObject_offset;</span>
<span class="line-modified">1363   static int _classLoaderName_offset;</span>
<span class="line-modified">1364   static int _moduleName_offset;</span>
<span class="line-modified">1365   static int _moduleVersion_offset;</span>
<span class="line-modified">1366   static int _declaringClass_offset;</span>
<span class="line-modified">1367   static int _methodName_offset;</span>
<span class="line-modified">1368   static int _fileName_offset;</span>
<span class="line-modified">1369   static int _lineNumber_offset;</span>
1370 
1371   // Setters
1372   static void set_classLoaderName(oop element, oop value);
1373   static void set_moduleName(oop element, oop value);
1374   static void set_moduleVersion(oop element, oop value);
1375   static void set_declaringClass(oop element, oop value);
1376   static void set_methodName(oop element, oop value);
1377   static void set_fileName(oop element, oop value);
1378   static void set_lineNumber(oop element, int value);
1379   static void set_declaringClassObject(oop element, oop value);
1380 
1381   static void decode_file_and_line(Handle java_mirror, InstanceKlass* holder, int version,
1382                                    const methodHandle&amp; method, int bci,
1383                                    Symbol*&amp; source, oop&amp; source_file, int&amp; line_number, TRAPS);
1384 
1385  public:
1386   // Create an instance of StackTraceElement
1387   static oop create(const methodHandle&amp; method, int bci, TRAPS);
1388 
1389   static void fill_in(Handle element, InstanceKlass* holder, const methodHandle&amp; method,
</pre>
<hr />
<pre>
1453   static int _operands_offset;
1454   static int _mode_offset;
1455 
1456  public:
1457   static void set_monitors(oop info, oop value);
1458   static void set_locals(oop info, oop value);
1459   static void set_operands(oop info, oop value);
1460   static void set_mode(oop info, int value);
1461 
1462   static void compute_offsets();
1463   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1464 
1465   // Debugging
1466   friend class JavaClasses;
1467 };
1468 
1469 // Interface to java.lang.reflect.RecordComponent objects
1470 
1471 class java_lang_reflect_RecordComponent: AllStatic {
1472  private:
<span class="line-modified">1473   static int _clazz_offset;</span>
<span class="line-modified">1474   static int _name_offset;</span>
<span class="line-modified">1475   static int _type_offset;</span>
<span class="line-modified">1476   static int _accessor_offset;</span>
<span class="line-modified">1477   static int _signature_offset;</span>
<span class="line-modified">1478   static int _annotations_offset;</span>
<span class="line-modified">1479   static int _typeAnnotations_offset;</span>
1480 
1481   // Setters
1482   static void set_clazz(oop element, oop value);
1483   static void set_name(oop element, oop value);
1484   static void set_type(oop element, oop value);
1485   static void set_accessor(oop element, oop value);
1486   static void set_signature(oop element, oop value);
1487   static void set_annotations(oop element, oop value);
1488   static void set_typeAnnotations(oop element, oop value);
1489 
1490  public:
1491   // Create an instance of RecordComponent
1492   static oop create(InstanceKlass* holder, RecordComponent* component, TRAPS);
1493 
1494   static void compute_offsets();
1495   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1496 
1497   // Debugging
1498   friend class JavaClasses;
1499 };
1500 
1501 
1502 // Interface to java.lang.AssertionStatusDirectives objects
1503 
1504 class java_lang_AssertionStatusDirectives: AllStatic {
1505  private:
<span class="line-modified">1506   static int _classes_offset;</span>
<span class="line-modified">1507   static int _classEnabled_offset;</span>
<span class="line-modified">1508   static int _packages_offset;</span>
<span class="line-modified">1509   static int _packageEnabled_offset;</span>
<span class="line-modified">1510   static int _deflt_offset;</span>
1511 
1512  public:
1513   // Setters
1514   static void set_classes(oop obj, oop val);
1515   static void set_classEnabled(oop obj, oop val);
1516   static void set_packages(oop obj, oop val);
1517   static void set_packageEnabled(oop obj, oop val);
1518   static void set_deflt(oop obj, bool val);
1519 
1520   static void compute_offsets();
1521   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1522 
1523   // Debugging
1524   friend class JavaClasses;
1525 };
1526 
1527 
1528 class java_nio_Buffer: AllStatic {
1529  private:
1530   static int _limit_offset;
1531 
1532  public:
<span class="line-modified">1533   static int  limit_offset() { CHECK_INIT(_limit_offset); }</span>
1534   static void compute_offsets();
1535   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1536 };
1537 
1538 class java_util_concurrent_locks_AbstractOwnableSynchronizer : AllStatic {
1539  private:
1540   static int  _owner_offset;
1541  public:
1542   static void compute_offsets();
1543   static oop  get_owner_threadObj(oop obj);
1544   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1545 };
1546 
1547  // Interface to jdk.internal.misc.UnsafeConsants
1548 
1549 class jdk_internal_misc_UnsafeConstants : AllStatic {
1550  public:
1551   static void set_unsafe_constants();
1552   static void compute_offsets() { }
1553   static void serialize_offsets(SerializeClosure* f) { }
</pre>
<hr />
<pre>
1690   static InjectedField _injected_fields[];
1691 
1692   static bool check_offset(const char *klass_name, int offset, const char *field_name, const char* field_sig) PRODUCT_RETURN0;
1693  public:
1694   enum InjectedFieldID {
1695     ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)
1696     MAX_enum
1697   };
1698 
1699   static int compute_injected_offset(InjectedFieldID id);
1700 
1701   static void compute_offsets();
1702   static void check_offsets() PRODUCT_RETURN;
1703   static void serialize_offsets(SerializeClosure* soc) NOT_CDS_RETURN;
1704   static InjectedField* get_injected(Symbol* class_name, int* field_count);
1705   static bool is_supported_for_archiving(oop obj) NOT_CDS_JAVA_HEAP_RETURN_(false);
1706 };
1707 
1708 #undef DECLARE_INJECTED_FIELD_ENUM
1709 
<span class="line-added">1710 #undef CHECK_INIT</span>
1711 #endif // SHARE_CLASSFILE_JAVACLASSES_HPP
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
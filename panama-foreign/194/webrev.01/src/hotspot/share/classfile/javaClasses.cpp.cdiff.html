<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compactHashtable.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 175,50 ***</span>
      vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
    }
    compute_offset(dest_offset, ik, name, signature_symbol, is_static);
  }
  
<span class="line-removed">- int java_lang_String::value_offset  = 0;</span>
<span class="line-removed">- int java_lang_String::hash_offset   = 0;</span>
<span class="line-removed">- int java_lang_String::hashIsZero_offset = 0;</span>
<span class="line-removed">- int java_lang_String::coder_offset  = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool java_lang_String::initialized  = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool java_lang_String::is_instance(oop obj) {</span>
<span class="line-removed">-   return is_instance_inlined(obj);</span>
<span class="line-removed">- }</span>
  
  #if INCLUDE_CDS
  #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
    f-&gt;do_u4((u4*)&amp;offset)
  #endif
  
  #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
    compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
  
  #define STRING_FIELDS_DO(macro) \
<span class="line-modified">!   macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \</span>
<span class="line-modified">!   macro(hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \</span>
<span class="line-modified">!   macro(hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \</span>
<span class="line-modified">!   macro(coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);</span>
  
  void java_lang_String::compute_offsets() {
<span class="line-modified">!   if (initialized) {</span>
      return;
    }
  
    InstanceKlass* k = SystemDictionary::String_klass();
    STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  
<span class="line-modified">!   initialized = true;</span>
  }
  
  #if INCLUDE_CDS
  void java_lang_String::serialize_offsets(SerializeClosure* f) {
    STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
<span class="line-modified">!   f-&gt;do_bool(&amp;initialized);</span>
  }
  #endif
  
  class CompactStringsFixup : public FieldClosure {
  private:
<span class="line-new-header">--- 175,54 ---</span>
      vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
    }
    compute_offset(dest_offset, ik, name, signature_symbol, is_static);
  }
  
  
  #if INCLUDE_CDS
  #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
    f-&gt;do_u4((u4*)&amp;offset)
  #endif
  
  #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
    compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
  
<span class="line-added">+ </span>
<span class="line-added">+ // java_lang_String</span>
<span class="line-added">+ </span>
<span class="line-added">+ int java_lang_String::_value_offset;</span>
<span class="line-added">+ int java_lang_String::_hash_offset;</span>
<span class="line-added">+ int java_lang_String::_hashIsZero_offset;</span>
<span class="line-added">+ int java_lang_String::_coder_offset;</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool java_lang_String::_initialized;</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool java_lang_String::is_instance(oop obj) {</span>
<span class="line-added">+   return is_instance_inlined(obj);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #define STRING_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \</span>
<span class="line-modified">!   macro(_hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \</span>
<span class="line-modified">!   macro(_hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \</span>
<span class="line-modified">!   macro(_coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);</span>
  
  void java_lang_String::compute_offsets() {
<span class="line-modified">!   if (_initialized) {</span>
      return;
    }
  
    InstanceKlass* k = SystemDictionary::String_klass();
    STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  
<span class="line-modified">!   _initialized = true;</span>
  }
  
  #if INCLUDE_CDS
  void java_lang_String::serialize_offsets(SerializeClosure* f) {
    STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
<span class="line-modified">!   f-&gt;do_bool(&amp;_initialized);</span>
  }
  #endif
  
  class CompactStringsFixup : public FieldClosure {
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,11 ***</span>
    CompactStringsFixup fix(value);
    SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);
  }
  
  Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
<span class="line-modified">!   assert(initialized, &quot;Must be initialized&quot;);</span>
    assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
  
    // Create the String object first, so there&#39;s a chance that the String
    // and the char array it points to end up in the same cache line.
    oop obj;
<span class="line-new-header">--- 245,11 ---</span>
    CompactStringsFixup fix(value);
    SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);
  }
  
  Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
<span class="line-modified">!   assert(_initialized, &quot;Must be initialized&quot;);</span>
    assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
  
    // Create the String object first, so there&#39;s a chance that the String
    // and the char array it points to end up in the same cache line.
    oop obj;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 539,13 ***</span>
    // these fields. Necessary restrictions to allow this to be correct
    // without explicit memory fences or similar concurrency primitives is
    // that we can ever only write to one of these two fields for a given
    // String instance, and that the computation is idempotent and derived
    // from immutable state
<span class="line-modified">!   assert(initialized &amp;&amp; (hash_offset &gt; 0) &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);</span>
    if (java_lang_String::hash_is_set(java_string)) {
<span class="line-modified">!     return java_string-&gt;int_field(hash_offset);</span>
    }
  
    typeArrayOop value = java_lang_String::value(java_string);
    int         length = java_lang_String::length(java_string, value);
    bool     is_latin1 = java_lang_String::is_latin1(java_string);
<span class="line-new-header">--- 543,13 ---</span>
    // these fields. Necessary restrictions to allow this to be correct
    // without explicit memory fences or similar concurrency primitives is
    // that we can ever only write to one of these two fields for a given
    // String instance, and that the computation is idempotent and derived
    // from immutable state
<span class="line-modified">!   assert(_initialized &amp;&amp; (_hash_offset &gt; 0) &amp;&amp; (_hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);</span>
    if (java_lang_String::hash_is_set(java_string)) {
<span class="line-modified">!     return java_string-&gt;int_field(_hash_offset);</span>
    }
  
    typeArrayOop value = java_lang_String::value(java_string);
    int         length = java_lang_String::length(java_string, value);
    bool     is_latin1 = java_lang_String::is_latin1(java_string);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 558,13 ***</span>
        hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);
      }
    }
  
    if (hash != 0) {
<span class="line-modified">!     java_string-&gt;int_field_put(hash_offset, hash);</span>
    } else {
<span class="line-modified">!     java_string-&gt;bool_field_put(hashIsZero_offset, true);</span>
    }
    return hash;
  }
  
  char* java_lang_String::as_quoted_ascii(oop java_string) {
<span class="line-new-header">--- 562,13 ---</span>
        hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);
      }
    }
  
    if (hash != 0) {
<span class="line-modified">!     java_string-&gt;int_field_put(_hash_offset, hash);</span>
    } else {
<span class="line-modified">!     java_string-&gt;bool_field_put(_hashIsZero_offset, true);</span>
    }
    return hash;
  }
  
  char* java_lang_String::as_quoted_ascii(oop java_string) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 792,10 ***</span>
<span class="line-new-header">--- 796,30 ---</span>
                             ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
    }
    st-&gt;print(&quot;\&quot;&quot;);
  }
  
<span class="line-added">+ // java_lang_Class</span>
<span class="line-added">+ </span>
<span class="line-added">+ int java_lang_Class::_klass_offset;</span>
<span class="line-added">+ int java_lang_Class::_array_klass_offset;</span>
<span class="line-added">+ int java_lang_Class::_oop_size_offset;</span>
<span class="line-added">+ int java_lang_Class::_static_oop_field_count_offset;</span>
<span class="line-added">+ int java_lang_Class::_class_loader_offset;</span>
<span class="line-added">+ int java_lang_Class::_module_offset;</span>
<span class="line-added">+ int java_lang_Class::_protection_domain_offset;</span>
<span class="line-added">+ int java_lang_Class::_component_mirror_offset;</span>
<span class="line-added">+ int java_lang_Class::_init_lock_offset;</span>
<span class="line-added">+ int java_lang_Class::_signers_offset;</span>
<span class="line-added">+ int java_lang_Class::_name_offset;</span>
<span class="line-added">+ int java_lang_Class::_source_file_offset;</span>
<span class="line-added">+ int java_lang_Class::_classData_offset;</span>
<span class="line-added">+ int java_lang_Class::_classRedefinedCount_offset;</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool java_lang_Class::_offsets_computed = false;</span>
<span class="line-added">+ GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;</span>
<span class="line-added">+ GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;</span>
  
  static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
    assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
    if (fd-&gt;has_initial_value()) {
      BasicType t = fd-&gt;field_type();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1616,27 ***</span>
    assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
    assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
    return mirror;
  }
  
<span class="line-removed">- bool java_lang_Class::offsets_computed = false;</span>
<span class="line-removed">- int  java_lang_Class::classRedefinedCount_offset = -1;</span>
<span class="line-removed">- </span>
  #define CLASS_FIELDS_DO(macro) \
<span class="line-modified">!   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \</span>
<span class="line-modified">!   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \</span>
<span class="line-modified">!   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \</span>
<span class="line-modified">!   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \</span>
<span class="line-modified">!   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \</span>
<span class="line-modified">!   macro(_classData_offset,          k, &quot;classData&quot;,           object_signature,      false);</span>
  
  void java_lang_Class::compute_offsets() {
<span class="line-modified">!   if (offsets_computed) {</span>
      return;
    }
  
<span class="line-modified">!   offsets_computed = true;</span>
  
    InstanceKlass* k = SystemDictionary::Class_klass();
    CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  
    // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
<span class="line-new-header">--- 1640,24 ---</span>
    assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
    assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
    return mirror;
  }
  
  #define CLASS_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \</span>
<span class="line-modified">!   macro(_class_loader_offset,        k, &quot;classLoader&quot;,         classloader_signature, false); \</span>
<span class="line-modified">!   macro(_component_mirror_offset,    k, &quot;componentType&quot;,       class_signature,       false); \</span>
<span class="line-modified">!   macro(_module_offset,              k, &quot;module&quot;,              module_signature,      false); \</span>
<span class="line-modified">!   macro(_name_offset,                k, &quot;name&quot;,                string_signature,      false); \</span>
<span class="line-modified">!   macro(_classData_offset,           k, &quot;classData&quot;,           object_signature,      false);</span>
  
  void java_lang_Class::compute_offsets() {
<span class="line-modified">!   if (_offsets_computed) {</span>
      return;
    }
  
<span class="line-modified">!   _offsets_computed = true;</span>
  
    InstanceKlass* k = SystemDictionary::Class_klass();
    CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  
    // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1647,27 ***</span>
    CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
  }
  
  #if INCLUDE_CDS
  void java_lang_Class::serialize_offsets(SerializeClosure* f) {
<span class="line-modified">!   f-&gt;do_bool(&amp;offsets_computed);</span>
    f-&gt;do_u4((u4*)&amp;_init_lock_offset);
  
    CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  
    CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
<span class="line-modified">!   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">!   return the_class_mirror-&gt;int_field(classRedefinedCount_offset);</span>
  }
  
  void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
<span class="line-modified">!   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">!   the_class_mirror-&gt;int_field_put(classRedefinedCount_offset, value);</span>
  }
  
  
  // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
  //       platform thread structure, and a eetop offset which was used for thread
<span class="line-new-header">--- 1668,27 ---</span>
    CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
  }
  
  #if INCLUDE_CDS
  void java_lang_Class::serialize_offsets(SerializeClosure* f) {
<span class="line-modified">!   f-&gt;do_bool(&amp;_offsets_computed);</span>
    f-&gt;do_u4((u4*)&amp;_init_lock_offset);
  
    CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  
    CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
<span class="line-modified">!   assert(_classRedefinedCount_offset != 0, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">!   return the_class_mirror-&gt;int_field(_classRedefinedCount_offset);</span>
  }
  
  void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
<span class="line-modified">!   assert(_classRedefinedCount_offset != 0, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">!   the_class_mirror-&gt;int_field_put(_classRedefinedCount_offset, value);</span>
  }
  
  
  // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
  //       platform thread structure, and a eetop offset which was used for thread
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1675,23 ***</span>
  //       merged, so in the HotSpot VM we just use the eetop field for the thread
  //       instead of the privateInfo_offset.
  //
  // Note: The stackSize field is only present starting in 1.4.
  
<span class="line-modified">! int java_lang_Thread::_name_offset = 0;</span>
<span class="line-modified">! int java_lang_Thread::_group_offset = 0;</span>
<span class="line-modified">! int java_lang_Thread::_contextClassLoader_offset = 0;</span>
<span class="line-modified">! int java_lang_Thread::_inheritedAccessControlContext_offset = 0;</span>
<span class="line-modified">! int java_lang_Thread::_priority_offset = 0;</span>
<span class="line-modified">! int java_lang_Thread::_eetop_offset = 0;</span>
<span class="line-modified">! int java_lang_Thread::_interrupted_offset = 0;</span>
<span class="line-modified">! int java_lang_Thread::_daemon_offset = 0;</span>
<span class="line-modified">! int java_lang_Thread::_stillborn_offset = 0;</span>
<span class="line-modified">! int java_lang_Thread::_stackSize_offset = 0;</span>
<span class="line-modified">! int java_lang_Thread::_tid_offset = 0;</span>
<span class="line-modified">! int java_lang_Thread::_thread_status_offset = 0;</span>
<span class="line-modified">! int java_lang_Thread::_park_blocker_offset = 0;</span>
  
  #define THREAD_FIELDS_DO(macro) \
    macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
    macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
    macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
<span class="line-new-header">--- 1696,23 ---</span>
  //       merged, so in the HotSpot VM we just use the eetop field for the thread
  //       instead of the privateInfo_offset.
  //
  // Note: The stackSize field is only present starting in 1.4.
  
<span class="line-modified">! int java_lang_Thread::_name_offset;</span>
<span class="line-modified">! int java_lang_Thread::_group_offset;</span>
<span class="line-modified">! int java_lang_Thread::_contextClassLoader_offset;</span>
<span class="line-modified">! int java_lang_Thread::_inheritedAccessControlContext_offset;</span>
<span class="line-modified">! int java_lang_Thread::_priority_offset;</span>
<span class="line-modified">! int java_lang_Thread::_eetop_offset;</span>
<span class="line-modified">! int java_lang_Thread::_interrupted_offset;</span>
<span class="line-modified">! int java_lang_Thread::_daemon_offset;</span>
<span class="line-modified">! int java_lang_Thread::_stillborn_offset;</span>
<span class="line-modified">! int java_lang_Thread::_stackSize_offset;</span>
<span class="line-modified">! int java_lang_Thread::_tid_offset;</span>
<span class="line-modified">! int java_lang_Thread::_thread_status_offset;</span>
<span class="line-modified">! int java_lang_Thread::_park_blocker_offset;</span>
  
  #define THREAD_FIELDS_DO(macro) \
    macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
    macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
    macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1849,19 ***</span>
      case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
      case TERMINATED               : return &quot;TERMINATED&quot;;
      default                       : return &quot;UNKNOWN&quot;;
    };
  }
<span class="line-modified">! int java_lang_ThreadGroup::_parent_offset = 0;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_name_offset = 0;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_threads_offset = 0;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_groups_offset = 0;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_maxPriority_offset = 0;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_destroyed_offset = 0;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_daemon_offset = 0;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_nthreads_offset = 0;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_ngroups_offset = 0;</span>
  
  oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
    assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
    return java_thread_group-&gt;obj_field(_parent_offset);
  }
<span class="line-new-header">--- 1870,19 ---</span>
      case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
      case TERMINATED               : return &quot;TERMINATED&quot;;
      default                       : return &quot;UNKNOWN&quot;;
    };
  }
<span class="line-modified">! int java_lang_ThreadGroup::_parent_offset;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_name_offset;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_threads_offset;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_groups_offset;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_maxPriority_offset;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_destroyed_offset;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_daemon_offset;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_nthreads_offset;</span>
<span class="line-modified">! int java_lang_ThreadGroup::_ngroups_offset;</span>
  
  oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
    assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
    return java_thread_group-&gt;obj_field(_parent_offset);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1937,16 ***</span>
  void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
    THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  #define THROWABLE_FIELDS_DO(macro) \
<span class="line-modified">!   macro(backtrace_offset,     k, &quot;backtrace&quot;,     object_signature,                  false); \</span>
<span class="line-modified">!   macro(detailMessage_offset, k, &quot;detailMessage&quot;, string_signature,                  false); \</span>
<span class="line-modified">!   macro(stackTrace_offset,    k, &quot;stackTrace&quot;,    java_lang_StackTraceElement_array, false); \</span>
<span class="line-modified">!   macro(depth_offset,         k, &quot;depth&quot;,         int_signature,                     false); \</span>
<span class="line-modified">!   macro(static_unassigned_stacktrace_offset, k, &quot;UNASSIGNED_STACK&quot;, java_lang_StackTraceElement_array, true)</span>
  
  void java_lang_Throwable::compute_offsets() {
    InstanceKlass* k = SystemDictionary::Throwable_klass();
    THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
<span class="line-new-header">--- 1958,24 ---</span>
  void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
    THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
<span class="line-added">+ // java_lang_Throwable</span>
<span class="line-added">+ </span>
<span class="line-added">+ int java_lang_Throwable::_backtrace_offset;</span>
<span class="line-added">+ int java_lang_Throwable::_detailMessage_offset;</span>
<span class="line-added">+ int java_lang_Throwable::_stackTrace_offset;</span>
<span class="line-added">+ int java_lang_Throwable::_depth_offset;</span>
<span class="line-added">+ int java_lang_Throwable::_static_unassigned_stacktrace_offset;</span>
<span class="line-added">+ </span>
  #define THROWABLE_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_backtrace_offset,     k, &quot;backtrace&quot;,     object_signature,                  false); \</span>
<span class="line-modified">!   macro(_detailMessage_offset, k, &quot;detailMessage&quot;, string_signature,                  false); \</span>
<span class="line-modified">!   macro(_stackTrace_offset,    k, &quot;stackTrace&quot;,    java_lang_StackTraceElement_array, false); \</span>
<span class="line-modified">!   macro(_depth_offset,         k, &quot;depth&quot;,         int_signature,                     false); \</span>
<span class="line-modified">!   macro(_static_unassigned_stacktrace_offset, k, &quot;UNASSIGNED_STACK&quot;, java_lang_StackTraceElement_array, true)</span>
  
  void java_lang_Throwable::compute_offsets() {
    InstanceKlass* k = SystemDictionary::Throwable_klass();
    THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1958,32 ***</span>
  #endif
  
  oop java_lang_Throwable::unassigned_stacktrace() {
    InstanceKlass* ik = SystemDictionary::Throwable_klass();
    oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">!   return base-&gt;obj_field(static_unassigned_stacktrace_offset);</span>
  }
  
  oop java_lang_Throwable::backtrace(oop throwable) {
<span class="line-modified">!   return throwable-&gt;obj_field_acquire(backtrace_offset);</span>
  }
  
  
  void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
<span class="line-modified">!   throwable-&gt;release_obj_field_put(backtrace_offset, value);</span>
  }
  
  int java_lang_Throwable::depth(oop throwable) {
<span class="line-modified">!   return throwable-&gt;int_field(depth_offset);</span>
  }
  
  void java_lang_Throwable::set_depth(oop throwable, int value) {
<span class="line-modified">!   throwable-&gt;int_field_put(depth_offset, value);</span>
  }
  
  oop java_lang_Throwable::message(oop throwable) {
<span class="line-modified">!   return throwable-&gt;obj_field(detailMessage_offset);</span>
  }
  
  
  // Return Symbol for detailed_message or NULL
  Symbol* java_lang_Throwable::detail_message(oop throwable) {
<span class="line-new-header">--- 1987,32 ---</span>
  #endif
  
  oop java_lang_Throwable::unassigned_stacktrace() {
    InstanceKlass* ik = SystemDictionary::Throwable_klass();
    oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">!   return base-&gt;obj_field(_static_unassigned_stacktrace_offset);</span>
  }
  
  oop java_lang_Throwable::backtrace(oop throwable) {
<span class="line-modified">!   return throwable-&gt;obj_field_acquire(_backtrace_offset);</span>
  }
  
  
  void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
<span class="line-modified">!   throwable-&gt;release_obj_field_put(_backtrace_offset, value);</span>
  }
  
  int java_lang_Throwable::depth(oop throwable) {
<span class="line-modified">!   return throwable-&gt;int_field(_depth_offset);</span>
  }
  
  void java_lang_Throwable::set_depth(oop throwable, int value) {
<span class="line-modified">!   throwable-&gt;int_field_put(_depth_offset, value);</span>
  }
  
  oop java_lang_Throwable::message(oop throwable) {
<span class="line-modified">!   return throwable-&gt;obj_field(_detailMessage_offset);</span>
  }
  
  
  // Return Symbol for detailed_message or NULL
  Symbol* java_lang_Throwable::detail_message(oop throwable) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1994,16 ***</span>
    }
    return NULL;
  }
  
  void java_lang_Throwable::set_message(oop throwable, oop value) {
<span class="line-modified">!   throwable-&gt;obj_field_put(detailMessage_offset, value);</span>
  }
  
  
  void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
<span class="line-modified">!   throwable-&gt;obj_field_put(stackTrace_offset, st_element_array);</span>
  }
  
  void java_lang_Throwable::clear_stacktrace(oop throwable) {
    set_stacktrace(throwable, NULL);
  }
<span class="line-new-header">--- 2023,16 ---</span>
    }
    return NULL;
  }
  
  void java_lang_Throwable::set_message(oop throwable, oop value) {
<span class="line-modified">!   throwable-&gt;obj_field_put(_detailMessage_offset, value);</span>
  }
  
  
  void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
<span class="line-modified">!   throwable-&gt;obj_field_put(_stackTrace_offset, st_element_array);</span>
  }
  
  void java_lang_Throwable::clear_stacktrace(oop throwable) {
    set_stacktrace(throwable, NULL);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2778,10 ***</span>
<span class="line-new-header">--- 2807,33 ---</span>
    Handle java_class(THREAD, holder-&gt;java_mirror());
    decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
  }
  #endif // INCLUDE_JVMCI
  
<span class="line-added">+ // java_lang_StackFrameInfo</span>
<span class="line-added">+ </span>
<span class="line-added">+ int java_lang_StackFrameInfo::_memberName_offset;</span>
<span class="line-added">+ int java_lang_StackFrameInfo::_bci_offset;</span>
<span class="line-added">+ int java_lang_StackFrameInfo::_version_offset;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define STACKFRAMEINFO_FIELDS_DO(macro) \</span>
<span class="line-added">+   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \</span>
<span class="line-added">+   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false)</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_StackFrameInfo::compute_offsets() {</span>
<span class="line-added">+   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();</span>
<span class="line-added">+   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">+   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_CDS</span>
<span class="line-added">+ void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">+   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">+   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
    HandleMark hm(THREAD);
    Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
    Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
    // we should expand MemberName::name when Throwable uses StackTrace
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2817,26 ***</span>
    Symbol* name = method-&gt;name();
    java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),
                                         version, bci, name, CHECK);
  }
  
<span class="line-modified">! #define STACKFRAMEINFO_FIELDS_DO(macro) \</span>
<span class="line-modified">!   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \</span>
<span class="line-removed">-   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false)</span>
<span class="line-removed">- </span>
<span class="line-removed">- void java_lang_StackFrameInfo::compute_offsets() {</span>
<span class="line-removed">-   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();</span>
<span class="line-removed">-   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-removed">-   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);</span>
  }
  
<span class="line-modified">! #if INCLUDE_CDS</span>
<span class="line-modified">! void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-modified">!   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-removed">-   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);</span>
  }
<span class="line-modified">! #endif</span>
  
  #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
    macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
    macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
    macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
<span class="line-new-header">--- 2869,23 ---</span>
    Symbol* name = method-&gt;name();
    java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),
                                         version, bci, name, CHECK);
  }
  
<span class="line-modified">! void java_lang_StackFrameInfo::set_version(oop element, short value) {</span>
<span class="line-modified">!   element-&gt;short_field_put(_version_offset, value);</span>
  }
  
<span class="line-modified">! void java_lang_StackFrameInfo::set_bci(oop element, int value) {</span>
<span class="line-modified">!   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);</span>
<span class="line-modified">!   element-&gt;int_field_put(_bci_offset, value);</span>
  }
<span class="line-modified">! </span>
<span class="line-added">+ int java_lang_LiveStackFrameInfo::_monitors_offset;</span>
<span class="line-added">+ int java_lang_LiveStackFrameInfo::_locals_offset;</span>
<span class="line-added">+ int java_lang_LiveStackFrameInfo::_operands_offset;</span>
<span class="line-added">+ int java_lang_LiveStackFrameInfo::_mode_offset;</span>
  
  #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
    macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
    macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
    macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2851,12 ***</span>
  void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
    LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
<span class="line-modified">!   macro(override_offset, k, &quot;override&quot;, bool_signature, false)</span>
  
  void java_lang_reflect_AccessibleObject::compute_offsets() {
    InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
    ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
<span class="line-new-header">--- 2900,33 ---</span>
  void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
    LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
<span class="line-added">+ void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {</span>
<span class="line-added">+   element-&gt;obj_field_put(_monitors_offset, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {</span>
<span class="line-added">+   element-&gt;obj_field_put(_locals_offset, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {</span>
<span class="line-added">+   element-&gt;obj_field_put(_operands_offset, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {</span>
<span class="line-added">+   element-&gt;int_field_put(_mode_offset, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ // java_lang_AccessibleObject</span>
<span class="line-added">+ </span>
<span class="line-added">+ int java_lang_reflect_AccessibleObject::_override_offset;</span>
<span class="line-added">+ </span>
  #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_override_offset, k, &quot;override&quot;, bool_signature, false)</span>
  
  void java_lang_reflect_AccessibleObject::compute_offsets() {
    InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
    ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2866,31 ***</span>
    ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return (jboolean) reflect-&gt;bool_field(override_offset);</span>
  }
  
  void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   reflect-&gt;bool_field_put(override_offset, (int) value);</span>
  }
  
  #define METHOD_FIELDS_DO(macro) \
<span class="line-modified">!   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \</span>
<span class="line-modified">!   macro(name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \</span>
<span class="line-modified">!   macro(returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \</span>
<span class="line-modified">!   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">!   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">!   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \</span>
<span class="line-modified">!   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \</span>
<span class="line-modified">!   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \</span>
<span class="line-modified">!   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \</span>
<span class="line-modified">!   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \</span>
<span class="line-modified">!   macro(annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);</span>
  
  void java_lang_reflect_Method::compute_offsets() {
    InstanceKlass* k = SystemDictionary::reflect_Method_klass();
    METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
<span class="line-new-header">--- 2936,43 ---</span>
    ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
<span class="line-modified">!   return (jboolean) reflect-&gt;bool_field(_override_offset);</span>
  }
  
  void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
<span class="line-modified">!   reflect-&gt;bool_field_put(_override_offset, (int) value);</span>
  }
  
<span class="line-added">+ // java_lang_reflect_Method</span>
<span class="line-added">+ </span>
<span class="line-added">+ int java_lang_reflect_Method::_clazz_offset;</span>
<span class="line-added">+ int java_lang_reflect_Method::_name_offset;</span>
<span class="line-added">+ int java_lang_reflect_Method::_returnType_offset;</span>
<span class="line-added">+ int java_lang_reflect_Method::_parameterTypes_offset;</span>
<span class="line-added">+ int java_lang_reflect_Method::_exceptionTypes_offset;</span>
<span class="line-added">+ int java_lang_reflect_Method::_slot_offset;</span>
<span class="line-added">+ int java_lang_reflect_Method::_modifiers_offset;</span>
<span class="line-added">+ int java_lang_reflect_Method::_signature_offset;</span>
<span class="line-added">+ int java_lang_reflect_Method::_annotations_offset;</span>
<span class="line-added">+ int java_lang_reflect_Method::_parameter_annotations_offset;</span>
<span class="line-added">+ int java_lang_reflect_Method::_annotation_default_offset;</span>
<span class="line-added">+ </span>
  #define METHOD_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \</span>
<span class="line-modified">!   macro(_name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \</span>
<span class="line-modified">!   macro(_returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \</span>
<span class="line-modified">!   macro(_parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">!   macro(_exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">!   macro(_slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \</span>
<span class="line-modified">!   macro(_modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \</span>
<span class="line-modified">!   macro(_signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \</span>
<span class="line-modified">!   macro(_annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \</span>
<span class="line-modified">!   macro(_parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \</span>
<span class="line-modified">!   macro(_annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);</span>
  
  void java_lang_reflect_Method::compute_offsets() {
    InstanceKlass* k = SystemDictionary::reflect_Method_klass();
    METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2909,93 ***</span>
    assert(InstanceKlass::cast(klass)-&gt;is_initialized(), &quot;must be initialized&quot;);
    return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(THREAD);
  }
  
  oop java_lang_reflect_Method::clazz(oop reflect) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return reflect-&gt;obj_field(clazz_offset);</span>
  }
  
  void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-    reflect-&gt;obj_field_put(clazz_offset, value);</span>
  }
  
  int java_lang_reflect_Method::slot(oop reflect) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return reflect-&gt;int_field(slot_offset);</span>
  }
  
  void java_lang_reflect_Method::set_slot(oop reflect, int value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   reflect-&gt;int_field_put(slot_offset, value);</span>
  }
  
  void java_lang_reflect_Method::set_name(oop method, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   method-&gt;obj_field_put(name_offset, value);</span>
  }
  
  oop java_lang_reflect_Method::return_type(oop method) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return method-&gt;obj_field(returnType_offset);</span>
  }
  
  void java_lang_reflect_Method::set_return_type(oop method, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   method-&gt;obj_field_put(returnType_offset, value);</span>
  }
  
  oop java_lang_reflect_Method::parameter_types(oop method) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return method-&gt;obj_field(parameterTypes_offset);</span>
  }
  
  void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   method-&gt;obj_field_put(parameterTypes_offset, value);</span>
  }
  
  void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   method-&gt;obj_field_put(exceptionTypes_offset, value);</span>
  }
  
  void java_lang_reflect_Method::set_modifiers(oop method, int value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   method-&gt;int_field_put(modifiers_offset, value);</span>
  }
  
  void java_lang_reflect_Method::set_signature(oop method, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   method-&gt;obj_field_put(signature_offset, value);</span>
  }
  
  void java_lang_reflect_Method::set_annotations(oop method, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   method-&gt;obj_field_put(annotations_offset, value);</span>
  }
  
  void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   method-&gt;obj_field_put(parameter_annotations_offset, value);</span>
  }
  
  void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   method-&gt;obj_field_put(annotation_default_offset, value);</span>
  }
  
  #define CONSTRUCTOR_FIELDS_DO(macro) \
<span class="line-modified">!   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \</span>
<span class="line-modified">!   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">!   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">!   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \</span>
<span class="line-modified">!   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \</span>
<span class="line-modified">!   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \</span>
<span class="line-modified">!   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \</span>
<span class="line-modified">!   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);</span>
  
  void java_lang_reflect_Constructor::compute_offsets() {
    InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
    CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
<span class="line-new-header">--- 2991,87 ---</span>
    assert(InstanceKlass::cast(klass)-&gt;is_initialized(), &quot;must be initialized&quot;);
    return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(THREAD);
  }
  
  oop java_lang_reflect_Method::clazz(oop reflect) {
<span class="line-modified">!   return reflect-&gt;obj_field(_clazz_offset);</span>
  }
  
  void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
<span class="line-modified">!    reflect-&gt;obj_field_put(_clazz_offset, value);</span>
  }
  
  int java_lang_reflect_Method::slot(oop reflect) {
<span class="line-modified">!   return reflect-&gt;int_field(_slot_offset);</span>
  }
  
  void java_lang_reflect_Method::set_slot(oop reflect, int value) {
<span class="line-modified">!   reflect-&gt;int_field_put(_slot_offset, value);</span>
  }
  
  void java_lang_reflect_Method::set_name(oop method, oop value) {
<span class="line-modified">!   method-&gt;obj_field_put(_name_offset, value);</span>
  }
  
  oop java_lang_reflect_Method::return_type(oop method) {
<span class="line-modified">!   return method-&gt;obj_field(_returnType_offset);</span>
  }
  
  void java_lang_reflect_Method::set_return_type(oop method, oop value) {
<span class="line-modified">!   method-&gt;obj_field_put(_returnType_offset, value);</span>
  }
  
  oop java_lang_reflect_Method::parameter_types(oop method) {
<span class="line-modified">!   return method-&gt;obj_field(_parameterTypes_offset);</span>
  }
  
  void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
<span class="line-modified">!   method-&gt;obj_field_put(_parameterTypes_offset, value);</span>
  }
  
  void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
<span class="line-modified">!   method-&gt;obj_field_put(_exceptionTypes_offset, value);</span>
  }
  
  void java_lang_reflect_Method::set_modifiers(oop method, int value) {
<span class="line-modified">!   method-&gt;int_field_put(_modifiers_offset, value);</span>
  }
  
  void java_lang_reflect_Method::set_signature(oop method, oop value) {
<span class="line-modified">!   method-&gt;obj_field_put(_signature_offset, value);</span>
  }
  
  void java_lang_reflect_Method::set_annotations(oop method, oop value) {
<span class="line-modified">!   method-&gt;obj_field_put(_annotations_offset, value);</span>
  }
  
  void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
<span class="line-modified">!   method-&gt;obj_field_put(_parameter_annotations_offset, value);</span>
  }
  
  void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
<span class="line-modified">!   method-&gt;obj_field_put(_annotation_default_offset, value);</span>
  }
  
<span class="line-added">+ int java_lang_reflect_Constructor::_clazz_offset;</span>
<span class="line-added">+ int java_lang_reflect_Constructor::_parameterTypes_offset;</span>
<span class="line-added">+ int java_lang_reflect_Constructor::_exceptionTypes_offset;</span>
<span class="line-added">+ int java_lang_reflect_Constructor::_slot_offset;</span>
<span class="line-added">+ int java_lang_reflect_Constructor::_modifiers_offset;</span>
<span class="line-added">+ int java_lang_reflect_Constructor::_signature_offset;</span>
<span class="line-added">+ int java_lang_reflect_Constructor::_annotations_offset;</span>
<span class="line-added">+ int java_lang_reflect_Constructor::_parameter_annotations_offset;</span>
<span class="line-added">+ </span>
  #define CONSTRUCTOR_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \</span>
<span class="line-modified">!   macro(_parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">!   macro(_exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">!   macro(_slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \</span>
<span class="line-modified">!   macro(_modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \</span>
<span class="line-modified">!   macro(_signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \</span>
<span class="line-modified">!   macro(_annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \</span>
<span class="line-modified">!   macro(_parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);</span>
  
  void java_lang_reflect_Constructor::compute_offsets() {
    InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
    CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3015,72 ***</span>
    ik-&gt;initialize(CHECK_NH);
    return ik-&gt;allocate_instance_handle(THREAD);
  }
  
  oop java_lang_reflect_Constructor::clazz(oop reflect) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return reflect-&gt;obj_field(clazz_offset);</span>
  }
  
  void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-    reflect-&gt;obj_field_put(clazz_offset, value);</span>
  }
  
  oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return constructor-&gt;obj_field(parameterTypes_offset);</span>
  }
  
  void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   constructor-&gt;obj_field_put(parameterTypes_offset, value);</span>
  }
  
  void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   constructor-&gt;obj_field_put(exceptionTypes_offset, value);</span>
  }
  
  int java_lang_reflect_Constructor::slot(oop reflect) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return reflect-&gt;int_field(slot_offset);</span>
  }
  
  void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   reflect-&gt;int_field_put(slot_offset, value);</span>
  }
  
  void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   constructor-&gt;int_field_put(modifiers_offset, value);</span>
  }
  
  void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   constructor-&gt;obj_field_put(signature_offset, value);</span>
  }
  
  void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   constructor-&gt;obj_field_put(annotations_offset, value);</span>
  }
  
  void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   method-&gt;obj_field_put(parameter_annotations_offset, value);</span>
  }
  
  #define FIELD_FIELDS_DO(macro) \
<span class="line-modified">!   macro(clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \</span>
<span class="line-modified">!   macro(name_offset,      k, vmSymbols::name_name(),      string_signature, false); \</span>
<span class="line-modified">!   macro(type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \</span>
<span class="line-modified">!   macro(slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \</span>
<span class="line-modified">!   macro(modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \</span>
<span class="line-modified">!   macro(signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \</span>
<span class="line-modified">!   macro(annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);</span>
  
  void java_lang_reflect_Field::compute_offsets() {
    InstanceKlass* k = SystemDictionary::reflect_Field_klass();
    FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
<span class="line-new-header">--- 3091,69 ---</span>
    ik-&gt;initialize(CHECK_NH);
    return ik-&gt;allocate_instance_handle(THREAD);
  }
  
  oop java_lang_reflect_Constructor::clazz(oop reflect) {
<span class="line-modified">!   return reflect-&gt;obj_field(_clazz_offset);</span>
  }
  
  void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
<span class="line-modified">!    reflect-&gt;obj_field_put(_clazz_offset, value);</span>
  }
  
  oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
<span class="line-modified">!   return constructor-&gt;obj_field(_parameterTypes_offset);</span>
  }
  
  void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
<span class="line-modified">!   constructor-&gt;obj_field_put(_parameterTypes_offset, value);</span>
  }
  
  void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
<span class="line-modified">!   constructor-&gt;obj_field_put(_exceptionTypes_offset, value);</span>
  }
  
  int java_lang_reflect_Constructor::slot(oop reflect) {
<span class="line-modified">!   return reflect-&gt;int_field(_slot_offset);</span>
  }
  
  void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
<span class="line-modified">!   reflect-&gt;int_field_put(_slot_offset, value);</span>
  }
  
  void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
<span class="line-modified">!   constructor-&gt;int_field_put(_modifiers_offset, value);</span>
  }
  
  void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
<span class="line-modified">!   constructor-&gt;obj_field_put(_signature_offset, value);</span>
  }
  
  void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
<span class="line-modified">!   constructor-&gt;obj_field_put(_annotations_offset, value);</span>
  }
  
  void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
<span class="line-modified">!   method-&gt;obj_field_put(_parameter_annotations_offset, value);</span>
  }
  
<span class="line-added">+ int java_lang_reflect_Field::_clazz_offset;</span>
<span class="line-added">+ int java_lang_reflect_Field::_name_offset;</span>
<span class="line-added">+ int java_lang_reflect_Field::_type_offset;</span>
<span class="line-added">+ int java_lang_reflect_Field::_slot_offset;</span>
<span class="line-added">+ int java_lang_reflect_Field::_modifiers_offset;</span>
<span class="line-added">+ int java_lang_reflect_Field::_signature_offset;</span>
<span class="line-added">+ int java_lang_reflect_Field::_annotations_offset;</span>
<span class="line-added">+ </span>
  #define FIELD_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \</span>
<span class="line-modified">!   macro(_name_offset,      k, vmSymbols::name_name(),      string_signature, false); \</span>
<span class="line-modified">!   macro(_type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \</span>
<span class="line-modified">!   macro(_slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \</span>
<span class="line-modified">!   macro(_modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \</span>
<span class="line-modified">!   macro(_signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \</span>
<span class="line-modified">!   macro(_annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);</span>
  
  void java_lang_reflect_Field::compute_offsets() {
    InstanceKlass* k = SystemDictionary::reflect_Field_klass();
    FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3100,67 ***</span>
    ik-&gt;initialize(CHECK_NH);
    return ik-&gt;allocate_instance_handle(THREAD);
  }
  
  oop java_lang_reflect_Field::clazz(oop reflect) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return reflect-&gt;obj_field(clazz_offset);</span>
  }
  
  void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-    reflect-&gt;obj_field_put(clazz_offset, value);</span>
  }
  
  oop java_lang_reflect_Field::name(oop field) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return field-&gt;obj_field(name_offset);</span>
  }
  
  void java_lang_reflect_Field::set_name(oop field, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   field-&gt;obj_field_put(name_offset, value);</span>
  }
  
  oop java_lang_reflect_Field::type(oop field) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return field-&gt;obj_field(type_offset);</span>
  }
  
  void java_lang_reflect_Field::set_type(oop field, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   field-&gt;obj_field_put(type_offset, value);</span>
  }
  
  int java_lang_reflect_Field::slot(oop reflect) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return reflect-&gt;int_field(slot_offset);</span>
  }
  
  void java_lang_reflect_Field::set_slot(oop reflect, int value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   reflect-&gt;int_field_put(slot_offset, value);</span>
  }
  
  int java_lang_reflect_Field::modifiers(oop field) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return field-&gt;int_field(modifiers_offset);</span>
  }
  
  void java_lang_reflect_Field::set_modifiers(oop field, int value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   field-&gt;int_field_put(modifiers_offset, value);</span>
  }
  
  void java_lang_reflect_Field::set_signature(oop field, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   field-&gt;obj_field_put(signature_offset, value);</span>
  }
  
  void java_lang_reflect_Field::set_annotations(oop field, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   field-&gt;obj_field_put(annotations_offset, value);</span>
  }
  
  oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {
    // Allocate java.lang.reflect.RecordComponent instance
    HandleMark hm(THREAD);
<span class="line-new-header">--- 3173,55 ---</span>
    ik-&gt;initialize(CHECK_NH);
    return ik-&gt;allocate_instance_handle(THREAD);
  }
  
  oop java_lang_reflect_Field::clazz(oop reflect) {
<span class="line-modified">!   return reflect-&gt;obj_field(_clazz_offset);</span>
  }
  
  void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
<span class="line-modified">!   reflect-&gt;obj_field_put(_clazz_offset, value);</span>
  }
  
  oop java_lang_reflect_Field::name(oop field) {
<span class="line-modified">!   return field-&gt;obj_field(_name_offset);</span>
  }
  
  void java_lang_reflect_Field::set_name(oop field, oop value) {
<span class="line-modified">!   field-&gt;obj_field_put(_name_offset, value);</span>
  }
  
  oop java_lang_reflect_Field::type(oop field) {
<span class="line-modified">!   return field-&gt;obj_field(_type_offset);</span>
  }
  
  void java_lang_reflect_Field::set_type(oop field, oop value) {
<span class="line-modified">!   field-&gt;obj_field_put(_type_offset, value);</span>
  }
  
  int java_lang_reflect_Field::slot(oop reflect) {
<span class="line-modified">!   return reflect-&gt;int_field(_slot_offset);</span>
  }
  
  void java_lang_reflect_Field::set_slot(oop reflect, int value) {
<span class="line-modified">!   reflect-&gt;int_field_put(_slot_offset, value);</span>
  }
  
  int java_lang_reflect_Field::modifiers(oop field) {
<span class="line-modified">!   return field-&gt;int_field(_modifiers_offset);</span>
  }
  
  void java_lang_reflect_Field::set_modifiers(oop field, int value) {
<span class="line-modified">!   field-&gt;int_field_put(_modifiers_offset, value);</span>
  }
  
  void java_lang_reflect_Field::set_signature(oop field, oop value) {
<span class="line-modified">!   field-&gt;obj_field_put(_signature_offset, value);</span>
  }
  
  void java_lang_reflect_Field::set_annotations(oop field, oop value) {
<span class="line-modified">!   field-&gt;obj_field_put(_annotations_offset, value);</span>
  }
  
  oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {
    // Allocate java.lang.reflect.RecordComponent instance
    HandleMark hm(THREAD);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3217,10 ***</span>
<span class="line-new-header">--- 3278,12 ---</span>
    java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);
  
    return element();
  }
  
<span class="line-added">+ int reflect_ConstantPool::_oop_offset;</span>
<span class="line-added">+ </span>
  #define CONSTANTPOOL_FIELDS_DO(macro) \
    macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
  
  void reflect_ConstantPool::compute_offsets() {
    InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3232,15 ***</span>
  void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
    CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  #define PARAMETER_FIELDS_DO(macro) \
<span class="line-modified">!   macro(name_offset,        k, vmSymbols::name_name(),        string_signature, false); \</span>
<span class="line-modified">!   macro(modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \</span>
<span class="line-modified">!   macro(index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \</span>
<span class="line-modified">!   macro(executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)</span>
  
  void java_lang_reflect_Parameter::compute_offsets() {
    InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
    PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
<span class="line-new-header">--- 3295,20 ---</span>
  void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
    CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
<span class="line-added">+ int java_lang_reflect_Parameter::_name_offset;</span>
<span class="line-added">+ int java_lang_reflect_Parameter::_modifiers_offset;</span>
<span class="line-added">+ int java_lang_reflect_Parameter::_index_offset;</span>
<span class="line-added">+ int java_lang_reflect_Parameter::_executable_offset;</span>
<span class="line-added">+ </span>
  #define PARAMETER_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_name_offset,        k, vmSymbols::name_name(),        string_signature, false); \</span>
<span class="line-modified">!   macro(_modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \</span>
<span class="line-modified">!   macro(_index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \</span>
<span class="line-modified">!   macro(_executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)</span>
  
  void java_lang_reflect_Parameter::compute_offsets() {
    InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
    PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3260,64 ***</span>
    ik-&gt;initialize(CHECK_NH);
    return ik-&gt;allocate_instance_handle(THREAD);
  }
  
  oop java_lang_reflect_Parameter::name(oop param) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return param-&gt;obj_field(name_offset);</span>
  }
  
  void java_lang_reflect_Parameter::set_name(oop param, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   param-&gt;obj_field_put(name_offset, value);</span>
  }
  
  int java_lang_reflect_Parameter::modifiers(oop param) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return param-&gt;int_field(modifiers_offset);</span>
  }
  
  void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   param-&gt;int_field_put(modifiers_offset, value);</span>
  }
  
  int java_lang_reflect_Parameter::index(oop param) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return param-&gt;int_field(index_offset);</span>
  }
  
  void java_lang_reflect_Parameter::set_index(oop param, int value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   param-&gt;int_field_put(index_offset, value);</span>
  }
  
  oop java_lang_reflect_Parameter::executable(oop param) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return param-&gt;obj_field(executable_offset);</span>
  }
  
  void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   param-&gt;obj_field_put(executable_offset, value);</span>
  }
  
  
<span class="line-modified">! int java_lang_Module::loader_offset;</span>
<span class="line-modified">! int java_lang_Module::name_offset;</span>
<span class="line-modified">! int java_lang_Module::_module_entry_offset = -1;</span>
  
  Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
    assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
    return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
                            vmSymbols::java_lang_module_init_signature(),
                            loader, module_name, CHECK_NH);
  }
  
  #define MODULE_FIELDS_DO(macro) \
<span class="line-modified">!   macro(loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \</span>
<span class="line-modified">!   macro(name_offset,    k, vmSymbols::name_name(),    string_signature,      false)</span>
  
  void java_lang_Module::compute_offsets() {
    InstanceKlass* k = SystemDictionary::Module_klass();
    MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
    MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
<span class="line-new-header">--- 3328,57 ---</span>
    ik-&gt;initialize(CHECK_NH);
    return ik-&gt;allocate_instance_handle(THREAD);
  }
  
  oop java_lang_reflect_Parameter::name(oop param) {
<span class="line-modified">!   return param-&gt;obj_field(_name_offset);</span>
  }
  
  void java_lang_reflect_Parameter::set_name(oop param, oop value) {
<span class="line-modified">!   param-&gt;obj_field_put(_name_offset, value);</span>
  }
  
  int java_lang_reflect_Parameter::modifiers(oop param) {
<span class="line-modified">!   return param-&gt;int_field(_modifiers_offset);</span>
  }
  
  void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
<span class="line-modified">!   param-&gt;int_field_put(_modifiers_offset, value);</span>
  }
  
  int java_lang_reflect_Parameter::index(oop param) {
<span class="line-modified">!   return param-&gt;int_field(_index_offset);</span>
  }
  
  void java_lang_reflect_Parameter::set_index(oop param, int value) {
<span class="line-modified">!   param-&gt;int_field_put(_index_offset, value);</span>
  }
  
  oop java_lang_reflect_Parameter::executable(oop param) {
<span class="line-modified">!   return param-&gt;obj_field(_executable_offset);</span>
  }
  
  void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
<span class="line-modified">!   param-&gt;obj_field_put(_executable_offset, value);</span>
  }
  
<span class="line-added">+ // java_lang_Module</span>
  
<span class="line-modified">! int java_lang_Module::_loader_offset;</span>
<span class="line-modified">! int java_lang_Module::_name_offset;</span>
<span class="line-modified">! int java_lang_Module::_module_entry_offset;</span>
  
  Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
    assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
    return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
                            vmSymbols::java_lang_module_init_signature(),
                            loader, module_name, CHECK_NH);
  }
  
  #define MODULE_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \</span>
<span class="line-modified">!   macro(_name_offset,    k, vmSymbols::name_name(),    string_signature,      false)</span>
  
  void java_lang_Module::compute_offsets() {
    InstanceKlass* k = SystemDictionary::Module_klass();
    MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
    MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3329,31 ***</span>
    MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  oop java_lang_Module::loader(oop module) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return module-&gt;obj_field(loader_offset);</span>
  }
  
  void java_lang_Module::set_loader(oop module, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   module-&gt;obj_field_put(loader_offset, value);</span>
  }
  
  oop java_lang_Module::name(oop module) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   return module-&gt;obj_field(name_offset);</span>
  }
  
  void java_lang_Module::set_name(oop module, oop value) {
<span class="line-modified">!   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">-   module-&gt;obj_field_put(name_offset, value);</span>
  }
  
  ModuleEntry* java_lang_Module::module_entry(oop module) {
<span class="line-modified">!   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);</span>
    assert(module != NULL, &quot;module can&#39;t be null&quot;);
    assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
  
    ModuleEntry* module_entry = (ModuleEntry*)module-&gt;address_field(_module_entry_offset);
    if (module_entry == NULL) {
<span class="line-new-header">--- 3390,27 ---</span>
    MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  oop java_lang_Module::loader(oop module) {
<span class="line-modified">!   return module-&gt;obj_field(_loader_offset);</span>
  }
  
  void java_lang_Module::set_loader(oop module, oop value) {
<span class="line-modified">!   module-&gt;obj_field_put(_loader_offset, value);</span>
  }
  
  oop java_lang_Module::name(oop module) {
<span class="line-modified">!   return module-&gt;obj_field(_name_offset);</span>
  }
  
  void java_lang_Module::set_name(oop module, oop value) {
<span class="line-modified">!   module-&gt;obj_field_put(_name_offset, value);</span>
  }
  
  ModuleEntry* java_lang_Module::module_entry(oop module) {
<span class="line-modified">!   assert(_module_entry_offset != 0, &quot;Uninitialized module_entry_offset&quot;);</span>
    assert(module != NULL, &quot;module can&#39;t be null&quot;);
    assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
  
    ModuleEntry* module_entry = (ModuleEntry*)module-&gt;address_field(_module_entry_offset);
    if (module_entry == NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3366,11 ***</span>
    }
    return module_entry;
  }
  
  void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
<span class="line-modified">!   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);</span>
    assert(module != NULL, &quot;module can&#39;t be null&quot;);
    assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
    module-&gt;address_field_put(_module_entry_offset, (address)module_entry);
  }
  
<span class="line-new-header">--- 3423,11 ---</span>
    }
    return module_entry;
  }
  
  void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
<span class="line-modified">!   assert(_module_entry_offset != 0, &quot;Uninitialized module_entry_offset&quot;);</span>
    assert(module != NULL, &quot;module can&#39;t be null&quot;);
    assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
    module-&gt;address_field_put(_module_entry_offset, (address)module_entry);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3382,18 ***</span>
    return k-&gt;allocate_instance_handle(THREAD);
  }
  
  
  void reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {
<span class="line-removed">-   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
    oop mirror = value-&gt;pool_holder()-&gt;java_mirror();
    // Save the mirror to get back the constant pool.
    reflect-&gt;obj_field_put(_oop_offset, mirror);
  }
  
  ConstantPool* reflect_ConstantPool::get_cp(oop reflect) {
<span class="line-removed">-   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
  
    oop mirror = reflect-&gt;obj_field(_oop_offset);
    Klass* k = java_lang_Class::as_Klass(mirror);
    assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
  
<span class="line-new-header">--- 3439,16 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3403,10 ***</span>
<span class="line-new-header">--- 3458,12 ---</span>
    // no longer done in the future, this will have to change to save
    // the original.
    return InstanceKlass::cast(k)-&gt;constants();
  }
  
<span class="line-added">+ int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;</span>
<span class="line-added">+ </span>
  #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
    macro(_base_offset, k, &quot;base&quot;, object_signature, false)
  
  void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
    InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3417,10 ***</span>
<span class="line-new-header">--- 3474,77 ---</span>
  void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
    UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
<span class="line-added">+ // Support for java_lang_ref_Reference</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool java_lang_ref_Reference::_offsets_initialized;</span>
<span class="line-added">+ </span>
<span class="line-added">+ int java_lang_ref_Reference::_referent_offset;</span>
<span class="line-added">+ int java_lang_ref_Reference::_queue_offset;</span>
<span class="line-added">+ int java_lang_ref_Reference::_next_offset;</span>
<span class="line-added">+ int java_lang_ref_Reference::_discovered_offset;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define REFERENCE_FIELDS_DO(macro) \</span>
<span class="line-added">+   macro(_referent_offset,   k, &quot;referent&quot;, object_signature, false); \</span>
<span class="line-added">+   macro(_queue_offset,      k, &quot;queue&quot;, referencequeue_signature, false); \</span>
<span class="line-added">+   macro(_next_offset,       k, &quot;next&quot;, reference_signature, false); \</span>
<span class="line-added">+   macro(_discovered_offset, k, &quot;discovered&quot;, reference_signature, false);</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_ref_Reference::compute_offsets() {</span>
<span class="line-added">+   if (_offsets_initialized) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   _offsets_initialized = true;</span>
<span class="line-added">+   InstanceKlass* k = SystemDictionary::Reference_klass();</span>
<span class="line-added">+   REFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_CDS</span>
<span class="line-added">+ void java_lang_ref_Reference::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">+   f-&gt;do_bool(&amp;_offsets_initialized);</span>
<span class="line-added">+   REFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {</span>
<span class="line-added">+   assert(obj != NULL, &quot;sanity&quot;);</span>
<span class="line-added">+   if (offset != _referent_offset) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   Klass* k = obj-&gt;klass();</span>
<span class="line-added">+   if (!k-&gt;is_instance_klass()) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());</span>
<span class="line-added">+   bool is_reference = ik-&gt;reference_type() != REF_NONE;</span>
<span class="line-added">+   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);</span>
<span class="line-added">+   return is_reference;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int java_lang_boxing_object::_value_offset;</span>
<span class="line-added">+ int java_lang_boxing_object::_long_value_offset;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define BOXING_FIELDS_DO(macro) \</span>
<span class="line-added">+   macro(_value_offset,      integerKlass, &quot;value&quot;, int_signature, false); \</span>
<span class="line-added">+   macro(_long_value_offset, longKlass, &quot;value&quot;, long_signature, false);</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_boxing_object::compute_offsets() {</span>
<span class="line-added">+   InstanceKlass* integerKlass = SystemDictionary::Integer_klass();</span>
<span class="line-added">+   InstanceKlass* longKlass = SystemDictionary::Long_klass();</span>
<span class="line-added">+   BOXING_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_CDS</span>
<span class="line-added">+ void java_lang_boxing_object::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">+   BOXING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
    Klass* k = SystemDictionary::box_klass(type);
    if (k == NULL)  return NULL;
    InstanceKlass* ik = InstanceKlass::cast(k);
    if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3431,32 ***</span>
  oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
    oop box = initialize_and_allocate(type, CHECK_NULL);
    if (box == NULL)  return NULL;
    switch (type) {
      case T_BOOLEAN:
<span class="line-modified">!       box-&gt;bool_field_put(value_offset, value-&gt;z);</span>
        break;
      case T_CHAR:
<span class="line-modified">!       box-&gt;char_field_put(value_offset, value-&gt;c);</span>
        break;
      case T_FLOAT:
<span class="line-modified">!       box-&gt;float_field_put(value_offset, value-&gt;f);</span>
        break;
      case T_DOUBLE:
<span class="line-modified">!       box-&gt;double_field_put(long_value_offset, value-&gt;d);</span>
        break;
      case T_BYTE:
<span class="line-modified">!       box-&gt;byte_field_put(value_offset, value-&gt;b);</span>
        break;
      case T_SHORT:
<span class="line-modified">!       box-&gt;short_field_put(value_offset, value-&gt;s);</span>
        break;
      case T_INT:
<span class="line-modified">!       box-&gt;int_field_put(value_offset, value-&gt;i);</span>
        break;
      case T_LONG:
<span class="line-modified">!       box-&gt;long_field_put(long_value_offset, value-&gt;j);</span>
        break;
      default:
        return NULL;
    }
    return box;
<span class="line-new-header">--- 3555,32 ---</span>
  oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
    oop box = initialize_and_allocate(type, CHECK_NULL);
    if (box == NULL)  return NULL;
    switch (type) {
      case T_BOOLEAN:
<span class="line-modified">!       box-&gt;bool_field_put(_value_offset, value-&gt;z);</span>
        break;
      case T_CHAR:
<span class="line-modified">!       box-&gt;char_field_put(_value_offset, value-&gt;c);</span>
        break;
      case T_FLOAT:
<span class="line-modified">!       box-&gt;float_field_put(_value_offset, value-&gt;f);</span>
        break;
      case T_DOUBLE:
<span class="line-modified">!       box-&gt;double_field_put(_long_value_offset, value-&gt;d);</span>
        break;
      case T_BYTE:
<span class="line-modified">!       box-&gt;byte_field_put(_value_offset, value-&gt;b);</span>
        break;
      case T_SHORT:
<span class="line-modified">!       box-&gt;short_field_put(_value_offset, value-&gt;s);</span>
        break;
      case T_INT:
<span class="line-modified">!       box-&gt;int_field_put(_value_offset, value-&gt;i);</span>
        break;
      case T_LONG:
<span class="line-modified">!       box-&gt;long_field_put(_long_value_offset, value-&gt;j);</span>
        break;
      default:
        return NULL;
    }
    return box;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3474,32 ***</span>
  
  BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
    BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
    switch (type) {
    case T_BOOLEAN:
<span class="line-modified">!     value-&gt;z = box-&gt;bool_field(value_offset);</span>
      break;
    case T_CHAR:
<span class="line-modified">!     value-&gt;c = box-&gt;char_field(value_offset);</span>
      break;
    case T_FLOAT:
<span class="line-modified">!     value-&gt;f = box-&gt;float_field(value_offset);</span>
      break;
    case T_DOUBLE:
<span class="line-modified">!     value-&gt;d = box-&gt;double_field(long_value_offset);</span>
      break;
    case T_BYTE:
<span class="line-modified">!     value-&gt;b = box-&gt;byte_field(value_offset);</span>
      break;
    case T_SHORT:
<span class="line-modified">!     value-&gt;s = box-&gt;short_field(value_offset);</span>
      break;
    case T_INT:
<span class="line-modified">!     value-&gt;i = box-&gt;int_field(value_offset);</span>
      break;
    case T_LONG:
<span class="line-modified">!     value-&gt;j = box-&gt;long_field(long_value_offset);</span>
      break;
    default:
      return T_ILLEGAL;
    } // end switch
    return type;
<span class="line-new-header">--- 3598,32 ---</span>
  
  BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
    BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
    switch (type) {
    case T_BOOLEAN:
<span class="line-modified">!     value-&gt;z = box-&gt;bool_field(_value_offset);</span>
      break;
    case T_CHAR:
<span class="line-modified">!     value-&gt;c = box-&gt;char_field(_value_offset);</span>
      break;
    case T_FLOAT:
<span class="line-modified">!     value-&gt;f = box-&gt;float_field(_value_offset);</span>
      break;
    case T_DOUBLE:
<span class="line-modified">!     value-&gt;d = box-&gt;double_field(_long_value_offset);</span>
      break;
    case T_BYTE:
<span class="line-modified">!     value-&gt;b = box-&gt;byte_field(_value_offset);</span>
      break;
    case T_SHORT:
<span class="line-modified">!     value-&gt;s = box-&gt;short_field(_value_offset);</span>
      break;
    case T_INT:
<span class="line-modified">!     value-&gt;i = box-&gt;int_field(_value_offset);</span>
      break;
    case T_LONG:
<span class="line-modified">!     value-&gt;j = box-&gt;long_field(_long_value_offset);</span>
      break;
    default:
      return T_ILLEGAL;
    } // end switch
    return type;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3508,32 ***</span>
  
  BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
    BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
    switch (type) {
    case T_BOOLEAN:
<span class="line-modified">!     box-&gt;bool_field_put(value_offset, value-&gt;z);</span>
      break;
    case T_CHAR:
<span class="line-modified">!     box-&gt;char_field_put(value_offset, value-&gt;c);</span>
      break;
    case T_FLOAT:
<span class="line-modified">!     box-&gt;float_field_put(value_offset, value-&gt;f);</span>
      break;
    case T_DOUBLE:
<span class="line-modified">!     box-&gt;double_field_put(long_value_offset, value-&gt;d);</span>
      break;
    case T_BYTE:
<span class="line-modified">!     box-&gt;byte_field_put(value_offset, value-&gt;b);</span>
      break;
    case T_SHORT:
<span class="line-modified">!     box-&gt;short_field_put(value_offset, value-&gt;s);</span>
      break;
    case T_INT:
<span class="line-modified">!     box-&gt;int_field_put(value_offset, value-&gt;i);</span>
      break;
    case T_LONG:
<span class="line-modified">!     box-&gt;long_field_put(long_value_offset, value-&gt;j);</span>
      break;
    default:
      return T_ILLEGAL;
    } // end switch
    return type;
<span class="line-new-header">--- 3632,32 ---</span>
  
  BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
    BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
    switch (type) {
    case T_BOOLEAN:
<span class="line-modified">!     box-&gt;bool_field_put(_value_offset, value-&gt;z);</span>
      break;
    case T_CHAR:
<span class="line-modified">!     box-&gt;char_field_put(_value_offset, value-&gt;c);</span>
      break;
    case T_FLOAT:
<span class="line-modified">!     box-&gt;float_field_put(_value_offset, value-&gt;f);</span>
      break;
    case T_DOUBLE:
<span class="line-modified">!     box-&gt;double_field_put(_long_value_offset, value-&gt;d);</span>
      break;
    case T_BYTE:
<span class="line-modified">!     box-&gt;byte_field_put(_value_offset, value-&gt;b);</span>
      break;
    case T_SHORT:
<span class="line-modified">!     box-&gt;short_field_put(_value_offset, value-&gt;s);</span>
      break;
    case T_INT:
<span class="line-modified">!     box-&gt;int_field_put(_value_offset, value-&gt;i);</span>
      break;
    case T_LONG:
<span class="line-modified">!     box-&gt;long_field_put(_long_value_offset, value-&gt;j);</span>
      break;
    default:
      return T_ILLEGAL;
    } // end switch
    return type;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3552,73 ***</span>
    case T_DOUBLE:    st-&gt;print(&quot;%lf&quot;, value-&gt;d);                     break;
    default:          st-&gt;print(&quot;type %d?&quot;, type);                    break;
    }
  }
  
<span class="line-removed">- // Support for java_lang_ref_Reference</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {</span>
<span class="line-removed">-   assert(obj != NULL, &quot;sanity&quot;);</span>
<span class="line-removed">-   if (offset != java_lang_ref_Reference::referent_offset) {</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Klass* k = obj-&gt;klass();</span>
<span class="line-removed">-   if (!k-&gt;is_instance_klass()) {</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());</span>
<span class="line-removed">-   bool is_reference = ik-&gt;reference_type() != REF_NONE;</span>
<span class="line-removed">-   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);</span>
<span class="line-removed">-   return is_reference;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #define REFERENCE_FIELDS_DO(macro) \</span>
<span class="line-removed">-   macro(referent_offset,   k, &quot;referent&quot;, object_signature, false); \</span>
<span class="line-removed">-   macro(queue_offset,      k, &quot;queue&quot;, referencequeue_signature, false); \</span>
<span class="line-removed">-   macro(next_offset,       k, &quot;next&quot;, reference_signature, false); \</span>
<span class="line-removed">-   macro(discovered_offset, k, &quot;discovered&quot;, reference_signature, false);</span>
<span class="line-removed">- </span>
<span class="line-removed">- void java_lang_ref_Reference::compute_offsets() {</span>
<span class="line-removed">-   if (_offsets_initialized) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   _offsets_initialized = true;</span>
<span class="line-removed">-   InstanceKlass* k = SystemDictionary::Reference_klass();</span>
<span class="line-removed">-   REFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if INCLUDE_CDS</span>
<span class="line-removed">- void java_lang_ref_Reference::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-removed">-   f-&gt;do_bool(&amp;_offsets_initialized);</span>
<span class="line-removed">-   REFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- #define BOXING_FIELDS_DO(macro) \</span>
<span class="line-removed">-   macro(value_offset,      integerKlass, &quot;value&quot;, int_signature, false); \</span>
<span class="line-removed">-   macro(long_value_offset, longKlass, &quot;value&quot;, long_signature, false);</span>
<span class="line-removed">- </span>
<span class="line-removed">- void java_lang_boxing_object::compute_offsets() {</span>
<span class="line-removed">-   InstanceKlass* integerKlass = SystemDictionary::Integer_klass();</span>
<span class="line-removed">-   InstanceKlass* longKlass = SystemDictionary::Long_klass();</span>
<span class="line-removed">-   BOXING_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if INCLUDE_CDS</span>
<span class="line-removed">- void java_lang_boxing_object::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-removed">-   BOXING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
  
  // Support for java_lang_ref_SoftReference
  //
  
  #define SOFTREFERENCE_FIELDS_DO(macro) \
<span class="line-modified">!   macro(timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \</span>
<span class="line-modified">!   macro(static_clock_offset, k, &quot;clock&quot;,     long_signature, true)</span>
  
  void java_lang_ref_SoftReference::compute_offsets() {
    InstanceKlass* k = SystemDictionary::SoftReference_klass();
    SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
<span class="line-new-header">--- 3676,20 ---</span>
    case T_DOUBLE:    st-&gt;print(&quot;%lf&quot;, value-&gt;d);                     break;
    default:          st-&gt;print(&quot;type %d?&quot;, type);                    break;
    }
  }
  
  
  // Support for java_lang_ref_SoftReference
  //
  
<span class="line-added">+ int java_lang_ref_SoftReference::_timestamp_offset;</span>
<span class="line-added">+ int java_lang_ref_SoftReference::_static_clock_offset;</span>
<span class="line-added">+ </span>
  #define SOFTREFERENCE_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \</span>
<span class="line-modified">!   macro(_static_clock_offset, k, &quot;clock&quot;,     long_signature, true)</span>
  
  void java_lang_ref_SoftReference::compute_offsets() {
    InstanceKlass* k = SystemDictionary::SoftReference_klass();
    SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3628,34 ***</span>
    SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  jlong java_lang_ref_SoftReference::timestamp(oop ref) {
<span class="line-modified">!   return ref-&gt;long_field(timestamp_offset);</span>
  }
  
  jlong java_lang_ref_SoftReference::clock() {
    InstanceKlass* ik = SystemDictionary::SoftReference_klass();
    oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">!   return base-&gt;long_field(static_clock_offset);</span>
  }
  
  void java_lang_ref_SoftReference::set_clock(jlong value) {
    InstanceKlass* ik = SystemDictionary::SoftReference_klass();
    oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">!   base-&gt;long_field_put(static_clock_offset, value);</span>
  }
  
  // Support for java_lang_invoke_DirectMethodHandle
  
  int java_lang_invoke_DirectMethodHandle::_member_offset;
  
  oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
    oop member_name = NULL;
    assert(oopDesc::is_oop(dmh) &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh),
           &quot;a DirectMethodHandle oop is expected&quot;);
<span class="line-modified">!   return dmh-&gt;obj_field(member_offset_in_bytes());</span>
  }
  
  #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
    macro(_member_offset, k, &quot;member&quot;, java_lang_invoke_MemberName_signature, false)
  
<span class="line-new-header">--- 3699,34 ---</span>
    SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  jlong java_lang_ref_SoftReference::timestamp(oop ref) {
<span class="line-modified">!   return ref-&gt;long_field(_timestamp_offset);</span>
  }
  
  jlong java_lang_ref_SoftReference::clock() {
    InstanceKlass* ik = SystemDictionary::SoftReference_klass();
    oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">!   return base-&gt;long_field(_static_clock_offset);</span>
  }
  
  void java_lang_ref_SoftReference::set_clock(jlong value) {
    InstanceKlass* ik = SystemDictionary::SoftReference_klass();
    oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">!   base-&gt;long_field_put(_static_clock_offset, value);</span>
  }
  
  // Support for java_lang_invoke_DirectMethodHandle
  
  int java_lang_invoke_DirectMethodHandle::_member_offset;
  
  oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
    oop member_name = NULL;
    assert(oopDesc::is_oop(dmh) &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh),
           &quot;a DirectMethodHandle oop is expected&quot;);
<span class="line-modified">!   return dmh-&gt;obj_field(_member_offset);</span>
  }
  
  #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
    macro(_member_offset, k, &quot;member&quot;, java_lang_invoke_MemberName_signature, false)
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4069,14 ***</span>
    return dep_ctx;
  }
  
  // Support for java_security_AccessControlContext
  
<span class="line-modified">! int java_security_AccessControlContext::_context_offset = 0;</span>
<span class="line-modified">! int java_security_AccessControlContext::_privilegedContext_offset = 0;</span>
<span class="line-modified">! int java_security_AccessControlContext::_isPrivileged_offset = 0;</span>
<span class="line-modified">! int java_security_AccessControlContext::_isAuthorized_offset = -1;</span>
  
  #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
    macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
    macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
    macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
<span class="line-new-header">--- 4140,14 ---</span>
    return dep_ctx;
  }
  
  // Support for java_security_AccessControlContext
  
<span class="line-modified">! int java_security_AccessControlContext::_context_offset;</span>
<span class="line-modified">! int java_security_AccessControlContext::_privilegedContext_offset;</span>
<span class="line-modified">! int java_security_AccessControlContext::_isPrivileged_offset;</span>
<span class="line-modified">! int java_security_AccessControlContext::_isAuthorized_offset;</span>
  
  #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
    macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
    macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
    macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4094,11 ***</span>
  }
  #endif
  
  oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
    assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
<span class="line-modified">!   assert(_isAuthorized_offset != -1, &quot;offsets should have been initialized&quot;);</span>
    // Ensure klass is initialized
    SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);
    // Allocate result
    oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);
    // Fill in values
<span class="line-new-header">--- 4165,11 ---</span>
  }
  #endif
  
  oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
    assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
<span class="line-modified">!   assert(_isAuthorized_offset != 0, &quot;offsets should have been initialized&quot;);</span>
    // Ensure klass is initialized
    SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);
    // Allocate result
    oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);
    // Fill in values
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4111,16 ***</span>
  }
  
  
  // Support for java_lang_ClassLoader
  
<span class="line-modified">! bool java_lang_ClassLoader::offsets_computed = false;</span>
<span class="line-modified">! int  java_lang_ClassLoader::_loader_data_offset = -1;</span>
<span class="line-modified">! int  java_lang_ClassLoader::parallelCapable_offset = -1;</span>
<span class="line-modified">! int  java_lang_ClassLoader::name_offset = -1;</span>
<span class="line-modified">! int  java_lang_ClassLoader::nameAndId_offset = -1;</span>
<span class="line-modified">! int  java_lang_ClassLoader::unnamedModule_offset = -1;</span>
  
  ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
    assert(loader != NULL, &quot;loader must not be NULL&quot;);
    assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
    return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
<span class="line-new-header">--- 4182,16 ---</span>
  }
  
  
  // Support for java_lang_ClassLoader
  
<span class="line-modified">! int  java_lang_ClassLoader::_loader_data_offset;</span>
<span class="line-modified">! int  java_lang_ClassLoader::_parallelCapable_offset;</span>
<span class="line-modified">! int  java_lang_ClassLoader::_name_offset;</span>
<span class="line-modified">! int  java_lang_ClassLoader::_nameAndId_offset;</span>
<span class="line-modified">! int  java_lang_ClassLoader::_unnamedModule_offset;</span>
<span class="line-modified">! int  java_lang_ClassLoader::_parent_offset;</span>
  
  ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
    assert(loader != NULL, &quot;loader must not be NULL&quot;);
    assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
    return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4137,20 ***</span>
    assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
    HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
  }
  
  #define CLASSLOADER_FIELDS_DO(macro) \
<span class="line-modified">!   macro(parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \</span>
<span class="line-modified">!   macro(name_offset,            k1, vmSymbols::name_name(), string_signature, false); \</span>
<span class="line-modified">!   macro(nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \</span>
<span class="line-modified">!   macro(unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \</span>
<span class="line-modified">!   macro(parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)</span>
  
  void java_lang_ClassLoader::compute_offsets() {
<span class="line-removed">-   assert(!offsets_computed, &quot;offsets should be initialized only once&quot;);</span>
<span class="line-removed">-   offsets_computed = true;</span>
<span class="line-removed">- </span>
    InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
    CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  
    CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
  }
<span class="line-new-header">--- 4208,17 ---</span>
    assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
    HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
  }
  
  #define CLASSLOADER_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \</span>
<span class="line-modified">!   macro(_name_offset,            k1, vmSymbols::name_name(), string_signature, false); \</span>
<span class="line-modified">!   macro(_nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \</span>
<span class="line-modified">!   macro(_unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \</span>
<span class="line-modified">!   macro(_parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)</span>
  
  void java_lang_ClassLoader::compute_offsets() {
    InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
    CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  
    CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4162,29 ***</span>
  }
  #endif
  
  oop java_lang_ClassLoader::parent(oop loader) {
    assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">!   return loader-&gt;obj_field(parent_offset);</span>
  }
  
  // Returns the name field of this class loader.  If the name field has not
  // been set, null will be returned.
  oop java_lang_ClassLoader::name(oop loader) {
    assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">!   return loader-&gt;obj_field(name_offset);</span>
  }
  
  // Returns the nameAndId field of this class loader. The format is
  // as follows:
  //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
  //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
  //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
  // Use ClassLoader::loader_name_id() to obtain this String as a char*.
  oop java_lang_ClassLoader::nameAndId(oop loader) {
    assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">!   return loader-&gt;obj_field(nameAndId_offset);</span>
  }
  
  bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
    assert(is_instance(loader), &quot;loader must be oop&quot;);
    assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
<span class="line-new-header">--- 4230,29 ---</span>
  }
  #endif
  
  oop java_lang_ClassLoader::parent(oop loader) {
    assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">!   return loader-&gt;obj_field(_parent_offset);</span>
  }
  
  // Returns the name field of this class loader.  If the name field has not
  // been set, null will be returned.
  oop java_lang_ClassLoader::name(oop loader) {
    assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">!   return loader-&gt;obj_field(_name_offset);</span>
  }
  
  // Returns the nameAndId field of this class loader. The format is
  // as follows:
  //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
  //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
  //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
  // Use ClassLoader::loader_name_id() to obtain this String as a char*.
  oop java_lang_ClassLoader::nameAndId(oop loader) {
    assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">!   return loader-&gt;obj_field(_nameAndId_offset);</span>
  }
  
  bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
    assert(is_instance(loader), &quot;loader must be oop&quot;);
    assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4208,12 ***</span>
  
  // For class loader classes, parallelCapable defined
  // based on non-null field
  // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
  bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
<span class="line-modified">!   assert(parallelCapable_offset != -1, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">!   return (class_loader-&gt;obj_field(parallelCapable_offset) != NULL);</span>
  }
  
  bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
    // Fix for 4474172; see evaluation for more details
    loader = non_reflection_class_loader(loader);
<span class="line-new-header">--- 4276,12 ---</span>
  
  // For class loader classes, parallelCapable defined
  // based on non-null field
  // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
  bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
<span class="line-modified">!   assert(_parallelCapable_offset != 0, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">!   return (class_loader-&gt;obj_field(_parallelCapable_offset) != NULL);</span>
  }
  
  bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
    // Fix for 4474172; see evaluation for more details
    loader = non_reflection_class_loader(loader);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4248,20 ***</span>
    return loader;
  }
  
  oop java_lang_ClassLoader::unnamedModule(oop loader) {
    assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">!   return loader-&gt;obj_field(unnamedModule_offset);</span>
  }
  
  // Support for java_lang_System
  //
  #define SYSTEM_FIELDS_DO(macro) \
<span class="line-modified">!   macro(static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \</span>
<span class="line-modified">!   macro(static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \</span>
<span class="line-modified">!   macro(static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \</span>
<span class="line-modified">!   macro(static_security_offset, k, &quot;security&quot;, security_manager_signature, true)</span>
  
  void java_lang_System::compute_offsets() {
    InstanceKlass* k = SystemDictionary::System_klass();
    SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
<span class="line-new-header">--- 4316,26 ---</span>
    return loader;
  }
  
  oop java_lang_ClassLoader::unnamedModule(oop loader) {
    assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">!   return loader-&gt;obj_field(_unnamedModule_offset);</span>
  }
  
  // Support for java_lang_System
  //
<span class="line-added">+ </span>
<span class="line-added">+ int java_lang_System::_static_in_offset;</span>
<span class="line-added">+ int java_lang_System::_static_out_offset;</span>
<span class="line-added">+ int java_lang_System::_static_err_offset;</span>
<span class="line-added">+ int java_lang_System::_static_security_offset;</span>
<span class="line-added">+ </span>
  #define SYSTEM_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \</span>
<span class="line-modified">!   macro(_static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \</span>
<span class="line-modified">!   macro(_static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \</span>
<span class="line-modified">!   macro(_static_security_offset, k, &quot;security&quot;, security_manager_signature, true)</span>
  
  void java_lang_System::compute_offsets() {
    InstanceKlass* k = SystemDictionary::System_klass();
    SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4270,14 ***</span>
  void java_lang_System::serialize_offsets(SerializeClosure* f) {
     SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
<span class="line-removed">- int java_lang_System::in_offset_in_bytes() { return static_in_offset; }</span>
<span class="line-removed">- int java_lang_System::out_offset_in_bytes() { return static_out_offset; }</span>
<span class="line-removed">- int java_lang_System::err_offset_in_bytes() { return static_err_offset; }</span>
<span class="line-removed">- </span>
  // Support for jdk_internal_misc_UnsafeConstants
  //
  class UnsafeConstantsFixup : public FieldClosure {
  private:
    int _address_size;
<span class="line-new-header">--- 4344,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4320,125 ***</span>
  void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
    UnsafeConstantsFixup fixup;
    SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
  }
  
<span class="line-removed">- int java_lang_Class::_klass_offset;</span>
<span class="line-removed">- int java_lang_Class::_array_klass_offset;</span>
<span class="line-removed">- int java_lang_Class::_oop_size_offset;</span>
<span class="line-removed">- int java_lang_Class::_static_oop_field_count_offset;</span>
<span class="line-removed">- int java_lang_Class::_class_loader_offset;</span>
<span class="line-removed">- int java_lang_Class::_module_offset;</span>
<span class="line-removed">- int java_lang_Class::_protection_domain_offset;</span>
<span class="line-removed">- int java_lang_Class::_component_mirror_offset;</span>
<span class="line-removed">- int java_lang_Class::_init_lock_offset;</span>
<span class="line-removed">- int java_lang_Class::_signers_offset;</span>
<span class="line-removed">- int java_lang_Class::_name_offset;</span>
<span class="line-removed">- int java_lang_Class::_source_file_offset;</span>
<span class="line-removed">- int java_lang_Class::_classData_offset;</span>
<span class="line-removed">- GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;</span>
<span class="line-removed">- GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;</span>
<span class="line-removed">- int java_lang_Throwable::backtrace_offset;</span>
<span class="line-removed">- int java_lang_Throwable::detailMessage_offset;</span>
<span class="line-removed">- int java_lang_Throwable::stackTrace_offset;</span>
<span class="line-removed">- int java_lang_Throwable::depth_offset;</span>
<span class="line-removed">- int java_lang_Throwable::static_unassigned_stacktrace_offset;</span>
<span class="line-removed">- int java_lang_reflect_AccessibleObject::override_offset;</span>
<span class="line-removed">- int java_lang_reflect_Method::clazz_offset;</span>
<span class="line-removed">- int java_lang_reflect_Method::name_offset;</span>
<span class="line-removed">- int java_lang_reflect_Method::returnType_offset;</span>
<span class="line-removed">- int java_lang_reflect_Method::parameterTypes_offset;</span>
<span class="line-removed">- int java_lang_reflect_Method::exceptionTypes_offset;</span>
<span class="line-removed">- int java_lang_reflect_Method::slot_offset;</span>
<span class="line-removed">- int java_lang_reflect_Method::modifiers_offset;</span>
<span class="line-removed">- int java_lang_reflect_Method::signature_offset;</span>
<span class="line-removed">- int java_lang_reflect_Method::annotations_offset;</span>
<span class="line-removed">- int java_lang_reflect_Method::parameter_annotations_offset;</span>
<span class="line-removed">- int java_lang_reflect_Method::annotation_default_offset;</span>
<span class="line-removed">- int java_lang_reflect_Constructor::clazz_offset;</span>
<span class="line-removed">- int java_lang_reflect_Constructor::parameterTypes_offset;</span>
<span class="line-removed">- int java_lang_reflect_Constructor::exceptionTypes_offset;</span>
<span class="line-removed">- int java_lang_reflect_Constructor::slot_offset;</span>
<span class="line-removed">- int java_lang_reflect_Constructor::modifiers_offset;</span>
<span class="line-removed">- int java_lang_reflect_Constructor::signature_offset;</span>
<span class="line-removed">- int java_lang_reflect_Constructor::annotations_offset;</span>
<span class="line-removed">- int java_lang_reflect_Constructor::parameter_annotations_offset;</span>
<span class="line-removed">- int java_lang_reflect_Field::clazz_offset;</span>
<span class="line-removed">- int java_lang_reflect_Field::name_offset;</span>
<span class="line-removed">- int java_lang_reflect_Field::type_offset;</span>
<span class="line-removed">- int java_lang_reflect_Field::slot_offset;</span>
<span class="line-removed">- int java_lang_reflect_Field::modifiers_offset;</span>
<span class="line-removed">- int java_lang_reflect_Field::signature_offset;</span>
<span class="line-removed">- int java_lang_reflect_Field::annotations_offset;</span>
<span class="line-removed">- int java_lang_reflect_Parameter::name_offset;</span>
<span class="line-removed">- int java_lang_reflect_Parameter::modifiers_offset;</span>
<span class="line-removed">- int java_lang_reflect_Parameter::index_offset;</span>
<span class="line-removed">- int java_lang_reflect_Parameter::executable_offset;</span>
<span class="line-removed">- int java_lang_boxing_object::value_offset;</span>
<span class="line-removed">- int java_lang_boxing_object::long_value_offset;</span>
<span class="line-removed">- bool java_lang_ref_Reference::_offsets_initialized;</span>
<span class="line-removed">- int java_lang_ref_Reference::referent_offset;</span>
<span class="line-removed">- int java_lang_ref_Reference::queue_offset;</span>
<span class="line-removed">- int java_lang_ref_Reference::next_offset;</span>
<span class="line-removed">- int java_lang_ref_Reference::discovered_offset;</span>
<span class="line-removed">- int java_lang_ref_SoftReference::timestamp_offset;</span>
<span class="line-removed">- int java_lang_ref_SoftReference::static_clock_offset;</span>
<span class="line-removed">- int java_lang_ClassLoader::parent_offset;</span>
<span class="line-removed">- int java_lang_System::static_in_offset;</span>
<span class="line-removed">- int java_lang_System::static_out_offset;</span>
<span class="line-removed">- int java_lang_System::static_err_offset;</span>
<span class="line-removed">- int java_lang_System::static_security_offset;</span>
<span class="line-removed">- int java_lang_StackTraceElement::methodName_offset;</span>
<span class="line-removed">- int java_lang_StackTraceElement::fileName_offset;</span>
<span class="line-removed">- int java_lang_StackTraceElement::lineNumber_offset;</span>
<span class="line-removed">- int java_lang_StackTraceElement::moduleName_offset;</span>
<span class="line-removed">- int java_lang_StackTraceElement::moduleVersion_offset;</span>
<span class="line-removed">- int java_lang_StackTraceElement::classLoaderName_offset;</span>
<span class="line-removed">- int java_lang_StackTraceElement::declaringClass_offset;</span>
<span class="line-removed">- int java_lang_StackTraceElement::declaringClassObject_offset;</span>
<span class="line-removed">- int java_lang_StackFrameInfo::_memberName_offset;</span>
<span class="line-removed">- int java_lang_StackFrameInfo::_bci_offset;</span>
<span class="line-removed">- int java_lang_StackFrameInfo::_version_offset;</span>
<span class="line-removed">- int java_lang_LiveStackFrameInfo::_monitors_offset;</span>
<span class="line-removed">- int java_lang_LiveStackFrameInfo::_locals_offset;</span>
<span class="line-removed">- int java_lang_LiveStackFrameInfo::_operands_offset;</span>
<span class="line-removed">- int java_lang_LiveStackFrameInfo::_mode_offset;</span>
<span class="line-removed">- int java_lang_AssertionStatusDirectives::classes_offset;</span>
<span class="line-removed">- int java_lang_AssertionStatusDirectives::classEnabled_offset;</span>
<span class="line-removed">- int java_lang_AssertionStatusDirectives::packages_offset;</span>
<span class="line-removed">- int java_lang_AssertionStatusDirectives::packageEnabled_offset;</span>
<span class="line-removed">- int java_lang_AssertionStatusDirectives::deflt_offset;</span>
<span class="line-removed">- int java_nio_Buffer::_limit_offset;</span>
<span class="line-removed">- int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;</span>
<span class="line-removed">- int reflect_ConstantPool::_oop_offset;</span>
<span class="line-removed">- int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;</span>
<span class="line-removed">- int java_lang_Integer_IntegerCache::_static_cache_offset;</span>
<span class="line-removed">- int java_lang_Long_LongCache::_static_cache_offset;</span>
<span class="line-removed">- int java_lang_Character_CharacterCache::_static_cache_offset;</span>
<span class="line-removed">- int java_lang_Short_ShortCache::_static_cache_offset;</span>
<span class="line-removed">- int java_lang_Byte_ByteCache::_static_cache_offset;</span>
<span class="line-removed">- int java_lang_Boolean::_static_TRUE_offset;</span>
<span class="line-removed">- int java_lang_Boolean::_static_FALSE_offset;</span>
<span class="line-removed">- int java_lang_reflect_RecordComponent::clazz_offset;</span>
<span class="line-removed">- int java_lang_reflect_RecordComponent::name_offset;</span>
<span class="line-removed">- int java_lang_reflect_RecordComponent::type_offset;</span>
<span class="line-removed">- int java_lang_reflect_RecordComponent::accessor_offset;</span>
<span class="line-removed">- int java_lang_reflect_RecordComponent::signature_offset;</span>
<span class="line-removed">- int java_lang_reflect_RecordComponent::annotations_offset;</span>
<span class="line-removed">- int java_lang_reflect_RecordComponent::typeAnnotations_offset;</span>
  
  
  
  #define STACKTRACEELEMENT_FIELDS_DO(macro) \
<span class="line-modified">!   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \</span>
<span class="line-modified">!   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \</span>
<span class="line-modified">!   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \</span>
<span class="line-modified">!   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \</span>
<span class="line-modified">!   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \</span>
<span class="line-modified">!   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \</span>
<span class="line-modified">!   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \</span>
<span class="line-modified">!   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)</span>
  
  // Support for java_lang_StackTraceElement
  void java_lang_StackTraceElement::compute_offsets() {
    InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
    STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
<span class="line-new-header">--- 4390,31 ---</span>
  void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
    UnsafeConstantsFixup fixup;
    SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
  }
  
  
<span class="line-added">+ // java_lang_StackTraceElement</span>
  
<span class="line-added">+ int java_lang_StackTraceElement::_methodName_offset;</span>
<span class="line-added">+ int java_lang_StackTraceElement::_fileName_offset;</span>
<span class="line-added">+ int java_lang_StackTraceElement::_lineNumber_offset;</span>
<span class="line-added">+ int java_lang_StackTraceElement::_moduleName_offset;</span>
<span class="line-added">+ int java_lang_StackTraceElement::_moduleVersion_offset;</span>
<span class="line-added">+ int java_lang_StackTraceElement::_classLoaderName_offset;</span>
<span class="line-added">+ int java_lang_StackTraceElement::_declaringClass_offset;</span>
<span class="line-added">+ int java_lang_StackTraceElement::_declaringClassObject_offset;</span>
  
  #define STACKTRACEELEMENT_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \</span>
<span class="line-modified">!   macro(_classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \</span>
<span class="line-modified">!   macro(_moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \</span>
<span class="line-modified">!   macro(_moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \</span>
<span class="line-modified">!   macro(_declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \</span>
<span class="line-modified">!   macro(_methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \</span>
<span class="line-modified">!   macro(_fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \</span>
<span class="line-modified">!   macro(_lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)</span>
  
  // Support for java_lang_StackTraceElement
  void java_lang_StackTraceElement::compute_offsets() {
    InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
    STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4449,73 ***</span>
    STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(fileName_offset, value);</span>
  }
  
  void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(declaringClass_offset, value);</span>
  }
  
  void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(methodName_offset, value);</span>
  }
  
  void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
<span class="line-modified">!   element-&gt;int_field_put(lineNumber_offset, value);</span>
  }
  
  void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(moduleName_offset, value);</span>
  }
  
  void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(moduleVersion_offset, value);</span>
  }
  
  void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(classLoaderName_offset, value);</span>
  }
  
  void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(declaringClassObject_offset, value);</span>
  }
  
<span class="line-removed">- void java_lang_StackFrameInfo::set_version(oop element, short value) {</span>
<span class="line-removed">-   element-&gt;short_field_put(_version_offset, value);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void java_lang_StackFrameInfo::set_bci(oop element, int value) {</span>
<span class="line-removed">-   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);</span>
<span class="line-removed">-   element-&gt;int_field_put(_bci_offset, value);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {</span>
<span class="line-removed">-   element-&gt;obj_field_put(_monitors_offset, value);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {</span>
<span class="line-removed">-   element-&gt;obj_field_put(_locals_offset, value);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {</span>
<span class="line-removed">-   element-&gt;obj_field_put(_operands_offset, value);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {</span>
<span class="line-modified">!   element-&gt;int_field_put(_mode_offset, value);</span>
<span class="line-modified">! }</span>
  
  // Support for java Assertions - java_lang_AssertionStatusDirectives.
  #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
<span class="line-modified">!   macro(classes_offset,        k, &quot;classes&quot;,        string_array_signature, false); \</span>
<span class="line-modified">!   macro(classEnabled_offset,   k, &quot;classEnabled&quot;,   bool_array_signature, false); \</span>
<span class="line-modified">!   macro(packages_offset,       k, &quot;packages&quot;,       string_array_signature, false); \</span>
<span class="line-modified">!   macro(packageEnabled_offset, k, &quot;packageEnabled&quot;, bool_array_signature,   false); \</span>
<span class="line-modified">!   macro(deflt_offset,          k, &quot;deflt&quot;,          bool_signature,         false)</span>
  
  void java_lang_AssertionStatusDirectives::compute_offsets() {
    InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
    ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
<span class="line-new-header">--- 4425,57 ---</span>
    STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(_fileName_offset, value);</span>
  }
  
  void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(_declaringClass_offset, value);</span>
  }
  
  void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(_methodName_offset, value);</span>
  }
  
  void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
<span class="line-modified">!   element-&gt;int_field_put(_lineNumber_offset, value);</span>
  }
  
  void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(_moduleName_offset, value);</span>
  }
  
  void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(_moduleVersion_offset, value);</span>
  }
  
  void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(_classLoaderName_offset, value);</span>
  }
  
  void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(_declaringClassObject_offset, value);</span>
  }
  
  
<span class="line-modified">! // java_lang_AssertionStatusDirectives</span>
  
<span class="line-modified">! int java_lang_AssertionStatusDirectives::_classes_offset;</span>
<span class="line-modified">! int java_lang_AssertionStatusDirectives::_classEnabled_offset;</span>
<span class="line-modified">! int java_lang_AssertionStatusDirectives::_packages_offset;</span>
<span class="line-added">+ int java_lang_AssertionStatusDirectives::_packageEnabled_offset;</span>
<span class="line-added">+ int java_lang_AssertionStatusDirectives::_deflt_offset;</span>
  
  // Support for java Assertions - java_lang_AssertionStatusDirectives.
  #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_classes_offset,        k, &quot;classes&quot;,        string_array_signature, false); \</span>
<span class="line-modified">!   macro(_classEnabled_offset,   k, &quot;classEnabled&quot;,   bool_array_signature, false); \</span>
<span class="line-modified">!   macro(_packages_offset,       k, &quot;packages&quot;,       string_array_signature, false); \</span>
<span class="line-modified">!   macro(_packageEnabled_offset, k, &quot;packageEnabled&quot;, bool_array_signature,   false); \</span>
<span class="line-modified">!   macro(_deflt_offset,          k, &quot;deflt&quot;,          bool_signature,         false)</span>
  
  void java_lang_AssertionStatusDirectives::compute_offsets() {
    InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
    ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4525,34 ***</span>
    ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
<span class="line-modified">!   o-&gt;obj_field_put(classes_offset, val);</span>
  }
  
  void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
<span class="line-modified">!   o-&gt;obj_field_put(classEnabled_offset, val);</span>
  }
  
  void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
<span class="line-modified">!   o-&gt;obj_field_put(packages_offset, val);</span>
  }
  
  void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
<span class="line-modified">!   o-&gt;obj_field_put(packageEnabled_offset, val);</span>
  }
  
  void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
<span class="line-modified">!   o-&gt;bool_field_put(deflt_offset, val);</span>
  }
  
  
  // Support for intrinsification of java.nio.Buffer.checkIndex
<span class="line-modified">! int java_nio_Buffer::limit_offset() {</span>
<span class="line-modified">!   return _limit_offset;</span>
<span class="line-removed">- }</span>
  
  #define BUFFER_FIELDS_DO(macro) \
    macro(_limit_offset, k, &quot;limit&quot;, int_signature, false)
  
  void java_nio_Buffer::compute_offsets() {
<span class="line-new-header">--- 4485,33 ---</span>
    ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
<span class="line-modified">!   o-&gt;obj_field_put(_classes_offset, val);</span>
  }
  
  void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
<span class="line-modified">!   o-&gt;obj_field_put(_classEnabled_offset, val);</span>
  }
  
  void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
<span class="line-modified">!   o-&gt;obj_field_put(_packages_offset, val);</span>
  }
  
  void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
<span class="line-modified">!   o-&gt;obj_field_put(_packageEnabled_offset, val);</span>
  }
  
  void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
<span class="line-modified">!   o-&gt;bool_field_put(_deflt_offset, val);</span>
  }
  
  
  // Support for intrinsification of java.nio.Buffer.checkIndex
<span class="line-modified">! </span>
<span class="line-modified">! int java_nio_Buffer::_limit_offset;</span>
  
  #define BUFFER_FIELDS_DO(macro) \
    macro(_limit_offset, k, &quot;limit&quot;, int_signature, false)
  
  void java_nio_Buffer::compute_offsets() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4565,10 ***</span>
<span class="line-new-header">--- 4524,12 ---</span>
  void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {
    BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
<span class="line-added">+ int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;</span>
<span class="line-added">+ </span>
  #define AOS_FIELDS_DO(macro) \
    macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
  
  void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
    InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4584,10 ***</span>
<span class="line-new-header">--- 4545,16 ---</span>
  void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
    AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
<span class="line-added">+ int java_lang_Integer_IntegerCache::_static_cache_offset;</span>
<span class="line-added">+ int java_lang_Long_LongCache::_static_cache_offset;</span>
<span class="line-added">+ int java_lang_Character_CharacterCache::_static_cache_offset;</span>
<span class="line-added">+ int java_lang_Short_ShortCache::_static_cache_offset;</span>
<span class="line-added">+ int java_lang_Byte_ByteCache::_static_cache_offset;</span>
<span class="line-added">+ </span>
  #define INTEGER_CACHE_FIELDS_DO(macro) \
    macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Integer_array_signature, true)
  
  void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {
    guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4733,10 ***</span>
<span class="line-new-header">--- 4700,14 ---</span>
  jbyte java_lang_Byte::value(oop obj) {
     jvalue v;
     java_lang_boxing_object::get_value(obj, &amp;v);
     return v.b;
  }
<span class="line-added">+ </span>
<span class="line-added">+ int java_lang_Boolean::_static_TRUE_offset;</span>
<span class="line-added">+ int java_lang_Boolean::_static_FALSE_offset;</span>
<span class="line-added">+ </span>
  #define BOOLEAN_FIELDS_DO(macro) \
    macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
    macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4770,18 ***</span>
     jvalue v;
     java_lang_boxing_object::get_value(obj, &amp;v);
     return v.z;
  }
  
  #define RECORDCOMPONENT_FIELDS_DO(macro) \
<span class="line-modified">!   macro(clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \</span>
<span class="line-modified">!   macro(name_offset,        k, &quot;name&quot;,        string_signature, false); \</span>
<span class="line-modified">!   macro(type_offset,        k, &quot;type&quot;,        class_signature,  false); \</span>
<span class="line-modified">!   macro(accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \</span>
<span class="line-modified">!   macro(signature_offset,   k, &quot;signature&quot;,   string_signature, false); \</span>
<span class="line-modified">!   macro(annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \</span>
<span class="line-modified">!   macro(typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);</span>
  
  // Support for java_lang_reflect_RecordComponent
  void java_lang_reflect_RecordComponent::compute_offsets() {
    InstanceKlass* k = SystemDictionary::RecordComponent_klass();
    RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
<span class="line-new-header">--- 4741,28 ---</span>
     jvalue v;
     java_lang_boxing_object::get_value(obj, &amp;v);
     return v.z;
  }
  
<span class="line-added">+ // java_lang_reflect_RecordComponent</span>
<span class="line-added">+ </span>
<span class="line-added">+ int java_lang_reflect_RecordComponent::_clazz_offset;</span>
<span class="line-added">+ int java_lang_reflect_RecordComponent::_name_offset;</span>
<span class="line-added">+ int java_lang_reflect_RecordComponent::_type_offset;</span>
<span class="line-added">+ int java_lang_reflect_RecordComponent::_accessor_offset;</span>
<span class="line-added">+ int java_lang_reflect_RecordComponent::_signature_offset;</span>
<span class="line-added">+ int java_lang_reflect_RecordComponent::_annotations_offset;</span>
<span class="line-added">+ int java_lang_reflect_RecordComponent::_typeAnnotations_offset;</span>
<span class="line-added">+ </span>
  #define RECORDCOMPONENT_FIELDS_DO(macro) \
<span class="line-modified">!   macro(_clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \</span>
<span class="line-modified">!   macro(_name_offset,        k, &quot;name&quot;,        string_signature, false); \</span>
<span class="line-modified">!   macro(_type_offset,        k, &quot;type&quot;,        class_signature,  false); \</span>
<span class="line-modified">!   macro(_accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \</span>
<span class="line-modified">!   macro(_signature_offset,   k, &quot;signature&quot;,   string_signature, false); \</span>
<span class="line-modified">!   macro(_annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \</span>
<span class="line-modified">!   macro(_typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);</span>
  
  // Support for java_lang_reflect_RecordComponent
  void java_lang_reflect_RecordComponent::compute_offsets() {
    InstanceKlass* k = SystemDictionary::RecordComponent_klass();
    RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4792,47 ***</span>
    RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(clazz_offset, value);</span>
  }
  
  void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(name_offset, value);</span>
  }
  
  void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(type_offset, value);</span>
  }
  
  void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(accessor_offset, value);</span>
  }
  
  void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(signature_offset, value);</span>
  }
  
  void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(annotations_offset, value);</span>
  }
  
  void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(typeAnnotations_offset, value);</span>
  }
  
  #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
  
<span class="line-modified">! // Compute non-hard-coded field offsets of all the classes in this file</span>
  void JavaClasses::compute_offsets() {
    if (UseSharedSpaces) {
      JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
                                                           JvmtiExport::has_early_class_hook_env()),
                        &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
      // None of the classes used by the rest of this function can be replaced by
<span class="line-modified">!     // JMVTI ClassFileLoadHook.</span>
      // We are safe to use the archived offsets, which have already been restored
      // by JavaClasses::serialize_offsets, without computing the offsets again.
      return;
    }
  
<span class="line-new-header">--- 4773,47 ---</span>
    RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(_clazz_offset, value);</span>
  }
  
  void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(_name_offset, value);</span>
  }
  
  void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(_type_offset, value);</span>
  }
  
  void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(_accessor_offset, value);</span>
  }
  
  void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(_signature_offset, value);</span>
  }
  
  void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(_annotations_offset, value);</span>
  }
  
  void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
<span class="line-modified">!   element-&gt;obj_field_put(_typeAnnotations_offset, value);</span>
  }
  
  #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
  
<span class="line-modified">! // Compute field offsets of all the classes in this file</span>
  void JavaClasses::compute_offsets() {
    if (UseSharedSpaces) {
      JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
                                                           JvmtiExport::has_early_class_hook_env()),
                        &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
      // None of the classes used by the rest of this function can be replaced by
<span class="line-modified">!     // JVMTI ClassFileLoadHook.</span>
      // We are safe to use the archived offsets, which have already been restored
      // by JavaClasses::serialize_offsets, without computing the offsets again.
      return;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4873,14 ***</span>
  }
  #endif
  
  #ifndef PRODUCT
  
<span class="line-modified">! // These functions exist to assert the validity of hard-coded field offsets to guard</span>
<span class="line-removed">- // against changes in the class files</span>
  
<span class="line-modified">! bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {</span>
    EXCEPTION_MARK;
    fieldDescriptor fd;
    TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);
    Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
    InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-new-header">--- 4854,14 ---</span>
  }
  #endif
  
  #ifndef PRODUCT
  
<span class="line-modified">! // These functions exist to assert the validity of de-serialized offsets in boxing object as a sanity check.</span>
  
<span class="line-modified">! bool JavaClasses::check_offset(const char *klass_name, int deserialized_offset, const char *field_name,</span>
<span class="line-added">+                                const char* field_sig) {</span>
    EXCEPTION_MARK;
    fieldDescriptor fd;
    TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);
    Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
    InstanceKlass* ik = InstanceKlass::cast(k);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4892,29 ***</span>
    }
    if (fd.is_static()) {
      tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
      return false;
    }
<span class="line-modified">!   if (fd.offset() == hardcoded_offset ) {</span>
      return true;
    } else {
<span class="line-modified">!     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is hardcoded as %d but should really be %d.&quot;,</span>
<span class="line-modified">!                   klass_name, field_name, hardcoded_offset, fd.offset());</span>
      return false;
    }
  }
  
<span class="line-removed">- // Check the hard-coded field offsets of all the classes in this file</span>
<span class="line-removed">- </span>
  void JavaClasses::check_offsets() {
    bool valid = true;
  
  #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
<span class="line-modified">!   valid &amp;= check_offset(klass_name, cpp_klass_name :: field_name ## _offset, #field_name, field_sig)</span>
  
  #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
<span class="line-modified">!   valid &amp;= check_offset(klass_name, cpp_klass_name :: long_ ## field_name ## _offset, #field_name, field_sig)</span>
  
    // Boxed primitive objects (java_lang_boxing_object)
  
    CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
    CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
<span class="line-new-header">--- 4873,27 ---</span>
    }
    if (fd.is_static()) {
      tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
      return false;
    }
<span class="line-modified">!   if (fd.offset() == deserialized_offset ) {</span>
      return true;
    } else {
<span class="line-modified">!     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is deserialized as %d but should really be %d.&quot;,</span>
<span class="line-modified">!                   klass_name, field_name, deserialized_offset, fd.offset());</span>
      return false;
    }
  }
  
  void JavaClasses::check_offsets() {
    bool valid = true;
  
  #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
<span class="line-modified">!   valid &amp;= check_offset(klass_name, cpp_klass_name :: _##field_name ## _offset, #field_name, field_sig)</span>
  
  #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
<span class="line-modified">!   valid &amp;= check_offset(klass_name, cpp_klass_name :: _##long_ ## field_name ## _offset, #field_name, field_sig)</span>
  
    // Boxed primitive objects (java_lang_boxing_object)
  
    CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
    CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4923,11 ***</span>
    CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
    CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
    CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
    CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
  
<span class="line-modified">!   if (!valid) vm_exit_during_initialization(&quot;Hard-coded field offset verification failed&quot;);</span>
  }
  
  #endif // PRODUCT
  
  int InjectedField::compute_offset() {
<span class="line-new-header">--- 4902,11 ---</span>
    CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
    CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
    CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
    CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
  
<span class="line-modified">!   if (!valid) vm_exit_during_initialization(&quot;Field offset verification failed&quot;);</span>
  }
  
  #endif // PRODUCT
  
  int InjectedField::compute_offset() {
</pre>
<center><a href="compactHashtable.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
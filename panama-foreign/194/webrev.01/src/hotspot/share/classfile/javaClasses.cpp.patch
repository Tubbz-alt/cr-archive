diff a/src/hotspot/share/classfile/javaClasses.cpp b/src/hotspot/share/classfile/javaClasses.cpp
--- a/src/hotspot/share/classfile/javaClasses.cpp
+++ b/src/hotspot/share/classfile/javaClasses.cpp
@@ -175,50 +175,54 @@
     vm_exit_during_initialization("Invalid layout of well-known class", ik->external_name());
   }
   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 }
 
-int java_lang_String::value_offset  = 0;
-int java_lang_String::hash_offset   = 0;
-int java_lang_String::hashIsZero_offset = 0;
-int java_lang_String::coder_offset  = 0;
-
-bool java_lang_String::initialized  = false;
-
-bool java_lang_String::is_instance(oop obj) {
-  return is_instance_inlined(obj);
-}
 
 #if INCLUDE_CDS
 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
   f->do_u4((u4*)&offset)
 #endif
 
 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 
+
+// java_lang_String
+
+int java_lang_String::_value_offset;
+int java_lang_String::_hash_offset;
+int java_lang_String::_hashIsZero_offset;
+int java_lang_String::_coder_offset;
+
+bool java_lang_String::_initialized;
+
+bool java_lang_String::is_instance(oop obj) {
+  return is_instance_inlined(obj);
+}
+
 #define STRING_FIELDS_DO(macro) \
-  macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \
-  macro(hash_offset,  k, "hash",                  int_signature,        false); \
-  macro(hashIsZero_offset, k, "hashIsZero",       bool_signature,       false); \
-  macro(coder_offset, k, "coder",                 byte_signature,       false);
+  macro(_value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \
+  macro(_hash_offset,  k, "hash",                  int_signature,        false); \
+  macro(_hashIsZero_offset, k, "hashIsZero",       bool_signature,       false); \
+  macro(_coder_offset, k, "coder",                 byte_signature,       false);
 
 void java_lang_String::compute_offsets() {
-  if (initialized) {
+  if (_initialized) {
     return;
   }
 
   InstanceKlass* k = SystemDictionary::String_klass();
   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 
-  initialized = true;
+  _initialized = true;
 }
 
 #if INCLUDE_CDS
 void java_lang_String::serialize_offsets(SerializeClosure* f) {
   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
-  f->do_bool(&initialized);
+  f->do_bool(&_initialized);
 }
 #endif
 
 class CompactStringsFixup : public FieldClosure {
 private:
@@ -241,11 +245,11 @@
   CompactStringsFixup fix(value);
   SystemDictionary::String_klass()->do_local_static_fields(&fix);
 }
 
 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
-  assert(initialized, "Must be initialized");
+  assert(_initialized, "Must be initialized");
   assert(CompactStrings || !is_latin1, "Must be UTF16 without CompactStrings");
 
   // Create the String object first, so there's a chance that the String
   // and the char array it points to end up in the same cache line.
   oop obj;
@@ -539,13 +543,13 @@
   // these fields. Necessary restrictions to allow this to be correct
   // without explicit memory fences or similar concurrency primitives is
   // that we can ever only write to one of these two fields for a given
   // String instance, and that the computation is idempotent and derived
   // from immutable state
-  assert(initialized && (hash_offset > 0) && (hashIsZero_offset > 0), "Must be initialized");
+  assert(_initialized && (_hash_offset > 0) && (_hashIsZero_offset > 0), "Must be initialized");
   if (java_lang_String::hash_is_set(java_string)) {
-    return java_string->int_field(hash_offset);
+    return java_string->int_field(_hash_offset);
   }
 
   typeArrayOop value = java_lang_String::value(java_string);
   int         length = java_lang_String::length(java_string, value);
   bool     is_latin1 = java_lang_String::is_latin1(java_string);
@@ -558,13 +562,13 @@
       hash = java_lang_String::hash_code(value->char_at_addr(0), length);
     }
   }
 
   if (hash != 0) {
-    java_string->int_field_put(hash_offset, hash);
+    java_string->int_field_put(_hash_offset, hash);
   } else {
-    java_string->bool_field_put(hashIsZero_offset, true);
+    java_string->bool_field_put(_hashIsZero_offset, true);
   }
   return hash;
 }
 
 char* java_lang_String::as_quoted_ascii(oop java_string) {
@@ -792,10 +796,30 @@
                            ((jchar) value->byte_at(index)) & 0xff );
   }
   st->print("\"");
 }
 
+// java_lang_Class
+
+int java_lang_Class::_klass_offset;
+int java_lang_Class::_array_klass_offset;
+int java_lang_Class::_oop_size_offset;
+int java_lang_Class::_static_oop_field_count_offset;
+int java_lang_Class::_class_loader_offset;
+int java_lang_Class::_module_offset;
+int java_lang_Class::_protection_domain_offset;
+int java_lang_Class::_component_mirror_offset;
+int java_lang_Class::_init_lock_offset;
+int java_lang_Class::_signers_offset;
+int java_lang_Class::_name_offset;
+int java_lang_Class::_source_file_offset;
+int java_lang_Class::_classData_offset;
+int java_lang_Class::_classRedefinedCount_offset;
+
+bool java_lang_Class::_offsets_computed = false;
+GrowableArray<Klass*>* java_lang_Class::_fixup_mirror_list = NULL;
+GrowableArray<Klass*>* java_lang_Class::_fixup_module_field_list = NULL;
 
 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
   assert(mirror.not_null() && fd->is_static(), "just checking");
   if (fd->has_initial_value()) {
     BasicType t = fd->field_type();
@@ -1616,27 +1640,24 @@
   assert(mirror != NULL && mirror->is_a(SystemDictionary::Class_klass()), "must be a Class");
   assert(java_lang_Class::is_primitive(mirror), "must be primitive");
   return mirror;
 }
 
-bool java_lang_Class::offsets_computed = false;
-int  java_lang_Class::classRedefinedCount_offset = -1;
-
 #define CLASS_FIELDS_DO(macro) \
-  macro(classRedefinedCount_offset, k, "classRedefinedCount", int_signature,         false); \
-  macro(_class_loader_offset,       k, "classLoader",         classloader_signature, false); \
-  macro(_component_mirror_offset,   k, "componentType",       class_signature,       false); \
-  macro(_module_offset,             k, "module",              module_signature,      false); \
-  macro(_name_offset,               k, "name",                string_signature,      false); \
-  macro(_classData_offset,          k, "classData",           object_signature,      false);
+  macro(_classRedefinedCount_offset, k, "classRedefinedCount", int_signature,         false); \
+  macro(_class_loader_offset,        k, "classLoader",         classloader_signature, false); \
+  macro(_component_mirror_offset,    k, "componentType",       class_signature,       false); \
+  macro(_module_offset,              k, "module",              module_signature,      false); \
+  macro(_name_offset,                k, "name",                string_signature,      false); \
+  macro(_classData_offset,           k, "classData",           object_signature,      false);
 
 void java_lang_Class::compute_offsets() {
-  if (offsets_computed) {
+  if (_offsets_computed) {
     return;
   }
 
-  offsets_computed = true;
+  _offsets_computed = true;
 
   InstanceKlass* k = SystemDictionary::Class_klass();
   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 
   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
@@ -1647,27 +1668,27 @@
   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
 }
 
 #if INCLUDE_CDS
 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
-  f->do_bool(&offsets_computed);
+  f->do_bool(&_offsets_computed);
   f->do_u4((u4*)&_init_lock_offset);
 
   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 
   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
 }
 #endif
 
 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
-  assert(classRedefinedCount_offset != -1, "offsets should have been initialized");
-  return the_class_mirror->int_field(classRedefinedCount_offset);
+  assert(_classRedefinedCount_offset != 0, "offsets should have been initialized");
+  return the_class_mirror->int_field(_classRedefinedCount_offset);
 }
 
 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
-  assert(classRedefinedCount_offset != -1, "offsets should have been initialized");
-  the_class_mirror->int_field_put(classRedefinedCount_offset, value);
+  assert(_classRedefinedCount_offset != 0, "offsets should have been initialized");
+  the_class_mirror->int_field_put(_classRedefinedCount_offset, value);
 }
 
 
 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
 //       platform thread structure, and a eetop offset which was used for thread
@@ -1675,23 +1696,23 @@
 //       merged, so in the HotSpot VM we just use the eetop field for the thread
 //       instead of the privateInfo_offset.
 //
 // Note: The stackSize field is only present starting in 1.4.
 
-int java_lang_Thread::_name_offset = 0;
-int java_lang_Thread::_group_offset = 0;
-int java_lang_Thread::_contextClassLoader_offset = 0;
-int java_lang_Thread::_inheritedAccessControlContext_offset = 0;
-int java_lang_Thread::_priority_offset = 0;
-int java_lang_Thread::_eetop_offset = 0;
-int java_lang_Thread::_interrupted_offset = 0;
-int java_lang_Thread::_daemon_offset = 0;
-int java_lang_Thread::_stillborn_offset = 0;
-int java_lang_Thread::_stackSize_offset = 0;
-int java_lang_Thread::_tid_offset = 0;
-int java_lang_Thread::_thread_status_offset = 0;
-int java_lang_Thread::_park_blocker_offset = 0;
+int java_lang_Thread::_name_offset;
+int java_lang_Thread::_group_offset;
+int java_lang_Thread::_contextClassLoader_offset;
+int java_lang_Thread::_inheritedAccessControlContext_offset;
+int java_lang_Thread::_priority_offset;
+int java_lang_Thread::_eetop_offset;
+int java_lang_Thread::_interrupted_offset;
+int java_lang_Thread::_daemon_offset;
+int java_lang_Thread::_stillborn_offset;
+int java_lang_Thread::_stackSize_offset;
+int java_lang_Thread::_tid_offset;
+int java_lang_Thread::_thread_status_offset;
+int java_lang_Thread::_park_blocker_offset;
 
 #define THREAD_FIELDS_DO(macro) \
   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
@@ -1849,19 +1870,19 @@
     case BLOCKED_ON_MONITOR_ENTER : return "BLOCKED (on object monitor)";
     case TERMINATED               : return "TERMINATED";
     default                       : return "UNKNOWN";
   };
 }
-int java_lang_ThreadGroup::_parent_offset = 0;
-int java_lang_ThreadGroup::_name_offset = 0;
-int java_lang_ThreadGroup::_threads_offset = 0;
-int java_lang_ThreadGroup::_groups_offset = 0;
-int java_lang_ThreadGroup::_maxPriority_offset = 0;
-int java_lang_ThreadGroup::_destroyed_offset = 0;
-int java_lang_ThreadGroup::_daemon_offset = 0;
-int java_lang_ThreadGroup::_nthreads_offset = 0;
-int java_lang_ThreadGroup::_ngroups_offset = 0;
+int java_lang_ThreadGroup::_parent_offset;
+int java_lang_ThreadGroup::_name_offset;
+int java_lang_ThreadGroup::_threads_offset;
+int java_lang_ThreadGroup::_groups_offset;
+int java_lang_ThreadGroup::_maxPriority_offset;
+int java_lang_ThreadGroup::_destroyed_offset;
+int java_lang_ThreadGroup::_daemon_offset;
+int java_lang_ThreadGroup::_nthreads_offset;
+int java_lang_ThreadGroup::_ngroups_offset;
 
 oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
   assert(oopDesc::is_oop(java_thread_group), "thread group must be oop");
   return java_thread_group->obj_field(_parent_offset);
 }
@@ -1937,16 +1958,24 @@
 void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
   THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 }
 #endif
 
+// java_lang_Throwable
+
+int java_lang_Throwable::_backtrace_offset;
+int java_lang_Throwable::_detailMessage_offset;
+int java_lang_Throwable::_stackTrace_offset;
+int java_lang_Throwable::_depth_offset;
+int java_lang_Throwable::_static_unassigned_stacktrace_offset;
+
 #define THROWABLE_FIELDS_DO(macro) \
-  macro(backtrace_offset,     k, "backtrace",     object_signature,                  false); \
-  macro(detailMessage_offset, k, "detailMessage", string_signature,                  false); \
-  macro(stackTrace_offset,    k, "stackTrace",    java_lang_StackTraceElement_array, false); \
-  macro(depth_offset,         k, "depth",         int_signature,                     false); \
-  macro(static_unassigned_stacktrace_offset, k, "UNASSIGNED_STACK", java_lang_StackTraceElement_array, true)
+  macro(_backtrace_offset,     k, "backtrace",     object_signature,                  false); \
+  macro(_detailMessage_offset, k, "detailMessage", string_signature,                  false); \
+  macro(_stackTrace_offset,    k, "stackTrace",    java_lang_StackTraceElement_array, false); \
+  macro(_depth_offset,         k, "depth",         int_signature,                     false); \
+  macro(_static_unassigned_stacktrace_offset, k, "UNASSIGNED_STACK", java_lang_StackTraceElement_array, true)
 
 void java_lang_Throwable::compute_offsets() {
   InstanceKlass* k = SystemDictionary::Throwable_klass();
   THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 }
@@ -1958,32 +1987,32 @@
 #endif
 
 oop java_lang_Throwable::unassigned_stacktrace() {
   InstanceKlass* ik = SystemDictionary::Throwable_klass();
   oop base = ik->static_field_base_raw();
-  return base->obj_field(static_unassigned_stacktrace_offset);
+  return base->obj_field(_static_unassigned_stacktrace_offset);
 }
 
 oop java_lang_Throwable::backtrace(oop throwable) {
-  return throwable->obj_field_acquire(backtrace_offset);
+  return throwable->obj_field_acquire(_backtrace_offset);
 }
 
 
 void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
-  throwable->release_obj_field_put(backtrace_offset, value);
+  throwable->release_obj_field_put(_backtrace_offset, value);
 }
 
 int java_lang_Throwable::depth(oop throwable) {
-  return throwable->int_field(depth_offset);
+  return throwable->int_field(_depth_offset);
 }
 
 void java_lang_Throwable::set_depth(oop throwable, int value) {
-  throwable->int_field_put(depth_offset, value);
+  throwable->int_field_put(_depth_offset, value);
 }
 
 oop java_lang_Throwable::message(oop throwable) {
-  return throwable->obj_field(detailMessage_offset);
+  return throwable->obj_field(_detailMessage_offset);
 }
 
 
 // Return Symbol for detailed_message or NULL
 Symbol* java_lang_Throwable::detail_message(oop throwable) {
@@ -1994,16 +2023,16 @@
   }
   return NULL;
 }
 
 void java_lang_Throwable::set_message(oop throwable, oop value) {
-  throwable->obj_field_put(detailMessage_offset, value);
+  throwable->obj_field_put(_detailMessage_offset, value);
 }
 
 
 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
-  throwable->obj_field_put(stackTrace_offset, st_element_array);
+  throwable->obj_field_put(_stackTrace_offset, st_element_array);
 }
 
 void java_lang_Throwable::clear_stacktrace(oop throwable) {
   set_stacktrace(throwable, NULL);
 }
@@ -2778,10 +2807,33 @@
   Handle java_class(THREAD, holder->java_mirror());
   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
 }
 #endif // INCLUDE_JVMCI
 
+// java_lang_StackFrameInfo
+
+int java_lang_StackFrameInfo::_memberName_offset;
+int java_lang_StackFrameInfo::_bci_offset;
+int java_lang_StackFrameInfo::_version_offset;
+
+#define STACKFRAMEINFO_FIELDS_DO(macro) \
+  macro(_memberName_offset,     k, "memberName",  object_signature, false); \
+  macro(_bci_offset,            k, "bci",         int_signature,    false)
+
+void java_lang_StackFrameInfo::compute_offsets() {
+  InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();
+  STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
+  STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
+}
+
+#if INCLUDE_CDS
+void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {
+  STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
+  STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
+}
+#endif
+
 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
   HandleMark hm(THREAD);
   Handle mname(THREAD, stackFrame->obj_field(_memberName_offset));
   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
   // we should expand MemberName::name when Throwable uses StackTrace
@@ -2817,26 +2869,23 @@
   Symbol* name = method->name();
   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),
                                        version, bci, name, CHECK);
 }
 
-#define STACKFRAMEINFO_FIELDS_DO(macro) \
-  macro(_memberName_offset,     k, "memberName",  object_signature, false); \
-  macro(_bci_offset,            k, "bci",         int_signature,    false)
-
-void java_lang_StackFrameInfo::compute_offsets() {
-  InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();
-  STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
-  STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
+void java_lang_StackFrameInfo::set_version(oop element, short value) {
+  element->short_field_put(_version_offset, value);
 }
 
-#if INCLUDE_CDS
-void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {
-  STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
-  STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
+void java_lang_StackFrameInfo::set_bci(oop element, int value) {
+  assert(value >= 0 && value < max_jushort, "must be a valid bci value");
+  element->int_field_put(_bci_offset, value);
 }
-#endif
+
+int java_lang_LiveStackFrameInfo::_monitors_offset;
+int java_lang_LiveStackFrameInfo::_locals_offset;
+int java_lang_LiveStackFrameInfo::_operands_offset;
+int java_lang_LiveStackFrameInfo::_mode_offset;
 
 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
   macro(_monitors_offset,   k, "monitors",    object_array_signature, false); \
   macro(_locals_offset,     k, "locals",      object_array_signature, false); \
   macro(_operands_offset,   k, "operands",    object_array_signature, false); \
@@ -2851,12 +2900,33 @@
 void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 }
 #endif
 
+void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {
+  element->obj_field_put(_monitors_offset, value);
+}
+
+void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {
+  element->obj_field_put(_locals_offset, value);
+}
+
+void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {
+  element->obj_field_put(_operands_offset, value);
+}
+
+void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {
+  element->int_field_put(_mode_offset, value);
+}
+
+
+// java_lang_AccessibleObject
+
+int java_lang_reflect_AccessibleObject::_override_offset;
+
 #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
-  macro(override_offset, k, "override", bool_signature, false)
+  macro(_override_offset, k, "override", bool_signature, false)
 
 void java_lang_reflect_AccessibleObject::compute_offsets() {
   InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 }
@@ -2866,31 +2936,43 @@
   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 }
 #endif
 
 jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return (jboolean) reflect->bool_field(override_offset);
+  return (jboolean) reflect->bool_field(_override_offset);
 }
 
 void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  reflect->bool_field_put(override_offset, (int) value);
+  reflect->bool_field_put(_override_offset, (int) value);
 }
 
+// java_lang_reflect_Method
+
+int java_lang_reflect_Method::_clazz_offset;
+int java_lang_reflect_Method::_name_offset;
+int java_lang_reflect_Method::_returnType_offset;
+int java_lang_reflect_Method::_parameterTypes_offset;
+int java_lang_reflect_Method::_exceptionTypes_offset;
+int java_lang_reflect_Method::_slot_offset;
+int java_lang_reflect_Method::_modifiers_offset;
+int java_lang_reflect_Method::_signature_offset;
+int java_lang_reflect_Method::_annotations_offset;
+int java_lang_reflect_Method::_parameter_annotations_offset;
+int java_lang_reflect_Method::_annotation_default_offset;
+
 #define METHOD_FIELDS_DO(macro) \
-  macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
-  macro(name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \
-  macro(returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \
-  macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
-  macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
-  macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
-  macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
-  macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
-  macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
-  macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \
-  macro(annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);
+  macro(_clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
+  macro(_name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \
+  macro(_returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \
+  macro(_parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
+  macro(_exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
+  macro(_slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
+  macro(_modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
+  macro(_signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
+  macro(_annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
+  macro(_parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \
+  macro(_annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);
 
 void java_lang_reflect_Method::compute_offsets() {
   InstanceKlass* k = SystemDictionary::reflect_Method_klass();
   METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 }
@@ -2909,93 +2991,87 @@
   assert(InstanceKlass::cast(klass)->is_initialized(), "must be initialized");
   return InstanceKlass::cast(klass)->allocate_instance_handle(THREAD);
 }
 
 oop java_lang_reflect_Method::clazz(oop reflect) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return reflect->obj_field(clazz_offset);
+  return reflect->obj_field(_clazz_offset);
 }
 
 void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-   reflect->obj_field_put(clazz_offset, value);
+   reflect->obj_field_put(_clazz_offset, value);
 }
 
 int java_lang_reflect_Method::slot(oop reflect) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return reflect->int_field(slot_offset);
+  return reflect->int_field(_slot_offset);
 }
 
 void java_lang_reflect_Method::set_slot(oop reflect, int value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  reflect->int_field_put(slot_offset, value);
+  reflect->int_field_put(_slot_offset, value);
 }
 
 void java_lang_reflect_Method::set_name(oop method, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  method->obj_field_put(name_offset, value);
+  method->obj_field_put(_name_offset, value);
 }
 
 oop java_lang_reflect_Method::return_type(oop method) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return method->obj_field(returnType_offset);
+  return method->obj_field(_returnType_offset);
 }
 
 void java_lang_reflect_Method::set_return_type(oop method, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  method->obj_field_put(returnType_offset, value);
+  method->obj_field_put(_returnType_offset, value);
 }
 
 oop java_lang_reflect_Method::parameter_types(oop method) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return method->obj_field(parameterTypes_offset);
+  return method->obj_field(_parameterTypes_offset);
 }
 
 void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  method->obj_field_put(parameterTypes_offset, value);
+  method->obj_field_put(_parameterTypes_offset, value);
 }
 
 void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  method->obj_field_put(exceptionTypes_offset, value);
+  method->obj_field_put(_exceptionTypes_offset, value);
 }
 
 void java_lang_reflect_Method::set_modifiers(oop method, int value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  method->int_field_put(modifiers_offset, value);
+  method->int_field_put(_modifiers_offset, value);
 }
 
 void java_lang_reflect_Method::set_signature(oop method, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  method->obj_field_put(signature_offset, value);
+  method->obj_field_put(_signature_offset, value);
 }
 
 void java_lang_reflect_Method::set_annotations(oop method, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  method->obj_field_put(annotations_offset, value);
+  method->obj_field_put(_annotations_offset, value);
 }
 
 void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  method->obj_field_put(parameter_annotations_offset, value);
+  method->obj_field_put(_parameter_annotations_offset, value);
 }
 
 void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  method->obj_field_put(annotation_default_offset, value);
+  method->obj_field_put(_annotation_default_offset, value);
 }
 
+int java_lang_reflect_Constructor::_clazz_offset;
+int java_lang_reflect_Constructor::_parameterTypes_offset;
+int java_lang_reflect_Constructor::_exceptionTypes_offset;
+int java_lang_reflect_Constructor::_slot_offset;
+int java_lang_reflect_Constructor::_modifiers_offset;
+int java_lang_reflect_Constructor::_signature_offset;
+int java_lang_reflect_Constructor::_annotations_offset;
+int java_lang_reflect_Constructor::_parameter_annotations_offset;
+
 #define CONSTRUCTOR_FIELDS_DO(macro) \
-  macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
-  macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
-  macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
-  macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
-  macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
-  macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
-  macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
-  macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);
+  macro(_clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
+  macro(_parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
+  macro(_exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
+  macro(_slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
+  macro(_modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
+  macro(_signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
+  macro(_annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
+  macro(_parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);
 
 void java_lang_reflect_Constructor::compute_offsets() {
   InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
   CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 }
@@ -3015,72 +3091,69 @@
   ik->initialize(CHECK_NH);
   return ik->allocate_instance_handle(THREAD);
 }
 
 oop java_lang_reflect_Constructor::clazz(oop reflect) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return reflect->obj_field(clazz_offset);
+  return reflect->obj_field(_clazz_offset);
 }
 
 void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-   reflect->obj_field_put(clazz_offset, value);
+   reflect->obj_field_put(_clazz_offset, value);
 }
 
 oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return constructor->obj_field(parameterTypes_offset);
+  return constructor->obj_field(_parameterTypes_offset);
 }
 
 void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  constructor->obj_field_put(parameterTypes_offset, value);
+  constructor->obj_field_put(_parameterTypes_offset, value);
 }
 
 void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  constructor->obj_field_put(exceptionTypes_offset, value);
+  constructor->obj_field_put(_exceptionTypes_offset, value);
 }
 
 int java_lang_reflect_Constructor::slot(oop reflect) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return reflect->int_field(slot_offset);
+  return reflect->int_field(_slot_offset);
 }
 
 void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  reflect->int_field_put(slot_offset, value);
+  reflect->int_field_put(_slot_offset, value);
 }
 
 void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  constructor->int_field_put(modifiers_offset, value);
+  constructor->int_field_put(_modifiers_offset, value);
 }
 
 void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  constructor->obj_field_put(signature_offset, value);
+  constructor->obj_field_put(_signature_offset, value);
 }
 
 void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  constructor->obj_field_put(annotations_offset, value);
+  constructor->obj_field_put(_annotations_offset, value);
 }
 
 void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  method->obj_field_put(parameter_annotations_offset, value);
+  method->obj_field_put(_parameter_annotations_offset, value);
 }
 
+int java_lang_reflect_Field::_clazz_offset;
+int java_lang_reflect_Field::_name_offset;
+int java_lang_reflect_Field::_type_offset;
+int java_lang_reflect_Field::_slot_offset;
+int java_lang_reflect_Field::_modifiers_offset;
+int java_lang_reflect_Field::_signature_offset;
+int java_lang_reflect_Field::_annotations_offset;
+
 #define FIELD_FIELDS_DO(macro) \
-  macro(clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \
-  macro(name_offset,      k, vmSymbols::name_name(),      string_signature, false); \
-  macro(type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \
-  macro(slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \
-  macro(modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \
-  macro(signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \
-  macro(annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);
+  macro(_clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \
+  macro(_name_offset,      k, vmSymbols::name_name(),      string_signature, false); \
+  macro(_type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \
+  macro(_slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \
+  macro(_modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \
+  macro(_signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \
+  macro(_annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);
 
 void java_lang_reflect_Field::compute_offsets() {
   InstanceKlass* k = SystemDictionary::reflect_Field_klass();
   FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 }
@@ -3100,67 +3173,55 @@
   ik->initialize(CHECK_NH);
   return ik->allocate_instance_handle(THREAD);
 }
 
 oop java_lang_reflect_Field::clazz(oop reflect) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return reflect->obj_field(clazz_offset);
+  return reflect->obj_field(_clazz_offset);
 }
 
 void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-   reflect->obj_field_put(clazz_offset, value);
+  reflect->obj_field_put(_clazz_offset, value);
 }
 
 oop java_lang_reflect_Field::name(oop field) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return field->obj_field(name_offset);
+  return field->obj_field(_name_offset);
 }
 
 void java_lang_reflect_Field::set_name(oop field, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  field->obj_field_put(name_offset, value);
+  field->obj_field_put(_name_offset, value);
 }
 
 oop java_lang_reflect_Field::type(oop field) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return field->obj_field(type_offset);
+  return field->obj_field(_type_offset);
 }
 
 void java_lang_reflect_Field::set_type(oop field, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  field->obj_field_put(type_offset, value);
+  field->obj_field_put(_type_offset, value);
 }
 
 int java_lang_reflect_Field::slot(oop reflect) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return reflect->int_field(slot_offset);
+  return reflect->int_field(_slot_offset);
 }
 
 void java_lang_reflect_Field::set_slot(oop reflect, int value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  reflect->int_field_put(slot_offset, value);
+  reflect->int_field_put(_slot_offset, value);
 }
 
 int java_lang_reflect_Field::modifiers(oop field) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return field->int_field(modifiers_offset);
+  return field->int_field(_modifiers_offset);
 }
 
 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  field->int_field_put(modifiers_offset, value);
+  field->int_field_put(_modifiers_offset, value);
 }
 
 void java_lang_reflect_Field::set_signature(oop field, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  field->obj_field_put(signature_offset, value);
+  field->obj_field_put(_signature_offset, value);
 }
 
 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  field->obj_field_put(annotations_offset, value);
+  field->obj_field_put(_annotations_offset, value);
 }
 
 oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {
   // Allocate java.lang.reflect.RecordComponent instance
   HandleMark hm(THREAD);
@@ -3217,10 +3278,12 @@
   java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);
 
   return element();
 }
 
+int reflect_ConstantPool::_oop_offset;
+
 #define CONSTANTPOOL_FIELDS_DO(macro) \
   macro(_oop_offset, k, "constantPoolOop", object_signature, false)
 
 void reflect_ConstantPool::compute_offsets() {
   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
@@ -3232,15 +3295,20 @@
 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 }
 #endif
 
+int java_lang_reflect_Parameter::_name_offset;
+int java_lang_reflect_Parameter::_modifiers_offset;
+int java_lang_reflect_Parameter::_index_offset;
+int java_lang_reflect_Parameter::_executable_offset;
+
 #define PARAMETER_FIELDS_DO(macro) \
-  macro(name_offset,        k, vmSymbols::name_name(),        string_signature, false); \
-  macro(modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \
-  macro(index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \
-  macro(executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)
+  macro(_name_offset,        k, vmSymbols::name_name(),        string_signature, false); \
+  macro(_modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \
+  macro(_index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \
+  macro(_executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)
 
 void java_lang_reflect_Parameter::compute_offsets() {
   InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
   PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 }
@@ -3260,64 +3328,57 @@
   ik->initialize(CHECK_NH);
   return ik->allocate_instance_handle(THREAD);
 }
 
 oop java_lang_reflect_Parameter::name(oop param) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return param->obj_field(name_offset);
+  return param->obj_field(_name_offset);
 }
 
 void java_lang_reflect_Parameter::set_name(oop param, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  param->obj_field_put(name_offset, value);
+  param->obj_field_put(_name_offset, value);
 }
 
 int java_lang_reflect_Parameter::modifiers(oop param) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return param->int_field(modifiers_offset);
+  return param->int_field(_modifiers_offset);
 }
 
 void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  param->int_field_put(modifiers_offset, value);
+  param->int_field_put(_modifiers_offset, value);
 }
 
 int java_lang_reflect_Parameter::index(oop param) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return param->int_field(index_offset);
+  return param->int_field(_index_offset);
 }
 
 void java_lang_reflect_Parameter::set_index(oop param, int value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  param->int_field_put(index_offset, value);
+  param->int_field_put(_index_offset, value);
 }
 
 oop java_lang_reflect_Parameter::executable(oop param) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return param->obj_field(executable_offset);
+  return param->obj_field(_executable_offset);
 }
 
 void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  param->obj_field_put(executable_offset, value);
+  param->obj_field_put(_executable_offset, value);
 }
 
+// java_lang_Module
 
-int java_lang_Module::loader_offset;
-int java_lang_Module::name_offset;
-int java_lang_Module::_module_entry_offset = -1;
+int java_lang_Module::_loader_offset;
+int java_lang_Module::_name_offset;
+int java_lang_Module::_module_entry_offset;
 
 Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
   return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
                           vmSymbols::java_lang_module_init_signature(),
                           loader, module_name, CHECK_NH);
 }
 
 #define MODULE_FIELDS_DO(macro) \
-  macro(loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \
-  macro(name_offset,    k, vmSymbols::name_name(),    string_signature,      false)
+  macro(_loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \
+  macro(_name_offset,    k, vmSymbols::name_name(),    string_signature,      false)
 
 void java_lang_Module::compute_offsets() {
   InstanceKlass* k = SystemDictionary::Module_klass();
   MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
   MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
@@ -3329,31 +3390,27 @@
   MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
 }
 #endif
 
 oop java_lang_Module::loader(oop module) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return module->obj_field(loader_offset);
+  return module->obj_field(_loader_offset);
 }
 
 void java_lang_Module::set_loader(oop module, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  module->obj_field_put(loader_offset, value);
+  module->obj_field_put(_loader_offset, value);
 }
 
 oop java_lang_Module::name(oop module) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  return module->obj_field(name_offset);
+  return module->obj_field(_name_offset);
 }
 
 void java_lang_Module::set_name(oop module, oop value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
-  module->obj_field_put(name_offset, value);
+  module->obj_field_put(_name_offset, value);
 }
 
 ModuleEntry* java_lang_Module::module_entry(oop module) {
-  assert(_module_entry_offset != -1, "Uninitialized module_entry_offset");
+  assert(_module_entry_offset != 0, "Uninitialized module_entry_offset");
   assert(module != NULL, "module can't be null");
   assert(oopDesc::is_oop(module), "module must be oop");
 
   ModuleEntry* module_entry = (ModuleEntry*)module->address_field(_module_entry_offset);
   if (module_entry == NULL) {
@@ -3366,11 +3423,11 @@
   }
   return module_entry;
 }
 
 void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
-  assert(_module_entry_offset != -1, "Uninitialized module_entry_offset");
+  assert(_module_entry_offset != 0, "Uninitialized module_entry_offset");
   assert(module != NULL, "module can't be null");
   assert(oopDesc::is_oop(module), "module must be oop");
   module->address_field_put(_module_entry_offset, (address)module_entry);
 }
 
@@ -3382,18 +3439,16 @@
   return k->allocate_instance_handle(THREAD);
 }
 
 
 void reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
   oop mirror = value->pool_holder()->java_mirror();
   // Save the mirror to get back the constant pool.
   reflect->obj_field_put(_oop_offset, mirror);
 }
 
 ConstantPool* reflect_ConstantPool::get_cp(oop reflect) {
-  assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
 
   oop mirror = reflect->obj_field(_oop_offset);
   Klass* k = java_lang_Class::as_Klass(mirror);
   assert(k->is_instance_klass(), "Must be");
 
@@ -3403,10 +3458,12 @@
   // no longer done in the future, this will have to change to save
   // the original.
   return InstanceKlass::cast(k)->constants();
 }
 
+int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
+
 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
   macro(_base_offset, k, "base", object_signature, false)
 
 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
@@ -3417,10 +3474,77 @@
 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 }
 #endif
 
+// Support for java_lang_ref_Reference
+
+bool java_lang_ref_Reference::_offsets_initialized;
+
+int java_lang_ref_Reference::_referent_offset;
+int java_lang_ref_Reference::_queue_offset;
+int java_lang_ref_Reference::_next_offset;
+int java_lang_ref_Reference::_discovered_offset;
+
+#define REFERENCE_FIELDS_DO(macro) \
+  macro(_referent_offset,   k, "referent", object_signature, false); \
+  macro(_queue_offset,      k, "queue", referencequeue_signature, false); \
+  macro(_next_offset,       k, "next", reference_signature, false); \
+  macro(_discovered_offset, k, "discovered", reference_signature, false);
+
+void java_lang_ref_Reference::compute_offsets() {
+  if (_offsets_initialized) {
+    return;
+  }
+  _offsets_initialized = true;
+  InstanceKlass* k = SystemDictionary::Reference_klass();
+  REFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
+}
+
+#if INCLUDE_CDS
+void java_lang_ref_Reference::serialize_offsets(SerializeClosure* f) {
+  f->do_bool(&_offsets_initialized);
+  REFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
+}
+#endif
+
+bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {
+  assert(obj != NULL, "sanity");
+  if (offset != _referent_offset) {
+    return false;
+  }
+
+  Klass* k = obj->klass();
+  if (!k->is_instance_klass()) {
+    return false;
+  }
+
+  InstanceKlass* ik = InstanceKlass::cast(obj->klass());
+  bool is_reference = ik->reference_type() != REF_NONE;
+  assert(!is_reference || ik->is_subclass_of(SystemDictionary::Reference_klass()), "sanity");
+  return is_reference;
+}
+
+int java_lang_boxing_object::_value_offset;
+int java_lang_boxing_object::_long_value_offset;
+
+#define BOXING_FIELDS_DO(macro) \
+  macro(_value_offset,      integerKlass, "value", int_signature, false); \
+  macro(_long_value_offset, longKlass, "value", long_signature, false);
+
+void java_lang_boxing_object::compute_offsets() {
+  InstanceKlass* integerKlass = SystemDictionary::Integer_klass();
+  InstanceKlass* longKlass = SystemDictionary::Long_klass();
+  BOXING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
+}
+
+#if INCLUDE_CDS
+void java_lang_boxing_object::serialize_offsets(SerializeClosure* f) {
+  BOXING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
+}
+#endif
+
 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
   Klass* k = SystemDictionary::box_klass(type);
   if (k == NULL)  return NULL;
   InstanceKlass* ik = InstanceKlass::cast(k);
   if (!ik->is_initialized())  ik->initialize(CHECK_NULL);
@@ -3431,32 +3555,32 @@
 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
   oop box = initialize_and_allocate(type, CHECK_NULL);
   if (box == NULL)  return NULL;
   switch (type) {
     case T_BOOLEAN:
-      box->bool_field_put(value_offset, value->z);
+      box->bool_field_put(_value_offset, value->z);
       break;
     case T_CHAR:
-      box->char_field_put(value_offset, value->c);
+      box->char_field_put(_value_offset, value->c);
       break;
     case T_FLOAT:
-      box->float_field_put(value_offset, value->f);
+      box->float_field_put(_value_offset, value->f);
       break;
     case T_DOUBLE:
-      box->double_field_put(long_value_offset, value->d);
+      box->double_field_put(_long_value_offset, value->d);
       break;
     case T_BYTE:
-      box->byte_field_put(value_offset, value->b);
+      box->byte_field_put(_value_offset, value->b);
       break;
     case T_SHORT:
-      box->short_field_put(value_offset, value->s);
+      box->short_field_put(_value_offset, value->s);
       break;
     case T_INT:
-      box->int_field_put(value_offset, value->i);
+      box->int_field_put(_value_offset, value->i);
       break;
     case T_LONG:
-      box->long_field_put(long_value_offset, value->j);
+      box->long_field_put(_long_value_offset, value->j);
       break;
     default:
       return NULL;
   }
   return box;
@@ -3474,32 +3598,32 @@
 
 BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
   BasicType type = SystemDictionary::box_klass_type(box->klass());
   switch (type) {
   case T_BOOLEAN:
-    value->z = box->bool_field(value_offset);
+    value->z = box->bool_field(_value_offset);
     break;
   case T_CHAR:
-    value->c = box->char_field(value_offset);
+    value->c = box->char_field(_value_offset);
     break;
   case T_FLOAT:
-    value->f = box->float_field(value_offset);
+    value->f = box->float_field(_value_offset);
     break;
   case T_DOUBLE:
-    value->d = box->double_field(long_value_offset);
+    value->d = box->double_field(_long_value_offset);
     break;
   case T_BYTE:
-    value->b = box->byte_field(value_offset);
+    value->b = box->byte_field(_value_offset);
     break;
   case T_SHORT:
-    value->s = box->short_field(value_offset);
+    value->s = box->short_field(_value_offset);
     break;
   case T_INT:
-    value->i = box->int_field(value_offset);
+    value->i = box->int_field(_value_offset);
     break;
   case T_LONG:
-    value->j = box->long_field(long_value_offset);
+    value->j = box->long_field(_long_value_offset);
     break;
   default:
     return T_ILLEGAL;
   } // end switch
   return type;
@@ -3508,32 +3632,32 @@
 
 BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
   BasicType type = SystemDictionary::box_klass_type(box->klass());
   switch (type) {
   case T_BOOLEAN:
-    box->bool_field_put(value_offset, value->z);
+    box->bool_field_put(_value_offset, value->z);
     break;
   case T_CHAR:
-    box->char_field_put(value_offset, value->c);
+    box->char_field_put(_value_offset, value->c);
     break;
   case T_FLOAT:
-    box->float_field_put(value_offset, value->f);
+    box->float_field_put(_value_offset, value->f);
     break;
   case T_DOUBLE:
-    box->double_field_put(long_value_offset, value->d);
+    box->double_field_put(_long_value_offset, value->d);
     break;
   case T_BYTE:
-    box->byte_field_put(value_offset, value->b);
+    box->byte_field_put(_value_offset, value->b);
     break;
   case T_SHORT:
-    box->short_field_put(value_offset, value->s);
+    box->short_field_put(_value_offset, value->s);
     break;
   case T_INT:
-    box->int_field_put(value_offset, value->i);
+    box->int_field_put(_value_offset, value->i);
     break;
   case T_LONG:
-    box->long_field_put(long_value_offset, value->j);
+    box->long_field_put(_long_value_offset, value->j);
     break;
   default:
     return T_ILLEGAL;
   } // end switch
   return type;
@@ -3552,73 +3676,20 @@
   case T_DOUBLE:    st->print("%lf", value->d);                     break;
   default:          st->print("type %d?", type);                    break;
   }
 }
 
-// Support for java_lang_ref_Reference
-
-bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {
-  assert(obj != NULL, "sanity");
-  if (offset != java_lang_ref_Reference::referent_offset) {
-    return false;
-  }
-
-  Klass* k = obj->klass();
-  if (!k->is_instance_klass()) {
-    return false;
-  }
-
-  InstanceKlass* ik = InstanceKlass::cast(obj->klass());
-  bool is_reference = ik->reference_type() != REF_NONE;
-  assert(!is_reference || ik->is_subclass_of(SystemDictionary::Reference_klass()), "sanity");
-  return is_reference;
-}
-
-#define REFERENCE_FIELDS_DO(macro) \
-  macro(referent_offset,   k, "referent", object_signature, false); \
-  macro(queue_offset,      k, "queue", referencequeue_signature, false); \
-  macro(next_offset,       k, "next", reference_signature, false); \
-  macro(discovered_offset, k, "discovered", reference_signature, false);
-
-void java_lang_ref_Reference::compute_offsets() {
-  if (_offsets_initialized) {
-    return;
-  }
-  _offsets_initialized = true;
-  InstanceKlass* k = SystemDictionary::Reference_klass();
-  REFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
-}
-
-#if INCLUDE_CDS
-void java_lang_ref_Reference::serialize_offsets(SerializeClosure* f) {
-  f->do_bool(&_offsets_initialized);
-  REFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
-}
-#endif
-
-#define BOXING_FIELDS_DO(macro) \
-  macro(value_offset,      integerKlass, "value", int_signature, false); \
-  macro(long_value_offset, longKlass, "value", long_signature, false);
-
-void java_lang_boxing_object::compute_offsets() {
-  InstanceKlass* integerKlass = SystemDictionary::Integer_klass();
-  InstanceKlass* longKlass = SystemDictionary::Long_klass();
-  BOXING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
-}
-
-#if INCLUDE_CDS
-void java_lang_boxing_object::serialize_offsets(SerializeClosure* f) {
-  BOXING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
-}
-#endif
 
 // Support for java_lang_ref_SoftReference
 //
 
+int java_lang_ref_SoftReference::_timestamp_offset;
+int java_lang_ref_SoftReference::_static_clock_offset;
+
 #define SOFTREFERENCE_FIELDS_DO(macro) \
-  macro(timestamp_offset,    k, "timestamp", long_signature, false); \
-  macro(static_clock_offset, k, "clock",     long_signature, true)
+  macro(_timestamp_offset,    k, "timestamp", long_signature, false); \
+  macro(_static_clock_offset, k, "clock",     long_signature, true)
 
 void java_lang_ref_SoftReference::compute_offsets() {
   InstanceKlass* k = SystemDictionary::SoftReference_klass();
   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 }
@@ -3628,34 +3699,34 @@
   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 }
 #endif
 
 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
-  return ref->long_field(timestamp_offset);
+  return ref->long_field(_timestamp_offset);
 }
 
 jlong java_lang_ref_SoftReference::clock() {
   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
   oop base = ik->static_field_base_raw();
-  return base->long_field(static_clock_offset);
+  return base->long_field(_static_clock_offset);
 }
 
 void java_lang_ref_SoftReference::set_clock(jlong value) {
   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
   oop base = ik->static_field_base_raw();
-  base->long_field_put(static_clock_offset, value);
+  base->long_field_put(_static_clock_offset, value);
 }
 
 // Support for java_lang_invoke_DirectMethodHandle
 
 int java_lang_invoke_DirectMethodHandle::_member_offset;
 
 oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
   oop member_name = NULL;
   assert(oopDesc::is_oop(dmh) && java_lang_invoke_DirectMethodHandle::is_instance(dmh),
          "a DirectMethodHandle oop is expected");
-  return dmh->obj_field(member_offset_in_bytes());
+  return dmh->obj_field(_member_offset);
 }
 
 #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
   macro(_member_offset, k, "member", java_lang_invoke_MemberName_signature, false)
 
@@ -4069,14 +4140,14 @@
   return dep_ctx;
 }
 
 // Support for java_security_AccessControlContext
 
-int java_security_AccessControlContext::_context_offset = 0;
-int java_security_AccessControlContext::_privilegedContext_offset = 0;
-int java_security_AccessControlContext::_isPrivileged_offset = 0;
-int java_security_AccessControlContext::_isAuthorized_offset = -1;
+int java_security_AccessControlContext::_context_offset;
+int java_security_AccessControlContext::_privilegedContext_offset;
+int java_security_AccessControlContext::_isPrivileged_offset;
+int java_security_AccessControlContext::_isAuthorized_offset;
 
 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
   macro(_context_offset,           k, "context",      protectiondomain_signature, false); \
   macro(_privilegedContext_offset, k, "privilegedContext", accesscontrolcontext_signature, false); \
   macro(_isPrivileged_offset,      k, "isPrivileged", bool_signature, false); \
@@ -4094,11 +4165,11 @@
 }
 #endif
 
 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
   assert(_isPrivileged_offset != 0, "offsets should have been initialized");
-  assert(_isAuthorized_offset != -1, "offsets should have been initialized");
+  assert(_isAuthorized_offset != 0, "offsets should have been initialized");
   // Ensure klass is initialized
   SystemDictionary::AccessControlContext_klass()->initialize(CHECK_NULL);
   // Allocate result
   oop result = SystemDictionary::AccessControlContext_klass()->allocate_instance(CHECK_NULL);
   // Fill in values
@@ -4111,16 +4182,16 @@
 }
 
 
 // Support for java_lang_ClassLoader
 
-bool java_lang_ClassLoader::offsets_computed = false;
-int  java_lang_ClassLoader::_loader_data_offset = -1;
-int  java_lang_ClassLoader::parallelCapable_offset = -1;
-int  java_lang_ClassLoader::name_offset = -1;
-int  java_lang_ClassLoader::nameAndId_offset = -1;
-int  java_lang_ClassLoader::unnamedModule_offset = -1;
+int  java_lang_ClassLoader::_loader_data_offset;
+int  java_lang_ClassLoader::_parallelCapable_offset;
+int  java_lang_ClassLoader::_name_offset;
+int  java_lang_ClassLoader::_nameAndId_offset;
+int  java_lang_ClassLoader::_unnamedModule_offset;
+int  java_lang_ClassLoader::_parent_offset;
 
 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
   assert(loader != NULL, "loader must not be NULL");
   assert(oopDesc::is_oop(loader), "loader must be oop");
   return HeapAccess<MO_ACQUIRE>::load_at(loader, _loader_data_offset);
@@ -4137,20 +4208,17 @@
   assert(oopDesc::is_oop(loader), "loader must be oop");
   HeapAccess<MO_RELEASE>::store_at(loader, _loader_data_offset, new_data);
 }
 
 #define CLASSLOADER_FIELDS_DO(macro) \
-  macro(parallelCapable_offset, k1, "parallelLockMap",      concurrenthashmap_signature, false); \
-  macro(name_offset,            k1, vmSymbols::name_name(), string_signature, false); \
-  macro(nameAndId_offset,       k1, "nameAndId",            string_signature, false); \
-  macro(unnamedModule_offset,   k1, "unnamedModule",        module_signature, false); \
-  macro(parent_offset,          k1, "parent",               classloader_signature, false)
+  macro(_parallelCapable_offset, k1, "parallelLockMap",      concurrenthashmap_signature, false); \
+  macro(_name_offset,            k1, vmSymbols::name_name(), string_signature, false); \
+  macro(_nameAndId_offset,       k1, "nameAndId",            string_signature, false); \
+  macro(_unnamedModule_offset,   k1, "unnamedModule",        module_signature, false); \
+  macro(_parent_offset,          k1, "parent",               classloader_signature, false)
 
 void java_lang_ClassLoader::compute_offsets() {
-  assert(!offsets_computed, "offsets should be initialized only once");
-  offsets_computed = true;
-
   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 
   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
 }
@@ -4162,29 +4230,29 @@
 }
 #endif
 
 oop java_lang_ClassLoader::parent(oop loader) {
   assert(is_instance(loader), "loader must be oop");
-  return loader->obj_field(parent_offset);
+  return loader->obj_field(_parent_offset);
 }
 
 // Returns the name field of this class loader.  If the name field has not
 // been set, null will be returned.
 oop java_lang_ClassLoader::name(oop loader) {
   assert(is_instance(loader), "loader must be oop");
-  return loader->obj_field(name_offset);
+  return loader->obj_field(_name_offset);
 }
 
 // Returns the nameAndId field of this class loader. The format is
 // as follows:
 //   If the defining loader has a name explicitly set then '<loader-name>' @<id>
 //   If the defining loader has no name then <qualified-class-name> @<id>
 //   If built-in loader, then omit '@<id>' as there is only one instance.
 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
 oop java_lang_ClassLoader::nameAndId(oop loader) {
   assert(is_instance(loader), "loader must be oop");
-  return loader->obj_field(nameAndId_offset);
+  return loader->obj_field(_nameAndId_offset);
 }
 
 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
   assert(is_instance(loader), "loader must be oop");
   assert(cl == NULL || is_instance(cl), "cl argument must be oop");
@@ -4208,12 +4276,12 @@
 
 // For class loader classes, parallelCapable defined
 // based on non-null field
 // Written to by java.lang.ClassLoader, vm only reads this field, doesn't set it
 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
-  assert(parallelCapable_offset != -1, "offsets should have been initialized");
-  return (class_loader->obj_field(parallelCapable_offset) != NULL);
+  assert(_parallelCapable_offset != 0, "offsets should have been initialized");
+  return (class_loader->obj_field(_parallelCapable_offset) != NULL);
 }
 
 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
   // Fix for 4474172; see evaluation for more details
   loader = non_reflection_class_loader(loader);
@@ -4248,20 +4316,26 @@
   return loader;
 }
 
 oop java_lang_ClassLoader::unnamedModule(oop loader) {
   assert(is_instance(loader), "loader must be oop");
-  return loader->obj_field(unnamedModule_offset);
+  return loader->obj_field(_unnamedModule_offset);
 }
 
 // Support for java_lang_System
 //
+
+int java_lang_System::_static_in_offset;
+int java_lang_System::_static_out_offset;
+int java_lang_System::_static_err_offset;
+int java_lang_System::_static_security_offset;
+
 #define SYSTEM_FIELDS_DO(macro) \
-  macro(static_in_offset,  k, "in",  input_stream_signature, true); \
-  macro(static_out_offset, k, "out", print_stream_signature, true); \
-  macro(static_err_offset, k, "err", print_stream_signature, true); \
-  macro(static_security_offset, k, "security", security_manager_signature, true)
+  macro(_static_in_offset,  k, "in",  input_stream_signature, true); \
+  macro(_static_out_offset, k, "out", print_stream_signature, true); \
+  macro(_static_err_offset, k, "err", print_stream_signature, true); \
+  macro(_static_security_offset, k, "security", security_manager_signature, true)
 
 void java_lang_System::compute_offsets() {
   InstanceKlass* k = SystemDictionary::System_klass();
   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 }
@@ -4270,14 +4344,10 @@
 void java_lang_System::serialize_offsets(SerializeClosure* f) {
    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 }
 #endif
 
-int java_lang_System::in_offset_in_bytes() { return static_in_offset; }
-int java_lang_System::out_offset_in_bytes() { return static_out_offset; }
-int java_lang_System::err_offset_in_bytes() { return static_err_offset; }
-
 // Support for jdk_internal_misc_UnsafeConstants
 //
 class UnsafeConstantsFixup : public FieldClosure {
 private:
   int _address_size;
@@ -4320,125 +4390,31 @@
 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
   UnsafeConstantsFixup fixup;
   SystemDictionary::UnsafeConstants_klass()->do_local_static_fields(&fixup);
 }
 
-int java_lang_Class::_klass_offset;
-int java_lang_Class::_array_klass_offset;
-int java_lang_Class::_oop_size_offset;
-int java_lang_Class::_static_oop_field_count_offset;
-int java_lang_Class::_class_loader_offset;
-int java_lang_Class::_module_offset;
-int java_lang_Class::_protection_domain_offset;
-int java_lang_Class::_component_mirror_offset;
-int java_lang_Class::_init_lock_offset;
-int java_lang_Class::_signers_offset;
-int java_lang_Class::_name_offset;
-int java_lang_Class::_source_file_offset;
-int java_lang_Class::_classData_offset;
-GrowableArray<Klass*>* java_lang_Class::_fixup_mirror_list = NULL;
-GrowableArray<Klass*>* java_lang_Class::_fixup_module_field_list = NULL;
-int java_lang_Throwable::backtrace_offset;
-int java_lang_Throwable::detailMessage_offset;
-int java_lang_Throwable::stackTrace_offset;
-int java_lang_Throwable::depth_offset;
-int java_lang_Throwable::static_unassigned_stacktrace_offset;
-int java_lang_reflect_AccessibleObject::override_offset;
-int java_lang_reflect_Method::clazz_offset;
-int java_lang_reflect_Method::name_offset;
-int java_lang_reflect_Method::returnType_offset;
-int java_lang_reflect_Method::parameterTypes_offset;
-int java_lang_reflect_Method::exceptionTypes_offset;
-int java_lang_reflect_Method::slot_offset;
-int java_lang_reflect_Method::modifiers_offset;
-int java_lang_reflect_Method::signature_offset;
-int java_lang_reflect_Method::annotations_offset;
-int java_lang_reflect_Method::parameter_annotations_offset;
-int java_lang_reflect_Method::annotation_default_offset;
-int java_lang_reflect_Constructor::clazz_offset;
-int java_lang_reflect_Constructor::parameterTypes_offset;
-int java_lang_reflect_Constructor::exceptionTypes_offset;
-int java_lang_reflect_Constructor::slot_offset;
-int java_lang_reflect_Constructor::modifiers_offset;
-int java_lang_reflect_Constructor::signature_offset;
-int java_lang_reflect_Constructor::annotations_offset;
-int java_lang_reflect_Constructor::parameter_annotations_offset;
-int java_lang_reflect_Field::clazz_offset;
-int java_lang_reflect_Field::name_offset;
-int java_lang_reflect_Field::type_offset;
-int java_lang_reflect_Field::slot_offset;
-int java_lang_reflect_Field::modifiers_offset;
-int java_lang_reflect_Field::signature_offset;
-int java_lang_reflect_Field::annotations_offset;
-int java_lang_reflect_Parameter::name_offset;
-int java_lang_reflect_Parameter::modifiers_offset;
-int java_lang_reflect_Parameter::index_offset;
-int java_lang_reflect_Parameter::executable_offset;
-int java_lang_boxing_object::value_offset;
-int java_lang_boxing_object::long_value_offset;
-bool java_lang_ref_Reference::_offsets_initialized;
-int java_lang_ref_Reference::referent_offset;
-int java_lang_ref_Reference::queue_offset;
-int java_lang_ref_Reference::next_offset;
-int java_lang_ref_Reference::discovered_offset;
-int java_lang_ref_SoftReference::timestamp_offset;
-int java_lang_ref_SoftReference::static_clock_offset;
-int java_lang_ClassLoader::parent_offset;
-int java_lang_System::static_in_offset;
-int java_lang_System::static_out_offset;
-int java_lang_System::static_err_offset;
-int java_lang_System::static_security_offset;
-int java_lang_StackTraceElement::methodName_offset;
-int java_lang_StackTraceElement::fileName_offset;
-int java_lang_StackTraceElement::lineNumber_offset;
-int java_lang_StackTraceElement::moduleName_offset;
-int java_lang_StackTraceElement::moduleVersion_offset;
-int java_lang_StackTraceElement::classLoaderName_offset;
-int java_lang_StackTraceElement::declaringClass_offset;
-int java_lang_StackTraceElement::declaringClassObject_offset;
-int java_lang_StackFrameInfo::_memberName_offset;
-int java_lang_StackFrameInfo::_bci_offset;
-int java_lang_StackFrameInfo::_version_offset;
-int java_lang_LiveStackFrameInfo::_monitors_offset;
-int java_lang_LiveStackFrameInfo::_locals_offset;
-int java_lang_LiveStackFrameInfo::_operands_offset;
-int java_lang_LiveStackFrameInfo::_mode_offset;
-int java_lang_AssertionStatusDirectives::classes_offset;
-int java_lang_AssertionStatusDirectives::classEnabled_offset;
-int java_lang_AssertionStatusDirectives::packages_offset;
-int java_lang_AssertionStatusDirectives::packageEnabled_offset;
-int java_lang_AssertionStatusDirectives::deflt_offset;
-int java_nio_Buffer::_limit_offset;
-int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
-int reflect_ConstantPool::_oop_offset;
-int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
-int java_lang_Integer_IntegerCache::_static_cache_offset;
-int java_lang_Long_LongCache::_static_cache_offset;
-int java_lang_Character_CharacterCache::_static_cache_offset;
-int java_lang_Short_ShortCache::_static_cache_offset;
-int java_lang_Byte_ByteCache::_static_cache_offset;
-int java_lang_Boolean::_static_TRUE_offset;
-int java_lang_Boolean::_static_FALSE_offset;
-int java_lang_reflect_RecordComponent::clazz_offset;
-int java_lang_reflect_RecordComponent::name_offset;
-int java_lang_reflect_RecordComponent::type_offset;
-int java_lang_reflect_RecordComponent::accessor_offset;
-int java_lang_reflect_RecordComponent::signature_offset;
-int java_lang_reflect_RecordComponent::annotations_offset;
-int java_lang_reflect_RecordComponent::typeAnnotations_offset;
 
+// java_lang_StackTraceElement
 
+int java_lang_StackTraceElement::_methodName_offset;
+int java_lang_StackTraceElement::_fileName_offset;
+int java_lang_StackTraceElement::_lineNumber_offset;
+int java_lang_StackTraceElement::_moduleName_offset;
+int java_lang_StackTraceElement::_moduleVersion_offset;
+int java_lang_StackTraceElement::_classLoaderName_offset;
+int java_lang_StackTraceElement::_declaringClass_offset;
+int java_lang_StackTraceElement::_declaringClassObject_offset;
 
 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
-  macro(declaringClassObject_offset,  k, "declaringClassObject", class_signature, false); \
-  macro(classLoaderName_offset, k, "classLoaderName", string_signature, false); \
-  macro(moduleName_offset,      k, "moduleName",      string_signature, false); \
-  macro(moduleVersion_offset,   k, "moduleVersion",   string_signature, false); \
-  macro(declaringClass_offset,  k, "declaringClass",  string_signature, false); \
-  macro(methodName_offset,      k, "methodName",      string_signature, false); \
-  macro(fileName_offset,        k, "fileName",        string_signature, false); \
-  macro(lineNumber_offset,      k, "lineNumber",      int_signature,    false)
+  macro(_declaringClassObject_offset,  k, "declaringClassObject", class_signature, false); \
+  macro(_classLoaderName_offset, k, "classLoaderName", string_signature, false); \
+  macro(_moduleName_offset,      k, "moduleName",      string_signature, false); \
+  macro(_moduleVersion_offset,   k, "moduleVersion",   string_signature, false); \
+  macro(_declaringClass_offset,  k, "declaringClass",  string_signature, false); \
+  macro(_methodName_offset,      k, "methodName",      string_signature, false); \
+  macro(_fileName_offset,        k, "fileName",        string_signature, false); \
+  macro(_lineNumber_offset,      k, "lineNumber",      int_signature,    false)
 
 // Support for java_lang_StackTraceElement
 void java_lang_StackTraceElement::compute_offsets() {
   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
@@ -4449,73 +4425,57 @@
   STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 }
 #endif
 
 void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
-  element->obj_field_put(fileName_offset, value);
+  element->obj_field_put(_fileName_offset, value);
 }
 
 void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
-  element->obj_field_put(declaringClass_offset, value);
+  element->obj_field_put(_declaringClass_offset, value);
 }
 
 void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
-  element->obj_field_put(methodName_offset, value);
+  element->obj_field_put(_methodName_offset, value);
 }
 
 void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
-  element->int_field_put(lineNumber_offset, value);
+  element->int_field_put(_lineNumber_offset, value);
 }
 
 void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
-  element->obj_field_put(moduleName_offset, value);
+  element->obj_field_put(_moduleName_offset, value);
 }
 
 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
-  element->obj_field_put(moduleVersion_offset, value);
+  element->obj_field_put(_moduleVersion_offset, value);
 }
 
 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
-  element->obj_field_put(classLoaderName_offset, value);
+  element->obj_field_put(_classLoaderName_offset, value);
 }
 
 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
-  element->obj_field_put(declaringClassObject_offset, value);
+  element->obj_field_put(_declaringClassObject_offset, value);
 }
 
-void java_lang_StackFrameInfo::set_version(oop element, short value) {
-  element->short_field_put(_version_offset, value);
-}
 
-void java_lang_StackFrameInfo::set_bci(oop element, int value) {
-  assert(value >= 0 && value < max_jushort, "must be a valid bci value");
-  element->int_field_put(_bci_offset, value);
-}
-
-void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {
-  element->obj_field_put(_monitors_offset, value);
-}
-
-void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {
-  element->obj_field_put(_locals_offset, value);
-}
-
-void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {
-  element->obj_field_put(_operands_offset, value);
-}
+// java_lang_AssertionStatusDirectives
 
-void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {
-  element->int_field_put(_mode_offset, value);
-}
+int java_lang_AssertionStatusDirectives::_classes_offset;
+int java_lang_AssertionStatusDirectives::_classEnabled_offset;
+int java_lang_AssertionStatusDirectives::_packages_offset;
+int java_lang_AssertionStatusDirectives::_packageEnabled_offset;
+int java_lang_AssertionStatusDirectives::_deflt_offset;
 
 // Support for java Assertions - java_lang_AssertionStatusDirectives.
 #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
-  macro(classes_offset,        k, "classes",        string_array_signature, false); \
-  macro(classEnabled_offset,   k, "classEnabled",   bool_array_signature, false); \
-  macro(packages_offset,       k, "packages",       string_array_signature, false); \
-  macro(packageEnabled_offset, k, "packageEnabled", bool_array_signature,   false); \
-  macro(deflt_offset,          k, "deflt",          bool_signature,         false)
+  macro(_classes_offset,        k, "classes",        string_array_signature, false); \
+  macro(_classEnabled_offset,   k, "classEnabled",   bool_array_signature, false); \
+  macro(_packages_offset,       k, "packages",       string_array_signature, false); \
+  macro(_packageEnabled_offset, k, "packageEnabled", bool_array_signature,   false); \
+  macro(_deflt_offset,          k, "deflt",          bool_signature,         false)
 
 void java_lang_AssertionStatusDirectives::compute_offsets() {
   InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 }
@@ -4525,34 +4485,33 @@
   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 }
 #endif
 
 void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
-  o->obj_field_put(classes_offset, val);
+  o->obj_field_put(_classes_offset, val);
 }
 
 void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
-  o->obj_field_put(classEnabled_offset, val);
+  o->obj_field_put(_classEnabled_offset, val);
 }
 
 void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
-  o->obj_field_put(packages_offset, val);
+  o->obj_field_put(_packages_offset, val);
 }
 
 void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
-  o->obj_field_put(packageEnabled_offset, val);
+  o->obj_field_put(_packageEnabled_offset, val);
 }
 
 void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
-  o->bool_field_put(deflt_offset, val);
+  o->bool_field_put(_deflt_offset, val);
 }
 
 
 // Support for intrinsification of java.nio.Buffer.checkIndex
-int java_nio_Buffer::limit_offset() {
-  return _limit_offset;
-}
+
+int java_nio_Buffer::_limit_offset;
 
 #define BUFFER_FIELDS_DO(macro) \
   macro(_limit_offset, k, "limit", int_signature, false)
 
 void java_nio_Buffer::compute_offsets() {
@@ -4565,10 +4524,12 @@
 void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {
   BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 }
 #endif
 
+int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
+
 #define AOS_FIELDS_DO(macro) \
   macro(_owner_offset, k, "exclusiveOwnerThread", thread_signature, false)
 
 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
@@ -4584,10 +4545,16 @@
 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 }
 #endif
 
+int java_lang_Integer_IntegerCache::_static_cache_offset;
+int java_lang_Long_LongCache::_static_cache_offset;
+int java_lang_Character_CharacterCache::_static_cache_offset;
+int java_lang_Short_ShortCache::_static_cache_offset;
+int java_lang_Byte_ByteCache::_static_cache_offset;
+
 #define INTEGER_CACHE_FIELDS_DO(macro) \
   macro(_static_cache_offset, k, "cache", java_lang_Integer_array_signature, true)
 
 void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {
   guarantee(k != NULL && k->is_initialized(), "must be loaded and initialized");
@@ -4733,10 +4700,14 @@
 jbyte java_lang_Byte::value(oop obj) {
    jvalue v;
    java_lang_boxing_object::get_value(obj, &v);
    return v.b;
 }
+
+int java_lang_Boolean::_static_TRUE_offset;
+int java_lang_Boolean::_static_FALSE_offset;
+
 #define BOOLEAN_FIELDS_DO(macro) \
   macro(_static_TRUE_offset, k, "TRUE", java_lang_Boolean_signature, true); \
   macro(_static_FALSE_offset, k, "FALSE", java_lang_Boolean_signature, true)
 
 
@@ -4770,18 +4741,28 @@
    jvalue v;
    java_lang_boxing_object::get_value(obj, &v);
    return v.z;
 }
 
+// java_lang_reflect_RecordComponent
+
+int java_lang_reflect_RecordComponent::_clazz_offset;
+int java_lang_reflect_RecordComponent::_name_offset;
+int java_lang_reflect_RecordComponent::_type_offset;
+int java_lang_reflect_RecordComponent::_accessor_offset;
+int java_lang_reflect_RecordComponent::_signature_offset;
+int java_lang_reflect_RecordComponent::_annotations_offset;
+int java_lang_reflect_RecordComponent::_typeAnnotations_offset;
+
 #define RECORDCOMPONENT_FIELDS_DO(macro) \
-  macro(clazz_offset,       k, "clazz",       class_signature,  false); \
-  macro(name_offset,        k, "name",        string_signature, false); \
-  macro(type_offset,        k, "type",        class_signature,  false); \
-  macro(accessor_offset,    k, "accessor",    reflect_method_signature, false); \
-  macro(signature_offset,   k, "signature",   string_signature, false); \
-  macro(annotations_offset, k, "annotations", byte_array_signature,     false); \
-  macro(typeAnnotations_offset, k, "typeAnnotations", byte_array_signature, false);
+  macro(_clazz_offset,       k, "clazz",       class_signature,  false); \
+  macro(_name_offset,        k, "name",        string_signature, false); \
+  macro(_type_offset,        k, "type",        class_signature,  false); \
+  macro(_accessor_offset,    k, "accessor",    reflect_method_signature, false); \
+  macro(_signature_offset,   k, "signature",   string_signature, false); \
+  macro(_annotations_offset, k, "annotations", byte_array_signature,     false); \
+  macro(_typeAnnotations_offset, k, "typeAnnotations", byte_array_signature, false);
 
 // Support for java_lang_reflect_RecordComponent
 void java_lang_reflect_RecordComponent::compute_offsets() {
   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
@@ -4792,47 +4773,47 @@
   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 }
 #endif
 
 void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {
-  element->obj_field_put(clazz_offset, value);
+  element->obj_field_put(_clazz_offset, value);
 }
 
 void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {
-  element->obj_field_put(name_offset, value);
+  element->obj_field_put(_name_offset, value);
 }
 
 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
-  element->obj_field_put(type_offset, value);
+  element->obj_field_put(_type_offset, value);
 }
 
 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
-  element->obj_field_put(accessor_offset, value);
+  element->obj_field_put(_accessor_offset, value);
 }
 
 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
-  element->obj_field_put(signature_offset, value);
+  element->obj_field_put(_signature_offset, value);
 }
 
 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
-  element->obj_field_put(annotations_offset, value);
+  element->obj_field_put(_annotations_offset, value);
 }
 
 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
-  element->obj_field_put(typeAnnotations_offset, value);
+  element->obj_field_put(_typeAnnotations_offset, value);
 }
 
 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
 
-// Compute non-hard-coded field offsets of all the classes in this file
+// Compute field offsets of all the classes in this file
 void JavaClasses::compute_offsets() {
   if (UseSharedSpaces) {
     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() && !(JvmtiExport::should_post_class_file_load_hook() &&
                                                          JvmtiExport::has_early_class_hook_env()),
                       "JavaClasses::compute_offsets() must be called in early JVMTI phase."));
     // None of the classes used by the rest of this function can be replaced by
-    // JMVTI ClassFileLoadHook.
+    // JVMTI ClassFileLoadHook.
     // We are safe to use the archived offsets, which have already been restored
     // by JavaClasses::serialize_offsets, without computing the offsets again.
     return;
   }
 
@@ -4873,14 +4854,14 @@
 }
 #endif
 
 #ifndef PRODUCT
 
-// These functions exist to assert the validity of hard-coded field offsets to guard
-// against changes in the class files
+// These functions exist to assert the validity of de-serialized offsets in boxing object as a sanity check.
 
-bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {
+bool JavaClasses::check_offset(const char *klass_name, int deserialized_offset, const char *field_name,
+                               const char* field_sig) {
   EXCEPTION_MARK;
   fieldDescriptor fd;
   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);
   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
   InstanceKlass* ik = InstanceKlass::cast(k);
@@ -4892,29 +4873,27 @@
   }
   if (fd.is_static()) {
     tty->print_cr("Nonstatic field %s.%s appears to be static", klass_name, field_name);
     return false;
   }
-  if (fd.offset() == hardcoded_offset ) {
+  if (fd.offset() == deserialized_offset ) {
     return true;
   } else {
-    tty->print_cr("Offset of nonstatic field %s.%s is hardcoded as %d but should really be %d.",
-                  klass_name, field_name, hardcoded_offset, fd.offset());
+    tty->print_cr("Offset of nonstatic field %s.%s is deserialized as %d but should really be %d.",
+                  klass_name, field_name, deserialized_offset, fd.offset());
     return false;
   }
 }
 
-// Check the hard-coded field offsets of all the classes in this file
-
 void JavaClasses::check_offsets() {
   bool valid = true;
 
 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
-  valid &= check_offset(klass_name, cpp_klass_name :: field_name ## _offset, #field_name, field_sig)
+  valid &= check_offset(klass_name, cpp_klass_name :: _##field_name ## _offset, #field_name, field_sig)
 
 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
-  valid &= check_offset(klass_name, cpp_klass_name :: long_ ## field_name ## _offset, #field_name, field_sig)
+  valid &= check_offset(klass_name, cpp_klass_name :: _##long_ ## field_name ## _offset, #field_name, field_sig)
 
   // Boxed primitive objects (java_lang_boxing_object)
 
   CHECK_OFFSET("java/lang/Boolean",   java_lang_boxing_object, value, "Z");
   CHECK_OFFSET("java/lang/Character", java_lang_boxing_object, value, "C");
@@ -4923,11 +4902,11 @@
   CHECK_OFFSET("java/lang/Byte",      java_lang_boxing_object, value, "B");
   CHECK_OFFSET("java/lang/Short",     java_lang_boxing_object, value, "S");
   CHECK_OFFSET("java/lang/Integer",   java_lang_boxing_object, value, "I");
   CHECK_LONG_OFFSET("java/lang/Long", java_lang_boxing_object, value, "J");
 
-  if (!valid) vm_exit_during_initialization("Hard-coded field offset verification failed");
+  if (!valid) vm_exit_during_initialization("Field offset verification failed");
 }
 
 #endif // PRODUCT
 
 int InjectedField::compute_offset() {

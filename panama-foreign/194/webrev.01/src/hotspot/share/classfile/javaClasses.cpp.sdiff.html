<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compactHashtable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 160     ik-&gt;print_on(&amp;ls);
 161 #endif //PRODUCT
 162     vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
 163   }
 164   dest_offset = fd.offset();
 165 }
 166 
 167 // Overloading to pass name as a string.
 168 static void compute_offset(int&amp; dest_offset, InstanceKlass* ik,
 169                            const char* name_string, Symbol* signature_symbol,
 170                            bool is_static = false) {
 171   TempNewSymbol name = SymbolTable::probe(name_string, (int)strlen(name_string));
 172   if (name == NULL) {
 173     ResourceMark rm;
 174     log_error(class)(&quot;Name %s should be in the SymbolTable since its class is loaded&quot;, name_string);
 175     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
 176   }
 177   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 178 }
 179 
<span class="line-removed"> 180 int java_lang_String::value_offset  = 0;</span>
<span class="line-removed"> 181 int java_lang_String::hash_offset   = 0;</span>
<span class="line-removed"> 182 int java_lang_String::hashIsZero_offset = 0;</span>
<span class="line-removed"> 183 int java_lang_String::coder_offset  = 0;</span>
<span class="line-removed"> 184 </span>
<span class="line-removed"> 185 bool java_lang_String::initialized  = false;</span>
<span class="line-removed"> 186 </span>
<span class="line-removed"> 187 bool java_lang_String::is_instance(oop obj) {</span>
<span class="line-removed"> 188   return is_instance_inlined(obj);</span>
<span class="line-removed"> 189 }</span>
 190 
 191 #if INCLUDE_CDS
 192 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
 193   f-&gt;do_u4((u4*)&amp;offset)
 194 #endif
 195 
 196 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
 197   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 198 














 199 #define STRING_FIELDS_DO(macro) \
<span class="line-modified"> 200   macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \</span>
<span class="line-modified"> 201   macro(hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \</span>
<span class="line-modified"> 202   macro(hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \</span>
<span class="line-modified"> 203   macro(coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);</span>
 204 
 205 void java_lang_String::compute_offsets() {
<span class="line-modified"> 206   if (initialized) {</span>
 207     return;
 208   }
 209 
 210   InstanceKlass* k = SystemDictionary::String_klass();
 211   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 212 
<span class="line-modified"> 213   initialized = true;</span>
 214 }
 215 
 216 #if INCLUDE_CDS
 217 void java_lang_String::serialize_offsets(SerializeClosure* f) {
 218   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
<span class="line-modified"> 219   f-&gt;do_bool(&amp;initialized);</span>
 220 }
 221 #endif
 222 
 223 class CompactStringsFixup : public FieldClosure {
 224 private:
 225   bool _value;
 226 
 227 public:
 228   CompactStringsFixup(bool value) : _value(value) {}
 229 
 230   void do_field(fieldDescriptor* fd) {
 231     if (fd-&gt;name() == vmSymbols::compact_strings_name()) {
 232       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
 233       assert(fd-&gt;field_holder() == SystemDictionary::String_klass(), &quot;Should be String&quot;);
 234       assert(mirror != NULL, &quot;String must have mirror already&quot;);
 235       mirror-&gt;bool_field_put(fd-&gt;offset(), _value);
 236     }
 237   }
 238 };
 239 
 240 void java_lang_String::set_compact_strings(bool value) {
 241   CompactStringsFixup fix(value);
 242   SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);
 243 }
 244 
 245 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
<span class="line-modified"> 246   assert(initialized, &quot;Must be initialized&quot;);</span>
 247   assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
 248 
 249   // Create the String object first, so there&#39;s a chance that the String
 250   // and the char array it points to end up in the same cache line.
 251   oop obj;
 252   obj = SystemDictionary::String_klass()-&gt;allocate_instance(CHECK_NH);
 253 
 254   // Create the char array.  The String object must be handlized here
 255   // because GC can happen as a result of the allocation attempt.
 256   Handle h_obj(THREAD, obj);
 257   int arr_length = is_latin1 ? length : length &lt;&lt; 1; // 2 bytes per UTF16.
 258   typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;
 259 
 260   // Point the String at the char array
 261   obj = h_obj();
 262   set_value(obj, buffer);
 263   // No need to zero the offset, allocation zero&#39;ed the entire String object
 264   set_coder(obj, is_latin1 ? CODER_LATIN1 : CODER_UTF16);
 265   return h_obj;
 266 }
</pre>
<hr />
<pre>
 524     } else {
 525       for (int index = 0; index &lt; length; index++) {
 526         result[index] = ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 527       }
 528     }
 529   } else {
 530     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), &quot;could not allocate Unicode string&quot;);
 531   }
 532   return result;
 533 }
 534 
 535 unsigned int java_lang_String::hash_code(oop java_string) {
 536   // The hash and hashIsZero fields are subject to a benign data race,
 537   // making it crucial to ensure that any observable result of the
 538   // calculation in this method stays correct under any possible read of
 539   // these fields. Necessary restrictions to allow this to be correct
 540   // without explicit memory fences or similar concurrency primitives is
 541   // that we can ever only write to one of these two fields for a given
 542   // String instance, and that the computation is idempotent and derived
 543   // from immutable state
<span class="line-modified"> 544   assert(initialized &amp;&amp; (hash_offset &gt; 0) &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);</span>
 545   if (java_lang_String::hash_is_set(java_string)) {
<span class="line-modified"> 546     return java_string-&gt;int_field(hash_offset);</span>
 547   }
 548 
 549   typeArrayOop value = java_lang_String::value(java_string);
 550   int         length = java_lang_String::length(java_string, value);
 551   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 552 
 553   unsigned int hash = 0;
 554   if (length &gt; 0) {
 555     if (is_latin1) {
 556       hash = java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);
 557     } else {
 558       hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);
 559     }
 560   }
 561 
 562   if (hash != 0) {
<span class="line-modified"> 563     java_string-&gt;int_field_put(hash_offset, hash);</span>
 564   } else {
<span class="line-modified"> 565     java_string-&gt;bool_field_put(hashIsZero_offset, true);</span>
 566   }
 567   return hash;
 568 }
 569 
 570 char* java_lang_String::as_quoted_ascii(oop java_string) {
 571   typeArrayOop value  = java_lang_String::value(java_string);
 572   int          length = java_lang_String::length(java_string, value);
 573   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 574 
 575   if (length == 0) return NULL;
 576 
 577   char* result;
 578   int result_length;
 579   if (!is_latin1) {
 580     jchar* base = value-&gt;char_at_addr(0);
 581     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 582     result = NEW_RESOURCE_ARRAY(char, result_length);
 583     UNICODE::as_quoted_ascii(base, length, result, result_length);
 584   } else {
 585     jbyte* base = value-&gt;byte_at_addr(0);
</pre>
<hr />
<pre>
 777   typeArrayOop value  = java_lang_String::value_no_keepalive(java_string);
 778 
 779   if (value == NULL) {
 780     // This can happen if, e.g., printing a String
 781     // object before its initializer has been called
 782     st-&gt;print(&quot;NULL&quot;);
 783     return;
 784   }
 785 
 786   int length = java_lang_String::length(java_string, value);
 787   bool is_latin1 = java_lang_String::is_latin1(java_string);
 788 
 789   st-&gt;print(&quot;\&quot;&quot;);
 790   for (int index = 0; index &lt; length; index++) {
 791     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 792                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 793   }
 794   st-&gt;print(&quot;\&quot;&quot;);
 795 }
 796 




















 797 
 798 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 799   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 800   if (fd-&gt;has_initial_value()) {
 801     BasicType t = fd-&gt;field_type();
 802     switch (t) {
 803       case T_BYTE:
 804         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 805               break;
 806       case T_BOOLEAN:
 807         mirror()-&gt;bool_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 808               break;
 809       case T_CHAR:
 810         mirror()-&gt;char_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 811               break;
 812       case T_SHORT:
 813         mirror()-&gt;short_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 814               break;
 815       case T_INT:
 816         mirror()-&gt;int_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
</pre>
<hr />
<pre>
1601   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1602   if (is_primitive(java_class)) {
1603     if (reference_klass != NULL)
1604       (*reference_klass) = NULL;
1605     return primitive_type(java_class);
1606   } else {
1607     if (reference_klass != NULL)
1608       (*reference_klass) = as_Klass(java_class);
1609     return T_OBJECT;
1610   }
1611 }
1612 
1613 
1614 oop java_lang_Class::primitive_mirror(BasicType t) {
1615   oop mirror = Universe::java_mirror(t);
1616   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1617   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1618   return mirror;
1619 }
1620 
<span class="line-removed">1621 bool java_lang_Class::offsets_computed = false;</span>
<span class="line-removed">1622 int  java_lang_Class::classRedefinedCount_offset = -1;</span>
<span class="line-removed">1623 </span>
1624 #define CLASS_FIELDS_DO(macro) \
<span class="line-modified">1625   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \</span>
<span class="line-modified">1626   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \</span>
<span class="line-modified">1627   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \</span>
<span class="line-modified">1628   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \</span>
<span class="line-modified">1629   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \</span>
<span class="line-modified">1630   macro(_classData_offset,          k, &quot;classData&quot;,           object_signature,      false);</span>
1631 
1632 void java_lang_Class::compute_offsets() {
<span class="line-modified">1633   if (offsets_computed) {</span>
1634     return;
1635   }
1636 
<span class="line-modified">1637   offsets_computed = true;</span>
1638 
1639   InstanceKlass* k = SystemDictionary::Class_klass();
1640   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1641 
1642   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1643   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1644   // GC treats them the same.
1645   _init_lock_offset = _component_mirror_offset;
1646 
1647   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1648 }
1649 
1650 #if INCLUDE_CDS
1651 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
<span class="line-modified">1652   f-&gt;do_bool(&amp;offsets_computed);</span>
1653   f-&gt;do_u4((u4*)&amp;_init_lock_offset);
1654 
1655   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1656 
1657   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
1658 }
1659 #endif
1660 
1661 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
<span class="line-modified">1662   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">1663   return the_class_mirror-&gt;int_field(classRedefinedCount_offset);</span>
1664 }
1665 
1666 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
<span class="line-modified">1667   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">1668   the_class_mirror-&gt;int_field_put(classRedefinedCount_offset, value);</span>
1669 }
1670 
1671 
1672 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
1673 //       platform thread structure, and a eetop offset which was used for thread
1674 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
1675 //       merged, so in the HotSpot VM we just use the eetop field for the thread
1676 //       instead of the privateInfo_offset.
1677 //
1678 // Note: The stackSize field is only present starting in 1.4.
1679 
<span class="line-modified">1680 int java_lang_Thread::_name_offset = 0;</span>
<span class="line-modified">1681 int java_lang_Thread::_group_offset = 0;</span>
<span class="line-modified">1682 int java_lang_Thread::_contextClassLoader_offset = 0;</span>
<span class="line-modified">1683 int java_lang_Thread::_inheritedAccessControlContext_offset = 0;</span>
<span class="line-modified">1684 int java_lang_Thread::_priority_offset = 0;</span>
<span class="line-modified">1685 int java_lang_Thread::_eetop_offset = 0;</span>
<span class="line-modified">1686 int java_lang_Thread::_interrupted_offset = 0;</span>
<span class="line-modified">1687 int java_lang_Thread::_daemon_offset = 0;</span>
<span class="line-modified">1688 int java_lang_Thread::_stillborn_offset = 0;</span>
<span class="line-modified">1689 int java_lang_Thread::_stackSize_offset = 0;</span>
<span class="line-modified">1690 int java_lang_Thread::_tid_offset = 0;</span>
<span class="line-modified">1691 int java_lang_Thread::_thread_status_offset = 0;</span>
<span class="line-modified">1692 int java_lang_Thread::_park_blocker_offset = 0;</span>
1693 
1694 #define THREAD_FIELDS_DO(macro) \
1695   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
1696   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
1697   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
1698   macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
1699   macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
1700   macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
1701   macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
1702   macro(_interrupted_offset,   k, &quot;interrupted&quot;, bool_signature, false); \
1703   macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
1704   macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
1705   macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
1706   macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
1707   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false)
1708 
1709 void java_lang_Thread::compute_offsets() {
1710   assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
1711 
1712   InstanceKlass* k = SystemDictionary::Thread_klass();
</pre>
<hr />
<pre>
1834 
1835 oop java_lang_Thread::park_blocker(oop java_thread) {
1836   return java_thread-&gt;obj_field(_park_blocker_offset);
1837 }
1838 
1839 const char* java_lang_Thread::thread_status_name(oop java_thread) {
1840   ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1841   switch (status) {
1842     case NEW                      : return &quot;NEW&quot;;
1843     case RUNNABLE                 : return &quot;RUNNABLE&quot;;
1844     case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
1845     case IN_OBJECT_WAIT           : return &quot;WAITING (on object monitor)&quot;;
1846     case IN_OBJECT_WAIT_TIMED     : return &quot;TIMED_WAITING (on object monitor)&quot;;
1847     case PARKED                   : return &quot;WAITING (parking)&quot;;
1848     case PARKED_TIMED             : return &quot;TIMED_WAITING (parking)&quot;;
1849     case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
1850     case TERMINATED               : return &quot;TERMINATED&quot;;
1851     default                       : return &quot;UNKNOWN&quot;;
1852   };
1853 }
<span class="line-modified">1854 int java_lang_ThreadGroup::_parent_offset = 0;</span>
<span class="line-modified">1855 int java_lang_ThreadGroup::_name_offset = 0;</span>
<span class="line-modified">1856 int java_lang_ThreadGroup::_threads_offset = 0;</span>
<span class="line-modified">1857 int java_lang_ThreadGroup::_groups_offset = 0;</span>
<span class="line-modified">1858 int java_lang_ThreadGroup::_maxPriority_offset = 0;</span>
<span class="line-modified">1859 int java_lang_ThreadGroup::_destroyed_offset = 0;</span>
<span class="line-modified">1860 int java_lang_ThreadGroup::_daemon_offset = 0;</span>
<span class="line-modified">1861 int java_lang_ThreadGroup::_nthreads_offset = 0;</span>
<span class="line-modified">1862 int java_lang_ThreadGroup::_ngroups_offset = 0;</span>
1863 
1864 oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
1865   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1866   return java_thread_group-&gt;obj_field(_parent_offset);
1867 }
1868 
1869 // (&quot;name as oop&quot; accessor is not necessary)
1870 
1871 const char* java_lang_ThreadGroup::name(oop java_thread_group) {
1872   oop name = java_thread_group-&gt;obj_field(_name_offset);
1873   // ThreadGroup.name can be null
1874   if (name != NULL) {
1875     return java_lang_String::as_utf8_string(name);
1876   }
1877   return NULL;
1878 }
1879 
1880 int java_lang_ThreadGroup::nthreads(oop java_thread_group) {
1881   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1882   return java_thread_group-&gt;int_field(_nthreads_offset);
</pre>
<hr />
<pre>
1922   macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature, false); \
1923   macro(_maxPriority_offset, k, vmSymbols::maxPriority_name(), int_signature,               false); \
1924   macro(_destroyed_offset,   k, vmSymbols::destroyed_name(),   bool_signature,              false); \
1925   macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,              false); \
1926   macro(_nthreads_offset,    k, vmSymbols::nthreads_name(),    int_signature,               false); \
1927   macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,               false)
1928 
1929 void java_lang_ThreadGroup::compute_offsets() {
1930   assert(_parent_offset == 0, &quot;offsets should be initialized only once&quot;);
1931 
1932   InstanceKlass* k = SystemDictionary::ThreadGroup_klass();
1933   THREADGROUP_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1934 }
1935 
1936 #if INCLUDE_CDS
1937 void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
1938   THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1939 }
1940 #endif
1941 








1942 #define THROWABLE_FIELDS_DO(macro) \
<span class="line-modified">1943   macro(backtrace_offset,     k, &quot;backtrace&quot;,     object_signature,                  false); \</span>
<span class="line-modified">1944   macro(detailMessage_offset, k, &quot;detailMessage&quot;, string_signature,                  false); \</span>
<span class="line-modified">1945   macro(stackTrace_offset,    k, &quot;stackTrace&quot;,    java_lang_StackTraceElement_array, false); \</span>
<span class="line-modified">1946   macro(depth_offset,         k, &quot;depth&quot;,         int_signature,                     false); \</span>
<span class="line-modified">1947   macro(static_unassigned_stacktrace_offset, k, &quot;UNASSIGNED_STACK&quot;, java_lang_StackTraceElement_array, true)</span>
1948 
1949 void java_lang_Throwable::compute_offsets() {
1950   InstanceKlass* k = SystemDictionary::Throwable_klass();
1951   THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1952 }
1953 
1954 #if INCLUDE_CDS
1955 void java_lang_Throwable::serialize_offsets(SerializeClosure* f) {
1956   THROWABLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1957 }
1958 #endif
1959 
1960 oop java_lang_Throwable::unassigned_stacktrace() {
1961   InstanceKlass* ik = SystemDictionary::Throwable_klass();
1962   oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">1963   return base-&gt;obj_field(static_unassigned_stacktrace_offset);</span>
1964 }
1965 
1966 oop java_lang_Throwable::backtrace(oop throwable) {
<span class="line-modified">1967   return throwable-&gt;obj_field_acquire(backtrace_offset);</span>
1968 }
1969 
1970 
1971 void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
<span class="line-modified">1972   throwable-&gt;release_obj_field_put(backtrace_offset, value);</span>
1973 }
1974 
1975 int java_lang_Throwable::depth(oop throwable) {
<span class="line-modified">1976   return throwable-&gt;int_field(depth_offset);</span>
1977 }
1978 
1979 void java_lang_Throwable::set_depth(oop throwable, int value) {
<span class="line-modified">1980   throwable-&gt;int_field_put(depth_offset, value);</span>
1981 }
1982 
1983 oop java_lang_Throwable::message(oop throwable) {
<span class="line-modified">1984   return throwable-&gt;obj_field(detailMessage_offset);</span>
1985 }
1986 
1987 
1988 // Return Symbol for detailed_message or NULL
1989 Symbol* java_lang_Throwable::detail_message(oop throwable) {
1990   PRESERVE_EXCEPTION_MARK;  // Keep original exception
1991   oop detailed_message = java_lang_Throwable::message(throwable);
1992   if (detailed_message != NULL) {
1993     return java_lang_String::as_symbol(detailed_message);
1994   }
1995   return NULL;
1996 }
1997 
1998 void java_lang_Throwable::set_message(oop throwable, oop value) {
<span class="line-modified">1999   throwable-&gt;obj_field_put(detailMessage_offset, value);</span>
2000 }
2001 
2002 
2003 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
<span class="line-modified">2004   throwable-&gt;obj_field_put(stackTrace_offset, st_element_array);</span>
2005 }
2006 
2007 void java_lang_Throwable::clear_stacktrace(oop throwable) {
2008   set_stacktrace(throwable, NULL);
2009 }
2010 
2011 
2012 void java_lang_Throwable::print(oop throwable, outputStream* st) {
2013   ResourceMark rm;
2014   Klass* k = throwable-&gt;klass();
2015   assert(k != NULL, &quot;just checking&quot;);
2016   st-&gt;print(&quot;%s&quot;, k-&gt;external_name());
2017   oop msg = message(throwable);
2018   if (msg != NULL) {
2019     st-&gt;print(&quot;: %s&quot;, java_lang_String::as_utf8_string(msg));
2020   }
2021 }
2022 
2023 // After this many redefines, the stack trace is unreliable.
2024 const int MAX_VERSION = USHRT_MAX;
</pre>
<hr />
<pre>
2763   line_number = Backtrace::get_line_number(method(), bci);
2764 }
2765 
2766 #if INCLUDE_JVMCI
2767 void java_lang_StackTraceElement::decode(const methodHandle&amp; method, int bci,
2768                                          Symbol*&amp; filename, int&amp; line_number, TRAPS) {
2769   ResourceMark rm(THREAD);
2770   HandleMark hm(THREAD);
2771 
2772   filename = NULL;
2773   line_number = -1;
2774 
2775   oop source_file;
2776   int version = method-&gt;constants()-&gt;version();
2777   InstanceKlass* holder = method-&gt;method_holder();
2778   Handle java_class(THREAD, holder-&gt;java_mirror());
2779   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
2780 }
2781 #endif // INCLUDE_JVMCI
2782 























2783 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
2784   HandleMark hm(THREAD);
2785   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
2786   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
2787   // we should expand MemberName::name when Throwable uses StackTrace
2788   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
2789   return method;
2790 }
2791 
2792 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS) {
2793   // set Method* or mid/cpref
2794   HandleMark hm(THREAD);
2795   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));
2796   InstanceKlass* ik = method-&gt;method_holder();
2797   CallInfo info(method(), ik, CHECK);
2798   MethodHandles::init_method_MemberName(mname, info);
2799   // set bci
2800   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
2801   // method may be redefined; store the version
2802   int version = method-&gt;constants()-&gt;version();
2803   assert((jushort)version == version, &quot;version should be short&quot;);
2804   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
2805 }
2806 
2807 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
2808   ResourceMark rm(THREAD);
2809   HandleMark hm(THREAD);
2810   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
2811   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
2812   InstanceKlass* holder = InstanceKlass::cast(clazz);
2813   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
2814 
2815   short version = stackFrame-&gt;short_field(_version_offset);
2816   int bci = stackFrame-&gt;int_field(_bci_offset);
2817   Symbol* name = method-&gt;name();
2818   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),
2819                                        version, bci, name, CHECK);
2820 }
2821 
<span class="line-modified">2822 #define STACKFRAMEINFO_FIELDS_DO(macro) \</span>
<span class="line-modified">2823   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \</span>
<span class="line-removed">2824   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false)</span>
<span class="line-removed">2825 </span>
<span class="line-removed">2826 void java_lang_StackFrameInfo::compute_offsets() {</span>
<span class="line-removed">2827   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();</span>
<span class="line-removed">2828   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-removed">2829   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);</span>
2830 }
2831 
<span class="line-modified">2832 #if INCLUDE_CDS</span>
<span class="line-modified">2833 void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-modified">2834   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-removed">2835   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);</span>
2836 }
<span class="line-modified">2837 #endif</span>




2838 
2839 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
2840   macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
2841   macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
2842   macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
2843   macro(_mode_offset,       k, &quot;mode&quot;,        int_signature,          false)
2844 
2845 void java_lang_LiveStackFrameInfo::compute_offsets() {
2846   InstanceKlass* k = SystemDictionary::LiveStackFrameInfo_klass();
2847   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2848 }
2849 
2850 #if INCLUDE_CDS
2851 void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
2852   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2853 }
2854 #endif
2855 





















2856 #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
<span class="line-modified">2857   macro(override_offset, k, &quot;override&quot;, bool_signature, false)</span>
2858 
2859 void java_lang_reflect_AccessibleObject::compute_offsets() {
2860   InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
2861   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2862 }
2863 
2864 #if INCLUDE_CDS
2865 void java_lang_reflect_AccessibleObject::serialize_offsets(SerializeClosure* f) {
2866   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2867 }
2868 #endif
2869 
2870 jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
<span class="line-modified">2871   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2872   return (jboolean) reflect-&gt;bool_field(override_offset);</span>
2873 }
2874 
2875 void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
<span class="line-modified">2876   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2877   reflect-&gt;bool_field_put(override_offset, (int) value);</span>
2878 }
2879 














2880 #define METHOD_FIELDS_DO(macro) \
<span class="line-modified">2881   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \</span>
<span class="line-modified">2882   macro(name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \</span>
<span class="line-modified">2883   macro(returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \</span>
<span class="line-modified">2884   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">2885   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">2886   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \</span>
<span class="line-modified">2887   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \</span>
<span class="line-modified">2888   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \</span>
<span class="line-modified">2889   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \</span>
<span class="line-modified">2890   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \</span>
<span class="line-modified">2891   macro(annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);</span>
2892 
2893 void java_lang_reflect_Method::compute_offsets() {
2894   InstanceKlass* k = SystemDictionary::reflect_Method_klass();
2895   METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2896 }
2897 
2898 #if INCLUDE_CDS
2899 void java_lang_reflect_Method::serialize_offsets(SerializeClosure* f) {
2900   METHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2901 }
2902 #endif
2903 
2904 Handle java_lang_reflect_Method::create(TRAPS) {
2905   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2906   Klass* klass = SystemDictionary::reflect_Method_klass();
2907   // This class is eagerly initialized during VM initialization, since we keep a refence
2908   // to one of the methods
2909   assert(InstanceKlass::cast(klass)-&gt;is_initialized(), &quot;must be initialized&quot;);
2910   return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(THREAD);
2911 }
2912 
2913 oop java_lang_reflect_Method::clazz(oop reflect) {
<span class="line-modified">2914   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2915   return reflect-&gt;obj_field(clazz_offset);</span>
2916 }
2917 
2918 void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
<span class="line-modified">2919   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2920    reflect-&gt;obj_field_put(clazz_offset, value);</span>
2921 }
2922 
2923 int java_lang_reflect_Method::slot(oop reflect) {
<span class="line-modified">2924   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2925   return reflect-&gt;int_field(slot_offset);</span>
2926 }
2927 
2928 void java_lang_reflect_Method::set_slot(oop reflect, int value) {
<span class="line-modified">2929   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2930   reflect-&gt;int_field_put(slot_offset, value);</span>
2931 }
2932 
2933 void java_lang_reflect_Method::set_name(oop method, oop value) {
<span class="line-modified">2934   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2935   method-&gt;obj_field_put(name_offset, value);</span>
2936 }
2937 
2938 oop java_lang_reflect_Method::return_type(oop method) {
<span class="line-modified">2939   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2940   return method-&gt;obj_field(returnType_offset);</span>
2941 }
2942 
2943 void java_lang_reflect_Method::set_return_type(oop method, oop value) {
<span class="line-modified">2944   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2945   method-&gt;obj_field_put(returnType_offset, value);</span>
2946 }
2947 
2948 oop java_lang_reflect_Method::parameter_types(oop method) {
<span class="line-modified">2949   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2950   return method-&gt;obj_field(parameterTypes_offset);</span>
2951 }
2952 
2953 void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
<span class="line-modified">2954   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2955   method-&gt;obj_field_put(parameterTypes_offset, value);</span>
2956 }
2957 
2958 void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
<span class="line-modified">2959   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2960   method-&gt;obj_field_put(exceptionTypes_offset, value);</span>
2961 }
2962 
2963 void java_lang_reflect_Method::set_modifiers(oop method, int value) {
<span class="line-modified">2964   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2965   method-&gt;int_field_put(modifiers_offset, value);</span>
2966 }
2967 
2968 void java_lang_reflect_Method::set_signature(oop method, oop value) {
<span class="line-modified">2969   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2970   method-&gt;obj_field_put(signature_offset, value);</span>
2971 }
2972 
2973 void java_lang_reflect_Method::set_annotations(oop method, oop value) {
<span class="line-modified">2974   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2975   method-&gt;obj_field_put(annotations_offset, value);</span>
2976 }
2977 
2978 void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
<span class="line-modified">2979   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2980   method-&gt;obj_field_put(parameter_annotations_offset, value);</span>
2981 }
2982 
2983 void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
<span class="line-modified">2984   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2985   method-&gt;obj_field_put(annotation_default_offset, value);</span>
2986 }
2987 









2988 #define CONSTRUCTOR_FIELDS_DO(macro) \
<span class="line-modified">2989   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \</span>
<span class="line-modified">2990   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">2991   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">2992   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \</span>
<span class="line-modified">2993   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \</span>
<span class="line-modified">2994   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \</span>
<span class="line-modified">2995   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \</span>
<span class="line-modified">2996   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);</span>
2997 
2998 void java_lang_reflect_Constructor::compute_offsets() {
2999   InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
3000   CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3001 }
3002 
3003 #if INCLUDE_CDS
3004 void java_lang_reflect_Constructor::serialize_offsets(SerializeClosure* f) {
3005   CONSTRUCTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3006 }
3007 #endif
3008 
3009 Handle java_lang_reflect_Constructor::create(TRAPS) {
3010   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3011   Symbol* name = vmSymbols::java_lang_reflect_Constructor();
3012   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3013   InstanceKlass* ik = InstanceKlass::cast(k);
3014   // Ensure it is initialized
3015   ik-&gt;initialize(CHECK_NH);
3016   return ik-&gt;allocate_instance_handle(THREAD);
3017 }
3018 
3019 oop java_lang_reflect_Constructor::clazz(oop reflect) {
<span class="line-modified">3020   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3021   return reflect-&gt;obj_field(clazz_offset);</span>
3022 }
3023 
3024 void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
<span class="line-modified">3025   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3026    reflect-&gt;obj_field_put(clazz_offset, value);</span>
3027 }
3028 
3029 oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
<span class="line-modified">3030   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3031   return constructor-&gt;obj_field(parameterTypes_offset);</span>
3032 }
3033 
3034 void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
<span class="line-modified">3035   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3036   constructor-&gt;obj_field_put(parameterTypes_offset, value);</span>
3037 }
3038 
3039 void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
<span class="line-modified">3040   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3041   constructor-&gt;obj_field_put(exceptionTypes_offset, value);</span>
3042 }
3043 
3044 int java_lang_reflect_Constructor::slot(oop reflect) {
<span class="line-modified">3045   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3046   return reflect-&gt;int_field(slot_offset);</span>
3047 }
3048 
3049 void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
<span class="line-modified">3050   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3051   reflect-&gt;int_field_put(slot_offset, value);</span>
3052 }
3053 
3054 void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
<span class="line-modified">3055   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3056   constructor-&gt;int_field_put(modifiers_offset, value);</span>
3057 }
3058 
3059 void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
<span class="line-modified">3060   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3061   constructor-&gt;obj_field_put(signature_offset, value);</span>
3062 }
3063 
3064 void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
<span class="line-modified">3065   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3066   constructor-&gt;obj_field_put(annotations_offset, value);</span>
3067 }
3068 
3069 void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
<span class="line-modified">3070   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3071   method-&gt;obj_field_put(parameter_annotations_offset, value);</span>
3072 }
3073 








3074 #define FIELD_FIELDS_DO(macro) \
<span class="line-modified">3075   macro(clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \</span>
<span class="line-modified">3076   macro(name_offset,      k, vmSymbols::name_name(),      string_signature, false); \</span>
<span class="line-modified">3077   macro(type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \</span>
<span class="line-modified">3078   macro(slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \</span>
<span class="line-modified">3079   macro(modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \</span>
<span class="line-modified">3080   macro(signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \</span>
<span class="line-modified">3081   macro(annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);</span>
3082 
3083 void java_lang_reflect_Field::compute_offsets() {
3084   InstanceKlass* k = SystemDictionary::reflect_Field_klass();
3085   FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3086 }
3087 
3088 #if INCLUDE_CDS
3089 void java_lang_reflect_Field::serialize_offsets(SerializeClosure* f) {
3090   FIELD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3091 }
3092 #endif
3093 
3094 Handle java_lang_reflect_Field::create(TRAPS) {
3095   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3096   Symbol* name = vmSymbols::java_lang_reflect_Field();
3097   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3098   InstanceKlass* ik = InstanceKlass::cast(k);
3099   // Ensure it is initialized
3100   ik-&gt;initialize(CHECK_NH);
3101   return ik-&gt;allocate_instance_handle(THREAD);
3102 }
3103 
3104 oop java_lang_reflect_Field::clazz(oop reflect) {
<span class="line-modified">3105   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3106   return reflect-&gt;obj_field(clazz_offset);</span>
3107 }
3108 
3109 void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
<span class="line-modified">3110   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3111    reflect-&gt;obj_field_put(clazz_offset, value);</span>
3112 }
3113 
3114 oop java_lang_reflect_Field::name(oop field) {
<span class="line-modified">3115   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3116   return field-&gt;obj_field(name_offset);</span>
3117 }
3118 
3119 void java_lang_reflect_Field::set_name(oop field, oop value) {
<span class="line-modified">3120   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3121   field-&gt;obj_field_put(name_offset, value);</span>
3122 }
3123 
3124 oop java_lang_reflect_Field::type(oop field) {
<span class="line-modified">3125   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3126   return field-&gt;obj_field(type_offset);</span>
3127 }
3128 
3129 void java_lang_reflect_Field::set_type(oop field, oop value) {
<span class="line-modified">3130   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3131   field-&gt;obj_field_put(type_offset, value);</span>
3132 }
3133 
3134 int java_lang_reflect_Field::slot(oop reflect) {
<span class="line-modified">3135   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3136   return reflect-&gt;int_field(slot_offset);</span>
3137 }
3138 
3139 void java_lang_reflect_Field::set_slot(oop reflect, int value) {
<span class="line-modified">3140   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3141   reflect-&gt;int_field_put(slot_offset, value);</span>
3142 }
3143 
3144 int java_lang_reflect_Field::modifiers(oop field) {
<span class="line-modified">3145   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3146   return field-&gt;int_field(modifiers_offset);</span>
3147 }
3148 
3149 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
<span class="line-modified">3150   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3151   field-&gt;int_field_put(modifiers_offset, value);</span>
3152 }
3153 
3154 void java_lang_reflect_Field::set_signature(oop field, oop value) {
<span class="line-modified">3155   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3156   field-&gt;obj_field_put(signature_offset, value);</span>
3157 }
3158 
3159 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
<span class="line-modified">3160   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3161   field-&gt;obj_field_put(annotations_offset, value);</span>
3162 }
3163 
3164 oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {
3165   // Allocate java.lang.reflect.RecordComponent instance
3166   HandleMark hm(THREAD);
3167   InstanceKlass* ik = SystemDictionary::RecordComponent_klass();
3168   assert(ik != NULL, &quot;must be loaded&quot;);
3169   ik-&gt;initialize(CHECK_NULL);
3170 
3171   Handle element = ik-&gt;allocate_instance_handle(CHECK_NULL);
3172 
3173   Handle decl_class(THREAD, holder-&gt;java_mirror());
3174   java_lang_reflect_RecordComponent::set_clazz(element(), decl_class());
3175 
3176   Symbol* name = holder-&gt;constants()-&gt;symbol_at(component-&gt;name_index()); // name_index is a utf8
3177   oop component_name = StringTable::intern(name, CHECK_NULL);
3178   java_lang_reflect_RecordComponent::set_name(element(), component_name);
3179 
3180   Symbol* type = holder-&gt;constants()-&gt;symbol_at(component-&gt;descriptor_index());
3181   Handle component_type_h =
</pre>
<hr />
<pre>
3202   }
3203 
3204   int sig_index = component-&gt;generic_signature_index();
3205   if (sig_index &gt; 0) {
3206     Symbol* sig = holder-&gt;constants()-&gt;symbol_at(sig_index); // sig_index is a utf8
3207     oop component_sig = StringTable::intern(sig, CHECK_NULL);
3208     java_lang_reflect_RecordComponent::set_signature(element(), component_sig);
3209   } else {
3210     java_lang_reflect_RecordComponent::set_signature(element(), NULL);
3211   }
3212 
3213   typeArrayOop annotation_oop = Annotations::make_java_array(component-&gt;annotations(), CHECK_NULL);
3214   java_lang_reflect_RecordComponent::set_annotations(element(), annotation_oop);
3215 
3216   typeArrayOop type_annotation_oop = Annotations::make_java_array(component-&gt;type_annotations(), CHECK_NULL);
3217   java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);
3218 
3219   return element();
3220 }
3221 


3222 #define CONSTANTPOOL_FIELDS_DO(macro) \
3223   macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
3224 
3225 void reflect_ConstantPool::compute_offsets() {
3226   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3227   // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
3228   CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3229 }
3230 
3231 #if INCLUDE_CDS
3232 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
3233   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3234 }
3235 #endif
3236 





3237 #define PARAMETER_FIELDS_DO(macro) \
<span class="line-modified">3238   macro(name_offset,        k, vmSymbols::name_name(),        string_signature, false); \</span>
<span class="line-modified">3239   macro(modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \</span>
<span class="line-modified">3240   macro(index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \</span>
<span class="line-modified">3241   macro(executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)</span>
3242 
3243 void java_lang_reflect_Parameter::compute_offsets() {
3244   InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
3245   PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3246 }
3247 
3248 #if INCLUDE_CDS
3249 void java_lang_reflect_Parameter::serialize_offsets(SerializeClosure* f) {
3250   PARAMETER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3251 }
3252 #endif
3253 
3254 Handle java_lang_reflect_Parameter::create(TRAPS) {
3255   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3256   Symbol* name = vmSymbols::java_lang_reflect_Parameter();
3257   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3258   InstanceKlass* ik = InstanceKlass::cast(k);
3259   // Ensure it is initialized
3260   ik-&gt;initialize(CHECK_NH);
3261   return ik-&gt;allocate_instance_handle(THREAD);
3262 }
3263 
3264 oop java_lang_reflect_Parameter::name(oop param) {
<span class="line-modified">3265   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3266   return param-&gt;obj_field(name_offset);</span>
3267 }
3268 
3269 void java_lang_reflect_Parameter::set_name(oop param, oop value) {
<span class="line-modified">3270   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3271   param-&gt;obj_field_put(name_offset, value);</span>
3272 }
3273 
3274 int java_lang_reflect_Parameter::modifiers(oop param) {
<span class="line-modified">3275   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3276   return param-&gt;int_field(modifiers_offset);</span>
3277 }
3278 
3279 void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
<span class="line-modified">3280   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3281   param-&gt;int_field_put(modifiers_offset, value);</span>
3282 }
3283 
3284 int java_lang_reflect_Parameter::index(oop param) {
<span class="line-modified">3285   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3286   return param-&gt;int_field(index_offset);</span>
3287 }
3288 
3289 void java_lang_reflect_Parameter::set_index(oop param, int value) {
<span class="line-modified">3290   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3291   param-&gt;int_field_put(index_offset, value);</span>
3292 }
3293 
3294 oop java_lang_reflect_Parameter::executable(oop param) {
<span class="line-modified">3295   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3296   return param-&gt;obj_field(executable_offset);</span>
3297 }
3298 
3299 void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
<span class="line-modified">3300   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3301   param-&gt;obj_field_put(executable_offset, value);</span>
3302 }
3303 

3304 
<span class="line-modified">3305 int java_lang_Module::loader_offset;</span>
<span class="line-modified">3306 int java_lang_Module::name_offset;</span>
<span class="line-modified">3307 int java_lang_Module::_module_entry_offset = -1;</span>
3308 
3309 Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
3310   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3311   return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
3312                           vmSymbols::java_lang_module_init_signature(),
3313                           loader, module_name, CHECK_NH);
3314 }
3315 
3316 #define MODULE_FIELDS_DO(macro) \
<span class="line-modified">3317   macro(loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \</span>
<span class="line-modified">3318   macro(name_offset,    k, vmSymbols::name_name(),    string_signature,      false)</span>
3319 
3320 void java_lang_Module::compute_offsets() {
3321   InstanceKlass* k = SystemDictionary::Module_klass();
3322   MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3323   MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3324 }
3325 
3326 #if INCLUDE_CDS
3327 void java_lang_Module::serialize_offsets(SerializeClosure* f) {
3328   MODULE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3329   MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3330 }
3331 #endif
3332 
3333 oop java_lang_Module::loader(oop module) {
<span class="line-modified">3334   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3335   return module-&gt;obj_field(loader_offset);</span>
3336 }
3337 
3338 void java_lang_Module::set_loader(oop module, oop value) {
<span class="line-modified">3339   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3340   module-&gt;obj_field_put(loader_offset, value);</span>
3341 }
3342 
3343 oop java_lang_Module::name(oop module) {
<span class="line-modified">3344   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3345   return module-&gt;obj_field(name_offset);</span>
3346 }
3347 
3348 void java_lang_Module::set_name(oop module, oop value) {
<span class="line-modified">3349   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3350   module-&gt;obj_field_put(name_offset, value);</span>
3351 }
3352 
3353 ModuleEntry* java_lang_Module::module_entry(oop module) {
<span class="line-modified">3354   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);</span>
3355   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3356   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3357 
3358   ModuleEntry* module_entry = (ModuleEntry*)module-&gt;address_field(_module_entry_offset);
3359   if (module_entry == NULL) {
3360     // If the inject field containing the ModuleEntry* is null then return the
3361     // class loader&#39;s unnamed module.
3362     oop loader = java_lang_Module::loader(module);
3363     Handle h_loader = Handle(Thread::current(), loader);
3364     ClassLoaderData* loader_cld = SystemDictionary::register_loader(h_loader);
3365     return loader_cld-&gt;unnamed_module();
3366   }
3367   return module_entry;
3368 }
3369 
3370 void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
<span class="line-modified">3371   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);</span>
3372   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3373   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3374   module-&gt;address_field_put(_module_entry_offset, (address)module_entry);
3375 }
3376 
3377 Handle reflect_ConstantPool::create(TRAPS) {
3378   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3379   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3380   // Ensure it is initialized
3381   k-&gt;initialize(CHECK_NH);
3382   return k-&gt;allocate_instance_handle(THREAD);
3383 }
3384 
3385 
3386 void reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {
<span class="line-removed">3387   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
3388   oop mirror = value-&gt;pool_holder()-&gt;java_mirror();
3389   // Save the mirror to get back the constant pool.
3390   reflect-&gt;obj_field_put(_oop_offset, mirror);
3391 }
3392 
3393 ConstantPool* reflect_ConstantPool::get_cp(oop reflect) {
<span class="line-removed">3394   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
3395 
3396   oop mirror = reflect-&gt;obj_field(_oop_offset);
3397   Klass* k = java_lang_Class::as_Klass(mirror);
3398   assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
3399 
3400   // Get the constant pool back from the klass.  Since class redefinition
3401   // merges the new constant pool into the old, this is essentially the
3402   // same constant pool as the original.  If constant pool merging is
3403   // no longer done in the future, this will have to change to save
3404   // the original.
3405   return InstanceKlass::cast(k)-&gt;constants();
3406 }
3407 


3408 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3409   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3410 
3411 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3412   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3413   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3414 }
3415 
3416 #if INCLUDE_CDS
3417 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3418   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3419 }
3420 #endif
3421 



































































3422 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3423   Klass* k = SystemDictionary::box_klass(type);
3424   if (k == NULL)  return NULL;
3425   InstanceKlass* ik = InstanceKlass::cast(k);
3426   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_NULL);
3427   return ik-&gt;allocate_instance(THREAD);
3428 }
3429 
3430 
3431 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
3432   oop box = initialize_and_allocate(type, CHECK_NULL);
3433   if (box == NULL)  return NULL;
3434   switch (type) {
3435     case T_BOOLEAN:
<span class="line-modified">3436       box-&gt;bool_field_put(value_offset, value-&gt;z);</span>
3437       break;
3438     case T_CHAR:
<span class="line-modified">3439       box-&gt;char_field_put(value_offset, value-&gt;c);</span>
3440       break;
3441     case T_FLOAT:
<span class="line-modified">3442       box-&gt;float_field_put(value_offset, value-&gt;f);</span>
3443       break;
3444     case T_DOUBLE:
<span class="line-modified">3445       box-&gt;double_field_put(long_value_offset, value-&gt;d);</span>
3446       break;
3447     case T_BYTE:
<span class="line-modified">3448       box-&gt;byte_field_put(value_offset, value-&gt;b);</span>
3449       break;
3450     case T_SHORT:
<span class="line-modified">3451       box-&gt;short_field_put(value_offset, value-&gt;s);</span>
3452       break;
3453     case T_INT:
<span class="line-modified">3454       box-&gt;int_field_put(value_offset, value-&gt;i);</span>
3455       break;
3456     case T_LONG:
<span class="line-modified">3457       box-&gt;long_field_put(long_value_offset, value-&gt;j);</span>
3458       break;
3459     default:
3460       return NULL;
3461   }
3462   return box;
3463 }
3464 
3465 
3466 BasicType java_lang_boxing_object::basic_type(oop box) {
3467   if (box == NULL)  return T_ILLEGAL;
3468   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3469   if (type == T_OBJECT)         // &#39;unknown&#39; value returned by SD::bkt
3470     return T_ILLEGAL;
3471   return type;
3472 }
3473 
3474 
3475 BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
3476   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3477   switch (type) {
3478   case T_BOOLEAN:
<span class="line-modified">3479     value-&gt;z = box-&gt;bool_field(value_offset);</span>
3480     break;
3481   case T_CHAR:
<span class="line-modified">3482     value-&gt;c = box-&gt;char_field(value_offset);</span>
3483     break;
3484   case T_FLOAT:
<span class="line-modified">3485     value-&gt;f = box-&gt;float_field(value_offset);</span>
3486     break;
3487   case T_DOUBLE:
<span class="line-modified">3488     value-&gt;d = box-&gt;double_field(long_value_offset);</span>
3489     break;
3490   case T_BYTE:
<span class="line-modified">3491     value-&gt;b = box-&gt;byte_field(value_offset);</span>
3492     break;
3493   case T_SHORT:
<span class="line-modified">3494     value-&gt;s = box-&gt;short_field(value_offset);</span>
3495     break;
3496   case T_INT:
<span class="line-modified">3497     value-&gt;i = box-&gt;int_field(value_offset);</span>
3498     break;
3499   case T_LONG:
<span class="line-modified">3500     value-&gt;j = box-&gt;long_field(long_value_offset);</span>
3501     break;
3502   default:
3503     return T_ILLEGAL;
3504   } // end switch
3505   return type;
3506 }
3507 
3508 
3509 BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
3510   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3511   switch (type) {
3512   case T_BOOLEAN:
<span class="line-modified">3513     box-&gt;bool_field_put(value_offset, value-&gt;z);</span>
3514     break;
3515   case T_CHAR:
<span class="line-modified">3516     box-&gt;char_field_put(value_offset, value-&gt;c);</span>
3517     break;
3518   case T_FLOAT:
<span class="line-modified">3519     box-&gt;float_field_put(value_offset, value-&gt;f);</span>
3520     break;
3521   case T_DOUBLE:
<span class="line-modified">3522     box-&gt;double_field_put(long_value_offset, value-&gt;d);</span>
3523     break;
3524   case T_BYTE:
<span class="line-modified">3525     box-&gt;byte_field_put(value_offset, value-&gt;b);</span>
3526     break;
3527   case T_SHORT:
<span class="line-modified">3528     box-&gt;short_field_put(value_offset, value-&gt;s);</span>
3529     break;
3530   case T_INT:
<span class="line-modified">3531     box-&gt;int_field_put(value_offset, value-&gt;i);</span>
3532     break;
3533   case T_LONG:
<span class="line-modified">3534     box-&gt;long_field_put(long_value_offset, value-&gt;j);</span>
3535     break;
3536   default:
3537     return T_ILLEGAL;
3538   } // end switch
3539   return type;
3540 }
3541 
3542 
3543 void java_lang_boxing_object::print(BasicType type, jvalue* value, outputStream* st) {
3544   switch (type) {
3545   case T_BOOLEAN:   st-&gt;print(&quot;%s&quot;, value-&gt;z ? &quot;true&quot; : &quot;false&quot;);   break;
3546   case T_CHAR:      st-&gt;print(&quot;%d&quot;, value-&gt;c);                      break;
3547   case T_BYTE:      st-&gt;print(&quot;%d&quot;, value-&gt;b);                      break;
3548   case T_SHORT:     st-&gt;print(&quot;%d&quot;, value-&gt;s);                      break;
3549   case T_INT:       st-&gt;print(&quot;%d&quot;, value-&gt;i);                      break;
3550   case T_LONG:      st-&gt;print(JLONG_FORMAT, value-&gt;j);              break;
3551   case T_FLOAT:     st-&gt;print(&quot;%f&quot;, value-&gt;f);                      break;
3552   case T_DOUBLE:    st-&gt;print(&quot;%lf&quot;, value-&gt;d);                     break;
3553   default:          st-&gt;print(&quot;type %d?&quot;, type);                    break;
3554   }
3555 }
3556 
<span class="line-removed">3557 // Support for java_lang_ref_Reference</span>
<span class="line-removed">3558 </span>
<span class="line-removed">3559 bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {</span>
<span class="line-removed">3560   assert(obj != NULL, &quot;sanity&quot;);</span>
<span class="line-removed">3561   if (offset != java_lang_ref_Reference::referent_offset) {</span>
<span class="line-removed">3562     return false;</span>
<span class="line-removed">3563   }</span>
<span class="line-removed">3564 </span>
<span class="line-removed">3565   Klass* k = obj-&gt;klass();</span>
<span class="line-removed">3566   if (!k-&gt;is_instance_klass()) {</span>
<span class="line-removed">3567     return false;</span>
<span class="line-removed">3568   }</span>
<span class="line-removed">3569 </span>
<span class="line-removed">3570   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());</span>
<span class="line-removed">3571   bool is_reference = ik-&gt;reference_type() != REF_NONE;</span>
<span class="line-removed">3572   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);</span>
<span class="line-removed">3573   return is_reference;</span>
<span class="line-removed">3574 }</span>
<span class="line-removed">3575 </span>
<span class="line-removed">3576 #define REFERENCE_FIELDS_DO(macro) \</span>
<span class="line-removed">3577   macro(referent_offset,   k, &quot;referent&quot;, object_signature, false); \</span>
<span class="line-removed">3578   macro(queue_offset,      k, &quot;queue&quot;, referencequeue_signature, false); \</span>
<span class="line-removed">3579   macro(next_offset,       k, &quot;next&quot;, reference_signature, false); \</span>
<span class="line-removed">3580   macro(discovered_offset, k, &quot;discovered&quot;, reference_signature, false);</span>
<span class="line-removed">3581 </span>
<span class="line-removed">3582 void java_lang_ref_Reference::compute_offsets() {</span>
<span class="line-removed">3583   if (_offsets_initialized) {</span>
<span class="line-removed">3584     return;</span>
<span class="line-removed">3585   }</span>
<span class="line-removed">3586   _offsets_initialized = true;</span>
<span class="line-removed">3587   InstanceKlass* k = SystemDictionary::Reference_klass();</span>
<span class="line-removed">3588   REFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-removed">3589 }</span>
<span class="line-removed">3590 </span>
<span class="line-removed">3591 #if INCLUDE_CDS</span>
<span class="line-removed">3592 void java_lang_ref_Reference::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-removed">3593   f-&gt;do_bool(&amp;_offsets_initialized);</span>
<span class="line-removed">3594   REFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-removed">3595 }</span>
<span class="line-removed">3596 #endif</span>
<span class="line-removed">3597 </span>
<span class="line-removed">3598 #define BOXING_FIELDS_DO(macro) \</span>
<span class="line-removed">3599   macro(value_offset,      integerKlass, &quot;value&quot;, int_signature, false); \</span>
<span class="line-removed">3600   macro(long_value_offset, longKlass, &quot;value&quot;, long_signature, false);</span>
<span class="line-removed">3601 </span>
<span class="line-removed">3602 void java_lang_boxing_object::compute_offsets() {</span>
<span class="line-removed">3603   InstanceKlass* integerKlass = SystemDictionary::Integer_klass();</span>
<span class="line-removed">3604   InstanceKlass* longKlass = SystemDictionary::Long_klass();</span>
<span class="line-removed">3605   BOXING_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-removed">3606 }</span>
<span class="line-removed">3607 </span>
<span class="line-removed">3608 #if INCLUDE_CDS</span>
<span class="line-removed">3609 void java_lang_boxing_object::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-removed">3610   BOXING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-removed">3611 }</span>
<span class="line-removed">3612 #endif</span>
3613 
3614 // Support for java_lang_ref_SoftReference
3615 //
3616 



3617 #define SOFTREFERENCE_FIELDS_DO(macro) \
<span class="line-modified">3618   macro(timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \</span>
<span class="line-modified">3619   macro(static_clock_offset, k, &quot;clock&quot;,     long_signature, true)</span>
3620 
3621 void java_lang_ref_SoftReference::compute_offsets() {
3622   InstanceKlass* k = SystemDictionary::SoftReference_klass();
3623   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3624 }
3625 
3626 #if INCLUDE_CDS
3627 void java_lang_ref_SoftReference::serialize_offsets(SerializeClosure* f) {
3628   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3629 }
3630 #endif
3631 
3632 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
<span class="line-modified">3633   return ref-&gt;long_field(timestamp_offset);</span>
3634 }
3635 
3636 jlong java_lang_ref_SoftReference::clock() {
3637   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3638   oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">3639   return base-&gt;long_field(static_clock_offset);</span>
3640 }
3641 
3642 void java_lang_ref_SoftReference::set_clock(jlong value) {
3643   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3644   oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">3645   base-&gt;long_field_put(static_clock_offset, value);</span>
3646 }
3647 
3648 // Support for java_lang_invoke_DirectMethodHandle
3649 
3650 int java_lang_invoke_DirectMethodHandle::_member_offset;
3651 
3652 oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
3653   oop member_name = NULL;
3654   assert(oopDesc::is_oop(dmh) &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh),
3655          &quot;a DirectMethodHandle oop is expected&quot;);
<span class="line-modified">3656   return dmh-&gt;obj_field(member_offset_in_bytes());</span>
3657 }
3658 
3659 #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
3660   macro(_member_offset, k, &quot;member&quot;, java_lang_invoke_MemberName_signature, false)
3661 
3662 void java_lang_invoke_DirectMethodHandle::compute_offsets() {
3663   InstanceKlass* k = SystemDictionary::DirectMethodHandle_klass();
3664   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3665 }
3666 
3667 #if INCLUDE_CDS
3668 void java_lang_invoke_DirectMethodHandle::serialize_offsets(SerializeClosure* f) {
3669   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3670 }
3671 #endif
3672 
3673 // Support for java_lang_invoke_MethodHandle
3674 
3675 int java_lang_invoke_MethodHandle::_type_offset;
3676 int java_lang_invoke_MethodHandle::_form_offset;
</pre>
<hr />
<pre>
4054   InstanceKlass* k = SystemDictionary::Context_klass();
4055   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4056 }
4057 
4058 #if INCLUDE_CDS
4059 void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {
4060   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4061 }
4062 #endif
4063 
4064 DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {
4065   assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), &quot;&quot;);
4066   nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site-&gt;field_addr(_vmdependencies_offset);
4067   volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site-&gt;field_addr(_last_cleanup_offset);
4068   DependencyContext dep_ctx(vmdeps_addr, last_cleanup_addr);
4069   return dep_ctx;
4070 }
4071 
4072 // Support for java_security_AccessControlContext
4073 
<span class="line-modified">4074 int java_security_AccessControlContext::_context_offset = 0;</span>
<span class="line-modified">4075 int java_security_AccessControlContext::_privilegedContext_offset = 0;</span>
<span class="line-modified">4076 int java_security_AccessControlContext::_isPrivileged_offset = 0;</span>
<span class="line-modified">4077 int java_security_AccessControlContext::_isAuthorized_offset = -1;</span>
4078 
4079 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
4080   macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
4081   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4082   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4083   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4084 
4085 void java_security_AccessControlContext::compute_offsets() {
4086   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4087   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4088   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4089 }
4090 
4091 #if INCLUDE_CDS
4092 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4093   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4094 }
4095 #endif
4096 
4097 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4098   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
<span class="line-modified">4099   assert(_isAuthorized_offset != -1, &quot;offsets should have been initialized&quot;);</span>
4100   // Ensure klass is initialized
4101   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);
4102   // Allocate result
4103   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);
4104   // Fill in values
4105   result-&gt;obj_field_put(_context_offset, context());
4106   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4107   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4108   // whitelist AccessControlContexts created by the JVM
4109   result-&gt;bool_field_put(_isAuthorized_offset, true);
4110   return result;
4111 }
4112 
4113 
4114 // Support for java_lang_ClassLoader
4115 
<span class="line-modified">4116 bool java_lang_ClassLoader::offsets_computed = false;</span>
<span class="line-modified">4117 int  java_lang_ClassLoader::_loader_data_offset = -1;</span>
<span class="line-modified">4118 int  java_lang_ClassLoader::parallelCapable_offset = -1;</span>
<span class="line-modified">4119 int  java_lang_ClassLoader::name_offset = -1;</span>
<span class="line-modified">4120 int  java_lang_ClassLoader::nameAndId_offset = -1;</span>
<span class="line-modified">4121 int  java_lang_ClassLoader::unnamedModule_offset = -1;</span>
4122 
4123 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
4124   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4125   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4126   return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
4127 }
4128 
4129 ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
4130   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4131   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4132   return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
4133 }
4134 
4135 void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
4136   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4137   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4138   HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
4139 }
4140 
4141 #define CLASSLOADER_FIELDS_DO(macro) \
<span class="line-modified">4142   macro(parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \</span>
<span class="line-modified">4143   macro(name_offset,            k1, vmSymbols::name_name(), string_signature, false); \</span>
<span class="line-modified">4144   macro(nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \</span>
<span class="line-modified">4145   macro(unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \</span>
<span class="line-modified">4146   macro(parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)</span>
4147 
4148 void java_lang_ClassLoader::compute_offsets() {
<span class="line-removed">4149   assert(!offsets_computed, &quot;offsets should be initialized only once&quot;);</span>
<span class="line-removed">4150   offsets_computed = true;</span>
<span class="line-removed">4151 </span>
4152   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
4153   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4154 
4155   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4156 }
4157 
4158 #if INCLUDE_CDS
4159 void java_lang_ClassLoader::serialize_offsets(SerializeClosure* f) {
4160   CLASSLOADER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4161   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4162 }
4163 #endif
4164 
4165 oop java_lang_ClassLoader::parent(oop loader) {
4166   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4167   return loader-&gt;obj_field(parent_offset);</span>
4168 }
4169 
4170 // Returns the name field of this class loader.  If the name field has not
4171 // been set, null will be returned.
4172 oop java_lang_ClassLoader::name(oop loader) {
4173   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4174   return loader-&gt;obj_field(name_offset);</span>
4175 }
4176 
4177 // Returns the nameAndId field of this class loader. The format is
4178 // as follows:
4179 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
4180 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
4181 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
4182 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
4183 oop java_lang_ClassLoader::nameAndId(oop loader) {
4184   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4185   return loader-&gt;obj_field(nameAndId_offset);</span>
4186 }
4187 
4188 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
4189   assert(is_instance(loader), &quot;loader must be oop&quot;);
4190   assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
4191   oop acl = loader;
4192   debug_only(jint loop_count = 0);
4193   // This loop taken verbatim from ClassLoader.java:
4194   do {
4195     acl = parent(acl);
4196     if (cl == acl) {
4197       return true;
4198     }
4199     assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
4200   } while (acl != NULL);
4201   return false;
4202 }
4203 
4204 bool java_lang_ClassLoader::is_instance(oop obj) {
4205   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
4206 }
4207 
4208 
4209 // For class loader classes, parallelCapable defined
4210 // based on non-null field
4211 // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
4212 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
<span class="line-modified">4213   assert(parallelCapable_offset != -1, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">4214   return (class_loader-&gt;obj_field(parallelCapable_offset) != NULL);</span>
4215 }
4216 
4217 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
4218   // Fix for 4474172; see evaluation for more details
4219   loader = non_reflection_class_loader(loader);
4220 
4221   oop cl = SystemDictionary::java_system_loader();
4222   while(cl != NULL) {
4223     if (cl == loader) return true;
4224     cl = parent(cl);
4225   }
4226   return false;
4227 }
4228 
4229 // Return true if this is one of the class loaders associated with
4230 // the generated bytecodes for reflection.
4231 bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {
4232   if (loader != NULL) {
4233     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
4234     // This might be null in non-1.4 JDKs
4235     return (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class));
4236   }
4237   return false;
4238 }
4239 
4240 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
4241   // See whether this is one of the class loaders associated with
4242   // the generated bytecodes for reflection, and if so, &quot;magically&quot;
4243   // delegate to its parent to prevent class loading from occurring
4244   // in places where applications using reflection didn&#39;t expect it.
4245   if (is_reflection_class_loader(loader)) {
4246     return parent(loader);
4247   }
4248   return loader;
4249 }
4250 
4251 oop java_lang_ClassLoader::unnamedModule(oop loader) {
4252   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4253   return loader-&gt;obj_field(unnamedModule_offset);</span>
4254 }
4255 
4256 // Support for java_lang_System
4257 //






4258 #define SYSTEM_FIELDS_DO(macro) \
<span class="line-modified">4259   macro(static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \</span>
<span class="line-modified">4260   macro(static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \</span>
<span class="line-modified">4261   macro(static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \</span>
<span class="line-modified">4262   macro(static_security_offset, k, &quot;security&quot;, security_manager_signature, true)</span>
4263 
4264 void java_lang_System::compute_offsets() {
4265   InstanceKlass* k = SystemDictionary::System_klass();
4266   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4267 }
4268 
4269 #if INCLUDE_CDS
4270 void java_lang_System::serialize_offsets(SerializeClosure* f) {
4271    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4272 }
4273 #endif
4274 
<span class="line-removed">4275 int java_lang_System::in_offset_in_bytes() { return static_in_offset; }</span>
<span class="line-removed">4276 int java_lang_System::out_offset_in_bytes() { return static_out_offset; }</span>
<span class="line-removed">4277 int java_lang_System::err_offset_in_bytes() { return static_err_offset; }</span>
<span class="line-removed">4278 </span>
4279 // Support for jdk_internal_misc_UnsafeConstants
4280 //
4281 class UnsafeConstantsFixup : public FieldClosure {
4282 private:
4283   int _address_size;
4284   int _page_size;
4285   bool _big_endian;
4286   bool _use_unaligned_access;
4287   int _data_cache_line_flush_size;
4288 public:
4289   UnsafeConstantsFixup() {
4290     // round up values for all static final fields
4291     _address_size = sizeof(void*);
4292     _page_size = os::vm_page_size();
4293     _big_endian = LITTLE_ENDIAN_ONLY(false) BIG_ENDIAN_ONLY(true);
4294     _use_unaligned_access = UseUnalignedAccesses;
4295     _data_cache_line_flush_size = (int)VM_Version::data_cache_line_flush_size();
4296   }
4297 
4298   void do_field(fieldDescriptor* fd) {
</pre>
<hr />
<pre>
4305       mirror-&gt;int_field_put(fd-&gt;offset(), _address_size);
4306     } else if (fd-&gt;name() == vmSymbols::page_size_name()) {
4307       mirror-&gt;int_field_put(fd-&gt;offset(), _page_size);
4308     } else if (fd-&gt;name() == vmSymbols::big_endian_name()) {
4309       mirror-&gt;bool_field_put(fd-&gt;offset(), _big_endian);
4310     } else if (fd-&gt;name() == vmSymbols::use_unaligned_access_name()) {
4311       mirror-&gt;bool_field_put(fd-&gt;offset(), _use_unaligned_access);
4312     } else if (fd-&gt;name() == vmSymbols::data_cache_line_flush_size_name()) {
4313       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4314     } else {
4315       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4316     }
4317   }
4318 };
4319 
4320 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4321   UnsafeConstantsFixup fixup;
4322   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4323 }
4324 
<span class="line-removed">4325 int java_lang_Class::_klass_offset;</span>
<span class="line-removed">4326 int java_lang_Class::_array_klass_offset;</span>
<span class="line-removed">4327 int java_lang_Class::_oop_size_offset;</span>
<span class="line-removed">4328 int java_lang_Class::_static_oop_field_count_offset;</span>
<span class="line-removed">4329 int java_lang_Class::_class_loader_offset;</span>
<span class="line-removed">4330 int java_lang_Class::_module_offset;</span>
<span class="line-removed">4331 int java_lang_Class::_protection_domain_offset;</span>
<span class="line-removed">4332 int java_lang_Class::_component_mirror_offset;</span>
<span class="line-removed">4333 int java_lang_Class::_init_lock_offset;</span>
<span class="line-removed">4334 int java_lang_Class::_signers_offset;</span>
<span class="line-removed">4335 int java_lang_Class::_name_offset;</span>
<span class="line-removed">4336 int java_lang_Class::_source_file_offset;</span>
<span class="line-removed">4337 int java_lang_Class::_classData_offset;</span>
<span class="line-removed">4338 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;</span>
<span class="line-removed">4339 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;</span>
<span class="line-removed">4340 int java_lang_Throwable::backtrace_offset;</span>
<span class="line-removed">4341 int java_lang_Throwable::detailMessage_offset;</span>
<span class="line-removed">4342 int java_lang_Throwable::stackTrace_offset;</span>
<span class="line-removed">4343 int java_lang_Throwable::depth_offset;</span>
<span class="line-removed">4344 int java_lang_Throwable::static_unassigned_stacktrace_offset;</span>
<span class="line-removed">4345 int java_lang_reflect_AccessibleObject::override_offset;</span>
<span class="line-removed">4346 int java_lang_reflect_Method::clazz_offset;</span>
<span class="line-removed">4347 int java_lang_reflect_Method::name_offset;</span>
<span class="line-removed">4348 int java_lang_reflect_Method::returnType_offset;</span>
<span class="line-removed">4349 int java_lang_reflect_Method::parameterTypes_offset;</span>
<span class="line-removed">4350 int java_lang_reflect_Method::exceptionTypes_offset;</span>
<span class="line-removed">4351 int java_lang_reflect_Method::slot_offset;</span>
<span class="line-removed">4352 int java_lang_reflect_Method::modifiers_offset;</span>
<span class="line-removed">4353 int java_lang_reflect_Method::signature_offset;</span>
<span class="line-removed">4354 int java_lang_reflect_Method::annotations_offset;</span>
<span class="line-removed">4355 int java_lang_reflect_Method::parameter_annotations_offset;</span>
<span class="line-removed">4356 int java_lang_reflect_Method::annotation_default_offset;</span>
<span class="line-removed">4357 int java_lang_reflect_Constructor::clazz_offset;</span>
<span class="line-removed">4358 int java_lang_reflect_Constructor::parameterTypes_offset;</span>
<span class="line-removed">4359 int java_lang_reflect_Constructor::exceptionTypes_offset;</span>
<span class="line-removed">4360 int java_lang_reflect_Constructor::slot_offset;</span>
<span class="line-removed">4361 int java_lang_reflect_Constructor::modifiers_offset;</span>
<span class="line-removed">4362 int java_lang_reflect_Constructor::signature_offset;</span>
<span class="line-removed">4363 int java_lang_reflect_Constructor::annotations_offset;</span>
<span class="line-removed">4364 int java_lang_reflect_Constructor::parameter_annotations_offset;</span>
<span class="line-removed">4365 int java_lang_reflect_Field::clazz_offset;</span>
<span class="line-removed">4366 int java_lang_reflect_Field::name_offset;</span>
<span class="line-removed">4367 int java_lang_reflect_Field::type_offset;</span>
<span class="line-removed">4368 int java_lang_reflect_Field::slot_offset;</span>
<span class="line-removed">4369 int java_lang_reflect_Field::modifiers_offset;</span>
<span class="line-removed">4370 int java_lang_reflect_Field::signature_offset;</span>
<span class="line-removed">4371 int java_lang_reflect_Field::annotations_offset;</span>
<span class="line-removed">4372 int java_lang_reflect_Parameter::name_offset;</span>
<span class="line-removed">4373 int java_lang_reflect_Parameter::modifiers_offset;</span>
<span class="line-removed">4374 int java_lang_reflect_Parameter::index_offset;</span>
<span class="line-removed">4375 int java_lang_reflect_Parameter::executable_offset;</span>
<span class="line-removed">4376 int java_lang_boxing_object::value_offset;</span>
<span class="line-removed">4377 int java_lang_boxing_object::long_value_offset;</span>
<span class="line-removed">4378 bool java_lang_ref_Reference::_offsets_initialized;</span>
<span class="line-removed">4379 int java_lang_ref_Reference::referent_offset;</span>
<span class="line-removed">4380 int java_lang_ref_Reference::queue_offset;</span>
<span class="line-removed">4381 int java_lang_ref_Reference::next_offset;</span>
<span class="line-removed">4382 int java_lang_ref_Reference::discovered_offset;</span>
<span class="line-removed">4383 int java_lang_ref_SoftReference::timestamp_offset;</span>
<span class="line-removed">4384 int java_lang_ref_SoftReference::static_clock_offset;</span>
<span class="line-removed">4385 int java_lang_ClassLoader::parent_offset;</span>
<span class="line-removed">4386 int java_lang_System::static_in_offset;</span>
<span class="line-removed">4387 int java_lang_System::static_out_offset;</span>
<span class="line-removed">4388 int java_lang_System::static_err_offset;</span>
<span class="line-removed">4389 int java_lang_System::static_security_offset;</span>
<span class="line-removed">4390 int java_lang_StackTraceElement::methodName_offset;</span>
<span class="line-removed">4391 int java_lang_StackTraceElement::fileName_offset;</span>
<span class="line-removed">4392 int java_lang_StackTraceElement::lineNumber_offset;</span>
<span class="line-removed">4393 int java_lang_StackTraceElement::moduleName_offset;</span>
<span class="line-removed">4394 int java_lang_StackTraceElement::moduleVersion_offset;</span>
<span class="line-removed">4395 int java_lang_StackTraceElement::classLoaderName_offset;</span>
<span class="line-removed">4396 int java_lang_StackTraceElement::declaringClass_offset;</span>
<span class="line-removed">4397 int java_lang_StackTraceElement::declaringClassObject_offset;</span>
<span class="line-removed">4398 int java_lang_StackFrameInfo::_memberName_offset;</span>
<span class="line-removed">4399 int java_lang_StackFrameInfo::_bci_offset;</span>
<span class="line-removed">4400 int java_lang_StackFrameInfo::_version_offset;</span>
<span class="line-removed">4401 int java_lang_LiveStackFrameInfo::_monitors_offset;</span>
<span class="line-removed">4402 int java_lang_LiveStackFrameInfo::_locals_offset;</span>
<span class="line-removed">4403 int java_lang_LiveStackFrameInfo::_operands_offset;</span>
<span class="line-removed">4404 int java_lang_LiveStackFrameInfo::_mode_offset;</span>
<span class="line-removed">4405 int java_lang_AssertionStatusDirectives::classes_offset;</span>
<span class="line-removed">4406 int java_lang_AssertionStatusDirectives::classEnabled_offset;</span>
<span class="line-removed">4407 int java_lang_AssertionStatusDirectives::packages_offset;</span>
<span class="line-removed">4408 int java_lang_AssertionStatusDirectives::packageEnabled_offset;</span>
<span class="line-removed">4409 int java_lang_AssertionStatusDirectives::deflt_offset;</span>
<span class="line-removed">4410 int java_nio_Buffer::_limit_offset;</span>
<span class="line-removed">4411 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;</span>
<span class="line-removed">4412 int reflect_ConstantPool::_oop_offset;</span>
<span class="line-removed">4413 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;</span>
<span class="line-removed">4414 int java_lang_Integer_IntegerCache::_static_cache_offset;</span>
<span class="line-removed">4415 int java_lang_Long_LongCache::_static_cache_offset;</span>
<span class="line-removed">4416 int java_lang_Character_CharacterCache::_static_cache_offset;</span>
<span class="line-removed">4417 int java_lang_Short_ShortCache::_static_cache_offset;</span>
<span class="line-removed">4418 int java_lang_Byte_ByteCache::_static_cache_offset;</span>
<span class="line-removed">4419 int java_lang_Boolean::_static_TRUE_offset;</span>
<span class="line-removed">4420 int java_lang_Boolean::_static_FALSE_offset;</span>
<span class="line-removed">4421 int java_lang_reflect_RecordComponent::clazz_offset;</span>
<span class="line-removed">4422 int java_lang_reflect_RecordComponent::name_offset;</span>
<span class="line-removed">4423 int java_lang_reflect_RecordComponent::type_offset;</span>
<span class="line-removed">4424 int java_lang_reflect_RecordComponent::accessor_offset;</span>
<span class="line-removed">4425 int java_lang_reflect_RecordComponent::signature_offset;</span>
<span class="line-removed">4426 int java_lang_reflect_RecordComponent::annotations_offset;</span>
<span class="line-removed">4427 int java_lang_reflect_RecordComponent::typeAnnotations_offset;</span>
4428 

4429 








4430 
4431 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
<span class="line-modified">4432   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \</span>
<span class="line-modified">4433   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \</span>
<span class="line-modified">4434   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \</span>
<span class="line-modified">4435   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \</span>
<span class="line-modified">4436   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \</span>
<span class="line-modified">4437   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \</span>
<span class="line-modified">4438   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \</span>
<span class="line-modified">4439   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)</span>
4440 
4441 // Support for java_lang_StackTraceElement
4442 void java_lang_StackTraceElement::compute_offsets() {
4443   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4444   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4445 }
4446 
4447 #if INCLUDE_CDS
4448 void java_lang_StackTraceElement::serialize_offsets(SerializeClosure* f) {
4449   STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4450 }
4451 #endif
4452 
4453 void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
<span class="line-modified">4454   element-&gt;obj_field_put(fileName_offset, value);</span>
4455 }
4456 
4457 void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
<span class="line-modified">4458   element-&gt;obj_field_put(declaringClass_offset, value);</span>
4459 }
4460 
4461 void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
<span class="line-modified">4462   element-&gt;obj_field_put(methodName_offset, value);</span>
4463 }
4464 
4465 void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
<span class="line-modified">4466   element-&gt;int_field_put(lineNumber_offset, value);</span>
4467 }
4468 
4469 void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
<span class="line-modified">4470   element-&gt;obj_field_put(moduleName_offset, value);</span>
4471 }
4472 
4473 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
<span class="line-modified">4474   element-&gt;obj_field_put(moduleVersion_offset, value);</span>
4475 }
4476 
4477 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
<span class="line-modified">4478   element-&gt;obj_field_put(classLoaderName_offset, value);</span>
4479 }
4480 
4481 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
<span class="line-modified">4482   element-&gt;obj_field_put(declaringClassObject_offset, value);</span>
4483 }
4484 
<span class="line-removed">4485 void java_lang_StackFrameInfo::set_version(oop element, short value) {</span>
<span class="line-removed">4486   element-&gt;short_field_put(_version_offset, value);</span>
<span class="line-removed">4487 }</span>
4488 
<span class="line-modified">4489 void java_lang_StackFrameInfo::set_bci(oop element, int value) {</span>
<span class="line-removed">4490   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);</span>
<span class="line-removed">4491   element-&gt;int_field_put(_bci_offset, value);</span>
<span class="line-removed">4492 }</span>
<span class="line-removed">4493 </span>
<span class="line-removed">4494 void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {</span>
<span class="line-removed">4495   element-&gt;obj_field_put(_monitors_offset, value);</span>
<span class="line-removed">4496 }</span>
<span class="line-removed">4497 </span>
<span class="line-removed">4498 void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {</span>
<span class="line-removed">4499   element-&gt;obj_field_put(_locals_offset, value);</span>
<span class="line-removed">4500 }</span>
<span class="line-removed">4501 </span>
<span class="line-removed">4502 void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {</span>
<span class="line-removed">4503   element-&gt;obj_field_put(_operands_offset, value);</span>
<span class="line-removed">4504 }</span>
4505 
<span class="line-modified">4506 void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {</span>
<span class="line-modified">4507   element-&gt;int_field_put(_mode_offset, value);</span>
<span class="line-modified">4508 }</span>


4509 
4510 // Support for java Assertions - java_lang_AssertionStatusDirectives.
4511 #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
<span class="line-modified">4512   macro(classes_offset,        k, &quot;classes&quot;,        string_array_signature, false); \</span>
<span class="line-modified">4513   macro(classEnabled_offset,   k, &quot;classEnabled&quot;,   bool_array_signature, false); \</span>
<span class="line-modified">4514   macro(packages_offset,       k, &quot;packages&quot;,       string_array_signature, false); \</span>
<span class="line-modified">4515   macro(packageEnabled_offset, k, &quot;packageEnabled&quot;, bool_array_signature,   false); \</span>
<span class="line-modified">4516   macro(deflt_offset,          k, &quot;deflt&quot;,          bool_signature,         false)</span>
4517 
4518 void java_lang_AssertionStatusDirectives::compute_offsets() {
4519   InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
4520   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4521 }
4522 
4523 #if INCLUDE_CDS
4524 void java_lang_AssertionStatusDirectives::serialize_offsets(SerializeClosure* f) {
4525   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4526 }
4527 #endif
4528 
4529 void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
<span class="line-modified">4530   o-&gt;obj_field_put(classes_offset, val);</span>
4531 }
4532 
4533 void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
<span class="line-modified">4534   o-&gt;obj_field_put(classEnabled_offset, val);</span>
4535 }
4536 
4537 void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
<span class="line-modified">4538   o-&gt;obj_field_put(packages_offset, val);</span>
4539 }
4540 
4541 void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
<span class="line-modified">4542   o-&gt;obj_field_put(packageEnabled_offset, val);</span>
4543 }
4544 
4545 void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
<span class="line-modified">4546   o-&gt;bool_field_put(deflt_offset, val);</span>
4547 }
4548 
4549 
4550 // Support for intrinsification of java.nio.Buffer.checkIndex
<span class="line-modified">4551 int java_nio_Buffer::limit_offset() {</span>
<span class="line-modified">4552   return _limit_offset;</span>
<span class="line-removed">4553 }</span>
4554 
4555 #define BUFFER_FIELDS_DO(macro) \
4556   macro(_limit_offset, k, &quot;limit&quot;, int_signature, false)
4557 
4558 void java_nio_Buffer::compute_offsets() {
4559   InstanceKlass* k = SystemDictionary::nio_Buffer_klass();
4560   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
4561   BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4562 }
4563 
4564 #if INCLUDE_CDS
4565 void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {
4566   BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4567 }
4568 #endif
4569 


4570 #define AOS_FIELDS_DO(macro) \
4571   macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
4572 
4573 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
4574   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
4575   AOS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4576 }
4577 
4578 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
4579   assert(_owner_offset != 0, &quot;Must be initialized&quot;);
4580   return obj-&gt;obj_field(_owner_offset);
4581 }
4582 
4583 #if INCLUDE_CDS
4584 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
4585   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4586 }
4587 #endif
4588 






4589 #define INTEGER_CACHE_FIELDS_DO(macro) \
4590   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Integer_array_signature, true)
4591 
4592 void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {
4593   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4594   INTEGER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4595 }
4596 
4597 objArrayOop java_lang_Integer_IntegerCache::cache(InstanceKlass *ik) {
4598   oop base = ik-&gt;static_field_base_raw();
4599   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4600 }
4601 
4602 Symbol* java_lang_Integer_IntegerCache::symbol() {
4603   return vmSymbols::java_lang_Integer_IntegerCache();
4604 }
4605 
4606 #if INCLUDE_CDS
4607 void java_lang_Integer_IntegerCache::serialize_offsets(SerializeClosure* f) {
4608   INTEGER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
</pre>
<hr />
<pre>
4718   oop base = ik-&gt;static_field_base_raw();
4719   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4720 }
4721 
4722 Symbol* java_lang_Byte_ByteCache::symbol() {
4723   return vmSymbols::java_lang_Byte_ByteCache();
4724 }
4725 
4726 #if INCLUDE_CDS
4727 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4728   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4729 }
4730 #endif
4731 #undef BYTE_CACHE_FIELDS_DO
4732 
4733 jbyte java_lang_Byte::value(oop obj) {
4734    jvalue v;
4735    java_lang_boxing_object::get_value(obj, &amp;v);
4736    return v.b;
4737 }




4738 #define BOOLEAN_FIELDS_DO(macro) \
4739   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4740   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4741 
4742 
4743 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4744   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4745   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4746 }
4747 
4748 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4749   oop base = ik-&gt;static_field_base_raw();
4750   return base-&gt;obj_field(_static_TRUE_offset);
4751 }
4752 
4753 oop java_lang_Boolean::get_FALSE(InstanceKlass *ik) {
4754   oop base = ik-&gt;static_field_base_raw();
4755   return base-&gt;obj_field(_static_FALSE_offset);
4756 }
4757 
4758 Symbol* java_lang_Boolean::symbol() {
4759   return vmSymbols::java_lang_Boolean();
4760 }
4761 
4762 #if INCLUDE_CDS
4763 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
4764   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4765 }
4766 #endif
4767 #undef BOOLEAN_CACHE_FIELDS_DO
4768 
4769 jboolean java_lang_Boolean::value(oop obj) {
4770    jvalue v;
4771    java_lang_boxing_object::get_value(obj, &amp;v);
4772    return v.z;
4773 }
4774 










4775 #define RECORDCOMPONENT_FIELDS_DO(macro) \
<span class="line-modified">4776   macro(clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \</span>
<span class="line-modified">4777   macro(name_offset,        k, &quot;name&quot;,        string_signature, false); \</span>
<span class="line-modified">4778   macro(type_offset,        k, &quot;type&quot;,        class_signature,  false); \</span>
<span class="line-modified">4779   macro(accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \</span>
<span class="line-modified">4780   macro(signature_offset,   k, &quot;signature&quot;,   string_signature, false); \</span>
<span class="line-modified">4781   macro(annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \</span>
<span class="line-modified">4782   macro(typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);</span>
4783 
4784 // Support for java_lang_reflect_RecordComponent
4785 void java_lang_reflect_RecordComponent::compute_offsets() {
4786   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
4787   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4788 }
4789 
4790 #if INCLUDE_CDS
4791 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
4792   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4793 }
4794 #endif
4795 
4796 void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {
<span class="line-modified">4797   element-&gt;obj_field_put(clazz_offset, value);</span>
4798 }
4799 
4800 void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {
<span class="line-modified">4801   element-&gt;obj_field_put(name_offset, value);</span>
4802 }
4803 
4804 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
<span class="line-modified">4805   element-&gt;obj_field_put(type_offset, value);</span>
4806 }
4807 
4808 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
<span class="line-modified">4809   element-&gt;obj_field_put(accessor_offset, value);</span>
4810 }
4811 
4812 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
<span class="line-modified">4813   element-&gt;obj_field_put(signature_offset, value);</span>
4814 }
4815 
4816 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
<span class="line-modified">4817   element-&gt;obj_field_put(annotations_offset, value);</span>
4818 }
4819 
4820 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
<span class="line-modified">4821   element-&gt;obj_field_put(typeAnnotations_offset, value);</span>
4822 }
4823 
4824 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4825 
<span class="line-modified">4826 // Compute non-hard-coded field offsets of all the classes in this file</span>
4827 void JavaClasses::compute_offsets() {
4828   if (UseSharedSpaces) {
4829     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4830                                                          JvmtiExport::has_early_class_hook_env()),
4831                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
4832     // None of the classes used by the rest of this function can be replaced by
<span class="line-modified">4833     // JMVTI ClassFileLoadHook.</span>
4834     // We are safe to use the archived offsets, which have already been restored
4835     // by JavaClasses::serialize_offsets, without computing the offsets again.
4836     return;
4837   }
4838 
4839   // We have already called the compute_offsets() of the
4840   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String, java_lang_Class and
4841   // java_lang_ref_Reference) earlier inside SystemDictionary::resolve_well_known_classes()
4842   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4843 }
4844 
4845 #if INCLUDE_CDS
4846 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4847 
4848 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4849   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4850 }
4851 #endif
4852 
4853 #if INCLUDE_CDS_JAVA_HEAP
</pre>
<hr />
<pre>
4858       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed
4859       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in
4860       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes
4861       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.
4862       // So for now we cannot not support these classes for archiving.
4863       //
4864       // These objects typically are not referenced by static fields, but rather by resolved
4865       // constant pool entries, so excluding them shouldn&#39;t affect the archiving of static fields.
4866       klass == SystemDictionary::ResolvedMethodName_klass() ||
4867       klass == SystemDictionary::MemberName_klass() ||
4868       klass == SystemDictionary::Context_klass()) {
4869     return false;
4870   }
4871 
4872   return true;
4873 }
4874 #endif
4875 
4876 #ifndef PRODUCT
4877 
<span class="line-modified">4878 // These functions exist to assert the validity of hard-coded field offsets to guard</span>
<span class="line-removed">4879 // against changes in the class files</span>
4880 
<span class="line-modified">4881 bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {</span>

4882   EXCEPTION_MARK;
4883   fieldDescriptor fd;
4884   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);
4885   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
4886   InstanceKlass* ik = InstanceKlass::cast(k);
4887   TempNewSymbol f_name = SymbolTable::new_symbol(field_name);
4888   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig);
4889   if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
4890     tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
4891     return false;
4892   }
4893   if (fd.is_static()) {
4894     tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
4895     return false;
4896   }
<span class="line-modified">4897   if (fd.offset() == hardcoded_offset ) {</span>
4898     return true;
4899   } else {
<span class="line-modified">4900     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is hardcoded as %d but should really be %d.&quot;,</span>
<span class="line-modified">4901                   klass_name, field_name, hardcoded_offset, fd.offset());</span>
4902     return false;
4903   }
4904 }
4905 
<span class="line-removed">4906 // Check the hard-coded field offsets of all the classes in this file</span>
<span class="line-removed">4907 </span>
4908 void JavaClasses::check_offsets() {
4909   bool valid = true;
4910 
4911 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
<span class="line-modified">4912   valid &amp;= check_offset(klass_name, cpp_klass_name :: field_name ## _offset, #field_name, field_sig)</span>
4913 
4914 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
<span class="line-modified">4915   valid &amp;= check_offset(klass_name, cpp_klass_name :: long_ ## field_name ## _offset, #field_name, field_sig)</span>
4916 
4917   // Boxed primitive objects (java_lang_boxing_object)
4918 
4919   CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
4920   CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
4921   CHECK_OFFSET(&quot;java/lang/Float&quot;,     java_lang_boxing_object, value, &quot;F&quot;);
4922   CHECK_LONG_OFFSET(&quot;java/lang/Double&quot;, java_lang_boxing_object, value, &quot;D&quot;);
4923   CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
4924   CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
4925   CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
4926   CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
4927 
<span class="line-modified">4928   if (!valid) vm_exit_during_initialization(&quot;Hard-coded field offset verification failed&quot;);</span>
4929 }
4930 
4931 #endif // PRODUCT
4932 
4933 int InjectedField::compute_offset() {
4934   InstanceKlass* ik = InstanceKlass::cast(klass());
4935   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
4936     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
4937       // Only look at injected fields
4938       continue;
4939     }
4940     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
4941       return fs.offset();
4942     }
4943   }
4944   ResourceMark rm;
4945   tty-&gt;print_cr(&quot;Invalid layout of %s at %s/%s%s&quot;, ik-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? &quot; (may_be_java)&quot; : &quot;&quot;);
4946 #ifndef PRODUCT
4947   ik-&gt;print();
4948   tty-&gt;print_cr(&quot;all fields:&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 160     ik-&gt;print_on(&amp;ls);
 161 #endif //PRODUCT
 162     vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
 163   }
 164   dest_offset = fd.offset();
 165 }
 166 
 167 // Overloading to pass name as a string.
 168 static void compute_offset(int&amp; dest_offset, InstanceKlass* ik,
 169                            const char* name_string, Symbol* signature_symbol,
 170                            bool is_static = false) {
 171   TempNewSymbol name = SymbolTable::probe(name_string, (int)strlen(name_string));
 172   if (name == NULL) {
 173     ResourceMark rm;
 174     log_error(class)(&quot;Name %s should be in the SymbolTable since its class is loaded&quot;, name_string);
 175     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
 176   }
 177   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 178 }
 179 










 180 
 181 #if INCLUDE_CDS
 182 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
 183   f-&gt;do_u4((u4*)&amp;offset)
 184 #endif
 185 
 186 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
 187   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 188 
<span class="line-added"> 189 </span>
<span class="line-added"> 190 // java_lang_String</span>
<span class="line-added"> 191 </span>
<span class="line-added"> 192 int java_lang_String::_value_offset;</span>
<span class="line-added"> 193 int java_lang_String::_hash_offset;</span>
<span class="line-added"> 194 int java_lang_String::_hashIsZero_offset;</span>
<span class="line-added"> 195 int java_lang_String::_coder_offset;</span>
<span class="line-added"> 196 </span>
<span class="line-added"> 197 bool java_lang_String::_initialized;</span>
<span class="line-added"> 198 </span>
<span class="line-added"> 199 bool java_lang_String::is_instance(oop obj) {</span>
<span class="line-added"> 200   return is_instance_inlined(obj);</span>
<span class="line-added"> 201 }</span>
<span class="line-added"> 202 </span>
 203 #define STRING_FIELDS_DO(macro) \
<span class="line-modified"> 204   macro(_value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \</span>
<span class="line-modified"> 205   macro(_hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \</span>
<span class="line-modified"> 206   macro(_hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \</span>
<span class="line-modified"> 207   macro(_coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);</span>
 208 
 209 void java_lang_String::compute_offsets() {
<span class="line-modified"> 210   if (_initialized) {</span>
 211     return;
 212   }
 213 
 214   InstanceKlass* k = SystemDictionary::String_klass();
 215   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 216 
<span class="line-modified"> 217   _initialized = true;</span>
 218 }
 219 
 220 #if INCLUDE_CDS
 221 void java_lang_String::serialize_offsets(SerializeClosure* f) {
 222   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
<span class="line-modified"> 223   f-&gt;do_bool(&amp;_initialized);</span>
 224 }
 225 #endif
 226 
 227 class CompactStringsFixup : public FieldClosure {
 228 private:
 229   bool _value;
 230 
 231 public:
 232   CompactStringsFixup(bool value) : _value(value) {}
 233 
 234   void do_field(fieldDescriptor* fd) {
 235     if (fd-&gt;name() == vmSymbols::compact_strings_name()) {
 236       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
 237       assert(fd-&gt;field_holder() == SystemDictionary::String_klass(), &quot;Should be String&quot;);
 238       assert(mirror != NULL, &quot;String must have mirror already&quot;);
 239       mirror-&gt;bool_field_put(fd-&gt;offset(), _value);
 240     }
 241   }
 242 };
 243 
 244 void java_lang_String::set_compact_strings(bool value) {
 245   CompactStringsFixup fix(value);
 246   SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);
 247 }
 248 
 249 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
<span class="line-modified"> 250   assert(_initialized, &quot;Must be initialized&quot;);</span>
 251   assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
 252 
 253   // Create the String object first, so there&#39;s a chance that the String
 254   // and the char array it points to end up in the same cache line.
 255   oop obj;
 256   obj = SystemDictionary::String_klass()-&gt;allocate_instance(CHECK_NH);
 257 
 258   // Create the char array.  The String object must be handlized here
 259   // because GC can happen as a result of the allocation attempt.
 260   Handle h_obj(THREAD, obj);
 261   int arr_length = is_latin1 ? length : length &lt;&lt; 1; // 2 bytes per UTF16.
 262   typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;
 263 
 264   // Point the String at the char array
 265   obj = h_obj();
 266   set_value(obj, buffer);
 267   // No need to zero the offset, allocation zero&#39;ed the entire String object
 268   set_coder(obj, is_latin1 ? CODER_LATIN1 : CODER_UTF16);
 269   return h_obj;
 270 }
</pre>
<hr />
<pre>
 528     } else {
 529       for (int index = 0; index &lt; length; index++) {
 530         result[index] = ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 531       }
 532     }
 533   } else {
 534     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), &quot;could not allocate Unicode string&quot;);
 535   }
 536   return result;
 537 }
 538 
 539 unsigned int java_lang_String::hash_code(oop java_string) {
 540   // The hash and hashIsZero fields are subject to a benign data race,
 541   // making it crucial to ensure that any observable result of the
 542   // calculation in this method stays correct under any possible read of
 543   // these fields. Necessary restrictions to allow this to be correct
 544   // without explicit memory fences or similar concurrency primitives is
 545   // that we can ever only write to one of these two fields for a given
 546   // String instance, and that the computation is idempotent and derived
 547   // from immutable state
<span class="line-modified"> 548   assert(_initialized &amp;&amp; (_hash_offset &gt; 0) &amp;&amp; (_hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);</span>
 549   if (java_lang_String::hash_is_set(java_string)) {
<span class="line-modified"> 550     return java_string-&gt;int_field(_hash_offset);</span>
 551   }
 552 
 553   typeArrayOop value = java_lang_String::value(java_string);
 554   int         length = java_lang_String::length(java_string, value);
 555   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 556 
 557   unsigned int hash = 0;
 558   if (length &gt; 0) {
 559     if (is_latin1) {
 560       hash = java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);
 561     } else {
 562       hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);
 563     }
 564   }
 565 
 566   if (hash != 0) {
<span class="line-modified"> 567     java_string-&gt;int_field_put(_hash_offset, hash);</span>
 568   } else {
<span class="line-modified"> 569     java_string-&gt;bool_field_put(_hashIsZero_offset, true);</span>
 570   }
 571   return hash;
 572 }
 573 
 574 char* java_lang_String::as_quoted_ascii(oop java_string) {
 575   typeArrayOop value  = java_lang_String::value(java_string);
 576   int          length = java_lang_String::length(java_string, value);
 577   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 578 
 579   if (length == 0) return NULL;
 580 
 581   char* result;
 582   int result_length;
 583   if (!is_latin1) {
 584     jchar* base = value-&gt;char_at_addr(0);
 585     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 586     result = NEW_RESOURCE_ARRAY(char, result_length);
 587     UNICODE::as_quoted_ascii(base, length, result, result_length);
 588   } else {
 589     jbyte* base = value-&gt;byte_at_addr(0);
</pre>
<hr />
<pre>
 781   typeArrayOop value  = java_lang_String::value_no_keepalive(java_string);
 782 
 783   if (value == NULL) {
 784     // This can happen if, e.g., printing a String
 785     // object before its initializer has been called
 786     st-&gt;print(&quot;NULL&quot;);
 787     return;
 788   }
 789 
 790   int length = java_lang_String::length(java_string, value);
 791   bool is_latin1 = java_lang_String::is_latin1(java_string);
 792 
 793   st-&gt;print(&quot;\&quot;&quot;);
 794   for (int index = 0; index &lt; length; index++) {
 795     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 796                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 797   }
 798   st-&gt;print(&quot;\&quot;&quot;);
 799 }
 800 
<span class="line-added"> 801 // java_lang_Class</span>
<span class="line-added"> 802 </span>
<span class="line-added"> 803 int java_lang_Class::_klass_offset;</span>
<span class="line-added"> 804 int java_lang_Class::_array_klass_offset;</span>
<span class="line-added"> 805 int java_lang_Class::_oop_size_offset;</span>
<span class="line-added"> 806 int java_lang_Class::_static_oop_field_count_offset;</span>
<span class="line-added"> 807 int java_lang_Class::_class_loader_offset;</span>
<span class="line-added"> 808 int java_lang_Class::_module_offset;</span>
<span class="line-added"> 809 int java_lang_Class::_protection_domain_offset;</span>
<span class="line-added"> 810 int java_lang_Class::_component_mirror_offset;</span>
<span class="line-added"> 811 int java_lang_Class::_init_lock_offset;</span>
<span class="line-added"> 812 int java_lang_Class::_signers_offset;</span>
<span class="line-added"> 813 int java_lang_Class::_name_offset;</span>
<span class="line-added"> 814 int java_lang_Class::_source_file_offset;</span>
<span class="line-added"> 815 int java_lang_Class::_classData_offset;</span>
<span class="line-added"> 816 int java_lang_Class::_classRedefinedCount_offset;</span>
<span class="line-added"> 817 </span>
<span class="line-added"> 818 bool java_lang_Class::_offsets_computed = false;</span>
<span class="line-added"> 819 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;</span>
<span class="line-added"> 820 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;</span>
 821 
 822 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 823   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 824   if (fd-&gt;has_initial_value()) {
 825     BasicType t = fd-&gt;field_type();
 826     switch (t) {
 827       case T_BYTE:
 828         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 829               break;
 830       case T_BOOLEAN:
 831         mirror()-&gt;bool_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 832               break;
 833       case T_CHAR:
 834         mirror()-&gt;char_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 835               break;
 836       case T_SHORT:
 837         mirror()-&gt;short_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 838               break;
 839       case T_INT:
 840         mirror()-&gt;int_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
</pre>
<hr />
<pre>
1625   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1626   if (is_primitive(java_class)) {
1627     if (reference_klass != NULL)
1628       (*reference_klass) = NULL;
1629     return primitive_type(java_class);
1630   } else {
1631     if (reference_klass != NULL)
1632       (*reference_klass) = as_Klass(java_class);
1633     return T_OBJECT;
1634   }
1635 }
1636 
1637 
1638 oop java_lang_Class::primitive_mirror(BasicType t) {
1639   oop mirror = Universe::java_mirror(t);
1640   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1641   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1642   return mirror;
1643 }
1644 



1645 #define CLASS_FIELDS_DO(macro) \
<span class="line-modified">1646   macro(_classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \</span>
<span class="line-modified">1647   macro(_class_loader_offset,        k, &quot;classLoader&quot;,         classloader_signature, false); \</span>
<span class="line-modified">1648   macro(_component_mirror_offset,    k, &quot;componentType&quot;,       class_signature,       false); \</span>
<span class="line-modified">1649   macro(_module_offset,              k, &quot;module&quot;,              module_signature,      false); \</span>
<span class="line-modified">1650   macro(_name_offset,                k, &quot;name&quot;,                string_signature,      false); \</span>
<span class="line-modified">1651   macro(_classData_offset,           k, &quot;classData&quot;,           object_signature,      false);</span>
1652 
1653 void java_lang_Class::compute_offsets() {
<span class="line-modified">1654   if (_offsets_computed) {</span>
1655     return;
1656   }
1657 
<span class="line-modified">1658   _offsets_computed = true;</span>
1659 
1660   InstanceKlass* k = SystemDictionary::Class_klass();
1661   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1662 
1663   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1664   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1665   // GC treats them the same.
1666   _init_lock_offset = _component_mirror_offset;
1667 
1668   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1669 }
1670 
1671 #if INCLUDE_CDS
1672 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
<span class="line-modified">1673   f-&gt;do_bool(&amp;_offsets_computed);</span>
1674   f-&gt;do_u4((u4*)&amp;_init_lock_offset);
1675 
1676   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1677 
1678   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
1679 }
1680 #endif
1681 
1682 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
<span class="line-modified">1683   assert(_classRedefinedCount_offset != 0, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">1684   return the_class_mirror-&gt;int_field(_classRedefinedCount_offset);</span>
1685 }
1686 
1687 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
<span class="line-modified">1688   assert(_classRedefinedCount_offset != 0, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">1689   the_class_mirror-&gt;int_field_put(_classRedefinedCount_offset, value);</span>
1690 }
1691 
1692 
1693 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
1694 //       platform thread structure, and a eetop offset which was used for thread
1695 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
1696 //       merged, so in the HotSpot VM we just use the eetop field for the thread
1697 //       instead of the privateInfo_offset.
1698 //
1699 // Note: The stackSize field is only present starting in 1.4.
1700 
<span class="line-modified">1701 int java_lang_Thread::_name_offset;</span>
<span class="line-modified">1702 int java_lang_Thread::_group_offset;</span>
<span class="line-modified">1703 int java_lang_Thread::_contextClassLoader_offset;</span>
<span class="line-modified">1704 int java_lang_Thread::_inheritedAccessControlContext_offset;</span>
<span class="line-modified">1705 int java_lang_Thread::_priority_offset;</span>
<span class="line-modified">1706 int java_lang_Thread::_eetop_offset;</span>
<span class="line-modified">1707 int java_lang_Thread::_interrupted_offset;</span>
<span class="line-modified">1708 int java_lang_Thread::_daemon_offset;</span>
<span class="line-modified">1709 int java_lang_Thread::_stillborn_offset;</span>
<span class="line-modified">1710 int java_lang_Thread::_stackSize_offset;</span>
<span class="line-modified">1711 int java_lang_Thread::_tid_offset;</span>
<span class="line-modified">1712 int java_lang_Thread::_thread_status_offset;</span>
<span class="line-modified">1713 int java_lang_Thread::_park_blocker_offset;</span>
1714 
1715 #define THREAD_FIELDS_DO(macro) \
1716   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
1717   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
1718   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
1719   macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
1720   macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
1721   macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
1722   macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
1723   macro(_interrupted_offset,   k, &quot;interrupted&quot;, bool_signature, false); \
1724   macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
1725   macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
1726   macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
1727   macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
1728   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false)
1729 
1730 void java_lang_Thread::compute_offsets() {
1731   assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
1732 
1733   InstanceKlass* k = SystemDictionary::Thread_klass();
</pre>
<hr />
<pre>
1855 
1856 oop java_lang_Thread::park_blocker(oop java_thread) {
1857   return java_thread-&gt;obj_field(_park_blocker_offset);
1858 }
1859 
1860 const char* java_lang_Thread::thread_status_name(oop java_thread) {
1861   ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1862   switch (status) {
1863     case NEW                      : return &quot;NEW&quot;;
1864     case RUNNABLE                 : return &quot;RUNNABLE&quot;;
1865     case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
1866     case IN_OBJECT_WAIT           : return &quot;WAITING (on object monitor)&quot;;
1867     case IN_OBJECT_WAIT_TIMED     : return &quot;TIMED_WAITING (on object monitor)&quot;;
1868     case PARKED                   : return &quot;WAITING (parking)&quot;;
1869     case PARKED_TIMED             : return &quot;TIMED_WAITING (parking)&quot;;
1870     case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
1871     case TERMINATED               : return &quot;TERMINATED&quot;;
1872     default                       : return &quot;UNKNOWN&quot;;
1873   };
1874 }
<span class="line-modified">1875 int java_lang_ThreadGroup::_parent_offset;</span>
<span class="line-modified">1876 int java_lang_ThreadGroup::_name_offset;</span>
<span class="line-modified">1877 int java_lang_ThreadGroup::_threads_offset;</span>
<span class="line-modified">1878 int java_lang_ThreadGroup::_groups_offset;</span>
<span class="line-modified">1879 int java_lang_ThreadGroup::_maxPriority_offset;</span>
<span class="line-modified">1880 int java_lang_ThreadGroup::_destroyed_offset;</span>
<span class="line-modified">1881 int java_lang_ThreadGroup::_daemon_offset;</span>
<span class="line-modified">1882 int java_lang_ThreadGroup::_nthreads_offset;</span>
<span class="line-modified">1883 int java_lang_ThreadGroup::_ngroups_offset;</span>
1884 
1885 oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
1886   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1887   return java_thread_group-&gt;obj_field(_parent_offset);
1888 }
1889 
1890 // (&quot;name as oop&quot; accessor is not necessary)
1891 
1892 const char* java_lang_ThreadGroup::name(oop java_thread_group) {
1893   oop name = java_thread_group-&gt;obj_field(_name_offset);
1894   // ThreadGroup.name can be null
1895   if (name != NULL) {
1896     return java_lang_String::as_utf8_string(name);
1897   }
1898   return NULL;
1899 }
1900 
1901 int java_lang_ThreadGroup::nthreads(oop java_thread_group) {
1902   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1903   return java_thread_group-&gt;int_field(_nthreads_offset);
</pre>
<hr />
<pre>
1943   macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature, false); \
1944   macro(_maxPriority_offset, k, vmSymbols::maxPriority_name(), int_signature,               false); \
1945   macro(_destroyed_offset,   k, vmSymbols::destroyed_name(),   bool_signature,              false); \
1946   macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,              false); \
1947   macro(_nthreads_offset,    k, vmSymbols::nthreads_name(),    int_signature,               false); \
1948   macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,               false)
1949 
1950 void java_lang_ThreadGroup::compute_offsets() {
1951   assert(_parent_offset == 0, &quot;offsets should be initialized only once&quot;);
1952 
1953   InstanceKlass* k = SystemDictionary::ThreadGroup_klass();
1954   THREADGROUP_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1955 }
1956 
1957 #if INCLUDE_CDS
1958 void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
1959   THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1960 }
1961 #endif
1962 
<span class="line-added">1963 // java_lang_Throwable</span>
<span class="line-added">1964 </span>
<span class="line-added">1965 int java_lang_Throwable::_backtrace_offset;</span>
<span class="line-added">1966 int java_lang_Throwable::_detailMessage_offset;</span>
<span class="line-added">1967 int java_lang_Throwable::_stackTrace_offset;</span>
<span class="line-added">1968 int java_lang_Throwable::_depth_offset;</span>
<span class="line-added">1969 int java_lang_Throwable::_static_unassigned_stacktrace_offset;</span>
<span class="line-added">1970 </span>
1971 #define THROWABLE_FIELDS_DO(macro) \
<span class="line-modified">1972   macro(_backtrace_offset,     k, &quot;backtrace&quot;,     object_signature,                  false); \</span>
<span class="line-modified">1973   macro(_detailMessage_offset, k, &quot;detailMessage&quot;, string_signature,                  false); \</span>
<span class="line-modified">1974   macro(_stackTrace_offset,    k, &quot;stackTrace&quot;,    java_lang_StackTraceElement_array, false); \</span>
<span class="line-modified">1975   macro(_depth_offset,         k, &quot;depth&quot;,         int_signature,                     false); \</span>
<span class="line-modified">1976   macro(_static_unassigned_stacktrace_offset, k, &quot;UNASSIGNED_STACK&quot;, java_lang_StackTraceElement_array, true)</span>
1977 
1978 void java_lang_Throwable::compute_offsets() {
1979   InstanceKlass* k = SystemDictionary::Throwable_klass();
1980   THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1981 }
1982 
1983 #if INCLUDE_CDS
1984 void java_lang_Throwable::serialize_offsets(SerializeClosure* f) {
1985   THROWABLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1986 }
1987 #endif
1988 
1989 oop java_lang_Throwable::unassigned_stacktrace() {
1990   InstanceKlass* ik = SystemDictionary::Throwable_klass();
1991   oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">1992   return base-&gt;obj_field(_static_unassigned_stacktrace_offset);</span>
1993 }
1994 
1995 oop java_lang_Throwable::backtrace(oop throwable) {
<span class="line-modified">1996   return throwable-&gt;obj_field_acquire(_backtrace_offset);</span>
1997 }
1998 
1999 
2000 void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
<span class="line-modified">2001   throwable-&gt;release_obj_field_put(_backtrace_offset, value);</span>
2002 }
2003 
2004 int java_lang_Throwable::depth(oop throwable) {
<span class="line-modified">2005   return throwable-&gt;int_field(_depth_offset);</span>
2006 }
2007 
2008 void java_lang_Throwable::set_depth(oop throwable, int value) {
<span class="line-modified">2009   throwable-&gt;int_field_put(_depth_offset, value);</span>
2010 }
2011 
2012 oop java_lang_Throwable::message(oop throwable) {
<span class="line-modified">2013   return throwable-&gt;obj_field(_detailMessage_offset);</span>
2014 }
2015 
2016 
2017 // Return Symbol for detailed_message or NULL
2018 Symbol* java_lang_Throwable::detail_message(oop throwable) {
2019   PRESERVE_EXCEPTION_MARK;  // Keep original exception
2020   oop detailed_message = java_lang_Throwable::message(throwable);
2021   if (detailed_message != NULL) {
2022     return java_lang_String::as_symbol(detailed_message);
2023   }
2024   return NULL;
2025 }
2026 
2027 void java_lang_Throwable::set_message(oop throwable, oop value) {
<span class="line-modified">2028   throwable-&gt;obj_field_put(_detailMessage_offset, value);</span>
2029 }
2030 
2031 
2032 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
<span class="line-modified">2033   throwable-&gt;obj_field_put(_stackTrace_offset, st_element_array);</span>
2034 }
2035 
2036 void java_lang_Throwable::clear_stacktrace(oop throwable) {
2037   set_stacktrace(throwable, NULL);
2038 }
2039 
2040 
2041 void java_lang_Throwable::print(oop throwable, outputStream* st) {
2042   ResourceMark rm;
2043   Klass* k = throwable-&gt;klass();
2044   assert(k != NULL, &quot;just checking&quot;);
2045   st-&gt;print(&quot;%s&quot;, k-&gt;external_name());
2046   oop msg = message(throwable);
2047   if (msg != NULL) {
2048     st-&gt;print(&quot;: %s&quot;, java_lang_String::as_utf8_string(msg));
2049   }
2050 }
2051 
2052 // After this many redefines, the stack trace is unreliable.
2053 const int MAX_VERSION = USHRT_MAX;
</pre>
<hr />
<pre>
2792   line_number = Backtrace::get_line_number(method(), bci);
2793 }
2794 
2795 #if INCLUDE_JVMCI
2796 void java_lang_StackTraceElement::decode(const methodHandle&amp; method, int bci,
2797                                          Symbol*&amp; filename, int&amp; line_number, TRAPS) {
2798   ResourceMark rm(THREAD);
2799   HandleMark hm(THREAD);
2800 
2801   filename = NULL;
2802   line_number = -1;
2803 
2804   oop source_file;
2805   int version = method-&gt;constants()-&gt;version();
2806   InstanceKlass* holder = method-&gt;method_holder();
2807   Handle java_class(THREAD, holder-&gt;java_mirror());
2808   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
2809 }
2810 #endif // INCLUDE_JVMCI
2811 
<span class="line-added">2812 // java_lang_StackFrameInfo</span>
<span class="line-added">2813 </span>
<span class="line-added">2814 int java_lang_StackFrameInfo::_memberName_offset;</span>
<span class="line-added">2815 int java_lang_StackFrameInfo::_bci_offset;</span>
<span class="line-added">2816 int java_lang_StackFrameInfo::_version_offset;</span>
<span class="line-added">2817 </span>
<span class="line-added">2818 #define STACKFRAMEINFO_FIELDS_DO(macro) \</span>
<span class="line-added">2819   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \</span>
<span class="line-added">2820   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false)</span>
<span class="line-added">2821 </span>
<span class="line-added">2822 void java_lang_StackFrameInfo::compute_offsets() {</span>
<span class="line-added">2823   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();</span>
<span class="line-added">2824   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">2825   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">2826 }</span>
<span class="line-added">2827 </span>
<span class="line-added">2828 #if INCLUDE_CDS</span>
<span class="line-added">2829 void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">2830   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">2831   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">2832 }</span>
<span class="line-added">2833 #endif</span>
<span class="line-added">2834 </span>
2835 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
2836   HandleMark hm(THREAD);
2837   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
2838   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
2839   // we should expand MemberName::name when Throwable uses StackTrace
2840   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
2841   return method;
2842 }
2843 
2844 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS) {
2845   // set Method* or mid/cpref
2846   HandleMark hm(THREAD);
2847   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));
2848   InstanceKlass* ik = method-&gt;method_holder();
2849   CallInfo info(method(), ik, CHECK);
2850   MethodHandles::init_method_MemberName(mname, info);
2851   // set bci
2852   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
2853   // method may be redefined; store the version
2854   int version = method-&gt;constants()-&gt;version();
2855   assert((jushort)version == version, &quot;version should be short&quot;);
2856   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
2857 }
2858 
2859 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
2860   ResourceMark rm(THREAD);
2861   HandleMark hm(THREAD);
2862   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
2863   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
2864   InstanceKlass* holder = InstanceKlass::cast(clazz);
2865   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
2866 
2867   short version = stackFrame-&gt;short_field(_version_offset);
2868   int bci = stackFrame-&gt;int_field(_bci_offset);
2869   Symbol* name = method-&gt;name();
2870   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),
2871                                        version, bci, name, CHECK);
2872 }
2873 
<span class="line-modified">2874 void java_lang_StackFrameInfo::set_version(oop element, short value) {</span>
<span class="line-modified">2875   element-&gt;short_field_put(_version_offset, value);</span>






2876 }
2877 
<span class="line-modified">2878 void java_lang_StackFrameInfo::set_bci(oop element, int value) {</span>
<span class="line-modified">2879   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);</span>
<span class="line-modified">2880   element-&gt;int_field_put(_bci_offset, value);</span>

2881 }
<span class="line-modified">2882 </span>
<span class="line-added">2883 int java_lang_LiveStackFrameInfo::_monitors_offset;</span>
<span class="line-added">2884 int java_lang_LiveStackFrameInfo::_locals_offset;</span>
<span class="line-added">2885 int java_lang_LiveStackFrameInfo::_operands_offset;</span>
<span class="line-added">2886 int java_lang_LiveStackFrameInfo::_mode_offset;</span>
2887 
2888 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
2889   macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
2890   macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
2891   macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
2892   macro(_mode_offset,       k, &quot;mode&quot;,        int_signature,          false)
2893 
2894 void java_lang_LiveStackFrameInfo::compute_offsets() {
2895   InstanceKlass* k = SystemDictionary::LiveStackFrameInfo_klass();
2896   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2897 }
2898 
2899 #if INCLUDE_CDS
2900 void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
2901   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2902 }
2903 #endif
2904 
<span class="line-added">2905 void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {</span>
<span class="line-added">2906   element-&gt;obj_field_put(_monitors_offset, value);</span>
<span class="line-added">2907 }</span>
<span class="line-added">2908 </span>
<span class="line-added">2909 void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {</span>
<span class="line-added">2910   element-&gt;obj_field_put(_locals_offset, value);</span>
<span class="line-added">2911 }</span>
<span class="line-added">2912 </span>
<span class="line-added">2913 void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {</span>
<span class="line-added">2914   element-&gt;obj_field_put(_operands_offset, value);</span>
<span class="line-added">2915 }</span>
<span class="line-added">2916 </span>
<span class="line-added">2917 void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {</span>
<span class="line-added">2918   element-&gt;int_field_put(_mode_offset, value);</span>
<span class="line-added">2919 }</span>
<span class="line-added">2920 </span>
<span class="line-added">2921 </span>
<span class="line-added">2922 // java_lang_AccessibleObject</span>
<span class="line-added">2923 </span>
<span class="line-added">2924 int java_lang_reflect_AccessibleObject::_override_offset;</span>
<span class="line-added">2925 </span>
2926 #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
<span class="line-modified">2927   macro(_override_offset, k, &quot;override&quot;, bool_signature, false)</span>
2928 
2929 void java_lang_reflect_AccessibleObject::compute_offsets() {
2930   InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
2931   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2932 }
2933 
2934 #if INCLUDE_CDS
2935 void java_lang_reflect_AccessibleObject::serialize_offsets(SerializeClosure* f) {
2936   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2937 }
2938 #endif
2939 
2940 jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
<span class="line-modified">2941   return (jboolean) reflect-&gt;bool_field(_override_offset);</span>

2942 }
2943 
2944 void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
<span class="line-modified">2945   reflect-&gt;bool_field_put(_override_offset, (int) value);</span>

2946 }
2947 
<span class="line-added">2948 // java_lang_reflect_Method</span>
<span class="line-added">2949 </span>
<span class="line-added">2950 int java_lang_reflect_Method::_clazz_offset;</span>
<span class="line-added">2951 int java_lang_reflect_Method::_name_offset;</span>
<span class="line-added">2952 int java_lang_reflect_Method::_returnType_offset;</span>
<span class="line-added">2953 int java_lang_reflect_Method::_parameterTypes_offset;</span>
<span class="line-added">2954 int java_lang_reflect_Method::_exceptionTypes_offset;</span>
<span class="line-added">2955 int java_lang_reflect_Method::_slot_offset;</span>
<span class="line-added">2956 int java_lang_reflect_Method::_modifiers_offset;</span>
<span class="line-added">2957 int java_lang_reflect_Method::_signature_offset;</span>
<span class="line-added">2958 int java_lang_reflect_Method::_annotations_offset;</span>
<span class="line-added">2959 int java_lang_reflect_Method::_parameter_annotations_offset;</span>
<span class="line-added">2960 int java_lang_reflect_Method::_annotation_default_offset;</span>
<span class="line-added">2961 </span>
2962 #define METHOD_FIELDS_DO(macro) \
<span class="line-modified">2963   macro(_clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \</span>
<span class="line-modified">2964   macro(_name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \</span>
<span class="line-modified">2965   macro(_returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \</span>
<span class="line-modified">2966   macro(_parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">2967   macro(_exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">2968   macro(_slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \</span>
<span class="line-modified">2969   macro(_modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \</span>
<span class="line-modified">2970   macro(_signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \</span>
<span class="line-modified">2971   macro(_annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \</span>
<span class="line-modified">2972   macro(_parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \</span>
<span class="line-modified">2973   macro(_annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);</span>
2974 
2975 void java_lang_reflect_Method::compute_offsets() {
2976   InstanceKlass* k = SystemDictionary::reflect_Method_klass();
2977   METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2978 }
2979 
2980 #if INCLUDE_CDS
2981 void java_lang_reflect_Method::serialize_offsets(SerializeClosure* f) {
2982   METHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2983 }
2984 #endif
2985 
2986 Handle java_lang_reflect_Method::create(TRAPS) {
2987   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2988   Klass* klass = SystemDictionary::reflect_Method_klass();
2989   // This class is eagerly initialized during VM initialization, since we keep a refence
2990   // to one of the methods
2991   assert(InstanceKlass::cast(klass)-&gt;is_initialized(), &quot;must be initialized&quot;);
2992   return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(THREAD);
2993 }
2994 
2995 oop java_lang_reflect_Method::clazz(oop reflect) {
<span class="line-modified">2996   return reflect-&gt;obj_field(_clazz_offset);</span>

2997 }
2998 
2999 void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
<span class="line-modified">3000    reflect-&gt;obj_field_put(_clazz_offset, value);</span>

3001 }
3002 
3003 int java_lang_reflect_Method::slot(oop reflect) {
<span class="line-modified">3004   return reflect-&gt;int_field(_slot_offset);</span>

3005 }
3006 
3007 void java_lang_reflect_Method::set_slot(oop reflect, int value) {
<span class="line-modified">3008   reflect-&gt;int_field_put(_slot_offset, value);</span>

3009 }
3010 
3011 void java_lang_reflect_Method::set_name(oop method, oop value) {
<span class="line-modified">3012   method-&gt;obj_field_put(_name_offset, value);</span>

3013 }
3014 
3015 oop java_lang_reflect_Method::return_type(oop method) {
<span class="line-modified">3016   return method-&gt;obj_field(_returnType_offset);</span>

3017 }
3018 
3019 void java_lang_reflect_Method::set_return_type(oop method, oop value) {
<span class="line-modified">3020   method-&gt;obj_field_put(_returnType_offset, value);</span>

3021 }
3022 
3023 oop java_lang_reflect_Method::parameter_types(oop method) {
<span class="line-modified">3024   return method-&gt;obj_field(_parameterTypes_offset);</span>

3025 }
3026 
3027 void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
<span class="line-modified">3028   method-&gt;obj_field_put(_parameterTypes_offset, value);</span>

3029 }
3030 
3031 void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
<span class="line-modified">3032   method-&gt;obj_field_put(_exceptionTypes_offset, value);</span>

3033 }
3034 
3035 void java_lang_reflect_Method::set_modifiers(oop method, int value) {
<span class="line-modified">3036   method-&gt;int_field_put(_modifiers_offset, value);</span>

3037 }
3038 
3039 void java_lang_reflect_Method::set_signature(oop method, oop value) {
<span class="line-modified">3040   method-&gt;obj_field_put(_signature_offset, value);</span>

3041 }
3042 
3043 void java_lang_reflect_Method::set_annotations(oop method, oop value) {
<span class="line-modified">3044   method-&gt;obj_field_put(_annotations_offset, value);</span>

3045 }
3046 
3047 void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
<span class="line-modified">3048   method-&gt;obj_field_put(_parameter_annotations_offset, value);</span>

3049 }
3050 
3051 void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
<span class="line-modified">3052   method-&gt;obj_field_put(_annotation_default_offset, value);</span>

3053 }
3054 
<span class="line-added">3055 int java_lang_reflect_Constructor::_clazz_offset;</span>
<span class="line-added">3056 int java_lang_reflect_Constructor::_parameterTypes_offset;</span>
<span class="line-added">3057 int java_lang_reflect_Constructor::_exceptionTypes_offset;</span>
<span class="line-added">3058 int java_lang_reflect_Constructor::_slot_offset;</span>
<span class="line-added">3059 int java_lang_reflect_Constructor::_modifiers_offset;</span>
<span class="line-added">3060 int java_lang_reflect_Constructor::_signature_offset;</span>
<span class="line-added">3061 int java_lang_reflect_Constructor::_annotations_offset;</span>
<span class="line-added">3062 int java_lang_reflect_Constructor::_parameter_annotations_offset;</span>
<span class="line-added">3063 </span>
3064 #define CONSTRUCTOR_FIELDS_DO(macro) \
<span class="line-modified">3065   macro(_clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \</span>
<span class="line-modified">3066   macro(_parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">3067   macro(_exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">3068   macro(_slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \</span>
<span class="line-modified">3069   macro(_modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \</span>
<span class="line-modified">3070   macro(_signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \</span>
<span class="line-modified">3071   macro(_annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \</span>
<span class="line-modified">3072   macro(_parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);</span>
3073 
3074 void java_lang_reflect_Constructor::compute_offsets() {
3075   InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
3076   CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3077 }
3078 
3079 #if INCLUDE_CDS
3080 void java_lang_reflect_Constructor::serialize_offsets(SerializeClosure* f) {
3081   CONSTRUCTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3082 }
3083 #endif
3084 
3085 Handle java_lang_reflect_Constructor::create(TRAPS) {
3086   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3087   Symbol* name = vmSymbols::java_lang_reflect_Constructor();
3088   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3089   InstanceKlass* ik = InstanceKlass::cast(k);
3090   // Ensure it is initialized
3091   ik-&gt;initialize(CHECK_NH);
3092   return ik-&gt;allocate_instance_handle(THREAD);
3093 }
3094 
3095 oop java_lang_reflect_Constructor::clazz(oop reflect) {
<span class="line-modified">3096   return reflect-&gt;obj_field(_clazz_offset);</span>

3097 }
3098 
3099 void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
<span class="line-modified">3100    reflect-&gt;obj_field_put(_clazz_offset, value);</span>

3101 }
3102 
3103 oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
<span class="line-modified">3104   return constructor-&gt;obj_field(_parameterTypes_offset);</span>

3105 }
3106 
3107 void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
<span class="line-modified">3108   constructor-&gt;obj_field_put(_parameterTypes_offset, value);</span>

3109 }
3110 
3111 void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
<span class="line-modified">3112   constructor-&gt;obj_field_put(_exceptionTypes_offset, value);</span>

3113 }
3114 
3115 int java_lang_reflect_Constructor::slot(oop reflect) {
<span class="line-modified">3116   return reflect-&gt;int_field(_slot_offset);</span>

3117 }
3118 
3119 void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
<span class="line-modified">3120   reflect-&gt;int_field_put(_slot_offset, value);</span>

3121 }
3122 
3123 void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
<span class="line-modified">3124   constructor-&gt;int_field_put(_modifiers_offset, value);</span>

3125 }
3126 
3127 void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
<span class="line-modified">3128   constructor-&gt;obj_field_put(_signature_offset, value);</span>

3129 }
3130 
3131 void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
<span class="line-modified">3132   constructor-&gt;obj_field_put(_annotations_offset, value);</span>

3133 }
3134 
3135 void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
<span class="line-modified">3136   method-&gt;obj_field_put(_parameter_annotations_offset, value);</span>

3137 }
3138 
<span class="line-added">3139 int java_lang_reflect_Field::_clazz_offset;</span>
<span class="line-added">3140 int java_lang_reflect_Field::_name_offset;</span>
<span class="line-added">3141 int java_lang_reflect_Field::_type_offset;</span>
<span class="line-added">3142 int java_lang_reflect_Field::_slot_offset;</span>
<span class="line-added">3143 int java_lang_reflect_Field::_modifiers_offset;</span>
<span class="line-added">3144 int java_lang_reflect_Field::_signature_offset;</span>
<span class="line-added">3145 int java_lang_reflect_Field::_annotations_offset;</span>
<span class="line-added">3146 </span>
3147 #define FIELD_FIELDS_DO(macro) \
<span class="line-modified">3148   macro(_clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \</span>
<span class="line-modified">3149   macro(_name_offset,      k, vmSymbols::name_name(),      string_signature, false); \</span>
<span class="line-modified">3150   macro(_type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \</span>
<span class="line-modified">3151   macro(_slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \</span>
<span class="line-modified">3152   macro(_modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \</span>
<span class="line-modified">3153   macro(_signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \</span>
<span class="line-modified">3154   macro(_annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);</span>
3155 
3156 void java_lang_reflect_Field::compute_offsets() {
3157   InstanceKlass* k = SystemDictionary::reflect_Field_klass();
3158   FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3159 }
3160 
3161 #if INCLUDE_CDS
3162 void java_lang_reflect_Field::serialize_offsets(SerializeClosure* f) {
3163   FIELD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3164 }
3165 #endif
3166 
3167 Handle java_lang_reflect_Field::create(TRAPS) {
3168   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3169   Symbol* name = vmSymbols::java_lang_reflect_Field();
3170   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3171   InstanceKlass* ik = InstanceKlass::cast(k);
3172   // Ensure it is initialized
3173   ik-&gt;initialize(CHECK_NH);
3174   return ik-&gt;allocate_instance_handle(THREAD);
3175 }
3176 
3177 oop java_lang_reflect_Field::clazz(oop reflect) {
<span class="line-modified">3178   return reflect-&gt;obj_field(_clazz_offset);</span>

3179 }
3180 
3181 void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
<span class="line-modified">3182   reflect-&gt;obj_field_put(_clazz_offset, value);</span>

3183 }
3184 
3185 oop java_lang_reflect_Field::name(oop field) {
<span class="line-modified">3186   return field-&gt;obj_field(_name_offset);</span>

3187 }
3188 
3189 void java_lang_reflect_Field::set_name(oop field, oop value) {
<span class="line-modified">3190   field-&gt;obj_field_put(_name_offset, value);</span>

3191 }
3192 
3193 oop java_lang_reflect_Field::type(oop field) {
<span class="line-modified">3194   return field-&gt;obj_field(_type_offset);</span>

3195 }
3196 
3197 void java_lang_reflect_Field::set_type(oop field, oop value) {
<span class="line-modified">3198   field-&gt;obj_field_put(_type_offset, value);</span>

3199 }
3200 
3201 int java_lang_reflect_Field::slot(oop reflect) {
<span class="line-modified">3202   return reflect-&gt;int_field(_slot_offset);</span>

3203 }
3204 
3205 void java_lang_reflect_Field::set_slot(oop reflect, int value) {
<span class="line-modified">3206   reflect-&gt;int_field_put(_slot_offset, value);</span>

3207 }
3208 
3209 int java_lang_reflect_Field::modifiers(oop field) {
<span class="line-modified">3210   return field-&gt;int_field(_modifiers_offset);</span>

3211 }
3212 
3213 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
<span class="line-modified">3214   field-&gt;int_field_put(_modifiers_offset, value);</span>

3215 }
3216 
3217 void java_lang_reflect_Field::set_signature(oop field, oop value) {
<span class="line-modified">3218   field-&gt;obj_field_put(_signature_offset, value);</span>

3219 }
3220 
3221 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
<span class="line-modified">3222   field-&gt;obj_field_put(_annotations_offset, value);</span>

3223 }
3224 
3225 oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {
3226   // Allocate java.lang.reflect.RecordComponent instance
3227   HandleMark hm(THREAD);
3228   InstanceKlass* ik = SystemDictionary::RecordComponent_klass();
3229   assert(ik != NULL, &quot;must be loaded&quot;);
3230   ik-&gt;initialize(CHECK_NULL);
3231 
3232   Handle element = ik-&gt;allocate_instance_handle(CHECK_NULL);
3233 
3234   Handle decl_class(THREAD, holder-&gt;java_mirror());
3235   java_lang_reflect_RecordComponent::set_clazz(element(), decl_class());
3236 
3237   Symbol* name = holder-&gt;constants()-&gt;symbol_at(component-&gt;name_index()); // name_index is a utf8
3238   oop component_name = StringTable::intern(name, CHECK_NULL);
3239   java_lang_reflect_RecordComponent::set_name(element(), component_name);
3240 
3241   Symbol* type = holder-&gt;constants()-&gt;symbol_at(component-&gt;descriptor_index());
3242   Handle component_type_h =
</pre>
<hr />
<pre>
3263   }
3264 
3265   int sig_index = component-&gt;generic_signature_index();
3266   if (sig_index &gt; 0) {
3267     Symbol* sig = holder-&gt;constants()-&gt;symbol_at(sig_index); // sig_index is a utf8
3268     oop component_sig = StringTable::intern(sig, CHECK_NULL);
3269     java_lang_reflect_RecordComponent::set_signature(element(), component_sig);
3270   } else {
3271     java_lang_reflect_RecordComponent::set_signature(element(), NULL);
3272   }
3273 
3274   typeArrayOop annotation_oop = Annotations::make_java_array(component-&gt;annotations(), CHECK_NULL);
3275   java_lang_reflect_RecordComponent::set_annotations(element(), annotation_oop);
3276 
3277   typeArrayOop type_annotation_oop = Annotations::make_java_array(component-&gt;type_annotations(), CHECK_NULL);
3278   java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);
3279 
3280   return element();
3281 }
3282 
<span class="line-added">3283 int reflect_ConstantPool::_oop_offset;</span>
<span class="line-added">3284 </span>
3285 #define CONSTANTPOOL_FIELDS_DO(macro) \
3286   macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
3287 
3288 void reflect_ConstantPool::compute_offsets() {
3289   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3290   // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
3291   CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3292 }
3293 
3294 #if INCLUDE_CDS
3295 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
3296   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3297 }
3298 #endif
3299 
<span class="line-added">3300 int java_lang_reflect_Parameter::_name_offset;</span>
<span class="line-added">3301 int java_lang_reflect_Parameter::_modifiers_offset;</span>
<span class="line-added">3302 int java_lang_reflect_Parameter::_index_offset;</span>
<span class="line-added">3303 int java_lang_reflect_Parameter::_executable_offset;</span>
<span class="line-added">3304 </span>
3305 #define PARAMETER_FIELDS_DO(macro) \
<span class="line-modified">3306   macro(_name_offset,        k, vmSymbols::name_name(),        string_signature, false); \</span>
<span class="line-modified">3307   macro(_modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \</span>
<span class="line-modified">3308   macro(_index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \</span>
<span class="line-modified">3309   macro(_executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)</span>
3310 
3311 void java_lang_reflect_Parameter::compute_offsets() {
3312   InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
3313   PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3314 }
3315 
3316 #if INCLUDE_CDS
3317 void java_lang_reflect_Parameter::serialize_offsets(SerializeClosure* f) {
3318   PARAMETER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3319 }
3320 #endif
3321 
3322 Handle java_lang_reflect_Parameter::create(TRAPS) {
3323   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3324   Symbol* name = vmSymbols::java_lang_reflect_Parameter();
3325   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3326   InstanceKlass* ik = InstanceKlass::cast(k);
3327   // Ensure it is initialized
3328   ik-&gt;initialize(CHECK_NH);
3329   return ik-&gt;allocate_instance_handle(THREAD);
3330 }
3331 
3332 oop java_lang_reflect_Parameter::name(oop param) {
<span class="line-modified">3333   return param-&gt;obj_field(_name_offset);</span>

3334 }
3335 
3336 void java_lang_reflect_Parameter::set_name(oop param, oop value) {
<span class="line-modified">3337   param-&gt;obj_field_put(_name_offset, value);</span>

3338 }
3339 
3340 int java_lang_reflect_Parameter::modifiers(oop param) {
<span class="line-modified">3341   return param-&gt;int_field(_modifiers_offset);</span>

3342 }
3343 
3344 void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
<span class="line-modified">3345   param-&gt;int_field_put(_modifiers_offset, value);</span>

3346 }
3347 
3348 int java_lang_reflect_Parameter::index(oop param) {
<span class="line-modified">3349   return param-&gt;int_field(_index_offset);</span>

3350 }
3351 
3352 void java_lang_reflect_Parameter::set_index(oop param, int value) {
<span class="line-modified">3353   param-&gt;int_field_put(_index_offset, value);</span>

3354 }
3355 
3356 oop java_lang_reflect_Parameter::executable(oop param) {
<span class="line-modified">3357   return param-&gt;obj_field(_executable_offset);</span>

3358 }
3359 
3360 void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
<span class="line-modified">3361   param-&gt;obj_field_put(_executable_offset, value);</span>

3362 }
3363 
<span class="line-added">3364 // java_lang_Module</span>
3365 
<span class="line-modified">3366 int java_lang_Module::_loader_offset;</span>
<span class="line-modified">3367 int java_lang_Module::_name_offset;</span>
<span class="line-modified">3368 int java_lang_Module::_module_entry_offset;</span>
3369 
3370 Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
3371   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3372   return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
3373                           vmSymbols::java_lang_module_init_signature(),
3374                           loader, module_name, CHECK_NH);
3375 }
3376 
3377 #define MODULE_FIELDS_DO(macro) \
<span class="line-modified">3378   macro(_loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \</span>
<span class="line-modified">3379   macro(_name_offset,    k, vmSymbols::name_name(),    string_signature,      false)</span>
3380 
3381 void java_lang_Module::compute_offsets() {
3382   InstanceKlass* k = SystemDictionary::Module_klass();
3383   MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3384   MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3385 }
3386 
3387 #if INCLUDE_CDS
3388 void java_lang_Module::serialize_offsets(SerializeClosure* f) {
3389   MODULE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3390   MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3391 }
3392 #endif
3393 
3394 oop java_lang_Module::loader(oop module) {
<span class="line-modified">3395   return module-&gt;obj_field(_loader_offset);</span>

3396 }
3397 
3398 void java_lang_Module::set_loader(oop module, oop value) {
<span class="line-modified">3399   module-&gt;obj_field_put(_loader_offset, value);</span>

3400 }
3401 
3402 oop java_lang_Module::name(oop module) {
<span class="line-modified">3403   return module-&gt;obj_field(_name_offset);</span>

3404 }
3405 
3406 void java_lang_Module::set_name(oop module, oop value) {
<span class="line-modified">3407   module-&gt;obj_field_put(_name_offset, value);</span>

3408 }
3409 
3410 ModuleEntry* java_lang_Module::module_entry(oop module) {
<span class="line-modified">3411   assert(_module_entry_offset != 0, &quot;Uninitialized module_entry_offset&quot;);</span>
3412   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3413   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3414 
3415   ModuleEntry* module_entry = (ModuleEntry*)module-&gt;address_field(_module_entry_offset);
3416   if (module_entry == NULL) {
3417     // If the inject field containing the ModuleEntry* is null then return the
3418     // class loader&#39;s unnamed module.
3419     oop loader = java_lang_Module::loader(module);
3420     Handle h_loader = Handle(Thread::current(), loader);
3421     ClassLoaderData* loader_cld = SystemDictionary::register_loader(h_loader);
3422     return loader_cld-&gt;unnamed_module();
3423   }
3424   return module_entry;
3425 }
3426 
3427 void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
<span class="line-modified">3428   assert(_module_entry_offset != 0, &quot;Uninitialized module_entry_offset&quot;);</span>
3429   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3430   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3431   module-&gt;address_field_put(_module_entry_offset, (address)module_entry);
3432 }
3433 
3434 Handle reflect_ConstantPool::create(TRAPS) {
3435   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3436   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3437   // Ensure it is initialized
3438   k-&gt;initialize(CHECK_NH);
3439   return k-&gt;allocate_instance_handle(THREAD);
3440 }
3441 
3442 
3443 void reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {

3444   oop mirror = value-&gt;pool_holder()-&gt;java_mirror();
3445   // Save the mirror to get back the constant pool.
3446   reflect-&gt;obj_field_put(_oop_offset, mirror);
3447 }
3448 
3449 ConstantPool* reflect_ConstantPool::get_cp(oop reflect) {

3450 
3451   oop mirror = reflect-&gt;obj_field(_oop_offset);
3452   Klass* k = java_lang_Class::as_Klass(mirror);
3453   assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
3454 
3455   // Get the constant pool back from the klass.  Since class redefinition
3456   // merges the new constant pool into the old, this is essentially the
3457   // same constant pool as the original.  If constant pool merging is
3458   // no longer done in the future, this will have to change to save
3459   // the original.
3460   return InstanceKlass::cast(k)-&gt;constants();
3461 }
3462 
<span class="line-added">3463 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;</span>
<span class="line-added">3464 </span>
3465 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3466   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3467 
3468 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3469   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3470   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3471 }
3472 
3473 #if INCLUDE_CDS
3474 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3475   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3476 }
3477 #endif
3478 
<span class="line-added">3479 // Support for java_lang_ref_Reference</span>
<span class="line-added">3480 </span>
<span class="line-added">3481 bool java_lang_ref_Reference::_offsets_initialized;</span>
<span class="line-added">3482 </span>
<span class="line-added">3483 int java_lang_ref_Reference::_referent_offset;</span>
<span class="line-added">3484 int java_lang_ref_Reference::_queue_offset;</span>
<span class="line-added">3485 int java_lang_ref_Reference::_next_offset;</span>
<span class="line-added">3486 int java_lang_ref_Reference::_discovered_offset;</span>
<span class="line-added">3487 </span>
<span class="line-added">3488 #define REFERENCE_FIELDS_DO(macro) \</span>
<span class="line-added">3489   macro(_referent_offset,   k, &quot;referent&quot;, object_signature, false); \</span>
<span class="line-added">3490   macro(_queue_offset,      k, &quot;queue&quot;, referencequeue_signature, false); \</span>
<span class="line-added">3491   macro(_next_offset,       k, &quot;next&quot;, reference_signature, false); \</span>
<span class="line-added">3492   macro(_discovered_offset, k, &quot;discovered&quot;, reference_signature, false);</span>
<span class="line-added">3493 </span>
<span class="line-added">3494 void java_lang_ref_Reference::compute_offsets() {</span>
<span class="line-added">3495   if (_offsets_initialized) {</span>
<span class="line-added">3496     return;</span>
<span class="line-added">3497   }</span>
<span class="line-added">3498   _offsets_initialized = true;</span>
<span class="line-added">3499   InstanceKlass* k = SystemDictionary::Reference_klass();</span>
<span class="line-added">3500   REFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">3501 }</span>
<span class="line-added">3502 </span>
<span class="line-added">3503 #if INCLUDE_CDS</span>
<span class="line-added">3504 void java_lang_ref_Reference::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">3505   f-&gt;do_bool(&amp;_offsets_initialized);</span>
<span class="line-added">3506   REFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">3507 }</span>
<span class="line-added">3508 #endif</span>
<span class="line-added">3509 </span>
<span class="line-added">3510 bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {</span>
<span class="line-added">3511   assert(obj != NULL, &quot;sanity&quot;);</span>
<span class="line-added">3512   if (offset != _referent_offset) {</span>
<span class="line-added">3513     return false;</span>
<span class="line-added">3514   }</span>
<span class="line-added">3515 </span>
<span class="line-added">3516   Klass* k = obj-&gt;klass();</span>
<span class="line-added">3517   if (!k-&gt;is_instance_klass()) {</span>
<span class="line-added">3518     return false;</span>
<span class="line-added">3519   }</span>
<span class="line-added">3520 </span>
<span class="line-added">3521   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());</span>
<span class="line-added">3522   bool is_reference = ik-&gt;reference_type() != REF_NONE;</span>
<span class="line-added">3523   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);</span>
<span class="line-added">3524   return is_reference;</span>
<span class="line-added">3525 }</span>
<span class="line-added">3526 </span>
<span class="line-added">3527 int java_lang_boxing_object::_value_offset;</span>
<span class="line-added">3528 int java_lang_boxing_object::_long_value_offset;</span>
<span class="line-added">3529 </span>
<span class="line-added">3530 #define BOXING_FIELDS_DO(macro) \</span>
<span class="line-added">3531   macro(_value_offset,      integerKlass, &quot;value&quot;, int_signature, false); \</span>
<span class="line-added">3532   macro(_long_value_offset, longKlass, &quot;value&quot;, long_signature, false);</span>
<span class="line-added">3533 </span>
<span class="line-added">3534 void java_lang_boxing_object::compute_offsets() {</span>
<span class="line-added">3535   InstanceKlass* integerKlass = SystemDictionary::Integer_klass();</span>
<span class="line-added">3536   InstanceKlass* longKlass = SystemDictionary::Long_klass();</span>
<span class="line-added">3537   BOXING_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">3538 }</span>
<span class="line-added">3539 </span>
<span class="line-added">3540 #if INCLUDE_CDS</span>
<span class="line-added">3541 void java_lang_boxing_object::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">3542   BOXING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">3543 }</span>
<span class="line-added">3544 #endif</span>
<span class="line-added">3545 </span>
3546 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3547   Klass* k = SystemDictionary::box_klass(type);
3548   if (k == NULL)  return NULL;
3549   InstanceKlass* ik = InstanceKlass::cast(k);
3550   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_NULL);
3551   return ik-&gt;allocate_instance(THREAD);
3552 }
3553 
3554 
3555 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
3556   oop box = initialize_and_allocate(type, CHECK_NULL);
3557   if (box == NULL)  return NULL;
3558   switch (type) {
3559     case T_BOOLEAN:
<span class="line-modified">3560       box-&gt;bool_field_put(_value_offset, value-&gt;z);</span>
3561       break;
3562     case T_CHAR:
<span class="line-modified">3563       box-&gt;char_field_put(_value_offset, value-&gt;c);</span>
3564       break;
3565     case T_FLOAT:
<span class="line-modified">3566       box-&gt;float_field_put(_value_offset, value-&gt;f);</span>
3567       break;
3568     case T_DOUBLE:
<span class="line-modified">3569       box-&gt;double_field_put(_long_value_offset, value-&gt;d);</span>
3570       break;
3571     case T_BYTE:
<span class="line-modified">3572       box-&gt;byte_field_put(_value_offset, value-&gt;b);</span>
3573       break;
3574     case T_SHORT:
<span class="line-modified">3575       box-&gt;short_field_put(_value_offset, value-&gt;s);</span>
3576       break;
3577     case T_INT:
<span class="line-modified">3578       box-&gt;int_field_put(_value_offset, value-&gt;i);</span>
3579       break;
3580     case T_LONG:
<span class="line-modified">3581       box-&gt;long_field_put(_long_value_offset, value-&gt;j);</span>
3582       break;
3583     default:
3584       return NULL;
3585   }
3586   return box;
3587 }
3588 
3589 
3590 BasicType java_lang_boxing_object::basic_type(oop box) {
3591   if (box == NULL)  return T_ILLEGAL;
3592   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3593   if (type == T_OBJECT)         // &#39;unknown&#39; value returned by SD::bkt
3594     return T_ILLEGAL;
3595   return type;
3596 }
3597 
3598 
3599 BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
3600   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3601   switch (type) {
3602   case T_BOOLEAN:
<span class="line-modified">3603     value-&gt;z = box-&gt;bool_field(_value_offset);</span>
3604     break;
3605   case T_CHAR:
<span class="line-modified">3606     value-&gt;c = box-&gt;char_field(_value_offset);</span>
3607     break;
3608   case T_FLOAT:
<span class="line-modified">3609     value-&gt;f = box-&gt;float_field(_value_offset);</span>
3610     break;
3611   case T_DOUBLE:
<span class="line-modified">3612     value-&gt;d = box-&gt;double_field(_long_value_offset);</span>
3613     break;
3614   case T_BYTE:
<span class="line-modified">3615     value-&gt;b = box-&gt;byte_field(_value_offset);</span>
3616     break;
3617   case T_SHORT:
<span class="line-modified">3618     value-&gt;s = box-&gt;short_field(_value_offset);</span>
3619     break;
3620   case T_INT:
<span class="line-modified">3621     value-&gt;i = box-&gt;int_field(_value_offset);</span>
3622     break;
3623   case T_LONG:
<span class="line-modified">3624     value-&gt;j = box-&gt;long_field(_long_value_offset);</span>
3625     break;
3626   default:
3627     return T_ILLEGAL;
3628   } // end switch
3629   return type;
3630 }
3631 
3632 
3633 BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
3634   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3635   switch (type) {
3636   case T_BOOLEAN:
<span class="line-modified">3637     box-&gt;bool_field_put(_value_offset, value-&gt;z);</span>
3638     break;
3639   case T_CHAR:
<span class="line-modified">3640     box-&gt;char_field_put(_value_offset, value-&gt;c);</span>
3641     break;
3642   case T_FLOAT:
<span class="line-modified">3643     box-&gt;float_field_put(_value_offset, value-&gt;f);</span>
3644     break;
3645   case T_DOUBLE:
<span class="line-modified">3646     box-&gt;double_field_put(_long_value_offset, value-&gt;d);</span>
3647     break;
3648   case T_BYTE:
<span class="line-modified">3649     box-&gt;byte_field_put(_value_offset, value-&gt;b);</span>
3650     break;
3651   case T_SHORT:
<span class="line-modified">3652     box-&gt;short_field_put(_value_offset, value-&gt;s);</span>
3653     break;
3654   case T_INT:
<span class="line-modified">3655     box-&gt;int_field_put(_value_offset, value-&gt;i);</span>
3656     break;
3657   case T_LONG:
<span class="line-modified">3658     box-&gt;long_field_put(_long_value_offset, value-&gt;j);</span>
3659     break;
3660   default:
3661     return T_ILLEGAL;
3662   } // end switch
3663   return type;
3664 }
3665 
3666 
3667 void java_lang_boxing_object::print(BasicType type, jvalue* value, outputStream* st) {
3668   switch (type) {
3669   case T_BOOLEAN:   st-&gt;print(&quot;%s&quot;, value-&gt;z ? &quot;true&quot; : &quot;false&quot;);   break;
3670   case T_CHAR:      st-&gt;print(&quot;%d&quot;, value-&gt;c);                      break;
3671   case T_BYTE:      st-&gt;print(&quot;%d&quot;, value-&gt;b);                      break;
3672   case T_SHORT:     st-&gt;print(&quot;%d&quot;, value-&gt;s);                      break;
3673   case T_INT:       st-&gt;print(&quot;%d&quot;, value-&gt;i);                      break;
3674   case T_LONG:      st-&gt;print(JLONG_FORMAT, value-&gt;j);              break;
3675   case T_FLOAT:     st-&gt;print(&quot;%f&quot;, value-&gt;f);                      break;
3676   case T_DOUBLE:    st-&gt;print(&quot;%lf&quot;, value-&gt;d);                     break;
3677   default:          st-&gt;print(&quot;type %d?&quot;, type);                    break;
3678   }
3679 }
3680 
























































3681 
3682 // Support for java_lang_ref_SoftReference
3683 //
3684 
<span class="line-added">3685 int java_lang_ref_SoftReference::_timestamp_offset;</span>
<span class="line-added">3686 int java_lang_ref_SoftReference::_static_clock_offset;</span>
<span class="line-added">3687 </span>
3688 #define SOFTREFERENCE_FIELDS_DO(macro) \
<span class="line-modified">3689   macro(_timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \</span>
<span class="line-modified">3690   macro(_static_clock_offset, k, &quot;clock&quot;,     long_signature, true)</span>
3691 
3692 void java_lang_ref_SoftReference::compute_offsets() {
3693   InstanceKlass* k = SystemDictionary::SoftReference_klass();
3694   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3695 }
3696 
3697 #if INCLUDE_CDS
3698 void java_lang_ref_SoftReference::serialize_offsets(SerializeClosure* f) {
3699   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3700 }
3701 #endif
3702 
3703 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
<span class="line-modified">3704   return ref-&gt;long_field(_timestamp_offset);</span>
3705 }
3706 
3707 jlong java_lang_ref_SoftReference::clock() {
3708   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3709   oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">3710   return base-&gt;long_field(_static_clock_offset);</span>
3711 }
3712 
3713 void java_lang_ref_SoftReference::set_clock(jlong value) {
3714   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3715   oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">3716   base-&gt;long_field_put(_static_clock_offset, value);</span>
3717 }
3718 
3719 // Support for java_lang_invoke_DirectMethodHandle
3720 
3721 int java_lang_invoke_DirectMethodHandle::_member_offset;
3722 
3723 oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
3724   oop member_name = NULL;
3725   assert(oopDesc::is_oop(dmh) &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh),
3726          &quot;a DirectMethodHandle oop is expected&quot;);
<span class="line-modified">3727   return dmh-&gt;obj_field(_member_offset);</span>
3728 }
3729 
3730 #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
3731   macro(_member_offset, k, &quot;member&quot;, java_lang_invoke_MemberName_signature, false)
3732 
3733 void java_lang_invoke_DirectMethodHandle::compute_offsets() {
3734   InstanceKlass* k = SystemDictionary::DirectMethodHandle_klass();
3735   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3736 }
3737 
3738 #if INCLUDE_CDS
3739 void java_lang_invoke_DirectMethodHandle::serialize_offsets(SerializeClosure* f) {
3740   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3741 }
3742 #endif
3743 
3744 // Support for java_lang_invoke_MethodHandle
3745 
3746 int java_lang_invoke_MethodHandle::_type_offset;
3747 int java_lang_invoke_MethodHandle::_form_offset;
</pre>
<hr />
<pre>
4125   InstanceKlass* k = SystemDictionary::Context_klass();
4126   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4127 }
4128 
4129 #if INCLUDE_CDS
4130 void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {
4131   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4132 }
4133 #endif
4134 
4135 DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {
4136   assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), &quot;&quot;);
4137   nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site-&gt;field_addr(_vmdependencies_offset);
4138   volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site-&gt;field_addr(_last_cleanup_offset);
4139   DependencyContext dep_ctx(vmdeps_addr, last_cleanup_addr);
4140   return dep_ctx;
4141 }
4142 
4143 // Support for java_security_AccessControlContext
4144 
<span class="line-modified">4145 int java_security_AccessControlContext::_context_offset;</span>
<span class="line-modified">4146 int java_security_AccessControlContext::_privilegedContext_offset;</span>
<span class="line-modified">4147 int java_security_AccessControlContext::_isPrivileged_offset;</span>
<span class="line-modified">4148 int java_security_AccessControlContext::_isAuthorized_offset;</span>
4149 
4150 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
4151   macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
4152   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4153   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4154   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4155 
4156 void java_security_AccessControlContext::compute_offsets() {
4157   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4158   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4159   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4160 }
4161 
4162 #if INCLUDE_CDS
4163 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4164   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4165 }
4166 #endif
4167 
4168 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4169   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
<span class="line-modified">4170   assert(_isAuthorized_offset != 0, &quot;offsets should have been initialized&quot;);</span>
4171   // Ensure klass is initialized
4172   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);
4173   // Allocate result
4174   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);
4175   // Fill in values
4176   result-&gt;obj_field_put(_context_offset, context());
4177   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4178   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4179   // whitelist AccessControlContexts created by the JVM
4180   result-&gt;bool_field_put(_isAuthorized_offset, true);
4181   return result;
4182 }
4183 
4184 
4185 // Support for java_lang_ClassLoader
4186 
<span class="line-modified">4187 int  java_lang_ClassLoader::_loader_data_offset;</span>
<span class="line-modified">4188 int  java_lang_ClassLoader::_parallelCapable_offset;</span>
<span class="line-modified">4189 int  java_lang_ClassLoader::_name_offset;</span>
<span class="line-modified">4190 int  java_lang_ClassLoader::_nameAndId_offset;</span>
<span class="line-modified">4191 int  java_lang_ClassLoader::_unnamedModule_offset;</span>
<span class="line-modified">4192 int  java_lang_ClassLoader::_parent_offset;</span>
4193 
4194 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
4195   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4196   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4197   return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
4198 }
4199 
4200 ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
4201   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4202   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4203   return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
4204 }
4205 
4206 void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
4207   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4208   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4209   HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
4210 }
4211 
4212 #define CLASSLOADER_FIELDS_DO(macro) \
<span class="line-modified">4213   macro(_parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \</span>
<span class="line-modified">4214   macro(_name_offset,            k1, vmSymbols::name_name(), string_signature, false); \</span>
<span class="line-modified">4215   macro(_nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \</span>
<span class="line-modified">4216   macro(_unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \</span>
<span class="line-modified">4217   macro(_parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)</span>
4218 
4219 void java_lang_ClassLoader::compute_offsets() {



4220   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
4221   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4222 
4223   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4224 }
4225 
4226 #if INCLUDE_CDS
4227 void java_lang_ClassLoader::serialize_offsets(SerializeClosure* f) {
4228   CLASSLOADER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4229   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4230 }
4231 #endif
4232 
4233 oop java_lang_ClassLoader::parent(oop loader) {
4234   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4235   return loader-&gt;obj_field(_parent_offset);</span>
4236 }
4237 
4238 // Returns the name field of this class loader.  If the name field has not
4239 // been set, null will be returned.
4240 oop java_lang_ClassLoader::name(oop loader) {
4241   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4242   return loader-&gt;obj_field(_name_offset);</span>
4243 }
4244 
4245 // Returns the nameAndId field of this class loader. The format is
4246 // as follows:
4247 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
4248 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
4249 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
4250 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
4251 oop java_lang_ClassLoader::nameAndId(oop loader) {
4252   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4253   return loader-&gt;obj_field(_nameAndId_offset);</span>
4254 }
4255 
4256 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
4257   assert(is_instance(loader), &quot;loader must be oop&quot;);
4258   assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
4259   oop acl = loader;
4260   debug_only(jint loop_count = 0);
4261   // This loop taken verbatim from ClassLoader.java:
4262   do {
4263     acl = parent(acl);
4264     if (cl == acl) {
4265       return true;
4266     }
4267     assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
4268   } while (acl != NULL);
4269   return false;
4270 }
4271 
4272 bool java_lang_ClassLoader::is_instance(oop obj) {
4273   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
4274 }
4275 
4276 
4277 // For class loader classes, parallelCapable defined
4278 // based on non-null field
4279 // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
4280 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
<span class="line-modified">4281   assert(_parallelCapable_offset != 0, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">4282   return (class_loader-&gt;obj_field(_parallelCapable_offset) != NULL);</span>
4283 }
4284 
4285 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
4286   // Fix for 4474172; see evaluation for more details
4287   loader = non_reflection_class_loader(loader);
4288 
4289   oop cl = SystemDictionary::java_system_loader();
4290   while(cl != NULL) {
4291     if (cl == loader) return true;
4292     cl = parent(cl);
4293   }
4294   return false;
4295 }
4296 
4297 // Return true if this is one of the class loaders associated with
4298 // the generated bytecodes for reflection.
4299 bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {
4300   if (loader != NULL) {
4301     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
4302     // This might be null in non-1.4 JDKs
4303     return (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class));
4304   }
4305   return false;
4306 }
4307 
4308 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
4309   // See whether this is one of the class loaders associated with
4310   // the generated bytecodes for reflection, and if so, &quot;magically&quot;
4311   // delegate to its parent to prevent class loading from occurring
4312   // in places where applications using reflection didn&#39;t expect it.
4313   if (is_reflection_class_loader(loader)) {
4314     return parent(loader);
4315   }
4316   return loader;
4317 }
4318 
4319 oop java_lang_ClassLoader::unnamedModule(oop loader) {
4320   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4321   return loader-&gt;obj_field(_unnamedModule_offset);</span>
4322 }
4323 
4324 // Support for java_lang_System
4325 //
<span class="line-added">4326 </span>
<span class="line-added">4327 int java_lang_System::_static_in_offset;</span>
<span class="line-added">4328 int java_lang_System::_static_out_offset;</span>
<span class="line-added">4329 int java_lang_System::_static_err_offset;</span>
<span class="line-added">4330 int java_lang_System::_static_security_offset;</span>
<span class="line-added">4331 </span>
4332 #define SYSTEM_FIELDS_DO(macro) \
<span class="line-modified">4333   macro(_static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \</span>
<span class="line-modified">4334   macro(_static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \</span>
<span class="line-modified">4335   macro(_static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \</span>
<span class="line-modified">4336   macro(_static_security_offset, k, &quot;security&quot;, security_manager_signature, true)</span>
4337 
4338 void java_lang_System::compute_offsets() {
4339   InstanceKlass* k = SystemDictionary::System_klass();
4340   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4341 }
4342 
4343 #if INCLUDE_CDS
4344 void java_lang_System::serialize_offsets(SerializeClosure* f) {
4345    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4346 }
4347 #endif
4348 




4349 // Support for jdk_internal_misc_UnsafeConstants
4350 //
4351 class UnsafeConstantsFixup : public FieldClosure {
4352 private:
4353   int _address_size;
4354   int _page_size;
4355   bool _big_endian;
4356   bool _use_unaligned_access;
4357   int _data_cache_line_flush_size;
4358 public:
4359   UnsafeConstantsFixup() {
4360     // round up values for all static final fields
4361     _address_size = sizeof(void*);
4362     _page_size = os::vm_page_size();
4363     _big_endian = LITTLE_ENDIAN_ONLY(false) BIG_ENDIAN_ONLY(true);
4364     _use_unaligned_access = UseUnalignedAccesses;
4365     _data_cache_line_flush_size = (int)VM_Version::data_cache_line_flush_size();
4366   }
4367 
4368   void do_field(fieldDescriptor* fd) {
</pre>
<hr />
<pre>
4375       mirror-&gt;int_field_put(fd-&gt;offset(), _address_size);
4376     } else if (fd-&gt;name() == vmSymbols::page_size_name()) {
4377       mirror-&gt;int_field_put(fd-&gt;offset(), _page_size);
4378     } else if (fd-&gt;name() == vmSymbols::big_endian_name()) {
4379       mirror-&gt;bool_field_put(fd-&gt;offset(), _big_endian);
4380     } else if (fd-&gt;name() == vmSymbols::use_unaligned_access_name()) {
4381       mirror-&gt;bool_field_put(fd-&gt;offset(), _use_unaligned_access);
4382     } else if (fd-&gt;name() == vmSymbols::data_cache_line_flush_size_name()) {
4383       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4384     } else {
4385       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4386     }
4387   }
4388 };
4389 
4390 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4391   UnsafeConstantsFixup fixup;
4392   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4393 }
4394 







































































































4395 
<span class="line-added">4396 // java_lang_StackTraceElement</span>
4397 
<span class="line-added">4398 int java_lang_StackTraceElement::_methodName_offset;</span>
<span class="line-added">4399 int java_lang_StackTraceElement::_fileName_offset;</span>
<span class="line-added">4400 int java_lang_StackTraceElement::_lineNumber_offset;</span>
<span class="line-added">4401 int java_lang_StackTraceElement::_moduleName_offset;</span>
<span class="line-added">4402 int java_lang_StackTraceElement::_moduleVersion_offset;</span>
<span class="line-added">4403 int java_lang_StackTraceElement::_classLoaderName_offset;</span>
<span class="line-added">4404 int java_lang_StackTraceElement::_declaringClass_offset;</span>
<span class="line-added">4405 int java_lang_StackTraceElement::_declaringClassObject_offset;</span>
4406 
4407 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
<span class="line-modified">4408   macro(_declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \</span>
<span class="line-modified">4409   macro(_classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \</span>
<span class="line-modified">4410   macro(_moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \</span>
<span class="line-modified">4411   macro(_moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \</span>
<span class="line-modified">4412   macro(_declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \</span>
<span class="line-modified">4413   macro(_methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \</span>
<span class="line-modified">4414   macro(_fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \</span>
<span class="line-modified">4415   macro(_lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)</span>
4416 
4417 // Support for java_lang_StackTraceElement
4418 void java_lang_StackTraceElement::compute_offsets() {
4419   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4420   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4421 }
4422 
4423 #if INCLUDE_CDS
4424 void java_lang_StackTraceElement::serialize_offsets(SerializeClosure* f) {
4425   STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4426 }
4427 #endif
4428 
4429 void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
<span class="line-modified">4430   element-&gt;obj_field_put(_fileName_offset, value);</span>
4431 }
4432 
4433 void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
<span class="line-modified">4434   element-&gt;obj_field_put(_declaringClass_offset, value);</span>
4435 }
4436 
4437 void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
<span class="line-modified">4438   element-&gt;obj_field_put(_methodName_offset, value);</span>
4439 }
4440 
4441 void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
<span class="line-modified">4442   element-&gt;int_field_put(_lineNumber_offset, value);</span>
4443 }
4444 
4445 void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
<span class="line-modified">4446   element-&gt;obj_field_put(_moduleName_offset, value);</span>
4447 }
4448 
4449 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
<span class="line-modified">4450   element-&gt;obj_field_put(_moduleVersion_offset, value);</span>
4451 }
4452 
4453 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
<span class="line-modified">4454   element-&gt;obj_field_put(_classLoaderName_offset, value);</span>
4455 }
4456 
4457 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
<span class="line-modified">4458   element-&gt;obj_field_put(_declaringClassObject_offset, value);</span>
4459 }
4460 



4461 
<span class="line-modified">4462 // java_lang_AssertionStatusDirectives</span>















4463 
<span class="line-modified">4464 int java_lang_AssertionStatusDirectives::_classes_offset;</span>
<span class="line-modified">4465 int java_lang_AssertionStatusDirectives::_classEnabled_offset;</span>
<span class="line-modified">4466 int java_lang_AssertionStatusDirectives::_packages_offset;</span>
<span class="line-added">4467 int java_lang_AssertionStatusDirectives::_packageEnabled_offset;</span>
<span class="line-added">4468 int java_lang_AssertionStatusDirectives::_deflt_offset;</span>
4469 
4470 // Support for java Assertions - java_lang_AssertionStatusDirectives.
4471 #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
<span class="line-modified">4472   macro(_classes_offset,        k, &quot;classes&quot;,        string_array_signature, false); \</span>
<span class="line-modified">4473   macro(_classEnabled_offset,   k, &quot;classEnabled&quot;,   bool_array_signature, false); \</span>
<span class="line-modified">4474   macro(_packages_offset,       k, &quot;packages&quot;,       string_array_signature, false); \</span>
<span class="line-modified">4475   macro(_packageEnabled_offset, k, &quot;packageEnabled&quot;, bool_array_signature,   false); \</span>
<span class="line-modified">4476   macro(_deflt_offset,          k, &quot;deflt&quot;,          bool_signature,         false)</span>
4477 
4478 void java_lang_AssertionStatusDirectives::compute_offsets() {
4479   InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
4480   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4481 }
4482 
4483 #if INCLUDE_CDS
4484 void java_lang_AssertionStatusDirectives::serialize_offsets(SerializeClosure* f) {
4485   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4486 }
4487 #endif
4488 
4489 void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
<span class="line-modified">4490   o-&gt;obj_field_put(_classes_offset, val);</span>
4491 }
4492 
4493 void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
<span class="line-modified">4494   o-&gt;obj_field_put(_classEnabled_offset, val);</span>
4495 }
4496 
4497 void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
<span class="line-modified">4498   o-&gt;obj_field_put(_packages_offset, val);</span>
4499 }
4500 
4501 void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
<span class="line-modified">4502   o-&gt;obj_field_put(_packageEnabled_offset, val);</span>
4503 }
4504 
4505 void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
<span class="line-modified">4506   o-&gt;bool_field_put(_deflt_offset, val);</span>
4507 }
4508 
4509 
4510 // Support for intrinsification of java.nio.Buffer.checkIndex
<span class="line-modified">4511 </span>
<span class="line-modified">4512 int java_nio_Buffer::_limit_offset;</span>

4513 
4514 #define BUFFER_FIELDS_DO(macro) \
4515   macro(_limit_offset, k, &quot;limit&quot;, int_signature, false)
4516 
4517 void java_nio_Buffer::compute_offsets() {
4518   InstanceKlass* k = SystemDictionary::nio_Buffer_klass();
4519   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
4520   BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4521 }
4522 
4523 #if INCLUDE_CDS
4524 void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {
4525   BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4526 }
4527 #endif
4528 
<span class="line-added">4529 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;</span>
<span class="line-added">4530 </span>
4531 #define AOS_FIELDS_DO(macro) \
4532   macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
4533 
4534 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
4535   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
4536   AOS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4537 }
4538 
4539 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
4540   assert(_owner_offset != 0, &quot;Must be initialized&quot;);
4541   return obj-&gt;obj_field(_owner_offset);
4542 }
4543 
4544 #if INCLUDE_CDS
4545 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
4546   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4547 }
4548 #endif
4549 
<span class="line-added">4550 int java_lang_Integer_IntegerCache::_static_cache_offset;</span>
<span class="line-added">4551 int java_lang_Long_LongCache::_static_cache_offset;</span>
<span class="line-added">4552 int java_lang_Character_CharacterCache::_static_cache_offset;</span>
<span class="line-added">4553 int java_lang_Short_ShortCache::_static_cache_offset;</span>
<span class="line-added">4554 int java_lang_Byte_ByteCache::_static_cache_offset;</span>
<span class="line-added">4555 </span>
4556 #define INTEGER_CACHE_FIELDS_DO(macro) \
4557   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Integer_array_signature, true)
4558 
4559 void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {
4560   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4561   INTEGER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4562 }
4563 
4564 objArrayOop java_lang_Integer_IntegerCache::cache(InstanceKlass *ik) {
4565   oop base = ik-&gt;static_field_base_raw();
4566   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4567 }
4568 
4569 Symbol* java_lang_Integer_IntegerCache::symbol() {
4570   return vmSymbols::java_lang_Integer_IntegerCache();
4571 }
4572 
4573 #if INCLUDE_CDS
4574 void java_lang_Integer_IntegerCache::serialize_offsets(SerializeClosure* f) {
4575   INTEGER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
</pre>
<hr />
<pre>
4685   oop base = ik-&gt;static_field_base_raw();
4686   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4687 }
4688 
4689 Symbol* java_lang_Byte_ByteCache::symbol() {
4690   return vmSymbols::java_lang_Byte_ByteCache();
4691 }
4692 
4693 #if INCLUDE_CDS
4694 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4695   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4696 }
4697 #endif
4698 #undef BYTE_CACHE_FIELDS_DO
4699 
4700 jbyte java_lang_Byte::value(oop obj) {
4701    jvalue v;
4702    java_lang_boxing_object::get_value(obj, &amp;v);
4703    return v.b;
4704 }
<span class="line-added">4705 </span>
<span class="line-added">4706 int java_lang_Boolean::_static_TRUE_offset;</span>
<span class="line-added">4707 int java_lang_Boolean::_static_FALSE_offset;</span>
<span class="line-added">4708 </span>
4709 #define BOOLEAN_FIELDS_DO(macro) \
4710   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4711   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4712 
4713 
4714 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4715   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4716   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4717 }
4718 
4719 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4720   oop base = ik-&gt;static_field_base_raw();
4721   return base-&gt;obj_field(_static_TRUE_offset);
4722 }
4723 
4724 oop java_lang_Boolean::get_FALSE(InstanceKlass *ik) {
4725   oop base = ik-&gt;static_field_base_raw();
4726   return base-&gt;obj_field(_static_FALSE_offset);
4727 }
4728 
4729 Symbol* java_lang_Boolean::symbol() {
4730   return vmSymbols::java_lang_Boolean();
4731 }
4732 
4733 #if INCLUDE_CDS
4734 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
4735   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4736 }
4737 #endif
4738 #undef BOOLEAN_CACHE_FIELDS_DO
4739 
4740 jboolean java_lang_Boolean::value(oop obj) {
4741    jvalue v;
4742    java_lang_boxing_object::get_value(obj, &amp;v);
4743    return v.z;
4744 }
4745 
<span class="line-added">4746 // java_lang_reflect_RecordComponent</span>
<span class="line-added">4747 </span>
<span class="line-added">4748 int java_lang_reflect_RecordComponent::_clazz_offset;</span>
<span class="line-added">4749 int java_lang_reflect_RecordComponent::_name_offset;</span>
<span class="line-added">4750 int java_lang_reflect_RecordComponent::_type_offset;</span>
<span class="line-added">4751 int java_lang_reflect_RecordComponent::_accessor_offset;</span>
<span class="line-added">4752 int java_lang_reflect_RecordComponent::_signature_offset;</span>
<span class="line-added">4753 int java_lang_reflect_RecordComponent::_annotations_offset;</span>
<span class="line-added">4754 int java_lang_reflect_RecordComponent::_typeAnnotations_offset;</span>
<span class="line-added">4755 </span>
4756 #define RECORDCOMPONENT_FIELDS_DO(macro) \
<span class="line-modified">4757   macro(_clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \</span>
<span class="line-modified">4758   macro(_name_offset,        k, &quot;name&quot;,        string_signature, false); \</span>
<span class="line-modified">4759   macro(_type_offset,        k, &quot;type&quot;,        class_signature,  false); \</span>
<span class="line-modified">4760   macro(_accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \</span>
<span class="line-modified">4761   macro(_signature_offset,   k, &quot;signature&quot;,   string_signature, false); \</span>
<span class="line-modified">4762   macro(_annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \</span>
<span class="line-modified">4763   macro(_typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);</span>
4764 
4765 // Support for java_lang_reflect_RecordComponent
4766 void java_lang_reflect_RecordComponent::compute_offsets() {
4767   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
4768   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4769 }
4770 
4771 #if INCLUDE_CDS
4772 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
4773   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4774 }
4775 #endif
4776 
4777 void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {
<span class="line-modified">4778   element-&gt;obj_field_put(_clazz_offset, value);</span>
4779 }
4780 
4781 void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {
<span class="line-modified">4782   element-&gt;obj_field_put(_name_offset, value);</span>
4783 }
4784 
4785 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
<span class="line-modified">4786   element-&gt;obj_field_put(_type_offset, value);</span>
4787 }
4788 
4789 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
<span class="line-modified">4790   element-&gt;obj_field_put(_accessor_offset, value);</span>
4791 }
4792 
4793 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
<span class="line-modified">4794   element-&gt;obj_field_put(_signature_offset, value);</span>
4795 }
4796 
4797 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
<span class="line-modified">4798   element-&gt;obj_field_put(_annotations_offset, value);</span>
4799 }
4800 
4801 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
<span class="line-modified">4802   element-&gt;obj_field_put(_typeAnnotations_offset, value);</span>
4803 }
4804 
4805 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4806 
<span class="line-modified">4807 // Compute field offsets of all the classes in this file</span>
4808 void JavaClasses::compute_offsets() {
4809   if (UseSharedSpaces) {
4810     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4811                                                          JvmtiExport::has_early_class_hook_env()),
4812                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
4813     // None of the classes used by the rest of this function can be replaced by
<span class="line-modified">4814     // JVMTI ClassFileLoadHook.</span>
4815     // We are safe to use the archived offsets, which have already been restored
4816     // by JavaClasses::serialize_offsets, without computing the offsets again.
4817     return;
4818   }
4819 
4820   // We have already called the compute_offsets() of the
4821   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String, java_lang_Class and
4822   // java_lang_ref_Reference) earlier inside SystemDictionary::resolve_well_known_classes()
4823   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4824 }
4825 
4826 #if INCLUDE_CDS
4827 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4828 
4829 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4830   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4831 }
4832 #endif
4833 
4834 #if INCLUDE_CDS_JAVA_HEAP
</pre>
<hr />
<pre>
4839       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed
4840       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in
4841       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes
4842       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.
4843       // So for now we cannot not support these classes for archiving.
4844       //
4845       // These objects typically are not referenced by static fields, but rather by resolved
4846       // constant pool entries, so excluding them shouldn&#39;t affect the archiving of static fields.
4847       klass == SystemDictionary::ResolvedMethodName_klass() ||
4848       klass == SystemDictionary::MemberName_klass() ||
4849       klass == SystemDictionary::Context_klass()) {
4850     return false;
4851   }
4852 
4853   return true;
4854 }
4855 #endif
4856 
4857 #ifndef PRODUCT
4858 
<span class="line-modified">4859 // These functions exist to assert the validity of de-serialized offsets in boxing object as a sanity check.</span>

4860 
<span class="line-modified">4861 bool JavaClasses::check_offset(const char *klass_name, int deserialized_offset, const char *field_name,</span>
<span class="line-added">4862                                const char* field_sig) {</span>
4863   EXCEPTION_MARK;
4864   fieldDescriptor fd;
4865   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);
4866   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
4867   InstanceKlass* ik = InstanceKlass::cast(k);
4868   TempNewSymbol f_name = SymbolTable::new_symbol(field_name);
4869   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig);
4870   if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
4871     tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
4872     return false;
4873   }
4874   if (fd.is_static()) {
4875     tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
4876     return false;
4877   }
<span class="line-modified">4878   if (fd.offset() == deserialized_offset ) {</span>
4879     return true;
4880   } else {
<span class="line-modified">4881     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is deserialized as %d but should really be %d.&quot;,</span>
<span class="line-modified">4882                   klass_name, field_name, deserialized_offset, fd.offset());</span>
4883     return false;
4884   }
4885 }
4886 


4887 void JavaClasses::check_offsets() {
4888   bool valid = true;
4889 
4890 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
<span class="line-modified">4891   valid &amp;= check_offset(klass_name, cpp_klass_name :: _##field_name ## _offset, #field_name, field_sig)</span>
4892 
4893 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
<span class="line-modified">4894   valid &amp;= check_offset(klass_name, cpp_klass_name :: _##long_ ## field_name ## _offset, #field_name, field_sig)</span>
4895 
4896   // Boxed primitive objects (java_lang_boxing_object)
4897 
4898   CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
4899   CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
4900   CHECK_OFFSET(&quot;java/lang/Float&quot;,     java_lang_boxing_object, value, &quot;F&quot;);
4901   CHECK_LONG_OFFSET(&quot;java/lang/Double&quot;, java_lang_boxing_object, value, &quot;D&quot;);
4902   CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
4903   CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
4904   CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
4905   CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
4906 
<span class="line-modified">4907   if (!valid) vm_exit_during_initialization(&quot;Field offset verification failed&quot;);</span>
4908 }
4909 
4910 #endif // PRODUCT
4911 
4912 int InjectedField::compute_offset() {
4913   InstanceKlass* ik = InstanceKlass::cast(klass());
4914   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
4915     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
4916       // Only look at injected fields
4917       continue;
4918     }
4919     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
4920       return fs.offset();
4921     }
4922   }
4923   ResourceMark rm;
4924   tty-&gt;print_cr(&quot;Invalid layout of %s at %s/%s%s&quot;, ik-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? &quot; (may_be_java)&quot; : &quot;&quot;);
4925 #ifndef PRODUCT
4926   ik-&gt;print();
4927   tty-&gt;print_cr(&quot;all fields:&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="compactHashtable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
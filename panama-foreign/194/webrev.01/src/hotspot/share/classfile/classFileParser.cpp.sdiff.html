<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../ci/ciInstanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3195   _nest_members = nest_members;
3196 
3197   int index = 0;
3198   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3199   for (int n = 0; n &lt; length; n++) {
3200     const u2 class_info_index = cfs-&gt;get_u2_fast();
3201     check_property(
3202       valid_klass_reference_at(class_info_index),
3203       &quot;Nest member class_info_index %u has bad constant type in class file %s&quot;,
3204       class_info_index, CHECK_0);
3205     nest_members-&gt;at_put(index++, class_info_index);
3206   }
3207   assert(index == size, &quot;wrong size&quot;);
3208 
3209   // Restore buffer&#39;s current position.
3210   cfs-&gt;set_current(current_mark);
3211 
3212   return length;
3213 }
3214 



































3215 //  Record {
3216 //    u2 attribute_name_index;
3217 //    u4 attribute_length;
3218 //    u2 components_count;
3219 //    component_info components[components_count];
3220 //  }
3221 //  component_info {
3222 //    u2 name_index;
3223 //    u2 descriptor_index
3224 //    u2 attributes_count;
3225 //    attribute_info_attributes[attributes_count];
3226 //  }
3227 u2 ClassFileParser::parse_classfile_record_attribute(const ClassFileStream* const cfs,
3228                                                      const ConstantPool* cp,
3229                                                      const u1* const record_attribute_start,
3230                                                      TRAPS) {
3231   const u1* const current_mark = cfs-&gt;current();
3232   int components_count = 0;
3233   unsigned int calculate_attr_size = 0;
3234   if (record_attribute_start != NULL) {
</pre>
<hr />
<pre>
3459     operands-&gt;at_put(operand_fill_index++, bootstrap_method_index);
3460     operands-&gt;at_put(operand_fill_index++, argument_count);
3461 
3462     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3463     for (int j = 0; j &lt; argument_count; j++) {
3464       const u2 argument_index = cfs-&gt;get_u2_fast();
3465       check_property(
3466         valid_cp_range(argument_index, cp_size) &amp;&amp;
3467         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3468         &quot;argument_index %u has bad constant type in class file %s&quot;,
3469         argument_index,
3470         CHECK);
3471       operands-&gt;at_put(operand_fill_index++, argument_index);
3472     }
3473   }
3474   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3475                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3476                      CHECK);
3477 }
3478 






3479 bool ClassFileParser::supports_records() {
3480   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
<span class="line-modified">3481     _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;</span>
<span class="line-modified">3482     Arguments::enable_preview();</span>
3483 }
3484 
3485 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3486                                                  ConstantPool* cp,
3487                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3488                                                  TRAPS) {
3489   assert(cfs != NULL, &quot;invariant&quot;);
3490   assert(cp != NULL, &quot;invariant&quot;);
3491   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3492 
3493   // Set inner classes attribute to default sentinel
3494   _inner_classes = Universe::the_empty_short_array();
3495   // Set nest members attribute to default sentinel
3496   _nest_members = Universe::the_empty_short_array();


3497   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3498   u2 attributes_count = cfs-&gt;get_u2_fast();
3499   bool parsed_sourcefile_attribute = false;
3500   bool parsed_innerclasses_attribute = false;
3501   bool parsed_nest_members_attribute = false;

3502   bool parsed_nest_host_attribute = false;
3503   bool parsed_record_attribute = false;
3504   bool parsed_enclosingmethod_attribute = false;
3505   bool parsed_bootstrap_methods_attribute = false;
3506   const u1* runtime_visible_annotations = NULL;
3507   int runtime_visible_annotations_length = 0;
3508   const u1* runtime_invisible_annotations = NULL;
3509   int runtime_invisible_annotations_length = 0;
3510   const u1* runtime_visible_type_annotations = NULL;
3511   int runtime_visible_type_annotations_length = 0;
3512   const u1* runtime_invisible_type_annotations = NULL;
3513   int runtime_invisible_type_annotations_length = 0;
3514   bool runtime_invisible_type_annotations_exists = false;
3515   bool runtime_invisible_annotations_exists = false;
3516   bool parsed_source_debug_ext_annotations_exist = false;
3517   const u1* inner_classes_attribute_start = NULL;
3518   u4  inner_classes_attribute_length = 0;
3519   u2  enclosing_method_class_index = 0;
3520   u2  enclosing_method_method_index = 0;
3521   const u1* nest_members_attribute_start = NULL;
3522   u4  nest_members_attribute_length = 0;
3523   const u1* record_attribute_start = NULL;
3524   u4  record_attribute_length = 0;


3525 
3526   // Iterate over attributes
3527   while (attributes_count--) {
3528     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3529     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3530     const u4 attribute_length = cfs-&gt;get_u4_fast();
3531     check_property(
3532       valid_symbol_at(attribute_name_index),
3533       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3534       attribute_name_index, CHECK);
3535     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3536     if (tag == vmSymbols::tag_source_file()) {
3537       // Check for SourceFile tag
3538       if (_need_verify) {
3539         guarantee_property(attribute_length == 2, &quot;Wrong SourceFile attribute length in class file %s&quot;, CHECK);
3540       }
3541       if (parsed_sourcefile_attribute) {
3542         classfile_parse_error(&quot;Multiple SourceFile attributes in class file %s&quot;, CHECK);
3543       } else {
3544         parsed_sourcefile_attribute = true;
</pre>
<hr />
<pre>
3721               parsed_record_attribute = true;
3722               record_attribute_start = cfs-&gt;current();
3723               record_attribute_length = attribute_length;
3724             } else if (log_is_enabled(Info, class, record)) {
3725               // Log why the Record attribute was ignored.  Note that if the
3726               // class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and
3727               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError
3728               // exception would have been thrown.
3729               ResourceMark rm(THREAD);
3730               if (supports_records()) {
3731                 log_info(class, record)(
3732                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,
3733                   _class_name-&gt;as_C_string());
3734               } else {
3735                 log_info(class, record)(
3736                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,
3737                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);
3738               }
3739             }
3740             cfs-&gt;skip_u1(attribute_length, CHECK);




















3741           } else {
3742             // Unknown attribute
3743             cfs-&gt;skip_u1(attribute_length, CHECK);
3744           }
3745         } else {
3746           // Unknown attribute
3747           cfs-&gt;skip_u1(attribute_length, CHECK);
3748         }
3749       } else {
3750         // Unknown attribute
3751         cfs-&gt;skip_u1(attribute_length, CHECK);
3752       }
3753     } else {
3754       // Unknown attribute
3755       cfs-&gt;skip_u1(attribute_length, CHECK);
3756     }
3757   }
3758   _class_annotations = assemble_annotations(runtime_visible_annotations,
3759                                             runtime_visible_annotations_length,
3760                                             runtime_invisible_annotations,
</pre>
<hr />
<pre>
3789     if (_need_verify) {
3790       guarantee_property(
3791         nest_members_attribute_length == sizeof(num_of_classes) + sizeof(u2) * num_of_classes,
3792         &quot;Wrong NestMembers attribute length in class file %s&quot;, CHECK);
3793     }
3794   }
3795 
3796   if (parsed_record_attribute) {
3797     const unsigned int calculated_attr_length = parse_classfile_record_attribute(
3798                             cfs,
3799                             cp,
3800                             record_attribute_start,
3801                             CHECK);
3802     if (_need_verify) {
3803       guarantee_property(record_attribute_length == calculated_attr_length,
3804                          &quot;Record attribute has wrong length in class file %s&quot;,
3805                          CHECK);
3806     }
3807   }
3808 












3809   if (_max_bootstrap_specifier_index &gt;= 0) {
3810     guarantee_property(parsed_bootstrap_methods_attribute,
3811                        &quot;Missing BootstrapMethods attribute in class file %s&quot;, CHECK);
3812   }
3813 }
3814 
3815 void ClassFileParser::apply_parsed_class_attributes(InstanceKlass* k) {
3816   assert(k != NULL, &quot;invariant&quot;);
3817 
3818   if (_synthetic_flag)
3819     k-&gt;set_is_synthetic();
3820   if (_sourcefile_index != 0) {
3821     k-&gt;set_source_file_name_index(_sourcefile_index);
3822   }
3823   if (_generic_signature_index != 0) {
3824     k-&gt;set_generic_signature_index(_generic_signature_index);
3825   }
3826   if (_sde_buffer != NULL) {
3827     k-&gt;set_source_debug_extension(_sde_buffer, _sde_length);
3828   }
</pre>
<hr />
<pre>
3856     _fields_annotations      = NULL;
3857     _fields_type_annotations = NULL;
3858 }
3859 
3860 // Transfer ownership of metadata allocated to the InstanceKlass.
3861 void ClassFileParser::apply_parsed_class_metadata(
3862                                             InstanceKlass* this_klass,
3863                                             int java_fields_count,
3864                                             TRAPS) {
3865   assert(this_klass != NULL, &quot;invariant&quot;);
3866 
3867   _cp-&gt;set_pool_holder(this_klass);
3868   this_klass-&gt;set_constants(_cp);
3869   this_klass-&gt;set_fields(_fields, java_fields_count);
3870   this_klass-&gt;set_methods(_methods);
3871   this_klass-&gt;set_inner_classes(_inner_classes);
3872   this_klass-&gt;set_nest_members(_nest_members);
3873   this_klass-&gt;set_nest_host_index(_nest_host);
3874   this_klass-&gt;set_local_interfaces(_local_interfaces);
3875   this_klass-&gt;set_annotations(_combined_annotations);

3876   this_klass-&gt;set_record_components(_record_components);
3877   // Delay the setting of _transitive_interfaces until after initialize_supers() in
3878   // fill_instance_klass(). It is because the _transitive_interfaces may be shared with
3879   // its _super. If an OOM occurs while loading the current klass, its _super field
3880   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
3881   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
3882   // dereferences to the deallocated _transitive_interfaces will result in a crash.
3883 
3884   // Clear out these fields so they don&#39;t get deallocated by the destructor
3885   clear_class_metadata();
3886 }
3887 
3888 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
3889                                                        int runtime_visible_annotations_length,
3890                                                        const u1* const runtime_invisible_annotations,
3891                                                        int runtime_invisible_annotations_length,
3892                                                        TRAPS) {
3893   AnnotationArray* annotations = NULL;
3894   if (runtime_visible_annotations != NULL ||
3895       runtime_invisible_annotations != NULL) {
</pre>
<hr />
<pre>
4664 
4665     // length will be less than the max_transitive_size if duplicates were removed
4666     const int length = result-&gt;length();
4667     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
4668     Array&lt;InstanceKlass*&gt;* const new_result =
4669       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4670     for (int i = 0; i &lt; length; i++) {
4671       InstanceKlass* const e = result-&gt;at(i);
4672       assert(e != NULL, &quot;just checking&quot;);
4673       new_result-&gt;at_put(i, e);
4674     }
4675     return new_result;
4676   }
4677 }
4678 
4679 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4680   assert(this_klass != NULL, &quot;invariant&quot;);
4681   const Klass* const super = this_klass-&gt;super();
4682 
4683   if (super != NULL) {























4684 
4685     // If the loader is not the boot loader then throw an exception if its
4686     // superclass is in package jdk.internal.reflect and its loader is not a
4687     // special reflection class loader
4688     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {
<span class="line-removed">4689       assert(super-&gt;is_instance_klass(), &quot;super is not instance klass&quot;);</span>
4690       PackageEntry* super_package = super-&gt;package();
4691       if (super_package != NULL &amp;&amp;
4692           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
4693           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
4694         ResourceMark rm(THREAD);
4695         Exceptions::fthrow(
4696           THREAD_AND_LOCATION,
4697           vmSymbols::java_lang_IllegalAccessError(),
4698           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
4699           this_klass-&gt;external_name(),
4700           this_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
4701           super-&gt;external_name());
4702         return;
4703       }
4704     }
4705 
4706     Reflection::VerifyClassAccessResults vca_result =
4707       Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);
4708     if (vca_result != Reflection::ACCESS_OK) {
4709       ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
4725       } else {
4726         // Add additional message content.
4727         Exceptions::fthrow(
4728           THREAD_AND_LOCATION,
4729           vmSymbols::java_lang_IllegalAccessError(),
4730           &quot;superclass access check failed: %s&quot;,
4731           msg);
4732       }
4733     }
4734   }
4735 }
4736 
4737 
4738 static void check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {
4739   assert(this_klass != NULL, &quot;invariant&quot;);
4740   const Array&lt;InstanceKlass*&gt;* const local_interfaces = this_klass-&gt;local_interfaces();
4741   const int lng = local_interfaces-&gt;length();
4742   for (int i = lng - 1; i &gt;= 0; i--) {
4743     InstanceKlass* const k = local_interfaces-&gt;at(i);
4744     assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);













4745     Reflection::VerifyClassAccessResults vca_result =
4746       Reflection::verify_class_access(this_klass, k, false);
4747     if (vca_result != Reflection::ACCESS_OK) {
4748       ResourceMark rm(THREAD);
4749       char* msg = Reflection::verify_class_access_msg(this_klass,
4750                                                       k,
4751                                                       vca_result);
4752       if (msg == NULL) {
4753         bool same_module = (this_klass-&gt;module() == k-&gt;module());
4754         Exceptions::fthrow(
4755           THREAD_AND_LOCATION,
4756           vmSymbols::java_lang_IllegalAccessError(),
4757           &quot;class %s cannot access its superinterface %s (%s%s%s)&quot;,
4758           this_klass-&gt;external_name(),
4759           k-&gt;external_name(),
4760           (same_module) ? this_klass-&gt;joint_in_module_of_loader(k) : this_klass-&gt;class_in_module_of_loader(),
4761           (same_module) ? &quot;&quot; : &quot;; &quot;,
4762           (same_module) ? &quot;&quot; : k-&gt;class_in_module_of_loader());
4763       } else {
4764         // Add additional message content.
</pre>
<hr />
<pre>
5660   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);
5661 
5662   // this transfers ownership of a lot of arrays from
5663   // the parser onto the InstanceKlass*
5664   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5665 
5666   // can only set dynamic nest-host after static nest information is set
5667   if (cl_inst_info.dynamic_nest_host() != NULL) {
5668     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
5669   }
5670 
5671   // note that is not safe to use the fields in the parser from this point on
5672   assert(NULL == _cp, &quot;invariant&quot;);
5673   assert(NULL == _fields, &quot;invariant&quot;);
5674   assert(NULL == _methods, &quot;invariant&quot;);
5675   assert(NULL == _inner_classes, &quot;invariant&quot;);
5676   assert(NULL == _nest_members, &quot;invariant&quot;);
5677   assert(NULL == _local_interfaces, &quot;invariant&quot;);
5678   assert(NULL == _combined_annotations, &quot;invariant&quot;);
5679   assert(NULL == _record_components, &quot;invariant&quot;);

5680 
5681   if (_has_final_method) {
5682     ik-&gt;set_has_final_method();
5683   }
5684 
5685   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
5686   // The InstanceKlass::_methods_jmethod_ids cache
5687   // is managed on the assumption that the initial cache
5688   // size is equal to the number of methods in the class. If
5689   // that changes, then InstanceKlass::idnum_can_increment()
5690   // has to be changed accordingly.
5691   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5692 
5693   ik-&gt;set_this_class_index(_this_class_index);
5694 
5695   if (_is_hidden || is_unsafe_anonymous()) {
5696     // _this_class_index is a CONSTANT_Class entry that refers to this
5697     // hidden or anonymous class itself. If this class needs to refer to its own
5698     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
5699     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
</pre>
<hr />
<pre>
5948                                  Publicity pub_level,
5949                                  TRAPS) :
5950   _stream(stream),
5951   _class_name(NULL),
5952   _loader_data(loader_data),
5953   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
5954   _cp_patches(cl_info-&gt;cp_patches()),
5955   _is_hidden(cl_info-&gt;is_hidden()),
5956   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
5957   _num_patched_klasses(0),
5958   _max_num_patched_klasses(0),
5959   _orig_cp_size(0),
5960   _first_patched_klass_resolved_index(0),
5961   _super_klass(),
5962   _cp(NULL),
5963   _fields(NULL),
5964   _methods(NULL),
5965   _inner_classes(NULL),
5966   _nest_members(NULL),
5967   _nest_host(0),

5968   _record_components(NULL),
5969   _local_interfaces(NULL),
5970   _transitive_interfaces(NULL),
5971   _combined_annotations(NULL),
5972   _class_annotations(NULL),
5973   _class_type_annotations(NULL),
5974   _fields_annotations(NULL),
5975   _fields_type_annotations(NULL),
5976   _klass(NULL),
5977   _klass_to_deallocate(NULL),
5978   _parsed_annotations(NULL),
5979   _fac(NULL),
5980   _field_info(NULL),
5981   _method_ordering(NULL),
5982   _all_mirandas(NULL),
5983   _vtable_size(0),
5984   _itable_size(0),
5985   _num_miranda_methods(0),
5986   _rt(REF_NONE),
5987   _protection_domain(cl_info-&gt;protection_domain()),
</pre>
<hr />
<pre>
6056   // synch back verification state to stream
6057   stream-&gt;set_verify(_need_verify);
6058 
6059   // Check if verification needs to be relaxed for this class file
6060   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
6061   _relax_verify = relax_format_check_for(_loader_data);
6062 
6063   parse_stream(stream, CHECK);
6064 
6065   post_process_parsed_stream(stream, _cp, CHECK);
6066 }
6067 
6068 void ClassFileParser::clear_class_metadata() {
6069   // metadata created before the instance klass is created.  Must be
6070   // deallocated if classfile parsing returns an error.
6071   _cp = NULL;
6072   _fields = NULL;
6073   _methods = NULL;
6074   _inner_classes = NULL;
6075   _nest_members = NULL;

6076   _local_interfaces = NULL;
6077   _combined_annotations = NULL;
6078   _class_annotations = _class_type_annotations = NULL;
6079   _fields_annotations = _fields_type_annotations = NULL;
6080   _record_components = NULL;
6081 }
6082 
6083 // Destructor to clean up
6084 ClassFileParser::~ClassFileParser() {
6085   _class_name-&gt;decrement_refcount();
6086 
6087   if (_cp != NULL) {
6088     MetadataFactory::free_metadata(_loader_data, _cp);
6089   }
6090   if (_fields != NULL) {
6091     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
6092   }
6093 
6094   if (_methods != NULL) {
6095     // Free methods
6096     InstanceKlass::deallocate_methods(_loader_data, _methods);
6097   }
6098 
6099   // beware of the Universe::empty_blah_array!!
6100   if (_inner_classes != NULL &amp;&amp; _inner_classes != Universe::the_empty_short_array()) {
6101     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _inner_classes);
6102   }
6103 
6104   if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {
6105     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _nest_members);
6106   }
6107 
6108   if (_record_components != NULL) {
6109     InstanceKlass::deallocate_record_components(_loader_data, _record_components);
6110   }
6111 




6112   // Free interfaces
6113   InstanceKlass::deallocate_interfaces(_loader_data, _super_klass,
6114                                        _local_interfaces, _transitive_interfaces);
6115 
6116   if (_combined_annotations != NULL) {
6117     // After all annotations arrays have been created, they are installed into the
6118     // Annotations object that will be assigned to the InstanceKlass being created.
6119 
6120     // Deallocate the Annotations object and the installed annotations arrays.
6121     _combined_annotations-&gt;deallocate_contents(_loader_data);
6122 
6123     // If the _combined_annotations pointer is non-NULL,
6124     // then the other annotations fields should have been cleared.
6125     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);
6126     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);
6127     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
6128     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
6129   } else {
6130     // If the annotations arrays were not installed into the Annotations object,
6131     // then they have to be deallocated explicitly.
</pre>
<hr />
<pre>
6490                                                                true,
6491                                                                CHECK);
6492   }
6493 
6494   if (_super_klass != NULL) {
6495     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6496       _has_nonstatic_concrete_methods = true;
6497     }
6498 
6499     if (_super_klass-&gt;is_interface()) {
6500       ResourceMark rm(THREAD);
6501       Exceptions::fthrow(
6502         THREAD_AND_LOCATION,
6503         vmSymbols::java_lang_IncompatibleClassChangeError(),
6504         &quot;class %s has interface %s as super class&quot;,
6505         _class_name-&gt;as_klass_external_name(),
6506         _super_klass-&gt;external_name()
6507       );
6508       return;
6509     }
<span class="line-removed">6510     // Make sure super class is not final</span>
<span class="line-removed">6511     if (_super_klass-&gt;is_final()) {</span>
<span class="line-removed">6512       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);</span>
<span class="line-removed">6513     }</span>
6514   }
6515 
6516   // Compute the transitive list of all unique interfaces implemented by this class
6517   _transitive_interfaces =
6518     compute_transitive_interfaces(_super_klass,
6519                                   _local_interfaces,
6520                                   _loader_data,
6521                                   CHECK);
6522 
6523   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6524 
6525   // sort methods
6526   _method_ordering = sort_methods(_methods);
6527 
6528   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6529 
6530   Handle loader(THREAD, _loader_data-&gt;class_loader());
6531   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6532                                                     &amp;_num_miranda_methods,
6533                                                     _all_mirandas,
</pre>
</td>
<td>
<hr />
<pre>
3195   _nest_members = nest_members;
3196 
3197   int index = 0;
3198   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3199   for (int n = 0; n &lt; length; n++) {
3200     const u2 class_info_index = cfs-&gt;get_u2_fast();
3201     check_property(
3202       valid_klass_reference_at(class_info_index),
3203       &quot;Nest member class_info_index %u has bad constant type in class file %s&quot;,
3204       class_info_index, CHECK_0);
3205     nest_members-&gt;at_put(index++, class_info_index);
3206   }
3207   assert(index == size, &quot;wrong size&quot;);
3208 
3209   // Restore buffer&#39;s current position.
3210   cfs-&gt;set_current(current_mark);
3211 
3212   return length;
3213 }
3214 
<span class="line-added">3215 u2 ClassFileParser::parse_classfile_permitted_subclasses_attribute(const ClassFileStream* const cfs,</span>
<span class="line-added">3216                                                                    const u1* const permitted_subclasses_attribute_start,</span>
<span class="line-added">3217                                                                    TRAPS) {</span>
<span class="line-added">3218   const u1* const current_mark = cfs-&gt;current();</span>
<span class="line-added">3219   u2 length = 0;</span>
<span class="line-added">3220   if (permitted_subclasses_attribute_start != NULL) {</span>
<span class="line-added">3221     cfs-&gt;set_current(permitted_subclasses_attribute_start);</span>
<span class="line-added">3222     cfs-&gt;guarantee_more(2, CHECK_0);  // length</span>
<span class="line-added">3223     length = cfs-&gt;get_u2_fast();</span>
<span class="line-added">3224   }</span>
<span class="line-added">3225   if (length &lt; 1) {</span>
<span class="line-added">3226     classfile_parse_error(&quot;PermittedSubclasses attribute is empty in class file %s&quot;, CHECK_0);</span>
<span class="line-added">3227   }</span>
<span class="line-added">3228   const int size = length;</span>
<span class="line-added">3229   Array&lt;u2&gt;* const permitted_subclasses = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);</span>
<span class="line-added">3230   _permitted_subclasses = permitted_subclasses;</span>
<span class="line-added">3231 </span>
<span class="line-added">3232   int index = 0;</span>
<span class="line-added">3233   cfs-&gt;guarantee_more(2 * length, CHECK_0);</span>
<span class="line-added">3234   for (int n = 0; n &lt; length; n++) {</span>
<span class="line-added">3235     const u2 class_info_index = cfs-&gt;get_u2_fast();</span>
<span class="line-added">3236     check_property(</span>
<span class="line-added">3237       valid_klass_reference_at(class_info_index),</span>
<span class="line-added">3238       &quot;Permitted subclass class_info_index %u has bad constant type in class file %s&quot;,</span>
<span class="line-added">3239       class_info_index, CHECK_0);</span>
<span class="line-added">3240     permitted_subclasses-&gt;at_put(index++, class_info_index);</span>
<span class="line-added">3241   }</span>
<span class="line-added">3242   assert(index == size, &quot;wrong size&quot;);</span>
<span class="line-added">3243 </span>
<span class="line-added">3244   // Restore buffer&#39;s current position.</span>
<span class="line-added">3245   cfs-&gt;set_current(current_mark);</span>
<span class="line-added">3246 </span>
<span class="line-added">3247   return length;</span>
<span class="line-added">3248 }</span>
<span class="line-added">3249 </span>
3250 //  Record {
3251 //    u2 attribute_name_index;
3252 //    u4 attribute_length;
3253 //    u2 components_count;
3254 //    component_info components[components_count];
3255 //  }
3256 //  component_info {
3257 //    u2 name_index;
3258 //    u2 descriptor_index
3259 //    u2 attributes_count;
3260 //    attribute_info_attributes[attributes_count];
3261 //  }
3262 u2 ClassFileParser::parse_classfile_record_attribute(const ClassFileStream* const cfs,
3263                                                      const ConstantPool* cp,
3264                                                      const u1* const record_attribute_start,
3265                                                      TRAPS) {
3266   const u1* const current_mark = cfs-&gt;current();
3267   int components_count = 0;
3268   unsigned int calculate_attr_size = 0;
3269   if (record_attribute_start != NULL) {
</pre>
<hr />
<pre>
3494     operands-&gt;at_put(operand_fill_index++, bootstrap_method_index);
3495     operands-&gt;at_put(operand_fill_index++, argument_count);
3496 
3497     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3498     for (int j = 0; j &lt; argument_count; j++) {
3499       const u2 argument_index = cfs-&gt;get_u2_fast();
3500       check_property(
3501         valid_cp_range(argument_index, cp_size) &amp;&amp;
3502         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3503         &quot;argument_index %u has bad constant type in class file %s&quot;,
3504         argument_index,
3505         CHECK);
3506       operands-&gt;at_put(operand_fill_index++, argument_index);
3507     }
3508   }
3509   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3510                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3511                      CHECK);
3512 }
3513 
<span class="line-added">3514 bool ClassFileParser::supports_sealed_types() {</span>
<span class="line-added">3515   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;</span>
<span class="line-added">3516          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;</span>
<span class="line-added">3517          Arguments::enable_preview();</span>
<span class="line-added">3518 }</span>
<span class="line-added">3519 </span>
3520 bool ClassFileParser::supports_records() {
3521   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
<span class="line-modified">3522          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;</span>
<span class="line-modified">3523          Arguments::enable_preview();</span>
3524 }
3525 
3526 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3527                                                  ConstantPool* cp,
3528                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3529                                                  TRAPS) {
3530   assert(cfs != NULL, &quot;invariant&quot;);
3531   assert(cp != NULL, &quot;invariant&quot;);
3532   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3533 
3534   // Set inner classes attribute to default sentinel
3535   _inner_classes = Universe::the_empty_short_array();
3536   // Set nest members attribute to default sentinel
3537   _nest_members = Universe::the_empty_short_array();
<span class="line-added">3538   // Set _permitted_subclasses attribute to default sentinel</span>
<span class="line-added">3539   _permitted_subclasses = Universe::the_empty_short_array();</span>
3540   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3541   u2 attributes_count = cfs-&gt;get_u2_fast();
3542   bool parsed_sourcefile_attribute = false;
3543   bool parsed_innerclasses_attribute = false;
3544   bool parsed_nest_members_attribute = false;
<span class="line-added">3545   bool parsed_permitted_subclasses_attribute = false;</span>
3546   bool parsed_nest_host_attribute = false;
3547   bool parsed_record_attribute = false;
3548   bool parsed_enclosingmethod_attribute = false;
3549   bool parsed_bootstrap_methods_attribute = false;
3550   const u1* runtime_visible_annotations = NULL;
3551   int runtime_visible_annotations_length = 0;
3552   const u1* runtime_invisible_annotations = NULL;
3553   int runtime_invisible_annotations_length = 0;
3554   const u1* runtime_visible_type_annotations = NULL;
3555   int runtime_visible_type_annotations_length = 0;
3556   const u1* runtime_invisible_type_annotations = NULL;
3557   int runtime_invisible_type_annotations_length = 0;
3558   bool runtime_invisible_type_annotations_exists = false;
3559   bool runtime_invisible_annotations_exists = false;
3560   bool parsed_source_debug_ext_annotations_exist = false;
3561   const u1* inner_classes_attribute_start = NULL;
3562   u4  inner_classes_attribute_length = 0;
3563   u2  enclosing_method_class_index = 0;
3564   u2  enclosing_method_method_index = 0;
3565   const u1* nest_members_attribute_start = NULL;
3566   u4  nest_members_attribute_length = 0;
3567   const u1* record_attribute_start = NULL;
3568   u4  record_attribute_length = 0;
<span class="line-added">3569   const u1* permitted_subclasses_attribute_start = NULL;</span>
<span class="line-added">3570   u4  permitted_subclasses_attribute_length = 0;</span>
3571 
3572   // Iterate over attributes
3573   while (attributes_count--) {
3574     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3575     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3576     const u4 attribute_length = cfs-&gt;get_u4_fast();
3577     check_property(
3578       valid_symbol_at(attribute_name_index),
3579       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3580       attribute_name_index, CHECK);
3581     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3582     if (tag == vmSymbols::tag_source_file()) {
3583       // Check for SourceFile tag
3584       if (_need_verify) {
3585         guarantee_property(attribute_length == 2, &quot;Wrong SourceFile attribute length in class file %s&quot;, CHECK);
3586       }
3587       if (parsed_sourcefile_attribute) {
3588         classfile_parse_error(&quot;Multiple SourceFile attributes in class file %s&quot;, CHECK);
3589       } else {
3590         parsed_sourcefile_attribute = true;
</pre>
<hr />
<pre>
3767               parsed_record_attribute = true;
3768               record_attribute_start = cfs-&gt;current();
3769               record_attribute_length = attribute_length;
3770             } else if (log_is_enabled(Info, class, record)) {
3771               // Log why the Record attribute was ignored.  Note that if the
3772               // class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and
3773               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError
3774               // exception would have been thrown.
3775               ResourceMark rm(THREAD);
3776               if (supports_records()) {
3777                 log_info(class, record)(
3778                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,
3779                   _class_name-&gt;as_C_string());
3780               } else {
3781                 log_info(class, record)(
3782                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,
3783                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);
3784               }
3785             }
3786             cfs-&gt;skip_u1(attribute_length, CHECK);
<span class="line-added">3787           } else if (_major_version &gt;= JAVA_15_VERSION) {</span>
<span class="line-added">3788             // Check for PermittedSubclasses tag</span>
<span class="line-added">3789             if (tag == vmSymbols::tag_permitted_subclasses()) {</span>
<span class="line-added">3790               if (supports_sealed_types()) {</span>
<span class="line-added">3791                 if (parsed_permitted_subclasses_attribute) {</span>
<span class="line-added">3792                   classfile_parse_error(&quot;Multiple PermittedSubclasses attributes in class file %s&quot;, CHECK);</span>
<span class="line-added">3793                 }</span>
<span class="line-added">3794                 // Classes marked ACC_FINAL cannot have a PermittedSubclasses attribute.</span>
<span class="line-added">3795                 if (_access_flags.is_final()) {</span>
<span class="line-added">3796                   classfile_parse_error(&quot;PermittedSubclasses attribute in final class file %s&quot;, CHECK);</span>
<span class="line-added">3797                 }</span>
<span class="line-added">3798                 parsed_permitted_subclasses_attribute = true;</span>
<span class="line-added">3799                 permitted_subclasses_attribute_start = cfs-&gt;current();</span>
<span class="line-added">3800                 permitted_subclasses_attribute_length = attribute_length;</span>
<span class="line-added">3801               }</span>
<span class="line-added">3802               cfs-&gt;skip_u1(attribute_length, CHECK);</span>
<span class="line-added">3803             } else {</span>
<span class="line-added">3804               // Unknown attribute</span>
<span class="line-added">3805               cfs-&gt;skip_u1(attribute_length, CHECK);</span>
<span class="line-added">3806             }</span>
3807           } else {
3808             // Unknown attribute
3809             cfs-&gt;skip_u1(attribute_length, CHECK);
3810           }
3811         } else {
3812           // Unknown attribute
3813           cfs-&gt;skip_u1(attribute_length, CHECK);
3814         }
3815       } else {
3816         // Unknown attribute
3817         cfs-&gt;skip_u1(attribute_length, CHECK);
3818       }
3819     } else {
3820       // Unknown attribute
3821       cfs-&gt;skip_u1(attribute_length, CHECK);
3822     }
3823   }
3824   _class_annotations = assemble_annotations(runtime_visible_annotations,
3825                                             runtime_visible_annotations_length,
3826                                             runtime_invisible_annotations,
</pre>
<hr />
<pre>
3855     if (_need_verify) {
3856       guarantee_property(
3857         nest_members_attribute_length == sizeof(num_of_classes) + sizeof(u2) * num_of_classes,
3858         &quot;Wrong NestMembers attribute length in class file %s&quot;, CHECK);
3859     }
3860   }
3861 
3862   if (parsed_record_attribute) {
3863     const unsigned int calculated_attr_length = parse_classfile_record_attribute(
3864                             cfs,
3865                             cp,
3866                             record_attribute_start,
3867                             CHECK);
3868     if (_need_verify) {
3869       guarantee_property(record_attribute_length == calculated_attr_length,
3870                          &quot;Record attribute has wrong length in class file %s&quot;,
3871                          CHECK);
3872     }
3873   }
3874 
<span class="line-added">3875   if (parsed_permitted_subclasses_attribute) {</span>
<span class="line-added">3876     const u2 num_subclasses = parse_classfile_permitted_subclasses_attribute(</span>
<span class="line-added">3877                             cfs,</span>
<span class="line-added">3878                             permitted_subclasses_attribute_start,</span>
<span class="line-added">3879                             CHECK);</span>
<span class="line-added">3880     if (_need_verify) {</span>
<span class="line-added">3881       guarantee_property(</span>
<span class="line-added">3882         permitted_subclasses_attribute_length == sizeof(num_subclasses) + sizeof(u2) * num_subclasses,</span>
<span class="line-added">3883         &quot;Wrong PermittedSubclasses attribute length in class file %s&quot;, CHECK);</span>
<span class="line-added">3884     }</span>
<span class="line-added">3885   }</span>
<span class="line-added">3886 </span>
3887   if (_max_bootstrap_specifier_index &gt;= 0) {
3888     guarantee_property(parsed_bootstrap_methods_attribute,
3889                        &quot;Missing BootstrapMethods attribute in class file %s&quot;, CHECK);
3890   }
3891 }
3892 
3893 void ClassFileParser::apply_parsed_class_attributes(InstanceKlass* k) {
3894   assert(k != NULL, &quot;invariant&quot;);
3895 
3896   if (_synthetic_flag)
3897     k-&gt;set_is_synthetic();
3898   if (_sourcefile_index != 0) {
3899     k-&gt;set_source_file_name_index(_sourcefile_index);
3900   }
3901   if (_generic_signature_index != 0) {
3902     k-&gt;set_generic_signature_index(_generic_signature_index);
3903   }
3904   if (_sde_buffer != NULL) {
3905     k-&gt;set_source_debug_extension(_sde_buffer, _sde_length);
3906   }
</pre>
<hr />
<pre>
3934     _fields_annotations      = NULL;
3935     _fields_type_annotations = NULL;
3936 }
3937 
3938 // Transfer ownership of metadata allocated to the InstanceKlass.
3939 void ClassFileParser::apply_parsed_class_metadata(
3940                                             InstanceKlass* this_klass,
3941                                             int java_fields_count,
3942                                             TRAPS) {
3943   assert(this_klass != NULL, &quot;invariant&quot;);
3944 
3945   _cp-&gt;set_pool_holder(this_klass);
3946   this_klass-&gt;set_constants(_cp);
3947   this_klass-&gt;set_fields(_fields, java_fields_count);
3948   this_klass-&gt;set_methods(_methods);
3949   this_klass-&gt;set_inner_classes(_inner_classes);
3950   this_klass-&gt;set_nest_members(_nest_members);
3951   this_klass-&gt;set_nest_host_index(_nest_host);
3952   this_klass-&gt;set_local_interfaces(_local_interfaces);
3953   this_klass-&gt;set_annotations(_combined_annotations);
<span class="line-added">3954   this_klass-&gt;set_permitted_subclasses(_permitted_subclasses);</span>
3955   this_klass-&gt;set_record_components(_record_components);
3956   // Delay the setting of _transitive_interfaces until after initialize_supers() in
3957   // fill_instance_klass(). It is because the _transitive_interfaces may be shared with
3958   // its _super. If an OOM occurs while loading the current klass, its _super field
3959   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
3960   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
3961   // dereferences to the deallocated _transitive_interfaces will result in a crash.
3962 
3963   // Clear out these fields so they don&#39;t get deallocated by the destructor
3964   clear_class_metadata();
3965 }
3966 
3967 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
3968                                                        int runtime_visible_annotations_length,
3969                                                        const u1* const runtime_invisible_annotations,
3970                                                        int runtime_invisible_annotations_length,
3971                                                        TRAPS) {
3972   AnnotationArray* annotations = NULL;
3973   if (runtime_visible_annotations != NULL ||
3974       runtime_invisible_annotations != NULL) {
</pre>
<hr />
<pre>
4743 
4744     // length will be less than the max_transitive_size if duplicates were removed
4745     const int length = result-&gt;length();
4746     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
4747     Array&lt;InstanceKlass*&gt;* const new_result =
4748       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4749     for (int i = 0; i &lt; length; i++) {
4750       InstanceKlass* const e = result-&gt;at(i);
4751       assert(e != NULL, &quot;just checking&quot;);
4752       new_result-&gt;at_put(i, e);
4753     }
4754     return new_result;
4755   }
4756 }
4757 
4758 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4759   assert(this_klass != NULL, &quot;invariant&quot;);
4760   const Klass* const super = this_klass-&gt;super();
4761 
4762   if (super != NULL) {
<span class="line-added">4763     const InstanceKlass* super_ik = InstanceKlass::cast(super);</span>
<span class="line-added">4764 </span>
<span class="line-added">4765     if (super-&gt;is_final()) {</span>
<span class="line-added">4766       ResourceMark rm(THREAD);</span>
<span class="line-added">4767       Exceptions::fthrow(</span>
<span class="line-added">4768         THREAD_AND_LOCATION,</span>
<span class="line-added">4769         vmSymbols::java_lang_VerifyError(),</span>
<span class="line-added">4770         &quot;class %s cannot inherit from final class %s&quot;,</span>
<span class="line-added">4771         this_klass-&gt;external_name(),</span>
<span class="line-added">4772         super_ik-&gt;external_name());</span>
<span class="line-added">4773       return;</span>
<span class="line-added">4774     }</span>
<span class="line-added">4775 </span>
<span class="line-added">4776     if (super_ik-&gt;is_sealed() &amp;&amp; !super_ik-&gt;has_as_permitted_subclass(this_klass)) {</span>
<span class="line-added">4777       ResourceMark rm(THREAD);</span>
<span class="line-added">4778       Exceptions::fthrow(</span>
<span class="line-added">4779         THREAD_AND_LOCATION,</span>
<span class="line-added">4780         vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">4781         &quot;class %s cannot inherit from sealed class %s&quot;,</span>
<span class="line-added">4782         this_klass-&gt;external_name(),</span>
<span class="line-added">4783         super_ik-&gt;external_name());</span>
<span class="line-added">4784       return;</span>
<span class="line-added">4785     }</span>
4786 
4787     // If the loader is not the boot loader then throw an exception if its
4788     // superclass is in package jdk.internal.reflect and its loader is not a
4789     // special reflection class loader
4790     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {

4791       PackageEntry* super_package = super-&gt;package();
4792       if (super_package != NULL &amp;&amp;
4793           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
4794           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
4795         ResourceMark rm(THREAD);
4796         Exceptions::fthrow(
4797           THREAD_AND_LOCATION,
4798           vmSymbols::java_lang_IllegalAccessError(),
4799           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
4800           this_klass-&gt;external_name(),
4801           this_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
4802           super-&gt;external_name());
4803         return;
4804       }
4805     }
4806 
4807     Reflection::VerifyClassAccessResults vca_result =
4808       Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);
4809     if (vca_result != Reflection::ACCESS_OK) {
4810       ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
4826       } else {
4827         // Add additional message content.
4828         Exceptions::fthrow(
4829           THREAD_AND_LOCATION,
4830           vmSymbols::java_lang_IllegalAccessError(),
4831           &quot;superclass access check failed: %s&quot;,
4832           msg);
4833       }
4834     }
4835   }
4836 }
4837 
4838 
4839 static void check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {
4840   assert(this_klass != NULL, &quot;invariant&quot;);
4841   const Array&lt;InstanceKlass*&gt;* const local_interfaces = this_klass-&gt;local_interfaces();
4842   const int lng = local_interfaces-&gt;length();
4843   for (int i = lng - 1; i &gt;= 0; i--) {
4844     InstanceKlass* const k = local_interfaces-&gt;at(i);
4845     assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
<span class="line-added">4846 </span>
<span class="line-added">4847     if (k-&gt;is_sealed() &amp;&amp; !k-&gt;has_as_permitted_subclass(this_klass)) {</span>
<span class="line-added">4848       ResourceMark rm(THREAD);</span>
<span class="line-added">4849       Exceptions::fthrow(</span>
<span class="line-added">4850         THREAD_AND_LOCATION,</span>
<span class="line-added">4851         vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">4852         &quot;class %s cannot %s sealed interface %s&quot;,</span>
<span class="line-added">4853         this_klass-&gt;external_name(),</span>
<span class="line-added">4854         this_klass-&gt;is_interface() ? &quot;extend&quot; : &quot;implement&quot;,</span>
<span class="line-added">4855         k-&gt;external_name());</span>
<span class="line-added">4856       return;</span>
<span class="line-added">4857     }</span>
<span class="line-added">4858 </span>
4859     Reflection::VerifyClassAccessResults vca_result =
4860       Reflection::verify_class_access(this_klass, k, false);
4861     if (vca_result != Reflection::ACCESS_OK) {
4862       ResourceMark rm(THREAD);
4863       char* msg = Reflection::verify_class_access_msg(this_klass,
4864                                                       k,
4865                                                       vca_result);
4866       if (msg == NULL) {
4867         bool same_module = (this_klass-&gt;module() == k-&gt;module());
4868         Exceptions::fthrow(
4869           THREAD_AND_LOCATION,
4870           vmSymbols::java_lang_IllegalAccessError(),
4871           &quot;class %s cannot access its superinterface %s (%s%s%s)&quot;,
4872           this_klass-&gt;external_name(),
4873           k-&gt;external_name(),
4874           (same_module) ? this_klass-&gt;joint_in_module_of_loader(k) : this_klass-&gt;class_in_module_of_loader(),
4875           (same_module) ? &quot;&quot; : &quot;; &quot;,
4876           (same_module) ? &quot;&quot; : k-&gt;class_in_module_of_loader());
4877       } else {
4878         // Add additional message content.
</pre>
<hr />
<pre>
5774   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);
5775 
5776   // this transfers ownership of a lot of arrays from
5777   // the parser onto the InstanceKlass*
5778   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5779 
5780   // can only set dynamic nest-host after static nest information is set
5781   if (cl_inst_info.dynamic_nest_host() != NULL) {
5782     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
5783   }
5784 
5785   // note that is not safe to use the fields in the parser from this point on
5786   assert(NULL == _cp, &quot;invariant&quot;);
5787   assert(NULL == _fields, &quot;invariant&quot;);
5788   assert(NULL == _methods, &quot;invariant&quot;);
5789   assert(NULL == _inner_classes, &quot;invariant&quot;);
5790   assert(NULL == _nest_members, &quot;invariant&quot;);
5791   assert(NULL == _local_interfaces, &quot;invariant&quot;);
5792   assert(NULL == _combined_annotations, &quot;invariant&quot;);
5793   assert(NULL == _record_components, &quot;invariant&quot;);
<span class="line-added">5794   assert(NULL == _permitted_subclasses, &quot;invariant&quot;);</span>
5795 
5796   if (_has_final_method) {
5797     ik-&gt;set_has_final_method();
5798   }
5799 
5800   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
5801   // The InstanceKlass::_methods_jmethod_ids cache
5802   // is managed on the assumption that the initial cache
5803   // size is equal to the number of methods in the class. If
5804   // that changes, then InstanceKlass::idnum_can_increment()
5805   // has to be changed accordingly.
5806   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5807 
5808   ik-&gt;set_this_class_index(_this_class_index);
5809 
5810   if (_is_hidden || is_unsafe_anonymous()) {
5811     // _this_class_index is a CONSTANT_Class entry that refers to this
5812     // hidden or anonymous class itself. If this class needs to refer to its own
5813     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
5814     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
</pre>
<hr />
<pre>
6063                                  Publicity pub_level,
6064                                  TRAPS) :
6065   _stream(stream),
6066   _class_name(NULL),
6067   _loader_data(loader_data),
6068   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
6069   _cp_patches(cl_info-&gt;cp_patches()),
6070   _is_hidden(cl_info-&gt;is_hidden()),
6071   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
6072   _num_patched_klasses(0),
6073   _max_num_patched_klasses(0),
6074   _orig_cp_size(0),
6075   _first_patched_klass_resolved_index(0),
6076   _super_klass(),
6077   _cp(NULL),
6078   _fields(NULL),
6079   _methods(NULL),
6080   _inner_classes(NULL),
6081   _nest_members(NULL),
6082   _nest_host(0),
<span class="line-added">6083   _permitted_subclasses(NULL),</span>
6084   _record_components(NULL),
6085   _local_interfaces(NULL),
6086   _transitive_interfaces(NULL),
6087   _combined_annotations(NULL),
6088   _class_annotations(NULL),
6089   _class_type_annotations(NULL),
6090   _fields_annotations(NULL),
6091   _fields_type_annotations(NULL),
6092   _klass(NULL),
6093   _klass_to_deallocate(NULL),
6094   _parsed_annotations(NULL),
6095   _fac(NULL),
6096   _field_info(NULL),
6097   _method_ordering(NULL),
6098   _all_mirandas(NULL),
6099   _vtable_size(0),
6100   _itable_size(0),
6101   _num_miranda_methods(0),
6102   _rt(REF_NONE),
6103   _protection_domain(cl_info-&gt;protection_domain()),
</pre>
<hr />
<pre>
6172   // synch back verification state to stream
6173   stream-&gt;set_verify(_need_verify);
6174 
6175   // Check if verification needs to be relaxed for this class file
6176   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
6177   _relax_verify = relax_format_check_for(_loader_data);
6178 
6179   parse_stream(stream, CHECK);
6180 
6181   post_process_parsed_stream(stream, _cp, CHECK);
6182 }
6183 
6184 void ClassFileParser::clear_class_metadata() {
6185   // metadata created before the instance klass is created.  Must be
6186   // deallocated if classfile parsing returns an error.
6187   _cp = NULL;
6188   _fields = NULL;
6189   _methods = NULL;
6190   _inner_classes = NULL;
6191   _nest_members = NULL;
<span class="line-added">6192   _permitted_subclasses = NULL;</span>
6193   _local_interfaces = NULL;
6194   _combined_annotations = NULL;
6195   _class_annotations = _class_type_annotations = NULL;
6196   _fields_annotations = _fields_type_annotations = NULL;
6197   _record_components = NULL;
6198 }
6199 
6200 // Destructor to clean up
6201 ClassFileParser::~ClassFileParser() {
6202   _class_name-&gt;decrement_refcount();
6203 
6204   if (_cp != NULL) {
6205     MetadataFactory::free_metadata(_loader_data, _cp);
6206   }
6207   if (_fields != NULL) {
6208     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
6209   }
6210 
6211   if (_methods != NULL) {
6212     // Free methods
6213     InstanceKlass::deallocate_methods(_loader_data, _methods);
6214   }
6215 
6216   // beware of the Universe::empty_blah_array!!
6217   if (_inner_classes != NULL &amp;&amp; _inner_classes != Universe::the_empty_short_array()) {
6218     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _inner_classes);
6219   }
6220 
6221   if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {
6222     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _nest_members);
6223   }
6224 
6225   if (_record_components != NULL) {
6226     InstanceKlass::deallocate_record_components(_loader_data, _record_components);
6227   }
6228 
<span class="line-added">6229   if (_permitted_subclasses != NULL &amp;&amp; _permitted_subclasses != Universe::the_empty_short_array()) {</span>
<span class="line-added">6230     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _permitted_subclasses);</span>
<span class="line-added">6231   }</span>
<span class="line-added">6232 </span>
6233   // Free interfaces
6234   InstanceKlass::deallocate_interfaces(_loader_data, _super_klass,
6235                                        _local_interfaces, _transitive_interfaces);
6236 
6237   if (_combined_annotations != NULL) {
6238     // After all annotations arrays have been created, they are installed into the
6239     // Annotations object that will be assigned to the InstanceKlass being created.
6240 
6241     // Deallocate the Annotations object and the installed annotations arrays.
6242     _combined_annotations-&gt;deallocate_contents(_loader_data);
6243 
6244     // If the _combined_annotations pointer is non-NULL,
6245     // then the other annotations fields should have been cleared.
6246     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);
6247     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);
6248     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
6249     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
6250   } else {
6251     // If the annotations arrays were not installed into the Annotations object,
6252     // then they have to be deallocated explicitly.
</pre>
<hr />
<pre>
6611                                                                true,
6612                                                                CHECK);
6613   }
6614 
6615   if (_super_klass != NULL) {
6616     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6617       _has_nonstatic_concrete_methods = true;
6618     }
6619 
6620     if (_super_klass-&gt;is_interface()) {
6621       ResourceMark rm(THREAD);
6622       Exceptions::fthrow(
6623         THREAD_AND_LOCATION,
6624         vmSymbols::java_lang_IncompatibleClassChangeError(),
6625         &quot;class %s has interface %s as super class&quot;,
6626         _class_name-&gt;as_klass_external_name(),
6627         _super_klass-&gt;external_name()
6628       );
6629       return;
6630     }




6631   }
6632 
6633   // Compute the transitive list of all unique interfaces implemented by this class
6634   _transitive_interfaces =
6635     compute_transitive_interfaces(_super_klass,
6636                                   _local_interfaces,
6637                                   _loader_data,
6638                                   CHECK);
6639 
6640   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6641 
6642   // sort methods
6643   _method_ordering = sort_methods(_methods);
6644 
6645   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6646 
6647   Handle loader(THREAD, _loader_data-&gt;class_loader());
6648   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6649                                                     &amp;_num_miranda_methods,
6650                                                     _all_mirandas,
</pre>
</td>
</tr>
</table>
<center><a href="../ci/ciInstanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
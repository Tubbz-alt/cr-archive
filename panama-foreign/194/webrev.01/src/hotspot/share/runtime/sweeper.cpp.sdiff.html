<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/sweeper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sweeper.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sweeper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 64   address uep;
 65   int line;
 66 
 67   void print() {
 68       tty-&gt;print_cr(&quot;traversal = %d compile_id = %d %s uep = &quot; PTR_FORMAT &quot; vep = &quot;
 69                     PTR_FORMAT &quot; state = %d traversal_mark %ld line = %d&quot;,
 70                     traversal,
 71                     compile_id,
 72                     kind == NULL ? &quot;&quot; : kind,
 73                     p2i(uep),
 74                     p2i(vep),
 75                     state,
 76                     traversal_mark,
 77                     line);
 78   }
 79 };
 80 
 81 static int _sweep_index = 0;
 82 static SweeperRecord* _records = NULL;
 83 
<span class="line-removed"> 84 void NMethodSweeper::report_events(int id, address entry) {</span>
<span class="line-removed"> 85   if (_records != NULL) {</span>
<span class="line-removed"> 86     for (int i = _sweep_index; i &lt; SweeperLogEntries; i++) {</span>
<span class="line-removed"> 87       if (_records[i].uep == entry ||</span>
<span class="line-removed"> 88           _records[i].vep == entry ||</span>
<span class="line-removed"> 89           _records[i].compile_id == id) {</span>
<span class="line-removed"> 90         _records[i].print();</span>
<span class="line-removed"> 91       }</span>
<span class="line-removed"> 92     }</span>
<span class="line-removed"> 93     for (int i = 0; i &lt; _sweep_index; i++) {</span>
<span class="line-removed"> 94       if (_records[i].uep == entry ||</span>
<span class="line-removed"> 95           _records[i].vep == entry ||</span>
<span class="line-removed"> 96           _records[i].compile_id == id) {</span>
<span class="line-removed"> 97         _records[i].print();</span>
<span class="line-removed"> 98       }</span>
<span class="line-removed"> 99     }</span>
<span class="line-removed">100   }</span>
<span class="line-removed">101 }</span>
<span class="line-removed">102 </span>
<span class="line-removed">103 void NMethodSweeper::report_events() {</span>
<span class="line-removed">104   if (_records != NULL) {</span>
<span class="line-removed">105     for (int i = _sweep_index; i &lt; SweeperLogEntries; i++) {</span>
<span class="line-removed">106       // skip empty records</span>
<span class="line-removed">107       if (_records[i].vep == NULL) continue;</span>
<span class="line-removed">108       _records[i].print();</span>
<span class="line-removed">109     }</span>
<span class="line-removed">110     for (int i = 0; i &lt; _sweep_index; i++) {</span>
<span class="line-removed">111       // skip empty records</span>
<span class="line-removed">112       if (_records[i].vep == NULL) continue;</span>
<span class="line-removed">113       _records[i].print();</span>
<span class="line-removed">114     }</span>
<span class="line-removed">115   }</span>
<span class="line-removed">116 }</span>
<span class="line-removed">117 </span>
118 void NMethodSweeper::record_sweep(CompiledMethod* nm, int line) {
119   if (_records != NULL) {
120     _records[_sweep_index].traversal = _traversals;
121     _records[_sweep_index].traversal_mark = nm-&gt;is_nmethod() ? ((nmethod*)nm)-&gt;stack_traversal_mark() : 0;
122     _records[_sweep_index].compile_id = nm-&gt;compile_id();
123     _records[_sweep_index].kind = nm-&gt;compile_kind();
124     _records[_sweep_index].state = nm-&gt;get_state();
125     _records[_sweep_index].vep = nm-&gt;verified_entry_point();
126     _records[_sweep_index].uep = nm-&gt;entry_point();
127     _records[_sweep_index].line = line;
128     _sweep_index = (_sweep_index + 1) % SweeperLogEntries;
129   }
130 }
131 
132 void NMethodSweeper::init_sweeper_log() {
133  if (LogSweeper &amp;&amp; _records == NULL) {
134    // Create the ring buffer for the logging code
135    _records = NEW_C_HEAP_ARRAY(SweeperRecord, SweeperLogEntries, mtGC);
136    memset(_records, 0, sizeof(SweeperRecord) * SweeperLogEntries);
137   }
138 }
139 #else
140 #define SWEEP(nm)
141 #endif
142 
143 CompiledMethodIterator NMethodSweeper::_current(CompiledMethodIterator::all_blobs); // Current compiled method
144 long     NMethodSweeper::_traversals                   = 0;    // Stack scan count, also sweep ID.
145 long     NMethodSweeper::_total_nof_code_cache_sweeps  = 0;    // Total number of full sweeps of the code cache
<span class="line-removed">146 long     NMethodSweeper::_time_counter                 = 0;    // Virtual time used to periodically invoke sweeper</span>
<span class="line-removed">147 long     NMethodSweeper::_last_sweep                   = 0;    // Value of _time_counter when the last sweep happened</span>
148 int      NMethodSweeper::_seen                         = 0;    // Nof. nmethod we have currently processed in current pass of CodeCache

149 
<span class="line-modified">150 volatile bool NMethodSweeper::_should_sweep            = false;// Indicates if we should invoke the sweeper</span>
<span class="line-modified">151 volatile bool NMethodSweeper::_force_sweep             = false;// Indicates if we should force a sweep</span>
<span class="line-modified">152 volatile int  NMethodSweeper::_bytes_changed           = 0;    // Counts the total nmethod size if the nmethod changed from:</span>
153                                                                //   1) alive       -&gt; not_entrant
154                                                                //   2) not_entrant -&gt; zombie
155 int    NMethodSweeper::_hotness_counter_reset_val       = 0;
156 
157 long   NMethodSweeper::_total_nof_methods_reclaimed     = 0;   // Accumulated nof methods flushed
158 long   NMethodSweeper::_total_nof_c2_methods_reclaimed  = 0;   // Accumulated nof methods flushed
159 size_t NMethodSweeper::_total_flushed_size              = 0;   // Total number of bytes flushed from the code cache
160 Tickspan NMethodSweeper::_total_time_sweeping;                 // Accumulated time sweeping
161 Tickspan NMethodSweeper::_total_time_this_sweep;               // Total time this sweep
162 Tickspan NMethodSweeper::_peak_sweep_time;                     // Peak time for a full sweep
163 Tickspan NMethodSweeper::_peak_sweep_fraction_time;            // Peak time sweeping one fraction
164 
165 class MarkActivationClosure: public CodeBlobClosure {
166 public:
167   virtual void do_code_blob(CodeBlob* cb) {
168     assert(cb-&gt;is_nmethod(), &quot;CodeBlob should be nmethod&quot;);
169     nmethod* nm = (nmethod*)cb;
170     nm-&gt;set_hotness_counter(NMethodSweeper::hotness_counter_reset_val());
171     // If we see an activation belonging to a non_entrant nmethod, we mark it.
172     if (nm-&gt;is_not_entrant()) {
</pre>
<hr />
<pre>
193   }
194   return _hotness_counter_reset_val;
195 }
196 bool NMethodSweeper::wait_for_stack_scanning() {
197   return _current.end();
198 }
199 
200 class NMethodMarkingClosure : public HandshakeClosure {
201 private:
202   CodeBlobClosure* _cl;
203 public:
204   NMethodMarkingClosure(CodeBlobClosure* cl) : HandshakeClosure(&quot;NMethodMarking&quot;), _cl(cl) {}
205   void do_thread(Thread* thread) {
206     if (thread-&gt;is_Java_thread() &amp;&amp; ! thread-&gt;is_Code_cache_sweeper_thread()) {
207       JavaThread* jt = (JavaThread*) thread;
208       jt-&gt;nmethods_do(_cl);
209     }
210   }
211 };
212 
<span class="line-removed">213 class NMethodMarkingTask : public AbstractGangTask {</span>
<span class="line-removed">214 private:</span>
<span class="line-removed">215   NMethodMarkingClosure* _cl;</span>
<span class="line-removed">216 public:</span>
<span class="line-removed">217   NMethodMarkingTask(NMethodMarkingClosure* cl) :</span>
<span class="line-removed">218     AbstractGangTask(&quot;Parallel NMethod Marking&quot;),</span>
<span class="line-removed">219     _cl(cl) {</span>
<span class="line-removed">220     Threads::change_thread_claim_token();</span>
<span class="line-removed">221   }</span>
<span class="line-removed">222 </span>
<span class="line-removed">223   ~NMethodMarkingTask() {</span>
<span class="line-removed">224     Threads::assert_all_threads_claimed();</span>
<span class="line-removed">225   }</span>
<span class="line-removed">226 </span>
<span class="line-removed">227   void work(uint worker_id) {</span>
<span class="line-removed">228     Threads::possibly_parallel_threads_do(true, _cl);</span>
<span class="line-removed">229   }</span>
<span class="line-removed">230 };</span>
<span class="line-removed">231 </span>
<span class="line-removed">232 /**</span>
<span class="line-removed">233   * Scans the stacks of all Java threads and marks activations of not-entrant methods.</span>
<span class="line-removed">234   * No need to synchronize access, since &#39;mark_active_nmethods&#39; is always executed at a</span>
<span class="line-removed">235   * safepoint.</span>
<span class="line-removed">236   */</span>
<span class="line-removed">237 void NMethodSweeper::mark_active_nmethods() {</span>
<span class="line-removed">238   CodeBlobClosure* cl = prepare_mark_active_nmethods();</span>
<span class="line-removed">239   if (cl != NULL) {</span>
<span class="line-removed">240     WorkGang* workers = Universe::heap()-&gt;get_safepoint_workers();</span>
<span class="line-removed">241     if (workers != NULL) {</span>
<span class="line-removed">242       NMethodMarkingClosure tcl(cl);</span>
<span class="line-removed">243       NMethodMarkingTask task(&amp;tcl);</span>
<span class="line-removed">244       workers-&gt;run_task(&amp;task);</span>
<span class="line-removed">245     } else {</span>
<span class="line-removed">246       Threads::nmethods_do(cl);</span>
<span class="line-removed">247     }</span>
<span class="line-removed">248   }</span>
<span class="line-removed">249 }</span>
<span class="line-removed">250 </span>
251 CodeBlobClosure* NMethodSweeper::prepare_mark_active_nmethods() {
252 #ifdef ASSERT
253   assert(Thread::current()-&gt;is_Code_cache_sweeper_thread(), &quot;must be executed under CodeCache_lock and in sweeper thread&quot;);
254   assert_lock_strong(CodeCache_lock);
255 #endif
256 
257   // If we do not want to reclaim not-entrant or zombie methods there is no need
258   // to scan stacks
259   if (!MethodFlushing) {
260     return NULL;
261   }
262 
<span class="line-removed">263   // Increase time so that we can estimate when to invoke the sweeper again.</span>
<span class="line-removed">264   _time_counter++;</span>
<span class="line-removed">265 </span>
266   // Check for restart
267   assert(_current.method() == NULL, &quot;should only happen between sweeper cycles&quot;);
268   assert(wait_for_stack_scanning(), &quot;should only happen between sweeper cycles&quot;);
269 
270   _seen = 0;
271   _current = CompiledMethodIterator(CompiledMethodIterator::all_blobs);
272   // Initialize to first nmethod
273   _current.next();
274   _traversals += 1;
275   _total_time_this_sweep = Tickspan();
276 
277   if (PrintMethodFlushing) {
278     tty-&gt;print_cr(&quot;### Sweep: stack traversal %ld&quot;, _traversals);
279   }
280   return &amp;mark_activation_closure;
281 }
282 
283 CodeBlobClosure* NMethodSweeper::prepare_reset_hotness_counters() {
284   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be executed at a safepoint&quot;);
285 
286   // If we do not want to reclaim not-entrant or zombie methods there is no need
287   // to scan stacks
288   if (!MethodFlushing) {
289     return NULL;
290   }
291 
<span class="line-removed">292   // Increase time so that we can estimate when to invoke the sweeper again.</span>
<span class="line-removed">293   _time_counter++;</span>
<span class="line-removed">294 </span>
295   // Check for restart
296   if (_current.method() != NULL) {
297     if (_current.method()-&gt;is_nmethod()) {
298       assert(CodeCache::find_blob_unsafe(_current.method()) == _current.method(), &quot;Sweeper nmethod cached state invalid&quot;);
299     } else if (_current.method()-&gt;is_aot()) {
300       assert(CodeCache::find_blob_unsafe(_current.method()-&gt;code_begin()) == _current.method(), &quot;Sweeper AOT method cached state invalid&quot;);
301     } else {
302       ShouldNotReachHere();
303     }
304   }
305 
306   return &amp;set_hotness_closure;
307 }
308 
309 /**
310   * This function triggers a VM operation that does stack scanning of active
311   * methods. Stack scanning is mandatory for the sweeper to make progress.
312   */
313 void NMethodSweeper::do_stack_scanning() {
314   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;just checking&quot;);
315   if (wait_for_stack_scanning()) {
316     CodeBlobClosure* code_cl;
317     {
318       MutexLocker ccl(CodeCache_lock, Mutex::_no_safepoint_check_flag);
319       code_cl = prepare_mark_active_nmethods();
320     }
321     if (code_cl != NULL) {
322       NMethodMarkingClosure nm_cl(code_cl);
323       Handshake::execute(&amp;nm_cl);
324     }
325   }
326 }
327 
328 void NMethodSweeper::sweeper_loop() {
329   bool timeout;
330   while (true) {
331     {
332       ThreadBlockInVM tbivm(JavaThread::current());
<span class="line-modified">333       MonitorLocker waiter(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
334       const long wait_time = 60*60*24 * 1000;
335       timeout = waiter.wait(wait_time);
336     }
<span class="line-modified">337     if (!timeout) {</span>
<span class="line-modified">338       possibly_sweep();</span>
339     }
340   }
341 }
342 
343 /**
<span class="line-modified">344   * Wakes up the sweeper thread to possibly sweep.</span>
345   */
<span class="line-modified">346 void NMethodSweeper::notify(int code_blob_type) {</span>








347   // Makes sure that we do not invoke the sweeper too often during startup.
348   double start_threshold = 100.0 / (double)StartAggressiveSweepingAt;
<span class="line-modified">349   double aggressive_sweep_threshold = MIN2(start_threshold, 1.1);</span>
<span class="line-modified">350   if (CodeCache::reverse_free_ratio(code_blob_type) &gt;= aggressive_sweep_threshold) {</span>
<span class="line-removed">351     assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-removed">352     CodeCache_lock-&gt;notify();</span>
<span class="line-removed">353   }</span>
354 }
355 
356 /**
357   * Wakes up the sweeper thread and forces a sweep. Blocks until it finished.
358   */
359 void NMethodSweeper::force_sweep() {
360   ThreadBlockInVM tbivm(JavaThread::current());
<span class="line-modified">361   MonitorLocker waiter(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
362   // Request forced sweep
363   _force_sweep = true;
364   while (_force_sweep) {
365     // Notify sweeper that we want to force a sweep and wait for completion.
366     // In case a sweep currently takes place we timeout and try again because
367     // we want to enforce a full sweep.
<span class="line-modified">368     CodeCache_lock-&gt;notify();</span>
369     waiter.wait(1000);
370   }
371 }
372 
373 /**
374  * Handle a safepoint request
375  */
376 void NMethodSweeper::handle_safepoint_request() {
377   JavaThread* thread = JavaThread::current();
378   if (SafepointMechanism::should_block(thread)) {
379     if (PrintMethodFlushing &amp;&amp; Verbose) {
380       tty-&gt;print_cr(&quot;### Sweep at %d out of %d, yielding to safepoint&quot;, _seen, CodeCache::nmethod_count());
381     }
382     MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
383 
384     ThreadBlockInVM tbivm(thread);
385     thread-&gt;java_suspend_self();
386   }
387 }
388 
<span class="line-modified">389 /**</span>
<span class="line-modified">390  * This function invokes the sweeper if at least one of the three conditions is met:</span>
<span class="line-removed">391  *    (1) The code cache is getting full</span>
<span class="line-removed">392  *    (2) There are sufficient state changes in/since the last sweep.</span>
<span class="line-removed">393  *    (3) We have not been sweeping for &#39;some time&#39;</span>
<span class="line-removed">394  */</span>
<span class="line-removed">395 void NMethodSweeper::possibly_sweep() {</span>
396   assert(JavaThread::current()-&gt;thread_state() == _thread_in_vm, &quot;must run in vm mode&quot;);
<span class="line-modified">397   // If there was no state change while nmethod sweeping, &#39;should_sweep&#39; will be false.</span>
<span class="line-modified">398   // This is one of the two places where should_sweep can be set to true. The general</span>
<span class="line-modified">399   // idea is as follows: If there is enough free space in the code cache, there is no</span>
<span class="line-modified">400   // need to invoke the sweeper. The following formula (which determines whether to invoke</span>
<span class="line-removed">401   // the sweeper or not) depends on the assumption that for larger ReservedCodeCacheSizes</span>
<span class="line-removed">402   // we need less frequent sweeps than for smaller ReservedCodecCacheSizes. Furthermore,</span>
<span class="line-removed">403   // the formula considers how much space in the code cache is currently used. Here are</span>
<span class="line-removed">404   // some examples that will (hopefully) help in understanding.</span>
<span class="line-removed">405   //</span>
<span class="line-removed">406   // Small ReservedCodeCacheSizes:  (e.g., &lt; 16M) We invoke the sweeper every time, since</span>
<span class="line-removed">407   //                                              the result of the division is 0. This</span>
<span class="line-removed">408   //                                              keeps the used code cache size small</span>
<span class="line-removed">409   //                                              (important for embedded Java)</span>
<span class="line-removed">410   // Large ReservedCodeCacheSize :  (e.g., 256M + code cache is 10% full). The formula</span>
<span class="line-removed">411   //                                              computes: (256 / 16) - 1 = 15</span>
<span class="line-removed">412   //                                              As a result, we invoke the sweeper after</span>
<span class="line-removed">413   //                                              15 invocations of &#39;mark_active_nmethods.</span>
<span class="line-removed">414   // Large ReservedCodeCacheSize:   (e.g., 256M + code Cache is 90% full). The formula</span>
<span class="line-removed">415   //                                              computes: (256 / 16) - 10 = 6.</span>
<span class="line-removed">416   if (!_should_sweep) {</span>
<span class="line-removed">417     const int time_since_last_sweep = _time_counter - _last_sweep;</span>
<span class="line-removed">418     // ReservedCodeCacheSize has an &#39;unsigned&#39; type. We need a &#39;signed&#39; type for max_wait_time,</span>
<span class="line-removed">419     // since &#39;time_since_last_sweep&#39; can be larger than &#39;max_wait_time&#39;. If that happens using</span>
<span class="line-removed">420     // an unsigned type would cause an underflow (wait_until_next_sweep becomes a large positive</span>
<span class="line-removed">421     // value) that disables the intended periodic sweeps.</span>
<span class="line-removed">422     const int max_wait_time = ReservedCodeCacheSize / (16 * M);</span>
<span class="line-removed">423     double wait_until_next_sweep = max_wait_time - time_since_last_sweep -</span>
<span class="line-removed">424         MAX2(CodeCache::reverse_free_ratio(CodeBlobType::MethodProfiled),</span>
<span class="line-removed">425              CodeCache::reverse_free_ratio(CodeBlobType::MethodNonProfiled));</span>
<span class="line-removed">426     assert(wait_until_next_sweep &lt;= (double)max_wait_time, &quot;Calculation of code cache sweeper interval is incorrect&quot;);</span>
<span class="line-removed">427 </span>
<span class="line-removed">428     if ((wait_until_next_sweep &lt;= 0.0) || !CompileBroker::should_compile_new_jobs()) {</span>
<span class="line-removed">429       _should_sweep = true;</span>
<span class="line-removed">430     }</span>
431   }
432 
<span class="line-modified">433   // Remember if this was a forced sweep</span>
<span class="line-removed">434   bool forced = _force_sweep;</span>
<span class="line-removed">435 </span>
<span class="line-removed">436   // Force stack scanning if there is only 10% free space in the code cache.</span>
<span class="line-removed">437   // We force stack scanning only if the non-profiled code heap gets full, since critical</span>
<span class="line-removed">438   // allocations go to the non-profiled heap and we must be make sure that there is</span>
<span class="line-removed">439   // enough space.</span>
<span class="line-removed">440   double free_percent = 1 / CodeCache::reverse_free_ratio(CodeBlobType::MethodNonProfiled) * 100;</span>
<span class="line-removed">441   if (free_percent &lt;= StartAggressiveSweepingAt || forced || _should_sweep) {</span>
<span class="line-removed">442     do_stack_scanning();</span>
<span class="line-removed">443   }</span>
444 
<span class="line-modified">445   if (_should_sweep || forced) {</span>
<span class="line-modified">446     init_sweeper_log();</span>
<span class="line-removed">447     sweep_code_cache();</span>
<span class="line-removed">448   }</span>
449 
450   // We are done with sweeping the code cache once.
451   _total_nof_code_cache_sweeps++;
<span class="line-removed">452   _last_sweep = _time_counter;</span>
<span class="line-removed">453   // Reset flag; temporarily disables sweeper</span>
<span class="line-removed">454   _should_sweep = false;</span>
<span class="line-removed">455   // If there was enough state change, &#39;possibly_enable_sweeper()&#39;</span>
<span class="line-removed">456   // sets &#39;_should_sweep&#39; to true</span>
<span class="line-removed">457   possibly_enable_sweeper();</span>
<span class="line-removed">458   // Reset _bytes_changed only if there was enough state change. _bytes_changed</span>
<span class="line-removed">459   // can further increase by calls to &#39;report_state_change&#39;.</span>
<span class="line-removed">460   if (_should_sweep) {</span>
<span class="line-removed">461     _bytes_changed = 0;</span>
<span class="line-removed">462   }</span>
463 
<span class="line-modified">464   if (forced) {</span>
465     // Notify requester that forced sweep finished
<span class="line-modified">466     assert(_force_sweep, &quot;Should be a forced sweep&quot;);</span>
<span class="line-removed">467     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
468     _force_sweep = false;
<span class="line-modified">469     CodeCache_lock-&gt;notify();</span>
470   }
471 }
472 
473 static void post_sweep_event(EventSweepCodeCache* event,
474                              const Ticks&amp; start,
475                              const Ticks&amp; end,
476                              s4 traversals,
477                              int swept,
478                              int flushed,
479                              int zombified) {
480   assert(event != NULL, &quot;invariant&quot;);
481   assert(event-&gt;should_commit(), &quot;invariant&quot;);
482   event-&gt;set_starttime(start);
483   event-&gt;set_endtime(end);
484   event-&gt;set_sweepId(traversals);
485   event-&gt;set_sweptCount(swept);
486   event-&gt;set_flushedCount(flushed);
487   event-&gt;set_zombifiedCount(zombified);
488   event-&gt;commit();
489 }
</pre>
<hr />
<pre>
592     CodeCache::print_summary(&amp;ls, false);
593   }
594   log_sweep(&quot;finished&quot;);
595 
596   // Sweeper is the only case where memory is released, check here if it
597   // is time to restart the compiler. Only checking if there is a certain
598   // amount of free memory in the code cache might lead to re-enabling
599   // compilation although no memory has been released. For example, there are
600   // cases when compilation was disabled although there is 4MB (or more) free
601   // memory in the code cache. The reason is code cache fragmentation. Therefore,
602   // it only makes sense to re-enable compilation if we have actually freed memory.
603   // Note that typically several kB are released for sweeping 16MB of the code
604   // cache. As a result, &#39;freed_memory&#39; &gt; 0 to restart the compiler.
605   if (!CompileBroker::should_compile_new_jobs() &amp;&amp; (freed_memory &gt; 0)) {
606     CompileBroker::set_should_compile_new_jobs(CompileBroker::run_compilation);
607     log.debug(&quot;restart compiler&quot;);
608     log_sweep(&quot;restart_compiler&quot;);
609   }
610 }
611 
<span class="line-modified">612 /**</span>
<span class="line-modified">613  * This function updates the sweeper statistics that keep track of nmethods</span>
<span class="line-modified">614  * state changes. If there is &#39;enough&#39; state change, the sweeper is invoked</span>
<span class="line-modified">615  * as soon as possible. There can be data races on _bytes_changed. The data</span>
<span class="line-removed">616  * races are benign, since it does not matter if we loose a couple of bytes.</span>
<span class="line-removed">617  * In the worst case we call the sweeper a little later. Also, we are guaranteed</span>
<span class="line-removed">618  * to invoke the sweeper if the code cache gets full.</span>
<span class="line-removed">619  */</span>
620 void NMethodSweeper::report_state_change(nmethod* nm) {
<span class="line-modified">621   _bytes_changed += nm-&gt;total_size();</span>
<span class="line-modified">622   possibly_enable_sweeper();</span>
<span class="line-modified">623 }</span>
<span class="line-removed">624 </span>
<span class="line-removed">625 /**</span>
<span class="line-removed">626  * Function determines if there was &#39;enough&#39; state change in the code cache to invoke</span>
<span class="line-removed">627  * the sweeper again. Currently, we determine &#39;enough&#39; as more than 1% state change in</span>
<span class="line-removed">628  * the code cache since the last sweep.</span>
<span class="line-removed">629  */</span>
<span class="line-removed">630 void NMethodSweeper::possibly_enable_sweeper() {</span>
<span class="line-removed">631   double percent_changed = ((double)_bytes_changed / (double)ReservedCodeCacheSize) * 100;</span>
<span class="line-removed">632   if (percent_changed &gt; 1.0) {</span>
633     _should_sweep = true;

634   }
635 }
636 
637 class CompiledMethodMarker: public StackObj {
638  private:
639   CodeCacheSweeperThread* _thread;
640  public:
641   CompiledMethodMarker(CompiledMethod* cm) {
642     JavaThread* current = JavaThread::current();
643     assert (current-&gt;is_Code_cache_sweeper_thread(), &quot;Must be&quot;);
644     _thread = (CodeCacheSweeperThread*)current;
645     if (!cm-&gt;is_zombie() &amp;&amp; !cm-&gt;is_unloading()) {
646       // Only expose live nmethods for scanning
647       _thread-&gt;set_scanned_compiled_method(cm);
648     }
649   }
650   ~CompiledMethodMarker() {
651     _thread-&gt;set_scanned_compiled_method(NULL);
652   }
653 };
</pre>
</td>
<td>
<hr />
<pre>
 64   address uep;
 65   int line;
 66 
 67   void print() {
 68       tty-&gt;print_cr(&quot;traversal = %d compile_id = %d %s uep = &quot; PTR_FORMAT &quot; vep = &quot;
 69                     PTR_FORMAT &quot; state = %d traversal_mark %ld line = %d&quot;,
 70                     traversal,
 71                     compile_id,
 72                     kind == NULL ? &quot;&quot; : kind,
 73                     p2i(uep),
 74                     p2i(vep),
 75                     state,
 76                     traversal_mark,
 77                     line);
 78   }
 79 };
 80 
 81 static int _sweep_index = 0;
 82 static SweeperRecord* _records = NULL;
 83 


































 84 void NMethodSweeper::record_sweep(CompiledMethod* nm, int line) {
 85   if (_records != NULL) {
 86     _records[_sweep_index].traversal = _traversals;
 87     _records[_sweep_index].traversal_mark = nm-&gt;is_nmethod() ? ((nmethod*)nm)-&gt;stack_traversal_mark() : 0;
 88     _records[_sweep_index].compile_id = nm-&gt;compile_id();
 89     _records[_sweep_index].kind = nm-&gt;compile_kind();
 90     _records[_sweep_index].state = nm-&gt;get_state();
 91     _records[_sweep_index].vep = nm-&gt;verified_entry_point();
 92     _records[_sweep_index].uep = nm-&gt;entry_point();
 93     _records[_sweep_index].line = line;
 94     _sweep_index = (_sweep_index + 1) % SweeperLogEntries;
 95   }
 96 }
 97 
 98 void NMethodSweeper::init_sweeper_log() {
 99  if (LogSweeper &amp;&amp; _records == NULL) {
100    // Create the ring buffer for the logging code
101    _records = NEW_C_HEAP_ARRAY(SweeperRecord, SweeperLogEntries, mtGC);
102    memset(_records, 0, sizeof(SweeperRecord) * SweeperLogEntries);
103   }
104 }
105 #else
106 #define SWEEP(nm)
107 #endif
108 
109 CompiledMethodIterator NMethodSweeper::_current(CompiledMethodIterator::all_blobs); // Current compiled method
110 long     NMethodSweeper::_traversals                   = 0;    // Stack scan count, also sweep ID.
111 long     NMethodSweeper::_total_nof_code_cache_sweeps  = 0;    // Total number of full sweeps of the code cache


112 int      NMethodSweeper::_seen                         = 0;    // Nof. nmethod we have currently processed in current pass of CodeCache
<span class="line-added">113 size_t   NMethodSweeper::_sweep_threshold_bytes        = 0;    // Threshold for when to sweep. Updated after ergonomics</span>
114 
<span class="line-modified">115 volatile bool NMethodSweeper::_should_sweep            = false;// Indicates if a normal sweep will be done</span>
<span class="line-modified">116 volatile bool NMethodSweeper::_force_sweep             = false;// Indicates if a forced sweep will be done</span>
<span class="line-modified">117 volatile size_t NMethodSweeper::_bytes_changed         = 0;    // Counts the total nmethod size if the nmethod changed from:</span>
118                                                                //   1) alive       -&gt; not_entrant
119                                                                //   2) not_entrant -&gt; zombie
120 int    NMethodSweeper::_hotness_counter_reset_val       = 0;
121 
122 long   NMethodSweeper::_total_nof_methods_reclaimed     = 0;   // Accumulated nof methods flushed
123 long   NMethodSweeper::_total_nof_c2_methods_reclaimed  = 0;   // Accumulated nof methods flushed
124 size_t NMethodSweeper::_total_flushed_size              = 0;   // Total number of bytes flushed from the code cache
125 Tickspan NMethodSweeper::_total_time_sweeping;                 // Accumulated time sweeping
126 Tickspan NMethodSweeper::_total_time_this_sweep;               // Total time this sweep
127 Tickspan NMethodSweeper::_peak_sweep_time;                     // Peak time for a full sweep
128 Tickspan NMethodSweeper::_peak_sweep_fraction_time;            // Peak time sweeping one fraction
129 
130 class MarkActivationClosure: public CodeBlobClosure {
131 public:
132   virtual void do_code_blob(CodeBlob* cb) {
133     assert(cb-&gt;is_nmethod(), &quot;CodeBlob should be nmethod&quot;);
134     nmethod* nm = (nmethod*)cb;
135     nm-&gt;set_hotness_counter(NMethodSweeper::hotness_counter_reset_val());
136     // If we see an activation belonging to a non_entrant nmethod, we mark it.
137     if (nm-&gt;is_not_entrant()) {
</pre>
<hr />
<pre>
158   }
159   return _hotness_counter_reset_val;
160 }
161 bool NMethodSweeper::wait_for_stack_scanning() {
162   return _current.end();
163 }
164 
165 class NMethodMarkingClosure : public HandshakeClosure {
166 private:
167   CodeBlobClosure* _cl;
168 public:
169   NMethodMarkingClosure(CodeBlobClosure* cl) : HandshakeClosure(&quot;NMethodMarking&quot;), _cl(cl) {}
170   void do_thread(Thread* thread) {
171     if (thread-&gt;is_Java_thread() &amp;&amp; ! thread-&gt;is_Code_cache_sweeper_thread()) {
172       JavaThread* jt = (JavaThread*) thread;
173       jt-&gt;nmethods_do(_cl);
174     }
175   }
176 };
177 






































178 CodeBlobClosure* NMethodSweeper::prepare_mark_active_nmethods() {
179 #ifdef ASSERT
180   assert(Thread::current()-&gt;is_Code_cache_sweeper_thread(), &quot;must be executed under CodeCache_lock and in sweeper thread&quot;);
181   assert_lock_strong(CodeCache_lock);
182 #endif
183 
184   // If we do not want to reclaim not-entrant or zombie methods there is no need
185   // to scan stacks
186   if (!MethodFlushing) {
187     return NULL;
188   }
189 



190   // Check for restart
191   assert(_current.method() == NULL, &quot;should only happen between sweeper cycles&quot;);
192   assert(wait_for_stack_scanning(), &quot;should only happen between sweeper cycles&quot;);
193 
194   _seen = 0;
195   _current = CompiledMethodIterator(CompiledMethodIterator::all_blobs);
196   // Initialize to first nmethod
197   _current.next();
198   _traversals += 1;
199   _total_time_this_sweep = Tickspan();
200 
201   if (PrintMethodFlushing) {
202     tty-&gt;print_cr(&quot;### Sweep: stack traversal %ld&quot;, _traversals);
203   }
204   return &amp;mark_activation_closure;
205 }
206 
207 CodeBlobClosure* NMethodSweeper::prepare_reset_hotness_counters() {
208   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be executed at a safepoint&quot;);
209 
210   // If we do not want to reclaim not-entrant or zombie methods there is no need
211   // to scan stacks
212   if (!MethodFlushing) {
213     return NULL;
214   }
215 



216   // Check for restart
217   if (_current.method() != NULL) {
218     if (_current.method()-&gt;is_nmethod()) {
219       assert(CodeCache::find_blob_unsafe(_current.method()) == _current.method(), &quot;Sweeper nmethod cached state invalid&quot;);
220     } else if (_current.method()-&gt;is_aot()) {
221       assert(CodeCache::find_blob_unsafe(_current.method()-&gt;code_begin()) == _current.method(), &quot;Sweeper AOT method cached state invalid&quot;);
222     } else {
223       ShouldNotReachHere();
224     }
225   }
226 
227   return &amp;set_hotness_closure;
228 }
229 
230 /**
231   * This function triggers a VM operation that does stack scanning of active
232   * methods. Stack scanning is mandatory for the sweeper to make progress.
233   */
234 void NMethodSweeper::do_stack_scanning() {
235   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;just checking&quot;);
236   if (wait_for_stack_scanning()) {
237     CodeBlobClosure* code_cl;
238     {
239       MutexLocker ccl(CodeCache_lock, Mutex::_no_safepoint_check_flag);
240       code_cl = prepare_mark_active_nmethods();
241     }
242     if (code_cl != NULL) {
243       NMethodMarkingClosure nm_cl(code_cl);
244       Handshake::execute(&amp;nm_cl);
245     }
246   }
247 }
248 
249 void NMethodSweeper::sweeper_loop() {
250   bool timeout;
251   while (true) {
252     {
253       ThreadBlockInVM tbivm(JavaThread::current());
<span class="line-modified">254       MonitorLocker waiter(CodeSweeper_lock, Mutex::_no_safepoint_check_flag);</span>
255       const long wait_time = 60*60*24 * 1000;
256       timeout = waiter.wait(wait_time);
257     }
<span class="line-modified">258     if (!timeout &amp;&amp; (_should_sweep || _force_sweep)) {</span>
<span class="line-modified">259       sweep();</span>
260     }
261   }
262 }
263 
264 /**
<span class="line-modified">265   * Wakes up the sweeper thread to sweep if code cache space runs low</span>
266   */
<span class="line-modified">267 void NMethodSweeper::report_allocation(int code_blob_type) {</span>
<span class="line-added">268   if (should_start_aggressive_sweep(code_blob_type)) {</span>
<span class="line-added">269     MonitorLocker waiter(CodeSweeper_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">270     _should_sweep = true;</span>
<span class="line-added">271     CodeSweeper_lock-&gt;notify();</span>
<span class="line-added">272   }</span>
<span class="line-added">273 }</span>
<span class="line-added">274 </span>
<span class="line-added">275 bool NMethodSweeper::should_start_aggressive_sweep(int code_blob_type) {</span>
276   // Makes sure that we do not invoke the sweeper too often during startup.
277   double start_threshold = 100.0 / (double)StartAggressiveSweepingAt;
<span class="line-modified">278   double aggressive_sweep_threshold = MAX2(start_threshold, 1.1);</span>
<span class="line-modified">279   return (CodeCache::reverse_free_ratio(code_blob_type) &gt;= aggressive_sweep_threshold);</span>



280 }
281 
282 /**
283   * Wakes up the sweeper thread and forces a sweep. Blocks until it finished.
284   */
285 void NMethodSweeper::force_sweep() {
286   ThreadBlockInVM tbivm(JavaThread::current());
<span class="line-modified">287   MonitorLocker waiter(CodeSweeper_lock, Mutex::_no_safepoint_check_flag);</span>
288   // Request forced sweep
289   _force_sweep = true;
290   while (_force_sweep) {
291     // Notify sweeper that we want to force a sweep and wait for completion.
292     // In case a sweep currently takes place we timeout and try again because
293     // we want to enforce a full sweep.
<span class="line-modified">294     CodeSweeper_lock-&gt;notify();</span>
295     waiter.wait(1000);
296   }
297 }
298 
299 /**
300  * Handle a safepoint request
301  */
302 void NMethodSweeper::handle_safepoint_request() {
303   JavaThread* thread = JavaThread::current();
304   if (SafepointMechanism::should_block(thread)) {
305     if (PrintMethodFlushing &amp;&amp; Verbose) {
306       tty-&gt;print_cr(&quot;### Sweep at %d out of %d, yielding to safepoint&quot;, _seen, CodeCache::nmethod_count());
307     }
308     MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
309 
310     ThreadBlockInVM tbivm(thread);
311     thread-&gt;java_suspend_self();
312   }
313 }
314 
<span class="line-modified">315 void NMethodSweeper::sweep() {</span>
<span class="line-modified">316   assert(_should_sweep || _force_sweep, &quot;must have been set&quot;);</span>





317   assert(JavaThread::current()-&gt;thread_state() == _thread_in_vm, &quot;must run in vm mode&quot;);
<span class="line-modified">318   Atomic::store(&amp;_bytes_changed, static_cast&lt;size_t&gt;(0)); // reset regardless of sleep reason</span>
<span class="line-modified">319   if (_should_sweep) {</span>
<span class="line-modified">320     MutexLocker mu(CodeSweeper_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">321     _should_sweep = false;</span>






























322   }
323 
<span class="line-modified">324   do_stack_scanning();</span>










325 
<span class="line-modified">326   init_sweeper_log();</span>
<span class="line-modified">327   sweep_code_cache();</span>


328 
329   // We are done with sweeping the code cache once.
330   _total_nof_code_cache_sweeps++;











331 
<span class="line-modified">332   if (_force_sweep) {</span>
333     // Notify requester that forced sweep finished
<span class="line-modified">334     MutexLocker mu(CodeSweeper_lock, Mutex::_no_safepoint_check_flag);</span>

335     _force_sweep = false;
<span class="line-modified">336     CodeSweeper_lock-&gt;notify();</span>
337   }
338 }
339 
340 static void post_sweep_event(EventSweepCodeCache* event,
341                              const Ticks&amp; start,
342                              const Ticks&amp; end,
343                              s4 traversals,
344                              int swept,
345                              int flushed,
346                              int zombified) {
347   assert(event != NULL, &quot;invariant&quot;);
348   assert(event-&gt;should_commit(), &quot;invariant&quot;);
349   event-&gt;set_starttime(start);
350   event-&gt;set_endtime(end);
351   event-&gt;set_sweepId(traversals);
352   event-&gt;set_sweptCount(swept);
353   event-&gt;set_flushedCount(flushed);
354   event-&gt;set_zombifiedCount(zombified);
355   event-&gt;commit();
356 }
</pre>
<hr />
<pre>
459     CodeCache::print_summary(&amp;ls, false);
460   }
461   log_sweep(&quot;finished&quot;);
462 
463   // Sweeper is the only case where memory is released, check here if it
464   // is time to restart the compiler. Only checking if there is a certain
465   // amount of free memory in the code cache might lead to re-enabling
466   // compilation although no memory has been released. For example, there are
467   // cases when compilation was disabled although there is 4MB (or more) free
468   // memory in the code cache. The reason is code cache fragmentation. Therefore,
469   // it only makes sense to re-enable compilation if we have actually freed memory.
470   // Note that typically several kB are released for sweeping 16MB of the code
471   // cache. As a result, &#39;freed_memory&#39; &gt; 0 to restart the compiler.
472   if (!CompileBroker::should_compile_new_jobs() &amp;&amp; (freed_memory &gt; 0)) {
473     CompileBroker::set_should_compile_new_jobs(CompileBroker::run_compilation);
474     log.debug(&quot;restart compiler&quot;);
475     log_sweep(&quot;restart_compiler&quot;);
476   }
477 }
478 
<span class="line-modified">479  // This function updates the sweeper statistics that keep track of nmethods</span>
<span class="line-modified">480  // state changes. If there is &#39;enough&#39; state change, the sweeper is invoked</span>
<span class="line-modified">481  // as soon as possible. Also, we are guaranteed to invoke the sweeper if</span>
<span class="line-modified">482  // the code cache gets full.</span>




483 void NMethodSweeper::report_state_change(nmethod* nm) {
<span class="line-modified">484   Atomic::add(&amp;_bytes_changed, (size_t)nm-&gt;total_size());</span>
<span class="line-modified">485   if (Atomic::load(&amp;_bytes_changed) &gt; _sweep_threshold_bytes) {</span>
<span class="line-modified">486     MutexLocker mu(CodeSweeper_lock, Mutex::_no_safepoint_check_flag);</span>









487     _should_sweep = true;
<span class="line-added">488     CodeSweeper_lock-&gt;notify(); // Wake up sweeper.</span>
489   }
490 }
491 
492 class CompiledMethodMarker: public StackObj {
493  private:
494   CodeCacheSweeperThread* _thread;
495  public:
496   CompiledMethodMarker(CompiledMethod* cm) {
497     JavaThread* current = JavaThread::current();
498     assert (current-&gt;is_Code_cache_sweeper_thread(), &quot;Must be&quot;);
499     _thread = (CodeCacheSweeperThread*)current;
500     if (!cm-&gt;is_zombie() &amp;&amp; !cm-&gt;is_unloading()) {
501       // Only expose live nmethods for scanning
502       _thread-&gt;set_scanned_compiled_method(cm);
503     }
504   }
505   ~CompiledMethodMarker() {
506     _thread-&gt;set_scanned_compiled_method(NULL);
507   }
508 };
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sweeper.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
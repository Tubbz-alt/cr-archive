<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/objectMonitor.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="objectMonitor.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="safepoint.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/objectMonitor.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35   return 0;
 36 }
 37 
 38 inline markWord ObjectMonitor::header() const {
 39   return Atomic::load(&amp;_header);
 40 }
 41 
 42 inline volatile markWord* ObjectMonitor::header_addr() {
 43   assert((intptr_t)this == (intptr_t)&amp;_header, &quot;sync code expects this&quot;);
 44   return &amp;_header;
 45 }
 46 
 47 inline void ObjectMonitor::set_header(markWord hdr) {
 48   Atomic::store(&amp;_header, hdr);
 49 }
 50 
 51 inline jint ObjectMonitor::waiters() const {
 52   return _waiters;
 53 }
 54 

 55 inline void* ObjectMonitor::owner() const {
<span class="line-modified"> 56   return _owner;</span>













 57 }
 58 
 59 inline void ObjectMonitor::clear() {
 60   assert(Atomic::load(&amp;_header).value() != 0, &quot;must be non-zero&quot;);
<span class="line-modified"> 61   assert(_contentions == 0, &quot;must be 0: contentions=%d&quot;, _contentions);</span>



















 62   assert(_waiters == 0, &quot;must be 0: waiters=%d&quot;, _waiters);
 63   assert(_recursions == 0, &quot;must be 0: recursions=&quot; INTX_FORMAT, _recursions);
 64   assert(_object != NULL, &quot;must be non-NULL&quot;);
<span class="line-removed"> 65   assert(_owner == NULL, &quot;must be NULL: owner=&quot; INTPTR_FORMAT, p2i(_owner));</span>
 66 
<span class="line-modified"> 67   Atomic::store(&amp;_header, markWord::zero());</span>
 68   _object = NULL;
 69 }
 70 
 71 inline void* ObjectMonitor::object() const {
 72   return _object;
 73 }
 74 
 75 inline void* ObjectMonitor::object_addr() {
 76   return (void *)(&amp;_object);
 77 }
 78 
 79 inline void ObjectMonitor::set_object(void* obj) {
 80   _object = obj;
 81 }
 82 
<span class="line-modified"> 83 // return number of threads contending for this monitor</span>
 84 inline jint ObjectMonitor::contentions() const {
<span class="line-modified"> 85   return _contentions;</span>





 86 }
 87 
 88 // Clear _owner field; current value must match old_value.
 89 inline void ObjectMonitor::release_clear_owner(void* old_value) {
<span class="line-modified"> 90   DEBUG_ONLY(void* prev = Atomic::load(&amp;_owner);)</span>
<span class="line-modified"> 91   assert(prev == old_value, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="line-modified"> 92          &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(old_value));</span>
 93   Atomic::release_store(&amp;_owner, (void*)NULL);
 94   log_trace(monitorinflation, owner)(&quot;release_clear_owner(): mid=&quot;
 95                                      INTPTR_FORMAT &quot;, old_value=&quot; INTPTR_FORMAT,
 96                                      p2i(this), p2i(old_value));
 97 }
 98 
 99 // Simply set _owner field to new_value; current value must match old_value.
100 // (Simple means no memory sync needed.)
101 inline void ObjectMonitor::set_owner_from(void* old_value, void* new_value) {
<span class="line-modified">102   DEBUG_ONLY(void* prev = Atomic::load(&amp;_owner);)</span>
<span class="line-modified">103   assert(prev == old_value, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="line-modified">104          &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(old_value));</span>
105   Atomic::store(&amp;_owner, new_value);
106   log_trace(monitorinflation, owner)(&quot;set_owner_from(): mid=&quot;
107                                      INTPTR_FORMAT &quot;, old_value=&quot; INTPTR_FORMAT
108                                      &quot;, new_value=&quot; INTPTR_FORMAT, p2i(this),
109                                      p2i(old_value), p2i(new_value));
110 }
111 

















112 // Simply set _owner field to self; current value must match basic_lock_p.
113 inline void ObjectMonitor::set_owner_from_BasicLock(void* basic_lock_p, Thread* self) {
<span class="line-modified">114   DEBUG_ONLY(void* prev = Atomic::load(&amp;_owner);)</span>
<span class="line-modified">115   assert(prev == basic_lock_p, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="line-modified">116          &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(basic_lock_p));</span>
117   // Non-null owner field to non-null owner field is safe without
118   // cmpxchg() as long as all readers can tolerate either flavor.
119   Atomic::store(&amp;_owner, self);
120   log_trace(monitorinflation, owner)(&quot;set_owner_from_BasicLock(): mid=&quot;
121                                      INTPTR_FORMAT &quot;, basic_lock_p=&quot;
122                                      INTPTR_FORMAT &quot;, new_value=&quot; INTPTR_FORMAT,
123                                      p2i(this), p2i(basic_lock_p), p2i(self));
124 }
125 
126 // Try to set _owner field to new_value if the current value matches
127 // old_value. Otherwise, does not change the _owner field. Returns
128 // the prior value of the _owner field.
129 inline void* ObjectMonitor::try_set_owner_from(void* old_value, void* new_value) {
130   void* prev = Atomic::cmpxchg(&amp;_owner, old_value, new_value);
131   if (prev == old_value) {
132     log_trace(monitorinflation, owner)(&quot;try_set_owner_from(): mid=&quot;
133                                        INTPTR_FORMAT &quot;, prev=&quot; INTPTR_FORMAT
134                                        &quot;, new=&quot; INTPTR_FORMAT, p2i(this),
135                                        p2i(prev), p2i(new_value));
136   }
137   return prev;
138 }
139 




















140 // The _next_om field can be concurrently read and modified so we
141 // use Atomic operations to disable compiler optimizations that
142 // might try to elide loading and/or storing this field.
143 
144 inline ObjectMonitor* ObjectMonitor::next_om() const {
145   return Atomic::load(&amp;_next_om);
146 }
147 
148 // Simply set _next_om field to new_value.
149 inline void ObjectMonitor::set_next_om(ObjectMonitor* new_value) {
150   Atomic::store(&amp;_next_om, new_value);
151 }
152 
153 // Try to set _next_om field to new_value if the current value matches
154 // old_value. Otherwise, does not change the _next_om field. Returns
155 // the prior value of the _next_om field.
156 inline ObjectMonitor* ObjectMonitor::try_set_next_om(ObjectMonitor* old_value, ObjectMonitor* new_value) {
157   return Atomic::cmpxchg(&amp;_next_om, old_value, new_value);
158 }
159 
</pre>
</td>
<td>
<hr />
<pre>
 35   return 0;
 36 }
 37 
 38 inline markWord ObjectMonitor::header() const {
 39   return Atomic::load(&amp;_header);
 40 }
 41 
 42 inline volatile markWord* ObjectMonitor::header_addr() {
 43   assert((intptr_t)this == (intptr_t)&amp;_header, &quot;sync code expects this&quot;);
 44   return &amp;_header;
 45 }
 46 
 47 inline void ObjectMonitor::set_header(markWord hdr) {
 48   Atomic::store(&amp;_header, hdr);
 49 }
 50 
 51 inline jint ObjectMonitor::waiters() const {
 52   return _waiters;
 53 }
 54 
<span class="line-added"> 55 // Returns NULL if DEFLATER_MARKER is observed.</span>
 56 inline void* ObjectMonitor::owner() const {
<span class="line-modified"> 57   void* owner = _owner;</span>
<span class="line-added"> 58   return owner != DEFLATER_MARKER ? owner : NULL;</span>
<span class="line-added"> 59 }</span>
<span class="line-added"> 60 </span>
<span class="line-added"> 61 // Returns true if owner field == DEFLATER_MARKER and false otherwise.</span>
<span class="line-added"> 62 // This accessor is called when we really need to know if the owner</span>
<span class="line-added"> 63 // field == DEFLATER_MARKER and any non-NULL value won&#39;t do the trick.</span>
<span class="line-added"> 64 inline bool ObjectMonitor::owner_is_DEFLATER_MARKER() {</span>
<span class="line-added"> 65   return Atomic::load(&amp;_owner) == DEFLATER_MARKER;</span>
<span class="line-added"> 66 }</span>
<span class="line-added"> 67 </span>
<span class="line-added"> 68 // Returns true if &#39;this&#39; is being async deflated and false otherwise.</span>
<span class="line-added"> 69 inline bool ObjectMonitor::is_being_async_deflated() {</span>
<span class="line-added"> 70   return AsyncDeflateIdleMonitors &amp;&amp; contentions() &lt; 0;</span>
 71 }
 72 
 73 inline void ObjectMonitor::clear() {
 74   assert(Atomic::load(&amp;_header).value() != 0, &quot;must be non-zero&quot;);
<span class="line-modified"> 75   assert(_owner == NULL, &quot;must be NULL: owner=&quot; INTPTR_FORMAT, p2i(_owner));</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77   Atomic::store(&amp;_header, markWord::zero());</span>
<span class="line-added"> 78 </span>
<span class="line-added"> 79   clear_common();</span>
<span class="line-added"> 80 }</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82 inline void ObjectMonitor::clear_common() {</span>
<span class="line-added"> 83   if (AsyncDeflateIdleMonitors) {</span>
<span class="line-added"> 84     // Async deflation protocol uses the header, owner and contentions</span>
<span class="line-added"> 85     // fields. While the ObjectMonitor being deflated is on the global</span>
<span class="line-added"> 86     // free list, we leave those three fields alone; contentions &lt; 0</span>
<span class="line-added"> 87     // will force any racing threads to retry. The header field is used</span>
<span class="line-added"> 88     // by install_displaced_markword_in_object() to restore the object&#39;s</span>
<span class="line-added"> 89     // header so we cannot check its value here.</span>
<span class="line-added"> 90     guarantee(_owner == NULL || _owner == DEFLATER_MARKER,</span>
<span class="line-added"> 91               &quot;must be NULL or DEFLATER_MARKER: owner=&quot; INTPTR_FORMAT,</span>
<span class="line-added"> 92               p2i(_owner));</span>
<span class="line-added"> 93   }</span>
<span class="line-added"> 94   assert(contentions() &lt;= 0, &quot;must not be positive: contentions=%d&quot;, contentions());</span>
 95   assert(_waiters == 0, &quot;must be 0: waiters=%d&quot;, _waiters);
 96   assert(_recursions == 0, &quot;must be 0: recursions=&quot; INTX_FORMAT, _recursions);
 97   assert(_object != NULL, &quot;must be non-NULL&quot;);

 98 
<span class="line-modified"> 99   set_allocation_state(Free);</span>
100   _object = NULL;
101 }
102 
103 inline void* ObjectMonitor::object() const {
104   return _object;
105 }
106 
107 inline void* ObjectMonitor::object_addr() {
108   return (void *)(&amp;_object);
109 }
110 
111 inline void ObjectMonitor::set_object(void* obj) {
112   _object = obj;
113 }
114 
<span class="line-modified">115 // Return number of threads contending for this monitor.</span>
116 inline jint ObjectMonitor::contentions() const {
<span class="line-modified">117   return Atomic::load(&amp;_contentions);</span>
<span class="line-added">118 }</span>
<span class="line-added">119 </span>
<span class="line-added">120 // Add value to the contentions field.</span>
<span class="line-added">121 inline void ObjectMonitor::add_to_contentions(jint value) {</span>
<span class="line-added">122   Atomic::add(&amp;_contentions, value);</span>
123 }
124 
125 // Clear _owner field; current value must match old_value.
126 inline void ObjectMonitor::release_clear_owner(void* old_value) {
<span class="line-modified">127   void* prev = Atomic::load(&amp;_owner);</span>
<span class="line-modified">128   ADIM_guarantee(prev == old_value, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="line-modified">129                  &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(old_value));</span>
130   Atomic::release_store(&amp;_owner, (void*)NULL);
131   log_trace(monitorinflation, owner)(&quot;release_clear_owner(): mid=&quot;
132                                      INTPTR_FORMAT &quot;, old_value=&quot; INTPTR_FORMAT,
133                                      p2i(this), p2i(old_value));
134 }
135 
136 // Simply set _owner field to new_value; current value must match old_value.
137 // (Simple means no memory sync needed.)
138 inline void ObjectMonitor::set_owner_from(void* old_value, void* new_value) {
<span class="line-modified">139   void* prev = Atomic::load(&amp;_owner);</span>
<span class="line-modified">140   ADIM_guarantee(prev == old_value, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="line-modified">141                  &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(old_value));</span>
142   Atomic::store(&amp;_owner, new_value);
143   log_trace(monitorinflation, owner)(&quot;set_owner_from(): mid=&quot;
144                                      INTPTR_FORMAT &quot;, old_value=&quot; INTPTR_FORMAT
145                                      &quot;, new_value=&quot; INTPTR_FORMAT, p2i(this),
146                                      p2i(old_value), p2i(new_value));
147 }
148 
<span class="line-added">149 // Simply set _owner field to new_value; current value must match old_value1 or old_value2.</span>
<span class="line-added">150 // (Simple means no memory sync needed.)</span>
<span class="line-added">151 inline void ObjectMonitor::set_owner_from(void* old_value1, void* old_value2, void* new_value) {</span>
<span class="line-added">152   void* prev = Atomic::load(&amp;_owner);</span>
<span class="line-added">153   ADIM_guarantee(prev == old_value1 || prev == old_value2,</span>
<span class="line-added">154                  &quot;unexpected prev owner=&quot; INTPTR_FORMAT &quot;, expected1=&quot;</span>
<span class="line-added">155                  INTPTR_FORMAT &quot; or expected2=&quot; INTPTR_FORMAT, p2i(prev),</span>
<span class="line-added">156                  p2i(old_value1), p2i(old_value2));</span>
<span class="line-added">157   _owner = new_value;</span>
<span class="line-added">158   log_trace(monitorinflation, owner)(&quot;set_owner_from(old1=&quot; INTPTR_FORMAT</span>
<span class="line-added">159                                      &quot;, old2=&quot; INTPTR_FORMAT &quot;): mid=&quot;</span>
<span class="line-added">160                                      INTPTR_FORMAT &quot;, prev=&quot; INTPTR_FORMAT</span>
<span class="line-added">161                                      &quot;, new=&quot; INTPTR_FORMAT, p2i(old_value1),</span>
<span class="line-added">162                                      p2i(old_value2), p2i(this), p2i(prev),</span>
<span class="line-added">163                                      p2i(new_value));</span>
<span class="line-added">164 }</span>
<span class="line-added">165 </span>
166 // Simply set _owner field to self; current value must match basic_lock_p.
167 inline void ObjectMonitor::set_owner_from_BasicLock(void* basic_lock_p, Thread* self) {
<span class="line-modified">168   void* prev = Atomic::load(&amp;_owner);</span>
<span class="line-modified">169   ADIM_guarantee(prev == basic_lock_p, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="line-modified">170                  &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(basic_lock_p));</span>
171   // Non-null owner field to non-null owner field is safe without
172   // cmpxchg() as long as all readers can tolerate either flavor.
173   Atomic::store(&amp;_owner, self);
174   log_trace(monitorinflation, owner)(&quot;set_owner_from_BasicLock(): mid=&quot;
175                                      INTPTR_FORMAT &quot;, basic_lock_p=&quot;
176                                      INTPTR_FORMAT &quot;, new_value=&quot; INTPTR_FORMAT,
177                                      p2i(this), p2i(basic_lock_p), p2i(self));
178 }
179 
180 // Try to set _owner field to new_value if the current value matches
181 // old_value. Otherwise, does not change the _owner field. Returns
182 // the prior value of the _owner field.
183 inline void* ObjectMonitor::try_set_owner_from(void* old_value, void* new_value) {
184   void* prev = Atomic::cmpxchg(&amp;_owner, old_value, new_value);
185   if (prev == old_value) {
186     log_trace(monitorinflation, owner)(&quot;try_set_owner_from(): mid=&quot;
187                                        INTPTR_FORMAT &quot;, prev=&quot; INTPTR_FORMAT
188                                        &quot;, new=&quot; INTPTR_FORMAT, p2i(this),
189                                        p2i(prev), p2i(new_value));
190   }
191   return prev;
192 }
193 
<span class="line-added">194 inline void ObjectMonitor::set_allocation_state(ObjectMonitor::AllocationState s) {</span>
<span class="line-added">195   _allocation_state = s;</span>
<span class="line-added">196 }</span>
<span class="line-added">197 </span>
<span class="line-added">198 inline ObjectMonitor::AllocationState ObjectMonitor::allocation_state() const {</span>
<span class="line-added">199   return _allocation_state;</span>
<span class="line-added">200 }</span>
<span class="line-added">201 </span>
<span class="line-added">202 inline bool ObjectMonitor::is_free() const {</span>
<span class="line-added">203   return _allocation_state == Free;</span>
<span class="line-added">204 }</span>
<span class="line-added">205 </span>
<span class="line-added">206 inline bool ObjectMonitor::is_old() const {</span>
<span class="line-added">207   return _allocation_state == Old;</span>
<span class="line-added">208 }</span>
<span class="line-added">209 </span>
<span class="line-added">210 inline bool ObjectMonitor::is_new() const {</span>
<span class="line-added">211   return _allocation_state == New;</span>
<span class="line-added">212 }</span>
<span class="line-added">213 </span>
214 // The _next_om field can be concurrently read and modified so we
215 // use Atomic operations to disable compiler optimizations that
216 // might try to elide loading and/or storing this field.
217 
218 inline ObjectMonitor* ObjectMonitor::next_om() const {
219   return Atomic::load(&amp;_next_om);
220 }
221 
222 // Simply set _next_om field to new_value.
223 inline void ObjectMonitor::set_next_om(ObjectMonitor* new_value) {
224   Atomic::store(&amp;_next_om, new_value);
225 }
226 
227 // Try to set _next_om field to new_value if the current value matches
228 // old_value. Otherwise, does not change the _next_om field. Returns
229 // the prior value of the _next_om field.
230 inline ObjectMonitor* ObjectMonitor::try_set_next_om(ObjectMonitor* old_value, ObjectMonitor* new_value) {
231   return Atomic::cmpxchg(&amp;_next_om, old_value, new_value);
232 }
233 
</pre>
</td>
</tr>
</table>
<center><a href="objectMonitor.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="safepoint.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
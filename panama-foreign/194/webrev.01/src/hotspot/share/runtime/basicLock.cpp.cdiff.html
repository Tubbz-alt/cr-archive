<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/basicLock.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arguments.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globals.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/basicLock.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 34,39 ***</span>
  }
  
  void BasicLock::move_to(oop obj, BasicLock* dest) {
    // Check to see if we need to inflate the lock. This is only needed
    // if an object is locked using &quot;this&quot; lightweight monitor. In that
<span class="line-modified">!   // case, the displaced_header() is unlocked, because the</span>
    // displaced_header() contains the header for the originally unlocked
<span class="line-modified">!   // object. However the object could have already been inflated. But it</span>
<span class="line-modified">!   // does not matter, the inflation will just a no-op. For other cases,</span>
    // the displaced header will be either 0x0 or 0x3, which are location
    // independent, therefore the BasicLock is free to move.
    //
    // During OSR we may need to relocate a BasicLock (which contains a
    // displaced word) from a location in an interpreter frame to a
    // new location in a compiled frame.  &quot;this&quot; refers to the source
<span class="line-modified">!   // basiclock in the interpreter frame.  &quot;dest&quot; refers to the destination</span>
<span class="line-modified">!   // basiclock in the new compiled frame.  We *always* inflate in move_to().</span>
<span class="line-modified">!   // The always-Inflate policy works properly, but in 1.5.0 it can sometimes</span>
<span class="line-modified">!   // cause performance problems in code that makes heavy use of a small # of</span>
<span class="line-modified">!   // uncontended locks.   (We&#39;d inflate during OSR, and then sync performance</span>
<span class="line-modified">!   // would subsequently plummet because the thread would be forced thru the slow-path).</span>
<span class="line-modified">!   // This problem has been made largely moot on IA32 by inlining the inflated fast-path</span>
<span class="line-modified">!   // operations in Fast_Lock and Fast_Unlock in i486.ad.</span>
    //
    // Note that there is a way to safely swing the object&#39;s markword from
    // one stack location to another.  This avoids inflation.  Obviously,
    // we need to ensure that both locations refer to the current thread&#39;s stack.
    // There are some subtle concurrency issues, however, and since the benefit is
    // is small (given the support for inflated fast-path locking in the fast_lock, etc)
    // we&#39;ll leave that optimization for another time.
  
    if (displaced_header().is_neutral()) {
      ObjectSynchronizer::inflate_helper(obj);
<span class="line-modified">!     // WARNING: We can not put check here, because the inflation</span>
      // will not update the displaced header. Once BasicLock is inflated,
      // no one should ever look at its content.
    } else {
      // Typically the displaced header will be 0 (recursive stack lock) or
      // unused_mark.  Naively we&#39;d like to assert that the displaced mark
<span class="line-new-header">--- 34,41 ---</span>
  }
  
  void BasicLock::move_to(oop obj, BasicLock* dest) {
    // Check to see if we need to inflate the lock. This is only needed
    // if an object is locked using &quot;this&quot; lightweight monitor. In that
<span class="line-modified">!   // case, the displaced_header() is unlocked/is_neutral, because the</span>
    // displaced_header() contains the header for the originally unlocked
<span class="line-modified">!   // object. However the lock could have already been inflated. But it</span>
<span class="line-modified">!   // does not matter, this inflation will just a no-op. For other cases,</span>
    // the displaced header will be either 0x0 or 0x3, which are location
    // independent, therefore the BasicLock is free to move.
    //
    // During OSR we may need to relocate a BasicLock (which contains a
    // displaced word) from a location in an interpreter frame to a
    // new location in a compiled frame.  &quot;this&quot; refers to the source
<span class="line-modified">!   // BasicLock in the interpreter frame.  &quot;dest&quot; refers to the destination</span>
<span class="line-modified">!   // BasicLock in the new compiled frame.  We *always* inflate in move_to()</span>
<span class="line-modified">!   // when the object is locked using &quot;this&quot; lightweight monitor.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // The always-Inflate policy works properly, but it depends on the</span>
<span class="line-modified">!   // inflated fast-path operations in fast_lock and fast_unlock to avoid</span>
<span class="line-modified">!   // performance problems. See x86/macroAssembler_x86.cpp: fast_lock()</span>
<span class="line-modified">!   // and fast_unlock() for examples.</span>
    //
    // Note that there is a way to safely swing the object&#39;s markword from
    // one stack location to another.  This avoids inflation.  Obviously,
    // we need to ensure that both locations refer to the current thread&#39;s stack.
    // There are some subtle concurrency issues, however, and since the benefit is
    // is small (given the support for inflated fast-path locking in the fast_lock, etc)
    // we&#39;ll leave that optimization for another time.
  
    if (displaced_header().is_neutral()) {
<span class="line-added">+     // The object is locked and the resulting ObjectMonitor* will also be</span>
<span class="line-added">+     // locked so it can&#39;t be async deflated until ownership is dropped.</span>
      ObjectSynchronizer::inflate_helper(obj);
<span class="line-modified">!     // WARNING: We cannot put a check here, because the inflation</span>
      // will not update the displaced header. Once BasicLock is inflated,
      // no one should ever look at its content.
    } else {
      // Typically the displaced header will be 0 (recursive stack lock) or
      // unused_mark.  Naively we&#39;d like to assert that the displaced mark
</pre>
<center><a href="arguments.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globals.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
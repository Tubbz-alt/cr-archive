<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/objectMonitor.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="mutexLocker.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objectMonitor.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/objectMonitor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 223 //
 224 // * See also http://blogs.sun.com/dave
 225 
 226 
 227 void* ObjectMonitor::operator new (size_t size) throw() {
 228   return AllocateHeap(size, mtInternal);
 229 }
 230 void* ObjectMonitor::operator new[] (size_t size) throw() {
 231   return operator new (size);
 232 }
 233 void ObjectMonitor::operator delete(void* p) {
 234   FreeHeap(p);
 235 }
 236 void ObjectMonitor::operator delete[] (void *p) {
 237   operator delete(p);
 238 }
 239 
 240 // -----------------------------------------------------------------------------
 241 // Enter support
 242 
<span class="line-modified"> 243 void ObjectMonitor::enter(TRAPS) {</span>
 244   // The following code is ordered to check the most common cases first
 245   // and to reduce RTS-&gt;RTO cache line upgrades on SPARC and IA32 processors.
 246   Thread * const Self = THREAD;
 247 
 248   void* cur = try_set_owner_from(NULL, Self);
 249   if (cur == NULL) {
 250     assert(_recursions == 0, &quot;invariant&quot;);
<span class="line-modified"> 251     return;</span>
 252   }
 253 
 254   if (cur == Self) {
 255     // TODO-FIXME: check for integer overflow!  BUGID 6557169.
 256     _recursions++;
<span class="line-modified"> 257     return;</span>
 258   }
 259 
 260   if (Self-&gt;is_lock_owned((address)cur)) {
 261     assert(_recursions == 0, &quot;internal state error&quot;);
 262     _recursions = 1;
 263     set_owner_from_BasicLock(cur, Self);  // Convert from BasicLock* to Thread*.
<span class="line-modified"> 264     return;</span>
 265   }
 266 
 267   // We&#39;ve encountered genuine contention.
 268   assert(Self-&gt;_Stalled == 0, &quot;invariant&quot;);
 269   Self-&gt;_Stalled = intptr_t(this);
 270 
 271   // Try one round of spinning *before* enqueueing Self
 272   // and before going through the awkward and expensive state
 273   // transitions.  The following spin is strictly optional ...
 274   // Note that if we acquire the monitor from an initial spin
 275   // we forgo posting JVMTI events and firing DTRACE probes.
 276   if (TrySpin(Self) &gt; 0) {
 277     assert(_owner == Self, &quot;must be Self: owner=&quot; INTPTR_FORMAT, p2i(_owner));
 278     assert(_recursions == 0, &quot;must be 0: recursions=&quot; INTX_FORMAT, _recursions);
 279     assert(((oop)object())-&gt;mark() == markWord::encode(this),
 280            &quot;object mark must match encoded this: mark=&quot; INTPTR_FORMAT
 281            &quot;, encoded this=&quot; INTPTR_FORMAT, ((oop)object())-&gt;mark().value(),
 282            markWord::encode(this).value());
 283     Self-&gt;_Stalled = 0;
<span class="line-modified"> 284     return;</span>
 285   }
 286 
 287   assert(_owner != Self, &quot;invariant&quot;);
 288   assert(_succ != Self, &quot;invariant&quot;);
 289   assert(Self-&gt;is_Java_thread(), &quot;invariant&quot;);
 290   JavaThread * jt = (JavaThread *) Self;
 291   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 292   assert(jt-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;);
<span class="line-modified"> 293   assert(this-&gt;object() != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 294   assert(_contentions &gt;= 0, &quot;invariant&quot;);</span>
<span class="line-modified"> 295 </span>
<span class="line-modified"> 296   // Prevent deflation at STW-time.  See deflate_idle_monitors() and is_busy().</span>
<span class="line-modified"> 297   // Ensure the object-monitor relationship remains stable while there&#39;s contention.</span>
<span class="line-modified"> 298   Atomic::inc(&amp;_contentions);</span>













 299 
 300   JFR_ONLY(JfrConditionalFlushWithStacktrace&lt;EventJavaMonitorEnter&gt; flush(jt);)
 301   EventJavaMonitorEnter event;
 302   if (event.should_commit()) {
 303     event.set_monitorClass(((oop)this-&gt;object())-&gt;klass());
 304     event.set_address((uintptr_t)(this-&gt;object_addr()));
 305   }
 306 
 307   { // Change java thread status to indicate blocked on monitor enter.
 308     JavaThreadBlockedOnMonitorEnterState jtbmes(jt, this);
 309 
 310     Self-&gt;set_current_pending_monitor(this);
 311 
 312     DTRACE_MONITOR_PROBE(contended__enter, this, object(), jt);
 313     if (JvmtiExport::should_post_monitor_contended_enter()) {
 314       JvmtiExport::post_monitor_contended_enter(jt, this);
 315 
 316       // The current thread does not yet own the monitor and does not
 317       // yet appear on any queues that would get it made the successor.
 318       // This means that the JVMTI_EVENT_MONITOR_CONTENDED_ENTER event
</pre>
<hr />
<pre>
 339       // thread that suspended us.
 340       //
 341       _recursions = 0;
 342       _succ = NULL;
 343       exit(false, Self);
 344 
 345       jt-&gt;java_suspend_self();
 346     }
 347     Self-&gt;set_current_pending_monitor(NULL);
 348 
 349     // We cleared the pending monitor info since we&#39;ve just gotten past
 350     // the enter-check-for-suspend dance and we now own the monitor free
 351     // and clear, i.e., it is no longer pending. The ThreadBlockInVM
 352     // destructor can go to a safepoint at the end of this block. If we
 353     // do a thread dump during that safepoint, then this thread will show
 354     // as having &quot;-locked&quot; the monitor, but the OS and java.lang.Thread
 355     // states will still report that the thread is blocked trying to
 356     // acquire it.
 357   }
 358 
<span class="line-modified"> 359   Atomic::dec(&amp;_contentions);</span>
<span class="line-modified"> 360   assert(_contentions &gt;= 0, &quot;invariant&quot;);</span>
 361   Self-&gt;_Stalled = 0;
 362 
 363   // Must either set _recursions = 0 or ASSERT _recursions == 0.
 364   assert(_recursions == 0, &quot;invariant&quot;);
 365   assert(_owner == Self, &quot;invariant&quot;);
 366   assert(_succ != Self, &quot;invariant&quot;);
 367   assert(((oop)(object()))-&gt;mark() == markWord::encode(this), &quot;invariant&quot;);
 368 
 369   // The thread -- now the owner -- is back in vm mode.
 370   // Report the glorious news via TI,DTrace and jvmstat.
 371   // The probe effect is non-trivial.  All the reportage occurs
 372   // while we hold the monitor, increasing the length of the critical
 373   // section.  Amdahl&#39;s parallel speedup law comes vividly into play.
 374   //
 375   // Another option might be to aggregate the events (thread local or
 376   // per-monitor aggregation) and defer reporting until a more opportune
 377   // time -- such as next time some thread encounters contention but has
 378   // yet to acquire the lock.  While spinning that thread could
 379   // spinning we could increment JVMStat counters, etc.
 380 
 381   DTRACE_MONITOR_PROBE(contended__entered, this, object(), jt);
 382   if (JvmtiExport::should_post_monitor_contended_entered()) {
 383     JvmtiExport::post_monitor_contended_entered(jt, this);
 384 
 385     // The current thread already owns the monitor and is not going to
 386     // call park() for the remainder of the monitor enter protocol. So
 387     // it doesn&#39;t matter if the JVMTI_EVENT_MONITOR_CONTENDED_ENTERED
 388     // event handler consumed an unpark() issued by the thread that
 389     // just exited the monitor.
 390   }
 391   if (event.should_commit()) {
 392     event.set_previousOwner((uintptr_t)_previous_owner_tid);
 393     event.commit();
 394   }
 395   OM_PERFDATA_OP(ContendedLockAttempts, inc());

 396 }
 397 
 398 // Caveat: TryLock() is not necessarily serializing if it returns failure.
 399 // Callers must compensate as needed.
 400 
 401 int ObjectMonitor::TryLock(Thread * Self) {
 402   void * own = _owner;
 403   if (own != NULL) return 0;
 404   if (try_set_owner_from(NULL, Self) == NULL) {
 405     assert(_recursions == 0, &quot;invariant&quot;);
 406     return 1;
 407   }
 408   // The lock had been free momentarily, but we lost the race to the lock.
 409   // Interference -- the CAS failed.
 410   // We can either return -1 or retry.
 411   // Retry doesn&#39;t make as much sense because the lock was just acquired.
 412   return -1;
 413 }
 414 

























































 415 // Convert the fields used by is_busy() to a string that can be
 416 // used for diagnostic output.
 417 const char* ObjectMonitor::is_busy_to_string(stringStream* ss) {
<span class="line-modified"> 418   ss-&gt;print(&quot;is_busy: contentions=%d, waiters=%d, owner=&quot; INTPTR_FORMAT</span>
<span class="line-modified"> 419             &quot;, cxq=&quot; INTPTR_FORMAT &quot;, EntryList=&quot; INTPTR_FORMAT, _contentions,</span>
<span class="line-modified"> 420             _waiters, p2i(_owner), p2i(_cxq), p2i(_EntryList));</span>

















 421   return ss-&gt;base();
 422 }
 423 
 424 #define MAX_RECHECK_INTERVAL 1000
 425 
 426 void ObjectMonitor::EnterI(TRAPS) {
 427   Thread * const Self = THREAD;
 428   assert(Self-&gt;is_Java_thread(), &quot;invariant&quot;);
 429   assert(((JavaThread *) Self)-&gt;thread_state() == _thread_blocked, &quot;invariant&quot;);
 430 
 431   // Try the lock - TATAS
 432   if (TryLock (Self) &gt; 0) {
 433     assert(_succ != Self, &quot;invariant&quot;);
 434     assert(_owner == Self, &quot;invariant&quot;);
 435     assert(_Responsible != Self, &quot;invariant&quot;);
 436     return;
 437   }
 438 



















 439   assert(InitDone, &quot;Unexpectedly not initialized&quot;);
 440 
 441   // We try one round of spinning *before* enqueueing Self.
 442   //
 443   // If the _owner is ready but OFFPROC we could use a YieldTo()
 444   // operation to donate the remainder of this thread&#39;s quantum
 445   // to the owner.  This has subtle but beneficial affinity
 446   // effects.
 447 
 448   if (TrySpin(Self) &gt; 0) {
 449     assert(_owner == Self, &quot;invariant&quot;);
 450     assert(_succ != Self, &quot;invariant&quot;);
 451     assert(_Responsible != Self, &quot;invariant&quot;);
 452     return;
 453   }
 454 
 455   // The Spin failed -- Enqueue and park the thread ...
 456   assert(_succ != Self, &quot;invariant&quot;);
 457   assert(_owner != Self, &quot;invariant&quot;);
 458   assert(_Responsible != Self, &quot;invariant&quot;);
</pre>
<hr />
<pre>
 535 
 536   for (;;) {
 537 
 538     if (TryLock(Self) &gt; 0) break;
 539     assert(_owner != Self, &quot;invariant&quot;);
 540 
 541     // park self
 542     if (_Responsible == Self) {
 543       Self-&gt;_ParkEvent-&gt;park((jlong) recheckInterval);
 544       // Increase the recheckInterval, but clamp the value.
 545       recheckInterval *= 8;
 546       if (recheckInterval &gt; MAX_RECHECK_INTERVAL) {
 547         recheckInterval = MAX_RECHECK_INTERVAL;
 548       }
 549     } else {
 550       Self-&gt;_ParkEvent-&gt;park();
 551     }
 552 
 553     if (TryLock(Self) &gt; 0) break;
 554 

















 555     // The lock is still contested.
 556     // Keep a tally of the # of futile wakeups.
 557     // Note that the counter is not protected by a lock or updated by atomics.
 558     // That is by design - we trade &quot;lossy&quot; counters which are exposed to
 559     // races during updates for a lower probe effect.
 560 
 561     // This PerfData object can be used in parallel with a safepoint.
 562     // See the work around in PerfDataManager::destroy().
 563     OM_PERFDATA_OP(FutileWakeups, inc());
 564     ++nWakeups;
 565 
 566     // Assuming this is not a spurious wakeup we&#39;ll normally find _succ == Self.
 567     // We can defer clearing _succ until after the spin completes
 568     // TrySpin() must tolerate being called with _succ == Self.
 569     // Try yet another round of adaptive spinning.
 570     if (TrySpin(Self) &gt; 0) break;
 571 
 572     // We can find that we were unpark()ed and redesignated _succ while
 573     // we were spinning.  That&#39;s harmless.  If we iterate and call park(),
 574     // park() will consume the event and return immediately and we&#39;ll
</pre>
<hr />
<pre>
 799   SelfNode-&gt;_prev  = (ObjectWaiter *) 0xBAD;
 800   SelfNode-&gt;_next  = (ObjectWaiter *) 0xBAD;
 801   SelfNode-&gt;TState = ObjectWaiter::TS_RUN;
 802 #endif
 803 }
 804 
 805 // -----------------------------------------------------------------------------
 806 // Exit support
 807 //
 808 // exit()
 809 // ~~~~~~
 810 // Note that the collector can&#39;t reclaim the objectMonitor or deflate
 811 // the object out from underneath the thread calling ::exit() as the
 812 // thread calling ::exit() never transitions to a stable state.
 813 // This inhibits GC, which in turn inhibits asynchronous (and
 814 // inopportune) reclamation of &quot;this&quot;.
 815 //
 816 // We&#39;d like to assert that: (THREAD-&gt;thread_state() != _thread_blocked) ;
 817 // There&#39;s one exception to the claim above, however.  EnterI() can call
 818 // exit() to drop a lock if the acquirer has been externally suspended.
<span class="line-modified"> 819 // In that case exit() is called with _thread_state as _thread_blocked,</span>
 820 // but the monitor&#39;s _contentions field is &gt; 0, which inhibits reclamation.
 821 //
 822 // 1-0 exit
 823 // ~~~~~~~~
 824 // ::exit() uses a canonical 1-1 idiom with a MEMBAR although some of
 825 // the fast-path operators have been optimized so the common ::exit()
 826 // operation is 1-0, e.g., see macroAssembler_x86.cpp: fast_unlock().
 827 // The code emitted by fast_unlock() elides the usual MEMBAR.  This
 828 // greatly improves latency -- MEMBAR and CAS having considerable local
 829 // latency on modern processors -- but at the cost of &quot;stranding&quot;.  Absent the
 830 // MEMBAR, a thread in fast_unlock() can race a thread in the slow
 831 // ::enter() path, resulting in the entering thread being stranding
 832 // and a progress-liveness failure.   Stranding is extremely rare.
 833 // We use timers (timed park operations) &amp; periodic polling to detect
 834 // and recover from stranding.  Potentially stranded threads periodically
 835 // wake up and poll the lock.  See the usage of the _Responsible variable.
 836 //
 837 // The CAS() in enter provides for safety and exclusion, while the CAS or
 838 // MEMBAR in exit provides for progress and avoids stranding.  1-0 locking
 839 // eliminates the CAS/MEMBAR from the exit path, but it admits stranding.
</pre>
<hr />
<pre>
1074 }
1075 
1076 
1077 void ObjectMonitor::ExitEpilog(Thread * Self, ObjectWaiter * Wakee) {
1078   assert(_owner == Self, &quot;invariant&quot;);
1079 
1080   // Exit protocol:
1081   // 1. ST _succ = wakee
1082   // 2. membar #loadstore|#storestore;
1083   // 2. ST _owner = NULL
1084   // 3. unpark(wakee)
1085 
1086   _succ = Wakee-&gt;_thread;
1087   ParkEvent * Trigger = Wakee-&gt;_event;
1088 
1089   // Hygiene -- once we&#39;ve set _owner = NULL we can&#39;t safely dereference Wakee again.
1090   // The thread associated with Wakee may have grabbed the lock and &quot;Wakee&quot; may be
1091   // out-of-scope (non-extant).
1092   Wakee  = NULL;
1093 
<span class="line-modified">1094   // Drop the lock</span>
1095   // Uses a fence to separate release_store(owner) from the LD in unpark().
1096   release_clear_owner(Self);
1097   OrderAccess::fence();
1098 
1099   DTRACE_MONITOR_PROBE(contended__exit, this, object(), Self);
1100   Trigger-&gt;unpark();
1101 
1102   // Maintain stats and report events to JVMTI
1103   OM_PERFDATA_OP(Parks, inc());
1104 }
1105 
1106 
1107 // -----------------------------------------------------------------------------
1108 // Class Loader deadlock handling.
1109 //
1110 // complete_exit exits a lock returning recursion count
1111 // complete_exit/reenter operate as a wait without waiting
1112 // complete_exit requires an inflated monitor
1113 // The _owner field is not always the Thread addr even with an
1114 // inflated monitor, e.g. the monitor can be inflated by a non-owning
</pre>
<hr />
<pre>
1122 
1123   void* cur = Atomic::load(&amp;_owner);
1124   if (THREAD != cur) {
1125     if (THREAD-&gt;is_lock_owned((address)cur)) {
1126       assert(_recursions == 0, &quot;internal state error&quot;);
1127       set_owner_from_BasicLock(cur, Self);  // Convert from BasicLock* to Thread*.
1128       _recursions = 0;
1129     }
1130   }
1131 
1132   guarantee(Self == _owner, &quot;complete_exit not owner&quot;);
1133   intx save = _recursions; // record the old recursion count
1134   _recursions = 0;        // set the recursion level to be 0
1135   exit(true, Self);           // exit the monitor
1136   guarantee(_owner != Self, &quot;invariant&quot;);
1137   return save;
1138 }
1139 
1140 // reenter() enters a lock and sets recursion count
1141 // complete_exit/reenter operate as a wait without waiting
<span class="line-modified">1142 void ObjectMonitor::reenter(intx recursions, TRAPS) {</span>
1143   Thread * const Self = THREAD;
1144   assert(Self-&gt;is_Java_thread(), &quot;Must be Java thread!&quot;);
1145   JavaThread *jt = (JavaThread *)THREAD;
1146 
1147   guarantee(_owner != Self, &quot;reenter already owner&quot;);
<span class="line-modified">1148   enter(THREAD);       // enter the monitor</span>



1149   guarantee(_recursions == 0, &quot;reenter recursion&quot;);
1150   _recursions = recursions;
<span class="line-modified">1151   return;</span>
1152 }
1153 
1154 // Checks that the current THREAD owns this monitor and causes an
1155 // immediate return if it doesn&#39;t. We don&#39;t use the CHECK macro
1156 // because we want the IMSE to be the only exception that is thrown
1157 // from the call site when false is returned. Any other pending
1158 // exception is ignored.
1159 #define CHECK_OWNER()                                                  \
1160   do {                                                                 \
1161     if (!check_owner(THREAD)) {                                        \
1162        assert(HAS_PENDING_EXCEPTION, &quot;expected a pending IMSE here.&quot;); \
1163        return;                                                         \
1164      }                                                                 \
1165   } while (false)
1166 
1167 // Returns true if the specified thread owns the ObjectMonitor.
1168 // Otherwise returns false and throws IllegalMonitorStateException
1169 // (IMSE). If there is a pending exception and the specified thread
1170 // is not the owner, that exception will be replaced by the IMSE.
1171 bool ObjectMonitor::check_owner(Thread* THREAD) {
</pre>
<hr />
<pre>
1945   }
1946 
1947   DEBUG_ONLY(InitDone = true;)
1948 }
1949 
1950 void ObjectMonitor::print_on(outputStream* st) const {
1951   // The minimal things to print for markWord printing, more can be added for debugging and logging.
1952   st-&gt;print(&quot;{contentions=0x%08x,waiters=0x%08x&quot;
1953             &quot;,recursions=&quot; INTX_FORMAT &quot;,owner=&quot; INTPTR_FORMAT &quot;}&quot;,
1954             contentions(), waiters(), recursions(),
1955             p2i(owner()));
1956 }
1957 void ObjectMonitor::print() const { print_on(tty); }
1958 
1959 #ifdef ASSERT
1960 // Print the ObjectMonitor like a debugger would:
1961 //
1962 // (ObjectMonitor) 0x00007fdfb6012e40 = {
1963 //   _header = 0x0000000000000001
1964 //   _object = 0x000000070ff45fd0
<span class="line-modified">1965 //   _next_om = 0x0000000000000000</span>
1966 //   _pad_buf0 = {
1967 //     [0] = &#39;\0&#39;
1968 //     ...
<span class="line-modified">1969 //     [103] = &#39;\0&#39;</span>
1970 //   }
1971 //   _owner = 0x0000000000000000
1972 //   _previous_owner_tid = 0






1973 //   _recursions = 0
1974 //   _EntryList = 0x0000000000000000
1975 //   _cxq = 0x0000000000000000
1976 //   _succ = 0x0000000000000000
1977 //   _Responsible = 0x0000000000000000
1978 //   _Spinner = 0
1979 //   _SpinDuration = 5000
1980 //   _contentions = 0
1981 //   _WaitSet = 0x0000700009756248
1982 //   _waiters = 1
1983 //   _WaitSetLock = 0
1984 // }
1985 //
1986 void ObjectMonitor::print_debug_style_on(outputStream* st) const {
1987   st-&gt;print_cr(&quot;(ObjectMonitor*) &quot; INTPTR_FORMAT &quot; = {&quot;, p2i(this));
1988   st-&gt;print_cr(&quot;  _header = &quot; INTPTR_FORMAT, header().value());
1989   st-&gt;print_cr(&quot;  _object = &quot; INTPTR_FORMAT, p2i(_object));
<span class="line-modified">1990   st-&gt;print_cr(&quot;  _next_om = &quot; INTPTR_FORMAT, p2i(next_om()));</span>










1991   st-&gt;print_cr(&quot;  _pad_buf0 = {&quot;);
1992   st-&gt;print_cr(&quot;    [0] = &#39;\\0&#39;&quot;);
1993   st-&gt;print_cr(&quot;    ...&quot;);
1994   st-&gt;print_cr(&quot;    [%d] = &#39;\\0&#39;&quot;, (int)sizeof(_pad_buf0) - 1);
1995   st-&gt;print_cr(&quot;  }&quot;);
1996   st-&gt;print_cr(&quot;  _owner = &quot; INTPTR_FORMAT, p2i(_owner));
1997   st-&gt;print_cr(&quot;  _previous_owner_tid = &quot; JLONG_FORMAT, _previous_owner_tid);






1998   st-&gt;print_cr(&quot;  _recursions = &quot; INTX_FORMAT, _recursions);
1999   st-&gt;print_cr(&quot;  _EntryList = &quot; INTPTR_FORMAT, p2i(_EntryList));
2000   st-&gt;print_cr(&quot;  _cxq = &quot; INTPTR_FORMAT, p2i(_cxq));
2001   st-&gt;print_cr(&quot;  _succ = &quot; INTPTR_FORMAT, p2i(_succ));
2002   st-&gt;print_cr(&quot;  _Responsible = &quot; INTPTR_FORMAT, p2i(_Responsible));
2003   st-&gt;print_cr(&quot;  _Spinner = %d&quot;, _Spinner);
2004   st-&gt;print_cr(&quot;  _SpinDuration = %d&quot;, _SpinDuration);
<span class="line-modified">2005   st-&gt;print_cr(&quot;  _contentions = %d&quot;, _contentions);</span>
2006   st-&gt;print_cr(&quot;  _WaitSet = &quot; INTPTR_FORMAT, p2i(_WaitSet));
2007   st-&gt;print_cr(&quot;  _waiters = %d&quot;, _waiters);
2008   st-&gt;print_cr(&quot;  _WaitSetLock = %d&quot;, _WaitSetLock);
2009   st-&gt;print_cr(&quot;}&quot;);
2010 }
2011 #endif
</pre>
</td>
<td>
<hr />
<pre>
 223 //
 224 // * See also http://blogs.sun.com/dave
 225 
 226 
 227 void* ObjectMonitor::operator new (size_t size) throw() {
 228   return AllocateHeap(size, mtInternal);
 229 }
 230 void* ObjectMonitor::operator new[] (size_t size) throw() {
 231   return operator new (size);
 232 }
 233 void ObjectMonitor::operator delete(void* p) {
 234   FreeHeap(p);
 235 }
 236 void ObjectMonitor::operator delete[] (void *p) {
 237   operator delete(p);
 238 }
 239 
 240 // -----------------------------------------------------------------------------
 241 // Enter support
 242 
<span class="line-modified"> 243 bool ObjectMonitor::enter(TRAPS) {</span>
 244   // The following code is ordered to check the most common cases first
 245   // and to reduce RTS-&gt;RTO cache line upgrades on SPARC and IA32 processors.
 246   Thread * const Self = THREAD;
 247 
 248   void* cur = try_set_owner_from(NULL, Self);
 249   if (cur == NULL) {
 250     assert(_recursions == 0, &quot;invariant&quot;);
<span class="line-modified"> 251     return true;</span>
 252   }
 253 
 254   if (cur == Self) {
 255     // TODO-FIXME: check for integer overflow!  BUGID 6557169.
 256     _recursions++;
<span class="line-modified"> 257     return true;</span>
 258   }
 259 
 260   if (Self-&gt;is_lock_owned((address)cur)) {
 261     assert(_recursions == 0, &quot;internal state error&quot;);
 262     _recursions = 1;
 263     set_owner_from_BasicLock(cur, Self);  // Convert from BasicLock* to Thread*.
<span class="line-modified"> 264     return true;</span>
 265   }
 266 
 267   // We&#39;ve encountered genuine contention.
 268   assert(Self-&gt;_Stalled == 0, &quot;invariant&quot;);
 269   Self-&gt;_Stalled = intptr_t(this);
 270 
 271   // Try one round of spinning *before* enqueueing Self
 272   // and before going through the awkward and expensive state
 273   // transitions.  The following spin is strictly optional ...
 274   // Note that if we acquire the monitor from an initial spin
 275   // we forgo posting JVMTI events and firing DTRACE probes.
 276   if (TrySpin(Self) &gt; 0) {
 277     assert(_owner == Self, &quot;must be Self: owner=&quot; INTPTR_FORMAT, p2i(_owner));
 278     assert(_recursions == 0, &quot;must be 0: recursions=&quot; INTX_FORMAT, _recursions);
 279     assert(((oop)object())-&gt;mark() == markWord::encode(this),
 280            &quot;object mark must match encoded this: mark=&quot; INTPTR_FORMAT
 281            &quot;, encoded this=&quot; INTPTR_FORMAT, ((oop)object())-&gt;mark().value(),
 282            markWord::encode(this).value());
 283     Self-&gt;_Stalled = 0;
<span class="line-modified"> 284     return true;</span>
 285   }
 286 
 287   assert(_owner != Self, &quot;invariant&quot;);
 288   assert(_succ != Self, &quot;invariant&quot;);
 289   assert(Self-&gt;is_Java_thread(), &quot;invariant&quot;);
 290   JavaThread * jt = (JavaThread *) Self;
 291   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 292   assert(jt-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;);
<span class="line-modified"> 293   assert(AsyncDeflateIdleMonitors || this-&gt;object() != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 294   assert(AsyncDeflateIdleMonitors || contentions() &gt;= 0, &quot;must not be negative: contentions=%d&quot;, contentions());</span>
<span class="line-modified"> 295 </span>
<span class="line-modified"> 296   // Keep track of contention for JVM/TI and M&amp;M queries.</span>
<span class="line-modified"> 297   add_to_contentions(1);</span>
<span class="line-modified"> 298   if (is_being_async_deflated()) {</span>
<span class="line-added"> 299     // Async deflation is in progress and our contentions increment</span>
<span class="line-added"> 300     // above lost the race to async deflation. Undo the work and</span>
<span class="line-added"> 301     // force the caller to retry.</span>
<span class="line-added"> 302     const oop l_object = (oop)object();</span>
<span class="line-added"> 303     if (l_object != NULL) {</span>
<span class="line-added"> 304       // Attempt to restore the header/dmw to the object&#39;s header so that</span>
<span class="line-added"> 305       // we only retry once if the deflater thread happens to be slow.</span>
<span class="line-added"> 306       install_displaced_markword_in_object(l_object);</span>
<span class="line-added"> 307     }</span>
<span class="line-added"> 308     Self-&gt;_Stalled = 0;</span>
<span class="line-added"> 309     add_to_contentions(-1);</span>
<span class="line-added"> 310     return false;</span>
<span class="line-added"> 311   }</span>
 312 
 313   JFR_ONLY(JfrConditionalFlushWithStacktrace&lt;EventJavaMonitorEnter&gt; flush(jt);)
 314   EventJavaMonitorEnter event;
 315   if (event.should_commit()) {
 316     event.set_monitorClass(((oop)this-&gt;object())-&gt;klass());
 317     event.set_address((uintptr_t)(this-&gt;object_addr()));
 318   }
 319 
 320   { // Change java thread status to indicate blocked on monitor enter.
 321     JavaThreadBlockedOnMonitorEnterState jtbmes(jt, this);
 322 
 323     Self-&gt;set_current_pending_monitor(this);
 324 
 325     DTRACE_MONITOR_PROBE(contended__enter, this, object(), jt);
 326     if (JvmtiExport::should_post_monitor_contended_enter()) {
 327       JvmtiExport::post_monitor_contended_enter(jt, this);
 328 
 329       // The current thread does not yet own the monitor and does not
 330       // yet appear on any queues that would get it made the successor.
 331       // This means that the JVMTI_EVENT_MONITOR_CONTENDED_ENTER event
</pre>
<hr />
<pre>
 352       // thread that suspended us.
 353       //
 354       _recursions = 0;
 355       _succ = NULL;
 356       exit(false, Self);
 357 
 358       jt-&gt;java_suspend_self();
 359     }
 360     Self-&gt;set_current_pending_monitor(NULL);
 361 
 362     // We cleared the pending monitor info since we&#39;ve just gotten past
 363     // the enter-check-for-suspend dance and we now own the monitor free
 364     // and clear, i.e., it is no longer pending. The ThreadBlockInVM
 365     // destructor can go to a safepoint at the end of this block. If we
 366     // do a thread dump during that safepoint, then this thread will show
 367     // as having &quot;-locked&quot; the monitor, but the OS and java.lang.Thread
 368     // states will still report that the thread is blocked trying to
 369     // acquire it.
 370   }
 371 
<span class="line-modified"> 372   add_to_contentions(-1);</span>
<span class="line-modified"> 373   assert(contentions() &gt;= 0, &quot;must not be negative: contentions=%d&quot;, contentions());</span>
 374   Self-&gt;_Stalled = 0;
 375 
 376   // Must either set _recursions = 0 or ASSERT _recursions == 0.
 377   assert(_recursions == 0, &quot;invariant&quot;);
 378   assert(_owner == Self, &quot;invariant&quot;);
 379   assert(_succ != Self, &quot;invariant&quot;);
 380   assert(((oop)(object()))-&gt;mark() == markWord::encode(this), &quot;invariant&quot;);
 381 
 382   // The thread -- now the owner -- is back in vm mode.
 383   // Report the glorious news via TI,DTrace and jvmstat.
 384   // The probe effect is non-trivial.  All the reportage occurs
 385   // while we hold the monitor, increasing the length of the critical
 386   // section.  Amdahl&#39;s parallel speedup law comes vividly into play.
 387   //
 388   // Another option might be to aggregate the events (thread local or
 389   // per-monitor aggregation) and defer reporting until a more opportune
 390   // time -- such as next time some thread encounters contention but has
 391   // yet to acquire the lock.  While spinning that thread could
 392   // spinning we could increment JVMStat counters, etc.
 393 
 394   DTRACE_MONITOR_PROBE(contended__entered, this, object(), jt);
 395   if (JvmtiExport::should_post_monitor_contended_entered()) {
 396     JvmtiExport::post_monitor_contended_entered(jt, this);
 397 
 398     // The current thread already owns the monitor and is not going to
 399     // call park() for the remainder of the monitor enter protocol. So
 400     // it doesn&#39;t matter if the JVMTI_EVENT_MONITOR_CONTENDED_ENTERED
 401     // event handler consumed an unpark() issued by the thread that
 402     // just exited the monitor.
 403   }
 404   if (event.should_commit()) {
 405     event.set_previousOwner((uintptr_t)_previous_owner_tid);
 406     event.commit();
 407   }
 408   OM_PERFDATA_OP(ContendedLockAttempts, inc());
<span class="line-added"> 409   return true;</span>
 410 }
 411 
 412 // Caveat: TryLock() is not necessarily serializing if it returns failure.
 413 // Callers must compensate as needed.
 414 
 415 int ObjectMonitor::TryLock(Thread * Self) {
 416   void * own = _owner;
 417   if (own != NULL) return 0;
 418   if (try_set_owner_from(NULL, Self) == NULL) {
 419     assert(_recursions == 0, &quot;invariant&quot;);
 420     return 1;
 421   }
 422   // The lock had been free momentarily, but we lost the race to the lock.
 423   // Interference -- the CAS failed.
 424   // We can either return -1 or retry.
 425   // Retry doesn&#39;t make as much sense because the lock was just acquired.
 426   return -1;
 427 }
 428 
<span class="line-added"> 429 // Install the displaced mark word (dmw) of a deflating ObjectMonitor</span>
<span class="line-added"> 430 // into the header of the object associated with the monitor. This</span>
<span class="line-added"> 431 // idempotent method is called by a thread that is deflating a</span>
<span class="line-added"> 432 // monitor and by other threads that have detected a race with the</span>
<span class="line-added"> 433 // deflation process.</span>
<span class="line-added"> 434 void ObjectMonitor::install_displaced_markword_in_object(const oop obj) {</span>
<span class="line-added"> 435   // This function must only be called when (owner == DEFLATER_MARKER</span>
<span class="line-added"> 436   // &amp;&amp; contentions &lt;= 0), but we can&#39;t guarantee that here because</span>
<span class="line-added"> 437   // those values could change when the ObjectMonitor gets moved from</span>
<span class="line-added"> 438   // the global free list to a per-thread free list.</span>
<span class="line-added"> 439 </span>
<span class="line-added"> 440   guarantee(obj != NULL, &quot;must be non-NULL&quot;);</span>
<span class="line-added"> 441 </span>
<span class="line-added"> 442   // Separate loads in is_being_async_deflated(), which is almost always</span>
<span class="line-added"> 443   // called before this function, from the load of dmw/header below.</span>
<span class="line-added"> 444   if (support_IRIW_for_not_multiple_copy_atomic_cpu) {</span>
<span class="line-added"> 445     // A non-multiple copy atomic (nMCA) machine needs a bigger</span>
<span class="line-added"> 446     // hammer to separate the loads before and the load below.</span>
<span class="line-added"> 447     OrderAccess::fence();</span>
<span class="line-added"> 448   } else {</span>
<span class="line-added"> 449     OrderAccess::loadload();</span>
<span class="line-added"> 450   }</span>
<span class="line-added"> 451 </span>
<span class="line-added"> 452   const oop l_object = (oop)object();</span>
<span class="line-added"> 453   if (l_object == NULL) {</span>
<span class="line-added"> 454     // ObjectMonitor&#39;s object ref has already been cleared by async</span>
<span class="line-added"> 455     // deflation so we&#39;re done here.</span>
<span class="line-added"> 456     return;</span>
<span class="line-added"> 457   }</span>
<span class="line-added"> 458   ADIM_guarantee(l_object == obj, &quot;object=&quot; INTPTR_FORMAT &quot; must equal obj=&quot;</span>
<span class="line-added"> 459                  INTPTR_FORMAT, p2i(l_object), p2i(obj));</span>
<span class="line-added"> 460 </span>
<span class="line-added"> 461   markWord dmw = header();</span>
<span class="line-added"> 462   // The dmw has to be neutral (not NULL, not locked and not marked).</span>
<span class="line-added"> 463   ADIM_guarantee(dmw.is_neutral(), &quot;must be neutral: dmw=&quot; INTPTR_FORMAT, dmw.value());</span>
<span class="line-added"> 464 </span>
<span class="line-added"> 465   // Install displaced mark word if the object&#39;s header still points</span>
<span class="line-added"> 466   // to this ObjectMonitor. More than one racing caller to this function</span>
<span class="line-added"> 467   // can rarely reach this point, but only one can win.</span>
<span class="line-added"> 468   markWord res = obj-&gt;cas_set_mark(dmw, markWord::encode(this));</span>
<span class="line-added"> 469   if (res != markWord::encode(this)) {</span>
<span class="line-added"> 470     // This should be rare so log at the Info level when it happens.</span>
<span class="line-added"> 471     log_info(monitorinflation)(&quot;install_displaced_markword_in_object: &quot;</span>
<span class="line-added"> 472                                &quot;failed cas_set_mark: new_mark=&quot; INTPTR_FORMAT</span>
<span class="line-added"> 473                                &quot;, old_mark=&quot; INTPTR_FORMAT &quot;, res=&quot; INTPTR_FORMAT,</span>
<span class="line-added"> 474                                dmw.value(), markWord::encode(this).value(),</span>
<span class="line-added"> 475                                res.value());</span>
<span class="line-added"> 476   }</span>
<span class="line-added"> 477 </span>
<span class="line-added"> 478   // Note: It does not matter which thread restored the header/dmw</span>
<span class="line-added"> 479   // into the object&#39;s header. The thread deflating the monitor just</span>
<span class="line-added"> 480   // wanted the object&#39;s header restored and it is. The threads that</span>
<span class="line-added"> 481   // detected a race with the deflation process also wanted the</span>
<span class="line-added"> 482   // object&#39;s header restored before they retry their operation and</span>
<span class="line-added"> 483   // because it is restored they will only retry once.</span>
<span class="line-added"> 484 }</span>
<span class="line-added"> 485 </span>
 486 // Convert the fields used by is_busy() to a string that can be
 487 // used for diagnostic output.
 488 const char* ObjectMonitor::is_busy_to_string(stringStream* ss) {
<span class="line-modified"> 489   ss-&gt;print(&quot;is_busy: waiters=%d, &quot;, _waiters);</span>
<span class="line-modified"> 490   if (!AsyncDeflateIdleMonitors) {</span>
<span class="line-modified"> 491     ss-&gt;print(&quot;contentions=%d, &quot;, contentions());</span>
<span class="line-added"> 492     ss-&gt;print(&quot;owner=&quot; INTPTR_FORMAT, p2i(_owner));</span>
<span class="line-added"> 493   } else {</span>
<span class="line-added"> 494     if (contentions() &gt; 0) {</span>
<span class="line-added"> 495       ss-&gt;print(&quot;contentions=%d, &quot;, contentions());</span>
<span class="line-added"> 496     } else {</span>
<span class="line-added"> 497       ss-&gt;print(&quot;contentions=0&quot;);</span>
<span class="line-added"> 498     }</span>
<span class="line-added"> 499     if (_owner != DEFLATER_MARKER) {</span>
<span class="line-added"> 500       ss-&gt;print(&quot;owner=&quot; INTPTR_FORMAT, p2i(_owner));</span>
<span class="line-added"> 501     } else {</span>
<span class="line-added"> 502       // We report NULL instead of DEFLATER_MARKER here because is_busy()</span>
<span class="line-added"> 503       // ignores DEFLATER_MARKER values.</span>
<span class="line-added"> 504       ss-&gt;print(&quot;owner=&quot; INTPTR_FORMAT, NULL);</span>
<span class="line-added"> 505     }</span>
<span class="line-added"> 506   }</span>
<span class="line-added"> 507   ss-&gt;print(&quot;, cxq=&quot; INTPTR_FORMAT &quot;, EntryList=&quot; INTPTR_FORMAT, p2i(_cxq),</span>
<span class="line-added"> 508             p2i(_EntryList));</span>
 509   return ss-&gt;base();
 510 }
 511 
 512 #define MAX_RECHECK_INTERVAL 1000
 513 
 514 void ObjectMonitor::EnterI(TRAPS) {
 515   Thread * const Self = THREAD;
 516   assert(Self-&gt;is_Java_thread(), &quot;invariant&quot;);
 517   assert(((JavaThread *) Self)-&gt;thread_state() == _thread_blocked, &quot;invariant&quot;);
 518 
 519   // Try the lock - TATAS
 520   if (TryLock (Self) &gt; 0) {
 521     assert(_succ != Self, &quot;invariant&quot;);
 522     assert(_owner == Self, &quot;invariant&quot;);
 523     assert(_Responsible != Self, &quot;invariant&quot;);
 524     return;
 525   }
 526 
<span class="line-added"> 527   if (AsyncDeflateIdleMonitors &amp;&amp;</span>
<span class="line-added"> 528       try_set_owner_from(DEFLATER_MARKER, Self) == DEFLATER_MARKER) {</span>
<span class="line-added"> 529     // Cancelled the in-progress async deflation by changing owner from</span>
<span class="line-added"> 530     // DEFLATER_MARKER to Self. As part of the contended enter protocol,</span>
<span class="line-added"> 531     // contentions was incremented to a positive value before EnterI()</span>
<span class="line-added"> 532     // was called and that prevents the deflater thread from winning the</span>
<span class="line-added"> 533     // last part of the 2-part async deflation protocol. After EnterI()</span>
<span class="line-added"> 534     // returns to enter(), contentions is decremented because the caller</span>
<span class="line-added"> 535     // now owns the monitor. We bump contentions an extra time here to</span>
<span class="line-added"> 536     // prevent the deflater thread from winning the last part of the</span>
<span class="line-added"> 537     // 2-part async deflation protocol after the regular decrement</span>
<span class="line-added"> 538     // occurs in enter(). The deflater thread will decrement contentions</span>
<span class="line-added"> 539     // after it recognizes that the async deflation was cancelled.</span>
<span class="line-added"> 540     add_to_contentions(1);</span>
<span class="line-added"> 541     assert(_succ != Self, &quot;invariant&quot;);</span>
<span class="line-added"> 542     assert(_Responsible != Self, &quot;invariant&quot;);</span>
<span class="line-added"> 543     return;</span>
<span class="line-added"> 544   }</span>
<span class="line-added"> 545 </span>
 546   assert(InitDone, &quot;Unexpectedly not initialized&quot;);
 547 
 548   // We try one round of spinning *before* enqueueing Self.
 549   //
 550   // If the _owner is ready but OFFPROC we could use a YieldTo()
 551   // operation to donate the remainder of this thread&#39;s quantum
 552   // to the owner.  This has subtle but beneficial affinity
 553   // effects.
 554 
 555   if (TrySpin(Self) &gt; 0) {
 556     assert(_owner == Self, &quot;invariant&quot;);
 557     assert(_succ != Self, &quot;invariant&quot;);
 558     assert(_Responsible != Self, &quot;invariant&quot;);
 559     return;
 560   }
 561 
 562   // The Spin failed -- Enqueue and park the thread ...
 563   assert(_succ != Self, &quot;invariant&quot;);
 564   assert(_owner != Self, &quot;invariant&quot;);
 565   assert(_Responsible != Self, &quot;invariant&quot;);
</pre>
<hr />
<pre>
 642 
 643   for (;;) {
 644 
 645     if (TryLock(Self) &gt; 0) break;
 646     assert(_owner != Self, &quot;invariant&quot;);
 647 
 648     // park self
 649     if (_Responsible == Self) {
 650       Self-&gt;_ParkEvent-&gt;park((jlong) recheckInterval);
 651       // Increase the recheckInterval, but clamp the value.
 652       recheckInterval *= 8;
 653       if (recheckInterval &gt; MAX_RECHECK_INTERVAL) {
 654         recheckInterval = MAX_RECHECK_INTERVAL;
 655       }
 656     } else {
 657       Self-&gt;_ParkEvent-&gt;park();
 658     }
 659 
 660     if (TryLock(Self) &gt; 0) break;
 661 
<span class="line-added"> 662     if (AsyncDeflateIdleMonitors &amp;&amp;</span>
<span class="line-added"> 663         try_set_owner_from(DEFLATER_MARKER, Self) == DEFLATER_MARKER) {</span>
<span class="line-added"> 664       // Cancelled the in-progress async deflation by changing owner from</span>
<span class="line-added"> 665       // DEFLATER_MARKER to Self. As part of the contended enter protocol,</span>
<span class="line-added"> 666       // contentions was incremented to a positive value before EnterI()</span>
<span class="line-added"> 667       // was called and that prevents the deflater thread from winning the</span>
<span class="line-added"> 668       // last part of the 2-part async deflation protocol. After EnterI()</span>
<span class="line-added"> 669       // returns to enter(), contentions is decremented because the caller</span>
<span class="line-added"> 670       // now owns the monitor. We bump contentions an extra time here to</span>
<span class="line-added"> 671       // prevent the deflater thread from winning the last part of the</span>
<span class="line-added"> 672       // 2-part async deflation protocol after the regular decrement</span>
<span class="line-added"> 673       // occurs in enter(). The deflater thread will decrement contentions</span>
<span class="line-added"> 674       // after it recognizes that the async deflation was cancelled.</span>
<span class="line-added"> 675       add_to_contentions(1);</span>
<span class="line-added"> 676       break;</span>
<span class="line-added"> 677     }</span>
<span class="line-added"> 678 </span>
 679     // The lock is still contested.
 680     // Keep a tally of the # of futile wakeups.
 681     // Note that the counter is not protected by a lock or updated by atomics.
 682     // That is by design - we trade &quot;lossy&quot; counters which are exposed to
 683     // races during updates for a lower probe effect.
 684 
 685     // This PerfData object can be used in parallel with a safepoint.
 686     // See the work around in PerfDataManager::destroy().
 687     OM_PERFDATA_OP(FutileWakeups, inc());
 688     ++nWakeups;
 689 
 690     // Assuming this is not a spurious wakeup we&#39;ll normally find _succ == Self.
 691     // We can defer clearing _succ until after the spin completes
 692     // TrySpin() must tolerate being called with _succ == Self.
 693     // Try yet another round of adaptive spinning.
 694     if (TrySpin(Self) &gt; 0) break;
 695 
 696     // We can find that we were unpark()ed and redesignated _succ while
 697     // we were spinning.  That&#39;s harmless.  If we iterate and call park(),
 698     // park() will consume the event and return immediately and we&#39;ll
</pre>
<hr />
<pre>
 923   SelfNode-&gt;_prev  = (ObjectWaiter *) 0xBAD;
 924   SelfNode-&gt;_next  = (ObjectWaiter *) 0xBAD;
 925   SelfNode-&gt;TState = ObjectWaiter::TS_RUN;
 926 #endif
 927 }
 928 
 929 // -----------------------------------------------------------------------------
 930 // Exit support
 931 //
 932 // exit()
 933 // ~~~~~~
 934 // Note that the collector can&#39;t reclaim the objectMonitor or deflate
 935 // the object out from underneath the thread calling ::exit() as the
 936 // thread calling ::exit() never transitions to a stable state.
 937 // This inhibits GC, which in turn inhibits asynchronous (and
 938 // inopportune) reclamation of &quot;this&quot;.
 939 //
 940 // We&#39;d like to assert that: (THREAD-&gt;thread_state() != _thread_blocked) ;
 941 // There&#39;s one exception to the claim above, however.  EnterI() can call
 942 // exit() to drop a lock if the acquirer has been externally suspended.
<span class="line-modified"> 943 // In that case exit() is called with _thread_state == _thread_blocked,</span>
 944 // but the monitor&#39;s _contentions field is &gt; 0, which inhibits reclamation.
 945 //
 946 // 1-0 exit
 947 // ~~~~~~~~
 948 // ::exit() uses a canonical 1-1 idiom with a MEMBAR although some of
 949 // the fast-path operators have been optimized so the common ::exit()
 950 // operation is 1-0, e.g., see macroAssembler_x86.cpp: fast_unlock().
 951 // The code emitted by fast_unlock() elides the usual MEMBAR.  This
 952 // greatly improves latency -- MEMBAR and CAS having considerable local
 953 // latency on modern processors -- but at the cost of &quot;stranding&quot;.  Absent the
 954 // MEMBAR, a thread in fast_unlock() can race a thread in the slow
 955 // ::enter() path, resulting in the entering thread being stranding
 956 // and a progress-liveness failure.   Stranding is extremely rare.
 957 // We use timers (timed park operations) &amp; periodic polling to detect
 958 // and recover from stranding.  Potentially stranded threads periodically
 959 // wake up and poll the lock.  See the usage of the _Responsible variable.
 960 //
 961 // The CAS() in enter provides for safety and exclusion, while the CAS or
 962 // MEMBAR in exit provides for progress and avoids stranding.  1-0 locking
 963 // eliminates the CAS/MEMBAR from the exit path, but it admits stranding.
</pre>
<hr />
<pre>
1198 }
1199 
1200 
1201 void ObjectMonitor::ExitEpilog(Thread * Self, ObjectWaiter * Wakee) {
1202   assert(_owner == Self, &quot;invariant&quot;);
1203 
1204   // Exit protocol:
1205   // 1. ST _succ = wakee
1206   // 2. membar #loadstore|#storestore;
1207   // 2. ST _owner = NULL
1208   // 3. unpark(wakee)
1209 
1210   _succ = Wakee-&gt;_thread;
1211   ParkEvent * Trigger = Wakee-&gt;_event;
1212 
1213   // Hygiene -- once we&#39;ve set _owner = NULL we can&#39;t safely dereference Wakee again.
1214   // The thread associated with Wakee may have grabbed the lock and &quot;Wakee&quot; may be
1215   // out-of-scope (non-extant).
1216   Wakee  = NULL;
1217 
<span class="line-modified">1218   // Drop the lock.</span>
1219   // Uses a fence to separate release_store(owner) from the LD in unpark().
1220   release_clear_owner(Self);
1221   OrderAccess::fence();
1222 
1223   DTRACE_MONITOR_PROBE(contended__exit, this, object(), Self);
1224   Trigger-&gt;unpark();
1225 
1226   // Maintain stats and report events to JVMTI
1227   OM_PERFDATA_OP(Parks, inc());
1228 }
1229 
1230 
1231 // -----------------------------------------------------------------------------
1232 // Class Loader deadlock handling.
1233 //
1234 // complete_exit exits a lock returning recursion count
1235 // complete_exit/reenter operate as a wait without waiting
1236 // complete_exit requires an inflated monitor
1237 // The _owner field is not always the Thread addr even with an
1238 // inflated monitor, e.g. the monitor can be inflated by a non-owning
</pre>
<hr />
<pre>
1246 
1247   void* cur = Atomic::load(&amp;_owner);
1248   if (THREAD != cur) {
1249     if (THREAD-&gt;is_lock_owned((address)cur)) {
1250       assert(_recursions == 0, &quot;internal state error&quot;);
1251       set_owner_from_BasicLock(cur, Self);  // Convert from BasicLock* to Thread*.
1252       _recursions = 0;
1253     }
1254   }
1255 
1256   guarantee(Self == _owner, &quot;complete_exit not owner&quot;);
1257   intx save = _recursions; // record the old recursion count
1258   _recursions = 0;        // set the recursion level to be 0
1259   exit(true, Self);           // exit the monitor
1260   guarantee(_owner != Self, &quot;invariant&quot;);
1261   return save;
1262 }
1263 
1264 // reenter() enters a lock and sets recursion count
1265 // complete_exit/reenter operate as a wait without waiting
<span class="line-modified">1266 bool ObjectMonitor::reenter(intx recursions, TRAPS) {</span>
1267   Thread * const Self = THREAD;
1268   assert(Self-&gt;is_Java_thread(), &quot;Must be Java thread!&quot;);
1269   JavaThread *jt = (JavaThread *)THREAD;
1270 
1271   guarantee(_owner != Self, &quot;reenter already owner&quot;);
<span class="line-modified">1272   if (!enter(THREAD)) {</span>
<span class="line-added">1273     return false;</span>
<span class="line-added">1274   }</span>
<span class="line-added">1275   // Entered the monitor.</span>
1276   guarantee(_recursions == 0, &quot;reenter recursion&quot;);
1277   _recursions = recursions;
<span class="line-modified">1278   return true;</span>
1279 }
1280 
1281 // Checks that the current THREAD owns this monitor and causes an
1282 // immediate return if it doesn&#39;t. We don&#39;t use the CHECK macro
1283 // because we want the IMSE to be the only exception that is thrown
1284 // from the call site when false is returned. Any other pending
1285 // exception is ignored.
1286 #define CHECK_OWNER()                                                  \
1287   do {                                                                 \
1288     if (!check_owner(THREAD)) {                                        \
1289        assert(HAS_PENDING_EXCEPTION, &quot;expected a pending IMSE here.&quot;); \
1290        return;                                                         \
1291      }                                                                 \
1292   } while (false)
1293 
1294 // Returns true if the specified thread owns the ObjectMonitor.
1295 // Otherwise returns false and throws IllegalMonitorStateException
1296 // (IMSE). If there is a pending exception and the specified thread
1297 // is not the owner, that exception will be replaced by the IMSE.
1298 bool ObjectMonitor::check_owner(Thread* THREAD) {
</pre>
<hr />
<pre>
2072   }
2073 
2074   DEBUG_ONLY(InitDone = true;)
2075 }
2076 
2077 void ObjectMonitor::print_on(outputStream* st) const {
2078   // The minimal things to print for markWord printing, more can be added for debugging and logging.
2079   st-&gt;print(&quot;{contentions=0x%08x,waiters=0x%08x&quot;
2080             &quot;,recursions=&quot; INTX_FORMAT &quot;,owner=&quot; INTPTR_FORMAT &quot;}&quot;,
2081             contentions(), waiters(), recursions(),
2082             p2i(owner()));
2083 }
2084 void ObjectMonitor::print() const { print_on(tty); }
2085 
2086 #ifdef ASSERT
2087 // Print the ObjectMonitor like a debugger would:
2088 //
2089 // (ObjectMonitor) 0x00007fdfb6012e40 = {
2090 //   _header = 0x0000000000000001
2091 //   _object = 0x000000070ff45fd0
<span class="line-modified">2092 //   _allocation_state = Old</span>
2093 //   _pad_buf0 = {
2094 //     [0] = &#39;\0&#39;
2095 //     ...
<span class="line-modified">2096 //     [43] = &#39;\0&#39;</span>
2097 //   }
2098 //   _owner = 0x0000000000000000
2099 //   _previous_owner_tid = 0
<span class="line-added">2100 //   _pad_buf1 = {</span>
<span class="line-added">2101 //     [0] = &#39;\0&#39;</span>
<span class="line-added">2102 //     ...</span>
<span class="line-added">2103 //     [47] = &#39;\0&#39;</span>
<span class="line-added">2104 //   }</span>
<span class="line-added">2105 //   _next_om = 0x0000000000000000</span>
2106 //   _recursions = 0
2107 //   _EntryList = 0x0000000000000000
2108 //   _cxq = 0x0000000000000000
2109 //   _succ = 0x0000000000000000
2110 //   _Responsible = 0x0000000000000000
2111 //   _Spinner = 0
2112 //   _SpinDuration = 5000
2113 //   _contentions = 0
2114 //   _WaitSet = 0x0000700009756248
2115 //   _waiters = 1
2116 //   _WaitSetLock = 0
2117 // }
2118 //
2119 void ObjectMonitor::print_debug_style_on(outputStream* st) const {
2120   st-&gt;print_cr(&quot;(ObjectMonitor*) &quot; INTPTR_FORMAT &quot; = {&quot;, p2i(this));
2121   st-&gt;print_cr(&quot;  _header = &quot; INTPTR_FORMAT, header().value());
2122   st-&gt;print_cr(&quot;  _object = &quot; INTPTR_FORMAT, p2i(_object));
<span class="line-modified">2123   st-&gt;print(&quot;  _allocation_state = &quot;);</span>
<span class="line-added">2124   if (is_free()) {</span>
<span class="line-added">2125     st-&gt;print(&quot;Free&quot;);</span>
<span class="line-added">2126   } else if (is_old()) {</span>
<span class="line-added">2127     st-&gt;print(&quot;Old&quot;);</span>
<span class="line-added">2128   } else if (is_new()) {</span>
<span class="line-added">2129     st-&gt;print(&quot;New&quot;);</span>
<span class="line-added">2130   } else {</span>
<span class="line-added">2131     st-&gt;print(&quot;unknown=%d&quot;, _allocation_state);</span>
<span class="line-added">2132   }</span>
<span class="line-added">2133   st-&gt;cr();</span>
2134   st-&gt;print_cr(&quot;  _pad_buf0 = {&quot;);
2135   st-&gt;print_cr(&quot;    [0] = &#39;\\0&#39;&quot;);
2136   st-&gt;print_cr(&quot;    ...&quot;);
2137   st-&gt;print_cr(&quot;    [%d] = &#39;\\0&#39;&quot;, (int)sizeof(_pad_buf0) - 1);
2138   st-&gt;print_cr(&quot;  }&quot;);
2139   st-&gt;print_cr(&quot;  _owner = &quot; INTPTR_FORMAT, p2i(_owner));
2140   st-&gt;print_cr(&quot;  _previous_owner_tid = &quot; JLONG_FORMAT, _previous_owner_tid);
<span class="line-added">2141   st-&gt;print_cr(&quot;  _pad_buf1 = {&quot;);</span>
<span class="line-added">2142   st-&gt;print_cr(&quot;    [0] = &#39;\\0&#39;&quot;);</span>
<span class="line-added">2143   st-&gt;print_cr(&quot;    ...&quot;);</span>
<span class="line-added">2144   st-&gt;print_cr(&quot;    [%d] = &#39;\\0&#39;&quot;, (int)sizeof(_pad_buf1) - 1);</span>
<span class="line-added">2145   st-&gt;print_cr(&quot;  }&quot;);</span>
<span class="line-added">2146   st-&gt;print_cr(&quot;  _next_om = &quot; INTPTR_FORMAT, p2i(next_om()));</span>
2147   st-&gt;print_cr(&quot;  _recursions = &quot; INTX_FORMAT, _recursions);
2148   st-&gt;print_cr(&quot;  _EntryList = &quot; INTPTR_FORMAT, p2i(_EntryList));
2149   st-&gt;print_cr(&quot;  _cxq = &quot; INTPTR_FORMAT, p2i(_cxq));
2150   st-&gt;print_cr(&quot;  _succ = &quot; INTPTR_FORMAT, p2i(_succ));
2151   st-&gt;print_cr(&quot;  _Responsible = &quot; INTPTR_FORMAT, p2i(_Responsible));
2152   st-&gt;print_cr(&quot;  _Spinner = %d&quot;, _Spinner);
2153   st-&gt;print_cr(&quot;  _SpinDuration = %d&quot;, _SpinDuration);
<span class="line-modified">2154   st-&gt;print_cr(&quot;  _contentions = %d&quot;, contentions());</span>
2155   st-&gt;print_cr(&quot;  _WaitSet = &quot; INTPTR_FORMAT, p2i(_WaitSet));
2156   st-&gt;print_cr(&quot;  _waiters = %d&quot;, _waiters);
2157   st-&gt;print_cr(&quot;  _WaitSetLock = %d&quot;, _WaitSetLock);
2158   st-&gt;print_cr(&quot;}&quot;);
2159 }
2160 #endif
</pre>
</td>
</tr>
</table>
<center><a href="mutexLocker.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objectMonitor.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
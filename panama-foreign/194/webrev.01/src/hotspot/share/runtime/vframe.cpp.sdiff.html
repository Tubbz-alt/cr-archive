<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/vframe.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="thread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/vframe.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
105 javaVFrame* vframe::java_sender() const {
106   vframe* f = sender();
107   while (f != NULL) {
108     if (f-&gt;is_java_frame()) return javaVFrame::cast(f);
109     f = f-&gt;sender();
110   }
111   return NULL;
112 }
113 
114 // ------------- javaVFrame --------------
115 
116 GrowableArray&lt;MonitorInfo*&gt;* javaVFrame::locked_monitors() {
117   assert(SafepointSynchronize::is_at_safepoint() || JavaThread::current() == thread(),
118          &quot;must be at safepoint or it&#39;s a java frame of the current thread&quot;);
119 
120   GrowableArray&lt;MonitorInfo*&gt;* mons = monitors();
121   GrowableArray&lt;MonitorInfo*&gt;* result = new GrowableArray&lt;MonitorInfo*&gt;(mons-&gt;length());
122   if (mons-&gt;is_empty()) return result;
123 
124   bool found_first_monitor = false;
<span class="line-modified">125   ObjectMonitor *pending_monitor = thread()-&gt;current_pending_monitor();</span>


126   ObjectMonitor *waiting_monitor = thread()-&gt;current_waiting_monitor();




127   oop pending_obj = (pending_monitor != NULL ? (oop) pending_monitor-&gt;object() : (oop) NULL);
128   oop waiting_obj = (waiting_monitor != NULL ? (oop) waiting_monitor-&gt;object() : (oop) NULL);
129 
130   for (int index = (mons-&gt;length()-1); index &gt;= 0; index--) {
131     MonitorInfo* monitor = mons-&gt;at(index);
132     if (monitor-&gt;eliminated() &amp;&amp; is_compiled_frame()) continue; // skip eliminated monitor
133     oop obj = monitor-&gt;owner();
134     if (obj == NULL) continue; // skip unowned monitor
135     //
136     // Skip the monitor that the thread is blocked to enter or waiting on
137     //
138     if (!found_first_monitor &amp;&amp; (obj == pending_obj || obj == waiting_obj)) {
139       continue;
140     }
141     found_first_monitor = true;
142     result-&gt;append(monitor);
143   }
144   return result;
145 }
146 
</pre>
<hr />
<pre>
214           st-&gt;print(&quot;\t- eliminated &lt;owner is scalar replaced&gt; (a %s)&quot;, k-&gt;external_name());
215         } else {
216           Handle obj(THREAD, monitor-&gt;owner());
217           if (obj() != NULL) {
218             print_locked_object_class_name(st, obj, &quot;eliminated&quot;);
219           }
220         }
221         continue;
222       }
223       if (monitor-&gt;owner() != NULL) {
224         // the monitor is associated with an object, i.e., it is locked
225 
226         const char *lock_state = &quot;locked&quot;; // assume we have the monitor locked
227         if (!found_first_monitor &amp;&amp; frame_count == 0) {
228           // If this is the first frame and we haven&#39;t found an owned
229           // monitor before, then we need to see if we have completed
230           // the lock or if we are blocked trying to acquire it. Only
231           // an inflated monitor that is first on the monitor list in
232           // the first frame can block us on a monitor enter.
233           markWord mark = monitor-&gt;owner()-&gt;mark();


234           if (mark.has_monitor() &amp;&amp;
235               ( // we have marked ourself as pending on this monitor
236                 mark.monitor() == thread()-&gt;current_pending_monitor() ||
237                 // we are not the owner of this monitor
238                 !mark.monitor()-&gt;is_entered(thread())
239               )) {
240             lock_state = &quot;waiting to lock&quot;;
241           }
242         }
243         print_locked_object_class_name(st, Handle(THREAD, monitor-&gt;owner()), lock_state);
244 
245         found_first_monitor = true;
246       }
247     }
248   }
249 }
250 
251 // ------------- interpretedVFrame --------------
252 
253 u_char* interpretedVFrame::bcp() const {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
105 javaVFrame* vframe::java_sender() const {
106   vframe* f = sender();
107   while (f != NULL) {
108     if (f-&gt;is_java_frame()) return javaVFrame::cast(f);
109     f = f-&gt;sender();
110   }
111   return NULL;
112 }
113 
114 // ------------- javaVFrame --------------
115 
116 GrowableArray&lt;MonitorInfo*&gt;* javaVFrame::locked_monitors() {
117   assert(SafepointSynchronize::is_at_safepoint() || JavaThread::current() == thread(),
118          &quot;must be at safepoint or it&#39;s a java frame of the current thread&quot;);
119 
120   GrowableArray&lt;MonitorInfo*&gt;* mons = monitors();
121   GrowableArray&lt;MonitorInfo*&gt;* result = new GrowableArray&lt;MonitorInfo*&gt;(mons-&gt;length());
122   if (mons-&gt;is_empty()) return result;
123 
124   bool found_first_monitor = false;
<span class="line-modified">125   // The ObjectMonitor* can&#39;t be async deflated since we are either</span>
<span class="line-added">126   // at a safepoint or the calling thread is operating on itself so</span>
<span class="line-added">127   // it cannot exit the ObjectMonitor so it remains busy.</span>
128   ObjectMonitor *waiting_monitor = thread()-&gt;current_waiting_monitor();
<span class="line-added">129   ObjectMonitor *pending_monitor = NULL;</span>
<span class="line-added">130   if (waiting_monitor == NULL) {</span>
<span class="line-added">131     pending_monitor = thread()-&gt;current_pending_monitor();</span>
<span class="line-added">132   }</span>
133   oop pending_obj = (pending_monitor != NULL ? (oop) pending_monitor-&gt;object() : (oop) NULL);
134   oop waiting_obj = (waiting_monitor != NULL ? (oop) waiting_monitor-&gt;object() : (oop) NULL);
135 
136   for (int index = (mons-&gt;length()-1); index &gt;= 0; index--) {
137     MonitorInfo* monitor = mons-&gt;at(index);
138     if (monitor-&gt;eliminated() &amp;&amp; is_compiled_frame()) continue; // skip eliminated monitor
139     oop obj = monitor-&gt;owner();
140     if (obj == NULL) continue; // skip unowned monitor
141     //
142     // Skip the monitor that the thread is blocked to enter or waiting on
143     //
144     if (!found_first_monitor &amp;&amp; (obj == pending_obj || obj == waiting_obj)) {
145       continue;
146     }
147     found_first_monitor = true;
148     result-&gt;append(monitor);
149   }
150   return result;
151 }
152 
</pre>
<hr />
<pre>
220           st-&gt;print(&quot;\t- eliminated &lt;owner is scalar replaced&gt; (a %s)&quot;, k-&gt;external_name());
221         } else {
222           Handle obj(THREAD, monitor-&gt;owner());
223           if (obj() != NULL) {
224             print_locked_object_class_name(st, obj, &quot;eliminated&quot;);
225           }
226         }
227         continue;
228       }
229       if (monitor-&gt;owner() != NULL) {
230         // the monitor is associated with an object, i.e., it is locked
231 
232         const char *lock_state = &quot;locked&quot;; // assume we have the monitor locked
233         if (!found_first_monitor &amp;&amp; frame_count == 0) {
234           // If this is the first frame and we haven&#39;t found an owned
235           // monitor before, then we need to see if we have completed
236           // the lock or if we are blocked trying to acquire it. Only
237           // an inflated monitor that is first on the monitor list in
238           // the first frame can block us on a monitor enter.
239           markWord mark = monitor-&gt;owner()-&gt;mark();
<span class="line-added">240           // The first stage of async deflation does not affect any field</span>
<span class="line-added">241           // used by this comparison so the ObjectMonitor* is usable here.</span>
242           if (mark.has_monitor() &amp;&amp;
243               ( // we have marked ourself as pending on this monitor
244                 mark.monitor() == thread()-&gt;current_pending_monitor() ||
245                 // we are not the owner of this monitor
246                 !mark.monitor()-&gt;is_entered(thread())
247               )) {
248             lock_state = &quot;waiting to lock&quot;;
249           }
250         }
251         print_locked_object_class_name(st, Handle(THREAD, monitor-&gt;owner()), lock_state);
252 
253         found_first_monitor = true;
254       }
255     }
256   }
257 }
258 
259 // ------------- interpretedVFrame --------------
260 
261 u_char* interpretedVFrame::bcp() const {
</pre>
</td>
</tr>
</table>
<center><a href="thread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/synchronizer.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="synchronizer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/synchronizer.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 41,15 ***</span>
  #endif
  
  typedef PaddedEnd&lt;ObjectMonitor, OM_CACHE_LINE_SIZE&gt; PaddedObjectMonitor;
  
  struct DeflateMonitorCounters {
<span class="line-modified">!   int n_in_use;              // currently associated with objects</span>
<span class="line-modified">!   int n_in_circulation;      // extant</span>
<span class="line-modified">!   int n_scavenged;           // reclaimed (global and per-thread)</span>
<span class="line-modified">!   int per_thread_scavenged;  // per-thread scavenge total</span>
<span class="line-modified">!   double per_thread_times;   // per-thread scavenge times</span>
  };
  
  class ObjectSynchronizer : AllStatic {
    friend class VMStructs;
   public:
<span class="line-new-header">--- 41,15 ---</span>
  #endif
  
  typedef PaddedEnd&lt;ObjectMonitor, OM_CACHE_LINE_SIZE&gt; PaddedObjectMonitor;
  
  struct DeflateMonitorCounters {
<span class="line-modified">!   volatile int n_in_use;              // currently associated with objects</span>
<span class="line-modified">!   volatile int n_in_circulation;      // extant</span>
<span class="line-modified">!   volatile int n_scavenged;           // reclaimed (global and per-thread)</span>
<span class="line-modified">!   volatile int per_thread_scavenged;  // per-thread scavenge total</span>
<span class="line-modified">!            double per_thread_times;   // per-thread scavenge times</span>
  };
  
  class ObjectSynchronizer : AllStatic {
    friend class VMStructs;
   public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,33 ***</span>
  
    // GC: we current use aggressive monitor deflation policy
    // Basically we deflate all monitors that are not busy.
    // An adaptive profile-based deflation policy could be used if needed
    static void deflate_idle_monitors(DeflateMonitorCounters* counters);
    static void deflate_thread_local_monitors(Thread* thread, DeflateMonitorCounters* counters);
    static void prepare_deflate_idle_monitors(DeflateMonitorCounters* counters);
    static void finish_deflate_idle_monitors(DeflateMonitorCounters* counters);
  
    // For a given monitor list: global or per-thread, deflate idle monitors
    static int deflate_monitor_list(ObjectMonitor** list_p,
                                    int* count_p,
                                    ObjectMonitor** free_head_p,
                                    ObjectMonitor** free_tail_p);
    static bool deflate_monitor(ObjectMonitor* mid, oop obj,
                                ObjectMonitor** free_head_p,
                                ObjectMonitor** free_tail_p);
<span class="line-modified">!   static bool is_cleanup_needed();</span>
    static void oops_do(OopClosure* f);
    // Process oops in thread local used monitors
    static void thread_local_used_oops_do(Thread* thread, OopClosure* f);
  
    // debugging
    static void audit_and_print_stats(bool on_exit);
    static void chk_free_entry(JavaThread* jt, ObjectMonitor* n,
                               outputStream * out, int *error_cnt_p);
    static void chk_global_free_list_and_count(outputStream * out,
                                               int *error_cnt_p);
    static void chk_global_in_use_list_and_count(outputStream * out,
                                                 int *error_cnt_p);
    static void chk_in_use_entry(JavaThread* jt, ObjectMonitor* n,
                                 outputStream * out, int *error_cnt_p);
    static void chk_per_thread_in_use_list_and_count(JavaThread *jt,
<span class="line-new-header">--- 130,55 ---</span>
  
    // GC: we current use aggressive monitor deflation policy
    // Basically we deflate all monitors that are not busy.
    // An adaptive profile-based deflation policy could be used if needed
    static void deflate_idle_monitors(DeflateMonitorCounters* counters);
<span class="line-added">+   static void deflate_idle_monitors_using_JT();</span>
<span class="line-added">+   static void deflate_global_idle_monitors_using_JT();</span>
<span class="line-added">+   static void deflate_per_thread_idle_monitors_using_JT(JavaThread* target);</span>
<span class="line-added">+   static void deflate_common_idle_monitors_using_JT(bool is_global, JavaThread* target);</span>
    static void deflate_thread_local_monitors(Thread* thread, DeflateMonitorCounters* counters);
    static void prepare_deflate_idle_monitors(DeflateMonitorCounters* counters);
    static void finish_deflate_idle_monitors(DeflateMonitorCounters* counters);
  
    // For a given monitor list: global or per-thread, deflate idle monitors
    static int deflate_monitor_list(ObjectMonitor** list_p,
                                    int* count_p,
                                    ObjectMonitor** free_head_p,
                                    ObjectMonitor** free_tail_p);
<span class="line-added">+   // For a given in-use monitor list: global or per-thread, deflate idle</span>
<span class="line-added">+   // monitors using a JavaThread.</span>
<span class="line-added">+   static int deflate_monitor_list_using_JT(ObjectMonitor** list_p,</span>
<span class="line-added">+                                            int* count_p,</span>
<span class="line-added">+                                            ObjectMonitor** free_head_p,</span>
<span class="line-added">+                                            ObjectMonitor** free_tail_p,</span>
<span class="line-added">+                                            ObjectMonitor** saved_mid_in_use_p);</span>
    static bool deflate_monitor(ObjectMonitor* mid, oop obj,
                                ObjectMonitor** free_head_p,
                                ObjectMonitor** free_tail_p);
<span class="line-modified">!   static bool deflate_monitor_using_JT(ObjectMonitor* mid,</span>
<span class="line-added">+                                        ObjectMonitor** free_head_p,</span>
<span class="line-added">+                                        ObjectMonitor** free_tail_p);</span>
<span class="line-added">+   static bool is_async_deflation_needed();</span>
<span class="line-added">+   static bool is_safepoint_deflation_needed();</span>
<span class="line-added">+   static bool is_async_deflation_requested() { return _is_async_deflation_requested; }</span>
<span class="line-added">+   static bool is_special_deflation_requested() { return _is_special_deflation_requested; }</span>
<span class="line-added">+   static void set_is_async_deflation_requested(bool new_value) { _is_async_deflation_requested = new_value; }</span>
<span class="line-added">+   static void set_is_special_deflation_requested(bool new_value) { _is_special_deflation_requested = new_value; }</span>
<span class="line-added">+   static jlong time_since_last_async_deflation_ms();</span>
    static void oops_do(OopClosure* f);
    // Process oops in thread local used monitors
    static void thread_local_used_oops_do(Thread* thread, OopClosure* f);
  
    // debugging
    static void audit_and_print_stats(bool on_exit);
    static void chk_free_entry(JavaThread* jt, ObjectMonitor* n,
                               outputStream * out, int *error_cnt_p);
    static void chk_global_free_list_and_count(outputStream * out,
                                               int *error_cnt_p);
<span class="line-added">+   static void chk_global_wait_list_and_count(outputStream * out,</span>
<span class="line-added">+                                              int *error_cnt_p);</span>
    static void chk_global_in_use_list_and_count(outputStream * out,
                                                 int *error_cnt_p);
    static void chk_in_use_entry(JavaThread* jt, ObjectMonitor* n,
                                 outputStream * out, int *error_cnt_p);
    static void chk_per_thread_in_use_list_and_count(JavaThread *jt,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 167,16 ***</span>
<span class="line-new-header">--- 189,21 ---</span>
                                                   int *error_cnt_p);
    static void log_in_use_monitor_details(outputStream * out);
    static int  log_monitor_list_counts(outputStream * out);
    static int  verify_objmon_isinpool(ObjectMonitor *addr) PRODUCT_RETURN0;
  
<span class="line-added">+   static void do_safepoint_work(DeflateMonitorCounters* counters);</span>
<span class="line-added">+ </span>
   private:
    friend class SynchronizerTest;
  
    enum { _BLOCKSIZE = 128 };
    // global list of blocks of monitors
    static PaddedObjectMonitor* g_block_list;
<span class="line-added">+   static volatile bool _is_async_deflation_requested;</span>
<span class="line-added">+   static volatile bool _is_special_deflation_requested;</span>
<span class="line-added">+   static jlong         _last_async_deflation_time_ns;</span>
  
    // Function to prepend new blocks to the appropriate lists:
    static void prepend_block_to_lists(PaddedObjectMonitor* new_blk);
  
    // Process oops in all global used monitors (i.e. moribund thread&#39;s monitors)
</pre>
<center><a href="synchronizer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
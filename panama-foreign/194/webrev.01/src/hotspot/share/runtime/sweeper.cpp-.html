<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/sweeper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;code/compiledIC.hpp&quot;
 28 #include &quot;code/icBuffer.hpp&quot;
 29 #include &quot;code/nmethod.hpp&quot;
 30 #include &quot;compiler/compileBroker.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.hpp&quot;
 32 #include &quot;gc/shared/workgroup.hpp&quot;
 33 #include &quot;jfr/jfrEvents.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;logging/logStream.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;
 38 #include &quot;memory/universe.hpp&quot;
 39 #include &quot;oops/method.hpp&quot;
 40 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 41 #include &quot;runtime/handshake.hpp&quot;
 42 #include &quot;runtime/mutexLocker.hpp&quot;
 43 #include &quot;runtime/orderAccess.hpp&quot;
 44 #include &quot;runtime/os.hpp&quot;
 45 #include &quot;runtime/sweeper.hpp&quot;
 46 #include &quot;runtime/thread.inline.hpp&quot;
 47 #include &quot;runtime/vmOperations.hpp&quot;
 48 #include &quot;runtime/vmThread.hpp&quot;
 49 #include &quot;utilities/events.hpp&quot;
 50 #include &quot;utilities/xmlstream.hpp&quot;
 51 
 52 #ifdef ASSERT
 53 
 54 #define SWEEP(nm) record_sweep(nm, __LINE__)
 55 // Sweeper logging code
 56 class SweeperRecord {
 57  public:
 58   int traversal;
 59   int compile_id;
 60   long traversal_mark;
 61   int state;
 62   const char* kind;
 63   address vep;
 64   address uep;
 65   int line;
 66 
 67   void print() {
 68       tty-&gt;print_cr(&quot;traversal = %d compile_id = %d %s uep = &quot; PTR_FORMAT &quot; vep = &quot;
 69                     PTR_FORMAT &quot; state = %d traversal_mark %ld line = %d&quot;,
 70                     traversal,
 71                     compile_id,
 72                     kind == NULL ? &quot;&quot; : kind,
 73                     p2i(uep),
 74                     p2i(vep),
 75                     state,
 76                     traversal_mark,
 77                     line);
 78   }
 79 };
 80 
 81 static int _sweep_index = 0;
 82 static SweeperRecord* _records = NULL;
 83 
 84 void NMethodSweeper::report_events(int id, address entry) {
 85   if (_records != NULL) {
 86     for (int i = _sweep_index; i &lt; SweeperLogEntries; i++) {
 87       if (_records[i].uep == entry ||
 88           _records[i].vep == entry ||
 89           _records[i].compile_id == id) {
 90         _records[i].print();
 91       }
 92     }
 93     for (int i = 0; i &lt; _sweep_index; i++) {
 94       if (_records[i].uep == entry ||
 95           _records[i].vep == entry ||
 96           _records[i].compile_id == id) {
 97         _records[i].print();
 98       }
 99     }
100   }
101 }
102 
103 void NMethodSweeper::report_events() {
104   if (_records != NULL) {
105     for (int i = _sweep_index; i &lt; SweeperLogEntries; i++) {
106       // skip empty records
107       if (_records[i].vep == NULL) continue;
108       _records[i].print();
109     }
110     for (int i = 0; i &lt; _sweep_index; i++) {
111       // skip empty records
112       if (_records[i].vep == NULL) continue;
113       _records[i].print();
114     }
115   }
116 }
117 
118 void NMethodSweeper::record_sweep(CompiledMethod* nm, int line) {
119   if (_records != NULL) {
120     _records[_sweep_index].traversal = _traversals;
121     _records[_sweep_index].traversal_mark = nm-&gt;is_nmethod() ? ((nmethod*)nm)-&gt;stack_traversal_mark() : 0;
122     _records[_sweep_index].compile_id = nm-&gt;compile_id();
123     _records[_sweep_index].kind = nm-&gt;compile_kind();
124     _records[_sweep_index].state = nm-&gt;get_state();
125     _records[_sweep_index].vep = nm-&gt;verified_entry_point();
126     _records[_sweep_index].uep = nm-&gt;entry_point();
127     _records[_sweep_index].line = line;
128     _sweep_index = (_sweep_index + 1) % SweeperLogEntries;
129   }
130 }
131 
132 void NMethodSweeper::init_sweeper_log() {
133  if (LogSweeper &amp;&amp; _records == NULL) {
134    // Create the ring buffer for the logging code
135    _records = NEW_C_HEAP_ARRAY(SweeperRecord, SweeperLogEntries, mtGC);
136    memset(_records, 0, sizeof(SweeperRecord) * SweeperLogEntries);
137   }
138 }
139 #else
140 #define SWEEP(nm)
141 #endif
142 
143 CompiledMethodIterator NMethodSweeper::_current(CompiledMethodIterator::all_blobs); // Current compiled method
144 long     NMethodSweeper::_traversals                   = 0;    // Stack scan count, also sweep ID.
145 long     NMethodSweeper::_total_nof_code_cache_sweeps  = 0;    // Total number of full sweeps of the code cache
146 long     NMethodSweeper::_time_counter                 = 0;    // Virtual time used to periodically invoke sweeper
147 long     NMethodSweeper::_last_sweep                   = 0;    // Value of _time_counter when the last sweep happened
148 int      NMethodSweeper::_seen                         = 0;    // Nof. nmethod we have currently processed in current pass of CodeCache
149 
150 volatile bool NMethodSweeper::_should_sweep            = false;// Indicates if we should invoke the sweeper
151 volatile bool NMethodSweeper::_force_sweep             = false;// Indicates if we should force a sweep
152 volatile int  NMethodSweeper::_bytes_changed           = 0;    // Counts the total nmethod size if the nmethod changed from:
153                                                                //   1) alive       -&gt; not_entrant
154                                                                //   2) not_entrant -&gt; zombie
155 int    NMethodSweeper::_hotness_counter_reset_val       = 0;
156 
157 long   NMethodSweeper::_total_nof_methods_reclaimed     = 0;   // Accumulated nof methods flushed
158 long   NMethodSweeper::_total_nof_c2_methods_reclaimed  = 0;   // Accumulated nof methods flushed
159 size_t NMethodSweeper::_total_flushed_size              = 0;   // Total number of bytes flushed from the code cache
160 Tickspan NMethodSweeper::_total_time_sweeping;                 // Accumulated time sweeping
161 Tickspan NMethodSweeper::_total_time_this_sweep;               // Total time this sweep
162 Tickspan NMethodSweeper::_peak_sweep_time;                     // Peak time for a full sweep
163 Tickspan NMethodSweeper::_peak_sweep_fraction_time;            // Peak time sweeping one fraction
164 
165 class MarkActivationClosure: public CodeBlobClosure {
166 public:
167   virtual void do_code_blob(CodeBlob* cb) {
168     assert(cb-&gt;is_nmethod(), &quot;CodeBlob should be nmethod&quot;);
169     nmethod* nm = (nmethod*)cb;
170     nm-&gt;set_hotness_counter(NMethodSweeper::hotness_counter_reset_val());
171     // If we see an activation belonging to a non_entrant nmethod, we mark it.
172     if (nm-&gt;is_not_entrant()) {
173       nm-&gt;mark_as_seen_on_stack();
174     }
175   }
176 };
177 static MarkActivationClosure mark_activation_closure;
178 
179 class SetHotnessClosure: public CodeBlobClosure {
180 public:
181   virtual void do_code_blob(CodeBlob* cb) {
182     assert(cb-&gt;is_nmethod(), &quot;CodeBlob should be nmethod&quot;);
183     nmethod* nm = (nmethod*)cb;
184     nm-&gt;set_hotness_counter(NMethodSweeper::hotness_counter_reset_val());
185   }
186 };
187 static SetHotnessClosure set_hotness_closure;
188 
189 
190 int NMethodSweeper::hotness_counter_reset_val() {
191   if (_hotness_counter_reset_val == 0) {
192     _hotness_counter_reset_val = (ReservedCodeCacheSize &lt; M) ? 1 : (ReservedCodeCacheSize / M) * 2;
193   }
194   return _hotness_counter_reset_val;
195 }
196 bool NMethodSweeper::wait_for_stack_scanning() {
197   return _current.end();
198 }
199 
200 class NMethodMarkingClosure : public HandshakeClosure {
201 private:
202   CodeBlobClosure* _cl;
203 public:
204   NMethodMarkingClosure(CodeBlobClosure* cl) : HandshakeClosure(&quot;NMethodMarking&quot;), _cl(cl) {}
205   void do_thread(Thread* thread) {
206     if (thread-&gt;is_Java_thread() &amp;&amp; ! thread-&gt;is_Code_cache_sweeper_thread()) {
207       JavaThread* jt = (JavaThread*) thread;
208       jt-&gt;nmethods_do(_cl);
209     }
210   }
211 };
212 
213 class NMethodMarkingTask : public AbstractGangTask {
214 private:
215   NMethodMarkingClosure* _cl;
216 public:
217   NMethodMarkingTask(NMethodMarkingClosure* cl) :
218     AbstractGangTask(&quot;Parallel NMethod Marking&quot;),
219     _cl(cl) {
220     Threads::change_thread_claim_token();
221   }
222 
223   ~NMethodMarkingTask() {
224     Threads::assert_all_threads_claimed();
225   }
226 
227   void work(uint worker_id) {
228     Threads::possibly_parallel_threads_do(true, _cl);
229   }
230 };
231 
232 /**
233   * Scans the stacks of all Java threads and marks activations of not-entrant methods.
234   * No need to synchronize access, since &#39;mark_active_nmethods&#39; is always executed at a
235   * safepoint.
236   */
237 void NMethodSweeper::mark_active_nmethods() {
238   CodeBlobClosure* cl = prepare_mark_active_nmethods();
239   if (cl != NULL) {
240     WorkGang* workers = Universe::heap()-&gt;get_safepoint_workers();
241     if (workers != NULL) {
242       NMethodMarkingClosure tcl(cl);
243       NMethodMarkingTask task(&amp;tcl);
244       workers-&gt;run_task(&amp;task);
245     } else {
246       Threads::nmethods_do(cl);
247     }
248   }
249 }
250 
251 CodeBlobClosure* NMethodSweeper::prepare_mark_active_nmethods() {
252 #ifdef ASSERT
253   assert(Thread::current()-&gt;is_Code_cache_sweeper_thread(), &quot;must be executed under CodeCache_lock and in sweeper thread&quot;);
254   assert_lock_strong(CodeCache_lock);
255 #endif
256 
257   // If we do not want to reclaim not-entrant or zombie methods there is no need
258   // to scan stacks
259   if (!MethodFlushing) {
260     return NULL;
261   }
262 
263   // Increase time so that we can estimate when to invoke the sweeper again.
264   _time_counter++;
265 
266   // Check for restart
267   assert(_current.method() == NULL, &quot;should only happen between sweeper cycles&quot;);
268   assert(wait_for_stack_scanning(), &quot;should only happen between sweeper cycles&quot;);
269 
270   _seen = 0;
271   _current = CompiledMethodIterator(CompiledMethodIterator::all_blobs);
272   // Initialize to first nmethod
273   _current.next();
274   _traversals += 1;
275   _total_time_this_sweep = Tickspan();
276 
277   if (PrintMethodFlushing) {
278     tty-&gt;print_cr(&quot;### Sweep: stack traversal %ld&quot;, _traversals);
279   }
280   return &amp;mark_activation_closure;
281 }
282 
283 CodeBlobClosure* NMethodSweeper::prepare_reset_hotness_counters() {
284   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be executed at a safepoint&quot;);
285 
286   // If we do not want to reclaim not-entrant or zombie methods there is no need
287   // to scan stacks
288   if (!MethodFlushing) {
289     return NULL;
290   }
291 
292   // Increase time so that we can estimate when to invoke the sweeper again.
293   _time_counter++;
294 
295   // Check for restart
296   if (_current.method() != NULL) {
297     if (_current.method()-&gt;is_nmethod()) {
298       assert(CodeCache::find_blob_unsafe(_current.method()) == _current.method(), &quot;Sweeper nmethod cached state invalid&quot;);
299     } else if (_current.method()-&gt;is_aot()) {
300       assert(CodeCache::find_blob_unsafe(_current.method()-&gt;code_begin()) == _current.method(), &quot;Sweeper AOT method cached state invalid&quot;);
301     } else {
302       ShouldNotReachHere();
303     }
304   }
305 
306   return &amp;set_hotness_closure;
307 }
308 
309 /**
310   * This function triggers a VM operation that does stack scanning of active
311   * methods. Stack scanning is mandatory for the sweeper to make progress.
312   */
313 void NMethodSweeper::do_stack_scanning() {
314   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;just checking&quot;);
315   if (wait_for_stack_scanning()) {
316     CodeBlobClosure* code_cl;
317     {
318       MutexLocker ccl(CodeCache_lock, Mutex::_no_safepoint_check_flag);
319       code_cl = prepare_mark_active_nmethods();
320     }
321     if (code_cl != NULL) {
322       NMethodMarkingClosure nm_cl(code_cl);
323       Handshake::execute(&amp;nm_cl);
324     }
325   }
326 }
327 
328 void NMethodSweeper::sweeper_loop() {
329   bool timeout;
330   while (true) {
331     {
332       ThreadBlockInVM tbivm(JavaThread::current());
333       MonitorLocker waiter(CodeCache_lock, Mutex::_no_safepoint_check_flag);
334       const long wait_time = 60*60*24 * 1000;
335       timeout = waiter.wait(wait_time);
336     }
337     if (!timeout) {
338       possibly_sweep();
339     }
340   }
341 }
342 
343 /**
344   * Wakes up the sweeper thread to possibly sweep.
345   */
346 void NMethodSweeper::notify(int code_blob_type) {
347   // Makes sure that we do not invoke the sweeper too often during startup.
348   double start_threshold = 100.0 / (double)StartAggressiveSweepingAt;
349   double aggressive_sweep_threshold = MIN2(start_threshold, 1.1);
350   if (CodeCache::reverse_free_ratio(code_blob_type) &gt;= aggressive_sweep_threshold) {
351     assert_locked_or_safepoint(CodeCache_lock);
352     CodeCache_lock-&gt;notify();
353   }
354 }
355 
356 /**
357   * Wakes up the sweeper thread and forces a sweep. Blocks until it finished.
358   */
359 void NMethodSweeper::force_sweep() {
360   ThreadBlockInVM tbivm(JavaThread::current());
361   MonitorLocker waiter(CodeCache_lock, Mutex::_no_safepoint_check_flag);
362   // Request forced sweep
363   _force_sweep = true;
364   while (_force_sweep) {
365     // Notify sweeper that we want to force a sweep and wait for completion.
366     // In case a sweep currently takes place we timeout and try again because
367     // we want to enforce a full sweep.
368     CodeCache_lock-&gt;notify();
369     waiter.wait(1000);
370   }
371 }
372 
373 /**
374  * Handle a safepoint request
375  */
376 void NMethodSweeper::handle_safepoint_request() {
377   JavaThread* thread = JavaThread::current();
378   if (SafepointMechanism::should_block(thread)) {
379     if (PrintMethodFlushing &amp;&amp; Verbose) {
380       tty-&gt;print_cr(&quot;### Sweep at %d out of %d, yielding to safepoint&quot;, _seen, CodeCache::nmethod_count());
381     }
382     MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
383 
384     ThreadBlockInVM tbivm(thread);
385     thread-&gt;java_suspend_self();
386   }
387 }
388 
389 /**
390  * This function invokes the sweeper if at least one of the three conditions is met:
391  *    (1) The code cache is getting full
392  *    (2) There are sufficient state changes in/since the last sweep.
393  *    (3) We have not been sweeping for &#39;some time&#39;
394  */
395 void NMethodSweeper::possibly_sweep() {
396   assert(JavaThread::current()-&gt;thread_state() == _thread_in_vm, &quot;must run in vm mode&quot;);
397   // If there was no state change while nmethod sweeping, &#39;should_sweep&#39; will be false.
398   // This is one of the two places where should_sweep can be set to true. The general
399   // idea is as follows: If there is enough free space in the code cache, there is no
400   // need to invoke the sweeper. The following formula (which determines whether to invoke
401   // the sweeper or not) depends on the assumption that for larger ReservedCodeCacheSizes
402   // we need less frequent sweeps than for smaller ReservedCodecCacheSizes. Furthermore,
403   // the formula considers how much space in the code cache is currently used. Here are
404   // some examples that will (hopefully) help in understanding.
405   //
406   // Small ReservedCodeCacheSizes:  (e.g., &lt; 16M) We invoke the sweeper every time, since
407   //                                              the result of the division is 0. This
408   //                                              keeps the used code cache size small
409   //                                              (important for embedded Java)
410   // Large ReservedCodeCacheSize :  (e.g., 256M + code cache is 10% full). The formula
411   //                                              computes: (256 / 16) - 1 = 15
412   //                                              As a result, we invoke the sweeper after
413   //                                              15 invocations of &#39;mark_active_nmethods.
414   // Large ReservedCodeCacheSize:   (e.g., 256M + code Cache is 90% full). The formula
415   //                                              computes: (256 / 16) - 10 = 6.
416   if (!_should_sweep) {
417     const int time_since_last_sweep = _time_counter - _last_sweep;
418     // ReservedCodeCacheSize has an &#39;unsigned&#39; type. We need a &#39;signed&#39; type for max_wait_time,
419     // since &#39;time_since_last_sweep&#39; can be larger than &#39;max_wait_time&#39;. If that happens using
420     // an unsigned type would cause an underflow (wait_until_next_sweep becomes a large positive
421     // value) that disables the intended periodic sweeps.
422     const int max_wait_time = ReservedCodeCacheSize / (16 * M);
423     double wait_until_next_sweep = max_wait_time - time_since_last_sweep -
424         MAX2(CodeCache::reverse_free_ratio(CodeBlobType::MethodProfiled),
425              CodeCache::reverse_free_ratio(CodeBlobType::MethodNonProfiled));
426     assert(wait_until_next_sweep &lt;= (double)max_wait_time, &quot;Calculation of code cache sweeper interval is incorrect&quot;);
427 
428     if ((wait_until_next_sweep &lt;= 0.0) || !CompileBroker::should_compile_new_jobs()) {
429       _should_sweep = true;
430     }
431   }
432 
433   // Remember if this was a forced sweep
434   bool forced = _force_sweep;
435 
436   // Force stack scanning if there is only 10% free space in the code cache.
437   // We force stack scanning only if the non-profiled code heap gets full, since critical
438   // allocations go to the non-profiled heap and we must be make sure that there is
439   // enough space.
440   double free_percent = 1 / CodeCache::reverse_free_ratio(CodeBlobType::MethodNonProfiled) * 100;
441   if (free_percent &lt;= StartAggressiveSweepingAt || forced || _should_sweep) {
442     do_stack_scanning();
443   }
444 
445   if (_should_sweep || forced) {
446     init_sweeper_log();
447     sweep_code_cache();
448   }
449 
450   // We are done with sweeping the code cache once.
451   _total_nof_code_cache_sweeps++;
452   _last_sweep = _time_counter;
453   // Reset flag; temporarily disables sweeper
454   _should_sweep = false;
455   // If there was enough state change, &#39;possibly_enable_sweeper()&#39;
456   // sets &#39;_should_sweep&#39; to true
457   possibly_enable_sweeper();
458   // Reset _bytes_changed only if there was enough state change. _bytes_changed
459   // can further increase by calls to &#39;report_state_change&#39;.
460   if (_should_sweep) {
461     _bytes_changed = 0;
462   }
463 
464   if (forced) {
465     // Notify requester that forced sweep finished
466     assert(_force_sweep, &quot;Should be a forced sweep&quot;);
467     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
468     _force_sweep = false;
469     CodeCache_lock-&gt;notify();
470   }
471 }
472 
473 static void post_sweep_event(EventSweepCodeCache* event,
474                              const Ticks&amp; start,
475                              const Ticks&amp; end,
476                              s4 traversals,
477                              int swept,
478                              int flushed,
479                              int zombified) {
480   assert(event != NULL, &quot;invariant&quot;);
481   assert(event-&gt;should_commit(), &quot;invariant&quot;);
482   event-&gt;set_starttime(start);
483   event-&gt;set_endtime(end);
484   event-&gt;set_sweepId(traversals);
485   event-&gt;set_sweptCount(swept);
486   event-&gt;set_flushedCount(flushed);
487   event-&gt;set_zombifiedCount(zombified);
488   event-&gt;commit();
489 }
490 
491 void NMethodSweeper::sweep_code_cache() {
492   ResourceMark rm;
493   Ticks sweep_start_counter = Ticks::now();
494 
495   log_debug(codecache, sweep, start)(&quot;CodeCache flushing&quot;);
496 
497   int flushed_count                = 0;
498   int zombified_count              = 0;
499   int flushed_c2_count     = 0;
500 
501   if (PrintMethodFlushing &amp;&amp; Verbose) {
502     tty-&gt;print_cr(&quot;### Sweep at %d out of %d&quot;, _seen, CodeCache::nmethod_count());
503   }
504 
505   int swept_count = 0;
506   assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be in safepoint when we get here&quot;);
507   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;just checking&quot;);
508 
509   int freed_memory = 0;
510   {
511     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
512 
513     while (!_current.end()) {
514       swept_count++;
515       // Since we will give up the CodeCache_lock, always skip ahead
516       // to the next nmethod.  Other blobs can be deleted by other
517       // threads but nmethods are only reclaimed by the sweeper.
518       CompiledMethod* nm = _current.method();
519       _current.next();
520 
521       // Now ready to process nmethod and give up CodeCache_lock
522       {
523         MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
524         // Save information before potentially flushing the nmethod
525         // Only flushing nmethods so size only matters for them.
526         int size = nm-&gt;is_nmethod() ? ((nmethod*)nm)-&gt;total_size() : 0;
527         bool is_c2_method = nm-&gt;is_compiled_by_c2();
528         bool is_osr = nm-&gt;is_osr_method();
529         int compile_id = nm-&gt;compile_id();
530         intptr_t address = p2i(nm);
531         const char* state_before = nm-&gt;state();
532         const char* state_after = &quot;&quot;;
533 
534         MethodStateChange type = process_compiled_method(nm);
535         switch (type) {
536           case Flushed:
537             state_after = &quot;flushed&quot;;
538             freed_memory += size;
539             ++flushed_count;
540             if (is_c2_method) {
541               ++flushed_c2_count;
542             }
543             break;
544           case MadeZombie:
545             state_after = &quot;made zombie&quot;;
546             ++zombified_count;
547             break;
548           case None:
549             break;
550           default:
551            ShouldNotReachHere();
552         }
553         if (PrintMethodFlushing &amp;&amp; Verbose &amp;&amp; type != None) {
554           tty-&gt;print_cr(&quot;### %s nmethod %3d/&quot; PTR_FORMAT &quot; (%s) %s&quot;, is_osr ? &quot;osr&quot; : &quot;&quot;, compile_id, address, state_before, state_after);
555         }
556       }
557 
558       _seen++;
559       handle_safepoint_request();
560     }
561   }
562 
563   assert(_current.end(), &quot;must have scanned the whole cache&quot;);
564 
565   const Ticks sweep_end_counter = Ticks::now();
566   const Tickspan sweep_time = sweep_end_counter - sweep_start_counter;
567   {
568     MutexLocker mu(NMethodSweeperStats_lock, Mutex::_no_safepoint_check_flag);
569     _total_time_sweeping  += sweep_time;
570     _total_time_this_sweep += sweep_time;
571     _peak_sweep_fraction_time = MAX2(sweep_time, _peak_sweep_fraction_time);
572     _total_flushed_size += freed_memory;
573     _total_nof_methods_reclaimed += flushed_count;
574     _total_nof_c2_methods_reclaimed += flushed_c2_count;
575     _peak_sweep_time = MAX2(_peak_sweep_time, _total_time_this_sweep);
576   }
577 
578   EventSweepCodeCache event(UNTIMED);
579   if (event.should_commit()) {
580     post_sweep_event(&amp;event, sweep_start_counter, sweep_end_counter, (s4)_traversals, swept_count, flushed_count, zombified_count);
581   }
582 
583 #ifdef ASSERT
584   if(PrintMethodFlushing) {
585     tty-&gt;print_cr(&quot;### sweeper:      sweep time(&quot; JLONG_FORMAT &quot;): &quot;, sweep_time.value());
586   }
587 #endif
588 
589   Log(codecache, sweep) log;
590   if (log.is_debug()) {
591     LogStream ls(log.debug());
592     CodeCache::print_summary(&amp;ls, false);
593   }
594   log_sweep(&quot;finished&quot;);
595 
596   // Sweeper is the only case where memory is released, check here if it
597   // is time to restart the compiler. Only checking if there is a certain
598   // amount of free memory in the code cache might lead to re-enabling
599   // compilation although no memory has been released. For example, there are
600   // cases when compilation was disabled although there is 4MB (or more) free
601   // memory in the code cache. The reason is code cache fragmentation. Therefore,
602   // it only makes sense to re-enable compilation if we have actually freed memory.
603   // Note that typically several kB are released for sweeping 16MB of the code
604   // cache. As a result, &#39;freed_memory&#39; &gt; 0 to restart the compiler.
605   if (!CompileBroker::should_compile_new_jobs() &amp;&amp; (freed_memory &gt; 0)) {
606     CompileBroker::set_should_compile_new_jobs(CompileBroker::run_compilation);
607     log.debug(&quot;restart compiler&quot;);
608     log_sweep(&quot;restart_compiler&quot;);
609   }
610 }
611 
612 /**
613  * This function updates the sweeper statistics that keep track of nmethods
614  * state changes. If there is &#39;enough&#39; state change, the sweeper is invoked
615  * as soon as possible. There can be data races on _bytes_changed. The data
616  * races are benign, since it does not matter if we loose a couple of bytes.
617  * In the worst case we call the sweeper a little later. Also, we are guaranteed
618  * to invoke the sweeper if the code cache gets full.
619  */
620 void NMethodSweeper::report_state_change(nmethod* nm) {
621   _bytes_changed += nm-&gt;total_size();
622   possibly_enable_sweeper();
623 }
624 
625 /**
626  * Function determines if there was &#39;enough&#39; state change in the code cache to invoke
627  * the sweeper again. Currently, we determine &#39;enough&#39; as more than 1% state change in
628  * the code cache since the last sweep.
629  */
630 void NMethodSweeper::possibly_enable_sweeper() {
631   double percent_changed = ((double)_bytes_changed / (double)ReservedCodeCacheSize) * 100;
632   if (percent_changed &gt; 1.0) {
633     _should_sweep = true;
634   }
635 }
636 
637 class CompiledMethodMarker: public StackObj {
638  private:
639   CodeCacheSweeperThread* _thread;
640  public:
641   CompiledMethodMarker(CompiledMethod* cm) {
642     JavaThread* current = JavaThread::current();
643     assert (current-&gt;is_Code_cache_sweeper_thread(), &quot;Must be&quot;);
644     _thread = (CodeCacheSweeperThread*)current;
645     if (!cm-&gt;is_zombie() &amp;&amp; !cm-&gt;is_unloading()) {
646       // Only expose live nmethods for scanning
647       _thread-&gt;set_scanned_compiled_method(cm);
648     }
649   }
650   ~CompiledMethodMarker() {
651     _thread-&gt;set_scanned_compiled_method(NULL);
652   }
653 };
654 
655 NMethodSweeper::MethodStateChange NMethodSweeper::process_compiled_method(CompiledMethod* cm) {
656   assert(cm != NULL, &quot;sanity&quot;);
657   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;just checking&quot;);
658 
659   MethodStateChange result = None;
660   // Make sure this nmethod doesn&#39;t get unloaded during the scan,
661   // since safepoints may happen during acquired below locks.
662   CompiledMethodMarker nmm(cm);
663   SWEEP(cm);
664 
665   // Skip methods that are currently referenced by the VM
666   if (cm-&gt;is_locked_by_vm()) {
667     // But still remember to clean-up inline caches for alive nmethods
668     if (cm-&gt;is_alive()) {
669       // Clean inline caches that point to zombie/non-entrant/unloaded nmethods
670       cm-&gt;cleanup_inline_caches(false);
671       SWEEP(cm);
672     }
673     return result;
674   }
675 
676   if (cm-&gt;is_zombie()) {
677     // All inline caches that referred to this nmethod were cleaned in the
678     // previous sweeper cycle. Now flush the nmethod from the code cache.
679     assert(!cm-&gt;is_locked_by_vm(), &quot;must not flush locked Compiled Methods&quot;);
680     cm-&gt;flush();
681     assert(result == None, &quot;sanity&quot;);
682     result = Flushed;
683   } else if (cm-&gt;is_not_entrant()) {
684     // If there are no current activations of this method on the
685     // stack we can safely convert it to a zombie method
686     OrderAccess::loadload(); // _stack_traversal_mark and _state
687     if (cm-&gt;can_convert_to_zombie()) {
688       // Code cache state change is tracked in make_zombie()
689       cm-&gt;make_zombie();
690       SWEEP(cm);
691       assert(result == None, &quot;sanity&quot;);
692       result = MadeZombie;
693       assert(cm-&gt;is_zombie(), &quot;nmethod must be zombie&quot;);
694     } else {
695       // Still alive, clean up its inline caches
696       cm-&gt;cleanup_inline_caches(false);
697       SWEEP(cm);
698     }
699   } else if (cm-&gt;is_unloaded()) {
700     // Code is unloaded, so there are no activations on the stack.
701     // Convert the nmethod to zombie.
702     // Code cache state change is tracked in make_zombie()
703     cm-&gt;make_zombie();
704     SWEEP(cm);
705     assert(result == None, &quot;sanity&quot;);
706     result = MadeZombie;
707   } else {
708     if (cm-&gt;is_nmethod()) {
709       possibly_flush((nmethod*)cm);
710     }
711     // Clean inline caches that point to zombie/non-entrant/unloaded nmethods
712     cm-&gt;cleanup_inline_caches(false);
713     SWEEP(cm);
714   }
715   return result;
716 }
717 
718 
719 void NMethodSweeper::possibly_flush(nmethod* nm) {
720   if (UseCodeCacheFlushing) {
721     if (!nm-&gt;is_locked_by_vm() &amp;&amp; !nm-&gt;is_native_method() &amp;&amp; !nm-&gt;is_not_installed() &amp;&amp; !nm-&gt;is_unloading()) {
722       bool make_not_entrant = false;
723 
724       // Do not make native methods not-entrant
725       nm-&gt;dec_hotness_counter();
726       // Get the initial value of the hotness counter. This value depends on the
727       // ReservedCodeCacheSize
728       int reset_val = hotness_counter_reset_val();
729       int time_since_reset = reset_val - nm-&gt;hotness_counter();
730       int code_blob_type = CodeCache::get_code_blob_type(nm);
731       double threshold = -reset_val + (CodeCache::reverse_free_ratio(code_blob_type) * NmethodSweepActivity);
732       // The less free space in the code cache we have - the bigger reverse_free_ratio() is.
733       // I.e., &#39;threshold&#39; increases with lower available space in the code cache and a higher
734       // NmethodSweepActivity. If the current hotness counter - which decreases from its initial
735       // value until it is reset by stack walking - is smaller than the computed threshold, the
736       // corresponding nmethod is considered for removal.
737       if ((NmethodSweepActivity &gt; 0) &amp;&amp; (nm-&gt;hotness_counter() &lt; threshold) &amp;&amp; (time_since_reset &gt; MinPassesBeforeFlush)) {
738         // A method is marked as not-entrant if the method is
739         // 1) &#39;old enough&#39;: nm-&gt;hotness_counter() &lt; threshold
740         // 2) The method was in_use for a minimum amount of time: (time_since_reset &gt; MinPassesBeforeFlush)
741         //    The second condition is necessary if we are dealing with very small code cache
742         //    sizes (e.g., &lt;10m) and the code cache size is too small to hold all hot methods.
743         //    The second condition ensures that methods are not immediately made not-entrant
744         //    after compilation.
745         make_not_entrant = true;
746       }
747 
748       // The stack-scanning low-cost detection may not see the method was used (which can happen for
749       // flat profiles). Check the age counter for possible data.
750       if (UseCodeAging &amp;&amp; make_not_entrant &amp;&amp; (nm-&gt;is_compiled_by_c2() || nm-&gt;is_compiled_by_c1())) {
751         MethodCounters* mc = nm-&gt;method()-&gt;get_method_counters(Thread::current());
752         if (mc != NULL) {
753           // Snapshot the value as it&#39;s changed concurrently
754           int age = mc-&gt;nmethod_age();
755           if (MethodCounters::is_nmethod_hot(age)) {
756             // The method has gone through flushing, and it became relatively hot that it deopted
757             // before we could take a look at it. Give it more time to appear in the stack traces,
758             // proportional to the number of deopts.
759             MethodData* md = nm-&gt;method()-&gt;method_data();
760             if (md != NULL &amp;&amp; time_since_reset &gt; (int)(MinPassesBeforeFlush * (md-&gt;tenure_traps() + 1))) {
761               // It&#39;s been long enough, we still haven&#39;t seen it on stack.
762               // Try to flush it, but enable counters the next time.
763               mc-&gt;reset_nmethod_age();
764             } else {
765               make_not_entrant = false;
766             }
767           } else if (MethodCounters::is_nmethod_warm(age)) {
768             // Method has counters enabled, and the method was used within
769             // previous MinPassesBeforeFlush sweeps. Reset the counter. Stay in the existing
770             // compiled state.
771             mc-&gt;reset_nmethod_age();
772             // delay the next check
773             nm-&gt;set_hotness_counter(NMethodSweeper::hotness_counter_reset_val());
774             make_not_entrant = false;
775           } else if (MethodCounters::is_nmethod_age_unset(age)) {
776             // No counters were used before. Set the counters to the detection
777             // limit value. If the method is going to be used again it will be compiled
778             // with counters that we&#39;re going to use for analysis the the next time.
779             mc-&gt;reset_nmethod_age();
780           } else {
781             // Method was totally idle for 10 sweeps
782             // The counter already has the initial value, flush it and may be recompile
783             // later with counters
784           }
785         }
786       }
787 
788       if (make_not_entrant) {
789         nm-&gt;make_not_entrant();
790 
791         // Code cache state change is tracked in make_not_entrant()
792         if (PrintMethodFlushing &amp;&amp; Verbose) {
793           tty-&gt;print_cr(&quot;### Nmethod %d/&quot; PTR_FORMAT &quot;made not-entrant: hotness counter %d/%d threshold %f&quot;,
794               nm-&gt;compile_id(), p2i(nm), nm-&gt;hotness_counter(), reset_val, threshold);
795         }
796       }
797     }
798   }
799 }
800 
801 // Print out some state information about the current sweep and the
802 // state of the code cache if it&#39;s requested.
803 void NMethodSweeper::log_sweep(const char* msg, const char* format, ...) {
804   if (PrintMethodFlushing) {
805     ResourceMark rm;
806     stringStream s;
807     // Dump code cache state into a buffer before locking the tty,
808     // because log_state() will use locks causing lock conflicts.
809     CodeCache::log_state(&amp;s);
810 
811     ttyLocker ttyl;
812     tty-&gt;print(&quot;### sweeper: %s &quot;, msg);
813     if (format != NULL) {
814       va_list ap;
815       va_start(ap, format);
816       tty-&gt;vprint(format, ap);
817       va_end(ap);
818     }
819     tty-&gt;print_cr(&quot;%s&quot;, s.as_string());
820   }
821 
822   if (LogCompilation &amp;&amp; (xtty != NULL)) {
823     ResourceMark rm;
824     stringStream s;
825     // Dump code cache state into a buffer before locking the tty,
826     // because log_state() will use locks causing lock conflicts.
827     CodeCache::log_state(&amp;s);
828 
829     ttyLocker ttyl;
830     xtty-&gt;begin_elem(&quot;sweeper state=&#39;%s&#39; traversals=&#39;&quot; INTX_FORMAT &quot;&#39; &quot;, msg, (intx)traversal_count());
831     if (format != NULL) {
832       va_list ap;
833       va_start(ap, format);
834       xtty-&gt;vprint(format, ap);
835       va_end(ap);
836     }
837     xtty-&gt;print(&quot;%s&quot;, s.as_string());
838     xtty-&gt;stamp();
839     xtty-&gt;end_elem();
840   }
841 }
842 
843 void NMethodSweeper::print(outputStream* out) {
844   ttyLocker ttyl;
845   out = (out == NULL) ? tty : out;
846   out-&gt;print_cr(&quot;Code cache sweeper statistics:&quot;);
847   out-&gt;print_cr(&quot;  Total sweep time:                %1.0lf ms&quot;, (double)_total_time_sweeping.value()/1000000);
848   out-&gt;print_cr(&quot;  Total number of full sweeps:     %ld&quot;, _total_nof_code_cache_sweeps);
849   out-&gt;print_cr(&quot;  Total number of flushed methods: %ld (thereof %ld C2 methods)&quot;, _total_nof_methods_reclaimed,
850                                                     _total_nof_c2_methods_reclaimed);
851   out-&gt;print_cr(&quot;  Total size of flushed methods:   &quot; SIZE_FORMAT &quot; kB&quot;, _total_flushed_size/K);
852 }
    </pre>
  </body>
</html>
diff a/src/hotspot/share/runtime/serviceThread.cpp b/src/hotspot/share/runtime/serviceThread.cpp
--- a/src/hotspot/share/runtime/serviceThread.cpp
+++ b/src/hotspot/share/runtime/serviceThread.cpp
@@ -108,10 +108,11 @@
     bool symboltable_work = false;
     bool resolved_method_table_work = false;
     bool thread_id_table_work = false;
     bool protection_domain_table_work = false;
     bool oopstorage_work = false;
+    bool deflate_idle_monitors = false;
     JvmtiDeferredEvent jvmti_event;
     {
       // Need state transition ThreadBlockInVM so that this thread
       // will be handled by safepoint correctly when this thread is
       // notified at a safepoint.
@@ -134,14 +135,18 @@
               (stringtable_work = StringTable::has_work()) |
               (symboltable_work = SymbolTable::has_work()) |
               (resolved_method_table_work = ResolvedMethodTable::has_work()) |
               (thread_id_table_work = ThreadIdTable::has_work()) |
               (protection_domain_table_work = SystemDictionary::pd_cache_table()->has_work()) |
-              (oopstorage_work = OopStorage::has_cleanup_work_and_reset())
+              (oopstorage_work = OopStorage::has_cleanup_work_and_reset()) |
+              (deflate_idle_monitors = ObjectSynchronizer::is_async_deflation_needed())
              ) == 0) {
         // Wait until notified that there is some work to do.
-        ml.wait();
+        // If AsyncDeflateIdleMonitors, then we wait for
+        // GuaranteedSafepointInterval so that is_async_deflation_needed()
+        // is checked at the same interval.
+        ml.wait(AsyncDeflateIdleMonitors ? GuaranteedSafepointInterval : 0);
       }
 
       if (has_jvmti_events) {
         // Get the event under the Service_lock
         jvmti_event = _jvmti_service_queue.dequeue();
@@ -189,10 +194,14 @@
     }
 
     if (oopstorage_work) {
       cleanup_oopstorages();
     }
+
+    if (deflate_idle_monitors) {
+      ObjectSynchronizer::deflate_idle_monitors_using_JT();
+    }
   }
 }
 
 void ServiceThread::enqueue_deferred_event(JvmtiDeferredEvent* event) {
   MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);

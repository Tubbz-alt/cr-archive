diff a/src/hotspot/share/runtime/vframe.cpp b/src/hotspot/share/runtime/vframe.cpp
--- a/src/hotspot/share/runtime/vframe.cpp
+++ b/src/hotspot/share/runtime/vframe.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -120,12 +120,18 @@
   GrowableArray<MonitorInfo*>* mons = monitors();
   GrowableArray<MonitorInfo*>* result = new GrowableArray<MonitorInfo*>(mons->length());
   if (mons->is_empty()) return result;
 
   bool found_first_monitor = false;
-  ObjectMonitor *pending_monitor = thread()->current_pending_monitor();
+  // The ObjectMonitor* can't be async deflated since we are either
+  // at a safepoint or the calling thread is operating on itself so
+  // it cannot exit the ObjectMonitor so it remains busy.
   ObjectMonitor *waiting_monitor = thread()->current_waiting_monitor();
+  ObjectMonitor *pending_monitor = NULL;
+  if (waiting_monitor == NULL) {
+    pending_monitor = thread()->current_pending_monitor();
+  }
   oop pending_obj = (pending_monitor != NULL ? (oop) pending_monitor->object() : (oop) NULL);
   oop waiting_obj = (waiting_monitor != NULL ? (oop) waiting_monitor->object() : (oop) NULL);
 
   for (int index = (mons->length()-1); index >= 0; index--) {
     MonitorInfo* monitor = mons->at(index);
@@ -229,10 +235,12 @@
           // monitor before, then we need to see if we have completed
           // the lock or if we are blocked trying to acquire it. Only
           // an inflated monitor that is first on the monitor list in
           // the first frame can block us on a monitor enter.
           markWord mark = monitor->owner()->mark();
+          // The first stage of async deflation does not affect any field
+          // used by this comparison so the ObjectMonitor* is usable here.
           if (mark.has_monitor() &&
               ( // we have marked ourself as pending on this monitor
                 mark.monitor() == thread()->current_pending_monitor() ||
                 // we are not the owner of this monitor
                 !mark.monitor()->is_entered(thread())

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/objectMonitor.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_OBJECTMONITOR_INLINE_HPP
 26 #define SHARE_RUNTIME_OBJECTMONITOR_INLINE_HPP
 27 
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;runtime/atomic.hpp&quot;
 30 
 31 inline intptr_t ObjectMonitor::is_entered(TRAPS) const {
 32   if (THREAD == _owner || THREAD-&gt;is_lock_owned((address) _owner)) {
 33     return 1;
 34   }
 35   return 0;
 36 }
 37 
 38 inline markWord ObjectMonitor::header() const {
 39   return Atomic::load(&amp;_header);
 40 }
 41 
 42 inline volatile markWord* ObjectMonitor::header_addr() {
 43   assert((intptr_t)this == (intptr_t)&amp;_header, &quot;sync code expects this&quot;);
 44   return &amp;_header;
 45 }
 46 
 47 inline void ObjectMonitor::set_header(markWord hdr) {
 48   Atomic::store(&amp;_header, hdr);
 49 }
 50 
 51 inline jint ObjectMonitor::waiters() const {
 52   return _waiters;
 53 }
 54 
<a name="1" id="anc1"></a><span class="line-added"> 55 // Returns NULL if DEFLATER_MARKER is observed.</span>
 56 inline void* ObjectMonitor::owner() const {
<a name="2" id="anc2"></a><span class="line-modified"> 57   void* owner = _owner;</span>
<span class="line-added"> 58   return owner != DEFLATER_MARKER ? owner : NULL;</span>
<span class="line-added"> 59 }</span>
<span class="line-added"> 60 </span>
<span class="line-added"> 61 // Returns true if owner field == DEFLATER_MARKER and false otherwise.</span>
<span class="line-added"> 62 // This accessor is called when we really need to know if the owner</span>
<span class="line-added"> 63 // field == DEFLATER_MARKER and any non-NULL value won&#39;t do the trick.</span>
<span class="line-added"> 64 inline bool ObjectMonitor::owner_is_DEFLATER_MARKER() {</span>
<span class="line-added"> 65   return Atomic::load(&amp;_owner) == DEFLATER_MARKER;</span>
<span class="line-added"> 66 }</span>
<span class="line-added"> 67 </span>
<span class="line-added"> 68 // Returns true if &#39;this&#39; is being async deflated and false otherwise.</span>
<span class="line-added"> 69 inline bool ObjectMonitor::is_being_async_deflated() {</span>
<span class="line-added"> 70   return AsyncDeflateIdleMonitors &amp;&amp; contentions() &lt; 0;</span>
 71 }
 72 
 73 inline void ObjectMonitor::clear() {
 74   assert(Atomic::load(&amp;_header).value() != 0, &quot;must be non-zero&quot;);
<a name="3" id="anc3"></a><span class="line-modified"> 75   assert(_owner == NULL, &quot;must be NULL: owner=&quot; INTPTR_FORMAT, p2i(_owner));</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77   Atomic::store(&amp;_header, markWord::zero());</span>
<span class="line-added"> 78 </span>
<span class="line-added"> 79   clear_common();</span>
<span class="line-added"> 80 }</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82 inline void ObjectMonitor::clear_common() {</span>
<span class="line-added"> 83   if (AsyncDeflateIdleMonitors) {</span>
<span class="line-added"> 84     // Async deflation protocol uses the header, owner and contentions</span>
<span class="line-added"> 85     // fields. While the ObjectMonitor being deflated is on the global</span>
<span class="line-added"> 86     // free list, we leave those three fields alone; contentions &lt; 0</span>
<span class="line-added"> 87     // will force any racing threads to retry. The header field is used</span>
<span class="line-added"> 88     // by install_displaced_markword_in_object() to restore the object&#39;s</span>
<span class="line-added"> 89     // header so we cannot check its value here.</span>
<span class="line-added"> 90     guarantee(_owner == NULL || _owner == DEFLATER_MARKER,</span>
<span class="line-added"> 91               &quot;must be NULL or DEFLATER_MARKER: owner=&quot; INTPTR_FORMAT,</span>
<span class="line-added"> 92               p2i(_owner));</span>
<span class="line-added"> 93   }</span>
<span class="line-added"> 94   assert(contentions() &lt;= 0, &quot;must not be positive: contentions=%d&quot;, contentions());</span>
 95   assert(_waiters == 0, &quot;must be 0: waiters=%d&quot;, _waiters);
 96   assert(_recursions == 0, &quot;must be 0: recursions=&quot; INTX_FORMAT, _recursions);
 97   assert(_object != NULL, &quot;must be non-NULL&quot;);
<a name="4" id="anc4"></a>
 98 
<a name="5" id="anc5"></a><span class="line-modified"> 99   set_allocation_state(Free);</span>
100   _object = NULL;
101 }
102 
103 inline void* ObjectMonitor::object() const {
104   return _object;
105 }
106 
107 inline void* ObjectMonitor::object_addr() {
108   return (void *)(&amp;_object);
109 }
110 
111 inline void ObjectMonitor::set_object(void* obj) {
112   _object = obj;
113 }
114 
<a name="6" id="anc6"></a><span class="line-modified">115 // Return number of threads contending for this monitor.</span>
116 inline jint ObjectMonitor::contentions() const {
<a name="7" id="anc7"></a><span class="line-modified">117   return Atomic::load(&amp;_contentions);</span>
<span class="line-added">118 }</span>
<span class="line-added">119 </span>
<span class="line-added">120 // Add value to the contentions field.</span>
<span class="line-added">121 inline void ObjectMonitor::add_to_contentions(jint value) {</span>
<span class="line-added">122   Atomic::add(&amp;_contentions, value);</span>
123 }
124 
125 // Clear _owner field; current value must match old_value.
126 inline void ObjectMonitor::release_clear_owner(void* old_value) {
<a name="8" id="anc8"></a><span class="line-modified">127   void* prev = Atomic::load(&amp;_owner);</span>
<span class="line-modified">128   ADIM_guarantee(prev == old_value, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="line-modified">129                  &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(old_value));</span>
130   Atomic::release_store(&amp;_owner, (void*)NULL);
131   log_trace(monitorinflation, owner)(&quot;release_clear_owner(): mid=&quot;
132                                      INTPTR_FORMAT &quot;, old_value=&quot; INTPTR_FORMAT,
133                                      p2i(this), p2i(old_value));
134 }
135 
136 // Simply set _owner field to new_value; current value must match old_value.
137 // (Simple means no memory sync needed.)
138 inline void ObjectMonitor::set_owner_from(void* old_value, void* new_value) {
<a name="9" id="anc9"></a><span class="line-modified">139   void* prev = Atomic::load(&amp;_owner);</span>
<span class="line-modified">140   ADIM_guarantee(prev == old_value, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="line-modified">141                  &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(old_value));</span>
142   Atomic::store(&amp;_owner, new_value);
143   log_trace(monitorinflation, owner)(&quot;set_owner_from(): mid=&quot;
144                                      INTPTR_FORMAT &quot;, old_value=&quot; INTPTR_FORMAT
145                                      &quot;, new_value=&quot; INTPTR_FORMAT, p2i(this),
146                                      p2i(old_value), p2i(new_value));
147 }
148 
<a name="10" id="anc10"></a><span class="line-added">149 // Simply set _owner field to new_value; current value must match old_value1 or old_value2.</span>
<span class="line-added">150 // (Simple means no memory sync needed.)</span>
<span class="line-added">151 inline void ObjectMonitor::set_owner_from(void* old_value1, void* old_value2, void* new_value) {</span>
<span class="line-added">152   void* prev = Atomic::load(&amp;_owner);</span>
<span class="line-added">153   ADIM_guarantee(prev == old_value1 || prev == old_value2,</span>
<span class="line-added">154                  &quot;unexpected prev owner=&quot; INTPTR_FORMAT &quot;, expected1=&quot;</span>
<span class="line-added">155                  INTPTR_FORMAT &quot; or expected2=&quot; INTPTR_FORMAT, p2i(prev),</span>
<span class="line-added">156                  p2i(old_value1), p2i(old_value2));</span>
<span class="line-added">157   _owner = new_value;</span>
<span class="line-added">158   log_trace(monitorinflation, owner)(&quot;set_owner_from(old1=&quot; INTPTR_FORMAT</span>
<span class="line-added">159                                      &quot;, old2=&quot; INTPTR_FORMAT &quot;): mid=&quot;</span>
<span class="line-added">160                                      INTPTR_FORMAT &quot;, prev=&quot; INTPTR_FORMAT</span>
<span class="line-added">161                                      &quot;, new=&quot; INTPTR_FORMAT, p2i(old_value1),</span>
<span class="line-added">162                                      p2i(old_value2), p2i(this), p2i(prev),</span>
<span class="line-added">163                                      p2i(new_value));</span>
<span class="line-added">164 }</span>
<span class="line-added">165 </span>
166 // Simply set _owner field to self; current value must match basic_lock_p.
167 inline void ObjectMonitor::set_owner_from_BasicLock(void* basic_lock_p, Thread* self) {
<a name="11" id="anc11"></a><span class="line-modified">168   void* prev = Atomic::load(&amp;_owner);</span>
<span class="line-modified">169   ADIM_guarantee(prev == basic_lock_p, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="line-modified">170                  &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(basic_lock_p));</span>
171   // Non-null owner field to non-null owner field is safe without
172   // cmpxchg() as long as all readers can tolerate either flavor.
173   Atomic::store(&amp;_owner, self);
174   log_trace(monitorinflation, owner)(&quot;set_owner_from_BasicLock(): mid=&quot;
175                                      INTPTR_FORMAT &quot;, basic_lock_p=&quot;
176                                      INTPTR_FORMAT &quot;, new_value=&quot; INTPTR_FORMAT,
177                                      p2i(this), p2i(basic_lock_p), p2i(self));
178 }
179 
180 // Try to set _owner field to new_value if the current value matches
181 // old_value. Otherwise, does not change the _owner field. Returns
182 // the prior value of the _owner field.
183 inline void* ObjectMonitor::try_set_owner_from(void* old_value, void* new_value) {
184   void* prev = Atomic::cmpxchg(&amp;_owner, old_value, new_value);
185   if (prev == old_value) {
186     log_trace(monitorinflation, owner)(&quot;try_set_owner_from(): mid=&quot;
187                                        INTPTR_FORMAT &quot;, prev=&quot; INTPTR_FORMAT
188                                        &quot;, new=&quot; INTPTR_FORMAT, p2i(this),
189                                        p2i(prev), p2i(new_value));
190   }
191   return prev;
192 }
193 
<a name="12" id="anc12"></a><span class="line-added">194 inline void ObjectMonitor::set_allocation_state(ObjectMonitor::AllocationState s) {</span>
<span class="line-added">195   _allocation_state = s;</span>
<span class="line-added">196 }</span>
<span class="line-added">197 </span>
<span class="line-added">198 inline ObjectMonitor::AllocationState ObjectMonitor::allocation_state() const {</span>
<span class="line-added">199   return _allocation_state;</span>
<span class="line-added">200 }</span>
<span class="line-added">201 </span>
<span class="line-added">202 inline bool ObjectMonitor::is_free() const {</span>
<span class="line-added">203   return _allocation_state == Free;</span>
<span class="line-added">204 }</span>
<span class="line-added">205 </span>
<span class="line-added">206 inline bool ObjectMonitor::is_old() const {</span>
<span class="line-added">207   return _allocation_state == Old;</span>
<span class="line-added">208 }</span>
<span class="line-added">209 </span>
<span class="line-added">210 inline bool ObjectMonitor::is_new() const {</span>
<span class="line-added">211   return _allocation_state == New;</span>
<span class="line-added">212 }</span>
<span class="line-added">213 </span>
214 // The _next_om field can be concurrently read and modified so we
215 // use Atomic operations to disable compiler optimizations that
216 // might try to elide loading and/or storing this field.
217 
218 inline ObjectMonitor* ObjectMonitor::next_om() const {
219   return Atomic::load(&amp;_next_om);
220 }
221 
222 // Simply set _next_om field to new_value.
223 inline void ObjectMonitor::set_next_om(ObjectMonitor* new_value) {
224   Atomic::store(&amp;_next_om, new_value);
225 }
226 
227 // Try to set _next_om field to new_value if the current value matches
228 // old_value. Otherwise, does not change the _next_om field. Returns
229 // the prior value of the _next_om field.
230 inline ObjectMonitor* ObjectMonitor::try_set_next_om(ObjectMonitor* old_value, ObjectMonitor* new_value) {
231   return Atomic::cmpxchg(&amp;_next_om, old_value, new_value);
232 }
233 
234 #endif // SHARE_RUNTIME_OBJECTMONITOR_INLINE_HPP
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 25 #include &quot;gc/shared/gcLogPrecious.hpp&quot;</span>
 26 #include &quot;gc/z/zArray.inline.hpp&quot;
 27 #include &quot;gc/z/zErrno.hpp&quot;
 28 #include &quot;gc/z/zGlobals.hpp&quot;
 29 #include &quot;gc/z/zLargePages.inline.hpp&quot;
 30 #include &quot;gc/z/zMountPoint_linux.hpp&quot;
 31 #include &quot;gc/z/zNUMA.inline.hpp&quot;
 32 #include &quot;gc/z/zPhysicalMemoryBacking_linux.hpp&quot;
 33 #include &quot;gc/z/zSyscall_linux.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;runtime/init.hpp&quot;
 36 #include &quot;runtime/os.hpp&quot;
 37 #include &quot;runtime/stubRoutines.hpp&quot;
 38 #include &quot;utilities/align.hpp&quot;
 39 #include &quot;utilities/debug.hpp&quot;
 40 #include &quot;utilities/growableArray.hpp&quot;
 41 
 42 #include &lt;fcntl.h&gt;
 43 #include &lt;stdio.h&gt;
 44 #include &lt;sys/mman.h&gt;
 45 #include &lt;sys/stat.h&gt;
 46 #include &lt;sys/statfs.h&gt;
 47 #include &lt;sys/types.h&gt;
 48 #include &lt;unistd.h&gt;
 49 
 50 //
 51 // Support for building on older Linux systems
 52 //
 53 
 54 // memfd_create(2) flags
 55 #ifndef MFD_CLOEXEC
 56 #define MFD_CLOEXEC                      0x0001U
 57 #endif
 58 #ifndef MFD_HUGETLB
 59 #define MFD_HUGETLB                      0x0004U
 60 #endif
 61 
 62 // open(2) flags
 63 #ifndef O_CLOEXEC
 64 #define O_CLOEXEC                        02000000
 65 #endif
 66 #ifndef O_TMPFILE
 67 #define O_TMPFILE                        (020000000 | O_DIRECTORY)
 68 #endif
 69 
 70 // fallocate(2) flags
 71 #ifndef FALLOC_FL_KEEP_SIZE
 72 #define FALLOC_FL_KEEP_SIZE              0x01
 73 #endif
 74 #ifndef FALLOC_FL_PUNCH_HOLE
 75 #define FALLOC_FL_PUNCH_HOLE             0x02
 76 #endif
 77 
 78 // Filesystem types, see statfs(2)
 79 #ifndef TMPFS_MAGIC
 80 #define TMPFS_MAGIC                      0x01021994
 81 #endif
 82 #ifndef HUGETLBFS_MAGIC
 83 #define HUGETLBFS_MAGIC                  0x958458f6
 84 #endif
 85 
 86 // Filesystem names
 87 #define ZFILESYSTEM_TMPFS                &quot;tmpfs&quot;
 88 #define ZFILESYSTEM_HUGETLBFS            &quot;hugetlbfs&quot;
 89 
 90 // Proc file entry for max map mount
 91 #define ZFILENAME_PROC_MAX_MAP_COUNT     &quot;/proc/sys/vm/max_map_count&quot;
 92 
 93 // Sysfs file for transparent huge page on tmpfs
 94 #define ZFILENAME_SHMEM_ENABLED          &quot;/sys/kernel/mm/transparent_hugepage/shmem_enabled&quot;
 95 
 96 // Java heap filename
 97 #define ZFILENAME_HEAP                   &quot;java_heap&quot;
 98 
 99 // Preferred tmpfs mount points, ordered by priority
100 static const char* z_preferred_tmpfs_mountpoints[] = {
101   &quot;/dev/shm&quot;,
102   &quot;/run/shm&quot;,
103   NULL
104 };
105 
106 // Preferred hugetlbfs mount points, ordered by priority
107 static const char* z_preferred_hugetlbfs_mountpoints[] = {
108   &quot;/dev/hugepages&quot;,
109   &quot;/hugepages&quot;,
110   NULL
111 };
112 
113 static int z_fallocate_hugetlbfs_attempts = 3;
114 static bool z_fallocate_supported = true;
115 
116 ZPhysicalMemoryBacking::ZPhysicalMemoryBacking() :
117     _fd(-1),
118     _size(0),
119     _filesystem(0),
120     _block_size(0),
121     _available(0),
122     _initialized(false) {
123 
124   // Create backing file
125   _fd = create_fd(ZFILENAME_HEAP);
126   if (_fd == -1) {
127     return;
128   }
129 
130   // Get filesystem statistics
131   struct statfs buf;
132   if (fstatfs(_fd, &amp;buf) == -1) {
133     ZErrno err;
<a name="2" id="anc2"></a><span class="line-modified">134     log_error_p(gc)(&quot;Failed to determine filesystem type for backing file (%s)&quot;, err.to_string());</span>
135     return;
136   }
137 
138   _filesystem = buf.f_type;
139   _block_size = buf.f_bsize;
140   _available = buf.f_bavail * _block_size;
141 
<a name="3" id="anc3"></a><span class="line-modified">142   log_info_p(gc, init)(&quot;Heap Backing Filesystem: %s (0x&quot; UINT64_FORMAT_X &quot;)&quot;,</span>
<span class="line-modified">143                        is_tmpfs() ? ZFILESYSTEM_TMPFS : is_hugetlbfs() ? ZFILESYSTEM_HUGETLBFS : &quot;other&quot;, _filesystem);</span>
144 
145   // Make sure the filesystem type matches requested large page type
146   if (ZLargePages::is_transparent() &amp;&amp; !is_tmpfs()) {
<a name="4" id="anc4"></a><span class="line-modified">147     log_error_p(gc)(&quot;-XX:+UseTransparentHugePages can only be enabled when using a %s filesystem&quot;,</span>
<span class="line-modified">148                     ZFILESYSTEM_TMPFS);</span>
149     return;
150   }
151 
152   if (ZLargePages::is_transparent() &amp;&amp; !tmpfs_supports_transparent_huge_pages()) {
<a name="5" id="anc5"></a><span class="line-modified">153     log_error_p(gc)(&quot;-XX:+UseTransparentHugePages on a %s filesystem not supported by kernel&quot;,</span>
<span class="line-modified">154                     ZFILESYSTEM_TMPFS);</span>
155     return;
156   }
157 
158   if (ZLargePages::is_explicit() &amp;&amp; !is_hugetlbfs()) {
<a name="6" id="anc6"></a><span class="line-modified">159     log_error_p(gc)(&quot;-XX:+UseLargePages (without -XX:+UseTransparentHugePages) can only be enabled &quot;</span>
<span class="line-modified">160                     &quot;when using a %s filesystem&quot;, ZFILESYSTEM_HUGETLBFS);</span>
161     return;
162   }
163 
164   if (!ZLargePages::is_explicit() &amp;&amp; is_hugetlbfs()) {
<a name="7" id="anc7"></a><span class="line-modified">165     log_error_p(gc)(&quot;-XX:+UseLargePages must be enabled when using a %s filesystem&quot;,</span>
<span class="line-modified">166                     ZFILESYSTEM_HUGETLBFS);</span>
167     return;
168   }
169 
170   if (ZLargePages::is_explicit() &amp;&amp; os::large_page_size() != ZGranuleSize) {
<a name="8" id="anc8"></a><span class="line-modified">171     log_error_p(gc)(&quot;Incompatible large page size configured &quot; SIZE_FORMAT &quot; (expected &quot; SIZE_FORMAT &quot;)&quot;,</span>
<span class="line-modified">172                     os::large_page_size(), ZGranuleSize);</span>
173     return;
174   }
175 
176   // Make sure the filesystem block size is compatible
177   if (ZGranuleSize % _block_size != 0) {
<a name="9" id="anc9"></a><span class="line-modified">178     log_error_p(gc)(&quot;Filesystem backing the heap has incompatible block size (&quot; SIZE_FORMAT &quot;)&quot;,</span>
<span class="line-modified">179                     _block_size);</span>
180     return;
181   }
182 
183   if (is_hugetlbfs() &amp;&amp; _block_size != ZGranuleSize) {
<a name="10" id="anc10"></a><span class="line-modified">184     log_error_p(gc)(&quot;%s filesystem has unexpected block size &quot; SIZE_FORMAT &quot; (expected &quot; SIZE_FORMAT &quot;)&quot;,</span>
<span class="line-modified">185                     ZFILESYSTEM_HUGETLBFS, _block_size, ZGranuleSize);</span>
186     return;
187   }
188 
189   // Successfully initialized
190   _initialized = true;
191 }
192 
193 int ZPhysicalMemoryBacking::create_mem_fd(const char* name) const {
194   // Create file name
195   char filename[PATH_MAX];
196   snprintf(filename, sizeof(filename), &quot;%s%s&quot;, name, ZLargePages::is_explicit() ? &quot;.hugetlb&quot; : &quot;&quot;);
197 
198   // Create file
199   const int extra_flags = ZLargePages::is_explicit() ? MFD_HUGETLB : 0;
200   const int fd = ZSyscall::memfd_create(filename, MFD_CLOEXEC | extra_flags);
201   if (fd == -1) {
202     ZErrno err;
<a name="11" id="anc11"></a><span class="line-modified">203     log_debug_p(gc, init)(&quot;Failed to create memfd file (%s)&quot;,</span>
<span class="line-modified">204                           ((ZLargePages::is_explicit() &amp;&amp; err == EINVAL) ? &quot;Hugepages not supported&quot; : err.to_string()));</span>
205     return -1;
206   }
207 
<a name="12" id="anc12"></a><span class="line-modified">208   log_info_p(gc, init)(&quot;Heap Backing File: /memfd:%s&quot;, filename);</span>
209 
210   return fd;
211 }
212 
213 int ZPhysicalMemoryBacking::create_file_fd(const char* name) const {
214   const char* const filesystem = ZLargePages::is_explicit()
215                                  ? ZFILESYSTEM_HUGETLBFS
216                                  : ZFILESYSTEM_TMPFS;
217   const char** const preferred_mountpoints = ZLargePages::is_explicit()
218                                              ? z_preferred_hugetlbfs_mountpoints
219                                              : z_preferred_tmpfs_mountpoints;
220 
221   // Find mountpoint
222   ZMountPoint mountpoint(filesystem, preferred_mountpoints);
223   if (mountpoint.get() == NULL) {
<a name="13" id="anc13"></a><span class="line-modified">224     log_error_p(gc)(&quot;Use -XX:AllocateHeapAt to specify the path to a %s filesystem&quot;, filesystem);</span>
225     return -1;
226   }
227 
228   // Try to create an anonymous file using the O_TMPFILE flag. Note that this
229   // flag requires kernel &gt;= 3.11. If this fails we fall back to open/unlink.
230   const int fd_anon = os::open(mountpoint.get(), O_TMPFILE|O_EXCL|O_RDWR|O_CLOEXEC, S_IRUSR|S_IWUSR);
231   if (fd_anon == -1) {
232     ZErrno err;
<a name="14" id="anc14"></a><span class="line-modified">233     log_debug_p(gc, init)(&quot;Failed to create anonymous file in %s (%s)&quot;, mountpoint.get(),</span>
<span class="line-modified">234                           (err == EINVAL ? &quot;Not supported&quot; : err.to_string()));</span>
235   } else {
236     // Get inode number for anonymous file
237     struct stat stat_buf;
238     if (fstat(fd_anon, &amp;stat_buf) == -1) {
239       ZErrno err;
<a name="15" id="anc15"></a><span class="line-modified">240       log_error_p(gc)(&quot;Failed to determine inode number for anonymous file (%s)&quot;, err.to_string());</span>
241       return -1;
242     }
243 
<a name="16" id="anc16"></a><span class="line-modified">244     log_info_p(gc, init)(&quot;Heap Backing File: %s/#&quot; UINT64_FORMAT, mountpoint.get(), (uint64_t)stat_buf.st_ino);</span>
245 
246     return fd_anon;
247   }
248 
<a name="17" id="anc17"></a><span class="line-modified">249   log_debug_p(gc, init)(&quot;Falling back to open/unlink&quot;);</span>
250 
251   // Create file name
252   char filename[PATH_MAX];
253   snprintf(filename, sizeof(filename), &quot;%s/%s.%d&quot;, mountpoint.get(), name, os::current_process_id());
254 
255   // Create file
256   const int fd = os::open(filename, O_CREAT|O_EXCL|O_RDWR|O_CLOEXEC, S_IRUSR|S_IWUSR);
257   if (fd == -1) {
258     ZErrno err;
<a name="18" id="anc18"></a><span class="line-modified">259     log_error_p(gc)(&quot;Failed to create file %s (%s)&quot;, filename, err.to_string());</span>
260     return -1;
261   }
262 
263   // Unlink file
264   if (unlink(filename) == -1) {
265     ZErrno err;
<a name="19" id="anc19"></a><span class="line-modified">266     log_error_p(gc)(&quot;Failed to unlink file %s (%s)&quot;, filename, err.to_string());</span>
267     return -1;
268   }
269 
<a name="20" id="anc20"></a><span class="line-modified">270   log_info_p(gc, init)(&quot;Heap Backing File: %s&quot;, filename);</span>
271 
272   return fd;
273 }
274 
275 int ZPhysicalMemoryBacking::create_fd(const char* name) const {
276   if (AllocateHeapAt == NULL) {
277     // If the path is not explicitly specified, then we first try to create a memfd file
278     // instead of looking for a tmpfd/hugetlbfs mount point. Note that memfd_create() might
279     // not be supported at all (requires kernel &gt;= 3.17), or it might not support large
280     // pages (requires kernel &gt;= 4.14). If memfd_create() fails, then we try to create a
281     // file on an accessible tmpfs or hugetlbfs mount point.
282     const int fd = create_mem_fd(name);
283     if (fd != -1) {
284       return fd;
285     }
286 
<a name="21" id="anc21"></a><span class="line-modified">287     log_debug_p(gc)(&quot;Falling back to searching for an accessible mount point&quot;);</span>
288   }
289 
290   return create_file_fd(name);
291 }
292 
293 bool ZPhysicalMemoryBacking::is_initialized() const {
294   return _initialized;
295 }
296 
297 void ZPhysicalMemoryBacking::warn_available_space(size_t max) const {
298   // Note that the available space on a tmpfs or a hugetlbfs filesystem
299   // will be zero if no size limit was specified when it was mounted.
300   if (_available == 0) {
301     // No size limit set, skip check
<a name="22" id="anc22"></a><span class="line-modified">302     log_info_p(gc, init)(&quot;Available space on backing filesystem: N/A&quot;);</span>
303     return;
304   }
305 
<a name="23" id="anc23"></a><span class="line-modified">306   log_info_p(gc, init)(&quot;Available space on backing filesystem: &quot; SIZE_FORMAT &quot;M&quot;, _available / M);</span>
307 
308   // Warn if the filesystem doesn&#39;t currently have enough space available to hold
309   // the max heap size. The max heap size will be capped if we later hit this limit
310   // when trying to expand the heap.
311   if (_available &lt; max) {
<a name="24" id="anc24"></a><span class="line-modified">312     log_warning_p(gc)(&quot;***** WARNING! INCORRECT SYSTEM CONFIGURATION DETECTED! *****&quot;);</span>
<span class="line-modified">313     log_warning_p(gc)(&quot;Not enough space available on the backing filesystem to hold the current max Java heap&quot;);</span>
<span class="line-modified">314     log_warning_p(gc)(&quot;size (&quot; SIZE_FORMAT &quot;M). Please adjust the size of the backing filesystem accordingly &quot;</span>
315                     &quot;(available&quot;, max / M);
<a name="25" id="anc25"></a><span class="line-modified">316     log_warning_p(gc)(&quot;space is currently &quot; SIZE_FORMAT &quot;M). Continuing execution with the current filesystem &quot;</span>
317                     &quot;size could&quot;, _available / M);
<a name="26" id="anc26"></a><span class="line-modified">318     log_warning_p(gc)(&quot;lead to a premature OutOfMemoryError being thrown, due to failure to map memory.&quot;);</span>
319   }
320 }
321 
322 void ZPhysicalMemoryBacking::warn_max_map_count(size_t max) const {
323   const char* const filename = ZFILENAME_PROC_MAX_MAP_COUNT;
324   FILE* const file = fopen(filename, &quot;r&quot;);
325   if (file == NULL) {
326     // Failed to open file, skip check
<a name="27" id="anc27"></a><span class="line-modified">327     log_debug_p(gc, init)(&quot;Failed to open %s&quot;, filename);</span>
328     return;
329   }
330 
331   size_t actual_max_map_count = 0;
332   const int result = fscanf(file, SIZE_FORMAT, &amp;actual_max_map_count);
333   fclose(file);
334   if (result != 1) {
335     // Failed to read file, skip check
<a name="28" id="anc28"></a><span class="line-modified">336     log_debug_p(gc, init)(&quot;Failed to read %s&quot;, filename);</span>
337     return;
338   }
339 
340   // The required max map count is impossible to calculate exactly since subsystems
341   // other than ZGC are also creating memory mappings, and we have no control over that.
342   // However, ZGC tends to create the most mappings and dominate the total count.
343   // In the worst cases, ZGC will map each granule three times, i.e. once per heap view.
344   // We speculate that we need another 20% to allow for non-ZGC subsystems to map memory.
345   const size_t required_max_map_count = (max / ZGranuleSize) * 3 * 1.2;
346   if (actual_max_map_count &lt; required_max_map_count) {
<a name="29" id="anc29"></a><span class="line-modified">347     log_warning_p(gc)(&quot;***** WARNING! INCORRECT SYSTEM CONFIGURATION DETECTED! *****&quot;);</span>
<span class="line-modified">348     log_warning_p(gc)(&quot;The system limit on number of memory mappings per process might be too low for the given&quot;);</span>
<span class="line-modified">349     log_warning_p(gc)(&quot;max Java heap size (&quot; SIZE_FORMAT &quot;M). Please adjust %s to allow for at&quot;,</span>
350                     max / M, filename);
<a name="30" id="anc30"></a><span class="line-modified">351     log_warning_p(gc)(&quot;least &quot; SIZE_FORMAT &quot; mappings (current limit is &quot; SIZE_FORMAT &quot;). Continuing execution &quot;</span>
352                     &quot;with the current&quot;, required_max_map_count, actual_max_map_count);
<a name="31" id="anc31"></a><span class="line-modified">353     log_warning_p(gc)(&quot;limit could lead to a fatal error, due to failure to map memory.&quot;);</span>
354   }
355 }
356 
357 void ZPhysicalMemoryBacking::warn_commit_limits(size_t max) const {
358   // Warn if available space is too low
359   warn_available_space(max);
360 
361   // Warn if max map count is too low
362   warn_max_map_count(max);
363 }
364 
365 size_t ZPhysicalMemoryBacking::size() const {
366   return _size;
367 }
368 
369 bool ZPhysicalMemoryBacking::is_tmpfs() const {
370   return _filesystem == TMPFS_MAGIC;
371 }
372 
373 bool ZPhysicalMemoryBacking::is_hugetlbfs() const {
374   return _filesystem == HUGETLBFS_MAGIC;
375 }
376 
377 bool ZPhysicalMemoryBacking::tmpfs_supports_transparent_huge_pages() const {
378   // If the shmem_enabled file exists and is readable then we
379   // know the kernel supports transparent huge pages for tmpfs.
380   return access(ZFILENAME_SHMEM_ENABLED, R_OK) == 0;
381 }
382 
383 ZErrno ZPhysicalMemoryBacking::fallocate_compat_ftruncate(size_t size) const {
384   while (ftruncate(_fd, size) == -1) {
385     if (errno != EINTR) {
386       // Failed
387       return errno;
388     }
389   }
390 
391   // Success
392   return 0;
393 }
394 
395 ZErrno ZPhysicalMemoryBacking::fallocate_compat_mmap_hugetlbfs(size_t offset, size_t length, bool touch) const {
396   // On hugetlbfs, mapping a file segment will fail immediately, without
397   // the need to touch the mapped pages first, if there aren&#39;t enough huge
398   // pages available to back the mapping.
399   void* const addr = mmap(0, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, offset);
400   if (addr == MAP_FAILED) {
401     // Failed
402     return errno;
403   }
404 
405   // Once mapped, the huge pages are only reserved. We need to touch them
406   // to associate them with the file segment. Note that we can not punch
407   // hole in file segments which only have reserved pages.
408   if (touch) {
409     char* const start = (char*)addr;
410     char* const end = start + length;
411     os::pretouch_memory(start, end, _block_size);
412   }
413 
414   // Unmap again. From now on, the huge pages that were mapped are allocated
415   // to this file. There&#39;s no risk of getting a SIGBUS when mapping and
416   // touching these pages again.
417   if (munmap(addr, length) == -1) {
418     // Failed
419     return errno;
420   }
421 
422   // Success
423   return 0;
424 }
425 
426 static bool safe_touch_mapping(void* addr, size_t length, size_t page_size) {
427   char* const start = (char*)addr;
428   char* const end = start + length;
429 
430   // Touching a mapping that can&#39;t be backed by memory will generate a
431   // SIGBUS. By using SafeFetch32 any SIGBUS will be safely caught and
432   // handled. On tmpfs, doing a fetch (rather than a store) is enough
433   // to cause backing pages to be allocated (there&#39;s no zero-page to
434   // worry about).
435   for (char *p = start; p &lt; end; p += page_size) {
436     if (SafeFetch32((int*)p, -1) == -1) {
437       // Failed
438       return false;
439     }
440   }
441 
442   // Success
443   return true;
444 }
445 
446 ZErrno ZPhysicalMemoryBacking::fallocate_compat_mmap_tmpfs(size_t offset, size_t length) const {
447   // On tmpfs, we need to touch the mapped pages to figure out
448   // if there are enough pages available to back the mapping.
449   void* const addr = mmap(0, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, offset);
450   if (addr == MAP_FAILED) {
451     // Failed
452     return errno;
453   }
454 
455   // Advise mapping to use transparent huge pages
456   os::realign_memory((char*)addr, length, os::large_page_size());
457 
458   // Touch the mapping (safely) to make sure it&#39;s backed by memory
459   const bool backed = safe_touch_mapping(addr, length, _block_size);
460 
461   // Unmap again. If successfully touched, the backing memory will
462   // be allocated to this file. There&#39;s no risk of getting a SIGBUS
463   // when mapping and touching these pages again.
464   if (munmap(addr, length) == -1) {
465     // Failed
466     return errno;
467   }
468 
469   // Success
470   return backed ? 0 : ENOMEM;
471 }
472 
473 ZErrno ZPhysicalMemoryBacking::fallocate_compat_pwrite(size_t offset, size_t length) const {
474   uint8_t data = 0;
475 
476   // Allocate backing memory by writing to each block
477   for (size_t pos = offset; pos &lt; offset + length; pos += _block_size) {
478     if (pwrite(_fd, &amp;data, sizeof(data), pos) == -1) {
479       // Failed
480       return errno;
481     }
482   }
483 
484   // Success
485   return 0;
486 }
487 
488 ZErrno ZPhysicalMemoryBacking::fallocate_fill_hole_compat(size_t offset, size_t length) {
489   // fallocate(2) is only supported by tmpfs since Linux 3.5, and by hugetlbfs
490   // since Linux 4.3. When fallocate(2) is not supported we emulate it using
491   // mmap/munmap (for hugetlbfs and tmpfs with transparent huge pages) or pwrite
492   // (for tmpfs without transparent huge pages and other filesystem types).
493 
494   const size_t end = offset + length;
495   if (end &gt; _size) {
496     // Increase file size
497     const ZErrno err = fallocate_compat_ftruncate(end);
498     if (err) {
499       // Failed
500       return err;
501     }
502   }
503 
504   // Allocate backing memory
505   const ZErrno err = ZLargePages::is_explicit()
506                      ? fallocate_compat_mmap_hugetlbfs(offset, length, false /* touch */)
507                      : (ZLargePages::is_transparent()
508                         ? fallocate_compat_mmap_tmpfs(offset, length)
509                         : fallocate_compat_pwrite(offset, length));
510 
511   if (err) {
512     if (end &gt; _size) {
513       // Restore file size
514       fallocate_compat_ftruncate(_size);
515     }
516 
517     // Failed
518     return err;
519   }
520 
521   if (end &gt; _size) {
522     // Record new file size
523     _size = end;
524   }
525 
526   // Success
527   return 0;
528 }
529 
530 ZErrno ZPhysicalMemoryBacking::fallocate_fill_hole_syscall(size_t offset, size_t length) {
531   const int mode = 0; // Allocate
532   const int res = ZSyscall::fallocate(_fd, mode, offset, length);
533   if (res == -1) {
534     // Failed
535     return errno;
536   }
537 
538   const size_t end = offset + length;
539   if (end &gt; _size) {
540     // Record new file size
541     _size = end;
542   }
543 
544   // Success
545   return 0;
546 }
547 
548 ZErrno ZPhysicalMemoryBacking::fallocate_fill_hole(size_t offset, size_t length) {
549   // Using compat mode is more efficient when allocating space on hugetlbfs.
550   // Note that allocating huge pages this way will only reserve them, and not
551   // associate them with segments of the file. We must guarantee that we at
552   // some point touch these segments, otherwise we can not punch hole in them.
553   // Also note that we need to use compat mode when using transparent huge pages,
554   // since we need to use madvise(2) on the mapping before the page is allocated.
555   if (z_fallocate_supported &amp;&amp; !ZLargePages::is_enabled()) {
556      const ZErrno err = fallocate_fill_hole_syscall(offset, length);
557      if (!err) {
558        // Success
559        return 0;
560      }
561 
562      if (err != ENOSYS &amp;&amp; err != EOPNOTSUPP) {
563        // Failed
564        return err;
565      }
566 
567      // Not supported
<a name="32" id="anc32"></a><span class="line-modified">568      log_debug_p(gc)(&quot;Falling back to fallocate() compatibility mode&quot;);</span>
569      z_fallocate_supported = false;
570   }
571 
572   return fallocate_fill_hole_compat(offset, length);
573 }
574 
575 ZErrno ZPhysicalMemoryBacking::fallocate_punch_hole(size_t offset, size_t length) {
576   if (ZLargePages::is_explicit()) {
577     // We can only punch hole in pages that have been touched. Non-touched
578     // pages are only reserved, and not associated with any specific file
579     // segment. We don&#39;t know which pages have been previously touched, so
580     // we always touch them here to guarantee that we can punch hole.
581     const ZErrno err = fallocate_compat_mmap_hugetlbfs(offset, length, true /* touch */);
582     if (err) {
583       // Failed
584       return err;
585     }
586   }
587 
588   const int mode = FALLOC_FL_PUNCH_HOLE|FALLOC_FL_KEEP_SIZE;
589   if (ZSyscall::fallocate(_fd, mode, offset, length) == -1) {
590     // Failed
591     return errno;
592   }
593 
594   // Success
595   return 0;
596 }
597 
598 ZErrno ZPhysicalMemoryBacking::split_and_fallocate(bool punch_hole, size_t offset, size_t length) {
599   // Try first half
600   const size_t offset0 = offset;
601   const size_t length0 = align_up(length / 2, _block_size);
602   const ZErrno err0 = fallocate(punch_hole, offset0, length0);
603   if (err0) {
604     return err0;
605   }
606 
607   // Try second half
608   const size_t offset1 = offset0 + length0;
609   const size_t length1 = length - length0;
610   const ZErrno err1 = fallocate(punch_hole, offset1, length1);
611   if (err1) {
612     return err1;
613   }
614 
615   // Success
616   return 0;
617 }
618 
619 ZErrno ZPhysicalMemoryBacking::fallocate(bool punch_hole, size_t offset, size_t length) {
620   assert(is_aligned(offset, _block_size), &quot;Invalid offset&quot;);
621   assert(is_aligned(length, _block_size), &quot;Invalid length&quot;);
622 
623   const ZErrno err = punch_hole ? fallocate_punch_hole(offset, length) : fallocate_fill_hole(offset, length);
624   if (err == EINTR &amp;&amp; length &gt; _block_size) {
625     // Calling fallocate(2) with a large length can take a long time to
626     // complete. When running profilers, such as VTune, this syscall will
627     // be constantly interrupted by signals. Expanding the file in smaller
628     // steps avoids this problem.
629     return split_and_fallocate(punch_hole, offset, length);
630   }
631 
632   return err;
633 }
634 
635 bool ZPhysicalMemoryBacking::commit_inner(size_t offset, size_t length) {
636   log_trace(gc, heap)(&quot;Committing memory: &quot; SIZE_FORMAT &quot;M-&quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot;M)&quot;,
637                       offset / M, (offset + length) / M, length / M);
638 
639 retry:
640   const ZErrno err = fallocate(false /* punch_hole */, offset, length);
641   if (err) {
642     if (err == ENOSPC &amp;&amp; !is_init_completed() &amp;&amp; ZLargePages::is_explicit() &amp;&amp; z_fallocate_hugetlbfs_attempts-- &gt; 0) {
643       // If we fail to allocate during initialization, due to lack of space on
644       // the hugetlbfs filesystem, then we wait and retry a few times before
645       // giving up. Otherwise there is a risk that running JVMs back-to-back
646       // will fail, since there is a delay between process termination and the
647       // huge pages owned by that process being returned to the huge page pool
648       // and made available for new allocations.
<a name="33" id="anc33"></a><span class="line-modified">649       log_debug_p(gc, init)(&quot;Failed to commit memory (%s), retrying&quot;, err.to_string());</span>
650 
651       // Wait and retry in one second, in the hope that huge pages will be
652       // available by then.
653       sleep(1);
654       goto retry;
655     }
656 
657     // Failed
<a name="34" id="anc34"></a><span class="line-modified">658     log_error_p(gc)(&quot;Failed to commit memory (%s)&quot;, err.to_string());</span>
659     return false;
660   }
661 
662   // Success
663   return true;
664 }
665 
666 static int offset_to_node(size_t offset) {
667   const GrowableArray&lt;int&gt;* mapping = os::Linux::numa_nindex_to_node();
668   const size_t nindex = (offset &gt;&gt; ZGranuleSizeShift) % mapping-&gt;length();
669   return mapping-&gt;at((int)nindex);
670 }
671 
672 size_t ZPhysicalMemoryBacking::commit_numa_interleaved(size_t offset, size_t length) {
673   size_t committed = 0;
674 
675   // Commit one granule at a time, so that each granule
676   // can be allocated from a different preferred node.
677   while (committed &lt; length) {
678     const size_t granule_offset = offset + committed;
679 
680     // Setup NUMA policy to allocate memory from a preferred node
681     os::Linux::numa_set_preferred(offset_to_node(granule_offset));
682 
683     if (!commit_inner(granule_offset, ZGranuleSize)) {
684       // Failed
685       break;
686     }
687 
688     committed += ZGranuleSize;
689   }
690 
691   // Restore NUMA policy
692   os::Linux::numa_set_preferred(-1);
693 
694   return committed;
695 }
696 
697 size_t ZPhysicalMemoryBacking::commit_default(size_t offset, size_t length) {
698   // Try to commit the whole region
699   if (commit_inner(offset, length)) {
700     // Success
701     return length;
702   }
703 
704   // Failed, try to commit as much as possible
705   size_t start = offset;
706   size_t end = offset + length;
707 
708   for (;;) {
709     length = align_down((end - start) / 2, ZGranuleSize);
710     if (length &lt; ZGranuleSize) {
711       // Done, don&#39;t commit more
712       return start - offset;
713     }
714 
715     if (commit_inner(start, length)) {
716       // Success, try commit more
717       start += length;
718     } else {
719       // Failed, try commit less
720       end -= length;
721     }
722   }
723 }
724 
725 size_t ZPhysicalMemoryBacking::commit(size_t offset, size_t length) {
726   if (ZNUMA::is_enabled() &amp;&amp; !ZLargePages::is_explicit()) {
727     // To get granule-level NUMA interleaving when using non-large pages,
728     // we must explicitly interleave the memory at commit/fallocate time.
729     return commit_numa_interleaved(offset, length);
730   }
731 
732   return commit_default(offset, length);
733 }
734 
735 size_t ZPhysicalMemoryBacking::uncommit(size_t offset, size_t length) {
736   log_trace(gc, heap)(&quot;Uncommitting memory: &quot; SIZE_FORMAT &quot;M-&quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot;M)&quot;,
737                       offset / M, (offset + length) / M, length / M);
738 
739   const ZErrno err = fallocate(true /* punch_hole */, offset, length);
740   if (err) {
741     log_error(gc)(&quot;Failed to uncommit memory (%s)&quot;, err.to_string());
742     return 0;
743   }
744 
745   return length;
746 }
747 
748 void ZPhysicalMemoryBacking::map(uintptr_t addr, size_t size, uintptr_t offset) const {
749   const void* const res = mmap((void*)addr, size, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, _fd, offset);
750   if (res == MAP_FAILED) {
751     ZErrno err;
752     fatal(&quot;Failed to map memory (%s)&quot;, err.to_string());
753   }
754 }
755 
756 void ZPhysicalMemoryBacking::unmap(uintptr_t addr, size_t size) const {
757   // Note that we must keep the address space reservation intact and just detach
758   // the backing memory. For this reason we map a new anonymous, non-accessible
759   // and non-reserved page over the mapping instead of actually unmapping.
760   const void* const res = mmap((void*)addr, size, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, -1, 0);
761   if (res == MAP_FAILED) {
762     ZErrno err;
763     fatal(&quot;Failed to map memory (%s)&quot;, err.to_string());
764   }
765 }
<a name="35" id="anc35"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="35" type="hidden" />
</body>
</html>
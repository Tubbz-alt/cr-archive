<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/methodHandles_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRGenerator_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateInterpreterGenerator_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/methodHandles_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 36 #include &quot;memory/resourceArea.hpp&quot;
 37 #include &quot;prims/methodHandles.hpp&quot;
 38 #include &quot;runtime/frame.inline.hpp&quot;
 39 #include &quot;utilities/preserveException.hpp&quot;
 40 
 41 #define __ _masm-&gt;
 42 
 43 #ifdef PRODUCT
 44 #define BLOCK_COMMENT(str) /* nothing */
 45 #else
 46 #define BLOCK_COMMENT(str) __ block_comment(str)
 47 #endif
 48 
 49 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
 50 
 51 void MethodHandles::load_klass_from_Class(MacroAssembler* _masm, Register klass_reg, Register temp1, Register temp2) {
 52   if (VerifyMethodHandles) {
 53     verify_klass(_masm, klass_reg, temp1, temp2, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),
 54                  &quot;MH argument is a Class&quot;);
 55   }
<span class="line-modified"> 56   __ ldr(klass_reg, Address(klass_reg, java_lang_Class::klass_offset_in_bytes()));</span>
 57 }
 58 
 59 #ifdef ASSERT
 60 static int check_nonzero(const char* xname, int x) {
 61   assert(x != 0, &quot;%s should be nonzero&quot;, xname);
 62   return x;
 63 }
 64 #define NONZERO(x) check_nonzero(#x, x)
 65 #else //ASSERT
 66 #define NONZERO(x) (x)
 67 #endif //ASSERT
 68 
 69 #ifdef ASSERT
 70 void MethodHandles::verify_klass(MacroAssembler* _masm,
 71                                  Register obj, Register temp1, Register temp2, SystemDictionary::WKID klass_id,
 72                                  const char* error_message) {
 73   InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);
 74   Klass* klass = SystemDictionary::well_known_klass(klass_id);
 75   Label L_ok, L_bad;
 76   BLOCK_COMMENT(&quot;verify_klass {&quot;);
</pre>
<hr />
<pre>
 78   __ cbz(obj, L_bad);
 79   __ load_klass(temp1, obj);
 80   __ lea(temp2, ExternalAddress((address) klass_addr));
 81   __ ldr(temp2, temp2); // the cmpptr on x86 dereferences the AddressLiteral (not lea)
 82   __ cmp(temp1, temp2);
 83   __ b(L_ok, eq);
 84   intptr_t super_check_offset = klass-&gt;super_check_offset();
 85   __ ldr(temp1, Address(temp1, super_check_offset));
 86   __ cmp(temp1, temp2);
 87   __ b(L_ok, eq);
 88 
 89   __ bind(L_bad);
 90   __ stop(error_message);
 91   __ BIND(L_ok);
 92   BLOCK_COMMENT(&quot;} verify_klass&quot;);
 93 }
 94 
 95 void MethodHandles::verify_ref_kind(MacroAssembler* _masm, int ref_kind, Register member_reg, Register temp) {
 96   Label L;
 97   BLOCK_COMMENT(&quot;verify_ref_kind {&quot;);
<span class="line-modified"> 98   __ ldr_u32(temp, Address(member_reg, NONZERO(java_lang_invoke_MemberName::flags_offset_in_bytes())));</span>
 99   __ logical_shift_right(temp, temp, java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT);
100   __ andr(temp, temp, (unsigned)java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK);
101   __ cmp(temp, ref_kind);
102   __ b(L, eq);
103   { char* buf = NEW_C_HEAP_ARRAY(char, 100, mtInternal);
104   jio_snprintf(buf, 100, &quot;verify_ref_kind expected %x&quot;, ref_kind);
105   if (ref_kind == JVM_REF_invokeVirtual ||
106       ref_kind == JVM_REF_invokeSpecial)
107     // could do this for all ref_kinds, but would explode assembly code size
108     trace_method_handle(_masm, buf);
109   __ stop(buf);
110   }
111   BLOCK_COMMENT(&quot;} verify_ref_kind&quot;);
112   __ bind(L);
113 }
114 
115 #endif //ASSERT
116 
117 void MethodHandles::jump_from_method_handle(MacroAssembler* _masm, bool for_compiler_entry) {
118   Label L_no_such_method;
</pre>
<hr />
<pre>
131   }
132   const ByteSize entry_offset = for_compiler_entry ? Method::from_compiled_offset() :
133                                                      Method::from_interpreted_offset();
134 
135   __ indirect_jump(Address(Rmethod, entry_offset), Rtemp);
136 
137   __ bind(L_no_such_method);
138   // throw exception
139   __ jump(StubRoutines::throw_AbstractMethodError_entry(), relocInfo::runtime_call_type, Rtemp);
140 }
141 
142 void MethodHandles::jump_to_lambda_form(MacroAssembler* _masm,
143                                         Register recv, Register tmp,
144                                         bool for_compiler_entry) {
145   BLOCK_COMMENT(&quot;jump_to_lambda_form {&quot;);
146   // This is the initial entry point of a lazy method handle.
147   // After type checking, it picks up the invoker from the LambdaForm.
148   assert_different_registers(recv, tmp, Rmethod);
149 
150   // Load the invoker, as MH -&gt; MH.form -&gt; LF.vmentry
<span class="line-modified">151   __ load_heap_oop(tmp, Address(recv, NONZERO(java_lang_invoke_MethodHandle::form_offset_in_bytes())));</span>
152   __ verify_oop(tmp);
153 
<span class="line-modified">154   __ load_heap_oop(tmp, Address(tmp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset_in_bytes())));</span>
155   __ verify_oop(tmp);
156 
<span class="line-modified">157   __ load_heap_oop(Rmethod, Address(tmp, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes())));</span>
158   __ verify_oop(Rmethod);
<span class="line-modified">159   __ access_load_at(T_ADDRESS, IN_HEAP, Address(Rmethod, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes())), Rmethod, noreg, noreg, noreg);</span>
160 
161   if (VerifyMethodHandles &amp;&amp; !for_compiler_entry) {
162     // make sure recv is already on stack
163     __ ldr(tmp, Address(Rmethod, Method::const_offset()));
164     __ load_sized_value(tmp,
165                         Address(tmp, ConstMethod::size_of_parameters_offset()),
166                         sizeof(u2), /*is_signed*/ false);
167     // assert(sizeof(u2) == sizeof(Method::_size_of_parameters), &quot;&quot;);
168     Label L;
169     __ ldr(tmp, __ receiver_argument_address(Rparams, tmp, tmp));
170     __ cmpoop(tmp, recv);
171     __ b(L, eq);
172     __ stop(&quot;receiver not on stack&quot;);
173     __ bind(L);
174   }
175 
176   jump_from_method_handle(_masm, for_compiler_entry);
177   BLOCK_COMMENT(&quot;} jump_to_lambda_form&quot;);
178 }
179 
</pre>
<hr />
<pre>
288     assert_different_registers(temp3, j_rarg0, j_rarg1, j_rarg2, j_rarg3);
289     assert_different_registers(temp4, j_rarg0, j_rarg1, j_rarg2, j_rarg3);
290   }
291   assert_different_registers(temp1, temp2, temp3, receiver_reg);
292   assert_different_registers(temp1, temp2, temp3, temp4, member_reg);
293   if (!for_compiler_entry)
294     assert_different_registers(temp1, temp2, temp3, temp4, saved_last_sp_register());  // don&#39;t trash lastSP
295 
296   if (iid == vmIntrinsics::_invokeBasic) {
297     // indirect through MH.form.exactInvoker.vmtarget
298     jump_to_lambda_form(_masm, receiver_reg, temp3, for_compiler_entry);
299 
300   } else {
301     // The method is a member invoker used by direct method handles.
302     if (VerifyMethodHandles) {
303       // make sure the trailing argument really is a MemberName (caller responsibility)
304       verify_klass(_masm, member_reg, temp2, temp3, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_invoke_MemberName),
305                    &quot;MemberName required for invokeVirtual etc.&quot;);
306     }
307 
<span class="line-modified">308     Address member_clazz(   member_reg, NONZERO(java_lang_invoke_MemberName::clazz_offset_in_bytes()));</span>
<span class="line-modified">309     Address member_vmindex( member_reg, NONZERO(java_lang_invoke_MemberName::vmindex_offset_in_bytes()));</span>
<span class="line-modified">310     Address member_vmtarget(member_reg, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes()));</span>
<span class="line-modified">311     Address vmtarget_method(Rmethod, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes()));</span>
312 
313     Register temp1_recv_klass = temp1;
314     if (iid != vmIntrinsics::_linkToStatic) {
315       if (iid == vmIntrinsics::_linkToSpecial) {
316         // Don&#39;t actually load the klass; just null-check the receiver.
317         __ null_check(receiver_reg, temp3);
318       } else {
319         // load receiver klass itself
320         __ null_check(receiver_reg, temp3, oopDesc::klass_offset_in_bytes());
321         __ load_klass(temp1_recv_klass, receiver_reg);
322         __ verify_klass_ptr(temp1_recv_klass);
323       }
324       BLOCK_COMMENT(&quot;check_receiver {&quot;);
325       // The receiver for the MemberName must be in receiver_reg.
326       // Check the receiver against the MemberName.clazz
327       if (VerifyMethodHandles &amp;&amp; iid == vmIntrinsics::_linkToSpecial) {
328         // Did not load it above...
329         __ load_klass(temp1_recv_klass, receiver_reg);
330         __ verify_klass_ptr(temp1_recv_klass);
331       }
</pre>
<hr />
<pre>
515       intptr_t* dump_fp = (intptr_t *) saved_bp;
516       address dump_pc = (address) saved_regs[trace_mh_nregs-2]; // LR (with LR,PC last in saved_regs)
517       frame dump_frame((intptr_t *)entry_sp, dump_fp, dump_pc);
518 
519       dump_frame.describe(values, 1);
520       // mark Rsender_sp if seems valid
521       if (has_mh) {
522         if ((saved_sp &gt;= entry_sp - UNREASONABLE_STACK_MOVE) &amp;&amp; (saved_sp &lt; dump_fp)) {
523           values.describe(-1, saved_sp, &quot;*Rsender_sp&quot;);
524         }
525       }
526 
527       // Note: the unextended_sp may not be correct
528       tty-&gt;print_cr(&quot;  stack layout:&quot;);
529       values.print(p);
530     }
531 
532     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
533       mh-&gt;print();
534       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
<span class="line-modified">535         if (java_lang_invoke_MethodHandle::form_offset_in_bytes() != 0) {</span>
<span class="line-removed">536           java_lang_invoke_MethodHandle::form(mh)-&gt;print();</span>
<span class="line-removed">537         }</span>
538       }
539     }
540   }
541 }
542 
543 void MethodHandles::trace_method_handle(MacroAssembler* _masm, const char* adaptername) {
544   if (!log_is_enabled(Info, methodhandles))  return;
545   BLOCK_COMMENT(&quot;trace_method_handle {&quot;);
546   // register saving
547   //  must correspond to trace_mh_nregs and trace_mh_regs defined above
548   int push_size = __ save_all_registers();
549   assert(trace_mh_nregs*wordSize == push_size,&quot;saved register count mismatch&quot;);
550 
551   __ mov_slow(R0, adaptername);
552   __ mov(R1, SP); // entry_sp (after pushes)
553   __ mov(R2, FP);
554   if (R5_mh != R3) {
555     assert_different_registers(R0, R1, R2, R5_mh);
556     __ mov(R3, R5_mh);
557   }
</pre>
</td>
<td>
<hr />
<pre>
 36 #include &quot;memory/resourceArea.hpp&quot;
 37 #include &quot;prims/methodHandles.hpp&quot;
 38 #include &quot;runtime/frame.inline.hpp&quot;
 39 #include &quot;utilities/preserveException.hpp&quot;
 40 
 41 #define __ _masm-&gt;
 42 
 43 #ifdef PRODUCT
 44 #define BLOCK_COMMENT(str) /* nothing */
 45 #else
 46 #define BLOCK_COMMENT(str) __ block_comment(str)
 47 #endif
 48 
 49 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
 50 
 51 void MethodHandles::load_klass_from_Class(MacroAssembler* _masm, Register klass_reg, Register temp1, Register temp2) {
 52   if (VerifyMethodHandles) {
 53     verify_klass(_masm, klass_reg, temp1, temp2, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),
 54                  &quot;MH argument is a Class&quot;);
 55   }
<span class="line-modified"> 56   __ ldr(klass_reg, Address(klass_reg, java_lang_Class::klass_offset()));</span>
 57 }
 58 
 59 #ifdef ASSERT
 60 static int check_nonzero(const char* xname, int x) {
 61   assert(x != 0, &quot;%s should be nonzero&quot;, xname);
 62   return x;
 63 }
 64 #define NONZERO(x) check_nonzero(#x, x)
 65 #else //ASSERT
 66 #define NONZERO(x) (x)
 67 #endif //ASSERT
 68 
 69 #ifdef ASSERT
 70 void MethodHandles::verify_klass(MacroAssembler* _masm,
 71                                  Register obj, Register temp1, Register temp2, SystemDictionary::WKID klass_id,
 72                                  const char* error_message) {
 73   InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);
 74   Klass* klass = SystemDictionary::well_known_klass(klass_id);
 75   Label L_ok, L_bad;
 76   BLOCK_COMMENT(&quot;verify_klass {&quot;);
</pre>
<hr />
<pre>
 78   __ cbz(obj, L_bad);
 79   __ load_klass(temp1, obj);
 80   __ lea(temp2, ExternalAddress((address) klass_addr));
 81   __ ldr(temp2, temp2); // the cmpptr on x86 dereferences the AddressLiteral (not lea)
 82   __ cmp(temp1, temp2);
 83   __ b(L_ok, eq);
 84   intptr_t super_check_offset = klass-&gt;super_check_offset();
 85   __ ldr(temp1, Address(temp1, super_check_offset));
 86   __ cmp(temp1, temp2);
 87   __ b(L_ok, eq);
 88 
 89   __ bind(L_bad);
 90   __ stop(error_message);
 91   __ BIND(L_ok);
 92   BLOCK_COMMENT(&quot;} verify_klass&quot;);
 93 }
 94 
 95 void MethodHandles::verify_ref_kind(MacroAssembler* _masm, int ref_kind, Register member_reg, Register temp) {
 96   Label L;
 97   BLOCK_COMMENT(&quot;verify_ref_kind {&quot;);
<span class="line-modified"> 98   __ ldr_u32(temp, Address(member_reg, NONZERO(java_lang_invoke_MemberName::flags_offset())));</span>
 99   __ logical_shift_right(temp, temp, java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT);
100   __ andr(temp, temp, (unsigned)java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK);
101   __ cmp(temp, ref_kind);
102   __ b(L, eq);
103   { char* buf = NEW_C_HEAP_ARRAY(char, 100, mtInternal);
104   jio_snprintf(buf, 100, &quot;verify_ref_kind expected %x&quot;, ref_kind);
105   if (ref_kind == JVM_REF_invokeVirtual ||
106       ref_kind == JVM_REF_invokeSpecial)
107     // could do this for all ref_kinds, but would explode assembly code size
108     trace_method_handle(_masm, buf);
109   __ stop(buf);
110   }
111   BLOCK_COMMENT(&quot;} verify_ref_kind&quot;);
112   __ bind(L);
113 }
114 
115 #endif //ASSERT
116 
117 void MethodHandles::jump_from_method_handle(MacroAssembler* _masm, bool for_compiler_entry) {
118   Label L_no_such_method;
</pre>
<hr />
<pre>
131   }
132   const ByteSize entry_offset = for_compiler_entry ? Method::from_compiled_offset() :
133                                                      Method::from_interpreted_offset();
134 
135   __ indirect_jump(Address(Rmethod, entry_offset), Rtemp);
136 
137   __ bind(L_no_such_method);
138   // throw exception
139   __ jump(StubRoutines::throw_AbstractMethodError_entry(), relocInfo::runtime_call_type, Rtemp);
140 }
141 
142 void MethodHandles::jump_to_lambda_form(MacroAssembler* _masm,
143                                         Register recv, Register tmp,
144                                         bool for_compiler_entry) {
145   BLOCK_COMMENT(&quot;jump_to_lambda_form {&quot;);
146   // This is the initial entry point of a lazy method handle.
147   // After type checking, it picks up the invoker from the LambdaForm.
148   assert_different_registers(recv, tmp, Rmethod);
149 
150   // Load the invoker, as MH -&gt; MH.form -&gt; LF.vmentry
<span class="line-modified">151   __ load_heap_oop(tmp, Address(recv, NONZERO(java_lang_invoke_MethodHandle::form_offset())));</span>
152   __ verify_oop(tmp);
153 
<span class="line-modified">154   __ load_heap_oop(tmp, Address(tmp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset())));</span>
155   __ verify_oop(tmp);
156 
<span class="line-modified">157   __ load_heap_oop(Rmethod, Address(tmp, NONZERO(java_lang_invoke_MemberName::method_offset())));</span>
158   __ verify_oop(Rmethod);
<span class="line-modified">159   __ access_load_at(T_ADDRESS, IN_HEAP, Address(Rmethod, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset())), Rmethod, noreg, noreg, noreg);</span>
160 
161   if (VerifyMethodHandles &amp;&amp; !for_compiler_entry) {
162     // make sure recv is already on stack
163     __ ldr(tmp, Address(Rmethod, Method::const_offset()));
164     __ load_sized_value(tmp,
165                         Address(tmp, ConstMethod::size_of_parameters_offset()),
166                         sizeof(u2), /*is_signed*/ false);
167     // assert(sizeof(u2) == sizeof(Method::_size_of_parameters), &quot;&quot;);
168     Label L;
169     __ ldr(tmp, __ receiver_argument_address(Rparams, tmp, tmp));
170     __ cmpoop(tmp, recv);
171     __ b(L, eq);
172     __ stop(&quot;receiver not on stack&quot;);
173     __ bind(L);
174   }
175 
176   jump_from_method_handle(_masm, for_compiler_entry);
177   BLOCK_COMMENT(&quot;} jump_to_lambda_form&quot;);
178 }
179 
</pre>
<hr />
<pre>
288     assert_different_registers(temp3, j_rarg0, j_rarg1, j_rarg2, j_rarg3);
289     assert_different_registers(temp4, j_rarg0, j_rarg1, j_rarg2, j_rarg3);
290   }
291   assert_different_registers(temp1, temp2, temp3, receiver_reg);
292   assert_different_registers(temp1, temp2, temp3, temp4, member_reg);
293   if (!for_compiler_entry)
294     assert_different_registers(temp1, temp2, temp3, temp4, saved_last_sp_register());  // don&#39;t trash lastSP
295 
296   if (iid == vmIntrinsics::_invokeBasic) {
297     // indirect through MH.form.exactInvoker.vmtarget
298     jump_to_lambda_form(_masm, receiver_reg, temp3, for_compiler_entry);
299 
300   } else {
301     // The method is a member invoker used by direct method handles.
302     if (VerifyMethodHandles) {
303       // make sure the trailing argument really is a MemberName (caller responsibility)
304       verify_klass(_masm, member_reg, temp2, temp3, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_invoke_MemberName),
305                    &quot;MemberName required for invokeVirtual etc.&quot;);
306     }
307 
<span class="line-modified">308     Address member_clazz(   member_reg, NONZERO(java_lang_invoke_MemberName::clazz_offset()));</span>
<span class="line-modified">309     Address member_vmindex( member_reg, NONZERO(java_lang_invoke_MemberName::vmindex_offset()));</span>
<span class="line-modified">310     Address member_vmtarget(member_reg, NONZERO(java_lang_invoke_MemberName::method_offset()));</span>
<span class="line-modified">311     Address vmtarget_method(Rmethod, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset()));</span>
312 
313     Register temp1_recv_klass = temp1;
314     if (iid != vmIntrinsics::_linkToStatic) {
315       if (iid == vmIntrinsics::_linkToSpecial) {
316         // Don&#39;t actually load the klass; just null-check the receiver.
317         __ null_check(receiver_reg, temp3);
318       } else {
319         // load receiver klass itself
320         __ null_check(receiver_reg, temp3, oopDesc::klass_offset_in_bytes());
321         __ load_klass(temp1_recv_klass, receiver_reg);
322         __ verify_klass_ptr(temp1_recv_klass);
323       }
324       BLOCK_COMMENT(&quot;check_receiver {&quot;);
325       // The receiver for the MemberName must be in receiver_reg.
326       // Check the receiver against the MemberName.clazz
327       if (VerifyMethodHandles &amp;&amp; iid == vmIntrinsics::_linkToSpecial) {
328         // Did not load it above...
329         __ load_klass(temp1_recv_klass, receiver_reg);
330         __ verify_klass_ptr(temp1_recv_klass);
331       }
</pre>
<hr />
<pre>
515       intptr_t* dump_fp = (intptr_t *) saved_bp;
516       address dump_pc = (address) saved_regs[trace_mh_nregs-2]; // LR (with LR,PC last in saved_regs)
517       frame dump_frame((intptr_t *)entry_sp, dump_fp, dump_pc);
518 
519       dump_frame.describe(values, 1);
520       // mark Rsender_sp if seems valid
521       if (has_mh) {
522         if ((saved_sp &gt;= entry_sp - UNREASONABLE_STACK_MOVE) &amp;&amp; (saved_sp &lt; dump_fp)) {
523           values.describe(-1, saved_sp, &quot;*Rsender_sp&quot;);
524         }
525       }
526 
527       // Note: the unextended_sp may not be correct
528       tty-&gt;print_cr(&quot;  stack layout:&quot;);
529       values.print(p);
530     }
531 
532     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
533       mh-&gt;print();
534       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
<span class="line-modified">535         java_lang_invoke_MethodHandle::form(mh)-&gt;print();</span>


536       }
537     }
538   }
539 }
540 
541 void MethodHandles::trace_method_handle(MacroAssembler* _masm, const char* adaptername) {
542   if (!log_is_enabled(Info, methodhandles))  return;
543   BLOCK_COMMENT(&quot;trace_method_handle {&quot;);
544   // register saving
545   //  must correspond to trace_mh_nregs and trace_mh_regs defined above
546   int push_size = __ save_all_registers();
547   assert(trace_mh_nregs*wordSize == push_size,&quot;saved register count mismatch&quot;);
548 
549   __ mov_slow(R0, adaptername);
550   __ mov(R1, SP); // entry_sp (after pushes)
551   __ mov(R2, FP);
552   if (R5_mh != R3) {
553     assert_different_registers(R0, R1, R2, R5_mh);
554     __ mov(R3, R5_mh);
555   }
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRGenerator_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateInterpreterGenerator_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
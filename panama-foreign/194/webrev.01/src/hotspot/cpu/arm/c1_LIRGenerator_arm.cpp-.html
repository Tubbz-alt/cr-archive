<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/arm/c1_LIRGenerator_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.inline.hpp&quot;
  27 #include &quot;c1/c1_Compilation.hpp&quot;
  28 #include &quot;c1/c1_FrameMap.hpp&quot;
  29 #include &quot;c1/c1_Instruction.hpp&quot;
  30 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  31 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  32 #include &quot;c1/c1_Runtime1.hpp&quot;
  33 #include &quot;c1/c1_ValueStack.hpp&quot;
  34 #include &quot;ci/ciArray.hpp&quot;
  35 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  36 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  37 #include &quot;ci/ciUtilities.hpp&quot;
  38 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  39 #include &quot;gc/shared/cardTable.hpp&quot;
  40 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
  42 #include &quot;runtime/stubRoutines.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 #include &quot;vmreg_arm.inline.hpp&quot;
  45 
  46 #ifdef ASSERT
  47 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  48 #else
  49 #define __ gen()-&gt;lir()-&gt;
  50 #endif
  51 
  52 void LIRItem::load_byte_item() {
  53   load_item();
  54 }
  55 
  56 void LIRItem::load_nonconstant() {
  57   LIR_Opr r = value()-&gt;operand();
  58   if (_gen-&gt;can_inline_as_constant(value())) {
  59     if (!r-&gt;is_constant()) {
  60       r = LIR_OprFact::value_type(value()-&gt;type());
  61     }
  62     _result = r;
  63   } else {
  64     load_item();
  65   }
  66 }
  67 
  68 //--------------------------------------------------------------
  69 //               LIRGenerator
  70 //--------------------------------------------------------------
  71 
  72 
  73 LIR_Opr LIRGenerator::exceptionOopOpr() {
  74   return FrameMap::Exception_oop_opr;
  75 }
  76 
  77 LIR_Opr LIRGenerator::exceptionPcOpr()  {
  78   return FrameMap::Exception_pc_opr;
  79 }
  80 
  81 LIR_Opr LIRGenerator::syncLockOpr()     {
  82   return new_register(T_INT);
  83 }
  84 
  85 LIR_Opr LIRGenerator::syncTempOpr()     {
  86   return new_register(T_OBJECT);
  87 }
  88 
  89 LIR_Opr LIRGenerator::getThreadTemp()   {
  90   return LIR_OprFact::illegalOpr;
  91 }
  92 
  93 LIR_Opr LIRGenerator::atomicLockOpr() {
  94   return LIR_OprFact::illegalOpr;
  95 }
  96 
  97 LIR_Opr LIRGenerator::result_register_for(ValueType* type, bool callee) {
  98   LIR_Opr opr;
  99   switch (type-&gt;tag()) {
 100     case intTag:     opr = FrameMap::Int_result_opr;    break;
 101     case objectTag:  opr = FrameMap::Object_result_opr; break;
 102     case longTag:    opr = FrameMap::Long_result_opr;   break;
 103     case floatTag:   opr = FrameMap::Float_result_opr;  break;
 104     case doubleTag:  opr = FrameMap::Double_result_opr; break;
 105     case addressTag:
 106     default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
 107   }
 108   assert(opr-&gt;type_field() == as_OprType(as_BasicType(type)), &quot;type mismatch&quot;);
 109   return opr;
 110 }
 111 
 112 
 113 LIR_Opr LIRGenerator::rlock_byte(BasicType type) {
 114   return new_register(T_INT);
 115 }
 116 
 117 
 118 //--------- loading items into registers --------------------------------
 119 
 120 
 121 bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {
 122   return false;
 123 }
 124 
 125 
 126 bool LIRGenerator::can_inline_as_constant(Value v) const {
 127   if (v-&gt;type()-&gt;as_IntConstant() != NULL) {
 128     return Assembler::is_arith_imm_in_range(v-&gt;type()-&gt;as_IntConstant()-&gt;value());
 129   } else if (v-&gt;type()-&gt;as_ObjectConstant() != NULL) {
 130     return v-&gt;type()-&gt;as_ObjectConstant()-&gt;value()-&gt;is_null_object();
 131   } else if (v-&gt;type()-&gt;as_FloatConstant() != NULL) {
 132     return v-&gt;type()-&gt;as_FloatConstant()-&gt;value() == 0.0f;
 133   } else if (v-&gt;type()-&gt;as_DoubleConstant() != NULL) {
 134     return v-&gt;type()-&gt;as_DoubleConstant()-&gt;value() == 0.0;
 135   }
 136   return false;
 137 }
 138 
 139 
 140 bool LIRGenerator::can_inline_as_constant(LIR_Const* c) const {
 141   ShouldNotCallThis(); // Not used on ARM
 142   return false;
 143 }
 144 
 145 
 146 
 147 
 148 LIR_Opr LIRGenerator::safepoint_poll_register() {
 149   return LIR_OprFact::illegalOpr;
 150 }
 151 
 152 
 153 static LIR_Opr make_constant(BasicType type, jlong c) {
 154   switch (type) {
 155     case T_ADDRESS:
 156     case T_OBJECT:  return LIR_OprFact::intptrConst(c);
 157     case T_LONG:    return LIR_OprFact::longConst(c);
 158     case T_INT:     return LIR_OprFact::intConst(c);
 159     default: ShouldNotReachHere();
 160     return LIR_OprFact::intConst(-1);
 161   }
 162 }
 163 
 164 
 165 
 166 void LIRGenerator::add_large_constant(LIR_Opr src, int c, LIR_Opr dest) {
 167   assert(c != 0, &quot;must be&quot;);
 168   // Find first non-zero bit
 169   int shift = 0;
 170   while ((c &amp; (3 &lt;&lt; shift)) == 0) {
 171     shift += 2;
 172   }
 173   // Add the least significant part of the constant
 174   int mask = 0xff &lt;&lt; shift;
 175   __ add(src, LIR_OprFact::intConst(c &amp; mask), dest);
 176   // Add up to 3 other parts of the constant;
 177   // each of them can be represented as rotated_imm
 178   if (c &amp; (mask &lt;&lt; 8)) {
 179     __ add(dest, LIR_OprFact::intConst(c &amp; (mask &lt;&lt; 8)), dest);
 180   }
 181   if (c &amp; (mask &lt;&lt; 16)) {
 182     __ add(dest, LIR_OprFact::intConst(c &amp; (mask &lt;&lt; 16)), dest);
 183   }
 184   if (c &amp; (mask &lt;&lt; 24)) {
 185     __ add(dest, LIR_OprFact::intConst(c &amp; (mask &lt;&lt; 24)), dest);
 186   }
 187 }
 188 
 189 static LIR_Address* make_address(LIR_Opr base, LIR_Opr index, LIR_Address::Scale scale, BasicType type) {
 190   return new LIR_Address(base, index, scale, 0, type);
 191 }
 192 
 193 LIR_Address* LIRGenerator::generate_address(LIR_Opr base, LIR_Opr index,
 194                                             int shift, int disp, BasicType type) {
 195   assert(base-&gt;is_register(), &quot;must be&quot;);
 196 
 197   if (index-&gt;is_constant()) {
 198     disp += index-&gt;as_constant_ptr()-&gt;as_jint() &lt;&lt; shift;
 199     index = LIR_OprFact::illegalOpr;
 200   }
 201 
 202   if (base-&gt;type() == T_LONG) {
 203     LIR_Opr tmp = new_register(T_INT);
 204     __ convert(Bytecodes::_l2i, base, tmp);
 205     base = tmp;
 206   }
 207   if (index != LIR_OprFact::illegalOpr &amp;&amp; index-&gt;type() == T_LONG) {
 208     LIR_Opr tmp = new_register(T_INT);
 209     __ convert(Bytecodes::_l2i, index, tmp);
 210     index = tmp;
 211   }
 212   // At this point base and index should be all ints and not constants
 213   assert(base-&gt;is_single_cpu() &amp;&amp; !base-&gt;is_constant(), &quot;base should be an non-constant int&quot;);
 214   assert(index-&gt;is_illegal() || (index-&gt;type() == T_INT &amp;&amp; !index-&gt;is_constant()), &quot;index should be an non-constant int&quot;);
 215 
 216   int max_disp;
 217   bool disp_is_in_range;
 218   bool embedded_shift;
 219 
 220   switch (type) {
 221     case T_BYTE:
 222     case T_SHORT:
 223     case T_CHAR:
 224       max_disp = 256;          // ldrh, ldrsb encoding has 8-bit offset
 225       embedded_shift = false;
 226       break;
 227     case T_FLOAT:
 228     case T_DOUBLE:
 229       max_disp = 1024;         // flds, fldd have 8-bit offset multiplied by 4
 230       embedded_shift = false;
 231       break;
 232     case T_LONG:
 233       max_disp = 4096;
 234       embedded_shift = false;
 235       break;
 236     default:
 237       max_disp = 4096;         // ldr, ldrb allow 12-bit offset
 238       embedded_shift = true;
 239   }
 240 
 241   disp_is_in_range = (-max_disp &lt; disp &amp;&amp; disp &lt; max_disp);
 242 
 243   if (index-&gt;is_register()) {
 244     LIR_Opr tmp = new_pointer_register();
 245     if (!disp_is_in_range) {
 246       add_large_constant(base, disp, tmp);
 247       base = tmp;
 248       disp = 0;
 249     }
 250     LIR_Address* addr = make_address(base, index, (LIR_Address::Scale)shift, type);
 251     if (disp == 0 &amp;&amp; embedded_shift) {
 252       // can use ldr/str instruction with register index
 253       return addr;
 254     } else {
 255       LIR_Opr tmp = new_pointer_register();
 256       __ add(base, LIR_OprFact::address(addr), tmp); // add with shifted/extended register
 257       return new LIR_Address(tmp, disp, type);
 258     }
 259   }
 260 
 261   // If the displacement is too large to be inlined into LDR instruction,
 262   // generate large constant with additional sequence of ADD instructions
 263   int excess_disp = disp &amp; ~(max_disp - 1);
 264   if (excess_disp != 0) {
 265     LIR_Opr tmp = new_pointer_register();
 266     add_large_constant(base, excess_disp, tmp);
 267     base = tmp;
 268   }
 269   return new LIR_Address(base, disp &amp; (max_disp - 1), type);
 270 }
 271 
 272 
 273 LIR_Address* LIRGenerator::emit_array_address(LIR_Opr array_opr, LIR_Opr index_opr, BasicType type) {
 274   int base_offset = arrayOopDesc::base_offset_in_bytes(type);
 275   int elem_size = type2aelembytes(type);
 276 
 277   if (index_opr-&gt;is_constant()) {
 278     int offset = base_offset + index_opr-&gt;as_constant_ptr()-&gt;as_jint() * elem_size;
 279     return generate_address(array_opr, offset, type);
 280   } else {
 281     assert(index_opr-&gt;is_register(), &quot;must be&quot;);
 282     int scale = exact_log2(elem_size);
 283     return generate_address(array_opr, index_opr, scale, base_offset, type);
 284   }
 285 }
 286 
 287 
 288 LIR_Opr LIRGenerator::load_immediate(int x, BasicType type) {
 289   assert(type == T_LONG || type == T_INT, &quot;should be&quot;);
 290   LIR_Opr r = make_constant(type, x);
 291   bool imm_in_range = AsmOperand::is_rotated_imm(x);
 292   if (!imm_in_range) {
 293     LIR_Opr tmp = new_register(type);
 294     __ move(r, tmp);
 295     return tmp;
 296   }
 297   return r;
 298 }
 299 
 300 
 301 void LIRGenerator::increment_counter(address counter, BasicType type, int step) {
 302   LIR_Opr pointer = new_pointer_register();
 303   __ move(LIR_OprFact::intptrConst(counter), pointer);
 304   LIR_Address* addr = new LIR_Address(pointer, type);
 305   increment_counter(addr, step);
 306 }
 307 
 308 
 309 void LIRGenerator::increment_counter(LIR_Address* addr, int step) {
 310   LIR_Opr temp = new_register(addr-&gt;type());
 311   __ move(addr, temp);
 312   __ add(temp, make_constant(addr-&gt;type(), step), temp);
 313   __ move(temp, addr);
 314 }
 315 
 316 
 317 void LIRGenerator::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
 318   __ load(new LIR_Address(base, disp, T_INT), FrameMap::LR_opr, info);
 319   __ cmp(condition, FrameMap::LR_opr, c);
 320 }
 321 
 322 
 323 void LIRGenerator::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Opr base, int disp, BasicType type, CodeEmitInfo* info) {
 324   __ load(new LIR_Address(base, disp, type), FrameMap::LR_opr, info);
 325   __ cmp(condition, reg, FrameMap::LR_opr);
 326 }
 327 
 328 
 329 bool LIRGenerator::strength_reduce_multiply(LIR_Opr left, int c, LIR_Opr result, LIR_Opr tmp) {
 330   assert(left != result, &quot;should be different registers&quot;);
 331   if (is_power_of_2(c + 1)) {
 332     LIR_Address::Scale scale = (LIR_Address::Scale) log2_intptr(c + 1);
 333     LIR_Address* addr = new LIR_Address(left, left, scale, 0, T_INT);
 334     __ sub(LIR_OprFact::address(addr), left, result); // rsb with shifted register
 335     return true;
 336   } else if (is_power_of_2(c - 1)) {
 337     LIR_Address::Scale scale = (LIR_Address::Scale) log2_intptr(c - 1);
 338     LIR_Address* addr = new LIR_Address(left, left, scale, 0, T_INT);
 339     __ add(left, LIR_OprFact::address(addr), result); // add with shifted register
 340     return true;
 341   }
 342   return false;
 343 }
 344 
 345 
 346 void LIRGenerator::store_stack_parameter(LIR_Opr item, ByteSize offset_from_sp) {
 347   assert(item-&gt;type() == T_INT, &quot;other types are not expected&quot;);
 348   __ store(item, new LIR_Address(FrameMap::SP_opr, in_bytes(offset_from_sp), item-&gt;type()));
 349 }
 350 
 351 void LIRGenerator::set_card(LIR_Opr value, LIR_Address* card_addr) {
 352   assert(CardTable::dirty_card_val() == 0,
 353     &quot;Cannot use the register containing the card table base address directly&quot;);
 354   if((ci_card_table_address_as&lt;intx&gt;() &amp; 0xff) == 0) {
 355     // If the card table base address is aligned to 256 bytes, we can use the register
 356     // that contains the card_table_base_address.
 357     __ move(value, card_addr);
 358   } else {
 359     // Otherwise we need to create a register containing that value.
 360     LIR_Opr tmp_zero = new_register(T_INT);
 361     __ move(LIR_OprFact::intConst(CardTable::dirty_card_val()), tmp_zero);
 362     __ move(tmp_zero, card_addr);
 363   }
 364 }
 365 
 366 void LIRGenerator::CardTableBarrierSet_post_barrier_helper(LIR_OprDesc* addr, LIR_Const* card_table_base) {
 367   assert(addr-&gt;is_register(), &quot;must be a register at this point&quot;);
 368 
 369   CardTableBarrierSet* ctbs = barrier_set_cast&lt;CardTableBarrierSet&gt;(BarrierSet::barrier_set());
 370   CardTable* ct = ctbs-&gt;card_table();
 371 
 372   LIR_Opr tmp = FrameMap::LR_ptr_opr;
 373 
 374   bool load_card_table_base_const = VM_Version::supports_movw();
 375   if (load_card_table_base_const) {
 376     __ move((LIR_Opr)card_table_base, tmp);
 377   } else {
 378     __ move(new LIR_Address(FrameMap::Rthread_opr, in_bytes(JavaThread::card_table_base_offset()), T_ADDRESS), tmp);
 379   }
 380 
 381   // Use unsigned type T_BOOLEAN here rather than (signed) T_BYTE since signed load
 382   // byte instruction does not support the addressing mode we need.
 383   LIR_Address* card_addr = new LIR_Address(tmp, addr, (LIR_Address::Scale) -CardTable::card_shift, 0, T_BOOLEAN);
 384   if (UseCondCardMark) {
 385     if (ct-&gt;scanned_concurrently()) {
 386       __ membar_storeload();
 387     }
 388     LIR_Opr cur_value = new_register(T_INT);
 389     __ move(card_addr, cur_value);
 390 
 391     LabelObj* L_already_dirty = new LabelObj();
 392     __ cmp(lir_cond_equal, cur_value, LIR_OprFact::intConst(CardTable::dirty_card_val()));
 393     __ branch(lir_cond_equal, T_BYTE, L_already_dirty-&gt;label());
 394     set_card(tmp, card_addr);
 395     __ branch_destination(L_already_dirty-&gt;label());
 396   } else {
 397     if (ct-&gt;scanned_concurrently()) {
 398       __ membar_storestore();
 399     }
 400     set_card(tmp, card_addr);
 401   }
 402 }
 403 
 404 void LIRGenerator::array_store_check(LIR_Opr value, LIR_Opr array, CodeEmitInfo* store_check_info, ciMethod* profiled_method, int profiled_bci) {
 405   LIR_Opr tmp1 = FrameMap::R0_oop_opr;
 406   LIR_Opr tmp2 = FrameMap::R1_oop_opr;
 407   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
 408   __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);
 409 }
 410 
 411 //----------------------------------------------------------------------
 412 //             visitor functions
 413 //----------------------------------------------------------------------
 414 
 415 void LIRGenerator::do_MonitorEnter(MonitorEnter* x) {
 416   assert(x-&gt;is_pinned(),&quot;&quot;);
 417   LIRItem obj(x-&gt;obj(), this);
 418   obj.load_item();
 419   set_no_result(x);
 420 
 421   LIR_Opr lock = new_pointer_register();
 422   LIR_Opr hdr  = new_pointer_register();
 423 
 424   // Need a scratch register for biased locking on arm
 425   LIR_Opr scratch = LIR_OprFact::illegalOpr;
 426   if(UseBiasedLocking) {
 427     scratch = new_pointer_register();
 428   } else {
 429     scratch = atomicLockOpr();
 430   }
 431 
 432   CodeEmitInfo* info_for_exception = NULL;
 433   if (x-&gt;needs_null_check()) {
 434     info_for_exception = state_for(x);
 435   }
 436 
 437   CodeEmitInfo* info = state_for(x, x-&gt;state(), true);
 438   monitor_enter(obj.result(), lock, hdr, scratch,
 439                 x-&gt;monitor_no(), info_for_exception, info);
 440 }
 441 
 442 
 443 void LIRGenerator::do_MonitorExit(MonitorExit* x) {
 444   assert(x-&gt;is_pinned(),&quot;&quot;);
 445   LIRItem obj(x-&gt;obj(), this);
 446   obj.dont_load_item();
 447   set_no_result(x);
 448 
 449   LIR_Opr obj_temp = new_pointer_register();
 450   LIR_Opr lock     = new_pointer_register();
 451   LIR_Opr hdr      = new_pointer_register();
 452 
 453   monitor_exit(obj_temp, lock, hdr, atomicLockOpr(), x-&gt;monitor_no());
 454 }
 455 
 456 
 457 // _ineg, _lneg, _fneg, _dneg
 458 void LIRGenerator::do_NegateOp(NegateOp* x) {
 459 #ifdef __SOFTFP__
 460   address runtime_func = NULL;
 461   ValueTag tag = x-&gt;type()-&gt;tag();
 462   if (tag == floatTag) {
 463     runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::fneg);
 464   } else if (tag == doubleTag) {
 465     runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::dneg);
 466   }
 467   if (runtime_func != NULL) {
 468     set_result(x, call_runtime(x-&gt;x(), runtime_func, x-&gt;type(), NULL));
 469     return;
 470   }
 471 #endif // __SOFTFP__
 472   LIRItem value(x-&gt;x(), this);
 473   value.load_item();
 474   LIR_Opr reg = rlock_result(x);
 475   __ negate(value.result(), reg);
 476 }
 477 
 478 
 479 // for  _fadd, _fmul, _fsub, _fdiv, _frem
 480 //      _dadd, _dmul, _dsub, _ddiv, _drem
 481 void LIRGenerator::do_ArithmeticOp_FPU(ArithmeticOp* x) {
 482   address runtime_func;
 483   switch (x-&gt;op()) {
 484     case Bytecodes::_frem:
 485       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::frem);
 486       break;
 487     case Bytecodes::_drem:
 488       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::drem);
 489       break;
 490 #ifdef __SOFTFP__
 491     // Call function compiled with -msoft-float.
 492 
 493       // __aeabi_XXXX_glibc: Imported code from glibc soft-fp bundle for calculation accuracy improvement. See CR 6757269.
 494 
 495     case Bytecodes::_fadd:
 496       runtime_func = CAST_FROM_FN_PTR(address, __aeabi_fadd_glibc);
 497       break;
 498     case Bytecodes::_fmul:
 499       runtime_func = CAST_FROM_FN_PTR(address, __aeabi_fmul);
 500       break;
 501     case Bytecodes::_fsub:
 502       runtime_func = CAST_FROM_FN_PTR(address, __aeabi_fsub_glibc);
 503       break;
 504     case Bytecodes::_fdiv:
 505       runtime_func = CAST_FROM_FN_PTR(address, __aeabi_fdiv);
 506       break;
 507     case Bytecodes::_dadd:
 508       runtime_func = CAST_FROM_FN_PTR(address, __aeabi_dadd_glibc);
 509       break;
 510     case Bytecodes::_dmul:
 511       runtime_func = CAST_FROM_FN_PTR(address, __aeabi_dmul);
 512       break;
 513     case Bytecodes::_dsub:
 514       runtime_func = CAST_FROM_FN_PTR(address, __aeabi_dsub_glibc);
 515       break;
 516     case Bytecodes::_ddiv:
 517       runtime_func = CAST_FROM_FN_PTR(address, __aeabi_ddiv);
 518       break;
 519     default:
 520       ShouldNotReachHere();
 521 #else // __SOFTFP__
 522     default: {
 523       LIRItem left(x-&gt;x(), this);
 524       LIRItem right(x-&gt;y(), this);
 525       left.load_item();
 526       right.load_item();
 527       rlock_result(x);
 528       arithmetic_op_fpu(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), x-&gt;is_strictfp());
 529       return;
 530     }
 531 #endif // __SOFTFP__
 532   }
 533 
 534   LIR_Opr result = call_runtime(x-&gt;x(), x-&gt;y(), runtime_func, x-&gt;type(), NULL);
 535   set_result(x, result);
 536 }
 537 
 538 
 539 void LIRGenerator::make_div_by_zero_check(LIR_Opr right_arg, BasicType type, CodeEmitInfo* info) {
 540   assert(right_arg-&gt;is_register(), &quot;must be&quot;);
 541   __ cmp(lir_cond_equal, right_arg, make_constant(type, 0));
 542   __ branch(lir_cond_equal, type, new DivByZeroStub(info));
 543 }
 544 
 545 
 546 // for  _ladd, _lmul, _lsub, _ldiv, _lrem
 547 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 548   CodeEmitInfo* info = NULL;
 549   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem) {
 550     info = state_for(x);
 551   }
 552 
 553   switch (x-&gt;op()) {
 554     case Bytecodes::_ldiv:
 555     case Bytecodes::_lrem: {
 556       LIRItem right(x-&gt;y(), this);
 557       right.load_item();
 558       make_div_by_zero_check(right.result(), T_LONG, info);
 559     }
 560     // Fall through
 561     case Bytecodes::_lmul: {
 562       address entry;
 563       switch (x-&gt;op()) {
 564       case Bytecodes::_lrem:
 565         entry = CAST_FROM_FN_PTR(address, SharedRuntime::lrem);
 566         break;
 567       case Bytecodes::_ldiv:
 568         entry = CAST_FROM_FN_PTR(address, SharedRuntime::ldiv);
 569         break;
 570       case Bytecodes::_lmul:
 571         entry = CAST_FROM_FN_PTR(address, SharedRuntime::lmul);
 572         break;
 573       default:
 574         ShouldNotReachHere();
 575         return;
 576       }
 577       LIR_Opr result = call_runtime(x-&gt;y(), x-&gt;x(), entry, x-&gt;type(), NULL);
 578       set_result(x, result);
 579       break;
 580     }
 581     case Bytecodes::_ladd:
 582     case Bytecodes::_lsub: {
 583       LIRItem left(x-&gt;x(), this);
 584       LIRItem right(x-&gt;y(), this);
 585       left.load_item();
 586       right.load_item();
 587       rlock_result(x);
 588       arithmetic_op_long(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), NULL);
 589       break;
 590     }
 591     default:
 592       ShouldNotReachHere();
 593   }
 594 }
 595 
 596 
 597 // for: _iadd, _imul, _isub, _idiv, _irem
 598 void LIRGenerator::do_ArithmeticOp_Int(ArithmeticOp* x) {
 599   bool is_div_rem = x-&gt;op() == Bytecodes::_idiv || x-&gt;op() == Bytecodes::_irem;
 600   LIRItem left(x-&gt;x(), this);
 601   LIRItem right(x-&gt;y(), this);
 602   LIRItem* left_arg = &amp;left;
 603   LIRItem* right_arg = &amp;right;
 604 
 605   // Test if instr is commutative and if we should swap
 606   if (x-&gt;is_commutative() &amp;&amp; left.is_constant()) {
 607     left_arg = &amp;right;
 608     right_arg = &amp;left;
 609   }
 610 
 611   if (is_div_rem) {
 612     CodeEmitInfo* info = state_for(x);
 613     if (x-&gt;op() == Bytecodes::_idiv &amp;&amp; right_arg-&gt;is_constant() &amp;&amp; is_power_of_2(right_arg-&gt;get_jint_constant())) {
 614       left_arg-&gt;load_item();
 615       right_arg-&gt;dont_load_item();
 616       LIR_Opr tmp = LIR_OprFact::illegalOpr;
 617       LIR_Opr result = rlock_result(x);
 618       __ idiv(left_arg-&gt;result(), right_arg-&gt;result(), result, tmp, info);
 619     } else {
 620       left_arg-&gt;load_item_force(FrameMap::R0_opr);
 621       right_arg-&gt;load_item_force(FrameMap::R2_opr);
 622       LIR_Opr tmp = FrameMap::R1_opr;
 623       LIR_Opr result = rlock_result(x);
 624       LIR_Opr out_reg;
 625       if (x-&gt;op() == Bytecodes::_irem) {
 626         out_reg = FrameMap::R0_opr;
 627         __ irem(left_arg-&gt;result(), right_arg-&gt;result(), out_reg, tmp, info);
 628       } else { // (x-&gt;op() == Bytecodes::_idiv)
 629         out_reg = FrameMap::R1_opr;
 630         __ idiv(left_arg-&gt;result(), right_arg-&gt;result(), out_reg, tmp, info);
 631       }
 632       __ move(out_reg, result);
 633     }
 634 
 635 
 636   } else {
 637     left_arg-&gt;load_item();
 638     if (x-&gt;op() == Bytecodes::_imul &amp;&amp; right_arg-&gt;is_constant()) {
 639       jint c = right_arg-&gt;get_jint_constant();
 640       if (c &gt; 0 &amp;&amp; c &lt; max_jint &amp;&amp; (is_power_of_2(c) || is_power_of_2(c - 1) || is_power_of_2(c + 1))) {
 641         right_arg-&gt;dont_load_item();
 642       } else {
 643         right_arg-&gt;load_item();
 644       }
 645     } else {
 646       right_arg-&gt;load_nonconstant();
 647     }
 648     rlock_result(x);
 649     assert(right_arg-&gt;is_constant() || right_arg-&gt;is_register(), &quot;wrong state of right&quot;);
 650     arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), NULL);
 651   }
 652 }
 653 
 654 
 655 void LIRGenerator::do_ArithmeticOp(ArithmeticOp* x) {
 656   ValueTag tag = x-&gt;type()-&gt;tag();
 657   assert(x-&gt;x()-&gt;type()-&gt;tag() == tag &amp;&amp; x-&gt;y()-&gt;type()-&gt;tag() == tag, &quot;wrong parameters&quot;);
 658   switch (tag) {
 659     case floatTag:
 660     case doubleTag:  do_ArithmeticOp_FPU(x);  return;
 661     case longTag:    do_ArithmeticOp_Long(x); return;
 662     case intTag:     do_ArithmeticOp_Int(x);  return;
 663     default:         ShouldNotReachHere();    return;
 664   }
 665 }
 666 
 667 
 668 // _ishl, _lshl, _ishr, _lshr, _iushr, _lushr
 669 void LIRGenerator::do_ShiftOp(ShiftOp* x) {
 670   LIRItem value(x-&gt;x(), this);
 671   LIRItem count(x-&gt;y(), this);
 672 
 673   if (value.type()-&gt;is_long()) {
 674     count.set_destroys_register();
 675   }
 676 
 677   if (count.is_constant()) {
 678     assert(count.type()-&gt;as_IntConstant() != NULL, &quot;should be&quot;);
 679     count.dont_load_item();
 680   } else {
 681     count.load_item();
 682   }
 683   value.load_item();
 684 
 685   LIR_Opr res = rlock_result(x);
 686   shift_op(x-&gt;op(), res, value.result(), count.result(), LIR_OprFact::illegalOpr);
 687 }
 688 
 689 
 690 // _iand, _land, _ior, _lor, _ixor, _lxor
 691 void LIRGenerator::do_LogicOp(LogicOp* x) {
 692   LIRItem left(x-&gt;x(), this);
 693   LIRItem right(x-&gt;y(), this);
 694 
 695   left.load_item();
 696 
 697   right.load_nonconstant();
 698 
 699   logic_op(x-&gt;op(), rlock_result(x), left.result(), right.result());
 700 }
 701 
 702 
 703 // _lcmp, _fcmpl, _fcmpg, _dcmpl, _dcmpg
 704 void LIRGenerator::do_CompareOp(CompareOp* x) {
 705 #ifdef __SOFTFP__
 706   address runtime_func;
 707   switch (x-&gt;op()) {
 708     case Bytecodes::_fcmpl:
 709       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::fcmpl);
 710       break;
 711     case Bytecodes::_fcmpg:
 712       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::fcmpg);
 713       break;
 714     case Bytecodes::_dcmpl:
 715       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::dcmpl);
 716       break;
 717     case Bytecodes::_dcmpg:
 718       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::dcmpg);
 719       break;
 720     case Bytecodes::_lcmp: {
 721         LIRItem left(x-&gt;x(), this);
 722         LIRItem right(x-&gt;y(), this);
 723         left.load_item();
 724         right.load_nonconstant();
 725         LIR_Opr reg = rlock_result(x);
 726          __ lcmp2int(left.result(), right.result(), reg);
 727         return;
 728       }
 729     default:
 730       ShouldNotReachHere();
 731   }
 732   LIR_Opr result = call_runtime(x-&gt;x(), x-&gt;y(), runtime_func, x-&gt;type(), NULL);
 733   set_result(x, result);
 734 #else // __SOFTFP__
 735   LIRItem left(x-&gt;x(), this);
 736   LIRItem right(x-&gt;y(), this);
 737   left.load_item();
 738 
 739   right.load_nonconstant();
 740 
 741   LIR_Opr reg = rlock_result(x);
 742 
 743   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 744     Bytecodes::Code code = x-&gt;op();
 745     __ fcmp2int(left.result(), right.result(), reg, (code == Bytecodes::_fcmpl || code == Bytecodes::_dcmpl));
 746   } else if (x-&gt;x()-&gt;type()-&gt;tag() == longTag) {
 747     __ lcmp2int(left.result(), right.result(), reg);
 748   } else {
 749     ShouldNotReachHere();
 750   }
 751 #endif // __SOFTFP__
 752 }
 753 
 754 LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 755   LIR_Opr ill = LIR_OprFact::illegalOpr;  // for convenience
 756   LIR_Opr tmp1 = LIR_OprFact::illegalOpr;
 757   LIR_Opr tmp2 = LIR_OprFact::illegalOpr;
 758   new_value.load_item();
 759   cmp_value.load_item();
 760   LIR_Opr result = new_register(T_INT);
 761   if (type == T_OBJECT || type == T_ARRAY) {
 762     __ cas_obj(addr, cmp_value.result(), new_value.result(), new_register(T_INT), new_register(T_INT), result);
 763   } else if (type == T_INT) {
 764     __ cas_int(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), tmp1, tmp1, result);
 765   } else if (type == T_LONG) {
 766     tmp1 = new_register(T_LONG);
 767     __ cas_long(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), tmp1, tmp2, result);
 768   } else {
 769     ShouldNotReachHere();
 770   }
 771   return result;
 772 }
 773 
 774 LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 775   bool is_oop = type == T_OBJECT || type == T_ARRAY;
 776   LIR_Opr result = new_register(type);
 777   value.load_item();
 778   assert(type == T_INT || is_oop || (type == T_LONG &amp;&amp; VM_Version::supports_ldrexd()), &quot;unexpected type&quot;);
 779   LIR_Opr tmp = (UseCompressedOops &amp;&amp; is_oop) ? new_pointer_register() : LIR_OprFact::illegalOpr;
 780   __ xchg(addr, value.result(), result, tmp);
 781   return result;
 782 }
 783 
 784 LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 785   LIR_Opr result = new_register(type);
 786   value.load_item();
 787   assert(type == T_INT || (type == T_LONG &amp;&amp; VM_Version::supports_ldrexd ()), &quot;unexpected type&quot;);
 788   LIR_Opr tmp = new_register(type);
 789   __ xadd(addr, value.result(), result, tmp);
 790   return result;
 791 }
 792 
 793 void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {
 794   address runtime_func;
 795   switch (x-&gt;id()) {
 796     case vmIntrinsics::_dabs: {
 797 #ifdef __SOFTFP__
 798       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::dabs);
 799       break;
 800 #else
 801       assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
 802       LIRItem value(x-&gt;argument_at(0), this);
 803       value.load_item();
 804       __ abs(value.result(), rlock_result(x), LIR_OprFact::illegalOpr);
 805       return;
 806 #endif // __SOFTFP__
 807     }
 808     case vmIntrinsics::_dsqrt: {
 809 #ifdef __SOFTFP__
 810       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::dsqrt);
 811       break;
 812 #else
 813       assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
 814       LIRItem value(x-&gt;argument_at(0), this);
 815       value.load_item();
 816       __ sqrt(value.result(), rlock_result(x), LIR_OprFact::illegalOpr);
 817       return;
 818 #endif // __SOFTFP__
 819     }
 820     case vmIntrinsics::_dsin:
 821       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::dsin);
 822       break;
 823     case vmIntrinsics::_dcos:
 824       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::dcos);
 825       break;
 826     case vmIntrinsics::_dtan:
 827       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::dtan);
 828       break;
 829     case vmIntrinsics::_dlog:
 830       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::dlog);
 831       break;
 832     case vmIntrinsics::_dlog10:
 833       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::dlog10);
 834       break;
 835     case vmIntrinsics::_dexp:
 836       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::dexp);
 837       break;
 838     case vmIntrinsics::_dpow:
 839       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::dpow);
 840       break;
 841     default:
 842       ShouldNotReachHere();
 843       return;
 844   }
 845 
 846   LIR_Opr result;
 847   if (x-&gt;number_of_arguments() == 1) {
 848     result = call_runtime(x-&gt;argument_at(0), runtime_func, x-&gt;type(), NULL);
 849   } else {
 850     assert(x-&gt;number_of_arguments() == 2 &amp;&amp; x-&gt;id() == vmIntrinsics::_dpow, &quot;unexpected intrinsic&quot;);
 851     result = call_runtime(x-&gt;argument_at(0), x-&gt;argument_at(1), runtime_func, x-&gt;type(), NULL);
 852   }
 853   set_result(x, result);
 854 }
 855 
 856 void LIRGenerator::do_FmaIntrinsic(Intrinsic* x) {
 857   fatal(&quot;FMA intrinsic is not implemented on this platform&quot;);
 858 }
 859 
 860 void LIRGenerator::do_vectorizedMismatch(Intrinsic* x) {
 861   fatal(&quot;vectorizedMismatch intrinsic is not implemented on this platform&quot;);
 862 }
 863 
 864 void LIRGenerator::do_ArrayCopy(Intrinsic* x) {
 865   CodeEmitInfo* info = state_for(x, x-&gt;state());
 866   assert(x-&gt;number_of_arguments() == 5, &quot;wrong type&quot;);
 867   LIRItem src(x-&gt;argument_at(0), this);
 868   LIRItem src_pos(x-&gt;argument_at(1), this);
 869   LIRItem dst(x-&gt;argument_at(2), this);
 870   LIRItem dst_pos(x-&gt;argument_at(3), this);
 871   LIRItem length(x-&gt;argument_at(4), this);
 872 
 873   // We put arguments into the same registers which are used for a Java call.
 874   // Note: we used fixed registers for all arguments because all registers
 875   // are caller-saved, so register allocator treats them all as used.
 876   src.load_item_force    (FrameMap::R0_oop_opr);
 877   src_pos.load_item_force(FrameMap::R1_opr);
 878   dst.load_item_force    (FrameMap::R2_oop_opr);
 879   dst_pos.load_item_force(FrameMap::R3_opr);
 880   length.load_item_force (FrameMap::R4_opr);
 881   LIR_Opr tmp =          (FrameMap::R5_opr);
 882   set_no_result(x);
 883 
 884   int flags;
 885   ciArrayKlass* expected_type;
 886   arraycopy_helper(x, &amp;flags, &amp;expected_type);
 887   __ arraycopy(src.result(), src_pos.result(), dst.result(), dst_pos.result(), length.result(),
 888                tmp, expected_type, flags, info);
 889 }
 890 
 891 void LIRGenerator::do_update_CRC32(Intrinsic* x) {
 892   fatal(&quot;CRC32 intrinsic is not implemented on this platform&quot;);
 893 }
 894 
 895 void LIRGenerator::do_update_CRC32C(Intrinsic* x) {
 896   Unimplemented();
 897 }
 898 
 899 void LIRGenerator::do_Convert(Convert* x) {
 900   address runtime_func;
 901   switch (x-&gt;op()) {
 902     case Bytecodes::_l2f:
 903       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::l2f);
 904       break;
 905     case Bytecodes::_l2d:
 906       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::l2d);
 907       break;
 908     case Bytecodes::_f2l:
 909       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::f2l);
 910       break;
 911     case Bytecodes::_d2l:
 912       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::d2l);
 913       break;
 914 #ifdef __SOFTFP__
 915     case Bytecodes::_f2d:
 916       runtime_func = CAST_FROM_FN_PTR(address, __aeabi_f2d);
 917       break;
 918     case Bytecodes::_d2f:
 919       runtime_func = CAST_FROM_FN_PTR(address, __aeabi_d2f);
 920       break;
 921     case Bytecodes::_i2f:
 922       runtime_func = CAST_FROM_FN_PTR(address, __aeabi_i2f);
 923       break;
 924     case Bytecodes::_i2d:
 925       runtime_func = CAST_FROM_FN_PTR(address, __aeabi_i2d);
 926       break;
 927     case Bytecodes::_f2i:
 928       runtime_func = CAST_FROM_FN_PTR(address, __aeabi_f2iz);
 929       break;
 930     case Bytecodes::_d2i:
 931       // This is implemented in hard float in assembler on arm but a call
 932       // on other platforms.
 933       runtime_func = CAST_FROM_FN_PTR(address, SharedRuntime::d2i);
 934       break;
 935 #endif // __SOFTFP__
 936     default: {
 937       LIRItem value(x-&gt;value(), this);
 938       value.load_item();
 939       LIR_Opr reg = rlock_result(x);
 940       __ convert(x-&gt;op(), value.result(), reg, NULL);
 941       return;
 942     }
 943   }
 944 
 945   LIR_Opr result = call_runtime(x-&gt;value(), runtime_func, x-&gt;type(), NULL);
 946   set_result(x, result);
 947 }
 948 
 949 
 950 void LIRGenerator::do_NewInstance(NewInstance* x) {
 951   print_if_not_loaded(x);
 952 
 953   CodeEmitInfo* info = state_for(x, x-&gt;state());
 954   LIR_Opr reg = result_register_for(x-&gt;type());  // R0 is required by runtime call in NewInstanceStub::emit_code
 955   LIR_Opr klass_reg = FrameMap::R1_metadata_opr; // R1 is required by runtime call in NewInstanceStub::emit_code
 956   LIR_Opr tmp1 = new_register(objectType);
 957   LIR_Opr tmp2 = new_register(objectType);
 958   LIR_Opr tmp3 = FrameMap::LR_oop_opr;
 959 
 960   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(), tmp1, tmp2, tmp3,
 961                LIR_OprFact::illegalOpr, klass_reg, info);
 962 
 963   LIR_Opr result = rlock_result(x);
 964   __ move(reg, result);
 965 }
 966 
 967 
 968 void LIRGenerator::do_NewTypeArray(NewTypeArray* x) {
 969   // Evaluate state_for() first, because it can emit code
 970   // with the same fixed registers that are used here (R1, R2)
 971   CodeEmitInfo* info = state_for(x, x-&gt;state());
 972   LIRItem length(x-&gt;length(), this);
 973 
 974   length.load_item_force(FrameMap::R2_opr);      // R2 is required by runtime call in NewTypeArrayStub::emit_code
 975   LIR_Opr len = length.result();
 976 
 977   LIR_Opr reg = result_register_for(x-&gt;type());  // R0 is required by runtime call in NewTypeArrayStub::emit_code
 978   LIR_Opr klass_reg = FrameMap::R1_metadata_opr; // R1 is required by runtime call in NewTypeArrayStub::emit_code
 979 
 980   LIR_Opr tmp1 = new_register(objectType);
 981   LIR_Opr tmp2 = new_register(objectType);
 982   LIR_Opr tmp3 = FrameMap::LR_oop_opr;
 983   LIR_Opr tmp4 = LIR_OprFact::illegalOpr;
 984 
 985   BasicType elem_type = x-&gt;elt_type();
 986   __ metadata2reg(ciTypeArrayKlass::make(elem_type)-&gt;constant_encoding(), klass_reg);
 987 
 988   CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len, reg, info);
 989   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);
 990 
 991   LIR_Opr result = rlock_result(x);
 992   __ move(reg, result);
 993 }
 994 
 995 
 996 void LIRGenerator::do_NewObjectArray(NewObjectArray* x) {
 997   // Evaluate state_for() first, because it can emit code
 998   // with the same fixed registers that are used here (R1, R2)
 999   CodeEmitInfo* info = state_for(x, x-&gt;state());
1000   LIRItem length(x-&gt;length(), this);
1001 
1002   length.load_item_force(FrameMap::R2_opr);           // R2 is required by runtime call in NewObjectArrayStub::emit_code
1003   LIR_Opr len = length.result();
1004 
1005   CodeEmitInfo* patching_info = NULL;
1006   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1007     patching_info = state_for(x, x-&gt;state_before());
1008   }
1009 
1010   LIR_Opr reg = result_register_for(x-&gt;type());       // R0 is required by runtime call in NewObjectArrayStub::emit_code
1011   LIR_Opr klass_reg = FrameMap::R1_metadata_opr;      // R1 is required by runtime call in NewObjectArrayStub::emit_code
1012 
1013   LIR_Opr tmp1 = new_register(objectType);
1014   LIR_Opr tmp2 = new_register(objectType);
1015   LIR_Opr tmp3 = FrameMap::LR_oop_opr;
1016   LIR_Opr tmp4 = LIR_OprFact::illegalOpr;
1017 
1018   CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info);
1019   ciMetadata* obj = ciObjArrayKlass::make(x-&gt;klass());
1020   if (obj == ciEnv::unloaded_ciobjarrayklass()) {
1021     BAILOUT(&quot;encountered unloaded_ciobjarrayklass due to out of memory error&quot;);
1022   }
1023   klass2reg_with_patching(klass_reg, obj, patching_info);
1024   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);
1025 
1026   LIR_Opr result = rlock_result(x);
1027   __ move(reg, result);
1028 }
1029 
1030 
1031 void LIRGenerator::do_NewMultiArray(NewMultiArray* x) {
1032   Values* dims = x-&gt;dims();
1033   int i = dims-&gt;length();
1034   LIRItemList* items = new LIRItemList(i, i, NULL);
1035   while (i-- &gt; 0) {
1036     LIRItem* size = new LIRItem(dims-&gt;at(i), this);
1037     items-&gt;at_put(i, size);
1038   }
1039 
1040   // Need to get the info before, as the items may become invalid through item_free
1041   CodeEmitInfo* patching_info = NULL;
1042   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1043     patching_info = state_for(x, x-&gt;state_before());
1044 
1045     // Cannot re-use same xhandlers for multiple CodeEmitInfos, so
1046     // clone all handlers (NOTE: Usually this is handled transparently
1047     // by the CodeEmitInfo cloning logic in CodeStub constructors but
1048     // is done explicitly here because a stub isn&#39;t being used).
1049     x-&gt;set_exception_handlers(new XHandlers(x-&gt;exception_handlers()));
1050   }
1051 
1052   i = dims-&gt;length();
1053   while (i-- &gt; 0) {
1054     LIRItem* size = items-&gt;at(i);
1055     size-&gt;load_item();
1056     LIR_Opr sz = size-&gt;result();
1057     assert(sz-&gt;type() == T_INT, &quot;should be&quot;);
1058     store_stack_parameter(sz, in_ByteSize(i * BytesPerInt));
1059   }
1060 
1061   CodeEmitInfo* info = state_for(x, x-&gt;state());
1062   LIR_Opr klass_reg = FrameMap::R0_metadata_opr;
1063   klass2reg_with_patching(klass_reg, x-&gt;klass(), patching_info);
1064 
1065   LIR_Opr rank = FrameMap::R2_opr;
1066   __ move(LIR_OprFact::intConst(x-&gt;rank()), rank);
1067   LIR_Opr varargs = FrameMap::SP_opr;
1068   LIR_OprList* args = new LIR_OprList(3);
1069   args-&gt;append(klass_reg);
1070   args-&gt;append(rank);
1071   args-&gt;append(varargs);
1072   LIR_Opr reg = result_register_for(x-&gt;type());
1073   __ call_runtime(Runtime1::entry_for(Runtime1::new_multi_array_id),
1074                   LIR_OprFact::illegalOpr, reg, args, info);
1075 
1076   LIR_Opr result = rlock_result(x);
1077   __ move(reg, result);
1078 }
1079 
1080 
1081 void LIRGenerator::do_BlockBegin(BlockBegin* x) {
1082   // nothing to do for now
1083 }
1084 
1085 
1086 void LIRGenerator::do_CheckCast(CheckCast* x) {
1087   LIRItem obj(x-&gt;obj(), this);
1088   CodeEmitInfo* patching_info = NULL;
1089   if (!x-&gt;klass()-&gt;is_loaded() || (PatchALot &amp;&amp; !x-&gt;is_incompatible_class_change_check() &amp;&amp; !x-&gt;is_invokespecial_receiver_check())) {
1090     patching_info = state_for(x, x-&gt;state_before());
1091   }
1092 
1093   obj.load_item();
1094 
1095   CodeEmitInfo* info_for_exception =
1096     (x-&gt;needs_exception_state() ? state_for(x) :
1097                                   state_for(x, x-&gt;state_before(), true /*ignore_xhandler*/));
1098 
1099   CodeStub* stub;
1100   if (x-&gt;is_incompatible_class_change_check()) {
1101     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1102     stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id,
1103                                    LIR_OprFact::illegalOpr, info_for_exception);
1104   } else if (x-&gt;is_invokespecial_receiver_check()) {
1105     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1106     stub = new DeoptimizeStub(info_for_exception,
1107                               Deoptimization::Reason_class_check,
1108                               Deoptimization::Action_none);
1109   } else {
1110     stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id,
1111                                    LIR_OprFact::illegalOpr, info_for_exception);
1112   }
1113 
1114   LIR_Opr out_reg = rlock_result(x);
1115   LIR_Opr tmp1 = FrameMap::R0_oop_opr;
1116   LIR_Opr tmp2 = FrameMap::R1_oop_opr;
1117   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1118 
1119   __ checkcast(out_reg, obj.result(), x-&gt;klass(), tmp1, tmp2, tmp3, x-&gt;direct_compare(),
1120                info_for_exception, patching_info, stub, x-&gt;profiled_method(), x-&gt;profiled_bci());
1121 }
1122 
1123 
1124 void LIRGenerator::do_InstanceOf(InstanceOf* x) {
1125   LIRItem obj(x-&gt;obj(), this);
1126   CodeEmitInfo* patching_info = NULL;
1127   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1128     patching_info = state_for(x, x-&gt;state_before());
1129   }
1130 
1131   obj.load_item();
1132   LIR_Opr out_reg = rlock_result(x);
1133   LIR_Opr tmp1 = FrameMap::R0_oop_opr;
1134   LIR_Opr tmp2 = FrameMap::R1_oop_opr;
1135   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1136 
1137   __ instanceof(out_reg, obj.result(), x-&gt;klass(), tmp1, tmp2, tmp3,
1138                 x-&gt;direct_compare(), patching_info, x-&gt;profiled_method(), x-&gt;profiled_bci());
1139 }
1140 
1141 
1142 #ifdef __SOFTFP__
1143 // Turn operator if (f &lt;op&gt; g) into runtime call:
1144 //     call _aeabi_fcmp&lt;op&gt;(f, g)
1145 //     cmp(eq, 1)
1146 //     branch(eq, true path).
1147 void LIRGenerator::do_soft_float_compare(If* x) {
1148   assert(x-&gt;number_of_sux() == 2, &quot;inconsistency&quot;);
1149   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
1150   If::Condition cond = x-&gt;cond();
1151   address runtime_func;
1152   // unordered comparison gets the wrong answer because aeabi functions
1153   //  return false.
1154   bool unordered_is_true = x-&gt;unordered_is_true();
1155   // reverse of condition for ne
1156   bool compare_to_zero = false;
1157   switch (lir_cond(cond)) {
1158     case lir_cond_notEqual:
1159       compare_to_zero = true;  // fall through
1160     case lir_cond_equal:
1161       runtime_func = tag == floatTag ?
1162           CAST_FROM_FN_PTR(address, __aeabi_fcmpeq):
1163           CAST_FROM_FN_PTR(address, __aeabi_dcmpeq);
1164       break;
1165     case lir_cond_less:
1166       if (unordered_is_true) {
1167         runtime_func = tag == floatTag ?
1168           CAST_FROM_FN_PTR(address, SharedRuntime::unordered_fcmplt):
1169           CAST_FROM_FN_PTR(address, SharedRuntime::unordered_dcmplt);
1170       } else {
1171         runtime_func = tag == floatTag ?
1172           CAST_FROM_FN_PTR(address, __aeabi_fcmplt):
1173           CAST_FROM_FN_PTR(address, __aeabi_dcmplt);
1174       }
1175       break;
1176     case lir_cond_lessEqual:
1177       if (unordered_is_true) {
1178         runtime_func = tag == floatTag ?
1179           CAST_FROM_FN_PTR(address, SharedRuntime::unordered_fcmple):
1180           CAST_FROM_FN_PTR(address, SharedRuntime::unordered_dcmple);
1181       } else {
1182         runtime_func = tag == floatTag ?
1183           CAST_FROM_FN_PTR(address, __aeabi_fcmple):
1184           CAST_FROM_FN_PTR(address, __aeabi_dcmple);
1185       }
1186       break;
1187     case lir_cond_greaterEqual:
1188       if (unordered_is_true) {
1189         runtime_func = tag == floatTag ?
1190           CAST_FROM_FN_PTR(address, SharedRuntime::unordered_fcmpge):
1191           CAST_FROM_FN_PTR(address, SharedRuntime::unordered_dcmpge);
1192       } else {
1193         runtime_func = tag == floatTag ?
1194           CAST_FROM_FN_PTR(address, __aeabi_fcmpge):
1195           CAST_FROM_FN_PTR(address, __aeabi_dcmpge);
1196       }
1197       break;
1198     case lir_cond_greater:
1199       if (unordered_is_true) {
1200         runtime_func = tag == floatTag ?
1201           CAST_FROM_FN_PTR(address, SharedRuntime::unordered_fcmpgt):
1202           CAST_FROM_FN_PTR(address, SharedRuntime::unordered_dcmpgt);
1203       } else {
1204         runtime_func = tag == floatTag ?
1205           CAST_FROM_FN_PTR(address, __aeabi_fcmpgt):
1206           CAST_FROM_FN_PTR(address, __aeabi_dcmpgt);
1207       }
1208       break;
1209     case lir_cond_aboveEqual:
1210     case lir_cond_belowEqual:
1211       ShouldNotReachHere();  // We&#39;re not going to get these.
1212     default:
1213       assert(lir_cond(cond) == lir_cond_always, &quot;must be&quot;);
1214       ShouldNotReachHere();
1215   }
1216   set_no_result(x);
1217 
1218   // add safepoint before generating condition code so it can be recomputed
1219   if (x-&gt;is_safepoint()) {
1220     increment_backedge_counter(state_for(x, x-&gt;state_before()), x-&gt;profiled_bci());
1221     __ safepoint(LIR_OprFact::illegalOpr, state_for(x, x-&gt;state_before()));
1222   }
1223   // Call float compare function, returns (1,0) if true or false.
1224   LIR_Opr result = call_runtime(x-&gt;x(), x-&gt;y(), runtime_func, intType, NULL);
1225   __ cmp(lir_cond_equal, result,
1226          compare_to_zero ?
1227            LIR_OprFact::intConst(0) : LIR_OprFact::intConst(1));
1228   profile_branch(x, cond);
1229   move_to_phi(x-&gt;state());
1230   __ branch(lir_cond_equal, T_INT, x-&gt;tsux());
1231 }
1232 #endif // __SOFTFP__
1233 
1234 void LIRGenerator::do_If(If* x) {
1235   assert(x-&gt;number_of_sux() == 2, &quot;inconsistency&quot;);
1236   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
1237 
1238 #ifdef __SOFTFP__
1239   if (tag == floatTag || tag == doubleTag) {
1240     do_soft_float_compare(x);
1241     assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1242     __ jump(x-&gt;default_sux());
1243     return;
1244   }
1245 #endif // __SOFTFP__
1246 
1247   LIRItem xitem(x-&gt;x(), this);
1248   LIRItem yitem(x-&gt;y(), this);
1249   LIRItem* xin = &amp;xitem;
1250   LIRItem* yin = &amp;yitem;
1251   If::Condition cond = x-&gt;cond();
1252 
1253   if (tag == longTag) {
1254     if (cond == If::gtr || cond == If::leq) {
1255       cond = Instruction::mirror(cond);
1256       xin = &amp;yitem;
1257       yin = &amp;xitem;
1258     }
1259     xin-&gt;set_destroys_register();
1260   }
1261 
1262   xin-&gt;load_item();
1263   LIR_Opr left = xin-&gt;result();
1264   LIR_Opr right;
1265 
1266   if (tag == longTag &amp;&amp; yin-&gt;is_constant() &amp;&amp; yin-&gt;get_jlong_constant() == 0 &amp;&amp;
1267       (cond == If::eql || cond == If::neq)) {
1268     // inline long zero
1269     right = LIR_OprFact::value_type(yin-&gt;value()-&gt;type());
1270   } else {
1271     yin-&gt;load_nonconstant();
1272     right = yin-&gt;result();
1273   }
1274 
1275   set_no_result(x);
1276 
1277   // add safepoint before generating condition code so it can be recomputed
1278   if (x-&gt;is_safepoint()) {
1279     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1280         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1281     __ safepoint(LIR_OprFact::illegalOpr, state_for(x, x-&gt;state_before()));
1282   }
1283 
1284   __ cmp(lir_cond(cond), left, right);
1285   profile_branch(x, cond);
1286   move_to_phi(x-&gt;state());
1287   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
1288     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());
1289   } else {
1290     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());
1291   }
1292   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1293   __ jump(x-&gt;default_sux());
1294 }
1295 
1296 
1297 LIR_Opr LIRGenerator::getThreadPointer() {
1298   return FrameMap::Rthread_opr;
1299 }
1300 
1301 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1302   __ move(LIR_OprFact::intConst(block-&gt;block_id()), FrameMap::R0_opr);
1303   LIR_OprList* args = new LIR_OprList(1);
1304   args-&gt;append(FrameMap::R0_opr);
1305   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
1306   __ call_runtime_leaf(func, getThreadTemp(), LIR_OprFact::illegalOpr, args);
1307 }
1308 
1309 
1310 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1311                                         CodeEmitInfo* info) {
1312   if (value-&gt;is_double_cpu()) {
1313     assert(address-&gt;index()-&gt;is_illegal(), &quot;should have a constant displacement&quot;);
1314     LIR_Address* store_addr = NULL;
1315     if (address-&gt;disp() != 0) {
1316       LIR_Opr tmp = new_pointer_register();
1317       add_large_constant(address-&gt;base(), address-&gt;disp(), tmp);
1318       store_addr = new LIR_Address(tmp, (intx)0, address-&gt;type());
1319     } else {
1320       // address-&gt;disp() can be 0, if the address is referenced using the unsafe intrinsic
1321       store_addr = address;
1322     }
1323     __ volatile_store_mem_reg(value, store_addr, info);
1324     return;
1325   }
1326   __ store(value, address, info, lir_patch_none);
1327 }
1328 
1329 void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
1330                                        CodeEmitInfo* info) {
1331   if (result-&gt;is_double_cpu()) {
1332     assert(address-&gt;index()-&gt;is_illegal(), &quot;should have a constant displacement&quot;);
1333     LIR_Address* load_addr = NULL;
1334     if (address-&gt;disp() != 0) {
1335       LIR_Opr tmp = new_pointer_register();
1336       add_large_constant(address-&gt;base(), address-&gt;disp(), tmp);
1337       load_addr = new LIR_Address(tmp, (intx)0, address-&gt;type());
1338     } else {
1339       // address-&gt;disp() can be 0, if the address is referenced using the unsafe intrinsic
1340       load_addr = address;
1341     }
1342     __ volatile_load_mem_reg(load_addr, result, info);
1343     return;
1344   }
1345   __ load(address, result, info, lir_patch_none);
1346 }
    </pre>
  </body>
</html>
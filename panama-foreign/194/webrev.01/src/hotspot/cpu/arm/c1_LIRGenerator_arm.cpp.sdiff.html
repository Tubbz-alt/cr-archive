<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/c1_LIRGenerator_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_CodeStubs_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/c1_LIRGenerator_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 373 
 374   bool load_card_table_base_const = VM_Version::supports_movw();
 375   if (load_card_table_base_const) {
 376     __ move((LIR_Opr)card_table_base, tmp);
 377   } else {
 378     __ move(new LIR_Address(FrameMap::Rthread_opr, in_bytes(JavaThread::card_table_base_offset()), T_ADDRESS), tmp);
 379   }
 380 
 381   // Use unsigned type T_BOOLEAN here rather than (signed) T_BYTE since signed load
 382   // byte instruction does not support the addressing mode we need.
 383   LIR_Address* card_addr = new LIR_Address(tmp, addr, (LIR_Address::Scale) -CardTable::card_shift, 0, T_BOOLEAN);
 384   if (UseCondCardMark) {
 385     if (ct-&gt;scanned_concurrently()) {
 386       __ membar_storeload();
 387     }
 388     LIR_Opr cur_value = new_register(T_INT);
 389     __ move(card_addr, cur_value);
 390 
 391     LabelObj* L_already_dirty = new LabelObj();
 392     __ cmp(lir_cond_equal, cur_value, LIR_OprFact::intConst(CardTable::dirty_card_val()));
<span class="line-modified"> 393     __ branch(lir_cond_equal, T_BYTE, L_already_dirty-&gt;label());</span>
 394     set_card(tmp, card_addr);
 395     __ branch_destination(L_already_dirty-&gt;label());
 396   } else {
 397     if (ct-&gt;scanned_concurrently()) {
 398       __ membar_storestore();
 399     }
 400     set_card(tmp, card_addr);
 401   }
 402 }
 403 
 404 void LIRGenerator::array_store_check(LIR_Opr value, LIR_Opr array, CodeEmitInfo* store_check_info, ciMethod* profiled_method, int profiled_bci) {
 405   LIR_Opr tmp1 = FrameMap::R0_oop_opr;
 406   LIR_Opr tmp2 = FrameMap::R1_oop_opr;
 407   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
 408   __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);
 409 }
 410 
 411 //----------------------------------------------------------------------
 412 //             visitor functions
 413 //----------------------------------------------------------------------
</pre>
<hr />
<pre>
 522     default: {
 523       LIRItem left(x-&gt;x(), this);
 524       LIRItem right(x-&gt;y(), this);
 525       left.load_item();
 526       right.load_item();
 527       rlock_result(x);
 528       arithmetic_op_fpu(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), x-&gt;is_strictfp());
 529       return;
 530     }
 531 #endif // __SOFTFP__
 532   }
 533 
 534   LIR_Opr result = call_runtime(x-&gt;x(), x-&gt;y(), runtime_func, x-&gt;type(), NULL);
 535   set_result(x, result);
 536 }
 537 
 538 
 539 void LIRGenerator::make_div_by_zero_check(LIR_Opr right_arg, BasicType type, CodeEmitInfo* info) {
 540   assert(right_arg-&gt;is_register(), &quot;must be&quot;);
 541   __ cmp(lir_cond_equal, right_arg, make_constant(type, 0));
<span class="line-modified"> 542   __ branch(lir_cond_equal, type, new DivByZeroStub(info));</span>
 543 }
 544 
 545 
 546 // for  _ladd, _lmul, _lsub, _ldiv, _lrem
 547 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 548   CodeEmitInfo* info = NULL;
 549   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem) {
 550     info = state_for(x);
 551   }
 552 
 553   switch (x-&gt;op()) {
 554     case Bytecodes::_ldiv:
 555     case Bytecodes::_lrem: {
 556       LIRItem right(x-&gt;y(), this);
 557       right.load_item();
 558       make_div_by_zero_check(right.result(), T_LONG, info);
 559     }
 560     // Fall through
 561     case Bytecodes::_lmul: {
 562       address entry;
</pre>
<hr />
<pre>
1210     case lir_cond_belowEqual:
1211       ShouldNotReachHere();  // We&#39;re not going to get these.
1212     default:
1213       assert(lir_cond(cond) == lir_cond_always, &quot;must be&quot;);
1214       ShouldNotReachHere();
1215   }
1216   set_no_result(x);
1217 
1218   // add safepoint before generating condition code so it can be recomputed
1219   if (x-&gt;is_safepoint()) {
1220     increment_backedge_counter(state_for(x, x-&gt;state_before()), x-&gt;profiled_bci());
1221     __ safepoint(LIR_OprFact::illegalOpr, state_for(x, x-&gt;state_before()));
1222   }
1223   // Call float compare function, returns (1,0) if true or false.
1224   LIR_Opr result = call_runtime(x-&gt;x(), x-&gt;y(), runtime_func, intType, NULL);
1225   __ cmp(lir_cond_equal, result,
1226          compare_to_zero ?
1227            LIR_OprFact::intConst(0) : LIR_OprFact::intConst(1));
1228   profile_branch(x, cond);
1229   move_to_phi(x-&gt;state());
<span class="line-modified">1230   __ branch(lir_cond_equal, T_INT, x-&gt;tsux());</span>
1231 }
1232 #endif // __SOFTFP__
1233 
1234 void LIRGenerator::do_If(If* x) {
1235   assert(x-&gt;number_of_sux() == 2, &quot;inconsistency&quot;);
1236   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
1237 
1238 #ifdef __SOFTFP__
1239   if (tag == floatTag || tag == doubleTag) {
1240     do_soft_float_compare(x);
1241     assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1242     __ jump(x-&gt;default_sux());
1243     return;
1244   }
1245 #endif // __SOFTFP__
1246 
1247   LIRItem xitem(x-&gt;x(), this);
1248   LIRItem yitem(x-&gt;y(), this);
1249   LIRItem* xin = &amp;xitem;
1250   LIRItem* yin = &amp;yitem;
</pre>
<hr />
<pre>
1268     // inline long zero
1269     right = LIR_OprFact::value_type(yin-&gt;value()-&gt;type());
1270   } else {
1271     yin-&gt;load_nonconstant();
1272     right = yin-&gt;result();
1273   }
1274 
1275   set_no_result(x);
1276 
1277   // add safepoint before generating condition code so it can be recomputed
1278   if (x-&gt;is_safepoint()) {
1279     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1280         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1281     __ safepoint(LIR_OprFact::illegalOpr, state_for(x, x-&gt;state_before()));
1282   }
1283 
1284   __ cmp(lir_cond(cond), left, right);
1285   profile_branch(x, cond);
1286   move_to_phi(x-&gt;state());
1287   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
<span class="line-modified">1288     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());</span>
1289   } else {
<span class="line-modified">1290     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());</span>
1291   }
1292   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1293   __ jump(x-&gt;default_sux());
1294 }
1295 
1296 
1297 LIR_Opr LIRGenerator::getThreadPointer() {
1298   return FrameMap::Rthread_opr;
1299 }
1300 
1301 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1302   __ move(LIR_OprFact::intConst(block-&gt;block_id()), FrameMap::R0_opr);
1303   LIR_OprList* args = new LIR_OprList(1);
1304   args-&gt;append(FrameMap::R0_opr);
1305   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
1306   __ call_runtime_leaf(func, getThreadTemp(), LIR_OprFact::illegalOpr, args);
1307 }
1308 
1309 
1310 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
</pre>
</td>
<td>
<hr />
<pre>
 373 
 374   bool load_card_table_base_const = VM_Version::supports_movw();
 375   if (load_card_table_base_const) {
 376     __ move((LIR_Opr)card_table_base, tmp);
 377   } else {
 378     __ move(new LIR_Address(FrameMap::Rthread_opr, in_bytes(JavaThread::card_table_base_offset()), T_ADDRESS), tmp);
 379   }
 380 
 381   // Use unsigned type T_BOOLEAN here rather than (signed) T_BYTE since signed load
 382   // byte instruction does not support the addressing mode we need.
 383   LIR_Address* card_addr = new LIR_Address(tmp, addr, (LIR_Address::Scale) -CardTable::card_shift, 0, T_BOOLEAN);
 384   if (UseCondCardMark) {
 385     if (ct-&gt;scanned_concurrently()) {
 386       __ membar_storeload();
 387     }
 388     LIR_Opr cur_value = new_register(T_INT);
 389     __ move(card_addr, cur_value);
 390 
 391     LabelObj* L_already_dirty = new LabelObj();
 392     __ cmp(lir_cond_equal, cur_value, LIR_OprFact::intConst(CardTable::dirty_card_val()));
<span class="line-modified"> 393     __ branch(lir_cond_equal, L_already_dirty-&gt;label());</span>
 394     set_card(tmp, card_addr);
 395     __ branch_destination(L_already_dirty-&gt;label());
 396   } else {
 397     if (ct-&gt;scanned_concurrently()) {
 398       __ membar_storestore();
 399     }
 400     set_card(tmp, card_addr);
 401   }
 402 }
 403 
 404 void LIRGenerator::array_store_check(LIR_Opr value, LIR_Opr array, CodeEmitInfo* store_check_info, ciMethod* profiled_method, int profiled_bci) {
 405   LIR_Opr tmp1 = FrameMap::R0_oop_opr;
 406   LIR_Opr tmp2 = FrameMap::R1_oop_opr;
 407   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
 408   __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);
 409 }
 410 
 411 //----------------------------------------------------------------------
 412 //             visitor functions
 413 //----------------------------------------------------------------------
</pre>
<hr />
<pre>
 522     default: {
 523       LIRItem left(x-&gt;x(), this);
 524       LIRItem right(x-&gt;y(), this);
 525       left.load_item();
 526       right.load_item();
 527       rlock_result(x);
 528       arithmetic_op_fpu(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), x-&gt;is_strictfp());
 529       return;
 530     }
 531 #endif // __SOFTFP__
 532   }
 533 
 534   LIR_Opr result = call_runtime(x-&gt;x(), x-&gt;y(), runtime_func, x-&gt;type(), NULL);
 535   set_result(x, result);
 536 }
 537 
 538 
 539 void LIRGenerator::make_div_by_zero_check(LIR_Opr right_arg, BasicType type, CodeEmitInfo* info) {
 540   assert(right_arg-&gt;is_register(), &quot;must be&quot;);
 541   __ cmp(lir_cond_equal, right_arg, make_constant(type, 0));
<span class="line-modified"> 542   __ branch(lir_cond_equal, new DivByZeroStub(info));</span>
 543 }
 544 
 545 
 546 // for  _ladd, _lmul, _lsub, _ldiv, _lrem
 547 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 548   CodeEmitInfo* info = NULL;
 549   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem) {
 550     info = state_for(x);
 551   }
 552 
 553   switch (x-&gt;op()) {
 554     case Bytecodes::_ldiv:
 555     case Bytecodes::_lrem: {
 556       LIRItem right(x-&gt;y(), this);
 557       right.load_item();
 558       make_div_by_zero_check(right.result(), T_LONG, info);
 559     }
 560     // Fall through
 561     case Bytecodes::_lmul: {
 562       address entry;
</pre>
<hr />
<pre>
1210     case lir_cond_belowEqual:
1211       ShouldNotReachHere();  // We&#39;re not going to get these.
1212     default:
1213       assert(lir_cond(cond) == lir_cond_always, &quot;must be&quot;);
1214       ShouldNotReachHere();
1215   }
1216   set_no_result(x);
1217 
1218   // add safepoint before generating condition code so it can be recomputed
1219   if (x-&gt;is_safepoint()) {
1220     increment_backedge_counter(state_for(x, x-&gt;state_before()), x-&gt;profiled_bci());
1221     __ safepoint(LIR_OprFact::illegalOpr, state_for(x, x-&gt;state_before()));
1222   }
1223   // Call float compare function, returns (1,0) if true or false.
1224   LIR_Opr result = call_runtime(x-&gt;x(), x-&gt;y(), runtime_func, intType, NULL);
1225   __ cmp(lir_cond_equal, result,
1226          compare_to_zero ?
1227            LIR_OprFact::intConst(0) : LIR_OprFact::intConst(1));
1228   profile_branch(x, cond);
1229   move_to_phi(x-&gt;state());
<span class="line-modified">1230   __ branch(lir_cond_equal, x-&gt;tsux());</span>
1231 }
1232 #endif // __SOFTFP__
1233 
1234 void LIRGenerator::do_If(If* x) {
1235   assert(x-&gt;number_of_sux() == 2, &quot;inconsistency&quot;);
1236   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
1237 
1238 #ifdef __SOFTFP__
1239   if (tag == floatTag || tag == doubleTag) {
1240     do_soft_float_compare(x);
1241     assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1242     __ jump(x-&gt;default_sux());
1243     return;
1244   }
1245 #endif // __SOFTFP__
1246 
1247   LIRItem xitem(x-&gt;x(), this);
1248   LIRItem yitem(x-&gt;y(), this);
1249   LIRItem* xin = &amp;xitem;
1250   LIRItem* yin = &amp;yitem;
</pre>
<hr />
<pre>
1268     // inline long zero
1269     right = LIR_OprFact::value_type(yin-&gt;value()-&gt;type());
1270   } else {
1271     yin-&gt;load_nonconstant();
1272     right = yin-&gt;result();
1273   }
1274 
1275   set_no_result(x);
1276 
1277   // add safepoint before generating condition code so it can be recomputed
1278   if (x-&gt;is_safepoint()) {
1279     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1280         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1281     __ safepoint(LIR_OprFact::illegalOpr, state_for(x, x-&gt;state_before()));
1282   }
1283 
1284   __ cmp(lir_cond(cond), left, right);
1285   profile_branch(x, cond);
1286   move_to_phi(x-&gt;state());
1287   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
<span class="line-modified">1288     __ branch(lir_cond(cond), x-&gt;tsux(), x-&gt;usux());</span>
1289   } else {
<span class="line-modified">1290     __ branch(lir_cond(cond), x-&gt;tsux());</span>
1291   }
1292   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1293   __ jump(x-&gt;default_sux());
1294 }
1295 
1296 
1297 LIR_Opr LIRGenerator::getThreadPointer() {
1298   return FrameMap::Rthread_opr;
1299 }
1300 
1301 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1302   __ move(LIR_OprFact::intConst(block-&gt;block_id()), FrameMap::R0_opr);
1303   LIR_OprList* args = new LIR_OprList(1);
1304   args-&gt;append(FrameMap::R0_opr);
1305   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
1306   __ call_runtime_leaf(func, getThreadTemp(), LIR_OprFact::illegalOpr, args);
1307 }
1308 
1309 
1310 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
</pre>
</td>
</tr>
</table>
<center><a href="c1_CodeStubs_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
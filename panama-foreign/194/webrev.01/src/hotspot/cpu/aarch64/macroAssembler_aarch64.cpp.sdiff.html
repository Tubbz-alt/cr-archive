<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRGenerator_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  43 #include &quot;oops/klass.inline.hpp&quot;
  44 #include &quot;runtime/biasedLocking.hpp&quot;
  45 #include &quot;runtime/icache.hpp&quot;
  46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  47 #include &quot;runtime/jniHandles.inline.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/thread.hpp&quot;
  50 #include &quot;utilities/powerOfTwo.hpp&quot;
  51 #ifdef COMPILER1
  52 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  53 #endif
  54 #ifdef COMPILER2
  55 #include &quot;oops/oop.hpp&quot;
  56 #include &quot;opto/compile.hpp&quot;
  57 #include &quot;opto/node.hpp&quot;
  58 #include &quot;opto/output.hpp&quot;
  59 #endif
  60 
  61 #ifdef PRODUCT
  62 #define BLOCK_COMMENT(str) /* nothing */
<span class="line-removed">  63 #define STOP(error) stop(error)</span>
  64 #else
  65 #define BLOCK_COMMENT(str) block_comment(str)
<span class="line-removed">  66 #define STOP(error) block_comment(error); stop(error)</span>
  67 #endif
<span class="line-modified">  68 </span>
  69 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  70 
  71 // Patch any kind of instruction; there may be several instructions.
  72 // Return the total length (in bytes) of the instructions.
  73 int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
  74   int instructions = 1;
  75   assert((uint64_t)target &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
  76   long offset = (target - branch) &gt;&gt; 2;
  77   unsigned insn = *(unsigned*)branch;
  78   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b111011) == 0b011000) {
  79     // Load register (literal)
  80     Instruction_aarch64::spatch(branch, 23, 5, offset);
  81   } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
  82     // Unconditional branch (immediate)
  83     Instruction_aarch64::spatch(branch, 25, 0, offset);
  84   } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {
  85     // Conditional branch (immediate)
  86     Instruction_aarch64::spatch(branch, 23, 5, offset);
  87   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {
  88     // Compare &amp; branch (immediate)
</pre>
<hr />
<pre>
2206   Label done, not_weak;
2207   cbz(value, done);           // Use NULL as-is.
2208 
2209   STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);
2210   tbz(r0, 0, not_weak);    // Test for jweak tag.
2211 
2212   // Resolve jweak.
2213   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, value,
2214                  Address(value, -JNIHandles::weak_tag_value), tmp, thread);
2215   verify_oop(value);
2216   b(done);
2217 
2218   bind(not_weak);
2219   // Resolve (untagged) jobject.
2220   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
2221   verify_oop(value);
2222   bind(done);
2223 }
2224 
2225 void MacroAssembler::stop(const char* msg) {
<span class="line-modified">2226   address ip = pc();</span>
<span class="line-modified">2227   pusha();</span>
<span class="line-modified">2228   mov(c_rarg0, (address)msg);</span>
<span class="line-removed">2229   mov(c_rarg1, (address)ip);</span>
<span class="line-removed">2230   mov(c_rarg2, sp);</span>
<span class="line-removed">2231   mov(c_rarg3, CAST_FROM_FN_PTR(address, MacroAssembler::debug64));</span>
<span class="line-removed">2232   blr(c_rarg3);</span>
<span class="line-removed">2233   hlt(0);</span>
<span class="line-removed">2234 }</span>
<span class="line-removed">2235 </span>
<span class="line-removed">2236 void MacroAssembler::warn(const char* msg) {</span>
<span class="line-removed">2237   pusha();</span>
<span class="line-removed">2238   mov(c_rarg0, (address)msg);</span>
<span class="line-removed">2239   mov(lr, CAST_FROM_FN_PTR(address, warning));</span>
<span class="line-removed">2240   blr(lr);</span>
<span class="line-removed">2241   popa();</span>
2242 }
2243 
2244 void MacroAssembler::unimplemented(const char* what) {
2245   const char* buf = NULL;
2246   {
2247     ResourceMark rm;
2248     stringStream ss;
2249     ss.print(&quot;unimplemented: %s&quot;, what);
2250     buf = code_string(ss.as_string());
2251   }
2252   stop(buf);
2253 }
2254 
2255 // If a constant does not fit in an immediate field, generate some
2256 // number of MOV instructions and then perform the operation.
2257 void MacroAssembler::wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,
2258                                            add_sub_imm_insn insn1,
2259                                            add_sub_reg_insn insn2) {
2260   assert(Rd != zr, &quot;Rd = zr and not setting flags?&quot;);
2261   if (operand_valid_for_add_sub_immediate((int)imm)) {
</pre>
</td>
<td>
<hr />
<pre>
  43 #include &quot;oops/klass.inline.hpp&quot;
  44 #include &quot;runtime/biasedLocking.hpp&quot;
  45 #include &quot;runtime/icache.hpp&quot;
  46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  47 #include &quot;runtime/jniHandles.inline.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/thread.hpp&quot;
  50 #include &quot;utilities/powerOfTwo.hpp&quot;
  51 #ifdef COMPILER1
  52 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  53 #endif
  54 #ifdef COMPILER2
  55 #include &quot;oops/oop.hpp&quot;
  56 #include &quot;opto/compile.hpp&quot;
  57 #include &quot;opto/node.hpp&quot;
  58 #include &quot;opto/output.hpp&quot;
  59 #endif
  60 
  61 #ifdef PRODUCT
  62 #define BLOCK_COMMENT(str) /* nothing */

  63 #else
  64 #define BLOCK_COMMENT(str) block_comment(str)

  65 #endif
<span class="line-modified">  66 #define STOP(str) stop(str);</span>
  67 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  68 
  69 // Patch any kind of instruction; there may be several instructions.
  70 // Return the total length (in bytes) of the instructions.
  71 int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
  72   int instructions = 1;
  73   assert((uint64_t)target &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
  74   long offset = (target - branch) &gt;&gt; 2;
  75   unsigned insn = *(unsigned*)branch;
  76   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b111011) == 0b011000) {
  77     // Load register (literal)
  78     Instruction_aarch64::spatch(branch, 23, 5, offset);
  79   } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
  80     // Unconditional branch (immediate)
  81     Instruction_aarch64::spatch(branch, 25, 0, offset);
  82   } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {
  83     // Conditional branch (immediate)
  84     Instruction_aarch64::spatch(branch, 23, 5, offset);
  85   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {
  86     // Compare &amp; branch (immediate)
</pre>
<hr />
<pre>
2204   Label done, not_weak;
2205   cbz(value, done);           // Use NULL as-is.
2206 
2207   STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);
2208   tbz(r0, 0, not_weak);    // Test for jweak tag.
2209 
2210   // Resolve jweak.
2211   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, value,
2212                  Address(value, -JNIHandles::weak_tag_value), tmp, thread);
2213   verify_oop(value);
2214   b(done);
2215 
2216   bind(not_weak);
2217   // Resolve (untagged) jobject.
2218   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
2219   verify_oop(value);
2220   bind(done);
2221 }
2222 
2223 void MacroAssembler::stop(const char* msg) {
<span class="line-modified">2224   BLOCK_COMMENT(msg);</span>
<span class="line-modified">2225   dcps1(0xdeae);</span>
<span class="line-modified">2226   emit_int64((uintptr_t)msg);</span>













2227 }
2228 
2229 void MacroAssembler::unimplemented(const char* what) {
2230   const char* buf = NULL;
2231   {
2232     ResourceMark rm;
2233     stringStream ss;
2234     ss.print(&quot;unimplemented: %s&quot;, what);
2235     buf = code_string(ss.as_string());
2236   }
2237   stop(buf);
2238 }
2239 
2240 // If a constant does not fit in an immediate field, generate some
2241 // number of MOV instructions and then perform the operation.
2242 void MacroAssembler::wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,
2243                                            add_sub_imm_insn insn1,
2244                                            add_sub_reg_insn insn2) {
2245   assert(Rd != zr, &quot;Rd = zr and not setting flags?&quot;);
2246   if (operand_valid_for_add_sub_immediate((int)imm)) {
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRGenerator_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
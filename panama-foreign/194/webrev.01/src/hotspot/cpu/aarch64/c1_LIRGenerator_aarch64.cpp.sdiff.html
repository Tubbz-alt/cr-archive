<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 442   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem) {
 443 
 444     left.load_item();
 445     bool need_zero_check = true;
 446     if (right.is_constant()) {
 447       jlong c = right.get_jlong_constant();
 448       // no need to do div-by-zero check if the divisor is a non-zero constant
 449       if (c != 0) need_zero_check = false;
 450       // do not load right if the divisor is a power-of-2 constant
 451       if (c &gt; 0 &amp;&amp; is_power_of_2(c)) {
 452         right.dont_load_item();
 453       } else {
 454         right.load_item();
 455       }
 456     } else {
 457       right.load_item();
 458     }
 459     if (need_zero_check) {
 460       CodeEmitInfo* info = state_for(x);
 461       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
<span class="line-modified"> 462       __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));</span>
 463     }
 464 
 465     rlock_result(x);
 466     switch (x-&gt;op()) {
 467     case Bytecodes::_lrem:
 468       __ rem (left.result(), right.result(), x-&gt;operand());
 469       break;
 470     case Bytecodes::_ldiv:
 471       __ div (left.result(), right.result(), x-&gt;operand());
 472       break;
 473     default:
 474       ShouldNotReachHere();
 475       break;
 476     }
 477 
 478 
 479   } else {
 480     assert (x-&gt;op() == Bytecodes::_lmul || x-&gt;op() == Bytecodes::_ladd || x-&gt;op() == Bytecodes::_lsub,
 481             &quot;expect lmul, ladd or lsub&quot;);
 482     // add, sub, mul
</pre>
<hr />
<pre>
 517   if (x-&gt;op() == Bytecodes::_idiv || x-&gt;op() == Bytecodes::_irem) {
 518 
 519     rlock_result(x);
 520     bool need_zero_check = true;
 521     if (right.is_constant()) {
 522       jint c = right.get_jint_constant();
 523       // no need to do div-by-zero check if the divisor is a non-zero constant
 524       if (c != 0) need_zero_check = false;
 525       // do not load right if the divisor is a power-of-2 constant
 526       if (c &gt; 0 &amp;&amp; is_power_of_2(c)) {
 527         right_arg-&gt;dont_load_item();
 528       } else {
 529         right_arg-&gt;load_item();
 530       }
 531     } else {
 532       right_arg-&gt;load_item();
 533     }
 534     if (need_zero_check) {
 535       CodeEmitInfo* info = state_for(x);
 536       __ cmp(lir_cond_equal, right_arg-&gt;result(), LIR_OprFact::longConst(0));
<span class="line-modified"> 537       __ branch(lir_cond_equal, T_INT, new DivByZeroStub(info));</span>
 538     }
 539 
 540     LIR_Opr ill = LIR_OprFact::illegalOpr;
 541     if (x-&gt;op() == Bytecodes::_irem) {
 542       __ irem(left_arg-&gt;result(), right_arg-&gt;result(), x-&gt;operand(), ill, NULL);
 543     } else if (x-&gt;op() == Bytecodes::_idiv) {
 544       __ idiv(left_arg-&gt;result(), right_arg-&gt;result(), x-&gt;operand(), ill, NULL);
 545     }
 546 
 547   } else if (x-&gt;op() == Bytecodes::_iadd || x-&gt;op() == Bytecodes::_isub) {
 548     if (right.is_constant()
 549         &amp;&amp; Assembler::operand_valid_for_add_sub_immediate(right.get_jint_constant())) {
 550       right.load_nonconstant();
 551     } else {
 552       right.load_item();
 553     }
 554     rlock_result(x);
 555     arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), LIR_OprFact::illegalOpr);
 556   } else {
 557     assert (x-&gt;op() == Bytecodes::_imul, &quot;expect imul&quot;);
</pre>
<hr />
<pre>
1367   }
1368 
1369   set_no_result(x);
1370 
1371   LIR_Opr left = xin-&gt;result();
1372   LIR_Opr right = yin-&gt;result();
1373 
1374   // add safepoint before generating condition code so it can be recomputed
1375   if (x-&gt;is_safepoint()) {
1376     // increment backedge counter if needed
1377     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1378         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1379     __ safepoint(LIR_OprFact::illegalOpr, state_for(x, x-&gt;state_before()));
1380   }
1381 
1382   __ cmp(lir_cond(cond), left, right);
1383   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1384   profile_branch(x, cond);
1385   move_to_phi(x-&gt;state());
1386   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
<span class="line-modified">1387     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());</span>
1388   } else {
<span class="line-modified">1389     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());</span>
1390   }
1391   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1392   __ jump(x-&gt;default_sux());
1393 }
1394 
1395 LIR_Opr LIRGenerator::getThreadPointer() {
1396    return FrameMap::as_pointer_opr(rthread);
1397 }
1398 
1399 void LIRGenerator::trace_block_entry(BlockBegin* block) { Unimplemented(); }
1400 
1401 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1402                                         CodeEmitInfo* info) {
1403   __ volatile_store_mem_reg(value, address, info);
1404 }
1405 
1406 void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
1407                                        CodeEmitInfo* info) {
1408   // 8179954: We need to make sure that the code generated for
1409   // volatile accesses forms a sequentially-consistent set of
</pre>
</td>
<td>
<hr />
<pre>
 442   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem) {
 443 
 444     left.load_item();
 445     bool need_zero_check = true;
 446     if (right.is_constant()) {
 447       jlong c = right.get_jlong_constant();
 448       // no need to do div-by-zero check if the divisor is a non-zero constant
 449       if (c != 0) need_zero_check = false;
 450       // do not load right if the divisor is a power-of-2 constant
 451       if (c &gt; 0 &amp;&amp; is_power_of_2(c)) {
 452         right.dont_load_item();
 453       } else {
 454         right.load_item();
 455       }
 456     } else {
 457       right.load_item();
 458     }
 459     if (need_zero_check) {
 460       CodeEmitInfo* info = state_for(x);
 461       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
<span class="line-modified"> 462       __ branch(lir_cond_equal, new DivByZeroStub(info));</span>
 463     }
 464 
 465     rlock_result(x);
 466     switch (x-&gt;op()) {
 467     case Bytecodes::_lrem:
 468       __ rem (left.result(), right.result(), x-&gt;operand());
 469       break;
 470     case Bytecodes::_ldiv:
 471       __ div (left.result(), right.result(), x-&gt;operand());
 472       break;
 473     default:
 474       ShouldNotReachHere();
 475       break;
 476     }
 477 
 478 
 479   } else {
 480     assert (x-&gt;op() == Bytecodes::_lmul || x-&gt;op() == Bytecodes::_ladd || x-&gt;op() == Bytecodes::_lsub,
 481             &quot;expect lmul, ladd or lsub&quot;);
 482     // add, sub, mul
</pre>
<hr />
<pre>
 517   if (x-&gt;op() == Bytecodes::_idiv || x-&gt;op() == Bytecodes::_irem) {
 518 
 519     rlock_result(x);
 520     bool need_zero_check = true;
 521     if (right.is_constant()) {
 522       jint c = right.get_jint_constant();
 523       // no need to do div-by-zero check if the divisor is a non-zero constant
 524       if (c != 0) need_zero_check = false;
 525       // do not load right if the divisor is a power-of-2 constant
 526       if (c &gt; 0 &amp;&amp; is_power_of_2(c)) {
 527         right_arg-&gt;dont_load_item();
 528       } else {
 529         right_arg-&gt;load_item();
 530       }
 531     } else {
 532       right_arg-&gt;load_item();
 533     }
 534     if (need_zero_check) {
 535       CodeEmitInfo* info = state_for(x);
 536       __ cmp(lir_cond_equal, right_arg-&gt;result(), LIR_OprFact::longConst(0));
<span class="line-modified"> 537       __ branch(lir_cond_equal, new DivByZeroStub(info));</span>
 538     }
 539 
 540     LIR_Opr ill = LIR_OprFact::illegalOpr;
 541     if (x-&gt;op() == Bytecodes::_irem) {
 542       __ irem(left_arg-&gt;result(), right_arg-&gt;result(), x-&gt;operand(), ill, NULL);
 543     } else if (x-&gt;op() == Bytecodes::_idiv) {
 544       __ idiv(left_arg-&gt;result(), right_arg-&gt;result(), x-&gt;operand(), ill, NULL);
 545     }
 546 
 547   } else if (x-&gt;op() == Bytecodes::_iadd || x-&gt;op() == Bytecodes::_isub) {
 548     if (right.is_constant()
 549         &amp;&amp; Assembler::operand_valid_for_add_sub_immediate(right.get_jint_constant())) {
 550       right.load_nonconstant();
 551     } else {
 552       right.load_item();
 553     }
 554     rlock_result(x);
 555     arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), LIR_OprFact::illegalOpr);
 556   } else {
 557     assert (x-&gt;op() == Bytecodes::_imul, &quot;expect imul&quot;);
</pre>
<hr />
<pre>
1367   }
1368 
1369   set_no_result(x);
1370 
1371   LIR_Opr left = xin-&gt;result();
1372   LIR_Opr right = yin-&gt;result();
1373 
1374   // add safepoint before generating condition code so it can be recomputed
1375   if (x-&gt;is_safepoint()) {
1376     // increment backedge counter if needed
1377     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1378         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1379     __ safepoint(LIR_OprFact::illegalOpr, state_for(x, x-&gt;state_before()));
1380   }
1381 
1382   __ cmp(lir_cond(cond), left, right);
1383   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1384   profile_branch(x, cond);
1385   move_to_phi(x-&gt;state());
1386   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
<span class="line-modified">1387     __ branch(lir_cond(cond), x-&gt;tsux(), x-&gt;usux());</span>
1388   } else {
<span class="line-modified">1389     __ branch(lir_cond(cond), x-&gt;tsux());</span>
1390   }
1391   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1392   __ jump(x-&gt;default_sux());
1393 }
1394 
1395 LIR_Opr LIRGenerator::getThreadPointer() {
1396    return FrameMap::as_pointer_opr(rthread);
1397 }
1398 
1399 void LIRGenerator::trace_block_entry(BlockBegin* block) { Unimplemented(); }
1400 
1401 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1402                                         CodeEmitInfo* info) {
1403   __ volatile_store_mem_reg(value, address, info);
1404 }
1405 
1406 void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
1407                                        CodeEmitInfo* info) {
1408   // 8179954: We need to make sure that the code generated for
1409   // volatile accesses forms a sequentially-consistent set of
</pre>
</td>
</tr>
</table>
<center><a href="aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
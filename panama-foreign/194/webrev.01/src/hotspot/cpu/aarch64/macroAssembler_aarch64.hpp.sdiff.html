<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 963 
 964   // Debugging
 965 
 966   // only if +VerifyOops
 967   void verify_oop(Register reg, const char* s = &quot;broken oop&quot;);
 968   void verify_oop_addr(Address addr, const char * s = &quot;broken oop addr&quot;);
 969 
 970 // TODO: verify method and klass metadata (compare against vptr?)
 971   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 972   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 973 
 974 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 975 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 976 
 977   // only if +VerifyFPU
 978   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);
 979 
 980   // prints msg, dumps registers and stops execution
 981   void stop(const char* msg);
 982 
<span class="line-removed"> 983   // prints msg and continues</span>
<span class="line-removed"> 984   void warn(const char* msg);</span>
<span class="line-removed"> 985 </span>
 986   static void debug64(char* msg, int64_t pc, int64_t regs[]);
 987 
 988   void untested()                                { stop(&quot;untested&quot;); }
 989 
 990   void unimplemented(const char* what = &quot;&quot;);
 991 
 992   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }
 993 
 994   // Stack overflow checking
 995   void bang_stack_with_offset(int offset) {
 996     // stack grows down, caller passes positive offset
 997     assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
 998     sub(rscratch2, sp, offset);
 999     str(zr, Address(rscratch2));
1000   }
1001 
1002   // Writes to stack successive pages until offset reached to check for
1003   // stack overflow + shadow pages.  Also, clobbers tmp
1004   void bang_stack_size(Register size, Register tmp);
1005 
</pre>
</td>
<td>
<hr />
<pre>
 963 
 964   // Debugging
 965 
 966   // only if +VerifyOops
 967   void verify_oop(Register reg, const char* s = &quot;broken oop&quot;);
 968   void verify_oop_addr(Address addr, const char * s = &quot;broken oop addr&quot;);
 969 
 970 // TODO: verify method and klass metadata (compare against vptr?)
 971   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 972   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 973 
 974 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 975 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 976 
 977   // only if +VerifyFPU
 978   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);
 979 
 980   // prints msg, dumps registers and stops execution
 981   void stop(const char* msg);
 982 



 983   static void debug64(char* msg, int64_t pc, int64_t regs[]);
 984 
 985   void untested()                                { stop(&quot;untested&quot;); }
 986 
 987   void unimplemented(const char* what = &quot;&quot;);
 988 
 989   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }
 990 
 991   // Stack overflow checking
 992   void bang_stack_with_offset(int offset) {
 993     // stack grows down, caller passes positive offset
 994     assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
 995     sub(rscratch2, sp, offset);
 996     str(zr, Address(rscratch2));
 997   }
 998 
 999   // Writes to stack successive pages until offset reached to check for
1000   // stack overflow + shadow pages.  Also, clobbers tmp
1001   void bang_stack_size(Register size, Register tmp);
1002 
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
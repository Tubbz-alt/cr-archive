<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/methodHandles_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/methodHandles_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,11 ***</span>
  
  void MethodHandles::load_klass_from_Class(MacroAssembler* _masm, Register klass_reg) {
    if (VerifyMethodHandles)
      verify_klass(_masm, klass_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),
                   &quot;MH argument is a Class&quot;);
<span class="line-modified">!   __ ldr(klass_reg, Address(klass_reg, java_lang_Class::klass_offset_in_bytes()));</span>
  }
  
  #ifdef ASSERT
  static int check_nonzero(const char* xname, int x) {
    assert(x != 0, &quot;%s should be nonzero&quot;, xname);
<span class="line-new-header">--- 45,11 ---</span>
  
  void MethodHandles::load_klass_from_Class(MacroAssembler* _masm, Register klass_reg) {
    if (VerifyMethodHandles)
      verify_klass(_masm, klass_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),
                   &quot;MH argument is a Class&quot;);
<span class="line-modified">!   __ ldr(klass_reg, Address(klass_reg, java_lang_Class::klass_offset()));</span>
  }
  
  #ifdef ASSERT
  static int check_nonzero(const char* xname, int x) {
    assert(x != 0, &quot;%s should be nonzero&quot;, xname);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,17 ***</span>
  
    //NOT_PRODUCT({ FlagSetting fs(TraceMethodHandles, true); trace_method_handle(_masm, &quot;LZMH&quot;); });
  
    // Load the invoker, as MH -&gt; MH.form -&gt; LF.vmentry
    __ verify_oop(recv);
<span class="line-modified">!   __ load_heap_oop(method_temp, Address(recv, NONZERO(java_lang_invoke_MethodHandle::form_offset_in_bytes())), temp2);</span>
    __ verify_oop(method_temp);
<span class="line-modified">!   __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset_in_bytes())), temp2);</span>
    __ verify_oop(method_temp);
<span class="line-modified">!   __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes())), temp2);</span>
    __ verify_oop(method_temp);
<span class="line-modified">!   __ access_load_at(T_ADDRESS, IN_HEAP, method_temp, Address(method_temp, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes())), noreg, noreg);</span>
  
    if (VerifyMethodHandles &amp;&amp; !for_compiler_entry) {
      // make sure recv is already on stack
      __ ldr(temp2, Address(method_temp, Method::const_offset()));
      __ load_sized_value(temp2,
<span class="line-new-header">--- 133,17 ---</span>
  
    //NOT_PRODUCT({ FlagSetting fs(TraceMethodHandles, true); trace_method_handle(_masm, &quot;LZMH&quot;); });
  
    // Load the invoker, as MH -&gt; MH.form -&gt; LF.vmentry
    __ verify_oop(recv);
<span class="line-modified">!   __ load_heap_oop(method_temp, Address(recv, NONZERO(java_lang_invoke_MethodHandle::form_offset())), temp2);</span>
    __ verify_oop(method_temp);
<span class="line-modified">!   __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset())), temp2);</span>
    __ verify_oop(method_temp);
<span class="line-modified">!   __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_MemberName::method_offset())), temp2);</span>
    __ verify_oop(method_temp);
<span class="line-modified">!   __ access_load_at(T_ADDRESS, IN_HEAP, method_temp, Address(method_temp, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset())), noreg, noreg);</span>
  
    if (VerifyMethodHandles &amp;&amp; !for_compiler_entry) {
      // make sure recv is already on stack
      __ ldr(temp2, Address(method_temp, Method::const_offset()));
      __ load_sized_value(temp2,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 281,14 ***</span>
        // make sure the trailing argument really is a MemberName (caller responsibility)
        verify_klass(_masm, member_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_invoke_MemberName),
                     &quot;MemberName required for invokeVirtual etc.&quot;);
      }
  
<span class="line-modified">!     Address member_clazz(    member_reg, NONZERO(java_lang_invoke_MemberName::clazz_offset_in_bytes()));</span>
<span class="line-modified">!     Address member_vmindex(  member_reg, NONZERO(java_lang_invoke_MemberName::vmindex_offset_in_bytes()));</span>
<span class="line-modified">!     Address member_vmtarget( member_reg, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes()));</span>
<span class="line-modified">!     Address vmtarget_method( rmethod, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes()));</span>
  
      Register temp1_recv_klass = temp1;
      if (iid != vmIntrinsics::_linkToStatic) {
        __ verify_oop(receiver_reg);
        if (iid == vmIntrinsics::_linkToSpecial) {
<span class="line-new-header">--- 281,14 ---</span>
        // make sure the trailing argument really is a MemberName (caller responsibility)
        verify_klass(_masm, member_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_invoke_MemberName),
                     &quot;MemberName required for invokeVirtual etc.&quot;);
      }
  
<span class="line-modified">!     Address member_clazz(    member_reg, NONZERO(java_lang_invoke_MemberName::clazz_offset()));</span>
<span class="line-modified">!     Address member_vmindex(  member_reg, NONZERO(java_lang_invoke_MemberName::vmindex_offset()));</span>
<span class="line-modified">!     Address member_vmtarget( member_reg, NONZERO(java_lang_invoke_MemberName::method_offset()));</span>
<span class="line-modified">!     Address vmtarget_method( rmethod, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset()));</span>
  
      Register temp1_recv_klass = temp1;
      if (iid != vmIntrinsics::_linkToStatic) {
        __ verify_oop(receiver_reg);
        if (iid == vmIntrinsics::_linkToSpecial) {
</pre>
<center><a href="macroAssembler_aarch64.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/c1_LIRGenerator_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_CodeStubs_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/c1_LIRGenerator_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 368     LIR_Opr divisor_opr = right.result();
 369     if (divisor_opr-&gt;is_constant() &amp;&amp; is_power_of_2(divisor_opr-&gt;as_jlong())) {
 370       left.load_item();
 371       right.dont_load_item();
 372     } else {
 373       left.load_item_force(ldivInOpr());
 374       right.load_item();
 375 
 376       // DSGR instruction needs register pair.
 377       if (x-&gt;op() == Bytecodes::_ldiv) {
 378         result_reg = ldivOutOpr();
 379         tmp        = lremOutOpr();
 380       } else {
 381         result_reg = lremOutOpr();
 382         tmp        = ldivOutOpr();
 383       }
 384     }
 385 
 386     if (!ImplicitDiv0Checks) {
 387       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
<span class="line-modified"> 388       __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));</span>
 389       // Idiv/irem cannot trap (passing info would generate an assertion).
 390       info = NULL;
 391     }
 392 
 393     if (x-&gt;op() == Bytecodes::_lrem) {
 394       __ irem(left.result(), right.result(), result_reg, tmp, info);
 395     } else if (x-&gt;op() == Bytecodes::_ldiv) {
 396       __ idiv(left.result(), right.result(), result_reg, tmp, info);
 397     } else {
 398       ShouldNotReachHere();
 399     }
 400 
 401     if (result_reg != result) {
 402       __ move(result_reg, result);
 403     }
 404   } else {
 405     LIRItem left(x-&gt;x(), this);
 406     LIRItem right(x-&gt;y(), this);
 407 
 408     left.load_item();
</pre>
<hr />
<pre>
 444     LIR_Opr divisor_opr = right.result();
 445     if (divisor_opr-&gt;is_constant() &amp;&amp; is_power_of_2(divisor_opr-&gt;as_jint())) {
 446       left.load_item();
 447       right.dont_load_item();
 448     } else {
 449       left.load_item_force(divInOpr());
 450       right.load_item();
 451 
 452       // DSGFR instruction needs register pair.
 453       if (x-&gt;op() == Bytecodes::_idiv) {
 454         result_reg = divOutOpr();
 455         tmp        = remOutOpr();
 456       } else {
 457         result_reg = remOutOpr();
 458         tmp        = divOutOpr();
 459       }
 460     }
 461 
 462     if (!ImplicitDiv0Checks) {
 463       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::intConst(0));
<span class="line-modified"> 464       __ branch(lir_cond_equal, T_INT, new DivByZeroStub(info));</span>
 465       // Idiv/irem cannot trap (passing info would generate an assertion).
 466       info = NULL;
 467     }
 468 
 469     if (x-&gt;op() == Bytecodes::_irem) {
 470       __ irem(left.result(), right.result(), result_reg, tmp, info);
 471     } else if (x-&gt;op() == Bytecodes::_idiv) {
 472       __ idiv(left.result(), right.result(), result_reg, tmp, info);
 473     } else {
 474       ShouldNotReachHere();
 475     }
 476 
 477     if (result_reg != result) {
 478       __ move(result_reg, result);
 479     }
 480   } else {
 481     LIRItem left(x-&gt;x(),  this);
 482     LIRItem right(x-&gt;y(), this);
 483     LIRItem* left_arg = &amp;left;
 484     LIRItem* right_arg = &amp;right;
</pre>
<hr />
<pre>
 971 
 972   LIR_Opr left = xin-&gt;result();
 973   LIR_Opr right = yin-&gt;result();
 974 
 975   set_no_result(x);
 976 
 977   // Add safepoint before generating condition code so it can be recomputed.
 978   if (x-&gt;is_safepoint()) {
 979     // Increment backedge counter if needed.
 980     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
 981         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
 982     // Use safepoint_poll_register() instead of LIR_OprFact::illegalOpr.
 983     __ safepoint(safepoint_poll_register(), state_for (x, x-&gt;state_before()));
 984   }
 985 
 986   __ cmp(lir_cond(cond), left, right);
 987   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
 988   profile_branch(x, cond);
 989   move_to_phi(x-&gt;state());
 990   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
<span class="line-modified"> 991     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());</span>
 992   } else {
<span class="line-modified"> 993     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());</span>
 994   }
 995   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
 996   __ jump(x-&gt;default_sux());
 997 }
 998 
 999 LIR_Opr LIRGenerator::getThreadPointer() {
1000   return FrameMap::as_pointer_opr(Z_thread);
1001 }
1002 
1003 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1004   __ move(LIR_OprFact::intConst(block-&gt;block_id()), FrameMap::Z_R2_opr);
1005   LIR_OprList* args = new LIR_OprList(1);
1006   args-&gt;append(FrameMap::Z_R2_opr);
1007   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
1008   __ call_runtime_leaf(func, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, args);
1009 }
1010 
1011 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1012                                         CodeEmitInfo* info) {
1013   __ store(value, address, info);
</pre>
</td>
<td>
<hr />
<pre>
 368     LIR_Opr divisor_opr = right.result();
 369     if (divisor_opr-&gt;is_constant() &amp;&amp; is_power_of_2(divisor_opr-&gt;as_jlong())) {
 370       left.load_item();
 371       right.dont_load_item();
 372     } else {
 373       left.load_item_force(ldivInOpr());
 374       right.load_item();
 375 
 376       // DSGR instruction needs register pair.
 377       if (x-&gt;op() == Bytecodes::_ldiv) {
 378         result_reg = ldivOutOpr();
 379         tmp        = lremOutOpr();
 380       } else {
 381         result_reg = lremOutOpr();
 382         tmp        = ldivOutOpr();
 383       }
 384     }
 385 
 386     if (!ImplicitDiv0Checks) {
 387       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
<span class="line-modified"> 388       __ branch(lir_cond_equal, new DivByZeroStub(info));</span>
 389       // Idiv/irem cannot trap (passing info would generate an assertion).
 390       info = NULL;
 391     }
 392 
 393     if (x-&gt;op() == Bytecodes::_lrem) {
 394       __ irem(left.result(), right.result(), result_reg, tmp, info);
 395     } else if (x-&gt;op() == Bytecodes::_ldiv) {
 396       __ idiv(left.result(), right.result(), result_reg, tmp, info);
 397     } else {
 398       ShouldNotReachHere();
 399     }
 400 
 401     if (result_reg != result) {
 402       __ move(result_reg, result);
 403     }
 404   } else {
 405     LIRItem left(x-&gt;x(), this);
 406     LIRItem right(x-&gt;y(), this);
 407 
 408     left.load_item();
</pre>
<hr />
<pre>
 444     LIR_Opr divisor_opr = right.result();
 445     if (divisor_opr-&gt;is_constant() &amp;&amp; is_power_of_2(divisor_opr-&gt;as_jint())) {
 446       left.load_item();
 447       right.dont_load_item();
 448     } else {
 449       left.load_item_force(divInOpr());
 450       right.load_item();
 451 
 452       // DSGFR instruction needs register pair.
 453       if (x-&gt;op() == Bytecodes::_idiv) {
 454         result_reg = divOutOpr();
 455         tmp        = remOutOpr();
 456       } else {
 457         result_reg = remOutOpr();
 458         tmp        = divOutOpr();
 459       }
 460     }
 461 
 462     if (!ImplicitDiv0Checks) {
 463       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::intConst(0));
<span class="line-modified"> 464       __ branch(lir_cond_equal, new DivByZeroStub(info));</span>
 465       // Idiv/irem cannot trap (passing info would generate an assertion).
 466       info = NULL;
 467     }
 468 
 469     if (x-&gt;op() == Bytecodes::_irem) {
 470       __ irem(left.result(), right.result(), result_reg, tmp, info);
 471     } else if (x-&gt;op() == Bytecodes::_idiv) {
 472       __ idiv(left.result(), right.result(), result_reg, tmp, info);
 473     } else {
 474       ShouldNotReachHere();
 475     }
 476 
 477     if (result_reg != result) {
 478       __ move(result_reg, result);
 479     }
 480   } else {
 481     LIRItem left(x-&gt;x(),  this);
 482     LIRItem right(x-&gt;y(), this);
 483     LIRItem* left_arg = &amp;left;
 484     LIRItem* right_arg = &amp;right;
</pre>
<hr />
<pre>
 971 
 972   LIR_Opr left = xin-&gt;result();
 973   LIR_Opr right = yin-&gt;result();
 974 
 975   set_no_result(x);
 976 
 977   // Add safepoint before generating condition code so it can be recomputed.
 978   if (x-&gt;is_safepoint()) {
 979     // Increment backedge counter if needed.
 980     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
 981         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
 982     // Use safepoint_poll_register() instead of LIR_OprFact::illegalOpr.
 983     __ safepoint(safepoint_poll_register(), state_for (x, x-&gt;state_before()));
 984   }
 985 
 986   __ cmp(lir_cond(cond), left, right);
 987   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
 988   profile_branch(x, cond);
 989   move_to_phi(x-&gt;state());
 990   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
<span class="line-modified"> 991     __ branch(lir_cond(cond), x-&gt;tsux(), x-&gt;usux());</span>
 992   } else {
<span class="line-modified"> 993     __ branch(lir_cond(cond), x-&gt;tsux());</span>
 994   }
 995   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
 996   __ jump(x-&gt;default_sux());
 997 }
 998 
 999 LIR_Opr LIRGenerator::getThreadPointer() {
1000   return FrameMap::as_pointer_opr(Z_thread);
1001 }
1002 
1003 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1004   __ move(LIR_OprFact::intConst(block-&gt;block_id()), FrameMap::Z_R2_opr);
1005   LIR_OprList* args = new LIR_OprList(1);
1006   args-&gt;append(FrameMap::Z_R2_opr);
1007   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
1008   __ call_runtime_leaf(func, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, args);
1009 }
1010 
1011 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1012                                         CodeEmitInfo* info) {
1013   __ store(value, address, info);
</pre>
</td>
</tr>
</table>
<center><a href="c1_CodeStubs_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
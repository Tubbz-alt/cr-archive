<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/methodHandles_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRGenerator_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="s390.ad.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/methodHandles_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39 #define __ _masm-&gt;
 40 #define BLOCK_COMMENT(str) /* nothing */
 41 #else
 42 #define __ (Verbose ? (_masm-&gt;block_comment(FILE_AND_LINE),_masm):_masm)-&gt;
 43 #define BLOCK_COMMENT(str) __ block_comment(str)
 44 #endif
 45 
 46 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
 47 
 48 // Workaround for C++ overloading nastiness on &#39;0&#39; for RegisterOrConstant.
 49 static RegisterOrConstant constant(int value) {
 50   return RegisterOrConstant(value);
 51 }
 52 
 53 void MethodHandles::load_klass_from_Class(MacroAssembler* _masm, Register klass_reg,
 54                                           Register temp_reg, Register temp2_reg) {
 55   if (VerifyMethodHandles) {
 56     verify_klass(_masm, klass_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),
 57                  temp_reg, temp2_reg, &quot;MH argument is a Class&quot;);
 58   }
<span class="line-modified"> 59   __ z_lg(klass_reg, Address(klass_reg, java_lang_Class::klass_offset_in_bytes()));</span>
 60 }
 61 
 62 
 63 #ifdef ASSERT
 64 static int check_nonzero(const char* xname, int x) {
 65   assert(x != 0, &quot;%s should be nonzero&quot;, xname);
 66   return x;
 67 }
 68 #define NONZERO(x) check_nonzero(#x, x)
 69 #else
 70 #define NONZERO(x) (x)
 71 #endif
 72 
 73 #ifdef ASSERT
 74 void MethodHandles::verify_klass(MacroAssembler* _masm,
 75                                  Register obj_reg, SystemDictionary::WKID klass_id,
 76                                  Register temp_reg, Register temp2_reg,
 77                                  const char* error_message) {
 78 
 79   InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);
</pre>
<hr />
<pre>
 94   __ z_lg(temp2_reg, Address(temp2_reg));
 95   __ compareU64_and_branch(temp_reg, temp2_reg, Assembler::bcondEqual, L_ok);
 96 
 97   intptr_t super_check_offset = klass-&gt;super_check_offset();
 98   __ z_lg(temp_reg, Address(temp_reg, super_check_offset));
 99   __ compareU64_and_branch(temp_reg, temp2_reg, Assembler::bcondEqual, L_ok);
100   __ BIND(L_bad);
101   __ stop(error_message);
102   __ BIND(L_ok);
103 
104   BLOCK_COMMENT(&quot;} verify_klass&quot;);
105 }
106 
107 void MethodHandles::verify_ref_kind(MacroAssembler* _masm, int ref_kind,
108                                     Register member_reg, Register temp  ) {
109   NearLabel L;
110   BLOCK_COMMENT(&quot;verify_ref_kind {&quot;);
111 
112   __ z_llgf(temp,
113             Address(member_reg,
<span class="line-modified">114                     NONZERO(java_lang_invoke_MemberName::flags_offset_in_bytes())));</span>
115   __ z_srl(temp,  java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT);
116   __ z_nilf(temp, java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK);
117   __ compare32_and_branch(temp, constant(ref_kind), Assembler::bcondEqual, L);
118 
119   {
120     char *buf = NEW_C_HEAP_ARRAY(char, 100, mtInternal);
121 
122     jio_snprintf(buf, 100, &quot;verify_ref_kind expected %x&quot;, ref_kind);
123     if (ref_kind == JVM_REF_invokeVirtual || ref_kind == JVM_REF_invokeSpecial) {
124       // Could do this for all ref_kinds, but would explode assembly code size.
125       trace_method_handle(_masm, buf);
126     }
127     __ stop(buf);
128   }
129 
130   BLOCK_COMMENT(&quot;} verify_ref_kind&quot;);
131 
132   __ bind(L);
133 }
134 #endif // ASSERT
</pre>
<hr />
<pre>
181   __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());
182   __ z_br(target);
183 }
184 
185 void MethodHandles::jump_to_lambda_form(MacroAssembler* _masm,
186                                         Register recv, Register method_temp,
187                                         Register temp2, Register temp3,
188                                         bool for_compiler_entry) {
189 
190   // This is the initial entry point of a lazy method handle.
191   // After type checking, it picks up the invoker from the LambdaForm.
192   assert_different_registers(recv, method_temp, temp2, temp3);
193   assert(method_temp == Z_method, &quot;required register for loading method&quot;);
194 
195   BLOCK_COMMENT(&quot;jump_to_lambda_form {&quot;);
196 
197   // Load the invoker, as MH -&gt; MH.form -&gt; LF.vmentry
198   __ verify_oop(recv, FILE_AND_LINE);
199   __ load_heap_oop(method_temp,
200                    Address(recv,
<span class="line-modified">201                            NONZERO(java_lang_invoke_MethodHandle::form_offset_in_bytes())),</span>
202                    noreg, noreg, IS_NOT_NULL);
203   __ verify_oop(method_temp, FILE_AND_LINE);
204   __ load_heap_oop(method_temp,
205                    Address(method_temp,
<span class="line-modified">206                            NONZERO(java_lang_invoke_LambdaForm::vmentry_offset_in_bytes())),</span>
207                    noreg, noreg, IS_NOT_NULL);
208   __ verify_oop(method_temp, FILE_AND_LINE);
209   __ load_heap_oop(method_temp,
210                    Address(method_temp,
<span class="line-modified">211                            NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes())),</span>
212                    noreg, noreg, IS_NOT_NULL);
213   __ verify_oop(method_temp, FILE_AND_LINE);
214   __ z_lg(method_temp,
215           Address(method_temp,
<span class="line-modified">216                   NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes())));</span>
217 
218   if (VerifyMethodHandles &amp;&amp; !for_compiler_entry) {
219     // Make sure recv is already on stack.
220     NearLabel L;
221     Address paramSize(temp2, ConstMethod::size_of_parameters_offset());
222 
223     __ z_lg(temp2, Address(method_temp, Method::const_offset()));
224     __ load_sized_value(temp2, paramSize, sizeof(u2), /*is_signed*/ false);
225     // if (temp2 != recv) stop
226     __ z_lg(temp2, __ argument_address(temp2, temp2, 0));
227     __ compare64_and_branch(temp2, recv, Assembler::bcondEqual, L);
228     __ stop(&quot;receiver not on stack&quot;);
229     __ BIND(L);
230   }
231 
232   jump_from_method_handle(_masm, method_temp, temp2, Z_R0, for_compiler_entry);
233 
234   BLOCK_COMMENT(&quot;} jump_to_lambda_form&quot;);
235 }
236 
</pre>
<hr />
<pre>
362   if (!for_compiler_entry) {  // Don&#39;t trash last SP.
363     assert_different_registers(temp1, temp2, temp3, temp4, Z_R10);
364   }
365 
366   if (iid == vmIntrinsics::_invokeBasic) {
367     __ pc(); // Just for the block comment.
368     // Indirect through MH.form.vmentry.vmtarget.
369     jump_to_lambda_form(_masm, receiver_reg, Z_method, Z_R1, temp3, for_compiler_entry);
370     return;
371   }
372 
373   // The method is a member invoker used by direct method handles.
374   if (VerifyMethodHandles) {
375     // Make sure the trailing argument really is a MemberName (caller responsibility).
376     verify_klass(_masm, member_reg,
377                  SystemDictionary::WK_KLASS_ENUM_NAME(MemberName_klass),
378                  temp1, temp2,
379                  &quot;MemberName required for invokeVirtual etc.&quot;);
380   }
381 
<span class="line-modified">382   Address  member_clazz(   member_reg, NONZERO(java_lang_invoke_MemberName::clazz_offset_in_bytes()));</span>
<span class="line-modified">383   Address  member_vmindex( member_reg, NONZERO(java_lang_invoke_MemberName::vmindex_offset_in_bytes()));</span>
<span class="line-modified">384   Address  member_vmtarget(member_reg, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes()));</span>
<span class="line-modified">385   Address  vmtarget_method(Z_method, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes()));</span>
386   Register temp1_recv_klass = temp1;
387 
388   if (iid != vmIntrinsics::_linkToStatic) {
389     __ verify_oop(receiver_reg, FILE_AND_LINE);
390     if (iid == vmIntrinsics::_linkToSpecial) {
391       // Don&#39;t actually load the klass; just null-check the receiver.
392       __ null_check(receiver_reg);
393     } else {
394       // Load receiver klass itself.
395       __ null_check(receiver_reg, Z_R0, oopDesc::klass_offset_in_bytes());
396       __ load_klass(temp1_recv_klass, receiver_reg);
397       __ verify_klass_ptr(temp1_recv_klass);
398     }
399     BLOCK_COMMENT(&quot;check_receiver {&quot;);
400     // The receiver for the MemberName must be in receiver_reg.
401     // Check the receiver against the MemberName.clazz.
402     if (VerifyMethodHandles &amp;&amp; iid == vmIntrinsics::_linkToSpecial) {
403       // Did not load it above...
404       __ load_klass(temp1_recv_klass, receiver_reg);
405       __ verify_klass_ptr(temp1_recv_klass);
</pre>
<hr />
<pre>
591       // Add descriptions without building a Java frame to avoid issues.
592       values.describe(-1, dump_fp, &quot;fp for #1 &lt;not parsed, cannot trust pc&gt;&quot;);
593       values.describe(-1, dump_sp, &quot;sp&quot;);
594     }
595 
596     bool has_args = has_mh; // Whether Z_esp is meaningful.
597 
598     // Mark args, if seems valid (may not be valid for some adapters).
599     if (has_args) {
600       if ((args &gt;= dump_sp) &amp;&amp; (args &lt; dump_fp)) {
601         values.describe(-1, args, &quot;*Z_esp&quot;);
602       }
603     }
604 
605     // Note: the unextended_sp may not be correct.
606     tty-&gt;print_cr(&quot;  stack layout:&quot;);
607     values.print(p);
608     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
609       mh-&gt;print();
610       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
<span class="line-modified">611         if (java_lang_invoke_MethodHandle::form_offset_in_bytes() != 0) {</span>
<span class="line-removed">612           java_lang_invoke_MethodHandle::form(mh)-&gt;print();</span>
<span class="line-removed">613         }</span>
614       }
615     }
616   }
617 }
618 
619 void MethodHandles::trace_method_handle(MacroAssembler* _masm, const char* adaptername) {
620   if (!log_is_enabled(Info, methodhandles)) { return; }
621 
622   // If arg registers are contiguous, we can use STMG/LMG.
623   assert((Z_ARG5-&gt;encoding() - Z_ARG1-&gt;encoding() + 1) == RegisterImpl::number_of_arg_registers, &quot;Oops&quot;);
624 
625   BLOCK_COMMENT(&quot;trace_method_handle {&quot;);
626 
627   // Save argument registers (they are used in raise exception stub).
628   // Argument registers have contiguous register numbers -&gt; we can use stmg/lmg.
629   __ z_stmg(Z_ARG1, Z_ARG5, 16, Z_SP);
630 
631   // Setup arguments.
632   __ z_lgr(Z_ARG2, Z_ARG4); // mh, see generate_method_handle_interpreter_entry()
633   __ z_lgr(Z_ARG3, Z_R10);  // sender_sp
</pre>
</td>
<td>
<hr />
<pre>
 39 #define __ _masm-&gt;
 40 #define BLOCK_COMMENT(str) /* nothing */
 41 #else
 42 #define __ (Verbose ? (_masm-&gt;block_comment(FILE_AND_LINE),_masm):_masm)-&gt;
 43 #define BLOCK_COMMENT(str) __ block_comment(str)
 44 #endif
 45 
 46 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
 47 
 48 // Workaround for C++ overloading nastiness on &#39;0&#39; for RegisterOrConstant.
 49 static RegisterOrConstant constant(int value) {
 50   return RegisterOrConstant(value);
 51 }
 52 
 53 void MethodHandles::load_klass_from_Class(MacroAssembler* _masm, Register klass_reg,
 54                                           Register temp_reg, Register temp2_reg) {
 55   if (VerifyMethodHandles) {
 56     verify_klass(_masm, klass_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),
 57                  temp_reg, temp2_reg, &quot;MH argument is a Class&quot;);
 58   }
<span class="line-modified"> 59   __ z_lg(klass_reg, Address(klass_reg, java_lang_Class::klass_offset()));</span>
 60 }
 61 
 62 
 63 #ifdef ASSERT
 64 static int check_nonzero(const char* xname, int x) {
 65   assert(x != 0, &quot;%s should be nonzero&quot;, xname);
 66   return x;
 67 }
 68 #define NONZERO(x) check_nonzero(#x, x)
 69 #else
 70 #define NONZERO(x) (x)
 71 #endif
 72 
 73 #ifdef ASSERT
 74 void MethodHandles::verify_klass(MacroAssembler* _masm,
 75                                  Register obj_reg, SystemDictionary::WKID klass_id,
 76                                  Register temp_reg, Register temp2_reg,
 77                                  const char* error_message) {
 78 
 79   InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);
</pre>
<hr />
<pre>
 94   __ z_lg(temp2_reg, Address(temp2_reg));
 95   __ compareU64_and_branch(temp_reg, temp2_reg, Assembler::bcondEqual, L_ok);
 96 
 97   intptr_t super_check_offset = klass-&gt;super_check_offset();
 98   __ z_lg(temp_reg, Address(temp_reg, super_check_offset));
 99   __ compareU64_and_branch(temp_reg, temp2_reg, Assembler::bcondEqual, L_ok);
100   __ BIND(L_bad);
101   __ stop(error_message);
102   __ BIND(L_ok);
103 
104   BLOCK_COMMENT(&quot;} verify_klass&quot;);
105 }
106 
107 void MethodHandles::verify_ref_kind(MacroAssembler* _masm, int ref_kind,
108                                     Register member_reg, Register temp  ) {
109   NearLabel L;
110   BLOCK_COMMENT(&quot;verify_ref_kind {&quot;);
111 
112   __ z_llgf(temp,
113             Address(member_reg,
<span class="line-modified">114                     NONZERO(java_lang_invoke_MemberName::flags_offset())));</span>
115   __ z_srl(temp,  java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT);
116   __ z_nilf(temp, java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK);
117   __ compare32_and_branch(temp, constant(ref_kind), Assembler::bcondEqual, L);
118 
119   {
120     char *buf = NEW_C_HEAP_ARRAY(char, 100, mtInternal);
121 
122     jio_snprintf(buf, 100, &quot;verify_ref_kind expected %x&quot;, ref_kind);
123     if (ref_kind == JVM_REF_invokeVirtual || ref_kind == JVM_REF_invokeSpecial) {
124       // Could do this for all ref_kinds, but would explode assembly code size.
125       trace_method_handle(_masm, buf);
126     }
127     __ stop(buf);
128   }
129 
130   BLOCK_COMMENT(&quot;} verify_ref_kind&quot;);
131 
132   __ bind(L);
133 }
134 #endif // ASSERT
</pre>
<hr />
<pre>
181   __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());
182   __ z_br(target);
183 }
184 
185 void MethodHandles::jump_to_lambda_form(MacroAssembler* _masm,
186                                         Register recv, Register method_temp,
187                                         Register temp2, Register temp3,
188                                         bool for_compiler_entry) {
189 
190   // This is the initial entry point of a lazy method handle.
191   // After type checking, it picks up the invoker from the LambdaForm.
192   assert_different_registers(recv, method_temp, temp2, temp3);
193   assert(method_temp == Z_method, &quot;required register for loading method&quot;);
194 
195   BLOCK_COMMENT(&quot;jump_to_lambda_form {&quot;);
196 
197   // Load the invoker, as MH -&gt; MH.form -&gt; LF.vmentry
198   __ verify_oop(recv, FILE_AND_LINE);
199   __ load_heap_oop(method_temp,
200                    Address(recv,
<span class="line-modified">201                            NONZERO(java_lang_invoke_MethodHandle::form_offset())),</span>
202                    noreg, noreg, IS_NOT_NULL);
203   __ verify_oop(method_temp, FILE_AND_LINE);
204   __ load_heap_oop(method_temp,
205                    Address(method_temp,
<span class="line-modified">206                            NONZERO(java_lang_invoke_LambdaForm::vmentry_offset())),</span>
207                    noreg, noreg, IS_NOT_NULL);
208   __ verify_oop(method_temp, FILE_AND_LINE);
209   __ load_heap_oop(method_temp,
210                    Address(method_temp,
<span class="line-modified">211                            NONZERO(java_lang_invoke_MemberName::method_offset())),</span>
212                    noreg, noreg, IS_NOT_NULL);
213   __ verify_oop(method_temp, FILE_AND_LINE);
214   __ z_lg(method_temp,
215           Address(method_temp,
<span class="line-modified">216                   NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset())));</span>
217 
218   if (VerifyMethodHandles &amp;&amp; !for_compiler_entry) {
219     // Make sure recv is already on stack.
220     NearLabel L;
221     Address paramSize(temp2, ConstMethod::size_of_parameters_offset());
222 
223     __ z_lg(temp2, Address(method_temp, Method::const_offset()));
224     __ load_sized_value(temp2, paramSize, sizeof(u2), /*is_signed*/ false);
225     // if (temp2 != recv) stop
226     __ z_lg(temp2, __ argument_address(temp2, temp2, 0));
227     __ compare64_and_branch(temp2, recv, Assembler::bcondEqual, L);
228     __ stop(&quot;receiver not on stack&quot;);
229     __ BIND(L);
230   }
231 
232   jump_from_method_handle(_masm, method_temp, temp2, Z_R0, for_compiler_entry);
233 
234   BLOCK_COMMENT(&quot;} jump_to_lambda_form&quot;);
235 }
236 
</pre>
<hr />
<pre>
362   if (!for_compiler_entry) {  // Don&#39;t trash last SP.
363     assert_different_registers(temp1, temp2, temp3, temp4, Z_R10);
364   }
365 
366   if (iid == vmIntrinsics::_invokeBasic) {
367     __ pc(); // Just for the block comment.
368     // Indirect through MH.form.vmentry.vmtarget.
369     jump_to_lambda_form(_masm, receiver_reg, Z_method, Z_R1, temp3, for_compiler_entry);
370     return;
371   }
372 
373   // The method is a member invoker used by direct method handles.
374   if (VerifyMethodHandles) {
375     // Make sure the trailing argument really is a MemberName (caller responsibility).
376     verify_klass(_masm, member_reg,
377                  SystemDictionary::WK_KLASS_ENUM_NAME(MemberName_klass),
378                  temp1, temp2,
379                  &quot;MemberName required for invokeVirtual etc.&quot;);
380   }
381 
<span class="line-modified">382   Address  member_clazz(   member_reg, NONZERO(java_lang_invoke_MemberName::clazz_offset()));</span>
<span class="line-modified">383   Address  member_vmindex( member_reg, NONZERO(java_lang_invoke_MemberName::vmindex_offset()));</span>
<span class="line-modified">384   Address  member_vmtarget(member_reg, NONZERO(java_lang_invoke_MemberName::method_offset()));</span>
<span class="line-modified">385   Address  vmtarget_method(Z_method, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset()));</span>
386   Register temp1_recv_klass = temp1;
387 
388   if (iid != vmIntrinsics::_linkToStatic) {
389     __ verify_oop(receiver_reg, FILE_AND_LINE);
390     if (iid == vmIntrinsics::_linkToSpecial) {
391       // Don&#39;t actually load the klass; just null-check the receiver.
392       __ null_check(receiver_reg);
393     } else {
394       // Load receiver klass itself.
395       __ null_check(receiver_reg, Z_R0, oopDesc::klass_offset_in_bytes());
396       __ load_klass(temp1_recv_klass, receiver_reg);
397       __ verify_klass_ptr(temp1_recv_klass);
398     }
399     BLOCK_COMMENT(&quot;check_receiver {&quot;);
400     // The receiver for the MemberName must be in receiver_reg.
401     // Check the receiver against the MemberName.clazz.
402     if (VerifyMethodHandles &amp;&amp; iid == vmIntrinsics::_linkToSpecial) {
403       // Did not load it above...
404       __ load_klass(temp1_recv_klass, receiver_reg);
405       __ verify_klass_ptr(temp1_recv_klass);
</pre>
<hr />
<pre>
591       // Add descriptions without building a Java frame to avoid issues.
592       values.describe(-1, dump_fp, &quot;fp for #1 &lt;not parsed, cannot trust pc&gt;&quot;);
593       values.describe(-1, dump_sp, &quot;sp&quot;);
594     }
595 
596     bool has_args = has_mh; // Whether Z_esp is meaningful.
597 
598     // Mark args, if seems valid (may not be valid for some adapters).
599     if (has_args) {
600       if ((args &gt;= dump_sp) &amp;&amp; (args &lt; dump_fp)) {
601         values.describe(-1, args, &quot;*Z_esp&quot;);
602       }
603     }
604 
605     // Note: the unextended_sp may not be correct.
606     tty-&gt;print_cr(&quot;  stack layout:&quot;);
607     values.print(p);
608     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
609       mh-&gt;print();
610       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
<span class="line-modified">611         java_lang_invoke_MethodHandle::form(mh)-&gt;print();</span>


612       }
613     }
614   }
615 }
616 
617 void MethodHandles::trace_method_handle(MacroAssembler* _masm, const char* adaptername) {
618   if (!log_is_enabled(Info, methodhandles)) { return; }
619 
620   // If arg registers are contiguous, we can use STMG/LMG.
621   assert((Z_ARG5-&gt;encoding() - Z_ARG1-&gt;encoding() + 1) == RegisterImpl::number_of_arg_registers, &quot;Oops&quot;);
622 
623   BLOCK_COMMENT(&quot;trace_method_handle {&quot;);
624 
625   // Save argument registers (they are used in raise exception stub).
626   // Argument registers have contiguous register numbers -&gt; we can use stmg/lmg.
627   __ z_stmg(Z_ARG1, Z_ARG5, 16, Z_SP);
628 
629   // Setup arguments.
630   __ z_lgr(Z_ARG2, Z_ARG4); // mh, see generate_method_handle_interpreter_entry()
631   __ z_lgr(Z_ARG3, Z_R10);  // sender_sp
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRGenerator_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="s390.ad.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/c1_CodeStubs_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../ppc/templateInterpreterGenerator_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/c1_CodeStubs_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2016, 2018 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
336       address ptr = (address)(_pc_start + i);
337       int a_byte = (*ptr) &amp; 0xFF;
338       __ emit_int8 (a_byte);
339     }
340   }
341 
342   address end_of_patch = __ pc();
343   int bytes_to_skip = 0;
344   if (_id == load_mirror_id) {
345     int offset = __ offset();
346     if (CommentedAssembly) {
347       __ block_comment(&quot; being_initialized check&quot;);
348     }
349 
350     // Static field accesses have special semantics while the class
351     // initializer is being run, so we emit a test which can be used to
352     // check that this code is being executed by the initializing
353     // thread.
354     assert(_obj != noreg, &quot;must be a valid register&quot;);
355     assert(_index &gt;= 0, &quot;must have oop index&quot;);
<span class="line-modified">356     __ z_lg(Z_R1_scratch, java_lang_Class::klass_offset_in_bytes(), _obj);</span>
357     __ z_cg(Z_thread, Address(Z_R1_scratch, InstanceKlass::init_thread_offset()));
358     __ branch_optimized(Assembler::bcondNotEqual, call_patch);
359 
360     // Load_klass patches may execute the patched code before it&#39;s
361     // copied back into place so we need to jump back into the main
362     // code of the nmethod to continue execution.
363     __ branch_optimized(Assembler::bcondAlways, _patch_site_continuation);
364 
365     // Make sure this extra code gets skipped.
366     bytes_to_skip += __ offset() - offset;
367   }
368 
369   // Now emit the patch record telling the runtime how to find the
370   // pieces of the patch. We only need 3 bytes but to help the disassembler
371   // we make the data look like a the following add instruction:
372   //   A R1, D2(X2, B2)
373   // which requires 4 bytes.
374   int sizeof_patch_record = 4;
375   bytes_to_skip += sizeof_patch_record;
376 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2016, 2018 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
336       address ptr = (address)(_pc_start + i);
337       int a_byte = (*ptr) &amp; 0xFF;
338       __ emit_int8 (a_byte);
339     }
340   }
341 
342   address end_of_patch = __ pc();
343   int bytes_to_skip = 0;
344   if (_id == load_mirror_id) {
345     int offset = __ offset();
346     if (CommentedAssembly) {
347       __ block_comment(&quot; being_initialized check&quot;);
348     }
349 
350     // Static field accesses have special semantics while the class
351     // initializer is being run, so we emit a test which can be used to
352     // check that this code is being executed by the initializing
353     // thread.
354     assert(_obj != noreg, &quot;must be a valid register&quot;);
355     assert(_index &gt;= 0, &quot;must have oop index&quot;);
<span class="line-modified">356     __ z_lg(Z_R1_scratch, java_lang_Class::klass_offset(), _obj);</span>
357     __ z_cg(Z_thread, Address(Z_R1_scratch, InstanceKlass::init_thread_offset()));
358     __ branch_optimized(Assembler::bcondNotEqual, call_patch);
359 
360     // Load_klass patches may execute the patched code before it&#39;s
361     // copied back into place so we need to jump back into the main
362     // code of the nmethod to continue execution.
363     __ branch_optimized(Assembler::bcondAlways, _patch_site_continuation);
364 
365     // Make sure this extra code gets skipped.
366     bytes_to_skip += __ offset() - offset;
367   }
368 
369   // Now emit the patch record telling the runtime how to find the
370   // pieces of the patch. We only need 3 bytes but to help the disassembler
371   // we make the data look like a the following add instruction:
372   //   A R1, D2(X2, B2)
373   // which requires 4 bytes.
374   int sizeof_patch_record = 4;
375   bytes_to_skip += sizeof_patch_record;
376 
</pre>
</td>
</tr>
</table>
<center><a href="../ppc/templateInterpreterGenerator_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
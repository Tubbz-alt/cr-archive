<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/c1_CodeStubs_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../arm/templateInterpreterGenerator_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/c1_CodeStubs_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
344     for (int i = 0; i &lt; _bytes_to_copy; i++) {
345       address ptr = (address)(_pc_start + i);
346       int a_byte = (*ptr) &amp; 0xFF;
347       __ emit_int8 (a_byte);
348     }
349   }
350 
351   address end_of_patch = __ pc();
352   int bytes_to_skip = 0;
353   if (_id == load_mirror_id) {
354     int offset = __ offset();
355     __ block_comment(&quot; being_initialized check&quot;);
356 
357     // Static field accesses have special semantics while the class
358     // initializer is being run so we emit a test which can be used to
359     // check that this code is being executed by the initializing
360     // thread.
361     assert(_obj != noreg, &quot;must be a valid register&quot;);
362     assert(_index &gt;= 0, &quot;must have oop index&quot;);
363     __ mr(R0, _obj); // spill
<span class="line-modified">364     __ ld(_obj, java_lang_Class::klass_offset_in_bytes(), _obj);</span>
365     __ ld(_obj, in_bytes(InstanceKlass::init_thread_offset()), _obj);
366     __ cmpd(CCR0, _obj, R16_thread);
367     __ mr(_obj, R0); // restore
368     __ bne(CCR0, call_patch);
369 
370     // Load_klass patches may execute the patched code before it&#39;s
371     // copied back into place so we need to jump back into the main
372     // code of the nmethod to continue execution.
373     __ b(_patch_site_continuation);
374 
375     // Make sure this extra code gets skipped.
376     bytes_to_skip += __ offset() - offset;
377   }
378 
379   // Now emit the patch record telling the runtime how to find the
380   // pieces of the patch.  We only need 3 bytes but it has to be
381   // aligned as an instruction so emit 4 bytes.
382   int sizeof_patch_record = 4;
383   bytes_to_skip += sizeof_patch_record;
384 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
344     for (int i = 0; i &lt; _bytes_to_copy; i++) {
345       address ptr = (address)(_pc_start + i);
346       int a_byte = (*ptr) &amp; 0xFF;
347       __ emit_int8 (a_byte);
348     }
349   }
350 
351   address end_of_patch = __ pc();
352   int bytes_to_skip = 0;
353   if (_id == load_mirror_id) {
354     int offset = __ offset();
355     __ block_comment(&quot; being_initialized check&quot;);
356 
357     // Static field accesses have special semantics while the class
358     // initializer is being run so we emit a test which can be used to
359     // check that this code is being executed by the initializing
360     // thread.
361     assert(_obj != noreg, &quot;must be a valid register&quot;);
362     assert(_index &gt;= 0, &quot;must have oop index&quot;);
363     __ mr(R0, _obj); // spill
<span class="line-modified">364     __ ld(_obj, java_lang_Class::klass_offset(), _obj);</span>
365     __ ld(_obj, in_bytes(InstanceKlass::init_thread_offset()), _obj);
366     __ cmpd(CCR0, _obj, R16_thread);
367     __ mr(_obj, R0); // restore
368     __ bne(CCR0, call_patch);
369 
370     // Load_klass patches may execute the patched code before it&#39;s
371     // copied back into place so we need to jump back into the main
372     // code of the nmethod to continue execution.
373     __ b(_patch_site_continuation);
374 
375     // Make sure this extra code gets skipped.
376     bytes_to_skip += __ offset() - offset;
377   }
378 
379   // Now emit the patch record telling the runtime how to find the
380   // pieces of the patch.  We only need 3 bytes but it has to be
381   // aligned as an instruction so emit 4 bytes.
382   int sizeof_patch_record = 4;
383   bytes_to_skip += sizeof_patch_record;
384 
</pre>
</td>
</tr>
</table>
<center><a href="../arm/templateInterpreterGenerator_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
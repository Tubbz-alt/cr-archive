diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/EventWriter.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/EventWriter.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/EventWriter.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/EventWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -33,25 +33,29 @@
  *
  * Users should not have direct access to underlying memory.
  *
  */
 public final class EventWriter {
+
+    // Event may not exceed size for a padded integer
+    private static final long MAX_EVENT_SIZE = (1 << 28) -1;
     private static final Unsafe unsafe = Unsafe.getUnsafe();
     private final static JVM jvm = JVM.getJVM();
 
+    // The JVM needs access to these values. Don't remove
+    private final long threadID;
     private long startPosition;
     private long startPositionAddress;
     private long currentPosition;
     private long maxPosition;
-    private final long threadID;
+    private boolean valid;
+    boolean notified; // Not private to avoid being optimized away
+
     private PlatformEventType eventType;
-    private int maxEventSize;
     private boolean started;
-    private boolean valid;
     private boolean flushOnEnd;
-    // set by the JVM, not private to avoid being optimized out
-    boolean notified;
+    private boolean largeSize = false;
 
     public static EventWriter getEventWriter() {
         EventWriter ew = (EventWriter)JVM.getEventWriter();
         return ew != null ? ew : JVM.newEventWriter();
     }
@@ -173,13 +177,19 @@
             putLong(0L);
         }
     }
 
     private void reserveEventSizeField() {
-        // move currentPosition Integer.Bytes offset from start position
-        if (isValidForSize(Integer.BYTES)) {
-            currentPosition += Integer.BYTES;
+        this.largeSize = eventType.isLargeSize();
+        if (largeSize) {
+            if (isValidForSize(Integer.BYTES)) {
+                currentPosition +=  Integer.BYTES;
+            }
+        } else {
+            if (isValidForSize(1)) {
+                currentPosition += 1;
+            }
         }
     }
 
     private void reset() {
         currentPosition = startPosition;
@@ -240,15 +250,29 @@
         if (!valid) {
             reset();
             return true;
         }
         final int eventSize = usedSize();
-        if (eventSize > maxEventSize) {
+        if (eventSize > MAX_EVENT_SIZE) {
             reset();
             return true;
         }
-        Bits.putInt(startPosition, makePaddedInt(eventSize));
+
+        if (largeSize) {
+            Bits.putInt(startPosition, makePaddedInt(eventSize));
+        } else {
+            if (eventSize < 128) {
+                Bits.putByte(startPosition, (byte) eventSize);
+            } else {
+                eventType.setLargeSize();
+                reset();
+                // returning false will trigger restart of the
+                // event write attempt
+                return false;
+            }
+        }
+
         if (isNotified()) {
             resetNotified();
             reset();
             // returning false will trigger restart of the event write attempt
             return false;
@@ -271,12 +295,10 @@
         this.threadID = threadID;
         started = false;
         flushOnEnd = false;
         this.valid = valid;
         notified = false;
-        // event may not exceed size for a padded integer
-        maxEventSize = (1 << 28) -1;
     }
 
     private static int makePaddedInt(int v) {
         // bit  0-6 + pad => bit 24 - 31
         long b1 = (((v >>> 0) & 0x7F) | 0x80) << 24;

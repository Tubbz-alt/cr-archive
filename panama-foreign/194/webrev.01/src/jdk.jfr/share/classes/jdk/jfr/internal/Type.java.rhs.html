<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/Type.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Collection;
 30 import java.util.Collections;
 31 import java.util.HashMap;
<a name="1" id="anc1"></a><span class="line-added"> 32 import java.util.LinkedHashMap;</span>
 33 import java.util.List;
 34 import java.util.Map;
 35 import java.util.Objects;
 36 
 37 import jdk.jfr.AnnotationElement;
 38 import jdk.jfr.Event;
 39 import jdk.jfr.SettingControl;
 40 import jdk.jfr.ValueDescriptor;
 41 
 42 /**
 43  * Internal data structure that describes a type,
 44  *
 45  * Used to create event types, value descriptor and annotations.
 46  *
 47  */
 48 public class Type implements Comparable&lt;Type&gt; {
 49     public static final String SUPER_TYPE_ANNOTATION = java.lang.annotation.Annotation.class.getName();
 50     public static final String SUPER_TYPE_SETTING = SettingControl.class.getName();
 51     public static final String SUPER_TYPE_EVENT = Event.class.getName();
 52     public static final String EVENT_NAME_PREFIX = &quot;jdk.&quot;;
 53     public static final String TYPES_PREFIX = &quot;jdk.types.&quot;;
 54     public static final String SETTINGS_PREFIX = &quot;jdk.settings.&quot;;
 55 
 56 
<a name="2" id="anc2"></a><span class="line-modified"> 57     // To bootstrap the type system, the supported Java types</span>
<span class="line-modified"> 58     // are available here as statics. When metadata.xml is parsed</span>
<span class="line-modified"> 59     // fields are added to THREAD and STACK_TRACE.</span>
<span class="line-modified"> 60     private final static Map&lt;Type, Class&lt;?&gt;&gt; knownTypes = new LinkedHashMap&lt;&gt;();</span>
<span class="line-modified"> 61     static final Type BOOLEAN = createKnownType(boolean.class);</span>
<span class="line-modified"> 62     static final Type CHAR = createKnownType(char.class);</span>
<span class="line-modified"> 63     static final Type FLOAT = createKnownType(float.class);</span>
<span class="line-modified"> 64     static final Type DOUBLE = createKnownType(double.class);</span>
<span class="line-modified"> 65     static final Type BYTE = createKnownType(byte.class);</span>
<span class="line-modified"> 66     static final Type SHORT = createKnownType(short.class);</span>
<span class="line-modified"> 67     static final Type INT = createKnownType(int.class);</span>
<span class="line-modified"> 68     static final Type LONG = createKnownType(long.class);</span>
<span class="line-modified"> 69     static final Type CLASS = createKnownType(Class.class);</span>
<span class="line-modified"> 70     static final Type STRING = createKnownType(String.class);</span>
<span class="line-added"> 71     static final Type THREAD = createKnownType(Thread.class);</span>
<span class="line-added"> 72     static final Type STACK_TRACE = createKnownType(TYPES_PREFIX + &quot;StackTrace&quot;, null);</span>
<span class="line-added"> 73 </span>
<span class="line-added"> 74     private static Type createKnownType(Class&lt;?&gt; clazz) {</span>
<span class="line-added"> 75         return createKnownType(clazz.getName(), clazz);</span>
<span class="line-added"> 76     }</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78     private static Type createKnownType(String name, Class&lt;?&gt; clazz) {</span>
<span class="line-added"> 79         long id = JVM.getJVM().getTypeId(name);</span>
<span class="line-added"> 80         Type t =  new Type(name, null, id);</span>
<span class="line-added"> 81         knownTypes.put(t, clazz);</span>
<span class="line-added"> 82         return t;</span>
<span class="line-added"> 83     }</span>
 84 
 85     private final AnnotationConstruct annos = new AnnotationConstruct();
 86     private final String name;
 87     private final String superType;
<a name="3" id="anc3"></a>
 88     private List&lt;ValueDescriptor&gt; fields = new ArrayList&lt;&gt;();
 89     private Boolean simpleType; // calculated lazy
 90     private boolean remove = true;
 91     private long id;
 92 
 93     /**
 94      * Creates a type
 95      *
 96      * @param javaTypeName i.e &quot;java.lang.String&quot;
 97      * @param superType i.e &quot;java.lang.Annotation&quot;
 98      * @param typeId the class id that represents the class in the JVM
 99      *
100      */
101     public Type(String javaTypeName, String superType, long typeId) {
<a name="4" id="anc4"></a><span class="line-modified">102         this(javaTypeName, superType, typeId, null);</span>




103     }
104 
<a name="5" id="anc5"></a><span class="line-modified">105     Type(String javaTypeName, String superType, long typeId, Boolean simpleType) {</span>
106         Objects.requireNonNull(javaTypeName);
107 
108         if (!isValidJavaIdentifier(javaTypeName)) {
109             throw new IllegalArgumentException(javaTypeName + &quot; is not a valid Java identifier&quot;);
110         }
<a name="6" id="anc6"></a>
111         this.superType = superType;
112         this.name = javaTypeName;
113         this.id = typeId;
114         this.simpleType = simpleType;
115     }
116 
117     static boolean isDefinedByJVM(long id) {
118         return id &lt; JVM.RESERVED_CLASS_ID_LIMIT;
119     }
120 
121     public static long getTypeId(Class&lt;?&gt; clazz) {
122         Type type = Type.getKnownType(clazz);
123         return type == null ? JVM.getJVM().getTypeId(clazz) : type.getId();
124     }
125 
126     static Collection&lt;Type&gt; getKnownTypes() {
127         return knownTypes.keySet();
128     }
129 
130     public static boolean isValidJavaIdentifier(String identifier) {
131         if (identifier.isEmpty()) {
132             return false;
133         }
134         if (!Character.isJavaIdentifierStart(identifier.charAt(0))) {
135             return false;
136         }
137         for (int i = 1; i &lt; identifier.length(); i++) {
138             char c = identifier.charAt(i);
139             if (c != &#39;.&#39;) {
140                 if (!Character.isJavaIdentifierPart(c)) {
141                     return false;
142                 }
143             }
144         }
145         return true;
146     }
147 
148     public static boolean isValidJavaFieldType(String name) {
149         for (Map.Entry&lt;Type, Class&lt;?&gt;&gt; entry : knownTypes.entrySet()) {
150             Class&lt;?&gt; clazz = entry.getValue();
151             if (clazz != null &amp;&amp; name.equals(clazz.getName())) {
152                 return true;
153             }
154         }
155         return false;
156     }
157 
158     public static Type getKnownType(String typeName) {
159         for (Type type : knownTypes.keySet()) {
160             if (type.getName().equals(typeName)) {
161                 return type;
162             }
163         }
164         return null;
165     }
166 
167     static boolean isKnownType(Class&lt;?&gt; type) {
168         if (type.isPrimitive()) {
169             return true;
170         }
171         if (type.equals(Class.class) || type.equals(Thread.class) || type.equals(String.class)) {
172             return true;
173         }
174         return false;
175     }
176 
177     public static Type getKnownType(Class&lt;?&gt; clazz) {
178         for (Map.Entry&lt;Type, Class&lt;?&gt;&gt; entry : knownTypes.entrySet()) {
179             if (clazz != null &amp;&amp; clazz.equals(entry.getValue())) {
180                 return entry.getKey();
181             }
182         }
183         return null;
184     }
185 
186     public String getName() {
187         return name;
188     }
189 
190     public String getLogName() {
191        return getName() + &quot;(&quot; + getId() + &quot;)&quot;;
192     }
193 
194     public List&lt;ValueDescriptor&gt; getFields() {
195         if (fields instanceof ArrayList) {
196             ((ArrayList&lt;ValueDescriptor&gt;) fields).trimToSize();
197             fields = Collections.unmodifiableList(fields);
198         }
199         return fields;
200     }
201 
202     public boolean isSimpleType() {
203         if (simpleType == null) {
204             simpleType = calculateSimpleType();
205         }
206         return simpleType.booleanValue();
207     }
208 
209     private boolean calculateSimpleType() {
210         if (fields.size() != 1) {
211             return false;
212         }
213         // annotation, settings and event can never be simple types
214         return superType == null;
215     }
216 
217     public boolean isDefinedByJVM() {
218         return id &lt; JVM.RESERVED_CLASS_ID_LIMIT;
219     }
220 
<a name="7" id="anc7"></a>




221     public void add(ValueDescriptor valueDescriptor) {
222         Objects.requireNonNull(valueDescriptor);
223         fields.add(valueDescriptor);
224     }
225 
226     void trimFields() {
227         getFields();
228     }
229 
230     void setAnnotations(List&lt;AnnotationElement&gt; annotations) {
231         annos.setAnnotationElements(annotations);
232     }
233 
234     public String getSuperType() {
235         return superType;
236     }
237 
238     public long getId() {
239         return id;
240     }
241 
<a name="8" id="anc8"></a>



242     public String getLabel() {
243         return annos.getLabel();
244     }
245 
246     public List&lt;AnnotationElement&gt; getAnnotationElements() {
247         return annos.getUnmodifiableAnnotationElements();
248     }
249 
250     public &lt;T&gt; T getAnnotation(Class&lt;? extends java.lang.annotation.Annotation&gt; clazz) {
251         return annos.getAnnotation(clazz);
252     }
253 
254     public String getDescription() {
255         return annos.getDescription();
256     }
257 
258     @Override
259     public int hashCode() {
260         return Long.hashCode(id);
261     }
262 
263     @Override
264     public boolean equals(Object object) {
265         if (object instanceof Type) {
266             Type that = (Type) object;
267             return that.id == this.id;
268         }
269         return false;
270     }
271 
272     @Override
273     public int compareTo(Type that) {
274         return Long.compare(this.id, that.id);
275     }
276 
277     void log(String action, LogTag logTag, LogLevel level) {
278         if (Logger.shouldLog(logTag, level) &amp;&amp; !isSimpleType()) {
279             Logger.log(logTag, LogLevel.TRACE, action + &quot; &quot; + typeText() + &quot; &quot; + getLogName() + &quot; {&quot;);
280             for (ValueDescriptor v : getFields()) {
281                 String array = v.isArray() ? &quot;[]&quot; : &quot;&quot;;
282                 Logger.log(logTag, LogLevel.TRACE, &quot;  &quot; + v.getTypeName() + array + &quot; &quot; + v.getName() + &quot;;&quot;);
283             }
284             Logger.log(logTag, LogLevel.TRACE, &quot;}&quot;);
285         } else {
286             if (Logger.shouldLog(logTag, LogLevel.INFO) &amp;&amp; !isSimpleType()) {
287                 Logger.log(logTag, LogLevel.INFO, action + &quot; &quot; + typeText() + &quot; &quot; + getLogName());
288             }
289         }
290     }
291 
292     private String typeText() {
293         if (this instanceof PlatformEventType) {
294             return &quot;event type&quot;;
295         }
296         if (Type.SUPER_TYPE_SETTING.equals(superType)) {
297             return &quot;setting type&quot;;
298         }
299         if (Type.SUPER_TYPE_ANNOTATION.equals(superType)) {
300             return &quot;annotation type&quot;;
301         }
302         return &quot;type&quot;;
303     }
304 
305     @Override
306     public String toString() {
307         StringBuilder sb = new StringBuilder();
308         sb.append(getLogName());
309         if (!getFields().isEmpty()) {
310             sb.append(&quot; {\n&quot;);
311             for (ValueDescriptor td : getFields()) {
312                 sb.append(&quot;  type=&quot; + td.getTypeName() + &quot;(&quot; + td.getTypeId() + &quot;) name=&quot; + td.getName() + &quot;\n&quot;);
313             }
314             sb.append(&quot;}\n&quot;);
315         }
316         return sb.toString();
317     }
318 
319     public void setRemove(boolean remove) {
320        this.remove = remove;
321     }
322 
323     public boolean getRemove() {
324         return remove;
325     }
326 
327     public void setId(long id) {
328         this.id = id;
329     }
330 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
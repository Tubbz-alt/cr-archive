<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/compiler/arraycopy/TestEliminateArrayCopy.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<a name="2" id="anc2"></a><span class="line-modified"> 26  * @bug 8076188</span>
 27  * @summary arraycopy to non escaping destination may be eliminated
 28  * @library /
 29  *
 30  * @run main/othervm -ea -XX:-BackgroundCompilation -XX:-UseOnStackReplacement
 31  *                   -XX:CompileCommand=dontinline,compiler.arraycopy.TestEliminateArrayCopy*::m*
 32  *                   compiler.arraycopy.TestEliminateArrayCopy
<a name="3" id="anc3"></a><span class="line-modified"> 33  *</span>



 34  */
 35 
 36 package compiler.arraycopy;
 37 
 38 public class TestEliminateArrayCopy {
 39 
 40     static class CloneTests extends TestInstanceCloneUtils {
 41         // object allocation and ArrayCopyNode should be eliminated
 42         static void m1(E src) throws CloneNotSupportedException {
 43             src.clone();
 44         }
 45 
 46         // both object allocations and ArrayCopyNode should be eliminated
 47         static void m2(Object dummy) throws CloneNotSupportedException {
 48             E src = new E(false);
 49             src.clone();
 50         }
 51 
 52         // object allocation and ArrayCopyNode should be eliminated. Fields should be loaded from src.
 53         static int m3(E src) throws CloneNotSupportedException {
 54             E dest = (E)src.clone();
 55             return dest.i1 + dest.i2 + dest.i3 + dest.i4 + dest.i5 +
 56                 dest.i6 + dest.i7 + dest.i8 + dest.i9;
 57         }
 58     }
 59 
 60     static class ArrayCopyTests extends TestArrayCopyUtils {
 61 
 62         // object allocation and ArrayCopyNode should be eliminated.
 63         @Args(src=ArraySrc.LARGE)
 64         static int m1() throws CloneNotSupportedException {
 65             int[] array_clone = (int[])large_int_src.clone();
 66             return array_clone[0] + array_clone[1] + array_clone[2] +
 67                 array_clone[3] + array_clone[4] + array_clone[5] +
 68                 array_clone[6] + array_clone[7] + array_clone[8] +
 69                 array_clone[9];
 70         }
 71 
 72         // object allocation and ArrayCopyNode should be eliminated.
 73         @Args(src=ArraySrc.LARGE)
 74         static int m2() {
 75             int[] dest = new int[10];
 76             System.arraycopy(large_int_src, 0, dest, 0, 10);
 77             return dest[0] + dest[1] + dest[2] + dest[3] + dest[4] +
 78                 dest[5] + dest[6] + dest[7] + dest[8] + dest[9];
 79         }
 80 
 81         // object allocations and ArrayCopyNodes should be eliminated.
 82         @Args(src=ArraySrc.LARGE)
 83         static int m3() {
 84             int[] dest1 = new int[10];
 85             System.arraycopy(large_int_src, 0, dest1, 0, 10);
 86 
 87             int[] dest2 = new int[10];
 88             System.arraycopy(dest1, 0, dest2, 0, 10);
 89 
 90             return dest2[0] + dest2[1] + dest2[2] + dest2[3] + dest2[4] +
 91                 dest2[5] + dest2[6] + dest2[7] + dest2[8] + dest2[9];
 92         }
 93 
 94         static class m4_class {
 95             Object f;
 96         }
 97 
 98         static void m4_helper() {}
 99 
100         // allocations eliminated and arraycopy optimized out
101         @Args(src=ArraySrc.LARGE)
102         static int m4() {
103             int[] dest = new int[10];
104             m4_class o = new m4_class();
105             o.f = dest;
106             m4_helper();
107             System.arraycopy(large_int_src, 0, o.f, 0, 10);
108             return dest[0] + dest[1] + dest[2] + dest[3] + dest[4] +
109                 dest[5] + dest[6] + dest[7] + dest[8] + dest[9];
110         }
111 
112         static void m5_helper() {}
113 
114         // Small copy cannot be converted to loads/stores because
115         // allocation is not close enough to arraycopy but arraycopy
116         // itself can be eliminated
117         @Args(src=ArraySrc.SMALL, dst=ArrayDst.NEW)
118         static void m5(A[] src, A[] dest) {
119             A[] temp = new A[5];
120             m5_helper();
121             System.arraycopy(src, 0, temp, 0, 5);
122             dest[0] = temp[0];
123             dest[1] = temp[1];
124             dest[2] = temp[2];
125             dest[3] = temp[3];
126             dest[4] = temp[4];
127         }
128 
129         // object allocation and ArrayCopyNode should be eliminated.
130         @Args(src=ArraySrc.LARGE)
131         static int m6(int [] src) {
132             int res = src[0] + src[1] + src[2] + src[3] + src[4] +
133                 src[5] + src[6] + src[7] + src[8] + src[9];
134 
135             int[] dest = new int[10];
136 
137             System.arraycopy(src, 0, dest, 0, 10);
138 
139             res += dest[0] + dest[1] + dest[2] + dest[3] + dest[4] +
140                 dest[5] + dest[6] + dest[7] + dest[8] + dest[9];
141             return res/2;
142         }
143 
144         @Args(src=ArraySrc.LARGE)
145         static int m7() {
146             int[] dest = new int[10];
147             dest[0] = large_int_src[8];
148             dest[1] = large_int_src[9];
149             System.arraycopy(large_int_src, 0, dest, 2, 8);
150             return dest[0] + dest[1] + dest[2] + dest[3] + dest[4] +
151                 dest[5] + dest[6] + dest[7] + dest[8] + dest[9];
152         }
153     }
154 
155     // test that OptimizePtrCompare still works
156     static final Object[] m1_array = new Object[10];
157     static boolean m1_array_null_element = false;
158     static void m1(int i) {
159         Object[] array_clone = (Object[])m1_array.clone();
160         if (array_clone[i] == null) {
161             m1_array_null_element = true;
162         }
163     }
164 
165     static public void main(String[] args) throws Exception {
166         CloneTests clone_tests = new CloneTests();
167 
168         clone_tests.doTest(clone_tests.e, &quot;m1&quot;);
169         clone_tests.doTest(null, &quot;m2&quot;);
170         clone_tests.doTest(clone_tests.e, &quot;m3&quot;);
171 
172         ArrayCopyTests ac_tests = new ArrayCopyTests();
173 
174         ac_tests.doTest(&quot;m1&quot;);
175         ac_tests.doTest(&quot;m2&quot;);
176         ac_tests.doTest(&quot;m3&quot;);
177         ac_tests.doTest(&quot;m4&quot;);
178         ac_tests.doTest(&quot;m5&quot;);
179         ac_tests.doTest(&quot;m6&quot;);
180         ac_tests.doTest(&quot;m7&quot;);
181 
182         if (!clone_tests.success || !ac_tests.success) {
183             throw new RuntimeException(&quot;some tests failed&quot;);
184         }
185 
186         // Make sure both branches of the if in m1() appear taken
187         for (int i = 0; i &lt; 7000; i++) {
188             m1(0);
189         }
190         m1_array[0] = new Object();
191         for (int i = 0; i &lt; 20000; i++) {
192             m1(0);
193         }
194         m1_array_null_element = false;
195         m1(0);
196         if (m1_array_null_element) {
197             throw new RuntimeException(&quot;OptimizePtrCompare test failed&quot;);
198         }
199     }
200 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
diff a/test/hotspot/jtreg/vmTestbase/gc/huge/quicklook/largeheap/Access/access.java b/test/hotspot/jtreg/vmTestbase/gc/huge/quicklook/largeheap/Access/access.java
--- a/test/hotspot/jtreg/vmTestbase/gc/huge/quicklook/largeheap/Access/access.java
+++ b/test/hotspot/jtreg/vmTestbase/gc/huge/quicklook/largeheap/Access/access.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -51,14 +51,14 @@
  * @run main/othervm -XX:-UseGCOverheadLimit gc.huge.quicklook.largeheap.Access.access
  */
 
 package gc.huge.quicklook.largeheap.Access;
 
-import java.util.concurrent.ThreadLocalRandom;
 import java.util.ArrayList;
 import nsk.share.TestFailure;
 import nsk.share.gc.*;
+import nsk.share.test.LocalRandom;
 
 public class access extends ThreadedGCTest {
 
     // The test should fill just about 30% of 4G range (32-bit address range)
     final static double PART_OF_HEAP = 0.3;
@@ -163,10 +163,12 @@
 
     class MainWorker implements Runnable {
 
         @Override
         public void run() {
+            // ensure LocalRandom is loaded and has enough memory
+            LocalRandom.init();
             synchronized (lock) {
                 for (int i = 0; i < STORAGE_SIZE_DIM1; i++) {
                     if (!getExecutionController().continueExecution()) {
                         log.debug("Test run out of time before 4G were allocated");
                         lock.notifyAll();
@@ -176,15 +178,14 @@
                 }
                 log.debug("The 4G are allocated, starting to test");
                 is4GAllocated = true;
                 lock.notifyAll();
             }
-            ThreadLocalRandom random = ThreadLocalRandom.current();
             while (getExecutionController().continueExecution()) {
-                int i = random.nextInt(STORAGE_SIZE_DIM1);
-                int j = random.nextInt(STORAGE_SIZE_DIM2);
-                long value = random.nextLong(Long.MAX_VALUE);
+                int i = LocalRandom.nextInt(STORAGE_SIZE_DIM1);
+                int j = LocalRandom.nextInt(STORAGE_SIZE_DIM2);
+                long value = LocalRandom.nextLong();
                 storage[i][j] = value;
                 if (storage[i][j] != value) {
                     throw new TestFailure("The value = "
                             + storage[i][j] + " when expected ="
                             + value);

diff a/test/hotspot/jtreg/vmTestbase/gc/gctests/JumbleGC002/JumbleGC002.java b/test/hotspot/jtreg/vmTestbase/gc/gctests/JumbleGC002/JumbleGC002.java
--- a/test/hotspot/jtreg/vmTestbase/gc/gctests/JumbleGC002/JumbleGC002.java
+++ b/test/hotspot/jtreg/vmTestbase/gc/gctests/JumbleGC002/JumbleGC002.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -21,11 +21,11 @@
  * questions.
  */
 
 /*
  * @test
- * @key stress gc
+ * @key stress gc randomness
  *
  * @summary converted from VM Testbase gc/gctests/JumbleGC002.
  * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent, quarantine]
  * VM Testbase readme:
  * DESCRIPTION
@@ -56,14 +56,14 @@
 
 package gc.gctests.JumbleGC002;
 
 import java.io.*;
 import java.util.*;
-import java.util.concurrent.ThreadLocalRandom;
 
 import nsk.share.*;
 import nsk.share.gc.*;
+import nsk.share.test.LocalRandom;
 
 /**
  * This test simply does Algorithms.eatMemory() in a loop
  * in multiple threads.
  */
@@ -87,11 +87,10 @@
         private Vector vector;
         int numberOfElements;
         int numberOfQuarters;
         int id;
         int nodes;
-        ThreadLocalRandom random = ThreadLocalRandom.current();
 
         public Eater(int id, int numberOfQuarters, int nodes) {
             this.numberOfQuarters = numberOfQuarters;
             numberOfElements = 4 * numberOfQuarters;
             this.id = id;
@@ -121,28 +120,28 @@
         // element in the quarter is a NonbranchyTree.
         private void fillVector() {
             for (int i = 0; i < numberOfQuarters; i++) {
 
                 // Append initialized long[]
-                int length = random.nextInt(ARRAY_MAX_LENGTH);
+                int length = LocalRandom.nextInt(ARRAY_MAX_LENGTH);
                 long[] l = new long[length];
                 for (int j = 0; j < length; j++) {
                     l[j] = (long) j;
                 }
                 if (vector.elementAt(4 * i) == null) {
                     vector.setElementAt(l, 4 * i);
                 }
 
                 // Append not initialized double[]
-                length = random.nextInt(ARRAY_MAX_LENGTH);
+                length = LocalRandom.nextInt(ARRAY_MAX_LENGTH);
                 double[] d = new double[length];
                 if (vector.elementAt(4 * i + 1) == null) {
                     vector.setElementAt(d, 4 * i + 1);
                 }
 
                 // Append initialized int[]
-                length = random.nextInt(ARRAY_MAX_LENGTH);
+                length = LocalRandom.nextInt(ARRAY_MAX_LENGTH);
                 int[] n = new int[length];
                 for (int j = 0; j < length; j++) {
                     n[j] = j;
                 }
                 if (vector.elementAt(4 * i + 2) == null) {
@@ -160,11 +159,11 @@
             }
         }
 
         // Drop references to half of the elements of the vector
         private void cleanVector() {
-            int index = random.nextInt(numberOfElements / 2);
+            int index = LocalRandom.nextInt(numberOfElements / 2);
             for (int i = index; i < index + numberOfElements / 2; i++) {
                 vector.setElementAt(null, i);
             }
         }
     }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/gc/gctests/JumbleGC002/JumbleGC002.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<a name="2" id="anc2"></a><span class="line-modified"> 26  * @key stress gc</span>
 27  *
 28  * @summary converted from VM Testbase gc/gctests/JumbleGC002.
 29  * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent, quarantine]
 30  * VM Testbase readme:
 31  * DESCRIPTION
 32  *     The test checks that Garbage Collector can manage jumble in the JVM. The
 33  *     test fails if any unexpected exceptions and errors are thrown or the JVM
 34  *     is not crashed.
 35  *     The test starts a number of threads that is set in *.cfg file or calculates
 36  *     that value based on the machine. All threads have
 37  *     java.util.Vector field anf they fill that vector with 4 types of objects:
 38  *         1. Initialized long[]
 39  *         2. Uninitialized double[]
 40  *         3. Initialized int[]
 41  *         4. A nsk.share.gc.NonbranchyTree (number of nodes and their size depend
 42  *            on valkue returned by Runtime.maxMemory())
 43  *     As soon as the vector is filled, each thread removes half elements of it and
 44  *     then fills those places of the vector again. However, all threads use just
 45  *     about 10% of maximum amount of memory that JVM attemts to use, so
 46  *     OutOfMemoryError is treated as a failure. That means GC does not work
 47  *     quickly enough to destroy all objects that do not have references. The
 48  *     procedure of filling and cleaning of the vector is repeated for
 49  *     INTERNAL_ITERATIONS times.
 50  *
 51  * @library /vmTestbase
 52  *          /test/lib
 53  * @run driver jdk.test.lib.FileInstaller . .
 54  * @run main/othervm -XX:-UseGCOverheadLimit gc.gctests.JumbleGC002.JumbleGC002
 55  */
 56 
 57 package gc.gctests.JumbleGC002;
 58 
 59 import java.io.*;
 60 import java.util.*;
<a name="3" id="anc3"></a><span class="line-removed"> 61 import java.util.concurrent.ThreadLocalRandom;</span>
 62 
 63 import nsk.share.*;
 64 import nsk.share.gc.*;
<a name="4" id="anc4"></a>
 65 
 66 /**
 67  * This test simply does Algorithms.eatMemory() in a loop
 68  * in multiple threads.
 69  */
 70 public class JumbleGC002 extends ThreadedGCTest {
 71 
 72     // The test should fill just about 10% of the heap
 73     final static double PART_OF_HEAP = 0.1;
 74     // Maximum number of elements in an array of primitive types
 75     final static int ARRAY_MAX_LENGTH = 10;
 76     // Internal number of iterations to create new objects and to drop
 77     // references
 78     final static int INTERNAL_ITERATIONS = 150;
 79     // Size of core for each node of a tree
 80     final static int EACH_NODE_SIZE = 1;
 81     // Number of bytes that arrays of primitive types take in the vector
 82     final static long PRIMITIVE_ARRAYS_SIZE = (long) (8 * ARRAY_MAX_LENGTH
 83             + 8 * ARRAY_MAX_LENGTH + 4 * ARRAY_MAX_LENGTH);
 84 
 85     private class Eater implements Runnable {
 86 
 87         private Vector vector;
 88         int numberOfElements;
 89         int numberOfQuarters;
 90         int id;
 91         int nodes;
<a name="5" id="anc5"></a><span class="line-removed"> 92         ThreadLocalRandom random = ThreadLocalRandom.current();</span>
 93 
 94         public Eater(int id, int numberOfQuarters, int nodes) {
 95             this.numberOfQuarters = numberOfQuarters;
 96             numberOfElements = 4 * numberOfQuarters;
 97             this.id = id;
 98             this.nodes = nodes;
 99         }
100 
101         public void run() {
102             // Make jumble in the heap!
103             initVector();
104             while (getExecutionController().continueExecution()) {
105                 fillVector();
106                 cleanVector();
107             }
108         }
109 
110         // Initialize the vector and build appropriate number of cells in it
111         private void initVector() {
112             vector = new Vector();
113             for (int i = 0; i &lt; numberOfElements; i++) {
114                 vector.addElement(null);
115             }
116         }
117 
118         // Fill the vector. It is devided into quarters. Each quarters has an
119         // initialized array of long and int, and uninitialized array of double.
120         // Each array has not more than ARRAY_MAX_LENGTH elements. The fourth
121         // element in the quarter is a NonbranchyTree.
122         private void fillVector() {
123             for (int i = 0; i &lt; numberOfQuarters; i++) {
124 
125                 // Append initialized long[]
<a name="6" id="anc6"></a><span class="line-modified">126                 int length = random.nextInt(ARRAY_MAX_LENGTH);</span>
127                 long[] l = new long[length];
128                 for (int j = 0; j &lt; length; j++) {
129                     l[j] = (long) j;
130                 }
131                 if (vector.elementAt(4 * i) == null) {
132                     vector.setElementAt(l, 4 * i);
133                 }
134 
135                 // Append not initialized double[]
<a name="7" id="anc7"></a><span class="line-modified">136                 length = random.nextInt(ARRAY_MAX_LENGTH);</span>
137                 double[] d = new double[length];
138                 if (vector.elementAt(4 * i + 1) == null) {
139                     vector.setElementAt(d, 4 * i + 1);
140                 }
141 
142                 // Append initialized int[]
<a name="8" id="anc8"></a><span class="line-modified">143                 length = random.nextInt(ARRAY_MAX_LENGTH);</span>
144                 int[] n = new int[length];
145                 for (int j = 0; j &lt; length; j++) {
146                     n[j] = j;
147                 }
148                 if (vector.elementAt(4 * i + 2) == null) {
149                     vector.setElementAt(n, 4 * i + 2);
150                 }
151 
152                 // Append a tree. Every even thread has a &quot;bent&quot; tree.
153                 NonbranchyTree tree = new NonbranchyTree(nodes, 0.3f, EACH_NODE_SIZE);
154                 if (id % 2 == 0) {
155                     tree.bend();
156                 }
157                 if (vector.elementAt(4 * i + 3) == null) {
158                     vector.setElementAt(tree, 4 * i + 3);
159                 }
160             }
161         }
162 
163         // Drop references to half of the elements of the vector
164         private void cleanVector() {
<a name="9" id="anc9"></a><span class="line-modified">165             int index = random.nextInt(numberOfElements / 2);</span>
166             for (int i = index; i &lt; index + numberOfElements / 2; i++) {
167                 vector.setElementAt(null, i);
168             }
169         }
170     }
171 
172     protected Runnable createRunnable(int i) {
173         // Perform calculations specific to the test
174         long memoryForThread = (long) (Runtime.getRuntime().maxMemory() * PART_OF_HEAP / runParams.getNumberOfThreads());
175         int numberOfQuarters;
176 
177         if (i == 0) {
178             // The very first thread
179             numberOfQuarters = 1;
180         } else {
181             // All other threads
182             numberOfQuarters = 8;
183         }
184 
185         // Calculate number of nodes for a tree depending on number of
186         // elements in the Vector
187 
188         double freeMemory = (double) memoryForThread / numberOfQuarters
189                 - (double) PRIMITIVE_ARRAYS_SIZE;
190         int nodes = (int) (freeMemory / (NonbranchyTree.MIN_NODE_SIZE + EACH_NODE_SIZE));
191         nodes = Math.max(1, nodes);
192         log.debug(&quot;Thread &quot; + i + &quot; has a tree with &quot;
193                 + nodes + &quot; node(s).&quot;);
194 
195         return new Eater(i, numberOfQuarters, nodes);
196     }
197 
198     public static void main(String args[]) {
199         GC.runTest(new JumbleGC002(), args);
200     }
201 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
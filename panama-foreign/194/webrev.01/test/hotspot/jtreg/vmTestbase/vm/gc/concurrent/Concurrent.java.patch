diff a/test/hotspot/jtreg/vmTestbase/vm/gc/concurrent/Concurrent.java b/test/hotspot/jtreg/vmTestbase/vm/gc/concurrent/Concurrent.java
--- a/test/hotspot/jtreg/vmTestbase/vm/gc/concurrent/Concurrent.java
+++ b/test/hotspot/jtreg/vmTestbase/vm/gc/concurrent/Concurrent.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,11 +23,10 @@
 package vm.gc.concurrent;
 
 import java.lang.management.ManagementFactory;
 import java.lang.management.MemoryMXBean;
 import java.lang.management.MemoryUsage;
-import java.util.Random;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 import nsk.share.TestFailure;
 import nsk.share.gc.GC;
@@ -39,11 +38,11 @@
 import nsk.share.gc.gp.MemoryStrategy;
 import nsk.share.gc.gp.MemoryStrategyAware;
 import nsk.share.gc.tree.*;
 import nsk.share.log.Log;
 import nsk.share.test.ExecutionController;
-
+import nsk.share.test.LocalRandom;
 
 class Forest {
 
     // the actual size of TreeNode in bytes in the memory calculated as occupied memory / count of nodes
     static int nodeSize;
@@ -60,11 +59,10 @@
 
     static long actuallyMut = 0;
     private static Forest instance = new Forest();
     private Tree[] trees;
     private Lock[] locks;
-    private static Random rnd = new Random();
 
     private int nodeGarbageSize;
 
     private GarbageProducer gp;
     /*
@@ -175,14 +173,14 @@
 
 
     // Interchanges two randomly selected subtrees (of same size and depth) several times
     void swapSubtrees(long count) {
         for (int i = 0; i < count; i++) {
-            int index1 = rnd.nextInt(trees.length);
-            int index2 = rnd.nextInt(trees.length);
-            int depth = rnd.nextInt(treeHeight);
-            int path = rnd.nextInt();
+            int index1 = LocalRandom.nextInt(trees.length);
+            int index2 = LocalRandom.nextInt(trees.length);
+            int depth = LocalRandom.nextInt(treeHeight);
+            int path = LocalRandom.nextInt();
             locks[index1].lock();
             // Skip the round to avoid deadlocks
             if (locks[index2].tryLock()) {
                 swapSubtrees(trees[index1], trees[index2], depth, path);
                 actuallyMut += 2;

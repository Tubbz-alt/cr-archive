<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/jfr/jvm/TestFatEvent.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.jvm;
 27 
 28 import java.io.IOException;
 29 import java.util.List;
 30 
 31 import jdk.jfr.Event;
 32 import jdk.jfr.Recording;
 33 import jdk.jfr.ValueDescriptor;
 34 import jdk.jfr.consumer.RecordedEvent;
 35 import jdk.test.lib.Asserts;
 36 import jdk.test.lib.jfr.EventNames;
 37 import jdk.test.lib.jfr.Events;
 38 
 39 /**
 40  * @test TestFatEvent
 41  * @key jfr
 42  * @requires vm.hasJFR
 43  * @library /test/lib
 44  * @run main/othervm -Dprop1=12345678901234567890123456789012345678901234567890
 45  *      -Dprop2=12345678901234567890123456789012345678901234567890
 46  *      -Dprop3=12345678901234567890123456789012345678901234567890
 47  *      jdk.jfr.jvm.TestFatEvent
 48  */
 49 public class TestFatEvent {
 50 
 51     public static void main(String... args) throws Exception {
 52         testFatNativeEvent();
 53         testFatJavaEvent();
 54     }
 55 
 56     private static void testFatNativeEvent() throws Exception {
 57         try (Recording r = new Recording()) {
 58             r.enable(EventNames.JVMInformation).with(&quot;period&quot;, &quot;everyChunk&quot;);
 59             r.start();
 60             r.stop();
 61             List&lt;RecordedEvent&gt; events = Events.fromRecording(r);
 62             Asserts.assertEquals(2, events.size());
 63             for (RecordedEvent e : events) {
 64                 String s = e.getString(&quot;jvmArguments&quot;);
 65                 if (s.length() &lt; 150) {
 66                     throw new Exception(&quot;Expected at least 150 characters&quot;);
 67                 }
 68             }
 69         }
 70     }
 71     private static final Long expected = Long.MAX_VALUE;
 72 
 73     private static void testFatJavaEvent() throws IOException, Exception {
 74         // This event use more than 127 bytes
 75         // which requires two bytes in compressed
 76         // integer format
 77         class FatEvent extends Event {
 78             long a = expected;
 79             long b = expected;
 80             long c = expected;
 81             long d = expected;
 82             long e = expected;
 83             long f = expected;
 84             long g = expected;
 85             long h = expected;
 86             long i = expected;
 87             long j = expected;
 88             long k = expected;
 89             long l = expected;
 90             long m = expected;
 91             long n = expected;
 92             long o = expected;
 93             long p = expected;
 94             long q = expected;
 95             long r = expected;
 96             long s = expected;
 97             long t = expected;
 98             long u = expected;
 99             long v = expected;
100             long w = expected;
101             long x = expected;
102             long y = expected;
103             long z = expected;
104         }
105         try (Recording r = new Recording()) {
106             r.start();
107             int eventCount = 5000; //
108             for (int i = 0; i &lt; eventCount; i++) {
109                 FatEvent event = new FatEvent();
110                 event.commit();
111             }
112             r.stop();
113             List&lt;RecordedEvent&gt; events = Events.fromRecording(r);
114             int count = 0;
115             for (RecordedEvent event : events) {
116                 verifyEvent(event);
117                 count++;
118             }
119             if (count != eventCount) {
120                 throw new Exception(&quot;Unexpected event count &quot; + count + &quot;, expected &quot; + eventCount);
121             }
122         }
123     }
124 
125     private static void verifyEvent(RecordedEvent e) throws Exception {
126         for (ValueDescriptor v : e.getEventType().getFields()) {
127             String fieldName = v.getName();
128             Object o = e.getValue(v.getName());
129             if (fieldName.length() == 1 &amp;&amp; !o.equals(expected)) {
130                 System.out.println(&quot;Expected: &quot; + expected);
131                 System.out.println(e);
132                 throw new Exception(&quot;Unexpected value &quot; + o + &quot; for field &quot; + fieldName);
133             }
134         }
135     }
136 }
    </pre>
  </body>
</html>
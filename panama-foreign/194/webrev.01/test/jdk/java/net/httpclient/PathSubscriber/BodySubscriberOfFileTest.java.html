<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/PathSubscriber/BodySubscriberOfFileTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8237470
 27  * @summary Confirm HttpResponse.BodySubscribers#ofFile(Path)
 28  *          works with default and non-default file systems
 29  *          when SecurityManager is enabled
 30  * @modules java.base/sun.net.www.http
 31  *          java.net.http/jdk.internal.net.http.common
 32  *          java.net.http/jdk.internal.net.http.frame
 33  *          java.net.http/jdk.internal.net.http.hpack
 34  *          jdk.httpserver
 35  * @library /test/lib ../http2/server
 36  * @compile ../HttpServerAdapters.java
 37  * @build jdk.test.lib.net.SimpleSSLContext
 38  * @run testng/othervm BodySubscriberOfFileTest
 39  * @run testng/othervm/java.security.policy=ofFile.policy BodySubscriberOfFileTest
 40  */
 41 
 42 import com.sun.net.httpserver.HttpServer;
 43 import com.sun.net.httpserver.HttpsConfigurator;
 44 import com.sun.net.httpserver.HttpsServer;
 45 import jdk.test.lib.net.SimpleSSLContext;
 46 import jdk.test.lib.util.FileUtils;
 47 import org.testng.annotations.AfterTest;
 48 import org.testng.annotations.BeforeTest;
 49 import org.testng.annotations.DataProvider;
 50 import org.testng.annotations.Test;
 51 
 52 import javax.net.ssl.SSLContext;
 53 import java.io.IOException;
 54 import java.io.InputStream;
 55 import java.io.OutputStream;
 56 import java.net.InetAddress;
 57 import java.net.InetSocketAddress;
 58 import java.net.URI;
 59 import java.net.http.HttpClient;
 60 import java.net.http.HttpRequest;
 61 import java.net.http.HttpRequest.BodyPublishers;
 62 import java.net.http.HttpResponse.BodyHandler;
 63 import java.net.http.HttpResponse.BodySubscriber;
 64 import java.net.http.HttpResponse.BodySubscribers;
 65 import java.nio.charset.StandardCharsets;
 66 import java.nio.file.*;
 67 import java.security.AccessController;
 68 import java.security.PrivilegedAction;
 69 import java.util.Map;
 70 
 71 import static java.lang.System.out;
 72 import static java.net.http.HttpClient.Builder.NO_PROXY;
 73 import static org.testng.Assert.assertEquals;
 74 
 75 public class BodySubscriberOfFileTest implements HttpServerAdapters {
 76     static final String MSG = &quot;msg&quot;;
 77 
 78     SSLContext sslContext;
 79     HttpServerAdapters.HttpTestServer httpTestServer;    // HTTP/1.1      [ 4 servers ]
 80     HttpServerAdapters.HttpTestServer httpsTestServer;   // HTTPS/1.1
 81     HttpServerAdapters.HttpTestServer http2TestServer;   // HTTP/2 ( h2c )
 82     HttpServerAdapters.HttpTestServer https2TestServer;  // HTTP/2 ( h2  )
 83     String httpURI;
 84     String httpsURI;
 85     String http2URI;
 86     String https2URI;
 87 
 88     FileSystem zipFs;
 89     Path defaultFsPath;
 90     Path zipFsPath;
 91 
 92     // Default file system set-up
 93 
 94     static Path defaultFsFile() throws Exception {
 95         var file = Path.of(&quot;defaultFile.txt&quot;);
 96         if (Files.notExists(file)) {
 97             Files.createFile(file);
 98         }
 99         return file;
100     }
101 
102     @DataProvider(name = &quot;defaultFsData&quot;)
103     public Object[][] defaultFsData() {
104         return new Object[][]{
105                 {  httpURI,    defaultFsPath,  MSG,  true   },
106                 {  httpsURI,   defaultFsPath,  MSG,  true   },
107                 {  http2URI,   defaultFsPath,  MSG,  true   },
108                 {  https2URI,  defaultFsPath,  MSG,  true   },
109                 {  httpURI,    defaultFsPath,  MSG,  false  },
110                 {  httpsURI,   defaultFsPath,  MSG,  false  },
111                 {  http2URI,   defaultFsPath,  MSG,  false  },
112                 {  https2URI,  defaultFsPath,  MSG,  false  },
113         };
114     }
115 
116     @Test(dataProvider = &quot;defaultFsData&quot;)
117     public void testDefaultFs(String uriString,
118                               Path path,
119                               String expectedMsg,
120                               boolean sameClient) throws Exception {
121         out.printf(&quot;\n\n--- testDefaultFs(%s, %s, \&quot;%s\&quot;, %b): starting\n&quot;,
122                 uriString, path, expectedMsg, sameClient);
123         receive(uriString, path, expectedMsg, sameClient);
124     }
125 
126     // Zip file system set-up
127 
128     static FileSystem newZipFs() throws Exception {
129         Path zipFile = Path.of(&quot;file.zip&quot;);
130         return FileSystems.newFileSystem(zipFile, Map.of(&quot;create&quot;, &quot;true&quot;));
131     }
132 
133     static Path zipFsFile(FileSystem fs) throws Exception {
134         var file = fs.getPath(&quot;fileInZip.txt&quot;);
135         if (Files.notExists(file)) {
136             Files.createFile(file);
137         }
138         return file;
139     }
140 
141     @DataProvider(name = &quot;zipFsData&quot;)
142     public Object[][] zipFsData() {
143         return new Object[][]{
144                 {  httpURI,    zipFsPath,  MSG,  true   },
145                 {  httpsURI,   zipFsPath,  MSG,  true   },
146                 {  http2URI,   zipFsPath,  MSG,  true   },
147                 {  https2URI,  zipFsPath,  MSG,  true   },
148                 {  httpURI,    zipFsPath,  MSG,  false  },
149                 {  httpsURI,   zipFsPath,  MSG,  false  },
150                 {  http2URI,   zipFsPath,  MSG,  false  },
151                 {  https2URI,  zipFsPath,  MSG,  false  },
152         };
153     }
154 
155     @Test(dataProvider = &quot;zipFsData&quot;)
156     public void testZipFs(String uriString,
157                           Path path,
158                           String expectedMsg,
159                           boolean sameClient) throws Exception {
160         out.printf(&quot;\n\n--- testZipFs(%s, %s, \&quot;%s\&quot;, %b): starting\n&quot;,
161                 uriString, path, expectedMsg, sameClient);
162         receive(uriString, path, expectedMsg, sameClient);
163     }
164 
165     private static final int ITERATION_COUNT = 3;
166 
167     private void receive(String uriString,
168                       Path path,
169                       String expectedMsg,
170                       boolean sameClient) throws Exception {
171         HttpClient client = null;
172 
173         for (int i = 0; i &lt; ITERATION_COUNT; i++) {
174             if (!sameClient || client == null) {
175                 client = HttpClient.newBuilder()
176                         .proxy(NO_PROXY)
177                         .sslContext(sslContext)
178                         .build();
179             }
180             var req = HttpRequest.newBuilder(URI.create(uriString))
181                 .POST(BodyPublishers.noBody())
182                 .build();
183 
184             // Retrieve handler with caller&#39;s privileges enabled
185             PrivilegedAction&lt;BodySubscriber&lt;Path&gt;&gt; action = () -&gt;
186                     BodySubscribers.ofFile(path);
187             BodyHandler&lt;Path&gt; handler = respInfo -&gt;
188                     AccessController.doPrivileged(action);
189             var resp = client.send(req, handler);
190             String msg = Files.readString(path, StandardCharsets.UTF_8);
191             out.printf(&quot;Resp code: %s\n&quot;, resp.statusCode());
192             out.printf(&quot;Msg written to %s: %s\n&quot;, resp.body(), msg);
193             assertEquals(resp.statusCode(), 200);
194             assertEquals(msg, expectedMsg);
195         }
196     }
197 
198     @BeforeTest
199     public void setup() throws Exception {
200         sslContext = new SimpleSSLContext().get();
201         if (sslContext == null)
202             throw new AssertionError(&quot;Unexpected null sslContext&quot;);
203 
204         defaultFsPath = defaultFsFile();
205         zipFs = newZipFs();
206         zipFsPath = zipFsFile(zipFs);
207 
208         InetSocketAddress sa =
209                 new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);
210 
211         httpTestServer = HttpServerAdapters.HttpTestServer.of(HttpServer.create(sa, 0));
212         httpTestServer.addHandler(new HttpEchoHandler(), &quot;/http1/echo&quot;);
213         httpURI = &quot;http://&quot; + httpTestServer.serverAuthority() + &quot;/http1/echo&quot;;
214 
215         HttpsServer httpsServer = HttpsServer.create(sa, 0);
216         httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));
217         httpsTestServer = HttpServerAdapters.HttpTestServer.of(httpsServer);
218         httpsTestServer.addHandler(new HttpEchoHandler(), &quot;/https1/echo&quot;);
219         httpsURI = &quot;https://&quot; + httpsTestServer.serverAuthority() + &quot;/https1/echo&quot;;
220 
221         http2TestServer = HttpServerAdapters.HttpTestServer.of(
222                 new Http2TestServer(&quot;localhost&quot;, false, 0));
223         http2TestServer.addHandler(new HttpEchoHandler(), &quot;/http2/echo&quot;);
224         http2URI = &quot;http://&quot; + http2TestServer.serverAuthority() + &quot;/http2/echo&quot;;
225 
226         https2TestServer = HttpServerAdapters.HttpTestServer.of(
227                 new Http2TestServer(&quot;localhost&quot;, true, sslContext));
228         https2TestServer.addHandler(new HttpEchoHandler(), &quot;/https2/echo&quot;);
229         https2URI = &quot;https://&quot; + https2TestServer.serverAuthority() + &quot;/https2/echo&quot;;
230 
231         httpTestServer.start();
232         httpsTestServer.start();
233         http2TestServer.start();
234         https2TestServer.start();
235     }
236 
237     @AfterTest
238     public void teardown() throws Exception {
239         if (Files.exists(zipFsPath))
240             FileUtils.deleteFileTreeWithRetry(zipFsPath);
241         if (Files.exists(defaultFsPath))
242             FileUtils.deleteFileTreeWithRetry(defaultFsPath);
243 
244         httpTestServer.stop();
245         httpsTestServer.stop();
246         http2TestServer.stop();
247         https2TestServer.stop();
248         zipFs.close();
249     }
250 
251     static class HttpEchoHandler implements HttpServerAdapters.HttpTestHandler {
252         @Override
253         public void handle(HttpServerAdapters.HttpTestExchange t) throws IOException {
254             try (InputStream is = t.getRequestBody();
255                 OutputStream os = t.getResponseBody()) {
256                 is.readAllBytes();
257                 t.sendResponseHeaders(200, MSG.getBytes().length);
258                 os.write(MSG.getBytes(StandardCharsets.UTF_8));
259             }
260         }
261     }
262 }
    </pre>
  </body>
</html>
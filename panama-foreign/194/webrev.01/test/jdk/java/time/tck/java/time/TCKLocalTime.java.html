<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/time/tck/java/time/TCKLocalTime.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * This file is available under and governed by the GNU General Public
  26  * License version 2 only, as published by the Free Software Foundation.
  27  * However, the following notice accompanied the original version of this
  28  * file:
  29  *
  30  * Copyright (c) 2007-2012, Stephen Colebourne &amp; Michael Nascimento Santos
  31  *
  32  * All rights reserved.
  33  *
  34  * Redistribution and use in source and binary forms, with or without
  35  * modification, are permitted provided that the following conditions are met:
  36  *
  37  *  * Redistributions of source code must retain the above copyright notice,
  38  *    this list of conditions and the following disclaimer.
  39  *
  40  *  * Redistributions in binary form must reproduce the above copyright notice,
  41  *    this list of conditions and the following disclaimer in the documentation
  42  *    and/or other materials provided with the distribution.
  43  *
  44  *  * Neither the name of JSR-310 nor the names of its contributors
  45  *    may be used to endorse or promote products derived from this software
  46  *    without specific prior written permission.
  47  *
  48  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  49  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  50  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  51  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  52  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  53  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  54  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  55  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  56  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  57  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  58  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  59  */
  60 package tck.java.time;
  61 
  62 import static java.time.temporal.ChronoField.AMPM_OF_DAY;
  63 import static java.time.temporal.ChronoField.CLOCK_HOUR_OF_AMPM;
  64 import static java.time.temporal.ChronoField.CLOCK_HOUR_OF_DAY;
  65 import static java.time.temporal.ChronoField.HOUR_OF_AMPM;
  66 import static java.time.temporal.ChronoField.HOUR_OF_DAY;
  67 import static java.time.temporal.ChronoField.MICRO_OF_DAY;
  68 import static java.time.temporal.ChronoField.MICRO_OF_SECOND;
  69 import static java.time.temporal.ChronoField.MILLI_OF_DAY;
  70 import static java.time.temporal.ChronoField.MILLI_OF_SECOND;
  71 import static java.time.temporal.ChronoField.MINUTE_OF_DAY;
  72 import static java.time.temporal.ChronoField.MINUTE_OF_HOUR;
  73 import static java.time.temporal.ChronoField.NANO_OF_DAY;
  74 import static java.time.temporal.ChronoField.NANO_OF_SECOND;
  75 import static java.time.temporal.ChronoField.SECOND_OF_DAY;
  76 import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;
  77 import static java.time.temporal.ChronoUnit.DAYS;
  78 import static java.time.temporal.ChronoUnit.FOREVER;
  79 import static java.time.temporal.ChronoUnit.HALF_DAYS;
  80 import static java.time.temporal.ChronoUnit.HOURS;
  81 import static java.time.temporal.ChronoUnit.MICROS;
  82 import static java.time.temporal.ChronoUnit.MILLIS;
  83 import static java.time.temporal.ChronoUnit.MINUTES;
  84 import static java.time.temporal.ChronoUnit.MONTHS;
  85 import static java.time.temporal.ChronoUnit.NANOS;
  86 import static java.time.temporal.ChronoUnit.SECONDS;
  87 import static java.time.temporal.ChronoUnit.WEEKS;
  88 import static java.time.temporal.ChronoUnit.YEARS;
  89 import static org.testng.Assert.assertEquals;
  90 import static org.testng.Assert.assertNotNull;
  91 import static org.testng.Assert.assertSame;
  92 import static org.testng.Assert.assertTrue;
  93 import static org.testng.Assert.fail;
  94 
  95 import java.time.Clock;
  96 import java.time.DateTimeException;
  97 import java.time.Duration;
  98 import java.time.Instant;
  99 import java.time.LocalDate;
 100 import java.time.LocalDateTime;
 101 import java.time.LocalTime;
 102 import java.time.OffsetDateTime;
 103 import java.time.OffsetTime;
 104 import java.time.Period;
 105 import java.time.Year;
 106 import java.time.ZoneId;
 107 import java.time.ZoneOffset;
 108 import java.time.ZonedDateTime;
 109 import java.time.format.DateTimeFormatter;
 110 import java.time.format.DateTimeParseException;
 111 import java.time.temporal.ChronoField;
 112 import java.time.temporal.ChronoUnit;
 113 import java.time.temporal.JulianFields;
 114 import java.time.temporal.Temporal;
 115 import java.time.temporal.TemporalAccessor;
 116 import java.time.temporal.TemporalAdjuster;
 117 import java.time.temporal.TemporalAmount;
 118 import java.time.temporal.TemporalField;
 119 import java.time.temporal.TemporalQueries;
 120 import java.time.temporal.TemporalQuery;
 121 import java.time.temporal.TemporalUnit;
 122 import java.time.temporal.UnsupportedTemporalTypeException;
 123 import java.time.temporal.ValueRange;
 124 import java.util.ArrayList;
 125 import java.util.Arrays;
 126 import java.util.EnumSet;
 127 import java.util.Iterator;
 128 import java.util.List;
 129 
 130 import org.testng.annotations.BeforeMethod;
 131 import org.testng.annotations.DataProvider;
 132 import org.testng.annotations.Test;
 133 
 134 /**
 135  * Test LocalTime.
 136  */
 137 @Test
 138 public class TCKLocalTime extends AbstractDateTimeTest {
 139 
 140     private static final ZoneOffset OFFSET_PTWO = ZoneOffset.ofHours(2);
 141     private static final ZoneOffset OFFSET_MTWO = ZoneOffset.ofHours(-2);
 142     private static final ZoneId ZONE_PARIS = ZoneId.of(&quot;Europe/Paris&quot;);
 143 
 144     private LocalTime TEST_12_30_40_987654321;
 145 
 146     private static final TemporalUnit[] INVALID_UNITS;
 147     static {
 148         EnumSet&lt;ChronoUnit&gt; set = EnumSet.range(DAYS, FOREVER);
 149         INVALID_UNITS = set.toArray(new TemporalUnit[set.size()]);
 150     }
 151 
 152     @BeforeMethod
 153     public void setUp() {
 154         TEST_12_30_40_987654321 = LocalTime.of(12, 30, 40, 987654321);
 155     }
 156 
 157     //-----------------------------------------------------------------------
 158     @Override
 159     protected List&lt;TemporalAccessor&gt; samples() {
 160         TemporalAccessor[] array = {TEST_12_30_40_987654321, LocalTime.MIN, LocalTime.MAX, LocalTime.MIDNIGHT, LocalTime.NOON};
 161         return Arrays.asList(array);
 162     }
 163 
 164     @Override
 165     protected List&lt;TemporalField&gt; validFields() {
 166         TemporalField[] array = {
 167             NANO_OF_SECOND,
 168             NANO_OF_DAY,
 169             MICRO_OF_SECOND,
 170             MICRO_OF_DAY,
 171             MILLI_OF_SECOND,
 172             MILLI_OF_DAY,
 173             SECOND_OF_MINUTE,
 174             SECOND_OF_DAY,
 175             MINUTE_OF_HOUR,
 176             MINUTE_OF_DAY,
 177             CLOCK_HOUR_OF_AMPM,
 178             HOUR_OF_AMPM,
 179             CLOCK_HOUR_OF_DAY,
 180             HOUR_OF_DAY,
 181             AMPM_OF_DAY,
 182         };
 183         return Arrays.asList(array);
 184     }
 185 
 186     @Override
 187     protected List&lt;TemporalField&gt; invalidFields() {
 188         List&lt;TemporalField&gt; list = new ArrayList&lt;&gt;(Arrays.&lt;TemporalField&gt;asList(ChronoField.values()));
 189         list.removeAll(validFields());
 190         list.add(JulianFields.JULIAN_DAY);
 191         list.add(JulianFields.MODIFIED_JULIAN_DAY);
 192         list.add(JulianFields.RATA_DIE);
 193         return list;
 194     }
 195 
 196     //-----------------------------------------------------------------------
 197 
 198     private void check(LocalTime test, int h, int m, int s, int n) {
 199         assertEquals(test.getHour(), h);
 200         assertEquals(test.getMinute(), m);
 201         assertEquals(test.getSecond(), s);
 202         assertEquals(test.getNano(), n);
 203         assertEquals(test, test);
 204         assertEquals(test.hashCode(), test.hashCode());
 205         assertEquals(LocalTime.of(h, m, s, n), test);
 206     }
 207 
 208     //-----------------------------------------------------------------------
 209     // constants
 210     //-----------------------------------------------------------------------
 211     @Test
 212     public void constant_MIDNIGHT() {
 213         check(LocalTime.MIDNIGHT, 0, 0, 0, 0);
 214     }
 215 
 216     @Test
 217     public void constant_MIDDAY() {
 218         check(LocalTime.NOON, 12, 0, 0, 0);
 219     }
 220 
 221     @Test
 222     public void constant_MIN() {
 223         check(LocalTime.MIN, 0, 0, 0, 0);
 224     }
 225 
 226     @Test
 227     public void constant_MAX() {
 228         check(LocalTime.MAX, 23, 59, 59, 999999999);
 229     }
 230 
 231     //-----------------------------------------------------------------------
 232     // now(ZoneId)
 233     //-----------------------------------------------------------------------
 234     @Test(expectedExceptions=NullPointerException.class)
 235     public void now_ZoneId_nullZoneId() {
 236         LocalTime.now((ZoneId) null);
 237     }
 238 
 239     @Test
 240     public void now_ZoneId() {
 241         ZoneId zone = ZoneId.of(&quot;UTC+01:02:03&quot;);
 242         LocalTime expected = LocalTime.now(Clock.system(zone));
 243         LocalTime test = LocalTime.now(zone);
 244         assertEquals(Duration.between(expected, test).truncatedTo(ChronoUnit.SECONDS),
 245                 Duration.ZERO);
 246     }
 247 
 248     //-----------------------------------------------------------------------
 249     // now(Clock)
 250     //-----------------------------------------------------------------------
 251     @Test(expectedExceptions=NullPointerException.class)
 252     public void now_Clock_nullClock() {
 253         LocalTime.now((Clock) null);
 254     }
 255 
 256     @Test
 257     public void now_Clock_allSecsInDay() {
 258         for (int i = 0; i &lt; (2 * 24 * 60 * 60); i++) {
 259             Instant instant = Instant.ofEpochSecond(i, 8);
 260             Clock clock = Clock.fixed(instant, ZoneOffset.UTC);
 261             LocalTime test = LocalTime.now(clock);
 262             assertEquals(test.getHour(), (i / (60 * 60)) % 24);
 263             assertEquals(test.getMinute(), (i / 60) % 60);
 264             assertEquals(test.getSecond(), i % 60);
 265             assertEquals(test.getNano(), 8);
 266         }
 267     }
 268 
 269     @Test
 270     public void now_Clock_beforeEpoch() {
 271         for (int i =-1; i &gt;= -(24 * 60 * 60); i--) {
 272             Instant instant = Instant.ofEpochSecond(i, 8);
 273             Clock clock = Clock.fixed(instant, ZoneOffset.UTC);
 274             LocalTime test = LocalTime.now(clock);
 275             assertEquals(test.getHour(), ((i + 24 * 60 * 60) / (60 * 60)) % 24);
 276             assertEquals(test.getMinute(), ((i + 24 * 60 * 60) / 60) % 60);
 277             assertEquals(test.getSecond(), (i + 24 * 60 * 60) % 60);
 278             assertEquals(test.getNano(), 8);
 279         }
 280     }
 281 
 282     //-----------------------------------------------------------------------
 283     @Test
 284     public void now_Clock_max() {
 285         Clock clock = Clock.fixed(Instant.MAX, ZoneOffset.UTC);
 286         LocalTime test = LocalTime.now(clock);
 287         assertEquals(test.getHour(), 23);
 288         assertEquals(test.getMinute(), 59);
 289         assertEquals(test.getSecond(), 59);
 290         assertEquals(test.getNano(), 999_999_999);
 291     }
 292 
 293     @Test
 294     public void now_Clock_min() {
 295         Clock clock = Clock.fixed(Instant.MIN, ZoneOffset.UTC);
 296         LocalTime test = LocalTime.now(clock);
 297         assertEquals(test.getHour(), 0);
 298         assertEquals(test.getMinute(), 0);
 299         assertEquals(test.getSecond(), 0);
 300         assertEquals(test.getNano(), 0);
 301     }
 302 
 303     //-----------------------------------------------------------------------
 304     // of() factories
 305     //-----------------------------------------------------------------------
 306     @Test
 307     public void factory_time_2ints() {
 308         LocalTime test = LocalTime.of(12, 30);
 309         check(test, 12, 30, 0, 0);
 310     }
 311 
 312     @Test(expectedExceptions=DateTimeException.class)
 313     public void factory_time_2ints_hourTooLow() {
 314         LocalTime.of(-1, 0);
 315     }
 316 
 317     @Test(expectedExceptions=DateTimeException.class)
 318     public void factory_time_2ints_hourTooHigh() {
 319         LocalTime.of(24, 0);
 320     }
 321 
 322     @Test(expectedExceptions=DateTimeException.class)
 323     public void factory_time_2ints_minuteTooLow() {
 324         LocalTime.of(0, -1);
 325     }
 326 
 327     @Test(expectedExceptions=DateTimeException.class)
 328     public void factory_time_2ints_minuteTooHigh() {
 329         LocalTime.of(0, 60);
 330     }
 331 
 332     //-----------------------------------------------------------------------
 333     @Test
 334     public void factory_time_3ints() {
 335         LocalTime test = LocalTime.of(12, 30, 40);
 336         check(test, 12, 30, 40, 0);
 337     }
 338 
 339     @Test(expectedExceptions=DateTimeException.class)
 340     public void factory_time_3ints_hourTooLow() {
 341         LocalTime.of(-1, 0, 0);
 342     }
 343 
 344     @Test(expectedExceptions=DateTimeException.class)
 345     public void factory_time_3ints_hourTooHigh() {
 346         LocalTime.of(24, 0, 0);
 347     }
 348 
 349     @Test(expectedExceptions=DateTimeException.class)
 350     public void factory_time_3ints_minuteTooLow() {
 351         LocalTime.of(0, -1, 0);
 352     }
 353 
 354     @Test(expectedExceptions=DateTimeException.class)
 355     public void factory_time_3ints_minuteTooHigh() {
 356         LocalTime.of(0, 60, 0);
 357     }
 358 
 359     @Test(expectedExceptions=DateTimeException.class)
 360     public void factory_time_3ints_secondTooLow() {
 361         LocalTime.of(0, 0, -1);
 362     }
 363 
 364     @Test(expectedExceptions=DateTimeException.class)
 365     public void factory_time_3ints_secondTooHigh() {
 366         LocalTime.of(0, 0, 60);
 367     }
 368 
 369     //-----------------------------------------------------------------------
 370     @Test
 371     public void factory_time_4ints() {
 372         LocalTime test = LocalTime.of(12, 30, 40, 987654321);
 373         check(test, 12, 30, 40, 987654321);
 374         test = LocalTime.of(12, 0, 40, 987654321);
 375         check(test, 12, 0, 40, 987654321);
 376     }
 377 
 378     @Test(expectedExceptions=DateTimeException.class)
 379     public void factory_time_4ints_hourTooLow() {
 380         LocalTime.of(-1, 0, 0, 0);
 381     }
 382 
 383     @Test(expectedExceptions=DateTimeException.class)
 384     public void factory_time_4ints_hourTooHigh() {
 385         LocalTime.of(24, 0, 0, 0);
 386     }
 387 
 388     @Test(expectedExceptions=DateTimeException.class)
 389     public void factory_time_4ints_minuteTooLow() {
 390         LocalTime.of(0, -1, 0, 0);
 391     }
 392 
 393     @Test(expectedExceptions=DateTimeException.class)
 394     public void factory_time_4ints_minuteTooHigh() {
 395         LocalTime.of(0, 60, 0, 0);
 396     }
 397 
 398     @Test(expectedExceptions=DateTimeException.class)
 399     public void factory_time_4ints_secondTooLow() {
 400         LocalTime.of(0, 0, -1, 0);
 401     }
 402 
 403     @Test(expectedExceptions=DateTimeException.class)
 404     public void factory_time_4ints_secondTooHigh() {
 405         LocalTime.of(0, 0, 60, 0);
 406     }
 407 
 408     @Test(expectedExceptions=DateTimeException.class)
 409     public void factory_time_4ints_nanoTooLow() {
 410         LocalTime.of(0, 0, 0, -1);
 411     }
 412 
 413     @Test(expectedExceptions=DateTimeException.class)
 414     public void factory_time_4ints_nanoTooHigh() {
 415         LocalTime.of(0, 0, 0, 1000000000);
 416     }
 417 
 418      //-----------------------------------------------------------------------
 419      // ofInstant()
 420      //-----------------------------------------------------------------------
 421      @DataProvider(name=&quot;instantFactory&quot;)
 422      Object[][] data_instantFactory() {
 423          return new Object[][] {
 424                  {Instant.ofEpochSecond(86400 + 3600 + 120 + 4, 500), ZONE_PARIS, LocalTime.of(2, 2, 4, 500)},
 425                  {Instant.ofEpochSecond(86400 + 3600 + 120 + 4, 500), OFFSET_MTWO, LocalTime.of(23, 2, 4, 500)},
 426                  {Instant.ofEpochSecond(-86400 + 4, 500), OFFSET_PTWO, LocalTime.of(2, 0, 4, 500)},
 427                  {OffsetDateTime.of(LocalDateTime.of(Year.MIN_VALUE, 1, 1, 0, 0), ZoneOffset.UTC).toInstant(),
 428                          ZoneOffset.UTC, LocalTime.MIN},
 429                  {OffsetDateTime.of(LocalDateTime.of(Year.MAX_VALUE, 12, 31, 23, 59, 59, 999_999_999), ZoneOffset.UTC).toInstant(),
 430                          ZoneOffset.UTC, LocalTime.MAX},
 431          };
 432      }
 433 
 434      @Test(dataProvider=&quot;instantFactory&quot;)
 435      public void factory_ofInstant(Instant instant, ZoneId zone, LocalTime expected) {
 436          LocalTime test = LocalTime.ofInstant(instant, zone);
 437          assertEquals(test, expected);
 438      }
 439 
 440      @Test(expectedExceptions=NullPointerException.class)
 441      public void factory_ofInstant_nullInstant() {
 442          LocalTime.ofInstant((Instant) null, ZONE_PARIS);
 443      }
 444 
 445      @Test(expectedExceptions=NullPointerException.class)
 446      public void factory_ofInstant_nullZone() {
 447          LocalTime.ofInstant(Instant.EPOCH, (ZoneId) null);
 448      }
 449 
 450     //-----------------------------------------------------------------------
 451     // ofSecondOfDay(long)
 452     //-----------------------------------------------------------------------
 453     @Test
 454     public void factory_ofSecondOfDay() {
 455         LocalTime localTime = LocalTime.ofSecondOfDay(2 * 60 * 60 + 17 * 60 + 23);
 456         check(localTime, 2, 17, 23, 0);
 457     }
 458 
 459     @Test(expectedExceptions=DateTimeException.class)
 460     public void factory_ofSecondOfDay_tooLow() {
 461         LocalTime.ofSecondOfDay(-1);
 462     }
 463 
 464     @Test(expectedExceptions=DateTimeException.class)
 465     public void factory_ofSecondOfDay_tooHigh() {
 466         LocalTime.ofSecondOfDay(24 * 60 * 60);
 467     }
 468 
 469     //-----------------------------------------------------------------------
 470     // ofNanoOfDay(long)
 471     //-----------------------------------------------------------------------
 472     @Test
 473     public void factory_ofNanoOfDay() {
 474         LocalTime localTime = LocalTime.ofNanoOfDay(60 * 60 * 1000000000L + 17);
 475         check(localTime, 1, 0, 0, 17);
 476     }
 477 
 478     @Test(expectedExceptions=DateTimeException.class)
 479     public void factory_ofNanoOfDay_tooLow() {
 480         LocalTime.ofNanoOfDay(-1);
 481     }
 482 
 483     @Test(expectedExceptions=DateTimeException.class)
 484     public void factory_ofNanoOfDay_tooHigh() {
 485         LocalTime.ofNanoOfDay(24 * 60 * 60 * 1000000000L);
 486     }
 487 
 488     //-----------------------------------------------------------------------
 489     // from()
 490     //-----------------------------------------------------------------------
 491     @Test
 492     public void factory_from_TemporalAccessor() {
 493         assertEquals(LocalTime.from(LocalTime.of(17, 30)), LocalTime.of(17, 30));
 494         assertEquals(LocalTime.from(LocalDateTime.of(2012, 5, 1, 17, 30)), LocalTime.of(17, 30));
 495     }
 496 
 497     @Test(expectedExceptions=DateTimeException.class)
 498     public void factory_from_TemporalAccessor_invalid_noDerive() {
 499         LocalTime.from(LocalDate.of(2007, 7, 15));
 500     }
 501 
 502     @Test(expectedExceptions=NullPointerException.class)
 503     public void factory_from_TemporalAccessor_null() {
 504         LocalTime.from((TemporalAccessor) null);
 505     }
 506 
 507     //-----------------------------------------------------------------------
 508     // parse()
 509     //-----------------------------------------------------------------------
 510     @Test(dataProvider = &quot;sampleToString&quot;)
 511     public void factory_parse_validText(int h, int m, int s, int n, String parsable) {
 512         LocalTime t = LocalTime.parse(parsable);
 513         assertNotNull(t, parsable);
 514         assertEquals(t.getHour(), h);
 515         assertEquals(t.getMinute(), m);
 516         assertEquals(t.getSecond(), s);
 517         assertEquals(t.getNano(), n);
 518     }
 519 
 520     @DataProvider(name=&quot;sampleBadParse&quot;)
 521     Object[][] provider_sampleBadParse() {
 522         return new Object[][]{
 523                 {&quot;00;00&quot;},
 524                 {&quot;12-00&quot;},
 525                 {&quot;-01:00&quot;},
 526                 {&quot;00:00:00-09&quot;},
 527                 {&quot;00:00:00,09&quot;},
 528                 {&quot;00:00:abs&quot;},
 529                 {&quot;11&quot;},
 530                 {&quot;11:30+01:00&quot;},
 531                 {&quot;11:30+01:00[Europe/Paris]&quot;},
 532         };
 533     }
 534 
 535     @Test(dataProvider = &quot;sampleBadParse&quot;, expectedExceptions={DateTimeParseException.class})
 536     public void factory_parse_invalidText(String unparsable) {
 537         LocalTime.parse(unparsable);
 538     }
 539 
 540     //-----------------------------------------------------------------------s
 541     @Test(expectedExceptions=DateTimeParseException.class)
 542     public void factory_parse_illegalHour() {
 543         LocalTime.parse(&quot;25:00&quot;);
 544     }
 545 
 546     @Test(expectedExceptions=DateTimeParseException.class)
 547     public void factory_parse_illegalMinute() {
 548         LocalTime.parse(&quot;12:60&quot;);
 549     }
 550 
 551     @Test(expectedExceptions=DateTimeParseException.class)
 552     public void factory_parse_illegalSecond() {
 553         LocalTime.parse(&quot;12:12:60&quot;);
 554     }
 555 
 556     //-----------------------------------------------------------------------s
 557     @Test(expectedExceptions = {NullPointerException.class})
 558     public void factory_parse_nullTest() {
 559         LocalTime.parse((String) null);
 560     }
 561 
 562     //-----------------------------------------------------------------------
 563     // parse(DateTimeFormatter)
 564     //-----------------------------------------------------------------------
 565     @Test
 566     public void factory_parse_formatter() {
 567         DateTimeFormatter f = DateTimeFormatter.ofPattern(&quot;H m s&quot;);
 568         LocalTime test = LocalTime.parse(&quot;14 30 40&quot;, f);
 569         assertEquals(test, LocalTime.of(14, 30, 40));
 570     }
 571 
 572     @Test(expectedExceptions=NullPointerException.class)
 573     public void factory_parse_formatter_nullText() {
 574         DateTimeFormatter f = DateTimeFormatter.ofPattern(&quot;H m s&quot;);
 575         LocalTime.parse((String) null, f);
 576     }
 577 
 578     @Test(expectedExceptions=NullPointerException.class)
 579     public void factory_parse_formatter_nullFormatter() {
 580         LocalTime.parse(&quot;ANY&quot;, null);
 581     }
 582 
 583     //-----------------------------------------------------------------------
 584     // isSupported(TemporalField)
 585     //-----------------------------------------------------------------------
 586     @Test
 587     public void test_isSupported_TemporalField() {
 588         assertEquals(TEST_12_30_40_987654321.isSupported((TemporalField) null), false);
 589         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.NANO_OF_SECOND), true);
 590         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.NANO_OF_DAY), true);
 591         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.MICRO_OF_SECOND), true);
 592         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.MICRO_OF_DAY), true);
 593         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.MILLI_OF_SECOND), true);
 594         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.MILLI_OF_DAY), true);
 595         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.SECOND_OF_MINUTE), true);
 596         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.SECOND_OF_DAY), true);
 597         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.MINUTE_OF_HOUR), true);
 598         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.MINUTE_OF_DAY), true);
 599         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.HOUR_OF_AMPM), true);
 600         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.CLOCK_HOUR_OF_AMPM), true);
 601         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.HOUR_OF_DAY), true);
 602         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.CLOCK_HOUR_OF_DAY), true);
 603         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.AMPM_OF_DAY), true);
 604         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.DAY_OF_WEEK), false);
 605         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH), false);
 606         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), false);
 607         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.DAY_OF_MONTH), false);
 608         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.DAY_OF_YEAR), false);
 609         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.EPOCH_DAY), false);
 610         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.ALIGNED_WEEK_OF_MONTH), false);
 611         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.ALIGNED_WEEK_OF_YEAR), false);
 612         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.MONTH_OF_YEAR), false);
 613         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.PROLEPTIC_MONTH), false);
 614         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.YEAR), false);
 615         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.YEAR_OF_ERA), false);
 616         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.ERA), false);
 617         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.INSTANT_SECONDS), false);
 618         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoField.OFFSET_SECONDS), false);
 619     }
 620 
 621     //-----------------------------------------------------------------------
 622     // isSupported(TemporalUnit)
 623     //-----------------------------------------------------------------------
 624     @Test
 625     public void test_isSupported_TemporalUnit() {
 626         assertEquals(TEST_12_30_40_987654321.isSupported((TemporalUnit) null), false);
 627         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.NANOS), true);
 628         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.MICROS), true);
 629         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.MILLIS), true);
 630         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.SECONDS), true);
 631         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.MINUTES), true);
 632         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.HOURS), true);
 633         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.HALF_DAYS), true);
 634         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.DAYS), false);
 635         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.WEEKS), false);
 636         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.MONTHS), false);
 637         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.YEARS), false);
 638         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.DECADES), false);
 639         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.CENTURIES), false);
 640         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.MILLENNIA), false);
 641         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.ERAS), false);
 642         assertEquals(TEST_12_30_40_987654321.isSupported(ChronoUnit.FOREVER), false);
 643     }
 644 
 645     //-----------------------------------------------------------------------
 646     // get(TemporalField)
 647     //-----------------------------------------------------------------------
 648     @Test
 649     public void test_get_TemporalField() {
 650         LocalTime test = TEST_12_30_40_987654321;
 651         assertEquals(test.get(ChronoField.HOUR_OF_DAY), 12);
 652         assertEquals(test.get(ChronoField.MINUTE_OF_HOUR), 30);
 653         assertEquals(test.get(ChronoField.SECOND_OF_MINUTE), 40);
 654         assertEquals(test.get(ChronoField.NANO_OF_SECOND), 987654321);
 655 
 656         assertEquals(test.get(ChronoField.SECOND_OF_DAY), 12 * 3600 + 30 * 60 + 40);
 657         assertEquals(test.get(ChronoField.MINUTE_OF_DAY), 12 * 60 + 30);
 658         assertEquals(test.get(ChronoField.HOUR_OF_AMPM), 0);
 659         assertEquals(test.get(ChronoField.CLOCK_HOUR_OF_AMPM), 12);
 660         assertEquals(test.get(ChronoField.CLOCK_HOUR_OF_DAY), 12);
 661         assertEquals(test.get(ChronoField.AMPM_OF_DAY), 1);
 662     }
 663 
 664     @Test
 665     public void test_getLong_TemporalField() {
 666         LocalTime test = TEST_12_30_40_987654321;
 667         assertEquals(test.getLong(ChronoField.HOUR_OF_DAY), 12);
 668         assertEquals(test.getLong(ChronoField.MINUTE_OF_HOUR), 30);
 669         assertEquals(test.getLong(ChronoField.SECOND_OF_MINUTE), 40);
 670         assertEquals(test.getLong(ChronoField.NANO_OF_SECOND), 987654321);
 671 
 672         assertEquals(test.getLong(ChronoField.SECOND_OF_DAY), 12 * 3600 + 30 * 60 + 40);
 673         assertEquals(test.getLong(ChronoField.MINUTE_OF_DAY), 12 * 60 + 30);
 674         assertEquals(test.getLong(ChronoField.HOUR_OF_AMPM), 0);
 675         assertEquals(test.getLong(ChronoField.CLOCK_HOUR_OF_AMPM), 12);
 676         assertEquals(test.getLong(ChronoField.CLOCK_HOUR_OF_DAY), 12);
 677         assertEquals(test.getLong(ChronoField.AMPM_OF_DAY), 1);
 678     }
 679 
 680     //-----------------------------------------------------------------------
 681     // query(TemporalQuery)
 682     //-----------------------------------------------------------------------
 683     @DataProvider(name=&quot;query&quot;)
 684     Object[][] data_query() {
 685         return new Object[][] {
 686                 {TEST_12_30_40_987654321, TemporalQueries.chronology(), null},
 687                 {TEST_12_30_40_987654321, TemporalQueries.zoneId(), null},
 688                 {TEST_12_30_40_987654321, TemporalQueries.precision(), ChronoUnit.NANOS},
 689                 {TEST_12_30_40_987654321, TemporalQueries.zone(), null},
 690                 {TEST_12_30_40_987654321, TemporalQueries.offset(), null},
 691                 {TEST_12_30_40_987654321, TemporalQueries.localDate(), null},
 692                 {TEST_12_30_40_987654321, TemporalQueries.localTime(), TEST_12_30_40_987654321},
 693         };
 694     }
 695 
 696     @Test(dataProvider=&quot;query&quot;)
 697     public &lt;T&gt; void test_query(TemporalAccessor temporal, TemporalQuery&lt;T&gt; query, T expected) {
 698         assertEquals(temporal.query(query), expected);
 699     }
 700 
 701     @Test(dataProvider=&quot;query&quot;)
 702     public &lt;T&gt; void test_queryFrom(TemporalAccessor temporal, TemporalQuery&lt;T&gt; query, T expected) {
 703         assertEquals(query.queryFrom(temporal), expected);
 704     }
 705 
 706     @Test(expectedExceptions=NullPointerException.class)
 707     public void test_query_null() {
 708         TEST_12_30_40_987654321.query(null);
 709     }
 710 
 711     //-----------------------------------------------------------------------
 712     // get*()
 713     //-----------------------------------------------------------------------
 714     @DataProvider(name=&quot;sampleTimes&quot;)
 715     Object[][] provider_sampleTimes() {
 716         return new Object[][] {
 717             {0, 0, 0, 0},
 718             {0, 0, 0, 1},
 719             {0, 0, 1, 0},
 720             {0, 0, 1, 1},
 721             {0, 1, 0, 0},
 722             {0, 1, 0, 1},
 723             {0, 1, 1, 0},
 724             {0, 1, 1, 1},
 725             {1, 0, 0, 0},
 726             {1, 0, 0, 1},
 727             {1, 0, 1, 0},
 728             {1, 0, 1, 1},
 729             {1, 1, 0, 0},
 730             {1, 1, 0, 1},
 731             {1, 1, 1, 0},
 732             {1, 1, 1, 1},
 733         };
 734     }
 735 
 736     //-----------------------------------------------------------------------
 737     @Test(dataProvider=&quot;sampleTimes&quot;)
 738     public void test_get(int h, int m, int s, int ns) {
 739         LocalTime a = LocalTime.of(h, m, s, ns);
 740         assertEquals(a.getHour(), h);
 741         assertEquals(a.getMinute(), m);
 742         assertEquals(a.getSecond(), s);
 743         assertEquals(a.getNano(), ns);
 744     }
 745 
 746     //-----------------------------------------------------------------------
 747     // adjustInto(Temporal)
 748     //-----------------------------------------------------------------------
 749     @DataProvider(name=&quot;adjustInto&quot;)
 750     Object[][] data_adjustInto() {
 751         return new Object[][]{
 752                 {LocalTime.of(23, 5), LocalTime.of(4, 1, 1, 100), LocalTime.of(23, 5, 0, 0), null},
 753                 {LocalTime.of(23, 5, 20), LocalTime.of(4, 1, 1, 100), LocalTime.of(23, 5, 20, 0), null},
 754                 {LocalTime.of(23, 5, 20, 1000), LocalTime.of(4, 1, 1, 100), LocalTime.of(23, 5, 20, 1000), null},
 755                 {LocalTime.of(23, 5, 20, 1000), LocalTime.MAX, LocalTime.of(23, 5, 20, 1000), null},
 756                 {LocalTime.of(23, 5, 20, 1000), LocalTime.MIN, LocalTime.of(23, 5, 20, 1000), null},
 757                 {LocalTime.of(23, 5, 20, 1000), LocalTime.NOON, LocalTime.of(23, 5, 20, 1000), null},
 758                 {LocalTime.of(23, 5, 20, 1000), LocalTime.MIDNIGHT, LocalTime.of(23, 5, 20, 1000), null},
 759                 {LocalTime.MAX, LocalTime.of(23, 5, 20, 1000), LocalTime.of(23, 59, 59, 999999999), null},
 760                 {LocalTime.MIN, LocalTime.of(23, 5, 20, 1000), LocalTime.of(0, 0, 0), null},
 761                 {LocalTime.NOON, LocalTime.of(23, 5, 20, 1000), LocalTime.of(12, 0, 0), null},
 762                 {LocalTime.MIDNIGHT, LocalTime.of(23, 5, 20, 1000), LocalTime.of(0, 0, 0), null},
 763 
 764                 {LocalTime.of(23, 5), LocalDateTime.of(2210, 2, 2, 1, 1), LocalDateTime.of(2210, 2, 2, 23, 5), null},
 765                 {LocalTime.of(23, 5), OffsetTime.of(1, 1, 0, 0, OFFSET_PTWO), OffsetTime.of(23, 5, 0, 0, OFFSET_PTWO), null},
 766                 {LocalTime.of(23, 5), OffsetDateTime.of(2210, 2, 2, 1, 1, 0, 0, OFFSET_PTWO), OffsetDateTime.of(2210, 2, 2, 23, 5, 0, 0, OFFSET_PTWO), null},
 767                 {LocalTime.of(23, 5), ZonedDateTime.of(2210, 2, 2, 1, 1, 0, 0, ZONE_PARIS), ZonedDateTime.of(2210, 2, 2, 23, 5, 0, 0, ZONE_PARIS), null},
 768 
 769                 {LocalTime.of(23, 5), LocalDate.of(2210, 2, 2), null, DateTimeException.class},
 770                 {LocalTime.of(23, 5), null, null, NullPointerException.class},
 771 
 772         };
 773     }
 774 
 775     @Test(dataProvider=&quot;adjustInto&quot;)
 776     public void test_adjustInto(LocalTime test, Temporal temporal, Temporal expected, Class&lt;?&gt; expectedEx) {
 777         if (expectedEx == null) {
 778             Temporal result = test.adjustInto(temporal);
 779             assertEquals(result, expected);
 780         } else {
 781             try {
 782                 Temporal result = test.adjustInto(temporal);
 783                 fail();
 784             } catch (Exception ex) {
 785                 assertTrue(expectedEx.isInstance(ex));
 786             }
 787         }
 788     }
 789 
 790     //-----------------------------------------------------------------------
 791     // with(TemporalAdjuster)
 792     //-----------------------------------------------------------------------
 793     @Test
 794     public void test_with_adjustment() {
 795         final LocalTime sample = LocalTime.of(23, 5);
 796         TemporalAdjuster adjuster = new TemporalAdjuster() {
 797             @Override
 798             public Temporal adjustInto(Temporal dateTime) {
 799                 return sample;
 800             }
 801         };
 802         assertEquals(TEST_12_30_40_987654321.with(adjuster), sample);
 803     }
 804 
 805     @Test(expectedExceptions=NullPointerException.class)
 806     public void test_with_adjustment_null() {
 807         TEST_12_30_40_987654321.with((TemporalAdjuster) null);
 808     }
 809 
 810     //-----------------------------------------------------------------------
 811     // with(TemporalField, long)
 812     //-----------------------------------------------------------------------
 813     private long[] testPoints(long max) {
 814         long[] points = new long[9];
 815         points[0] = 0;
 816         points[1] = 1;
 817         points[2] = 2;
 818         points[3] = max / 7;
 819         points[4] = (max / 7) * 2;
 820         points[5] = (max / 2);
 821         points[6] = (max / 7) * 6;;
 822         points[7] = max - 2;
 823         points[8] = max - 1;
 824         return points;
 825     }
 826 
 827     // Returns a {@code LocalTime} with the specified nano-of-second.
 828     // The hour, minute and second will be unchanged.
 829     @Test
 830     public void test_with_longTemporalField_nanoOfSecond() {
 831         for (long i : testPoints(1_000_000_000L)) {
 832             LocalTime test = TEST_12_30_40_987654321.with(NANO_OF_SECOND, i);
 833             assertEquals(test.get(NANO_OF_SECOND),  i);
 834             assertEquals(test.get(HOUR_OF_DAY), TEST_12_30_40_987654321.get(HOUR_OF_DAY));
 835             assertEquals(test.get(MINUTE_OF_HOUR), TEST_12_30_40_987654321.get(MINUTE_OF_HOUR));
 836             assertEquals(test.get(SECOND_OF_MINUTE), TEST_12_30_40_987654321.get(SECOND_OF_MINUTE));
 837         }
 838     }
 839 
 840     // Returns a {@code LocalTime} with the specified nano-of-day.
 841     // This completely replaces the time and is equivalent to {@link #ofNanoOfDay(long)}.
 842     @Test
 843     public void test_with_longTemporalField_nanoOfDay() {
 844         for (long i : testPoints(86_400_000_000_000L)) {
 845             LocalTime test = TEST_12_30_40_987654321.with(NANO_OF_DAY, i);
 846             assertEquals(test, LocalTime.ofNanoOfDay(i));
 847         }
 848     }
 849 
 850     // Returns a {@code LocalTime} with the nano-of-second replaced by the specified
 851     // micro-of-second multiplied by 1,000.
 852     // The hour, minute and second will be unchanged.
 853     @Test
 854     public void test_with_longTemporalField_microOfSecond() {
 855         for (long i : testPoints(1_000_000L)) {
 856             LocalTime test = TEST_12_30_40_987654321.with(MICRO_OF_SECOND, i);
 857             assertEquals(test.get(NANO_OF_SECOND),  i * 1_000);
 858             assertEquals(test.get(HOUR_OF_DAY), TEST_12_30_40_987654321.get(HOUR_OF_DAY));
 859             assertEquals(test.get(MINUTE_OF_HOUR), TEST_12_30_40_987654321.get(MINUTE_OF_HOUR));
 860             assertEquals(test.get(SECOND_OF_MINUTE), TEST_12_30_40_987654321.get(SECOND_OF_MINUTE));
 861         }
 862     }
 863 
 864     // Returns a {@code LocalTime} with the specified micro-of-day.
 865     // This completely replaces the time and is equivalent to using {@link #ofNanoOfDay(long)}
 866     // with the micro-of-day multiplied by 1,000.
 867     @Test
 868     public void test_with_longTemporalField_microOfDay() {
 869         for (long i : testPoints(86_400_000_000L)) {
 870             LocalTime test = TEST_12_30_40_987654321.with(MICRO_OF_DAY, i);
 871             assertEquals(test, LocalTime.ofNanoOfDay(i * 1000));
 872         }
 873     }
 874 
 875     // Returns a {@code LocalTime} with the nano-of-second replaced by the specified
 876     // milli-of-second multiplied by 1,000,000.
 877     // The hour, minute and second will be unchanged.
 878     @Test
 879     public void test_with_longTemporalField_milliOfSecond() {
 880         for (long i : testPoints(1_000L)) {
 881             LocalTime test = TEST_12_30_40_987654321.with(MILLI_OF_SECOND, i);
 882             assertEquals(test.get(NANO_OF_SECOND),  i * 1_000_000);
 883             assertEquals(test.get(HOUR_OF_DAY), TEST_12_30_40_987654321.get(HOUR_OF_DAY));
 884             assertEquals(test.get(MINUTE_OF_HOUR), TEST_12_30_40_987654321.get(MINUTE_OF_HOUR));
 885             assertEquals(test.get(SECOND_OF_MINUTE), TEST_12_30_40_987654321.get(SECOND_OF_MINUTE));
 886         }
 887     }
 888 
 889     // Returns a {@code LocalTime} with the specified milli-of-day.
 890     // This completely replaces the time and is equivalent to using {@link #ofNanoOfDay(long)}
 891     // with the milli-of-day multiplied by 1,000,000.
 892     @Test
 893     public void test_with_longTemporalField_milliOfDay() {
 894         for (long i : testPoints(86_400_000L)) {
 895             LocalTime test = TEST_12_30_40_987654321.with(MILLI_OF_DAY, i);
 896             assertEquals(test, LocalTime.ofNanoOfDay(i * 1_000_000));
 897         }
 898     }
 899 
 900     // Returns a {@code LocalTime} with the specified second-of-minute.
 901     // The hour, minute and nano-of-second will be unchanged.
 902     @Test
 903     public void test_with_longTemporalField_secondOfMinute() {
 904         for (long i : testPoints(60L)) {
 905             LocalTime test = TEST_12_30_40_987654321.with(SECOND_OF_MINUTE, i);
 906             assertEquals(test.get(SECOND_OF_MINUTE), i);
 907             assertEquals(test.get(HOUR_OF_DAY), TEST_12_30_40_987654321.get(HOUR_OF_DAY));
 908             assertEquals(test.get(MINUTE_OF_HOUR), TEST_12_30_40_987654321.get(MINUTE_OF_HOUR));
 909             assertEquals(test.get(NANO_OF_SECOND), TEST_12_30_40_987654321.get(NANO_OF_SECOND));
 910         }
 911     }
 912 
 913     // Returns a {@code LocalTime} with the specified second-of-day.
 914     // The nano-of-second will be unchanged.
 915     @Test
 916     public void test_with_longTemporalField_secondOfDay() {
 917         for (long i : testPoints(24 * 60 * 60)) {
 918             LocalTime test = TEST_12_30_40_987654321.with(SECOND_OF_DAY, i);
 919             assertEquals(test.get(SECOND_OF_DAY), i);
 920             assertEquals(test.get(NANO_OF_SECOND), TEST_12_30_40_987654321.get(NANO_OF_SECOND));
 921         }
 922     }
 923 
 924     // Returns a {@code LocalTime} with the specified minute-of-hour.
 925     // The hour, second-of-minute and nano-of-second will be unchanged.
 926     @Test
 927     public void test_with_longTemporalField_minuteOfHour() {
 928         for (long i : testPoints(60)) {
 929             LocalTime test = TEST_12_30_40_987654321.with(MINUTE_OF_HOUR, i);
 930             assertEquals(test.get(MINUTE_OF_HOUR), i);
 931             assertEquals(test.get(HOUR_OF_DAY), TEST_12_30_40_987654321.get(HOUR_OF_DAY));
 932             assertEquals(test.get(SECOND_OF_MINUTE), TEST_12_30_40_987654321.get(SECOND_OF_MINUTE));
 933             assertEquals(test.get(NANO_OF_SECOND), TEST_12_30_40_987654321.get(NANO_OF_SECOND));
 934         }
 935     }
 936 
 937     // Returns a {@code LocalTime} with the specified minute-of-day.
 938     // The second-of-minute and nano-of-second will be unchanged.
 939     @Test
 940     public void test_with_longTemporalField_minuteOfDay() {
 941         for (long i : testPoints(24 * 60)) {
 942             LocalTime test = TEST_12_30_40_987654321.with(MINUTE_OF_DAY, i);
 943             assertEquals(test.get(MINUTE_OF_DAY), i);
 944             assertEquals(test.get(SECOND_OF_MINUTE), TEST_12_30_40_987654321.get(SECOND_OF_MINUTE));
 945             assertEquals(test.get(NANO_OF_SECOND), TEST_12_30_40_987654321.get(NANO_OF_SECOND));
 946         }
 947     }
 948 
 949     // Returns a {@code LocalTime} with the specified hour-of-am-pm.
 950     // The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.
 951     @Test
 952     public void test_with_longTemporalField_hourOfAmPm() {
 953         for (int i = 0; i &lt; 12; i++) {
 954             LocalTime test = TEST_12_30_40_987654321.with(HOUR_OF_AMPM, i);
 955             assertEquals(test.get(HOUR_OF_AMPM), i);
 956             assertEquals(test.get(AMPM_OF_DAY), TEST_12_30_40_987654321.get(AMPM_OF_DAY));
 957             assertEquals(test.get(MINUTE_OF_HOUR), TEST_12_30_40_987654321.get(MINUTE_OF_HOUR));
 958             assertEquals(test.get(SECOND_OF_MINUTE), TEST_12_30_40_987654321.get(SECOND_OF_MINUTE));
 959             assertEquals(test.get(NANO_OF_SECOND), TEST_12_30_40_987654321.get(NANO_OF_SECOND));
 960         }
 961     }
 962 
 963     // Returns a {@code LocalTime} with the specified clock-hour-of-am-pm.
 964     // The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.
 965     @Test
 966     public void test_with_longTemporalField_clockHourOfAmPm() {
 967         for (int i = 1; i &lt;= 12; i++) {
 968             LocalTime test = TEST_12_30_40_987654321.with(CLOCK_HOUR_OF_AMPM, i);
 969             assertEquals(test.get(CLOCK_HOUR_OF_AMPM), i);
 970             assertEquals(test.get(AMPM_OF_DAY), TEST_12_30_40_987654321.get(AMPM_OF_DAY));
 971             assertEquals(test.get(MINUTE_OF_HOUR), TEST_12_30_40_987654321.get(MINUTE_OF_HOUR));
 972             assertEquals(test.get(SECOND_OF_MINUTE), TEST_12_30_40_987654321.get(SECOND_OF_MINUTE));
 973             assertEquals(test.get(NANO_OF_SECOND), TEST_12_30_40_987654321.get(NANO_OF_SECOND));
 974         }
 975     }
 976 
 977     // Returns a {@code LocalTime} with the specified hour-of-day.
 978     // The minute-of-hour, second-of-minute and nano-of-second will be unchanged.
 979     @Test
 980     public void test_with_longTemporalField_hourOfDay() {
 981         for (int i = 0; i &lt; 24; i++) {
 982             LocalTime test = TEST_12_30_40_987654321.with(HOUR_OF_DAY, i);
 983             assertEquals(test.get(HOUR_OF_DAY), i);
 984             assertEquals(test.get(MINUTE_OF_HOUR), TEST_12_30_40_987654321.get(MINUTE_OF_HOUR));
 985             assertEquals(test.get(SECOND_OF_MINUTE), TEST_12_30_40_987654321.get(SECOND_OF_MINUTE));
 986             assertEquals(test.get(NANO_OF_SECOND), TEST_12_30_40_987654321.get(NANO_OF_SECOND));
 987         }
 988     }
 989 
 990     // Returns a {@code LocalTime} with the specified clock-hour-of-day.
 991     // The minute-of-hour, second-of-minute and nano-of-second will be unchanged.
 992     @Test
 993     public void test_with_longTemporalField_clockHourOfDay() {
 994         for (int i = 1; i &lt;= 24; i++) {
 995             LocalTime test = TEST_12_30_40_987654321.with(CLOCK_HOUR_OF_DAY, i);
 996             assertEquals(test.get(CLOCK_HOUR_OF_DAY), i);
 997             assertEquals(test.get(MINUTE_OF_HOUR), TEST_12_30_40_987654321.get(MINUTE_OF_HOUR));
 998             assertEquals(test.get(SECOND_OF_MINUTE), TEST_12_30_40_987654321.get(SECOND_OF_MINUTE));
 999             assertEquals(test.get(NANO_OF_SECOND), TEST_12_30_40_987654321.get(NANO_OF_SECOND));
1000         }
1001     }
1002 
1003     // Returns a {@code LocalTime} with the specified AM/PM.
1004     // The hour-of-am-pm, minute-of-hour, second-of-minute and nano-of-second will be unchanged.
1005     @Test
1006     public void test_with_longTemporalField_amPmOfDay() {
1007         for (int i = 0; i &lt;= 1; i++) {
1008             LocalTime test = TEST_12_30_40_987654321.with(AMPM_OF_DAY, i);
1009             assertEquals(test.get(AMPM_OF_DAY), i);
1010             assertEquals(test.get(HOUR_OF_AMPM), TEST_12_30_40_987654321.get(HOUR_OF_AMPM));
1011             assertEquals(test.get(MINUTE_OF_HOUR), TEST_12_30_40_987654321.get(MINUTE_OF_HOUR));
1012             assertEquals(test.get(SECOND_OF_MINUTE), TEST_12_30_40_987654321.get(SECOND_OF_MINUTE));
1013             assertEquals(test.get(NANO_OF_SECOND), TEST_12_30_40_987654321.get(NANO_OF_SECOND));
1014         }
1015     }
1016 
1017     // The supported fields behave as follows...
1018     // In all cases, if the new value is outside the valid range of values for the field
1019     // then a {@code DateTimeException} will be thrown.
1020     @DataProvider(name = &quot;withTemporalField_outOfRange&quot;)
1021     Object[][] data_withTemporalField_outOfRange() {
1022         return new Object[][] {
1023                 {NANO_OF_SECOND, time(0, 0, 0, 0), NANO_OF_SECOND.range().getMinimum() - 1},
1024                 {NANO_OF_SECOND, time(0, 0, 0, 0), NANO_OF_SECOND.range().getMaximum() + 1},
1025 
1026                 {NANO_OF_DAY, time(0, 0, 0, 0), NANO_OF_DAY.range().getMinimum() - 1},
1027                 {NANO_OF_DAY, time(0, 0, 0, 0), NANO_OF_DAY.range().getMaximum() + 1},
1028 
1029                 {MICRO_OF_SECOND, time(0, 0, 0, 0), MICRO_OF_SECOND.range().getMinimum() - 1},
1030                 {MICRO_OF_SECOND, time(0, 0, 0, 0), MICRO_OF_SECOND.range().getMaximum() + 1},
1031 
1032                 {MICRO_OF_DAY, time(0, 0, 0, 0), MICRO_OF_DAY.range().getMinimum() - 1},
1033                 {MICRO_OF_DAY, time(0, 0, 0, 0), MICRO_OF_DAY.range().getMaximum() + 1},
1034 
1035                 {MILLI_OF_SECOND, time(0, 0, 0, 0), MILLI_OF_SECOND.range().getMinimum() - 1},
1036                 {MILLI_OF_SECOND, time(0, 0, 0, 0), MILLI_OF_SECOND.range().getMaximum() + 1},
1037 
1038                 {MILLI_OF_DAY, time(0, 0, 0, 0), MILLI_OF_DAY.range().getMinimum() - 1},
1039                 {MILLI_OF_DAY, time(0, 0, 0, 0), MILLI_OF_DAY.range().getMaximum() + 1},
1040 
1041                 {SECOND_OF_MINUTE, time(0, 0, 0, 0), SECOND_OF_MINUTE.range().getMinimum() - 1},
1042                 {SECOND_OF_MINUTE, time(0, 0, 0, 0), SECOND_OF_MINUTE.range().getMaximum() + 1},
1043 
1044                 {SECOND_OF_DAY, time(0, 0, 0, 0), SECOND_OF_DAY.range().getMinimum() - 1},
1045                 {SECOND_OF_DAY, time(0, 0, 0, 0), SECOND_OF_DAY.range().getMaximum() + 1},
1046 
1047                 {MINUTE_OF_HOUR, time(0, 0, 0, 0), MINUTE_OF_HOUR.range().getMinimum() - 1},
1048                 {MINUTE_OF_HOUR, time(0, 0, 0, 0), MINUTE_OF_HOUR.range().getMaximum() + 1},
1049 
1050                 {MINUTE_OF_DAY, time(0, 0, 0, 0), MINUTE_OF_DAY.range().getMinimum() - 1},
1051                 {MINUTE_OF_DAY, time(0, 0, 0, 0), MINUTE_OF_DAY.range().getMaximum() + 1},
1052 
1053                 {HOUR_OF_AMPM, time(0, 0, 0, 0), HOUR_OF_AMPM.range().getMinimum() - 1},
1054                 {HOUR_OF_AMPM, time(0, 0, 0, 0), HOUR_OF_AMPM.range().getMaximum() + 1},
1055 
1056                 {CLOCK_HOUR_OF_AMPM, time(0, 0, 0, 0), CLOCK_HOUR_OF_AMPM.range().getMinimum() - 1},
1057                 {CLOCK_HOUR_OF_AMPM, time(0, 0, 0, 0), CLOCK_HOUR_OF_AMPM.range().getMaximum() + 1},
1058 
1059                 {HOUR_OF_DAY, time(0, 0, 0, 0), HOUR_OF_DAY.range().getMinimum() - 1},
1060                 {HOUR_OF_DAY, time(0, 0, 0, 0), HOUR_OF_DAY.range().getMaximum() + 1},
1061 
1062                 {CLOCK_HOUR_OF_DAY, time(0, 0, 0, 0), CLOCK_HOUR_OF_DAY.range().getMinimum() - 1},
1063                 {CLOCK_HOUR_OF_DAY, time(0, 0, 0, 0), CLOCK_HOUR_OF_DAY.range().getMaximum() + 1},
1064 
1065                 {AMPM_OF_DAY, time(0, 0, 0, 0), AMPM_OF_DAY.range().getMinimum() - 1},
1066                 {AMPM_OF_DAY, time(0, 0, 0, 0), AMPM_OF_DAY.range().getMaximum() + 1},
1067         };
1068     }
1069 
1070     @Test(dataProvider = &quot;withTemporalField_outOfRange&quot;)
1071     public void test_with_longTemporalField_invalid(TemporalField field, LocalTime base, long newValue) {
1072         try {
1073             base.with(field, newValue);
1074             fail(&quot;Field should not be allowed &quot; + field);
1075         } catch (DateTimeException ex) {
1076             // expected
1077         }
1078     }
1079 
1080     // All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
1081     @Test(expectedExceptions=UnsupportedTemporalTypeException.class)
1082     public void test_with_longTemporalField_otherChronoField() {
1083         TEST_12_30_40_987654321.with(ChronoField.DAY_OF_MONTH, 1);
1084     }
1085 
1086     // If the field is not a {@code ChronoField}, then the result of this method
1087     // is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}
1088     // passing {@code this} as the argument.
1089     @Test
1090     public void test_with_longTemporalField_notChronoField() {
1091         final LocalTime result = LocalTime.of(12, 30);
1092         final LocalTime base = LocalTime.of(15, 45);
1093         TemporalField field = new TemporalField() {
1094             public ValueRange rangeRefinedBy(TemporalAccessor temporal) {
1095                 throw new UnsupportedOperationException();
1096             }
1097             public ValueRange range() {
1098                 return null;
1099             }
1100             public boolean isTimeBased() {
1101                 throw new UnsupportedOperationException();
1102             }
1103             public boolean isSupportedBy(TemporalAccessor temporal) {
1104                 throw new UnsupportedOperationException();
1105             }
1106             public boolean isDateBased() {
1107                 throw new UnsupportedOperationException();
1108             }
1109             public TemporalUnit getRangeUnit() {
1110                 throw new UnsupportedOperationException();
1111             }
1112             public long getFrom(TemporalAccessor temporal) {
1113                 throw new UnsupportedOperationException();
1114             }
1115             public TemporalUnit getBaseUnit() {
1116                 throw new UnsupportedOperationException();
1117             }
1118             public &lt;R extends Temporal&gt; R adjustInto(R temporal, long newValue) {
1119                 assertEquals(temporal, base);
1120                 assertEquals(newValue, 12L);
1121                 @SuppressWarnings(&quot;unchecked&quot;)
1122                 R r = (R) result;
1123                 return r;
1124             }
1125         };
1126         LocalTime test = base.with(field, 12L);
1127         assertSame(test, result);
1128     }
1129 
1130     @Test(expectedExceptions=NullPointerException.class)
1131     public void test_with_longTemporalField_null() {
1132         TEST_12_30_40_987654321.with((TemporalField) null, 1);
1133     }
1134 
1135     //-----------------------------------------------------------------------
1136     // withHour()
1137     //-----------------------------------------------------------------------
1138     @Test
1139     public void test_withHour_normal() {
1140         LocalTime t = TEST_12_30_40_987654321;
1141         for (int i = 0; i &lt; 24; i++) {
1142             t = t.withHour(i);
1143             assertEquals(t.getHour(), i);
1144         }
1145     }
1146 
1147     @Test
1148     public void test_withHour_noChange_equal() {
1149         LocalTime t = TEST_12_30_40_987654321.withHour(12);
1150         assertEquals(t, TEST_12_30_40_987654321);
1151     }
1152 
1153     @Test
1154     public void test_withHour_toMidnight_equal() {
1155         LocalTime t = LocalTime.of(1, 0).withHour(0);
1156         assertEquals(t, LocalTime.MIDNIGHT);
1157     }
1158 
1159     @Test
1160     public void test_withHour_toMidday_equal() {
1161         LocalTime t = LocalTime.of(1, 0).withHour(12);
1162         assertEquals(t, LocalTime.NOON);
1163     }
1164 
1165     @Test(expectedExceptions=DateTimeException.class)
1166     public void test_withHour_hourTooLow() {
1167         TEST_12_30_40_987654321.withHour(-1);
1168     }
1169 
1170     @Test(expectedExceptions=DateTimeException.class)
1171     public void test_withHour_hourTooHigh() {
1172         TEST_12_30_40_987654321.withHour(24);
1173     }
1174 
1175     //-----------------------------------------------------------------------
1176     // withMinute()
1177     //-----------------------------------------------------------------------
1178     @Test
1179     public void test_withMinute_normal() {
1180         LocalTime t = TEST_12_30_40_987654321;
1181         for (int i = 0; i &lt; 60; i++) {
1182             t = t.withMinute(i);
1183             assertEquals(t.getMinute(), i);
1184         }
1185     }
1186 
1187     @Test
1188     public void test_withMinute_noChange_equal() {
1189         LocalTime t = TEST_12_30_40_987654321.withMinute(30);
1190         assertEquals(t, TEST_12_30_40_987654321);
1191     }
1192 
1193     @Test
1194     public void test_withMinute_toMidnight_equal() {
1195         LocalTime t = LocalTime.of(0, 1).withMinute(0);
1196         assertEquals(t, LocalTime.MIDNIGHT);
1197     }
1198 
1199     @Test
1200     public void test_withMinute_toMidday_equals() {
1201         LocalTime t = LocalTime.of(12, 1).withMinute(0);
1202         assertEquals(t, LocalTime.NOON);
1203     }
1204 
1205     @Test(expectedExceptions=DateTimeException.class)
1206     public void test_withMinute_minuteTooLow() {
1207         TEST_12_30_40_987654321.withMinute(-1);
1208     }
1209 
1210     @Test(expectedExceptions=DateTimeException.class)
1211     public void test_withMinute_minuteTooHigh() {
1212         TEST_12_30_40_987654321.withMinute(60);
1213     }
1214 
1215     //-----------------------------------------------------------------------
1216     // withSecond()
1217     //-----------------------------------------------------------------------
1218     @Test
1219     public void test_withSecond_normal() {
1220         LocalTime t = TEST_12_30_40_987654321;
1221         for (int i = 0; i &lt; 60; i++) {
1222             t = t.withSecond(i);
1223             assertEquals(t.getSecond(), i);
1224         }
1225     }
1226 
1227     @Test
1228     public void test_withSecond_noChange_equal() {
1229         LocalTime t = TEST_12_30_40_987654321.withSecond(40);
1230         assertEquals(t, TEST_12_30_40_987654321);
1231     }
1232 
1233     @Test
1234     public void test_withSecond_toMidnight_equal() {
1235         LocalTime t = LocalTime.of(0, 0, 1).withSecond(0);
1236         assertEquals(t, LocalTime.MIDNIGHT);
1237     }
1238 
1239     @Test
1240     public void test_withSecond_toMidday_equal() {
1241         LocalTime t = LocalTime.of(12, 0, 1).withSecond(0);
1242         assertEquals(t, LocalTime.NOON);
1243     }
1244 
1245     @Test(expectedExceptions=DateTimeException.class)
1246     public void test_withSecond_secondTooLow() {
1247         TEST_12_30_40_987654321.withSecond(-1);
1248     }
1249 
1250     @Test(expectedExceptions=DateTimeException.class)
1251     public void test_withSecond_secondTooHigh() {
1252         TEST_12_30_40_987654321.withSecond(60);
1253     }
1254 
1255     //-----------------------------------------------------------------------
1256     // withNano()
1257     //-----------------------------------------------------------------------
1258     @Test
1259     public void test_withNanoOfSecond_normal() {
1260         LocalTime t = TEST_12_30_40_987654321;
1261         t = t.withNano(1);
1262         assertEquals(t.getNano(), 1);
1263         t = t.withNano(10);
1264         assertEquals(t.getNano(), 10);
1265         t = t.withNano(100);
1266         assertEquals(t.getNano(), 100);
1267         t = t.withNano(999999999);
1268         assertEquals(t.getNano(), 999999999);
1269     }
1270 
1271     @Test
1272     public void test_withNanoOfSecond_noChange_equal() {
1273         LocalTime t = TEST_12_30_40_987654321.withNano(987654321);
1274         assertEquals(t, TEST_12_30_40_987654321);
1275     }
1276 
1277     @Test
1278     public void test_withNanoOfSecond_toMidnight_equal() {
1279         LocalTime t = LocalTime.of(0, 0, 0, 1).withNano(0);
1280         assertEquals(t, LocalTime.MIDNIGHT);
1281     }
1282 
1283     @Test
1284     public void test_withNanoOfSecond_toMidday_equal() {
1285         LocalTime t = LocalTime.of(12, 0, 0, 1).withNano(0);
1286         assertEquals(t, LocalTime.NOON);
1287     }
1288 
1289     @Test(expectedExceptions=DateTimeException.class)
1290     public void test_withNanoOfSecond_nanoTooLow() {
1291         TEST_12_30_40_987654321.withNano(-1);
1292     }
1293 
1294     @Test(expectedExceptions=DateTimeException.class)
1295     public void test_withNanoOfSecond_nanoTooHigh() {
1296         TEST_12_30_40_987654321.withNano(1000000000);
1297     }
1298 
1299     //-----------------------------------------------------------------------
1300     // truncated(TemporalUnit)
1301     //-----------------------------------------------------------------------
1302     TemporalUnit NINETY_MINS = new TemporalUnit() {
1303         @Override
1304         public Duration getDuration() {
1305             return Duration.ofMinutes(90);
1306         }
1307         @Override
1308         public boolean isDurationEstimated() {
1309             return false;
1310         }
1311         @Override
1312         public boolean isDateBased() {
1313             return false;
1314         }
1315         @Override
1316         public boolean isTimeBased() {
1317             return true;
1318         }
1319         @Override
1320         public boolean isSupportedBy(Temporal temporal) {
1321             return false;
1322         }
1323         @Override
1324         public &lt;R extends Temporal&gt; R addTo(R temporal, long amount) {
1325             throw new UnsupportedOperationException();
1326         }
1327         @Override
1328         public long between(Temporal temporal1, Temporal temporal2) {
1329             throw new UnsupportedOperationException();
1330         }
1331         @Override
1332         public String toString() {
1333             return &quot;NinetyMins&quot;;
1334         }
1335     };
1336 
1337     TemporalUnit NINETY_FIVE_MINS = new TemporalUnit() {
1338         @Override
1339         public Duration getDuration() {
1340             return Duration.ofMinutes(95);
1341         }
1342         @Override
1343         public boolean isDurationEstimated() {
1344             return false;
1345         }
1346         @Override
1347         public boolean isDateBased() {
1348             return false;
1349         }
1350         @Override
1351         public boolean isTimeBased() {
1352             return false;
1353         }
1354         @Override
1355         public boolean isSupportedBy(Temporal temporal) {
1356             return false;
1357         }
1358         @Override
1359         public &lt;R extends Temporal&gt; R addTo(R temporal, long amount) {
1360             throw new UnsupportedOperationException();
1361         }
1362         @Override
1363         public long between(Temporal temporal1, Temporal temporal2) {
1364             throw new UnsupportedOperationException();
1365         }
1366         @Override
1367         public String toString() {
1368             return &quot;NinetyFiveMins&quot;;
1369         }
1370     };
1371 
1372     @DataProvider(name=&quot;truncatedToValid&quot;)
1373     Object[][] data_truncatedToValid() {
1374         return new Object[][] {
1375             {LocalTime.of(1, 2, 3, 123_456_789), NANOS, LocalTime.of(1, 2, 3, 123_456_789)},
1376             {LocalTime.of(1, 2, 3, 123_456_789), MICROS, LocalTime.of(1, 2, 3, 123_456_000)},
1377             {LocalTime.of(1, 2, 3, 123_456_789), MILLIS, LocalTime.of(1, 2, 3, 1230_00_000)},
1378             {LocalTime.of(1, 2, 3, 123_456_789), SECONDS, LocalTime.of(1, 2, 3)},
1379             {LocalTime.of(1, 2, 3, 123_456_789), MINUTES, LocalTime.of(1, 2)},
1380             {LocalTime.of(1, 2, 3, 123_456_789), HOURS, LocalTime.of(1, 0)},
1381             {LocalTime.of(1, 2, 3, 123_456_789), DAYS, LocalTime.MIDNIGHT},
1382 
1383             {LocalTime.of(1, 1, 1, 123_456_789), NINETY_MINS, LocalTime.of(0, 0)},
1384             {LocalTime.of(2, 1, 1, 123_456_789), NINETY_MINS, LocalTime.of(1, 30)},
1385             {LocalTime.of(3, 1, 1, 123_456_789), NINETY_MINS, LocalTime.of(3, 0)},
1386         };
1387     }
1388 
1389     @Test(dataProvider=&quot;truncatedToValid&quot;)
1390     public void test_truncatedTo_valid(LocalTime input, TemporalUnit unit, LocalTime expected) {
1391         assertEquals(input.truncatedTo(unit), expected);
1392     }
1393 
1394     @DataProvider(name=&quot;truncatedToInvalid&quot;)
1395     Object[][] data_truncatedToInvalid() {
1396         return new Object[][] {
1397             {LocalTime.of(1, 2, 3, 123_456_789), NINETY_FIVE_MINS},
1398             {LocalTime.of(1, 2, 3, 123_456_789), WEEKS},
1399             {LocalTime.of(1, 2, 3, 123_456_789), MONTHS},
1400             {LocalTime.of(1, 2, 3, 123_456_789), YEARS},
1401         };
1402     }
1403 
1404     @Test(dataProvider=&quot;truncatedToInvalid&quot;, expectedExceptions=DateTimeException.class)
1405     public void test_truncatedTo_invalid(LocalTime input, TemporalUnit unit) {
1406         input.truncatedTo(unit);
1407     }
1408 
1409     @Test(expectedExceptions=NullPointerException.class)
1410     public void test_truncatedTo_null() {
1411         TEST_12_30_40_987654321.truncatedTo(null);
1412     }
1413 
1414     //-----------------------------------------------------------------------
1415     // plus(TemporalAmount)
1416     //-----------------------------------------------------------------------
1417     @Test
1418     public void test_plus_TemporalAmount_positiveHours() {
1419         TemporalAmount period = MockSimplePeriod.of(7, ChronoUnit.HOURS);
1420         LocalTime t = TEST_12_30_40_987654321.plus(period);
1421         assertEquals(t, LocalTime.of(19, 30, 40, 987654321));
1422     }
1423 
1424     @Test
1425     public void test_plus_TemporalAmount_negativeMinutes() {
1426         TemporalAmount period = MockSimplePeriod.of(-25, ChronoUnit.MINUTES);
1427         LocalTime t = TEST_12_30_40_987654321.plus(period);
1428         assertEquals(t, LocalTime.of(12, 5, 40, 987654321));
1429     }
1430 
1431     @Test
1432     public void test_plus_TemporalAmount_zero() {
1433         TemporalAmount period = Period.ZERO;
1434         LocalTime t = TEST_12_30_40_987654321.plus(period);
1435         assertEquals(t, TEST_12_30_40_987654321);
1436     }
1437 
1438     @Test
1439     public void test_plus_TemporalAmount_wrap() {
1440         TemporalAmount p = MockSimplePeriod.of(1, HOURS);
1441         LocalTime t = LocalTime.of(23, 30).plus(p);
1442         assertEquals(t, LocalTime.of(0, 30));
1443     }
1444 
1445     @Test(expectedExceptions=DateTimeException.class)
1446     public void test_plus_TemporalAmount_dateNotAllowed() {
1447         TemporalAmount period = MockSimplePeriod.of(7, ChronoUnit.MONTHS);
1448         TEST_12_30_40_987654321.plus(period);
1449     }
1450 
1451     @Test(expectedExceptions=NullPointerException.class)
1452     public void test_plus_TemporalAmount_null() {
1453         TEST_12_30_40_987654321.plus((TemporalAmount) null);
1454     }
1455 
1456     //-----------------------------------------------------------------------
1457     // plus(long,TemporalUnit)
1458     //-----------------------------------------------------------------------
1459     @Test
1460     public void test_plus_longTemporalUnit_positiveHours() {
1461         LocalTime t = TEST_12_30_40_987654321.plus(7, ChronoUnit.HOURS);
1462         assertEquals(t, LocalTime.of(19, 30, 40, 987654321));
1463     }
1464 
1465     @Test
1466     public void test_plus_longTemporalUnit_negativeMinutes() {
1467         LocalTime t = TEST_12_30_40_987654321.plus(-25, ChronoUnit.MINUTES);
1468         assertEquals(t, LocalTime.of(12, 5, 40, 987654321));
1469     }
1470 
1471     @Test
1472     public void test_plus_longTemporalUnit_zero() {
1473         LocalTime t = TEST_12_30_40_987654321.plus(0, ChronoUnit.MINUTES);
1474         assertEquals(t, TEST_12_30_40_987654321);
1475     }
1476 
1477     @Test
1478     public void test_plus_longTemporalUnit_invalidUnit() {
1479         for (TemporalUnit unit : INVALID_UNITS) {
1480             try {
1481                 TEST_12_30_40_987654321.plus(1, unit);
1482                 fail(&quot;Unit should not be allowed &quot; + unit);
1483             } catch (DateTimeException ex) {
1484                 // expected
1485             }
1486         }
1487     }
1488 
1489     @Test(expectedExceptions=NullPointerException.class)
1490     public void test_plus_longTemporalUnit_null() {
1491         TEST_12_30_40_987654321.plus(1, (TemporalUnit) null);
1492     }
1493 
1494     //-----------------------------------------------------------------------
1495     // plusHours()
1496     //-----------------------------------------------------------------------
1497     @Test
1498     public void test_plusHours_one() {
1499         LocalTime t = LocalTime.MIDNIGHT;
1500         for (int i = 0; i &lt; 50; i++) {
1501             t = t.plusHours(1);
1502             assertEquals(t.getHour(), (i + 1) % 24);
1503         }
1504     }
1505 
1506     @Test
1507     public void test_plusHours_fromZero() {
1508         LocalTime base = LocalTime.MIDNIGHT;
1509         for (int i = -50; i &lt; 50; i++) {
1510             LocalTime t = base.plusHours(i);
1511             assertEquals(t.getHour(), (i + 72) % 24);
1512         }
1513     }
1514 
1515     @Test
1516     public void test_plusHours_fromOne() {
1517         LocalTime base = LocalTime.of(1, 0);
1518         for (int i = -50; i &lt; 50; i++) {
1519             LocalTime t = base.plusHours(i);
1520             assertEquals(t.getHour(), (1 + i + 72) % 24);
1521         }
1522     }
1523 
1524     @Test
1525     public void test_plusHours_noChange_equal() {
1526         LocalTime t = TEST_12_30_40_987654321.plusHours(0);
1527         assertEquals(t, TEST_12_30_40_987654321);
1528     }
1529 
1530     @Test
1531     public void test_plusHours_toMidnight_equal() {
1532         LocalTime t = LocalTime.of(23, 0).plusHours(1);
1533         assertEquals(t, LocalTime.MIDNIGHT);
1534     }
1535 
1536     @Test
1537     public void test_plusHours_toMidday_equal() {
1538         LocalTime t = LocalTime.of(11, 0).plusHours(1);
1539         assertEquals(t, LocalTime.NOON);
1540     }
1541 
1542     @Test
1543     public void test_plusHours_big() {
1544         LocalTime t = LocalTime.of(2, 30).plusHours(Long.MAX_VALUE);
1545         int hours = (int) (Long.MAX_VALUE % 24L);
1546         assertEquals(t, LocalTime.of(2, 30).plusHours(hours));
1547     }
1548 
1549     //-----------------------------------------------------------------------
1550     // plusMinutes()
1551     //-----------------------------------------------------------------------
1552     @Test
1553     public void test_plusMinutes_one() {
1554         LocalTime t = LocalTime.MIDNIGHT;
1555         int hour = 0;
1556         int min = 0;
1557         for (int i = 0; i &lt; 70; i++) {
1558             t = t.plusMinutes(1);
1559             min++;
1560             if (min == 60) {
1561                 hour++;
1562                 min = 0;
1563             }
1564             assertEquals(t.getHour(), hour);
1565             assertEquals(t.getMinute(), min);
1566         }
1567     }
1568 
1569     @Test
1570     public void test_plusMinutes_fromZero() {
1571         LocalTime base = LocalTime.MIDNIGHT;
1572         int hour;
1573         int min;
1574         for (int i = -70; i &lt; 70; i++) {
1575             LocalTime t = base.plusMinutes(i);
1576             if (i &lt; -60) {
1577                 hour = 22;
1578                 min = i + 120;
1579             } else if (i &lt; 0) {
1580                 hour = 23;
1581                 min = i + 60;
1582             } else if (i &gt;= 60) {
1583                 hour = 1;
1584                 min = i - 60;
1585             } else {
1586                 hour = 0;
1587                 min = i;
1588             }
1589             assertEquals(t.getHour(), hour);
1590             assertEquals(t.getMinute(), min);
1591         }
1592     }
1593 
1594     @Test
1595     public void test_plusMinutes_noChange_equal() {
1596         LocalTime t = TEST_12_30_40_987654321.plusMinutes(0);
1597         assertEquals(t, TEST_12_30_40_987654321);
1598     }
1599 
1600     @Test
1601     public void test_plusMinutes_noChange_oneDay_equal() {
1602         LocalTime t = TEST_12_30_40_987654321.plusMinutes(24 * 60);
1603         assertEquals(t, TEST_12_30_40_987654321);
1604     }
1605 
1606     @Test
1607     public void test_plusMinutes_toMidnight_equal() {
1608         LocalTime t = LocalTime.of(23, 59).plusMinutes(1);
1609         assertEquals(t, LocalTime.MIDNIGHT);
1610     }
1611 
1612     @Test
1613     public void test_plusMinutes_toMidday_equal() {
1614         LocalTime t = LocalTime.of(11, 59).plusMinutes(1);
1615         assertEquals(t, LocalTime.NOON);
1616     }
1617 
1618     @Test
1619     public void test_plusMinutes_big() {
1620         LocalTime t = LocalTime.of(2, 30).plusMinutes(Long.MAX_VALUE);
1621         int mins = (int) (Long.MAX_VALUE % (24L * 60L));
1622         assertEquals(t, LocalTime.of(2, 30).plusMinutes(mins));
1623     }
1624 
1625     //-----------------------------------------------------------------------
1626     // plusSeconds()
1627     //-----------------------------------------------------------------------
1628     @Test
1629     public void test_plusSeconds_one() {
1630         LocalTime t = LocalTime.MIDNIGHT;
1631         int hour = 0;
1632         int min = 0;
1633         int sec = 0;
1634         for (int i = 0; i &lt; 3700; i++) {
1635             t = t.plusSeconds(1);
1636             sec++;
1637             if (sec == 60) {
1638                 min++;
1639                 sec = 0;
1640             }
1641             if (min == 60) {
1642                 hour++;
1643                 min = 0;
1644             }
1645             assertEquals(t.getHour(), hour);
1646             assertEquals(t.getMinute(), min);
1647             assertEquals(t.getSecond(), sec);
1648         }
1649     }
1650 
1651     @DataProvider(name=&quot;plusSeconds_fromZero&quot;)
1652     Iterator&lt;Object[]&gt; plusSeconds_fromZero() {
1653         return new Iterator&lt;Object[]&gt;() {
1654             int delta = 30;
1655             int i = -3660;
1656             int hour = 22;
1657             int min = 59;
1658             int sec = 0;
1659 
1660             public boolean hasNext() {
1661                 return i &lt;= 3660;
1662             }
1663 
1664             public Object[] next() {
1665                 final Object[] ret = new Object[] {i, hour, min, sec};
1666                 i += delta;
1667                 sec += delta;
1668 
1669                 if (sec &gt;= 60) {
1670                     min++;
1671                     sec -= 60;
1672 
1673                     if (min == 60) {
1674                         hour++;
1675                         min = 0;
1676 
1677                         if (hour == 24) {
1678                             hour = 0;
1679                         }
1680                     }
1681                 }
1682 
1683                 return ret;
1684             }
1685 
1686             public void remove() {
1687                 throw new UnsupportedOperationException();
1688             }
1689         };
1690     }
1691 
1692     @Test(dataProvider=&quot;plusSeconds_fromZero&quot;)
1693     public void test_plusSeconds_fromZero(int seconds, int hour, int min, int sec) {
1694         LocalTime base = LocalTime.MIDNIGHT;
1695         LocalTime t = base.plusSeconds(seconds);
1696 
1697         assertEquals(hour, t.getHour());
1698         assertEquals(min, t.getMinute());
1699         assertEquals(sec, t.getSecond());
1700     }
1701 
1702     @Test
1703     public void test_plusSeconds_noChange_equal() {
1704         LocalTime t = TEST_12_30_40_987654321.plusSeconds(0);
1705         assertEquals(t, TEST_12_30_40_987654321);
1706     }
1707 
1708     @Test
1709     public void test_plusSeconds_noChange_oneDay_equal() {
1710         LocalTime t = TEST_12_30_40_987654321.plusSeconds(24 * 60 * 60);
1711         assertEquals(t, TEST_12_30_40_987654321);
1712     }
1713 
1714     @Test
1715     public void test_plusSeconds_toMidnight_equal() {
1716         LocalTime t = LocalTime.of(23, 59, 59).plusSeconds(1);
1717         assertEquals(t, LocalTime.MIDNIGHT);
1718     }
1719 
1720     @Test
1721     public void test_plusSeconds_toMidday_equal() {
1722         LocalTime t = LocalTime.of(11, 59, 59).plusSeconds(1);
1723         assertEquals(t, LocalTime.NOON);
1724     }
1725 
1726     //-----------------------------------------------------------------------
1727     // plusNanos()
1728     //-----------------------------------------------------------------------
1729     @Test
1730     public void test_plusNanos_halfABillion() {
1731         LocalTime t = LocalTime.MIDNIGHT;
1732         int hour = 0;
1733         int min = 0;
1734         int sec = 0;
1735         int nanos = 0;
1736         for (long i = 0; i &lt; 3700 * 1000000000L; i+= 500000000) {
1737             t = t.plusNanos(500000000);
1738             nanos += 500000000;
1739             if (nanos == 1000000000) {
1740                 sec++;
1741                 nanos = 0;
1742             }
1743             if (sec == 60) {
1744                 min++;
1745                 sec = 0;
1746             }
1747             if (min == 60) {
1748                 hour++;
1749                 min = 0;
1750             }
1751             assertEquals(t.getHour(), hour);
1752             assertEquals(t.getMinute(), min);
1753             assertEquals(t.getSecond(), sec);
1754             assertEquals(t.getNano(), nanos);
1755         }
1756     }
1757 
1758     @DataProvider(name=&quot;plusNanos_fromZero&quot;)
1759     Iterator&lt;Object[]&gt; plusNanos_fromZero() {
1760         return new Iterator&lt;Object[]&gt;() {
1761             long delta = 7500000000L;
1762             long i = -3660 * 1000000000L;
1763             int hour = 22;
1764             int min = 59;
1765             int sec = 0;
1766             long nanos = 0;
1767 
1768             public boolean hasNext() {
1769                 return i &lt;= 3660 * 1000000000L;
1770             }
1771 
1772             public Object[] next() {
1773                 final Object[] ret = new Object[] {i, hour, min, sec, (int)nanos};
1774                 i += delta;
1775                 nanos += delta;
1776 
1777                 if (nanos &gt;= 1000000000L) {
1778                     sec += nanos / 1000000000L;
1779                     nanos %= 1000000000L;
1780 
1781                     if (sec &gt;= 60) {
1782                         min++;
1783                         sec %= 60;
1784 
1785                         if (min == 60) {
1786                             hour++;
1787                             min = 0;
1788 
1789                             if (hour == 24) {
1790                                 hour = 0;
1791                             }
1792                         }
1793                     }
1794                 }
1795 
1796                 return ret;
1797             }
1798 
1799             public void remove() {
1800                 throw new UnsupportedOperationException();
1801             }
1802         };
1803     }
1804 
1805     @Test(dataProvider=&quot;plusNanos_fromZero&quot;)
1806     public void test_plusNanos_fromZero(long nanoseconds, int hour, int min, int sec, int nanos) {
1807         LocalTime base = LocalTime.MIDNIGHT;
1808         LocalTime t = base.plusNanos(nanoseconds);
1809 
1810         assertEquals(hour, t.getHour());
1811         assertEquals(min, t.getMinute());
1812         assertEquals(sec, t.getSecond());
1813         assertEquals(nanos, t.getNano());
1814     }
1815 
1816     @Test
1817     public void test_plusNanos_noChange_equal() {
1818         LocalTime t = TEST_12_30_40_987654321.plusNanos(0);
1819         assertEquals(t, TEST_12_30_40_987654321);
1820     }
1821 
1822     @Test
1823     public void test_plusNanos_noChange_oneDay_equal() {
1824         LocalTime t = TEST_12_30_40_987654321.plusNanos(24 * 60 * 60 * 1000000000L);
1825         assertEquals(t, TEST_12_30_40_987654321);
1826     }
1827 
1828     @Test
1829     public void test_plusNanos_toMidnight_equal() {
1830         LocalTime t = LocalTime.of(23, 59, 59, 999999999).plusNanos(1);
1831         assertEquals(t, LocalTime.MIDNIGHT);
1832     }
1833 
1834     @Test
1835     public void test_plusNanos_toMidday_equal() {
1836         LocalTime t = LocalTime.of(11, 59, 59, 999999999).plusNanos(1);
1837         assertEquals(t, LocalTime.NOON);
1838     }
1839 
1840     //-----------------------------------------------------------------------
1841     // minus(TemporalAmount)
1842     //-----------------------------------------------------------------------
1843     @Test
1844     public void test_minus_TemporalAmount_positiveHours() {
1845         TemporalAmount period = MockSimplePeriod.of(7, ChronoUnit.HOURS);
1846         LocalTime t = TEST_12_30_40_987654321.minus(period);
1847         assertEquals(t, LocalTime.of(5, 30, 40, 987654321));
1848     }
1849 
1850     @Test
1851     public void test_minus_TemporalAmount_negativeMinutes() {
1852         TemporalAmount period = MockSimplePeriod.of(-25, ChronoUnit.MINUTES);
1853         LocalTime t = TEST_12_30_40_987654321.minus(period);
1854         assertEquals(t, LocalTime.of(12, 55, 40, 987654321));
1855     }
1856 
1857     @Test
1858     public void test_minus_TemporalAmount_zero() {
1859         TemporalAmount period = Period.ZERO;
1860         LocalTime t = TEST_12_30_40_987654321.minus(period);
1861         assertEquals(t, TEST_12_30_40_987654321);
1862     }
1863 
1864     @Test
1865     public void test_minus_TemporalAmount_wrap() {
1866         TemporalAmount p = MockSimplePeriod.of(1, HOURS);
1867         LocalTime t = LocalTime.of(0, 30).minus(p);
1868         assertEquals(t, LocalTime.of(23, 30));
1869     }
1870 
1871     @Test(expectedExceptions=DateTimeException.class)
1872     public void test_minus_TemporalAmount_dateNotAllowed() {
1873         TemporalAmount period = MockSimplePeriod.of(7, ChronoUnit.MONTHS);
1874         TEST_12_30_40_987654321.minus(period);
1875     }
1876 
1877     @Test(expectedExceptions=NullPointerException.class)
1878     public void test_minus_TemporalAmount_null() {
1879         TEST_12_30_40_987654321.minus((TemporalAmount) null);
1880     }
1881 
1882     //-----------------------------------------------------------------------
1883     // minus(long,TemporalUnit)
1884     //-----------------------------------------------------------------------
1885     @Test
1886     public void test_minus_longTemporalUnit_positiveHours() {
1887         LocalTime t = TEST_12_30_40_987654321.minus(7, ChronoUnit.HOURS);
1888         assertEquals(t, LocalTime.of(5, 30, 40, 987654321));
1889     }
1890 
1891     @Test
1892     public void test_minus_longTemporalUnit_negativeMinutes() {
1893         LocalTime t = TEST_12_30_40_987654321.minus(-25, ChronoUnit.MINUTES);
1894         assertEquals(t, LocalTime.of(12, 55, 40, 987654321));
1895     }
1896 
1897     @Test
1898     public void test_minus_longTemporalUnit_zero() {
1899         LocalTime t = TEST_12_30_40_987654321.minus(0, ChronoUnit.MINUTES);
1900         assertEquals(t, TEST_12_30_40_987654321);
1901     }
1902 
1903     @Test
1904     public void test_minus_longTemporalUnit_invalidUnit() {
1905         for (TemporalUnit unit : INVALID_UNITS) {
1906             try {
1907                 TEST_12_30_40_987654321.minus(1, unit);
1908                 fail(&quot;Unit should not be allowed &quot; + unit);
1909             } catch (DateTimeException ex) {
1910                 // expected
1911             }
1912         }
1913     }
1914 
1915     @Test(expectedExceptions=NullPointerException.class)
1916     public void test_minus_longTemporalUnit_null() {
1917         TEST_12_30_40_987654321.minus(1, (TemporalUnit) null);
1918     }
1919 
1920     //-----------------------------------------------------------------------
1921     // minusHours()
1922     //-----------------------------------------------------------------------
1923     @Test
1924     public void test_minusHours_one() {
1925         LocalTime t = LocalTime.MIDNIGHT;
1926         for (int i = 0; i &lt; 50; i++) {
1927             t = t.minusHours(1);
1928             assertEquals(t.getHour(), (((-i + 23) % 24) + 24) % 24, String.valueOf(i));
1929         }
1930     }
1931 
1932     @Test
1933     public void test_minusHours_fromZero() {
1934         LocalTime base = LocalTime.MIDNIGHT;
1935         for (int i = -50; i &lt; 50; i++) {
1936             LocalTime t = base.minusHours(i);
1937             assertEquals(t.getHour(), ((-i % 24) + 24) % 24);
1938         }
1939     }
1940 
1941     @Test
1942     public void test_minusHours_fromOne() {
1943         LocalTime base = LocalTime.of(1, 0);
1944         for (int i = -50; i &lt; 50; i++) {
1945             LocalTime t = base.minusHours(i);
1946             assertEquals(t.getHour(), (1 + (-i % 24) + 24) % 24);
1947         }
1948     }
1949 
1950     @Test
1951     public void test_minusHours_noChange_equal() {
1952         LocalTime t = TEST_12_30_40_987654321.minusHours(0);
1953         assertEquals(t, TEST_12_30_40_987654321);
1954     }
1955 
1956     @Test
1957     public void test_minusHours_toMidnight_equal() {
1958         LocalTime t = LocalTime.of(1, 0).minusHours(1);
1959         assertEquals(t, LocalTime.MIDNIGHT);
1960     }
1961 
1962     @Test
1963     public void test_minusHours_toMidday_equal() {
1964         LocalTime t = LocalTime.of(13, 0).minusHours(1);
1965         assertEquals(t, LocalTime.NOON);
1966     }
1967 
1968     @Test
1969     public void test_minusHours_big() {
1970         LocalTime t = LocalTime.of(2, 30).minusHours(Long.MAX_VALUE);
1971         int hours = (int) (Long.MAX_VALUE % 24L);
1972         assertEquals(t, LocalTime.of(2, 30).minusHours(hours));
1973     }
1974 
1975     //-----------------------------------------------------------------------
1976     // minusMinutes()
1977     //-----------------------------------------------------------------------
1978     @Test
1979     public void test_minusMinutes_one() {
1980         LocalTime t = LocalTime.MIDNIGHT;
1981         int hour = 0;
1982         int min = 0;
1983         for (int i = 0; i &lt; 70; i++) {
1984             t = t.minusMinutes(1);
1985             min--;
1986             if (min == -1) {
1987                 hour--;
1988                 min = 59;
1989 
1990                 if (hour == -1) {
1991                     hour = 23;
1992                 }
1993             }
1994             assertEquals(t.getHour(), hour);
1995             assertEquals(t.getMinute(), min);
1996         }
1997     }
1998 
1999     @Test
2000     public void test_minusMinutes_fromZero() {
2001         LocalTime base = LocalTime.MIDNIGHT;
2002         int hour = 22;
2003         int min = 49;
2004         for (int i = 70; i &gt; -70; i--) {
2005             LocalTime t = base.minusMinutes(i);
2006             min++;
2007 
2008             if (min == 60) {
2009                 hour++;
2010                 min = 0;
2011 
2012                 if (hour == 24) {
2013                     hour = 0;
2014                 }
2015             }
2016 
2017             assertEquals(t.getHour(), hour);
2018             assertEquals(t.getMinute(), min);
2019         }
2020     }
2021 
2022     @Test
2023     public void test_minusMinutes_noChange_equal() {
2024         LocalTime t = TEST_12_30_40_987654321.minusMinutes(0);
2025         assertEquals(t, TEST_12_30_40_987654321);
2026     }
2027 
2028     @Test
2029     public void test_minusMinutes_noChange_oneDay_equal() {
2030         LocalTime t = TEST_12_30_40_987654321.minusMinutes(24 * 60);
2031         assertEquals(t, TEST_12_30_40_987654321);
2032     }
2033 
2034     @Test
2035     public void test_minusMinutes_toMidnight_equal() {
2036         LocalTime t = LocalTime.of(0, 1).minusMinutes(1);
2037         assertEquals(t, LocalTime.MIDNIGHT);
2038     }
2039 
2040     @Test
2041     public void test_minusMinutes_toMidday_equals() {
2042         LocalTime t = LocalTime.of(12, 1).minusMinutes(1);
2043         assertEquals(t, LocalTime.NOON);
2044     }
2045 
2046     @Test
2047     public void test_minusMinutes_big() {
2048         LocalTime t = LocalTime.of(2, 30).minusMinutes(Long.MAX_VALUE);
2049         int mins = (int) (Long.MAX_VALUE % (24L * 60L));
2050         assertEquals(t, LocalTime.of(2, 30).minusMinutes(mins));
2051     }
2052 
2053     //-----------------------------------------------------------------------
2054     // minusSeconds()
2055     //-----------------------------------------------------------------------
2056     @Test
2057     public void test_minusSeconds_one() {
2058         LocalTime t = LocalTime.MIDNIGHT;
2059         int hour = 0;
2060         int min = 0;
2061         int sec = 0;
2062         for (int i = 0; i &lt; 3700; i++) {
2063             t = t.minusSeconds(1);
2064             sec--;
2065             if (sec == -1) {
2066                 min--;
2067                 sec = 59;
2068 
2069                 if (min == -1) {
2070                     hour--;
2071                     min = 59;
2072 
2073                     if (hour == -1) {
2074                         hour = 23;
2075                     }
2076                 }
2077             }
2078             assertEquals(t.getHour(), hour);
2079             assertEquals(t.getMinute(), min);
2080             assertEquals(t.getSecond(), sec);
2081         }
2082     }
2083 
2084     @DataProvider(name=&quot;minusSeconds_fromZero&quot;)
2085     Iterator&lt;Object[]&gt; minusSeconds_fromZero() {
2086         return new Iterator&lt;Object[]&gt;() {
2087             int delta = 30;
2088             int i = 3660;
2089             int hour = 22;
2090             int min = 59;
2091             int sec = 0;
2092 
2093             public boolean hasNext() {
2094                 return i &gt;= -3660;
2095             }
2096 
2097             public Object[] next() {
2098                 final Object[] ret = new Object[] {i, hour, min, sec};
2099                 i -= delta;
2100                 sec += delta;
2101 
2102                 if (sec &gt;= 60) {
2103                     min++;
2104                     sec -= 60;
2105 
2106                     if (min == 60) {
2107                         hour++;
2108                         min = 0;
2109 
2110                         if (hour == 24) {
2111                             hour = 0;
2112                         }
2113                     }
2114                 }
2115 
2116                 return ret;
2117             }
2118 
2119             public void remove() {
2120                 throw new UnsupportedOperationException();
2121             }
2122         };
2123     }
2124 
2125     @Test(dataProvider=&quot;minusSeconds_fromZero&quot;)
2126     public void test_minusSeconds_fromZero(int seconds, int hour, int min, int sec) {
2127         LocalTime base = LocalTime.MIDNIGHT;
2128         LocalTime t = base.minusSeconds(seconds);
2129 
2130         assertEquals(t.getHour(), hour);
2131         assertEquals(t.getMinute(), min);
2132         assertEquals(t.getSecond(), sec);
2133     }
2134 
2135     @Test
2136     public void test_minusSeconds_noChange_equal() {
2137         LocalTime t = TEST_12_30_40_987654321.minusSeconds(0);
2138         assertEquals(t, TEST_12_30_40_987654321);
2139     }
2140 
2141     @Test
2142     public void test_minusSeconds_noChange_oneDay_equal() {
2143         LocalTime t = TEST_12_30_40_987654321.minusSeconds(24 * 60 * 60);
2144         assertEquals(t, TEST_12_30_40_987654321);
2145     }
2146 
2147     @Test
2148     public void test_minusSeconds_toMidnight_equal() {
2149         LocalTime t = LocalTime.of(0, 0, 1).minusSeconds(1);
2150         assertEquals(t, LocalTime.MIDNIGHT);
2151     }
2152 
2153     @Test
2154     public void test_minusSeconds_toMidday_equal() {
2155         LocalTime t = LocalTime.of(12, 0, 1).minusSeconds(1);
2156         assertEquals(t, LocalTime.NOON);
2157     }
2158 
2159     @Test
2160     public void test_minusSeconds_big() {
2161         LocalTime t = LocalTime.of(2, 30).minusSeconds(Long.MAX_VALUE);
2162         int secs = (int) (Long.MAX_VALUE % (24L * 60L * 60L));
2163         assertEquals(t, LocalTime.of(2, 30).minusSeconds(secs));
2164     }
2165 
2166     //-----------------------------------------------------------------------
2167     // minusNanos()
2168     //-----------------------------------------------------------------------
2169     @Test
2170     public void test_minusNanos_halfABillion() {
2171         LocalTime t = LocalTime.MIDNIGHT;
2172         int hour = 0;
2173         int min = 0;
2174         int sec = 0;
2175         int nanos = 0;
2176         for (long i = 0; i &lt; 3700 * 1000000000L; i+= 500000000) {
2177             t = t.minusNanos(500000000);
2178             nanos -= 500000000;
2179 
2180             if (nanos &lt; 0) {
2181                 sec--;
2182                 nanos += 1000000000;
2183 
2184                 if (sec == -1) {
2185                     min--;
2186                     sec += 60;
2187 
2188                     if (min == -1) {
2189                         hour--;
2190                         min += 60;
2191 
2192                         if (hour == -1) {
2193                             hour += 24;
2194                         }
2195                     }
2196                 }
2197             }
2198 
2199             assertEquals(t.getHour(), hour);
2200             assertEquals(t.getMinute(), min);
2201             assertEquals(t.getSecond(), sec);
2202             assertEquals(t.getNano(), nanos);
2203         }
2204     }
2205 
2206     @DataProvider(name=&quot;minusNanos_fromZero&quot;)
2207     Iterator&lt;Object[]&gt; minusNanos_fromZero() {
2208         return new Iterator&lt;Object[]&gt;() {
2209             long delta = 7500000000L;
2210             long i = 3660 * 1000000000L;
2211             int hour = 22;
2212             int min = 59;
2213             int sec = 0;
2214             long nanos = 0;
2215 
2216             public boolean hasNext() {
2217                 return i &gt;= -3660 * 1000000000L;
2218             }
2219 
2220             public Object[] next() {
2221                 final Object[] ret = new Object[] {i, hour, min, sec, (int)nanos};
2222                 i -= delta;
2223                 nanos += delta;
2224 
2225                 if (nanos &gt;= 1000000000L) {
2226                     sec += nanos / 1000000000L;
2227                     nanos %= 1000000000L;
2228 
2229                     if (sec &gt;= 60) {
2230                         min++;
2231                         sec %= 60;
2232 
2233                         if (min == 60) {
2234                             hour++;
2235                             min = 0;
2236 
2237                             if (hour == 24) {
2238                                 hour = 0;
2239                             }
2240                         }
2241                     }
2242                 }
2243 
2244                 return ret;
2245             }
2246 
2247             public void remove() {
2248                 throw new UnsupportedOperationException();
2249             }
2250         };
2251     }
2252 
2253     @Test(dataProvider=&quot;minusNanos_fromZero&quot;)
2254     public void test_minusNanos_fromZero(long nanoseconds, int hour, int min, int sec, int nanos) {
2255         LocalTime base = LocalTime.MIDNIGHT;
2256         LocalTime t = base.minusNanos(nanoseconds);
2257 
2258         assertEquals(hour, t.getHour());
2259         assertEquals(min, t.getMinute());
2260         assertEquals(sec, t.getSecond());
2261         assertEquals(nanos, t.getNano());
2262     }
2263 
2264     @Test
2265     public void test_minusNanos_noChange_equal() {
2266         LocalTime t = TEST_12_30_40_987654321.minusNanos(0);
2267         assertEquals(t, TEST_12_30_40_987654321);
2268     }
2269 
2270     @Test
2271     public void test_minusNanos_noChange_oneDay_equal() {
2272         LocalTime t = TEST_12_30_40_987654321.minusNanos(24 * 60 * 60 * 1000000000L);
2273         assertEquals(t, TEST_12_30_40_987654321);
2274     }
2275 
2276     @Test
2277     public void test_minusNanos_toMidnight_equal() {
2278         LocalTime t = LocalTime.of(0, 0, 0, 1).minusNanos(1);
2279         assertEquals(t, LocalTime.MIDNIGHT);
2280     }
2281 
2282     @Test
2283     public void test_minusNanos_toMidday_equal() {
2284         LocalTime t = LocalTime.of(12, 0, 0, 1).minusNanos(1);
2285         assertEquals(t, LocalTime.NOON);
2286     }
2287 
2288     //-----------------------------------------------------------------------
2289     // until(Temporal, TemporalUnit)
2290     //-----------------------------------------------------------------------
2291     @DataProvider(name=&quot;periodUntilUnit&quot;)
2292     Object[][] data_periodUntilUnit() {
2293         return new Object[][] {
2294                 {time(0, 0, 0, 0), time(0, 0, 0, 0), NANOS, 0},
2295                 {time(0, 0, 0, 0), time(0, 0, 0, 0), MICROS, 0},
2296                 {time(0, 0, 0, 0), time(0, 0, 0, 0), MILLIS, 0},
2297                 {time(0, 0, 0, 0), time(0, 0, 0, 0), SECONDS, 0},
2298                 {time(0, 0, 0, 0), time(0, 0, 0, 0), MINUTES, 0},
2299                 {time(0, 0, 0, 0), time(0, 0, 0, 0), HOURS, 0},
2300                 {time(0, 0, 0, 0), time(0, 0, 0, 0), HALF_DAYS, 0},
2301 
2302                 {time(0, 0, 0, 0), time(2, 0, 0, 0), NANOS, 2 * 3600 * 1_000_000_000L},
2303                 {time(0, 0, 0, 0), time(2, 0, 0, 0), MICROS, 2 * 3600 * 1_000_000L},
2304                 {time(0, 0, 0, 0), time(2, 0, 0, 0), MILLIS, 2 * 3600 * 1_000L},
2305                 {time(0, 0, 0, 0), time(2, 0, 0, 0), SECONDS, 2 * 3600},
2306                 {time(0, 0, 0, 0), time(2, 0, 0, 0), MINUTES, 2 * 60},
2307                 {time(0, 0, 0, 0), time(2, 0, 0, 0), HOURS, 2},
2308                 {time(0, 0, 0, 0), time(2, 0, 0, 0), HALF_DAYS, 0},
2309 
2310                 {time(0, 0, 0, 0), time(14, 0, 0, 0), NANOS, 14 * 3600 * 1_000_000_000L},
2311                 {time(0, 0, 0, 0), time(14, 0, 0, 0), MICROS, 14 * 3600 * 1_000_000L},
2312                 {time(0, 0, 0, 0), time(14, 0, 0, 0), MILLIS, 14 * 3600 * 1_000L},
2313                 {time(0, 0, 0, 0), time(14, 0, 0, 0), SECONDS, 14 * 3600},
2314                 {time(0, 0, 0, 0), time(14, 0, 0, 0), MINUTES, 14 * 60},
2315                 {time(0, 0, 0, 0), time(14, 0, 0, 0), HOURS, 14},
2316                 {time(0, 0, 0, 0), time(14, 0, 0, 0), HALF_DAYS, 1},
2317 
2318                 {time(0, 0, 0, 0), time(2, 30, 40, 1500), NANOS, (2 * 3600 + 30 * 60 + 40) * 1_000_000_000L + 1500},
2319                 {time(0, 0, 0, 0), time(2, 30, 40, 1500), MICROS, (2 * 3600 + 30 * 60 + 40) * 1_000_000L + 1},
2320                 {time(0, 0, 0, 0), time(2, 30, 40, 1500), MILLIS, (2 * 3600 + 30 * 60 + 40) * 1_000L},
2321                 {time(0, 0, 0, 0), time(2, 30, 40, 1500), SECONDS, 2 * 3600 + 30 * 60 + 40},
2322                 {time(0, 0, 0, 0), time(2, 30, 40, 1500), MINUTES, 2 * 60 + 30},
2323                 {time(0, 0, 0, 0), time(2, 30, 40, 1500), HOURS, 2},
2324         };
2325     }
2326 
2327     @Test(dataProvider=&quot;periodUntilUnit&quot;)
2328     public void test_until_TemporalUnit(LocalTime time1, LocalTime time2, TemporalUnit unit, long expected) {
2329         long amount = time1.until(time2, unit);
2330         assertEquals(amount, expected);
2331     }
2332 
2333     @Test(dataProvider=&quot;periodUntilUnit&quot;)
2334     public void test_until_TemporalUnit_negated(LocalTime time1, LocalTime time2, TemporalUnit unit, long expected) {
2335         long amount = time2.until(time1, unit);
2336         assertEquals(amount, -expected);
2337     }
2338 
2339     @Test(dataProvider=&quot;periodUntilUnit&quot;)
2340     public void test_until_TemporalUnit_between(LocalTime time1, LocalTime time2, TemporalUnit unit, long expected) {
2341         long amount = unit.between(time1, time2);
2342         assertEquals(amount, expected);
2343     }
2344 
2345     @Test
2346     public void test_until_convertedType() {
2347         LocalTime start = LocalTime.of(11, 30);
2348         LocalDateTime end = start.plusSeconds(2).atDate(LocalDate.of(2010, 6, 30));
2349         assertEquals(start.until(end, SECONDS), 2);
2350     }
2351 
2352     @Test(expectedExceptions=DateTimeException.class)
2353     public void test_until_invalidType() {
2354         LocalTime start = LocalTime.of(11, 30);
2355         start.until(LocalDate.of(2010, 6, 30), SECONDS);
2356     }
2357 
2358     @Test(expectedExceptions = UnsupportedTemporalTypeException.class)
2359     public void test_until_TemporalUnit_unsupportedUnit() {
2360         TEST_12_30_40_987654321.until(TEST_12_30_40_987654321, DAYS);
2361     }
2362 
2363     @Test(expectedExceptions = NullPointerException.class)
2364     public void test_until_TemporalUnit_nullEnd() {
2365         TEST_12_30_40_987654321.until(null, HOURS);
2366     }
2367 
2368     @Test(expectedExceptions = NullPointerException.class)
2369     public void test_until_TemporalUnit_nullUnit() {
2370         TEST_12_30_40_987654321.until(TEST_12_30_40_987654321, null);
2371     }
2372 
2373     //-----------------------------------------------------------------------
2374     // format(DateTimeFormatter)
2375     //-----------------------------------------------------------------------
2376     @Test
2377     public void test_format_formatter() {
2378         DateTimeFormatter f = DateTimeFormatter.ofPattern(&quot;H m s&quot;);
2379         String t = LocalTime.of(11, 30, 45).format(f);
2380         assertEquals(t, &quot;11 30 45&quot;);
2381     }
2382 
2383     @Test(expectedExceptions=NullPointerException.class)
2384     public void test_format_formatter_null() {
2385         LocalTime.of(11, 30, 45).format(null);
2386     }
2387 
2388     //-----------------------------------------------------------------------
2389     // atDate()
2390     //-----------------------------------------------------------------------
2391     @Test
2392     public void test_atDate() {
2393         LocalTime t = LocalTime.of(11, 30);
2394         assertEquals(t.atDate(LocalDate.of(2012, 6, 30)), LocalDateTime.of(2012, 6, 30, 11, 30));
2395     }
2396 
2397     @Test(expectedExceptions=NullPointerException.class)
2398     public void test_atDate_nullDate() {
2399         TEST_12_30_40_987654321.atDate((LocalDate) null);
2400     }
2401 
2402     //-----------------------------------------------------------------------
2403     // atOffset()
2404     //-----------------------------------------------------------------------
2405     @Test
2406     public void test_atOffset() {
2407         LocalTime t = LocalTime.of(11, 30);
2408         assertEquals(t.atOffset(OFFSET_PTWO), OffsetTime.of(LocalTime.of(11, 30), OFFSET_PTWO));
2409     }
2410 
2411     @Test(expectedExceptions=NullPointerException.class)
2412     public void test_atOffset_nullZoneOffset() {
2413         LocalTime t = LocalTime.of(11, 30);
2414         t.atOffset((ZoneOffset) null);
2415     }
2416 
2417     //-----------------------------------------------------------------------
2418     // toSecondOfDay()
2419     //-----------------------------------------------------------------------
2420     @Test
2421     public void test_toSecondOfDay() {
2422         LocalTime t = LocalTime.of(0, 0);
2423         for (int i = 0; i &lt; 24 * 60 * 60; i++) {
2424             assertEquals(t.toSecondOfDay(), i);
2425             t = t.plusSeconds(1);
2426         }
2427     }
2428 
2429     //-----------------------------------------------------------------------
2430     // toEpochSecond()
2431     //--------------------------------------------------------------------------
2432     @DataProvider(name=&quot;epochSecond&quot;)
2433     Object[][] provider__toEpochSecond() {
2434         return new Object[][] {
2435         {LocalTime.of(0, 0).toEpochSecond(LocalDate.of(1970, 1, 1), OFFSET_PTWO), -7200L},
2436         {LocalTime.of(11, 30).toEpochSecond(LocalDate.of(1965, 12, 31), OFFSET_PTWO), -126282600L},
2437         {LocalTime.of(11, 30).toEpochSecond(LocalDate.of(1995, 5, 3), OFFSET_MTWO), 799507800L},
2438         {LocalTime.of(0, 0).toEpochSecond(LocalDate.of(1970, 1, 1), OFFSET_PTWO),
2439                 Instant.ofEpochSecond(-7200).getEpochSecond()},
2440         {LocalTime.of(11, 30).toEpochSecond(LocalDate.of(1969, 12, 31), OFFSET_MTWO),
2441                 Instant.ofEpochSecond(-37800L).getEpochSecond()},
2442         {LocalTime.of(11, 30).toEpochSecond(LocalDate.of(1970, 1, 1), OFFSET_PTWO),
2443                 LocalDateTime.of(1970, 1, 1, 11, 30).toEpochSecond(OFFSET_PTWO)},
2444         };
2445     }
2446 
2447     @Test(dataProvider=&quot;epochSecond&quot;)
2448     public void test_toEpochSecond(long actual, long expected) {
2449         assertEquals(actual, expected);
2450     }
2451 
2452     //-----------------------------------------------------------------------
2453     // toSecondOfDay_fromNanoOfDay_symmetry()
2454     //-----------------------------------------------------------------------
2455     @Test
2456     public void test_toSecondOfDay_fromNanoOfDay_symmetry() {
2457         LocalTime t = LocalTime.of(0, 0);
2458         for (int i = 0; i &lt; 24 * 60 * 60; i++) {
2459             assertEquals(LocalTime.ofSecondOfDay(t.toSecondOfDay()), t);
2460             t = t.plusSeconds(1);
2461         }
2462     }
2463 
2464     //-----------------------------------------------------------------------
2465     // toNanoOfDay()
2466     //-----------------------------------------------------------------------
2467     @Test
2468     public void test_toNanoOfDay() {
2469         LocalTime t = LocalTime.of(0, 0);
2470         for (int i = 0; i &lt; 1000000; i++) {
2471             assertEquals(t.toNanoOfDay(), i);
2472             t = t.plusNanos(1);
2473         }
2474         t = LocalTime.of(0, 0);
2475         for (int i = 1; i &lt;= 1000000; i++) {
2476             t = t.minusNanos(1);
2477             assertEquals(t.toNanoOfDay(), 24 * 60 * 60 * 1000000000L - i);
2478         }
2479     }
2480 
2481     @Test
2482     public void test_toNanoOfDay_fromNanoOfDay_symmetry() {
2483         LocalTime t = LocalTime.of(0, 0);
2484         for (int i = 0; i &lt; 1000000; i++) {
2485             assertEquals(LocalTime.ofNanoOfDay(t.toNanoOfDay()), t);
2486             t = t.plusNanos(1);
2487         }
2488         t = LocalTime.of(0, 0);
2489         for (int i = 1; i &lt;= 1000000; i++) {
2490             t = t.minusNanos(1);
2491             assertEquals(LocalTime.ofNanoOfDay(t.toNanoOfDay()), t);
2492         }
2493     }
2494 
2495     //-----------------------------------------------------------------------
2496     // compareTo()
2497     //-----------------------------------------------------------------------
2498     @Test
2499     public void test_comparisons() {
2500         doTest_comparisons_LocalTime(
2501             LocalTime.MIDNIGHT,
2502             LocalTime.of(0, 0, 0, 999999999),
2503             LocalTime.of(0, 0, 59, 0),
2504             LocalTime.of(0, 0, 59, 999999999),
2505             LocalTime.of(0, 59, 0, 0),
2506             LocalTime.of(0, 59, 0, 999999999),
2507             LocalTime.of(0, 59, 59, 0),
2508             LocalTime.of(0, 59, 59, 999999999),
2509             LocalTime.NOON,
2510             LocalTime.of(12, 0, 0, 999999999),
2511             LocalTime.of(12, 0, 59, 0),
2512             LocalTime.of(12, 0, 59, 999999999),
2513             LocalTime.of(12, 59, 0, 0),
2514             LocalTime.of(12, 59, 0, 999999999),
2515             LocalTime.of(12, 59, 59, 0),
2516             LocalTime.of(12, 59, 59, 999999999),
2517             LocalTime.of(23, 0, 0, 0),
2518             LocalTime.of(23, 0, 0, 999999999),
2519             LocalTime.of(23, 0, 59, 0),
2520             LocalTime.of(23, 0, 59, 999999999),
2521             LocalTime.of(23, 59, 0, 0),
2522             LocalTime.of(23, 59, 0, 999999999),
2523             LocalTime.of(23, 59, 59, 0),
2524             LocalTime.of(23, 59, 59, 999999999)
2525         );
2526     }
2527 
2528     void doTest_comparisons_LocalTime(LocalTime... localTimes) {
2529         for (int i = 0; i &lt; localTimes.length; i++) {
2530             LocalTime a = localTimes[i];
2531             for (int j = 0; j &lt; localTimes.length; j++) {
2532                 LocalTime b = localTimes[j];
2533                 if (i &lt; j) {
2534                     assertTrue(a.compareTo(b) &lt; 0, a + &quot; &lt;=&gt; &quot; + b);
2535                     assertEquals(a.isBefore(b), true, a + &quot; &lt;=&gt; &quot; + b);
2536                     assertEquals(a.isAfter(b), false, a + &quot; &lt;=&gt; &quot; + b);
2537                     assertEquals(a.equals(b), false, a + &quot; &lt;=&gt; &quot; + b);
2538                 } else if (i &gt; j) {
2539                     assertTrue(a.compareTo(b) &gt; 0, a + &quot; &lt;=&gt; &quot; + b);
2540                     assertEquals(a.isBefore(b), false, a + &quot; &lt;=&gt; &quot; + b);
2541                     assertEquals(a.isAfter(b), true, a + &quot; &lt;=&gt; &quot; + b);
2542                     assertEquals(a.equals(b), false, a + &quot; &lt;=&gt; &quot; + b);
2543                 } else {
2544                     assertEquals(a.compareTo(b), 0, a + &quot; &lt;=&gt; &quot; + b);
2545                     assertEquals(a.isBefore(b), false, a + &quot; &lt;=&gt; &quot; + b);
2546                     assertEquals(a.isAfter(b), false, a + &quot; &lt;=&gt; &quot; + b);
2547                     assertEquals(a.equals(b), true, a + &quot; &lt;=&gt; &quot; + b);
2548                 }
2549             }
2550         }
2551     }
2552 
2553     @Test(expectedExceptions=NullPointerException.class)
2554     public void test_compareTo_ObjectNull() {
2555         TEST_12_30_40_987654321.compareTo(null);
2556     }
2557 
2558     @Test(expectedExceptions=NullPointerException.class)
2559     public void test_isBefore_ObjectNull() {
2560         TEST_12_30_40_987654321.isBefore(null);
2561     }
2562 
2563     @Test(expectedExceptions=NullPointerException.class)
2564     public void test_isAfter_ObjectNull() {
2565         TEST_12_30_40_987654321.isAfter(null);
2566     }
2567 
2568     @Test(expectedExceptions=ClassCastException.class)
2569     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
2570     public void compareToNonLocalTime() {
2571        Comparable c = TEST_12_30_40_987654321;
2572        c.compareTo(new Object());
2573     }
2574 
2575     //-----------------------------------------------------------------------
2576     // equals()
2577     //-----------------------------------------------------------------------
2578     @Test(dataProvider=&quot;sampleTimes&quot;)
2579     public void test_equals_true(int h, int m, int s, int n) {
2580         LocalTime a = LocalTime.of(h, m, s, n);
2581         LocalTime b = LocalTime.of(h, m, s, n);
2582         assertEquals(a.equals(b), true);
2583     }
2584     @Test(dataProvider=&quot;sampleTimes&quot;)
2585     public void test_equals_false_hour_differs(int h, int m, int s, int n) {
2586         LocalTime a = LocalTime.of(h, m, s, n);
2587         LocalTime b = LocalTime.of(h + 1, m, s, n);
2588         assertEquals(a.equals(b), false);
2589     }
2590     @Test(dataProvider=&quot;sampleTimes&quot;)
2591     public void test_equals_false_minute_differs(int h, int m, int s, int n) {
2592         LocalTime a = LocalTime.of(h, m, s, n);
2593         LocalTime b = LocalTime.of(h, m + 1, s, n);
2594         assertEquals(a.equals(b), false);
2595     }
2596     @Test(dataProvider=&quot;sampleTimes&quot;)
2597     public void test_equals_false_second_differs(int h, int m, int s, int n) {
2598         LocalTime a = LocalTime.of(h, m, s, n);
2599         LocalTime b = LocalTime.of(h, m, s + 1, n);
2600         assertEquals(a.equals(b), false);
2601     }
2602     @Test(dataProvider=&quot;sampleTimes&quot;)
2603     public void test_equals_false_nano_differs(int h, int m, int s, int n) {
2604         LocalTime a = LocalTime.of(h, m, s, n);
2605         LocalTime b = LocalTime.of(h, m, s, n + 1);
2606         assertEquals(a.equals(b), false);
2607     }
2608 
2609     @Test
2610     public void test_equals_itself_true() {
2611         assertEquals(TEST_12_30_40_987654321.equals(TEST_12_30_40_987654321), true);
2612     }
2613 
2614     @Test
2615     public void test_equals_string_false() {
2616         assertEquals(TEST_12_30_40_987654321.equals(&quot;2007-07-15&quot;), false);
2617     }
2618 
2619     @Test
2620     public void test_equals_null_false() {
2621         assertEquals(TEST_12_30_40_987654321.equals(null), false);
2622     }
2623 
2624     //-----------------------------------------------------------------------
2625     // hashCode()
2626     //-----------------------------------------------------------------------
2627     @Test(dataProvider=&quot;sampleTimes&quot;)
2628     public void test_hashCode_same(int h, int m, int s, int n) {
2629         LocalTime a = LocalTime.of(h, m, s, n);
2630         LocalTime b = LocalTime.of(h, m, s, n);
2631         assertEquals(a.hashCode(), b.hashCode());
2632     }
2633 
2634     @Test(dataProvider=&quot;sampleTimes&quot;)
2635     public void test_hashCode_hour_differs(int h, int m, int s, int n) {
2636         LocalTime a = LocalTime.of(h, m, s, n);
2637         LocalTime b = LocalTime.of(h + 1, m, s, n);
2638         assertEquals(a.hashCode() == b.hashCode(), false);
2639     }
2640 
2641     @Test(dataProvider=&quot;sampleTimes&quot;)
2642     public void test_hashCode_minute_differs(int h, int m, int s, int n) {
2643         LocalTime a = LocalTime.of(h, m, s, n);
2644         LocalTime b = LocalTime.of(h, m + 1, s, n);
2645         assertEquals(a.hashCode() == b.hashCode(), false);
2646     }
2647 
2648     @Test(dataProvider=&quot;sampleTimes&quot;)
2649     public void test_hashCode_second_differs(int h, int m, int s, int n) {
2650         LocalTime a = LocalTime.of(h, m, s, n);
2651         LocalTime b = LocalTime.of(h, m, s + 1, n);
2652         assertEquals(a.hashCode() == b.hashCode(), false);
2653     }
2654 
2655     @Test(dataProvider=&quot;sampleTimes&quot;)
2656     public void test_hashCode_nano_differs(int h, int m, int s, int n) {
2657         LocalTime a = LocalTime.of(h, m, s, n);
2658         LocalTime b = LocalTime.of(h, m, s, n + 1);
2659         assertEquals(a.hashCode() == b.hashCode(), false);
2660     }
2661 
2662     //-----------------------------------------------------------------------
2663     // toString()
2664     //-----------------------------------------------------------------------
2665     @DataProvider(name=&quot;sampleToString&quot;)
2666     Object[][] provider_sampleToString() {
2667         return new Object[][] {
2668             {0, 0, 0, 0, &quot;00:00&quot;},
2669             {1, 0, 0, 0, &quot;01:00&quot;},
2670             {23, 0, 0, 0, &quot;23:00&quot;},
2671             {0, 1, 0, 0, &quot;00:01&quot;},
2672             {12, 30, 0, 0, &quot;12:30&quot;},
2673             {23, 59, 0, 0, &quot;23:59&quot;},
2674             {0, 0, 1, 0, &quot;00:00:01&quot;},
2675             {0, 0, 59, 0, &quot;00:00:59&quot;},
2676             {0, 0, 0, 100000000, &quot;00:00:00.100&quot;},
2677             {0, 0, 0, 10000000, &quot;00:00:00.010&quot;},
2678             {0, 0, 0, 1000000, &quot;00:00:00.001&quot;},
2679             {0, 0, 0, 100000, &quot;00:00:00.000100&quot;},
2680             {0, 0, 0, 10000, &quot;00:00:00.000010&quot;},
2681             {0, 0, 0, 1000, &quot;00:00:00.000001&quot;},
2682             {0, 0, 0, 100, &quot;00:00:00.000000100&quot;},
2683             {0, 0, 0, 10, &quot;00:00:00.000000010&quot;},
2684             {0, 0, 0, 1, &quot;00:00:00.000000001&quot;},
2685             {0, 0, 0, 999999999, &quot;00:00:00.999999999&quot;},
2686             {0, 0, 0, 99999999, &quot;00:00:00.099999999&quot;},
2687             {0, 0, 0, 9999999, &quot;00:00:00.009999999&quot;},
2688             {0, 0, 0, 999999, &quot;00:00:00.000999999&quot;},
2689             {0, 0, 0, 99999, &quot;00:00:00.000099999&quot;},
2690             {0, 0, 0, 9999, &quot;00:00:00.000009999&quot;},
2691             {0, 0, 0, 999, &quot;00:00:00.000000999&quot;},
2692             {0, 0, 0, 99, &quot;00:00:00.000000099&quot;},
2693             {0, 0, 0, 9, &quot;00:00:00.000000009&quot;},
2694         };
2695     }
2696 
2697     @Test(dataProvider=&quot;sampleToString&quot;)
2698     public void test_toString(int h, int m, int s, int n, String expected) {
2699         LocalTime t = LocalTime.of(h, m, s, n);
2700         String str = t.toString();
2701         assertEquals(str, expected);
2702     }
2703 
2704     private LocalTime time(int hour, int min, int sec, int nano) {
2705         return LocalTime.of(hour, min, sec, nano);
2706     }
2707 }
    </pre>
  </body>
</html>
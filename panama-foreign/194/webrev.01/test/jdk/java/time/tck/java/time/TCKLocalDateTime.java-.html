<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/time/tck/java/time/TCKLocalDateTime.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * This file is available under and governed by the GNU General Public
  26  * License version 2 only, as published by the Free Software Foundation.
  27  * However, the following notice accompanied the original version of this
  28  * file:
  29  *
  30  * Copyright (c) 2008-2012, Stephen Colebourne &amp; Michael Nascimento Santos
  31  *
  32  * All rights reserved.
  33  *
  34  * Redistribution and use in source and binary forms, with or without
  35  * modification, are permitted provided that the following conditions are met:
  36  *
  37  *  * Redistributions of source code must retain the above copyright notice,
  38  *    this list of conditions and the following disclaimer.
  39  *
  40  *  * Redistributions in binary form must reproduce the above copyright notice,
  41  *    this list of conditions and the following disclaimer in the documentation
  42  *    and/or other materials provided with the distribution.
  43  *
  44  *  * Neither the name of JSR-310 nor the names of its contributors
  45  *    may be used to endorse or promote products derived from this software
  46  *    without specific prior written permission.
  47  *
  48  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  49  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  50  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  51  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  52  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  53  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  54  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  55  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  56  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  57  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  58  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  59  */
  60 package tck.java.time;
  61 
  62 import static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH;
  63 import static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR;
  64 import static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_MONTH;
  65 import static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_YEAR;
  66 import static java.time.temporal.ChronoField.AMPM_OF_DAY;
  67 import static java.time.temporal.ChronoField.CLOCK_HOUR_OF_AMPM;
  68 import static java.time.temporal.ChronoField.CLOCK_HOUR_OF_DAY;
  69 import static java.time.temporal.ChronoField.DAY_OF_MONTH;
  70 import static java.time.temporal.ChronoField.DAY_OF_WEEK;
  71 import static java.time.temporal.ChronoField.DAY_OF_YEAR;
  72 import static java.time.temporal.ChronoField.EPOCH_DAY;
  73 import static java.time.temporal.ChronoField.ERA;
  74 import static java.time.temporal.ChronoField.HOUR_OF_AMPM;
  75 import static java.time.temporal.ChronoField.HOUR_OF_DAY;
  76 import static java.time.temporal.ChronoField.MICRO_OF_DAY;
  77 import static java.time.temporal.ChronoField.MICRO_OF_SECOND;
  78 import static java.time.temporal.ChronoField.MILLI_OF_DAY;
  79 import static java.time.temporal.ChronoField.MILLI_OF_SECOND;
  80 import static java.time.temporal.ChronoField.MINUTE_OF_DAY;
  81 import static java.time.temporal.ChronoField.MINUTE_OF_HOUR;
  82 import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
  83 import static java.time.temporal.ChronoField.NANO_OF_DAY;
  84 import static java.time.temporal.ChronoField.NANO_OF_SECOND;
  85 import static java.time.temporal.ChronoField.PROLEPTIC_MONTH;
  86 import static java.time.temporal.ChronoField.SECOND_OF_DAY;
  87 import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;
  88 import static java.time.temporal.ChronoField.YEAR;
  89 import static java.time.temporal.ChronoField.YEAR_OF_ERA;
  90 import static java.time.temporal.ChronoUnit.CENTURIES;
  91 import static java.time.temporal.ChronoUnit.DAYS;
  92 import static java.time.temporal.ChronoUnit.DECADES;
  93 import static java.time.temporal.ChronoUnit.HALF_DAYS;
  94 import static java.time.temporal.ChronoUnit.HOURS;
  95 import static java.time.temporal.ChronoUnit.MICROS;
  96 import static java.time.temporal.ChronoUnit.MILLENNIA;
  97 import static java.time.temporal.ChronoUnit.MILLIS;
  98 import static java.time.temporal.ChronoUnit.MINUTES;
  99 import static java.time.temporal.ChronoUnit.MONTHS;
 100 import static java.time.temporal.ChronoUnit.NANOS;
 101 import static java.time.temporal.ChronoUnit.SECONDS;
 102 import static java.time.temporal.ChronoUnit.WEEKS;
 103 import static java.time.temporal.ChronoUnit.YEARS;
 104 import static org.testng.Assert.assertEquals;
 105 import static org.testng.Assert.assertFalse;
 106 import static org.testng.Assert.assertSame;
 107 import static org.testng.Assert.assertTrue;
 108 import static org.testng.Assert.fail;
 109 
 110 import java.time.Clock;
 111 import java.time.DateTimeException;
 112 import java.time.DayOfWeek;
 113 import java.time.Instant;
 114 import java.time.LocalDate;
 115 import java.time.LocalDateTime;
 116 import java.time.LocalTime;
 117 import java.time.Month;
 118 import java.time.OffsetDateTime;
 119 import java.time.OffsetTime;
 120 import java.time.Year;
 121 import java.time.ZoneId;
 122 import java.time.ZoneOffset;
 123 import java.time.ZonedDateTime;
 124 import java.time.chrono.IsoChronology;
 125 import java.time.format.DateTimeFormatter;
 126 import java.time.format.DateTimeParseException;
 127 import java.time.temporal.ChronoField;
 128 import java.time.temporal.ChronoUnit;
 129 import java.time.temporal.JulianFields;
 130 import java.time.temporal.Temporal;
 131 import java.time.temporal.TemporalAccessor;
 132 import java.time.temporal.TemporalAdjuster;
 133 import java.time.temporal.TemporalAmount;
 134 import java.time.temporal.TemporalField;
 135 import java.time.temporal.TemporalQueries;
 136 import java.time.temporal.TemporalQuery;
 137 import java.time.temporal.TemporalUnit;
 138 import java.util.ArrayList;
 139 import java.util.Arrays;
 140 import java.util.Iterator;
 141 import java.util.List;
 142 
 143 import org.testng.annotations.BeforeMethod;
 144 import org.testng.annotations.DataProvider;
 145 import org.testng.annotations.Test;
 146 
 147 /**
 148  * Test LocalDateTime.
 149  */
 150 @Test
 151 public class TCKLocalDateTime extends AbstractDateTimeTest {
 152 
 153     private static final ZoneOffset OFFSET_PONE = ZoneOffset.ofHours(1);
 154     private static final ZoneOffset OFFSET_PTWO = ZoneOffset.ofHours(2);
 155     private static final ZoneOffset OFFSET_MTWO = ZoneOffset.ofHours(-2);
 156     private static final ZoneId ZONE_PARIS = ZoneId.of(&quot;Europe/Paris&quot;);
 157     private static final ZoneId ZONE_GAZA = ZoneId.of(&quot;Asia/Gaza&quot;);
 158 
 159     private LocalDateTime TEST_2007_07_15_12_30_40_987654321 = LocalDateTime.of(2007, 7, 15, 12, 30, 40, 987654321);
 160     private LocalDateTime MAX_DATE_TIME;
 161     private LocalDateTime MIN_DATE_TIME;
 162     private Instant MAX_INSTANT;
 163     private Instant MIN_INSTANT;
 164 
 165     @BeforeMethod
 166     public void setUp() {
 167         MAX_DATE_TIME = LocalDateTime.MAX;
 168         MIN_DATE_TIME = LocalDateTime.MIN;
 169         MAX_INSTANT = MAX_DATE_TIME.atZone(ZoneOffset.UTC).toInstant();
 170         MIN_INSTANT = MIN_DATE_TIME.atZone(ZoneOffset.UTC).toInstant();
 171     }
 172 
 173     //-----------------------------------------------------------------------
 174     @Override
 175     protected List&lt;TemporalAccessor&gt; samples() {
 176         TemporalAccessor[] array = {TEST_2007_07_15_12_30_40_987654321, LocalDateTime.MAX, LocalDateTime.MIN, };
 177         return Arrays.asList(array);
 178     }
 179 
 180     @Override
 181     protected List&lt;TemporalField&gt; validFields() {
 182         TemporalField[] array = {
 183             NANO_OF_SECOND,
 184             NANO_OF_DAY,
 185             MICRO_OF_SECOND,
 186             MICRO_OF_DAY,
 187             MILLI_OF_SECOND,
 188             MILLI_OF_DAY,
 189             SECOND_OF_MINUTE,
 190             SECOND_OF_DAY,
 191             MINUTE_OF_HOUR,
 192             MINUTE_OF_DAY,
 193             CLOCK_HOUR_OF_AMPM,
 194             HOUR_OF_AMPM,
 195             CLOCK_HOUR_OF_DAY,
 196             HOUR_OF_DAY,
 197             AMPM_OF_DAY,
 198             DAY_OF_WEEK,
 199             ALIGNED_DAY_OF_WEEK_IN_MONTH,
 200             ALIGNED_DAY_OF_WEEK_IN_YEAR,
 201             DAY_OF_MONTH,
 202             DAY_OF_YEAR,
 203             EPOCH_DAY,
 204             ALIGNED_WEEK_OF_MONTH,
 205             ALIGNED_WEEK_OF_YEAR,
 206             MONTH_OF_YEAR,
 207             PROLEPTIC_MONTH,
 208             YEAR_OF_ERA,
 209             YEAR,
 210             ERA,
 211             JulianFields.JULIAN_DAY,
 212             JulianFields.MODIFIED_JULIAN_DAY,
 213             JulianFields.RATA_DIE,
 214         };
 215         return Arrays.asList(array);
 216     }
 217 
 218     @Override
 219     protected List&lt;TemporalField&gt; invalidFields() {
 220         List&lt;TemporalField&gt; list = new ArrayList&lt;&gt;(Arrays.&lt;TemporalField&gt;asList(ChronoField.values()));
 221         list.removeAll(validFields());
 222         return list;
 223     }
 224 
 225     //-----------------------------------------------------------------------
 226     private void check(LocalDateTime test, int y, int m, int d, int h, int mi, int s, int n) {
 227         assertEquals(test.getYear(), y);
 228         assertEquals(test.getMonth().getValue(), m);
 229         assertEquals(test.getDayOfMonth(), d);
 230         assertEquals(test.getHour(), h);
 231         assertEquals(test.getMinute(), mi);
 232         assertEquals(test.getSecond(), s);
 233         assertEquals(test.getNano(), n);
 234         assertEquals(test, test);
 235         assertEquals(test.hashCode(), test.hashCode());
 236         assertEquals(LocalDateTime.of(y, m, d, h, mi, s, n), test);
 237     }
 238 
 239     private LocalDateTime createDateMidnight(int year, int month, int day) {
 240         return LocalDateTime.of(year, month, day, 0, 0);
 241     }
 242 
 243     //-----------------------------------------------------------------------
 244     // constants
 245     //-----------------------------------------------------------------------
 246     @Test
 247     public void constant_MIN() {
 248         check(LocalDateTime.MIN, Year.MIN_VALUE, 1, 1, 0, 0, 0, 0);
 249     }
 250 
 251     @Test
 252     public void constant_MAX() {
 253         check(LocalDateTime.MAX, Year.MAX_VALUE, 12, 31, 23, 59, 59, 999999999);
 254     }
 255 
 256     //-----------------------------------------------------------------------
 257     // now()
 258     //-----------------------------------------------------------------------
 259     @Test(timeOut=30000)  // TODO: remove when time zone loading is faster
 260     public void now() {
 261         final long DELTA = 20_000_000_000L;    // 20 seconds of nanos leeway
 262         LocalDateTime expected = LocalDateTime.now(Clock.systemDefaultZone());
 263         LocalDateTime test = LocalDateTime.now();
 264         long diff = Math.abs(test.toLocalTime().toNanoOfDay() - expected.toLocalTime().toNanoOfDay());
 265         if (diff &gt;= DELTA) {
 266             // may be date change
 267             expected = LocalDateTime.now(Clock.systemDefaultZone());
 268             test = LocalDateTime.now();
 269             diff = Math.abs(test.toLocalTime().toNanoOfDay() - expected.toLocalTime().toNanoOfDay());
 270         }
 271         assertTrue(diff &lt; DELTA);
 272     }
 273 
 274     //-----------------------------------------------------------------------
 275     // now(ZoneId)
 276     //-----------------------------------------------------------------------
 277     @Test(expectedExceptions=NullPointerException.class)
 278     public void now_ZoneId_nullZoneId() {
 279         LocalDateTime.now((ZoneId) null);
 280     }
 281 
 282     @Test
 283     public void now_ZoneId() {
 284         ZoneId zone = ZoneId.of(&quot;UTC+01:02:03&quot;);
 285         LocalDateTime expected = LocalDateTime.now(Clock.system(zone));
 286         LocalDateTime test = LocalDateTime.now(zone);
 287         for (int i = 0; i &lt; 100; i++) {
 288             if (expected.equals(test)) {
 289                 return;
 290             }
 291             expected = LocalDateTime.now(Clock.system(zone));
 292             test = LocalDateTime.now(zone);
 293         }
 294         assertEquals(test.truncatedTo(ChronoUnit.SECONDS),
 295                      expected.truncatedTo(ChronoUnit.SECONDS));
 296     }
 297 
 298     //-----------------------------------------------------------------------
 299     // now(Clock)
 300     //-----------------------------------------------------------------------
 301     @Test(expectedExceptions=NullPointerException.class)
 302     public void now_Clock_nullClock() {
 303         LocalDateTime.now((Clock) null);
 304     }
 305 
 306     @Test
 307     public void now_Clock_allSecsInDay_utc() {
 308         for (int i = 0; i &lt; (2 * 24 * 60 * 60); i++) {
 309             Instant instant = Instant.ofEpochSecond(i).plusNanos(123456789L);
 310             Clock clock = Clock.fixed(instant, ZoneOffset.UTC);
 311             LocalDateTime test = LocalDateTime.now(clock);
 312             assertEquals(test.getYear(), 1970);
 313             assertEquals(test.getMonth(), Month.JANUARY);
 314             assertEquals(test.getDayOfMonth(), (i &lt; 24 * 60 * 60 ? 1 : 2));
 315             assertEquals(test.getHour(), (i / (60 * 60)) % 24);
 316             assertEquals(test.getMinute(), (i / 60) % 60);
 317             assertEquals(test.getSecond(), i % 60);
 318             assertEquals(test.getNano(), 123456789);
 319         }
 320     }
 321 
 322     @Test
 323     public void now_Clock_allSecsInDay_offset() {
 324         for (int i = 0; i &lt; (2 * 24 * 60 * 60); i++) {
 325             Instant instant = Instant.ofEpochSecond(i).plusNanos(123456789L);
 326             Clock clock = Clock.fixed(instant.minusSeconds(OFFSET_PONE.getTotalSeconds()), OFFSET_PONE);
 327             LocalDateTime test = LocalDateTime.now(clock);
 328             assertEquals(test.getYear(), 1970);
 329             assertEquals(test.getMonth(), Month.JANUARY);
 330             assertEquals(test.getDayOfMonth(), (i &lt; 24 * 60 * 60) ? 1 : 2);
 331             assertEquals(test.getHour(), (i / (60 * 60)) % 24);
 332             assertEquals(test.getMinute(), (i / 60) % 60);
 333             assertEquals(test.getSecond(), i % 60);
 334             assertEquals(test.getNano(), 123456789);
 335         }
 336     }
 337 
 338     @Test
 339     public void now_Clock_allSecsInDay_beforeEpoch() {
 340         LocalTime expected = LocalTime.MIDNIGHT.plusNanos(123456789L);
 341         for (int i =-1; i &gt;= -(24 * 60 * 60); i--) {
 342             Instant instant = Instant.ofEpochSecond(i).plusNanos(123456789L);
 343             Clock clock = Clock.fixed(instant, ZoneOffset.UTC);
 344             LocalDateTime test = LocalDateTime.now(clock);
 345             assertEquals(test.getYear(), 1969);
 346             assertEquals(test.getMonth(), Month.DECEMBER);
 347             assertEquals(test.getDayOfMonth(), 31);
 348             expected = expected.minusSeconds(1);
 349             assertEquals(test.toLocalTime(), expected);
 350         }
 351     }
 352 
 353     //-----------------------------------------------------------------------
 354     @Test
 355     public void now_Clock_maxYear() {
 356         Clock clock = Clock.fixed(MAX_INSTANT, ZoneOffset.UTC);
 357         LocalDateTime test = LocalDateTime.now(clock);
 358         assertEquals(test, MAX_DATE_TIME);
 359     }
 360 
 361     @Test(expectedExceptions=DateTimeException.class)
 362     public void now_Clock_tooBig() {
 363         Clock clock = Clock.fixed(MAX_INSTANT.plusSeconds(24 * 60 * 60), ZoneOffset.UTC);
 364         LocalDateTime.now(clock);
 365     }
 366 
 367     @Test
 368     public void now_Clock_minYear() {
 369         Clock clock = Clock.fixed(MIN_INSTANT, ZoneOffset.UTC);
 370         LocalDateTime test = LocalDateTime.now(clock);
 371         assertEquals(test, MIN_DATE_TIME);
 372     }
 373 
 374     @Test(expectedExceptions=DateTimeException.class)
 375     public void now_Clock_tooLow() {
 376         Clock clock = Clock.fixed(MIN_INSTANT.minusNanos(1), ZoneOffset.UTC);
 377         LocalDateTime.now(clock);
 378     }
 379 
 380     //-----------------------------------------------------------------------
 381     // of() factories
 382     //-----------------------------------------------------------------------
 383     //-----------------------------------------------------------------------
 384     @Test
 385     public void factory_of_4intsMonth() {
 386         LocalDateTime dateTime = LocalDateTime.of(2007, Month.JULY, 15, 12, 30);
 387         check(dateTime, 2007, 7, 15, 12, 30, 0, 0);
 388     }
 389 
 390     @Test(expectedExceptions=DateTimeException.class)
 391     public void factory_of_4intsMonth_yearTooLow() {
 392         LocalDateTime.of(Integer.MIN_VALUE, Month.JULY, 15, 12, 30);
 393     }
 394 
 395     @Test(expectedExceptions=NullPointerException.class)
 396     public void factory_of_4intsMonth_nullMonth() {
 397         LocalDateTime.of(2007, null, 15, 12, 30);
 398     }
 399 
 400     @Test(expectedExceptions=DateTimeException.class)
 401     public void factory_of_4intsMonth_dayTooLow() {
 402         LocalDateTime.of(2007, Month.JULY, -1, 12, 30);
 403     }
 404 
 405     @Test(expectedExceptions=DateTimeException.class)
 406     public void factory_of_4intsMonth_dayTooHigh() {
 407         LocalDateTime.of(2007, Month.JULY, 32, 12, 30);
 408     }
 409 
 410     @Test(expectedExceptions=DateTimeException.class)
 411     public void factory_of_4intsMonth_hourTooLow() {
 412         LocalDateTime.of(2007, Month.JULY, 15, -1, 30);
 413     }
 414 
 415     @Test(expectedExceptions=DateTimeException.class)
 416     public void factory_of_4intsMonth_hourTooHigh() {
 417         LocalDateTime.of(2007, Month.JULY, 15, 24, 30);
 418     }
 419 
 420     @Test(expectedExceptions=DateTimeException.class)
 421     public void factory_of_4intsMonth_minuteTooLow() {
 422         LocalDateTime.of(2007, Month.JULY, 15, 12, -1);
 423     }
 424 
 425     @Test(expectedExceptions=DateTimeException.class)
 426     public void factory_of_4intsMonth_minuteTooHigh() {
 427         LocalDateTime.of(2007, Month.JULY, 15, 12, 60);
 428     }
 429 
 430     //-----------------------------------------------------------------------
 431     @Test
 432     public void factory_of_5intsMonth() {
 433         LocalDateTime dateTime = LocalDateTime.of(2007, Month.JULY, 15, 12, 30, 40);
 434         check(dateTime, 2007, 7, 15, 12, 30, 40, 0);
 435     }
 436 
 437     @Test(expectedExceptions=DateTimeException.class)
 438     public void factory_of_5intsMonth_yearTooLow() {
 439         LocalDateTime.of(Integer.MIN_VALUE, Month.JULY, 15, 12, 30, 40);
 440     }
 441 
 442     @Test(expectedExceptions=NullPointerException.class)
 443     public void factory_of_5intsMonth_nullMonth() {
 444         LocalDateTime.of(2007, null, 15, 12, 30, 40);
 445     }
 446 
 447     @Test(expectedExceptions=DateTimeException.class)
 448     public void factory_of_5intsMonth_dayTooLow() {
 449         LocalDateTime.of(2007, Month.JULY, -1, 12, 30, 40);
 450     }
 451 
 452     @Test(expectedExceptions=DateTimeException.class)
 453     public void factory_of_5intsMonth_dayTooHigh() {
 454         LocalDateTime.of(2007, Month.JULY, 32, 12, 30, 40);
 455     }
 456 
 457     @Test(expectedExceptions=DateTimeException.class)
 458     public void factory_of_5intsMonth_hourTooLow() {
 459         LocalDateTime.of(2007, Month.JULY, 15, -1, 30, 40);
 460     }
 461 
 462     @Test(expectedExceptions=DateTimeException.class)
 463     public void factory_of_5intsMonth_hourTooHigh() {
 464         LocalDateTime.of(2007, Month.JULY, 15, 24, 30, 40);
 465     }
 466 
 467     @Test(expectedExceptions=DateTimeException.class)
 468     public void factory_of_5intsMonth_minuteTooLow() {
 469         LocalDateTime.of(2007, Month.JULY, 15, 12, -1, 40);
 470     }
 471 
 472     @Test(expectedExceptions=DateTimeException.class)
 473     public void factory_of_5intsMonth_minuteTooHigh() {
 474         LocalDateTime.of(2007, Month.JULY, 15, 12, 60, 40);
 475     }
 476 
 477     @Test(expectedExceptions=DateTimeException.class)
 478     public void factory_of_5intsMonth_secondTooLow() {
 479         LocalDateTime.of(2007, Month.JULY, 15, 12, 30, -1);
 480     }
 481 
 482     @Test(expectedExceptions=DateTimeException.class)
 483     public void factory_of_5intsMonth_secondTooHigh() {
 484         LocalDateTime.of(2007, Month.JULY, 15, 12, 30, 60);
 485     }
 486 
 487     //-----------------------------------------------------------------------
 488     @Test
 489     public void factory_of_6intsMonth() {
 490         LocalDateTime dateTime = LocalDateTime.of(2007, Month.JULY, 15, 12, 30, 40, 987654321);
 491         check(dateTime, 2007, 7, 15, 12, 30, 40, 987654321);
 492     }
 493 
 494     @Test(expectedExceptions=DateTimeException.class)
 495     public void factory_of_6intsMonth_yearTooLow() {
 496         LocalDateTime.of(Integer.MIN_VALUE, Month.JULY, 15, 12, 30, 40, 987654321);
 497     }
 498 
 499     @Test(expectedExceptions=NullPointerException.class)
 500     public void factory_of_6intsMonth_nullMonth() {
 501         LocalDateTime.of(2007, null, 15, 12, 30, 40, 987654321);
 502     }
 503 
 504     @Test(expectedExceptions=DateTimeException.class)
 505     public void factory_of_6intsMonth_dayTooLow() {
 506         LocalDateTime.of(2007, Month.JULY, -1, 12, 30, 40, 987654321);
 507     }
 508 
 509     @Test(expectedExceptions=DateTimeException.class)
 510     public void factory_of_6intsMonth_dayTooHigh() {
 511         LocalDateTime.of(2007, Month.JULY, 32, 12, 30, 40, 987654321);
 512     }
 513 
 514     @Test(expectedExceptions=DateTimeException.class)
 515     public void factory_of_6intsMonth_hourTooLow() {
 516         LocalDateTime.of(2007, Month.JULY, 15, -1, 30, 40, 987654321);
 517     }
 518 
 519     @Test(expectedExceptions=DateTimeException.class)
 520     public void factory_of_6intsMonth_hourTooHigh() {
 521         LocalDateTime.of(2007, Month.JULY, 15, 24, 30, 40, 987654321);
 522     }
 523 
 524     @Test(expectedExceptions=DateTimeException.class)
 525     public void factory_of_6intsMonth_minuteTooLow() {
 526         LocalDateTime.of(2007, Month.JULY, 15, 12, -1, 40, 987654321);
 527     }
 528 
 529     @Test(expectedExceptions=DateTimeException.class)
 530     public void factory_of_6intsMonth_minuteTooHigh() {
 531         LocalDateTime.of(2007, Month.JULY, 15, 12, 60, 40, 987654321);
 532     }
 533 
 534     @Test(expectedExceptions=DateTimeException.class)
 535     public void factory_of_6intsMonth_secondTooLow() {
 536         LocalDateTime.of(2007, Month.JULY, 15, 12, 30, -1, 987654321);
 537     }
 538 
 539     @Test(expectedExceptions=DateTimeException.class)
 540     public void factory_of_6intsMonth_secondTooHigh() {
 541         LocalDateTime.of(2007, Month.JULY, 15, 12, 30, 60, 987654321);
 542     }
 543 
 544     @Test(expectedExceptions=DateTimeException.class)
 545     public void factory_of_6intsMonth_nanoTooLow() {
 546         LocalDateTime.of(2007, Month.JULY, 15, 12, 30, 40, -1);
 547     }
 548 
 549     @Test(expectedExceptions=DateTimeException.class)
 550     public void factory_of_6intsMonth_nanoTooHigh() {
 551         LocalDateTime.of(2007, Month.JULY, 15, 12, 30, 40, 1000000000);
 552     }
 553 
 554     //-----------------------------------------------------------------------
 555     @Test
 556     public void factory_of_5ints() {
 557         LocalDateTime dateTime = LocalDateTime.of(2007, 7, 15, 12, 30);
 558         check(dateTime, 2007, 7, 15, 12, 30, 0, 0);
 559     }
 560 
 561     @Test(expectedExceptions=DateTimeException.class)
 562     public void factory_of_5ints_yearTooLow() {
 563         LocalDateTime.of(Integer.MIN_VALUE, 7, 15, 12, 30);
 564     }
 565 
 566     @Test(expectedExceptions=DateTimeException.class)
 567     public void factory_of_5ints_monthTooLow() {
 568         LocalDateTime.of(2007, 0, 15, 12, 30);
 569     }
 570 
 571     @Test(expectedExceptions=DateTimeException.class)
 572     public void factory_of_5ints_monthTooHigh() {
 573         LocalDateTime.of(2007, 13, 15, 12, 30);
 574     }
 575 
 576     @Test(expectedExceptions=DateTimeException.class)
 577     public void factory_of_5ints_dayTooLow() {
 578         LocalDateTime.of(2007, 7, -1, 12, 30);
 579     }
 580 
 581     @Test(expectedExceptions=DateTimeException.class)
 582     public void factory_of_5ints_dayTooHigh() {
 583         LocalDateTime.of(2007, 7, 32, 12, 30);
 584     }
 585 
 586     @Test(expectedExceptions=DateTimeException.class)
 587     public void factory_of_5ints_hourTooLow() {
 588         LocalDateTime.of(2007, 7, 15, -1, 30);
 589     }
 590 
 591     @Test(expectedExceptions=DateTimeException.class)
 592     public void factory_of_5ints_hourTooHigh() {
 593         LocalDateTime.of(2007, 7, 15, 24, 30);
 594     }
 595 
 596     @Test(expectedExceptions=DateTimeException.class)
 597     public void factory_of_5ints_minuteTooLow() {
 598         LocalDateTime.of(2007, 7, 15, 12, -1);
 599     }
 600 
 601     @Test(expectedExceptions=DateTimeException.class)
 602     public void factory_of_5ints_minuteTooHigh() {
 603         LocalDateTime.of(2007, 7, 15, 12, 60);
 604     }
 605 
 606     //-----------------------------------------------------------------------
 607     @Test
 608     public void factory_of_6ints() {
 609         LocalDateTime dateTime = LocalDateTime.of(2007, 7, 15, 12, 30, 40);
 610         check(dateTime, 2007, 7, 15, 12, 30, 40, 0);
 611     }
 612 
 613     @Test(expectedExceptions=DateTimeException.class)
 614     public void factory_of_6ints_yearTooLow() {
 615         LocalDateTime.of(Integer.MIN_VALUE, 7, 15, 12, 30, 40);
 616     }
 617 
 618     @Test(expectedExceptions=DateTimeException.class)
 619     public void factory_of_6ints_monthTooLow() {
 620         LocalDateTime.of(2007, 0, 15, 12, 30, 40);
 621     }
 622 
 623     @Test(expectedExceptions=DateTimeException.class)
 624     public void factory_of_6ints_monthTooHigh() {
 625         LocalDateTime.of(2007, 13, 15, 12, 30, 40);
 626     }
 627 
 628     @Test(expectedExceptions=DateTimeException.class)
 629     public void factory_of_6ints_dayTooLow() {
 630         LocalDateTime.of(2007, 7, -1, 12, 30, 40);
 631     }
 632 
 633     @Test(expectedExceptions=DateTimeException.class)
 634     public void factory_of_6ints_dayTooHigh() {
 635         LocalDateTime.of(2007, 7, 32, 12, 30, 40);
 636     }
 637 
 638     @Test(expectedExceptions=DateTimeException.class)
 639     public void factory_of_6ints_hourTooLow() {
 640         LocalDateTime.of(2007, 7, 15, -1, 30, 40);
 641     }
 642 
 643     @Test(expectedExceptions=DateTimeException.class)
 644     public void factory_of_6ints_hourTooHigh() {
 645         LocalDateTime.of(2007, 7, 15, 24, 30, 40);
 646     }
 647 
 648     @Test(expectedExceptions=DateTimeException.class)
 649     public void factory_of_6ints_minuteTooLow() {
 650         LocalDateTime.of(2007, 7, 15, 12, -1, 40);
 651     }
 652 
 653     @Test(expectedExceptions=DateTimeException.class)
 654     public void factory_of_6ints_minuteTooHigh() {
 655         LocalDateTime.of(2007, 7, 15, 12, 60, 40);
 656     }
 657 
 658     @Test(expectedExceptions=DateTimeException.class)
 659     public void factory_of_6ints_secondTooLow() {
 660         LocalDateTime.of(2007, 7, 15, 12, 30, -1);
 661     }
 662 
 663     @Test(expectedExceptions=DateTimeException.class)
 664     public void factory_of_6ints_secondTooHigh() {
 665         LocalDateTime.of(2007, 7, 15, 12, 30, 60);
 666     }
 667 
 668     //-----------------------------------------------------------------------
 669     @Test
 670     public void factory_of_7ints() {
 671         LocalDateTime dateTime = LocalDateTime.of(2007, 7, 15, 12, 30, 40, 987654321);
 672         check(dateTime, 2007, 7, 15, 12, 30, 40, 987654321);
 673     }
 674 
 675     @Test(expectedExceptions=DateTimeException.class)
 676     public void factory_of_7ints_yearTooLow() {
 677         LocalDateTime.of(Integer.MIN_VALUE, 7, 15, 12, 30, 40, 987654321);
 678     }
 679 
 680     @Test(expectedExceptions=DateTimeException.class)
 681     public void factory_of_7ints_monthTooLow() {
 682         LocalDateTime.of(2007, 0, 15, 12, 30, 40, 987654321);
 683     }
 684 
 685     @Test(expectedExceptions=DateTimeException.class)
 686     public void factory_of_7ints_monthTooHigh() {
 687         LocalDateTime.of(2007, 13, 15, 12, 30, 40, 987654321);
 688     }
 689 
 690     @Test(expectedExceptions=DateTimeException.class)
 691     public void factory_of_7ints_dayTooLow() {
 692         LocalDateTime.of(2007, 7, -1, 12, 30, 40, 987654321);
 693     }
 694 
 695     @Test(expectedExceptions=DateTimeException.class)
 696     public void factory_of_7ints_dayTooHigh() {
 697         LocalDateTime.of(2007, 7, 32, 12, 30, 40, 987654321);
 698     }
 699 
 700     @Test(expectedExceptions=DateTimeException.class)
 701     public void factory_of_7ints_hourTooLow() {
 702         LocalDateTime.of(2007, 7, 15, -1, 30, 40, 987654321);
 703     }
 704 
 705     @Test(expectedExceptions=DateTimeException.class)
 706     public void factory_of_7ints_hourTooHigh() {
 707         LocalDateTime.of(2007, 7, 15, 24, 30, 40, 987654321);
 708     }
 709 
 710     @Test(expectedExceptions=DateTimeException.class)
 711     public void factory_of_7ints_minuteTooLow() {
 712         LocalDateTime.of(2007, 7, 15, 12, -1, 40, 987654321);
 713     }
 714 
 715     @Test(expectedExceptions=DateTimeException.class)
 716     public void factory_of_7ints_minuteTooHigh() {
 717         LocalDateTime.of(2007, 7, 15, 12, 60, 40, 987654321);
 718     }
 719 
 720     @Test(expectedExceptions=DateTimeException.class)
 721     public void factory_of_7ints_secondTooLow() {
 722         LocalDateTime.of(2007, 7, 15, 12, 30, -1, 987654321);
 723     }
 724 
 725     @Test(expectedExceptions=DateTimeException.class)
 726     public void factory_of_7ints_secondTooHigh() {
 727         LocalDateTime.of(2007, 7, 15, 12, 30, 60, 987654321);
 728     }
 729 
 730     @Test(expectedExceptions=DateTimeException.class)
 731     public void factory_of_7ints_nanoTooLow() {
 732         LocalDateTime.of(2007, 7, 15, 12, 30, 40, -1);
 733     }
 734 
 735     @Test(expectedExceptions=DateTimeException.class)
 736     public void factory_of_7ints_nanoTooHigh() {
 737         LocalDateTime.of(2007, 7, 15, 12, 30, 40, 1000000000);
 738     }
 739 
 740     //-----------------------------------------------------------------------
 741     @Test
 742     public void factory_of_LocalDate_LocalTime() {
 743         LocalDateTime dateTime = LocalDateTime.of(LocalDate.of(2007, 7, 15), LocalTime.of(12, 30, 40, 987654321));
 744         check(dateTime, 2007, 7, 15, 12, 30, 40, 987654321);
 745     }
 746 
 747     @Test(expectedExceptions=NullPointerException.class)
 748     public void factory_of_LocalDate_LocalTime_nullLocalDate() {
 749         LocalDateTime.of(null, LocalTime.of(12, 30, 40, 987654321));
 750     }
 751 
 752     @Test(expectedExceptions=NullPointerException.class)
 753     public void factory_of_LocalDate_LocalTime_nullLocalTime() {
 754         LocalDateTime.of(LocalDate.of(2007, 7, 15), null);
 755     }
 756 
 757     //-----------------------------------------------------------------------
 758     // ofInstant()
 759     //-----------------------------------------------------------------------
 760     @DataProvider(name=&quot;instantFactory&quot;)
 761     Object[][] data_instantFactory() {
 762         return new Object[][] {
 763                 {Instant.ofEpochSecond(86400 + 3600 + 120 + 4, 500), ZONE_PARIS, LocalDateTime.of(1970, 1, 2, 2, 2, 4, 500)},
 764                 {Instant.ofEpochSecond(86400 + 3600 + 120 + 4, 500), OFFSET_MTWO, LocalDateTime.of(1970, 1, 1, 23, 2, 4, 500)},
 765                 {Instant.ofEpochSecond(-86400 + 4, 500), OFFSET_PTWO, LocalDateTime.of(1969, 12, 31, 2, 0, 4, 500)},
 766                 {OffsetDateTime.of(LocalDateTime.of(Year.MIN_VALUE, 1, 1, 0, 0), ZoneOffset.UTC).toInstant(),
 767                         ZoneOffset.UTC, LocalDateTime.MIN},
 768                 {OffsetDateTime.of(LocalDateTime.of(Year.MAX_VALUE, 12, 31, 23, 59, 59, 999_999_999), ZoneOffset.UTC).toInstant(),
 769                         ZoneOffset.UTC, LocalDateTime.MAX},
 770         };
 771     }
 772 
 773     @Test(dataProvider=&quot;instantFactory&quot;)
 774     public void factory_ofInstant(Instant instant, ZoneId zone, LocalDateTime expected) {
 775         LocalDateTime test = LocalDateTime.ofInstant(instant, zone);
 776         assertEquals(test, expected);
 777     }
 778 
 779     @Test(expectedExceptions=DateTimeException.class)
 780     public void factory_ofInstant_instantTooBig() {
 781         LocalDateTime.ofInstant(Instant.MAX, OFFSET_PONE) ;
 782     }
 783 
 784     @Test(expectedExceptions=DateTimeException.class)
 785     public void factory_ofInstant_instantTooSmall() {
 786         LocalDateTime.ofInstant(Instant.MIN, OFFSET_PONE) ;
 787     }
 788 
 789     @Test(expectedExceptions=NullPointerException.class)
 790     public void factory_ofInstant_nullInstant() {
 791         LocalDateTime.ofInstant((Instant) null, ZONE_GAZA);
 792     }
 793 
 794     @Test(expectedExceptions=NullPointerException.class)
 795     public void factory_ofInstant_nullZone() {
 796         LocalDateTime.ofInstant(Instant.EPOCH, (ZoneId) null);
 797     }
 798 
 799     //-----------------------------------------------------------------------
 800     // ofEpochSecond()
 801     //-----------------------------------------------------------------------
 802     @Test
 803     public void factory_ofEpochSecond_longOffset_afterEpoch() {
 804         LocalDateTime base = LocalDateTime.of(1970, 1, 1, 2, 0, 0, 500);
 805         for (int i = 0; i &lt; 100000; i++) {
 806             LocalDateTime test = LocalDateTime.ofEpochSecond(i, 500, OFFSET_PTWO);
 807             assertEquals(test, base.plusSeconds(i));
 808         }
 809     }
 810 
 811     @Test
 812     public void factory_ofEpochSecond_longOffset_beforeEpoch() {
 813         LocalDateTime base = LocalDateTime.of(1970, 1, 1, 2, 0, 0, 500);
 814         for (int i = 0; i &lt; 100000; i++) {
 815             LocalDateTime test = LocalDateTime.ofEpochSecond(-i, 500, OFFSET_PTWO);
 816             assertEquals(test, base.minusSeconds(i));
 817         }
 818     }
 819 
 820     @Test(expectedExceptions=DateTimeException.class)
 821     public void factory_ofEpochSecond_longOffset_tooBig() {
 822         LocalDateTime.ofEpochSecond(Long.MAX_VALUE, 500, OFFSET_PONE);  // TODO: better test
 823     }
 824 
 825     @Test(expectedExceptions=DateTimeException.class)
 826     public void factory_ofEpochSecond_longOffset_tooSmall() {
 827         LocalDateTime.ofEpochSecond(Long.MIN_VALUE, 500, OFFSET_PONE);  // TODO: better test
 828     }
 829 
 830     @Test(expectedExceptions=DateTimeException.class)
 831     public void factory_ofEpochSecond_badNanos_toBig() {
 832         LocalDateTime.ofEpochSecond(0, 1_000_000_000, OFFSET_PONE);
 833     }
 834 
 835     @Test(expectedExceptions=DateTimeException.class)
 836     public void factory_ofEpochSecond_badNanos_toSmall() {
 837         LocalDateTime.ofEpochSecond(0, -1, OFFSET_PONE);
 838     }
 839 
 840     @Test(expectedExceptions=NullPointerException.class)
 841     public void factory_ofEpochSecond_longOffset_nullOffset() {
 842         LocalDateTime.ofEpochSecond(0L, 500, null);
 843     }
 844 
 845     //-----------------------------------------------------------------------
 846     // from()
 847     //-----------------------------------------------------------------------
 848     @Test
 849     public void test_from_TemporalAccessor() {
 850         LocalDateTime base = LocalDateTime.of(2007, 7, 15, 17, 30);
 851         assertEquals(LocalDateTime.from(base), base);
 852         assertEquals(LocalDateTime.from(ZonedDateTime.of(base, ZoneOffset.ofHours(2))), base);
 853     }
 854 
 855     @Test(expectedExceptions=DateTimeException.class)
 856     public void test_from_TemporalAccessor_invalid_noDerive() {
 857         LocalDateTime.from(LocalTime.of(12, 30));
 858     }
 859 
 860     @Test(expectedExceptions=NullPointerException.class)
 861     public void test_from_TemporalAccessor_null() {
 862         LocalDateTime.from((TemporalAccessor) null);
 863     }
 864 
 865     //-----------------------------------------------------------------------
 866     // parse()
 867     //-----------------------------------------------------------------------
 868     @Test(dataProvider=&quot;sampleToString&quot;)
 869     public void test_parse(int y, int month, int d, int h, int m, int s, int n, String text) {
 870         LocalDateTime t = LocalDateTime.parse(text);
 871         assertEquals(t.getYear(), y);
 872         assertEquals(t.getMonth().getValue(), month);
 873         assertEquals(t.getDayOfMonth(), d);
 874         assertEquals(t.getHour(), h);
 875         assertEquals(t.getMinute(), m);
 876         assertEquals(t.getSecond(), s);
 877         assertEquals(t.getNano(), n);
 878     }
 879 
 880     @Test(expectedExceptions=DateTimeParseException.class)
 881     public void factory_parse_illegalValue() {
 882         LocalDateTime.parse(&quot;2008-06-32T11:15&quot;);
 883     }
 884 
 885     @Test(expectedExceptions=DateTimeParseException.class)
 886     public void factory_parse_invalidValue() {
 887         LocalDateTime.parse(&quot;2008-06-31T11:15&quot;);
 888     }
 889 
 890     @Test(expectedExceptions=NullPointerException.class)
 891     public void factory_parse_nullText() {
 892         LocalDateTime.parse((String) null);
 893     }
 894 
 895     //-----------------------------------------------------------------------
 896     // parse(DateTimeFormatter)
 897     //-----------------------------------------------------------------------
 898     @Test
 899     public void factory_parse_formatter() {
 900         DateTimeFormatter f = DateTimeFormatter.ofPattern(&quot;y M d H m s&quot;);
 901         LocalDateTime test = LocalDateTime.parse(&quot;2010 12 3 11 30 45&quot;, f);
 902         assertEquals(test, LocalDateTime.of(2010, 12, 3, 11, 30, 45));
 903     }
 904 
 905     @Test(expectedExceptions=NullPointerException.class)
 906     public void factory_parse_formatter_nullText() {
 907         DateTimeFormatter f = DateTimeFormatter.ofPattern(&quot;y M d H m s&quot;);
 908         LocalDateTime.parse((String) null, f);
 909     }
 910 
 911     @Test(expectedExceptions=NullPointerException.class)
 912     public void factory_parse_formatter_nullFormatter() {
 913         LocalDateTime.parse(&quot;ANY&quot;, null);
 914     }
 915 
 916     //-----------------------------------------------------------------------
 917     // isSupported(TemporalField)
 918     //-----------------------------------------------------------------------
 919     @Test
 920     public void test_isSupported_TemporalField() {
 921         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported((TemporalField) null), false);
 922         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.NANO_OF_SECOND), true);
 923         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.NANO_OF_DAY), true);
 924         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.MICRO_OF_SECOND), true);
 925         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.MICRO_OF_DAY), true);
 926         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.MILLI_OF_SECOND), true);
 927         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.MILLI_OF_DAY), true);
 928         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.SECOND_OF_MINUTE), true);
 929         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.SECOND_OF_DAY), true);
 930         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.MINUTE_OF_HOUR), true);
 931         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.MINUTE_OF_DAY), true);
 932         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.HOUR_OF_AMPM), true);
 933         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.CLOCK_HOUR_OF_AMPM), true);
 934         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.HOUR_OF_DAY), true);
 935         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.CLOCK_HOUR_OF_DAY), true);
 936         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.AMPM_OF_DAY), true);
 937         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.DAY_OF_WEEK), true);
 938         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH), true);
 939         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), true);
 940         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.DAY_OF_MONTH), true);
 941         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.DAY_OF_YEAR), true);
 942         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.EPOCH_DAY), true);
 943         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.ALIGNED_WEEK_OF_MONTH), true);
 944         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.ALIGNED_WEEK_OF_YEAR), true);
 945         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.MONTH_OF_YEAR), true);
 946         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.PROLEPTIC_MONTH), true);
 947         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.YEAR), true);
 948         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.YEAR_OF_ERA), true);
 949         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.ERA), true);
 950         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.INSTANT_SECONDS), false);
 951         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoField.OFFSET_SECONDS), false);
 952     }
 953 
 954     //-----------------------------------------------------------------------
 955     // isSupported(TemporalUnit)
 956     //-----------------------------------------------------------------------
 957     @Test
 958     public void test_isSupported_TemporalUnit() {
 959         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported((TemporalUnit) null), false);
 960         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.NANOS), true);
 961         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.MICROS), true);
 962         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.MILLIS), true);
 963         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.SECONDS), true);
 964         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.MINUTES), true);
 965         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.HOURS), true);
 966         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.HALF_DAYS), true);
 967         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.DAYS), true);
 968         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.WEEKS), true);
 969         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.MONTHS), true);
 970         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.YEARS), true);
 971         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.DECADES), true);
 972         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.CENTURIES), true);
 973         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.MILLENNIA), true);
 974         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.ERAS), true);
 975         assertEquals(TEST_2007_07_15_12_30_40_987654321.isSupported(ChronoUnit.FOREVER), false);
 976     }
 977 
 978     //-----------------------------------------------------------------------
 979     // get(TemporalField)
 980     //-----------------------------------------------------------------------
 981     @Test
 982     public void test_get_TemporalField() {
 983         LocalDateTime test = LocalDateTime.of(2008, 6, 30, 12, 30, 40, 987654321);
 984         assertEquals(test.get(ChronoField.YEAR), 2008);
 985         assertEquals(test.get(ChronoField.MONTH_OF_YEAR), 6);
 986         assertEquals(test.get(ChronoField.DAY_OF_MONTH), 30);
 987         assertEquals(test.get(ChronoField.DAY_OF_WEEK), 1);
 988         assertEquals(test.get(ChronoField.DAY_OF_YEAR), 182);
 989 
 990         assertEquals(test.get(ChronoField.HOUR_OF_DAY), 12);
 991         assertEquals(test.get(ChronoField.MINUTE_OF_HOUR), 30);
 992         assertEquals(test.get(ChronoField.SECOND_OF_MINUTE), 40);
 993         assertEquals(test.get(ChronoField.NANO_OF_SECOND), 987654321);
 994         assertEquals(test.get(ChronoField.HOUR_OF_AMPM), 0);
 995         assertEquals(test.get(ChronoField.AMPM_OF_DAY), 1);
 996     }
 997 
 998     @Test
 999     public void test_getLong_TemporalField() {
1000         LocalDateTime test = LocalDateTime.of(2008, 6, 30, 12, 30, 40, 987654321);
1001         assertEquals(test.getLong(ChronoField.YEAR), 2008);
1002         assertEquals(test.getLong(ChronoField.MONTH_OF_YEAR), 6);
1003         assertEquals(test.getLong(ChronoField.DAY_OF_MONTH), 30);
1004         assertEquals(test.getLong(ChronoField.DAY_OF_WEEK), 1);
1005         assertEquals(test.getLong(ChronoField.DAY_OF_YEAR), 182);
1006 
1007         assertEquals(test.getLong(ChronoField.HOUR_OF_DAY), 12);
1008         assertEquals(test.getLong(ChronoField.MINUTE_OF_HOUR), 30);
1009         assertEquals(test.getLong(ChronoField.SECOND_OF_MINUTE), 40);
1010         assertEquals(test.getLong(ChronoField.NANO_OF_SECOND), 987654321);
1011         assertEquals(test.getLong(ChronoField.HOUR_OF_AMPM), 0);
1012         assertEquals(test.getLong(ChronoField.AMPM_OF_DAY), 1);
1013     }
1014 
1015     //-----------------------------------------------------------------------
1016     // query(TemporalQuery)
1017     //-----------------------------------------------------------------------
1018     @DataProvider(name=&quot;query&quot;)
1019     Object[][] data_query() {
1020         return new Object[][] {
1021                 {TEST_2007_07_15_12_30_40_987654321, TemporalQueries.chronology(), IsoChronology.INSTANCE},
1022                 {TEST_2007_07_15_12_30_40_987654321, TemporalQueries.zoneId(), null},
1023                 {TEST_2007_07_15_12_30_40_987654321, TemporalQueries.precision(), ChronoUnit.NANOS},
1024                 {TEST_2007_07_15_12_30_40_987654321, TemporalQueries.zone(), null},
1025                 {TEST_2007_07_15_12_30_40_987654321, TemporalQueries.offset(), null},
1026                 {TEST_2007_07_15_12_30_40_987654321, TemporalQueries.localDate(), LocalDate.of(2007, 7, 15)},
1027                 {TEST_2007_07_15_12_30_40_987654321, TemporalQueries.localTime(), LocalTime.of(12, 30, 40, 987654321)},
1028         };
1029     }
1030 
1031     @Test(dataProvider=&quot;query&quot;)
1032     public &lt;T&gt; void test_query(TemporalAccessor temporal, TemporalQuery&lt;T&gt; query, T expected) {
1033         assertEquals(temporal.query(query), expected);
1034     }
1035 
1036     @Test(dataProvider=&quot;query&quot;)
1037     public &lt;T&gt; void test_queryFrom(TemporalAccessor temporal, TemporalQuery&lt;T&gt; query, T expected) {
1038         assertEquals(query.queryFrom(temporal), expected);
1039     }
1040 
1041     @Test(expectedExceptions=NullPointerException.class)
1042     public void test_query_null() {
1043         TEST_2007_07_15_12_30_40_987654321.query(null);
1044     }
1045 
1046     //-----------------------------------------------------------------------
1047     @DataProvider(name=&quot;sampleDates&quot;)
1048     Object[][] provider_sampleDates() {
1049         return new Object[][] {
1050             {2008, 7, 5},
1051             {2007, 7, 5},
1052             {2006, 7, 5},
1053             {2005, 7, 5},
1054             {2004, 1, 1},
1055             {-1, 1, 2},
1056         };
1057     }
1058 
1059     @DataProvider(name=&quot;sampleTimes&quot;)
1060     Object[][] provider_sampleTimes() {
1061         return new Object[][] {
1062             {0, 0, 0, 0},
1063             {0, 0, 0, 1},
1064             {0, 0, 1, 0},
1065             {0, 0, 1, 1},
1066             {0, 1, 0, 0},
1067             {0, 1, 0, 1},
1068             {0, 1, 1, 0},
1069             {0, 1, 1, 1},
1070             {1, 0, 0, 0},
1071             {1, 0, 0, 1},
1072             {1, 0, 1, 0},
1073             {1, 0, 1, 1},
1074             {1, 1, 0, 0},
1075             {1, 1, 0, 1},
1076             {1, 1, 1, 0},
1077             {1, 1, 1, 1},
1078         };
1079     }
1080 
1081     //-----------------------------------------------------------------------
1082     // get*()
1083     //-----------------------------------------------------------------------
1084     @Test(dataProvider=&quot;sampleDates&quot;)
1085     public void test_get_dates(int y, int m, int d) {
1086         LocalDateTime a = LocalDateTime.of(y, m, d, 12, 30);
1087         assertEquals(a.getYear(), y);
1088         assertEquals(a.getMonth(), Month.of(m));
1089         assertEquals(a.getDayOfMonth(), d);
1090     }
1091 
1092     @Test(dataProvider=&quot;sampleDates&quot;)
1093     public void test_getDOY(int y, int m, int d) {
1094         LocalDateTime a = LocalDateTime.of(y, m, d, 12 ,30);
1095         int total = 0;
1096         for (int i = 1; i &lt; m; i++) {
1097             total += Month.of(i).length(isIsoLeap(y));
1098         }
1099         int doy = total + d;
1100         assertEquals(a.getDayOfYear(), doy);
1101     }
1102 
1103     @Test(dataProvider=&quot;sampleTimes&quot;)
1104     public void test_get_times(int h, int m, int s, int ns) {
1105         LocalDateTime a = LocalDateTime.of(TEST_2007_07_15_12_30_40_987654321.toLocalDate(), LocalTime.of(h, m, s, ns));
1106         assertEquals(a.getHour(), h);
1107         assertEquals(a.getMinute(), m);
1108         assertEquals(a.getSecond(), s);
1109         assertEquals(a.getNano(), ns);
1110     }
1111 
1112     //-----------------------------------------------------------------------
1113     // getDayOfWeek()
1114     //-----------------------------------------------------------------------
1115     @Test
1116     public void test_getDayOfWeek() {
1117         DayOfWeek dow = DayOfWeek.MONDAY;
1118         for (Month month : Month.values()) {
1119             int length = month.length(false);
1120             for (int i = 1; i &lt;= length; i++) {
1121                 LocalDateTime d = LocalDateTime.of(LocalDate.of(2007, month, i),
1122                         TEST_2007_07_15_12_30_40_987654321.toLocalTime());
1123                 assertSame(d.getDayOfWeek(), dow);
1124                 dow = dow.plus(1);
1125             }
1126         }
1127     }
1128 
1129     //-----------------------------------------------------------------------
1130     // adjustInto(Temporal)
1131     //-----------------------------------------------------------------------
1132     @DataProvider(name=&quot;adjustInto&quot;)
1133     Object[][] data_adjustInto() {
1134         return new Object[][]{
1135                 {LocalDateTime.of(2012, 3, 4, 23, 5), LocalDateTime.of(2012, 3, 4, 1, 1, 1, 100), LocalDateTime.of(2012, 3, 4, 23, 5, 0, 0), null},
1136                 {LocalDateTime.of(2012, Month.MARCH, 4, 0, 0), LocalDateTime.of(2012, 3, 4, 1, 1, 1, 100), LocalDateTime.of(2012, 3, 4, 0, 0), null},
1137                 {LocalDateTime.of(2012, 3, 4, 23, 5), LocalDateTime.MAX, LocalDateTime.of(2012, 3, 4, 23, 5), null},
1138                 {LocalDateTime.of(2012, 3, 4, 23, 5), LocalDateTime.MIN, LocalDateTime.of(2012, 3, 4, 23, 5), null},
1139                 {LocalDateTime.MAX, LocalDateTime.of(2012, 3, 4, 23, 5), LocalDateTime.MAX, null},
1140                 {LocalDateTime.MIN, LocalDateTime.of(2012, 3, 4, 23, 5), LocalDateTime.MIN, null},
1141 
1142                 {LocalDateTime.of(2012, 3, 4, 23, 5), OffsetDateTime.of(2210, 2, 2, 0, 0, 0, 0, ZoneOffset.UTC), OffsetDateTime.of(2012, 3, 4, 23, 5, 0, 0, ZoneOffset.UTC), null},
1143                 {LocalDateTime.of(2012, 3, 4, 23, 5), OffsetDateTime.of(2210, 2, 2, 0, 0, 0, 0, OFFSET_PONE), OffsetDateTime.of(2012, 3, 4, 23, 5, 0, 0, OFFSET_PONE), null},
1144                 {LocalDateTime.of(2012, 3, 4, 23, 5), ZonedDateTime.of(2210, 2, 2, 0, 0, 0, 0, ZONE_PARIS), ZonedDateTime.of(2012, 3, 4, 23, 5, 0, 0, ZONE_PARIS), null},
1145 
1146                 {LocalDateTime.of(2012, 3, 4, 23, 5), LocalDate.of(2210, 2, 2), null, DateTimeException.class},
1147                 {LocalDateTime.of(2012, 3, 4, 23, 5), LocalTime.of(22, 3, 0), null, DateTimeException.class},
1148                 {LocalDateTime.of(2012, 3, 4, 23, 5), OffsetTime.of(22, 3, 0, 0, ZoneOffset.UTC), null, DateTimeException.class},
1149                 {LocalDateTime.of(2012, 3, 4, 23, 5), null, null, NullPointerException.class},
1150 
1151         };
1152     }
1153 
1154     @Test(dataProvider=&quot;adjustInto&quot;)
1155     public void test_adjustInto(LocalDateTime test, Temporal temporal, Temporal expected, Class&lt;?&gt; expectedEx) {
1156         if (expectedEx == null) {
1157             Temporal result = test.adjustInto(temporal);
1158             assertEquals(result, expected);
1159         } else {
1160             try {
1161                 Temporal result = test.adjustInto(temporal);
1162                 fail();
1163             } catch (Exception ex) {
1164                 assertTrue(expectedEx.isInstance(ex));
1165             }
1166         }
1167     }
1168 
1169     //-----------------------------------------------------------------------
1170     // with()
1171     //-----------------------------------------------------------------------
1172     @Test
1173     public void test_with_adjustment() {
1174         final LocalDateTime sample = LocalDateTime.of(2012, 3, 4, 23, 5);
1175         TemporalAdjuster adjuster = new TemporalAdjuster() {
1176             @Override
1177             public Temporal adjustInto(Temporal dateTime) {
1178                 return sample;
1179             }
1180         };
1181         assertEquals(TEST_2007_07_15_12_30_40_987654321.with(adjuster), sample);
1182     }
1183 
1184     @Test(expectedExceptions=NullPointerException.class)
1185     public void test_with_adjustment_null() {
1186         TEST_2007_07_15_12_30_40_987654321.with((TemporalAdjuster) null);
1187     }
1188 
1189     //-----------------------------------------------------------------------
1190     // withYear()
1191     //-----------------------------------------------------------------------
1192     @Test
1193     public void test_withYear_int_normal() {
1194         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.withYear(2008);
1195         check(t, 2008, 7, 15, 12, 30, 40, 987654321);
1196     }
1197 
1198     @Test(expectedExceptions=DateTimeException.class)
1199     public void test_withYear_int_invalid() {
1200         TEST_2007_07_15_12_30_40_987654321.withYear(Year.MIN_VALUE - 1);
1201     }
1202 
1203     @Test
1204     public void test_withYear_int_adjustDay() {
1205         LocalDateTime t = LocalDateTime.of(2008, 2, 29, 12, 30).withYear(2007);
1206         LocalDateTime expected = LocalDateTime.of(2007, 2, 28, 12, 30);
1207         assertEquals(t, expected);
1208     }
1209 
1210     //-----------------------------------------------------------------------
1211     // withMonth()
1212     //-----------------------------------------------------------------------
1213     @Test
1214     public void test_withMonth_int_normal() {
1215         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.withMonth(1);
1216         check(t, 2007, 1, 15, 12, 30, 40, 987654321);
1217     }
1218 
1219     @Test(expectedExceptions=DateTimeException.class)
1220     public void test_withMonth_int_invalid() {
1221         TEST_2007_07_15_12_30_40_987654321.withMonth(13);
1222     }
1223 
1224     @Test
1225     public void test_withMonth_int_adjustDay() {
1226         LocalDateTime t = LocalDateTime.of(2007, 12, 31, 12, 30).withMonth(11);
1227         LocalDateTime expected = LocalDateTime.of(2007, 11, 30, 12, 30);
1228         assertEquals(t, expected);
1229     }
1230 
1231     //-----------------------------------------------------------------------
1232     // withDayOfMonth()
1233     //-----------------------------------------------------------------------
1234     @Test
1235     public void test_withDayOfMonth_normal() {
1236         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.withDayOfMonth(1);
1237         check(t, 2007, 7, 1, 12, 30, 40, 987654321);
1238     }
1239 
1240     @Test(expectedExceptions=DateTimeException.class)
1241     public void test_withDayOfMonth_invalid() {
1242         LocalDateTime.of(2007, 11, 30, 12, 30).withDayOfMonth(32);
1243     }
1244 
1245     @Test(expectedExceptions=DateTimeException.class)
1246     public void test_withDayOfMonth_invalidCombination() {
1247         LocalDateTime.of(2007, 11, 30, 12, 30).withDayOfMonth(31);
1248     }
1249 
1250     //-----------------------------------------------------------------------
1251     // withDayOfYear(int)
1252     //-----------------------------------------------------------------------
1253     @Test
1254     public void test_withDayOfYear_normal() {
1255         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.withDayOfYear(33);
1256         assertEquals(t, LocalDateTime.of(2007, 2, 2, 12, 30, 40, 987654321));
1257     }
1258 
1259     @Test(expectedExceptions=DateTimeException.class)
1260     public void test_withDayOfYear_illegal() {
1261         TEST_2007_07_15_12_30_40_987654321.withDayOfYear(367);
1262     }
1263 
1264     @Test(expectedExceptions=DateTimeException.class)
1265     public void test_withDayOfYear_invalid() {
1266         TEST_2007_07_15_12_30_40_987654321.withDayOfYear(366);
1267     }
1268 
1269     //-----------------------------------------------------------------------
1270     // withHour()
1271     //-----------------------------------------------------------------------
1272     @Test
1273     public void test_withHour_normal() {
1274         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321;
1275         for (int i = 0; i &lt; 24; i++) {
1276             t = t.withHour(i);
1277             assertEquals(t.getHour(), i);
1278         }
1279     }
1280 
1281     @Test(expectedExceptions=DateTimeException.class)
1282     public void test_withHour_hourTooLow() {
1283         TEST_2007_07_15_12_30_40_987654321.withHour(-1);
1284     }
1285 
1286     @Test(expectedExceptions=DateTimeException.class)
1287     public void test_withHour_hourTooHigh() {
1288         TEST_2007_07_15_12_30_40_987654321.withHour(24);
1289     }
1290 
1291     //-----------------------------------------------------------------------
1292     // withMinute()
1293     //-----------------------------------------------------------------------
1294     @Test
1295     public void test_withMinute_normal() {
1296         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321;
1297         for (int i = 0; i &lt; 60; i++) {
1298             t = t.withMinute(i);
1299             assertEquals(t.getMinute(), i);
1300         }
1301     }
1302 
1303     @Test(expectedExceptions=DateTimeException.class)
1304     public void test_withMinute_minuteTooLow() {
1305         TEST_2007_07_15_12_30_40_987654321.withMinute(-1);
1306     }
1307 
1308     @Test(expectedExceptions=DateTimeException.class)
1309     public void test_withMinute_minuteTooHigh() {
1310         TEST_2007_07_15_12_30_40_987654321.withMinute(60);
1311     }
1312 
1313     //-----------------------------------------------------------------------
1314     // withSecond()
1315     //-----------------------------------------------------------------------
1316     @Test
1317     public void test_withSecond_normal() {
1318         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321;
1319         for (int i = 0; i &lt; 60; i++) {
1320             t = t.withSecond(i);
1321             assertEquals(t.getSecond(), i);
1322         }
1323     }
1324 
1325     @Test(expectedExceptions=DateTimeException.class)
1326     public void test_withSecond_secondTooLow() {
1327         TEST_2007_07_15_12_30_40_987654321.withSecond(-1);
1328     }
1329 
1330     @Test(expectedExceptions=DateTimeException.class)
1331     public void test_withSecond_secondTooHigh() {
1332         TEST_2007_07_15_12_30_40_987654321.withSecond(60);
1333     }
1334 
1335     //-----------------------------------------------------------------------
1336     // withNano()
1337     //-----------------------------------------------------------------------
1338     @Test
1339     public void test_withNanoOfSecond_normal() {
1340         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321;
1341         t = t.withNano(1);
1342         assertEquals(t.getNano(), 1);
1343         t = t.withNano(10);
1344         assertEquals(t.getNano(), 10);
1345         t = t.withNano(100);
1346         assertEquals(t.getNano(), 100);
1347         t = t.withNano(999999999);
1348         assertEquals(t.getNano(), 999999999);
1349     }
1350 
1351     @Test(expectedExceptions=DateTimeException.class)
1352     public void test_withNanoOfSecond_nanoTooLow() {
1353         TEST_2007_07_15_12_30_40_987654321.withNano(-1);
1354     }
1355 
1356     @Test(expectedExceptions=DateTimeException.class)
1357     public void test_withNanoOfSecond_nanoTooHigh() {
1358         TEST_2007_07_15_12_30_40_987654321.withNano(1000000000);
1359     }
1360 
1361     //-----------------------------------------------------------------------
1362     // truncatedTo(TemporalUnit)
1363     //-----------------------------------------------------------------------
1364     @Test
1365     public void test_truncatedTo_normal() {
1366         assertEquals(TEST_2007_07_15_12_30_40_987654321.truncatedTo(NANOS), TEST_2007_07_15_12_30_40_987654321);
1367         assertEquals(TEST_2007_07_15_12_30_40_987654321.truncatedTo(SECONDS), TEST_2007_07_15_12_30_40_987654321.withNano(0));
1368         assertEquals(TEST_2007_07_15_12_30_40_987654321.truncatedTo(DAYS), TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT));
1369     }
1370 
1371     @Test(expectedExceptions=NullPointerException.class)
1372     public void test_truncatedTo_null() {
1373         TEST_2007_07_15_12_30_40_987654321.truncatedTo(null);
1374     }
1375 
1376     //-----------------------------------------------------------------------
1377     // plus(TemporalAmount)
1378     //-----------------------------------------------------------------------
1379     @Test
1380     public void test_plus_TemporalAmount_positiveMonths() {
1381         MockSimplePeriod period = MockSimplePeriod.of(7, MONTHS);
1382         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plus(period);
1383         assertEquals(t, LocalDateTime.of(2008, 2, 15, 12, 30, 40, 987654321));
1384     }
1385 
1386     @Test
1387     public void test_plus_TemporalAmount_negativeDays() {
1388         MockSimplePeriod period = MockSimplePeriod.of(-25, DAYS);
1389         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plus(period);
1390         assertEquals(t, LocalDateTime.of(2007, 6, 20, 12, 30, 40, 987654321));
1391     }
1392 
1393     @Test(expectedExceptions=DateTimeException.class)
1394     public void test_plus_TemporalAmount_invalidTooLarge() {
1395         MockSimplePeriod period = MockSimplePeriod.of(1, YEARS);
1396         LocalDateTime.of(Year.MAX_VALUE, 1, 1, 0, 0).plus(period);
1397     }
1398 
1399     @Test(expectedExceptions=DateTimeException.class)
1400     public void test_plus_TemporalAmount_invalidTooSmall() {
1401         MockSimplePeriod period = MockSimplePeriod.of(-1, YEARS);
1402         LocalDateTime.of(Year.MIN_VALUE, 1, 1, 0, 0).plus(period);
1403     }
1404 
1405     @Test(expectedExceptions=NullPointerException.class)
1406     public void test_plus_TemporalAmount_null() {
1407         TEST_2007_07_15_12_30_40_987654321.plus((TemporalAmount) null);
1408     }
1409 
1410     //-----------------------------------------------------------------------
1411     // plus(long,TemporalUnit)
1412     //-----------------------------------------------------------------------
1413     @Test
1414     public void test_plus_longTemporalUnit_positiveMonths() {
1415         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plus(7, ChronoUnit.MONTHS);
1416         assertEquals(t, LocalDateTime.of(2008, 2, 15, 12, 30, 40, 987654321));
1417     }
1418 
1419     @Test
1420     public void test_plus_longTemporalUnit_negativeDays() {
1421         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plus(-25, ChronoUnit.DAYS);
1422         assertEquals(t, LocalDateTime.of(2007, 6, 20, 12, 30, 40, 987654321));
1423     }
1424 
1425     @Test(expectedExceptions=NullPointerException.class)
1426     public void test_plus_longTemporalUnit_null() {
1427         TEST_2007_07_15_12_30_40_987654321.plus(1, (TemporalUnit) null);
1428     }
1429 
1430     @Test(expectedExceptions=DateTimeException.class)
1431     public void test_plus_longTemporalUnit_invalidTooLarge() {
1432         LocalDateTime.of(Year.MAX_VALUE, 1, 1, 0, 0).plus(1, ChronoUnit.YEARS);
1433     }
1434 
1435     @Test(expectedExceptions=DateTimeException.class)
1436     public void test_plus_longTemporalUnit_invalidTooSmall() {
1437         LocalDateTime.of(Year.MIN_VALUE, 1, 1, 0, 0).plus(-1, ChronoUnit.YEARS);
1438     }
1439 
1440     //-----------------------------------------------------------------------
1441     // plusYears()
1442     //-----------------------------------------------------------------------
1443     @Test
1444     public void test_plusYears_int_normal() {
1445         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusYears(1);
1446         check(t, 2008, 7, 15, 12, 30, 40, 987654321);
1447     }
1448 
1449     @Test
1450     public void test_plusYears_int_negative() {
1451         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusYears(-1);
1452         check(t, 2006, 7, 15, 12, 30, 40, 987654321);
1453     }
1454 
1455     @Test
1456     public void test_plusYears_int_adjustDay() {
1457         LocalDateTime t = createDateMidnight(2008, 2, 29).plusYears(1);
1458         check(t, 2009, 2, 28, 0, 0, 0, 0);
1459     }
1460 
1461     @Test(expectedExceptions=DateTimeException.class)
1462     public void test_plusYears_int_invalidTooLarge() {
1463         createDateMidnight(Year.MAX_VALUE, 1, 1).plusYears(1);
1464     }
1465 
1466     @Test(expectedExceptions=DateTimeException.class)
1467     public void test_plusYears_int_invalidTooSmall() {
1468         LocalDate.of(Year.MIN_VALUE, 1, 1).plusYears(-1);
1469     }
1470 
1471     //-----------------------------------------------------------------------
1472     // plusMonths()
1473     //-----------------------------------------------------------------------
1474     @Test
1475     public void test_plusMonths_int_normal() {
1476         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusMonths(1);
1477         check(t, 2007, 8, 15, 12, 30, 40, 987654321);
1478     }
1479 
1480     @Test
1481     public void test_plusMonths_int_overYears() {
1482         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusMonths(25);
1483         check(t, 2009, 8, 15, 12, 30, 40, 987654321);
1484     }
1485 
1486     @Test
1487     public void test_plusMonths_int_negative() {
1488         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusMonths(-1);
1489         check(t, 2007, 6, 15, 12, 30, 40, 987654321);
1490     }
1491 
1492     @Test
1493     public void test_plusMonths_int_negativeAcrossYear() {
1494         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusMonths(-7);
1495         check(t, 2006, 12, 15, 12, 30, 40, 987654321);
1496     }
1497 
1498     @Test
1499     public void test_plusMonths_int_negativeOverYears() {
1500         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusMonths(-31);
1501         check(t, 2004, 12, 15, 12, 30, 40, 987654321);
1502     }
1503 
1504     @Test
1505     public void test_plusMonths_int_adjustDayFromLeapYear() {
1506         LocalDateTime t = createDateMidnight(2008, 2, 29).plusMonths(12);
1507         check(t, 2009, 2, 28, 0, 0, 0, 0);
1508     }
1509 
1510     @Test
1511     public void test_plusMonths_int_adjustDayFromMonthLength() {
1512         LocalDateTime t = createDateMidnight(2007, 3, 31).plusMonths(1);
1513         check(t, 2007, 4, 30, 0, 0, 0, 0);
1514     }
1515 
1516     @Test(expectedExceptions=DateTimeException.class)
1517     public void test_plusMonths_int_invalidTooLarge() {
1518         createDateMidnight(Year.MAX_VALUE, 12, 1).plusMonths(1);
1519     }
1520 
1521     @Test(expectedExceptions=DateTimeException.class)
1522     public void test_plusMonths_int_invalidTooSmall() {
1523         createDateMidnight(Year.MIN_VALUE, 1, 1).plusMonths(-1);
1524     }
1525 
1526     //-----------------------------------------------------------------------
1527     // plusWeeks()
1528     //-----------------------------------------------------------------------
1529     @DataProvider(name=&quot;samplePlusWeeksSymmetry&quot;)
1530     Object[][] provider_samplePlusWeeksSymmetry() {
1531         return new Object[][] {
1532             {createDateMidnight(-1, 1, 1)},
1533             {createDateMidnight(-1, 2, 28)},
1534             {createDateMidnight(-1, 3, 1)},
1535             {createDateMidnight(-1, 12, 31)},
1536             {createDateMidnight(0, 1, 1)},
1537             {createDateMidnight(0, 2, 28)},
1538             {createDateMidnight(0, 2, 29)},
1539             {createDateMidnight(0, 3, 1)},
1540             {createDateMidnight(0, 12, 31)},
1541             {createDateMidnight(2007, 1, 1)},
1542             {createDateMidnight(2007, 2, 28)},
1543             {createDateMidnight(2007, 3, 1)},
1544             {createDateMidnight(2007, 12, 31)},
1545             {createDateMidnight(2008, 1, 1)},
1546             {createDateMidnight(2008, 2, 28)},
1547             {createDateMidnight(2008, 2, 29)},
1548             {createDateMidnight(2008, 3, 1)},
1549             {createDateMidnight(2008, 12, 31)},
1550             {createDateMidnight(2099, 1, 1)},
1551             {createDateMidnight(2099, 2, 28)},
1552             {createDateMidnight(2099, 3, 1)},
1553             {createDateMidnight(2099, 12, 31)},
1554             {createDateMidnight(2100, 1, 1)},
1555             {createDateMidnight(2100, 2, 28)},
1556             {createDateMidnight(2100, 3, 1)},
1557             {createDateMidnight(2100, 12, 31)},
1558         };
1559     }
1560 
1561     @Test(dataProvider=&quot;samplePlusWeeksSymmetry&quot;)
1562     public void test_plusWeeks_symmetry(LocalDateTime reference) {
1563         for (int weeks = 0; weeks &lt; 365 * 8; weeks++) {
1564             LocalDateTime t = reference.plusWeeks(weeks).plusWeeks(-weeks);
1565             assertEquals(t, reference);
1566 
1567             t = reference.plusWeeks(-weeks).plusWeeks(weeks);
1568             assertEquals(t, reference);
1569         }
1570     }
1571 
1572     @Test
1573     public void test_plusWeeks_normal() {
1574         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusWeeks(1);
1575         check(t, 2007, 7, 22, 12, 30, 40, 987654321);
1576     }
1577 
1578     @Test
1579     public void test_plusWeeks_overMonths() {
1580         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusWeeks(9);
1581         check(t, 2007, 9, 16, 12, 30, 40, 987654321);
1582     }
1583 
1584     @Test
1585     public void test_plusWeeks_overYears() {
1586         LocalDateTime t = LocalDateTime.of(2006, 7, 16, 12, 30, 40, 987654321).plusWeeks(52);
1587         assertEquals(t, TEST_2007_07_15_12_30_40_987654321);
1588     }
1589 
1590     @Test
1591     public void test_plusWeeks_overLeapYears() {
1592         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusYears(-1).plusWeeks(104);
1593         check(t, 2008, 7, 12, 12, 30, 40, 987654321);
1594     }
1595 
1596     @Test
1597     public void test_plusWeeks_negative() {
1598         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusWeeks(-1);
1599         check(t, 2007, 7, 8, 12, 30, 40, 987654321);
1600     }
1601 
1602     @Test
1603     public void test_plusWeeks_negativeAcrossYear() {
1604         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusWeeks(-28);
1605         check(t, 2006, 12, 31, 12, 30, 40, 987654321);
1606     }
1607 
1608     @Test
1609     public void test_plusWeeks_negativeOverYears() {
1610         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusWeeks(-104);
1611         check(t, 2005, 7, 17, 12, 30, 40, 987654321);
1612     }
1613 
1614     @Test
1615     public void test_plusWeeks_maximum() {
1616         LocalDateTime t = createDateMidnight(Year.MAX_VALUE, 12, 24).plusWeeks(1);
1617         check(t, Year.MAX_VALUE, 12, 31, 0, 0, 0, 0);
1618     }
1619 
1620     @Test
1621     public void test_plusWeeks_minimum() {
1622         LocalDateTime t = createDateMidnight(Year.MIN_VALUE, 1, 8).plusWeeks(-1);
1623         check(t, Year.MIN_VALUE, 1, 1, 0, 0, 0, 0);
1624     }
1625 
1626     @Test(expectedExceptions=DateTimeException.class)
1627     public void test_plusWeeks_invalidTooLarge() {
1628         createDateMidnight(Year.MAX_VALUE, 12, 25).plusWeeks(1);
1629     }
1630 
1631     @Test(expectedExceptions=DateTimeException.class)
1632     public void test_plusWeeks_invalidTooSmall() {
1633         createDateMidnight(Year.MIN_VALUE, 1, 7).plusWeeks(-1);
1634     }
1635 
1636     //-----------------------------------------------------------------------
1637     // plusDays()
1638     //-----------------------------------------------------------------------
1639     @DataProvider(name=&quot;samplePlusDaysSymmetry&quot;)
1640     Object[][] provider_samplePlusDaysSymmetry() {
1641         return new Object[][] {
1642             {createDateMidnight(-1, 1, 1)},
1643             {createDateMidnight(-1, 2, 28)},
1644             {createDateMidnight(-1, 3, 1)},
1645             {createDateMidnight(-1, 12, 31)},
1646             {createDateMidnight(0, 1, 1)},
1647             {createDateMidnight(0, 2, 28)},
1648             {createDateMidnight(0, 2, 29)},
1649             {createDateMidnight(0, 3, 1)},
1650             {createDateMidnight(0, 12, 31)},
1651             {createDateMidnight(2007, 1, 1)},
1652             {createDateMidnight(2007, 2, 28)},
1653             {createDateMidnight(2007, 3, 1)},
1654             {createDateMidnight(2007, 12, 31)},
1655             {createDateMidnight(2008, 1, 1)},
1656             {createDateMidnight(2008, 2, 28)},
1657             {createDateMidnight(2008, 2, 29)},
1658             {createDateMidnight(2008, 3, 1)},
1659             {createDateMidnight(2008, 12, 31)},
1660             {createDateMidnight(2099, 1, 1)},
1661             {createDateMidnight(2099, 2, 28)},
1662             {createDateMidnight(2099, 3, 1)},
1663             {createDateMidnight(2099, 12, 31)},
1664             {createDateMidnight(2100, 1, 1)},
1665             {createDateMidnight(2100, 2, 28)},
1666             {createDateMidnight(2100, 3, 1)},
1667             {createDateMidnight(2100, 12, 31)},
1668         };
1669     }
1670 
1671     @Test(dataProvider=&quot;samplePlusDaysSymmetry&quot;)
1672     public void test_plusDays_symmetry(LocalDateTime reference) {
1673         for (int days = 0; days &lt; 365 * 8; days++) {
1674             LocalDateTime t = reference.plusDays(days).plusDays(-days);
1675             assertEquals(t, reference);
1676 
1677             t = reference.plusDays(-days).plusDays(days);
1678             assertEquals(t, reference);
1679         }
1680     }
1681 
1682     @Test
1683     public void test_plusDays_normal() {
1684         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusDays(1);
1685         check(t, 2007, 7, 16, 12, 30, 40, 987654321);
1686     }
1687 
1688     @Test
1689     public void test_plusDays_overMonths() {
1690         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusDays(62);
1691         check(t, 2007, 9, 15, 12, 30, 40, 987654321);
1692     }
1693 
1694     @Test
1695     public void test_plusDays_overYears() {
1696         LocalDateTime t = LocalDateTime.of(2006, 7, 14, 12, 30, 40, 987654321).plusDays(366);
1697         assertEquals(t, TEST_2007_07_15_12_30_40_987654321);
1698     }
1699 
1700     @Test
1701     public void test_plusDays_overLeapYears() {
1702         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusYears(-1).plusDays(365 + 366);
1703         check(t, 2008, 7, 15, 12, 30, 40, 987654321);
1704     }
1705 
1706     @Test
1707     public void test_plusDays_negative() {
1708         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusDays(-1);
1709         check(t, 2007, 7, 14, 12, 30, 40, 987654321);
1710     }
1711 
1712     @Test
1713     public void test_plusDays_negativeAcrossYear() {
1714         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusDays(-196);
1715         check(t, 2006, 12, 31, 12, 30, 40, 987654321);
1716     }
1717 
1718     @Test
1719     public void test_plusDays_negativeOverYears() {
1720         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusDays(-730);
1721         check(t, 2005, 7, 15, 12, 30, 40, 987654321);
1722     }
1723 
1724     @Test
1725     public void test_plusDays_maximum() {
1726         LocalDateTime t = createDateMidnight(Year.MAX_VALUE, 12, 30).plusDays(1);
1727         check(t, Year.MAX_VALUE, 12, 31, 0, 0, 0, 0);
1728     }
1729 
1730     @Test
1731     public void test_plusDays_minimum() {
1732         LocalDateTime t = createDateMidnight(Year.MIN_VALUE, 1, 2).plusDays(-1);
1733         check(t, Year.MIN_VALUE, 1, 1, 0, 0, 0, 0);
1734     }
1735 
1736     @Test(expectedExceptions=DateTimeException.class)
1737     public void test_plusDays_invalidTooLarge() {
1738         createDateMidnight(Year.MAX_VALUE, 12, 31).plusDays(1);
1739     }
1740 
1741     @Test(expectedExceptions=DateTimeException.class)
1742     public void test_plusDays_invalidTooSmall() {
1743         createDateMidnight(Year.MIN_VALUE, 1, 1).plusDays(-1);
1744     }
1745 
1746     @Test(expectedExceptions=ArithmeticException.class)
1747     public void test_plusDays_overflowTooLarge() {
1748         createDateMidnight(Year.MAX_VALUE, 12, 31).plusDays(Long.MAX_VALUE);
1749     }
1750 
1751     @Test(expectedExceptions=ArithmeticException.class)
1752     public void test_plusDays_overflowTooSmall() {
1753         createDateMidnight(Year.MIN_VALUE, 1, 1).plusDays(Long.MIN_VALUE);
1754     }
1755 
1756     //-----------------------------------------------------------------------
1757     // plusHours()
1758     //-----------------------------------------------------------------------
1759     @Test
1760     public void test_plusHours_one() {
1761         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
1762         LocalDate d = t.toLocalDate();
1763 
1764         for (int i = 0; i &lt; 50; i++) {
1765             t = t.plusHours(1);
1766 
1767             if ((i + 1) % 24 == 0) {
1768                 d = d.plusDays(1);
1769             }
1770 
1771             assertEquals(t.toLocalDate(), d);
1772             assertEquals(t.getHour(), (i + 1) % 24);
1773         }
1774     }
1775 
1776     @Test
1777     public void test_plusHours_fromZero() {
1778         LocalDateTime base = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
1779         LocalDate d = base.toLocalDate().minusDays(3);
1780         LocalTime t = LocalTime.of(21, 0);
1781 
1782         for (int i = -50; i &lt; 50; i++) {
1783             LocalDateTime dt = base.plusHours(i);
1784             t = t.plusHours(1);
1785 
1786             if (t.getHour() == 0) {
1787                 d = d.plusDays(1);
1788             }
1789 
1790             assertEquals(dt.toLocalDate(), d);
1791             assertEquals(dt.toLocalTime(), t);
1792         }
1793     }
1794 
1795     @Test
1796     public void test_plusHours_fromOne() {
1797         LocalDateTime base = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.of(1, 0));
1798         LocalDate d = base.toLocalDate().minusDays(3);
1799         LocalTime t = LocalTime.of(22, 0);
1800 
1801         for (int i = -50; i &lt; 50; i++) {
1802             LocalDateTime dt = base.plusHours(i);
1803 
1804             t = t.plusHours(1);
1805 
1806             if (t.getHour() == 0) {
1807                 d = d.plusDays(1);
1808             }
1809 
1810             assertEquals(dt.toLocalDate(), d);
1811             assertEquals(dt.toLocalTime(), t);
1812         }
1813     }
1814 
1815     //-----------------------------------------------------------------------
1816     // plusMinutes()
1817     //-----------------------------------------------------------------------
1818     @Test
1819     public void test_plusMinutes_one() {
1820         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
1821         LocalDate d = t.toLocalDate();
1822 
1823         int hour = 0;
1824         int min = 0;
1825 
1826         for (int i = 0; i &lt; 70; i++) {
1827             t = t.plusMinutes(1);
1828             min++;
1829             if (min == 60) {
1830                 hour++;
1831                 min = 0;
1832             }
1833 
1834             assertEquals(t.toLocalDate(), d);
1835             assertEquals(t.getHour(), hour);
1836             assertEquals(t.getMinute(), min);
1837         }
1838     }
1839 
1840     @Test
1841     public void test_plusMinutes_fromZero() {
1842         LocalDateTime base = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
1843         LocalDate d = base.toLocalDate().minusDays(1);
1844         LocalTime t = LocalTime.of(22, 49);
1845 
1846         for (int i = -70; i &lt; 70; i++) {
1847             LocalDateTime dt = base.plusMinutes(i);
1848             t = t.plusMinutes(1);
1849 
1850             if (t.equals(LocalTime.MIDNIGHT)) {
1851                 d = d.plusDays(1);
1852             }
1853 
1854             assertEquals(dt.toLocalDate(), d, String.valueOf(i));
1855             assertEquals(dt.toLocalTime(), t, String.valueOf(i));
1856         }
1857     }
1858 
1859     @Test
1860     public void test_plusMinutes_noChange_oneDay() {
1861         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusMinutes(24 * 60);
1862         assertEquals(t.toLocalDate(), TEST_2007_07_15_12_30_40_987654321.toLocalDate().plusDays(1));
1863     }
1864 
1865     //-----------------------------------------------------------------------
1866     // plusSeconds()
1867     //-----------------------------------------------------------------------
1868     @Test
1869     public void test_plusSeconds_one() {
1870         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
1871         LocalDate d = t.toLocalDate();
1872 
1873         int hour = 0;
1874         int min = 0;
1875         int sec = 0;
1876 
1877         for (int i = 0; i &lt; 3700; i++) {
1878             t = t.plusSeconds(1);
1879             sec++;
1880             if (sec == 60) {
1881                 min++;
1882                 sec = 0;
1883             }
1884             if (min == 60) {
1885                 hour++;
1886                 min = 0;
1887             }
1888 
1889             assertEquals(t.toLocalDate(), d);
1890             assertEquals(t.getHour(), hour);
1891             assertEquals(t.getMinute(), min);
1892             assertEquals(t.getSecond(), sec);
1893         }
1894     }
1895 
1896     @DataProvider(name=&quot;plusSeconds_fromZero&quot;)
1897     Iterator&lt;Object[]&gt; plusSeconds_fromZero() {
1898         return new Iterator&lt;Object[]&gt;() {
1899             int delta = 30;
1900 
1901             int i = -3660;
1902             LocalDate date = TEST_2007_07_15_12_30_40_987654321.toLocalDate().minusDays(1);
1903             int hour = 22;
1904             int min = 59;
1905             int sec = 0;
1906 
1907             public boolean hasNext() {
1908                 return i &lt;= 3660;
1909             }
1910 
1911             public Object[] next() {
1912                 final Object[] ret = new Object[] {i, date, hour, min, sec};
1913                 i += delta;
1914                 sec += delta;
1915 
1916                 if (sec &gt;= 60) {
1917                     min++;
1918                     sec -= 60;
1919 
1920                     if (min == 60) {
1921                         hour++;
1922                         min = 0;
1923 
1924                         if (hour == 24) {
1925                             hour = 0;
1926                         }
1927                     }
1928                 }
1929 
1930                 if (i == 0) {
1931                     date = date.plusDays(1);
1932                 }
1933 
1934                 return ret;
1935             }
1936 
1937             public void remove() {
1938                 throw new UnsupportedOperationException();
1939             }
1940         };
1941     }
1942 
1943     @Test(dataProvider=&quot;plusSeconds_fromZero&quot;)
1944     public void test_plusSeconds_fromZero(int seconds, LocalDate date, int hour, int min, int sec) {
1945         LocalDateTime base = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
1946         LocalDateTime t = base.plusSeconds(seconds);
1947 
1948         assertEquals(date, t.toLocalDate());
1949         assertEquals(hour, t.getHour());
1950         assertEquals(min, t.getMinute());
1951         assertEquals(sec, t.getSecond());
1952     }
1953 
1954     @Test
1955     public void test_plusSeconds_noChange_oneDay() {
1956         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusSeconds(24 * 60 * 60);
1957         assertEquals(t.toLocalDate(), TEST_2007_07_15_12_30_40_987654321.toLocalDate().plusDays(1));
1958     }
1959 
1960     //-----------------------------------------------------------------------
1961     // plusNanos()
1962     //-----------------------------------------------------------------------
1963     @Test
1964     public void test_plusNanos_halfABillion() {
1965         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
1966         LocalDate d = t.toLocalDate();
1967 
1968         int hour = 0;
1969         int min = 0;
1970         int sec = 0;
1971         int nanos = 0;
1972 
1973         for (long i = 0; i &lt; 3700 * 1000000000L; i+= 500000000) {
1974             t = t.plusNanos(500000000);
1975             nanos += 500000000;
1976             if (nanos == 1000000000) {
1977                 sec++;
1978                 nanos = 0;
1979             }
1980             if (sec == 60) {
1981                 min++;
1982                 sec = 0;
1983             }
1984             if (min == 60) {
1985                 hour++;
1986                 min = 0;
1987             }
1988 
1989             assertEquals(t.toLocalDate(), d, String.valueOf(i));
1990             assertEquals(t.getHour(), hour);
1991             assertEquals(t.getMinute(), min);
1992             assertEquals(t.getSecond(), sec);
1993             assertEquals(t.getNano(), nanos);
1994         }
1995     }
1996 
1997     @DataProvider(name=&quot;plusNanos_fromZero&quot;)
1998     Iterator&lt;Object[]&gt; plusNanos_fromZero() {
1999         return new Iterator&lt;Object[]&gt;() {
2000             long delta = 7500000000L;
2001 
2002             long i = -3660 * 1000000000L;
2003             LocalDate date = TEST_2007_07_15_12_30_40_987654321.toLocalDate().minusDays(1);
2004             int hour = 22;
2005             int min = 59;
2006             int sec = 0;
2007             long nanos = 0;
2008 
2009             public boolean hasNext() {
2010                 return i &lt;= 3660 * 1000000000L;
2011             }
2012 
2013             public Object[] next() {
2014                 final Object[] ret = new Object[] {i, date, hour, min, sec, (int)nanos};
2015                 i += delta;
2016                 nanos += delta;
2017 
2018                 if (nanos &gt;= 1000000000L) {
2019                     sec += nanos / 1000000000L;
2020                     nanos %= 1000000000L;
2021 
2022                     if (sec &gt;= 60) {
2023                         min++;
2024                         sec %= 60;
2025 
2026                         if (min == 60) {
2027                             hour++;
2028                             min = 0;
2029 
2030                             if (hour == 24) {
2031                                 hour = 0;
2032                                 date = date.plusDays(1);
2033                             }
2034                         }
2035                     }
2036                 }
2037 
2038                 return ret;
2039             }
2040 
2041             public void remove() {
2042                 throw new UnsupportedOperationException();
2043             }
2044         };
2045     }
2046 
2047     @Test(dataProvider=&quot;plusNanos_fromZero&quot;)
2048     public void test_plusNanos_fromZero(long nanoseconds, LocalDate date, int hour, int min, int sec, int nanos) {
2049         LocalDateTime base = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
2050         LocalDateTime t = base.plusNanos(nanoseconds);
2051 
2052         assertEquals(date, t.toLocalDate());
2053         assertEquals(hour, t.getHour());
2054         assertEquals(min, t.getMinute());
2055         assertEquals(sec, t.getSecond());
2056         assertEquals(nanos, t.getNano());
2057     }
2058 
2059     @Test
2060     public void test_plusNanos_noChange_oneDay() {
2061         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusNanos(24 * 60 * 60 * 1000000000L);
2062         assertEquals(t.toLocalDate(), TEST_2007_07_15_12_30_40_987654321.toLocalDate().plusDays(1));
2063     }
2064 
2065     //-----------------------------------------------------------------------
2066     // minus(TemporalAmount)
2067     //-----------------------------------------------------------------------
2068     @Test
2069     public void test_minus_TemporalAmount_positiveMonths() {
2070         MockSimplePeriod period = MockSimplePeriod.of(7, MONTHS);
2071         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minus(period);
2072         assertEquals(t, LocalDateTime.of(2006, 12, 15, 12, 30, 40, 987654321));
2073     }
2074 
2075     @Test
2076     public void test_minus_TemporalAmount_negativeDays() {
2077         MockSimplePeriod period = MockSimplePeriod.of(-25, DAYS);
2078         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minus(period);
2079         assertEquals(t, LocalDateTime.of(2007, 8, 9, 12, 30, 40, 987654321));
2080     }
2081 
2082     @Test(expectedExceptions=DateTimeException.class)
2083     public void test_minus_TemporalAmount_invalidTooLarge() {
2084         MockSimplePeriod period = MockSimplePeriod.of(-1, YEARS);
2085         LocalDateTime.of(Year.MAX_VALUE, 1, 1, 0, 0).minus(period);
2086     }
2087 
2088     @Test(expectedExceptions=DateTimeException.class)
2089     public void test_minus_TemporalAmount_invalidTooSmall() {
2090         MockSimplePeriod period = MockSimplePeriod.of(1, YEARS);
2091         LocalDateTime.of(Year.MIN_VALUE, 1, 1, 0, 0).minus(period);
2092     }
2093 
2094     @Test(expectedExceptions=NullPointerException.class)
2095     public void test_minus_TemporalAmount_null() {
2096         TEST_2007_07_15_12_30_40_987654321.minus((TemporalAmount) null);
2097     }
2098 
2099     //-----------------------------------------------------------------------
2100     // minus(long,TemporalUnit)
2101     //-----------------------------------------------------------------------
2102     @Test
2103     public void test_minus_longTemporalUnit_positiveMonths() {
2104         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minus(7, ChronoUnit.MONTHS);
2105         assertEquals(t, LocalDateTime.of(2006, 12, 15, 12, 30, 40, 987654321));
2106     }
2107 
2108     @Test
2109     public void test_minus_longTemporalUnit_negativeDays() {
2110         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minus(-25, ChronoUnit.DAYS);
2111         assertEquals(t, LocalDateTime.of(2007, 8, 9, 12, 30, 40, 987654321));
2112     }
2113 
2114     @Test(expectedExceptions=NullPointerException.class)
2115     public void test_minus_longTemporalUnit_null() {
2116         TEST_2007_07_15_12_30_40_987654321.minus(1, (TemporalUnit) null);
2117     }
2118 
2119     @Test(expectedExceptions=DateTimeException.class)
2120     public void test_minus_longTemporalUnit_invalidTooLarge() {
2121         LocalDateTime.of(Year.MAX_VALUE, 1, 1, 0, 0).minus(-1, ChronoUnit.YEARS);
2122     }
2123 
2124     @Test(expectedExceptions=DateTimeException.class)
2125     public void test_minus_longTemporalUnit_invalidTooSmall() {
2126         LocalDateTime.of(Year.MIN_VALUE, 1, 1, 0, 0).minus(1, ChronoUnit.YEARS);
2127     }
2128 
2129     //-----------------------------------------------------------------------
2130     // minusYears()
2131     //-----------------------------------------------------------------------
2132     @Test
2133     public void test_minusYears_int_normal() {
2134         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusYears(1);
2135         check(t, 2006, 7, 15, 12, 30, 40, 987654321);
2136     }
2137 
2138     @Test
2139     public void test_minusYears_int_negative() {
2140         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusYears(-1);
2141         check(t, 2008, 7, 15, 12, 30, 40, 987654321);
2142     }
2143 
2144     @Test
2145     public void test_minusYears_int_adjustDay() {
2146         LocalDateTime t = createDateMidnight(2008, 2, 29).minusYears(1);
2147         check(t, 2007, 2, 28, 0, 0, 0, 0);
2148     }
2149 
2150     @Test(expectedExceptions=DateTimeException.class)
2151     public void test_minusYears_int_invalidTooLarge() {
2152         createDateMidnight(Year.MAX_VALUE, 1, 1).minusYears(-1);
2153     }
2154 
2155     @Test(expectedExceptions=DateTimeException.class)
2156     public void test_minusYears_int_invalidTooSmall() {
2157         createDateMidnight(Year.MIN_VALUE, 1, 1).minusYears(1);
2158     }
2159 
2160     //-----------------------------------------------------------------------
2161     // minusMonths()
2162     //-----------------------------------------------------------------------
2163     @Test
2164     public void test_minusMonths_int_normal() {
2165         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusMonths(1);
2166         check(t, 2007, 6, 15, 12, 30, 40, 987654321);
2167     }
2168 
2169     @Test
2170     public void test_minusMonths_int_overYears() {
2171         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusMonths(25);
2172         check(t, 2005, 6, 15, 12, 30, 40, 987654321);
2173     }
2174 
2175     @Test
2176     public void test_minusMonths_int_negative() {
2177         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusMonths(-1);
2178         check(t, 2007, 8, 15, 12, 30, 40, 987654321);
2179     }
2180 
2181     @Test
2182     public void test_minusMonths_int_negativeAcrossYear() {
2183         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusMonths(-7);
2184         check(t, 2008, 2, 15, 12, 30, 40, 987654321);
2185     }
2186 
2187     @Test
2188     public void test_minusMonths_int_negativeOverYears() {
2189         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusMonths(-31);
2190         check(t, 2010, 2, 15, 12, 30, 40, 987654321);
2191     }
2192 
2193     @Test
2194     public void test_minusMonths_int_adjustDayFromLeapYear() {
2195         LocalDateTime t = createDateMidnight(2008, 2, 29).minusMonths(12);
2196         check(t, 2007, 2, 28, 0, 0, 0, 0);
2197     }
2198 
2199     @Test
2200     public void test_minusMonths_int_adjustDayFromMonthLength() {
2201         LocalDateTime t = createDateMidnight(2007, 3, 31).minusMonths(1);
2202         check(t, 2007, 2, 28, 0, 0, 0, 0);
2203     }
2204 
2205     @Test(expectedExceptions=DateTimeException.class)
2206     public void test_minusMonths_int_invalidTooLarge() {
2207         createDateMidnight(Year.MAX_VALUE, 12, 1).minusMonths(-1);
2208     }
2209 
2210     @Test(expectedExceptions=DateTimeException.class)
2211     public void test_minusMonths_int_invalidTooSmall() {
2212         createDateMidnight(Year.MIN_VALUE, 1, 1).minusMonths(1);
2213     }
2214 
2215     //-----------------------------------------------------------------------
2216     // minusWeeks()
2217     //-----------------------------------------------------------------------
2218     @DataProvider(name=&quot;sampleMinusWeeksSymmetry&quot;)
2219     Object[][] provider_sampleMinusWeeksSymmetry() {
2220         return new Object[][] {
2221             {createDateMidnight(-1, 1, 1)},
2222             {createDateMidnight(-1, 2, 28)},
2223             {createDateMidnight(-1, 3, 1)},
2224             {createDateMidnight(-1, 12, 31)},
2225             {createDateMidnight(0, 1, 1)},
2226             {createDateMidnight(0, 2, 28)},
2227             {createDateMidnight(0, 2, 29)},
2228             {createDateMidnight(0, 3, 1)},
2229             {createDateMidnight(0, 12, 31)},
2230             {createDateMidnight(2007, 1, 1)},
2231             {createDateMidnight(2007, 2, 28)},
2232             {createDateMidnight(2007, 3, 1)},
2233             {createDateMidnight(2007, 12, 31)},
2234             {createDateMidnight(2008, 1, 1)},
2235             {createDateMidnight(2008, 2, 28)},
2236             {createDateMidnight(2008, 2, 29)},
2237             {createDateMidnight(2008, 3, 1)},
2238             {createDateMidnight(2008, 12, 31)},
2239             {createDateMidnight(2099, 1, 1)},
2240             {createDateMidnight(2099, 2, 28)},
2241             {createDateMidnight(2099, 3, 1)},
2242             {createDateMidnight(2099, 12, 31)},
2243             {createDateMidnight(2100, 1, 1)},
2244             {createDateMidnight(2100, 2, 28)},
2245             {createDateMidnight(2100, 3, 1)},
2246             {createDateMidnight(2100, 12, 31)},
2247         };
2248     }
2249 
2250     @Test(dataProvider=&quot;sampleMinusWeeksSymmetry&quot;)
2251     public void test_minusWeeks_symmetry(LocalDateTime reference) {
2252         for (int weeks = 0; weeks &lt; 365 * 8; weeks++) {
2253             LocalDateTime t = reference.minusWeeks(weeks).minusWeeks(-weeks);
2254             assertEquals(t, reference);
2255 
2256             t = reference.minusWeeks(-weeks).minusWeeks(weeks);
2257             assertEquals(t, reference);
2258         }
2259     }
2260 
2261     @Test
2262     public void test_minusWeeks_normal() {
2263         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusWeeks(1);
2264         check(t, 2007, 7, 8, 12, 30, 40, 987654321);
2265     }
2266 
2267     @Test
2268     public void test_minusWeeks_overMonths() {
2269         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusWeeks(9);
2270         check(t, 2007, 5, 13, 12, 30, 40, 987654321);
2271     }
2272 
2273     @Test
2274     public void test_minusWeeks_overYears() {
2275         LocalDateTime t = LocalDateTime.of(2008, 7, 13, 12, 30, 40, 987654321).minusWeeks(52);
2276         assertEquals(t, TEST_2007_07_15_12_30_40_987654321);
2277     }
2278 
2279     @Test
2280     public void test_minusWeeks_overLeapYears() {
2281         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusYears(-1).minusWeeks(104);
2282         check(t, 2006, 7, 18, 12, 30, 40, 987654321);
2283     }
2284 
2285     @Test
2286     public void test_minusWeeks_negative() {
2287         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusWeeks(-1);
2288         check(t, 2007, 7, 22, 12, 30, 40, 987654321);
2289     }
2290 
2291     @Test
2292     public void test_minusWeeks_negativeAcrossYear() {
2293         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusWeeks(-28);
2294         check(t, 2008, 1, 27, 12, 30, 40, 987654321);
2295     }
2296 
2297     @Test
2298     public void test_minusWeeks_negativeOverYears() {
2299         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusWeeks(-104);
2300         check(t, 2009, 7, 12, 12, 30, 40, 987654321);
2301     }
2302 
2303     @Test
2304     public void test_minusWeeks_maximum() {
2305         LocalDateTime t = createDateMidnight(Year.MAX_VALUE, 12, 24).minusWeeks(-1);
2306         check(t, Year.MAX_VALUE, 12, 31, 0, 0, 0, 0);
2307     }
2308 
2309     @Test
2310     public void test_minusWeeks_minimum() {
2311         LocalDateTime t = createDateMidnight(Year.MIN_VALUE, 1, 8).minusWeeks(1);
2312         check(t, Year.MIN_VALUE, 1, 1, 0, 0, 0, 0);
2313     }
2314 
2315     @Test(expectedExceptions=DateTimeException.class)
2316     public void test_minusWeeks_invalidTooLarge() {
2317         createDateMidnight(Year.MAX_VALUE, 12, 25).minusWeeks(-1);
2318     }
2319 
2320     @Test(expectedExceptions=DateTimeException.class)
2321     public void test_minusWeeks_invalidTooSmall() {
2322         createDateMidnight(Year.MIN_VALUE, 1, 7).minusWeeks(1);
2323     }
2324 
2325     //-----------------------------------------------------------------------
2326     // minusDays()
2327     //-----------------------------------------------------------------------
2328     @DataProvider(name=&quot;sampleMinusDaysSymmetry&quot;)
2329     Object[][] provider_sampleMinusDaysSymmetry() {
2330         return new Object[][] {
2331             {createDateMidnight(-1, 1, 1)},
2332             {createDateMidnight(-1, 2, 28)},
2333             {createDateMidnight(-1, 3, 1)},
2334             {createDateMidnight(-1, 12, 31)},
2335             {createDateMidnight(0, 1, 1)},
2336             {createDateMidnight(0, 2, 28)},
2337             {createDateMidnight(0, 2, 29)},
2338             {createDateMidnight(0, 3, 1)},
2339             {createDateMidnight(0, 12, 31)},
2340             {createDateMidnight(2007, 1, 1)},
2341             {createDateMidnight(2007, 2, 28)},
2342             {createDateMidnight(2007, 3, 1)},
2343             {createDateMidnight(2007, 12, 31)},
2344             {createDateMidnight(2008, 1, 1)},
2345             {createDateMidnight(2008, 2, 28)},
2346             {createDateMidnight(2008, 2, 29)},
2347             {createDateMidnight(2008, 3, 1)},
2348             {createDateMidnight(2008, 12, 31)},
2349             {createDateMidnight(2099, 1, 1)},
2350             {createDateMidnight(2099, 2, 28)},
2351             {createDateMidnight(2099, 3, 1)},
2352             {createDateMidnight(2099, 12, 31)},
2353             {createDateMidnight(2100, 1, 1)},
2354             {createDateMidnight(2100, 2, 28)},
2355             {createDateMidnight(2100, 3, 1)},
2356             {createDateMidnight(2100, 12, 31)},
2357         };
2358     }
2359 
2360     @Test(dataProvider=&quot;sampleMinusDaysSymmetry&quot;)
2361     public void test_minusDays_symmetry(LocalDateTime reference) {
2362         for (int days = 0; days &lt; 365 * 8; days++) {
2363             LocalDateTime t = reference.minusDays(days).minusDays(-days);
2364             assertEquals(t, reference);
2365 
2366             t = reference.minusDays(-days).minusDays(days);
2367             assertEquals(t, reference);
2368         }
2369     }
2370 
2371     @Test
2372     public void test_minusDays_normal() {
2373         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusDays(1);
2374         check(t, 2007, 7, 14, 12, 30, 40, 987654321);
2375     }
2376 
2377     @Test
2378     public void test_minusDays_overMonths() {
2379         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusDays(62);
2380         check(t, 2007, 5, 14, 12, 30, 40, 987654321);
2381     }
2382 
2383     @Test
2384     public void test_minusDays_overYears() {
2385         LocalDateTime t = LocalDateTime.of(2008, 7, 16, 12, 30, 40, 987654321).minusDays(367);
2386         assertEquals(t, TEST_2007_07_15_12_30_40_987654321);
2387     }
2388 
2389     @Test
2390     public void test_minusDays_overLeapYears() {
2391         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.plusYears(2).minusDays(365 + 366);
2392         assertEquals(t, TEST_2007_07_15_12_30_40_987654321);
2393     }
2394 
2395     @Test
2396     public void test_minusDays_negative() {
2397         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusDays(-1);
2398         check(t, 2007, 7, 16, 12, 30, 40, 987654321);
2399     }
2400 
2401     @Test
2402     public void test_minusDays_negativeAcrossYear() {
2403         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusDays(-169);
2404         check(t, 2007, 12, 31, 12, 30, 40, 987654321);
2405     }
2406 
2407     @Test
2408     public void test_minusDays_negativeOverYears() {
2409         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusDays(-731);
2410         check(t, 2009, 7, 15, 12, 30, 40, 987654321);
2411     }
2412 
2413     @Test
2414     public void test_minusDays_maximum() {
2415         LocalDateTime t = createDateMidnight(Year.MAX_VALUE, 12, 30).minusDays(-1);
2416         check(t, Year.MAX_VALUE, 12, 31, 0, 0, 0, 0);
2417     }
2418 
2419     @Test
2420     public void test_minusDays_minimum() {
2421         LocalDateTime t = createDateMidnight(Year.MIN_VALUE, 1, 2).minusDays(1);
2422         check(t, Year.MIN_VALUE, 1, 1, 0, 0, 0, 0);
2423     }
2424 
2425     @Test(expectedExceptions=DateTimeException.class)
2426     public void test_minusDays_invalidTooLarge() {
2427         createDateMidnight(Year.MAX_VALUE, 12, 31).minusDays(-1);
2428     }
2429 
2430     @Test(expectedExceptions=DateTimeException.class)
2431     public void test_minusDays_invalidTooSmall() {
2432         createDateMidnight(Year.MIN_VALUE, 1, 1).minusDays(1);
2433     }
2434 
2435     @Test(expectedExceptions=ArithmeticException.class)
2436     public void test_minusDays_overflowTooLarge() {
2437         createDateMidnight(Year.MAX_VALUE, 12, 31).minusDays(Long.MIN_VALUE);
2438     }
2439 
2440     @Test(expectedExceptions=ArithmeticException.class)
2441     public void test_minusDays_overflowTooSmall() {
2442         createDateMidnight(Year.MIN_VALUE, 1, 1).minusDays(Long.MAX_VALUE);
2443     }
2444 
2445     //-----------------------------------------------------------------------
2446     // minusHours()
2447     //-----------------------------------------------------------------------
2448     @Test
2449     public void test_minusHours_one() {
2450         LocalDateTime t =TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
2451         LocalDate d = t.toLocalDate();
2452 
2453         for (int i = 0; i &lt; 50; i++) {
2454             t = t.minusHours(1);
2455 
2456             if (i % 24 == 0) {
2457                 d = d.minusDays(1);
2458             }
2459 
2460             assertEquals(t.toLocalDate(), d);
2461             assertEquals(t.getHour(), (((-i + 23) % 24) + 24) % 24);
2462         }
2463     }
2464 
2465     @Test
2466     public void test_minusHours_fromZero() {
2467         LocalDateTime base = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
2468         LocalDate d = base.toLocalDate().plusDays(2);
2469         LocalTime t = LocalTime.of(3, 0);
2470 
2471         for (int i = -50; i &lt; 50; i++) {
2472             LocalDateTime dt = base.minusHours(i);
2473             t = t.minusHours(1);
2474 
2475             if (t.getHour() == 23) {
2476                 d = d.minusDays(1);
2477             }
2478 
2479             assertEquals(dt.toLocalDate(), d, String.valueOf(i));
2480             assertEquals(dt.toLocalTime(), t);
2481         }
2482     }
2483 
2484     @Test
2485     public void test_minusHours_fromOne() {
2486         LocalDateTime base = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.of(1, 0));
2487         LocalDate d = base.toLocalDate().plusDays(2);
2488         LocalTime t = LocalTime.of(4, 0);
2489 
2490         for (int i = -50; i &lt; 50; i++) {
2491             LocalDateTime dt = base.minusHours(i);
2492 
2493             t = t.minusHours(1);
2494 
2495             if (t.getHour() == 23) {
2496                 d = d.minusDays(1);
2497             }
2498 
2499             assertEquals(dt.toLocalDate(), d, String.valueOf(i));
2500             assertEquals(dt.toLocalTime(), t);
2501         }
2502     }
2503 
2504     //-----------------------------------------------------------------------
2505     // minusMinutes()
2506     //-----------------------------------------------------------------------
2507     @Test
2508     public void test_minusMinutes_one() {
2509         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
2510         LocalDate d = t.toLocalDate().minusDays(1);
2511 
2512         int hour = 0;
2513         int min = 0;
2514 
2515         for (int i = 0; i &lt; 70; i++) {
2516             t = t.minusMinutes(1);
2517             min--;
2518             if (min == -1) {
2519                 hour--;
2520                 min = 59;
2521 
2522                 if (hour == -1) {
2523                     hour = 23;
2524                 }
2525             }
2526             assertEquals(t.toLocalDate(), d);
2527             assertEquals(t.getHour(), hour);
2528             assertEquals(t.getMinute(), min);
2529         }
2530     }
2531 
2532     @Test
2533     public void test_minusMinutes_fromZero() {
2534         LocalDateTime base = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
2535         LocalDate d = base.toLocalDate().minusDays(1);
2536         LocalTime t = LocalTime.of(22, 49);
2537 
2538         for (int i = 70; i &gt; -70; i--) {
2539             LocalDateTime dt = base.minusMinutes(i);
2540             t = t.plusMinutes(1);
2541 
2542             if (t.equals(LocalTime.MIDNIGHT)) {
2543                 d = d.plusDays(1);
2544             }
2545 
2546             assertEquals(dt.toLocalDate(), d);
2547             assertEquals(dt.toLocalTime(), t);
2548         }
2549     }
2550 
2551     @Test
2552     public void test_minusMinutes_noChange_oneDay() {
2553         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.minusMinutes(24 * 60);
2554         assertEquals(t.toLocalDate(), TEST_2007_07_15_12_30_40_987654321.toLocalDate().minusDays(1));
2555     }
2556 
2557     //-----------------------------------------------------------------------
2558     // minusSeconds()
2559     //-----------------------------------------------------------------------
2560     @Test
2561     public void test_minusSeconds_one() {
2562         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
2563         LocalDate d = t.toLocalDate().minusDays(1);
2564 
2565         int hour = 0;
2566         int min = 0;
2567         int sec = 0;
2568 
2569         for (int i = 0; i &lt; 3700; i++) {
2570             t = t.minusSeconds(1);
2571             sec--;
2572             if (sec == -1) {
2573                 min--;
2574                 sec = 59;
2575 
2576                 if (min == -1) {
2577                     hour--;
2578                     min = 59;
2579 
2580                     if (hour == -1) {
2581                         hour = 23;
2582                     }
2583                 }
2584             }
2585 
2586             assertEquals(t.toLocalDate(), d);
2587             assertEquals(t.getHour(), hour);
2588             assertEquals(t.getMinute(), min);
2589             assertEquals(t.getSecond(), sec);
2590         }
2591     }
2592 
2593     @DataProvider(name=&quot;minusSeconds_fromZero&quot;)
2594     Iterator&lt;Object[]&gt; minusSeconds_fromZero() {
2595         return new Iterator&lt;Object[]&gt;() {
2596             int delta = 30;
2597 
2598             int i = 3660;
2599             LocalDate date = TEST_2007_07_15_12_30_40_987654321.toLocalDate().minusDays(1);
2600             int hour = 22;
2601             int min = 59;
2602             int sec = 0;
2603 
2604             public boolean hasNext() {
2605                 return i &gt;= -3660;
2606             }
2607 
2608             public Object[] next() {
2609                 final Object[] ret = new Object[] {i, date, hour, min, sec};
2610                 i -= delta;
2611                 sec += delta;
2612 
2613                 if (sec &gt;= 60) {
2614                     min++;
2615                     sec -= 60;
2616 
2617                     if (min == 60) {
2618                         hour++;
2619                         min = 0;
2620 
2621                         if (hour == 24) {
2622                             hour = 0;
2623                         }
2624                     }
2625                 }
2626 
2627                 if (i == 0) {
2628                     date = date.plusDays(1);
2629                 }
2630 
2631                 return ret;
2632             }
2633 
2634             public void remove() {
2635                 throw new UnsupportedOperationException();
2636             }
2637         };
2638     }
2639 
2640     @Test(dataProvider=&quot;minusSeconds_fromZero&quot;)
2641     public void test_minusSeconds_fromZero(int seconds, LocalDate date, int hour, int min, int sec) {
2642         LocalDateTime base = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
2643         LocalDateTime t = base.minusSeconds(seconds);
2644 
2645         assertEquals(date, t.toLocalDate());
2646         assertEquals(hour, t.getHour());
2647         assertEquals(min, t.getMinute());
2648         assertEquals(sec, t.getSecond());
2649     }
2650 
2651     //-----------------------------------------------------------------------
2652     // minusNanos()
2653     //-----------------------------------------------------------------------
2654     @Test
2655     public void test_minusNanos_halfABillion() {
2656         LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
2657         LocalDate d = t.toLocalDate().minusDays(1);
2658 
2659         int hour = 0;
2660         int min = 0;
2661         int sec = 0;
2662         int nanos = 0;
2663 
2664         for (long i = 0; i &lt; 3700 * 1000000000L; i+= 500000000) {
2665             t = t.minusNanos(500000000);
2666             nanos -= 500000000;
2667 
2668             if (nanos &lt; 0) {
2669                 sec--;
2670                 nanos += 1000000000;
2671 
2672                 if (sec == -1) {
2673                     min--;
2674                     sec += 60;
2675 
2676                     if (min == -1) {
2677                         hour--;
2678                         min += 60;
2679 
2680                         if (hour == -1) {
2681                             hour += 24;
2682                         }
2683                     }
2684                 }
2685             }
2686 
2687             assertEquals(t.toLocalDate(), d);
2688             assertEquals(t.getHour(), hour);
2689             assertEquals(t.getMinute(), min);
2690             assertEquals(t.getSecond(), sec);
2691             assertEquals(t.getNano(), nanos);
2692         }
2693     }
2694 
2695     @DataProvider(name=&quot;minusNanos_fromZero&quot;)
2696     Iterator&lt;Object[]&gt; minusNanos_fromZero() {
2697         return new Iterator&lt;Object[]&gt;() {
2698             long delta = 7500000000L;
2699 
2700             long i = 3660 * 1000000000L;
2701             LocalDate date = TEST_2007_07_15_12_30_40_987654321.toLocalDate().minusDays(1);
2702             int hour = 22;
2703             int min = 59;
2704             int sec = 0;
2705             long nanos = 0;
2706 
2707             public boolean hasNext() {
2708                 return i &gt;= -3660 * 1000000000L;
2709             }
2710 
2711             public Object[] next() {
2712                 final Object[] ret = new Object[] {i, date, hour, min, sec, (int)nanos};
2713                 i -= delta;
2714                 nanos += delta;
2715 
2716                 if (nanos &gt;= 1000000000L) {
2717                     sec += nanos / 1000000000L;
2718                     nanos %= 1000000000L;
2719 
2720                     if (sec &gt;= 60) {
2721                         min++;
2722                         sec %= 60;
2723 
2724                         if (min == 60) {
2725                             hour++;
2726                             min = 0;
2727 
2728                             if (hour == 24) {
2729                                 hour = 0;
2730                                 date = date.plusDays(1);
2731                             }
2732                         }
2733                     }
2734                 }
2735 
2736                 return ret;
2737             }
2738 
2739             public void remove() {
2740                 throw new UnsupportedOperationException();
2741             }
2742         };
2743     }
2744 
2745     @Test(dataProvider=&quot;minusNanos_fromZero&quot;)
2746     public void test_minusNanos_fromZero(long nanoseconds, LocalDate date, int hour, int min, int sec, int nanos) {
2747         LocalDateTime base = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT);
2748         LocalDateTime t = base.minusNanos(nanoseconds);
2749 
2750         assertEquals(date, t.toLocalDate());
2751         assertEquals(hour, t.getHour());
2752         assertEquals(min, t.getMinute());
2753         assertEquals(sec, t.getSecond());
2754         assertEquals(nanos, t.getNano());
2755     }
2756 
2757     //-----------------------------------------------------------------------
2758     // until(Temporal, TemporalUnit)
2759     //-----------------------------------------------------------------------
2760     @DataProvider(name=&quot;periodUntilUnit&quot;)
2761     Object[][] data_periodUntilUnit() {
2762         return new Object[][] {
2763                 // date only
2764                 {dtNoon(2000, 1, 1), dtNoon(2000, 1, 1), DAYS, 0},
2765                 {dtNoon(2000, 1, 1), dtNoon(2000, 1, 1), WEEKS, 0},
2766                 {dtNoon(2000, 1, 1), dtNoon(2000, 1, 1), MONTHS, 0},
2767                 {dtNoon(2000, 1, 1), dtNoon(2000, 1, 1), YEARS, 0},
2768                 {dtNoon(2000, 1, 1), dtNoon(2000, 1, 1), DECADES, 0},
2769                 {dtNoon(2000, 1, 1), dtNoon(2000, 1, 1), CENTURIES, 0},
2770                 {dtNoon(2000, 1, 1), dtNoon(2000, 1, 1), MILLENNIA, 0},
2771 
2772                 {dtNoon(2000, 1, 15), dtNoon(2000, 2, 14), DAYS, 30},
2773                 {dtNoon(2000, 1, 15), dtNoon(2000, 2, 15), DAYS, 31},
2774                 {dtNoon(2000, 1, 15), dtNoon(2000, 2, 16), DAYS, 32},
2775 
2776                 {dtNoon(2000, 1, 15), dtNoon(2000, 2, 17), WEEKS, 4},
2777                 {dtNoon(2000, 1, 15), dtNoon(2000, 2, 18), WEEKS, 4},
2778                 {dtNoon(2000, 1, 15), dtNoon(2000, 2, 19), WEEKS, 5},
2779                 {dtNoon(2000, 1, 15), dtNoon(2000, 2, 20), WEEKS, 5},
2780 
2781                 {dtNoon(2000, 1, 15), dtNoon(2000, 2, 14), MONTHS, 0},
2782                 {dtNoon(2000, 1, 15), dtNoon(2000, 2, 15), MONTHS, 1},
2783                 {dtNoon(2000, 1, 15), dtNoon(2000, 2, 16), MONTHS, 1},
2784                 {dtNoon(2000, 1, 15), dtNoon(2000, 3, 14), MONTHS, 1},
2785                 {dtNoon(2000, 1, 15), dtNoon(2000, 3, 15), MONTHS, 2},
2786                 {dtNoon(2000, 1, 15), dtNoon(2000, 3, 16), MONTHS, 2},
2787 
2788                 {dtNoon(2000, 1, 15), dtNoon(2001, 1, 14), YEARS, 0},
2789                 {dtNoon(2000, 1, 15), dtNoon(2001, 1, 15), YEARS, 1},
2790                 {dtNoon(2000, 1, 15), dtNoon(2001, 1, 16), YEARS, 1},
2791                 {dtNoon(2000, 1, 15), dtNoon(2004, 1, 14), YEARS, 3},
2792                 {dtNoon(2000, 1, 15), dtNoon(2004, 1, 15), YEARS, 4},
2793                 {dtNoon(2000, 1, 15), dtNoon(2004, 1, 16), YEARS, 4},
2794 
2795                 {dtNoon(2000, 1, 15), dtNoon(2010, 1, 14), DECADES, 0},
2796                 {dtNoon(2000, 1, 15), dtNoon(2010, 1, 15), DECADES, 1},
2797 
2798                 {dtNoon(2000, 1, 15), dtNoon(2100, 1, 14), CENTURIES, 0},
2799                 {dtNoon(2000, 1, 15), dtNoon(2100, 1, 15), CENTURIES, 1},
2800 
2801                 {dtNoon(2000, 1, 15), dtNoon(3000, 1, 14), MILLENNIA, 0},
2802                 {dtNoon(2000, 1, 15), dtNoon(3000, 1, 15), MILLENNIA, 1},
2803 
2804                 // time only
2805                 {dtEpoch(0, 0, 0, 0), dtEpoch(0, 0, 0, 0), NANOS, 0},
2806                 {dtEpoch(0, 0, 0, 0), dtEpoch(0, 0, 0, 0), MICROS, 0},
2807                 {dtEpoch(0, 0, 0, 0), dtEpoch(0, 0, 0, 0), MILLIS, 0},
2808                 {dtEpoch(0, 0, 0, 0), dtEpoch(0, 0, 0, 0), SECONDS, 0},
2809                 {dtEpoch(0, 0, 0, 0), dtEpoch(0, 0, 0, 0), MINUTES, 0},
2810                 {dtEpoch(0, 0, 0, 0), dtEpoch(0, 0, 0, 0), HOURS, 0},
2811                 {dtEpoch(0, 0, 0, 0), dtEpoch(0, 0, 0, 0), HALF_DAYS, 0},
2812 
2813                 {dtEpoch(0, 0, 0, 0), dtEpoch(2, 0, 0, 0), NANOS, 2 * 3600 * 1_000_000_000L},
2814                 {dtEpoch(0, 0, 0, 0), dtEpoch(2, 0, 0, 0), MICROS, 2 * 3600 * 1_000_000L},
2815                 {dtEpoch(0, 0, 0, 0), dtEpoch(2, 0, 0, 0), MILLIS, 2 * 3600 * 1_000L},
2816                 {dtEpoch(0, 0, 0, 0), dtEpoch(2, 0, 0, 0), SECONDS, 2 * 3600},
2817                 {dtEpoch(0, 0, 0, 0), dtEpoch(2, 0, 0, 0), MINUTES, 2 * 60},
2818                 {dtEpoch(0, 0, 0, 0), dtEpoch(2, 0, 0, 0), HOURS, 2},
2819                 {dtEpoch(0, 0, 0, 0), dtEpoch(2, 0, 0, 0), HALF_DAYS, 0},
2820 
2821                 {dtEpoch(0, 0, 0, 0), dtEpoch(14, 0, 0, 0), NANOS, 14 * 3600 * 1_000_000_000L},
2822                 {dtEpoch(0, 0, 0, 0), dtEpoch(14, 0, 0, 0), MICROS, 14 * 3600 * 1_000_000L},
2823                 {dtEpoch(0, 0, 0, 0), dtEpoch(14, 0, 0, 0), MILLIS, 14 * 3600 * 1_000L},
2824                 {dtEpoch(0, 0, 0, 0), dtEpoch(14, 0, 0, 0), SECONDS, 14 * 3600},
2825                 {dtEpoch(0, 0, 0, 0), dtEpoch(14, 0, 0, 0), MINUTES, 14 * 60},
2826                 {dtEpoch(0, 0, 0, 0), dtEpoch(14, 0, 0, 0), HOURS, 14},
2827                 {dtEpoch(0, 0, 0, 0), dtEpoch(14, 0, 0, 0), HALF_DAYS, 1},
2828 
2829                 {dtEpoch(0, 0, 0, 0), dtEpoch(2, 30, 40, 1500), NANOS, (2 * 3600 + 30 * 60 + 40) * 1_000_000_000L + 1500},
2830                 {dtEpoch(0, 0, 0, 0), dtEpoch(2, 30, 40, 1500), MICROS, (2 * 3600 + 30 * 60 + 40) * 1_000_000L + 1},
2831                 {dtEpoch(0, 0, 0, 0), dtEpoch(2, 30, 40, 1500), MILLIS, (2 * 3600 + 30 * 60 + 40) * 1_000L},
2832                 {dtEpoch(0, 0, 0, 0), dtEpoch(2, 30, 40, 1500), SECONDS, 2 * 3600 + 30 * 60 + 40},
2833                 {dtEpoch(0, 0, 0, 0), dtEpoch(2, 30, 40, 1500), MINUTES, 2 * 60 + 30},
2834                 {dtEpoch(0, 0, 0, 0), dtEpoch(2, 30, 40, 1500), HOURS, 2},
2835 
2836                 // combinations
2837                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 15, 12, 30, 40, 499), NANOS, -1},
2838                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 15, 12, 30, 40, 500), NANOS, 0},
2839                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 15, 12, 30, 40, 501), NANOS, 1},
2840 
2841                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 15, 12, 30, 39, 500), SECONDS, -1},
2842                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 15, 12, 30, 39, 501), SECONDS, 0},
2843                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 15, 12, 30, 40, 499), SECONDS, 0},
2844                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 15, 12, 30, 40, 500), SECONDS, 0},
2845                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 15, 12, 30, 40, 501), SECONDS, 0},
2846                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 15, 12, 30, 41, 499), SECONDS, 0},
2847                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 15, 12, 30, 41, 500), SECONDS, 1},
2848 
2849                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 499), NANOS, -1 + 86400_000_000_000L},
2850                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 500), NANOS, 0 + 86400_000_000_000L},
2851                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 501), NANOS, 1 + 86400_000_000_000L},
2852 
2853                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 39, 499), SECONDS, -2 + 86400L},
2854                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 39, 500), SECONDS, -1 + 86400L},
2855                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 39, 501), SECONDS, -1 + 86400L},
2856                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 499), SECONDS, -1 + 86400L},
2857                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 500), SECONDS, 0 + 86400L},
2858                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 501), SECONDS, 0 + 86400L},
2859                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 41, 499), SECONDS, 0 + 86400L},
2860                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 41, 500), SECONDS, 1 + 86400L},
2861 
2862                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 29, 40, 499), MINUTES, -2 + 24 * 60L},
2863                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 29, 40, 500), MINUTES, -1 + 24 * 60L},
2864                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 29, 40, 501), MINUTES, -1 + 24 * 60L},
2865                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 499), MINUTES, -1 + 24 * 60L},
2866                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 500), MINUTES, 0 + 24 * 60L},
2867                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 501), MINUTES, 0 + 24 * 60L},
2868                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 31, 40, 499), MINUTES, 0 + 24 * 60L},
2869                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 31, 40, 500), MINUTES, 1 + 24 * 60L},
2870 
2871                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 11, 30, 40, 499), HOURS, -2 + 24L},
2872                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 11, 30, 40, 500), HOURS, -1 + 24L},
2873                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 11, 30, 40, 501), HOURS, -1 + 24L},
2874                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 499), HOURS, -1 + 24L},
2875                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 500), HOURS, 0 + 24L},
2876                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 501), HOURS, 0 + 24L},
2877                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 13, 30, 40, 499), HOURS, 0 + 24L},
2878                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 13, 30, 40, 500), HOURS, 1 + 24L},
2879 
2880                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 13, 12, 30, 40, 499), DAYS, -2},
2881                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 13, 12, 30, 40, 500), DAYS, -2},
2882                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 13, 12, 30, 40, 501), DAYS, -1},
2883                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 14, 12, 30, 40, 499), DAYS, -1},
2884                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 14, 12, 30, 40, 500), DAYS, -1},
2885                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 14, 12, 30, 40, 501), DAYS, 0},
2886                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 15, 12, 30, 40, 499), DAYS, 0},
2887                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 15, 12, 30, 40, 500), DAYS, 0},
2888                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 15, 12, 30, 40, 501), DAYS, 0},
2889                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 499), DAYS, 0},
2890                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 500), DAYS, 1},
2891                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 16, 12, 30, 40, 501), DAYS, 1},
2892                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 17, 12, 30, 40, 499), DAYS, 1},
2893                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 17, 12, 30, 40, 500), DAYS, 2},
2894                 {dt(2000, 1, 15, 12, 30, 40, 500), dt(2000, 1, 17, 12, 30, 40, 501), DAYS, 2},
2895         };
2896     }
2897 
2898     @Test(dataProvider=&quot;periodUntilUnit&quot;)
2899     public void test_until_TemporalUnit(LocalDateTime dt1, LocalDateTime dt2, TemporalUnit unit, long expected) {
2900         long amount = dt1.until(dt2, unit);
2901         assertEquals(amount, expected);
2902     }
2903 
2904     @Test(dataProvider=&quot;periodUntilUnit&quot;)
2905     public void test_until_TemporalUnit_negated(LocalDateTime dt1, LocalDateTime dt2, TemporalUnit unit, long expected) {
2906         long amount = dt2.until(dt1, unit);
2907         assertEquals(amount, -expected);
2908     }
2909 
2910     @Test(dataProvider=&quot;periodUntilUnit&quot;)
2911     public void test_until_TemporalUnit_between(LocalDateTime dt1, LocalDateTime dt2, TemporalUnit unit, long expected) {
2912         long amount = unit.between(dt1, dt2);
2913         assertEquals(amount, expected);
2914     }
2915 
2916     @Test
2917     public void test_until_convertedType() {
2918         LocalDateTime start = LocalDateTime.of(2010, 6, 30, 2, 30);
2919         OffsetDateTime end = start.plusDays(2).atOffset(OFFSET_PONE);
2920         assertEquals(start.until(end, DAYS), 2);
2921     }
2922 
2923     @Test(expectedExceptions=DateTimeException.class)
2924     public void test_until_invalidType() {
2925         LocalDateTime start = LocalDateTime.of(2010, 6, 30, 2, 30);
2926         start.until(LocalTime.of(11, 30), DAYS);
2927     }
2928 
2929     @Test(expectedExceptions = NullPointerException.class)
2930     public void test_until_TemporalUnit_nullEnd() {
2931         TEST_2007_07_15_12_30_40_987654321.until(null, HOURS);
2932     }
2933 
2934     @Test(expectedExceptions = NullPointerException.class)
2935     public void test_until_TemporalUnit_nullUnit() {
2936         TEST_2007_07_15_12_30_40_987654321.until(TEST_2007_07_15_12_30_40_987654321, null);
2937     }
2938 
2939     //-----------------------------------------------------------------------
2940     // format(DateTimeFormatter)
2941     //-----------------------------------------------------------------------
2942     @Test
2943     public void test_format_formatter() {
2944         DateTimeFormatter f = DateTimeFormatter.ofPattern(&quot;y M d H m s&quot;);
2945         String t = LocalDateTime.of(2010, 12, 3, 11, 30, 45).format(f);
2946         assertEquals(t, &quot;2010 12 3 11 30 45&quot;);
2947     }
2948 
2949     @Test(expectedExceptions=NullPointerException.class)
2950     public void test_format_formatter_null() {
2951         LocalDateTime.of(2010, 12, 3, 11, 30, 45).format(null);
2952     }
2953 
2954     //-----------------------------------------------------------------------
2955     // atOffset()
2956     //-----------------------------------------------------------------------
2957     @Test
2958     public void test_atOffset() {
2959         LocalDateTime t = LocalDateTime.of(2008, 6, 30, 11, 30);
2960         assertEquals(t.atOffset(OFFSET_PTWO), OffsetDateTime.of(LocalDateTime.of(2008, 6, 30, 11, 30), OFFSET_PTWO));
2961     }
2962 
2963     @Test(expectedExceptions=NullPointerException.class)
2964     public void test_atOffset_nullZoneOffset() {
2965         LocalDateTime t = LocalDateTime.of(2008, 6, 30, 11, 30);
2966         t.atOffset((ZoneOffset) null);
2967     }
2968 
2969     //-----------------------------------------------------------------------
2970     // atZone()
2971     //-----------------------------------------------------------------------
2972     @Test
2973     public void test_atZone() {
2974         LocalDateTime t = LocalDateTime.of(2008, 6, 30, 11, 30);
2975         assertEquals(t.atZone(ZONE_PARIS),
2976                 ZonedDateTime.of(LocalDateTime.of(2008, 6, 30, 11, 30), ZONE_PARIS));
2977     }
2978 
2979     @Test
2980     public void test_atZone_Offset() {
2981         LocalDateTime t = LocalDateTime.of(2008, 6, 30, 11, 30);
2982         assertEquals(t.atZone(OFFSET_PTWO), ZonedDateTime.of(LocalDateTime.of(2008, 6, 30, 11, 30), OFFSET_PTWO));
2983     }
2984 
2985     @Test
2986     public void test_atZone_dstGap() {
2987         LocalDateTime t = LocalDateTime.of(2007, 4, 1, 0, 0);
2988         assertEquals(t.atZone(ZONE_GAZA),
2989                 ZonedDateTime.of(LocalDateTime.of(2007, 4, 1, 1, 0), ZONE_GAZA));
2990     }
2991 
2992     @Test
2993     public void test_atZone_dstOverlap() {
2994         LocalDateTime t = LocalDateTime.of(2007, 10, 28, 2, 30);
2995         assertEquals(t.atZone(ZONE_PARIS),
2996                 ZonedDateTime.ofStrict(LocalDateTime.of(2007, 10, 28, 2, 30), OFFSET_PTWO, ZONE_PARIS));
2997     }
2998 
2999     @Test(expectedExceptions=NullPointerException.class)
3000     public void test_atZone_nullTimeZone() {
3001         LocalDateTime t = LocalDateTime.of(2008, 6, 30, 11, 30);
3002         t.atZone((ZoneId) null);
3003     }
3004 
3005     //-----------------------------------------------------------------------
3006     // toEpochSecond()
3007     //-----------------------------------------------------------------------
3008     @Test
3009     public void test_toEpochSecond_afterEpoch() {
3010         for (int i = -5; i &lt; 5; i++) {
3011             ZoneOffset offset = ZoneOffset.ofHours(i);
3012             for (int j = 0; j &lt; 100000; j++) {
3013                 LocalDateTime a = LocalDateTime.of(1970, 1, 1, 0, 0).plusSeconds(j);
3014                 assertEquals(a.toEpochSecond(offset), j - i * 3600);
3015             }
3016         }
3017     }
3018 
3019     @Test
3020     public void test_toEpochSecond_beforeEpoch() {
3021         for (int i = 0; i &lt; 100000; i++) {
3022             LocalDateTime a = LocalDateTime.of(1970, 1, 1, 0, 0).minusSeconds(i);
3023             assertEquals(a.toEpochSecond(ZoneOffset.UTC), -i);
3024         }
3025     }
3026 
3027     //-----------------------------------------------------------------------
3028     // compareTo()
3029     //-----------------------------------------------------------------------
3030     @Test
3031     public void test_comparisons() {
3032         test_comparisons_LocalDateTime(
3033                 LocalDate.of(Year.MIN_VALUE, 1, 1),
3034                 LocalDate.of(Year.MIN_VALUE, 12, 31),
3035                 LocalDate.of(-1, 1, 1),
3036                 LocalDate.of(-1, 12, 31),
3037                 LocalDate.of(0, 1, 1),
3038                 LocalDate.of(0, 12, 31),
3039                 LocalDate.of(1, 1, 1),
3040                 LocalDate.of(1, 12, 31),
3041                 LocalDate.of(2008, 1, 1),
3042                 LocalDate.of(2008, 2, 29),
3043                 LocalDate.of(2008, 12, 31),
3044                 LocalDate.of(Year.MAX_VALUE, 1, 1),
3045                 LocalDate.of(Year.MAX_VALUE, 12, 31)
3046         );
3047     }
3048 
3049     void test_comparisons_LocalDateTime(LocalDate... localDates) {
3050         test_comparisons_LocalDateTime(
3051             localDates,
3052             LocalTime.MIDNIGHT,
3053             LocalTime.of(0, 0, 0, 999999999),
3054             LocalTime.of(0, 0, 59, 0),
3055             LocalTime.of(0, 0, 59, 999999999),
3056             LocalTime.of(0, 59, 0, 0),
3057             LocalTime.of(0, 59, 59, 999999999),
3058             LocalTime.NOON,
3059             LocalTime.of(12, 0, 0, 999999999),
3060             LocalTime.of(12, 0, 59, 0),
3061             LocalTime.of(12, 0, 59, 999999999),
3062             LocalTime.of(12, 59, 0, 0),
3063             LocalTime.of(12, 59, 59, 999999999),
3064             LocalTime.of(23, 0, 0, 0),
3065             LocalTime.of(23, 0, 0, 999999999),
3066             LocalTime.of(23, 0, 59, 0),
3067             LocalTime.of(23, 0, 59, 999999999),
3068             LocalTime.of(23, 59, 0, 0),
3069             LocalTime.of(23, 59, 59, 999999999)
3070         );
3071     }
3072 
3073     void test_comparisons_LocalDateTime(LocalDate[] localDates, LocalTime... localTimes) {
3074         LocalDateTime[] localDateTimes = new LocalDateTime[localDates.length * localTimes.length];
3075         int i = 0;
3076 
3077         for (LocalDate localDate : localDates) {
3078             for (LocalTime localTime : localTimes) {
3079                 localDateTimes[i++] = LocalDateTime.of(localDate, localTime);
3080             }
3081         }
3082 
3083         doTest_comparisons_LocalDateTime(localDateTimes);
3084     }
3085 
3086     void doTest_comparisons_LocalDateTime(LocalDateTime[] localDateTimes) {
3087         for (int i = 0; i &lt; localDateTimes.length; i++) {
3088             LocalDateTime a = localDateTimes[i];
3089             for (int j = 0; j &lt; localDateTimes.length; j++) {
3090                 LocalDateTime b = localDateTimes[j];
3091                 if (i &lt; j) {
3092                     assertTrue(a.compareTo(b) &lt; 0, a + &quot; &lt;=&gt; &quot; + b);
3093                     assertEquals(a.isBefore(b), true, a + &quot; &lt;=&gt; &quot; + b);
3094                     assertEquals(a.isAfter(b), false, a + &quot; &lt;=&gt; &quot; + b);
3095                     assertEquals(a.equals(b), false, a + &quot; &lt;=&gt; &quot; + b);
3096                 } else if (i &gt; j) {
3097                     assertTrue(a.compareTo(b) &gt; 0, a + &quot; &lt;=&gt; &quot; + b);
3098                     assertEquals(a.isBefore(b), false, a + &quot; &lt;=&gt; &quot; + b);
3099                     assertEquals(a.isAfter(b), true, a + &quot; &lt;=&gt; &quot; + b);
3100                     assertEquals(a.equals(b), false, a + &quot; &lt;=&gt; &quot; + b);
3101                 } else {
3102                     assertEquals(a.compareTo(b), 0, a + &quot; &lt;=&gt; &quot; + b);
3103                     assertEquals(a.isBefore(b), false, a + &quot; &lt;=&gt; &quot; + b);
3104                     assertEquals(a.isAfter(b), false, a + &quot; &lt;=&gt; &quot; + b);
3105                     assertEquals(a.equals(b), true, a + &quot; &lt;=&gt; &quot; + b);
3106                 }
3107             }
3108         }
3109     }
3110 
3111     @Test(expectedExceptions=NullPointerException.class)
3112     public void test_compareTo_ObjectNull() {
3113         TEST_2007_07_15_12_30_40_987654321.compareTo(null);
3114     }
3115 
3116     @Test(expectedExceptions=NullPointerException.class)
3117     public void test_isBefore_ObjectNull() {
3118         TEST_2007_07_15_12_30_40_987654321.isBefore(null);
3119     }
3120 
3121     @Test(expectedExceptions=NullPointerException.class)
3122     public void test_isAfter_ObjectNull() {
3123         TEST_2007_07_15_12_30_40_987654321.isAfter(null);
3124     }
3125 
3126     @Test(expectedExceptions=ClassCastException.class)
3127     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
3128     public void compareToNonLocalDateTime() {
3129        Comparable c = TEST_2007_07_15_12_30_40_987654321;
3130        c.compareTo(new Object());
3131     }
3132 
3133     //-----------------------------------------------------------------------
3134     // equals()
3135     //-----------------------------------------------------------------------
3136     @DataProvider(name=&quot;sampleDateTimes&quot;)
3137     Iterator&lt;Object[]&gt; provider_sampleDateTimes() {
3138         return new Iterator&lt;Object[]&gt;() {
3139             Object[][] sampleDates = provider_sampleDates();
3140             Object[][] sampleTimes = provider_sampleTimes();
3141             int datesIndex = 0;
3142             int timesIndex = 0;
3143 
3144             public boolean hasNext() {
3145                 return datesIndex &lt; sampleDates.length;
3146             }
3147 
3148             public Object[] next() {
3149                 Object[] sampleDate = sampleDates[datesIndex];
3150                 Object[] sampleTime = sampleTimes[timesIndex];
3151 
3152                 Object[] ret = new Object[sampleDate.length + sampleTime.length];
3153 
3154                 System.arraycopy(sampleDate, 0, ret, 0, sampleDate.length);
3155                 System.arraycopy(sampleTime, 0, ret, sampleDate.length, sampleTime.length);
3156 
3157                 if (++timesIndex == sampleTimes.length) {
3158                     datesIndex++;
3159                     timesIndex = 0;
3160                 }
3161 
3162                 return ret;
3163             }
3164 
3165             public void remove() {
3166                 throw new UnsupportedOperationException();
3167             }
3168         };
3169     }
3170 
3171     @Test(dataProvider=&quot;sampleDateTimes&quot;)
3172     public void test_equals_true(int y, int m, int d, int h, int mi, int s, int n) {
3173         LocalDateTime a = LocalDateTime.of(y, m, d, h, mi, s, n);
3174         LocalDateTime b = LocalDateTime.of(y, m, d, h, mi, s, n);
3175         assertTrue(a.equals(b));
3176     }
3177 
3178     @Test(dataProvider=&quot;sampleDateTimes&quot;)
3179     public void test_equals_false_year_differs(int y, int m, int d, int h, int mi, int s, int n) {
3180         LocalDateTime a = LocalDateTime.of(y, m, d, h, mi, s, n);
3181         LocalDateTime b = LocalDateTime.of(y + 1, m, d, h, mi, s, n);
3182         assertFalse(a.equals(b));
3183     }
3184 
3185     @Test(dataProvider=&quot;sampleDateTimes&quot;)
3186     public void test_equals_false_month_differs(int y, int m, int d, int h, int mi, int s, int n) {
3187         LocalDateTime a = LocalDateTime.of(y, m, d, h, mi, s, n);
3188         LocalDateTime b = LocalDateTime.of(y, m + 1, d, h, mi, s, n);
3189         assertFalse(a.equals(b));
3190     }
3191 
3192     @Test(dataProvider=&quot;sampleDateTimes&quot;)
3193     public void test_equals_false_day_differs(int y, int m, int d, int h, int mi, int s, int n) {
3194         LocalDateTime a = LocalDateTime.of(y, m, d, h, mi, s, n);
3195         LocalDateTime b = LocalDateTime.of(y, m, d + 1, h, mi, s, n);
3196         assertFalse(a.equals(b));
3197     }
3198 
3199     @Test(dataProvider=&quot;sampleDateTimes&quot;)
3200     public void test_equals_false_hour_differs(int y, int m, int d, int h, int mi, int s, int n) {
3201         LocalDateTime a = LocalDateTime.of(y, m, d, h, mi, s, n);
3202         LocalDateTime b = LocalDateTime.of(y, m, d, h + 1, mi, s, n);
3203         assertFalse(a.equals(b));
3204     }
3205 
3206     @Test(dataProvider=&quot;sampleDateTimes&quot;)
3207     public void test_equals_false_minute_differs(int y, int m, int d, int h, int mi, int s, int n) {
3208         LocalDateTime a = LocalDateTime.of(y, m, d, h, mi, s, n);
3209         LocalDateTime b = LocalDateTime.of(y, m, d, h, mi + 1, s, n);
3210         assertFalse(a.equals(b));
3211     }
3212 
3213     @Test(dataProvider=&quot;sampleDateTimes&quot;)
3214     public void test_equals_false_second_differs(int y, int m, int d, int h, int mi, int s, int n) {
3215         LocalDateTime a = LocalDateTime.of(y, m, d, h, mi, s, n);
3216         LocalDateTime b = LocalDateTime.of(y, m, d, h, mi, s + 1, n);
3217         assertFalse(a.equals(b));
3218     }
3219 
3220     @Test(dataProvider=&quot;sampleDateTimes&quot;)
3221     public void test_equals_false_nano_differs(int y, int m, int d, int h, int mi, int s, int n) {
3222         LocalDateTime a = LocalDateTime.of(y, m, d, h, mi, s, n);
3223         LocalDateTime b = LocalDateTime.of(y, m, d, h, mi, s, n + 1);
3224         assertFalse(a.equals(b));
3225     }
3226 
3227     @Test
3228     public void test_equals_itself_true() {
3229         assertEquals(TEST_2007_07_15_12_30_40_987654321.equals(TEST_2007_07_15_12_30_40_987654321), true);
3230     }
3231 
3232     @Test
3233     public void test_equals_string_false() {
3234         assertEquals(TEST_2007_07_15_12_30_40_987654321.equals(&quot;2007-07-15T12:30:40.987654321&quot;), false);
3235     }
3236 
3237     @Test
3238     public void test_equals_null_false() {
3239         assertEquals(TEST_2007_07_15_12_30_40_987654321.equals(null), false);
3240     }
3241 
3242     //-----------------------------------------------------------------------
3243     // hashCode()
3244     //-----------------------------------------------------------------------
3245     @Test(dataProvider=&quot;sampleDateTimes&quot;)
3246     public void test_hashCode(int y, int m, int d, int h, int mi, int s, int n) {
3247         LocalDateTime a = LocalDateTime.of(y, m, d, h, mi, s, n);
3248         assertEquals(a.hashCode(), a.hashCode());
3249         LocalDateTime b = LocalDateTime.of(y, m, d, h, mi, s, n);
3250         assertEquals(a.hashCode(), b.hashCode());
3251     }
3252 
3253     //-----------------------------------------------------------------------
3254     // toString()
3255     //-----------------------------------------------------------------------
3256     @DataProvider(name=&quot;sampleToString&quot;)
3257     Object[][] provider_sampleToString() {
3258         return new Object[][] {
3259             {2008, 7, 5, 2, 1, 0, 0, &quot;2008-07-05T02:01&quot;},
3260             {2007, 12, 31, 23, 59, 1, 0, &quot;2007-12-31T23:59:01&quot;},
3261             {999, 12, 31, 23, 59, 59, 990000000, &quot;0999-12-31T23:59:59.990&quot;},
3262             {-1, 1, 2, 23, 59, 59, 999990000, &quot;-0001-01-02T23:59:59.999990&quot;},
3263             {-2008, 1, 2, 23, 59, 59, 999999990, &quot;-2008-01-02T23:59:59.999999990&quot;},
3264         };
3265     }
3266 
3267     @Test(dataProvider=&quot;sampleToString&quot;)
3268     public void test_toString(int y, int m, int d, int h, int mi, int s, int n, String expected) {
3269         LocalDateTime t = LocalDateTime.of(y, m, d, h, mi, s, n);
3270         String str = t.toString();
3271         assertEquals(str, expected);
3272     }
3273 
3274     private LocalDateTime dtNoon(int year, int month, int day) {
3275         return LocalDateTime.of(year, month, day, 12, 0);
3276     }
3277 
3278     private LocalDateTime dtEpoch(int hour, int min, int sec, int nano) {
3279         return LocalDateTime.of(1970, 1, 1, hour, min, sec, nano);
3280     }
3281 
3282     private LocalDateTime dt(int year, int month, int day, int hour, int min, int sec, int nano) {
3283         return LocalDateTime.of(year, month, day, hour, min, sec, nano);
3284     }
3285 
3286 }
    </pre>
  </body>
</html>
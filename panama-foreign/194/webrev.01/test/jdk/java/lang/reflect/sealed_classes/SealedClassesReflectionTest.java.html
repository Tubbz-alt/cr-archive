<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/lang/reflect/sealed_classes/SealedClassesReflectionTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8227046
 27  * @summary reflection test for sealed classes
 28  * @compile --enable-preview -source ${jdk.version} SealedClassesReflectionTest.java
 29  * @run testng/othervm --enable-preview SealedClassesReflectionTest
 30  */
 31 
 32 import java.lang.annotation.*;
 33 import java.lang.constant.ClassDesc;
 34 import java.lang.reflect.*;
 35 import java.util.Arrays;
 36 import java.util.List;
 37 import org.testng.annotations.*;
 38 import static org.testng.Assert.*;
 39 
 40 @Test
 41 public class SealedClassesReflectionTest {
 42 
 43     sealed class SealedClass1 permits FinalSubclass1, NonSealedSubclass1 {}
 44     final class FinalSubclass1 extends SealedClass1 {}
 45     non-sealed class NonSealedSubclass1 extends SealedClass1 {}
 46 
 47     sealed class SealedClass2 permits FinalSubclass2, FinalSubclass3 {}
 48     final class FinalSubclass2 extends SealedClass2 {}
 49     final class FinalSubclass3 extends SealedClass2 {}
 50 
 51     sealed class SealedClass3 permits FinalSubclass4, SealedSubclass1 {}
 52     final class FinalSubclass4 extends SealedClass3  {}
 53     sealed class SealedSubclass1 extends SealedClass3 permits FinalSubclass5 {}
 54     final class FinalSubclass5 extends SealedSubclass1 {}
 55 
 56     sealed interface SealedInt1 permits FinalSubclass6, NonSealedSubInt1 {}
 57     final class FinalSubclass6 implements SealedInt1 {}
 58     non-sealed interface NonSealedSubInt1 extends SealedInt1 {}
 59 
 60     sealed interface SealedInt2 permits FinalSubclass7, FinalSubclass8 {}
 61     final class FinalSubclass7 implements SealedInt2 {}
 62     final class FinalSubclass8 implements SealedInt2 {}
 63 
 64     sealed interface SealedInt3 permits FinalSubclass9, SealedSubInt1, SealedSubclass2 {}
 65     final class FinalSubclass9 implements SealedInt3  {}
 66     sealed interface SealedSubInt1 extends SealedInt3 permits FinalSubclass10 {}
 67     final class FinalSubclass10 implements SealedSubInt1 {}
 68     sealed class SealedSubclass2 implements SealedInt3 permits NonSealedSubclass2 {}
 69     non-sealed class NonSealedSubclass2 extends SealedSubclass2 {}
 70 
 71     @DataProvider(name = &quot;sealedClasses&quot;)
 72     public Object[][] sealedClassesData() {
 73         return List.of(
 74                 SealedClass1.class,
 75                 SealedClass2.class,
 76                 SealedClass3.class,
 77                 SealedSubclass1.class,
 78                 SealedInt1.class,
 79                 SealedInt2.class,
 80                 SealedInt3.class,
 81                 SealedSubInt1.class
 82         ).stream().map(c -&gt; new Object[] {c}).toArray(Object[][]::new);
 83     }
 84 
 85     @Test(dataProvider = &quot;sealedClasses&quot;)
 86     public void testSealedClasses(Class&lt;?&gt; cls) {
 87         assertTrue(cls.isSealed());
 88         assertTrue(!Modifier.isFinal(cls.getModifiers()));
 89         assertTrue(cls.permittedSubclasses() != null);
 90         assertTrue(cls.permittedSubclasses().length &gt; 0);
 91     }
 92 
 93     @DataProvider(name = &quot;notSealedClasses&quot;)
 94     public Object[][] notSealedClassesData() {
 95         return List.of(
 96                 Object.class,
 97                 void.class, Void.class, Void[].class,
 98                 byte.class, byte[].class, Byte.class, Byte[].class,
 99                 short.class, short[].class, Short.class, Short[].class,
100                 char.class, char[].class, Character.class, Character[].class,
101                 int.class, int[].class, Integer.class, Integer[].class,
102                 long.class, long[].class, Long.class, Long[].class,
103                 float.class, float[].class, Float.class, Float[].class,
104                 double.class, double[].class, Double.class, Double[].class,
105                 boolean.class, boolean[].class, Boolean.class, Boolean[].class,
106                 String.class, String[].class
107         ).stream().map(c -&gt; new Object[] {c}).toArray(Object[][]::new);
108     }
109 
110     @Test(dataProvider = &quot;notSealedClasses&quot;)
111     public void testNotSealedClasses(Class&lt;?&gt; cls) {
112         assertTrue(!cls.isSealed());
113         assertTrue(cls.permittedSubclasses() != null);
114         assertTrue(cls.permittedSubclasses().length == 0);
115     }
116 
117     @DataProvider(name = &quot;non_sealedClasses&quot;)
118     public Object[][] non_sealedClassesData() {
119         return List.of(
120                 NonSealedSubclass1.class,
121                 NonSealedSubInt1.class,
122                 NonSealedSubclass2.class
123         ).stream().map(c -&gt; new Object[] {c}).toArray(Object[][]::new);
124     }
125 
126     @Test(dataProvider = &quot;non_sealedClasses&quot;)
127     public void testnon_sealedClasses(Class&lt;?&gt; cls) {
128         assertTrue(!cls.isSealed());
129         assertTrue(!Modifier.isFinal(cls.getModifiers()));
130         assertTrue((cls.getSuperclass() != null &amp;&amp; cls.getSuperclass().isSealed()) || Arrays.stream(cls.getInterfaces()).anyMatch(Class::isSealed));
131         assertTrue(cls.permittedSubclasses() != null);
132         assertTrue(cls.permittedSubclasses().length == 0);
133     }
134 
135     @DataProvider(name = &quot;reflectionData&quot;)
136     public Object[][] reflectionData() {
137         return new Object[][] {
138                 new Object[] {
139                         SealedClass1.class,
140                         2,
141                         new String[] {&quot;SealedClassesReflectionTest$FinalSubclass1&quot;, &quot;SealedClassesReflectionTest$NonSealedSubclass1&quot;},
142                         new Class&lt;?&gt;[] {FinalSubclass1.class, NonSealedSubclass1.class},
143                         new SealedStatus[] {SealedStatus.FINAL, SealedStatus.NON_SEALED}},
144 
145                 new Object[] {
146                         SealedClass2.class,
147                         2,
148                         new String[] {&quot;SealedClassesReflectionTest$FinalSubclass2&quot;, &quot;SealedClassesReflectionTest$FinalSubclass3&quot;},
149                         new Class&lt;?&gt;[] {FinalSubclass2.class, FinalSubclass3.class},
150                         new SealedStatus[] {SealedStatus.FINAL, SealedStatus.FINAL}},
151 
152                 new Object[] {
153                         SealedClass3.class,
154                         2,
155                         new String[] {&quot;SealedClassesReflectionTest$FinalSubclass4&quot;, &quot;SealedClassesReflectionTest$SealedSubclass1&quot;},
156                         new Class&lt;?&gt;[] {FinalSubclass4.class, SealedSubclass1.class},
157                         new SealedStatus[] {SealedStatus.FINAL, SealedStatus.SEALED}},
158 
159                 new Object[] {
160                         SealedSubclass1.class,
161                         1,
162                         new String[] {&quot;SealedClassesReflectionTest$FinalSubclass5&quot;},
163                         new Class&lt;?&gt;[] {FinalSubclass5.class},
164                         new SealedStatus[] {SealedStatus.FINAL}},
165 
166                 new Object[] {
167                         SealedInt1.class,
168                         2,
169                         new String[] {&quot;SealedClassesReflectionTest$FinalSubclass6&quot;, &quot;SealedClassesReflectionTest$NonSealedSubInt1&quot;},
170                         new Class&lt;?&gt;[] {FinalSubclass6.class, NonSealedSubInt1.class},
171                         new SealedStatus[] {SealedStatus.FINAL, SealedStatus.NON_SEALED}},
172 
173                 new Object[] {
174                         SealedInt2.class,
175                         2,
176                         new String[] {&quot;SealedClassesReflectionTest$FinalSubclass7&quot;, &quot;SealedClassesReflectionTest$FinalSubclass8&quot;},
177                         new Class&lt;?&gt;[] {FinalSubclass7.class, FinalSubclass8.class},
178                         new SealedStatus[] {SealedStatus.FINAL, SealedStatus.FINAL}},
179 
180                 new Object[] {
181                         SealedInt3.class,
182                         3,
183                         new String[] {&quot;SealedClassesReflectionTest$FinalSubclass9&quot;,
184                                 &quot;SealedClassesReflectionTest$SealedSubInt1&quot;,
185                                 &quot;SealedClassesReflectionTest$SealedSubclass2&quot;},
186                         new Class&lt;?&gt;[] {FinalSubclass9.class, SealedSubInt1.class, SealedSubclass2.class},
187                         new SealedStatus[] {SealedStatus.FINAL, SealedStatus.SEALED, SealedStatus.SEALED}},
188 
189                 new Object[] {
190                         SealedSubInt1.class,
191                         1,
192                         new String[] {&quot;SealedClassesReflectionTest$FinalSubclass10&quot;},
193                         new Class&lt;?&gt;[] {FinalSubclass10.class},
194                         new SealedStatus[] {SealedStatus.FINAL}},
195 
196                 new Object[] {
197                         SealedSubclass2.class,
198                         1,
199                         new String[] {&quot;SealedClassesReflectionTest$NonSealedSubclass2&quot;},
200                         new Class&lt;?&gt;[] {NonSealedSubclass2.class},
201                         new SealedStatus[] {SealedStatus.NON_SEALED}},
202         };
203     }
204 
205     enum SealedStatus {
206         SEALED, NON_SEALED, FINAL
207     }
208 
209     @Test(dataProvider = &quot;reflectionData&quot;)
210     public void testSealedReflection(Class&lt;?&gt; sealedClass,
211                                      int numberOfSubclasses,
212                                      String[] subclassDescriptors,
213                                      Class&lt;?&gt;[] subclasses,
214                                      SealedStatus[] subclassSealedStatus)
215             throws ReflectiveOperationException
216     {
217         assertTrue(sealedClass.isSealed());
218         assertTrue(sealedClass.permittedSubclasses().length == numberOfSubclasses);
219         int i = 0;
220         for (ClassDesc cd : sealedClass.permittedSubclasses()) {
221             assertTrue(cd.displayName().equals(subclassDescriptors[i]), &quot;expected: &quot; + subclassDescriptors[i] + &quot; found: &quot; + cd.displayName());
222             i++;
223         }
224         i = 0;
225         for (Class&lt;?&gt; subclass : subclasses) {
226             switch (subclassSealedStatus[i++]) {
227                 case SEALED:
228                     assertTrue(subclass.isSealed());
229                     break;
230                 case FINAL:
231                     assertTrue(Modifier.isFinal(subclass.getModifiers()));
232                     break;
233                 case NON_SEALED:
234                     assertTrue(!subclass.isSealed() &amp;&amp; !Modifier.isFinal(subclass.getModifiers()));
235                     break;
236             }
237         }
238     }
239 }
    </pre>
  </body>
</html>
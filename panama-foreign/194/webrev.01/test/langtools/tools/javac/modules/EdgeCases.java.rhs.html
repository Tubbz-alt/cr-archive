<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/modules/EdgeCases.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * @test
<a name="1" id="anc1"></a><span class="line-modified">  26  * @bug 8154283 8167320 8171098 8172809 8173068 8173117 8176045 8177311 8241519</span>
  27  * @summary tests for multi-module mode compilation
  28  * @library /tools/lib
  29  * @modules
  30  *      jdk.compiler/com.sun.tools.javac.api
  31  *      jdk.compiler/com.sun.tools.javac.code
  32  *      jdk.compiler/com.sun.tools.javac.main
  33  *      jdk.compiler/com.sun.tools.javac.processing
  34  *      jdk.compiler/com.sun.tools.javac.util
  35  * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask ModuleTestBase
  36  * @run main EdgeCases
  37  */
  38 
  39 import java.io.BufferedWriter;
  40 import java.io.Writer;
  41 import java.nio.file.Files;
  42 import java.nio.file.Path;
  43 import java.nio.file.Paths;
  44 import java.util.Arrays;
  45 import java.util.HashSet;
  46 import java.util.List;
  47 import java.util.Objects;
  48 import java.util.Set;
  49 
  50 import javax.annotation.processing.AbstractProcessor;
  51 import javax.annotation.processing.RoundEnvironment;
  52 import javax.annotation.processing.SupportedAnnotationTypes;
  53 import javax.annotation.processing.SupportedOptions;
  54 import javax.lang.model.SourceVersion;
  55 import javax.lang.model.element.Element;
  56 import javax.lang.model.element.ModuleElement;
  57 import javax.lang.model.element.ModuleElement.RequiresDirective;
  58 import javax.lang.model.element.PackageElement;
  59 import javax.lang.model.element.TypeElement;
  60 import javax.lang.model.util.ElementFilter;
  61 import javax.lang.model.util.Elements;
  62 import javax.tools.JavaCompiler;
  63 import javax.tools.JavaFileObject;
  64 import javax.tools.StandardJavaFileManager;
  65 import javax.tools.ToolProvider;
  66 
  67 import com.sun.source.tree.CompilationUnitTree;
  68 //import com.sun.source.util.JavacTask; // conflicts with toolbox.JavacTask
  69 import com.sun.tools.javac.api.JavacTaskImpl;
  70 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  71 import com.sun.tools.javac.code.Symtab;
  72 
  73 import toolbox.JarTask;
  74 import toolbox.JavacTask;
  75 import toolbox.Task;
  76 import toolbox.Task.Expect;
  77 import toolbox.Task.OutputKind;
  78 
  79 public class EdgeCases extends ModuleTestBase {
  80 
  81     public static void main(String... args) throws Exception {
  82         new EdgeCases().runTests();
  83     }
  84 
  85     @Test
  86     public void testAddExportUndefinedModule(Path base) throws Exception {
  87         Path src = base.resolve(&quot;src&quot;);
  88         tb.writeJavaFiles(src, &quot;package test; import undefPackage.Any; public class Test {}&quot;);
  89         Path classes = base.resolve(&quot;classes&quot;);
  90         tb.createDirectories(classes);
  91 
  92         List&lt;String&gt; log = new JavacTask(tb)
  93                 .options(&quot;--add-exports&quot;, &quot;undefModule/undefPackage=ALL-UNNAMED&quot;,
  94                          &quot;-XDrawDiagnostics&quot;)
  95                 .outdir(classes)
  96                 .files(findJavaFiles(src))
  97                 .run(Task.Expect.FAIL)
  98                 .writeAll()
  99                 .getOutputLines(Task.OutputKind.DIRECT);
 100 
 101         List&lt;String&gt; expected = Arrays.asList(&quot;- compiler.warn.module.for.option.not.found: --add-exports, undefModule&quot;,
 102                                               &quot;Test.java:1:34: compiler.err.doesnt.exist: undefPackage&quot;,
 103                                               &quot;1 error&quot;, &quot;1 warning&quot;);
 104 
 105         if (!expected.equals(log))
 106             throw new Exception(&quot;expected output not found: &quot; + log);
 107     }
 108 
 109     @Test
 110     public void testModuleSymbolOutterMostClass(Path base) throws Exception {
 111         JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
 112         try (StandardJavaFileManager fm = compiler.getStandardFileManager(null, null, null)) {
 113             Path moduleSrc = base.resolve(&quot;module-src&quot;);
 114             Path m1 = moduleSrc.resolve(&quot;m1x&quot;);
 115 
 116             tb.writeJavaFiles(m1, &quot;module m1x { }&quot;);
 117 
 118             Iterable&lt;? extends JavaFileObject&gt; files = fm.getJavaFileObjects(findJavaFiles(moduleSrc));
 119             com.sun.source.util.JavacTask task =
 120                 (com.sun.source.util.JavacTask) compiler.getTask(null, fm, null, null, null, files);
 121 
 122             task.analyze();
 123 
 124             ModuleSymbol msym = (ModuleSymbol) task.getElements().getModuleElement(&quot;m1x&quot;);
 125 
 126             msym.outermostClass();
 127         }
 128     }
 129 
 130     @Test
 131     public void testParseEnterAnalyze(Path base) throws Exception {
 132         JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
 133         try (StandardJavaFileManager fm = compiler.getStandardFileManager(null, null, null)) {
 134             Path moduleSrc = base.resolve(&quot;module-src&quot;);
 135             Path m1 = moduleSrc.resolve(&quot;m1x&quot;);
 136 
 137             tb.writeJavaFiles(m1, &quot;module m1x { }&quot;,
 138                                   &quot;package p;&quot;,
 139                                   &quot;package p; class T { }&quot;);
 140 
 141             Path classes = base.resolve(&quot;classes&quot;);
 142             Iterable&lt;? extends JavaFileObject&gt; files = fm.getJavaFileObjects(findJavaFiles(moduleSrc));
 143             List&lt;String&gt; options = Arrays.asList(&quot;-d&quot;, classes.toString(), &quot;-Xpkginfo:always&quot;);
 144             JavacTaskImpl task = (JavacTaskImpl) compiler.getTask(null, fm, null, options, null, files);
 145 
 146             Iterable&lt;? extends CompilationUnitTree&gt; parsed = task.parse();
 147             Iterable&lt;? extends Element&gt; entered = task.enter(parsed);
 148             Iterable&lt;? extends Element&gt; analyzed = task.analyze(entered);
 149             Iterable&lt;? extends JavaFileObject&gt; generatedFiles = task.generate(analyzed);
 150 
 151             Set&lt;String&gt; generated = new HashSet&lt;&gt;();
 152 
 153             for (JavaFileObject jfo : generatedFiles) {
 154                 generated.add(jfo.getName());
 155             }
 156 
 157             Set&lt;String&gt; expected = new HashSet&lt;&gt;(
 158                     Arrays.asList(Paths.get(&quot;testParseEnterAnalyze&quot;, &quot;classes&quot;, &quot;p&quot;, &quot;package-info.class&quot;).toString(),
 159                                   Paths.get(&quot;testParseEnterAnalyze&quot;, &quot;classes&quot;, &quot;module-info.class&quot;).toString(),
 160                                   Paths.get(&quot;testParseEnterAnalyze&quot;, &quot;classes&quot;, &quot;p&quot;, &quot;T.class&quot;).toString())
 161             );
 162 
 163             if (!Objects.equals(expected, generated))
 164                 throw new AssertionError(&quot;Incorrect generated files: &quot; + generated);
 165         }
 166     }
 167 
 168     @Test
 169     public void testModuleImplicitModuleBoundaries(Path base) throws Exception {
 170         Path src = base.resolve(&quot;src&quot;);
 171         Path src_m1 = src.resolve(&quot;m1x&quot;);
 172         tb.writeJavaFiles(src_m1,
 173                           &quot;module m1x { exports api1; }&quot;,
 174                           &quot;package api1; public class Api1 { public void call() { } }&quot;);
 175         Path src_m2 = src.resolve(&quot;m2x&quot;);
 176         tb.writeJavaFiles(src_m2,
 177                           &quot;module m2x { requires m1x; exports api2; }&quot;,
 178                           &quot;package api2; public class Api2 { public static api1.Api1 get() { return null; } }&quot;);
 179         Path src_m3 = src.resolve(&quot;m3x&quot;);
 180         tb.writeJavaFiles(src_m3,
 181                           &quot;module m3x { requires m2x; }&quot;,
 182                           &quot;package test; public class Test { { api2.Api2.get().call(); api2.Api2.get().toString(); } }&quot;);
 183         Path classes = base.resolve(&quot;classes&quot;);
 184         tb.createDirectories(classes);
 185 
 186         String log = new JavacTask(tb)
 187                 .options(&quot;-XDrawDiagnostics&quot;,
 188                          &quot;--module-source-path&quot;, src.toString())
 189                 .outdir(classes)
 190                 .files(findJavaFiles(src))
 191                 .run(Task.Expect.FAIL)
 192                 .writeAll()
 193                 .getOutput(Task.OutputKind.DIRECT);
 194 
 195         if (!log.contains(&quot;Test.java:1:52: compiler.err.not.def.access.class.intf.cant.access.reason: call(), api1.Api1, api1, (compiler.misc.not.def.access.does.not.read: m3x, api1, m1x)&quot;) ||
 196             !log.contains(&quot;Test.java:1:76: compiler.err.not.def.access.class.intf.cant.access: toString(), java.lang.Object&quot;))
 197             throw new Exception(&quot;expected output not found&quot;);
 198     }
 199 
 200     @Test
 201     public void testAssignClassToAutomaticModule(Path base) throws Exception {
 202         //check that if a ClassSymbol belongs to an automatic module, it is properly assigned and not
 203         //duplicated when being accessed through a classfile.
 204         Path automaticSrc = base.resolve(&quot;automaticSrc&quot;);
 205         tb.writeJavaFiles(automaticSrc, &quot;package api1; public class Api1 {}&quot;);
 206         Path automaticClasses = base.resolve(&quot;automaticClasses&quot;);
 207         tb.createDirectories(automaticClasses);
 208 
 209         String automaticLog = new JavacTask(tb)
 210                                 .outdir(automaticClasses)
 211                                 .files(findJavaFiles(automaticSrc))
 212                                 .run()
 213                                 .writeAll()
 214                                 .getOutput(Task.OutputKind.DIRECT);
 215 
 216         if (!automaticLog.isEmpty())
 217             throw new Exception(&quot;expected output not found: &quot; + automaticLog);
 218 
 219         Path modulePath = base.resolve(&quot;module-path&quot;);
 220 
 221         Files.createDirectories(modulePath);
 222 
 223         Path automaticJar = modulePath.resolve(&quot;a-1.0.jar&quot;);
 224 
 225         new JarTask(tb, automaticJar)
 226           .baseDir(automaticClasses)
 227           .files(&quot;api1/Api1.class&quot;)
 228           .run();
 229 
 230         Path src = base.resolve(&quot;src&quot;);
 231         Path src_m2 = src.resolve(&quot;m2x&quot;);
 232         tb.writeJavaFiles(src_m2,
 233                           &quot;module m2x { requires a; exports api2; }&quot;,
 234                           &quot;package api2; public class Api2 { public static api1.Api1 get() { return null; } }&quot;);
 235         Path src_m3 = src.resolve(&quot;m3x&quot;);
 236         tb.writeJavaFiles(src_m3,
 237                           &quot;module m3x { requires a; requires m2x; }&quot;,
 238                           &quot;package test; public class Test { { api2.Api2.get(); api1.Api1 a1; } }&quot;);
 239         Path classes = base.resolve(&quot;classes&quot;);
 240         tb.createDirectories(classes);
 241 
 242         new JavacTask(tb)
 243                 .options(&quot;--module-path&quot;, modulePath.toString(),
 244                          &quot;--module-source-path&quot;, src.toString())
 245                 .outdir(classes)
 246                 .files(findJavaFiles(src_m2))
 247                 .run()
 248                 .writeAll();
 249 
 250         new JavacTask(tb)
 251                 .options(&quot;--module-path&quot;, modulePath.toString(),
 252                          &quot;--module-source-path&quot;, src.toString())
 253                 .outdir(classes)
 254                 .files(findJavaFiles(src_m3))
 255                 .run()
 256                 .writeAll();
 257     }
 258 
 259     @Test
 260     public void testEmptyImplicitModuleInfo(Path base) throws Exception {
 261         Path src = base.resolve(&quot;src&quot;);
 262         Path src_m1 = src.resolve(&quot;m1x&quot;);
 263         Files.createDirectories(src_m1);
 264         try (Writer w = Files.newBufferedWriter(src_m1.resolve(&quot;module-info.java&quot;))) {}
 265         tb.writeJavaFiles(src_m1,
 266                           &quot;package test; public class Test {}&quot;);
 267         Path classes = base.resolve(&quot;classes&quot;);
 268         tb.createDirectories(classes);
 269 
 270         List&lt;String&gt; log = new JavacTask(tb)
 271                 .options(&quot;--source-path&quot;, src_m1.toString(),
 272                          &quot;-XDrawDiagnostics&quot;)
 273                 .outdir(classes)
 274                 .files(findJavaFiles(src_m1.resolve(&quot;test&quot;)))
 275                 .run(Task.Expect.FAIL)
 276                 .writeAll()
 277                 .getOutputLines(OutputKind.DIRECT);
 278 
 279         List&lt;String&gt; expected = Arrays.asList(
 280                 &quot;- compiler.err.cant.access: module-info, (compiler.misc.bad.source.file.header: module-info.java, (compiler.misc.file.does.not.contain.module))&quot;,
 281                 &quot;1 error&quot;);
 282 
 283         if (!expected.equals(log)) {
 284             throw new AssertionError(&quot;Unexpected output: &quot; + log);
 285         }
 286 
 287         tb.writeJavaFiles(src_m1,
 288                           &quot;module m1x {}&quot;);
 289 
 290         new JavacTask(tb)
 291                 .options(&quot;--source-path&quot;, src_m1.toString())
 292                 .outdir(classes)
 293                 .files(findJavaFiles(src_m1.resolve(&quot;test&quot;)))
 294                 .run()
 295                 .writeAll();
 296 
 297     }
 298 
 299     @Test
 300     public void testClassPackageClash(Path base) throws Exception {
 301         Path src = base.resolve(&quot;src&quot;);
 302         Path src_m1 = src.resolve(&quot;m1x&quot;);
 303         tb.writeJavaFiles(src_m1,
 304                           &quot;module m1x { exports test.m1x; }&quot;,
 305                           &quot;package test.m1x;\n&quot; +
 306                           &quot;public class Test {}\n&quot;);
 307         Path src_m2 = src.resolve(&quot;m2x&quot;);
 308         tb.writeJavaFiles(src_m2,
 309                           &quot;module m2x { requires m1x; }&quot;,
 310                           &quot;package test;\n&quot; +
 311                           &quot;public class m1x {}\n&quot;);
 312         Path classes = base.resolve(&quot;classes&quot;);
 313         tb.createDirectories(classes);
 314 
 315         List&lt;String&gt; log = new JavacTask(tb)
 316                 .options(&quot;--module-source-path&quot;, src.toString(),
 317                          &quot;-XDrawDiagnostics&quot;)
 318                 .outdir(classes)
 319                 .files(findJavaFiles(src))
 320                 .run(Task.Expect.FAIL)
 321                 .writeAll()
 322                 .getOutputLines(Task.OutputKind.DIRECT);
 323 
 324         List&lt;String&gt; expected = Arrays.asList(
 325             &quot;m1x.java:2:8: compiler.err.clash.with.pkg.of.same.name: kindname.class, test.m1x&quot;,
 326             &quot;1 error&quot;
 327         );
 328 
 329         if (!expected.equals(log)) {
 330             throw new IllegalStateException(log.toString());
 331         }
 332     }
 333 
 334     @Test
 335     public void testImplicitJavaBase(Path base) throws Exception {
 336         Path src = base.resolve(&quot;src&quot;);
 337         Path src_java_base = src.resolve(&quot;java.base&quot;);
 338         Files.createDirectories(src_java_base);
 339         tb.writeJavaFiles(src_java_base, &quot;module java.base { exports java.lang; }&quot;);
 340         tb.writeJavaFiles(src_java_base,
 341                           &quot;package java.lang; public class Object {}&quot;);
 342         Path classes = base.resolve(&quot;classes&quot;);
 343         tb.createDirectories(classes);
 344 
 345         //module-info from source:
 346         new JavacTask(tb)
 347             .options(&quot;-sourcepath&quot;, src_java_base.toString())
 348             .outdir(classes)
 349             .files(findJavaFiles(src_java_base.resolve(&quot;java&quot;).resolve(&quot;lang&quot;).resolve(&quot;Object.java&quot;)))
 350             .run()
 351             .writeAll();
 352 
 353         //module-info from class:
 354         if (!Files.exists(classes.resolve(&quot;module-info.class&quot;))) {
 355             throw new AssertionError(&quot;module-info.class not created!&quot;);
 356         }
 357 
 358         new JavacTask(tb)
 359             .outdir(classes)
 360             .files(findJavaFiles(src_java_base.resolve(&quot;java&quot;).resolve(&quot;lang&quot;).resolve(&quot;Object.java&quot;)))
 361             .run()
 362             .writeAll();
 363 
 364         //broken module-info.class:
 365         Files.newOutputStream(classes.resolve(&quot;module-info.class&quot;)).close();
 366 
 367         List&lt;String&gt; log = new JavacTask(tb)
 368             .options(&quot;-XDrawDiagnostics&quot;)
 369             .outdir(classes)
 370             .files(findJavaFiles(src_java_base.resolve(&quot;java&quot;).resolve(&quot;lang&quot;).resolve(&quot;Object.java&quot;)))
 371             .run(Expect.FAIL)
 372             .writeAll()
 373             .getOutputLines(OutputKind.DIRECT);
 374 
 375         List&lt;String&gt; expected = Arrays.asList(
 376                 &quot;- compiler.err.cant.access: &lt;error&gt;.module-info, (compiler.misc.bad.class.file.header: module-info.class, (compiler.misc.illegal.start.of.class.file))&quot;,
 377                 &quot;1 error&quot;);
 378 
 379         if (!expected.equals(log)) {
 380             throw new AssertionError(&quot;Unexpected output: &quot; + log);
 381         }
 382 
 383         //broken module-info.java:
 384         Files.delete(classes.resolve(&quot;module-info.class&quot;));
 385 
 386         try (Writer out = Files.newBufferedWriter(src_java_base.resolve(&quot;module-info.java&quot;))) {
 387             out.write(&quot;class Broken {}&quot;);
 388         }
 389 
 390         log = new JavacTask(tb)
 391             .options(&quot;-sourcepath&quot;, src_java_base.toString(),
 392                                 &quot;-XDrawDiagnostics&quot;)
 393             .outdir(classes)
 394             .files(findJavaFiles(src_java_base.resolve(&quot;java&quot;).resolve(&quot;lang&quot;).resolve(&quot;Object.java&quot;)))
 395             .run(Expect.FAIL)
 396             .writeAll()
 397             .getOutputLines(OutputKind.DIRECT);
 398 
 399         expected = Arrays.asList(&quot;X&quot;);
 400 
 401         if (expected.equals(log)) {
 402             throw new AssertionError(&quot;Unexpected output: &quot; + log);
 403         }
 404     }
 405 
 406     @Test
 407     public void testModuleInfoNameMismatchSource(Path base) throws Exception {
 408         Path src = base.resolve(&quot;src&quot;);
 409         Path m1 = src.resolve(&quot;m1x&quot;);
 410         Files.createDirectories(m1);
 411         tb.writeJavaFiles(m1, &quot;module other { }&quot;,
 412                               &quot;package test; public class Test {}&quot;);
 413         Path classes = base.resolve(&quot;classes&quot;);
 414         tb.createDirectories(classes);
 415 
 416         List&lt;String&gt; log = new JavacTask(tb)
 417             .options(&quot;--module-source-path&quot;, src.toString(),
 418                      &quot;-XDrawDiagnostics&quot;)
 419             .outdir(classes)
 420             .files(findJavaFiles(m1.resolve(&quot;test&quot;).resolve(&quot;Test.java&quot;)))
 421             .run(Expect.FAIL)
 422             .writeAll()
 423             .getOutputLines(OutputKind.DIRECT);
 424 
 425         List&lt;String&gt; expected = Arrays.asList(
 426                 &quot;module-info.java:1:1: compiler.err.module.name.mismatch: other, m1x&quot;,
 427                 &quot;- compiler.err.cant.access: m1x.module-info, (compiler.misc.cant.resolve.modules)&quot;,
 428                 &quot;2 errors&quot;);
 429 
 430         if (!expected.equals(log)) {
 431             throw new AssertionError(&quot;Unexpected output: &quot; + log);
 432         }
 433     }
 434 
 435     @Test
 436     public void testModuleInfoNameMismatchClass(Path base) throws Exception {
 437         Path src = base.resolve(&quot;src&quot;);
 438         Files.createDirectories(src);
 439         tb.writeJavaFiles(src, &quot;module other { }&quot;,
 440                                &quot;package test; public class Test {}&quot;);
 441         Path classes = base.resolve(&quot;classes&quot;);
 442         Path m1Classes = classes.resolve(&quot;m1x&quot;);
 443         tb.createDirectories(m1Classes);
 444 
 445         new JavacTask(tb)
 446             .outdir(m1Classes)
 447             .files(findJavaFiles(src))
 448             .run()
 449             .writeAll()
 450             .getOutputLines(OutputKind.DIRECT);
 451 
 452         Path src2 = base.resolve(&quot;src2&quot;);
 453         Files.createDirectories(src2);
 454         tb.writeJavaFiles(src2, &quot;module use { requires m1x; }&quot;);
 455 
 456         Path classes2 = base.resolve(&quot;classes2&quot;);
 457         tb.createDirectories(classes2);
 458 
 459         List&lt;String&gt; log = new JavacTask(tb)
 460             .options(&quot;--module-path&quot;, classes.toString(),
 461                      &quot;-XDrawDiagnostics&quot;)
 462             .outdir(classes2)
 463             .files(findJavaFiles(src2))
 464             .run(Expect.FAIL)
 465             .writeAll()
 466             .getOutputLines(OutputKind.DIRECT);
 467 
 468         List&lt;String&gt; expected = Arrays.asList(
 469                 &quot;- compiler.err.cant.access: m1x.module-info, (compiler.misc.bad.class.file.header: module-info.class, (compiler.misc.module.name.mismatch: other, m1x))&quot;,
 470                 &quot;module-info.java:1:1: compiler.err.module.not.found: m1x&quot;,
 471                 &quot;2 errors&quot;);
 472 
 473         if (!expected.equals(log)) {
 474             throw new AssertionError(&quot;Unexpected output: &quot; + log);
 475         }
 476     }
 477 
 478     @Test
 479     public void testGetDirectivesComplete(Path base) throws Exception {
 480         JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
 481         JavacTaskImpl task = (JavacTaskImpl) compiler.getTask(null, null, null, null, null, null);
 482         Symtab syms = Symtab.instance(task.getContext());
 483 
 484         syms.java_base.getDirectives();
 485     }
 486 
 487     @Test
 488     public void testPackageInModuleInfo(Path base) throws Exception {
 489         Path src = base.resolve(&quot;src&quot;);
 490         Files.createDirectories(src);
 491         tb.writeJavaFiles(src, &quot;package p; module foo { }&quot;);
 492         Path classes = base.resolve(&quot;classes&quot;);
 493         tb.createDirectories(classes);
 494 
 495         List&lt;String&gt; log = new JavacTask(tb)
 496             .options(&quot;-XDrawDiagnostics&quot;, &quot;-XDshould-stop.ifError=FLOW&quot;)
 497             .outdir(classes)
 498             .files(findJavaFiles(src))
 499             .run(Expect.FAIL)
 500             .writeAll()
 501             .getOutputLines(OutputKind.DIRECT);
 502 
 503         List&lt;String&gt; expected = Arrays.asList(
 504                 &quot;module-info.java:1:1: compiler.err.no.pkg.in.module-info.java&quot;,
 505                 &quot;1 error&quot;);
 506 
 507         if (!expected.equals(log)) {
 508             throw new AssertionError(&quot;Unexpected output: &quot; + log);
 509         }
 510     }
 511 
 512     @Test
 513     public void testInvisibleClassVisiblePackageClash(Path base) throws Exception {
 514         Path src = base.resolve(&quot;src&quot;);
 515         Path src_m1 = src.resolve(&quot;m1x&quot;);
 516         tb.writeJavaFiles(src_m1,
 517                           &quot;module m1x { }&quot;,
 518                           &quot;package m1x;\n&quot; +
 519                           &quot;import m1x.a.*; public class Test { A a; }\n&quot;,
 520                           &quot;package m1x.a;\n&quot; +
 521                           &quot;public class A { }\n&quot;);
 522         Path src_m2 = src.resolve(&quot;m2x&quot;);
 523         tb.writeJavaFiles(src_m2,
 524                           &quot;module m2x { }&quot;,
 525                           &quot;package m1x;\n&quot; +
 526                           &quot;public class a { public static class A { } }\n&quot;);
 527         Path classes = base.resolve(&quot;classes&quot;);
 528         tb.createDirectories(classes);
 529 
 530         new JavacTask(tb)
 531             .options(&quot;--module-source-path&quot;, src.toString(),
 532                      &quot;-XDrawDiagnostics&quot;)
 533             .outdir(classes)
 534             .files(findJavaFiles(src))
 535             .run()
 536             .writeAll();
 537     }
 538 
 539     @Test
 540     public void testStripUnknownRequired(Path base) throws Exception {
 541         Path src = base.resolve(&quot;src&quot;);
 542         Path src_m1 = src.resolve(&quot;m1x&quot;);
 543         tb.writeJavaFiles(src_m1,
 544                           &quot;module m1x { }&quot;);
 545         Path src_m2 = src.resolve(&quot;m2x&quot;);
 546         tb.writeJavaFiles(src_m2,
 547                           &quot;module m2x { }&quot;);
 548         Path src_m3 = src.resolve(&quot;m3x&quot;);
 549         tb.writeJavaFiles(src_m3,
 550                           &quot;module m3x { }&quot;);
 551         Path src_m4 = src.resolve(&quot;m4x&quot;);
 552         tb.writeJavaFiles(src_m4,
 553                           &quot;module m4x { }&quot;);
 554         Path src_test = src.resolve(&quot;test&quot;);
 555         tb.writeJavaFiles(src_test,
 556                           &quot;module test { requires m1x; requires m2x; requires java.base; requires m3x; requires m4x; }&quot;);
 557         Path src_compile = src.resolve(&quot;compile&quot;);
 558         tb.writeJavaFiles(src_compile,
 559                           &quot;module compile { exports p to test; }&quot;,
 560                           &quot;package p; public class Test { }&quot;);
 561         Path classes = base.resolve(&quot;classes&quot;);
 562         tb.createDirectories(classes);
 563 
 564         List&lt;String&gt; log = new JavacTask(tb)
 565                 .options(&quot;-processor&quot;, ListRequires.class.getName(),
 566                          &quot;--module-source-path&quot;, src.toString(),
 567                          &quot;--limit-modules&quot;, &quot;compile&quot;,
 568                          &quot;-XDaccessInternalAPI=true&quot;)
 569                 .outdir(classes)
 570                 .files(findJavaFiles(src_compile))
 571                 .run(Expect.FAIL)
 572                 .writeAll()
 573                 .getOutputLines(Task.OutputKind.STDOUT);
 574 
 575         List&lt;String&gt; expected = Arrays.asList(
 576                 &quot;from directives:&quot;,
 577                 &quot;java.base&quot;,
 578                 &quot;from requires:&quot;,
 579                 &quot;java.base&quot;
 580         );
 581         if (!Objects.equals(log, expected))
 582             throw new AssertionError(&quot;Unexpected output: &quot; + log);
 583     }
 584 
 585     @SupportedAnnotationTypes(&quot;*&quot;)
 586     @SupportedOptions(&quot;expectedEnclosedElements&quot;)
 587     public static final class ListRequires extends AbstractProcessor {
 588 
 589         private int round;
 590 
 591         @Override
 592         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
 593             if (round++ == 0) {
 594                 ModuleElement compileE = processingEnv.getElementUtils().getModuleElement(&quot;compile&quot;);
 595                 ModuleElement testE = ElementFilter.exportsIn(compileE.getDirectives()).get(0).getTargetModules().get(0);
 596 
 597                 System.out.println(&quot;from directives:&quot;);
 598                 for (RequiresDirective rd : ElementFilter.requiresIn(testE.getDirectives())) {
 599                     System.out.println(rd.getDependency().getQualifiedName());
 600                 }
 601 
 602                 System.out.println(&quot;from requires:&quot;);
 603                 for (RequiresDirective rd : ((ModuleSymbol) testE).requires) {
 604                     System.out.println(rd.getDependency().getQualifiedName());
 605                 }
 606             }
 607 
 608             return false;
 609         }
 610 
 611         @Override
 612         public SourceVersion getSupportedSourceVersion() {
 613             return SourceVersion.latest();
 614         }
 615 
 616     }
 617 
 618     @Test
 619     public void testOnDemandCompletionModuleInfoJava(Path base) throws Exception {
 620         Path src = base.resolve(&quot;src&quot;);
 621         Path src_m1 = src.resolve(&quot;m1x&quot;);
 622         tb.writeJavaFiles(src_m1,
 623                           &quot;@Deprecated module m1x { }&quot;);
 624         Path src_m2 = src.resolve(&quot;m2x&quot;);
 625         tb.writeJavaFiles(src_m2,
 626                           &quot;module m2x { requires m1x; }&quot;);
 627         Path src_m3 = src.resolve(&quot;m3x&quot;);
 628         tb.writeJavaFiles(src_m3,
 629                           &quot;module m3x { requires m2x; requires m1x; }&quot;);
 630         Path classes = base.resolve(&quot;classes&quot;);
 631         tb.createDirectories(classes);
 632 
 633         List&lt;String&gt; log;
 634         List&lt;String&gt; expected;
 635 
 636         log = new JavacTask(tb)
 637                 .options(&quot;--module-source-path&quot;, src.toString())
 638                 .outdir(classes)
 639                 .files(findJavaFiles(src_m1))
 640                 .run()
 641                 .writeAll()
 642                 .getOutputLines(Task.OutputKind.DIRECT);
 643 
 644         expected = Arrays.asList(&quot;&quot;);
 645 
 646         if (!expected.equals(log)) {
 647             throw new IllegalStateException(log.toString());
 648         }
 649 
 650         log = new JavacTask(tb)
 651                 .options(&quot;--module-source-path&quot;, src.toString(),
 652                          &quot;-XDrawDiagnostics&quot;,
 653                          &quot;-Xlint:deprecation&quot;)
 654                 .outdir(classes)
 655                 .files(findJavaFiles(src_m3))
 656                 .run()
 657                 .writeAll()
 658                 .getOutputLines(Task.OutputKind.DIRECT);
 659 
 660         expected = Arrays.asList(
 661                 &quot;module-info.java:1:23: compiler.warn.has.been.deprecated.module: m1x&quot;,
 662                 &quot;module-info.java:1:37: compiler.warn.has.been.deprecated.module: m1x&quot;,
 663                 &quot;2 warnings&quot;
 664         );
 665 
 666         if (!expected.equals(log)) {
 667             throw new IllegalStateException(log.toString());
 668         }
 669     }
 670 
 671     @Test
 672     public void testUnnamedPackage(Path base) throws Exception {
 673         List&lt;String&gt; out;
 674         List&lt;String&gt; expected;
 675 
 676         //-source 8:
 677         Path src8 = base.resolve(&quot;src8&quot;);
 678         Files.createDirectories(src8);
 679         tb.writeJavaFiles(src8,
 680                           &quot;package test; public class Test {}&quot;);
 681         Path classes = base.resolve(&quot;classes&quot;);
 682         tb.createDirectories(classes);
 683 
 684         out = new JavacTask(tb)
 685                 .options(&quot;--source-path&quot;, src8.toString(),
 686                          &quot;-processor&quot;, UnnamedPackageProcessor.class.getName(),
 687                          &quot;-source&quot;, &quot;8&quot;)
 688                 .outdir(classes)
 689                 .files(findJavaFiles(src8))
 690                 .run()
 691                 .writeAll()
 692                 .getOutputLines(OutputKind.STDOUT);
 693 
 694         expected = Arrays.asList(&quot;noModule&quot;);
 695 
 696         if (!expected.equals(out)) {
 697             throw new AssertionError(&quot;Unexpected output: &quot; + out);
 698         }
 699 
 700         //-source 9, unnamed:
 701         Path srcUnnamed = base.resolve(&quot;srcUnnamed&quot;);
 702         Files.createDirectories(srcUnnamed);
 703         tb.writeJavaFiles(srcUnnamed,
 704                           &quot;public class Test {}&quot;);
 705         Path classesUnnamed = base.resolve(&quot;classesUnnamed&quot;);
 706         tb.createDirectories(classesUnnamed);
 707 
 708         out = new JavacTask(tb)
 709                 .options(&quot;--source-path&quot;, srcUnnamed.toString(),
 710                          &quot;-processor&quot;, UnnamedPackageProcessor.class.getName())
 711                 .outdir(classesUnnamed)
 712                 .files(findJavaFiles(srcUnnamed))
 713                 .run()
 714                 .writeAll()
 715                 .getOutputLines(OutputKind.STDOUT);
 716 
 717         expected = Arrays.asList(&quot;unnamedModule&quot;);
 718 
 719         if (!expected.equals(out)) {
 720             throw new AssertionError(&quot;Unexpected output: &quot; + out);
 721         }
 722 
 723         //-source 9, named:
 724         Path srcNamed = base.resolve(&quot;srcNamed&quot;);
 725         Files.createDirectories(srcNamed);
 726         tb.writeJavaFiles(srcNamed,
 727                           &quot;module m {}&quot;,
 728                           &quot;public class Test {}&quot;);
 729         Path classesNamed = base.resolve(&quot;classesNamed&quot;);
 730         tb.createDirectories(classesNamed);
 731 
 732         out = new JavacTask(tb)
 733                 .options(&quot;--source-path&quot;, srcNamed.toString(),
 734                          &quot;-classpath&quot;, &quot;&quot;,
 735                          &quot;-processorpath&quot;, System.getProperty(&quot;test.class.path&quot;),
 736                          &quot;-processor&quot;, UnnamedPackageProcessor.class.getName())
 737                 .outdir(classesNamed)
 738                 .files(findJavaFiles(srcNamed))
 739                 .run()
 740                 .writeAll()
 741                 .getOutputLines(OutputKind.STDOUT);
 742 
 743         expected = Arrays.asList(&quot;m&quot;);
 744 
 745         if (!expected.equals(out)) {
 746             throw new AssertionError(&quot;Unexpected output: &quot; + out);
 747         }
 748 
 749         //-source 9, conflict:
 750         Path srcNamed2 = base.resolve(&quot;srcNamed2&quot;);
 751         Path srcNamed2m1 = srcNamed2.resolve(&quot;m1x&quot;);
 752         Files.createDirectories(srcNamed2m1);
 753         tb.writeJavaFiles(srcNamed2m1,
 754                           &quot;module m1x {}&quot;,
 755                           &quot;public class Test {}&quot;);
 756         Path srcNamed2m2 = srcNamed2.resolve(&quot;m2x&quot;);
 757         Files.createDirectories(srcNamed2m2);
 758         tb.writeJavaFiles(srcNamed2m2,
 759                           &quot;module m2x {}&quot;,
 760                           &quot;public class Test {}&quot;);
 761         Path classesNamed2 = base.resolve(&quot;classesNamed2&quot;);
 762         tb.createDirectories(classesNamed2);
 763 
 764         out = new JavacTask(tb)
 765                 .options(&quot;--module-source-path&quot;, srcNamed2.toString(),
 766                          &quot;-classpath&quot;, &quot;&quot;,
 767                          &quot;-processorpath&quot;, System.getProperty(&quot;test.class.path&quot;),
 768                          &quot;-processor&quot;, UnnamedPackageProcessor.class.getName(),
 769                          &quot;-XDshould-stop.ifError=FLOW&quot;)
 770                 .outdir(classesNamed2)
 771                 .files(findJavaFiles(srcNamed2))
 772                 .run(Expect.FAIL)
 773                 .writeAll()
 774                 .getOutputLines(OutputKind.STDOUT);
 775 
 776         expected = Arrays.asList(&quot;null&quot;,
 777                                  &quot;m1x: true&quot;,
 778                                  &quot;m2x: true&quot;);
 779 
 780         if (!expected.equals(out)) {
 781             throw new AssertionError(&quot;Unexpected output: &quot; + out);
 782         }
 783     }
 784 
 785     @SupportedAnnotationTypes(&quot;*&quot;)
 786     public static final class UnnamedPackageProcessor extends AbstractProcessor {
 787 
 788         int round = 0;
 789 
 790         @Override
 791         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
 792             if (round++ != 0)
 793                 return false;
 794 
 795             Elements elements = processingEnv.getElementUtils();
 796             PackageElement pe = elements.getPackageElement(&quot;&quot;);
 797 
 798             if (pe == null) {
 799                 System.out.println(&quot;null&quot;);
 800             } else {
 801                 ModuleElement mod = (ModuleElement) pe.getEnclosingElement();
 802                 if (mod == null) {
 803                     System.out.println(&quot;noModule&quot;);
 804                 } else if (mod.isUnnamed()) {
 805                     System.out.println(&quot;unnamedModule&quot;);
 806                 } else {
 807                     System.out.println(mod);
 808                 }
 809             }
 810 
 811             ModuleElement m1x = elements.getModuleElement(&quot;m1x&quot;);
 812             ModuleElement m2x = elements.getModuleElement(&quot;m2x&quot;);
 813 
 814             if (m1x != null &amp;&amp; m2x != null) {
 815                 System.out.println(&quot;m1x: &quot; + (elements.getPackageElement(m1x, &quot;&quot;) != null));
 816                 System.out.println(&quot;m2x: &quot; + (elements.getPackageElement(m2x, &quot;&quot;) != null));
 817             }
 818 
 819             return false;
 820         }
 821 
 822     }
 823 
 824     @Test
 825     public void testEmptyInExportedPackage(Path base) throws Exception {
 826         Path src = base.resolve(&quot;src&quot;);
 827         Path m = src.resolve(&quot;m&quot;);
 828         tb.writeJavaFiles(m,
 829                           &quot;module m { exports api; }&quot;);
 830         Path apiFile = m.resolve(&quot;api&quot;).resolve(&quot;Api.java&quot;);
 831         Files.createDirectories(apiFile.getParent());
 832         try (BufferedWriter w = Files.newBufferedWriter(apiFile)) {
 833             w.write(&quot;//no package decl&quot;);
 834         }
 835         Path classes = base.resolve(&quot;classes&quot;);
 836         tb.createDirectories(classes);
 837 
 838         List&lt;String&gt; log;
 839         List&lt;String&gt; expected =
 840                 Arrays.asList(&quot;module-info.java:1:20: compiler.err.package.empty.or.not.found: api&quot;,
 841                               &quot;1 error&quot;);
 842 
 843         System.err.println(&quot;file explicitly specified:&quot;);
 844 
 845         log = new JavacTask(tb)
 846             .options(&quot;-XDrawDiagnostics&quot;,
 847                      &quot;--module-source-path&quot;, src.toString())
 848             .outdir(classes)
 849             .files(findJavaFiles(src))
 850             .run(Task.Expect.FAIL)
 851             .writeAll()
 852             .getOutputLines(Task.OutputKind.DIRECT);
 853 
 854         if (!expected.equals(log))
 855             throw new Exception(&quot;expected output not found: &quot; + log);
 856 
 857         System.err.println(&quot;file not specified:&quot;);
 858 
 859         tb.cleanDirectory(classes);
 860 
 861         log = new JavacTask(tb)
 862             .options(&quot;-XDrawDiagnostics&quot;,
 863                      &quot;--module-source-path&quot;, src.toString())
 864             .outdir(classes)
 865             .files(findJavaFiles(m.resolve(&quot;module-info.java&quot;)))
 866             .run(Task.Expect.FAIL)
 867             .writeAll()
 868             .getOutputLines(Task.OutputKind.DIRECT);
 869 
 870         if (!expected.equals(log))
 871             throw new Exception(&quot;expected output not found: &quot; + log);
 872     }
 873 
 874     @Test
 875     public void testJustPackageInExportedPackage(Path base) throws Exception {
 876         Path src = base.resolve(&quot;src&quot;);
 877         Path m = src.resolve(&quot;m&quot;);
 878         tb.writeJavaFiles(m,
 879                           &quot;module m { exports api; }&quot;);
 880         Path apiFile = m.resolve(&quot;api&quot;).resolve(&quot;Api.java&quot;);
 881         Files.createDirectories(apiFile.getParent());
 882         try (BufferedWriter w = Files.newBufferedWriter(apiFile)) {
 883             w.write(&quot;package api;&quot;);
 884         }
 885         Path classes = base.resolve(&quot;classes&quot;);
 886         tb.createDirectories(classes);
 887 
 888         System.err.println(&quot;file explicitly specified:&quot;);
 889 
 890         new JavacTask(tb)
 891             .options(&quot;-XDrawDiagnostics&quot;,
 892                      &quot;--module-source-path&quot;, src.toString())
 893             .outdir(classes)
 894             .files(findJavaFiles(src))
 895             .run()
 896             .writeAll();
 897 
 898         System.err.println(&quot;file not specified:&quot;);
 899 
 900         tb.cleanDirectory(classes);
 901 
 902         new JavacTask(tb)
 903             .options(&quot;-XDrawDiagnostics&quot;,
 904                      &quot;--module-source-path&quot;, src.toString())
 905             .outdir(classes)
 906             .files(findJavaFiles(m.resolve(&quot;module-info.java&quot;)))
 907             .run()
 908             .writeAll();
 909     }
 910 
 911     @Test
 912     public void testWrongPackageInExportedPackage(Path base) throws Exception {
 913         Path src = base.resolve(&quot;src&quot;);
 914         Path m = src.resolve(&quot;m&quot;);
 915         tb.writeJavaFiles(m,
 916                           &quot;module m { exports api; }&quot;);
 917         Path apiFile = m.resolve(&quot;api&quot;).resolve(&quot;Api.java&quot;);
 918         Files.createDirectories(apiFile.getParent());
 919         try (BufferedWriter w = Files.newBufferedWriter(apiFile)) {
 920             w.write(&quot;package impl; public class Api { }&quot;);
 921         }
 922         Path classes = base.resolve(&quot;classes&quot;);
 923         tb.createDirectories(classes);
 924 
 925         List&lt;String&gt; log;
 926 
 927         List&lt;String&gt; expected =
 928                 Arrays.asList(&quot;module-info.java:1:20: compiler.err.package.empty.or.not.found: api&quot;,
 929                               &quot;1 error&quot;);
 930 
 931         System.err.println(&quot;file explicitly specified:&quot;);
 932 
 933         log = new JavacTask(tb)
 934                 .options(&quot;-XDrawDiagnostics&quot;,
 935                          &quot;--module-source-path&quot;, src.toString())
 936                 .outdir(classes)
 937                 .files(findJavaFiles(src))
 938                 .run(Task.Expect.FAIL)
 939                 .writeAll()
 940                 .getOutputLines(Task.OutputKind.DIRECT);
 941 
 942         if (!expected.equals(log))
 943             throw new Exception(&quot;expected output not found: &quot; + log);
 944 
 945         System.err.println(&quot;file not specified:&quot;);
 946 
 947         tb.cleanDirectory(classes);
 948 
 949         log = new JavacTask(tb)
 950                 .options(&quot;-XDrawDiagnostics&quot;,
 951                          &quot;--module-source-path&quot;, src.toString())
 952                 .outdir(classes)
 953                 .files(findJavaFiles(m.resolve(&quot;module-info.java&quot;)))
 954                 .run(Task.Expect.FAIL)
 955                 .writeAll()
 956                 .getOutputLines(Task.OutputKind.DIRECT);
 957 
 958         if (!expected.equals(log))
 959             throw new Exception(&quot;expected output not found: &quot; + log);
 960     }
 961 
 962     @Test
 963     public void testDependOnUnnamedAccessibility(Path base) throws Exception {
 964         Path unnamedSrc = base.resolve(&quot;unnamed-src&quot;);
 965         tb.writeJavaFiles(unnamedSrc,
 966                           &quot;package p1; public class First { public static p2.Second get() { return null; } }&quot;,
 967                           &quot;package p2; public class Second { public void test() { } }&quot;);
 968         Path unnamedClasses = base.resolve(&quot;unnamed-classes&quot;);
 969         tb.createDirectories(unnamedClasses);
 970 
 971         System.err.println(&quot;compiling unnamed sources:&quot;);
 972 
 973         new JavacTask(tb)
 974                 .outdir(unnamedClasses)
 975                 .files(findJavaFiles(unnamedSrc))
 976                 .run()
 977                 .writeAll();
 978 
 979         //test sources:
 980         Path src = base.resolve(&quot;src&quot;);
 981         Path m = src.resolve(&quot;m&quot;);
 982         tb.writeJavaFiles(m,
 983                           &quot;module m { }&quot;,
 984                           &quot;package p; public class Test { { p1.First.get().test(); } }&quot;);
 985         Path classes = base.resolve(&quot;classes&quot;);
 986         tb.createDirectories(classes);
 987 
 988         System.err.println(&quot;compiling test module:&quot;);
 989 
 990         new JavacTask(tb)
 991             .options(&quot;-classpath&quot;, unnamedClasses.toString(),
 992                      &quot;--add-reads&quot;, &quot;m=ALL-UNNAMED&quot;)
 993             .outdir(classes)
 994             .files(findJavaFiles(src))
 995             .run()
 996             .writeAll();
 997     }
 998 
<a name="2" id="anc2"></a><span class="line-added"> 999     @Test</span>
<span class="line-added">1000     public void testMisnamedModuleInfoClass(Path base) throws Exception {</span>
<span class="line-added">1001         Path src = base.resolve(&quot;src&quot;);</span>
<span class="line-added">1002         Path a = src.resolve(&quot;a&quot;);</span>
<span class="line-added">1003         tb.writeJavaFiles(a,</span>
<span class="line-added">1004                           &quot;module a {}&quot;);</span>
<span class="line-added">1005         Path b = src.resolve(&quot;b&quot;);</span>
<span class="line-added">1006         tb.writeJavaFiles(b,</span>
<span class="line-added">1007                           &quot;module b { uses com.example.c; }&quot;);</span>
<span class="line-added">1008         Path classes = base.resolve(&quot;classes&quot;);</span>
<span class="line-added">1009         tb.createDirectories(classes);</span>
<span class="line-added">1010         Path aClasses = classes.resolve(&quot;x&quot;);</span>
<span class="line-added">1011         tb.createDirectories(aClasses);</span>
<span class="line-added">1012 </span>
<span class="line-added">1013         new JavacTask(tb)</span>
<span class="line-added">1014                 .outdir(aClasses)</span>
<span class="line-added">1015                 .files(findJavaFiles(a))</span>
<span class="line-added">1016                 .run()</span>
<span class="line-added">1017                 .writeAll();</span>
<span class="line-added">1018 </span>
<span class="line-added">1019         Path bClasses = classes.resolve(&quot;b&quot;);</span>
<span class="line-added">1020         tb.createDirectories(bClasses);</span>
<span class="line-added">1021 </span>
<span class="line-added">1022         List&lt;String&gt; log;</span>
<span class="line-added">1023 </span>
<span class="line-added">1024         log = new JavacTask(tb)</span>
<span class="line-added">1025                 .outdir(bClasses)</span>
<span class="line-added">1026                 .options(&quot;-p&quot;, classes.toString(),</span>
<span class="line-added">1027                          &quot;-XDrawDiagnostics&quot;)</span>
<span class="line-added">1028                 .files(findJavaFiles(b))</span>
<span class="line-added">1029                 .run(Task.Expect.FAIL)</span>
<span class="line-added">1030                 .writeAll()</span>
<span class="line-added">1031                 .getOutputLines(Task.OutputKind.DIRECT);</span>
<span class="line-added">1032 </span>
<span class="line-added">1033         List&lt;String&gt; expected = List.of(&quot;module-info.java:1:28: compiler.err.doesnt.exist: com.example&quot;,</span>
<span class="line-added">1034                                         &quot;1 error&quot;);</span>
<span class="line-added">1035 </span>
<span class="line-added">1036         if (!expected.equals(log))</span>
<span class="line-added">1037             throw new Exception(&quot;expected output not found: &quot; + log);</span>
<span class="line-added">1038     }</span>
<span class="line-added">1039 </span>
1040 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/processing/model/element/TestSealed.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8227046
 27  * @summary Test basic modeling for sealed classes
 28  * @library /tools/lib /tools/javac/lib
 29  * @modules
 30  *     jdk.compiler/com.sun.tools.javac.api
 31  *     jdk.compiler/com.sun.tools.javac.main
 32  * @build toolbox.ToolBox toolbox.JavacTask JavacTestingAbstractProcessor
 33  * @compile --enable-preview -source ${jdk.version} TestSealed.java
 34  * @run main/othervm --enable-preview TestSealed
 35  */
 36 
 37 import java.io.*;
 38 import java.nio.file.Files;
 39 import java.nio.file.Path;
 40 import java.nio.file.Paths;
 41 import java.util.*;
 42 
 43 import javax.annotation.processing.*;
 44 import javax.lang.model.*;
 45 import javax.lang.model.element.*;
 46 import javax.lang.model.type.*;
 47 import javax.lang.model.util.*;
 48 import java.time.*;
 49 
 50 import javax.tools.Diagnostic.Kind;
 51 
 52 import toolbox.JavacTask;
 53 import toolbox.Task;
 54 import toolbox.Task.Mode;
 55 import toolbox.Task.OutputKind;
 56 import toolbox.TestRunner;
 57 import toolbox.ToolBox;
 58 
 59 public class TestSealed extends TestRunner {
 60 
 61     protected ToolBox tb;
 62 
 63     TestSealed() {
 64         super(System.err);
 65         tb = new ToolBox();
 66     }
 67 
 68     public static void main(String... args) throws Exception {
 69         new TestSealed().runTests();
 70     }
 71 
 72     /**
 73      * Run all methods annotated with @Test, and throw an exception if any
 74      * errors are reported..
 75      *
 76      * @throws Exception if any errors occurred
 77      */
 78     protected void runTests() throws Exception {
 79         runTests(m -&gt; new Object[] { Paths.get(m.getName()) });
 80     }
 81 
 82     Path[] findJavaFiles(Path... paths) throws IOException {
 83         return tb.findJavaFiles(paths);
 84     }
 85 
 86     void checkOutputContains(String log, String... expect) throws Exception {
 87         for (String e : expect) {
 88             if (!log.contains(e)) {
 89                 throw new Exception(&quot;expected output not found: &quot; + e);
 90             }
 91         }
 92     }
 93 
 94     @Test
 95     public void testSealedClassesProcessor(Path base) throws Exception {
 96         Path src = base.resolve(&quot;src&quot;);
 97         Path r = src.resolve(&quot;Test&quot;);
 98 
 99         Path classes = base.resolve(&quot;classes&quot;);
100 
101         Files.createDirectories(classes);
102 
103         tb.writeJavaFiles(r,
104             &quot;&quot;&quot;
105             sealed interface SealedInterface permits NonSealedClass1, SealedClass {}
106 
107             non-sealed class NonSealedClass1 implements SealedInterface {}
108 
109             sealed class SealedClass implements SealedInterface {}
110                 final class FinalClass extends SealedClass {}
111                 non-sealed class NonSealedClass2 extends SealedClass {}
112 
113             class ClassOutOfSealedHierarchy extends NonSealedClass1 {}
114             &quot;&quot;&quot;
115         );
116 
117         List&lt;String&gt; expected = List.of(
118                 &quot;Note: visiting: SealedInterface Modifiers: [abstract, sealed]&quot;,
119                 &quot;Note:     this class has: 2, permitted subclasses&quot;,
120                 &quot;Note:     permitted subclass: NonSealedClass1&quot;,
121                 &quot;Note:     permitted subclass: SealedClass&quot;,
122                 &quot;Note: visiting: NonSealedClass1 Modifiers: [non-sealed]&quot;,
123                 &quot;Note:     this class has: 0, permitted subclasses&quot;,
124                 &quot;Note: visiting: SealedClass Modifiers: [sealed]&quot;,
125                 &quot;Note:     this class has: 2, permitted subclasses&quot;,
126                 &quot;Note:     permitted subclass: FinalClass&quot;,
127                 &quot;Note:     permitted subclass: NonSealedClass2&quot;,
128                 &quot;Note: visiting: FinalClass Modifiers: [final]&quot;,
129                 &quot;Note:     this class has: 0, permitted subclasses&quot;,
130                 &quot;Note: visiting: NonSealedClass2 Modifiers: [non-sealed]&quot;,
131                 &quot;Note:     this class has: 0, permitted subclasses&quot;,
132                 &quot;Note: visiting: ClassOutOfSealedHierarchy Modifiers: []&quot;,
133                 &quot;Note:     this class has: 0, permitted subclasses&quot;,
134                 &quot;Note: testSealedClassesProcessor&quot; + File.separator + &quot;src&quot; + File.separator
135                         + &quot;Test&quot; + File.separator + &quot;SealedInterface.java uses preview language features.&quot;,
136                 &quot;Note: Recompile with -Xlint:preview for details.&quot;
137         );
138 
139         for (Mode mode : new Mode[] {Mode.API}) {
140             List&lt;String&gt; log = new JavacTask(tb, mode)
141                     .options(&quot;-processor&quot;, SealedClassesProcessor.class.getName(),
142                             &quot;--enable-preview&quot;,
143                             &quot;-source&quot;, Integer.toString(Runtime.version().feature()))
144                     .files(findJavaFiles(src))
145                     .outdir(classes)
146                     .run()
147                     .writeAll()
148                     .getOutputLines(Task.OutputKind.DIRECT);
149 
150             System.out.println(&quot;log:&quot; +log);
151 
152             if (!expected.equals(log)) {
153                 if (expected.size() == log.size()) {
154                     for (int i = 0; i &lt; expected.size(); i++) {
155                         if (!expected.get(i).equals(log.get(i))) {
156                             System.err.println(&quot;failing at line &quot; + (i + 1));
157                             System.err.println(&quot;    expecting &quot; + expected.get(i));
158                             System.err.println(&quot;    found &quot; + log.get(i));
159                         }
160                     }
161                 } else {
162                     System.err.println(&quot;expected and log lists differ in length&quot;);
163                 }
164                 throw new AssertionError(&quot;Unexpected output: &quot; + log);
165             }
166         }
167     }
168 
169     public static final class SealedClassesProcessor extends JavacTestingAbstractProcessor {
170 
171         @Override
172         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
173             if (!roundEnv.processingOver()) {
174                 Messager messager = processingEnv.getMessager();
175                 ElementScanner scanner = new SealedScanner(messager);
176                 for(Element rootElement : roundEnv.getRootElements()) {
177                     scanner.visit(rootElement);
178                 }
179             }
180             return true;
181         }
182 
183         class SealedScanner extends ElementScanner&lt;Void, Void&gt; {
184 
185             Messager messager;
186 
187             public SealedScanner(Messager messager) {
188                 this.messager = messager;
189             }
190 
191             @Override
192             public Void visitType(TypeElement element, Void p) {
193                 messager.printMessage(Kind.NOTE, &quot;visiting: &quot; + element.getSimpleName() + &quot; Modifiers: &quot; + element.getModifiers());
194                 List&lt;? extends TypeMirror&gt; permittedSubclasses = element.getPermittedSubclasses();
195                 messager.printMessage(Kind.NOTE, String.format(&quot;    this class has: %d, permitted subclasses&quot;, permittedSubclasses.size()));
196                 for (TypeMirror tm: permittedSubclasses) {
197                     messager.printMessage(Kind.NOTE, String.format(&quot;    permitted subclass: %s&quot;, ((DeclaredType)tm).asElement().getSimpleName()));
198                 }
199                 return super.visitType(element, p);
200             }
201         }
202     }
203 }
    </pre>
  </body>
</html>
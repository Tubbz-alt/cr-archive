<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../incubator/jextract/tool/Main.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../test/jdk/tools/jextract/RepeatedDeclsTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 import java.util.List;
 30 import java.util.Objects;
 31 import java.util.Optional;
 32 import java.util.OptionalLong;
 33 import java.util.function.Supplier;
 34 import jdk.incubator.foreign.MemoryLayout;
 35 import jdk.incubator.jextract.Declaration;
 36 import jdk.incubator.jextract.Type;
 37 
 38 public abstract class TypeImpl implements Type {
 39 
 40     @Override
 41     public boolean isErroneous() {
 42         return false;
 43     }
 44 
 45     static boolean equals(Type t1, Type.Delegated t2) {
 46         assert t1 != null;
 47         assert t2 != null;
 48 
<span class="line-modified"> 49         return (t2.kind() == Delegated.Kind.TYPEDEF)? t1.equals(t2.type()) : false;</span>
 50     }
 51 
 52     public static final TypeImpl ERROR = new TypeImpl() {
 53         @Override
 54         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
 55             return visitor.visitType(this, data);
 56         }
 57 
 58         @Override
 59         public boolean isErroneous() {
 60             return true;
 61         }
 62     };
 63 
 64     public static final class PrimitiveImpl extends TypeImpl implements Type.Primitive {
 65 
 66         private final Primitive.Kind kind;
 67         private final Optional&lt;MemoryLayout&gt; layoutOpt;
 68 
 69         public PrimitiveImpl(Kind kind, MemoryLayout layout) {
</pre>
<hr />
<pre>
 82 
 83         @Override
 84         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
 85             return visitor.visitPrimitive(this, data);
 86         }
 87 
 88         @Override
 89         public Kind kind() {
 90             return kind;
 91         }
 92 
 93         @Override
 94         public Optional&lt;MemoryLayout&gt; layout() {
 95             return layoutOpt;
 96         }
 97 
 98         @Override
 99         public boolean equals(Object o) {
100             if (this == o) return true;
101             if (!(o instanceof Type.Primitive)) {
<span class="line-modified">102                 return (o instanceof Type.Delegated)? equals(this, (Type.Delegated)o) : false;</span>
103             }
104             Type.Primitive primitive = (Type.Primitive) o;
105             return kind == primitive.kind();
106         }
107 
108         @Override
109         public int hashCode() {
110             return Objects.hash(kind);
111         }
112     }
113 
114     static abstract class DelegatedBase extends TypeImpl implements Type.Delegated {
115         Delegated.Kind kind;
116         Optional&lt;String&gt; name;
117 
118         DelegatedBase(Kind kind, Optional&lt;String&gt; name) {
119             this.kind = Objects.requireNonNull(kind);
120             this.name = Objects.requireNonNull(name);
121         }
122 
123         @Override
124         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
125             return visitor.visitDelegated(this, data);
126         }
127 
128         @Override
129         public final Delegated.Kind kind() {
130             return kind;
131         }
132 
133         @Override
134         public final Optional&lt;String&gt; name() {
135             return name;
136         }
137 
138         @Override
139         public boolean equals(Object o) {
140             if (this == o) return true;
141             if (!(o instanceof Type.Delegated)) {
<span class="line-modified">142                 return (o instanceof Type)? equals((Type)o, this) : false;</span>
143             }
144             Type.Delegated that = (Type.Delegated) o;
145             return kind == that.kind() &amp;&amp;
146                     name.equals(that.name());
147         }
148 
149         @Override
150         public int hashCode() {
151             return Objects.hash(kind, name);
152         }
153     }
154 
155     public static final class QualifiedImpl extends DelegatedBase {
156         private final Type type;
157 
158         public QualifiedImpl(Kind kind, Type type) {
159             this(kind, Optional.empty(), type);
160         }
161 
162         public QualifiedImpl(Kind kind, String name, Type type) {
163             this(kind, Optional.of(name), type);
164         }
165 
166         private QualifiedImpl(Kind kind, Optional&lt;String&gt; name, Type type) {
167             super(kind, name);
168             this.type = type;
169         }
170 
171         @Override
172         public Type type() {
173             return type;
174         }
175 
176         @Override
177         public boolean equals(Object o) {
178             if (this == o) return true;
179             if (!(o instanceof Type.Delegated)) return false;
180             if (!super.equals(o)) {
<span class="line-modified">181                 return (o instanceof Type.Delegated)? equals(this, (Type.Delegated)o) : false;</span>
182             }
183             Type.Delegated qualified = (Type.Delegated) o;
184             return Objects.equals(type, qualified.type());
185         }
186 
187         @Override
188         public int hashCode() {
189             return (kind() == Kind.TYPEDEF)? type().hashCode() : Objects.hash(super.hashCode(), type);
190         }
191     }
192 
193     public static final class PointerImpl extends DelegatedBase {
194         private final Supplier&lt;Type&gt; pointeeFactory;
195 
196         public PointerImpl(Supplier&lt;Type&gt; pointeeFactory) {
197             super(Kind.POINTER, Optional.empty());
198             this.pointeeFactory = Objects.requireNonNull(pointeeFactory);
199         }
200 
201         public PointerImpl(Type pointee) {
</pre>
<hr />
<pre>
214 
215         public DeclaredImpl(Declaration.Scoped declaration) {
216             super();
217             this.declaration = Objects.requireNonNull(declaration);
218         }
219 
220         @Override
221         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
222             return visitor.visitDeclared(this, data);
223         }
224 
225         @Override
226         public Declaration.Scoped tree() {
227             return declaration;
228         }
229 
230         @Override
231         public boolean equals(Object o) {
232             if (this == o) return true;
233             if (!(o instanceof Type.Declared)) {
<span class="line-modified">234                 return (o instanceof Type.Delegated)? equals(this, (Type.Delegated)o) : false;</span>
235             }
236             Type.Declared declared = (Type.Declared) o;
237             return declaration.equals(declared.tree());
238         }
239 
240         @Override
241         public int hashCode() {
242             return Objects.hash(declaration);
243         }
244     }
245 
246     public static final class FunctionImpl extends TypeImpl implements Type.Function {
247 
248         private final boolean varargs;
249         private final List&lt;Type&gt; argtypes;
250         private final Type restype;
251 
252         public FunctionImpl(boolean varargs, List&lt;Type&gt; argtypes, Type restype) {
253             super();
254             this.varargs = varargs;
</pre>
<hr />
<pre>
263 
264         @Override
265         public boolean varargs() {
266             return varargs;
267         }
268 
269         @Override
270         public List&lt;Type&gt; argumentTypes() {
271             return argtypes;
272         }
273 
274         @Override
275         public Type returnType() {
276             return restype;
277         }
278 
279         @Override
280         public boolean equals(Object o) {
281             if (this == o) return true;
282             if (!(o instanceof Type.Function)) {
<span class="line-modified">283                 return (o instanceof Type.Delegated)? equals(this, (Type.Delegated)o) : false;</span>
284             }
285             Type.Function function = (Type.Function) o;
286             return varargs == function.varargs() &amp;&amp;
287                     argtypes.equals(function.argumentTypes()) &amp;&amp;
288                     restype.equals(function.returnType());
289         }
290 
291         @Override
292         public int hashCode() {
293             return Objects.hash(varargs, argtypes, restype);
294         }
295     }
296 
297     public static final class ArrayImpl extends TypeImpl implements Type.Array {
298 
299         private final Kind kind;
300         private final OptionalLong elemCount;
301         private final Type elemType;
302 
303         public ArrayImpl(Kind kind, long count, Type elemType) {
</pre>
<hr />
<pre>
322 
323         @Override
324         public OptionalLong elementCount() {
325             return elemCount;
326         }
327 
328         @Override
329         public Type elementType() {
330             return elemType;
331         }
332 
333         @Override
334         public Kind kind() {
335             return kind;
336         }
337 
338         @Override
339         public boolean equals(Object o) {
340             if (this == o) return true;
341             if (!(o instanceof Type.Array)) {
<span class="line-modified">342                 return (o instanceof Type.Delegated)? equals(this, (Type.Delegated)o) : false;</span>
343             }
344             Type.Array array = (Type.Array) o;
345             return kind == array.kind() &amp;&amp;
346                     elemType.equals(array.elementType());
347         }
348 
349         @Override
350         public int hashCode() {
351             return Objects.hash(kind, elemType);
352         }
353     }
354 
355     @Override
356     public String toString() {
357         return PrettyPrinter.type(this);
358     }
359 }
</pre>
</td>
<td>
<hr />
<pre>
 29 import java.util.List;
 30 import java.util.Objects;
 31 import java.util.Optional;
 32 import java.util.OptionalLong;
 33 import java.util.function.Supplier;
 34 import jdk.incubator.foreign.MemoryLayout;
 35 import jdk.incubator.jextract.Declaration;
 36 import jdk.incubator.jextract.Type;
 37 
 38 public abstract class TypeImpl implements Type {
 39 
 40     @Override
 41     public boolean isErroneous() {
 42         return false;
 43     }
 44 
 45     static boolean equals(Type t1, Type.Delegated t2) {
 46         assert t1 != null;
 47         assert t2 != null;
 48 
<span class="line-modified"> 49         return (t2.kind() == Delegated.Kind.TYPEDEF) &amp;&amp; t1.equals(t2.type());</span>
 50     }
 51 
 52     public static final TypeImpl ERROR = new TypeImpl() {
 53         @Override
 54         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
 55             return visitor.visitType(this, data);
 56         }
 57 
 58         @Override
 59         public boolean isErroneous() {
 60             return true;
 61         }
 62     };
 63 
 64     public static final class PrimitiveImpl extends TypeImpl implements Type.Primitive {
 65 
 66         private final Primitive.Kind kind;
 67         private final Optional&lt;MemoryLayout&gt; layoutOpt;
 68 
 69         public PrimitiveImpl(Kind kind, MemoryLayout layout) {
</pre>
<hr />
<pre>
 82 
 83         @Override
 84         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
 85             return visitor.visitPrimitive(this, data);
 86         }
 87 
 88         @Override
 89         public Kind kind() {
 90             return kind;
 91         }
 92 
 93         @Override
 94         public Optional&lt;MemoryLayout&gt; layout() {
 95             return layoutOpt;
 96         }
 97 
 98         @Override
 99         public boolean equals(Object o) {
100             if (this == o) return true;
101             if (!(o instanceof Type.Primitive)) {
<span class="line-modified">102                 return (o instanceof Delegated) &amp;&amp; equals(this, (Delegated)o);</span>
103             }
104             Type.Primitive primitive = (Type.Primitive) o;
105             return kind == primitive.kind();
106         }
107 
108         @Override
109         public int hashCode() {
110             return Objects.hash(kind);
111         }
112     }
113 
114     static abstract class DelegatedBase extends TypeImpl implements Type.Delegated {
115         Delegated.Kind kind;
116         Optional&lt;String&gt; name;
117 
118         DelegatedBase(Kind kind, Optional&lt;String&gt; name) {
119             this.kind = Objects.requireNonNull(kind);
120             this.name = Objects.requireNonNull(name);
121         }
122 
123         @Override
124         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
125             return visitor.visitDelegated(this, data);
126         }
127 
128         @Override
129         public final Delegated.Kind kind() {
130             return kind;
131         }
132 
133         @Override
134         public final Optional&lt;String&gt; name() {
135             return name;
136         }
137 
138         @Override
139         public boolean equals(Object o) {
140             if (this == o) return true;
141             if (!(o instanceof Type.Delegated)) {
<span class="line-modified">142                 return (o instanceof Type) &amp;&amp; equals((Type)o, this);</span>
143             }
144             Type.Delegated that = (Type.Delegated) o;
145             return kind == that.kind() &amp;&amp;
146                     name.equals(that.name());
147         }
148 
149         @Override
150         public int hashCode() {
151             return Objects.hash(kind, name);
152         }
153     }
154 
155     public static final class QualifiedImpl extends DelegatedBase {
156         private final Type type;
157 
158         public QualifiedImpl(Kind kind, Type type) {
159             this(kind, Optional.empty(), type);
160         }
161 
162         public QualifiedImpl(Kind kind, String name, Type type) {
163             this(kind, Optional.of(name), type);
164         }
165 
166         private QualifiedImpl(Kind kind, Optional&lt;String&gt; name, Type type) {
167             super(kind, name);
168             this.type = type;
169         }
170 
171         @Override
172         public Type type() {
173             return type;
174         }
175 
176         @Override
177         public boolean equals(Object o) {
178             if (this == o) return true;
179             if (!(o instanceof Type.Delegated)) return false;
180             if (!super.equals(o)) {
<span class="line-modified">181                 return (o instanceof Delegated) &amp;&amp; equals(this, (Delegated) o);</span>
182             }
183             Type.Delegated qualified = (Type.Delegated) o;
184             return Objects.equals(type, qualified.type());
185         }
186 
187         @Override
188         public int hashCode() {
189             return (kind() == Kind.TYPEDEF)? type().hashCode() : Objects.hash(super.hashCode(), type);
190         }
191     }
192 
193     public static final class PointerImpl extends DelegatedBase {
194         private final Supplier&lt;Type&gt; pointeeFactory;
195 
196         public PointerImpl(Supplier&lt;Type&gt; pointeeFactory) {
197             super(Kind.POINTER, Optional.empty());
198             this.pointeeFactory = Objects.requireNonNull(pointeeFactory);
199         }
200 
201         public PointerImpl(Type pointee) {
</pre>
<hr />
<pre>
214 
215         public DeclaredImpl(Declaration.Scoped declaration) {
216             super();
217             this.declaration = Objects.requireNonNull(declaration);
218         }
219 
220         @Override
221         public &lt;R, D&gt; R accept(Visitor&lt;R, D&gt; visitor, D data) {
222             return visitor.visitDeclared(this, data);
223         }
224 
225         @Override
226         public Declaration.Scoped tree() {
227             return declaration;
228         }
229 
230         @Override
231         public boolean equals(Object o) {
232             if (this == o) return true;
233             if (!(o instanceof Type.Declared)) {
<span class="line-modified">234                 return (o instanceof Delegated) &amp;&amp; equals(this, (Delegated) o);</span>
235             }
236             Type.Declared declared = (Type.Declared) o;
237             return declaration.equals(declared.tree());
238         }
239 
240         @Override
241         public int hashCode() {
242             return Objects.hash(declaration);
243         }
244     }
245 
246     public static final class FunctionImpl extends TypeImpl implements Type.Function {
247 
248         private final boolean varargs;
249         private final List&lt;Type&gt; argtypes;
250         private final Type restype;
251 
252         public FunctionImpl(boolean varargs, List&lt;Type&gt; argtypes, Type restype) {
253             super();
254             this.varargs = varargs;
</pre>
<hr />
<pre>
263 
264         @Override
265         public boolean varargs() {
266             return varargs;
267         }
268 
269         @Override
270         public List&lt;Type&gt; argumentTypes() {
271             return argtypes;
272         }
273 
274         @Override
275         public Type returnType() {
276             return restype;
277         }
278 
279         @Override
280         public boolean equals(Object o) {
281             if (this == o) return true;
282             if (!(o instanceof Type.Function)) {
<span class="line-modified">283                 return (o instanceof Delegated) &amp;&amp; equals(this, (Delegated) o);</span>
284             }
285             Type.Function function = (Type.Function) o;
286             return varargs == function.varargs() &amp;&amp;
287                     argtypes.equals(function.argumentTypes()) &amp;&amp;
288                     restype.equals(function.returnType());
289         }
290 
291         @Override
292         public int hashCode() {
293             return Objects.hash(varargs, argtypes, restype);
294         }
295     }
296 
297     public static final class ArrayImpl extends TypeImpl implements Type.Array {
298 
299         private final Kind kind;
300         private final OptionalLong elemCount;
301         private final Type elemType;
302 
303         public ArrayImpl(Kind kind, long count, Type elemType) {
</pre>
<hr />
<pre>
322 
323         @Override
324         public OptionalLong elementCount() {
325             return elemCount;
326         }
327 
328         @Override
329         public Type elementType() {
330             return elemType;
331         }
332 
333         @Override
334         public Kind kind() {
335             return kind;
336         }
337 
338         @Override
339         public boolean equals(Object o) {
340             if (this == o) return true;
341             if (!(o instanceof Type.Array)) {
<span class="line-modified">342                 return (o instanceof Delegated) &amp;&amp; equals(this, (Delegated) o);</span>
343             }
344             Type.Array array = (Type.Array) o;
345             return kind == array.kind() &amp;&amp;
346                     elemType.equals(array.elementType());
347         }
348 
349         @Override
350         public int hashCode() {
351             return Objects.hash(kind, elemType);
352         }
353     }
354 
355     @Override
356     public String toString() {
357         return PrettyPrinter.type(this);
358     }
359 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../incubator/jextract/tool/Main.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../test/jdk/tools/jextract/RepeatedDeclsTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
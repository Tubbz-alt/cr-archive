<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff doc/building.html</title>
    <link rel="stylesheet" href="../style.css" />
  </head>
<body>
<center><a href="../bin/unshuffle_list.txt.sdiff.html" target="_top">&lt; prev</a> <a href="../index.html" target="_top">index</a> <a href="building.md.sdiff.html" target="_top">next &gt;</a></center>    <h2>doc/building.html</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 519 &lt;p&gt;If a configure argument exists, use that instead, e.g. use &lt;code&gt;--with-jtreg&lt;/code&gt; instead of setting &lt;code&gt;JTREGEXE&lt;/code&gt;.&lt;/p&gt;
 520 &lt;p&gt;Also note that, despite what autoconf claims, setting &lt;code&gt;CFLAGS&lt;/code&gt; will not accomplish anything. Instead use &lt;code&gt;--with-extra-cflags&lt;/code&gt; (and similar for &lt;code&gt;cxxflags&lt;/code&gt; and &lt;code&gt;ldflags&lt;/code&gt;).&lt;/p&gt;
 521 &lt;h2 id=&quot;running-make&quot;&gt;Running Make&lt;/h2&gt;
 522 &lt;p&gt;When you have a proper configuration, all you need to do to build the JDK is to run &lt;code&gt;make&lt;/code&gt;. (But see the warning at &lt;a href=&quot;#gnu-make&quot;&gt;GNU Make&lt;/a&gt; about running the correct version of make.)&lt;/p&gt;
 523 &lt;p&gt;When running &lt;code&gt;make&lt;/code&gt; without any arguments, the default target is used, which is the same as running &lt;code&gt;make default&lt;/code&gt; or &lt;code&gt;make jdk&lt;/code&gt;. This will build a minimal (or roughly minimal) set of compiled output (known as an &amp;quot;exploded image&amp;quot;) needed for a developer to actually execute the newly built JDK. The idea is that in an incremental development fashion, when doing a normal make, you should only spend time recompiling what&#39;s changed (making it purely incremental) and only do the work that&#39;s needed to actually run and test your code.&lt;/p&gt;
 524 &lt;p&gt;The output of the exploded image resides in &lt;code&gt;$BUILD/jdk&lt;/code&gt;. You can test the newly built JDK like this: &lt;code&gt;$BUILD/jdk/bin/java -version&lt;/code&gt;.&lt;/p&gt;
 525 &lt;h3 id=&quot;common-make-targets&quot;&gt;Common Make Targets&lt;/h3&gt;
 526 &lt;p&gt;Apart from the default target, here are some common make targets:&lt;/p&gt;
 527 &lt;ul&gt;
 528 &lt;li&gt;&lt;code&gt;hotspot&lt;/code&gt; - Build all of hotspot (but only hotspot)&lt;/li&gt;
 529 &lt;li&gt;&lt;code&gt;hotspot-&amp;lt;variant&amp;gt;&lt;/code&gt; - Build just the specified jvm variant&lt;/li&gt;
 530 &lt;li&gt;&lt;code&gt;images&lt;/code&gt; or &lt;code&gt;product-images&lt;/code&gt; - Build the JDK image&lt;/li&gt;
 531 &lt;li&gt;&lt;code&gt;docs&lt;/code&gt; or &lt;code&gt;docs-image&lt;/code&gt; - Build the documentation image&lt;/li&gt;
 532 &lt;li&gt;&lt;code&gt;test-image&lt;/code&gt; - Build the test image&lt;/li&gt;
 533 &lt;li&gt;&lt;code&gt;all&lt;/code&gt; or &lt;code&gt;all-images&lt;/code&gt; - Build all images (product, docs and test)&lt;/li&gt;
 534 &lt;li&gt;&lt;code&gt;bootcycle-images&lt;/code&gt; - Build images twice, second time with newly built JDK (good for testing)&lt;/li&gt;
 535 &lt;li&gt;&lt;code&gt;clean&lt;/code&gt; - Remove all files generated by make, but not those generated by configure&lt;/li&gt;
 536 &lt;li&gt;&lt;code&gt;dist-clean&lt;/code&gt; - Remove all files, including configuration&lt;/li&gt;
 537 &lt;/ul&gt;
 538 &lt;p&gt;Run &lt;code&gt;make help&lt;/code&gt; to get an up-to-date list of important make targets and make control variables.&lt;/p&gt;
<span class="line-modified"> 539 &lt;p&gt;It is possible to build just a single module, a single phase, or a single phase of a single module, by creating make targets according to these followin patterns. A phase can be either of &lt;code&gt;gensrc&lt;/code&gt;, &lt;code&gt;gendata&lt;/code&gt;, &lt;code&gt;copy&lt;/code&gt;, &lt;code&gt;java&lt;/code&gt;, &lt;code&gt;launchers&lt;/code&gt;, &lt;code&gt;libs&lt;/code&gt; or &lt;code&gt;rmic&lt;/code&gt;. See &lt;a href=&quot;#using-fine-grained-make-targets&quot;&gt;Using Fine-Grained Make Targets&lt;/a&gt; for more details about this functionality.&lt;/p&gt;</span>
 540 &lt;ul&gt;
 541 &lt;li&gt;&lt;code&gt;&amp;lt;phase&amp;gt;&lt;/code&gt; - Build the specified phase and everything it depends on&lt;/li&gt;
 542 &lt;li&gt;&lt;code&gt;&amp;lt;module&amp;gt;&lt;/code&gt; - Build the specified module and everything it depends on&lt;/li&gt;
 543 &lt;li&gt;&lt;code&gt;&amp;lt;module&amp;gt;-&amp;lt;phase&amp;gt;&lt;/code&gt; - Compile the specified phase for the specified module and everything it depends on&lt;/li&gt;
 544 &lt;/ul&gt;
 545 &lt;p&gt;Similarly, it is possible to clean just a part of the build by creating make targets according to these patterns:&lt;/p&gt;
 546 &lt;ul&gt;
 547 &lt;li&gt;&lt;code&gt;clean-&amp;lt;outputdir&amp;gt;&lt;/code&gt; - Remove the subdir in the output dir with the name&lt;/li&gt;
 548 &lt;li&gt;&lt;code&gt;clean-&amp;lt;phase&amp;gt;&lt;/code&gt; - Remove all build results related to a certain build phase&lt;/li&gt;
 549 &lt;li&gt;&lt;code&gt;clean-&amp;lt;module&amp;gt;&lt;/code&gt; - Remove all build results related to a certain module&lt;/li&gt;
 550 &lt;li&gt;&lt;code&gt;clean-&amp;lt;module&amp;gt;-&amp;lt;phase&amp;gt;&lt;/code&gt; - Remove all build results related to a certain module and phase&lt;/li&gt;
 551 &lt;/ul&gt;
 552 &lt;h3 id=&quot;make-control-variables&quot;&gt;Make Control Variables&lt;/h3&gt;
 553 &lt;p&gt;It is possible to control &lt;code&gt;make&lt;/code&gt; behavior by overriding the value of &lt;code&gt;make&lt;/code&gt; variables, either on the command line or in the environment.&lt;/p&gt;
 554 &lt;p&gt;Normally, this is &lt;strong&gt;not recommended&lt;/strong&gt;. If used improperly, it can lead to a broken build. Unless you&#39;re well versed in the build system, this is hard to use properly. Therefore, &lt;code&gt;make&lt;/code&gt; will print a warning if this is detected.&lt;/p&gt;
 555 &lt;p&gt;However, there are a few &lt;code&gt;make&lt;/code&gt; variables, known as &lt;em&gt;control variables&lt;/em&gt; that are supposed to be overriden on the command line. These make up the &amp;quot;make time&amp;quot; configuration, as opposed to the &amp;quot;configure time&amp;quot; configuration.&lt;/p&gt;
 556 &lt;h4 id=&quot;general-make-control-variables&quot;&gt;General Make Control Variables&lt;/h4&gt;
 557 &lt;ul&gt;
 558 &lt;li&gt;&lt;code&gt;JOBS&lt;/code&gt; - Specify the number of jobs to build with. See &lt;a href=&quot;#build-performance&quot;&gt;Build Performance&lt;/a&gt;.&lt;/li&gt;
 559 &lt;li&gt;&lt;code&gt;LOG&lt;/code&gt; - Specify the logging level and functionality. See &lt;a href=&quot;#checking-the-build-log-file&quot;&gt;Checking the Build Log File&lt;/a&gt;&lt;/li&gt;
</pre>
<hr />
<pre>
 912 &lt;h3 id=&quot;handling-reconfigurations&quot;&gt;Handling Reconfigurations&lt;/h3&gt;
 913 &lt;p&gt;If you update the repository and part of the configure script has changed, the build system will force you to re-run &lt;code&gt;configure&lt;/code&gt;.&lt;/p&gt;
 914 &lt;p&gt;Most of the time, you will be fine by running &lt;code&gt;configure&lt;/code&gt; again with the same arguments as the last time, which can easily be performed by &lt;code&gt;make reconfigure&lt;/code&gt;. To simplify this, you can use the &lt;code&gt;CONF_CHECK&lt;/code&gt; make control variable, either as &lt;code&gt;make CONF_CHECK=auto&lt;/code&gt;, or by setting an environment variable. For instance, if you add &lt;code&gt;export CONF_CHECK=auto&lt;/code&gt; to your &lt;code&gt;.bashrc&lt;/code&gt; file, &lt;code&gt;make&lt;/code&gt; will always run &lt;code&gt;reconfigure&lt;/code&gt; automatically whenever the configure script has changed.&lt;/p&gt;
 915 &lt;p&gt;You can also use &lt;code&gt;CONF_CHECK=ignore&lt;/code&gt; to skip the check for a needed configure update. This might speed up the build, but comes at the risk of an incorrect build result. This is only recommended if you know what you&#39;re doing.&lt;/p&gt;
 916 &lt;p&gt;From time to time, you will also need to modify the command line to &lt;code&gt;configure&lt;/code&gt; due to changes. Use &lt;code&gt;make print-configure&lt;/code&gt; to show the command line used for your current configuration.&lt;/p&gt;
 917 &lt;h3 id=&quot;using-fine-grained-make-targets&quot;&gt;Using Fine-Grained Make Targets&lt;/h3&gt;
 918 &lt;p&gt;The default behavior for make is to create consistent and correct output, at the expense of build speed, if necessary.&lt;/p&gt;
 919 &lt;p&gt;If you are prepared to take some risk of an incorrect build, and know enough of the system to understand how things build and interact, you can speed up the build process considerably by instructing make to only build a portion of the product.&lt;/p&gt;
 920 &lt;h4 id=&quot;building-individual-modules&quot;&gt;Building Individual Modules&lt;/h4&gt;
 921 &lt;p&gt;The safe way to use fine-grained make targets is to use the module specific make targets. All source code in the JDK is organized so it belongs to a module, e.g. &lt;code&gt;java.base&lt;/code&gt; or &lt;code&gt;jdk.jdwp.agent&lt;/code&gt;. You can build only a specific module, by giving it as make target: &lt;code&gt;make jdk.jdwp.agent&lt;/code&gt;. If the specified module depends on other modules (e.g. &lt;code&gt;java.base&lt;/code&gt;), those modules will be built first.&lt;/p&gt;
 922 &lt;p&gt;You can also specify a set of modules, just as you can always specify a set of make targets: &lt;code&gt;make jdk.crypto.cryptoki jdk.crypto.ec jdk.crypto.mscapi jdk.crypto.ucrypto&lt;/code&gt;&lt;/p&gt;
 923 &lt;h4 id=&quot;building-individual-module-phases&quot;&gt;Building Individual Module Phases&lt;/h4&gt;
 924 &lt;p&gt;The build process for each module is divided into separate phases. Not all modules need all phases. Which are needed depends on what kind of source code and other artifact the module consists of. The phases are:&lt;/p&gt;
 925 &lt;ul&gt;
 926 &lt;li&gt;&lt;code&gt;gensrc&lt;/code&gt; (Generate source code to compile)&lt;/li&gt;
 927 &lt;li&gt;&lt;code&gt;gendata&lt;/code&gt; (Generate non-source code artifacts)&lt;/li&gt;
 928 &lt;li&gt;&lt;code&gt;copy&lt;/code&gt; (Copy resource artifacts)&lt;/li&gt;
 929 &lt;li&gt;&lt;code&gt;java&lt;/code&gt; (Compile Java code)&lt;/li&gt;
 930 &lt;li&gt;&lt;code&gt;launchers&lt;/code&gt; (Compile native executables)&lt;/li&gt;
 931 &lt;li&gt;&lt;code&gt;libs&lt;/code&gt; (Compile native libraries)&lt;/li&gt;
<span class="line-removed"> 932 &lt;li&gt;&lt;code&gt;rmic&lt;/code&gt; (Run the &lt;code&gt;rmic&lt;/code&gt; tool)&lt;/li&gt;</span>
 933 &lt;/ul&gt;
 934 &lt;p&gt;You can build only a single phase for a module by using the notation &lt;code&gt;$MODULE-$PHASE&lt;/code&gt;. For instance, to build the &lt;code&gt;gensrc&lt;/code&gt; phase for &lt;code&gt;java.base&lt;/code&gt;, use &lt;code&gt;make java.base-gensrc&lt;/code&gt;.&lt;/p&gt;
 935 &lt;p&gt;Note that some phases may depend on others, e.g. &lt;code&gt;java&lt;/code&gt; depends on &lt;code&gt;gensrc&lt;/code&gt; (if present). Make will build all needed prerequisites before building the requested phase.&lt;/p&gt;
 936 &lt;h4 id=&quot;skipping-the-dependency-check&quot;&gt;Skipping the Dependency Check&lt;/h4&gt;
 937 &lt;p&gt;When using an iterative development style with frequent quick rebuilds, the dependency check made by make can take up a significant portion of the time spent on the rebuild. In such cases, it can be useful to bypass the dependency check in make.&lt;/p&gt;
 938 &lt;blockquote&gt;
 939 &lt;p&gt;&lt;strong&gt;Note that if used incorrectly, this can lead to a broken build!&lt;/strong&gt;&lt;/p&gt;
 940 &lt;/blockquote&gt;
 941 &lt;p&gt;To achieve this, append &lt;code&gt;-only&lt;/code&gt; to the build target. For instance, &lt;code&gt;make jdk.jdwp.agent-java-only&lt;/code&gt; will &lt;em&gt;only&lt;/em&gt; build the &lt;code&gt;java&lt;/code&gt; phase of the &lt;code&gt;jdk.jdwp.agent&lt;/code&gt; module. If the required dependencies are not present, the build can fail. On the other hand, the execution time measures in milliseconds.&lt;/p&gt;
 942 &lt;p&gt;A useful pattern is to build the first time normally (e.g. &lt;code&gt;make jdk.jdwp.agent&lt;/code&gt;) and then on subsequent builds, use the &lt;code&gt;-only&lt;/code&gt; make target.&lt;/p&gt;
 943 &lt;h4 id=&quot;rebuilding-part-of-java.base-jdk_filter&quot;&gt;Rebuilding Part of java.base (JDK_FILTER)&lt;/h4&gt;
 944 &lt;p&gt;If you are modifying files in &lt;code&gt;java.base&lt;/code&gt;, which is the by far largest module in the JDK, then you need to rebuild all those files whenever a single file has changed. (This inefficiency will hopefully be addressed in JDK 10.)&lt;/p&gt;
 945 &lt;p&gt;As a hack, you can use the make control variable &lt;code&gt;JDK_FILTER&lt;/code&gt; to specify a pattern that will be used to limit the set of files being recompiled. For instance, &lt;code&gt;make java.base JDK_FILTER=javax/crypto&lt;/code&gt; (or, to combine methods, &lt;code&gt;make java.base-java-only JDK_FILTER=javax/crypto&lt;/code&gt;) will limit the compilation to files in the &lt;code&gt;javax.crypto&lt;/code&gt; package.&lt;/p&gt;
 946 &lt;h3 id=&quot;learn-about-mercurial&quot;&gt;Learn About Mercurial&lt;/h3&gt;
 947 &lt;p&gt;To become an efficient JDK developer, it is recommended that you invest in learning Mercurial properly. Here are some links that can get you started:&lt;/p&gt;
 948 &lt;ul&gt;
 949 &lt;li&gt;&lt;a href=&quot;http://www.mercurial-scm.org/wiki/GitConcepts&quot;&gt;Mercurial for git users&lt;/a&gt;&lt;/li&gt;
 950 &lt;li&gt;&lt;a href=&quot;http://www.mercurial-scm.org/wiki/Tutorial&quot;&gt;The official Mercurial tutorial&lt;/a&gt;&lt;/li&gt;
 951 &lt;li&gt;&lt;a href=&quot;http://hginit.com/&quot;&gt;hg init&lt;/a&gt;&lt;/li&gt;
 952 &lt;li&gt;&lt;a href=&quot;http://hgbook.red-bean.com/read/&quot;&gt;Mercurial: The Definitive Guide&lt;/a&gt;&lt;/li&gt;
</pre>
</td>
<td>
<hr />
<pre>
 519 &lt;p&gt;If a configure argument exists, use that instead, e.g. use &lt;code&gt;--with-jtreg&lt;/code&gt; instead of setting &lt;code&gt;JTREGEXE&lt;/code&gt;.&lt;/p&gt;
 520 &lt;p&gt;Also note that, despite what autoconf claims, setting &lt;code&gt;CFLAGS&lt;/code&gt; will not accomplish anything. Instead use &lt;code&gt;--with-extra-cflags&lt;/code&gt; (and similar for &lt;code&gt;cxxflags&lt;/code&gt; and &lt;code&gt;ldflags&lt;/code&gt;).&lt;/p&gt;
 521 &lt;h2 id=&quot;running-make&quot;&gt;Running Make&lt;/h2&gt;
 522 &lt;p&gt;When you have a proper configuration, all you need to do to build the JDK is to run &lt;code&gt;make&lt;/code&gt;. (But see the warning at &lt;a href=&quot;#gnu-make&quot;&gt;GNU Make&lt;/a&gt; about running the correct version of make.)&lt;/p&gt;
 523 &lt;p&gt;When running &lt;code&gt;make&lt;/code&gt; without any arguments, the default target is used, which is the same as running &lt;code&gt;make default&lt;/code&gt; or &lt;code&gt;make jdk&lt;/code&gt;. This will build a minimal (or roughly minimal) set of compiled output (known as an &amp;quot;exploded image&amp;quot;) needed for a developer to actually execute the newly built JDK. The idea is that in an incremental development fashion, when doing a normal make, you should only spend time recompiling what&#39;s changed (making it purely incremental) and only do the work that&#39;s needed to actually run and test your code.&lt;/p&gt;
 524 &lt;p&gt;The output of the exploded image resides in &lt;code&gt;$BUILD/jdk&lt;/code&gt;. You can test the newly built JDK like this: &lt;code&gt;$BUILD/jdk/bin/java -version&lt;/code&gt;.&lt;/p&gt;
 525 &lt;h3 id=&quot;common-make-targets&quot;&gt;Common Make Targets&lt;/h3&gt;
 526 &lt;p&gt;Apart from the default target, here are some common make targets:&lt;/p&gt;
 527 &lt;ul&gt;
 528 &lt;li&gt;&lt;code&gt;hotspot&lt;/code&gt; - Build all of hotspot (but only hotspot)&lt;/li&gt;
 529 &lt;li&gt;&lt;code&gt;hotspot-&amp;lt;variant&amp;gt;&lt;/code&gt; - Build just the specified jvm variant&lt;/li&gt;
 530 &lt;li&gt;&lt;code&gt;images&lt;/code&gt; or &lt;code&gt;product-images&lt;/code&gt; - Build the JDK image&lt;/li&gt;
 531 &lt;li&gt;&lt;code&gt;docs&lt;/code&gt; or &lt;code&gt;docs-image&lt;/code&gt; - Build the documentation image&lt;/li&gt;
 532 &lt;li&gt;&lt;code&gt;test-image&lt;/code&gt; - Build the test image&lt;/li&gt;
 533 &lt;li&gt;&lt;code&gt;all&lt;/code&gt; or &lt;code&gt;all-images&lt;/code&gt; - Build all images (product, docs and test)&lt;/li&gt;
 534 &lt;li&gt;&lt;code&gt;bootcycle-images&lt;/code&gt; - Build images twice, second time with newly built JDK (good for testing)&lt;/li&gt;
 535 &lt;li&gt;&lt;code&gt;clean&lt;/code&gt; - Remove all files generated by make, but not those generated by configure&lt;/li&gt;
 536 &lt;li&gt;&lt;code&gt;dist-clean&lt;/code&gt; - Remove all files, including configuration&lt;/li&gt;
 537 &lt;/ul&gt;
 538 &lt;p&gt;Run &lt;code&gt;make help&lt;/code&gt; to get an up-to-date list of important make targets and make control variables.&lt;/p&gt;
<span class="line-modified"> 539 &lt;p&gt;It is possible to build just a single module, a single phase, or a single phase of a single module, by creating make targets according to these followin patterns. A phase can be either of &lt;code&gt;gensrc&lt;/code&gt;, &lt;code&gt;gendata&lt;/code&gt;, &lt;code&gt;copy&lt;/code&gt;, &lt;code&gt;java&lt;/code&gt;, &lt;code&gt;launchers&lt;/code&gt;, or &lt;code&gt;libs&lt;/code&gt;. See &lt;a href=&quot;#using-fine-grained-make-targets&quot;&gt;Using Fine-Grained Make Targets&lt;/a&gt; for more details about this functionality.&lt;/p&gt;</span>
 540 &lt;ul&gt;
 541 &lt;li&gt;&lt;code&gt;&amp;lt;phase&amp;gt;&lt;/code&gt; - Build the specified phase and everything it depends on&lt;/li&gt;
 542 &lt;li&gt;&lt;code&gt;&amp;lt;module&amp;gt;&lt;/code&gt; - Build the specified module and everything it depends on&lt;/li&gt;
 543 &lt;li&gt;&lt;code&gt;&amp;lt;module&amp;gt;-&amp;lt;phase&amp;gt;&lt;/code&gt; - Compile the specified phase for the specified module and everything it depends on&lt;/li&gt;
 544 &lt;/ul&gt;
 545 &lt;p&gt;Similarly, it is possible to clean just a part of the build by creating make targets according to these patterns:&lt;/p&gt;
 546 &lt;ul&gt;
 547 &lt;li&gt;&lt;code&gt;clean-&amp;lt;outputdir&amp;gt;&lt;/code&gt; - Remove the subdir in the output dir with the name&lt;/li&gt;
 548 &lt;li&gt;&lt;code&gt;clean-&amp;lt;phase&amp;gt;&lt;/code&gt; - Remove all build results related to a certain build phase&lt;/li&gt;
 549 &lt;li&gt;&lt;code&gt;clean-&amp;lt;module&amp;gt;&lt;/code&gt; - Remove all build results related to a certain module&lt;/li&gt;
 550 &lt;li&gt;&lt;code&gt;clean-&amp;lt;module&amp;gt;-&amp;lt;phase&amp;gt;&lt;/code&gt; - Remove all build results related to a certain module and phase&lt;/li&gt;
 551 &lt;/ul&gt;
 552 &lt;h3 id=&quot;make-control-variables&quot;&gt;Make Control Variables&lt;/h3&gt;
 553 &lt;p&gt;It is possible to control &lt;code&gt;make&lt;/code&gt; behavior by overriding the value of &lt;code&gt;make&lt;/code&gt; variables, either on the command line or in the environment.&lt;/p&gt;
 554 &lt;p&gt;Normally, this is &lt;strong&gt;not recommended&lt;/strong&gt;. If used improperly, it can lead to a broken build. Unless you&#39;re well versed in the build system, this is hard to use properly. Therefore, &lt;code&gt;make&lt;/code&gt; will print a warning if this is detected.&lt;/p&gt;
 555 &lt;p&gt;However, there are a few &lt;code&gt;make&lt;/code&gt; variables, known as &lt;em&gt;control variables&lt;/em&gt; that are supposed to be overriden on the command line. These make up the &amp;quot;make time&amp;quot; configuration, as opposed to the &amp;quot;configure time&amp;quot; configuration.&lt;/p&gt;
 556 &lt;h4 id=&quot;general-make-control-variables&quot;&gt;General Make Control Variables&lt;/h4&gt;
 557 &lt;ul&gt;
 558 &lt;li&gt;&lt;code&gt;JOBS&lt;/code&gt; - Specify the number of jobs to build with. See &lt;a href=&quot;#build-performance&quot;&gt;Build Performance&lt;/a&gt;.&lt;/li&gt;
 559 &lt;li&gt;&lt;code&gt;LOG&lt;/code&gt; - Specify the logging level and functionality. See &lt;a href=&quot;#checking-the-build-log-file&quot;&gt;Checking the Build Log File&lt;/a&gt;&lt;/li&gt;
</pre>
<hr />
<pre>
 912 &lt;h3 id=&quot;handling-reconfigurations&quot;&gt;Handling Reconfigurations&lt;/h3&gt;
 913 &lt;p&gt;If you update the repository and part of the configure script has changed, the build system will force you to re-run &lt;code&gt;configure&lt;/code&gt;.&lt;/p&gt;
 914 &lt;p&gt;Most of the time, you will be fine by running &lt;code&gt;configure&lt;/code&gt; again with the same arguments as the last time, which can easily be performed by &lt;code&gt;make reconfigure&lt;/code&gt;. To simplify this, you can use the &lt;code&gt;CONF_CHECK&lt;/code&gt; make control variable, either as &lt;code&gt;make CONF_CHECK=auto&lt;/code&gt;, or by setting an environment variable. For instance, if you add &lt;code&gt;export CONF_CHECK=auto&lt;/code&gt; to your &lt;code&gt;.bashrc&lt;/code&gt; file, &lt;code&gt;make&lt;/code&gt; will always run &lt;code&gt;reconfigure&lt;/code&gt; automatically whenever the configure script has changed.&lt;/p&gt;
 915 &lt;p&gt;You can also use &lt;code&gt;CONF_CHECK=ignore&lt;/code&gt; to skip the check for a needed configure update. This might speed up the build, but comes at the risk of an incorrect build result. This is only recommended if you know what you&#39;re doing.&lt;/p&gt;
 916 &lt;p&gt;From time to time, you will also need to modify the command line to &lt;code&gt;configure&lt;/code&gt; due to changes. Use &lt;code&gt;make print-configure&lt;/code&gt; to show the command line used for your current configuration.&lt;/p&gt;
 917 &lt;h3 id=&quot;using-fine-grained-make-targets&quot;&gt;Using Fine-Grained Make Targets&lt;/h3&gt;
 918 &lt;p&gt;The default behavior for make is to create consistent and correct output, at the expense of build speed, if necessary.&lt;/p&gt;
 919 &lt;p&gt;If you are prepared to take some risk of an incorrect build, and know enough of the system to understand how things build and interact, you can speed up the build process considerably by instructing make to only build a portion of the product.&lt;/p&gt;
 920 &lt;h4 id=&quot;building-individual-modules&quot;&gt;Building Individual Modules&lt;/h4&gt;
 921 &lt;p&gt;The safe way to use fine-grained make targets is to use the module specific make targets. All source code in the JDK is organized so it belongs to a module, e.g. &lt;code&gt;java.base&lt;/code&gt; or &lt;code&gt;jdk.jdwp.agent&lt;/code&gt;. You can build only a specific module, by giving it as make target: &lt;code&gt;make jdk.jdwp.agent&lt;/code&gt;. If the specified module depends on other modules (e.g. &lt;code&gt;java.base&lt;/code&gt;), those modules will be built first.&lt;/p&gt;
 922 &lt;p&gt;You can also specify a set of modules, just as you can always specify a set of make targets: &lt;code&gt;make jdk.crypto.cryptoki jdk.crypto.ec jdk.crypto.mscapi jdk.crypto.ucrypto&lt;/code&gt;&lt;/p&gt;
 923 &lt;h4 id=&quot;building-individual-module-phases&quot;&gt;Building Individual Module Phases&lt;/h4&gt;
 924 &lt;p&gt;The build process for each module is divided into separate phases. Not all modules need all phases. Which are needed depends on what kind of source code and other artifact the module consists of. The phases are:&lt;/p&gt;
 925 &lt;ul&gt;
 926 &lt;li&gt;&lt;code&gt;gensrc&lt;/code&gt; (Generate source code to compile)&lt;/li&gt;
 927 &lt;li&gt;&lt;code&gt;gendata&lt;/code&gt; (Generate non-source code artifacts)&lt;/li&gt;
 928 &lt;li&gt;&lt;code&gt;copy&lt;/code&gt; (Copy resource artifacts)&lt;/li&gt;
 929 &lt;li&gt;&lt;code&gt;java&lt;/code&gt; (Compile Java code)&lt;/li&gt;
 930 &lt;li&gt;&lt;code&gt;launchers&lt;/code&gt; (Compile native executables)&lt;/li&gt;
 931 &lt;li&gt;&lt;code&gt;libs&lt;/code&gt; (Compile native libraries)&lt;/li&gt;

 932 &lt;/ul&gt;
 933 &lt;p&gt;You can build only a single phase for a module by using the notation &lt;code&gt;$MODULE-$PHASE&lt;/code&gt;. For instance, to build the &lt;code&gt;gensrc&lt;/code&gt; phase for &lt;code&gt;java.base&lt;/code&gt;, use &lt;code&gt;make java.base-gensrc&lt;/code&gt;.&lt;/p&gt;
 934 &lt;p&gt;Note that some phases may depend on others, e.g. &lt;code&gt;java&lt;/code&gt; depends on &lt;code&gt;gensrc&lt;/code&gt; (if present). Make will build all needed prerequisites before building the requested phase.&lt;/p&gt;
 935 &lt;h4 id=&quot;skipping-the-dependency-check&quot;&gt;Skipping the Dependency Check&lt;/h4&gt;
 936 &lt;p&gt;When using an iterative development style with frequent quick rebuilds, the dependency check made by make can take up a significant portion of the time spent on the rebuild. In such cases, it can be useful to bypass the dependency check in make.&lt;/p&gt;
 937 &lt;blockquote&gt;
 938 &lt;p&gt;&lt;strong&gt;Note that if used incorrectly, this can lead to a broken build!&lt;/strong&gt;&lt;/p&gt;
 939 &lt;/blockquote&gt;
 940 &lt;p&gt;To achieve this, append &lt;code&gt;-only&lt;/code&gt; to the build target. For instance, &lt;code&gt;make jdk.jdwp.agent-java-only&lt;/code&gt; will &lt;em&gt;only&lt;/em&gt; build the &lt;code&gt;java&lt;/code&gt; phase of the &lt;code&gt;jdk.jdwp.agent&lt;/code&gt; module. If the required dependencies are not present, the build can fail. On the other hand, the execution time measures in milliseconds.&lt;/p&gt;
 941 &lt;p&gt;A useful pattern is to build the first time normally (e.g. &lt;code&gt;make jdk.jdwp.agent&lt;/code&gt;) and then on subsequent builds, use the &lt;code&gt;-only&lt;/code&gt; make target.&lt;/p&gt;
 942 &lt;h4 id=&quot;rebuilding-part-of-java.base-jdk_filter&quot;&gt;Rebuilding Part of java.base (JDK_FILTER)&lt;/h4&gt;
 943 &lt;p&gt;If you are modifying files in &lt;code&gt;java.base&lt;/code&gt;, which is the by far largest module in the JDK, then you need to rebuild all those files whenever a single file has changed. (This inefficiency will hopefully be addressed in JDK 10.)&lt;/p&gt;
 944 &lt;p&gt;As a hack, you can use the make control variable &lt;code&gt;JDK_FILTER&lt;/code&gt; to specify a pattern that will be used to limit the set of files being recompiled. For instance, &lt;code&gt;make java.base JDK_FILTER=javax/crypto&lt;/code&gt; (or, to combine methods, &lt;code&gt;make java.base-java-only JDK_FILTER=javax/crypto&lt;/code&gt;) will limit the compilation to files in the &lt;code&gt;javax.crypto&lt;/code&gt; package.&lt;/p&gt;
 945 &lt;h3 id=&quot;learn-about-mercurial&quot;&gt;Learn About Mercurial&lt;/h3&gt;
 946 &lt;p&gt;To become an efficient JDK developer, it is recommended that you invest in learning Mercurial properly. Here are some links that can get you started:&lt;/p&gt;
 947 &lt;ul&gt;
 948 &lt;li&gt;&lt;a href=&quot;http://www.mercurial-scm.org/wiki/GitConcepts&quot;&gt;Mercurial for git users&lt;/a&gt;&lt;/li&gt;
 949 &lt;li&gt;&lt;a href=&quot;http://www.mercurial-scm.org/wiki/Tutorial&quot;&gt;The official Mercurial tutorial&lt;/a&gt;&lt;/li&gt;
 950 &lt;li&gt;&lt;a href=&quot;http://hginit.com/&quot;&gt;hg init&lt;/a&gt;&lt;/li&gt;
 951 &lt;li&gt;&lt;a href=&quot;http://hgbook.red-bean.com/read/&quot;&gt;Mercurial: The Definitive Guide&lt;/a&gt;&lt;/li&gt;
</pre>
</td>
</tr>
</table>
<center><a href="../bin/unshuffle_list.txt.sdiff.html" target="_top">&lt; prev</a> <a href="../index.html" target="_top">index</a> <a href="building.md.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
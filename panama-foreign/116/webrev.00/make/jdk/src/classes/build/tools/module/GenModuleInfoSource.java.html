<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New make/jdk/src/classes/build/tools/module/GenModuleInfoSource.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package build.tools.module;
 26 
 27 import java.io.BufferedWriter;
 28 import java.io.IOException;
 29 import java.io.PrintWriter;
 30 import java.nio.file.Files;
 31 import java.nio.file.Path;
 32 import java.nio.file.Paths;
 33 import java.util.ArrayList;
 34 import java.util.Arrays;
 35 import java.util.Collections;
 36 import java.util.HashMap;
 37 import java.util.LinkedHashSet;
 38 import java.util.List;
 39 import java.util.Map;
 40 import java.util.Objects;
 41 import java.util.Set;
 42 import java.util.stream.Collectors;
 43 import java.util.stream.Stream;
 44 import static java.util.stream.Collectors.*;
 45 
 46 /**
 47  * A build tool to extend the module-info.java in the source tree for
 48  * platform-specific exports, opens, uses, and provides and write to
 49  * the specified output file.
 50  *
 51  * GenModuleInfoSource will be invoked for each module that has
 52  * module-info.java.extra in the source directory.
 53  *
 54  * The extra exports, opens, uses, provides can be specified
 55  * in module-info.java.extra.
 56  * Injecting platform-specific requires is not supported.
 57  *
 58  * @see build.tools.module.ModuleInfoExtraTest for basic testing
 59  */
 60 public class GenModuleInfoSource {
 61     private final static String USAGE =
 62             &quot;Usage: GenModuleInfoSource \n&quot; +
 63                     &quot; [-d]\n&quot; +
 64                     &quot; -o &lt;output file&gt;\n&quot; +
 65                     &quot;  --source-file &lt;module-info-java&gt;\n&quot; +
 66                     &quot;  --modules &lt;module-name&gt;[,&lt;module-name&gt;...]\n&quot; +
 67                     &quot;  &lt;module-info.java.extra&gt; ...\n&quot;;
 68 
 69     static boolean debug = false;
 70     static boolean verbose = false;
 71     public static void main(String... args) throws Exception {
 72         Path outfile = null;
 73         Path moduleInfoJava = null;
 74         Set&lt;String&gt; modules = Collections.emptySet();
 75         List&lt;Path&gt; extras = new ArrayList&lt;&gt;();
 76         // validate input arguments
 77         for (int i = 0; i &lt; args.length; i++){
 78             String option = args[i];
 79             String arg = i+1 &lt; args.length ? args[i+1] : null;
 80             switch (option) {
 81                 case &quot;-d&quot;:
 82                     debug = true;
 83                     break;
 84                 case &quot;-o&quot;:
 85                     outfile = Paths.get(arg);
 86                     i++;
 87                     break;
 88                 case &quot;--source-file&quot;:
 89                     moduleInfoJava = Paths.get(arg);
 90                     if (Files.notExists(moduleInfoJava)) {
 91                         throw new IllegalArgumentException(moduleInfoJava + &quot; not exist&quot;);
 92                     }
 93                     i++;
 94                     break;
 95                 case &quot;--modules&quot;:
 96                     modules = Arrays.stream(arg.split(&quot;,&quot;))
 97                                     .collect(toSet());
 98                     i++;
 99                     break;
100                 case &quot;-v&quot;:
101                     verbose = true;
102                     break;
103                 default:
104                     Path file = Paths.get(option);
105                     if (Files.notExists(file)) {
106                         throw new IllegalArgumentException(file + &quot; not exist&quot;);
107                     }
108                     extras.add(file);
109             }
110         }
111 
112         if (moduleInfoJava == null || outfile == null ||
113                 modules.isEmpty() || extras.isEmpty()) {
114             System.err.println(USAGE);
115             System.exit(-1);
116         }
117 
118         GenModuleInfoSource genModuleInfo =
119             new GenModuleInfoSource(moduleInfoJava, extras, modules);
120 
121         // generate new module-info.java
122         genModuleInfo.generate(outfile);
123     }
124 
125     final Path sourceFile;
126     final List&lt;Path&gt; extraFiles;
127     final ModuleInfo extras;
128     final Set&lt;String&gt; modules;
129     final ModuleInfo moduleInfo;
130     GenModuleInfoSource(Path sourceFile, List&lt;Path&gt; extraFiles, Set&lt;String&gt; modules)
131         throws IOException
132     {
133         this.sourceFile = sourceFile;
134         this.extraFiles = extraFiles;
135         this.modules = modules;
136         this.moduleInfo = new ModuleInfo();
137         this.moduleInfo.parse(sourceFile);
138 
139         // parse module-info.java.extra
140         this.extras = new ModuleInfo();
141         for (Path file : extraFiles) {
142             extras.parseExtra(file);
143         }
144 
145         // merge with module-info.java.extra
146         moduleInfo.augmentModuleInfo(extras, modules);
147     }
148 
149     void generate(Path output) throws IOException {
150         List&lt;String&gt; lines = Files.readAllLines(sourceFile);
151         try (BufferedWriter bw = Files.newBufferedWriter(output);
152              PrintWriter writer = new PrintWriter(bw)) {
153             // write the copyright header and lines up to module declaration
154             for (String l : lines) {
155                 writer.println(l);
156                 if (l.trim().startsWith(&quot;module &quot;)) {
157                     if (debug) {
158                         // print URI rather than file path to avoid escape
159                         writer.format(&quot;    // source file: %s%n&quot;, sourceFile.toUri());
160                         for (Path file : extraFiles) {
161                             writer.format(&quot;    //              %s%n&quot;, file.toUri());
162                         }
163                     }
164                     break;
165                 }
166             }
167 
168             // requires
169             for (String l : lines) {
170                 if (l.trim().startsWith(&quot;requires&quot;))
171                     writer.println(l);
172             }
173 
174             // write exports, opens, uses, and provides
175             moduleInfo.print(writer);
176 
177             // close
178             writer.println(&quot;}&quot;);
179         }
180     }
181 
182 
183     class ModuleInfo {
184         final Map&lt;String, Statement&gt; exports = new HashMap&lt;&gt;();
185         final Map&lt;String, Statement&gt; opens = new HashMap&lt;&gt;();
186         final Map&lt;String, Statement&gt; uses = new HashMap&lt;&gt;();
187         final Map&lt;String, Statement&gt; provides = new HashMap&lt;&gt;();
188 
189         Statement getStatement(String directive, String name) {
190             Objects.requireNonNull(name);
191             switch (directive) {
192                 case &quot;exports&quot;:
193                     if (moduleInfo.exports.containsKey(name) &amp;&amp;
194                         moduleInfo.exports.get(name).isUnqualified()) {
195                         throw new IllegalArgumentException(sourceFile +
196                             &quot; already has &quot; + directive + &quot; &quot; + name);
197                     }
198                     return exports.computeIfAbsent(name,
199                         _n -&gt; new Statement(&quot;exports&quot;, &quot;to&quot;, name));
200 
201                 case &quot;opens&quot;:
202                     if (moduleInfo.opens.containsKey(name) &amp;&amp;
203                         moduleInfo.opens.get(name).isUnqualified()) {
204                         throw new IllegalArgumentException(sourceFile +
205                             &quot; already has &quot; + directive + &quot; &quot; + name);
206                     }
207 
208                     if (moduleInfo.opens.containsKey(name)) {
209                         throw new IllegalArgumentException(sourceFile +
210                             &quot; already has &quot; + directive + &quot; &quot; + name);
211                     }
212                     return opens.computeIfAbsent(name,
213                         _n -&gt; new Statement(&quot;opens&quot;, &quot;to&quot;, name));
214 
215                 case &quot;uses&quot;:
216                     return uses.computeIfAbsent(name,
217                         _n -&gt; new Statement(&quot;uses&quot;, &quot;&quot;, name));
218 
219                 case &quot;provides&quot;:
220                     return provides.computeIfAbsent(name,
221                         _n -&gt; new Statement(&quot;provides&quot;, &quot;with&quot;, name, true));
222 
223                 default:
224                     throw new IllegalArgumentException(directive);
225             }
226 
227         }
228 
229         /*
230          * Augment this ModuleInfo with module-info.java.extra
231          */
232         void augmentModuleInfo(ModuleInfo extraFiles, Set&lt;String&gt; modules) {
233             // API package exported in the original module-info.java
234             extraFiles.exports.entrySet()
235                 .stream()
236                 .filter(e -&gt; exports.containsKey(e.getKey()) &amp;&amp;
237                     e.getValue().filter(modules))
238                 .forEach(e -&gt; mergeExportsOrOpens(exports.get(e.getKey()),
239                     e.getValue(),
240                     modules));
241 
242             // add exports that are not defined in the original module-info.java
243             extraFiles.exports.entrySet()
244                 .stream()
245                 .filter(e -&gt; !exports.containsKey(e.getKey()) &amp;&amp;
246                     e.getValue().filter(modules))
247                 .forEach(e -&gt; addTargets(getStatement(&quot;exports&quot;, e.getKey()),
248                     e.getValue(),
249                     modules));
250 
251             // API package opened in the original module-info.java
252             extraFiles.opens.entrySet()
253                 .stream()
254                 .filter(e -&gt; opens.containsKey(e.getKey()) &amp;&amp;
255                     e.getValue().filter(modules))
256                 .forEach(e -&gt; mergeExportsOrOpens(opens.get(e.getKey()),
257                     e.getValue(),
258                     modules));
259 
260             // add opens that are not defined in the original module-info.java
261             extraFiles.opens.entrySet()
262                 .stream()
263                 .filter(e -&gt; !opens.containsKey(e.getKey()) &amp;&amp;
264                     e.getValue().filter(modules))
265                 .forEach(e -&gt; addTargets(getStatement(&quot;opens&quot;, e.getKey()),
266                     e.getValue(),
267                     modules));
268 
269             // provides
270             extraFiles.provides.keySet()
271                 .stream()
272                 .filter(service -&gt; provides.containsKey(service))
273                 .forEach(service -&gt; mergeProvides(service,
274                     extraFiles.provides.get(service)));
275             extraFiles.provides.keySet()
276                 .stream()
277                 .filter(service -&gt; !provides.containsKey(service))
278                 .forEach(service -&gt; provides.put(service,
279                     extraFiles.provides.get(service)));
280 
281             // uses
282             extraFiles.uses.keySet()
283                 .stream()
284                 .filter(service -&gt; !uses.containsKey(service))
285                 .forEach(service -&gt; uses.put(service, extraFiles.uses.get(service)));
286         }
287 
288         // add qualified exports or opens to known modules only
289         private void addTargets(Statement statement,
290                                 Statement extra,
291                                 Set&lt;String&gt; modules)
292         {
293             extra.targets.stream()
294                 .filter(mn -&gt; modules.contains(mn))
295                 .forEach(mn -&gt; statement.addTarget(mn));
296         }
297 
298         private void mergeExportsOrOpens(Statement statement,
299                                          Statement extra,
300                                          Set&lt;String&gt; modules)
301         {
302             String pn = statement.name;
303             if (statement.isUnqualified() &amp;&amp; extra.isQualified()) {
304                 throw new RuntimeException(&quot;can&#39;t add qualified exports to &quot; +
305                     &quot;unqualified exports &quot; + pn);
306             }
307 
308             Set&lt;String&gt; mods = extra.targets.stream()
309                 .filter(mn -&gt; statement.targets.contains(mn))
310                 .collect(toSet());
311             if (mods.size() &gt; 0) {
312                 throw new RuntimeException(&quot;qualified exports &quot; + pn + &quot; to &quot; +
313                     mods.toString() + &quot; already declared in &quot; + sourceFile);
314             }
315 
316             // add qualified exports or opens to known modules only
317             addTargets(statement, extra, modules);
318         }
319 
320         private void mergeProvides(String service, Statement extra) {
321             Statement statement = provides.get(service);
322 
323             Set&lt;String&gt; mods = extra.targets.stream()
324                 .filter(mn -&gt; statement.targets.contains(mn))
325                 .collect(toSet());
326 
327             if (mods.size() &gt; 0) {
328                 throw new RuntimeException(&quot;qualified exports &quot; + service + &quot; to &quot; +
329                     mods.toString() + &quot; already declared in &quot; + sourceFile);
330             }
331 
332             extra.targets.stream()
333                 .forEach(mn -&gt; statement.addTarget(mn));
334         }
335 
336 
337         void print(PrintWriter writer) {
338             // print unqualified exports
339             exports.entrySet().stream()
340                 .filter(e -&gt; e.getValue().targets.isEmpty())
341                 .sorted(Map.Entry.comparingByKey())
342                 .forEach(e -&gt; writer.println(e.getValue()));
343 
344             // print qualified exports
345             exports.entrySet().stream()
346                 .filter(e -&gt; !e.getValue().targets.isEmpty())
347                 .sorted(Map.Entry.comparingByKey())
348                 .forEach(e -&gt; writer.println(e.getValue()));
349 
350             // print unqualified opens
351             opens.entrySet().stream()
352                 .filter(e -&gt; e.getValue().targets.isEmpty())
353                 .sorted(Map.Entry.comparingByKey())
354                 .forEach(e -&gt; writer.println(e.getValue()));
355 
356             // print qualified opens
357             opens.entrySet().stream()
358                 .filter(e -&gt; !e.getValue().targets.isEmpty())
359                 .sorted(Map.Entry.comparingByKey())
360                 .forEach(e -&gt; writer.println(e.getValue()));
361 
362             // uses and provides
363             writer.println();
364             uses.entrySet().stream()
365                 .sorted(Map.Entry.comparingByKey())
366                 .forEach(e -&gt; writer.println(e.getValue()));
367             provides.entrySet().stream()
368                 .sorted(Map.Entry.comparingByKey())
369                 .forEach(e -&gt; writer.println(e.getValue()));
370         }
371 
372 
373         private void parse(Path file) throws IOException {
374             Parser parser = new Parser(file);
375             parser.run();
376             if (verbose) {
377                 parser.dump();
378             }
379             process(parser, false);
380         }
381 
382         private void parseExtra(Path file) throws IOException {
383             Parser parser = new Parser(file);
384             parser.run();
385             if (verbose) {
386                 parser.dump();
387             }
388             process(parser, true);
389         }
390 
391 
392         private void process(Parser parser, boolean extraFile) throws IOException {
393             // no duplicate statement local in each file
394             Map&lt;String, Statement&gt; exports = new HashMap&lt;&gt;();
395             Map&lt;String, Statement&gt; opens = new HashMap&lt;&gt;();
396             Map&lt;String, Statement&gt; uses = new HashMap&lt;&gt;();
397             Map&lt;String, Statement&gt; provides = new HashMap&lt;&gt;();
398 
399             String token = null;
400             boolean hasCurlyBracket = false;
401             while ((token = parser.nextToken()) != null) {
402                 if (token.equals(&quot;module&quot;)) {
403                     String modulename = nextIdentifier(parser);
404                     if (extraFile) {
405                         throw parser.newError(&quot;cannot declare module in &quot; + parser.sourceFile);
406                     }
407                     skipTokenOrThrow(parser, &quot;{&quot;, &quot;missing {&quot;);
408                     hasCurlyBracket = true;
409                 } else if (token.equals(&quot;requires&quot;)) {
410                     token = nextIdentifier(parser);
411                     if (token.equals(&quot;transitive&quot;)) {
412                         token = nextIdentifier(parser);
413                     }
414                     if (extraFile) {
415                         throw parser.newError(&quot;cannot declare requires in &quot; + parser.sourceFile);
416                     }
417                     skipTokenOrThrow(parser, &quot;;&quot;, &quot;missing semicolon&quot;);
418                 } else if (isExportsOpensProvidesUses(token)) {
419                     // new statement
420                     String keyword = token;
421                     String name = nextIdentifier(parser);
422                     Statement statement = getStatement(keyword, name);
423                     switch (keyword) {
424                         case &quot;exports&quot;:
425                             if (exports.containsKey(name)) {
426                                 throw parser.newError(&quot;multiple &quot; + keyword + &quot; &quot; + name);
427                             }
428                             exports.put(name, statement);
429                             break;
430                         case &quot;opens&quot;:
431                             if (opens.containsKey(name)) {
432                                 throw parser.newError(&quot;multiple &quot; + keyword + &quot; &quot; + name);
433                             }
434                             opens.put(name, statement);
435                             break;
436                         case &quot;uses&quot;:
437                             if (uses.containsKey(name)) {
438                                 throw parser.newError(&quot;multiple &quot; + keyword + &quot; &quot; + name);
439                             }
440                             uses.put(name, statement);
441                             break;
442                         case &quot;provides&quot;:
443                             if (provides.containsKey(name)) {
444                                 throw parser.newError(&quot;multiple &quot; + keyword + &quot; &quot; + name);
445                             }
446                             provides.put(name, statement);
447                             break;
448                     }
449                     String lookAhead = lookAhead(parser);
450                     if (lookAhead.equals(statement.qualifier)) {
451                         parser.nextToken(); // skip qualifier
452                         while ((lookAhead = parser.peekToken()) != null) {
453                             // add target name
454                             name = nextIdentifier(parser);
455                             statement.addTarget(name);
456                             lookAhead = lookAhead(parser);
457                             if (lookAhead.equals(&quot;,&quot;) || lookAhead.equals(&quot;;&quot;)) {
458                                 parser.nextToken();
459                             } else {
460                                 throw parser.newError(&quot;missing semicolon&quot;);
461                             }
462                             if (lookAhead.equals(&quot;;&quot;)) {
463                                 break;
464                             }
465                         }
466                     } else {
467                         skipTokenOrThrow(parser, &quot;;&quot;, &quot;missing semicolon&quot;);
468                     }
469                 } else if (token.equals(&quot;;&quot;)) {
470                     continue;
471                 } else if (hasCurlyBracket &amp;&amp; token.equals(&quot;}&quot;)) {
472                     hasCurlyBracket = false;
473                     if (parser.peekToken() != null) {  // must be EOF
474                         throw parser.newError(&quot;is malformed&quot;);
475                     }
476                 } else {
477                     throw parser.newError(&quot;missing keyword&quot;);
478                 }
479             }
480             if (hasCurlyBracket) {
481                 parser.newError(&quot;missing }&quot;);
482             }
483         }
484 
485         private boolean isExportsOpensProvidesUses(String word) {
486             switch (word) {
487                 case &quot;exports&quot;:
488                 case &quot;opens&quot;:
489                 case &quot;provides&quot;:
490                 case &quot;uses&quot;:
491                     return true;
492                 default:
493                     return false;
494             }
495         }
496 
497         private String lookAhead(Parser parser) {
498             String lookAhead = parser.peekToken();
499             if (lookAhead == null) { // EOF
500                 throw parser.newError(&quot;reach end of file&quot;);
501             }
502             return lookAhead;
503         }
504 
505         private String nextIdentifier(Parser parser) {
506             String lookAhead = parser.peekToken();
507             boolean maybeIdentifier = true;
508             switch (lookAhead) {
509                 case &quot;module&quot;:
510                 case &quot;requires&quot;:
511                 case &quot;exports&quot;:
512                 case &quot;opens&quot;:
513                 case &quot;provides&quot;:
514                 case &quot;uses&quot;:
515                 case &quot;to&quot;:
516                 case &quot;with&quot;:
517                 case &quot;,&quot;:
518                 case &quot;;&quot;:
519                 case &quot;{&quot;:
520                 case &quot;}&quot;:
521                     maybeIdentifier = false;
522             }
523             if (lookAhead == null || !maybeIdentifier) {
524                 throw parser.newError(&quot;&lt;identifier&gt; missing&quot;);
525             }
526 
527             return parser.nextToken();
528         }
529 
530         private String skipTokenOrThrow(Parser parser, String token, String msg) {
531             // look ahead to report the proper line number
532             String lookAhead = parser.peekToken();
533             if (!token.equals(lookAhead)) {
534                 throw parser.newError(msg);
535             }
536             return parser.nextToken();
537         }
538     }
539 
540     static class Statement {
541         final String directive;
542         final String qualifier;
543         final String name;
544         final Set&lt;String&gt; targets = new LinkedHashSet&lt;&gt;();
545         final boolean ordered;
546 
547         Statement(String directive, String qualifier, String name) {
548             this(directive, qualifier, name, false);
549         }
550 
551         Statement(String directive, String qualifier, String name, boolean ordered) {
552             this.directive = directive;
553             this.qualifier = qualifier;
554             this.name = name;
555             this.ordered = ordered;
556         }
557 
558         Statement addTarget(String mn) {
559             if (mn.isEmpty())
560                 throw new IllegalArgumentException(&quot;empty module name&quot;);
561             targets.add(mn);
562             return this;
563         }
564 
565         boolean isQualified() {
566             return targets.size() &gt; 0;
567         }
568 
569         boolean isUnqualified() {
570             return targets.isEmpty();
571         }
572 
573         /**
574          * Returns true if this statement is unqualified or it has
575          * at least one target in the given names.
576          */
577         boolean filter(Set&lt;String&gt; names) {
578             if (isUnqualified()) {
579                 return true;
580             } else {
581                 return targets.stream()
582                     .filter(mn -&gt; names.contains(mn))
583                     .findAny().isPresent();
584             }
585         }
586 
587         @Override
588         public String toString() {
589             StringBuilder sb = new StringBuilder(&quot;    &quot;);
590             sb.append(directive).append(&quot; &quot;).append(name);
591             if (targets.isEmpty()) {
592                 sb.append(&quot;;&quot;);
593             } else if (targets.size() == 1) {
594                 sb.append(&quot; &quot;).append(qualifier)
595                   .append(orderedTargets().collect(joining(&quot;,&quot;, &quot; &quot;, &quot;;&quot;)));
596             } else {
597                 sb.append(&quot; &quot;).append(qualifier)
598                   .append(orderedTargets()
599                       .map(target -&gt; String.format(&quot;        %s&quot;, target))
600                       .collect(joining(&quot;,\n&quot;, &quot;\n&quot;, &quot;;&quot;)));
601             }
602             return sb.toString();
603         }
604 
605         public Stream&lt;String&gt; orderedTargets() {
606             return ordered ? targets.stream()
607                            : targets.stream().sorted();
608         }
609     }
610 
611     static void trace(String fmt, Object... params) {
612         if (verbose) {
613             System.out.format(fmt, params);
614         }
615     }
616 
617     static class Parser {
618         private static final List&lt;String&gt; EMPTY = List.of();
619 
620         private final Path sourceFile;
621         private boolean inCommentBlock = false;
622         private List&lt;List&lt;String&gt;&gt; tokens = new ArrayList&lt;&gt;();
623         private int lineNumber = 1;
624         private int index = 0;
625 
626         Parser(Path file) {
627             this.sourceFile = file;
628         }
629 
630         void run() throws IOException {
631             List&lt;String&gt; lines = Files.readAllLines(sourceFile);
632             for (int lineNumber = 1; lineNumber &lt;= lines.size(); lineNumber++) {
633                 String l = lines.get(lineNumber - 1).trim();
634                 tokenize(l);
635             }
636         }
637 
638         /*
639          * Tokenize the given string.  Comments are skipped.
640          */
641         List&lt;String&gt; tokenize(String l) {
642             while (!l.isEmpty()) {
643                 if (inCommentBlock) {
644                     int comment = l.indexOf(&quot;*/&quot;);
645                     if (comment == -1)
646                         return emptyTokens();
647 
648                     // end comment block
649                     inCommentBlock = false;
650                     if ((comment + 2) &gt;= l.length()) {
651                         return emptyTokens();
652                     }
653                     l = l.substring(comment + 2, l.length()).trim();
654                 }
655 
656                 // skip comment
657                 int comment = l.indexOf(&quot;//&quot;);
658                 if (comment &gt;= 0) {
659                     l = l.substring(0, comment).trim();
660                     if (l.isEmpty()) return emptyTokens();
661                 }
662 
663                 if (l.isEmpty()) {
664                     return emptyTokens();
665                 }
666 
667                 int beginComment = l.indexOf(&quot;/*&quot;);
668                 int endComment = l.indexOf(&quot;*/&quot;);
669                 if (beginComment == -1)
670                     return tokens(l);
671 
672                 String s1 = l.substring(0, beginComment).trim();
673                 if (endComment &gt; 0) {
674                     String s2 = l.substring(endComment + 2, l.length()).trim();
675                     if (s1.isEmpty()) {
676                         l = s2;
677                     } else if (s2.isEmpty()) {
678                         l = s1;
679                     } else {
680                         l = s1 + &quot; &quot; + s2;
681                     }
682                 } else {
683                     inCommentBlock = true;
684                     return tokens(s1);
685                 }
686             }
687             return tokens(l);
688         }
689 
690         private List&lt;String&gt; emptyTokens() {
691             this.tokens.add(EMPTY);
692             return EMPTY;
693         }
694         private List&lt;String&gt; tokens(String l) {
695             List&lt;String&gt; tokens = new ArrayList&lt;&gt;();
696             for (String s : l.split(&quot;\\s+&quot;)) {
697                 int pos=0;
698                 s = s.trim();
699                 if (s.isEmpty())
700                      continue;
701 
702                 int i = s.indexOf(&#39;,&#39;, pos);
703                 int j = s.indexOf(&#39;;&#39;, pos);
704                 while ((i &gt;= 0 &amp;&amp; i &lt; s.length()) || (j &gt;= 0 &amp;&amp; j &lt; s.length())) {
705                     if (j == -1 || (i &gt;= 0 &amp;&amp; i &lt; j)) {
706                         String n = s.substring(pos, i).trim();
707                         if (!n.isEmpty()) {
708                             tokens.add(n);
709                         }
710                         tokens.add(s.substring(i, i + 1));
711                         pos = i + 1;
712                         i = s.indexOf(&#39;,&#39;, pos);
713                     } else {
714                         String n = s.substring(pos, j).trim();
715                         if (!n.isEmpty()) {
716                             tokens.add(n);
717                         }
718                         tokens.add(s.substring(j, j + 1));
719                         pos = j + 1;
720                         j = s.indexOf(&#39;;&#39;, pos);
721                     }
722                 }
723 
724                 String n = s.substring(pos).trim();
725                 if (!n.isEmpty()) {
726                     tokens.add(n);
727                 }
728             }
729             this.tokens.add(tokens);
730             return tokens;
731         }
732 
733         /*
734          * Returns next token.
735          */
736         String nextToken() {
737             while (lineNumber &lt;= tokens.size()) {
738                 List&lt;String&gt; l = tokens.get(lineNumber-1);
739                 if (index &lt; l.size()) {
740                     return l.get(index++);
741                 } else {
742                     lineNumber++;
743                     index = 0;
744                 }
745             }
746             return null;
747         }
748 
749         /*
750          * Peeks next token.
751          */
752         String peekToken() {
753             int ln = lineNumber;
754             int i = index;
755             while (ln &lt;= tokens.size()) {
756                 List&lt;String&gt; l = tokens.get(ln-1);
757                 if (i &lt; l.size()) {
758                     return l.get(i++);
759                 } else {
760                     ln++;
761                     i = 0;
762                 }
763             }
764             return null;
765         }
766 
767         Error newError(String msg) {
768             if (lineNumber &lt;= tokens.size()) {
769                 throw new Error(sourceFile + &quot;, line &quot; +
770                     lineNumber + &quot;, &quot; + msg + &quot; \&quot;&quot; + lineAt(lineNumber) + &quot;\&quot;&quot;);
771             } else {
772                 throw new Error(sourceFile + &quot;, line &quot; + lineNumber + &quot;, &quot; + msg);
773             }
774         }
775 
776         void dump() {
777             for (int i = 1; i &lt;= tokens.size(); i++) {
778                 System.out.format(&quot;%d: %s%n&quot;, i, lineAt(i));
779             }
780         }
781 
782         private String lineAt(int i) {
783             return tokens.get(i-1).stream().collect(Collectors.joining(&quot; &quot;));
784         }
785     }
786 }
787 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old make/nashorn/buildtools/nasgen/src/jdk/nashorn/internal/tools/nasgen/ConstructorGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.tools.nasgen;
 27 
 28 import static jdk.internal.org.objectweb.asm.Opcodes.ACC_FINAL;
 29 import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;
 30 import static jdk.internal.org.objectweb.asm.Opcodes.H_INVOKESTATIC;
 31 import static jdk.internal.org.objectweb.asm.Opcodes.V1_7;
 32 import static jdk.nashorn.internal.tools.nasgen.StringConstants.CONSTRUCTOR_SUFFIX;
 33 import static jdk.nashorn.internal.tools.nasgen.StringConstants.DEFAULT_INIT_DESC;
 34 import static jdk.nashorn.internal.tools.nasgen.StringConstants.INIT;
 35 import static jdk.nashorn.internal.tools.nasgen.StringConstants.OBJECT_DESC;
 36 import static jdk.nashorn.internal.tools.nasgen.StringConstants.PROPERTYMAP_DESC;
 37 import static jdk.nashorn.internal.tools.nasgen.StringConstants.PROPERTYMAP_FIELD_NAME;
 38 import static jdk.nashorn.internal.tools.nasgen.StringConstants.PROTOTYPEOBJECT_SETCONSTRUCTOR;
 39 import static jdk.nashorn.internal.tools.nasgen.StringConstants.PROTOTYPEOBJECT_SETCONSTRUCTOR_DESC;
 40 import static jdk.nashorn.internal.tools.nasgen.StringConstants.PROTOTYPEOBJECT_TYPE;
 41 import static jdk.nashorn.internal.tools.nasgen.StringConstants.SCRIPTFUNCTION_INIT_DESC3;
 42 import static jdk.nashorn.internal.tools.nasgen.StringConstants.SCRIPTFUNCTION_INIT_DESC4;
 43 import static jdk.nashorn.internal.tools.nasgen.StringConstants.SCRIPTFUNCTION_SETARITY;
 44 import static jdk.nashorn.internal.tools.nasgen.StringConstants.SCRIPTFUNCTION_SETARITY_DESC;
 45 import static jdk.nashorn.internal.tools.nasgen.StringConstants.SCRIPTFUNCTION_SETDOCUMENTATIONKEY;
 46 import static jdk.nashorn.internal.tools.nasgen.StringConstants.SCRIPTFUNCTION_SETDOCUMENTATIONKEY_DESC;
 47 import static jdk.nashorn.internal.tools.nasgen.StringConstants.SCRIPTFUNCTION_SETPROTOTYPE;
 48 import static jdk.nashorn.internal.tools.nasgen.StringConstants.SCRIPTFUNCTION_SETPROTOTYPE_DESC;
 49 import static jdk.nashorn.internal.tools.nasgen.StringConstants.SCRIPTFUNCTION_TYPE;
 50 import static jdk.nashorn.internal.tools.nasgen.StringConstants.SCRIPTOBJECT_INIT_DESC;
 51 import static jdk.nashorn.internal.tools.nasgen.StringConstants.SCRIPTOBJECT_TYPE;
 52 
 53 import java.io.FileOutputStream;
 54 import java.io.IOException;
 55 import java.util.List;
 56 import jdk.internal.org.objectweb.asm.Handle;
 57 
 58 /**
 59  * This class generates constructor class for a @ScriptClass annotated class.
 60  *
 61  */
 62 public class ConstructorGenerator extends ClassGenerator {
 63     private final ScriptClassInfo scriptClassInfo;
 64     private final String className;
 65     private final MemberInfo constructor;
 66     private final int memberCount;
 67     private final List&lt;MemberInfo&gt; specs;
 68 
 69     ConstructorGenerator(final ScriptClassInfo sci) {
 70         this.scriptClassInfo = sci;
 71 
 72         this.className = scriptClassInfo.getConstructorClassName();
 73         this.constructor = scriptClassInfo.getConstructor();
 74         this.memberCount = scriptClassInfo.getConstructorMemberCount();
 75         this.specs = scriptClassInfo.getSpecializedConstructors();
 76     }
 77 
 78     byte[] getClassBytes() {
 79         // new class extending from ScriptObject
 80         final String superClass = (constructor != null)? SCRIPTFUNCTION_TYPE : SCRIPTOBJECT_TYPE;
 81         cw.visit(V1_7, ACC_FINAL, className, null, superClass, null);
 82         if (memberCount &gt; 0) {
 83             // add fields
 84             emitFields();
 85             // add &lt;clinit&gt;
 86             emitStaticInitializer();
 87         }
 88         // add &lt;init&gt;
 89         emitConstructor();
 90 
 91         if (constructor == null) {
 92             emitGetClassName(scriptClassInfo.getName());
 93         }
 94 
 95         cw.visitEnd();
 96         return cw.toByteArray();
 97     }
 98 
 99     // --Internals only below this point
100     private void emitFields() {
101         // Introduce &quot;Function&quot; type instance fields for each
102         // constructor @Function in script class and introduce instance
103         // fields for each constructor @Property in the script class.
104         for (MemberInfo memInfo : scriptClassInfo.getMembers()) {
105             if (memInfo.isConstructorFunction()) {
106                 addFunctionField(memInfo.getJavaName());
107                 memInfo = (MemberInfo)memInfo.clone();
108                 memInfo.setJavaDesc(OBJECT_DESC);
109                 memInfo.setJavaAccess(ACC_PUBLIC);
110                 addGetter(className, memInfo);
111                 addSetter(className, memInfo);
112             } else if (memInfo.isConstructorProperty()) {
113                 if (memInfo.isStaticFinal()) {
114                     addGetter(scriptClassInfo.getJavaName(), memInfo);
115                 } else {
116                     addField(memInfo.getJavaName(), memInfo.getJavaDesc());
117                     memInfo = (MemberInfo)memInfo.clone();
118                     memInfo.setJavaAccess(ACC_PUBLIC);
119                     addGetter(className, memInfo);
120                     addSetter(className, memInfo);
121                 }
122             }
123         }
124 
125         addMapField();
126     }
127 
128     private void emitStaticInitializer() {
129         final MethodGenerator mi = makeStaticInitializer();
130         emitStaticInitPrefix(mi, className, memberCount);
131 
132         for (final MemberInfo memInfo : scriptClassInfo.getMembers()) {
133             if (memInfo.isConstructorFunction() || memInfo.isConstructorProperty()) {
134                 linkerAddGetterSetter(mi, className, memInfo);
135             } else if (memInfo.isConstructorGetter()) {
136                 final MemberInfo setter = scriptClassInfo.findSetter(memInfo);
137                 linkerAddGetterSetter(mi, scriptClassInfo.getJavaName(), memInfo, setter);
138             }
139         }
140         emitStaticInitSuffix(mi, className);
141     }
142 
143     private void emitConstructor() {
144         final MethodGenerator mi = makeConstructor();
145         mi.visitCode();
146         callSuper(mi);
147 
148         if (memberCount &gt; 0) {
149             // initialize Function type fields
150             initFunctionFields(mi);
151             // initialize data fields
152             initDataFields(mi);
153         }
154 
155         if (constructor != null) {
156             initPrototype(mi);
157             final int arity = constructor.getArity();
158             if (arity != MemberInfo.DEFAULT_ARITY) {
159                 mi.loadThis();
160                 mi.push(arity);
161                 mi.invokeVirtual(SCRIPTFUNCTION_TYPE, SCRIPTFUNCTION_SETARITY,
162                         SCRIPTFUNCTION_SETARITY_DESC);
163             }
164 
165             mi.loadThis();
166             mi.loadLiteral(scriptClassInfo.getName());
167             mi.invokeVirtual(SCRIPTFUNCTION_TYPE, SCRIPTFUNCTION_SETDOCUMENTATIONKEY,
168                         SCRIPTFUNCTION_SETDOCUMENTATIONKEY_DESC);
169         }
170         mi.returnVoid();
171         mi.computeMaxs();
172         mi.visitEnd();
173     }
174 
175     private void loadMap(final MethodGenerator mi) {
176         if (memberCount &gt; 0) {
177             mi.getStatic(className, PROPERTYMAP_FIELD_NAME, PROPERTYMAP_DESC);
178         }
179     }
180 
181     private void callSuper(final MethodGenerator mi) {
182         String superClass, superDesc;
183         mi.loadThis();
184         if (constructor == null) {
185             // call ScriptObject.&lt;init&gt;
186             superClass = SCRIPTOBJECT_TYPE;
187             superDesc = (memberCount &gt; 0) ? SCRIPTOBJECT_INIT_DESC : DEFAULT_INIT_DESC;
188             loadMap(mi);
189         } else {
190             // call Function.&lt;init&gt;
191             superClass = SCRIPTFUNCTION_TYPE;
192             superDesc = (memberCount &gt; 0) ? SCRIPTFUNCTION_INIT_DESC4 : SCRIPTFUNCTION_INIT_DESC3;
193             mi.loadLiteral(constructor.getName());
194             mi.visitLdcInsn(new Handle(H_INVOKESTATIC, scriptClassInfo.getJavaName(), constructor.getJavaName(), constructor.getJavaDesc(), false));
195             loadMap(mi);
196             mi.memberInfoArray(scriptClassInfo.getJavaName(), specs); //pushes null if specs empty
197         }
198 
199         mi.invokeSpecial(superClass, INIT, superDesc);
200     }
201 
202     private void initFunctionFields(final MethodGenerator mi) {
203         assert memberCount &gt; 0;
204         for (final MemberInfo memInfo : scriptClassInfo.getMembers()) {
205             if (!memInfo.isConstructorFunction()) {
206                 continue;
207             }
208             mi.loadThis();
209             newFunction(mi, scriptClassInfo.getName(), scriptClassInfo.getJavaName(), memInfo, scriptClassInfo.findSpecializations(memInfo.getJavaName()));
210             mi.putField(className, memInfo.getJavaName(), OBJECT_DESC);
211         }
212     }
213 
214     private void initDataFields(final MethodGenerator mi) {
215         assert memberCount &gt; 0;
216         for (final MemberInfo memInfo : scriptClassInfo.getMembers()) {
217            if (!memInfo.isConstructorProperty() || memInfo.isFinal()) {
218                continue;
219            }
220            final Object value = memInfo.getValue();
221            if (value != null) {
222                mi.loadThis();
223                mi.loadLiteral(value);
224                mi.putField(className, memInfo.getJavaName(), memInfo.getJavaDesc());
225            } else if (!memInfo.getInitClass().isEmpty()) {
226                final String clazz = memInfo.getInitClass();
227                mi.loadThis();
228                mi.newObject(clazz);
229                mi.dup();
230                mi.invokeSpecial(clazz, INIT, DEFAULT_INIT_DESC);
231                mi.putField(className, memInfo.getJavaName(), memInfo.getJavaDesc());
232            }
233         }
234     }
235 
236     private void initPrototype(final MethodGenerator mi) {
237         assert constructor != null;
238         mi.loadThis();
239         final String protoName = scriptClassInfo.getPrototypeClassName();
240         mi.newObject(protoName);
241         mi.dup();
242         mi.invokeSpecial(protoName, INIT, DEFAULT_INIT_DESC);
243         mi.dup();
244         mi.loadThis();
245         mi.invokeStatic(PROTOTYPEOBJECT_TYPE, PROTOTYPEOBJECT_SETCONSTRUCTOR,
246                 PROTOTYPEOBJECT_SETCONSTRUCTOR_DESC);
247         mi.invokeVirtual(SCRIPTFUNCTION_TYPE, SCRIPTFUNCTION_SETPROTOTYPE, SCRIPTFUNCTION_SETPROTOTYPE_DESC);
248     }
249 
250     /**
251      * Entry point for ConstructorGenerator run separately as an application. Will display
252      * usage. Takes one argument, a class name.
253      * @param args args vector
254      * @throws IOException if class can&#39;t be read
255      */
256     public static void main(final String[] args) throws IOException {
257         if (args.length != 1) {
258             System.err.println(&quot;Usage: &quot; + ConstructorGenerator.class.getName() + &quot; &lt;class&gt;&quot;);
259             System.exit(1);
260         }
261 
262         final String className = args[0].replace(&#39;.&#39;, &#39;/&#39;);
263         final ScriptClassInfo sci = getScriptClassInfo(className + &quot;.class&quot;);
264         if (sci == null) {
265             System.err.println(&quot;No @ScriptClass in &quot; + className);
266             System.exit(2);
267             throw new IOException(); // get rid of warning for sci.verify() below - may be null
268         }
269 
270         try {
271             sci.verify();
272         } catch (final Exception e) {
273             System.err.println(e.getMessage());
274             System.exit(3);
275         }
276         final ConstructorGenerator gen = new ConstructorGenerator(sci);
277         try (FileOutputStream fos = new FileOutputStream(className + CONSTRUCTOR_SUFFIX + &quot;.class&quot;)) {
278             fos.write(gen.getClassBytes());
279         }
280     }
281 }
    </pre>
  </body>
</html>
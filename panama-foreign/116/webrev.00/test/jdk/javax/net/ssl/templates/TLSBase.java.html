<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/javax/net/ssl/templates/TLSBase.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import javax.net.ssl.SSLContext;
 25 import javax.net.ssl.SSLServerSocket;
 26 import javax.net.ssl.SSLServerSocketFactory;
 27 import javax.net.ssl.SSLSession;
 28 import javax.net.ssl.SSLSocket;
 29 import java.io.BufferedReader;
 30 import java.io.IOException;
 31 import java.io.InputStreamReader;
 32 import java.io.OutputStreamWriter;
 33 import java.io.PrintWriter;
 34 import java.net.InetSocketAddress;
 35 import java.util.Arrays;
 36 import java.util.concurrent.ConcurrentHashMap;
 37 
 38 /**
 39  * This is a base setup for creating a server and clients.  All clients will
 40  * connect to the server on construction.  The server constructor must be run
 41  * first.  The idea is for the test code to be minimal as possible without
 42  * this library class being complicated.
 43  *
 44  * Server.done() must be called or the server will never exit and hang the test.
 45  *
 46  * After construction, reading and writing are allowed from either side,
 47  * or a combination write/read from both sides for verifying text.
 48  *
 49  * The TLSBase.Server and TLSBase.Client classes are to allow full access to
 50  * the SSLSession for verifying data.
 51  *
 52  * See SSLSession/CheckSessionContext.java for an example
 53  *
 54  */
 55 
 56 abstract public class TLSBase {
 57     static String pathToStores = &quot;../etc&quot;;
 58     static String keyStoreFile = &quot;keystore&quot;;
 59     static String trustStoreFile = &quot;truststore&quot;;
 60     static String passwd = &quot;passphrase&quot;;
 61 
 62     SSLContext sslContext;
 63     // Server&#39;s port
 64     static int serverPort;
 65     // Name shown during read and write ops
 66     String name;
 67 
 68     TLSBase() {
 69         String keyFilename =
 70                 System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
 71                         &quot;/&quot; + keyStoreFile;
 72         String trustFilename =
 73                 System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
 74                         &quot;/&quot; + trustStoreFile;
 75         System.setProperty(&quot;javax.net.ssl.keyStore&quot;, keyFilename);
 76         System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, passwd);
 77         System.setProperty(&quot;javax.net.ssl.trustStore&quot;, trustFilename);
 78         System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, passwd);
 79     }
 80 
 81     // Base read operation
 82     byte[] read(SSLSocket sock) {
 83         try {
 84             BufferedReader reader = new BufferedReader(
 85                     new InputStreamReader(sock.getInputStream()));
 86             String s = reader.readLine();
 87             System.err.println(&quot;(read) &quot; + name + &quot;: &quot; + s);
 88             return s.getBytes();
 89         } catch (Exception e) {
 90             e.printStackTrace();
 91         }
 92         return null;
 93     }
 94 
 95     // Base write operation
 96     public void write(SSLSocket sock, byte[] data) {
 97         try {
 98             PrintWriter out = new PrintWriter(
 99                     new OutputStreamWriter(sock.getOutputStream()));
100             out.println(new String(data));
101             out.flush();
102             System.err.println(&quot;(write)&quot; + name + &quot;: &quot; + new String(data));
103         } catch (Exception e) {
104             e.printStackTrace();
105         }
106     }
107 
108     /**
109      * Server constructor must be called before any client operation so the
110      * tls server is ready.  There should be no timing problems as the
111      */
112     static class Server extends TLSBase {
113         SSLServerSocketFactory fac;
114         SSLServerSocket ssock;
115         // Clients sockets are kept in a hash table with the port as the key.
116         ConcurrentHashMap&lt;Integer, SSLSocket&gt; clientMap =
117                 new ConcurrentHashMap&lt;&gt;();
118         boolean exit = false;
119         Thread t;
120 
121         Server() {
122             super();
123             name = &quot;server&quot;;
124             try {
125                 sslContext = SSLContext.getDefault();
126                 fac = sslContext.getServerSocketFactory();
127                 ssock = (SSLServerSocket) fac.createServerSocket(0);
128                 serverPort = ssock.getLocalPort();
129             } catch (Exception e) {
130                 System.err.println(e.getMessage());
131                 e.printStackTrace();
132             }
133 
134             // Thread to allow multiple clients to connect
135             t = new Thread(() -&gt; {
136                 try {
137                     while (true) {
138                         System.err.println(&quot;Server ready on port &quot; +
139                                 serverPort);
140                         SSLSocket c = (SSLSocket)ssock.accept();
141                         clientMap.put(c.getPort(), c);
142                         try {
143                             write(c, read(c));
144                         } catch (Exception e) {
145                             e.printStackTrace();
146                         }
147                     }
148                 } catch (Exception ex) {
149                     System.err.println(&quot;Server Down&quot;);
150                     ex.printStackTrace();
151                 }
152             });
153             t.start();
154         }
155 
156         // Exit test to quit the test.  This must be called at the end of the
157         // test or the test will never end.
158         void done() {
159             try {
160                 t.interrupt();
161                 ssock.close();
162             } catch (Exception e) {
163                 System.err.println(e.getMessage());
164                 e.printStackTrace();
165             }
166         }
167 
168         // Read from the client
169         byte[] read(Client client) {
170             SSLSocket s = clientMap.get(Integer.valueOf(client.getPort()));
171             if (s == null) {
172                 System.err.println(&quot;No socket found, port &quot; + client.getPort());
173             }
174             return read(s);
175         }
176 
177         // Write to the client
178         void write(Client client, byte[] data) {
179             write(clientMap.get(client.getPort()), data);
180         }
181 
182         // Server writes to the client, then reads from the client.
183         // Return true if the read &amp; write data match, false if not.
184         boolean writeRead(Client client, String s) {
185             write(client, s.getBytes());
186             return (Arrays.compare(s.getBytes(), client.read()) == 0);
187         }
188 
189         // Get the SSLSession from the server side socket
190         SSLSession getSession(Client c) {
191             SSLSocket s = clientMap.get(Integer.valueOf(c.getPort()));
192             return s.getSession();
193         }
194 
195         // Close client socket
196         void close(Client c) throws IOException {
197             SSLSocket s = clientMap.get(Integer.valueOf(c.getPort()));
198             s.close();
199         }
200     }
201 
202     /**
203      * Client side will establish a connection from the constructor and wait.
204      * It must be run after the Server constructor is called.
205      */
206     static class Client extends TLSBase {
207         SSLSocket sock;
208 
209         Client() {
210             super();
211             try {
212                 sslContext = SSLContext.getDefault();
213             } catch (Exception e) {
214                 System.err.println(e.getMessage());
215                 e.printStackTrace();
216             }
217             connect();
218         }
219 
220         // Connect to server.  Maybe runnable in the future
221         public SSLSocket connect() {
222             try {
223                 sslContext = SSLContext.getDefault();
224                 sock = (SSLSocket)sslContext.getSocketFactory().createSocket();
225                 sock.connect(new InetSocketAddress(&quot;localhost&quot;, serverPort));
226                 System.err.println(&quot;Client connected using port &quot; +
227                         sock.getLocalPort());
228                 name = &quot;client(&quot; + sock.toString() + &quot;)&quot;;
229                 write(&quot;Hello&quot;);
230                 read();
231             } catch (Exception ex) {
232                 ex.printStackTrace();
233             }
234             return sock;
235         }
236 
237         // Read from the client socket
238         byte[] read() {
239             return read(sock);
240         }
241 
242         // Write to the client socket
243         void write(byte[] data) {
244             write(sock, data);
245         }
246         void write(String s) {
247             write(sock, s.getBytes());
248         }
249 
250         // Client writes to the server, then reads from the server.
251         // Return true if the read &amp; write data match, false if not.
252         boolean writeRead(Server server, String s) {
253             write(s.getBytes());
254             return (Arrays.compare(s.getBytes(), server.read(this)) == 0);
255         }
256 
257         // Get port from the socket
258         int getPort() {
259             return sock.getLocalPort();
260         }
261 
262         // Close socket
263         void close() throws IOException {
264             sock.close();
265         }
266     }
267 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/jdk/internal/jrtfs/Basic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Basic test of jrt file system provider
 27  * @run testng Basic
 28  */
 29 
 30 import java.io.InputStream;
 31 import java.io.IOError;
 32 import java.io.IOException;
 33 import java.io.DataInputStream;
 34 import java.nio.file.DirectoryStream;
 35 import java.nio.file.InvalidPathException;
 36 import java.nio.file.Files;
 37 import java.nio.file.FileSystem;
 38 import java.nio.file.FileSystems;
 39 import java.nio.file.Path;
 40 import java.nio.file.PathMatcher;
 41 import java.nio.file.Paths;
 42 import java.net.URI;
 43 import java.util.Collections;
 44 import java.util.HashMap;
 45 import java.util.Iterator;
 46 import java.util.Map;
 47 import java.util.NoSuchElementException;
 48 import java.util.stream.Stream;
 49 
 50 import org.testng.annotations.AfterClass;
 51 import org.testng.annotations.BeforeClass;
 52 import org.testng.annotations.DataProvider;
 53 import org.testng.annotations.Test;
 54 
 55 import static org.testng.Assert.assertEquals;
 56 import static org.testng.Assert.assertNotEquals;
 57 import static org.testng.Assert.assertNotNull;
 58 import static org.testng.Assert.assertTrue;
 59 import static org.testng.Assert.assertFalse;
 60 
 61 /**
 62  * Basic tests for jrt:/ file system provider.
 63  */
 64 
 65 public class Basic {
 66 
 67     private FileSystem theFileSystem;
 68     private FileSystem fs;
 69     private boolean isExplodedBuild = false;
 70 
 71     @BeforeClass
 72     public void setup() {
 73         theFileSystem = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
 74         Path modulesPath = Paths.get(System.getProperty(&quot;java.home&quot;),
 75                 &quot;lib&quot;, &quot;modules&quot;);
 76         isExplodedBuild = Files.notExists(modulesPath);
 77         if (isExplodedBuild) {
 78             System.out.printf(&quot;%s doesn&#39;t exist.&quot;, modulesPath.toString());
 79             System.out.println();
 80             System.out.println(&quot;It is most probably an exploded build.&quot;
 81                     + &quot; Skip non-default FileSystem testing.&quot;);
 82             return;
 83         }
 84 
 85         Map&lt;String, String&gt; env = new HashMap&lt;&gt;();
 86         // set java.home property to be underlying java.home
 87         // so that jrt-fs.jar loading is exercised.
 88         env.put(&quot;java.home&quot;, System.getProperty(&quot;java.home&quot;));
 89         try {
 90             fs = FileSystems.newFileSystem(URI.create(&quot;jrt:/&quot;), env);
 91         } catch (IOException ioExp) {
 92             throw new RuntimeException(ioExp);
 93         }
 94     }
 95 
 96     @AfterClass
 97     public void tearDown() {
 98         try {
 99             fs.close();
100         } catch (Exception ignored) {}
101     }
102 
103     private FileSystem selectFileSystem(boolean theDefault) {
104         return theDefault? theFileSystem : fs;
105     }
106 
107     // Checks that the given FileSystem is a jrt file system.
108     private void checkFileSystem(FileSystem fs) {
109         assertTrue(fs.provider().getScheme().equalsIgnoreCase(&quot;jrt&quot;));
110         assertTrue(fs.isOpen());
111         assertTrue(fs.isReadOnly());
112         assertEquals(fs.getSeparator(), &quot;/&quot;);
113 
114         // one root
115         Iterator&lt;Path&gt; roots = fs.getRootDirectories().iterator();
116         assertTrue(roots.next().toString().equals(&quot;/&quot;));
117         assertFalse(roots.hasNext());
118     }
119 
120     @Test
121     public void testGetFileSystem() {
122         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
123         checkFileSystem(fs);
124 
125         // getFileSystem should return the same object each time
126         assertTrue(fs == FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;)));
127     }
128 
129     @Test(expectedExceptions = UnsupportedOperationException.class)
130     public void testCloseFileSystem() throws Exception {
131         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
132         fs.close(); // should throw UOE
133     }
134 
135     @Test
136     public void testNewFileSystem() throws Exception {
137         FileSystem theFileSystem = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
138         Map&lt;String, ?&gt; env = Collections.emptyMap();
139         try (FileSystem fs = FileSystems.newFileSystem(URI.create(&quot;jrt:/&quot;), env)) {
140             checkFileSystem(fs);
141             assertTrue(fs != theFileSystem);
142         }
143     }
144 
145     @Test
146     public void testNewFileSystemWithJavaHome() throws Exception {
147         if (isExplodedBuild) {
148             System.out.println(&quot;Skip testNewFileSystemWithJavaHome&quot;
149                     + &quot; since this is an exploded build&quot;);
150             return;
151         }
152 
153         Map&lt;String, String&gt; env = new HashMap&lt;&gt;();
154         // set java.home property to be underlying java.home
155         // so that jrt-fs.jar loading is exercised.
156         env.put(&quot;java.home&quot;, System.getProperty(&quot;java.home&quot;));
157         try (FileSystem fs = FileSystems.newFileSystem(URI.create(&quot;jrt:/&quot;), env)) {
158             checkFileSystem(fs);
159             // jrt-fs.jar classes are loaded by another (non-boot) loader in this case
160             assertNotNull(fs.provider().getClass().getClassLoader());
161         }
162     }
163 
164     @DataProvider(name = &quot;knownClassFiles&quot;)
165     private Object[][] knownClassFiles() {
166         return new Object[][] {
167             { &quot;/modules/java.base/java/lang/Object.class&quot;, true },
168             { &quot;modules/java.base/java/lang/Object.class&quot;, true },
169             { &quot;/modules/java.base/java/lang/Object.class&quot;, false },
170             { &quot;modules/java.base/java/lang/Object.class&quot;, false },
171         };
172     }
173 
174     @Test(dataProvider = &quot;knownClassFiles&quot;)
175     public void testKnownClassFiles(String path, boolean theDefault) throws Exception {
176         if (isExplodedBuild &amp;&amp; !theDefault) {
177             System.out.println(&quot;Skip testKnownClassFiles with non-default FileSystem&quot;);
178             return;
179         }
180 
181         FileSystem fs = selectFileSystem(theDefault);
182         Path classFile = fs.getPath(path);
183 
184         assertTrue(Files.isRegularFile(classFile));
185         assertTrue(Files.size(classFile) &gt; 0L);
186 
187         // check magic number
188         try (InputStream in = Files.newInputStream(classFile)) {
189             int magic = new DataInputStream(in).readInt();
190             assertEquals(magic, 0xCAFEBABE);
191         }
192     }
193 
194     @DataProvider(name = &quot;knownDirectories&quot;)
195     private Object[][] knownDirectories() {
196         return new Object[][] {
197             { &quot;/&quot;, true                     },
198             { &quot;.&quot; , true                    },
199             { &quot;./&quot;, true                    },
200             { &quot;/.&quot;, true                    },
201             { &quot;/./&quot;, true                   },
202             { &quot;/modules/java.base/..&quot;, true         },
203             { &quot;/modules/java.base/../&quot;, true        },
204             { &quot;/modules/java.base/../.&quot;, true       },
205             { &quot;/modules/java.base&quot;, true            },
206             { &quot;/modules/java.base/java/lang&quot;, true  },
207             { &quot;modules/java.base/java/lang&quot;, true   },
208             { &quot;/modules/java.base/java/lang/&quot;, true },
209             { &quot;modules/java.base/java/lang/&quot;, true  },
210             { &quot;/&quot;, false                     },
211             { &quot;.&quot; , false                    },
212             { &quot;./&quot;, false                    },
213             { &quot;/.&quot;, false                    },
214             { &quot;/./&quot;, false                   },
215             { &quot;/modules/java.base/..&quot;, false         },
216             { &quot;/modules/java.base/../&quot;, false        },
217             { &quot;/modules/java.base/../.&quot;, false       },
218             { &quot;/modules/java.base&quot;, false            },
219             { &quot;/modules/java.base/java/lang&quot;, false  },
220             { &quot;modules/java.base/java/lang&quot;, false   },
221             { &quot;/modules/java.base/java/lang/&quot;, false },
222             { &quot;modules/java.base/java/lang/&quot;, false  },
223         };
224     }
225 
226     @Test(dataProvider = &quot;knownDirectories&quot;)
227     public void testKnownDirectories(String path, boolean theDefault) throws Exception {
228         if (isExplodedBuild &amp;&amp; !theDefault) {
229             System.out.println(&quot;Skip testKnownDirectories with non-default FileSystem&quot;);
230             return;
231         }
232 
233         FileSystem fs = selectFileSystem(theDefault);
234         Path dir = fs.getPath(path);
235 
236         assertTrue(Files.isDirectory(dir));
237 
238         // directory should not be empty
239         try (Stream&lt;Path&gt; stream = Files.list(dir)) {
240             assertTrue(stream.count() &gt; 0L);
241         }
242         try (Stream&lt;Path&gt; stream = Files.walk(dir)) {
243             assertTrue(stream.count() &gt; 0L);
244         }
245     }
246 
247     @DataProvider(name = &quot;topLevelPkgDirs&quot;)
248     private Object[][] topLevelPkgDirs() {
249         return new Object[][] {
250             { &quot;/java/lang&quot; },
251             { &quot;java/lang&quot;  },
252             { &quot;/java/util&quot; },
253             { &quot;java/util&quot;  },
254         };
255     }
256 
257     @Test(dataProvider = &quot;topLevelPkgDirs&quot;)
258     public void testNotExists(String path) throws Exception {
259         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
260         Path dir = fs.getPath(path);
261 
262         // package directories should not be there at top level
263         assertTrue(Files.notExists(dir));
264     }
265 
266     /**
267      * Test the URI of every file in the jrt file system
268      */
269     @Test
270     public void testToAndFromUri() throws Exception {
271         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
272         Path top = fs.getPath(&quot;/&quot;);
273         try (Stream&lt;Path&gt; stream = Files.walk(top)) {
274             stream.forEach(path -&gt; {
275                 String pathStr = path.toAbsolutePath().toString();
276                 URI u = null;
277                 try {
278                     u = path.toUri();
279                 } catch (IOError e) {
280                     assertFalse(pathStr.startsWith(&quot;/modules&quot;));
281                     return;
282                 }
283 
284                 assertTrue(u.getScheme().equalsIgnoreCase(&quot;jrt&quot;));
285                 assertFalse(u.isOpaque());
286                 assertTrue(u.getAuthority() == null);
287 
288                 pathStr = pathStr.substring(&quot;/modules&quot;.length());
289                 if (pathStr.isEmpty()) {
290                     pathStr = &quot;/&quot;;
291                 }
292                 assertEquals(u.getPath(), pathStr);
293                 Path p = Paths.get(u);
294                 assertEquals(p, path);
295             });
296         }
297     }
298 
299     // @bug 8216553: JrtFIleSystemProvider getPath(URI) omits /modules element from file path
300     @Test
301     public void testPathToURIConversion() throws Exception {
302         var uri = URI.create(&quot;jrt:/java.base/module-info.class&quot;);
303         var path = Path.of(uri);
304         assertTrue(Files.exists(path));
305 
306         uri = URI.create(&quot;jrt:/java.base/../java.base/module-info.class&quot;);
307         boolean seenIAE = false;
308         try {
309             Path.of(uri);
310         } catch (IllegalArgumentException iaExp) {
311             seenIAE = true;
312         }
313         assertTrue(seenIAE);
314 
315         // check round-trip
316         var jrtfs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
317         assertTrue(Files.exists(jrtfs.getPath(path.toString())));
318 
319         path = jrtfs.getPath(&quot;/modules/../modules/java.base/&quot;);
320         boolean seenIOError = false;
321         try {
322             path.toUri();
323         } catch (IOError ioError) {
324             seenIOError = true;
325         }
326         assertTrue(seenIOError);
327     }
328 
329     @Test
330     public void testDirectoryNames() throws Exception {
331         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
332         Path top = fs.getPath(&quot;/&quot;);
333         // check that directory names do not have trailing &#39;/&#39; char
334         try (Stream&lt;Path&gt; stream = Files.walk(top)) {
335             stream.skip(1).filter(Files::isDirectory).forEach(path -&gt; {
336                 assertFalse(path.toString().endsWith(&quot;/&quot;));
337             });
338         }
339     }
340 
341     @DataProvider(name = &quot;pathPrefixs&quot;)
342     private Object[][] pathPrefixes() {
343         return new Object[][] {
344             { &quot;/&quot;                       },
345             { &quot;modules/java.base/java/lang&quot;     },
346             { &quot;./modules/java.base/java/lang&quot;   },
347             { &quot;/modules/java.base/java/lang&quot;    },
348             { &quot;/./modules/java.base/java/lang&quot;  },
349             { &quot;modules/java.base/java/lang/&quot;    },
350             { &quot;./modules/java.base/java/lang/&quot;  },
351             { &quot;/./modules/java.base/java/lang/&quot; },
352         };
353     }
354 
355     // @Test(dataProvider = &quot;pathPrefixes&quot;)
356     public void testParentInDirList(String dir) throws Exception {
357         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
358         Path base = fs.getPath(dir);
359         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(base)) {
360             for (Path entry: stream) {
361                 assertTrue( entry.getParent().equals(base),
362                     base.toString() + &quot;-&gt; &quot; + entry.toString() );
363             }
364         }
365     }
366 
367     @DataProvider(name = &quot;dirStreamStringFilterData&quot;)
368     private Object[][] dirStreamStringFilterData() {
369         return new Object[][] {
370             { &quot;/modules/java.base/java/lang&quot;, &quot;/reflect&quot;      },
371             { &quot;/modules/java.base/java/lang&quot;, &quot;/Object.class&quot; },
372             { &quot;/modules/java.base/java/util&quot;, &quot;/stream&quot;       },
373             { &quot;/modules/java.base/java/util&quot;, &quot;/List.class&quot;   },
374         };
375     }
376 
377     @Test(dataProvider = &quot;dirStreamStringFilterData&quot;)
378     public void testDirectoryStreamStringFilter(String dir, String filter) throws Exception {
379         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
380         Path base = fs.getPath(dir);
381         try (DirectoryStream&lt;Path&gt; stream =
382                 Files.newDirectoryStream(base, p-&gt;!p.toString().endsWith(filter))) {
383             for (Path entry: stream) {
384                 assertFalse(entry.toString().contains(filter),
385                     &quot;filtered path seen: &quot; + filter);
386             }
387         }
388 
389         // make sure without filter, we do see that matching entry!
390         boolean seen = false;
391         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(base)) {
392             for (Path entry: stream) {
393                 if (entry.toString().endsWith(filter)) {
394                     seen = true;
395                     break;
396                 }
397             }
398         }
399 
400         assertTrue(seen, &quot;even without filter &quot; + filter + &quot; is missing&quot;);
401     }
402 
403     @DataProvider(name = &quot;dirStreamFilterData&quot;)
404     private Object[][] dirStreamFilterData() {
405         return new Object[][] {
406             {
407               &quot;/&quot;,
408               (DirectoryStream.Filter&lt;Path&gt;)(Files::isDirectory),
409               &quot;isDirectory&quot;
410             },
411             {
412               &quot;/modules/java.base/java/lang&quot;,
413               (DirectoryStream.Filter&lt;Path&gt;)(Files::isRegularFile),
414               &quot;isFile&quot;
415             }
416         };
417     }
418 
419     @Test(dataProvider = &quot;dirStreamFilterData&quot;)
420     private void testDirectoryStreamFilter(String dir, DirectoryStream.Filter filter,
421             String name) throws Exception {
422         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
423         Path base = fs.getPath(dir);
424         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(base, filter)) {
425             for (Path entry: stream) {
426                 assertTrue(filter.accept(entry), &quot;filtered path seen: &quot; + name);
427             }
428         }
429 
430         // make sure without filter, we do see that matching entry!
431         boolean seen = false;
432         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(base)) {
433             for (Path entry: stream) {
434                 if (filter.accept(entry)) {
435                     seen = true;
436                     break;
437                 }
438             }
439         }
440 
441         assertTrue(seen, &quot;even without filter &quot; + name + &quot; is missing&quot;);
442     }
443 
444     @Test
445     private void testDirectoryStreamIterator() throws Exception {
446         // run the tests with null filter (no filter)
447         dirStreamIteratorTest(null);
448         // run the same tests with trivial &quot;accept all&quot; filter
449         dirStreamIteratorTest(p-&gt;true);
450         // two other non-trivial ones
451         dirStreamIteratorTest(Files::isDirectory);
452         dirStreamIteratorTest(Files::isRegularFile);
453     }
454 
455     private void dirStreamIteratorTest(DirectoryStream.Filter&lt;Path&gt; filter)
456             throws Exception {
457         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
458         // This test assumes at least there are two elements in &quot;java/lang&quot;
459         // package with any filter passed. don&#39;t change to different path here!
460         Path dir = fs.getPath(&quot;/modules/java.base/java/lang&quot;);
461         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, filter)) {
462             Iterator&lt;Path&gt; itr = stream.iterator();
463             itr.hasNext();
464             Path path1 = itr.next();
465             // missing second hasNext call
466             Path path2 = itr.next();
467             assertNotEquals(path1, path2);
468         }
469 
470         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, filter)) {
471             Iterator&lt;Path&gt; itr = stream.iterator();
472             // no hasNext calls at all
473             Path path1 = itr.next();
474             Path path2 = itr.next();
475             assertNotEquals(path1, path2);
476         }
477 
478         int numEntries = 0;
479         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, filter)) {
480             Iterator&lt;Path&gt; itr = stream.iterator();
481             while (itr.hasNext()) {
482                 numEntries++;
483                 itr.next();
484             }
485 
486             // reached EOF, next call should result in exception
487             try {
488                 itr.next();
489                 throw new AssertionError(&quot;should have thrown exception&quot;);
490             } catch (NoSuchElementException nsee) {
491                 System.out.println(&quot;got NoSuchElementException as expected&quot;);
492             }
493         }
494 
495         // redundant hasNext calls
496         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, filter)) {
497             Iterator&lt;Path&gt; itr = stream.iterator();
498             // any number of hasNext should definitely stay at first element
499             for (int i = 0; i &lt; 2*numEntries; i++) {
500                 itr.hasNext();
501             }
502 
503             for (int j = 0; j &lt; numEntries; j++) {
504                 itr.next();
505             }
506             // exactly count number of entries!
507             assertFalse(itr.hasNext());
508         }
509     }
510 
511     @DataProvider(name = &quot;hiddenPaths&quot;)
512     private Object[][] hiddenPaths() {
513         return new Object[][] {
514             { &quot;/META-INF&quot; },
515             { &quot;/META-INF/services&quot; },
516             { &quot;/META-INF/services/java.nio.file.spi.FileSystemProvider&quot; },
517             { &quot;/modules/java.base/packages.offsets&quot; },
518             { &quot;/modules/java.instrument/packages.offsets&quot; },
519             { &quot;/modules/jdk.zipfs/packages.offsets&quot; },
520             { &quot;/modules/java.base/_the.java.base.vardeps&quot; },
521             { &quot;/modules/java.base/_the.java.base_batch&quot; },
522             { &quot;/java/lang&quot; },
523             { &quot;/java/util&quot; },
524         };
525     }
526 
527     @Test(dataProvider = &quot;hiddenPaths&quot;)
528     public void testHiddenPathsNotExposed(String path) throws Exception {
529         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
530         assertTrue(Files.notExists(fs.getPath(path)), path + &quot; should not exist&quot;);
531     }
532 
533     @DataProvider(name = &quot;pathGlobPatterns&quot;)
534     private Object[][] pathGlobPatterns() {
535         return new Object[][] {
536             { &quot;/modules/*&quot;, &quot;/modules/java.base&quot;, true },
537             { &quot;/modules/*&quot;, &quot;/modules/java.base/java&quot;, false },
538             { &quot;/modules/j*&quot;, &quot;/modules/java.base&quot;, true },
539             { &quot;/modules/J*&quot;, &quot;/modules/java.base&quot;, false },
540             { &quot;**.class&quot;, &quot;/modules/java.base/java/lang/Object.class&quot;, true },
541             { &quot;**.java&quot;, &quot;/modules/java.base/java/lang/Object.class&quot;, false },
542             { &quot;**java/*&quot;, &quot;/modules/java.base/java/lang&quot;, true },
543             { &quot;**java/lang/ref*&quot;, &quot;/modules/java.base/java/lang/reflect&quot;, true },
544             { &quot;**java/lang/ref*&quot;, &quot;/modules/java.base/java/lang/ref&quot;, true },
545             { &quot;**java/lang/ref?&quot;, &quot;/modules/java.base/java/lang/ref&quot;, false },
546             { &quot;**java/lang/{ref,refl*}&quot;, &quot;/modules/java.base/java/lang/ref&quot;, true },
547             { &quot;**java/lang/{ref,refl*}&quot;, &quot;/modules/java.base/java/lang/reflect&quot;, true },
548             { &quot;**java/[a-u]?*/*.class&quot;, &quot;/modules/java.base/java/util/Map.class&quot;, true },
549             { &quot;**java/util/[a-z]*.class&quot;, &quot;/modules/java.base/java/util/TreeMap.class&quot;, false },
550         };
551     }
552 
553     @Test(dataProvider = &quot;pathGlobPatterns&quot;)
554     public void testGlobPathMatcher(String pattern, String path,
555             boolean expectMatch) throws Exception {
556         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
557         PathMatcher pm = fs.getPathMatcher(&quot;glob:&quot; + pattern);
558         Path p = fs.getPath(path);
559         assertTrue(Files.exists(p), path);
560         assertTrue(!(pm.matches(p) ^ expectMatch),
561             p + (expectMatch? &quot; should match &quot; : &quot; should not match &quot;) +
562             pattern);
563     }
564 
565     @DataProvider(name = &quot;pathRegexPatterns&quot;)
566     private Object[][] pathRegexPatterns() {
567         return new Object[][] {
568             { &quot;/modules/.*&quot;, &quot;/modules/java.base&quot;, true },
569             { &quot;/modules/[^/]*&quot;, &quot;/modules/java.base/java&quot;, false },
570             { &quot;/modules/j.*&quot;, &quot;/modules/java.base&quot;, true },
571             { &quot;/modules/J.*&quot;, &quot;/modules/java.base&quot;, false },
572             { &quot;.*\\.class&quot;, &quot;/modules/java.base/java/lang/Object.class&quot;, true },
573             { &quot;.*\\.java&quot;, &quot;/modules/java.base/java/lang/Object.class&quot;, false },
574             { &quot;.*java/.*&quot;, &quot;/modules/java.base/java/lang&quot;, true },
575             { &quot;.*java/lang/ref.*&quot;, &quot;/modules/java.base/java/lang/reflect&quot;, true },
576             { &quot;.*java/lang/ref.*&quot;, &quot;/modules/java.base/java/lang/ref&quot;, true },
577             { &quot;.*/java/lang/ref.+&quot;, &quot;/modules/java.base/java/lang/ref&quot;, false },
578             { &quot;.*/java/lang/(ref|refl.*)&quot;, &quot;/modules/java.base/java/lang/ref&quot;, true },
579             { &quot;.*/java/lang/(ref|refl.*)&quot;, &quot;/modules/java.base/java/lang/reflect&quot;, true },
580             { &quot;.*/java/[a-u]?.*/.*\\.class&quot;, &quot;/modules/java.base/java/util/Map.class&quot;, true },
581             { &quot;.*/java/util/[a-z]*\\.class&quot;, &quot;/modules/java.base/java/util/TreeMap.class&quot;, false },
582         };
583     }
584 
585     @Test(dataProvider = &quot;pathRegexPatterns&quot;)
586     public void testRegexPathMatcher(String pattern, String path,
587             boolean expectMatch) throws Exception {
588         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
589         PathMatcher pm = fs.getPathMatcher(&quot;regex:&quot; + pattern);
590         Path p = fs.getPath(path);
591         assertTrue(Files.exists(p), path);
592         assertTrue(!(pm.matches(p) ^ expectMatch),
593             p + (expectMatch? &quot; should match &quot; : &quot; should not match &quot;) +
594             pattern);
595     }
596 
597     @Test
598     public void testPackagesAndModules() throws Exception {
599         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
600         assertTrue(Files.isDirectory(fs.getPath(&quot;/packages&quot;)));
601         assertTrue(Files.isDirectory(fs.getPath(&quot;/modules&quot;)));
602     }
603 
604     @DataProvider(name = &quot;packagesSubDirs&quot;)
605     private Object[][] packagesSubDirs() {
606         return new Object[][] {
607             { &quot;java.lang&quot; },
608             { &quot;java.util&quot; },
609             { &quot;java.nio&quot;  },
<a name="1" id="anc1"></a><span class="line-removed">610             { &quot;jdk.nashorn.api.scripting&quot; }</span>
611         };
612     }
613 
614     @Test(dataProvider = &quot;packagesSubDirs&quot;)
615     public void testPackagesSubDirs(String pkg) throws Exception {
616         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
617         assertTrue(Files.isDirectory(fs.getPath(&quot;/packages/&quot; + pkg)),
618             pkg + &quot; missing&quot;);
619     }
620 
621     @DataProvider(name = &quot;packagesLinks&quot;)
622     private Object[][] packagesLinks() {
623         return new Object[][] {
624             { &quot;/packages/java.lang/java.base&quot; },
625             { &quot;/packages/java.lang/java.instrument&quot; },
626             { &quot;/packages/java/java.base&quot; },
627             { &quot;/packages/java/java.instrument&quot; },
628             { &quot;/packages/java/java.rmi&quot;  },
629             { &quot;/packages/java/java.sql&quot;  },
630             { &quot;/packages/javax/java.base&quot;  },
631             { &quot;/packages/javax/java.sql&quot;  },
632             { &quot;/packages/javax/java.xml&quot;  },
633             { &quot;/packages/javax/java.management&quot;  },
634             { &quot;/packages/java.util/java.base&quot; },
<a name="2" id="anc2"></a><span class="line-removed">635             { &quot;/packages/jdk.nashorn.api.scripting/jdk.scripting.nashorn&quot; },</span>
636         };
637     }
638 
639     @Test(dataProvider = &quot;packagesLinks&quot;)
640     public void testPackagesLinks(String link) throws Exception {
641         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
642         Path path = fs.getPath(link);
643         assertTrue(Files.exists(path), link + &quot; missing&quot;);
644         assertTrue(Files.isSymbolicLink(path), path + &quot; is not a link&quot;);
645         path = Files.readSymbolicLink(path);
646         assertEquals(path.toString(), &quot;/modules&quot; + link.substring(link.lastIndexOf(&quot;/&quot;)));
647     }
648 
649     @DataProvider(name = &quot;modulesSubDirs&quot;)
650     private Object[][] modulesSubDirs() {
651         return new Object[][] {
652             { &quot;java.base&quot; },
653             { &quot;java.sql&quot; },
<a name="3" id="anc3"></a><span class="line-removed">654             { &quot;jdk.scripting.nashorn&quot; },</span>
655         };
656     }
657 
658     @Test(dataProvider = &quot;modulesSubDirs&quot;)
659     public void testModulesSubDirs(String module) throws Exception {
660         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
661         Path path = fs.getPath(&quot;/modules/&quot; + module);
662         assertTrue(Files.isDirectory(path), module + &quot; missing&quot;);
663         assertTrue(!Files.isSymbolicLink(path), path + &quot; is a link&quot;);
664     }
665 
666     @DataProvider(name=&quot;linkChases&quot;)
667     private Object[][] linkChases() {
668         return new Object[][] {
669             { &quot;/modules/java.base/java/lang&quot; },
670             { &quot;/modules/java.base/java/util/Vector.class&quot; },
<a name="4" id="anc4"></a><span class="line-removed">671             { &quot;/modules/jdk.scripting.nashorn/jdk/nashorn&quot; },</span>
672             { &quot;/packages/java.lang/java.base/java/lang&quot; },
673             { &quot;/packages/java.util/java.base/java/util/Vector.class&quot; },
674         };
675     }
676 
677     @Test(dataProvider = &quot;linkChases&quot;)
678     public void testLinkChases(String link) throws Exception {
679         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
680         Path path = fs.getPath(link);
681         assertTrue(Files.exists(path), link);
682     }
683 
684     @Test
685     public void testSymlinkDirList() throws Exception {
686         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
687         Path path = fs.getPath(&quot;/packages/java.lang/java.base&quot;);
688         assertTrue(Files.isSymbolicLink(path));
689         assertTrue(Files.isDirectory(path));
690 
691         boolean javaSeen = false, javaxSeen = false;
692         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(path)) {
693             for (Path p : stream) {
694                 String str = p.toString();
695                 if (str.endsWith(&quot;/java&quot;)) {
696                     javaSeen = true;
697                 } else if (str.endsWith(&quot;javax&quot;)) {
698                     javaxSeen = true;
699                 }
700             }
701         }
702         assertTrue(javaSeen);
703         assertTrue(javaxSeen);
704     }
705 
706     @Test
707     public void invalidPathTest() {
708         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
709         InvalidPathException ipe = null;
710         try {
711             boolean res = Files.exists(fs.getPath(&quot;/packages/\ud834\udd7b&quot;));
712             assertFalse(res);
713             return;
714         } catch (InvalidPathException e) {
715             ipe = e;
716         }
717         assertTrue(ipe != null);
718     }
719 
720     @DataProvider(name=&quot;packagesLinkedDirs&quot;)
721     private Object[][] packagesLinkedDirs() {
722         return new Object[][] {
723             { &quot;/packages/java.lang/java.base/java/lang/ref&quot;             },
724             { &quot;/./packages/java.lang/java.base/java/lang/ref&quot;           },
725             { &quot;packages/java.lang/java.base/java/lang/ref&quot;              },
726             { &quot;/packages/../packages/java.lang/java.base/java/lang/ref&quot; },
727             { &quot;/packages/java.lang/java.base/java/util/zip&quot;             },
728             { &quot;/./packages/java.lang/java.base/java/util/zip&quot;           },
729             { &quot;packages/java.lang/java.base/java/util/zip&quot;              },
730             { &quot;/packages/../packages/java.lang/java.base/java/util/zip&quot; },
731         };
732     }
733 
734     // @bug 8141521: jrt file system&#39;s DirectoryStream reports child paths
735     // with wrong paths for directories under /packages
736     @Test(dataProvider = &quot;packagesLinkedDirs&quot;)
737     public void dirStreamPackagesDirTest(String dirName) throws IOException {
738         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
739         Path path = fs.getPath(dirName);
740 
741         int childCount = 0, dirPrefixOkayCount = 0;
742         try (DirectoryStream&lt;Path&gt; dirStream = Files.newDirectoryStream(path)) {
743             for (Path child : dirStream) {
744                 childCount++;
745                 if (child.toString().startsWith(dirName)) {
746                     dirPrefixOkayCount++;
747                 }
748             }
749         }
750 
751         assertTrue(childCount != 0);
752         assertEquals(dirPrefixOkayCount, childCount);
753     }
754 
755     @Test
756     public void objectClassSizeTest() throws Exception {
757         String path = &quot;/modules/java.base/java/lang/Object.class&quot;;
758         FileSystem fs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
759         Path classFile = fs.getPath(path);
760 
761         assertTrue(Files.size(classFile) &gt; 0L);
762     }
763 }
764 
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
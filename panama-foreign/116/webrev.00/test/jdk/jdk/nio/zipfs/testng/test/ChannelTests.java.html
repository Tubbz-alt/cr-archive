<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/nio/zipfs/testng/test/ChannelTests.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 package test;
  25 
  26 import org.testng.annotations.Test;
  27 import util.ZipFsBaseTest;
  28 
  29 import java.io.ByteArrayOutputStream;
  30 import java.io.IOException;
  31 import java.nio.ByteBuffer;
  32 import java.nio.channels.ClosedChannelException;
  33 import java.nio.channels.FileChannel;
  34 import java.nio.channels.FileLock;
  35 import java.nio.channels.SeekableByteChannel;
  36 import java.nio.file.*;
  37 import java.util.Arrays;
  38 import java.util.Map;
  39 import java.util.Random;
  40 import java.util.Set;
  41 import java.util.zip.ZipEntry;
  42 
  43 import static java.nio.charset.StandardCharsets.UTF_8;
  44 import static java.nio.file.StandardOpenOption.*;
  45 import static org.testng.Assert.*;
  46 
  47 /**
  48  * @test
  49  * @bug 8242006
  50  * @summary Improve FileChannel and SeekableByteChannel Zip FS test coverage
  51  * @modules jdk.zipfs
  52  * @run testng test.ChannelTests
  53  */
  54 public class ChannelTests extends ZipFsBaseTest {
  55 
  56     // Size of the ByteBuffer to use for reading/writing
  57     public static final int BYTEBUFFER_SIZE = 8192;
  58     // Values used to create the entries to be copied into/from a Zip file
  59     private static final String GRAND_SLAMS_HEADER = &quot;The Grand Slams Are:&quot;
  60             + System.lineSeparator();
  61     private static final String AUSTRALIAN_OPEN = &quot;Australian Open&quot;
  62             + System.lineSeparator();
  63     private static final String FRENCH_OPEN = &quot;French Open&quot; + System.lineSeparator();
  64     private static final String WIMBLEDON = &quot;Wimbledon&quot; + System.lineSeparator();
  65     private static final String US_OPEN = &quot;U.S. Open&quot; + System.lineSeparator();
  66     private static final String GRAND_SLAMS = AUSTRALIAN_OPEN
  67             + FRENCH_OPEN
  68             + WIMBLEDON
  69             + US_OPEN;
  70     private static final String THE_SLAMS = GRAND_SLAMS_HEADER
  71             + GRAND_SLAMS;
  72     private static final String FIFTH_MAJOR = &quot;Indian Wells is the 5th Major&quot;
  73             + System.lineSeparator();
  74     private static final Random RANDOM = new Random();
  75 
  76     /**
  77      * Validate SeekableByteChannel can be used to copy an OS file to
  78      * a Zip file
  79      *
  80      * @param env         Zip FS properties to use when creating the Zip file
  81      * @param compression The compression used when writing the entries
  82      * @throws Exception If an error occurs
  83      */
  84     @Test(dataProvider = &quot;zipfsMap&quot;)
  85     public void sbcFromOSToZipTest(final Map&lt;String, String&gt; env,
  86                                    final int compression) throws Exception {
  87         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, FIFTH_MAJOR);
  88         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
  89         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
  90         Files.deleteIfExists(osFile);
  91         Files.deleteIfExists(zipFile);
  92         Files.writeString(osFile, FIFTH_MAJOR);
  93         // Create a Zip entry from an OS file
  94         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
  95             sbcCopy(osFile, zipfs.getPath(e00.name));
  96         }
  97         // Check to see if the entries match
  98         verify(zipFile, e00);
  99         Files.deleteIfExists(osFile);
 100         Files.deleteIfExists(zipFile);
 101     }
 102 
 103     /**
 104      * Validate SeekableByteChannel can be used to copy an entry from
 105      * a Zip file to an OS file
 106      *
 107      * @param env         Zip FS properties to use when creating the Zip file
 108      * @param compression The compression used when writing the entries
 109      * @throws Exception If an error occurs
 110      */
 111     @Test(dataProvider = &quot;zipfsMap&quot;)
 112     public void sbcFromZipToOSTest(final Map&lt;String, String&gt; env,
 113                                    final int compression) throws Exception {
 114         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 115         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
 116         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 117         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
 118         Files.deleteIfExists(zipFile);
 119         Files.deleteIfExists(osFile);
 120         zip(zipFile, env, e0, e1);
 121         verify(zipFile, e0, e1);
 122         // Create an OS file from a Zip entry
 123         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 124             sbcCopy(zipfs.getPath(e0.name), osFile);
 125         }
 126         // Check to see if the file exists and the bytes match
 127         assertTrue(Files.isRegularFile(osFile));
 128         assertEquals(Files.readAllBytes(osFile), e0.bytes);
 129         Files.deleteIfExists(zipFile);
 130         Files.deleteIfExists(osFile);
 131     }
 132 
 133     /**
 134      * Validate SeekableByteChannel can be used to copy an entry from
 135      * one Zip file to another Zip file
 136      *
 137      * @param env         Zip FS properties to use when creating the Zip file
 138      * @param compression The compression used when writing the entries
 139      * @throws Exception If an error occurs
 140      */
 141     @Test(dataProvider = &quot;zipfsMap&quot;)
 142     public void sbcFromZipToZipTest(final Map&lt;String, String&gt; env,
 143                                     final int compression) throws Exception {
 144         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 145         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
 146         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 147         Path zipFile2 = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 148         Files.deleteIfExists(zipFile);
 149         Files.deleteIfExists(zipFile2);
 150         zip(zipFile, env, e0, e1);
 151         verify(zipFile, e0, e1);
 152         // Copy entries from one Zip file to another using SeekableByteChannel
 153         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 154              FileSystem zipfs2 = FileSystems.newFileSystem(zipFile2, env)) {
 155             sbcCopy(zipfs.getPath(e0.name), zipfs2.getPath(e0.name));
 156             sbcCopy(zipfs.getPath(e1.name), zipfs2.getPath(e1.name));
 157         }
 158         // Check to see if the entries match
 159         verify(zipFile2, e0, e1);
 160         Files.deleteIfExists(zipFile);
 161         Files.deleteIfExists(zipFile2);
 162     }
 163 
 164     /**
 165      * Validate SeekableByteChannel can be used to copy an entry within
 166      * a Zip file with the correct compression
 167      *
 168      * @param env                 Zip FS properties to use when creating the Zip file
 169      * @param compression         The compression used when writing the initial entries
 170      * @param expectedCompression The compression to be used when copying the entry
 171      * @throws Exception If an error occurs
 172      */
 173     @Test(dataProvider = &quot;copyMoveMap&quot;)
 174     public void sbcChangeCompressionTest(final Map&lt;String, String&gt; env,
 175                                          final int compression,
 176                                          final int expectedCompression) throws Exception {
 177         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 178         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
 179         Entry e00 = Entry.of(&quot;Entry-00&quot;, expectedCompression, THE_SLAMS);
 180         // Compression method to use when copying the entry
 181         String targetCompression = expectedCompression == ZipEntry.STORED ? &quot;true&quot; : &quot;false&quot;;
 182         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 183         Path zipFile2 = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 184         Files.deleteIfExists(zipFile);
 185         Files.deleteIfExists(zipFile2);
 186         // Create the initial Zip files
 187         zip(zipFile, env, e0, e1);
 188         zip(zipFile2, env, e0, e1);
 189         verify(zipFile, e0, e1);
 190         // Copy the entry from one Zip file to another using SeekableByteChannel
 191         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 192              FileSystem zipfs2 = FileSystems.newFileSystem(zipFile2,
 193                      Map.of(&quot;noCompression&quot;, targetCompression))) {
 194             sbcCopy(zipfs.getPath(e0.name), zipfs2.getPath(e00.name));
 195         }
 196         // Check to see if the entries match
 197         verify(zipFile2, e0, e1, e00);
 198         Files.deleteIfExists(zipFile);
 199         Files.deleteIfExists(zipFile2);
 200     }
 201 
 202     /**
 203      * Validate SeekableByteChannel::read can be used to read a Zip entry
 204      *
 205      * @param env         Zip FS properties to use when creating the Zip file
 206      * @param compression The compression used when writing the entries
 207      * @throws Exception If an error occurs
 208      */
 209     @Test(dataProvider = &quot;zipfsMap&quot;)
 210     public void sbcReadTest(final Map&lt;String, String&gt; env,
 211                             final int compression) throws Exception {
 212         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 213         Files.deleteIfExists(zipFile);
 214         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 215         zip(zipFile, env, e0);
 216         // Read an entry
 217         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 218              SeekableByteChannel sbc =
 219                      Files.newByteChannel(zipfs.getPath(e0.name),
 220                      Set.of(READ))) {
 221             ByteBuffer buf = ByteBuffer.allocate((int) sbc.size());
 222             int bytesRead = sbc.read(buf);
 223             // Check to see if the expected bytes were read
 224             byte[] result = Arrays.copyOfRange(buf.array(), 0, bytesRead);
 225             assertEquals(THE_SLAMS.getBytes(UTF_8), result);
 226         }
 227         Files.deleteIfExists(zipFile);
 228     }
 229 
 230     /**
 231      * Validate SeekableByteChannel::write can be used to create a Zip entry
 232      *
 233      * @param env         Zip FS properties to use when creating the Zip file
 234      * @param compression The compression used when writing the entries
 235      * @throws Exception If an error occurs
 236      */
 237     @Test(dataProvider = &quot;zipfsMap&quot;)
 238     public void sbcWriteTest(final Map&lt;String, String&gt; env,
 239                              final int compression) throws Exception {
 240         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 241         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 242         Files.deleteIfExists(zipFile);
 243         // Create the Zip entry
 244         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 245              SeekableByteChannel sbc =
 246                      Files.newByteChannel(zipfs.getPath(e0.name),
 247                      Set.of(CREATE, WRITE))) {
 248             ByteBuffer bb = ByteBuffer.wrap(THE_SLAMS.getBytes(UTF_8));
 249             sbc.write(bb);
 250         }
 251         // Verify the entry
 252         verify(zipFile, e0);
 253         Files.deleteIfExists(zipFile);
 254     }
 255 
 256     /**
 257      * Validate SeekableByteChannel can be used to append to an entry
 258      * in a Zip file
 259      *
 260      * @param env         Zip FS properties to use when creating the Zip file
 261      * @param compression The compression used when writing the entries
 262      * @throws Exception If an error occurs
 263      */
 264     @Test(dataProvider = &quot;zipfsMap&quot;)
 265     public void sbcAppendTest(final Map&lt;String, String&gt; env,
 266                               final int compression) throws Exception {
 267         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 268         Files.deleteIfExists(zipFile);
 269         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 270         zip(zipFile, env, e0);
 271         // Update a Zip entry by appending to it
 272         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 273              SeekableByteChannel sbc =
 274                      Files.newByteChannel(zipfs.getPath(e0.name),
 275                              Set.of(WRITE, APPEND))) {
 276             ByteBuffer bb = ByteBuffer.wrap(FIFTH_MAJOR.getBytes());
 277             sbc.write(bb);
 278         }
 279         // Check to see if the entries match
 280         verify(zipFile, e0.content(THE_SLAMS + FIFTH_MAJOR));
 281         Files.deleteIfExists(zipFile);
 282     }
 283 
 284     /**
 285      * Validate UnsupportedOperationException is thrown when
 286      * SeekableByteChannel::truncate is invoked
 287      * Note: Feature Request: JDK-8241959 has been created to support this
 288      * functionality
 289      *
 290      * @param env         Zip FS properties to use when creating the Zip file
 291      * @param compression The compression used when writing the entries
 292      * @throws Exception If an error occurs
 293      */
 294     @Test(dataProvider = &quot;zipfsMap&quot;)
 295     public void sbcTruncateTest(final Map&lt;String, String&gt; env,
 296                                 final int compression) throws Exception {
 297         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 298         Files.deleteIfExists(zipFile);
 299         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 300         zip(zipFile, env, e0);
 301         // Verify that a UnsupportedOperationException is thrown
 302         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 303              SeekableByteChannel sbc =
 304                      Files.newByteChannel(zipfs.getPath(e0.name), Set.of(WRITE))) {
 305             assertThrows(UnsupportedOperationException.class, () -&gt;
 306                     sbc.truncate(GRAND_SLAMS_HEADER.length()));
 307         }
 308         Files.deleteIfExists(zipFile);
 309     }
 310 
 311     /**
 312      * Validate FileAlreadyExistsException is thrown when
 313      * Files::newByteChannel is invoked with the CREATE_NEW option along with
 314      * either the WRITE or APPEND option and the entry already exists
 315      *
 316      * @param env         Zip FS properties to use when creating the Zip file
 317      * @param compression The compression used when writing the entries
 318      * @throws Exception If an error occurs
 319      */
 320     @Test(dataProvider = &quot;zipfsMap&quot;)
 321     public void sbcFAETest(final Map&lt;String, String&gt; env,
 322                            final int compression) throws Exception {
 323         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 324         Files.deleteIfExists(zipFile);
 325         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 326         zip(zipFile, env, e0);
 327         // Validate that a FileAlreadyExistsException is thrown
 328         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 329             assertThrows(FileAlreadyExistsException.class, () -&gt;
 330                     Files.newByteChannel(zipfs.getPath(e0.name),
 331                             Set.of(CREATE_NEW, WRITE)));
 332             assertThrows(FileAlreadyExistsException.class, () -&gt;
 333                     Files.newByteChannel(zipfs.getPath(e0.name),
 334                             Set.of(CREATE_NEW, APPEND)));
 335         }
 336         Files.deleteIfExists(zipFile);
 337     }
 338 
 339     /**
 340      * Validate when SeekableByteChannel::close is called more than once, that
 341      * no error occurs
 342      *
 343      * @param env         Zip FS properties to use when creating the Zip file
 344      * @param compression The compression used when writing the entries
 345      * @throws Exception If an error occurs
 346      */
 347     @Test(dataProvider = &quot;zipfsMap&quot;)
 348     public void sbcCloseTest(final Map&lt;String, String&gt; env,
 349                              final int compression) throws Exception {
 350         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 351         Files.deleteIfExists(zipFile);
 352         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 353         zip(zipFile, env, e0);
 354         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 355             SeekableByteChannel sbc = Files.newByteChannel(zipfs.getPath(e0.name),
 356                     Set.of(READ, WRITE));
 357             sbc.close();
 358             sbc.close();
 359             assertFalse(sbc.isOpen());
 360         }
 361         Files.deleteIfExists(zipFile);
 362     }
 363 
 364     /**
 365      * Validate ClosedChannelException is thrown when a SeekableByteChannel
 366      * method is invoked after calling SeekableByteChannel::close
 367      *
 368      * @param env         Zip FS properties to use when creating the Zip file
 369      * @param compression The compression used when writing the entries
 370      * @throws Exception If an error occurs
 371      */
 372     @Test(dataProvider = &quot;zipfsMap&quot;)
 373     public void sbcCCETest(final Map&lt;String, String&gt; env,
 374                            final int compression) throws Exception {
 375         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 376         Files.deleteIfExists(zipFile);
 377         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 378         zip(zipFile, env, e0);
 379         ByteBuffer bb = ByteBuffer.wrap(&quot;First Serve&quot;.getBytes(UTF_8));
 380         // Check that ClosedChannelException is thrown if the channel is closed
 381         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 382             SeekableByteChannel sbc = Files.newByteChannel(zipfs.getPath(e0.name),
 383                     Set.of(READ, WRITE));
 384             sbc.close();
 385             assertThrows(ClosedChannelException.class, sbc::position);
 386             assertThrows(ClosedChannelException.class, () -&gt; sbc.position(1));
 387             assertThrows(ClosedChannelException.class, () -&gt; sbc.read(bb));
 388             assertThrows(ClosedChannelException.class, sbc::size);
 389             assertThrows(ClosedChannelException.class, () -&gt; sbc.truncate(2));
 390             assertThrows(ClosedChannelException.class, () -&gt; sbc.write(bb));
 391         }
 392         Files.deleteIfExists(zipFile);
 393     }
 394 
 395     /**
 396      * Validate SeekableByteChannel::size can be used to obtain the size
 397      * of a Zip entry
 398      * Note:  If the file is opened for writing, the test will fail unless data
 399      * has been written.  See: JDK-8241949
 400      * @param env         Zip FS properties to use when creating the Zip file
 401      * @param compression The compression used when writing the entries
 402      * @throws Exception If an error occurs
 403      */
 404     @Test(dataProvider = &quot;zipfsMap&quot;)
 405     public void sbcSizeTest(final Map&lt;String, String&gt; env,
 406                             final int compression) throws Exception {
 407         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 408         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 409         Files.deleteIfExists(zipFile);
 410         zip(zipFile, env, e0);
 411         // Open the file and validate the size
 412         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 413              SeekableByteChannel sbc = Files.newByteChannel(
 414                      zipfs.getPath(e0.name), Set.of(READ))) {
 415             assertEquals(sbc.size(), THE_SLAMS.length());
 416         }
 417         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 418              SeekableByteChannel sbc = Files.newByteChannel(zipfs.getPath(e0.name))) {
 419             assertEquals(sbc.size(), THE_SLAMS.length());
 420         }
 421         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 422              SeekableByteChannel sbc = Files.newByteChannel(zipfs.getPath(&quot;Entry-01&quot;)
 423                      , Set.of(CREATE, WRITE))) {
 424             sbc.write(ByteBuffer.wrap(FIFTH_MAJOR.getBytes(UTF_8)));
 425             assertEquals(sbc.size(), FIFTH_MAJOR.length());
 426         }
 427         Files.deleteIfExists(zipFile);
 428     }
 429 
 430     /**
 431      * Validate SeekableByteChannel::isOpen returns true when the file
 432      * is open and false after SeekableByteChannel::close is called
 433      *
 434      * @param env         Zip FS properties to use when creating the Zip file
 435      * @param compression The compression used when writing the entries
 436      * @throws Exception If an error occurs
 437      */
 438     @Test(dataProvider = &quot;zipfsMap&quot;)
 439     public void sbcOpenClosedTest(final Map&lt;String, String&gt; env,
 440                                   final int compression) throws Exception {
 441         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 442         Files.deleteIfExists(zipFile);
 443         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 444         zip(zipFile, env, e0);
 445         // Validate SeekableByteChannel::isOpen
 446         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 447              SeekableByteChannel sbc = Files.newByteChannel(zipfs.getPath(e0.name),
 448                      Set.of(READ))) {
 449             assertTrue(sbc.isOpen());
 450             sbc.close();
 451             assertFalse(sbc.isOpen());
 452         }
 453         Files.deleteIfExists(zipFile);
 454     }
 455 
 456     /**
 457      * Validate SeekableByteChannel::position returns the expected position
 458      * Note: due to bug JDK-8241882, the position will not exceed the file size
 459      * in the test
 460      *
 461      * @param env         Zip FS properties to use when creating the Zip file
 462      * @param compression The compression used when writing the entries
 463      * @throws Exception If an error occurs
 464      */
 465     @Test(dataProvider = &quot;zipfsMap&quot;)
 466     public void sbcPositionTest(final Map&lt;String, String&gt; env,
 467                                 final int compression) throws Exception {
 468         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 469         Files.deleteIfExists(zipFile);
 470         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 471         zip(zipFile, env, e0);
 472         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 473              SeekableByteChannel sbc =
 474                      Files.newByteChannel(zipfs.getPath(e0.name), Set.of(READ))) {
 475             int fSize = (int) sbc.size();
 476             // Specify the seed to use
 477             int seed = fSize + 1;
 478             ByteBuffer bb = ByteBuffer.allocate(BYTEBUFFER_SIZE);
 479             sbc.read(bb);
 480             for (var i = 0; i &lt; fSize; i++) {
 481                 long pos = RANDOM.nextInt(seed);
 482                 sbc.position(pos);
 483                 assertEquals(sbc.position(), pos);
 484             }
 485         }
 486         Files.deleteIfExists(zipFile);
 487     }
 488 
 489     // ### FileChannel Tests ###
 490 
 491     /**
 492      * Validate a FileChannel can be used to copy an OS file to
 493      * a Zip file
 494      *
 495      * @param env         Zip FS properties to use when creating the Zip file
 496      * @param compression The compression used when writing the entries
 497      * @throws Exception If an error occurs
 498      */
 499     @Test(dataProvider = &quot;zipfsMap&quot;)
 500     public void fcFromOSToZipTest(final Map&lt;String, String&gt; env,
 501                                   final int compression) throws Exception {
 502         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 503         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
 504         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 505         Files.deleteIfExists(osFile);
 506         Files.deleteIfExists(zipFile);
 507         Files.writeString(osFile, THE_SLAMS);
 508         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 509             fcCopy(osFile, zipfs.getPath(e0.name));
 510         }
 511         // Verify the entry was copied
 512         verify(zipFile, e0);
 513         Files.deleteIfExists(osFile);
 514         Files.deleteIfExists(zipFile);
 515     }
 516 
 517     /**
 518      * Validate a FileChannel can be used to copy an entry from
 519      * a Zip file to an OS file
 520      *
 521      * @param env         Zip FS properties to use when creating the Zip file
 522      * @param compression The compression used when writing the entries
 523      * @throws Exception If an error occurs
 524      */
 525     @Test(dataProvider = &quot;zipfsMap&quot;)
 526     public void fcFromZipToOSTest(final Map&lt;String, String&gt; env,
 527                                   final int compression) throws Exception {
 528         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 529         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
 530         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 531         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
 532         Files.deleteIfExists(zipFile);
 533         Files.deleteIfExists(osFile);
 534         zip(zipFile, env, e0, e1);
 535         verify(zipFile, e0, e1);
 536         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 537             fcCopy(zipfs.getPath(e0.name), osFile);
 538         }
 539         // Check to see if the file exists and the bytes match
 540         assertTrue(Files.isRegularFile(osFile));
 541         assertEquals(Files.readAllBytes(osFile), e0.bytes);
 542         Files.deleteIfExists(zipFile);
 543         Files.deleteIfExists(osFile);
 544     }
 545 
 546     /**
 547      * Validate a FileChannel can be used to copy an entry from
 548      * a Zip file to another Zip file
 549      *
 550      * @param env         Zip FS properties to use when creating the Zip file
 551      * @param compression The compression used when writing the entries
 552      * @throws Exception If an error occurs
 553      */
 554     @Test(dataProvider = &quot;zipfsMap&quot;)
 555     public void fcFromZipToZipTest(final Map&lt;String, String&gt; env,
 556                                    final int compression) throws Exception {
 557         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 558         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
 559         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 560         Path zipFile2 = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 561         Files.deleteIfExists(zipFile);
 562         Files.deleteIfExists(zipFile2);
 563         zip(zipFile, env, e0, e1);
 564         verify(zipFile, e0, e1);
 565         // Copy entries from one Zip file to another using FileChannel
 566         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 567              FileSystem zipfs2 = FileSystems.newFileSystem(zipFile2, env)) {
 568             fcCopy(zipfs.getPath(e0.name), zipfs2.getPath(e0.name));
 569             fcCopy(zipfs.getPath(e1.name), zipfs2.getPath(e1.name));
 570         }
 571         // Check to see if the entries match
 572         verify(zipFile2, e0, e1);
 573         Files.deleteIfExists(zipFile);
 574         Files.deleteIfExists(zipFile2);
 575     }
 576 
 577     /**
 578      * Validate a FileChannel can be used to copy an entry within
 579      * a Zip file with the correct compression
 580      *
 581      * @param env                 Zip FS properties to use when creating the Zip file
 582      * @param compression         The compression used when writing the initial entries
 583      * @param expectedCompression The compression to be used when copying the entry
 584      * @throws Exception If an error occurs
 585      */
 586     @Test(dataProvider = &quot;copyMoveMap&quot;)
 587     public void fcChangeCompressionTest(final Map&lt;String, String&gt; env,
 588                                         final int compression,
 589                                         final int expectedCompression) throws Exception {
 590         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 591         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
 592         Entry e00 = Entry.of(&quot;Entry-00&quot;, expectedCompression, THE_SLAMS);
 593         // Compression method to use when copying the entry
 594         String targetCompression = expectedCompression == ZipEntry.STORED ? &quot;true&quot; : &quot;false&quot;;
 595         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 596         Path zipFile2 = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 597         Files.deleteIfExists(zipFile);
 598         Files.deleteIfExists(zipFile2);
 599         // Create the initial Zip files
 600         zip(zipFile, env, e0, e1);
 601         zip(zipFile2, env, e0, e1);
 602         verify(zipFile, e0, e1);
 603         // Copy the entry from one Zip file to another
 604         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 605              FileSystem zipfs2 = FileSystems.newFileSystem(zipFile2,
 606                      Map.of(&quot;noCompression&quot;, targetCompression))) {
 607             fcCopy(zipfs.getPath(e0.name), zipfs2.getPath(e00.name));
 608         }
 609         // Check to see if the entries match
 610         verify(zipFile2, e0, e1, e00);
 611         Files.deleteIfExists(zipFile);
 612         Files.deleteIfExists(zipFile2);
 613     }
 614 
 615     /**
 616      * Validate a FileChannel can be used to append an entry
 617      * in a Zip file
 618      *
 619      * @param env         Zip FS properties to use when creating the Zip file
 620      * @param compression The compression used when writing the entries
 621      * @throws Exception If an error occurs
 622      */
 623     @Test(dataProvider = &quot;zipfsMap&quot;)
 624     public void fcAppendTest(final Map&lt;String, String&gt; env,
 625                              final int compression) throws Exception {
 626         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 627         Files.deleteIfExists(zipFile);
 628         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 629         zip(zipFile, env, e0);
 630         // Update the Zip entry by appending to it
 631         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 632              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 633                      Set.of(WRITE, APPEND))) {
 634             ByteBuffer bb = ByteBuffer.wrap(FIFTH_MAJOR.getBytes());
 635             fc.write(bb);
 636         }
 637         // Check to see if the entries match
 638         verify(zipFile, e0.content(THE_SLAMS + FIFTH_MAJOR));
 639         Files.deleteIfExists(zipFile);
 640     }
 641 
 642     /**
 643      * Validate FileChannel::truncate will truncate the file at the specified
 644      * position
 645      *
 646      * @param env         Zip FS properties to use when creating the Zip file
 647      * @param compression The compression used when writing the entries
 648      * @throws Exception If an error occurs
 649      */
 650     @Test(dataProvider = &quot;zipfsMap&quot;)
 651     public void fcTruncateTest(final Map&lt;String, String&gt; env,
 652                                final int compression) throws Exception {
 653         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 654         Files.deleteIfExists(zipFile);
 655         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 656         zip(zipFile, env, e0);
 657         // Truncate the Zip entry
 658         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 659              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 660                      Set.of(WRITE))) {
 661             fc.truncate(GRAND_SLAMS_HEADER.length());
 662         }
 663         // Check to see if the entries match
 664         verify(zipFile, e0.content(GRAND_SLAMS_HEADER));
 665         Files.deleteIfExists(zipFile);
 666     }
 667 
 668     /**
 669      * Validate FileChannel::map throws an UnsupportedOperationException
 670      *
 671      * @param env         Zip FS properties to use when creating the Zip file
 672      * @param compression The compression used when writing the entries
 673      * @throws Exception If an error occurs
 674      */
 675     @Test(dataProvider = &quot;zipfsMap&quot;)
 676     public void fcMapTest(final Map&lt;String, String&gt; env,
 677                           final int compression) throws Exception {
 678         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 679         Files.deleteIfExists(zipFile);
 680         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 681         zip(zipFile, env, e0);
 682         // Check UnsupportedOperationException is thrown
 683         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 684              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 685                      Set.of(READ))) {
 686             assertThrows(UnsupportedOperationException.class, () -&gt;
 687                     fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size()));
 688             assertThrows(UnsupportedOperationException.class, () -&gt;
 689                     fc.map(FileChannel.MapMode.READ_WRITE, 0, fc.size()));
 690             assertThrows(UnsupportedOperationException.class, () -&gt;
 691                     fc.map(FileChannel.MapMode.PRIVATE, 0, fc.size()));
 692         }
 693         Files.deleteIfExists(zipFile);
 694     }
 695 
 696     /**
 697      * Validate FileChannel::isOpen returns true when the file is open
 698      * and false after FileChannel::close is called
 699      *
 700      * @param env         Zip FS properties to use when creating the Zip file
 701      * @param compression The compression used when writing the entries
 702      * @throws Exception If an error occurs
 703      */
 704     @Test(dataProvider = &quot;zipfsMap&quot;)
 705     public void fcOpenClosedTest(final Map&lt;String, String&gt; env,
 706                                  final int compression) throws Exception {
 707         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 708         Files.deleteIfExists(zipFile);
 709         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 710         zip(zipFile, env, e0);
 711         // Validate FileChannel::isOpen
 712         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 713              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 714                      Set.of(READ))) {
 715             assertTrue(fc.isOpen());
 716             fc.close();
 717             assertFalse(fc.isOpen());
 718         }
 719         Files.deleteIfExists(zipFile);
 720     }
 721 
 722     /**
 723      * Validate FileAlreadyExistsException is thrown when
 724      * FileChannel::open is invoked with the CREATE_NEW option and the Zip
 725      * entry already exists
 726      *
 727      * @param env         Zip FS properties to use when creating the Zip file
 728      * @param compression The compression used when writing the entries
 729      * @throws Exception If an error occurs
 730      */
 731     @Test(dataProvider = &quot;zipfsMap&quot;)
 732     public void fcFAETest(final Map&lt;String, String&gt; env,
 733                           final int compression) throws Exception {
 734         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 735         Files.deleteIfExists(zipFile);
 736         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 737         zip(zipFile, env, e0);
 738         // Check FileAlreadyExistsException is thrown
 739         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 740             assertThrows(FileAlreadyExistsException.class, () -&gt;
 741                     FileChannel.open(zipfs.getPath(e0.name), Set.of(CREATE_NEW, WRITE)));
 742         }
 743         Files.deleteIfExists(zipFile);
 744     }
 745 
 746 
 747     /**
 748      * Validate when FileChannel::close is called more than once, that
 749      * no error occurs
 750      *
 751      * @param env         Zip FS properties to use when creating the Zip file
 752      * @param compression The compression used when writing the entries
 753      * @throws Exception If an error occurs
 754      */
 755     @Test(dataProvider = &quot;zipfsMap&quot;)
 756     public void fcCloseTest(final Map&lt;String, String&gt; env,
 757                              final int compression) throws Exception {
 758         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 759         Files.deleteIfExists(zipFile);
 760         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 761         zip(zipFile, env, e0);
 762         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 763             FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 764                     Set.of(READ, WRITE));
 765             fc.close();
 766             fc.close();
 767             assertFalse(fc.isOpen());
 768         }
 769         Files.deleteIfExists(zipFile);
 770     }
 771 
 772     /**
 773      * Validate ClosedChannelException is thrown when
 774      * FileChannel::close is invoked and another FileChannel method is invoked
 775      *
 776      * @param env         Zip FS properties to use when creating the Zip file
 777      * @param compression The compression used when writing the entries
 778      * @throws Exception If an error occurs
 779      */
 780     @Test(dataProvider = &quot;zipfsMap&quot;)
 781     public void fcCCETest(final Map&lt;String, String&gt; env,
 782                           final int compression) throws Exception {
 783         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 784         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
 785         Files.deleteIfExists(osFile);
 786         Files.deleteIfExists(zipFile);
 787         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 788         zip(zipFile, env, e0);
 789         // Create the ByteBuffer array to be used
 790         ByteBuffer[] bb = {
 791                 ByteBuffer.wrap(&quot;First Serve&quot;.getBytes(UTF_8)),
 792                 ByteBuffer.wrap(&quot;Fault&quot;.getBytes(UTF_8)),
 793                 ByteBuffer.wrap(&quot;Double Fault&quot;.getBytes(UTF_8))
 794         };
 795         // Check ClosedChannelException is thrown if the channel is closed
 796         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 797              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name), Set.of(READ, WRITE))) {
 798             fc.close();
 799             assertThrows(ClosedChannelException.class, () -&gt; fc.force(false));
 800             assertThrows(ClosedChannelException.class, fc::lock);
 801             assertThrows(ClosedChannelException.class, () -&gt; fc.lock(0, 0, false));
 802             assertThrows(ClosedChannelException.class, fc::position);
 803             assertThrows(ClosedChannelException.class, () -&gt; fc.position(1));
 804             assertThrows(ClosedChannelException.class, () -&gt; fc.read(bb));
 805             assertThrows(ClosedChannelException.class, () -&gt; fc.read(bb, 1, 2));
 806             assertThrows(ClosedChannelException.class, () -&gt; fc.read(bb[0]));
 807             assertThrows(ClosedChannelException.class, () -&gt; fc.read(bb[0], 1));
 808             assertThrows(ClosedChannelException.class, fc::size);
 809             assertThrows(ClosedChannelException.class, fc::tryLock);
 810             assertThrows(ClosedChannelException.class, () -&gt;
 811                     fc.tryLock(0, 1, false));
 812             assertThrows(ClosedChannelException.class, () -&gt; fc.truncate(2));
 813             assertThrows(ClosedChannelException.class, () -&gt; fc.write(bb));
 814             assertThrows(ClosedChannelException.class, () -&gt; fc.write(bb[0]));
 815             // Note does not check closed 1st when file not opened with &quot;WRITE&quot;
 816             assertThrows(ClosedChannelException.class, () -&gt; fc.write(bb[0], 1));
 817             assertThrows(ClosedChannelException.class, () -&gt; fc.write(bb, 1, 2));
 818             try (
 819                     FileChannel out = FileChannel.open(osFile, Set.of(CREATE_NEW, WRITE))) {
 820                 assertThrows(ClosedChannelException.class, () -&gt;
 821                         fc.transferTo(0, fc.size(), out));
 822                 // Check when &#39;fc&#39; is closed
 823                 assertThrows(ClosedChannelException.class, () -&gt;
 824                         out.transferFrom(fc, 0, fc.size()));
 825                 fc.close();
 826                 // Check when &#39;out&#39; is closed
 827                 assertThrows(ClosedChannelException.class, () -&gt;
 828                         out.transferFrom(fc, 0, fc.size()));
 829             }
 830         }
 831         Files.deleteIfExists(zipFile);
 832         Files.deleteIfExists(osFile);
 833     }
 834 
 835     /**
 836      * Validate FileChannel::read can read an entry from a Zip file
 837      *
 838      * @param env         Zip FS properties to use when creating the Zip file
 839      * @param compression The compression used when writing the entries
 840      * @throws Exception If an error occurs
 841      */
 842     @Test(dataProvider = &quot;zipfsMap&quot;)
 843     public void fcReadTest(final Map&lt;String, String&gt; env,
 844                            final int compression) throws Exception {
 845         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 846         Files.deleteIfExists(zipFile);
 847         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 848         zip(zipFile, env, e0);
 849         // Read an entry
 850         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 851              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 852                      Set.of(READ))) {
 853             ByteBuffer buf = ByteBuffer.allocate((int) fc.size());
 854             int bytesRead = fc.read(buf);
 855             // Check to see if the expected bytes were read
 856             byte[] result = Arrays.copyOfRange(buf.array(), 0, bytesRead);
 857             assertEquals(THE_SLAMS.getBytes(UTF_8), result);
 858         }
 859         Files.deleteIfExists(zipFile);
 860     }
 861 
 862     /**
 863      * Validate FileChannel::read can read an entry from a Zip file
 864      *  when specifying a starting position
 865      *
 866      * @param env         Zip FS properties to use when creating the Zip file
 867      * @param compression The compression used when writing the entries
 868      * @throws Exception If an error occurs
 869      */
 870     @Test(dataProvider = &quot;zipfsMap&quot;)
 871     public void fcReadPosTest(final Map&lt;String, String&gt; env,
 872                               final int compression) throws Exception {
 873         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 874         Files.deleteIfExists(zipFile);
 875         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 876         zip(zipFile, env, e0);
 877         // Read an entry specifying a starting position within the file
 878         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 879              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 880                      Set.of(READ))) {
 881             ByteBuffer buf = ByteBuffer.allocate((int) fc.size());
 882             int bytesRead = fc.read(buf, GRAND_SLAMS_HEADER.length());
 883             // Check to see if the expected bytes were read
 884             byte[] result = Arrays.copyOfRange(buf.array(), 0, bytesRead);
 885             assertEquals(GRAND_SLAMS.getBytes(UTF_8), result);
 886         }
 887         Files.deleteIfExists(zipFile);
 888     }
 889 
 890     /**
 891      * Validate FileChannel::read  can be used with a ByteBuffer array to
 892      * read an entry from a Zip file
 893      *
 894      * @param env         Zip FS properties to use when creating the Zip file
 895      * @param compression The compression used when writing the entries
 896      * @throws Exception If an error occurs
 897      */
 898     @Test(dataProvider = &quot;zipfsMap&quot;)
 899     public void fcReadArrayTest(final Map&lt;String, String&gt; env,
 900                                 final int compression) throws Exception {
 901         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 902         Files.deleteIfExists(zipFile);
 903         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 904         zip(zipFile, env, e0);
 905         // Create the ByteBuffer array that will be updated
 906         ByteBuffer[] bb = {
 907                 ByteBuffer.allocate(GRAND_SLAMS_HEADER.length()),
 908                 ByteBuffer.allocate(AUSTRALIAN_OPEN.length()),
 909                 ByteBuffer.allocate(FRENCH_OPEN.length()),
 910                 ByteBuffer.allocate(WIMBLEDON.length()),
 911                 ByteBuffer.allocate(US_OPEN.length()),
 912         };
 913         // Read an entry with a ByteBuffer array
 914         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 915              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 916                      Set.of(READ))) {
 917             fc.read(bb);
 918             // Convert the ByteBuffer array into a single byte array
 919             ByteArrayOutputStream bos = new ByteArrayOutputStream();
 920             for (ByteBuffer b : bb) {
 921                 bos.write(b.array());
 922             }
 923             // Check to see if the returned byte array is what is expected
 924             assertEquals(e0.bytes, bos.toByteArray());
 925         }
 926         Files.deleteIfExists(zipFile);
 927     }
 928 
 929     /**
 930      * Validate FileChannel::read can be used to update specific offset(s)
 931      * of a ByteBuffer array when reading a Zip entry
 932      *
 933      * @param env         Zip FS properties to use when creating the Zip file
 934      * @param compression The compression used when writing the entries
 935      * @throws Exception If an error occurs
 936      */
 937     @Test(dataProvider = &quot;zipfsMap&quot;)
 938     public void fcReadArrayWithOffsetTest(final Map&lt;String, String&gt; env,
 939                                           final int compression) throws Exception {
 940         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 941         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 942         Files.deleteIfExists(zipFile);
 943         zip(zipFile, env, e0);
 944         // Initial values that will be replaced by the AUSTRALIAN_OPEN and FRENCH_OPEN
 945         // values via FileChannel::read
 946         String newValue = &quot;Homeward Bound!&quot; + System.lineSeparator();
 947         String newValue2 = &quot;Sybase Open&quot; + System.lineSeparator();
 948         // Create the ByteBuffer array that will be updated
 949         ByteBuffer[] bb = {
 950                 ByteBuffer.wrap((newValue)
 951                         .getBytes(UTF_8)),
 952                 ByteBuffer.wrap((newValue2)
 953                         .getBytes(UTF_8)),
 954                 ByteBuffer.wrap((WIMBLEDON)
 955                         .getBytes(UTF_8)),
 956                 ByteBuffer.wrap((US_OPEN)
 957                         .getBytes(UTF_8))
 958         };
 959         // Read the Zip entry replacing the data in offset 0 and 1
 960         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 961              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 962                      Set.of(READ))) {
 963             fc.position(GRAND_SLAMS_HEADER.length());
 964             fc.read(bb, 0, 2);
 965         }
 966         // Convert the ByteBuffer array into a single byte array
 967         ByteArrayOutputStream bos = new ByteArrayOutputStream();
 968         for (ByteBuffer b : bb) {
 969             bos.write(b.array());
 970         }
 971         // Check to see if the returned byte array is what is expected
 972         assertEquals(GRAND_SLAMS.getBytes(UTF_8), bos.toByteArray());
 973         Files.deleteIfExists(zipFile);
 974     }
 975 
 976     /**
 977      * Validate FileChannel::transferTo can be used to copy an OS file to
 978      * a Zip file
 979      *
 980      * @param env         Zip FS properties to use when creating the Zip file
 981      * @param compression The compression used when writing the entries
 982      * @throws Exception If an error occurs
 983      */
 984     @Test(dataProvider = &quot;zipfsMap&quot;)
 985     public void fcTransferToZipTest(final Map&lt;String, String&gt; env,
 986                                     final int compression) throws Exception {
 987         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, THE_SLAMS);
 988         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
 989         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 990         Files.deleteIfExists(osFile);
 991         Files.deleteIfExists(zipFile);
 992         Files.writeString(osFile, THE_SLAMS);
 993         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 994             fcTransferTo(osFile, zipfs.getPath(e00.name));
 995         }
 996         // Verify the entry was copied
 997         verify(zipFile, e00);
 998         assertEquals(Files.readAllBytes(osFile), e00.bytes);
 999         Files.deleteIfExists(osFile);
1000         Files.deleteIfExists(zipFile);
1001     }
1002 
1003     /**
1004      * Validate FileChannel::transferTo can be used to copy a Zip entry to
1005      * an OS File
1006      *
1007      * @param env         Zip FS properties to use when creating the Zip file
1008      * @param compression The compression used when writing the entries
1009      * @throws Exception If an error occurs
1010      */
1011     @Test(dataProvider = &quot;zipfsMap&quot;)
1012     public void fcTransferToOsTest(final Map&lt;String, String&gt; env,
1013                                    final int compression) throws Exception {
1014         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, THE_SLAMS);
1015         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
1016         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1017         Files.deleteIfExists(osFile);
1018         Files.deleteIfExists(zipFile);
1019         zip(zipFile, env, e00);
1020         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
1021             fcTransferTo(zipfs.getPath(e00.name), osFile);
1022         }
1023         // Verify the entry was copied
1024         assertEquals(Files.readAllBytes(osFile), e00.bytes);
1025         Files.deleteIfExists(osFile);
1026         Files.deleteIfExists(zipFile);
1027     }
1028 
1029     /**
1030      * Validate FileChannel::transferTo can be used to copy a Zip entry to
1031      * another Zip file
1032      *
1033      * @param env         Zip FS properties to use when creating the Zip file
1034      * @param compression The compression used when writing the entries
1035      * @throws Exception If an error occurs
1036      */
1037     @Test(dataProvider = &quot;zipfsMap&quot;)
1038     public void fcTransferToZipToZipTest(final Map&lt;String, String&gt; env,
1039                                          final int compression) throws Exception {
1040         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1041         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
1042         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1043         Path zipFile2 = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1044         Files.deleteIfExists(zipFile);
1045         Files.deleteIfExists(zipFile2);
1046         zip(zipFile, env, e0, e1);
1047         verify(zipFile, e0, e1);
1048         // Copy entries from one Zip file to another using FileChannel
1049         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1050              FileSystem zipfs2 = FileSystems.newFileSystem(zipFile2, env)) {
1051             fcTransferTo(zipfs.getPath(e0.name), zipfs2.getPath(e0.name));
1052             fcTransferTo(zipfs.getPath(e1.name), zipfs2.getPath(e1.name));
1053         }
1054         // Check to see if the entries match
1055         verify(zipFile2, e0, e1);
1056         Files.deleteIfExists(zipFile);
1057         Files.deleteIfExists(zipFile2);
1058     }
1059 
1060     /**
1061      * Validate FileChannel::transferFrom can be used to copy an OS File to
1062      * a Zip entry
1063      *
1064      * @param env         Zip FS properties to use when creating the Zip file
1065      * @param compression The compression used when writing the entries
1066      * @throws Exception If an error occurs
1067      */
1068     @Test(dataProvider = &quot;zipfsMap&quot;)
1069     public void fcTransferFromOsTest(final Map&lt;String, String&gt; env,
1070                                      final int compression) throws Exception {
1071         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, THE_SLAMS);
1072         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
1073         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1074         Files.deleteIfExists(osFile);
1075         Files.deleteIfExists(zipFile);
1076         Files.writeString(osFile, THE_SLAMS);
1077         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
1078             fcTransferFrom(osFile, zipfs.getPath(e00.name));
1079         }
1080         // Verify the entry was copied
1081         zip(zipFile, env, e00);
1082         assertEquals(Files.readAllBytes(osFile), e00.bytes);
1083         Files.deleteIfExists(osFile);
1084         Files.deleteIfExists(zipFile);
1085     }
1086 
1087     /**
1088      * Validate FileChannel::transferFrom can be used to copy a Zip entry to
1089      * an OS File
1090      *
1091      * @param env         Zip FS properties to use when creating the Zip file
1092      * @param compression The compression used when writing the entries
1093      * @throws Exception If an error occurs
1094      */
1095     @Test(dataProvider = &quot;zipfsMap&quot;)
1096     public void fcTransferFromZipTest(final Map&lt;String, String&gt; env,
1097                                       final int compression) throws Exception {
1098         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, THE_SLAMS);
1099         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
1100         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1101         Files.deleteIfExists(osFile);
1102         Files.deleteIfExists(zipFile);
1103         zip(zipFile, env, e00);
1104         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
1105             fcTransferFrom(zipfs.getPath(e00.name), osFile);
1106         }
1107         // Verify the bytes match
1108         assertEquals(Files.readAllBytes(osFile), e00.bytes);
1109         Files.deleteIfExists(osFile);
1110         Files.deleteIfExists(zipFile);
1111     }
1112 
1113     /**
1114      * Validate FileChannel::transferFrom can be used to copy a Zip entry
1115      * to another Zip file
1116      *
1117      * @param env         Zip FS properties to use when creating the Zip file
1118      * @param compression The compression used when writing the entries
1119      * @throws Exception If an error occurs
1120      */
1121     @Test(dataProvider = &quot;zipfsMap&quot;)
1122     public void fcTransferFromZipToZipTest(final Map&lt;String, String&gt; env,
1123                                            final int compression) throws Exception {
1124         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1125         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
1126         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1127         Path zipFile2 = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1128         Files.deleteIfExists(zipFile);
1129         Files.deleteIfExists(zipFile2);
1130         zip(zipFile, env, e0, e1);
1131         verify(zipFile, e0, e1);
1132         // Copy entries from one Zip file to another using FileChannel
1133         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1134              FileSystem zipfs2 = FileSystems.newFileSystem(zipFile2, env)) {
1135             fcTransferFrom(zipfs.getPath(e0.name), zipfs2.getPath(e0.name));
1136             fcTransferFrom(zipfs.getPath(e1.name), zipfs2.getPath(e1.name));
1137         }
1138         // Check to see if the entries match
1139         verify(zipFile2, e0, e1);
1140         Files.deleteIfExists(zipFile);
1141         Files.deleteIfExists(zipFile2);
1142     }
1143 
1144     /**
1145      * Validate FileChannel::write can be used to create a Zip entry
1146      *
1147      * @param env         Zip FS properties to use when creating the Zip file
1148      * @param compression The compression used when writing the entries
1149      * @throws Exception If an error occurs
1150      */
1151     @Test(dataProvider = &quot;zipfsMap&quot;)
1152     public void fcWriteTest(final Map&lt;String, String&gt; env,
1153                             final int compression) throws Exception {
1154         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1155         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1156         Files.deleteIfExists(zipFile);
1157         // Create the Zip entry
1158         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1159              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
1160                      Set.of(CREATE, WRITE))) {
1161             ByteBuffer bb = ByteBuffer.wrap(THE_SLAMS.getBytes(UTF_8));
1162             fc.write(bb);
1163         }
1164         // Verify the entry was updated
1165         verify(zipFile, e0);
1166         Files.deleteIfExists(zipFile);
1167     }
1168 
1169     /**
1170      * Validate FileChannel::write can be used to update a Zip entry
1171      * when specifying a starting position
1172      *
1173      * @param env         Zip FS properties to use when creating the Zip file
1174      * @param compression The compression used when writing the entries
1175      * @throws Exception If an error occurs
1176      */
1177     @Test(dataProvider = &quot;zipfsMap&quot;)
1178     public void fcWritePosTest(final Map&lt;String, String&gt; env,
1179                                final int compression) throws Exception {
1180         // Use this value to replace the value specified for AUSTRALIAN_OPEN
1181         String NewValue = &quot;Homeward Bound!&quot; + System.lineSeparator();
1182         // Expected results after updating the file
1183         String updatedFile = GRAND_SLAMS_HEADER
1184                 + NewValue
1185                 + FRENCH_OPEN
1186                 + WIMBLEDON
1187                 + US_OPEN;
1188         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1189         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1190         Files.deleteIfExists(zipFile);
1191         zip(zipFile, env, e0);
1192         // Update the Zip entry at the specified position
1193         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1194              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
1195                      Set.of(READ, WRITE))) {
1196             ByteBuffer bb = ByteBuffer.wrap(NewValue.getBytes(UTF_8));
1197             fc.write(bb, GRAND_SLAMS_HEADER.length());
1198         }
1199         // Verify the entry was updated
1200         verify(zipFile, e0.content(updatedFile));
1201         Files.deleteIfExists(zipFile);
1202     }
1203 
1204     /**
1205      * Validate FileChannel::write using a ByteBuffer array
1206      * can be used to create a Zip entry
1207      *
1208      * @param env         Zip FS properties to use when creating the Zip file
1209      * @param compression The compression used when writing the entries
1210      * @throws Exception If an error occurs
1211      */
1212     @Test(dataProvider = &quot;zipfsMap&quot;)
1213     public void fcWriteArrayTest(final Map&lt;String, String&gt; env,
1214                                  final int compression) throws Exception {
1215         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1216         Files.deleteIfExists(zipFile);
1217         // Entry added to the Zip file
1218         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, GRAND_SLAMS);
1219         // Create the ByteBuffer array that will be used to create the Zip entry
1220         ByteBuffer[] bb = {
1221                 ByteBuffer.wrap(AUSTRALIAN_OPEN.getBytes(UTF_8)),
1222                 ByteBuffer.wrap(FRENCH_OPEN.getBytes(UTF_8)),
1223                 ByteBuffer.wrap(WIMBLEDON.getBytes(UTF_8)),
1224                 ByteBuffer.wrap(US_OPEN.getBytes(UTF_8))
1225         };
1226         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1227              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
1228                      Set.of(CREATE, WRITE))) {
1229             fc.write(bb);
1230             assertEquals(fc.size(), GRAND_SLAMS.length());
1231         }
1232         // Verify the entry was created
1233         verify(zipFile, e0);
1234         Files.deleteIfExists(zipFile);
1235     }
1236 
1237     /**
1238      * Validate FileChannel::write specifying a ByteBuffer array
1239      *  with an offset can be used to create a Zip entry
1240      *
1241      * @param env         Zip FS properties to use when creating the Zip file
1242      * @param compression The compression used when writing the entries
1243      * @throws Exception If an error occurs
1244      */
1245     @Test(dataProvider = &quot;zipfsMap&quot;)
1246     public void fcWriteArrayWithOffsetTest(final Map&lt;String, String&gt; env,
1247                                            final int compression) throws Exception {
1248 
1249         // Use this value to replace the value specified for AUSTRALIAN_OPEN
1250         String newValue = &quot;Homeward Bound!&quot; + System.lineSeparator();
1251         // Use this value to replace the value specified for FRENCH_OPEN
1252         String newValue2 = &quot;Sybase Open&quot; + System.lineSeparator();
1253         // Expected results after updating the file
1254         String updatedFile = GRAND_SLAMS_HEADER
1255                 + newValue
1256                 + newValue2
1257                 + WIMBLEDON
1258                 + US_OPEN;
1259         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1260         Files.deleteIfExists(zipFile);
1261         // Initial Zip entry
1262         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1263         zip(zipFile, env, e0);
1264         // Create the ByteBuffer array that will be used to update the Zip entry
1265         ByteBuffer[] bb = {
1266                 ByteBuffer.wrap(newValue.getBytes(UTF_8)),
1267                 ByteBuffer.wrap(newValue2.getBytes(UTF_8)),
1268                 ByteBuffer.wrap(&quot;!!!Should not Write!!!!&quot;.getBytes(UTF_8))
1269         };
1270         // Move to the file position and then write the updates to the file
1271         // specifying the ByteBuffer offset &amp; length
1272         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1273              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
1274                      Set.of(CREATE, WRITE))) {
1275             // Skip past the header
1276             fc.position(GRAND_SLAMS_HEADER.length());
1277             // Replace the original values
1278             fc.write(bb, 0, 2);
1279             assertEquals(fc.size(), THE_SLAMS.length());
1280         }
1281         // Verify the entry was updated
1282         verify(zipFile, e0.content(updatedFile));
1283         Files.deleteIfExists(zipFile);
1284     }
1285 
1286     /**
1287      * Validate FileChannel::force can be used when writing a Zip entry
1288      *
1289      * @param env         Zip FS properties to use when creating the Zip file
1290      * @param compression The compression used when writing the entries
1291      * @throws Exception If an error occurs
1292      */
1293     @Test(dataProvider = &quot;zipfsMap&quot;)
1294     public void fcForceWriteTest(final Map&lt;String, String&gt; env,
1295                             final int compression) throws Exception {
1296         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1297         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1298         Files.deleteIfExists(zipFile);
1299         // Check that no errors occur when using FileChannel::force
1300         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1301              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
1302                      Set.of(CREATE, WRITE))) {
1303             fc.force(false);
1304             fc.write(ByteBuffer.wrap(GRAND_SLAMS_HEADER.getBytes(UTF_8)));
1305             fc.force(true);
1306             fc.write(ByteBuffer.wrap(GRAND_SLAMS.getBytes(UTF_8)));
1307         }
1308         // Verify the entry was updated
1309         verify(zipFile, e0);
1310         Files.deleteIfExists(zipFile);
1311     }
1312 
1313     /**
1314      * Validate FileChannel::position returns the expected position
1315      *
1316      * @param env         Zip FS properties to use when creating the Zip file
1317      * @param compression The compression used when writing the entries
1318      * @throws Exception If an error occurs
1319      */
1320     @Test(dataProvider = &quot;zipfsMap&quot;)
1321     public void fcPositionTest(final Map&lt;String, String&gt; env,
1322                                 final int compression) throws Exception {
1323         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1324         Files.deleteIfExists(zipFile);
1325         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1326         zip(zipFile, env, e0);
1327         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1328              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name), Set.of(READ))) {
1329             int fSize = (int) fc.size();
1330             // Specify the seed to use
1331             int seed = fSize + 10;
1332             ByteBuffer bb = ByteBuffer.allocate(BYTEBUFFER_SIZE);
1333             fc.read(bb);
1334             for (var i = 0; i &lt; fSize; i++) {
1335                 long pos = RANDOM.nextInt(seed);
1336                 fc.position(pos);
1337                 assertEquals(fc.position(), pos);
1338             }
1339         }
1340         Files.deleteIfExists(zipFile);
1341     }
1342 
1343     /**
1344      * Validate FileChannel::size can be used to obtain the size of a Zip entry
1345      *
1346      * @param env         Zip FS properties to use when creating the Zip file
1347      * @param compression The compression used when writing the entries
1348      * @throws Exception If an error occurs
1349      */
1350     @Test(dataProvider = &quot;zipfsMap&quot;)
1351     public void fcSizeTest(final Map&lt;String, String&gt; env,
1352                            final int compression) throws Exception {
1353         Path osFile = Path.of(&quot;GrandSlams.txt&quot;);
1354         Files.deleteIfExists(osFile);
1355         Files.writeString(osFile, THE_SLAMS);
1356         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1357         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1358         Files.deleteIfExists(zipFile);
1359         zip(zipFile, env, e0);
1360         // Validate the file sizes match
1361         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1362              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name))) {
1363             assertEquals(fc.size(), THE_SLAMS.length());
1364         }
1365         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1366              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name), Set.of(READ))) {
1367             assertEquals(fc.size(), THE_SLAMS.length());
1368         }
1369         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1370              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name), Set.of(READ, WRITE))) {
1371             assertEquals(fc.size(), THE_SLAMS.length());
1372         }
1373         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1374              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name), Set.of(WRITE))) {
1375             assertEquals(fc.size(), THE_SLAMS.length());
1376         }
1377         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1378              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name), Set.of(APPEND))) {
1379             assertEquals(fc.size(), THE_SLAMS.length());
1380         }
1381         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1382              FileChannel fc = FileChannel.open(zipfs.getPath(&quot;Entry-01&quot;),
1383                      Set.of(CREATE, WRITE))) {
1384             fc.write(ByteBuffer.wrap(FIFTH_MAJOR.getBytes(UTF_8)));
1385             assertEquals(fc.size(), FIFTH_MAJOR.length());
1386         }
1387         Files.deleteIfExists(zipFile);
1388         Files.deleteIfExists(osFile);
1389     }
1390 
1391     /**
1392      * Validate FileChannel::lock returns a valid lock
1393      *
1394      * @param env         Zip FS properties to use when creating the Zip file
1395      * @param compression The compression used when writing the entries
1396      * @throws Exception If an error occurs
1397      */
1398     @Test(dataProvider = &quot;zipfsMap&quot;)
1399     public void fcLockTest(final Map&lt;String, String&gt; env,
1400                            final int compression) throws Exception {
1401         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1402         Files.deleteIfExists(zipFile);
1403         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1404         zip(zipFile, env, e0);
1405         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1406              FileChannel in = FileChannel.open(zipfs.getPath(e0.name), Set.of(READ, WRITE))) {
1407             FileLock lock = in.lock();
1408             assertNotNull(lock);
1409             assertTrue(lock.isValid());
1410             lock.close();
1411             assertFalse(lock.isValid());
1412             // Acquire another lock specifying an offset and size
1413             lock = in.lock(0, 10, false);
1414             assertNotNull(lock);
1415             assertTrue(lock.isValid());
1416             lock.close();
1417             assertFalse(lock.isValid());
1418         }
1419         Files.deleteIfExists(zipFile);
1420     }
1421 
1422     /**
1423      * Validate FileChannel::tryLock returns a valid lock
1424      *
1425      * @param env         Zip FS properties to use when creating the Zip file
1426      * @param compression The compression used when writing the entries
1427      * @throws Exception If an error occurs
1428      */
1429     @Test(dataProvider = &quot;zipfsMap&quot;)
1430     public void fcTryLockTest(final Map&lt;String, String&gt; env,
1431                               final int compression) throws Exception {
1432         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1433         Files.deleteIfExists(zipFile);
1434         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1435         zip(zipFile, env, e0);
1436         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1437              FileChannel in = FileChannel.open(zipfs.getPath(e0.name), Set.of(READ, WRITE))) {
1438             FileLock lock = in.tryLock();
1439             assertNotNull(lock);
1440             assertTrue(lock.isValid());
1441             lock.close();
1442             assertFalse(lock.isValid());
1443             // Acquire another lock specifying an offset and size
1444             lock = in.tryLock(0, 10, false);
1445             assertNotNull(lock);
1446             assertTrue(lock.isValid());
1447             lock.close();
1448             assertFalse(lock.isValid());
1449         }
1450         Files.deleteIfExists(zipFile);
1451     }
1452 
1453     /**
1454      * Use a SeekableByteChannel to copy an entry from one file to another
1455      *
1456      * @param src Path of file to read from
1457      * @param dst Path of file to write to
1458      * @throws IOException if an error occurs
1459      */
1460     private static void sbcCopy(Path src, Path dst) throws IOException {
1461         try (SeekableByteChannel in = Files.newByteChannel(src, Set.of(READ));
1462              SeekableByteChannel out = Files.newByteChannel(dst,
1463                      Set.of(CREATE_NEW, WRITE))) {
1464             ByteBuffer bb = ByteBuffer.allocate(BYTEBUFFER_SIZE);
1465             while (in.read(bb) &gt;= 0) {
1466                 bb.flip();
1467                 out.write(bb);
1468                 bb.clear();
1469             }
1470         }
1471     }
1472 
1473     /**
1474      * Use a FileChannel to copy an entry from one file to another
1475      *
1476      * @param src Path of file to read from
1477      * @param dst Path of file to write to
1478      * @throws IOException if an error occurs
1479      */
1480     private static void fcCopy(Path src, Path dst) throws IOException {
1481         try (FileChannel srcFc = FileChannel.open(src, Set.of(READ));
1482              FileChannel dstFc = FileChannel.open(dst, Set.of(CREATE_NEW, WRITE))) {
1483             ByteBuffer bb = ByteBuffer.allocate(BYTEBUFFER_SIZE);
1484             while (srcFc.read(bb) &gt;= 0) {
1485                 bb.flip();
1486                 dstFc.write(bb);
1487                 bb.clear();
1488             }
1489         }
1490     }
1491 
1492     /**
1493      * Use FileChannel::transferTo to copy an entry from one file to another
1494      *
1495      * @param src Path of file to read from
1496      * @param dst Path of file to write to
1497      * @throws IOException if an error occurs
1498      */
1499     private static void fcTransferTo(Path src, Path dst) throws IOException {
1500         try (FileChannel in = FileChannel.open(src, Set.of(READ));
1501              FileChannel out = FileChannel.open(dst, Set.of(CREATE_NEW, WRITE))) {
1502             in.transferTo(0, in.size(), out);
1503         }
1504     }
1505 
1506     /**
1507      * Use FileChannel::transferFrom to copy an entry from one file to another
1508      *
1509      * @param from Path of file to read from
1510      * @param to   Path of file to write to
1511      * @throws IOException if an error occurs
1512      */
1513     private static void fcTransferFrom(Path from, Path to) throws IOException {
1514         try (FileChannel in = FileChannel.open(from, Set.of(READ));
1515              FileChannel out = FileChannel.open(to, Set.of(CREATE_NEW, WRITE))) {
1516             out.transferFrom(in, 0, in.size());
1517         }
1518     }
1519 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/DatagramSocket/GetLocalAddress.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.IOException;
 25 import java.net.DatagramSocket;
 26 import java.net.InetAddress;
 27 import java.net.InetSocketAddress;
 28 import java.net.MulticastSocket;
 29 import java.nio.channels.DatagramChannel;
 30 import java.util.LinkedHashMap;
 31 import java.util.LinkedHashSet;
 32 import java.util.Map;
 33 import java.util.Set;
 34 
 35 /**
 36  * @test
 37  * @run main/othervm GetLocalAddress
 38  * @summary Check that getLocalAddress() and getLocalSocketAddress()
 39  *          work as specified
 40  */
 41 
 42 public class GetLocalAddress {
 43     static final Map&lt;DatagramSocket, InetAddress&gt; addressMap = new LinkedHashMap&lt;&gt;();
 44     static final Set&lt;DatagramSocket&gt; toClose = new LinkedHashSet&lt;&gt;();
 45 
 46     public static void main(String[] args) throws Exception {
 47         try {
 48             testAllSockets();
 49         } finally {
 50             cleanup();
 51         }
 52     }
 53 
 54     static void testAllSockets() throws IOException {
 55         var address = new InetSocketAddress(InetAddress.getLocalHost(), 0);
 56         bindAndAddToMap(new DatagramSocket(null), address);
 57         bindAndAddToMap(new MulticastSocket(null), address);
 58         bindAndAddToMap(DatagramChannel.open().socket(), address);
 59         addToMap(new DatagramSocket(address));
 60         addToMap(new MulticastSocket(address));
 61         addToMap(DatagramChannel.open().bind(address).socket());
 62         testSocket();
 63         testAfterClose();
 64     }
 65 
 66     static void bindAndAddToMap(DatagramSocket socket, InetSocketAddress address)
 67             throws IOException
 68     {
 69         toClose.add(socket);
 70         testNullAddress(socket, socket.getLocalSocketAddress(), &quot;before bind&quot;);
 71         testWildcardAddress(socket, socket.getLocalAddress(), &quot;before bind&quot;);
 72         socket.bind(address);
 73         addressMap.put(socket, ((InetSocketAddress)socket.getLocalSocketAddress())
 74                 .getAddress());
 75     }
 76 
 77     static void addToMap(DatagramSocket socket) throws IOException {
 78         toClose.add(socket);
 79         addressMap.put(socket, ((InetSocketAddress)socket.getLocalSocketAddress())
 80                 .getAddress());
 81     }
 82 
 83     static void testSocket() throws IOException {
 84         for (var entry : addressMap.entrySet()) {
 85             var socket = entry.getKey();
 86             checkAddresses(socket, entry.getValue(),
 87                     ((InetSocketAddress)entry.getKey().getLocalSocketAddress())
 88                                                       .getAddress());
 89             checkAddresses(socket, entry.getValue(),
 90                     entry.getKey().getLocalAddress());
 91         }
 92     }
 93 
 94     static void testAfterClose() throws IOException {
 95         for (var entry : addressMap.entrySet()) {
 96             var socket = entry.getKey();
 97             socket.close();
 98             toClose.remove(socket);
 99             testNullAddress(socket, socket.getLocalSocketAddress(), &quot;after close&quot;);
100             testNullAddress(socket, socket.getLocalAddress(), &quot;after close&quot;);
101         }
102     }
103 
104     static void checkAddresses(DatagramSocket socket, InetAddress a1, InetAddress a2) {
105         System.out.println(socket.getClass() + &quot;: Address1: &quot;
106                 + a1.toString() + &quot; Address2: &quot; + a2.toString());
107         if (!a1.getHostAddress().equals(a2.getHostAddress()))
108         {
109             throw new RuntimeException(&quot;Local address don&#39;t match for &quot; + socket.getClass());
110         }
111     }
112 
113     static void testNullAddress(DatagramSocket socket, Object address, String when) {
114         System.out.println(socket.getClass() + &quot;: Checking address &quot; + when);
115         if (address != null) {
116             throw new RuntimeException(&quot;Expected null address &quot; + when + &quot;, got: &quot;
117                     + address +  &quot; for &quot; + socket.getClass());
118         }
119     }
120 
121     static void testWildcardAddress(DatagramSocket socket, InetAddress address, String when) {
122         System.out.println(socket.getClass() + &quot;: Checking address &quot; + when);
123         if (address == null || !address.isAnyLocalAddress()) {
124             throw new RuntimeException(&quot;Expected wildcard address &quot; + when + &quot;, got: &quot;
125                     + address +  &quot; for &quot; + socket.getClass());
126         }
127     }
128 
129     static void cleanup() {
130         // Some socket might not have been closed if
131         // the test failed in exception.
132         // forcing cleanup here.
133         toClose.forEach(GetLocalAddress::close);
134         toClose.clear();
135         addressMap.clear();
136     }
137 
138     static void close(DatagramSocket socket) {
139         try {
140             socket.close();
141         } catch (Throwable ignore) { }
142     }
143 
144 }
    </pre>
  </body>
</html>
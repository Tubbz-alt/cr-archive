<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/security/ssl/SSLEngineImpl/EngineEnforceUseClientMode.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 //
 25 // SunJSSE does not support dynamic system properties, no way to re-use
 26 // system properties in samevm/agentvm mode.
 27 //
 28 
 29 /*
 30  * @test
<a name="2" id="anc2"></a><span class="line-modified"> 31  * @bug 4980882 8207250</span>
 32  * @summary SSLEngine should enforce setUseClientMode
 33  * @run main/othervm EngineEnforceUseClientMode
 34  * @author Brad R. Wetmore
 35  */
 36 
 37 import javax.net.ssl.*;
 38 import javax.net.ssl.SSLEngineResult.*;
 39 import java.io.*;
 40 import java.security.*;
 41 import java.nio.*;
 42 
 43 public class EngineEnforceUseClientMode {
 44 
 45     private static boolean debug = false;
 46 
 47     private SSLContext sslc;
 48     private SSLEngine ssle1;    // client
 49     private SSLEngine ssle2;    // server
 50 
 51     private SSLEngine ssle3;    // server
 52     private SSLEngine ssle4;    // server
 53     private SSLEngine ssle5;    // server
 54 
 55     private static String pathToStores = &quot;../../../../javax/net/ssl/etc&quot;;
 56     private static String keyStoreFile = &quot;keystore&quot;;
 57     private static String trustStoreFile = &quot;truststore&quot;;
 58     private static String passwd = &quot;passphrase&quot;;
 59 
 60     private static String keyFilename =
 61             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
 62                 &quot;/&quot; + keyStoreFile;
 63     private static String trustFilename =
 64             System.getProperty(&quot;test.src&quot;, &quot;./&quot;) + &quot;/&quot; + pathToStores +
 65                 &quot;/&quot; + trustStoreFile;
 66 
 67     private ByteBuffer appOut1;         // write side of ssle1
 68     private ByteBuffer appIn1;          // read side of ssle1
 69     private ByteBuffer appOut2;         // write side of ssle2
 70     private ByteBuffer appIn2;          // read side of ssle2
 71 
 72     private ByteBuffer oneToTwo;        // &quot;reliable&quot; transport ssle1-&gt;ssle2
 73     private ByteBuffer twoToOne;        // &quot;reliable&quot; transport ssle2-&gt;ssle1
 74 
 75     /*
 76      * Majority of the test case is here, setup is done below.
 77      */
 78     private void createSSLEngines() throws Exception {
 79         ssle1 = sslc.createSSLEngine(&quot;client&quot;, 1);
 80         ssle1.setUseClientMode(true);
 81 
 82         ssle2 = sslc.createSSLEngine();
 83         ssle2.setUseClientMode(false);
 84         ssle2.setNeedClientAuth(true);
 85 
 86         /*
 87          * Note, these are not initialized to client/server
 88          */
 89         ssle3 = sslc.createSSLEngine();
 90         ssle4 = sslc.createSSLEngine();
 91         ssle5 = sslc.createSSLEngine();
<a name="3" id="anc3"></a>




 92     }
 93 
 94     private void runTest() throws Exception {
 95 
 96         createSSLEngines();
 97         createBuffers();
 98 
 99         /*
100          * First try the engines with no client/server initialization
101          * All should fail.
102          */
103         try {
104             System.out.println(&quot;Testing wrap()&quot;);
105             ssle3.wrap(appOut1, oneToTwo);
106             throw new RuntimeException(
107                 &quot;wrap():  Didn&#39;t catch the exception properly&quot;);
108         } catch (IllegalStateException e) {
109             System.out.println(&quot;Caught the correct exception.&quot;);
110             oneToTwo.flip();
111             if (oneToTwo.hasRemaining()) {
112                 throw new Exception(&quot;wrap generated data&quot;);
113             }
114             oneToTwo.clear();
115         }
116 
117         try {
118             System.out.println(&quot;Testing unwrap()&quot;);
119             ssle4.unwrap(oneToTwo, appIn1);
120             throw new RuntimeException(
121                 &quot;unwrap():  Didn&#39;t catch the exception properly&quot;);
122         } catch (IllegalStateException e) {
123             System.out.println(&quot;Caught the correct exception.&quot;);
124             appIn1.flip();
125             if (appIn1.hasRemaining()) {
126                 throw new Exception(&quot;unwrap generated data&quot;);
127             }
128             appIn1.clear();
129         }
130 
131         try {
132             System.out.println(&quot;Testing beginHandshake()&quot;);
133             ssle5.beginHandshake();
134             throw new RuntimeException(
135                 &quot;unwrap():  Didn&#39;t catch the exception properly&quot;);
136         } catch (IllegalStateException e) {
137             System.out.println(&quot;Caught the correct exception.&quot;);
138         }
139 
140         boolean dataDone = false;
141 
142         SSLEngineResult result1;        // ssle1&#39;s results from last operation
143         SSLEngineResult result2;        // ssle2&#39;s results from last operation
144 
145         while (!isEngineClosed(ssle1) || !isEngineClosed(ssle2)) {
146 
147             log(&quot;================&quot;);
148 
149             result1 = ssle1.wrap(appOut1, oneToTwo);
150             result2 = ssle2.wrap(appOut2, twoToOne);
151 
152             log(&quot;wrap1:  &quot; + result1);
153             log(&quot;oneToTwo  = &quot; + oneToTwo);
154             log(&quot;&quot;);
155 
156             log(&quot;wrap2:  &quot; + result2);
157             log(&quot;twoToOne  = &quot; + twoToOne);
158 
159             runDelegatedTasks(result1, ssle1);
160             runDelegatedTasks(result2, ssle2);
161 
162             oneToTwo.flip();
163             twoToOne.flip();
164 
165             log(&quot;----&quot;);
166 
167             result1 = ssle1.unwrap(twoToOne, appIn1);
168             result2 = ssle2.unwrap(oneToTwo, appIn2);
169 
170             log(&quot;unwrap1: &quot; + result1);
171             log(&quot;twoToOne  = &quot; + twoToOne);
172             log(&quot;&quot;);
173 
174             log(&quot;unwrap2: &quot; + result2);
175             log(&quot;oneToTwo  = &quot; + oneToTwo);
176 
177             runDelegatedTasks(result1, ssle1);
178             runDelegatedTasks(result2, ssle2);
179 
180             oneToTwo.compact();
181             twoToOne.compact();
182 
183             /*
184              * If we&#39;ve transfered all the data between app1 and app2,
185              * we try to close and see what that gets us.
186              */
187             if (!dataDone &amp;&amp; (appOut1.limit() == appIn2.position()) &amp;&amp;
188                     (appOut2.limit() == appIn1.position())) {
189 
190                 checkTransfer(appOut1, appIn2);
191                 checkTransfer(appOut2, appIn1);
192 
193                 // Should not be able to set mode now, no matter if
194                 // it is the same of different.
195                 System.out.println(&quot;Try changing modes...&quot;);
196                 for (boolean b : new Boolean[] {true, false}) {
197                     try {
198                         ssle2.setUseClientMode(b);
199                         throw new RuntimeException(
200                                 &quot;setUseClientMode(&quot; + b + &quot;):  &quot; +
201                                         &quot;Didn&#39;t catch the exception properly&quot;);
202                     } catch (IllegalArgumentException e) {
203                         System.out.println(&quot;Caught the correct exception.&quot;);
204                     }
205                 }
206 
207                 return;
208             }
209         }
210     }
211 
212     public static void main(String args[]) throws Exception {
213 
214         EngineEnforceUseClientMode test;
215 
216         test = new EngineEnforceUseClientMode();
217 
218         test.createSSLEngines();
219 
220         test.runTest();
221 
222         System.out.println(&quot;Test Passed.&quot;);
223     }
224 
225     /*
226      * **********************************************************
227      * Majority of the test case is above, below is just setup stuff
228      * **********************************************************
229      */
230 
231     public EngineEnforceUseClientMode() throws Exception {
232         sslc = getSSLContext(keyFilename, trustFilename);
233     }
234 
235     /*
236      * Create an initialized SSLContext to use for this test.
237      */
238     private SSLContext getSSLContext(String keyFile, String trustFile)
239             throws Exception {
240 
241         KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
242         KeyStore ts = KeyStore.getInstance(&quot;JKS&quot;);
243 
244         char[] passphrase = &quot;passphrase&quot;.toCharArray();
245 
246         ks.load(new FileInputStream(keyFile), passphrase);
247         ts.load(new FileInputStream(trustFile), passphrase);
248 
249         KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;SunX509&quot;);
250         kmf.init(ks, passphrase);
251 
252         TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);
253         tmf.init(ts);
254 
255         SSLContext sslCtx = SSLContext.getInstance(&quot;TLS&quot;);
256 
257         sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
258 
259         return sslCtx;
260     }
261 
262     private void createBuffers() {
263         // Size the buffers as appropriate.
264 
265         SSLSession session = ssle1.getSession();
266         int appBufferMax = session.getApplicationBufferSize();
267         int netBufferMax = session.getPacketBufferSize();
268 
269         appIn1 = ByteBuffer.allocateDirect(appBufferMax + 50);
270         appIn2 = ByteBuffer.allocateDirect(appBufferMax + 50);
271 
272         oneToTwo = ByteBuffer.allocateDirect(netBufferMax);
273         twoToOne = ByteBuffer.allocateDirect(netBufferMax);
274 
275         appOut1 = ByteBuffer.wrap(&quot;Hi Engine2, I&#39;m SSLEngine1&quot;.getBytes());
276         appOut2 = ByteBuffer.wrap(&quot;Hello Engine1, I&#39;m SSLEngine2&quot;.getBytes());
277 
278         log(&quot;AppOut1 = &quot; + appOut1);
279         log(&quot;AppOut2 = &quot; + appOut2);
280         log(&quot;&quot;);
281     }
282 
283     private static void runDelegatedTasks(SSLEngineResult result,
284             SSLEngine engine) throws Exception {
285 
286         if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {
287             Runnable runnable;
288             while ((runnable = engine.getDelegatedTask()) != null) {
289                 log(&quot;running delegated task...&quot;);
290                 runnable.run();
291             }
292         }
293     }
294 
295     private static boolean isEngineClosed(SSLEngine engine) {
296         return (engine.isOutboundDone() &amp;&amp; engine.isInboundDone());
297     }
298 
299     private static void checkTransfer(ByteBuffer a, ByteBuffer b)
300             throws Exception {
301         a.flip();
302         b.flip();
303 
304         if (!a.equals(b)) {
305             throw new Exception(&quot;Data didn&#39;t transfer cleanly&quot;);
306         } else {
307             log(&quot;Data transferred cleanly&quot;);
308         }
309 
310         a.position(a.limit());
311         b.position(b.limit());
312         a.limit(a.capacity());
313         b.limit(b.capacity());
314     }
315 
316     private static void log(String str) {
317         if (debug) {
318             System.out.println(str);
319         }
320     }
321 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
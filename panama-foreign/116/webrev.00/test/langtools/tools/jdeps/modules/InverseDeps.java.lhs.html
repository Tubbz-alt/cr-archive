<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/jdeps/modules/InverseDeps.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Tests split packages
 27  * @library ../lib
 28  * @build CompilerUtils JdepsUtil
 29  * @modules java.logging
 30  *          jdk.jdeps/com.sun.tools.jdeps
 31  *          jdk.unsupported
 32  * @run testng InverseDeps
 33  */
 34 
 35 import java.io.File;
 36 import java.nio.file.Files;
 37 import java.nio.file.Path;
 38 import java.nio.file.Paths;
 39 import java.util.Arrays;
 40 import java.util.LinkedHashSet;
 41 import java.util.List;
 42 import java.util.Set;
 43 import java.util.stream.Collectors;
 44 import java.util.stream.Stream;
 45 
 46 import com.sun.tools.jdeps.Archive;
 47 import com.sun.tools.jdeps.InverseDepsAnalyzer;
 48 import org.testng.annotations.BeforeTest;
 49 import org.testng.annotations.DataProvider;
 50 import org.testng.annotations.Test;
 51 
 52 import static org.testng.Assert.assertTrue;
 53 import static org.testng.Assert.assertFalse;
 54 import static org.testng.Assert.assertEquals;
 55 
 56 
 57 public class InverseDeps {
 58     private static final String TEST_SRC = System.getProperty(&quot;test.src&quot;);
 59     private static final String TEST_CLASSES = System.getProperty(&quot;test.classes&quot;);
 60 
 61     private static final Path SRC_DIR = Paths.get(TEST_SRC, &quot;src&quot;);
 62     private static final Path MODS_DIR = Paths.get(&quot;mods&quot;);
 63     private static final Path LIBS_DIR = Paths.get(&quot;libs&quot;);
 64 
 65     private static final Set&lt;String&gt; modules = new LinkedHashSet(
 66         List.of(&quot;unsafe&quot;, &quot;mIV&quot;, &quot;mV&quot;, &quot;mVI&quot;, &quot;mVII&quot;)
 67     );
 68 
 69     /**
 70      * Compiles classes used by the test
 71      */
 72     @BeforeTest
 73     public void compileAll() throws Exception {
 74         CompilerUtils.cleanDir(MODS_DIR);
 75 
 76         for (String mn : modules) {
 77             // compile a module
 78             assertTrue(CompilerUtils.compileModule(SRC_DIR, MODS_DIR, mn));
 79 
 80             // create JAR files with no module-info.class
 81             Path root = MODS_DIR.resolve(mn);
 82 
 83             try (Stream&lt;Path&gt; stream = Files.walk(root, Integer.MAX_VALUE)) {
 84                 Stream&lt;Path&gt; entries = stream.filter(f -&gt; {
 85                     String fn = f.getFileName().toString();
 86                     return fn.endsWith(&quot;.class&quot;) &amp;&amp; !fn.equals(&quot;module-info.class&quot;);
 87                 });
 88                 JdepsUtil.createJar(LIBS_DIR.resolve(mn + &quot;.jar&quot;), root, entries);
 89             }
 90         }
 91     }
 92     @DataProvider(name = &quot;jdkModules&quot;)
 93     public Object[][] jdkModules() {
 94         return new Object[][]{
<a name="2" id="anc2"></a><span class="line-modified"> 95             // --require and a subset of dependences</span>
 96             { &quot;jdk.compiler&quot;, new String[][] {
 97                     new String[] {&quot;jdk.compiler&quot;, &quot;jdk.jshell&quot;},
<a name="3" id="anc3"></a><span class="line-modified"> 98                     new String[] {&quot;jdk.compiler&quot;, &quot;jdk.rmic&quot;},</span>
<span class="line-removed"> 99                     new String[] {&quot;jdk.compiler&quot;, &quot;jdk.javadoc&quot;, &quot;jdk.rmic&quot;},</span>
100                 }
101             },
102             { &quot;java.compiler&quot;, new String[][] {
103                     new String[] {&quot;java.compiler&quot;, &quot;jdk.jshell&quot;},
104                     new String[] {&quot;java.compiler&quot;, &quot;jdk.compiler&quot;, &quot;jdk.jshell&quot;},
<a name="4" id="anc4"></a><span class="line-modified">105                     new String[] {&quot;java.compiler&quot;, &quot;jdk.compiler&quot;, &quot;jdk.rmic&quot;},</span>
<span class="line-modified">106                     new String[] {&quot;java.compiler&quot;, &quot;jdk.compiler&quot;, &quot;jdk.javadoc&quot;, &quot;jdk.rmic&quot;},</span>
107                     new String[] {&quot;java.compiler&quot;, &quot;java.se&quot;},
108                 }
109             },
110         };
111     }
112 
113     @Test(dataProvider = &quot;jdkModules&quot;)
114     public void testJDKModule(String moduleName, String[][] expected) throws Exception {
115         // this invokes the jdeps launcher so that all system modules are observable
116         JdepsRunner jdeps = JdepsRunner.run(
117             &quot;--inverse&quot;, &quot;--require&quot;, moduleName
118         );
119         List&lt;String&gt; output = Arrays.stream(jdeps.output())
120             .map(s -&gt; s.trim())
121             .collect(Collectors.toList());
122 
123         // verify the dependences
124         assertTrue(Arrays.stream(expected)
125                          .map(path -&gt; Arrays.stream(path)
126                          .collect(Collectors.joining(&quot; &lt;- &quot;)))
127                          .anyMatch(output::contains));
128     }
129 
130 
131     @DataProvider(name = &quot;testrequires&quot;)
132     public Object[][] expected1() {
133         return new Object[][] {
134             // --require and result
135             { &quot;java.sql&quot;, new String[][] {
136                     new String[] { &quot;java.sql&quot;, &quot;mV&quot; },
137                 }
138             },
139             { &quot;java.compiler&quot;, new String[][] {
140                     new String[] { &quot;java.compiler&quot;, &quot;mV&quot; },
141                     new String[] { &quot;java.compiler&quot;, &quot;mIV&quot;, &quot;mV&quot; },
142                 }
143             },
144             { &quot;java.logging&quot;, new String[][]{
145                     new String[] {&quot;java.logging&quot;, &quot;mV&quot;},
146                     new String[] {&quot;java.logging&quot;, &quot;mIV&quot;, &quot;mV&quot;},
147                     new String[] {&quot;java.logging&quot;, &quot;java.sql&quot;, &quot;mV&quot;},
148                 }
149             },
150             { &quot;jdk.unsupported&quot;, new String[][] {
151                     new String[] {&quot;jdk.unsupported&quot;, &quot;unsafe&quot;, &quot;mVI&quot;, &quot;mVII&quot;},
152                     new String[] {&quot;jdk.unsupported&quot;, &quot;unsafe&quot;, &quot;mVII&quot;}
153                 }
154             },
155         };
156     }
157 
158     @Test(dataProvider = &quot;testrequires&quot;)
159     public void testrequires(String name, String[][] expected) throws Exception {
160         String cmd1 = String.format(&quot;jdeps --inverse --module-path %s --require %s --add-modules %s%n&quot;,
161                 MODS_DIR, name, modules.stream().collect(Collectors.joining(&quot;,&quot;)));
162 
163         try (JdepsUtil.Command jdeps = JdepsUtil.newCommand(cmd1)) {
164             jdeps.appModulePath(MODS_DIR.toString())
165                 .addmods(modules)
166                 .requires(Set.of(name));
167 
168             runJdeps(jdeps, expected);
169         }
170 
171         String cmd2 = String.format(&quot;jdeps --inverse --module-path %s --require %s&quot; +
172             &quot; --add-modules ALL-MODULE-PATH%n&quot;, LIBS_DIR, name);
173 
174             // automatic module
175         try (JdepsUtil.Command jdeps = JdepsUtil.newCommand(cmd2)) {
176             jdeps.appModulePath(MODS_DIR.toString())
177                 .addmods(Set.of(&quot;ALL-MODULE-PATH&quot;))
178                 .requires(Set.of(name));
179 
180             runJdeps(jdeps, expected);
181         }
182     }
183 
184     @DataProvider(name = &quot;testpackage&quot;)
185     public Object[][] expected2() {
186         return new Object[][] {
187             // -package and result
188             { &quot;p4&quot;, new String[][] {
189                         new String[] { &quot;mIV&quot;, &quot;mV&quot;},
190                     }
191             },
192             { &quot;javax.tools&quot;, new String[][] {
193                         new String[] {&quot;java.compiler&quot;, &quot;mV&quot;},
194                         new String[] {&quot;java.compiler&quot;, &quot;mIV&quot;, &quot;mV&quot;},
195                     }
196             },
197             { &quot;sun.misc&quot;, new String[][] {
198                         new String[] {&quot;jdk.unsupported&quot;, &quot;unsafe&quot;, &quot;mVI&quot;, &quot;mVII&quot;},
199                         new String[] {&quot;jdk.unsupported&quot;, &quot;unsafe&quot;, &quot;mVII&quot;}
200                     }
201             }
202         };
203     }
204 
205     @Test(dataProvider = &quot;testpackage&quot;)
206     public void testpackage(String name, String[][] expected) throws Exception {
207         String cmd = String.format(&quot;jdeps --inverse --module-path %s -package %s --add-modules %s%n&quot;,
208             MODS_DIR, name, modules.stream().collect(Collectors.joining(&quot;,&quot;)));
209         try (JdepsUtil.Command jdeps = JdepsUtil.newCommand(cmd)) {
210             jdeps.appModulePath(MODS_DIR.toString())
211                 .addmods(modules)
212                 .matchPackages(Set.of(name));
213 
214             runJdeps(jdeps, expected);
215         }
216     }
217 
218     @DataProvider(name = &quot;testregex&quot;)
219     public Object[][] expected3() {
220         return new Object[][] {
221             // -regex and result
222             { &quot;org.safe.Lib&quot;, new String[][] {
223                     new String[] { &quot;unsafe&quot;, &quot;mVII&quot;},
224                     new String[] { &quot;unsafe&quot;, &quot;mVI&quot;, &quot;mVII&quot;},
225                 }
226             },
227             { &quot;java.util.logging.*|org.safe.Lib&quot;, new String[][] {
228                     new String[] { &quot;unsafe&quot;, &quot;mVII&quot;},
229                     new String[] { &quot;unsafe&quot;, &quot;mVI&quot;, &quot;mVII&quot;},
230                     new String[] { &quot;java.logging&quot;, &quot;mV&quot;},
231                 }
232             }
233         };
234     }
235 
236     @Test(dataProvider = &quot;testregex&quot;)
237     public void testregex(String name, String[][] expected) throws Exception {
238         String cmd = String.format(&quot;jdeps --inverse --module-path %s -regex %s --add-modules %s%n&quot;,
239                 MODS_DIR, name, modules.stream().collect(Collectors.joining(&quot;,&quot;)));
240 
241         try (JdepsUtil.Command jdeps = JdepsUtil.newCommand(cmd)) {
242             jdeps.appModulePath(MODS_DIR.toString())
243                 .addmods(modules)
244                 .regex(name);
245 
246             runJdeps(jdeps, expected);
247         }
248     }
249 
250     @DataProvider(name = &quot;classpath&quot;)
251     public Object[][] expected4() {
252         return new Object[][] {
253             // -regex and result
254             { &quot;sun.misc.Unsafe&quot;, new String[][] {
255                     new String[] {&quot;jdk.unsupported&quot;, &quot;unsafe.jar&quot;, &quot;mVI.jar&quot;, &quot;mVII.jar&quot;},
256                     new String[] {&quot;jdk.unsupported&quot;, &quot;unsafe.jar&quot;, &quot;mVII.jar&quot;}
257                 }
258             },
259             { &quot;org.safe.Lib&quot;, new String[][] {
260                     new String[] { &quot;unsafe.jar&quot;, &quot;mVII.jar&quot;},
261                     new String[] { &quot;unsafe.jar&quot;, &quot;mVI.jar&quot;, &quot;mVII.jar&quot;},
262                 }
263             },
264             { &quot;java.util.logging.*|org.safe.Lib&quot;, new String[][] {
265                     new String[] { &quot;unsafe.jar&quot;, &quot;mVII.jar&quot;},
266                     new String[] { &quot;unsafe.jar&quot;, &quot;mVI.jar&quot;, &quot;mVII.jar&quot;},
267                     new String[] { &quot;java.logging&quot;, &quot;mV.jar&quot;},
268                 }
269             }
270         };
271     }
272 
273     @Test(dataProvider = &quot;classpath&quot;)
274     public void testClassPath(String name, String[][] expected) throws Exception {
275         // -classpath
276         String cpath = modules.stream()
277             .filter(mn -&gt; !mn.equals(&quot;mVII&quot;))
278             .map(mn -&gt; LIBS_DIR.resolve(mn + &quot;.jar&quot;).toString())
279             .collect(Collectors.joining(File.pathSeparator));
280 
281         Path jarfile = LIBS_DIR.resolve(&quot;mVII.jar&quot;);
282 
283         String cmd1 = String.format(&quot;jdeps --inverse -classpath %s -regex %s %s%n&quot;,
284             cpath, name, jarfile);
285         try (JdepsUtil.Command jdeps = JdepsUtil.newCommand(cmd1)) {
286             jdeps.verbose(&quot;-verbose:class&quot;)
287                 .addClassPath(cpath)
288                 .regex(name).addRoot(jarfile);
289             runJdeps(jdeps, expected);
290         }
291 
292         // all JAR files on the command-line arguments
293         Set&lt;Path&gt; paths = modules.stream()
294                                  .map(mn -&gt; LIBS_DIR.resolve(mn + &quot;.jar&quot;))
295                                  .collect(Collectors.toSet());
296         String cmd2 = String.format(&quot;jdeps --inverse -regex %s %s%n&quot;, name, paths);
297         try (JdepsUtil.Command jdeps = JdepsUtil.newCommand(cmd2)) {
298             jdeps.verbose(&quot;-verbose:class&quot;).regex(name);
299             paths.forEach(jdeps::addRoot);
300             runJdeps(jdeps, expected);
301         }
302     }
303 
304     private void runJdeps(JdepsUtil.Command jdeps, String[][] expected)  throws Exception {
305         InverseDepsAnalyzer analyzer = jdeps.getInverseDepsAnalyzer();
306 
307         assertTrue(analyzer.run());
308 
309         // get the inverse transitive dependences
310         List&lt;String[]&gt; paths = analyzer.inverseDependences().stream()
311             .map(deque -&gt; deque.stream()
312                                .map(Archive::getName)
313                                .collect(Collectors.toList()).toArray(new String[0]))
314             .collect(Collectors.toList());
315 
316         jdeps.dumpOutput(System.err);
317         paths.forEach(path -&gt; System.err.println(Arrays.stream(path)
318                 .collect(Collectors.joining(&quot; &lt;- &quot;))));
319 
320         // verify the dependences
321         assertEquals(paths.size(), expected.length);
322 
323         for (int i=0; i &lt; paths.size(); i++) {
324             String[] path = paths.get(i);
325             boolean noneMatched = Arrays.stream(expected)
326                     .filter(array -&gt; array.length == path.length)
327                     .noneMatch(array -&gt; Arrays.equals(array, path));
328             if (noneMatched)
329                 System.err.format(&quot;Expected: %s found: %s%n&quot;,
330                                   Arrays.stream(expected)
331                                       .map(Arrays::toString)
332                                       .collect(Collectors.joining(&quot;, &quot;)),
333                     Arrays.toString(path));
334 
335             assertFalse(noneMatched);
336         }
337     }
338 
339 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
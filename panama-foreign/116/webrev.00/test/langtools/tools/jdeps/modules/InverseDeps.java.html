<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/jdeps/modules/InverseDeps.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Tests split packages
 27  * @library ../lib
 28  * @build CompilerUtils JdepsUtil
 29  * @modules java.logging
 30  *          jdk.jdeps/com.sun.tools.jdeps
 31  *          jdk.unsupported
 32  * @run testng InverseDeps
 33  */
 34 
 35 import java.io.File;
 36 import java.nio.file.Files;
 37 import java.nio.file.Path;
 38 import java.nio.file.Paths;
 39 import java.util.Arrays;
 40 import java.util.LinkedHashSet;
 41 import java.util.List;
 42 import java.util.Set;
 43 import java.util.stream.Collectors;
 44 import java.util.stream.Stream;
 45 
 46 import com.sun.tools.jdeps.Archive;
 47 import com.sun.tools.jdeps.InverseDepsAnalyzer;
 48 import org.testng.annotations.BeforeTest;
 49 import org.testng.annotations.DataProvider;
 50 import org.testng.annotations.Test;
 51 
 52 import static org.testng.Assert.assertTrue;
 53 import static org.testng.Assert.assertFalse;
 54 import static org.testng.Assert.assertEquals;
 55 
 56 
 57 public class InverseDeps {
 58     private static final String TEST_SRC = System.getProperty(&quot;test.src&quot;);
 59     private static final String TEST_CLASSES = System.getProperty(&quot;test.classes&quot;);
 60 
 61     private static final Path SRC_DIR = Paths.get(TEST_SRC, &quot;src&quot;);
 62     private static final Path MODS_DIR = Paths.get(&quot;mods&quot;);
 63     private static final Path LIBS_DIR = Paths.get(&quot;libs&quot;);
 64 
 65     private static final Set&lt;String&gt; modules = new LinkedHashSet(
 66         List.of(&quot;unsafe&quot;, &quot;mIV&quot;, &quot;mV&quot;, &quot;mVI&quot;, &quot;mVII&quot;)
 67     );
 68 
 69     /**
 70      * Compiles classes used by the test
 71      */
 72     @BeforeTest
 73     public void compileAll() throws Exception {
 74         CompilerUtils.cleanDir(MODS_DIR);
 75 
 76         for (String mn : modules) {
 77             // compile a module
 78             assertTrue(CompilerUtils.compileModule(SRC_DIR, MODS_DIR, mn));
 79 
 80             // create JAR files with no module-info.class
 81             Path root = MODS_DIR.resolve(mn);
 82 
 83             try (Stream&lt;Path&gt; stream = Files.walk(root, Integer.MAX_VALUE)) {
 84                 Stream&lt;Path&gt; entries = stream.filter(f -&gt; {
 85                     String fn = f.getFileName().toString();
 86                     return fn.endsWith(&quot;.class&quot;) &amp;&amp; !fn.equals(&quot;module-info.class&quot;);
 87                 });
 88                 JdepsUtil.createJar(LIBS_DIR.resolve(mn + &quot;.jar&quot;), root, entries);
 89             }
 90         }
 91     }
 92     @DataProvider(name = &quot;jdkModules&quot;)
 93     public Object[][] jdkModules() {
 94         return new Object[][]{
 95             // --require and a subset of dependencies
 96             { &quot;jdk.compiler&quot;, new String[][] {
 97                     new String[] {&quot;jdk.compiler&quot;, &quot;jdk.jshell&quot;},
 98                     new String[] {&quot;jdk.compiler&quot;, &quot;jdk.javadoc&quot;},
 99                 }
100             },
101             { &quot;java.compiler&quot;, new String[][] {
102                     new String[] {&quot;java.compiler&quot;, &quot;jdk.jshell&quot;},
103                     new String[] {&quot;java.compiler&quot;, &quot;jdk.compiler&quot;, &quot;jdk.jshell&quot;},
104                     new String[] {&quot;java.compiler&quot;, &quot;jdk.compiler&quot;},
105                     new String[] {&quot;java.compiler&quot;, &quot;jdk.compiler&quot;, &quot;jdk.javadoc&quot;},
106                     new String[] {&quot;java.compiler&quot;, &quot;java.se&quot;},
107                 }
108             },
109         };
110     }
111 
112     @Test(dataProvider = &quot;jdkModules&quot;)
113     public void testJDKModule(String moduleName, String[][] expected) throws Exception {
114         // this invokes the jdeps launcher so that all system modules are observable
115         JdepsRunner jdeps = JdepsRunner.run(
116             &quot;--inverse&quot;, &quot;--require&quot;, moduleName
117         );
118         List&lt;String&gt; output = Arrays.stream(jdeps.output())
119             .map(s -&gt; s.trim())
120             .collect(Collectors.toList());
121 
122         // verify the dependences
123         assertTrue(Arrays.stream(expected)
124                          .map(path -&gt; Arrays.stream(path)
125                          .collect(Collectors.joining(&quot; &lt;- &quot;)))
126                          .anyMatch(output::contains));
127     }
128 
129 
130     @DataProvider(name = &quot;testrequires&quot;)
131     public Object[][] expected1() {
132         return new Object[][] {
133             // --require and result
134             { &quot;java.sql&quot;, new String[][] {
135                     new String[] { &quot;java.sql&quot;, &quot;mV&quot; },
136                 }
137             },
138             { &quot;java.compiler&quot;, new String[][] {
139                     new String[] { &quot;java.compiler&quot;, &quot;mV&quot; },
140                     new String[] { &quot;java.compiler&quot;, &quot;mIV&quot;, &quot;mV&quot; },
141                 }
142             },
143             { &quot;java.logging&quot;, new String[][]{
144                     new String[] {&quot;java.logging&quot;, &quot;mV&quot;},
145                     new String[] {&quot;java.logging&quot;, &quot;mIV&quot;, &quot;mV&quot;},
146                     new String[] {&quot;java.logging&quot;, &quot;java.sql&quot;, &quot;mV&quot;},
147                 }
148             },
149             { &quot;jdk.unsupported&quot;, new String[][] {
150                     new String[] {&quot;jdk.unsupported&quot;, &quot;unsafe&quot;, &quot;mVI&quot;, &quot;mVII&quot;},
151                     new String[] {&quot;jdk.unsupported&quot;, &quot;unsafe&quot;, &quot;mVII&quot;}
152                 }
153             },
154         };
155     }
156 
157     @Test(dataProvider = &quot;testrequires&quot;)
158     public void testrequires(String name, String[][] expected) throws Exception {
159         String cmd1 = String.format(&quot;jdeps --inverse --module-path %s --require %s --add-modules %s%n&quot;,
160                 MODS_DIR, name, modules.stream().collect(Collectors.joining(&quot;,&quot;)));
161 
162         try (JdepsUtil.Command jdeps = JdepsUtil.newCommand(cmd1)) {
163             jdeps.appModulePath(MODS_DIR.toString())
164                 .addmods(modules)
165                 .requires(Set.of(name));
166 
167             runJdeps(jdeps, expected);
168         }
169 
170         String cmd2 = String.format(&quot;jdeps --inverse --module-path %s --require %s&quot; +
171             &quot; --add-modules ALL-MODULE-PATH%n&quot;, LIBS_DIR, name);
172 
173             // automatic module
174         try (JdepsUtil.Command jdeps = JdepsUtil.newCommand(cmd2)) {
175             jdeps.appModulePath(MODS_DIR.toString())
176                 .addmods(Set.of(&quot;ALL-MODULE-PATH&quot;))
177                 .requires(Set.of(name));
178 
179             runJdeps(jdeps, expected);
180         }
181     }
182 
183     @DataProvider(name = &quot;testpackage&quot;)
184     public Object[][] expected2() {
185         return new Object[][] {
186             // -package and result
187             { &quot;p4&quot;, new String[][] {
188                         new String[] { &quot;mIV&quot;, &quot;mV&quot;},
189                     }
190             },
191             { &quot;javax.tools&quot;, new String[][] {
192                         new String[] {&quot;java.compiler&quot;, &quot;mV&quot;},
193                         new String[] {&quot;java.compiler&quot;, &quot;mIV&quot;, &quot;mV&quot;},
194                     }
195             },
196             { &quot;sun.misc&quot;, new String[][] {
197                         new String[] {&quot;jdk.unsupported&quot;, &quot;unsafe&quot;, &quot;mVI&quot;, &quot;mVII&quot;},
198                         new String[] {&quot;jdk.unsupported&quot;, &quot;unsafe&quot;, &quot;mVII&quot;}
199                     }
200             }
201         };
202     }
203 
204     @Test(dataProvider = &quot;testpackage&quot;)
205     public void testpackage(String name, String[][] expected) throws Exception {
206         String cmd = String.format(&quot;jdeps --inverse --module-path %s -package %s --add-modules %s%n&quot;,
207             MODS_DIR, name, modules.stream().collect(Collectors.joining(&quot;,&quot;)));
208         try (JdepsUtil.Command jdeps = JdepsUtil.newCommand(cmd)) {
209             jdeps.appModulePath(MODS_DIR.toString())
210                 .addmods(modules)
211                 .matchPackages(Set.of(name));
212 
213             runJdeps(jdeps, expected);
214         }
215     }
216 
217     @DataProvider(name = &quot;testregex&quot;)
218     public Object[][] expected3() {
219         return new Object[][] {
220             // -regex and result
221             { &quot;org.safe.Lib&quot;, new String[][] {
222                     new String[] { &quot;unsafe&quot;, &quot;mVII&quot;},
223                     new String[] { &quot;unsafe&quot;, &quot;mVI&quot;, &quot;mVII&quot;},
224                 }
225             },
226             { &quot;java.util.logging.*|org.safe.Lib&quot;, new String[][] {
227                     new String[] { &quot;unsafe&quot;, &quot;mVII&quot;},
228                     new String[] { &quot;unsafe&quot;, &quot;mVI&quot;, &quot;mVII&quot;},
229                     new String[] { &quot;java.logging&quot;, &quot;mV&quot;},
230                 }
231             }
232         };
233     }
234 
235     @Test(dataProvider = &quot;testregex&quot;)
236     public void testregex(String name, String[][] expected) throws Exception {
237         String cmd = String.format(&quot;jdeps --inverse --module-path %s -regex %s --add-modules %s%n&quot;,
238                 MODS_DIR, name, modules.stream().collect(Collectors.joining(&quot;,&quot;)));
239 
240         try (JdepsUtil.Command jdeps = JdepsUtil.newCommand(cmd)) {
241             jdeps.appModulePath(MODS_DIR.toString())
242                 .addmods(modules)
243                 .regex(name);
244 
245             runJdeps(jdeps, expected);
246         }
247     }
248 
249     @DataProvider(name = &quot;classpath&quot;)
250     public Object[][] expected4() {
251         return new Object[][] {
252             // -regex and result
253             { &quot;sun.misc.Unsafe&quot;, new String[][] {
254                     new String[] {&quot;jdk.unsupported&quot;, &quot;unsafe.jar&quot;, &quot;mVI.jar&quot;, &quot;mVII.jar&quot;},
255                     new String[] {&quot;jdk.unsupported&quot;, &quot;unsafe.jar&quot;, &quot;mVII.jar&quot;}
256                 }
257             },
258             { &quot;org.safe.Lib&quot;, new String[][] {
259                     new String[] { &quot;unsafe.jar&quot;, &quot;mVII.jar&quot;},
260                     new String[] { &quot;unsafe.jar&quot;, &quot;mVI.jar&quot;, &quot;mVII.jar&quot;},
261                 }
262             },
263             { &quot;java.util.logging.*|org.safe.Lib&quot;, new String[][] {
264                     new String[] { &quot;unsafe.jar&quot;, &quot;mVII.jar&quot;},
265                     new String[] { &quot;unsafe.jar&quot;, &quot;mVI.jar&quot;, &quot;mVII.jar&quot;},
266                     new String[] { &quot;java.logging&quot;, &quot;mV.jar&quot;},
267                 }
268             }
269         };
270     }
271 
272     @Test(dataProvider = &quot;classpath&quot;)
273     public void testClassPath(String name, String[][] expected) throws Exception {
274         // -classpath
275         String cpath = modules.stream()
276             .filter(mn -&gt; !mn.equals(&quot;mVII&quot;))
277             .map(mn -&gt; LIBS_DIR.resolve(mn + &quot;.jar&quot;).toString())
278             .collect(Collectors.joining(File.pathSeparator));
279 
280         Path jarfile = LIBS_DIR.resolve(&quot;mVII.jar&quot;);
281 
282         String cmd1 = String.format(&quot;jdeps --inverse -classpath %s -regex %s %s%n&quot;,
283             cpath, name, jarfile);
284         try (JdepsUtil.Command jdeps = JdepsUtil.newCommand(cmd1)) {
285             jdeps.verbose(&quot;-verbose:class&quot;)
286                 .addClassPath(cpath)
287                 .regex(name).addRoot(jarfile);
288             runJdeps(jdeps, expected);
289         }
290 
291         // all JAR files on the command-line arguments
292         Set&lt;Path&gt; paths = modules.stream()
293                                  .map(mn -&gt; LIBS_DIR.resolve(mn + &quot;.jar&quot;))
294                                  .collect(Collectors.toSet());
295         String cmd2 = String.format(&quot;jdeps --inverse -regex %s %s%n&quot;, name, paths);
296         try (JdepsUtil.Command jdeps = JdepsUtil.newCommand(cmd2)) {
297             jdeps.verbose(&quot;-verbose:class&quot;).regex(name);
298             paths.forEach(jdeps::addRoot);
299             runJdeps(jdeps, expected);
300         }
301     }
302 
303     private void runJdeps(JdepsUtil.Command jdeps, String[][] expected)  throws Exception {
304         InverseDepsAnalyzer analyzer = jdeps.getInverseDepsAnalyzer();
305 
306         assertTrue(analyzer.run());
307 
308         // get the inverse transitive dependences
309         List&lt;String[]&gt; paths = analyzer.inverseDependences().stream()
310             .map(deque -&gt; deque.stream()
311                                .map(Archive::getName)
312                                .collect(Collectors.toList()).toArray(new String[0]))
313             .collect(Collectors.toList());
314 
315         jdeps.dumpOutput(System.err);
316         paths.forEach(path -&gt; System.err.println(Arrays.stream(path)
317                 .collect(Collectors.joining(&quot; &lt;- &quot;))));
318 
319         // verify the dependences
320         assertEquals(paths.size(), expected.length);
321 
322         for (int i=0; i &lt; paths.size(); i++) {
323             String[] path = paths.get(i);
324             boolean noneMatched = Arrays.stream(expected)
325                     .filter(array -&gt; array.length == path.length)
326                     .noneMatch(array -&gt; Arrays.equals(array, path));
327             if (noneMatched)
328                 System.err.format(&quot;Expected: %s found: %s%n&quot;,
329                                   Arrays.stream(expected)
330                                       .map(Arrays::toString)
331                                       .collect(Collectors.joining(&quot;, &quot;)),
332                     Arrays.toString(path));
333 
334             assertFalse(noneMatched);
335         }
336     }
337 
338 }
    </pre>
  </body>
</html>
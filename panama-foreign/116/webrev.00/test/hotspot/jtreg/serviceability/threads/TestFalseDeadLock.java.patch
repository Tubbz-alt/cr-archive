diff a/test/hotspot/jtreg/serviceability/threads/TestFalseDeadLock.java b/test/hotspot/jtreg/serviceability/threads/TestFalseDeadLock.java
--- a/test/hotspot/jtreg/serviceability/threads/TestFalseDeadLock.java
+++ b/test/hotspot/jtreg/serviceability/threads/TestFalseDeadLock.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -26,10 +26,11 @@
 import java.lang.management.ThreadMXBean;
 import java.util.Random;
 
 /*
  * @test
+ * @key randomness
  * @bug 8016304
  * @summary Make sure no deadlock is reported for this program which has no deadlocks.
  * @modules java.base/jdk.internal.misc
  * @library /test/lib
  * @run main/othervm TestFalseDeadLock
@@ -46,12 +47,13 @@
     private static volatile boolean found = false;
 
     public static void main(String[] args) throws Exception {
         bean = ManagementFactory.getThreadMXBean();
         Thread[] threads = new Thread[500];
+        Random random = Utils.getRandomInstance();
         for (int i = 0; i < threads.length; i++) {
-            Test t = new Test();
+            Test t = new Test(random.nextLong());
             threads[i] = new Thread(t);
             threads[i].start();
         }
         try {
             Thread.sleep(5000);
@@ -65,12 +67,16 @@
             throw new Exception("Deadlock reported, but there is no deadlock.");
         }
     }
 
     public static class Test implements Runnable {
+        private final long seed;
+        public Test(long seed) {
+            this.seed = seed;
+        }
         public void run() {
-            Random r = Utils.getRandomInstance();
+            Random r = new Random(seed);
             while (running) {
                 try {
                     synchronized (this) {
                         wait(r.nextInt(1000) + 1);
                     }

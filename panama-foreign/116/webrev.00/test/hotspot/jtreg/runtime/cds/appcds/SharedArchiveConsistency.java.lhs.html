<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/runtime/cds/appcds/SharedArchiveConsistency.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 /*
 26  * @test
<a name="1" id="anc1"></a>
 27  * @summary SharedArchiveConsistency
 28  * @requires vm.cds
 29  * @library /test/lib
 30  * @build sun.hotspot.WhiteBox
 31  * @compile test-classes/Hello.java
 32  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 33  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI SharedArchiveConsistency
 34  */
 35 import jdk.test.lib.process.OutputAnalyzer;
 36 import jdk.test.lib.Utils;
 37 import java.io.File;
 38 import java.io.FileInputStream;
 39 import java.io.FileOutputStream;
 40 import java.io.IOException;
 41 import java.nio.ByteBuffer;
 42 import java.nio.ByteOrder;
 43 import java.nio.channels.FileChannel;
 44 import java.nio.file.Files;
 45 import java.nio.file.Path;
 46 import java.nio.file.Paths;
 47 import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
 48 import java.nio.file.StandardOpenOption;
 49 import static java.nio.file.StandardOpenOption.READ;
 50 import static java.nio.file.StandardOpenOption.WRITE;
 51 import java.util.ArrayList;
 52 import java.util.HashSet;
 53 import java.util.List;
 54 import java.util.Random;
 55 import sun.hotspot.WhiteBox;
 56 
 57 public class SharedArchiveConsistency {
 58     public static WhiteBox wb;
 59     public static int offset_magic;     // CDSFileMapHeaderBase::_magic
 60     public static int offset_version;   // CDSFileMapHeaderBase::_version
 61     public static int offset_jvm_ident; // FileMapHeader::_jvm_ident
 62     public static int sp_offset_crc;    // CDSFileMapRegion::_crc
 63     public static int file_header_size = -1;// total size of header, variant, need calculation
 64     public static int CDSFileMapRegion_size; // size of CDSFileMapRegion
 65     public static int sp_offset;       // offset of CDSFileMapRegion
 66     public static int sp_used_offset;  // offset of CDSFileMapRegion::_used
 67     public static int size_t_size;     // size of size_t
 68     public static int int_size;        // size of int
 69 
 70     public static File jsa;        // will be updated during test
 71     public static File orgJsaFile; // kept the original file not touched.
 72     // The following should be consistent with the enum in the C++ MetaspaceShared class
 73     public static String[] shared_region_name = {
 74         &quot;mc&quot;,          // MiscCode
 75         &quot;rw&quot;,          // ReadWrite
 76         &quot;ro&quot;,          // ReadOnly
 77         &quot;bm&quot;,          // relocation bitmaps
 78         &quot;first_closed_archive&quot;,
 79         &quot;last_closed_archive&quot;,
 80         &quot;first_open_archive&quot;,
 81         &quot;last_open_archive&quot;
 82     };
 83 
 84     public static int num_regions = shared_region_name.length;
 85     public static String[] matchMessages = {
 86         &quot;Unable to use shared archive&quot;,
 87         &quot;An error has occurred while processing the shared archive file.&quot;,
 88         &quot;Checksum verification failed.&quot;,
 89         &quot;The shared archive file has been truncated.&quot;
 90     };
 91 
 92     public static void getFileOffsetInfo() throws Exception {
 93         wb = WhiteBox.getWhiteBox();
 94         offset_magic = wb.getOffsetForName(&quot;FileMapHeader::_magic&quot;);
 95         offset_version = wb.getOffsetForName(&quot;FileMapHeader::_version&quot;);
 96         offset_jvm_ident = wb.getOffsetForName(&quot;FileMapHeader::_jvm_ident&quot;);
 97         sp_offset_crc = wb.getOffsetForName(&quot;CDSFileMapRegion::_crc&quot;);
 98         try {
 99             int nonExistOffset = wb.getOffsetForName(&quot;FileMapHeader::_non_exist_offset&quot;);
100             System.exit(-1); // should fail
101         } catch (Exception e) {
102             // success
103         }
104 
105         sp_offset = wb.getOffsetForName(&quot;FileMapHeader::_space[0]&quot;) - offset_magic;
106         sp_used_offset = wb.getOffsetForName(&quot;CDSFileMapRegion::_used&quot;) - sp_offset_crc;
107         size_t_size = wb.getOffsetForName(&quot;size_t_size&quot;);
108         CDSFileMapRegion_size  = wb.getOffsetForName(&quot;CDSFileMapRegion_size&quot;);
109     }
110 
111     public static int getFileHeaderSize(FileChannel fc) throws Exception {
112         if (file_header_size != -1) {
113             return file_header_size;
114         }
115         // this is not real header size, it is struct size
116         int_size = wb.getOffsetForName(&quot;int_size&quot;);
117         file_header_size = wb.getOffsetForName(&quot;file_header_size&quot;);
118         System.out.println(&quot;file_header_size      = &quot; + file_header_size);
119         file_header_size = (int)align_up_page(file_header_size);
120         System.out.println(&quot;file_header_size (aligned to page) = &quot; + file_header_size);
121         return file_header_size;
122     }
123 
124     public static long align_up_page(long l) throws Exception {
125         // wb is obtained in getFileOffsetInfo() which is called first in main() else we should call
126         // WhiteBox.getWhiteBox() here first.
127         int pageSize = wb.getVMPageSize();
128         return (l + pageSize -1) &amp; (~ (pageSize - 1));
129     }
130 
131     private static long getRandomBetween(long start, long end) throws Exception {
132         if (start &gt; end) {
133             throw new IllegalArgumentException(&quot;start must be less than end&quot;);
134         }
135         Random aRandom = Utils.getRandomInstance();
136         int d = aRandom.nextInt((int)(end - start));
137         if (d &lt; 1) {
138             d = 1;
139         }
140         return start + d;
141     }
142 
143     public static long readInt(FileChannel fc, long offset, int nbytes) throws Exception {
144         ByteBuffer bb = ByteBuffer.allocate(nbytes);
145         bb.order(ByteOrder.nativeOrder());
146         fc.position(offset);
147         fc.read(bb);
148         return  (nbytes &gt; 4 ? bb.getLong(0) : bb.getInt(0));
149     }
150 
151     public static void writeData(FileChannel fc, long offset, ByteBuffer bb) throws Exception {
152         fc.position(offset);
153         fc.write(bb);
154     }
155 
156     public static FileChannel getFileChannel(File jsaFile) throws Exception {
157         List&lt;StandardOpenOption&gt; arry = new ArrayList&lt;StandardOpenOption&gt;();
158         arry.add(READ);
159         arry.add(WRITE);
160         return FileChannel.open(jsaFile.toPath(), new HashSet&lt;StandardOpenOption&gt;(arry));
161     }
162 
163     public static void modifyJsaContentRandomly(File jsaFile) throws Exception {
164         FileChannel fc = getFileChannel(jsaFile);
165         // corrupt random area in the data areas
166         long[] used    = new long[num_regions];       // record used bytes
167         long start0, start, end, off;
168         int used_offset, path_info_size;
169 
170         int bufSize;
171         System.out.printf(&quot;%-24s%12s%12s%16s\n&quot;, &quot;Space Name&quot;, &quot;Used bytes&quot;, &quot;Reg Start&quot;, &quot;Random Offset&quot;);
172         start0 = getFileHeaderSize(fc);
173         for (int i = 0; i &lt; num_regions; i++) {
174             used[i] = get_region_used_size_aligned(fc, i);
175             start = start0;
176             for (int j = 0; j &lt; i; j++) {
177                 start += align_up_page(used[j]);
178             }
179             end = start + used[i];
180             if (start == end) {
181                 continue; // Ignore empty regions
182             }
183             off = getRandomBetween(start, end);
184             System.out.printf(&quot;%-24s%12d%12d%16d\n&quot;, shared_region_name[i], used[i], start, off);
185             if (end - off &lt; 1024) {
186                 bufSize = (int)(end - off + 1);
187             } else {
188                 bufSize = 1024;
189             }
190             ByteBuffer bbuf = ByteBuffer.wrap(new byte[bufSize]);
191             writeData(fc, off, bbuf);
192         }
193         if (fc.isOpen()) {
194             fc.close();
195         }
196     }
197 
198     static long get_region_used_size_aligned(FileChannel fc, int region) throws Exception {
199         long n = sp_offset + CDSFileMapRegion_size * region + sp_used_offset;
200         long alignment = WhiteBox.getWhiteBox().metaspaceReserveAlignment();
201         long used = readInt(fc, n, size_t_size);
202         used = (used + alignment - 1) &amp; ~(alignment - 1);
203         return used;
204     }
205 
206     public static boolean modifyJsaContent(int region, File jsaFile) throws Exception {
207         FileChannel fc = getFileChannel(jsaFile);
208         byte[] buf = new byte[4096];
209         ByteBuffer bbuf = ByteBuffer.wrap(buf);
210 
211         long total = 0L;
212         long[] used = new long[num_regions];
213         System.out.printf(&quot;%-24s%12s\n&quot;, &quot;Space name&quot;, &quot;Used bytes&quot;);
214         for (int i = 0; i &lt; num_regions; i++) {
215             used[i] = get_region_used_size_aligned(fc, i);
216             System.out.printf(&quot;%-24s%12d\n&quot;, shared_region_name[i], used[i]);
217             total += used[i];
218         }
219         System.out.printf(&quot;%-24s%12d\n&quot;, &quot;Total: &quot;, total);
220         long header_size = getFileHeaderSize(fc);
221         long region_start_offset = header_size;
222         for (int i=0; i&lt;region; i++) {
223             region_start_offset += used[i];
224         }
225         if (used[region] == 0) {
226             System.out.println(&quot;Region &quot; + shared_region_name[region] + &quot; is empty. Nothing to corrupt.&quot;);
227             return false;
228         }
229         System.out.println(&quot;Corrupt &quot; + shared_region_name[region] + &quot; section, start = &quot; + region_start_offset
230                            + &quot; (header_size + 0x&quot; + Long.toHexString(region_start_offset-header_size) + &quot;)&quot;);
231         long bytes_written = 0L;
232         while (bytes_written &lt; used[region]) {
233             writeData(fc, region_start_offset + bytes_written, bbuf);
234             bbuf.clear();
235             bytes_written += 4096;
236         }
237         if (fc.isOpen()) {
238             fc.close();
239         }
240         return true;
241     }
242 
243     public static void modifyJsaHeader(File jsaFile) throws Exception {
244         FileChannel fc = getFileChannel(jsaFile);
245         // screw up header info
246         byte[] buf = new byte[getFileHeaderSize(fc)];
247         ByteBuffer bbuf = ByteBuffer.wrap(buf);
248         writeData(fc, 0L, bbuf);
249         if (fc.isOpen()) {
250             fc.close();
251         }
252     }
253 
254     public static void modifyJvmIdent() throws Exception {
255         FileChannel fc = getFileChannel(jsa);
256         int headerSize = getFileHeaderSize(fc);
257         System.out.println(&quot;    offset_jvm_ident &quot; + offset_jvm_ident);
258         byte[] buf = new byte[256];
259         ByteBuffer bbuf = ByteBuffer.wrap(buf);
260         writeData(fc, (long)offset_jvm_ident, bbuf);
261         if (fc.isOpen()) {
262             fc.close();
263         }
264     }
265 
266     public static void modifyHeaderIntField(long offset, int value) throws Exception {
267         FileChannel fc = getFileChannel(jsa);
268         int headerSize = getFileHeaderSize(fc);
269         System.out.println(&quot;    offset &quot; + offset);
270         byte[] buf = ByteBuffer.allocate(4).putInt(value).array();
271         ByteBuffer bbuf = ByteBuffer.wrap(buf);
272         writeData(fc, offset, bbuf);
273         if (fc.isOpen()) {
274             fc.close();
275         }
276     }
277 
278     public static void copyFile(File from, File to) throws Exception {
279         if (to.exists()) {
280             if(!to.delete()) {
281                 throw new IOException(&quot;Could not delete file &quot; + to);
282             }
283         }
284         to.createNewFile();
285         setReadWritePermission(to);
286         Files.copy(from.toPath(), to.toPath(), REPLACE_EXISTING);
287     }
288 
289     // Copy file with bytes deleted or inserted
290     // del -- true, deleted, false, inserted
291     public static void copyFile(File from, File to, boolean del) throws Exception {
292         try (
293             FileChannel inputChannel = new FileInputStream(from).getChannel();
294             FileChannel outputChannel = new FileOutputStream(to).getChannel()
295         ) {
296             long size = inputChannel.size();
297             int init_size = getFileHeaderSize(inputChannel);
298             outputChannel.transferFrom(inputChannel, 0, init_size);
299             int n = (int)getRandomBetween(0, 1024);
300             if (del) {
301                 System.out.println(&quot;Delete &quot; + n + &quot; bytes at data start section&quot;);
302                 inputChannel.position(init_size + n);
303                 outputChannel.transferFrom(inputChannel, init_size, size - init_size - n);
304             } else {
305                 System.out.println(&quot;Insert &quot; + n + &quot; bytes at data start section&quot;);
306                 outputChannel.position(init_size);
307                 outputChannel.write(ByteBuffer.wrap(new byte[n]));
308                 outputChannel.transferFrom(inputChannel, init_size + n , size - init_size);
309             }
310         }
311     }
312 
313     public static void restoreJsaFile() throws Exception {
314         Files.copy(orgJsaFile.toPath(), jsa.toPath(), REPLACE_EXISTING);
315     }
316 
317     public static void setReadWritePermission(File file) throws Exception {
318         if (!file.canRead()) {
319             if (!file.setReadable(true)) {
320                 throw new IOException(&quot;Cannot modify file &quot; + file + &quot; as readable&quot;);
321             }
322         }
323         if (!file.canWrite()) {
324             if (!file.setWritable(true)) {
325                 throw new IOException(&quot;Cannot modify file &quot; + file + &quot; as writable&quot;);
326             }
327         }
328     }
329 
330     public static void testAndCheck(String[] execArgs) throws Exception {
331         OutputAnalyzer output = TestCommon.execCommon(execArgs);
332         String stdtxt = output.getOutput();
333         System.out.println(&quot;Note: this test may fail in very rare occasions due to CRC32 checksum collision&quot;);
334         for (String message : matchMessages) {
335             if (stdtxt.contains(message)) {
336                 // match any to return
337                 return;
338             }
339         }
340         TestCommon.checkExec(output);
341     }
342 
343     // dump with hello.jsa, then
344     // read the jsa file
345     //   1) run normal
346     //   2) modify header
347     //   3) keep header correct but modify content in each region specified by shared_region_name[]
348     //   4) update both header and content, test
349     //   5) delete bytes in data begining
350     //   6) insert bytes in data begining
351     //   7) randomly corrupt data in each region specified by shared_region_name[]
352     public static void main(String... args) throws Exception {
353         // must call to get offset info first!!!
354         getFileOffsetInfo();
355         Path currentRelativePath = Paths.get(&quot;&quot;);
356         String currentDir = currentRelativePath.toAbsolutePath().toString();
357         System.out.println(&quot;Current relative path is: &quot; + currentDir);
358         // get jar file
359         String jarFile = JarBuilder.getOrCreateHelloJar();
360 
361         // dump (appcds.jsa created)
362         TestCommon.testDump(jarFile, null);
363 
364         // test, should pass
365         System.out.println(&quot;1. Normal, should pass but may fail\n&quot;);
366 
367         String[] execArgs = {&quot;-Xlog:cds&quot;, &quot;-cp&quot;, jarFile, &quot;Hello&quot;};
368         // tests that corrupt contents of the archive need to run with
369         // VerifySharedSpaces enabled to detect inconsistencies
370         String[] verifyExecArgs = {&quot;-Xlog:cds&quot;, &quot;-XX:+VerifySharedSpaces&quot;, &quot;-cp&quot;, jarFile, &quot;Hello&quot;};
371 
372         OutputAnalyzer output = TestCommon.execCommon(execArgs);
373 
374         try {
375             TestCommon.checkExecReturn(output, 0, true, &quot;Hello World&quot;);
376         } catch (Exception e) {
377             TestCommon.checkExecReturn(output, 1, true, matchMessages[0]);
378         }
379 
380         // get current archive name
381         jsa = new File(TestCommon.getCurrentArchiveName());
382         if (!jsa.exists()) {
383             throw new IOException(jsa + &quot; does not exist!&quot;);
384         }
385 
386         setReadWritePermission(jsa);
387 
388         // save as original untouched
389         orgJsaFile = new File(new File(currentDir), &quot;appcds.jsa.bak&quot;);
390         copyFile(jsa, orgJsaFile);
391 
392         // modify jsa header, test should fail
393         System.out.println(&quot;\n2. Corrupt header, should fail\n&quot;);
394         modifyJsaHeader(jsa);
395         output = TestCommon.execCommon(execArgs);
396         output.shouldContain(&quot;The shared archive file has a bad magic number&quot;);
397         output.shouldNotContain(&quot;Checksum verification failed&quot;);
398 
399         copyFile(orgJsaFile, jsa);
400         // modify _jvm_ident, test should fail
401         System.out.println(&quot;\n2a. Corrupt _jvm_ident, should fail\n&quot;);
402         modifyJvmIdent();
403         output = TestCommon.execCommon(execArgs);
404         output.shouldContain(&quot;The shared archive file was created by a different version or build of HotSpot&quot;);
405         output.shouldNotContain(&quot;Checksum verification failed&quot;);
406 
407         copyFile(orgJsaFile, jsa);
408         // modify _jvm_ident and run with -Xshare:auto
409         System.out.println(&quot;\n2b. Corrupt _jvm_ident run with -Xshare:auto\n&quot;);
410         modifyJvmIdent();
411         output = TestCommon.execAuto(execArgs);
412         output.shouldContain(&quot;The shared archive file was created by a different version or build of HotSpot&quot;);
413         output.shouldContain(&quot;Hello World&quot;);
414 
415         copyFile(orgJsaFile, jsa);
416         // modify _magic, test should fail
417         System.out.println(&quot;\n2c. Corrupt _magic, should fail\n&quot;);
418         modifyHeaderIntField(offset_magic, 0x00000000);
419         output = TestCommon.execCommon(execArgs);
420         output.shouldContain(&quot;The shared archive file has a bad magic number&quot;);
421         output.shouldNotContain(&quot;Checksum verification failed&quot;);
422 
423         copyFile(orgJsaFile, jsa);
424         // modify _version, test should fail
425         System.out.println(&quot;\n2d. Corrupt _version, should fail\n&quot;);
426         modifyHeaderIntField(offset_version, 0x00000000);
427         output = TestCommon.execCommon(execArgs);
428         output.shouldContain(&quot;The shared archive file has the wrong version&quot;);
429         output.shouldNotContain(&quot;Checksum verification failed&quot;);
430 
431         File newJsaFile = null;
432         // modify content
433         System.out.println(&quot;\n3. Corrupt Content, should fail\n&quot;);
434         for (int i=0; i&lt;num_regions; i++) {
435             newJsaFile = new File(TestCommon.getNewArchiveName(shared_region_name[i]));
436             copyFile(orgJsaFile, newJsaFile);
437             TestCommon.setCurrentArchiveName(newJsaFile.toString());
438             if (modifyJsaContent(i, newJsaFile)) {
439                 testAndCheck(verifyExecArgs);
440             }
441         }
442 
443         // modify both header and content, test should fail
444         System.out.println(&quot;\n4. Corrupt Header and Content, should fail\n&quot;);
445         newJsaFile = new File(TestCommon.getNewArchiveName(&quot;header-and-content&quot;));
446         copyFile(orgJsaFile, newJsaFile);
447         TestCommon.setCurrentArchiveName(newJsaFile.toString());
448         modifyJsaHeader(newJsaFile);
449         modifyJsaContent(0, newJsaFile);  // this will not be reached since failed on header change first
450         output = TestCommon.execCommon(execArgs);
451         output.shouldContain(&quot;The shared archive file has a bad magic number&quot;);
452         output.shouldNotContain(&quot;Checksum verification failed&quot;);
453 
454         // delete bytes in data section
455         System.out.println(&quot;\n5. Delete bytes at beginning of data section, should fail\n&quot;);
456         copyFile(orgJsaFile, jsa, true);
457         TestCommon.setCurrentArchiveName(jsa.toString());
458         testAndCheck(verifyExecArgs);
459 
460         // insert bytes in data section forward
461         System.out.println(&quot;\n6. Insert bytes at beginning of data section, should fail\n&quot;);
462         copyFile(orgJsaFile, jsa, false);
463         testAndCheck(verifyExecArgs);
464 
465         System.out.println(&quot;\n7. modify Content in random areas, should fail\n&quot;);
466         newJsaFile = new File(TestCommon.getNewArchiveName(&quot;random-areas&quot;));
467         copyFile(orgJsaFile, newJsaFile);
468         TestCommon.setCurrentArchiveName(newJsaFile.toString());
469         modifyJsaContentRandomly(newJsaFile);
470         testAndCheck(verifyExecArgs);
471     }
472 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
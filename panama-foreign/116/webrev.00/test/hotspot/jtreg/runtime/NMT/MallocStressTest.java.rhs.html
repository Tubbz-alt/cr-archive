<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/runtime/NMT/MallocStressTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Stress test for malloc tracking
<a name="2" id="anc2"></a><span class="line-modified"> 27  * @key nmt jcmd stress randomness</span>
 28  * @library /test/lib
 29  * @modules java.base/jdk.internal.misc
 30  *          java.management
 31  * @build sun.hotspot.WhiteBox
 32  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 33  * @run main/othervm/timeout=1200 -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail MallocStressTest
 34  */
 35 
 36 import java.util.concurrent.atomic.AtomicInteger;
 37 import java.util.ArrayList;
 38 import java.util.List;
 39 import java.util.Random;
 40 import jdk.test.lib.JDKToolFinder;
 41 import jdk.test.lib.Platform;
<a name="3" id="anc3"></a><span class="line-added"> 42 import jdk.test.lib.Utils;</span>
 43 import jdk.test.lib.process.ProcessTools;
 44 import jdk.test.lib.process.OutputAnalyzer;
 45 import sun.hotspot.WhiteBox;
 46 
 47 public class MallocStressTest {
 48     private static int K = 1024;
 49 
 50     // The stress test runs in three phases:
 51     // 1. alloc: A lot of malloc with fewer free, which simulates a burst memory allocation
 52     //    that is usually seen during startup or class loading.
 53     // 2. pause: Pause the test to check accuracy of native memory tracking
 54     // 3. release: Release all malloc&#39;d memory and check native memory tracking result.
 55     public enum TestPhase {
 56         alloc,
 57         pause,
 58         release
 59     };
 60 
 61     static volatile TestPhase phase = TestPhase.alloc;
 62 
 63     // malloc&#39;d memory
 64     static final ArrayList&lt;MallocMemory&gt;  mallocd_memory = new ArrayList&lt;MallocMemory&gt;();
 65     static long                     mallocd_total  = 0;
 66     static WhiteBox                 whiteBox;
 67     static AtomicInteger            pause_count = new AtomicInteger();
 68 
 69     static final boolean            is_64_bit_system = Platform.is64bit();
 70 
 71     private static boolean is_64_bit_system() { return is_64_bit_system; }
 72 
 73     public static void main(String args[]) throws Exception {
 74         OutputAnalyzer output;
 75         whiteBox = WhiteBox.getWhiteBox();
 76 
 77         // Grab my own PID
 78         String pid = Long.toString(ProcessTools.getProcessId());
 79         ProcessBuilder pb = new ProcessBuilder();
 80 
 81         AllocThread[]   alloc_threads = new AllocThread[40];
 82         ReleaseThread[] release_threads = new ReleaseThread[10];
 83 
 84         int index;
 85         // Create many allocation threads
 86         for (index = 0; index &lt; alloc_threads.length; index ++) {
 87             alloc_threads[index] = new AllocThread();
 88         }
 89 
 90         // Fewer release threads
 91         for (index = 0; index &lt; release_threads.length; index ++) {
 92             release_threads[index] = new ReleaseThread();
 93         }
 94 
 95         // pause the stress test
 96         phase = TestPhase.pause;
 97         while (pause_count.intValue() &lt;  alloc_threads.length + release_threads.length) {
 98             sleep_wait(10);
 99         }
100 
101         long mallocd_total_in_KB = (mallocd_total + K / 2) / K;
102 
103         // Now check if the result from NMT matches the total memory allocated.
104         String expected_test_summary = &quot;Test (reserved=&quot; + mallocd_total_in_KB +&quot;KB, committed=&quot; + mallocd_total_in_KB + &quot;KB)&quot;;
105         // Run &#39;jcmd &lt;pid&gt; VM.native_memory summary&#39;
106         pb.command(new String[] { JDKToolFinder.getJDKTool(&quot;jcmd&quot;), pid, &quot;VM.native_memory&quot;, &quot;summary&quot;});
107         output = new OutputAnalyzer(pb.start());
108         output.shouldContain(expected_test_summary);
109 
110         // Release all allocated memory
111         phase = TestPhase.release;
112         synchronized(mallocd_memory) {
113             mallocd_memory.notifyAll();
114         }
115 
116         // Join all threads
117         for (index = 0; index &lt; alloc_threads.length; index ++) {
118             try {
119                 alloc_threads[index].join();
120             } catch (InterruptedException e) {
121             }
122         }
123 
124         for (index = 0; index &lt; release_threads.length; index ++) {
125             try {
126                 release_threads[index].join();
127             } catch (InterruptedException e) {
128             }
129         }
130 
131         // All test memory allocated should be released
132         output = new OutputAnalyzer(pb.start());
133         output.shouldNotContain(&quot;Test (reserved=&quot;);
134 
135         // Verify that tracking level has not been downgraded
136         pb.command(new String[] { JDKToolFinder.getJDKTool(&quot;jcmd&quot;), pid, &quot;VM.native_memory&quot;, &quot;statistics&quot;});
137         output = new OutputAnalyzer(pb.start());
138         output.shouldNotContain(&quot;Tracking level has been downgraded due to lack of resources&quot;);
139     }
140 
141     private static void sleep_wait(int n) {
142         try {
143             Thread.sleep(n);
144         } catch (InterruptedException e) {
145         }
146     }
147 
148 
149     static class MallocMemory {
150         private long  addr;
151         private int   size;
152 
153         MallocMemory(long addr, int size) {
154             this.addr = addr;
155             this.size = size;
156         }
157 
158         long addr()  { return this.addr; }
159         int  size()  { return this.size; }
160     }
161 
162     static class AllocThread extends Thread {
<a name="4" id="anc4"></a><span class="line-added">163         private final Random random = new Random(Utils.getRandomInstance().nextLong());</span>
164         AllocThread() {
165             this.setName(&quot;MallocThread&quot;);
166             this.start();
167         }
168 
169         // AllocThread only runs &quot;Alloc&quot; phase
170         public void run() {
<a name="5" id="anc5"></a>
171             // MallocStressTest.phase == TestPhase.alloc
172             for (int loops = 0; loops &lt; 100; loops++) {
173                 int r = random.nextInt(Integer.MAX_VALUE);
174                 // Only malloc small amount to avoid OOM
175                 int size = r % 32;
176                 if (is_64_bit_system()) {
177                     r = r % 32 * K;
178                 } else {
179                     r = r % 64;
180                 }
181                 if (size == 0) size = 1;
182                 long addr = MallocStressTest.whiteBox.NMTMallocWithPseudoStack(size, r);
183                 if (addr != 0) {
184                     try {
185                         MallocMemory mem = new MallocMemory(addr, size);
186                         synchronized(MallocStressTest.mallocd_memory) {
187                             MallocStressTest.mallocd_memory.add(mem);
188                             MallocStressTest.mallocd_total += size;
189                         }
190                     } catch (OutOfMemoryError e) {
191                         // Don&#39;t include this malloc memory because it didn&#39;t
192                         // get recorded in mallocd_memory list.
193                         MallocStressTest.whiteBox.NMTFree(addr);
194                         break;
195                     }
196                 } else {
197                     break;
198                 }
199             }
200             MallocStressTest.pause_count.incrementAndGet();
201         }
202     }
203 
204     static class ReleaseThread extends Thread {
<a name="6" id="anc6"></a><span class="line-modified">205         private final Random random = new Random(Utils.getRandomInstance().nextLong());</span>
206         ReleaseThread() {
207             this.setName(&quot;ReleaseThread&quot;);
208             this.start();
209         }
210 
211         public void run() {
212             while(true) {
213                 switch(MallocStressTest.phase) {
214                 case alloc:
215                     slow_release();
216                     break;
217                 case pause:
218                     enter_pause();
219                     break;
220                 case release:
221                     quick_release();
222                     return;
223                 }
224             }
225         }
226 
227         private void enter_pause() {
228             MallocStressTest.pause_count.incrementAndGet();
229             while (MallocStressTest.phase != MallocStressTest.TestPhase.release) {
230                 try {
231                     synchronized(MallocStressTest.mallocd_memory) {
232                         MallocStressTest.mallocd_memory.wait(10);
233                     }
234                 } catch (InterruptedException e) {
235                 }
236             }
237         }
238 
239         private void quick_release() {
240             List&lt;MallocMemory&gt; free_list;
241             while (true) {
242                 synchronized(MallocStressTest.mallocd_memory) {
243                     if (MallocStressTest.mallocd_memory.isEmpty()) return;
244                     int size =  Math.min(MallocStressTest.mallocd_memory.size(), 5000);
245                     List&lt;MallocMemory&gt; subList = MallocStressTest.mallocd_memory.subList(0, size);
246                     free_list = new ArrayList&lt;MallocMemory&gt;(subList);
247                     subList.clear();
248                 }
249                 for (int index = 0; index &lt; free_list.size(); index ++) {
250                     MallocMemory mem = free_list.get(index);
251                     MallocStressTest.whiteBox.NMTFree(mem.addr());
252                 }
253             }
254         }
255 
256         private void slow_release() {
257             try {
258                 Thread.sleep(10);
259             } catch (InterruptedException e) {
260             }
261             synchronized(MallocStressTest.mallocd_memory) {
262                 if (MallocStressTest.mallocd_memory.isEmpty()) return;
263                 int n = random.nextInt(MallocStressTest.mallocd_memory.size());
264                 MallocMemory mem = mallocd_memory.remove(n);
265                 MallocStressTest.whiteBox.NMTFree(mem.addr());
266                 MallocStressTest.mallocd_total -= mem.size();
267             }
268         }
269     }
270 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
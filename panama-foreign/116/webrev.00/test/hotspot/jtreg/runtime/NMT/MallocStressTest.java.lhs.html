<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/runtime/NMT/MallocStressTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Stress test for malloc tracking
<a name="2" id="anc2"></a><span class="line-modified"> 27  * @key nmt jcmd stress</span>
 28  * @library /test/lib
 29  * @modules java.base/jdk.internal.misc
 30  *          java.management
 31  * @build sun.hotspot.WhiteBox
 32  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 33  * @run main/othervm/timeout=1200 -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail MallocStressTest
 34  */
 35 
 36 import java.util.concurrent.atomic.AtomicInteger;
 37 import java.util.ArrayList;
 38 import java.util.List;
 39 import java.util.Random;
 40 import jdk.test.lib.JDKToolFinder;
 41 import jdk.test.lib.Platform;
<a name="3" id="anc3"></a>
 42 import jdk.test.lib.process.ProcessTools;
 43 import jdk.test.lib.process.OutputAnalyzer;
 44 import sun.hotspot.WhiteBox;
 45 
 46 public class MallocStressTest {
 47     private static int K = 1024;
 48 
 49     // The stress test runs in three phases:
 50     // 1. alloc: A lot of malloc with fewer free, which simulates a burst memory allocation
 51     //    that is usually seen during startup or class loading.
 52     // 2. pause: Pause the test to check accuracy of native memory tracking
 53     // 3. release: Release all malloc&#39;d memory and check native memory tracking result.
 54     public enum TestPhase {
 55         alloc,
 56         pause,
 57         release
 58     };
 59 
 60     static volatile TestPhase phase = TestPhase.alloc;
 61 
 62     // malloc&#39;d memory
 63     static final ArrayList&lt;MallocMemory&gt;  mallocd_memory = new ArrayList&lt;MallocMemory&gt;();
 64     static long                     mallocd_total  = 0;
 65     static WhiteBox                 whiteBox;
 66     static AtomicInteger            pause_count = new AtomicInteger();
 67 
 68     static final boolean            is_64_bit_system = Platform.is64bit();
 69 
 70     private static boolean is_64_bit_system() { return is_64_bit_system; }
 71 
 72     public static void main(String args[]) throws Exception {
 73         OutputAnalyzer output;
 74         whiteBox = WhiteBox.getWhiteBox();
 75 
 76         // Grab my own PID
 77         String pid = Long.toString(ProcessTools.getProcessId());
 78         ProcessBuilder pb = new ProcessBuilder();
 79 
 80         AllocThread[]   alloc_threads = new AllocThread[40];
 81         ReleaseThread[] release_threads = new ReleaseThread[10];
 82 
 83         int index;
 84         // Create many allocation threads
 85         for (index = 0; index &lt; alloc_threads.length; index ++) {
 86             alloc_threads[index] = new AllocThread();
 87         }
 88 
 89         // Fewer release threads
 90         for (index = 0; index &lt; release_threads.length; index ++) {
 91             release_threads[index] = new ReleaseThread();
 92         }
 93 
 94         // pause the stress test
 95         phase = TestPhase.pause;
 96         while (pause_count.intValue() &lt;  alloc_threads.length + release_threads.length) {
 97             sleep_wait(10);
 98         }
 99 
100         long mallocd_total_in_KB = (mallocd_total + K / 2) / K;
101 
102         // Now check if the result from NMT matches the total memory allocated.
103         String expected_test_summary = &quot;Test (reserved=&quot; + mallocd_total_in_KB +&quot;KB, committed=&quot; + mallocd_total_in_KB + &quot;KB)&quot;;
104         // Run &#39;jcmd &lt;pid&gt; VM.native_memory summary&#39;
105         pb.command(new String[] { JDKToolFinder.getJDKTool(&quot;jcmd&quot;), pid, &quot;VM.native_memory&quot;, &quot;summary&quot;});
106         output = new OutputAnalyzer(pb.start());
107         output.shouldContain(expected_test_summary);
108 
109         // Release all allocated memory
110         phase = TestPhase.release;
111         synchronized(mallocd_memory) {
112             mallocd_memory.notifyAll();
113         }
114 
115         // Join all threads
116         for (index = 0; index &lt; alloc_threads.length; index ++) {
117             try {
118                 alloc_threads[index].join();
119             } catch (InterruptedException e) {
120             }
121         }
122 
123         for (index = 0; index &lt; release_threads.length; index ++) {
124             try {
125                 release_threads[index].join();
126             } catch (InterruptedException e) {
127             }
128         }
129 
130         // All test memory allocated should be released
131         output = new OutputAnalyzer(pb.start());
132         output.shouldNotContain(&quot;Test (reserved=&quot;);
133 
134         // Verify that tracking level has not been downgraded
135         pb.command(new String[] { JDKToolFinder.getJDKTool(&quot;jcmd&quot;), pid, &quot;VM.native_memory&quot;, &quot;statistics&quot;});
136         output = new OutputAnalyzer(pb.start());
137         output.shouldNotContain(&quot;Tracking level has been downgraded due to lack of resources&quot;);
138     }
139 
140     private static void sleep_wait(int n) {
141         try {
142             Thread.sleep(n);
143         } catch (InterruptedException e) {
144         }
145     }
146 
147 
148     static class MallocMemory {
149         private long  addr;
150         private int   size;
151 
152         MallocMemory(long addr, int size) {
153             this.addr = addr;
154             this.size = size;
155         }
156 
157         long addr()  { return this.addr; }
158         int  size()  { return this.size; }
159     }
160 
161     static class AllocThread extends Thread {
<a name="4" id="anc4"></a>
162         AllocThread() {
163             this.setName(&quot;MallocThread&quot;);
164             this.start();
165         }
166 
167         // AllocThread only runs &quot;Alloc&quot; phase
168         public void run() {
<a name="5" id="anc5"></a><span class="line-removed">169             Random random = new Random();</span>
170             // MallocStressTest.phase == TestPhase.alloc
171             for (int loops = 0; loops &lt; 100; loops++) {
172                 int r = random.nextInt(Integer.MAX_VALUE);
173                 // Only malloc small amount to avoid OOM
174                 int size = r % 32;
175                 if (is_64_bit_system()) {
176                     r = r % 32 * K;
177                 } else {
178                     r = r % 64;
179                 }
180                 if (size == 0) size = 1;
181                 long addr = MallocStressTest.whiteBox.NMTMallocWithPseudoStack(size, r);
182                 if (addr != 0) {
183                     try {
184                         MallocMemory mem = new MallocMemory(addr, size);
185                         synchronized(MallocStressTest.mallocd_memory) {
186                             MallocStressTest.mallocd_memory.add(mem);
187                             MallocStressTest.mallocd_total += size;
188                         }
189                     } catch (OutOfMemoryError e) {
190                         // Don&#39;t include this malloc memory because it didn&#39;t
191                         // get recorded in mallocd_memory list.
192                         MallocStressTest.whiteBox.NMTFree(addr);
193                         break;
194                     }
195                 } else {
196                     break;
197                 }
198             }
199             MallocStressTest.pause_count.incrementAndGet();
200         }
201     }
202 
203     static class ReleaseThread extends Thread {
<a name="6" id="anc6"></a><span class="line-modified">204         private Random random = new Random();</span>
205         ReleaseThread() {
206             this.setName(&quot;ReleaseThread&quot;);
207             this.start();
208         }
209 
210         public void run() {
211             while(true) {
212                 switch(MallocStressTest.phase) {
213                 case alloc:
214                     slow_release();
215                     break;
216                 case pause:
217                     enter_pause();
218                     break;
219                 case release:
220                     quick_release();
221                     return;
222                 }
223             }
224         }
225 
226         private void enter_pause() {
227             MallocStressTest.pause_count.incrementAndGet();
228             while (MallocStressTest.phase != MallocStressTest.TestPhase.release) {
229                 try {
230                     synchronized(MallocStressTest.mallocd_memory) {
231                         MallocStressTest.mallocd_memory.wait(10);
232                     }
233                 } catch (InterruptedException e) {
234                 }
235             }
236         }
237 
238         private void quick_release() {
239             List&lt;MallocMemory&gt; free_list;
240             while (true) {
241                 synchronized(MallocStressTest.mallocd_memory) {
242                     if (MallocStressTest.mallocd_memory.isEmpty()) return;
243                     int size =  Math.min(MallocStressTest.mallocd_memory.size(), 5000);
244                     List&lt;MallocMemory&gt; subList = MallocStressTest.mallocd_memory.subList(0, size);
245                     free_list = new ArrayList&lt;MallocMemory&gt;(subList);
246                     subList.clear();
247                 }
248                 for (int index = 0; index &lt; free_list.size(); index ++) {
249                     MallocMemory mem = free_list.get(index);
250                     MallocStressTest.whiteBox.NMTFree(mem.addr());
251                 }
252             }
253         }
254 
255         private void slow_release() {
256             try {
257                 Thread.sleep(10);
258             } catch (InterruptedException e) {
259             }
260             synchronized(MallocStressTest.mallocd_memory) {
261                 if (MallocStressTest.mallocd_memory.isEmpty()) return;
262                 int n = random.nextInt(MallocStressTest.mallocd_memory.size());
263                 MallocMemory mem = mallocd_memory.remove(n);
264                 MallocStressTest.whiteBox.NMTFree(mem.addr());
265                 MallocStressTest.mallocd_total -= mem.size();
266             }
267         }
268     }
269 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
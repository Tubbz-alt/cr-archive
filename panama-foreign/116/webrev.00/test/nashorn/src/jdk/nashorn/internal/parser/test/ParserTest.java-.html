<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/nashorn/src/jdk/nashorn/internal/parser/test/ParserTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.parser.test;
 27 
 28 import static jdk.nashorn.internal.runtime.Source.readFully;
 29 import static jdk.nashorn.internal.runtime.Source.sourceFor;
 30 import java.io.File;
 31 import jdk.nashorn.internal.parser.Parser;
 32 import jdk.nashorn.internal.runtime.Context;
 33 import jdk.nashorn.internal.runtime.ErrorManager;
 34 import jdk.nashorn.internal.runtime.Source;
 35 import jdk.nashorn.internal.runtime.options.Options;
 36 import org.testng.Assert;
 37 import org.testng.annotations.AfterClass;
 38 import org.testng.annotations.BeforeClass;
 39 import org.testng.annotations.Test;
 40 
 41 /**
 42  * Run tests to check Nashorn&#39;s parser.
 43  */
 44 @SuppressWarnings(&quot;javadoc&quot;)
 45 public class ParserTest {
 46     private static final boolean VERBOSE   = Boolean.valueOf(System.getProperty(&quot;parsertest.verbose&quot;));
 47     private static final boolean TEST262   = Boolean.valueOf(System.getProperty(&quot;parsertest.test262&quot;));
 48 
 49     private static final String TEST_BASIC_DIR  = System.getProperty(&quot;test.basic.dir&quot;);
 50     private static final String TEST262_SUITE_DIR = System.getProperty(&quot;test262.suite.dir&quot;);
 51 
 52 
 53     interface TestFilter {
 54         public boolean exclude(File file, String content);
 55     }
 56 
 57     private static void log(final String msg) {
 58         org.testng.Reporter.log(msg, true);
 59     }
 60 
 61     private Context context;
 62 
 63     @BeforeClass
 64     public void setupTest() {
 65         final Options options = new Options(&quot;nashorn&quot;);
 66         options.set(&quot;parse.only&quot;, true);
 67         options.set(&quot;scripting&quot;, true);
 68         options.set(&quot;const.as.var&quot;, true);
 69 
 70         final ErrorManager errors = new ErrorManager();
 71         this.context = new Context(options, errors, Thread.currentThread().getContextClassLoader());
 72     }
 73 
 74     @AfterClass
 75     public void tearDownTest() {
 76         this.context = null;
 77     }
 78 
 79     @Test
 80     public void parseAllTests() {
 81         if (TEST262) {
 82             parseTestSet(TEST262_SUITE_DIR, new TestFilter() {
 83                 @Override
 84                 public boolean exclude(final File file, final String content) {
 85                     return content != null &amp;&amp; content.contains(&quot;@negative&quot;);
 86                 }
 87             });
 88         }
 89         parseTestSet(TEST_BASIC_DIR,  new TestFilter() {
 90             @Override
 91             public boolean exclude(final File file, final String content) {
 92                 return file.getName().equals(&quot;es6&quot;);
 93             }
 94         });
 95     }
 96 
 97     private void parseTestSet(final String testSet, final TestFilter filter) {
 98         passed  = 0;
 99         failed  = 0;
100         skipped = 0;
101 
102         final File testSetDir = new File(testSet);
103         if (! testSetDir.isDirectory()) {
104             log(&quot;WARNING: &quot; + testSetDir + &quot; not found or not a directory&quot;);
105             return;
106         }
107         log(testSetDir.getAbsolutePath());
108         parseJSDirectory(testSetDir, filter);
109 
110         log(testSet + &quot; parse done!&quot;);
111         log(&quot;parse ok: &quot; + passed);
112         log(&quot;parse failed: &quot; + failed);
113         log(&quot;parse skipped: &quot; + skipped);
114         if (failed != 0) {
115             Assert.fail(failed + &quot; tests failed to compile in &quot; + testSetDir.getAbsolutePath());
116         }
117     }
118 
119     // number of scripts that parsed fine
120     private int passed;
121     // number of scripts resulting in parse failure
122     private int failed;
123     // scripts that were skipped - all tests with @negative are
124     // skipped for now.
125     private int skipped;
126 
127     private void parseJSDirectory(final File dir, final TestFilter filter) {
128         if (filter != null &amp;&amp; filter.exclude(dir, null)) {
129             return;
130         }
131         for (final File f : dir.listFiles()) {
132             if (f.isDirectory()) {
133                 parseJSDirectory(f, filter);
134             } else if (f.getName().endsWith(&quot;.js&quot;)) {
135                 parseJSFile(f, filter);
136             }
137         }
138     }
139 
140     private void parseJSFile(final File file, final TestFilter filter) {
141         if (VERBOSE) {
142             log(&quot;Begin parsing &quot; + file.getAbsolutePath());
143         }
144 
145         try {
146             final char[] buffer = readFully(file);
147             boolean excluded = false;
148             if (filter != null) {
149                 final String content = new String(buffer);
150                 excluded = filter.exclude(file, content);
151             }
152 
153             if (excluded) {
154                 if (VERBOSE) {
155                     log(&quot;Skipping &quot; + file.getAbsolutePath());
156                 }
157                 skipped++;
158                 return;
159             }
160 
161             final ErrorManager errors = new ErrorManager() {
162                 @Override
163                 public void error(final String msg) {
164                     log(msg);
165                 }
166             };
167             errors.setLimit(0);
168             final Source source = sourceFor(file.getAbsolutePath(), buffer);
169             new Parser(context.getEnv(), source, errors, context.getEnv()._strict, null).parse();
170             if (errors.getNumberOfErrors() &gt; 0) {
171                 log(&quot;Parse failed: &quot; + file.getAbsolutePath());
172                 failed++;
173             } else {
174                 passed++;
175             }
176         } catch (final Throwable exp) {
177             exp.printStackTrace();
178             log(&quot;Parse failed: &quot; + file.getAbsolutePath() + &quot; : &quot; + exp);
179             if (VERBOSE) {
180                 exp.printStackTrace(System.out);
181             }
182             failed++;
183         }
184 
185         if (VERBOSE) {
186             log(&quot;Done parsing &quot; + file.getAbsolutePath());
187         }
188     }
189 }
    </pre>
  </body>
</html>
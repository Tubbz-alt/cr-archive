<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/nashorn/src/jdk/nashorn/api/scripting/test/ScriptObjectMirrorTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.api.scripting.test;
 27 
 28 import static org.testng.Assert.assertEquals;
 29 import static org.testng.Assert.assertFalse;
 30 import static org.testng.Assert.assertTrue;
 31 import static org.testng.Assert.fail;
 32 
 33 import java.nio.ByteBuffer;
 34 import java.util.HashMap;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.function.Function;
 38 import javax.script.Bindings;
 39 import javax.script.Invocable;
 40 import javax.script.ScriptContext;
 41 import javax.script.ScriptEngine;
 42 import javax.script.ScriptEngineManager;
 43 import javax.script.ScriptException;
 44 import jdk.nashorn.api.scripting.AbstractJSObject;
 45 import jdk.nashorn.api.scripting.JSObject;
 46 import jdk.nashorn.api.scripting.ScriptObjectMirror;
 47 import org.testng.annotations.Test;
 48 
 49 /**
 50  * Tests to check jdk.nashorn.api.scripting.ScriptObjectMirror API.
 51  *
 52  * @test
 53  * @run testng jdk.nashorn.api.scripting.test.ScriptObjectMirrorTest
 54  */
 55 @SuppressWarnings(&quot;javadoc&quot;)
 56 public class ScriptObjectMirrorTest {
 57 
 58     @SuppressWarnings(&quot;unchecked&quot;)
 59     @Test
 60     public void reflectionTest() throws ScriptException {
 61         final ScriptEngineManager m = new ScriptEngineManager();
 62         final ScriptEngine e = m.getEngineByName(&quot;nashorn&quot;);
 63 
 64         e.eval(&quot;var obj = { x: 344, y: &#39;nashorn&#39; }&quot;);
 65 
 66         int count = 0;
 67         Map&lt;Object, Object&gt; map = (Map&lt;Object, Object&gt;) e.get(&quot;obj&quot;);
 68         assertFalse(map.isEmpty());
 69         assertTrue(map.keySet().contains(&quot;x&quot;));
 70         assertTrue(map.containsKey(&quot;x&quot;));
 71         assertTrue(map.values().contains(&quot;nashorn&quot;));
 72         assertTrue(map.containsValue(&quot;nashorn&quot;));
 73         for (final Map.Entry&lt;?, ?&gt; ex : map.entrySet()) {
 74             final Object key = ex.getKey();
 75             if (key.equals(&quot;x&quot;)) {
 76                 assertTrue(344 == ((Number) ex.getValue()).doubleValue());
 77                 count++;
 78             } else if (key.equals(&quot;y&quot;)) {
 79                 assertEquals(ex.getValue(), &quot;nashorn&quot;);
 80                 count++;
 81             }
 82         }
 83         assertEquals(2, count);
 84         assertEquals(2, map.size());
 85 
 86         // add property
 87         map.put(&quot;z&quot;, &quot;hello&quot;);
 88         assertEquals(e.eval(&quot;obj.z&quot;), &quot;hello&quot;);
 89         assertEquals(map.get(&quot;z&quot;), &quot;hello&quot;);
 90         assertTrue(map.keySet().contains(&quot;z&quot;));
 91         assertTrue(map.containsKey(&quot;z&quot;));
 92         assertTrue(map.values().contains(&quot;hello&quot;));
 93         assertTrue(map.containsValue(&quot;hello&quot;));
 94         assertEquals(map.size(), 3);
 95 
 96         final Map&lt;Object, Object&gt; newMap = new HashMap&lt;&gt;();
 97         newMap.put(&quot;foo&quot;, 23.0);
 98         newMap.put(&quot;bar&quot;, true);
 99         map.putAll(newMap);
100 
101         assertEquals(e.eval(&quot;obj.foo&quot;), 23.0);
102         assertEquals(e.eval(&quot;obj.bar&quot;), true);
103 
104         // remove using map method
105         map.remove(&quot;foo&quot;);
106         assertEquals(e.eval(&quot;typeof obj.foo&quot;), &quot;undefined&quot;);
107 
108         count = 0;
109         e.eval(&quot;var arr = [ true, &#39;hello&#39; ]&quot;);
110         map = (Map&lt;Object, Object&gt;) e.get(&quot;arr&quot;);
111         assertFalse(map.isEmpty());
112         assertTrue(map.containsKey(&quot;length&quot;));
113         assertTrue(map.containsValue(&quot;hello&quot;));
114         for (final Map.Entry&lt;?, ?&gt; ex : map.entrySet()) {
115             final Object key = ex.getKey();
116             if (key.equals(&quot;0&quot;)) {
117                 assertEquals(ex.getValue(), Boolean.TRUE);
118                 count++;
119             } else if (key.equals(&quot;1&quot;)) {
120                 assertEquals(ex.getValue(), &quot;hello&quot;);
121                 count++;
122             }
123         }
124         assertEquals(count, 2);
125         assertEquals(map.size(), 2);
126 
127         // add element
128         map.put(&quot;2&quot;, &quot;world&quot;);
129         assertEquals(map.get(&quot;2&quot;), &quot;world&quot;);
130         assertEquals(map.size(), 3);
131 
132         // remove all
133         map.clear();
134         assertTrue(map.isEmpty());
135         assertEquals(e.eval(&quot;typeof arr[0]&quot;), &quot;undefined&quot;);
136         assertEquals(e.eval(&quot;typeof arr[1]&quot;), &quot;undefined&quot;);
137         assertEquals(e.eval(&quot;typeof arr[2]&quot;), &quot;undefined&quot;);
138     }
139 
140     @Test
141     public void jsobjectTest() {
142         final ScriptEngineManager m = new ScriptEngineManager();
143         final ScriptEngine e = m.getEngineByName(&quot;nashorn&quot;);
144         try {
145             e.eval(&quot;var obj = { &#39;1&#39;: &#39;world&#39;, func: function() { return this.bar; }, bar: &#39;hello&#39; }&quot;);
146             final ScriptObjectMirror obj = (ScriptObjectMirror) e.get(&quot;obj&quot;);
147 
148             // try basic get on existing properties
149             if (!obj.getMember(&quot;bar&quot;).equals(&quot;hello&quot;)) {
150                 fail(&quot;obj.bar != &#39;hello&#39;&quot;);
151             }
152 
153             if (!obj.getSlot(1).equals(&quot;world&quot;)) {
154                 fail(&quot;obj[1] != &#39;world&#39;&quot;);
155             }
156 
157             if (!obj.callMember(&quot;func&quot;, new Object[0]).equals(&quot;hello&quot;)) {
158                 fail(&quot;obj.func() != &#39;hello&#39;&quot;);
159             }
160 
161             // try setting properties
162             obj.setMember(&quot;bar&quot;, &quot;new-bar&quot;);
163             obj.setSlot(1, &quot;new-element-1&quot;);
164             if (!obj.getMember(&quot;bar&quot;).equals(&quot;new-bar&quot;)) {
165                 fail(&quot;obj.bar != &#39;new-bar&#39;&quot;);
166             }
167 
168             if (!obj.getSlot(1).equals(&quot;new-element-1&quot;)) {
169                 fail(&quot;obj[1] != &#39;new-element-1&#39;&quot;);
170             }
171 
172             // try adding properties
173             obj.setMember(&quot;prop&quot;, &quot;prop-value&quot;);
174             obj.setSlot(12, &quot;element-12&quot;);
175             if (!obj.getMember(&quot;prop&quot;).equals(&quot;prop-value&quot;)) {
176                 fail(&quot;obj.prop != &#39;prop-value&#39;&quot;);
177             }
178 
179             if (!obj.getSlot(12).equals(&quot;element-12&quot;)) {
180                 fail(&quot;obj[12] != &#39;element-12&#39;&quot;);
181             }
182 
183             // delete properties
184             obj.removeMember(&quot;prop&quot;);
185             if (&quot;prop-value&quot;.equals(obj.getMember(&quot;prop&quot;))) {
186                 fail(&quot;obj.prop is not deleted!&quot;);
187             }
188 
189             // Simple eval tests
190             assertEquals(obj.eval(&quot;typeof Object&quot;), &quot;function&quot;);
191             assertEquals(obj.eval(&quot;&#39;nashorn&#39;.substring(3)&quot;), &quot;horn&quot;);
192         } catch (final Exception exp) {
193             exp.printStackTrace();
194             fail(exp.getMessage());
195         }
196     }
197 
198     @Test
199     public void scriptObjectMirrorToStringTest() {
200         final ScriptEngineManager m = new ScriptEngineManager();
201         final ScriptEngine e = m.getEngineByName(&quot;nashorn&quot;);
202         try {
203             final Object obj = e.eval(&quot;new TypeError(&#39;wrong type&#39;)&quot;);
204             assertEquals(obj.toString(), &quot;TypeError: wrong type&quot;, &quot;toString returns wrong value&quot;);
205         } catch (final Throwable t) {
206             t.printStackTrace();
207             fail(t.getMessage());
208         }
209 
210         try {
211             final Object obj = e.eval(&quot;(function func() { print(&#39;hello&#39;); })&quot;);
212             assertEquals(obj.toString(), &quot;function func() { print(&#39;hello&#39;); }&quot;, &quot;toString returns wrong value&quot;);
213         } catch (final Throwable t) {
214             t.printStackTrace();
215             fail(t.getMessage());
216         }
217     }
218 
219     @Test
220     public void mirrorNewObjectGlobalFunctionTest() throws ScriptException {
221         final ScriptEngineManager m = new ScriptEngineManager();
222         final ScriptEngine e = m.getEngineByName(&quot;nashorn&quot;);
223         final ScriptEngine e2 = m.getEngineByName(&quot;nashorn&quot;);
224 
225         e.eval(&quot;function func() {}&quot;);
226         e2.put(&quot;foo&quot;, e.get(&quot;func&quot;));
227         final ScriptObjectMirror e2global = (ScriptObjectMirror)e2.eval(&quot;this&quot;);
228         final Object newObj = ((ScriptObjectMirror)e2global.getMember(&quot;foo&quot;)).newObject();
229         assertTrue(newObj instanceof ScriptObjectMirror);
230     }
231 
232     @Test
233     public void mirrorNewObjectInstanceFunctionTest() throws ScriptException {
234         final ScriptEngineManager m = new ScriptEngineManager();
235         final ScriptEngine e = m.getEngineByName(&quot;nashorn&quot;);
236         final ScriptEngine e2 = m.getEngineByName(&quot;nashorn&quot;);
237 
238         e.eval(&quot;function func() {}&quot;);
239         e2.put(&quot;func&quot;, e.get(&quot;func&quot;));
240         final ScriptObjectMirror e2obj = (ScriptObjectMirror)e2.eval(&quot;({ foo: func })&quot;);
241         final Object newObj = ((ScriptObjectMirror)e2obj.getMember(&quot;foo&quot;)).newObject();
242         assertTrue(newObj instanceof ScriptObjectMirror);
243     }
244 
245     @Test
246     public void indexPropertiesExternalBufferTest() throws ScriptException {
247         final ScriptEngineManager m = new ScriptEngineManager();
248         final ScriptEngine e = m.getEngineByName(&quot;nashorn&quot;);
249         final ScriptObjectMirror obj = (ScriptObjectMirror)e.eval(&quot;var obj = {}; obj&quot;);
250         final ByteBuffer buf = ByteBuffer.allocate(5);
251         int i;
252         for (i = 0; i &lt; 5; i++) {
253             buf.put(i, (byte)(i+10));
254         }
255         obj.setIndexedPropertiesToExternalArrayData(buf);
256 
257         for (i = 0; i &lt; 5; i++) {
258             assertEquals((byte)(i+10), ((Number)e.eval(&quot;obj[&quot; + i + &quot;]&quot;)).byteValue());
259         }
260 
261         e.eval(&quot;for (i = 0; i &lt; 5; i++) obj[i] = 0&quot;);
262         for (i = 0; i &lt; 5; i++) {
263             assertEquals((byte)0, ((Number)e.eval(&quot;obj[&quot; + i + &quot;]&quot;)).byteValue());
264             assertEquals((byte)0, buf.get(i));
265         }
266     }
267 
268     @Test
269     public void conversionTest() throws ScriptException {
270         final ScriptEngineManager m = new ScriptEngineManager();
271         final ScriptEngine e = m.getEngineByName(&quot;nashorn&quot;);
272         final ScriptObjectMirror arr = (ScriptObjectMirror)e.eval(&quot;[33, 45, 23]&quot;);
273         final int[] intArr = arr.to(int[].class);
274         assertEquals(intArr[0], 33);
275         assertEquals(intArr[1], 45);
276         assertEquals(intArr[2], 23);
277 
278         final List&lt;?&gt; list = arr.to(List.class);
279         assertEquals(list.get(0), 33);
280         assertEquals(list.get(1), 45);
281         assertEquals(list.get(2), 23);
282 
283         ScriptObjectMirror obj = (ScriptObjectMirror)e.eval(
284             &quot;({ valueOf: function() { return 42 } })&quot;);
285         assertEquals(42.0, obj.to(Double.class));
286 
287         obj = (ScriptObjectMirror)e.eval(
288             &quot;({ toString: function() { return &#39;foo&#39; } })&quot;);
289         assertEquals(&quot;foo&quot;, obj.to(String.class));
290     }
291 
292     // @bug 8044000: Access to undefined property yields &quot;null&quot; instead of &quot;undefined&quot;
293     @Test
294     public void mapScriptObjectMirrorCallsiteTest() throws ScriptException {
295         final ScriptEngineManager m = new ScriptEngineManager();
296         final ScriptEngine engine = m.getEngineByName(&quot;nashorn&quot;);
297         final String TEST_SCRIPT = &quot;typeof obj.foo&quot;;
298 
299         final Bindings global = engine.getContext().getBindings(ScriptContext.ENGINE_SCOPE);
300         engine.eval(&quot;var obj = java.util.Collections.emptyMap()&quot;);
301         // this will drive callsite &quot;obj.foo&quot; of TEST_SCRIPT
302         // to use &quot;obj instanceof Map&quot; as it&#39;s guard
303         engine.eval(TEST_SCRIPT, global);
304         // redefine &#39;obj&#39; to be a script object
305         engine.eval(&quot;obj = {}&quot;);
306 
307         final Bindings newGlobal = engine.createBindings();
308         // transfer &#39;obj&#39; from default global to new global
309         // new global will get a ScriptObjectMirror wrapping &#39;obj&#39;
310         newGlobal.put(&quot;obj&quot;, global.get(&quot;obj&quot;));
311 
312         // Every ScriptObjectMirror is a Map! If callsite &quot;obj.foo&quot;
313         // does not see the new &#39;obj&#39; is a ScriptObjectMirror, it&#39;ll
314         // continue to use Map&#39;s get(&quot;obj.foo&quot;) instead of ScriptObjectMirror&#39;s
315         // getMember(&quot;obj.foo&quot;) - thereby getting null instead of undefined
316         assertEquals(&quot;undefined&quot;, engine.eval(TEST_SCRIPT, newGlobal));
317     }
318 
319     public interface MirrorCheckExample {
320         Object test1(Object arg);
321         Object test2(Object arg);
322         boolean compare(Object o1, Object o2);
323     }
324 
325     // @bug 8053910: ScriptObjectMirror causing havoc with Invocation interface
326     @Test
327     public void checkMirrorToObject() throws Exception {
328         final ScriptEngineManager engineManager = new ScriptEngineManager();
329         final ScriptEngine engine = engineManager.getEngineByName(&quot;nashorn&quot;);
330         final Invocable invocable = (Invocable)engine;
331 
332         engine.eval(&quot;function test1(arg) { return { arg: arg }; }&quot;);
333         engine.eval(&quot;function test2(arg) { return arg; }&quot;);
334         engine.eval(&quot;function compare(arg1, arg2) { return arg1 == arg2; }&quot;);
335 
336         final Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
337         map.put(&quot;option&quot;, true);
338 
339         final MirrorCheckExample example = invocable.getInterface(MirrorCheckExample.class);
340 
341         final Object value1 = invocable.invokeFunction(&quot;test1&quot;, map);
342         final Object value2 = example.test1(map);
343         final Object value3 = invocable.invokeFunction(&quot;test2&quot;, value2);
344         final Object value4 = example.test2(value2);
345 
346         // check that Object type argument receives a ScriptObjectMirror
347         // when ScriptObject is passed
348         assertEquals(ScriptObjectMirror.class, value1.getClass());
349         assertEquals(ScriptObjectMirror.class, value2.getClass());
350         assertEquals(ScriptObjectMirror.class, value3.getClass());
351         assertEquals(ScriptObjectMirror.class, value4.getClass());
352         assertTrue((boolean)invocable.invokeFunction(&quot;compare&quot;, value1, value1));
353         assertTrue(example.compare(value1, value1));
354         assertTrue((boolean)invocable.invokeFunction(&quot;compare&quot;, value3, value4));
355         assertTrue(example.compare(value3, value4));
356     }
357 
358     // @bug 8053910: ScriptObjectMirror causing havoc with Invocation interface
359     @Test
360     public void mirrorUnwrapInterfaceMethod() throws Exception {
361         final ScriptEngineManager engineManager = new ScriptEngineManager();
362         final ScriptEngine engine = engineManager.getEngineByName(&quot;nashorn&quot;);
363         final Invocable invocable = (Invocable)engine;
364         engine.eval(&quot;function apply(obj) { &quot; +
365             &quot; return obj instanceof Packages.jdk.nashorn.api.scripting.ScriptObjectMirror; &quot; +
366             &quot;}&quot;);
367         @SuppressWarnings(&quot;unchecked&quot;)
368         final Function&lt;Object,Object&gt; func = invocable.getInterface(Function.class);
369         assertFalse((boolean)func.apply(engine.eval(&quot;({ x: 2 })&quot;)));
370     }
371 
372     // @bug 8055687: Wrong &quot;this&quot; passed to JSObject.eval call
373     @Test
374     public void checkThisForJSObjectEval() throws Exception {
375         final ScriptEngineManager engineManager = new ScriptEngineManager();
376         final ScriptEngine e = engineManager.getEngineByName(&quot;nashorn&quot;);
377         final JSObject jsobj = (JSObject)e.eval(&quot;({foo: 23, bar: &#39;hello&#39; })&quot;);
378         assertEquals(((Number)jsobj.eval(&quot;this.foo&quot;)).intValue(), 23);
379         assertEquals(jsobj.eval(&quot;this.bar&quot;), &quot;hello&quot;);
380         assertEquals(jsobj.eval(&quot;String(this)&quot;), &quot;[object Object]&quot;);
381         final Object global = e.eval(&quot;this&quot;);
382         assertFalse(global.equals(jsobj.eval(&quot;this&quot;)));
383     }
384 
385     @Test
386     public void topLevelAnonFuncStatement() throws Exception {
387         final ScriptEngineManager engineManager = new ScriptEngineManager();
388         final ScriptEngine e = engineManager.getEngineByName(&quot;nashorn&quot;);
389         final JSObject func = (JSObject)e.eval(&quot;function(x) { return x + &#39; world&#39; }&quot;);
390         assertTrue(func.isFunction());
391         assertEquals(func.call(e.eval(&quot;this&quot;), &quot;hello&quot;), &quot;hello world&quot;);
392     }
393 
394     // @bug 8170565: JSObject call() is passed undefined for the argument &#39;thiz&#39;
395     @Test
396     public void jsObjectThisTest() throws Exception {
397         final ScriptEngineManager engineManager = new ScriptEngineManager();
398         final ScriptEngine e = engineManager.getEngineByName(&quot;nashorn&quot;);
399         e.put(&quot;func&quot;, new AbstractJSObject() {
400             @Override
401             public boolean isFunction() { return true; }
402 
403             @Override
404             public Object call(Object thiz, Object...args) {
405                 return thiz;
406             }
407         });
408 
409         assertTrue((boolean)e.eval(&quot;func() === this&quot;));
410 
411         // check that there is no blind undefined-&gt;Global translation!
412         assertTrue((boolean)e.eval(&quot;typeof(Function.prototype.call.call(func, undefined)) == &#39;undefined&#39;&quot;));
413 
414         // make sure that strict functions don&#39;t get translated this for scope calls!
415         e.put(&quot;sfunc&quot;, new AbstractJSObject() {
416             @Override
417             public boolean isFunction() { return true; }
418 
419             @Override
420             public boolean isStrictFunction() { return true; }
421 
422             @Override
423             public Object call(Object thiz, Object...args) {
424                 return thiz;
425             }
426         });
427 
428         assertTrue((boolean)e.eval(&quot;typeof sfunc() == &#39;undefined&#39;&quot;));
429     }
430 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/nashorn/src/jdk/dynalink/linker/support/test/LookupTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.dynalink.linker.support.test;
 27 
 28 import java.lang.invoke.MethodHandle;
 29 import java.lang.invoke.MethodHandles;
 30 import java.lang.invoke.MethodType;
 31 import jdk.dynalink.linker.support.Lookup;
 32 import org.testng.Assert;
 33 import org.testng.annotations.DataProvider;
 34 import org.testng.annotations.Test;
 35 
 36 // Tests for jdk.dynalink.linker.support.Lookup class.
 37 
 38 public class LookupTest {
 39     private static final MethodHandles.Lookup MY_LOOKUP = MethodHandles.lookup();
 40 
 41     private static MethodHandles.Lookup getLookup(final boolean publicLookup) {
 42         return publicLookup? MethodHandles.publicLookup() : MY_LOOKUP;
 43     }
 44 
 45     // test constructors, methods used for lookup
 46     @SuppressWarnings(&quot;unused&quot;)
 47     public LookupTest() {}
 48 
 49     @SuppressWarnings(&quot;unused&quot;)
 50     private LookupTest(final int unused) {}
 51 
 52     @SuppressWarnings(&quot;unused&quot;)
 53     private void privateFunc() {}
 54 
 55     @SuppressWarnings(&quot;unused&quot;)
 56     protected void protectedFunc() {}
 57 
 58     @SuppressWarnings(&quot;unused&quot;)
 59     private static void privateStaticFunc() {}
 60 
 61     @SuppressWarnings(&quot;unused&quot;)
 62     private final int myIntField = 0;
 63 
 64     @SuppressWarnings(&quot;unused&quot;)
 65     @DataProvider
 66     private static Object[][] flags() {
 67         return new Object[][]{
 68             {Boolean.FALSE},
 69             {Boolean.TRUE}
 70         };
 71     }
 72 
 73     @Test(dataProvider = &quot;flags&quot;)
 74     public void unreflectTest(final boolean publicLookup) throws NoSuchMethodException {
 75         final MethodHandle mh = Lookup.unreflect(getLookup(publicLookup), LookupTest.class.getMethod(&quot;unreflectTest&quot;, Boolean.TYPE));
 76         Assert.assertNotNull(mh);
 77     }
 78 
 79     @Test
 80     public void unreflectTest2() throws NoSuchMethodException {
 81         final MethodHandle mh = Lookup.PUBLIC.unreflect(LookupTest.class.getMethod(&quot;unreflectTest&quot;, Boolean.TYPE));
 82         Assert.assertNotNull(mh);
 83     }
 84 
 85     @Test(dataProvider = &quot;flags&quot;)
 86     public void unreflectNegativeTest(final boolean publicLookup) throws NoSuchMethodException {
 87         try {
 88             final MethodHandle mh = Lookup.unreflect(getLookup(publicLookup),
 89                 LookupTest.class.getDeclaredMethod(&quot;privateFunc&quot;));
 90             if (publicLookup) {
 91                 throw new RuntimeException(&quot;should have thrown Error&quot;);
 92             }
 93             Assert.assertNotNull(mh);
 94         } catch (final Error err) {
 95             Assert.assertTrue(publicLookup);
 96             Assert.assertTrue(err instanceof NoSuchMethodError || err instanceof IllegalAccessError);
 97         }
 98     }
 99 
100     @Test
101     public void unreflectNegativeTest2() throws NoSuchMethodException {
102         try {
103             Lookup.PUBLIC.unreflect(LookupTest.class.getDeclaredMethod(&quot;privateFunc&quot;));
104             throw new RuntimeException(&quot;should have thrown Error&quot;);
105         } catch (final Error err) {
106             Assert.assertTrue(err instanceof NoSuchMethodError || err instanceof IllegalAccessError);
107         }
108     }
109 
110     @Test(dataProvider = &quot;flags&quot;)
111     public void unreflectConstructorTest(final boolean publicLookup) throws NoSuchMethodException {
112         final MethodHandle mh = Lookup.unreflectConstructor(getLookup(publicLookup), LookupTest.class.getConstructor());
113         Assert.assertNotNull(mh);
114     }
115 
116     @Test
117     public void unreflectConstructorTest2() throws NoSuchMethodException {
118         final MethodHandle mh = Lookup.PUBLIC.unreflectConstructor(LookupTest.class.getConstructor());
119         Assert.assertNotNull(mh);
120     }
121 
122     @Test(dataProvider = &quot;flags&quot;)
123     public void unreflectConstructorNegativeTest(final boolean publicLookup) throws NoSuchMethodException {
124         try {
125             final MethodHandle mh = Lookup.unreflectConstructor(getLookup(publicLookup),
126                 LookupTest.class.getDeclaredConstructor(Integer.TYPE));
127             if (publicLookup) {
128                 throw new RuntimeException(&quot;should have thrown Error&quot;);
129             }
130             Assert.assertNotNull(mh);
131         } catch (final Error err) {
132             Assert.assertTrue(publicLookup);
133             Assert.assertTrue(err instanceof NoSuchMethodError || err instanceof IllegalAccessError);
134         }
135     }
136 
137     @Test
138     public void unreflectConstructorNegativeTest2() throws NoSuchMethodException {
139         try {
140             Lookup.PUBLIC.unreflectConstructor(
141                 LookupTest.class.getDeclaredConstructor(Integer.TYPE));
142             throw new RuntimeException(&quot;should have thrown Error&quot;);
143         } catch (final Error err) {
144             Assert.assertTrue(err instanceof NoSuchMethodError || err instanceof IllegalAccessError);
145         }
146     }
147 
148     @Test(dataProvider = &quot;flags&quot;)
149     public void findOwnStaticTest(final boolean publicLookup) {
150         try {
151             final MethodHandle mh = Lookup.findOwnStatic(getLookup(publicLookup), &quot;getLookup&quot;,
152                     MethodHandles.Lookup.class, Boolean.TYPE);
153             if (publicLookup) {
154                 throw new RuntimeException(&quot;should have thrown Error&quot;);
155             }
156             Assert.assertNotNull(mh);
157         } catch (final Error err) {
158             Assert.assertTrue(publicLookup);
159             Assert.assertTrue(err instanceof NoSuchMethodError || err instanceof IllegalAccessError);
160         }
161     }
162 
163     @Test
164     public void findOwnStaticTest2() {
165         try {
166             Lookup.PUBLIC.findStatic(LookupTest.class, &quot;getLookup&quot;,
167                     MethodType.methodType(MethodHandles.Lookup.class, Boolean.TYPE));
168             throw new RuntimeException(&quot;should have thrown Error&quot;);
169         } catch (final Error err) {
170             Assert.assertTrue(err instanceof NoSuchMethodError || err instanceof IllegalAccessError);
171         }
172     }
173 
174     @Test(dataProvider = &quot;flags&quot;)
175     public void findOwnSepcialTest(final boolean publicLookup) {
176         try {
177             final MethodHandle mh = Lookup.findOwnSpecial(getLookup(publicLookup), &quot;privateFunc&quot;, Void.TYPE);
178             if (publicLookup) {
179                 throw new RuntimeException(&quot;should have thrown Error&quot;);
180             }
181             Assert.assertNotNull(mh);
182         } catch (final Error err) {
183             Assert.assertTrue(publicLookup);
184             Assert.assertTrue(err instanceof NoSuchMethodError || err instanceof IllegalAccessError);
185         }
186     }
187 
188     @Test
189     public void findOwnSepcialTest2() {
190         try {
191             Lookup.PUBLIC.findOwnSpecial(&quot;privateFunc&quot;, Void.TYPE);
192             throw new RuntimeException(&quot;should have thrown Error&quot;);
193         } catch (final Error err) {
194             Assert.assertTrue(err instanceof NoSuchMethodError || err instanceof IllegalAccessError);
195         }
196     }
197 
198     @Test(dataProvider = &quot;flags&quot;)
199     public void findGetterTest(final boolean publicLookup) {
200         try {
201             final MethodHandle mh = new Lookup(getLookup(publicLookup)).findGetter(LookupTest.class, &quot;myIntField&quot;, Integer.TYPE);
202             if (publicLookup) {
203                 throw new RuntimeException(&quot;should have thrown Error&quot;);
204             }
205             Assert.assertNotNull(mh);
206         } catch (final Error err) {
207             Assert.assertTrue(publicLookup);
208             Assert.assertTrue(err instanceof NoSuchMethodError || err instanceof IllegalAccessError);
209         }
210     }
211 
212     @Test
213     public void findGetterTest2() {
214         try {
215             Lookup.PUBLIC.findGetter(LookupTest.class, &quot;myIntField&quot;, Integer.TYPE);
216             throw new RuntimeException(&quot;should have thrown Error&quot;);
217         } catch (final Error err) {
218             Assert.assertTrue(err instanceof NoSuchMethodError || err instanceof IllegalAccessError);
219         }
220     }
221 
222     @Test(dataProvider = &quot;flags&quot;)
223     public void findVirtualTest(final boolean publicLookup) {
224         try {
225             final MethodHandle mh = new Lookup(getLookup(publicLookup)).findVirtual(LookupTest.class, &quot;protectedFunc&quot;,
226                     MethodType.methodType(Void.TYPE));
227             if (publicLookup) {
228                 throw new RuntimeException(&quot;should have thrown Error&quot;);
229             }
230             Assert.assertNotNull(mh);
231         } catch (final Error err) {
232             Assert.assertTrue(publicLookup);
233             Assert.assertTrue(err instanceof NoSuchMethodError || err instanceof IllegalAccessError);
234         }
235     }
236 
237     @Test
238     public void findVirtualTest2() {
239         try {
240             Lookup.PUBLIC.findVirtual(LookupTest.class, &quot;protectedFunc&quot;,
241                     MethodType.methodType(Void.TYPE));
242             throw new RuntimeException(&quot;should have thrown Error&quot;);
243         } catch (final Error err) {
244             Assert.assertTrue(err instanceof NoSuchMethodError || err instanceof IllegalAccessError);
245         }
246     }
247 
248     @Test(dataProvider = &quot;flags&quot;)
249     public void findStaticTest(final boolean publicLookup) {
250         try {
251             final MethodHandle mh = new Lookup(getLookup(publicLookup)).findStatic(LookupTest.class, &quot;privateStaticFunc&quot;,
252                     MethodType.methodType(Void.TYPE));
253             if (publicLookup) {
254                 throw new RuntimeException(&quot;should have thrown Error&quot;);
255             }
256             Assert.assertNotNull(mh);
257         } catch (final Error err) {
258             Assert.assertTrue(publicLookup);
259             Assert.assertTrue(err instanceof NoSuchMethodError || err instanceof IllegalAccessError);
260         }
261     }
262 
263     @Test
264     public void findStaticTest2() {
265         try {
266             Lookup.PUBLIC.findStatic(LookupTest.class, &quot;privateStaticFunc&quot;,
267                     MethodType.methodType(Void.TYPE));
268             throw new RuntimeException(&quot;should have thrown Error&quot;);
269         } catch (final Error err) {
270             Assert.assertTrue(err instanceof NoSuchMethodError || err instanceof IllegalAccessError);
271         }
272     }
273 }
    </pre>
  </body>
</html>
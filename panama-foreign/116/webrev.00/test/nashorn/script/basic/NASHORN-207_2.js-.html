<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/nashorn/script/basic/NASHORN-207_2.js</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * NASHORN-207 : Implement strict mode.
 26  *
 27  * @test
 28  * @run
 29  */
 30 
 31 // make sure that &#39;use strict&#39; as first directive inside eval
 32 // also works the same way (as eval called from strict mode caller).
 33 
 34 try {
 35     eval(&quot;&#39;use strict&#39;; foo = 4;&quot;);
 36     fail(&quot;#1 should have thrown ReferenceError&quot;);
 37 } catch (e) {
 38     if (! (e instanceof ReferenceError)) {
 39         fail(&quot;#2 expected ReferenceError but got &quot; + e);
 40     }
 41 }
 42 
 43 if (typeof foo !== &#39;undefined&#39;) {
 44     fail(&quot;#3 strict mode eval defined var in global scope!&quot;);
 45 }
 46 
 47 try {
 48     eval(&quot;&#39;use strict&#39;; var let = 23;&quot;);
 49     fail(&quot;#4 should have thrown SyntaxError&quot;);
 50 } catch (e) {
 51     if (! (e instanceof SyntaxError)) {
 52         fail(&quot;#5 SyntaxError expected but got &quot; + e);
 53     }
 54 }
 55 
 56 // non-strict mode, some of the future reserved words can be used
 57 // as identifiers. These include &quot;let&quot;, &quot;implements&quot;, &quot;yield&quot; etc.
 58 var let = 30;
 59 var implements = &quot;hello&quot;;
 60 function yield() {}
 61 function public() {}
 62 var private = false;
 63 var protected = &quot;hello&quot;;
 64 var interface = &quot;interface&quot;;
 65 function f(package) {}
 66 function static() {}
 67 
 68 // in strict mode, arguments does not alias named access
 69 function func(x, y) {
 70     &#39;use strict&#39;;
 71 
 72     if (x !== arguments[0]) {
 73         fail(&quot;#6 arguments[0] !== x&quot;);
 74     }
 75 
 76     if (y !== arguments[1]) {
 77         fail(&quot;#7 arguments[1] !== y&quot;);
 78     }
 79 
 80     arguments[0] = 1;
 81     arguments[1] = 2;
 82 
 83     if (x === arguments[0]) {
 84         fail(&quot;#8 arguments[0] === x after assignment to it&quot;);
 85     }
 86 
 87     if (y === arguments[1]) {
 88         fail(&quot;#9 arguments[1] === y after assignment to it &quot;);
 89     }
 90 }
 91 
 92 func();
 93 
 94 // functions can not be declared everywhere!!
 95 try {
 96     eval(&quot;&#39;use strict&#39;; if (true) { function func() {} }&quot;);
 97     fail(&quot;#10 should have thrown SyntaxError&quot;);
 98 } catch (e) {
 99     if (! (e instanceof SyntaxError)) {
100         fail(&quot;#11 SyntaxError expected got &quot; + e);
101     }
102 }
103 
104 // arguments.caller and arguments.callee can&#39;t read or written in strict mode
105 function func2() {
106     &#39;use strict&#39;;
107 
108     try {
109         print(arguments.callee);
110         fail(&quot;#12 arguments.callee should have thrown TypeError&quot;);
111     } catch (e) {
112         if (! (e instanceof TypeError)) {
113             fail(&quot;#13 TypeError expected, got &quot; + e);
114         }
115     }
116 
117     try {
118         print(arguments.caller);
119         fail(&quot;#14 arguments.caller should have thrown TypeError&quot;);
120     } catch (e) {
121         if (! (e instanceof TypeError)) {
122             fail(&quot;#15 TypeError expected, got &quot; + e);
123         }
124     }
125 
126     try {
127         arguments.caller = 10;
128         fail(&quot;#16 arguments.caller assign should have thrown TypeError&quot;);
129     } catch (e) {
130         if (! (e instanceof TypeError)) {
131             fail(&quot;#17 TypeError expected, got &quot; + e);
132         }
133     }
134 
135     try {
136         arguments.callee = true;
137         fail(&quot;#18 arguments.callee assign should have thrown TypeError&quot;);
138     } catch (e) {
139         if (! (e instanceof TypeError)) {
140             fail(&quot;#19 TypeError expected, got &quot; + e);
141         }
142     }
143 }
144 
145 func2();
146 
147 // func.caller and func.arguments can&#39;t read or written in strict mode
148 function func3() {
149     &#39;use strict&#39;;
150 
151     try {
152         print(func3.arguments);
153         fail(&quot;#20 func.arguments should have thrown TypeError&quot;);
154     } catch (e) {
155         if (! (e instanceof TypeError)) {
156             fail(&quot;#21 TypeError expected, got &quot; + e);
157         }
158     }
159 
160     try {
161         print(func3.caller);
162         fail(&quot;#22 func3.caller should have thrown TypeError&quot;);
163     } catch (e) {
164         if (! (e instanceof TypeError)) {
165             fail(&quot;#23 TypeError expected, got &quot; + e);
166         }
167     }
168 
169     try {
170         func3.arguments = 10;
171         fail(&quot;#24 func3.arguments assign should have thrown TypeError&quot;);
172     } catch (e) {
173         if (! (e instanceof TypeError)) {
174             fail(&quot;#25 TypeError expected, got &quot; + e);
175         }
176     }
177 
178     try {
179         func3.caller = true;
180         fail(&quot;#26 func3.caller assign should have thrown TypeError&quot;);
181     } catch (e) {
182         if (! (e instanceof TypeError)) {
183             fail(&quot;#27 TypeError expected, got &quot; + e);
184         }
185     }
186 }
187 
188 func3();
189 
190 try {
191     eval(&quot;function eval() { &#39;use strict&#39;; }&quot;);
192     fail(&quot;#28 should have thrown SyntaxError&quot;);
193 } catch (e) {
194     if (! (e instanceof SyntaxError)) {
195         fail(&quot;#29 SyntaxError expected, got &quot; + e);
196     }
197 }
198 
199 function func4() {
200   &#39;use \
201 strict&#39;;
202 
203     // The use strict directive can&#39;t contain line continuation.
204     // So this is not a strict mode function!!
205     with({}) {}
206 }
207 
208 func4();
209 
210 function func5() {
211    &#39;use\u2028strict&#39;;
212 
213     // The use strict directive can&#39;t contain unicode whitespace escapes
214     // So this is not a strict mode function!!
215     with({}) {}
216 }
217 
218 func5();
219 
220 function func6() {
221    &#39;use\u2029strict&#39;;
222 
223     // The use strict directive can&#39;t contain unicode whitespace escapes
224     // So this is not a strict mode function!!
225     with({}) {}
226 }
227 
228 func6();
229 
230 try {
231     eval(&quot;&#39;bogus directive&#39;; &#39;use strict&#39;; eval = 10&quot;);
232     fail(&quot;#30 SyntaxError expected from eval&quot;);
233 } catch (e) {
234     if (! (e instanceof SyntaxError)) {
235         fail(&quot;#31 SyntaxError expected but got &quot; + e);
236     }
237 }
    </pre>
  </body>
</html>
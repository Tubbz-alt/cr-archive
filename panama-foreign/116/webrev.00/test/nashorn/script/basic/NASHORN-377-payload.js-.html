<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/nashorn/script/basic/NASHORN-377-payload.js</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * NASHORN-377: Typed arrays. Payload for litte and big endian platforms.
 26  *
 27  * @subtest
 28  * @run
 29  */
 30 
 31 var types = [Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];
 32 
 33 //---------------------------------------------------------------------------
 34 // utility functions
 35 //---------------------------------------------------------------------------
 36 function tohex(d, w) {
 37   var hex = Number(d).toString(16);
 38   var pad = (w ? w : 8) - hex.length;
 39   hex = &quot;00000000&quot;.substr(0, pad) + hex;
 40   return hex;
 41 }
 42 
 43 function arrstr(a, n, w) {
 44   var s = &quot;&quot;;
 45   if (typeof n == &quot;undefined&quot;) n = a.length;
 46   if (typeof w == &quot;undefined&quot;) w = a.constructor.BYTES_PER_ELEMENT * 2;
 47   for (var i = 0; i &lt; n; i++) {
 48     s += tohex(a[i], w);
 49   }
 50   return s;
 51 }
 52 function bufstr(b) {
 53   if (b.buffer !== undefined) {
 54     b = b.buffer;
 55   }
 56   return arrstr(new Uint8Array(b));
 57 }
 58 
 59 function assertFail(f) {
 60   try {
 61     f();
 62   } catch (e) {
 63     //print(e);
 64     return;
 65   }
 66   throw &quot;assertion failed: expected exception&quot;;
 67 }
 68 
 69 function assertTrue(f) {
 70   if (f() !== true) throw &quot;assertion failed: &quot; + f;
 71 }
 72 
 73 function isUndefined(x) {
 74   return typeof x === &quot;undefined&quot;;
 75 }
 76 
 77 function fillArray(a, start) {
 78   if (typeof start == &quot;undefined&quot;) start = 1;
 79   for (var i = 0; i &lt; a.length; i++) {
 80     a[i] = i + start;
 81   }
 82   return a;
 83 }
 84 
 85 //---------------------------------------------------------------------------
 86 // tests
 87 //---------------------------------------------------------------------------
 88 (function() {
 89   var b = new ArrayBuffer(8);
 90   var i8 = new Int8Array(b);
 91   print(i8.buffer.byteLength, b.byteLength, i8.buffer === b, b.length);
 92   print(b, i8.buffer, i8);
 93 })();
 94 
 95 (function test_attributes() {
 96   var b = new ArrayBuffer(8);
 97   for (var i in types) {
 98     var x = new types[i](b);
 99     print(x.byteOffset, x.byteLength, x.length, x.constructor.BYTES_PER_ELEMENT);
100     assertTrue(function(){ return x.constructor === types[i] });
101   }
102 })();
103 
104 (function() {
105   var b = new ArrayBuffer(8);
106   var i8 = new Int8Array(b);
107   fillArray(i8, 0x70);
108 
109   var i8_2 = new Int8Array(b, 2);
110   var i8_2_4 = new Uint8Array(b, 2, 4);
111 
112   i8_2_4[3] = 0x80;
113 
114   print(arrstr(i8, 8, 2)  + &quot; &quot; + bufstr(i8));
115   print(arrstr(i8_2, 6)   + &quot; &quot; + i8_2.byteOffset   + &quot; &quot; + i8_2.byteLength);
116   print(arrstr(i8_2_4, 4) + &quot; &quot; + i8_2_4.byteOffset + &quot; &quot; + i8_2_4.byteLength);
117 
118   var i8_1_5 = i8.subarray(1, 5);
119   i8_2_4.subarray(1, 5);
120   print(arrstr(i8_1_5, 4) + &quot; &quot; + i8_1_5.byteOffset + &quot; &quot; + i8_1_5.byteLength);
121 
122   print(bufstr(b.slice(1,7)));
123 })();
124 
125 (function() {
126   var b = new ArrayBuffer(8);
127   fillArray(new Int8Array(b), 0x70);
128   new Int8Array(b)[5] = 0x80;
129 
130   var i32 = new Int32Array(b);
131   var u32 = new Uint32Array(b);
132   print(arrstr(i32), i32[0], i32[1]);
133   i32[1] = 0xfefdfcfb;
134   print(arrstr(i32), i32[0], i32[1]);
135   print(arrstr(u32), u32[0], u32[1]);
136 
137   var pi = 3.1415926;
138   var f32 = new Float32Array(b);
139   var f64 = new Float64Array(b);
140   f32[0] = pi;
141   print(bufstr(b), f32.length);
142   f64[0] = pi;
143   print(bufstr(b), f64.length);
144   print(arrstr(u32), u32[0], u32[1]);
145 
146   var d = new Int32Array(3);
147   d.set(i32,1);
148   print(bufstr(d));
149 
150   var s = new Int16Array(b);
151   var t = new Uint16Array(b);
152   print(arrstr(s), arrstr(t));
153   s[0] = -1; s[1] = 0x80;
154   print(arrstr(s), arrstr(t));
155 })();
156 
157 (function enumerate_properties() {
158   var i8 = new Int8Array(new ArrayBuffer(8));
159   var s = &quot;&quot;; for (var i in i8) { s += i + &quot; &quot;; } print(s.trim());
160 })();
161 
162 // check that ScriptObject fallback is still working
163 // DISABLED because correct behavior is unclear
164 (function() {
165   // NB: firefox will never set any out-of-bounds or non-array values although it does get both from prototype.
166   var z = new Uint8Array(4);
167   z[&quot;asdf&quot;] = &quot;asdf&quot;; print(z[&quot;asdf&quot;]);
168   z[0x100000000] = &quot;asdf&quot;; print(z[0x100000000]);
169   z[-1] = &quot;asdf&quot;; print(z[-1]);
170 
171   // v8 and nashorn disagree on out-of-bounds uint32 indices: v8 won&#39;t go to the prototype.
172   z[0xf0000000] = &quot;asdf&quot;; print(z[0xf0000000]);
173   z[0xffffffff] = &quot;asdf&quot;; print(z[0xffffffff]);
174   z[0x70000000] = &quot;asdf&quot;; print(z[0x70000000]);
175 
176   // this will work in firefox and nashorn (not in v8).
177   Uint8Array.prototype[4] = &quot;asdf&quot;; print(z[4]);
178 });
179 
180 (function test_exceptions() {
181   assertFail(function() { new Int32Array(new ArrayBuffer(7)); });
182   assertFail(function() { new Int32Array(new ArrayBuffer(8), 0, 4); });
183   assertFail(function() { new Int32Array(new ArrayBuffer(8),-1, 2); });
184   assertFail(function() { new Int32Array(new ArrayBuffer(8), 0,-1); });
185 })();
186 
187 (function test_subarray() {
188   var x = fillArray(new Int8Array(8));
189   print(arrstr(x));
190   print(&quot;subarray(2,4)=&quot; + arrstr(x.subarray(2, 4)), &quot;subarray(-6,-4)=&quot; + arrstr(x.subarray(-6, -4))); // negative index refers from the end of the array
191   print(arrstr(x.subarray(-10, -2))); // negative index clamped to 0
192   assertTrue(function(){ return arrstr(x.subarray(6, 4)) === &quot;&quot;; }); // negative length clamped to 0
193   print(arrstr(x.subarray(1,-1).subarray(1,-1)), arrstr(x.subarray(1,-1).subarray(1,-1).subarray(1,-1))); // subarray of subarray
194 })();
195 
196 (function test_slice() {
197   var b = new ArrayBuffer(16);
198   fillArray(new Int8Array(b));
199   print(bufstr(b));
200   print(&quot;slice(4,8)=&quot; + bufstr(b.slice(4, 8)), &quot;slice(-8,-4)=&quot; + bufstr(b.slice(-8, -4))); // negative index refers from the end of the array
201   print(bufstr(b.slice(-20, -4))); // negative index clamped to 0
202   assertTrue(function(){ return bufstr(b.slice(8, 4)) === &quot;&quot;; }); // negative length clamped to 0
203   print(arrstr(new Int16Array(b.slice(1,-1).slice(2,-1).slice(1,-2).slice(1,-1)))); // slice of slice
204 })();
205 
206 (function test_clamped() {
207   var a = new Uint8ClampedArray(10);
208   a[0] = -17;       // clamped to 0
209   a[1] = 4711;      // clamped to 255
210   a[2] = 17.5;      // clamped to 18
211   a[3] = 16.5;      // clamped to 16
212   a[4] = 255.9;     // clamped to 255
213   a[5] = Infinity;  // clamped to 255
214   a[6] = -Infinity; // clamped to 0
215   a[7] = NaN;       // 0
216   assertTrue(function(){ return a[0] === 0 &amp;&amp; a[1] === 255 &amp;&amp; a[2] === 18 &amp;&amp; a[3] === 16 &amp;&amp; a[4] === 255 &amp;&amp; a[5] === 255 &amp;&amp; a[6] === 0 &amp;&amp; a[7] === 0; });
217 })();
218 
219 (function test_out_of_bounds() {
220   var a = new Int32Array(10);
221   a[10] = 10;
222   a[100] = 100;
223   a[1000] = 1000;
224   assertTrue(function(){ return isUndefined(a[10]) &amp;&amp; isUndefined(a[11]) &amp;&amp; isUndefined(a[100]) &amp;&amp; isUndefined(a[123]) &amp;&amp; isUndefined(a[1000]); });
225 })();
226 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/nashorn/script/basic/javaarrayconversion.js</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * Tests for conversion of JavaScript arrays to Java arrays and the other
 26  * way round. Also generally useful as a JavaScript-to-Java type conversion
 27  * test.
 28  *
 29  * @test
 30  * @run
 31  */
 32 
 33 var x; // used for undefined
 34 var testCount = 0;
 35 
 36 function testF(inputValue, type, testFn) {
 37   var x = Java.to([inputValue], type + &quot;[]&quot;)[0];
 38   if(!testFn(x)) {
 39     throw (&quot;unexpected value: &quot; + x)
 40   }
 41   ++testCount;
 42 }
 43 
 44 function test(inputValue, type, expectedValue) {
 45   testF(inputValue, type, function(x) { return x === expectedValue })
 46 }
 47 
 48 function testNaN(inputValue, type) {
 49   testF(inputValue, type, isNaN)
 50 }
 51 
 52 // Those labeled &quot;Correct?&quot; are not clearly correct conversions. Those
 53 // labeled &quot;TypeError maybe?&quot; could actually throw a TypeError, or only
 54 // throw a TypeError when in strict mode.
 55 // The case of (&quot;false&quot;, &quot;boolean&quot;) =&gt; true is particularly amusing.
 56 
 57 test(x, &quot;int&quot;, 0) // Correct? TypeError maybe?
 58 test(null, &quot;int&quot;, 0) // Correct? TypeError maybe?
 59 test(1234, &quot;int&quot;, 1234)
 60 test(&quot;1234&quot;, &quot;int&quot;, 1234)
 61 test(&quot;1234.49&quot;, &quot;int&quot;, 1234)
 62 test(&quot;1234.51&quot;, &quot;int&quot;, 1234) // truncates, not rounds
 63 test(true, &quot;int&quot;, 1)
 64 test(false, &quot;int&quot;, 0)
 65 test(&quot;foo&quot;, &quot;int&quot;, 0) // Correct? TypeError maybe?
 66 
 67 test(x, &quot;boolean&quot;, false) // Correct? TypeError maybe?
 68 test(null, &quot;boolean&quot;, false) // Correct? TypeError maybe?
 69 test(0, &quot;boolean&quot;, false)
 70 test(1234, &quot;boolean&quot;, true)
 71 test(&quot;foo&quot;, &quot;boolean&quot;, true)
 72 test(&quot;&quot;, &quot;boolean&quot;, false)
 73 test(&quot;false&quot;, &quot;boolean&quot;, true) // Correct? false maybe?
 74 
 75 test(x, &quot;java.lang.String&quot;, &quot;undefined&quot;) // Correct? TypeError maybe?
 76 test(null, &quot;java.lang.String&quot;, null)
 77 test(1234, &quot;java.lang.String&quot;, &quot;1234&quot;)
 78 test(1234.5, &quot;java.lang.String&quot;, &quot;1234.5&quot;)
 79 test(true, &quot;java.lang.String&quot;, &quot;true&quot;)
 80 test(false, &quot;java.lang.String&quot;, &quot;false&quot;)
 81 
 82 test(x, &quot;java.lang.Integer&quot;, null) // Correct? TypeError maybe?
 83 test(null, &quot;java.lang.Integer&quot;, null)
 84 test(1234, &quot;java.lang.Integer&quot;, 1234)
 85 test(&quot;1234&quot;, &quot;java.lang.Integer&quot;, 1234)
 86 test(&quot;1234.49&quot;, &quot;java.lang.Integer&quot;, 1234)
 87 test(&quot;1234.51&quot;, &quot;java.lang.Integer&quot;, 1234) // truncates, not rounds
 88 test(true, &quot;java.lang.Integer&quot;, 1)
 89 test(false, &quot;java.lang.Integer&quot;, 0)
 90 test(&quot;foo&quot;, &quot;java.lang.Integer&quot;, 0) // Correct? TypeError maybe?
 91 
 92 test(x, &quot;java.lang.Boolean&quot;, null) // Correct? TypeError maybe?
 93 test(null, &quot;java.lang.Boolean&quot;, null)
 94 test(0, &quot;java.lang.Boolean&quot;, false)
 95 test(1234, &quot;java.lang.Boolean&quot;, true)
 96 test(&quot;foo&quot;, &quot;java.lang.Boolean&quot;, true)
 97 test(&quot;&quot;, &quot;java.lang.Boolean&quot;, false)
 98 test(&quot;false&quot;, &quot;java.lang.Boolean&quot;, true) // Correct? false maybe?
 99 
100 testNaN(x, &quot;double&quot;)
101 test(null, &quot;double&quot;, 0)
102 test(1234, &quot;double&quot;, 1234)
103 test(&quot;1234&quot;, &quot;double&quot;, 1234)
104 test(&quot;1234.5&quot;, &quot;double&quot;, 1234.5)
105 test(true, &quot;double&quot;, 1)
106 test(false, &quot;double&quot;, 0)
107 testNaN(&quot;foo&quot;, &quot;double&quot;)
108 
109 testNaN(x, &quot;java.lang.Double&quot;)
110 test(null, &quot;java.lang.Double&quot;, null)
111 test(1234, &quot;java.lang.Double&quot;, 1234)
112 test(&quot;1234&quot;, &quot;java.lang.Double&quot;, 1234)
113 test(&quot;1234.5&quot;, &quot;java.lang.Double&quot;, 1234.5)
114 test(true, &quot;java.lang.Double&quot;, 1)
115 test(false, &quot;java.lang.Double&quot;, 0)
116 testNaN(&quot;foo&quot;, &quot;java.lang.Double&quot;)
117 
118 test({ valueOf: function() { return 42; } }, &quot;int&quot;, 42)
119 test({ valueOf: function() { return &quot;42&quot;; } }, &quot;int&quot;, 42)
120 // If there&#39;s no valueOf, toString is used
121 test({ toString: function() { return &quot;42&quot;; } }, &quot;int&quot;, 42)
122 // For numbers, valueOf takes precedence over toString
123 test({ valueOf: function() { return &quot;42&quot;; },  toString: function() { return &quot;43&quot;; } }, &quot;int&quot;, 42)
124 
125 test({ toString: function() { return &quot;foo&quot;; } }, &quot;java.lang.String&quot;, &quot;foo&quot;)
126 // Yep, even if we have valueOf, toString from prototype takes precedence
127 test({ valueOf: function() { return 42; } }, &quot;java.lang.String&quot;, &quot;[object Object]&quot;)
128 // Converting to string, toString takes precedence over valueOf
129 test({ valueOf: function() { return &quot;42&quot;; },  toString: function() { return &quot;43&quot;; } }, &quot;java.lang.String&quot;, &quot;43&quot;)
130 
131 function assertCanConvert(sourceType, targetType) {
132   Java.to([new (Java.type(sourceType))()], targetType + &quot;[]&quot;)
133   ++testCount;
134 }
135 
136 function assertCantConvert(sourceType, targetType) {
137   try {
138     Java.to([new (Java.type(sourceType))()], targetType + &quot;[]&quot;)
139     throw &quot;no TypeError encountered&quot;
140   } catch(e) {
141       if(!(e instanceof TypeError) ||
142           !e.message.startsWith(&quot;Java.to conversion to array type&quot;)) {
143         throw e;
144       }
145       ++testCount;
146   }
147 }
148 
149 // Arbitrary POJOs to JS Primitive type should work
150 assertCanConvert(&quot;java.util.BitSet&quot;, &quot;int&quot;)
151 assertCanConvert(&quot;java.util.BitSet&quot;, &quot;double&quot;)
152 assertCanConvert(&quot;java.util.BitSet&quot;, &quot;long&quot;)
153 assertCanConvert(&quot;java.util.BitSet&quot;, &quot;boolean&quot;)
154 assertCanConvert(&quot;java.util.BitSet&quot;, &quot;java.lang.String&quot;)
155 
156 // Arbitrary POJOs can&#39;t be converted to Java values
157 assertCantConvert(&quot;java.util.BitSet&quot;, &quot;java.lang.Double&quot;)
158 assertCantConvert(&quot;java.util.BitSet&quot;, &quot;java.lang.Long&quot;)
159 
160 /***************************************************************************
161  * Now testing the other way round - Java arrays &amp; collections to JavaScript
162  **************************************************************************/
163 
164 function assert(x) {
165   if(!x) {
166     throw &quot;Assertion failed&quot;
167   }
168   ++testCount;
169 }
170 
171 var intArray = new (Java.type(&quot;int[]&quot;))(3)
172 intArray[0] = 1234;
173 intArray[1] = 42;
174 intArray[2] = 5;
175 var jsIntArray = Java.from(intArray)
176 assert(jsIntArray instanceof Array);
177 assert(jsIntArray[0] === 1234);
178 assert(jsIntArray[1] === 42);
179 assert(jsIntArray[2] === 5);
180 
181 // The arrays are copies, they don&#39;t reflect each other
182 intArray[2] = 6;
183 assert(jsIntArray[2] === 5);
184 jsIntArray[2] = 7;
185 assert(intArray[2] === 6);
186 
187 var byteArray = new (Java.type(&quot;byte[]&quot;))(2)
188 byteArray[0] = -128;
189 byteArray[1] = 127;
190 var jsByteArray = Java.from(byteArray)
191 assert(jsByteArray instanceof Array);
192 assert(jsByteArray[0] === -128);
193 assert(jsByteArray[1] === 127);
194 
195 var shortArray = new (Java.type(&quot;short[]&quot;))(2)
196 shortArray[0] = -32768;
197 shortArray[1] = 32767;
198 var jsShortArray = Java.from(shortArray)
199 assert(jsShortArray instanceof Array);
200 assert(jsShortArray[0] === -32768);
201 assert(jsShortArray[1] === 32767);
202 
203 var floatArray = new (Java.type(&quot;float[]&quot;))(2)
204 floatArray[0] = java.lang.Float.MIN_VALUE;
205 floatArray[1] = java.lang.Float.MAX_VALUE;
206 var jsFloatArray = Java.from(floatArray)
207 assert(jsFloatArray instanceof Array);
208 assert(jsFloatArray[0] == java.lang.Float.MIN_VALUE);
209 assert(jsFloatArray[1] == java.lang.Float.MAX_VALUE);
210 
211 var charArray = new (Java.type(&quot;char[]&quot;))(3)
212 charArray[0] = &quot;a&quot;;
213 charArray[1] = &quot;b&quot;;
214 charArray[2] = &quot;1&quot;;
215 var jsCharArray = Java.from(charArray)
216 assert(jsCharArray instanceof Array);
217 assert(jsCharArray[0] === 97);
218 assert(jsCharArray[1] === 98);
219 assert(jsCharArray[2] === 49);
220 
221 var booleanArray = new (Java.type(&quot;boolean[]&quot;))(2)
222 booleanArray[0] = true;
223 booleanArray[1] = false;
224 var jsBooleanArray = Java.from(booleanArray)
225 assert(jsBooleanArray instanceof Array);
226 assert(jsBooleanArray[0] === true);
227 assert(jsBooleanArray[1] === false);
228 
229 print(testCount + &quot; tests completed ok&quot;)
    </pre>
  </body>
</html>
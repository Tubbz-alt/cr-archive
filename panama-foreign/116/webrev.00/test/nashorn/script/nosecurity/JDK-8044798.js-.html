<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/nashorn/script/nosecurity/JDK-8044798.js</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * JDK-8044798: API for debugging Nashorn
 26  *
 27  * @test
 28  * @option -Dnashorn.mirror.always=false
 29  * @fork
 30  */
 31 
 32 // basic API exercise checks
 33 
 34 var Arrays = Java.type(&quot;java.util.Arrays&quot;);
 35 var CharArray = Java.type(&quot;char[]&quot;);
 36 var Reflector = Java.type(&quot;jdk.nashorn.test.models.Reflector&quot;);
 37 var DebuggerSupport = Java.type(&quot;jdk.nashorn.internal.runtime.DebuggerSupport&quot;);
 38 var DebuggerValueDesc = Java.type(&quot;jdk.nashorn.internal.runtime.DebuggerSupport.DebuggerValueDesc&quot;);
 39 
 40 var valueDescFields = DebuggerValueDesc.class.declaredFields;
 41 Arrays.sort(valueDescFields, function(f1, f2) f1.name.compareTo(f2.name));
 42 for each (var f in valueDescFields) {
 43     Reflector.setAccessible(f);
 44 }
 45 
 46 var debuggerSupportMethods = DebuggerSupport.class.declaredMethods;
 47 
 48 // methods of DebuggerSupport that we use
 49 var evalMethod, valueInfoMethod, valueInfosMethod;
 50 var getSourceInfoMethod, valueAsStringMethod;
 51 
 52 for each (var m in debuggerSupportMethods) {
 53     Reflector.setAccessible(m);
 54     switch (m.name) {
 55         case &quot;eval&quot;:
 56             evalMethod = m;
 57             break;
 58         case &quot;valueInfo&quot;:
 59             if (m.parameterCount == 3) {
 60                 valueInfoMethod = m;
 61             }
 62             break;
 63         case &quot;valueInfos&quot;:
 64             valueInfosMethod = m;
 65             break;
 66         case &quot;valueAsString&quot;:
 67             valueAsStringMethod = m;
 68             break;
 69         case &quot;getSourceInfo&quot;:
 70             getSourceInfoMethod = m;
 71             break;
 72     }
 73 }
 74 
 75 // eval
 76 var value = evalMethod.invoke(null, null, null, &quot;33 + 55&quot;, false);
 77 print(value);
 78 
 79 // valueInfo
 80 var info = valueInfoMethod.invoke(null, &quot;apply&quot;, Function, true);
 81 for each (var f in valueDescFields) {
 82     print(f.name, &quot;=&quot;, f.get(info));
 83 }
 84 
 85 // valueInfo - user defined object
 86 var info = valueInfoMethod.invoke(null, &quot;foo&quot;, { foo: 343 }, true);
 87 for each (var f in valueDescFields) {
 88     print(f.name, &quot;=&quot;, f.get(info));
 89 }
 90 
 91 // valueInfos
 92 var infos = valueInfosMethod.invoke(null, Object, true);
 93 for each (var info in infos) {
 94     for each (var f in valueDescFields) {
 95         print(f.name, &quot;=&quot;, f.get(info));
 96     }
 97 }
 98 
 99 // valueInfos - user defined object
100 var infos = valueInfosMethod.invoke(null, { foo: 34, bar: &quot;hello&quot; }, true);
101 for each (var info in infos) {
102     for each (var f in valueDescFields) {
103         print(f.name, &quot;=&quot;, f.get(info));
104     }
105 }
106 
107 // valueAsString
108 function printValue(value) {
109     print(valueAsStringMethod.invoke(null, value));
110 }
111 
112 printValue(undefined);
113 printValue(null);
114 printValue(&quot;hello&quot;);
115 printValue(Math.PI);
116 printValue(this);
117 
118 // The below are not part of DebuggerSupport. But we need these to
119 // test DebuggerSupport.getSourceInfo etc. which need compiled script class
120 
121 var Source = Java.type(&quot;jdk.nashorn.internal.runtime.Source&quot;);
122 var Context = Java.type(&quot;jdk.nashorn.internal.runtime.Context&quot;);
123 var ThrowErrorManager = Java.type(&quot;jdk.nashorn.internal.runtime.Context.ThrowErrorManager&quot;);
124 var contextCls = java.lang.Class.forName(&quot;jdk.nashorn.internal.runtime.Context&quot;);
125 var sourceCls = Source.class;
126 var errorMgrCls = Java.type(&quot;jdk.nashorn.internal.runtime.ErrorManager&quot;).class;
127 var booleanCls = Java.type(&quot;java.lang.Boolean&quot;).TYPE;
128 var stringCls = Java.type(&quot;java.lang.String&quot;).class;
129 
130 // private compile method of Context class
131 var compileMethod = contextCls.getDeclaredMethod(&quot;compile&quot;,
132                 sourceCls, errorMgrCls, booleanCls, booleanCls);
133 Reflector.setAccessible(compileMethod);
134 
135 var getContextMethod = contextCls.getMethod(&quot;getContext&quot;);
136 Reflector.setAccessible(getContextMethod);
137 
138 var sourceForMethod = sourceCls.getMethod(&quot;sourceFor&quot;, stringCls, stringCls);
139 var scriptCls = compileMethod.invoke(getContextMethod.invoke(null),
140     sourceForMethod.invoke(null, &quot;test&quot;, &quot;print(&#39;hello&#39;)&quot;),
141     ThrowErrorManager.class.newInstance(), false, false);
142 
143 var SCRIPT_CLASS_NAME_PREFIX = &quot;jdk.nashorn.internal.scripts.Script$&quot;;
144 print(&quot;script class name pattern satisfied? &quot; +
145     scriptCls.name.startsWith(SCRIPT_CLASS_NAME_PREFIX));
146 
147 var srcInfo = getSourceInfoMethod.invoke(null, scriptCls);
148 var srcInfoFields = srcInfo.class.declaredFields;
149 Arrays.sort(srcInfoFields, function(f1, f2) f1.name.compareTo(f2.name));
150 
151 print(&quot;Source info&quot;);
152 for each (var f in srcInfoFields) {
153     Reflector.setAccessible(f);
154     var fieldValue = f.get(srcInfo);
155     if (fieldValue instanceof CharArray) {
156         fieldValue = new java.lang.String(fieldValue);
157     }
158 
159     print(f.name, &quot;=&quot;, fieldValue);
160 }
    </pre>
  </body>
</html>
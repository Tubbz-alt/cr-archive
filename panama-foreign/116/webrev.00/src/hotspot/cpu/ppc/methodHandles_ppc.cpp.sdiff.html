<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/methodHandles_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../arm/methodHandles_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../s390/methodHandles_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/methodHandles_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2012, 2017 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;jvm.h&quot;
 28 #include &quot;asm/macroAssembler.inline.hpp&quot;
 29 #include &quot;classfile/javaClasses.inline.hpp&quot;
 30 #include &quot;interpreter/interpreter.hpp&quot;

 31 #include &quot;memory/allocation.inline.hpp&quot;
 32 #include &quot;memory/resourceArea.hpp&quot;
 33 #include &quot;prims/methodHandles.hpp&quot;
 34 #include &quot;runtime/frame.inline.hpp&quot;
 35 #include &quot;utilities/preserveException.hpp&quot;
 36 
 37 #define __ _masm-&gt;
 38 
 39 #ifdef PRODUCT
 40 #define BLOCK_COMMENT(str) // nothing
 41 #else
 42 #define BLOCK_COMMENT(str) __ block_comment(str)
 43 #endif
 44 
 45 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
 46 
 47 // Workaround for C++ overloading nastiness on &#39;0&#39; for RegisterOrConstant.
 48 inline static RegisterOrConstant constant(int value) {
 49   return RegisterOrConstant(value);
 50 }
</pre>
<hr />
<pre>
247   }
248 
249   // First task:  Find out how big the argument list is.
250   int ref_kind = signature_polymorphic_intrinsic_ref_kind(iid);
251   assert(ref_kind != 0 || iid == vmIntrinsics::_invokeBasic, &quot;must be _invokeBasic or a linkTo intrinsic&quot;);
252   if (ref_kind == 0 || MethodHandles::ref_kind_has_receiver(ref_kind)) {
253     __ ld(param_size, in_bytes(Method::const_offset()), R19_method);
254     __ load_sized_value(param_size, in_bytes(ConstMethod::size_of_parameters_offset()), param_size,
255                         sizeof(u2), /*is_signed*/ false);
256     // assert(sizeof(u2) == sizeof(ConstMethod::_size_of_parameters), &quot;&quot;);
257   } else {
258     DEBUG_ONLY(param_size = noreg);
259   }
260 
261   Register tmp_mh = noreg;
262   if (!is_signature_polymorphic_static(iid)) {
263     __ ld(tmp_mh = temp1, __ argument_offset(param_size, param_size, 0), argbase);
264     DEBUG_ONLY(param_size = noreg);
265   }
266 
<span class="line-modified">267   if (TraceMethodHandles) {</span>
268     if (tmp_mh != noreg) {
269       __ mr(R23_method_handle, tmp_mh);  // make stub happy
270     }
271     trace_method_handle_interpreter_entry(_masm, iid);
272   }
273 
274   if (iid == vmIntrinsics::_invokeBasic) {
275     generate_method_handle_dispatch(_masm, iid, tmp_mh, noreg, not_for_compiler_entry);
276 
277   } else {
278     // Adjust argument list by popping the trailing MemberName argument.
279     Register tmp_recv = noreg;
280     if (MethodHandles::ref_kind_has_receiver(ref_kind)) {
281       // Load the receiver (not the MH; the actual MemberName&#39;s receiver) up from the interpreter stack.
282       __ ld(tmp_recv = temp1, __ argument_offset(param_size, param_size, 0), argbase);
283       DEBUG_ONLY(param_size = noreg);
284     }
285     Register R19_member = R19_method;  // MemberName ptr; incoming method ptr is dead now
286     __ ld(R19_member, RegisterOrConstant((intptr_t)8), argbase);
287     __ add(argbase, Interpreter::stackElementSize, argbase);
</pre>
<hr />
<pre>
528       frame dump_frame = frame(dump_sp);
529       dump_frame.describe(values, 1);
530 
531       values.describe(-1, saved_regs, &quot;raw top of stack&quot;);
532 
533       tty-&gt;print_cr(&quot;Stack layout:&quot;);
534       values.print(p);
535     }
536 
537     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
538       mh-&gt;print();
539       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
540         if (java_lang_invoke_MethodHandle::form_offset_in_bytes() != 0)
541           java_lang_invoke_MethodHandle::form(mh)-&gt;print();
542       }
543     }
544   }
545 }
546 
547 void MethodHandles::trace_method_handle(MacroAssembler* _masm, const char* adaptername) {
<span class="line-modified">548   if (!TraceMethodHandles) return;</span>
549 
550   BLOCK_COMMENT(&quot;trace_method_handle {&quot;);
551 
552   const Register tmp = R11; // Will be preserved.
553   const int nbytes_save = MacroAssembler::num_volatile_regs * 8;
554   __ save_volatile_gprs(R1_SP, -nbytes_save); // except R0
555   __ save_LR_CR(tmp); // save in old frame
556 
557   __ mr(R5_ARG3, R1_SP);     // saved_sp
558   __ push_frame_reg_args(nbytes_save, tmp);
559 
560   __ load_const_optimized(R3_ARG1, (address)adaptername, tmp);
561   __ mr(R4_ARG2, R23_method_handle);
562   __ mr(R6_ARG4, R1_SP);
563   __ call_VM_leaf(CAST_FROM_FN_PTR(address, trace_method_handle_stub));
564 
565   __ pop_frame();
566   __ restore_LR_CR(tmp);
567   __ restore_volatile_gprs(R1_SP, -nbytes_save); // except R0
568 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2012, 2017 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;jvm.h&quot;
 28 #include &quot;asm/macroAssembler.inline.hpp&quot;
 29 #include &quot;classfile/javaClasses.inline.hpp&quot;
 30 #include &quot;interpreter/interpreter.hpp&quot;
<span class="line-added"> 31 #include &quot;logging/log.hpp&quot;</span>
 32 #include &quot;memory/allocation.inline.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;prims/methodHandles.hpp&quot;
 35 #include &quot;runtime/frame.inline.hpp&quot;
 36 #include &quot;utilities/preserveException.hpp&quot;
 37 
 38 #define __ _masm-&gt;
 39 
 40 #ifdef PRODUCT
 41 #define BLOCK_COMMENT(str) // nothing
 42 #else
 43 #define BLOCK_COMMENT(str) __ block_comment(str)
 44 #endif
 45 
 46 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
 47 
 48 // Workaround for C++ overloading nastiness on &#39;0&#39; for RegisterOrConstant.
 49 inline static RegisterOrConstant constant(int value) {
 50   return RegisterOrConstant(value);
 51 }
</pre>
<hr />
<pre>
248   }
249 
250   // First task:  Find out how big the argument list is.
251   int ref_kind = signature_polymorphic_intrinsic_ref_kind(iid);
252   assert(ref_kind != 0 || iid == vmIntrinsics::_invokeBasic, &quot;must be _invokeBasic or a linkTo intrinsic&quot;);
253   if (ref_kind == 0 || MethodHandles::ref_kind_has_receiver(ref_kind)) {
254     __ ld(param_size, in_bytes(Method::const_offset()), R19_method);
255     __ load_sized_value(param_size, in_bytes(ConstMethod::size_of_parameters_offset()), param_size,
256                         sizeof(u2), /*is_signed*/ false);
257     // assert(sizeof(u2) == sizeof(ConstMethod::_size_of_parameters), &quot;&quot;);
258   } else {
259     DEBUG_ONLY(param_size = noreg);
260   }
261 
262   Register tmp_mh = noreg;
263   if (!is_signature_polymorphic_static(iid)) {
264     __ ld(tmp_mh = temp1, __ argument_offset(param_size, param_size, 0), argbase);
265     DEBUG_ONLY(param_size = noreg);
266   }
267 
<span class="line-modified">268   if (log_is_enabled(Info, methodhandles)) {</span>
269     if (tmp_mh != noreg) {
270       __ mr(R23_method_handle, tmp_mh);  // make stub happy
271     }
272     trace_method_handle_interpreter_entry(_masm, iid);
273   }
274 
275   if (iid == vmIntrinsics::_invokeBasic) {
276     generate_method_handle_dispatch(_masm, iid, tmp_mh, noreg, not_for_compiler_entry);
277 
278   } else {
279     // Adjust argument list by popping the trailing MemberName argument.
280     Register tmp_recv = noreg;
281     if (MethodHandles::ref_kind_has_receiver(ref_kind)) {
282       // Load the receiver (not the MH; the actual MemberName&#39;s receiver) up from the interpreter stack.
283       __ ld(tmp_recv = temp1, __ argument_offset(param_size, param_size, 0), argbase);
284       DEBUG_ONLY(param_size = noreg);
285     }
286     Register R19_member = R19_method;  // MemberName ptr; incoming method ptr is dead now
287     __ ld(R19_member, RegisterOrConstant((intptr_t)8), argbase);
288     __ add(argbase, Interpreter::stackElementSize, argbase);
</pre>
<hr />
<pre>
529       frame dump_frame = frame(dump_sp);
530       dump_frame.describe(values, 1);
531 
532       values.describe(-1, saved_regs, &quot;raw top of stack&quot;);
533 
534       tty-&gt;print_cr(&quot;Stack layout:&quot;);
535       values.print(p);
536     }
537 
538     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
539       mh-&gt;print();
540       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
541         if (java_lang_invoke_MethodHandle::form_offset_in_bytes() != 0)
542           java_lang_invoke_MethodHandle::form(mh)-&gt;print();
543       }
544     }
545   }
546 }
547 
548 void MethodHandles::trace_method_handle(MacroAssembler* _masm, const char* adaptername) {
<span class="line-modified">549   if (!log_is_enabled(Info, methodhandles)) return;</span>
550 
551   BLOCK_COMMENT(&quot;trace_method_handle {&quot;);
552 
553   const Register tmp = R11; // Will be preserved.
554   const int nbytes_save = MacroAssembler::num_volatile_regs * 8;
555   __ save_volatile_gprs(R1_SP, -nbytes_save); // except R0
556   __ save_LR_CR(tmp); // save in old frame
557 
558   __ mr(R5_ARG3, R1_SP);     // saved_sp
559   __ push_frame_reg_args(nbytes_save, tmp);
560 
561   __ load_const_optimized(R3_ARG1, (address)adaptername, tmp);
562   __ mr(R4_ARG2, R23_method_handle);
563   __ mr(R6_ARG4, R1_SP);
564   __ call_VM_leaf(CAST_FROM_FN_PTR(address, trace_method_handle_stub));
565 
566   __ pop_frame();
567   __ restore_LR_CR(tmp);
568   __ restore_volatile_gprs(R1_SP, -nbytes_save); // except R0
569 
</pre>
</td>
</tr>
</table>
<center><a href="../arm/methodHandles_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../s390/methodHandles_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/dependencies.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileTask.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/dependencies.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1190   }
1191 
1192   bool is_witness(Klass* k) {
1193     if (doing_subtype_search()) {
1194       return Dependencies::is_concrete_klass(k);
1195     } else if (!k-&gt;is_instance_klass()) {
1196       return false; // no methods to find in an array type
1197     } else {
1198       // Search class hierarchy first, skipping private implementations
1199       // as they never override any inherited methods
1200       Method* m = InstanceKlass::cast(k)-&gt;find_instance_method(_name, _signature, Klass::skip_private);
1201       if (!Dependencies::is_concrete_method(m, k)) {
1202         // Check for re-abstraction of method
1203         if (!k-&gt;is_interface() &amp;&amp; m != NULL &amp;&amp; m-&gt;is_abstract()) {
1204           // Found a matching abstract method &#39;m&#39; in the class hierarchy.
1205           // This is fine iff &#39;k&#39; is an abstract class and all concrete subtypes
1206           // of &#39;k&#39; override &#39;m&#39; and are participates of the current search.
1207           ClassHierarchyWalker wf(_participants, _num_participants);
1208           Klass* w = wf.find_witness_subtype(k);
1209           if (w != NULL) {
<span class="line-modified">1210             Method* wm = InstanceKlass::cast(w)-&gt;find_instance_method(_name, _signature);</span>
1211             if (!Dependencies::is_concrete_method(wm, w)) {
1212               // Found a concrete subtype &#39;w&#39; which does not override abstract method &#39;m&#39;.
1213               // Bail out because &#39;m&#39; could be called with &#39;w&#39; as receiver (leading to an
1214               // AbstractMethodError) and thus the method we are looking for is not unique.
1215               _found_methods[_num_participants] = m;
1216               return true;
1217             }
1218           }
1219         }
1220         // Check interface defaults also, if any exist.
1221         Array&lt;Method*&gt;* default_methods = InstanceKlass::cast(k)-&gt;default_methods();
1222         if (default_methods == NULL)
1223             return false;
1224         m = InstanceKlass::cast(k)-&gt;find_method(default_methods, _name, _signature);
1225         if (!Dependencies::is_concrete_method(m, NULL))
1226             return false;
1227       }
1228       _found_methods[_num_participants] = m;
1229       // Note:  If add_participant(k) is called,
1230       // the method m will already be memoized for it.
</pre>
</td>
<td>
<hr />
<pre>
1190   }
1191 
1192   bool is_witness(Klass* k) {
1193     if (doing_subtype_search()) {
1194       return Dependencies::is_concrete_klass(k);
1195     } else if (!k-&gt;is_instance_klass()) {
1196       return false; // no methods to find in an array type
1197     } else {
1198       // Search class hierarchy first, skipping private implementations
1199       // as they never override any inherited methods
1200       Method* m = InstanceKlass::cast(k)-&gt;find_instance_method(_name, _signature, Klass::skip_private);
1201       if (!Dependencies::is_concrete_method(m, k)) {
1202         // Check for re-abstraction of method
1203         if (!k-&gt;is_interface() &amp;&amp; m != NULL &amp;&amp; m-&gt;is_abstract()) {
1204           // Found a matching abstract method &#39;m&#39; in the class hierarchy.
1205           // This is fine iff &#39;k&#39; is an abstract class and all concrete subtypes
1206           // of &#39;k&#39; override &#39;m&#39; and are participates of the current search.
1207           ClassHierarchyWalker wf(_participants, _num_participants);
1208           Klass* w = wf.find_witness_subtype(k);
1209           if (w != NULL) {
<span class="line-modified">1210             Method* wm = InstanceKlass::cast(w)-&gt;find_instance_method(_name, _signature, Klass::skip_private);</span>
1211             if (!Dependencies::is_concrete_method(wm, w)) {
1212               // Found a concrete subtype &#39;w&#39; which does not override abstract method &#39;m&#39;.
1213               // Bail out because &#39;m&#39; could be called with &#39;w&#39; as receiver (leading to an
1214               // AbstractMethodError) and thus the method we are looking for is not unique.
1215               _found_methods[_num_participants] = m;
1216               return true;
1217             }
1218           }
1219         }
1220         // Check interface defaults also, if any exist.
1221         Array&lt;Method*&gt;* default_methods = InstanceKlass::cast(k)-&gt;default_methods();
1222         if (default_methods == NULL)
1223             return false;
1224         m = InstanceKlass::cast(k)-&gt;find_method(default_methods, _name, _signature);
1225         if (!Dependencies::is_concrete_method(m, NULL))
1226             return false;
1227       }
1228       _found_methods[_num_participants] = m;
1229       // Note:  If add_participant(k) is called,
1230       // the method m will already be memoized for it.
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileTask.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
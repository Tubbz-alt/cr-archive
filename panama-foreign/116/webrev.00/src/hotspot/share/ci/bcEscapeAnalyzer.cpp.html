<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/ci/bcEscapeAnalyzer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  27 #include &quot;ci/ciConstant.hpp&quot;
  28 #include &quot;ci/ciField.hpp&quot;
  29 #include &quot;ci/ciMethodBlocks.hpp&quot;
  30 #include &quot;ci/ciStreams.hpp&quot;
  31 #include &quot;interpreter/bytecode.hpp&quot;
  32 #include &quot;oops/oop.inline.hpp&quot;
  33 #include &quot;utilities/align.hpp&quot;
  34 #include &quot;utilities/bitMap.inline.hpp&quot;
  35 #include &quot;utilities/copy.hpp&quot;
  36 
  37 #ifndef PRODUCT
  38   #define TRACE_BCEA(level, code)                                            \
  39     if (EstimateArgEscape &amp;&amp; BCEATraceLevel &gt;= level) {                        \
  40       code;                                                                  \
  41     }
  42 #else
  43   #define TRACE_BCEA(level, code)
  44 #endif
  45 
  46 // Maintain a map of which arguments a local variable or
  47 // stack slot may contain.  In addition to tracking
  48 // arguments, it tracks two special values, &quot;allocated&quot;
  49 // which represents any object allocated in the current
  50 // method, and &quot;unknown&quot; which is any other object.
  51 // Up to 30 arguments are handled, with the last one
  52 // representing summary information for any extra arguments
  53 class BCEscapeAnalyzer::ArgumentMap {
  54   uint  _bits;
  55   enum {MAXBIT = 29,
  56         ALLOCATED = 1,
  57         UNKNOWN = 2};
  58 
  59   uint int_to_bit(uint e) const {
  60     if (e &gt; MAXBIT)
  61       e = MAXBIT;
  62     return (1 &lt;&lt; (e + 2));
  63   }
  64 
  65 public:
  66   ArgumentMap()                         { _bits = 0;}
  67   void set_bits(uint bits)              { _bits = bits;}
  68   uint get_bits() const                 { return _bits;}
  69   void clear()                          { _bits = 0;}
  70   void set_all()                        { _bits = ~0u; }
  71   bool is_empty() const                 { return _bits == 0; }
  72   bool contains(uint var) const         { return (_bits &amp; int_to_bit(var)) != 0; }
  73   bool is_singleton(uint var) const     { return (_bits == int_to_bit(var)); }
  74   bool contains_unknown() const         { return (_bits &amp; UNKNOWN) != 0; }
  75   bool contains_allocated() const       { return (_bits &amp; ALLOCATED) != 0; }
  76   bool contains_vars() const            { return (_bits &amp; (((1 &lt;&lt; MAXBIT) -1) &lt;&lt; 2)) != 0; }
  77   void set(uint var)                    { _bits = int_to_bit(var); }
  78   void add(uint var)                    { _bits |= int_to_bit(var); }
  79   void add_unknown()                    { _bits = UNKNOWN; }
  80   void add_allocated()                  { _bits = ALLOCATED; }
  81   void set_union(const ArgumentMap &amp;am)     { _bits |= am._bits; }
  82   void set_difference(const ArgumentMap &amp;am) { _bits &amp;=  ~am._bits; }
  83   bool operator==(const ArgumentMap &amp;am) { return _bits == am._bits; }
  84   bool operator!=(const ArgumentMap &amp;am) { return _bits != am._bits; }
  85 };
  86 
  87 class BCEscapeAnalyzer::StateInfo {
  88 public:
  89   ArgumentMap *_vars;
  90   ArgumentMap *_stack;
  91   int _stack_height;
  92   int _max_stack;
  93   bool _initialized;
  94   ArgumentMap empty_map;
  95 
  96   StateInfo() {
  97     empty_map.clear();
  98   }
  99 
 100   ArgumentMap raw_pop()  { guarantee(_stack_height &gt; 0, &quot;stack underflow&quot;); return _stack[--_stack_height]; }
 101   ArgumentMap  apop()    { return raw_pop(); }
 102   void spop()            { raw_pop(); }
 103   void lpop()            { spop(); spop(); }
 104   void raw_push(ArgumentMap i)   { guarantee(_stack_height &lt; _max_stack, &quot;stack overflow&quot;); _stack[_stack_height++] = i; }
 105   void apush(ArgumentMap i)      { raw_push(i); }
 106   void spush()           { raw_push(empty_map); }
 107   void lpush()           { spush(); spush(); }
 108 
 109 };
 110 
 111 void BCEscapeAnalyzer::set_returned(ArgumentMap vars) {
 112   for (int i = 0; i &lt; _arg_size; i++) {
 113     if (vars.contains(i))
 114       _arg_returned.set(i);
 115   }
 116   _return_local = _return_local &amp;&amp; !(vars.contains_unknown() || vars.contains_allocated());
 117   _return_allocated = _return_allocated &amp;&amp; vars.contains_allocated() &amp;&amp; !(vars.contains_unknown() || vars.contains_vars());
 118 }
 119 
 120 // return true if any element of vars is an argument
 121 bool BCEscapeAnalyzer::is_argument(ArgumentMap vars) {
 122   for (int i = 0; i &lt; _arg_size; i++) {
 123     if (vars.contains(i))
 124       return true;
 125   }
 126   return false;
 127 }
 128 
 129 // return true if any element of vars is an arg_stack argument
 130 bool BCEscapeAnalyzer::is_arg_stack(ArgumentMap vars){
 131   if (_conservative)
 132     return true;
 133   for (int i = 0; i &lt; _arg_size; i++) {
 134     if (vars.contains(i) &amp;&amp; _arg_stack.test(i))
 135       return true;
 136   }
 137   return false;
 138 }
 139 
 140 // return true if all argument elements of vars are returned
 141 bool BCEscapeAnalyzer::returns_all(ArgumentMap vars) {
 142   for (int i = 0; i &lt; _arg_size; i++) {
 143     if (vars.contains(i) &amp;&amp; !_arg_returned.test(i)) {
 144       return false;
 145     }
 146   }
 147   return true;
 148 }
 149 
 150 void BCEscapeAnalyzer::clear_bits(ArgumentMap vars, VectorSet &amp;bm) {
 151   for (int i = 0; i &lt; _arg_size; i++) {
 152     if (vars.contains(i)) {
 153       bm.remove(i);
 154     }
 155   }
 156 }
 157 
 158 void BCEscapeAnalyzer::set_method_escape(ArgumentMap vars) {
 159   clear_bits(vars, _arg_local);
 160   if (vars.contains_allocated()) {
 161     _allocated_escapes = true;
 162   }
 163 }
 164 
 165 void BCEscapeAnalyzer::set_global_escape(ArgumentMap vars, bool merge) {
 166   clear_bits(vars, _arg_local);
 167   clear_bits(vars, _arg_stack);
 168   if (vars.contains_allocated())
 169     _allocated_escapes = true;
 170 
 171   if (merge &amp;&amp; !vars.is_empty()) {
 172     // Merge new state into already processed block.
 173     // New state is not taken into account and
 174     // it may invalidate set_returned() result.
 175     if (vars.contains_unknown() || vars.contains_allocated()) {
 176       _return_local = false;
 177     }
 178     if (vars.contains_unknown() || vars.contains_vars()) {
 179       _return_allocated = false;
 180     }
 181     if (_return_local &amp;&amp; vars.contains_vars() &amp;&amp; !returns_all(vars)) {
 182       // Return result should be invalidated if args in new
 183       // state are not recorded in return state.
 184       _return_local = false;
 185     }
 186   }
 187 }
 188 
 189 void BCEscapeAnalyzer::set_dirty(ArgumentMap vars) {
 190   clear_bits(vars, _dirty);
 191 }
 192 
 193 void BCEscapeAnalyzer::set_modified(ArgumentMap vars, int offs, int size) {
 194 
 195   for (int i = 0; i &lt; _arg_size; i++) {
 196     if (vars.contains(i)) {
 197       set_arg_modified(i, offs, size);
 198     }
 199   }
 200   if (vars.contains_unknown())
 201     _unknown_modified = true;
 202 }
 203 
 204 bool BCEscapeAnalyzer::is_recursive_call(ciMethod* callee) {
 205   for (BCEscapeAnalyzer* scope = this; scope != NULL; scope = scope-&gt;_parent) {
 206     if (scope-&gt;method() == callee) {
 207       return true;
 208     }
 209   }
 210   return false;
 211 }
 212 
 213 bool BCEscapeAnalyzer::is_arg_modified(int arg, int offset, int size_in_bytes) {
 214   if (offset == OFFSET_ANY)
 215     return _arg_modified[arg] != 0;
 216   assert(arg &gt;= 0 &amp;&amp; arg &lt; _arg_size, &quot;must be an argument.&quot;);
 217   bool modified = false;
 218   int l = offset / HeapWordSize;
 219   int h = align_up(offset + size_in_bytes, HeapWordSize) / HeapWordSize;
 220   if (l &gt; ARG_OFFSET_MAX)
 221     l = ARG_OFFSET_MAX;
 222   if (h &gt; ARG_OFFSET_MAX+1)
 223     h = ARG_OFFSET_MAX + 1;
 224   for (int i = l; i &lt; h; i++) {
 225     modified = modified || (_arg_modified[arg] &amp; (1 &lt;&lt; i)) != 0;
 226   }
 227   return modified;
 228 }
 229 
 230 void BCEscapeAnalyzer::set_arg_modified(int arg, int offset, int size_in_bytes) {
 231   if (offset == OFFSET_ANY) {
 232     _arg_modified[arg] =  (uint) -1;
 233     return;
 234   }
 235   assert(arg &gt;= 0 &amp;&amp; arg &lt; _arg_size, &quot;must be an argument.&quot;);
 236   int l = offset / HeapWordSize;
 237   int h = align_up(offset + size_in_bytes, HeapWordSize) / HeapWordSize;
 238   if (l &gt; ARG_OFFSET_MAX)
 239     l = ARG_OFFSET_MAX;
 240   if (h &gt; ARG_OFFSET_MAX+1)
 241     h = ARG_OFFSET_MAX + 1;
 242   for (int i = l; i &lt; h; i++) {
 243     _arg_modified[arg] |= (1 &lt;&lt; i);
 244   }
 245 }
 246 
 247 void BCEscapeAnalyzer::invoke(StateInfo &amp;state, Bytecodes::Code code, ciMethod* target, ciKlass* holder) {
 248   int i;
 249 
 250   // retrieve information about the callee
 251   ciInstanceKlass* klass = target-&gt;holder();
 252   ciInstanceKlass* calling_klass = method()-&gt;holder();
 253   ciInstanceKlass* callee_holder = ciEnv::get_instance_klass_for_declared_method_holder(holder);
 254   ciInstanceKlass* actual_recv = callee_holder;
 255 
 256   // Some methods are obviously bindable without any type checks so
 257   // convert them directly to an invokespecial or invokestatic.
 258   if (target-&gt;is_loaded() &amp;&amp; !target-&gt;is_abstract() &amp;&amp; target-&gt;can_be_statically_bound()) {
 259     switch (code) {
 260     case Bytecodes::_invokevirtual:
 261       code = Bytecodes::_invokespecial;
 262       break;
 263     case Bytecodes::_invokehandle:
 264       code = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokespecial;
 265       break;
 266     default:
 267       break;
 268     }
 269   }
 270 
 271   // compute size of arguments
 272   int arg_size = target-&gt;invoke_arg_size(code);
 273   int arg_base = MAX2(state._stack_height - arg_size, 0);
 274 
 275   // direct recursive calls are skipped if they can be bound statically without introducing
 276   // dependencies and if parameters are passed at the same position as in the current method
 277   // other calls are skipped if there are no unescaped arguments passed to them
 278   bool directly_recursive = (method() == target) &amp;&amp;
 279                (code != Bytecodes::_invokevirtual || target-&gt;is_final_method() || state._stack[arg_base] .is_empty());
 280 
 281   // check if analysis of callee can safely be skipped
 282   bool skip_callee = true;
 283   for (i = state._stack_height - 1; i &gt;= arg_base &amp;&amp; skip_callee; i--) {
 284     ArgumentMap arg = state._stack[i];
 285     skip_callee = !is_argument(arg) || !is_arg_stack(arg) || (directly_recursive &amp;&amp; arg.is_singleton(i - arg_base));
 286   }
 287   // For now we conservatively skip invokedynamic.
 288   if (code == Bytecodes::_invokedynamic) {
 289     skip_callee = true;
 290   }
 291   if (skip_callee) {
 292     TRACE_BCEA(3, tty-&gt;print_cr(&quot;[EA] skipping method %s::%s&quot;, holder-&gt;name()-&gt;as_utf8(), target-&gt;name()-&gt;as_utf8()));
 293     for (i = 0; i &lt; arg_size; i++) {
 294       set_method_escape(state.raw_pop());
 295     }
 296     _unknown_modified = true;  // assume the worst since we don&#39;t analyze the called method
 297     return;
 298   }
 299 
 300   // determine actual method (use CHA if necessary)
 301   ciMethod* inline_target = NULL;
 302   if (target-&gt;is_loaded() &amp;&amp; klass-&gt;is_loaded()
 303       &amp;&amp; (klass-&gt;is_initialized() || (klass-&gt;is_interface() &amp;&amp; target-&gt;holder()-&gt;is_initialized()))
 304       &amp;&amp; target-&gt;is_loaded()) {
 305     if (code == Bytecodes::_invokestatic
 306         || code == Bytecodes::_invokespecial
 307         || (code == Bytecodes::_invokevirtual &amp;&amp; target-&gt;is_final_method())) {
 308       inline_target = target;
 309     } else {
 310       inline_target = target-&gt;find_monomorphic_target(calling_klass, callee_holder, actual_recv);
 311     }
 312   }
 313 
 314   if (inline_target != NULL &amp;&amp; !is_recursive_call(inline_target)) {
 315     // analyze callee
 316     BCEscapeAnalyzer analyzer(inline_target, this);
 317 
 318     // adjust escape state of actual parameters
 319     bool must_record_dependencies = false;
 320     for (i = arg_size - 1; i &gt;= 0; i--) {
 321       ArgumentMap arg = state.raw_pop();
 322       // Check if callee arg is a caller arg or an allocated object
 323       bool allocated = arg.contains_allocated();
 324       if (!(is_argument(arg) || allocated))
 325         continue;
 326       for (int j = 0; j &lt; _arg_size; j++) {
 327         if (arg.contains(j)) {
 328           _arg_modified[j] |= analyzer._arg_modified[i];
 329         }
 330       }
 331       if (!(is_arg_stack(arg) || allocated)) {
 332         // arguments have already been recognized as escaping
 333       } else if (analyzer.is_arg_stack(i) &amp;&amp; !analyzer.is_arg_returned(i)) {
 334         set_method_escape(arg);
 335         must_record_dependencies = true;
 336       } else {
 337         set_global_escape(arg);
 338       }
 339     }
 340     _unknown_modified = _unknown_modified || analyzer.has_non_arg_side_affects();
 341 
 342     // record dependencies if at least one parameter retained stack-allocatable
 343     if (must_record_dependencies) {
 344       if (code == Bytecodes::_invokeinterface ||
 345           (code == Bytecodes::_invokevirtual &amp;&amp; !target-&gt;is_final_method())) {
 346         _dependencies.append(actual_recv);
 347         _dependencies.append(inline_target);
 348       }
 349       _dependencies.appendAll(analyzer.dependencies());
 350     }
 351   } else {
 352     TRACE_BCEA(1, tty-&gt;print_cr(&quot;[EA] virtual method %s is not monomorphic.&quot;,
 353                                 target-&gt;name()-&gt;as_utf8()));
 354     // conservatively mark all actual parameters as escaping globally
 355     for (i = 0; i &lt; arg_size; i++) {
 356       ArgumentMap arg = state.raw_pop();
 357       if (!is_argument(arg))
 358         continue;
 359       set_modified(arg, OFFSET_ANY, type2size[T_INT]*HeapWordSize);
 360       set_global_escape(arg);
 361     }
 362     _unknown_modified = true;  // assume the worst since we don&#39;t know the called method
 363   }
 364 }
 365 
 366 bool BCEscapeAnalyzer::contains(uint arg_set1, uint arg_set2) {
 367   return ((~arg_set1) | arg_set2) == 0;
 368 }
 369 
 370 
 371 void BCEscapeAnalyzer::iterate_one_block(ciBlock *blk, StateInfo &amp;state, GrowableArray&lt;ciBlock *&gt; &amp;successors) {
 372 
 373   blk-&gt;set_processed();
 374   ciBytecodeStream s(method());
 375   int limit_bci = blk-&gt;limit_bci();
 376   bool fall_through = false;
 377   ArgumentMap allocated_obj;
 378   allocated_obj.add_allocated();
 379   ArgumentMap unknown_obj;
 380   unknown_obj.add_unknown();
 381   ArgumentMap empty_map;
 382 
 383   s.reset_to_bci(blk-&gt;start_bci());
 384   while (s.next() != ciBytecodeStream::EOBC() &amp;&amp; s.cur_bci() &lt; limit_bci) {
 385     fall_through = true;
 386     switch (s.cur_bc()) {
 387       case Bytecodes::_nop:
 388         break;
 389       case Bytecodes::_aconst_null:
 390         state.apush(unknown_obj);
 391         break;
 392       case Bytecodes::_iconst_m1:
 393       case Bytecodes::_iconst_0:
 394       case Bytecodes::_iconst_1:
 395       case Bytecodes::_iconst_2:
 396       case Bytecodes::_iconst_3:
 397       case Bytecodes::_iconst_4:
 398       case Bytecodes::_iconst_5:
 399       case Bytecodes::_fconst_0:
 400       case Bytecodes::_fconst_1:
 401       case Bytecodes::_fconst_2:
 402       case Bytecodes::_bipush:
 403       case Bytecodes::_sipush:
 404         state.spush();
 405         break;
 406       case Bytecodes::_lconst_0:
 407       case Bytecodes::_lconst_1:
 408       case Bytecodes::_dconst_0:
 409       case Bytecodes::_dconst_1:
 410         state.lpush();
 411         break;
 412       case Bytecodes::_ldc:
 413       case Bytecodes::_ldc_w:
 414       case Bytecodes::_ldc2_w:
 415       {
 416         // Avoid calling get_constant() which will try to allocate
 417         // unloaded constant. We need only constant&#39;s type.
 418         int index = s.get_constant_pool_index();
 419         constantTag tag = s.get_constant_pool_tag(index);
 420         if (tag.is_long() || tag.is_double()) {
 421           // Only longs and doubles use 2 stack slots.
 422           state.lpush();
 423         } else if (tag.basic_type() == T_OBJECT) {
 424           state.apush(unknown_obj);
 425         } else {
 426           state.spush();
 427         }
 428         break;
 429       }
 430       case Bytecodes::_aload:
 431         state.apush(state._vars[s.get_index()]);
 432         break;
 433       case Bytecodes::_iload:
 434       case Bytecodes::_fload:
 435       case Bytecodes::_iload_0:
 436       case Bytecodes::_iload_1:
 437       case Bytecodes::_iload_2:
 438       case Bytecodes::_iload_3:
 439       case Bytecodes::_fload_0:
 440       case Bytecodes::_fload_1:
 441       case Bytecodes::_fload_2:
 442       case Bytecodes::_fload_3:
 443         state.spush();
 444         break;
 445       case Bytecodes::_lload:
 446       case Bytecodes::_dload:
 447       case Bytecodes::_lload_0:
 448       case Bytecodes::_lload_1:
 449       case Bytecodes::_lload_2:
 450       case Bytecodes::_lload_3:
 451       case Bytecodes::_dload_0:
 452       case Bytecodes::_dload_1:
 453       case Bytecodes::_dload_2:
 454       case Bytecodes::_dload_3:
 455         state.lpush();
 456         break;
 457       case Bytecodes::_aload_0:
 458         state.apush(state._vars[0]);
 459         break;
 460       case Bytecodes::_aload_1:
 461         state.apush(state._vars[1]);
 462         break;
 463       case Bytecodes::_aload_2:
 464         state.apush(state._vars[2]);
 465         break;
 466       case Bytecodes::_aload_3:
 467         state.apush(state._vars[3]);
 468         break;
 469       case Bytecodes::_iaload:
 470       case Bytecodes::_faload:
 471       case Bytecodes::_baload:
 472       case Bytecodes::_caload:
 473       case Bytecodes::_saload:
 474         state.spop();
 475         set_method_escape(state.apop());
 476         state.spush();
 477         break;
 478       case Bytecodes::_laload:
 479       case Bytecodes::_daload:
 480         state.spop();
 481         set_method_escape(state.apop());
 482         state.lpush();
 483         break;
 484       case Bytecodes::_aaload:
 485         { state.spop();
 486           ArgumentMap array = state.apop();
 487           set_method_escape(array);
 488           state.apush(unknown_obj);
 489           set_dirty(array);
 490         }
 491         break;
 492       case Bytecodes::_istore:
 493       case Bytecodes::_fstore:
 494       case Bytecodes::_istore_0:
 495       case Bytecodes::_istore_1:
 496       case Bytecodes::_istore_2:
 497       case Bytecodes::_istore_3:
 498       case Bytecodes::_fstore_0:
 499       case Bytecodes::_fstore_1:
 500       case Bytecodes::_fstore_2:
 501       case Bytecodes::_fstore_3:
 502         state.spop();
 503         break;
 504       case Bytecodes::_lstore:
 505       case Bytecodes::_dstore:
 506       case Bytecodes::_lstore_0:
 507       case Bytecodes::_lstore_1:
 508       case Bytecodes::_lstore_2:
 509       case Bytecodes::_lstore_3:
 510       case Bytecodes::_dstore_0:
 511       case Bytecodes::_dstore_1:
 512       case Bytecodes::_dstore_2:
 513       case Bytecodes::_dstore_3:
 514         state.lpop();
 515         break;
 516       case Bytecodes::_astore:
 517         state._vars[s.get_index()] = state.apop();
 518         break;
 519       case Bytecodes::_astore_0:
 520         state._vars[0] = state.apop();
 521         break;
 522       case Bytecodes::_astore_1:
 523         state._vars[1] = state.apop();
 524         break;
 525       case Bytecodes::_astore_2:
 526         state._vars[2] = state.apop();
 527         break;
 528       case Bytecodes::_astore_3:
 529         state._vars[3] = state.apop();
 530         break;
 531       case Bytecodes::_iastore:
 532       case Bytecodes::_fastore:
 533       case Bytecodes::_bastore:
 534       case Bytecodes::_castore:
 535       case Bytecodes::_sastore:
 536       {
 537         state.spop();
 538         state.spop();
 539         ArgumentMap arr = state.apop();
 540         set_method_escape(arr);
 541         set_modified(arr, OFFSET_ANY, type2size[T_INT]*HeapWordSize);
 542         break;
 543       }
 544       case Bytecodes::_lastore:
 545       case Bytecodes::_dastore:
 546       {
 547         state.lpop();
 548         state.spop();
 549         ArgumentMap arr = state.apop();
 550         set_method_escape(arr);
 551         set_modified(arr, OFFSET_ANY, type2size[T_LONG]*HeapWordSize);
 552         break;
 553       }
 554       case Bytecodes::_aastore:
 555       {
 556         set_global_escape(state.apop());
 557         state.spop();
 558         ArgumentMap arr = state.apop();
 559         set_modified(arr, OFFSET_ANY, type2size[T_OBJECT]*HeapWordSize);
 560         break;
 561       }
 562       case Bytecodes::_pop:
 563         state.raw_pop();
 564         break;
 565       case Bytecodes::_pop2:
 566         state.raw_pop();
 567         state.raw_pop();
 568         break;
 569       case Bytecodes::_dup:
 570         { ArgumentMap w1 = state.raw_pop();
 571           state.raw_push(w1);
 572           state.raw_push(w1);
 573         }
 574         break;
 575       case Bytecodes::_dup_x1:
 576         { ArgumentMap w1 = state.raw_pop();
 577           ArgumentMap w2 = state.raw_pop();
 578           state.raw_push(w1);
 579           state.raw_push(w2);
 580           state.raw_push(w1);
 581         }
 582         break;
 583       case Bytecodes::_dup_x2:
 584         { ArgumentMap w1 = state.raw_pop();
 585           ArgumentMap w2 = state.raw_pop();
 586           ArgumentMap w3 = state.raw_pop();
 587           state.raw_push(w1);
 588           state.raw_push(w3);
 589           state.raw_push(w2);
 590           state.raw_push(w1);
 591         }
 592         break;
 593       case Bytecodes::_dup2:
 594         { ArgumentMap w1 = state.raw_pop();
 595           ArgumentMap w2 = state.raw_pop();
 596           state.raw_push(w2);
 597           state.raw_push(w1);
 598           state.raw_push(w2);
 599           state.raw_push(w1);
 600         }
 601         break;
 602       case Bytecodes::_dup2_x1:
 603         { ArgumentMap w1 = state.raw_pop();
 604           ArgumentMap w2 = state.raw_pop();
 605           ArgumentMap w3 = state.raw_pop();
 606           state.raw_push(w2);
 607           state.raw_push(w1);
 608           state.raw_push(w3);
 609           state.raw_push(w2);
 610           state.raw_push(w1);
 611         }
 612         break;
 613       case Bytecodes::_dup2_x2:
 614         { ArgumentMap w1 = state.raw_pop();
 615           ArgumentMap w2 = state.raw_pop();
 616           ArgumentMap w3 = state.raw_pop();
 617           ArgumentMap w4 = state.raw_pop();
 618           state.raw_push(w2);
 619           state.raw_push(w1);
 620           state.raw_push(w4);
 621           state.raw_push(w3);
 622           state.raw_push(w2);
 623           state.raw_push(w1);
 624         }
 625         break;
 626       case Bytecodes::_swap:
 627         { ArgumentMap w1 = state.raw_pop();
 628           ArgumentMap w2 = state.raw_pop();
 629           state.raw_push(w1);
 630           state.raw_push(w2);
 631         }
 632         break;
 633       case Bytecodes::_iadd:
 634       case Bytecodes::_fadd:
 635       case Bytecodes::_isub:
 636       case Bytecodes::_fsub:
 637       case Bytecodes::_imul:
 638       case Bytecodes::_fmul:
 639       case Bytecodes::_idiv:
 640       case Bytecodes::_fdiv:
 641       case Bytecodes::_irem:
 642       case Bytecodes::_frem:
 643       case Bytecodes::_iand:
 644       case Bytecodes::_ior:
 645       case Bytecodes::_ixor:
 646         state.spop();
 647         state.spop();
 648         state.spush();
 649         break;
 650       case Bytecodes::_ladd:
 651       case Bytecodes::_dadd:
 652       case Bytecodes::_lsub:
 653       case Bytecodes::_dsub:
 654       case Bytecodes::_lmul:
 655       case Bytecodes::_dmul:
 656       case Bytecodes::_ldiv:
 657       case Bytecodes::_ddiv:
 658       case Bytecodes::_lrem:
 659       case Bytecodes::_drem:
 660       case Bytecodes::_land:
 661       case Bytecodes::_lor:
 662       case Bytecodes::_lxor:
 663         state.lpop();
 664         state.lpop();
 665         state.lpush();
 666         break;
 667       case Bytecodes::_ishl:
 668       case Bytecodes::_ishr:
 669       case Bytecodes::_iushr:
 670         state.spop();
 671         state.spop();
 672         state.spush();
 673         break;
 674       case Bytecodes::_lshl:
 675       case Bytecodes::_lshr:
 676       case Bytecodes::_lushr:
 677         state.spop();
 678         state.lpop();
 679         state.lpush();
 680         break;
 681       case Bytecodes::_ineg:
 682       case Bytecodes::_fneg:
 683         state.spop();
 684         state.spush();
 685         break;
 686       case Bytecodes::_lneg:
 687       case Bytecodes::_dneg:
 688         state.lpop();
 689         state.lpush();
 690         break;
 691       case Bytecodes::_iinc:
 692         break;
 693       case Bytecodes::_i2l:
 694       case Bytecodes::_i2d:
 695       case Bytecodes::_f2l:
 696       case Bytecodes::_f2d:
 697         state.spop();
 698         state.lpush();
 699         break;
 700       case Bytecodes::_i2f:
 701       case Bytecodes::_f2i:
 702         state.spop();
 703         state.spush();
 704         break;
 705       case Bytecodes::_l2i:
 706       case Bytecodes::_l2f:
 707       case Bytecodes::_d2i:
 708       case Bytecodes::_d2f:
 709         state.lpop();
 710         state.spush();
 711         break;
 712       case Bytecodes::_l2d:
 713       case Bytecodes::_d2l:
 714         state.lpop();
 715         state.lpush();
 716         break;
 717       case Bytecodes::_i2b:
 718       case Bytecodes::_i2c:
 719       case Bytecodes::_i2s:
 720         state.spop();
 721         state.spush();
 722         break;
 723       case Bytecodes::_lcmp:
 724       case Bytecodes::_dcmpl:
 725       case Bytecodes::_dcmpg:
 726         state.lpop();
 727         state.lpop();
 728         state.spush();
 729         break;
 730       case Bytecodes::_fcmpl:
 731       case Bytecodes::_fcmpg:
 732         state.spop();
 733         state.spop();
 734         state.spush();
 735         break;
 736       case Bytecodes::_ifeq:
 737       case Bytecodes::_ifne:
 738       case Bytecodes::_iflt:
 739       case Bytecodes::_ifge:
 740       case Bytecodes::_ifgt:
 741       case Bytecodes::_ifle:
 742       {
 743         state.spop();
 744         int dest_bci = s.get_dest();
 745         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 746         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 747         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 748         break;
 749       }
 750       case Bytecodes::_if_icmpeq:
 751       case Bytecodes::_if_icmpne:
 752       case Bytecodes::_if_icmplt:
 753       case Bytecodes::_if_icmpge:
 754       case Bytecodes::_if_icmpgt:
 755       case Bytecodes::_if_icmple:
 756       {
 757         state.spop();
 758         state.spop();
 759         int dest_bci = s.get_dest();
 760         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 761         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 762         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 763         break;
 764       }
 765       case Bytecodes::_if_acmpeq:
 766       case Bytecodes::_if_acmpne:
 767       {
 768         set_method_escape(state.apop());
 769         set_method_escape(state.apop());
 770         int dest_bci = s.get_dest();
 771         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 772         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 773         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 774         break;
 775       }
 776       case Bytecodes::_goto:
 777       {
 778         int dest_bci = s.get_dest();
 779         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 780         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 781         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 782         fall_through = false;
 783         break;
 784       }
 785       case Bytecodes::_jsr:
 786       {
 787         int dest_bci = s.get_dest();
 788         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 789         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 790         state.apush(empty_map);
 791         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 792         fall_through = false;
 793         break;
 794       }
 795       case Bytecodes::_ret:
 796         // we don&#39;t track  the destination of a &quot;ret&quot; instruction
 797         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 798         fall_through = false;
 799         break;
 800       case Bytecodes::_return:
 801         assert(s.next_bci() == limit_bci, &quot;return must end block&quot;);
 802         fall_through = false;
 803         break;
 804       case Bytecodes::_tableswitch:
 805         {
 806           state.spop();
 807           Bytecode_tableswitch sw(&amp;s);
 808           int len = sw.length();
 809           int dest_bci;
 810           for (int i = 0; i &lt; len; i++) {
 811             dest_bci = s.cur_bci() + sw.dest_offset_at(i);
 812             assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 813             successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 814           }
 815           dest_bci = s.cur_bci() + sw.default_offset();
 816           assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 817           successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 818           assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 819           fall_through = false;
 820           break;
 821         }
 822       case Bytecodes::_lookupswitch:
 823         {
 824           state.spop();
 825           Bytecode_lookupswitch sw(&amp;s);
 826           int len = sw.number_of_pairs();
 827           int dest_bci;
 828           for (int i = 0; i &lt; len; i++) {
 829             dest_bci = s.cur_bci() + sw.pair_at(i).offset();
 830             assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 831             successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 832           }
 833           dest_bci = s.cur_bci() + sw.default_offset();
 834           assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 835           successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 836           fall_through = false;
 837           break;
 838         }
 839       case Bytecodes::_ireturn:
 840       case Bytecodes::_freturn:
 841         state.spop();
 842         fall_through = false;
 843         break;
 844       case Bytecodes::_lreturn:
 845       case Bytecodes::_dreturn:
 846         state.lpop();
 847         fall_through = false;
 848         break;
 849       case Bytecodes::_areturn:
 850         set_returned(state.apop());
 851         fall_through = false;
 852         break;
 853       case Bytecodes::_getstatic:
 854       case Bytecodes::_getfield:
 855         { bool ignored_will_link;
 856           ciField* field = s.get_field(ignored_will_link);
 857           BasicType field_type = field-&gt;type()-&gt;basic_type();
 858           if (s.cur_bc() != Bytecodes::_getstatic) {
 859             set_method_escape(state.apop());
 860           }
 861           if (is_reference_type(field_type)) {
 862             state.apush(unknown_obj);
 863           } else if (type2size[field_type] == 1) {
 864             state.spush();
 865           } else {
 866             state.lpush();
 867           }
 868         }
 869         break;
 870       case Bytecodes::_putstatic:
 871       case Bytecodes::_putfield:
 872         { bool will_link;
 873           ciField* field = s.get_field(will_link);
 874           BasicType field_type = field-&gt;type()-&gt;basic_type();
 875           if (is_reference_type(field_type)) {
 876             set_global_escape(state.apop());
 877           } else if (type2size[field_type] == 1) {
 878             state.spop();
 879           } else {
 880             state.lpop();
 881           }
 882           if (s.cur_bc() != Bytecodes::_putstatic) {
 883             ArgumentMap p = state.apop();
 884             set_method_escape(p);
 885             set_modified(p, will_link ? field-&gt;offset() : OFFSET_ANY, type2size[field_type]*HeapWordSize);
 886           }
 887         }
 888         break;
 889       case Bytecodes::_invokevirtual:
 890       case Bytecodes::_invokespecial:
 891       case Bytecodes::_invokestatic:
 892       case Bytecodes::_invokedynamic:
 893       case Bytecodes::_invokeinterface:
 894         { bool ignored_will_link;
 895           ciSignature* declared_signature = NULL;
 896           ciMethod* target = s.get_method(ignored_will_link, &amp;declared_signature);
 897           ciKlass*  holder = s.get_declared_method_holder();
 898           assert(declared_signature != NULL, &quot;cannot be null&quot;);
 899           // If the current bytecode has an attached appendix argument,
 900           // push an unknown object to represent that argument. (Analysis
 901           // of dynamic call sites, especially invokehandle calls, needs
 902           // the appendix argument on the stack, in addition to &quot;regular&quot; arguments
 903           // pushed onto the stack by bytecode instructions preceding the call.)
 904           //
 905           // The escape analyzer does _not_ use the ciBytecodeStream::has_appendix(s)
 906           // method to determine whether the current bytecode has an appendix argument.
 907           // The has_appendix() method obtains the appendix from the
 908           // ConstantPoolCacheEntry::_f1 field, which can happen concurrently with
 909           // resolution of dynamic call sites. Callees in the
 910           // ciBytecodeStream::get_method() call above also access the _f1 field;
 911           // interleaving the get_method() and has_appendix() calls in the current
 912           // method with call site resolution can lead to an inconsistent view of
 913           // the current method&#39;s argument count. In particular, some interleaving(s)
 914           // can cause the method&#39;s argument count to not include the appendix, which
 915           // then leads to stack over-/underflow in the escape analyzer.
 916           //
 917           // Instead of pushing the argument if has_appendix() is true, the escape analyzer
 918           // pushes an appendix for all call sites targeted by invokedynamic and invokehandle
 919           // instructions, except if the call site is the _invokeBasic intrinsic
 920           // (that intrinsic is always targeted by an invokehandle instruction but does
 921           // not have an appendix argument).
 922           if (target-&gt;is_loaded() &amp;&amp;
 923               Bytecodes::has_optional_appendix(s.cur_bc_raw()) &amp;&amp;
 924               target-&gt;intrinsic_id() != vmIntrinsics::_invokeBasic) {
 925             state.apush(unknown_obj);
 926           }
 927           // Pass in raw bytecode because we need to see invokehandle instructions.
 928           invoke(state, s.cur_bc_raw(), target, holder);
 929           // We are using the return type of the declared signature here because
 930           // it might be a more concrete type than the one from the target (for
 931           // e.g. invokedynamic and invokehandle).
 932           ciType* return_type = declared_signature-&gt;return_type();
 933           if (!return_type-&gt;is_primitive_type()) {
 934             state.apush(unknown_obj);
 935           } else if (return_type-&gt;is_one_word()) {
 936             state.spush();
 937           } else if (return_type-&gt;is_two_word()) {
 938             state.lpush();
 939           }
 940         }
 941         break;
 942       case Bytecodes::_new:
 943         state.apush(allocated_obj);
 944         break;
 945       case Bytecodes::_newarray:
 946       case Bytecodes::_anewarray:
 947         state.spop();
 948         state.apush(allocated_obj);
 949         break;
 950       case Bytecodes::_multianewarray:
 951         { int i = s.cur_bcp()[3];
 952           while (i-- &gt; 0) state.spop();
 953           state.apush(allocated_obj);
 954         }
 955         break;
 956       case Bytecodes::_arraylength:
 957         set_method_escape(state.apop());
 958         state.spush();
 959         break;
 960       case Bytecodes::_athrow:
 961         set_global_escape(state.apop());
 962         fall_through = false;
 963         break;
 964       case Bytecodes::_checkcast:
 965         { ArgumentMap obj = state.apop();
 966           set_method_escape(obj);
 967           state.apush(obj);
 968         }
 969         break;
 970       case Bytecodes::_instanceof:
 971         set_method_escape(state.apop());
 972         state.spush();
 973         break;
 974       case Bytecodes::_monitorenter:
 975       case Bytecodes::_monitorexit:
 976         state.apop();
 977         break;
 978       case Bytecodes::_wide:
 979         ShouldNotReachHere();
 980         break;
 981       case Bytecodes::_ifnull:
 982       case Bytecodes::_ifnonnull:
 983       {
 984         set_method_escape(state.apop());
 985         int dest_bci = s.get_dest();
 986         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 987         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 988         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 989         break;
 990       }
 991       case Bytecodes::_goto_w:
 992       {
 993         int dest_bci = s.get_far_dest();
 994         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 995         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 996         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 997         fall_through = false;
 998         break;
 999       }
1000       case Bytecodes::_jsr_w:
1001       {
1002         int dest_bci = s.get_far_dest();
1003         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
1004         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
1005         state.apush(empty_map);
1006         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
1007         fall_through = false;
1008         break;
1009       }
1010       case Bytecodes::_breakpoint:
1011         break;
1012       default:
1013         ShouldNotReachHere();
1014         break;
1015     }
1016 
1017   }
1018   if (fall_through) {
1019     int fall_through_bci = s.cur_bci();
1020     if (fall_through_bci &lt; _method-&gt;code_size()) {
1021       assert(_methodBlocks-&gt;is_block_start(fall_through_bci), &quot;must fall through to block start.&quot;);
1022       successors.push(_methodBlocks-&gt;block_containing(fall_through_bci));
1023     }
1024   }
1025 }
1026 
1027 void BCEscapeAnalyzer::merge_block_states(StateInfo *blockstates, ciBlock *dest, StateInfo *s_state) {
1028   StateInfo *d_state = blockstates + dest-&gt;index();
1029   int nlocals = _method-&gt;max_locals();
1030 
1031   // exceptions may cause transfer of control to handlers in the middle of a
1032   // block, so we don&#39;t merge the incoming state of exception handlers
1033   if (dest-&gt;is_handler())
1034     return;
1035   if (!d_state-&gt;_initialized ) {
1036     // destination not initialized, just copy
1037     for (int i = 0; i &lt; nlocals; i++) {
1038       d_state-&gt;_vars[i] = s_state-&gt;_vars[i];
1039     }
1040     for (int i = 0; i &lt; s_state-&gt;_stack_height; i++) {
1041       d_state-&gt;_stack[i] = s_state-&gt;_stack[i];
1042     }
1043     d_state-&gt;_stack_height = s_state-&gt;_stack_height;
1044     d_state-&gt;_max_stack = s_state-&gt;_max_stack;
1045     d_state-&gt;_initialized = true;
1046   } else if (!dest-&gt;processed()) {
1047     // we have not yet walked the bytecodes of dest, we can merge
1048     // the states
1049     assert(d_state-&gt;_stack_height == s_state-&gt;_stack_height, &quot;computed stack heights must match&quot;);
1050     for (int i = 0; i &lt; nlocals; i++) {
1051       d_state-&gt;_vars[i].set_union(s_state-&gt;_vars[i]);
1052     }
1053     for (int i = 0; i &lt; s_state-&gt;_stack_height; i++) {
1054       d_state-&gt;_stack[i].set_union(s_state-&gt;_stack[i]);
1055     }
1056   } else {
1057     // the bytecodes of dest have already been processed, mark any
1058     // arguments in the source state which are not in the dest state
1059     // as global escape.
1060     // Future refinement:  we only need to mark these variable to the
1061     // maximum escape of any variables in dest state
1062     assert(d_state-&gt;_stack_height == s_state-&gt;_stack_height, &quot;computed stack heights must match&quot;);
1063     ArgumentMap extra_vars;
1064     for (int i = 0; i &lt; nlocals; i++) {
1065       ArgumentMap t;
1066       t = s_state-&gt;_vars[i];
1067       t.set_difference(d_state-&gt;_vars[i]);
1068       extra_vars.set_union(t);
1069     }
1070     for (int i = 0; i &lt; s_state-&gt;_stack_height; i++) {
1071       ArgumentMap t;
1072       //extra_vars |= !d_state-&gt;_vars[i] &amp; s_state-&gt;_vars[i];
1073       t.clear();
1074       t = s_state-&gt;_stack[i];
1075       t.set_difference(d_state-&gt;_stack[i]);
1076       extra_vars.set_union(t);
1077     }
1078     set_global_escape(extra_vars, true);
1079   }
1080 }
1081 
1082 void BCEscapeAnalyzer::iterate_blocks(Arena *arena) {
1083   int numblocks = _methodBlocks-&gt;num_blocks();
1084   int stkSize   = _method-&gt;max_stack();
1085   int numLocals = _method-&gt;max_locals();
1086   StateInfo state;
1087 
1088   int datacount = (numblocks + 1) * (stkSize + numLocals);
1089   int datasize = datacount * sizeof(ArgumentMap);
1090   StateInfo *blockstates = (StateInfo *) arena-&gt;Amalloc(numblocks * sizeof(StateInfo));
1091   ArgumentMap *statedata  = (ArgumentMap *) arena-&gt;Amalloc(datasize);
1092   for (int i = 0; i &lt; datacount; i++) ::new ((void*)&amp;statedata[i]) ArgumentMap();
1093   ArgumentMap *dp = statedata;
1094   state._vars = dp;
1095   dp += numLocals;
1096   state._stack = dp;
1097   dp += stkSize;
1098   state._initialized = false;
1099   state._max_stack = stkSize;
1100   for (int i = 0; i &lt; numblocks; i++) {
1101     blockstates[i]._vars = dp;
1102     dp += numLocals;
1103     blockstates[i]._stack = dp;
1104     dp += stkSize;
1105     blockstates[i]._initialized = false;
1106     blockstates[i]._stack_height = 0;
1107     blockstates[i]._max_stack  = stkSize;
1108   }
1109   GrowableArray&lt;ciBlock *&gt; worklist(arena, numblocks / 4, 0, NULL);
1110   GrowableArray&lt;ciBlock *&gt; successors(arena, 4, 0, NULL);
1111 
1112   _methodBlocks-&gt;clear_processed();
1113 
1114   // initialize block 0 state from method signature
1115   ArgumentMap allVars;   // all oop arguments to method
1116   ciSignature* sig = method()-&gt;signature();
1117   int j = 0;
1118   ciBlock* first_blk = _methodBlocks-&gt;block_containing(0);
1119   int fb_i = first_blk-&gt;index();
1120   if (!method()-&gt;is_static()) {
1121     // record information for &quot;this&quot;
1122     blockstates[fb_i]._vars[j].set(j);
1123     allVars.add(j);
1124     j++;
1125   }
1126   for (int i = 0; i &lt; sig-&gt;count(); i++) {
1127     ciType* t = sig-&gt;type_at(i);
1128     if (!t-&gt;is_primitive_type()) {
1129       blockstates[fb_i]._vars[j].set(j);
1130       allVars.add(j);
1131     }
1132     j += t-&gt;size();
1133   }
1134   blockstates[fb_i]._initialized = true;
1135   assert(j == _arg_size, &quot;just checking&quot;);
1136 
1137   ArgumentMap unknown_map;
1138   unknown_map.add_unknown();
1139 
1140   worklist.push(first_blk);
1141   while(worklist.length() &gt; 0) {
1142     ciBlock *blk = worklist.pop();
1143     StateInfo *blkState = blockstates + blk-&gt;index();
1144     if (blk-&gt;is_handler() || blk-&gt;is_ret_target()) {
1145       // for an exception handler or a target of a ret instruction, we assume the worst case,
1146       // that any variable could contain any argument
1147       for (int i = 0; i &lt; numLocals; i++) {
1148         state._vars[i] = allVars;
1149       }
1150       if (blk-&gt;is_handler()) {
1151         state._stack_height = 1;
1152       } else {
1153         state._stack_height = blkState-&gt;_stack_height;
1154       }
1155       for (int i = 0; i &lt; state._stack_height; i++) {
1156 // ??? should this be unknown_map ???
1157         state._stack[i] = allVars;
1158       }
1159     } else {
1160       for (int i = 0; i &lt; numLocals; i++) {
1161         state._vars[i] = blkState-&gt;_vars[i];
1162       }
1163       for (int i = 0; i &lt; blkState-&gt;_stack_height; i++) {
1164         state._stack[i] = blkState-&gt;_stack[i];
1165       }
1166       state._stack_height = blkState-&gt;_stack_height;
1167     }
1168     iterate_one_block(blk, state, successors);
1169     // if this block has any exception handlers, push them
1170     // onto successor list
1171     if (blk-&gt;has_handler()) {
1172       DEBUG_ONLY(int handler_count = 0;)
1173       int blk_start = blk-&gt;start_bci();
1174       int blk_end = blk-&gt;limit_bci();
1175       for (int i = 0; i &lt; numblocks; i++) {
1176         ciBlock *b = _methodBlocks-&gt;block(i);
1177         if (b-&gt;is_handler()) {
1178           int ex_start = b-&gt;ex_start_bci();
1179           int ex_end = b-&gt;ex_limit_bci();
1180           if ((ex_start &gt;= blk_start &amp;&amp; ex_start &lt; blk_end) ||
1181               (ex_end &gt; blk_start &amp;&amp; ex_end &lt;= blk_end)) {
1182             successors.push(b);
1183           }
1184           DEBUG_ONLY(handler_count++;)
1185         }
1186       }
1187       assert(handler_count &gt; 0, &quot;must find at least one handler&quot;);
1188     }
1189     // merge computed variable state with successors
1190     while(successors.length() &gt; 0) {
1191       ciBlock *succ = successors.pop();
1192       merge_block_states(blockstates, succ, &amp;state);
1193       if (!succ-&gt;processed())
1194         worklist.push(succ);
1195     }
1196   }
1197 }
1198 
1199 void BCEscapeAnalyzer::do_analysis() {
1200   Arena* arena = CURRENT_ENV-&gt;arena();
1201   // identify basic blocks
1202   _methodBlocks = _method-&gt;get_method_blocks();
1203 
1204   iterate_blocks(arena);
1205 }
1206 
1207 vmIntrinsics::ID BCEscapeAnalyzer::known_intrinsic() {
1208   vmIntrinsics::ID iid = method()-&gt;intrinsic_id();
1209   if (iid == vmIntrinsics::_getClass ||
1210       iid == vmIntrinsics::_hashCode) {
1211     return iid;
1212   } else {
1213     return vmIntrinsics::_none;
1214   }
1215 }
1216 
1217 void BCEscapeAnalyzer::compute_escape_for_intrinsic(vmIntrinsics::ID iid) {
1218   switch (iid) {
1219     case vmIntrinsics::_getClass:
1220       _return_local = false;
1221       _return_allocated = false;
1222       break;
1223     case vmIntrinsics::_hashCode:
1224       // initialized state is correct
1225       break;
1226   default:
1227     assert(false, &quot;unexpected intrinsic&quot;);
1228   }
1229 }
1230 
1231 void BCEscapeAnalyzer::initialize() {
1232   int i;
1233 
1234   // clear escape information (method may have been deoptimized)
1235   methodData()-&gt;clear_escape_info();
1236 
1237   // initialize escape state of object parameters
1238   ciSignature* sig = method()-&gt;signature();
1239   int j = 0;
1240   if (!method()-&gt;is_static()) {
1241     _arg_local.set(0);
1242     _arg_stack.set(0);
1243     j++;
1244   }
1245   for (i = 0; i &lt; sig-&gt;count(); i++) {
1246     ciType* t = sig-&gt;type_at(i);
1247     if (!t-&gt;is_primitive_type()) {
1248       _arg_local.set(j);
1249       _arg_stack.set(j);
1250     }
1251     j += t-&gt;size();
1252   }
1253   assert(j == _arg_size, &quot;just checking&quot;);
1254 
1255   // start with optimistic assumption
1256   ciType *rt = _method-&gt;return_type();
1257   if (rt-&gt;is_primitive_type()) {
1258     _return_local = false;
1259     _return_allocated = false;
1260   } else {
1261     _return_local = true;
1262     _return_allocated = true;
1263   }
1264   _allocated_escapes = false;
1265   _unknown_modified = false;
1266 }
1267 
1268 void BCEscapeAnalyzer::clear_escape_info() {
1269   ciSignature* sig = method()-&gt;signature();
1270   int arg_count = sig-&gt;count();
1271   ArgumentMap var;
1272   if (!method()-&gt;is_static()) {
1273     arg_count++;  // allow for &quot;this&quot;
1274   }
1275   for (int i = 0; i &lt; arg_count; i++) {
1276     set_arg_modified(i, OFFSET_ANY, 4);
1277     var.clear();
1278     var.set(i);
1279     set_modified(var, OFFSET_ANY, 4);
1280     set_global_escape(var);
1281   }
1282   _arg_local.clear();
1283   _arg_stack.clear();
1284   _arg_returned.clear();
1285   _return_local = false;
1286   _return_allocated = false;
1287   _allocated_escapes = true;
1288   _unknown_modified = true;
1289 }
1290 
1291 
1292 void BCEscapeAnalyzer::compute_escape_info() {
1293   int i;
1294   assert(!methodData()-&gt;has_escape_info(), &quot;do not overwrite escape info&quot;);
1295 
1296   vmIntrinsics::ID iid = known_intrinsic();
1297 
1298   // check if method can be analyzed
1299   if (iid == vmIntrinsics::_none &amp;&amp; (method()-&gt;is_abstract() || method()-&gt;is_native() || !method()-&gt;holder()-&gt;is_initialized()
1300       || _level &gt; MaxBCEAEstimateLevel
1301       || method()-&gt;code_size() &gt; MaxBCEAEstimateSize)) {
1302     if (BCEATraceLevel &gt;= 1) {
1303       tty-&gt;print(&quot;Skipping method because: &quot;);
1304       if (method()-&gt;is_abstract())
1305         tty-&gt;print_cr(&quot;method is abstract.&quot;);
1306       else if (method()-&gt;is_native())
1307         tty-&gt;print_cr(&quot;method is native.&quot;);
1308       else if (!method()-&gt;holder()-&gt;is_initialized())
1309         tty-&gt;print_cr(&quot;class of method is not initialized.&quot;);
1310       else if (_level &gt; MaxBCEAEstimateLevel)
1311         tty-&gt;print_cr(&quot;level (%d) exceeds MaxBCEAEstimateLevel (%d).&quot;,
1312                       _level, (int) MaxBCEAEstimateLevel);
1313       else if (method()-&gt;code_size() &gt; MaxBCEAEstimateSize)
1314         tty-&gt;print_cr(&quot;code size (%d) exceeds MaxBCEAEstimateSize (%d).&quot;,
1315                       method()-&gt;code_size(), (int) MaxBCEAEstimateSize);
1316       else
1317         ShouldNotReachHere();
1318     }
1319     clear_escape_info();
1320 
1321     return;
1322   }
1323 
1324   if (BCEATraceLevel &gt;= 1) {
1325     tty-&gt;print(&quot;[EA] estimating escape information for&quot;);
1326     if (iid != vmIntrinsics::_none)
1327       tty-&gt;print(&quot; intrinsic&quot;);
1328     method()-&gt;print_short_name();
1329     tty-&gt;print_cr(&quot; (%d bytes)&quot;, method()-&gt;code_size());
1330   }
1331 
1332   initialize();
1333 
1334   // Do not scan method if it has no object parameters and
1335   // does not returns an object (_return_allocated is set in initialize()).
1336   if (_arg_local.is_empty() &amp;&amp; !_return_allocated) {
1337     // Clear all info since method&#39;s bytecode was not analysed and
1338     // set pessimistic escape information.
1339     clear_escape_info();
1340     methodData()-&gt;set_eflag(MethodData::allocated_escapes);
1341     methodData()-&gt;set_eflag(MethodData::unknown_modified);
1342     methodData()-&gt;set_eflag(MethodData::estimated);
1343     return;
1344   }
1345 
1346   if (iid != vmIntrinsics::_none)
1347     compute_escape_for_intrinsic(iid);
1348   else {
1349     do_analysis();
1350   }
1351 
1352   // don&#39;t store interprocedural escape information if it introduces
1353   // dependencies or if method data is empty
1354   //
1355   if (!has_dependencies() &amp;&amp; !methodData()-&gt;is_empty()) {
1356     for (i = 0; i &lt; _arg_size; i++) {
1357       if (_arg_local.test(i)) {
1358         assert(_arg_stack.test(i), &quot;inconsistent escape info&quot;);
1359         methodData()-&gt;set_arg_local(i);
1360         methodData()-&gt;set_arg_stack(i);
1361       } else if (_arg_stack.test(i)) {
1362         methodData()-&gt;set_arg_stack(i);
1363       }
1364       if (_arg_returned.test(i)) {
1365         methodData()-&gt;set_arg_returned(i);
1366       }
1367       methodData()-&gt;set_arg_modified(i, _arg_modified[i]);
1368     }
1369     if (_return_local) {
1370       methodData()-&gt;set_eflag(MethodData::return_local);
1371     }
1372     if (_return_allocated) {
1373       methodData()-&gt;set_eflag(MethodData::return_allocated);
1374     }
1375     if (_allocated_escapes) {
1376       methodData()-&gt;set_eflag(MethodData::allocated_escapes);
1377     }
1378     if (_unknown_modified) {
1379       methodData()-&gt;set_eflag(MethodData::unknown_modified);
1380     }
1381     methodData()-&gt;set_eflag(MethodData::estimated);
1382   }
1383 }
1384 
1385 void BCEscapeAnalyzer::read_escape_info() {
1386   assert(methodData()-&gt;has_escape_info(), &quot;no escape info available&quot;);
1387 
1388   // read escape information from method descriptor
1389   for (int i = 0; i &lt; _arg_size; i++) {
1390     if (methodData()-&gt;is_arg_local(i))
1391       _arg_local.set(i);
1392     if (methodData()-&gt;is_arg_stack(i))
1393       _arg_stack.set(i);
1394     if (methodData()-&gt;is_arg_returned(i))
1395       _arg_returned.set(i);
1396     _arg_modified[i] = methodData()-&gt;arg_modified(i);
1397   }
1398   _return_local = methodData()-&gt;eflag_set(MethodData::return_local);
1399   _return_allocated = methodData()-&gt;eflag_set(MethodData::return_allocated);
1400   _allocated_escapes = methodData()-&gt;eflag_set(MethodData::allocated_escapes);
1401   _unknown_modified = methodData()-&gt;eflag_set(MethodData::unknown_modified);
1402 
1403 }
1404 
1405 #ifndef PRODUCT
1406 void BCEscapeAnalyzer::dump() {
1407   tty-&gt;print(&quot;[EA] estimated escape information for&quot;);
1408   method()-&gt;print_short_name();
1409   tty-&gt;print_cr(has_dependencies() ? &quot; (not stored)&quot; : &quot;&quot;);
1410   tty-&gt;print(&quot;     non-escaping args:      &quot;);
1411   _arg_local.print();
1412   tty-&gt;print(&quot;     stack-allocatable args: &quot;);
1413   _arg_stack.print();
1414   if (_return_local) {
1415     tty-&gt;print(&quot;     returned args:          &quot;);
1416     _arg_returned.print();
1417   } else if (is_return_allocated()) {
1418     tty-&gt;print_cr(&quot;     return allocated value&quot;);
1419   } else {
1420     tty-&gt;print_cr(&quot;     return non-local value&quot;);
1421   }
1422   tty-&gt;print(&quot;     modified args: &quot;);
1423   for (int i = 0; i &lt; _arg_size; i++) {
1424     if (_arg_modified[i] == 0)
1425       tty-&gt;print(&quot;    0&quot;);
1426     else
1427       tty-&gt;print(&quot;    0x%x&quot;, _arg_modified[i]);
1428   }
1429   tty-&gt;cr();
1430   tty-&gt;print(&quot;     flags: &quot;);
1431   if (_return_allocated)
1432     tty-&gt;print(&quot; return_allocated&quot;);
1433   if (_allocated_escapes)
1434     tty-&gt;print(&quot; allocated_escapes&quot;);
1435   if (_unknown_modified)
1436     tty-&gt;print(&quot; unknown_modified&quot;);
1437   tty-&gt;cr();
1438 }
1439 #endif
1440 
1441 BCEscapeAnalyzer::BCEscapeAnalyzer(ciMethod* method, BCEscapeAnalyzer* parent)
1442     : _arena(CURRENT_ENV-&gt;arena())
1443     , _conservative(method == NULL || !EstimateArgEscape)
1444     , _method(method)
1445     , _methodData(method ? method-&gt;method_data() : NULL)
1446     , _arg_size(method ? method-&gt;arg_size() : 0)
1447     , _arg_local(_arena)
1448     , _arg_stack(_arena)
1449     , _arg_returned(_arena)
1450     , _dirty(_arena)
1451     , _return_local(false)
1452     , _return_allocated(false)
1453     , _allocated_escapes(false)
1454     , _unknown_modified(false)
1455     , _dependencies(_arena, 4, 0, NULL)
1456     , _parent(parent)
1457     , _level(parent == NULL ? 0 : parent-&gt;level() + 1) {
1458   if (!_conservative) {
1459     _arg_local.clear();
1460     _arg_stack.clear();
1461     _arg_returned.clear();
1462     _dirty.clear();
1463     Arena* arena = CURRENT_ENV-&gt;arena();
1464     _arg_modified = (uint *) arena-&gt;Amalloc(_arg_size * sizeof(uint));
1465     Copy::zero_to_bytes(_arg_modified, _arg_size * sizeof(uint));
1466 
1467     if (methodData() == NULL)
1468       return;
1469     if (methodData()-&gt;has_escape_info()) {
1470       TRACE_BCEA(2, tty-&gt;print_cr(&quot;[EA] Reading previous results for %s.%s&quot;,
1471                                   method-&gt;holder()-&gt;name()-&gt;as_utf8(),
1472                                   method-&gt;name()-&gt;as_utf8()));
1473       read_escape_info();
1474     } else {
1475       TRACE_BCEA(2, tty-&gt;print_cr(&quot;[EA] computing results for %s.%s&quot;,
1476                                   method-&gt;holder()-&gt;name()-&gt;as_utf8(),
1477                                   method-&gt;name()-&gt;as_utf8()));
1478 
1479       compute_escape_info();
1480       methodData()-&gt;update_escape_info();
1481     }
1482 #ifndef PRODUCT
1483     if (BCEATraceLevel &gt;= 3) {
1484       // dump escape information
1485       dump();
1486     }
1487 #endif
1488   }
1489 }
1490 
1491 void BCEscapeAnalyzer::copy_dependencies(Dependencies *deps) {
1492   if (ciEnv::current()-&gt;jvmti_can_hotswap_or_post_breakpoint()) {
1493     // Also record evol dependencies so redefinition of the
1494     // callee will trigger recompilation.
1495     deps-&gt;assert_evol_method(method());
1496   }
1497   for (int i = 0; i &lt; _dependencies.length(); i+=2) {
1498     ciKlass *k = _dependencies.at(i)-&gt;as_klass();
1499     ciMethod *m = _dependencies.at(i+1)-&gt;as_method();
1500     deps-&gt;assert_unique_concrete_method(k, m);
1501   }
1502 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/interpreter/linkResolver.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bootstrapInfo.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../jvmci/jvmciRuntime.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/linkResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 434,48 ***</span>
  }
  
  Method* LinkResolver::lookup_polymorphic_method(const LinkInfo&amp; link_info,
                                                  Handle *appendix_result_or_null,
                                                  TRAPS) {
    Klass* klass = link_info.resolved_klass();
    Symbol* name = link_info.name();
    Symbol* full_signature = link_info.signature();
  
    vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);
<span class="line-modified">!   if (TraceMethodHandles) {</span>
<span class="line-modified">!     ResourceMark rm(THREAD);</span>
<span class="line-modified">!     tty-&gt;print_cr(&quot;lookup_polymorphic_method iid=%s %s.%s%s&quot;,</span>
<span class="line-removed">-                   vmIntrinsics::name_at(iid), klass-&gt;external_name(),</span>
<span class="line-removed">-                   name-&gt;as_C_string(), full_signature-&gt;as_C_string());</span>
<span class="line-removed">-   }</span>
    if ((klass == SystemDictionary::MethodHandle_klass() ||
         klass == SystemDictionary::VarHandle_klass()) &amp;&amp;
        iid != vmIntrinsics::_none) {
      if (MethodHandles::is_signature_polymorphic_intrinsic(iid)) {
        // Most of these do not need an up-call to Java to resolve, so can be done anywhere.
        // Do not erase last argument type (MemberName) if it is a static linkTo method.
        bool keep_last_arg = MethodHandles::is_signature_polymorphic_static(iid);
        TempNewSymbol basic_signature =
          MethodHandles::lookup_basic_type_signature(full_signature, keep_last_arg, CHECK_NULL);
<span class="line-modified">!       if (TraceMethodHandles) {</span>
<span class="line-modified">!         ResourceMark rm(THREAD);</span>
<span class="line-modified">!         tty-&gt;print_cr(&quot;lookup_polymorphic_method %s %s =&gt; basic %s&quot;,</span>
<span class="line-modified">!                       name-&gt;as_C_string(),</span>
<span class="line-removed">-                       full_signature-&gt;as_C_string(),</span>
<span class="line-removed">-                       basic_signature-&gt;as_C_string());</span>
<span class="line-removed">-       }</span>
        Method* result = SystemDictionary::find_method_handle_intrinsic(iid,
                                                                basic_signature,
                                                                CHECK_NULL);
        if (result != NULL) {
          assert(result-&gt;is_method_handle_intrinsic(), &quot;MH.invokeBasic or MH.linkTo* intrinsic&quot;);
          assert(result-&gt;intrinsic_id() != vmIntrinsics::_invokeGeneric, &quot;wrong place to find this&quot;);
          assert(basic_signature == result-&gt;signature(), &quot;predict the result signature&quot;);
<span class="line-modified">!         if (TraceMethodHandles) {</span>
<span class="line-modified">!           ttyLocker ttyl;</span>
<span class="line-modified">!           tty-&gt;print(&quot;lookup_polymorphic_method =&gt; intrinsic &quot;);</span>
<span class="line-modified">!           result-&gt;print_on(tty);</span>
          }
        }
        return result;
      } else if (iid == vmIntrinsics::_invokeGeneric
                 &amp;&amp; THREAD-&gt;can_call_java()
<span class="line-new-header">--- 434,44 ---</span>
  }
  
  Method* LinkResolver::lookup_polymorphic_method(const LinkInfo&amp; link_info,
                                                  Handle *appendix_result_or_null,
                                                  TRAPS) {
<span class="line-added">+   ResourceMark rm(THREAD);</span>
    Klass* klass = link_info.resolved_klass();
    Symbol* name = link_info.name();
    Symbol* full_signature = link_info.signature();
<span class="line-added">+   LogTarget(Info, methodhandles) lt_mh;</span>
  
    vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);
<span class="line-modified">!   log_info(methodhandles)(&quot;lookup_polymorphic_method iid=%s %s.%s%s&quot;,</span>
<span class="line-modified">!                           vmIntrinsics::name_at(iid), klass-&gt;external_name(),</span>
<span class="line-modified">!                           name-&gt;as_C_string(), full_signature-&gt;as_C_string());</span>
    if ((klass == SystemDictionary::MethodHandle_klass() ||
         klass == SystemDictionary::VarHandle_klass()) &amp;&amp;
        iid != vmIntrinsics::_none) {
      if (MethodHandles::is_signature_polymorphic_intrinsic(iid)) {
        // Most of these do not need an up-call to Java to resolve, so can be done anywhere.
        // Do not erase last argument type (MemberName) if it is a static linkTo method.
        bool keep_last_arg = MethodHandles::is_signature_polymorphic_static(iid);
        TempNewSymbol basic_signature =
          MethodHandles::lookup_basic_type_signature(full_signature, keep_last_arg, CHECK_NULL);
<span class="line-modified">!       log_info(methodhandles)(&quot;lookup_polymorphic_method %s %s =&gt; basic %s&quot;,</span>
<span class="line-modified">!                               name-&gt;as_C_string(),</span>
<span class="line-modified">!                               full_signature-&gt;as_C_string(),</span>
<span class="line-modified">!                               basic_signature-&gt;as_C_string());</span>
        Method* result = SystemDictionary::find_method_handle_intrinsic(iid,
                                                                basic_signature,
                                                                CHECK_NULL);
        if (result != NULL) {
          assert(result-&gt;is_method_handle_intrinsic(), &quot;MH.invokeBasic or MH.linkTo* intrinsic&quot;);
          assert(result-&gt;intrinsic_id() != vmIntrinsics::_invokeGeneric, &quot;wrong place to find this&quot;);
          assert(basic_signature == result-&gt;signature(), &quot;predict the result signature&quot;);
<span class="line-modified">!         if (lt_mh.is_enabled()) {</span>
<span class="line-modified">!           LogStream ls(lt_mh);</span>
<span class="line-modified">!           ls.print(&quot;lookup_polymorphic_method =&gt; intrinsic &quot;);</span>
<span class="line-modified">!           result-&gt;print_on(&amp;ls);</span>
          }
        }
        return result;
      } else if (iid == vmIntrinsics::_invokeGeneric
                 &amp;&amp; THREAD-&gt;can_call_java()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 501,17 ***</span>
                                                              name,
                                                              full_signature,
                                                              link_info.current_klass(),
                                                              &amp;appendix,
                                                              CHECK_NULL);
<span class="line-modified">!       if (TraceMethodHandles) {</span>
<span class="line-modified">!         ttyLocker ttyl;</span>
<span class="line-modified">!         tty-&gt;print(&quot;lookup_polymorphic_method =&gt; (via Java) &quot;);</span>
<span class="line-modified">!         result-&gt;print_on(tty);</span>
<span class="line-modified">!         tty-&gt;print(&quot;  lookup_polymorphic_method =&gt; appendix = &quot;);</span>
<span class="line-modified">!         if (appendix.is_null())  tty-&gt;print_cr(&quot;(none)&quot;);</span>
<span class="line-removed">-         else                     appendix-&gt;print_on(tty);</span>
        }
        if (result != NULL) {
  #ifdef ASSERT
          ResourceMark rm(THREAD);
  
<span class="line-new-header">--- 497,16 ---</span>
                                                              name,
                                                              full_signature,
                                                              link_info.current_klass(),
                                                              &amp;appendix,
                                                              CHECK_NULL);
<span class="line-modified">!       if (lt_mh.is_enabled()) {</span>
<span class="line-modified">!         LogStream ls(lt_mh);</span>
<span class="line-modified">!         ls.print(&quot;lookup_polymorphic_method =&gt; (via Java) &quot;);</span>
<span class="line-modified">!         result-&gt;print_on(&amp;ls);</span>
<span class="line-modified">!         ls.print(&quot;  lookup_polymorphic_method =&gt; appendix = &quot;);</span>
<span class="line-modified">!         appendix.is_null() ? ls.print_cr(&quot;(none)&quot;) : appendix-&gt;print_on(&amp;ls);</span>
        }
        if (result != NULL) {
  #ifdef ASSERT
          ResourceMark rm(THREAD);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1667,14 ***</span>
  
  
  void LinkResolver::resolve_invokehandle(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
    // This guy is reached from InterpreterRuntime::resolve_invokehandle.
    LinkInfo link_info(pool, index, CHECK);
<span class="line-modified">!   if (TraceMethodHandles) {</span>
      ResourceMark rm(THREAD);
<span class="line-modified">!     tty-&gt;print_cr(&quot;resolve_invokehandle %s %s&quot;, link_info.name()-&gt;as_C_string(),</span>
<span class="line-modified">!                   link_info.signature()-&gt;as_C_string());</span>
    }
    resolve_handle_call(result, link_info, CHECK);
  }
  
  void LinkResolver::resolve_handle_call(CallInfo&amp; result,
<span class="line-new-header">--- 1662,14 ---</span>
  
  
  void LinkResolver::resolve_invokehandle(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
    // This guy is reached from InterpreterRuntime::resolve_invokehandle.
    LinkInfo link_info(pool, index, CHECK);
<span class="line-modified">!   if (log_is_enabled(Info, methodhandles)) {</span>
      ResourceMark rm(THREAD);
<span class="line-modified">!     log_info(methodhandles)(&quot;resolve_invokehandle %s %s&quot;, link_info.name()-&gt;as_C_string(),</span>
<span class="line-modified">!                             link_info.signature()-&gt;as_C_string());</span>
    }
    resolve_handle_call(result, link_info, CHECK);
  }
  
  void LinkResolver::resolve_handle_call(CallInfo&amp; result,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1711,12 ***</span>
    // set the indy_rf flag since any subsequent invokedynamic instruction which shares
    // this bootstrap method will encounter the resolution of MethodHandleInError.
  
    resolve_dynamic_call(result, bootstrap_specifier, CHECK);
  
<span class="line-modified">!   if (TraceMethodHandles) {</span>
<span class="line-modified">!     bootstrap_specifier.print_msg_on(tty, &quot;resolve_invokedynamic&quot;);</span>
    }
  
    // The returned linkage result is provisional up to the moment
    // the interpreter or runtime performs a serialized check of
    // the relevant CPCE::f1 field.  This is done by the caller
<span class="line-new-header">--- 1706,14 ---</span>
    // set the indy_rf flag since any subsequent invokedynamic instruction which shares
    // this bootstrap method will encounter the resolution of MethodHandleInError.
  
    resolve_dynamic_call(result, bootstrap_specifier, CHECK);
  
<span class="line-modified">!   LogTarget(Debug, methodhandles, indy) lt_indy;</span>
<span class="line-modified">!   if (lt_indy.is_enabled()) {</span>
<span class="line-added">+     LogStream ls(lt_indy);</span>
<span class="line-added">+     bootstrap_specifier.print_msg_on(&amp;ls, &quot;resolve_invokedynamic&quot;);</span>
    }
  
    // The returned linkage result is provisional up to the moment
    // the interpreter or runtime performs a serialized check of
    // the relevant CPCE::f1 field.  This is done by the caller
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1733,11 ***</span>
    // The appendix argument is likely to be a freshly-created CallSite.
    // It may also be a MethodHandle from an unwrapped ConstantCallSite,
    // or any other reference.  The resolved_method as well as the appendix
    // are both recorded together via CallInfo::set_handle.
    SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
<span class="line-modified">!   Exceptions::wrap_dynamic_exception(THREAD);</span>
  
    if (HAS_PENDING_EXCEPTION) {
      if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {
        // Let any random low-level IE or SOE or OOME just bleed through.
        // Basically we pretend that the bootstrap method was never called,
<span class="line-new-header">--- 1730,11 ---</span>
    // The appendix argument is likely to be a freshly-created CallSite.
    // It may also be a MethodHandle from an unwrapped ConstantCallSite,
    // or any other reference.  The resolved_method as well as the appendix
    // are both recorded together via CallInfo::set_handle.
    SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
<span class="line-modified">!   Exceptions::wrap_dynamic_exception(/* is_indy */ true, THREAD);</span>
  
    if (HAS_PENDING_EXCEPTION) {
      if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {
        // Let any random low-level IE or SOE or OOME just bleed through.
        // Basically we pretend that the bootstrap method was never called,
</pre>
<center><a href="bootstrapInfo.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../jvmci/jvmciRuntime.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
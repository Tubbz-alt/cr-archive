diff a/src/hotspot/share/interpreter/bootstrapInfo.cpp b/src/hotspot/share/interpreter/bootstrapInfo.cpp
--- a/src/hotspot/share/interpreter/bootstrapInfo.cpp
+++ b/src/hotspot/share/interpreter/bootstrapInfo.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -63,11 +63,11 @@
   ConstantPoolCacheEntry* cpce = invokedynamic_cp_cache_entry();
   if (!cpce->is_f1_null()) {
     methodHandle method(     THREAD, cpce->f1_as_method());
     Handle       appendix(   THREAD, cpce->appendix_if_resolved(_pool));
     result.set_handle(method, appendix, THREAD);
-    Exceptions::wrap_dynamic_exception(CHECK_false);
+    Exceptions::wrap_dynamic_exception(/* is_indy */ true, CHECK_false);
     return true;
   } else if (cpce->indy_resolution_failed()) {
     int encoded_index = ResolutionErrorTable::encode_cpcache_index(_indy_index);
     ConstantPool::throw_resolution_error(_pool, encoded_index, CHECK_false);
     return true;
@@ -79,28 +79,32 @@
 // Resolve the bootstrap specifier in 3 steps:
 // - unpack the BSM by resolving the MH constant
 // - obtain the NameAndType description for the condy/indy
 // - prepare the BSM's static arguments
 Handle BootstrapInfo::resolve_bsm(TRAPS) {
-  if (_bsm.not_null())  return _bsm;
+  if (_bsm.not_null()) {
+    return _bsm;
+  }
+
+  bool is_indy = is_method_call();
   // The tag at the bootstrap method index must be a valid method handle or a method handle in error.
   // If it is a MethodHandleInError, a resolution error will be thrown which will be wrapped if necessary
   // with a BootstrapMethodError.
   assert(_pool->tag_at(bsm_index()).is_method_handle() ||
          _pool->tag_at(bsm_index()).is_method_handle_in_error(), "MH not present, classfile structural constraint");
   oop bsm_oop = _pool->resolve_possibly_cached_constant_at(bsm_index(), THREAD);
-  Exceptions::wrap_dynamic_exception(CHECK_NH);
+  Exceptions::wrap_dynamic_exception(is_indy, CHECK_NH);
   guarantee(java_lang_invoke_MethodHandle::is_instance(bsm_oop), "classfile must supply a valid BSM");
   _bsm = Handle(THREAD, bsm_oop);
 
   // Obtain NameAndType information
   resolve_bss_name_and_type(THREAD);
-  Exceptions::wrap_dynamic_exception(CHECK_NH);
+  Exceptions::wrap_dynamic_exception(is_indy, CHECK_NH);
 
   // Prepare static arguments
   resolve_args(THREAD);
-  Exceptions::wrap_dynamic_exception(CHECK_NH);
+  Exceptions::wrap_dynamic_exception(is_indy, CHECK_NH);
 
   return _bsm;
 }
 
 // Resolve metadata from the JVM_Dynamic_info or JVM_InvokeDynamic_info's name and type information.
@@ -251,32 +255,32 @@
       sprintf(argbuf+pos, "%d", arg_index(i));
     }
     st->print_cr("  argument indexes: {%s}", argbuf);
   }
   if (_bsm.not_null()) {
-    st->print("  resolved BSM: "); _bsm->print();
+    st->print("  resolved BSM: "); _bsm->print_on(st);
   }
 
   // How the array of resolved arguments is printed depends highly
   // on how BootstrapInfo::resolve_args structures the array based on
   // the use_BSCI setting.
   if (_arg_values.not_null()) {
     // Find the static arguments within the first element of _arg_values.
     objArrayOop static_args = (objArrayOop)_arg_values();
     if (!static_args->is_array()) {
       assert(_argc == 1, "Invalid BSM _arg_values for non-array");
-      st->print("  resolved arg[0]: "); static_args->print();
+      st->print("  resolved arg[0]: "); static_args->print_on(st);
     } else if (static_args->is_objArray()) {
       int lines = 0;
       for (int i = 0; i < _argc; i++) {
         oop x = static_args->obj_at(i);
         if (x != NULL) {
           if (++lines > 6) {
             st->print_cr("  resolved arg[%d]: ...", i);
             break;
           }
-          st->print("  resolved arg[%d]: ", i); x->print();
+          st->print("  resolved arg[%d]: ", i); x->print_on(st);
         }
       }
     } else if (static_args->is_typeArray()) {
       typeArrayOop tmp_array = (typeArrayOop) static_args;
       assert(tmp_array->length() == 2, "Invalid BSM _arg_values type array");

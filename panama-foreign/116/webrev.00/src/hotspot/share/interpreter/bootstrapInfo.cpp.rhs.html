<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/interpreter/bootstrapInfo.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;classfile/javaClasses.inline.hpp&quot;
 28 #include &quot;classfile/resolutionErrors.hpp&quot;
 29 #include &quot;interpreter/bootstrapInfo.hpp&quot;
 30 #include &quot;interpreter/linkResolver.hpp&quot;
 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;logging/logStream.hpp&quot;
 33 #include &quot;memory/oopFactory.hpp&quot;
 34 #include &quot;oops/cpCache.inline.hpp&quot;
 35 #include &quot;oops/objArrayOop.inline.hpp&quot;
 36 #include &quot;oops/typeArrayOop.inline.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/thread.inline.hpp&quot;
 39 #include &quot;runtime/vmThread.hpp&quot;
 40 
 41 //------------------------------------------------------------------------------------------------------------------------
 42 // Implementation of BootstrapInfo
 43 
 44 BootstrapInfo::BootstrapInfo(const constantPoolHandle&amp; pool, int bss_index, int indy_index)
 45   : _pool(pool),
 46     _bss_index(bss_index),
 47     _indy_index(indy_index),
 48     // derived and eagerly cached:
 49     _argc(      pool-&gt;bootstrap_argument_count_at(bss_index) ),
 50     _name(      pool-&gt;uncached_name_ref_at(bss_index) ),
 51     _signature( pool-&gt;uncached_signature_ref_at(bss_index) )
 52 {
 53   _is_resolved = false;
 54   assert(pool-&gt;tag_at(bss_index).has_bootstrap(), &quot;&quot;);
 55   assert(indy_index == -1 || pool-&gt;invokedynamic_bootstrap_ref_index_at(indy_index) == bss_index, &quot;invalid bootstrap specifier index&quot;);
 56 }
 57 
 58 // If there is evidence this call site was already linked, set the
 59 // existing linkage data into result, or throw previous exception.
 60 // Return true if either action is taken, else false.
 61 bool BootstrapInfo::resolve_previously_linked_invokedynamic(CallInfo&amp; result, TRAPS) {
 62   assert(_indy_index != -1, &quot;&quot;);
 63   ConstantPoolCacheEntry* cpce = invokedynamic_cp_cache_entry();
 64   if (!cpce-&gt;is_f1_null()) {
 65     methodHandle method(     THREAD, cpce-&gt;f1_as_method());
 66     Handle       appendix(   THREAD, cpce-&gt;appendix_if_resolved(_pool));
 67     result.set_handle(method, appendix, THREAD);
<a name="2" id="anc2"></a><span class="line-modified"> 68     Exceptions::wrap_dynamic_exception(/* is_indy */ true, CHECK_false);</span>
 69     return true;
 70   } else if (cpce-&gt;indy_resolution_failed()) {
 71     int encoded_index = ResolutionErrorTable::encode_cpcache_index(_indy_index);
 72     ConstantPool::throw_resolution_error(_pool, encoded_index, CHECK_false);
 73     return true;
 74   } else {
 75     return false;
 76   }
 77 }
 78 
 79 // Resolve the bootstrap specifier in 3 steps:
 80 // - unpack the BSM by resolving the MH constant
 81 // - obtain the NameAndType description for the condy/indy
 82 // - prepare the BSM&#39;s static arguments
 83 Handle BootstrapInfo::resolve_bsm(TRAPS) {
<a name="3" id="anc3"></a><span class="line-modified"> 84   if (_bsm.not_null()) {</span>
<span class="line-added"> 85     return _bsm;</span>
<span class="line-added"> 86   }</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88   bool is_indy = is_method_call();</span>
 89   // The tag at the bootstrap method index must be a valid method handle or a method handle in error.
 90   // If it is a MethodHandleInError, a resolution error will be thrown which will be wrapped if necessary
 91   // with a BootstrapMethodError.
 92   assert(_pool-&gt;tag_at(bsm_index()).is_method_handle() ||
 93          _pool-&gt;tag_at(bsm_index()).is_method_handle_in_error(), &quot;MH not present, classfile structural constraint&quot;);
 94   oop bsm_oop = _pool-&gt;resolve_possibly_cached_constant_at(bsm_index(), THREAD);
<a name="4" id="anc4"></a><span class="line-modified"> 95   Exceptions::wrap_dynamic_exception(is_indy, CHECK_NH);</span>
 96   guarantee(java_lang_invoke_MethodHandle::is_instance(bsm_oop), &quot;classfile must supply a valid BSM&quot;);
 97   _bsm = Handle(THREAD, bsm_oop);
 98 
 99   // Obtain NameAndType information
100   resolve_bss_name_and_type(THREAD);
<a name="5" id="anc5"></a><span class="line-modified">101   Exceptions::wrap_dynamic_exception(is_indy, CHECK_NH);</span>
102 
103   // Prepare static arguments
104   resolve_args(THREAD);
<a name="6" id="anc6"></a><span class="line-modified">105   Exceptions::wrap_dynamic_exception(is_indy, CHECK_NH);</span>
106 
107   return _bsm;
108 }
109 
110 // Resolve metadata from the JVM_Dynamic_info or JVM_InvokeDynamic_info&#39;s name and type information.
111 void BootstrapInfo::resolve_bss_name_and_type(TRAPS) {
112   assert(_bsm.not_null(), &quot;resolve_bsm first&quot;);
113   Symbol* name = this-&gt;name();
114   Symbol* type = this-&gt;signature();
115   _name_arg = java_lang_String::create_from_symbol(name, CHECK);
116   if (type-&gt;char_at(0) == &#39;(&#39;) {
117     _type_arg = SystemDictionary::find_method_handle_type(type, caller(), CHECK);
118   } else {
119     _type_arg = SystemDictionary::find_java_mirror_for_type(type, caller(), SignatureStream::NCDFError, CHECK);
120   }
121 }
122 
123 // Resolve the bootstrap method&#39;s static arguments and store the result in _arg_values.
124 void BootstrapInfo::resolve_args(TRAPS) {
125   assert(_bsm.not_null(), &quot;resolve_bsm first&quot;);
126 
127   // if there are no static arguments, return leaving _arg_values as null
128   if (_argc == 0 &amp;&amp; UseBootstrapCallInfo &lt; 2) return;
129 
130   bool use_BSCI;
131   switch (UseBootstrapCallInfo) {
132   default: use_BSCI = true;  break;  // stress mode
133   case 0:  use_BSCI = false; break;  // stress mode
134   case 1:                            // normal mode
135     // If we were to support an alternative mode of BSM invocation,
136     // we&#39;d convert to pull mode here if the BSM could be a candidate
137     // for that alternative mode.  We can&#39;t easily test for things
138     // like varargs here, but we can get away with approximate testing,
139     // since the JDK runtime will make up the difference either way.
140     // For now, exercise the pull-mode path if the BSM is of arity 2,
141     // or if there is a potential condy loop (see below).
142     oop mt_oop = java_lang_invoke_MethodHandle::type(_bsm());
143     use_BSCI = (java_lang_invoke_MethodType::ptype_count(mt_oop) == 2);
144     break;
145   }
146 
147   // Here&#39;s a reason to use BSCI even if it wasn&#39;t requested:
148   // If a condy uses a condy argument, we want to avoid infinite
149   // recursion (condy loops) in the C code.  It&#39;s OK in Java,
150   // because Java has stack overflow checking, so we punt
151   // potentially cyclic cases from C to Java.
152   if (!use_BSCI &amp;&amp; _pool-&gt;tag_at(_bss_index).is_dynamic_constant()) {
153     bool found_unresolved_condy = false;
154     for (int i = 0; i &lt; _argc; i++) {
155       int arg_index = _pool-&gt;bootstrap_argument_index_at(_bss_index, i);
156       if (_pool-&gt;tag_at(arg_index).is_dynamic_constant()) {
157         // potential recursion point condy -&gt; condy
158         bool found_it = false;
159         _pool-&gt;find_cached_constant_at(arg_index, found_it, CHECK);
160         if (!found_it) { found_unresolved_condy = true; break; }
161       }
162     }
163     if (found_unresolved_condy)
164       use_BSCI = true;
165   }
166 
167   const int SMALL_ARITY = 5;
168   if (use_BSCI &amp;&amp; _argc &lt;= SMALL_ARITY &amp;&amp; UseBootstrapCallInfo &lt;= 2) {
169     // If there are only a few arguments, and none of them need linking,
170     // push them, instead of asking the JDK runtime to turn around and
171     // pull them, saving a JVM/JDK transition in some simple cases.
172     bool all_resolved = true;
173     for (int i = 0; i &lt; _argc; i++) {
174       bool found_it = false;
175       int arg_index = _pool-&gt;bootstrap_argument_index_at(_bss_index, i);
176       _pool-&gt;find_cached_constant_at(arg_index, found_it, CHECK);
177       if (!found_it) { all_resolved = false; break; }
178     }
179     if (all_resolved)
180       use_BSCI = false;
181   }
182 
183   if (!use_BSCI) {
184     // return {arg...}; resolution of arguments is done immediately, before JDK code is called
185     objArrayOop args_oop = oopFactory::new_objArray(SystemDictionary::Object_klass(), _argc, CHECK);
186     objArrayHandle args(THREAD, args_oop);
187     _pool-&gt;copy_bootstrap_arguments_at(_bss_index, 0, _argc, args, 0, true, Handle(), CHECK);
188     oop arg_oop = ((_argc == 1) ? args-&gt;obj_at(0) : (oop)NULL);
189     // try to discard the singleton array
190     if (arg_oop != NULL &amp;&amp; !arg_oop-&gt;is_array()) {
191       // JVM treats arrays and nulls specially in this position,
192       // but other things are just single arguments
193       _arg_values = Handle(THREAD, arg_oop);
194     } else {
195       _arg_values = args;
196     }
197   } else {
198     // return {arg_count, pool_index}; JDK code must pull the arguments as needed
199     typeArrayOop ints_oop = oopFactory::new_typeArray(T_INT, 2, CHECK);
200     ints_oop-&gt;int_at_put(0, _argc);
201     ints_oop-&gt;int_at_put(1, _bss_index);
202     _arg_values = Handle(THREAD, ints_oop);
203   }
204 }
205 
206 // there must be a LinkageError pending; try to save it and then throw
207 bool BootstrapInfo::save_and_throw_indy_exc(TRAPS) {
208   assert(HAS_PENDING_EXCEPTION, &quot;&quot;);
209   assert(_indy_index != -1, &quot;&quot;);
210   ConstantPoolCacheEntry* cpce = invokedynamic_cp_cache_entry();
211   int encoded_index = ResolutionErrorTable::encode_cpcache_index(_indy_index);
212   bool recorded_res_status = cpce-&gt;save_and_throw_indy_exc(_pool, _bss_index,
213                                                            encoded_index,
214                                                            pool()-&gt;tag_at(_bss_index),
215                                                            CHECK_false);
216   return recorded_res_status;
217 }
218 
219 void BootstrapInfo::resolve_newly_linked_invokedynamic(CallInfo&amp; result, TRAPS) {
220   assert(is_resolved(), &quot;&quot;);
221   result.set_handle(resolved_method(), resolved_appendix(), CHECK);
222 }
223 
224 void BootstrapInfo::print_msg_on(outputStream* st, const char* msg) {
225   ResourceMark rm;
226   char what[20];
227   st = st ? st : tty;
228 
229   if (_indy_index != -1)
230     sprintf(what, &quot;indy#%d&quot;, decode_indy_index());
231   else
232     sprintf(what, &quot;condy&quot;);
233   bool have_msg = (msg != NULL &amp;&amp; strlen(msg) &gt; 0);
234   st-&gt;print_cr(&quot;%s%sBootstrap in %s %s@CP[%d] %s:%s%s BSMS[%d] BSM@CP[%d]%s argc=%d%s&quot;,
235                 (have_msg ? msg : &quot;&quot;), (have_msg ? &quot; &quot; : &quot;&quot;),
236                 caller()-&gt;name()-&gt;as_C_string(),
237                 what,  // &quot;indy#42&quot; or &quot;condy&quot;
238                 _bss_index,
239                 _name-&gt;as_C_string(),
240                 _signature-&gt;as_C_string(),
241                 (_type_arg.is_null() ? &quot;&quot; : &quot;(resolved)&quot;),
242                 bsms_attr_index(),
243                 bsm_index(), (_bsm.is_null() ? &quot;&quot; : &quot;(resolved)&quot;),
244                 _argc, (_arg_values.is_null() ? &quot;&quot; : &quot;(resolved)&quot;));
245   if (_argc &gt; 0) {
246     char argbuf[80];
247     argbuf[0] = 0;
248     for (int i = 0; i &lt; _argc; i++) {
249       int pos = (int) strlen(argbuf);
250       if (pos + 20 &gt; (int)sizeof(argbuf)) {
251         sprintf(argbuf + pos, &quot;...&quot;);
252         break;
253       }
254       if (i &gt; 0)  argbuf[pos++] = &#39;,&#39;;
255       sprintf(argbuf+pos, &quot;%d&quot;, arg_index(i));
256     }
257     st-&gt;print_cr(&quot;  argument indexes: {%s}&quot;, argbuf);
258   }
259   if (_bsm.not_null()) {
<a name="7" id="anc7"></a><span class="line-modified">260     st-&gt;print(&quot;  resolved BSM: &quot;); _bsm-&gt;print_on(st);</span>
261   }
262 
263   // How the array of resolved arguments is printed depends highly
264   // on how BootstrapInfo::resolve_args structures the array based on
265   // the use_BSCI setting.
266   if (_arg_values.not_null()) {
267     // Find the static arguments within the first element of _arg_values.
268     objArrayOop static_args = (objArrayOop)_arg_values();
269     if (!static_args-&gt;is_array()) {
270       assert(_argc == 1, &quot;Invalid BSM _arg_values for non-array&quot;);
<a name="8" id="anc8"></a><span class="line-modified">271       st-&gt;print(&quot;  resolved arg[0]: &quot;); static_args-&gt;print_on(st);</span>
272     } else if (static_args-&gt;is_objArray()) {
273       int lines = 0;
274       for (int i = 0; i &lt; _argc; i++) {
275         oop x = static_args-&gt;obj_at(i);
276         if (x != NULL) {
277           if (++lines &gt; 6) {
278             st-&gt;print_cr(&quot;  resolved arg[%d]: ...&quot;, i);
279             break;
280           }
<a name="9" id="anc9"></a><span class="line-modified">281           st-&gt;print(&quot;  resolved arg[%d]: &quot;, i); x-&gt;print_on(st);</span>
282         }
283       }
284     } else if (static_args-&gt;is_typeArray()) {
285       typeArrayOop tmp_array = (typeArrayOop) static_args;
286       assert(tmp_array-&gt;length() == 2, &quot;Invalid BSM _arg_values type array&quot;);
287       st-&gt;print_cr(&quot;  resolved arg[0]: %d&quot;, tmp_array-&gt;int_at(0));
288       st-&gt;print_cr(&quot;  resolved arg[1]: %d&quot;, tmp_array-&gt;int_at(1));
289     }
290   }
291 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
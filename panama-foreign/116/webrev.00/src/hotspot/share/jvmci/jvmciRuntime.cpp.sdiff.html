<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jvmci/jvmciRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../interpreter/linkResolver.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../logging/log.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 365   DEBUG_ONLY(ResetNoHandleMark rnhm);
 366   CompiledMethod* cm = NULL;
 367   address continuation = NULL;
 368   {
 369     // Enter VM mode by calling the helper
 370     ResetNoHandleMark rnhm;
 371     continuation = exception_handler_for_pc_helper(thread, exception, pc, cm);
 372   }
 373   // Back in JAVA, use no oops DON&#39;T safepoint
 374 
 375   // Now check to see if the compiled method we were called from is now deoptimized.
 376   // If so we must return to the deopt blob and deoptimize the nmethod
 377   if (cm != NULL &amp;&amp; caller_is_deopted()) {
 378     continuation = SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 379   }
 380 
 381   assert(continuation != NULL, &quot;no handler found&quot;);
 382   return continuation;
 383 }
 384 
<span class="line-modified"> 385 JRT_ENTRY_NO_ASYNC(void, JVMCIRuntime::monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock))</span>
<span class="line-modified"> 386   IF_TRACE_jvmci_3 {</span>
<span class="line-removed"> 387     char type[O_BUFLEN];</span>
<span class="line-removed"> 388     obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);</span>
<span class="line-removed"> 389     markWord mark = obj-&gt;mark();</span>
<span class="line-removed"> 390     TRACE_jvmci_3(&quot;%s: entered locking slow case with obj=&quot; INTPTR_FORMAT &quot;, type=%s, mark=&quot; INTPTR_FORMAT &quot;, lock=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, mark.value(), p2i(lock));</span>
<span class="line-removed"> 391     tty-&gt;flush();</span>
<span class="line-removed"> 392   }</span>
<span class="line-removed"> 393   if (PrintBiasedLockingStatistics) {</span>
<span class="line-removed"> 394     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span>
<span class="line-removed"> 395   }</span>
<span class="line-removed"> 396   Handle h_obj(thread, obj);</span>
<span class="line-removed"> 397   assert(oopDesc::is_oop(h_obj()), &quot;must be NULL or an object&quot;);</span>
<span class="line-removed"> 398   ObjectSynchronizer::enter(h_obj, lock, THREAD);</span>
<span class="line-removed"> 399   TRACE_jvmci_3(&quot;%s: exiting locking slow with obj=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj));</span>
 400 JRT_END
 401 
 402 JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* thread, oopDesc* obj, BasicLock* lock))
<span class="line-removed"> 403   assert(thread == JavaThread::current(), &quot;threads must correspond&quot;);</span>
 404   assert(thread-&gt;last_Java_sp(), &quot;last_Java_sp must be set&quot;);
<span class="line-modified"> 405   // monitorexit is non-blocking (leaf routine) =&gt; no exceptions can be thrown</span>
<span class="line-modified"> 406   EXCEPTION_MARK;</span>
<span class="line-removed"> 407 </span>
<span class="line-removed"> 408 #ifdef ASSERT</span>
<span class="line-removed"> 409   if (!oopDesc::is_oop(obj)) {</span>
<span class="line-removed"> 410     ResetNoHandleMark rhm;</span>
<span class="line-removed"> 411     nmethod* method = thread-&gt;last_frame().cb()-&gt;as_nmethod_or_null();</span>
<span class="line-removed"> 412     if (method != NULL) {</span>
<span class="line-removed"> 413       tty-&gt;print_cr(&quot;ERROR in monitorexit in method %s wrong obj &quot; INTPTR_FORMAT, method-&gt;name(), p2i(obj));</span>
<span class="line-removed"> 414     }</span>
<span class="line-removed"> 415     thread-&gt;print_stack_on(tty);</span>
<span class="line-removed"> 416     assert(false, &quot;invalid lock object pointer dected&quot;);</span>
<span class="line-removed"> 417   }</span>
<span class="line-removed"> 418 #endif</span>
<span class="line-removed"> 419 </span>
<span class="line-removed"> 420   ObjectSynchronizer::exit(obj, lock, THREAD);</span>
<span class="line-removed"> 421   IF_TRACE_jvmci_3 {</span>
<span class="line-removed"> 422     char type[O_BUFLEN];</span>
<span class="line-removed"> 423     obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);</span>
<span class="line-removed"> 424     TRACE_jvmci_3(&quot;%s: exited locking slow case with obj=&quot; INTPTR_FORMAT &quot;, type=%s, mark=&quot; INTPTR_FORMAT &quot;, lock=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, obj-&gt;mark().value(), p2i(lock));</span>
<span class="line-removed"> 425     tty-&gt;flush();</span>
<span class="line-removed"> 426   }</span>
 427 JRT_END
 428 
 429 // Object.notify() fast path, caller does slow path
 430 JRT_LEAF(jboolean, JVMCIRuntime::object_notify(JavaThread *thread, oopDesc* obj))
 431 
 432   // Very few notify/notifyAll operations find any threads on the waitset, so
 433   // the dominant fast-path is to simply return.
 434   // Relatedly, it&#39;s critical that notify/notifyAll be fast in order to
 435   // reduce lock hold times.
 436   if (!SafepointSynchronize::is_synchronizing()) {
 437     if (ObjectSynchronizer::quick_notify(obj, thread, false)) {
 438       return true;
 439     }
 440   }
 441   return false; // caller must perform slow path
 442 
 443 JRT_END
 444 
 445 // Object.notifyAll() fast path, caller does slow path
 446 JRT_LEAF(jboolean, JVMCIRuntime::object_notifyAll(JavaThread *thread, oopDesc* obj))
</pre>
</td>
<td>
<hr />
<pre>
 365   DEBUG_ONLY(ResetNoHandleMark rnhm);
 366   CompiledMethod* cm = NULL;
 367   address continuation = NULL;
 368   {
 369     // Enter VM mode by calling the helper
 370     ResetNoHandleMark rnhm;
 371     continuation = exception_handler_for_pc_helper(thread, exception, pc, cm);
 372   }
 373   // Back in JAVA, use no oops DON&#39;T safepoint
 374 
 375   // Now check to see if the compiled method we were called from is now deoptimized.
 376   // If so we must return to the deopt blob and deoptimize the nmethod
 377   if (cm != NULL &amp;&amp; caller_is_deopted()) {
 378     continuation = SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 379   }
 380 
 381   assert(continuation != NULL, &quot;no handler found&quot;);
 382   return continuation;
 383 }
 384 
<span class="line-modified"> 385 JRT_BLOCK_ENTRY(void, JVMCIRuntime::monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock))</span>
<span class="line-modified"> 386   SharedRuntime::monitor_enter_helper(obj, lock, thread);</span>













 387 JRT_END
 388 
 389 JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* thread, oopDesc* obj, BasicLock* lock))

 390   assert(thread-&gt;last_Java_sp(), &quot;last_Java_sp must be set&quot;);
<span class="line-modified"> 391   assert(oopDesc::is_oop(obj), &quot;invalid lock object pointer dected&quot;);</span>
<span class="line-modified"> 392   SharedRuntime::monitor_exit_helper(obj, lock, thread);</span>




















 393 JRT_END
 394 
 395 // Object.notify() fast path, caller does slow path
 396 JRT_LEAF(jboolean, JVMCIRuntime::object_notify(JavaThread *thread, oopDesc* obj))
 397 
 398   // Very few notify/notifyAll operations find any threads on the waitset, so
 399   // the dominant fast-path is to simply return.
 400   // Relatedly, it&#39;s critical that notify/notifyAll be fast in order to
 401   // reduce lock hold times.
 402   if (!SafepointSynchronize::is_synchronizing()) {
 403     if (ObjectSynchronizer::quick_notify(obj, thread, false)) {
 404       return true;
 405     }
 406   }
 407   return false; // caller must perform slow path
 408 
 409 JRT_END
 410 
 411 // Object.notifyAll() fast path, caller does slow path
 412 JRT_LEAF(jboolean, JVMCIRuntime::object_notifyAll(JavaThread *thread, oopDesc* obj))
</pre>
</td>
</tr>
</table>
<center><a href="../interpreter/linkResolver.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../logging/log.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
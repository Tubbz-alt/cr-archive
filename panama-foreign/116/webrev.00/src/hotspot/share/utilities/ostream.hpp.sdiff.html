<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/ostream.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ostream.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/com/sun/crypto/provider/AESCipher.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/ostream.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
213   // Return number of characters written into buffer, excluding terminating zero and
214   // subject to truncation in static buffer mode.
215   size_t      size() const { return buffer_pos; }
216   const char* base() const { return buffer; }
217   void  reset();
218   char* as_string() const;
219 };
220 
221 class fileStream : public outputStream {
222  protected:
223   FILE* _file;
224   bool  _need_close;
225  public:
226   fileStream() { _file = NULL; _need_close = false; }
227   fileStream(const char* file_name);
228   fileStream(const char* file_name, const char* opentype);
229   fileStream(FILE* file, bool need_close = false) { _file = file; _need_close = need_close; }
230   ~fileStream();
231   bool is_open() const { return _file != NULL; }
232   virtual void write(const char* c, size_t len);
<span class="line-modified">233   size_t read(void *data, size_t size, size_t count) { return ::fread(data, size, count, _file); }</span>
234   char* readln(char *data, int count);
<span class="line-modified">235   int eof() { return feof(_file); }</span>
236   long fileSize();
<span class="line-modified">237   void rewind() { ::rewind(_file); }</span>
238   void flush();
239 };
240 
241 CDS_ONLY(extern fileStream*   classlist_file;)
242 
243 // unlike fileStream, fdStream does unbuffered I/O by calling
244 // open() and write() directly. It is async-safe, but output
245 // from multiple thread may be mixed together. Used by fatal
246 // error handler.
247 class fdStream : public outputStream {
248  protected:
249   int  _fd;
250  public:
251   fdStream(int fd = -1) : _fd(fd) { }
252   bool is_open() const { return _fd != -1; }
253   void set_fd(int fd) { _fd = fd; }
254   int fd() const { return _fd; }
255   virtual void write(const char* c, size_t len);
256   void flush() {};
257 };
</pre>
</td>
<td>
<hr />
<pre>
213   // Return number of characters written into buffer, excluding terminating zero and
214   // subject to truncation in static buffer mode.
215   size_t      size() const { return buffer_pos; }
216   const char* base() const { return buffer; }
217   void  reset();
218   char* as_string() const;
219 };
220 
221 class fileStream : public outputStream {
222  protected:
223   FILE* _file;
224   bool  _need_close;
225  public:
226   fileStream() { _file = NULL; _need_close = false; }
227   fileStream(const char* file_name);
228   fileStream(const char* file_name, const char* opentype);
229   fileStream(FILE* file, bool need_close = false) { _file = file; _need_close = need_close; }
230   ~fileStream();
231   bool is_open() const { return _file != NULL; }
232   virtual void write(const char* c, size_t len);
<span class="line-modified">233   size_t read(void *data, size_t size, size_t count) { return _file != NULL ? ::fread(data, size, count, _file) : 0; }</span>
234   char* readln(char *data, int count);
<span class="line-modified">235   int eof() { return _file != NULL ? feof(_file) : -1; }</span>
236   long fileSize();
<span class="line-modified">237   void rewind() { if (_file != NULL) ::rewind(_file); }</span>
238   void flush();
239 };
240 
241 CDS_ONLY(extern fileStream*   classlist_file;)
242 
243 // unlike fileStream, fdStream does unbuffered I/O by calling
244 // open() and write() directly. It is async-safe, but output
245 // from multiple thread may be mixed together. Used by fatal
246 // error handler.
247 class fdStream : public outputStream {
248  protected:
249   int  _fd;
250  public:
251   fdStream(int fd = -1) : _fd(fd) { }
252   bool is_open() const { return _fd != -1; }
253   void set_fd(int fd) { _fd = fd; }
254   int fd() const { return _fd; }
255   virtual void write(const char* c, size_t len);
256   void flush() {};
257 };
</pre>
</td>
</tr>
</table>
<center><a href="ostream.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/com/sun/crypto/provider/AESCipher.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
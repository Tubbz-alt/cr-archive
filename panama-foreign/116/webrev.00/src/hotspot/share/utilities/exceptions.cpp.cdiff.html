<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/utilities/exceptions.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../runtime/sharedRuntime.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="exceptions.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/exceptions.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 399,29 ***</span>
  //    - bootstrap method resolution
  //    - post call to MethodHandleNatives::linkCallSite
  // dynamically computed constant uses wrap_dynamic_exception for:
  //    - bootstrap method resolution
  //    - post call to MethodHandleNatives::linkDynamicConstant
<span class="line-modified">! void Exceptions::wrap_dynamic_exception(Thread* THREAD) {</span>
    if (THREAD-&gt;has_pending_exception()) {
      oop exception = THREAD-&gt;pending_exception();
      // See the &quot;Linking Exceptions&quot; section for the invokedynamic instruction
      // in JVMS 6.5.
      if (exception-&gt;is_a(SystemDictionary::Error_klass())) {
        // Pass through an Error, including BootstrapMethodError, any other form
        // of linkage error, or say ThreadDeath/OutOfMemoryError
<span class="line-modified">!       if (TraceMethodHandles) {</span>
<span class="line-modified">!         tty-&gt;print_cr(&quot;bootstrap method invocation wraps BSME around &quot; INTPTR_FORMAT, p2i((void *)exception));</span>
<span class="line-modified">!         exception-&gt;print();</span>
        }
        return;
      }
  
      // Otherwise wrap the exception in a BootstrapMethodError
<span class="line-modified">!     if (TraceMethodHandles) {</span>
<span class="line-modified">!       tty-&gt;print_cr(&quot;[constant/invoke]dynamic throws BSME for &quot; INTPTR_FORMAT, p2i((void *)exception));</span>
<span class="line-modified">!       exception-&gt;print();</span>
      }
      Handle nested_exception(THREAD, exception);
      THREAD-&gt;clear_pending_exception();
      THROW_CAUSE(vmSymbols::java_lang_BootstrapMethodError(), nested_exception)
    }
<span class="line-new-header">--- 399,40 ---</span>
  //    - bootstrap method resolution
  //    - post call to MethodHandleNatives::linkCallSite
  // dynamically computed constant uses wrap_dynamic_exception for:
  //    - bootstrap method resolution
  //    - post call to MethodHandleNatives::linkDynamicConstant
<span class="line-modified">! void Exceptions::wrap_dynamic_exception(bool is_indy, Thread* THREAD) {</span>
    if (THREAD-&gt;has_pending_exception()) {
<span class="line-added">+     bool log_indy = log_is_enabled(Debug, methodhandles, indy) &amp;&amp; is_indy;</span>
<span class="line-added">+     bool log_condy = log_is_enabled(Debug, methodhandles, condy) &amp;&amp; !is_indy;</span>
<span class="line-added">+     LogStreamHandle(Debug, methodhandles, indy) lsh_indy;</span>
<span class="line-added">+     LogStreamHandle(Debug, methodhandles, condy) lsh_condy;</span>
<span class="line-added">+     LogStream* ls = NULL;</span>
<span class="line-added">+     if (log_indy) {</span>
<span class="line-added">+       ls = &amp;lsh_indy;</span>
<span class="line-added">+     } else if (log_condy) {</span>
<span class="line-added">+       ls = &amp;lsh_condy;</span>
<span class="line-added">+     }</span>
      oop exception = THREAD-&gt;pending_exception();
<span class="line-added">+ </span>
      // See the &quot;Linking Exceptions&quot; section for the invokedynamic instruction
      // in JVMS 6.5.
      if (exception-&gt;is_a(SystemDictionary::Error_klass())) {
        // Pass through an Error, including BootstrapMethodError, any other form
        // of linkage error, or say ThreadDeath/OutOfMemoryError
<span class="line-modified">!       if (ls != NULL) {</span>
<span class="line-modified">!         ls-&gt;print_cr(&quot;bootstrap method invocation wraps BSME around &quot; INTPTR_FORMAT, p2i((void *)exception));</span>
<span class="line-modified">!         exception-&gt;print_on(ls);</span>
        }
        return;
      }
  
      // Otherwise wrap the exception in a BootstrapMethodError
<span class="line-modified">!     if (ls != NULL) {</span>
<span class="line-modified">!       ls-&gt;print_cr(&quot;%s throws BSME for &quot; INTPTR_FORMAT, is_indy ? &quot;invokedynamic&quot; : &quot;dynamic constant&quot;, p2i((void *)exception));</span>
<span class="line-modified">!       exception-&gt;print_on(ls);</span>
      }
      Handle nested_exception(THREAD, exception);
      THREAD-&gt;clear_pending_exception();
      THROW_CAUSE(vmSymbols::java_lang_BootstrapMethodError(), nested_exception)
    }
</pre>
<center><a href="../runtime/sharedRuntime.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="exceptions.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/ostream.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;oops/oop.inline.hpp&quot;
  30 #include &quot;runtime/arguments.hpp&quot;
  31 #include &quot;runtime/os.inline.hpp&quot;
  32 #include &quot;runtime/vm_version.hpp&quot;
  33 #include &quot;utilities/defaultStream.hpp&quot;
  34 #include &quot;utilities/macros.hpp&quot;
  35 #include &quot;utilities/ostream.hpp&quot;
  36 #include &quot;utilities/vmError.hpp&quot;
  37 #include &quot;utilities/xmlstream.hpp&quot;
  38 
  39 // Declarations of jvm methods
  40 extern &quot;C&quot; void jio_print(const char* s, size_t len);
  41 extern &quot;C&quot; int jio_printf(const char *fmt, ...);
  42 
  43 outputStream::outputStream(int width) {
  44   _width       = width;
  45   _position    = 0;
  46   _newlines    = 0;
  47   _precount    = 0;
  48   _indentation = 0;
  49   _scratch     = NULL;
  50   _scratch_len = 0;
  51 }
  52 
  53 outputStream::outputStream(int width, bool has_time_stamps) {
  54   _width       = width;
  55   _position    = 0;
  56   _newlines    = 0;
  57   _precount    = 0;
  58   _indentation = 0;
  59   _scratch     = NULL;
  60   _scratch_len = 0;
  61   if (has_time_stamps)  _stamp.update();
  62 }
  63 
  64 void outputStream::update_position(const char* s, size_t len) {
  65   for (size_t i = 0; i &lt; len; i++) {
  66     char ch = s[i];
  67     if (ch == &#39;\n&#39;) {
  68       _newlines += 1;
  69       _precount += _position + 1;
  70       _position = 0;
  71     } else if (ch == &#39;\t&#39;) {
  72       int tw = 8 - (_position &amp; 7);
  73       _position += tw;
  74       _precount -= tw-1;  // invariant:  _precount + _position == total count
  75     } else {
  76       _position += 1;
  77     }
  78   }
  79 }
  80 
  81 // Execute a vsprintf, using the given buffer if necessary.
  82 // Return a pointer to the formatted string.
  83 const char* outputStream::do_vsnprintf(char* buffer, size_t buflen,
  84                                        const char* format, va_list ap,
  85                                        bool add_cr,
  86                                        size_t&amp; result_len) {
  87   assert(buflen &gt;= 2, &quot;buffer too small&quot;);
  88 
  89   const char* result;
  90   if (add_cr)  buflen--;
  91   if (!strchr(format, &#39;%&#39;)) {
  92     // constant format string
  93     result = format;
  94     result_len = strlen(result);
  95     if (add_cr &amp;&amp; result_len &gt;= buflen)  result_len = buflen-1;  // truncate
  96   } else if (format[0] == &#39;%&#39; &amp;&amp; format[1] == &#39;s&#39; &amp;&amp; format[2] == &#39;\0&#39;) {
  97     // trivial copy-through format string
  98     result = va_arg(ap, const char*);
  99     result_len = strlen(result);
 100     if (add_cr &amp;&amp; result_len &gt;= buflen)  result_len = buflen-1;  // truncate
 101   } else {
 102     int required_len = os::vsnprintf(buffer, buflen, format, ap);
 103     assert(required_len &gt;= 0, &quot;vsnprintf encoding error&quot;);
 104     result = buffer;
 105     if ((size_t)required_len &lt; buflen) {
 106       result_len = required_len;
 107     } else {
 108       DEBUG_ONLY(warning(&quot;outputStream::do_vsnprintf output truncated -- buffer length is %d bytes but %d bytes are needed.&quot;,
 109                          add_cr ? (int)buflen + 1 : (int)buflen, add_cr ? required_len + 2 : required_len + 1);)
 110       result_len = buflen - 1;
 111     }
 112   }
 113   if (add_cr) {
 114     if (result != buffer) {
 115       memcpy(buffer, result, result_len);
 116       result = buffer;
 117     }
 118     buffer[result_len++] = &#39;\n&#39;;
 119     buffer[result_len] = 0;
 120   }
 121   return result;
 122 }
 123 
 124 void outputStream::do_vsnprintf_and_write_with_automatic_buffer(const char* format, va_list ap, bool add_cr) {
 125   char buffer[O_BUFLEN];
 126   size_t len;
 127   const char* str = do_vsnprintf(buffer, sizeof(buffer), format, ap, add_cr, len);
 128   write(str, len);
 129 }
 130 
 131 void outputStream::do_vsnprintf_and_write_with_scratch_buffer(const char* format, va_list ap, bool add_cr) {
 132   size_t len;
 133   const char* str = do_vsnprintf(_scratch, _scratch_len, format, ap, add_cr, len);
 134   write(str, len);
 135 }
 136 
 137 void outputStream::do_vsnprintf_and_write(const char* format, va_list ap, bool add_cr) {
 138   if (_scratch) {
 139     do_vsnprintf_and_write_with_scratch_buffer(format, ap, add_cr);
 140   } else {
 141     do_vsnprintf_and_write_with_automatic_buffer(format, ap, add_cr);
 142   }
 143 }
 144 
 145 void outputStream::print(const char* format, ...) {
 146   va_list ap;
 147   va_start(ap, format);
 148   do_vsnprintf_and_write(format, ap, false);
 149   va_end(ap);
 150 }
 151 
 152 void outputStream::print_cr(const char* format, ...) {
 153   va_list ap;
 154   va_start(ap, format);
 155   do_vsnprintf_and_write(format, ap, true);
 156   va_end(ap);
 157 }
 158 
 159 void outputStream::vprint(const char *format, va_list argptr) {
 160   do_vsnprintf_and_write(format, argptr, false);
 161 }
 162 
 163 void outputStream::vprint_cr(const char* format, va_list argptr) {
 164   do_vsnprintf_and_write(format, argptr, true);
 165 }
 166 
 167 void outputStream::fill_to(int col) {
 168   int need_fill = col - position();
 169   sp(need_fill);
 170 }
 171 
 172 void outputStream::move_to(int col, int slop, int min_space) {
 173   if (position() &gt;= col + slop)
 174     cr();
 175   int need_fill = col - position();
 176   if (need_fill &lt; min_space)
 177     need_fill = min_space;
 178   sp(need_fill);
 179 }
 180 
 181 void outputStream::put(char ch) {
 182   assert(ch != 0, &quot;please fix call site&quot;);
 183   char buf[] = { ch, &#39;\0&#39; };
 184   write(buf, 1);
 185 }
 186 
 187 #define SP_USE_TABS false
 188 
 189 void outputStream::sp(int count) {
 190   if (count &lt; 0)  return;
 191   if (SP_USE_TABS &amp;&amp; count &gt;= 8) {
 192     int target = position() + count;
 193     while (count &gt;= 8) {
 194       this-&gt;write(&quot;\t&quot;, 1);
 195       count -= 8;
 196     }
 197     count = target - position();
 198   }
 199   while (count &gt; 0) {
 200     int nw = (count &gt; 8) ? 8 : count;
 201     this-&gt;write(&quot;        &quot;, nw);
 202     count -= nw;
 203   }
 204 }
 205 
 206 void outputStream::cr() {
 207   this-&gt;write(&quot;\n&quot;, 1);
 208 }
 209 
 210 void outputStream::cr_indent() {
 211   cr(); indent();
 212 }
 213 
 214 void outputStream::stamp() {
 215   if (! _stamp.is_updated()) {
 216     _stamp.update(); // start at 0 on first call to stamp()
 217   }
 218 
 219   // outputStream::stamp() may get called by ostream_abort(), use snprintf
 220   // to avoid allocating large stack buffer in print().
 221   char buf[40];
 222   jio_snprintf(buf, sizeof(buf), &quot;%.3f&quot;, _stamp.seconds());
 223   print_raw(buf);
 224 }
 225 
 226 void outputStream::stamp(bool guard,
 227                          const char* prefix,
 228                          const char* suffix) {
 229   if (!guard) {
 230     return;
 231   }
 232   print_raw(prefix);
 233   stamp();
 234   print_raw(suffix);
 235 }
 236 
 237 void outputStream::date_stamp(bool guard,
 238                               const char* prefix,
 239                               const char* suffix) {
 240   if (!guard) {
 241     return;
 242   }
 243   print_raw(prefix);
 244   static const char error_time[] = &quot;yyyy-mm-ddThh:mm:ss.mmm+zzzz&quot;;
 245   static const int buffer_length = 32;
 246   char buffer[buffer_length];
 247   const char* iso8601_result = os::iso8601_time(buffer, buffer_length);
 248   if (iso8601_result != NULL) {
 249     print_raw(buffer);
 250   } else {
 251     print_raw(error_time);
 252   }
 253   print_raw(suffix);
 254   return;
 255 }
 256 
 257 outputStream&amp; outputStream::indent() {
 258   while (_position &lt; _indentation) sp();
 259   return *this;
 260 }
 261 
 262 void outputStream::print_jlong(jlong value) {
 263   print(JLONG_FORMAT, value);
 264 }
 265 
 266 void outputStream::print_julong(julong value) {
 267   print(JULONG_FORMAT, value);
 268 }
 269 
 270 /**
 271  * This prints out hex data in a &#39;windbg&#39; or &#39;xxd&#39; form, where each line is:
 272  *   &lt;hex-address&gt;: 8 * &lt;hex-halfword&gt; &lt;ascii translation (optional)&gt;
 273  * example:
 274  * 0000000: 7f44 4f46 0102 0102 0000 0000 0000 0000  .DOF............
 275  * 0000010: 0000 0000 0000 0040 0000 0020 0000 0005  .......@... ....
 276  * 0000020: 0000 0000 0000 0040 0000 0000 0000 015d  .......@.......]
 277  * ...
 278  *
 279  * indent is applied to each line.  Ends with a CR.
 280  */
 281 void outputStream::print_data(void* data, size_t len, bool with_ascii) {
 282   size_t limit = (len + 16) / 16 * 16;
 283   for (size_t i = 0; i &lt; limit; ++i) {
 284     if (i % 16 == 0) {
 285       indent().print(INTPTR_FORMAT_W(07) &quot;:&quot;, i);
 286     }
 287     if (i % 2 == 0) {
 288       print(&quot; &quot;);
 289     }
 290     if (i &lt; len) {
 291       print(&quot;%02x&quot;, ((unsigned char*)data)[i]);
 292     } else {
 293       print(&quot;  &quot;);
 294     }
 295     if ((i + 1) % 16 == 0) {
 296       if (with_ascii) {
 297         print(&quot;  &quot;);
 298         for (size_t j = 0; j &lt; 16; ++j) {
 299           size_t idx = i + j - 15;
 300           if (idx &lt; len) {
 301             char c = ((char*)data)[idx];
 302             print(&quot;%c&quot;, c &gt;= 32 &amp;&amp; c &lt;= 126 ? c : &#39;.&#39;);
 303           }
 304         }
 305       }
 306       cr();
 307     }
 308   }
 309 }
 310 
 311 stringStream::stringStream(size_t initial_size) : outputStream() {
 312   buffer_length = initial_size;
 313   buffer        = NEW_C_HEAP_ARRAY(char, buffer_length, mtInternal);
 314   buffer_pos    = 0;
 315   buffer_fixed  = false;
 316   zero_terminate();
 317 }
 318 
 319 // useful for output to fixed chunks of memory, such as performance counters
 320 stringStream::stringStream(char* fixed_buffer, size_t fixed_buffer_size) : outputStream() {
 321   buffer_length = fixed_buffer_size;
 322   buffer        = fixed_buffer;
 323   buffer_pos    = 0;
 324   buffer_fixed  = true;
 325   zero_terminate();
 326 }
 327 
 328 void stringStream::write(const char* s, size_t len) {
 329   size_t write_len = len;               // number of non-null bytes to write
 330   size_t end = buffer_pos + len + 1;    // position after write and final &#39;\0&#39;
 331   if (end &gt; buffer_length) {
 332     if (buffer_fixed) {
 333       // if buffer cannot resize, silently truncate
 334       end = buffer_length;
 335       write_len = end - buffer_pos - 1; // leave room for the final &#39;\0&#39;
 336     } else {
 337       // For small overruns, double the buffer.  For larger ones,
 338       // increase to the requested size.
 339       if (end &lt; buffer_length * 2) {
 340         end = buffer_length * 2;
 341       }
 342       buffer = REALLOC_C_HEAP_ARRAY(char, buffer, end, mtInternal);
 343       buffer_length = end;
 344     }
 345   }
 346   // invariant: buffer is always null-terminated
 347   guarantee(buffer_pos + write_len + 1 &lt;= buffer_length, &quot;stringStream oob&quot;);
 348   if (write_len &gt; 0) {
 349     memcpy(buffer + buffer_pos, s, write_len);
 350     buffer_pos += write_len;
 351     zero_terminate();
 352   }
 353 
 354   // Note that the following does not depend on write_len.
 355   // This means that position and count get updated
 356   // even when overflow occurs.
 357   update_position(s, len);
 358 }
 359 
 360 void stringStream::zero_terminate() {
 361   assert(buffer != NULL &amp;&amp;
 362          buffer_pos &lt; buffer_length, &quot;sanity&quot;);
 363   buffer[buffer_pos] = &#39;\0&#39;;
 364 }
 365 
 366 void stringStream::reset() {
 367   buffer_pos = 0; _precount = 0; _position = 0;
 368   zero_terminate();
 369 }
 370 
 371 char* stringStream::as_string() const {
 372   char* copy = NEW_RESOURCE_ARRAY(char, buffer_pos + 1);
 373   strncpy(copy, buffer, buffer_pos);
 374   copy[buffer_pos] = 0;  // terminating null
 375   return copy;
 376 }
 377 
 378 stringStream::~stringStream() {
 379   if (buffer_fixed == false &amp;&amp; buffer != NULL) {
 380     FREE_C_HEAP_ARRAY(char, buffer);
 381   }
 382 }
 383 
 384 xmlStream*   xtty;
 385 outputStream* tty;
 386 CDS_ONLY(fileStream* classlist_file;) // Only dump the classes that can be stored into the CDS archive
 387 extern Mutex* tty_lock;
 388 
 389 #define EXTRACHARLEN   32
 390 #define CURRENTAPPX    &quot;.current&quot;
 391 // convert YYYY-MM-DD HH:MM:SS to YYYY-MM-DD_HH-MM-SS
 392 char* get_datetime_string(char *buf, size_t len) {
 393   os::local_time_string(buf, len);
 394   int i = (int)strlen(buf);
 395   while (--i &gt;= 0) {
 396     if (buf[i] == &#39; &#39;) buf[i] = &#39;_&#39;;
 397     else if (buf[i] == &#39;:&#39;) buf[i] = &#39;-&#39;;
 398   }
 399   return buf;
 400 }
 401 
 402 static const char* make_log_name_internal(const char* log_name, const char* force_directory,
 403                                                 int pid, const char* tms) {
 404   const char* basename = log_name;
 405   char file_sep = os::file_separator()[0];
 406   const char* cp;
 407   char  pid_text[32];
 408 
 409   for (cp = log_name; *cp != &#39;\0&#39;; cp++) {
 410     if (*cp == &#39;/&#39; || *cp == file_sep) {
 411       basename = cp + 1;
 412     }
 413   }
 414   const char* nametail = log_name;
 415   // Compute buffer length
 416   size_t buffer_length;
 417   if (force_directory != NULL) {
 418     buffer_length = strlen(force_directory) + strlen(os::file_separator()) +
 419                     strlen(basename) + 1;
 420   } else {
 421     buffer_length = strlen(log_name) + 1;
 422   }
 423 
 424   const char* pts = strstr(basename, &quot;%p&quot;);
 425   int pid_pos = (pts == NULL) ? -1 : (pts - nametail);
 426 
 427   if (pid_pos &gt;= 0) {
 428     jio_snprintf(pid_text, sizeof(pid_text), &quot;pid%u&quot;, pid);
 429     buffer_length += strlen(pid_text);
 430   }
 431 
 432   pts = strstr(basename, &quot;%t&quot;);
 433   int tms_pos = (pts == NULL) ? -1 : (pts - nametail);
 434   if (tms_pos &gt;= 0) {
 435     buffer_length += strlen(tms);
 436   }
 437 
 438   // File name is too long.
 439   if (buffer_length &gt; JVM_MAXPATHLEN) {
 440     return NULL;
 441   }
 442 
 443   // Create big enough buffer.
 444   char *buf = NEW_C_HEAP_ARRAY(char, buffer_length, mtInternal);
 445 
 446   strcpy(buf, &quot;&quot;);
 447   if (force_directory != NULL) {
 448     strcat(buf, force_directory);
 449     strcat(buf, os::file_separator());
 450     nametail = basename;       // completely skip directory prefix
 451   }
 452 
 453   // who is first, %p or %t?
 454   int first = -1, second = -1;
 455   const char *p1st = NULL;
 456   const char *p2nd = NULL;
 457 
 458   if (pid_pos &gt;= 0 &amp;&amp; tms_pos &gt;= 0) {
 459     // contains both %p and %t
 460     if (pid_pos &lt; tms_pos) {
 461       // case foo%pbar%tmonkey.log
 462       first  = pid_pos;
 463       p1st   = pid_text;
 464       second = tms_pos;
 465       p2nd   = tms;
 466     } else {
 467       // case foo%tbar%pmonkey.log
 468       first  = tms_pos;
 469       p1st   = tms;
 470       second = pid_pos;
 471       p2nd   = pid_text;
 472     }
 473   } else if (pid_pos &gt;= 0) {
 474     // contains %p only
 475     first  = pid_pos;
 476     p1st   = pid_text;
 477   } else if (tms_pos &gt;= 0) {
 478     // contains %t only
 479     first  = tms_pos;
 480     p1st   = tms;
 481   }
 482 
 483   int buf_pos = (int)strlen(buf);
 484   const char* tail = nametail;
 485 
 486   if (first &gt;= 0) {
 487     tail = nametail + first + 2;
 488     strncpy(&amp;buf[buf_pos], nametail, first);
 489     strcpy(&amp;buf[buf_pos + first], p1st);
 490     buf_pos = (int)strlen(buf);
 491     if (second &gt;= 0) {
 492       strncpy(&amp;buf[buf_pos], tail, second - first - 2);
 493       strcpy(&amp;buf[buf_pos + second - first - 2], p2nd);
 494       tail = nametail + second + 2;
 495     }
 496   }
 497   strcat(buf, tail);      // append rest of name, or all of name
 498   return buf;
 499 }
 500 
 501 // log_name comes from -XX:LogFile=log_name or
 502 // -XX:DumpLoadedClassList=&lt;file_name&gt;
 503 // in log_name, %p =&gt; pid1234 and
 504 //              %t =&gt; YYYY-MM-DD_HH-MM-SS
 505 static const char* make_log_name(const char* log_name, const char* force_directory) {
 506   char timestr[32];
 507   get_datetime_string(timestr, sizeof(timestr));
 508   return make_log_name_internal(log_name, force_directory, os::current_process_id(),
 509                                 timestr);
 510 }
 511 
 512 fileStream::fileStream(const char* file_name) {
 513   _file = fopen(file_name, &quot;w&quot;);
 514   if (_file != NULL) {
 515     _need_close = true;
 516   } else {
 517     warning(&quot;Cannot open file %s due to %s\n&quot;, file_name, os::strerror(errno));
 518     _need_close = false;
 519   }
 520 }
 521 
 522 fileStream::fileStream(const char* file_name, const char* opentype) {
 523   _file = fopen(file_name, opentype);
 524   if (_file != NULL) {
 525     _need_close = true;
 526   } else {
 527     warning(&quot;Cannot open file %s due to %s\n&quot;, file_name, os::strerror(errno));
 528     _need_close = false;
 529   }
 530 }
 531 
 532 void fileStream::write(const char* s, size_t len) {
 533   if (_file != NULL)  {
 534     // Make an unused local variable to avoid warning from gcc compiler.
 535     size_t count = fwrite(s, 1, len, _file);
<a name="1" id="anc1"></a><span class="line-added"> 536     update_position(s, len);</span>
 537   }
<a name="2" id="anc2"></a>
 538 }
 539 
 540 long fileStream::fileSize() {
 541   long size = -1;
 542   if (_file != NULL) {
 543     long pos = ::ftell(_file);
 544     if (pos &lt; 0) return pos;
 545     if (::fseek(_file, 0, SEEK_END) == 0) {
 546       size = ::ftell(_file);
 547     }
 548     ::fseek(_file, pos, SEEK_SET);
 549   }
 550   return size;
 551 }
 552 
 553 char* fileStream::readln(char *data, int count ) {
<a name="3" id="anc3"></a><span class="line-modified"> 554   char * ret = NULL;</span>
<span class="line-modified"> 555   if (_file != NULL) {</span>
<span class="line-modified"> 556     ret = ::fgets(data, count, _file);</span>
<span class="line-added"> 557     //Get rid of annoying \n char</span>
<span class="line-added"> 558     data[::strlen(data)-1] = &#39;\0&#39;;</span>
<span class="line-added"> 559   }</span>
 560   return ret;
 561 }
 562 
 563 fileStream::~fileStream() {
 564   if (_file != NULL) {
 565     if (_need_close) fclose(_file);
 566     _file      = NULL;
 567   }
 568 }
 569 
 570 void fileStream::flush() {
<a name="4" id="anc4"></a><span class="line-modified"> 571   if (_file != NULL) {</span>
<span class="line-added"> 572     fflush(_file);</span>
<span class="line-added"> 573   }</span>
 574 }
 575 
 576 void fdStream::write(const char* s, size_t len) {
 577   if (_fd != -1) {
 578     // Make an unused local variable to avoid warning from gcc compiler.
 579     size_t count = ::write(_fd, s, (int)len);
<a name="5" id="anc5"></a><span class="line-added"> 580     update_position(s, len);</span>
 581   }
<a name="6" id="anc6"></a>
 582 }
 583 
 584 defaultStream* defaultStream::instance = NULL;
 585 int defaultStream::_output_fd = 1;
 586 int defaultStream::_error_fd  = 2;
 587 FILE* defaultStream::_output_stream = stdout;
 588 FILE* defaultStream::_error_stream  = stderr;
 589 
 590 #define LOG_MAJOR_VERSION 160
 591 #define LOG_MINOR_VERSION 1
 592 
 593 void defaultStream::init() {
 594   _inited = true;
 595   if (LogVMOutput || LogCompilation) {
 596     init_log();
 597   }
 598 }
 599 
 600 bool defaultStream::has_log_file() {
 601   // lazily create log file (at startup, LogVMOutput is false even
 602   // if +LogVMOutput is used, because the flags haven&#39;t been parsed yet)
 603   // For safer printing during fatal error handling, do not init logfile
 604   // if a VM error has been reported.
 605   if (!_inited &amp;&amp; !VMError::is_error_reported())  init();
 606   return _log_file != NULL;
 607 }
 608 
 609 fileStream* defaultStream::open_file(const char* log_name) {
 610   const char* try_name = make_log_name(log_name, NULL);
 611   if (try_name == NULL) {
 612     warning(&quot;Cannot open file %s: file name is too long.\n&quot;, log_name);
 613     return NULL;
 614   }
 615 
 616   fileStream* file = new(ResourceObj::C_HEAP, mtInternal) fileStream(try_name);
 617   FREE_C_HEAP_ARRAY(char, try_name);
 618   if (file-&gt;is_open()) {
 619     return file;
 620   }
 621 
 622   // Try again to open the file in the temp directory.
 623   delete file;
 624   // Note: This feature is for maintainer use only.  No need for L10N.
 625   jio_printf(&quot;Warning:  Cannot open log file: %s\n&quot;, log_name);
 626   try_name = make_log_name(log_name, os::get_temp_directory());
 627   if (try_name == NULL) {
 628     warning(&quot;Cannot open file %s: file name is too long for directory %s.\n&quot;, log_name, os::get_temp_directory());
 629     return NULL;
 630   }
 631 
 632   jio_printf(&quot;Warning:  Forcing option -XX:LogFile=%s\n&quot;, try_name);
 633 
 634   file = new(ResourceObj::C_HEAP, mtInternal) fileStream(try_name);
 635   FREE_C_HEAP_ARRAY(char, try_name);
 636   if (file-&gt;is_open()) {
 637     return file;
 638   }
 639 
 640   delete file;
 641   return NULL;
 642 }
 643 
 644 void defaultStream::init_log() {
 645   // %%% Need a MutexLocker?
 646   const char* log_name = LogFile != NULL ? LogFile : &quot;hotspot_%p.log&quot;;
 647   fileStream* file = open_file(log_name);
 648 
 649   if (file != NULL) {
 650     _log_file = file;
 651     _outer_xmlStream = new(ResourceObj::C_HEAP, mtInternal) xmlStream(file);
 652     start_log();
 653   } else {
 654     // and leave xtty as NULL
 655     LogVMOutput = false;
 656     DisplayVMOutput = true;
 657     LogCompilation = false;
 658   }
 659 }
 660 
 661 void defaultStream::start_log() {
 662   xmlStream*xs = _outer_xmlStream;
 663     if (this == tty)  xtty = xs;
 664     // Write XML header.
 665     xs-&gt;print_cr(&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;&quot;);
 666     // (For now, don&#39;t bother to issue a DTD for this private format.)
 667 
 668     // Calculate the start time of the log as ms since the epoch: this is
 669     // the current time in ms minus the uptime in ms.
 670     jlong time_ms = os::javaTimeMillis() - tty-&gt;time_stamp().milliseconds();
 671     xs-&gt;head(&quot;hotspot_log version=&#39;%d %d&#39;&quot;
 672              &quot; process=&#39;%d&#39; time_ms=&#39;&quot; INT64_FORMAT &quot;&#39;&quot;,
 673              LOG_MAJOR_VERSION, LOG_MINOR_VERSION,
 674              os::current_process_id(), (int64_t)time_ms);
 675     // Write VM version header immediately.
 676     xs-&gt;head(&quot;vm_version&quot;);
 677     xs-&gt;head(&quot;name&quot;); xs-&gt;text(&quot;%s&quot;, VM_Version::vm_name()); xs-&gt;cr();
 678     xs-&gt;tail(&quot;name&quot;);
 679     xs-&gt;head(&quot;release&quot;); xs-&gt;text(&quot;%s&quot;, VM_Version::vm_release()); xs-&gt;cr();
 680     xs-&gt;tail(&quot;release&quot;);
 681     xs-&gt;head(&quot;info&quot;); xs-&gt;text(&quot;%s&quot;, VM_Version::internal_vm_info_string()); xs-&gt;cr();
 682     xs-&gt;tail(&quot;info&quot;);
 683     xs-&gt;tail(&quot;vm_version&quot;);
 684     // Record information about the command-line invocation.
 685     xs-&gt;head(&quot;vm_arguments&quot;);  // Cf. Arguments::print_on()
 686     if (Arguments::num_jvm_flags() &gt; 0) {
 687       xs-&gt;head(&quot;flags&quot;);
 688       Arguments::print_jvm_flags_on(xs-&gt;text());
 689       xs-&gt;tail(&quot;flags&quot;);
 690     }
 691     if (Arguments::num_jvm_args() &gt; 0) {
 692       xs-&gt;head(&quot;args&quot;);
 693       Arguments::print_jvm_args_on(xs-&gt;text());
 694       xs-&gt;tail(&quot;args&quot;);
 695     }
 696     if (Arguments::java_command() != NULL) {
 697       xs-&gt;head(&quot;command&quot;); xs-&gt;text()-&gt;print_cr(&quot;%s&quot;, Arguments::java_command());
 698       xs-&gt;tail(&quot;command&quot;);
 699     }
 700     if (Arguments::sun_java_launcher() != NULL) {
 701       xs-&gt;head(&quot;launcher&quot;); xs-&gt;text()-&gt;print_cr(&quot;%s&quot;, Arguments::sun_java_launcher());
 702       xs-&gt;tail(&quot;launcher&quot;);
 703     }
 704     if (Arguments::system_properties() !=  NULL) {
 705       xs-&gt;head(&quot;properties&quot;);
 706       // Print it as a java-style property list.
 707       // System properties don&#39;t generally contain newlines, so don&#39;t bother with unparsing.
 708       outputStream *text = xs-&gt;text();
 709       for (SystemProperty* p = Arguments::system_properties(); p != NULL; p = p-&gt;next()) {
 710         assert(p-&gt;key() != NULL, &quot;p-&gt;key() is NULL&quot;);
 711         if (p-&gt;is_readable()) {
 712           // Print in two stages to avoid problems with long
 713           // keys/values.
 714           text-&gt;print_raw(p-&gt;key());
 715           text-&gt;put(&#39;=&#39;);
 716           assert(p-&gt;value() != NULL, &quot;p-&gt;value() is NULL&quot;);
 717           text-&gt;print_raw_cr(p-&gt;value());
 718         }
 719       }
 720       xs-&gt;tail(&quot;properties&quot;);
 721     }
 722     xs-&gt;tail(&quot;vm_arguments&quot;);
 723     // tty output per se is grouped under the &lt;tty&gt;...&lt;/tty&gt; element.
 724     xs-&gt;head(&quot;tty&quot;);
 725     // All further non-markup text gets copied to the tty:
 726     xs-&gt;_text = this;  // requires friend declaration!
 727 }
 728 
 729 // finish_log() is called during normal VM shutdown. finish_log_on_error() is
 730 // called by ostream_abort() after a fatal error.
 731 //
 732 void defaultStream::finish_log() {
 733   xmlStream* xs = _outer_xmlStream;
 734   xs-&gt;done(&quot;tty&quot;);
 735 
 736   // Other log forks are appended here, at the End of Time:
 737   CompileLog::finish_log(xs-&gt;out());  // write compile logging, if any, now
 738 
 739   xs-&gt;done(&quot;hotspot_log&quot;);
 740   xs-&gt;flush();
 741 
 742   fileStream* file = _log_file;
 743   _log_file = NULL;
 744 
 745   delete _outer_xmlStream;
 746   _outer_xmlStream = NULL;
 747 
 748   file-&gt;flush();
 749   delete file;
 750 }
 751 
 752 void defaultStream::finish_log_on_error(char *buf, int buflen) {
 753   xmlStream* xs = _outer_xmlStream;
 754 
 755   if (xs &amp;&amp; xs-&gt;out()) {
 756 
 757     xs-&gt;done_raw(&quot;tty&quot;);
 758 
 759     // Other log forks are appended here, at the End of Time:
 760     CompileLog::finish_log_on_error(xs-&gt;out(), buf, buflen);  // write compile logging, if any, now
 761 
 762     xs-&gt;done_raw(&quot;hotspot_log&quot;);
 763     xs-&gt;flush();
 764 
 765     fileStream* file = _log_file;
 766     _log_file = NULL;
 767     _outer_xmlStream = NULL;
 768 
 769     if (file) {
 770       file-&gt;flush();
 771 
 772       // Can&#39;t delete or close the file because delete and fclose aren&#39;t
 773       // async-safe. We are about to die, so leave it to the kernel.
 774       // delete file;
 775     }
 776   }
 777 }
 778 
 779 intx defaultStream::hold(intx writer_id) {
 780   bool has_log = has_log_file();  // check before locking
 781   if (// impossible, but who knows?
 782       writer_id == NO_WRITER ||
 783 
 784       // bootstrap problem
 785       tty_lock == NULL ||
 786 
 787       // can&#39;t grab a lock if current Thread isn&#39;t set
 788       Thread::current_or_null() == NULL ||
 789 
 790       // developer hook
 791       !SerializeVMOutput ||
 792 
 793       // VM already unhealthy
 794       VMError::is_error_reported() ||
 795 
 796       // safepoint == global lock (for VM only)
 797       (SafepointSynchronize::is_synchronizing() &amp;&amp;
 798        Thread::current()-&gt;is_VM_thread())
 799       ) {
 800     // do not attempt to lock unless we know the thread and the VM is healthy
 801     return NO_WRITER;
 802   }
 803   if (_writer == writer_id) {
 804     // already held, no need to re-grab the lock
 805     return NO_WRITER;
 806   }
 807   tty_lock-&gt;lock_without_safepoint_check();
 808   // got the lock
 809   if (writer_id != _last_writer) {
 810     if (has_log) {
 811       _log_file-&gt;bol();
 812       // output a hint where this output is coming from:
 813       _log_file-&gt;print_cr(&quot;&lt;writer thread=&#39;&quot; UINTX_FORMAT &quot;&#39;/&gt;&quot;, writer_id);
 814     }
 815     _last_writer = writer_id;
 816   }
 817   _writer = writer_id;
 818   return writer_id;
 819 }
 820 
 821 void defaultStream::release(intx holder) {
 822   if (holder == NO_WRITER) {
 823     // nothing to release:  either a recursive lock, or we scribbled (too bad)
 824     return;
 825   }
 826   if (_writer != holder) {
 827     return;  // already unlocked, perhaps via break_tty_lock_for_safepoint
 828   }
 829   _writer = NO_WRITER;
 830   tty_lock-&gt;unlock();
 831 }
 832 
 833 void defaultStream::write(const char* s, size_t len) {
 834   intx thread_id = os::current_thread_id();
 835   intx holder = hold(thread_id);
 836 
 837   if (DisplayVMOutput &amp;&amp;
 838       (_outer_xmlStream == NULL || !_outer_xmlStream-&gt;inside_attrs())) {
 839     // print to output stream. It can be redirected by a vfprintf hook
 840     jio_print(s, len);
 841   }
 842 
 843   // print to log file
 844   if (has_log_file()) {
 845     int nl0 = _newlines;
 846     xmlTextStream::write(s, len);
 847     // flush the log file too, if there were any newlines
 848     if (nl0 != _newlines){
 849       flush();
 850     }
 851   } else {
 852     update_position(s, len);
 853   }
 854 
 855   release(holder);
 856 }
 857 
 858 intx ttyLocker::hold_tty() {
 859   if (defaultStream::instance == NULL)  return defaultStream::NO_WRITER;
 860   intx thread_id = os::current_thread_id();
 861   return defaultStream::instance-&gt;hold(thread_id);
 862 }
 863 
 864 void ttyLocker::release_tty(intx holder) {
 865   if (holder == defaultStream::NO_WRITER)  return;
 866   defaultStream::instance-&gt;release(holder);
 867 }
 868 
 869 bool ttyLocker::release_tty_if_locked() {
 870   intx thread_id = os::current_thread_id();
 871   if (defaultStream::instance-&gt;writer() == thread_id) {
 872     // release the lock and return true so callers know if was
 873     // previously held.
 874     release_tty(thread_id);
 875     return true;
 876   }
 877   return false;
 878 }
 879 
 880 void ttyLocker::break_tty_lock_for_safepoint(intx holder) {
 881   if (defaultStream::instance != NULL &amp;&amp;
 882       defaultStream::instance-&gt;writer() == holder) {
 883     if (xtty != NULL) {
 884       xtty-&gt;print_cr(&quot;&lt;!-- safepoint while printing --&gt;&quot;);
 885     }
 886     defaultStream::instance-&gt;release(holder);
 887   }
 888   // (else there was no lock to break)
 889 }
 890 
 891 void ostream_init() {
 892   if (defaultStream::instance == NULL) {
 893     defaultStream::instance = new(ResourceObj::C_HEAP, mtInternal) defaultStream();
 894     tty = defaultStream::instance;
 895 
 896     // We want to ensure that time stamps in GC logs consider time 0
 897     // the time when the JVM is initialized, not the first time we ask
 898     // for a time stamp. So, here, we explicitly update the time stamp
 899     // of tty.
 900     tty-&gt;time_stamp().update_to(1);
 901   }
 902 }
 903 
 904 void ostream_init_log() {
 905   // Note : this must be called AFTER ostream_init()
 906 
 907 #if INCLUDE_CDS
 908   // For -XX:DumpLoadedClassList=&lt;file&gt; option
 909   if (DumpLoadedClassList != NULL) {
 910     const char* list_name = make_log_name(DumpLoadedClassList, NULL);
 911     classlist_file = new(ResourceObj::C_HEAP, mtInternal)
 912                          fileStream(list_name);
 913     FREE_C_HEAP_ARRAY(char, list_name);
 914   }
 915 #endif
 916 
 917   // If we haven&#39;t lazily initialized the logfile yet, do it now,
 918   // to avoid the possibility of lazy initialization during a VM
 919   // crash, which can affect the stability of the fatal error handler.
 920   defaultStream::instance-&gt;has_log_file();
 921 }
 922 
 923 // ostream_exit() is called during normal VM exit to finish log files, flush
 924 // output and free resource.
 925 void ostream_exit() {
 926   static bool ostream_exit_called = false;
 927   if (ostream_exit_called)  return;
 928   ostream_exit_called = true;
 929 #if INCLUDE_CDS
 930   if (classlist_file != NULL) {
 931     delete classlist_file;
 932   }
 933 #endif
 934   if (tty != defaultStream::instance) {
 935     delete tty;
 936   }
 937   if (defaultStream::instance != NULL) {
 938     delete defaultStream::instance;
 939   }
 940   tty = NULL;
 941   xtty = NULL;
 942   defaultStream::instance = NULL;
 943 }
 944 
 945 // ostream_abort() is called by os::abort() when VM is about to die.
 946 void ostream_abort() {
 947   // Here we can&#39;t delete tty, just flush its output
 948   if (tty) tty-&gt;flush();
 949 
 950   if (defaultStream::instance != NULL) {
 951     static char buf[4096];
 952     defaultStream::instance-&gt;finish_log_on_error(buf, sizeof(buf));
 953   }
 954 }
 955 
 956 bufferedStream::bufferedStream(size_t initial_size, size_t bufmax) : outputStream() {
 957   buffer_length = initial_size;
 958   buffer        = NEW_C_HEAP_ARRAY(char, buffer_length, mtInternal);
 959   buffer_pos    = 0;
 960   buffer_fixed  = false;
 961   buffer_max    = bufmax;
 962   truncated     = false;
 963 }
 964 
 965 bufferedStream::bufferedStream(char* fixed_buffer, size_t fixed_buffer_size, size_t bufmax) : outputStream() {
 966   buffer_length = fixed_buffer_size;
 967   buffer        = fixed_buffer;
 968   buffer_pos    = 0;
 969   buffer_fixed  = true;
 970   buffer_max    = bufmax;
 971   truncated     = false;
 972 }
 973 
 974 void bufferedStream::write(const char* s, size_t len) {
 975 
 976   if (truncated) {
 977     return;
 978   }
 979 
 980   if(buffer_pos + len &gt; buffer_max) {
 981     flush(); // Note: may be a noop.
 982   }
 983 
 984   size_t end = buffer_pos + len;
 985   if (end &gt;= buffer_length) {
 986     if (buffer_fixed) {
 987       // if buffer cannot resize, silently truncate
 988       len = buffer_length - buffer_pos - 1;
 989       truncated = true;
 990     } else {
 991       // For small overruns, double the buffer.  For larger ones,
 992       // increase to the requested size.
 993       if (end &lt; buffer_length * 2) {
 994         end = buffer_length * 2;
 995       }
 996       // Impose a cap beyond which the buffer cannot grow - a size which
 997       // in all probability indicates a real error, e.g. faulty printing
 998       // code looping, while not affecting cases of just-very-large-but-its-normal
 999       // output.
1000       const size_t reasonable_cap = MAX2(100 * M, buffer_max * 2);
1001       if (end &gt; reasonable_cap) {
1002         // In debug VM, assert right away.
1003         assert(false, &quot;Exceeded max buffer size for this string.&quot;);
1004         // Release VM: silently truncate. We do this since these kind of errors
1005         // are both difficult to predict with testing (depending on logging content)
1006         // and usually not serious enough to kill a production VM for it.
1007         end = reasonable_cap;
1008         size_t remaining = end - buffer_pos;
1009         if (len &gt;= remaining) {
1010           len = remaining - 1;
1011           truncated = true;
1012         }
1013       }
1014       if (buffer_length &lt; end) {
1015         buffer = REALLOC_C_HEAP_ARRAY(char, buffer, end, mtInternal);
1016         buffer_length = end;
1017       }
1018     }
1019   }
1020   if (len &gt; 0) {
1021     memcpy(buffer + buffer_pos, s, len);
1022     buffer_pos += len;
1023     update_position(s, len);
1024   }
1025 }
1026 
1027 char* bufferedStream::as_string() {
1028   char* copy = NEW_RESOURCE_ARRAY(char, buffer_pos+1);
1029   strncpy(copy, buffer, buffer_pos);
1030   copy[buffer_pos] = 0;  // terminating null
1031   return copy;
1032 }
1033 
1034 bufferedStream::~bufferedStream() {
1035   if (!buffer_fixed) {
1036     FREE_C_HEAP_ARRAY(char, buffer);
1037   }
1038 }
1039 
1040 #ifndef PRODUCT
1041 
1042 #if defined(SOLARIS) || defined(LINUX) || defined(AIX) || defined(_ALLBSD_SOURCE)
1043 #include &lt;sys/types.h&gt;
1044 #include &lt;sys/socket.h&gt;
1045 #include &lt;netinet/in.h&gt;
1046 #include &lt;arpa/inet.h&gt;
1047 #elif defined(_WINDOWS)
1048 #include &lt;winsock2.h&gt;
1049 #endif
1050 
1051 // Network access
1052 networkStream::networkStream() : bufferedStream(1024*10, 1024*10) {
1053 
1054   _socket = -1;
1055 
1056   int result = os::socket(AF_INET, SOCK_STREAM, 0);
1057   if (result &lt;= 0) {
1058     assert(false, &quot;Socket could not be created!&quot;);
1059   } else {
1060     _socket = result;
1061   }
1062 }
1063 
1064 int networkStream::read(char *buf, size_t len) {
1065   return os::recv(_socket, buf, (int)len, 0);
1066 }
1067 
1068 void networkStream::flush() {
1069   if (size() != 0) {
1070     int result = os::raw_send(_socket, (char *)base(), size(), 0);
1071     assert(result != -1, &quot;connection error&quot;);
1072     assert(result == (int)size(), &quot;didn&#39;t send enough data&quot;);
1073   }
1074   reset();
1075 }
1076 
1077 networkStream::~networkStream() {
1078   close();
1079 }
1080 
1081 void networkStream::close() {
1082   if (_socket != -1) {
1083     flush();
1084     os::socket_close(_socket);
1085     _socket = -1;
1086   }
1087 }
1088 
1089 bool networkStream::connect(const char *ip, short port) {
1090 
1091   struct sockaddr_in server;
1092   server.sin_family = AF_INET;
1093   server.sin_port = htons(port);
1094 
1095   server.sin_addr.s_addr = inet_addr(ip);
1096   if (server.sin_addr.s_addr == (uint32_t)-1) {
1097     struct hostent* host = os::get_host_by_name((char*)ip);
1098     if (host != NULL) {
1099       memcpy(&amp;server.sin_addr, host-&gt;h_addr_list[0], host-&gt;h_length);
1100     } else {
1101       return false;
1102     }
1103   }
1104 
1105 
1106   int result = os::connect(_socket, (struct sockaddr*)&amp;server, sizeof(struct sockaddr_in));
1107   return (result &gt;= 0);
1108 }
1109 
1110 #endif
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
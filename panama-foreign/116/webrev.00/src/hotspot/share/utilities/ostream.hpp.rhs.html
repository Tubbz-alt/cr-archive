<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/ostream.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_OSTREAM_HPP
 26 #define SHARE_UTILITIES_OSTREAM_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/timer.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 
 32 DEBUG_ONLY(class ResourceMark;)
 33 
 34 // Output streams for printing
 35 //
 36 // Printing guidelines:
 37 // Where possible, please use tty-&gt;print() and tty-&gt;print_cr().
 38 // For product mode VM warnings use warning() which internally uses tty.
 39 // In places where tty is not initialized yet or too much overhead,
 40 // we may use jio_printf:
 41 //     jio_fprintf(defaultStream::output_stream(), &quot;Message&quot;);
 42 // This allows for redirection via -XX:+DisplayVMOutputToStdout and
 43 // -XX:+DisplayVMOutputToStderr
 44 class outputStream : public ResourceObj {
 45  private:
 46    NONCOPYABLE(outputStream);
 47 
 48  protected:
 49    int _indentation; // current indentation
 50    int _width;       // width of the page
 51    int _position;    // position on the current line
 52    int _newlines;    // number of &#39;\n&#39; output so far
 53    julong _precount; // number of chars output, less _position
 54    TimeStamp _stamp; // for time stamps
 55    char* _scratch;   // internal scratch buffer for printf
 56    size_t _scratch_len; // size of internal scratch buffer
 57 
 58    void update_position(const char* s, size_t len);
 59    static const char* do_vsnprintf(char* buffer, size_t buflen,
 60                                    const char* format, va_list ap,
 61                                    bool add_cr,
 62                                    size_t&amp; result_len)  ATTRIBUTE_PRINTF(3, 0);
 63 
 64    // calls do_vsnprintf and writes output to stream; uses an on-stack buffer.
 65    void do_vsnprintf_and_write_with_automatic_buffer(const char* format, va_list ap, bool add_cr) ATTRIBUTE_PRINTF(2, 0);
 66    // calls do_vsnprintf and writes output to stream; uses the user-provided buffer;
 67    void do_vsnprintf_and_write_with_scratch_buffer(const char* format, va_list ap, bool add_cr) ATTRIBUTE_PRINTF(2, 0);
 68    // calls do_vsnprintf, then writes output to stream.
 69    void do_vsnprintf_and_write(const char* format, va_list ap, bool add_cr) ATTRIBUTE_PRINTF(2, 0);
 70 
 71  public:
 72    // creation
 73    outputStream(int width = 80);
 74    outputStream(int width, bool has_time_stamps);
 75 
 76    // indentation
 77    outputStream&amp; indent();
 78    void inc() { _indentation++; };
 79    void dec() { _indentation--; };
 80    void inc(int n) { _indentation += n; };
 81    void dec(int n) { _indentation -= n; };
 82    int  indentation() const    { return _indentation; }
 83    void set_indentation(int i) { _indentation = i;    }
 84    void fill_to(int col);
 85    void move_to(int col, int slop = 6, int min_space = 2);
 86 
 87    // sizing
 88    int width()    const { return _width;    }
 89    int position() const { return _position; }
 90    int newlines() const { return _newlines; }
 91    julong count() const { return _precount + _position; }
 92    void set_count(julong count) { _precount = count - _position; }
 93    void set_position(int pos)   { _position = pos; }
 94 
 95    // printing
 96    void print(const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
 97    void print_cr(const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
 98    void vprint(const char *format, va_list argptr) ATTRIBUTE_PRINTF(2, 0);
 99    void vprint_cr(const char* format, va_list argptr) ATTRIBUTE_PRINTF(2, 0);
100    void print_raw(const char* str)            { write(str, strlen(str)); }
101    void print_raw(const char* str, int len)   { write(str,         len); }
102    void print_raw_cr(const char* str)         { write(str, strlen(str)); cr(); }
103    void print_raw_cr(const char* str, int len){ write(str,         len); cr(); }
104    void print_data(void* data, size_t len, bool with_ascii);
105    void put(char ch);
106    void sp(int count = 1);
107    void cr();
108    void cr_indent();
109    void bol() { if (_position &gt; 0)  cr(); }
110 
111 
112    // Time stamp
113    TimeStamp&amp; time_stamp() { return _stamp; }
114    void stamp();
115    void stamp(bool guard, const char* prefix, const char* suffix);
116    void stamp(bool guard) {
117      stamp(guard, &quot;&quot;, &quot;: &quot;);
118    }
119    // Date stamp
120    void date_stamp(bool guard, const char* prefix, const char* suffix);
121    // A simplified call that includes a suffix of &quot;: &quot;
122    void date_stamp(bool guard) {
123      date_stamp(guard, &quot;&quot;, &quot;: &quot;);
124    }
125 
126    // portable printing of 64 bit integers
127    void print_jlong(jlong value);
128    void print_julong(julong value);
129 
130    // flushing
131    virtual void flush() {}
132    virtual void write(const char* str, size_t len) = 0;
133    virtual void rotate_log(bool force, outputStream* out = NULL) {} // GC log rotation
134    virtual ~outputStream() {}   // close properly on deletion
135 
136    // Caller may specify their own scratch buffer to use for printing; otherwise,
137    // an automatic buffer on the stack (with O_BUFLEN len) is used.
138    void set_scratch_buffer(char* p, size_t len) { _scratch = p; _scratch_len = len; }
139 
140    void dec_cr() { dec(); cr(); }
141    void inc_cr() { inc(); cr(); }
142 };
143 
144 // standard output
145 // ANSI C++ name collision
146 extern outputStream* tty;           // tty output
147 
148 class streamIndentor : public StackObj {
149  private:
150   outputStream* _str;
151   int _amount;
152 
153  public:
154   streamIndentor(outputStream* str, int amt = 2) : _str(str), _amount(amt) {
155     _str-&gt;inc(_amount);
156   }
157   ~streamIndentor() { _str-&gt;dec(_amount); }
158 };
159 
160 // advisory locking for the shared tty stream:
161 class ttyLocker: StackObj {
162   friend class ttyUnlocker;
163  private:
164   intx _holder;
165 
166  public:
167   static intx  hold_tty();                // returns a &quot;holder&quot; token
168   static void  release_tty(intx holder);  // must witness same token
169   static bool  release_tty_if_locked();   // returns true if lock was released
170   static void  break_tty_lock_for_safepoint(intx holder);
171 
172   ttyLocker()  { _holder = hold_tty(); }
173   ~ttyLocker() { release_tty(_holder); }
174 };
175 
176 // Release the tty lock if it&#39;s held and reacquire it if it was
177 // locked.  Used to avoid lock ordering problems.
178 class ttyUnlocker: StackObj {
179  private:
180   bool _was_locked;
181  public:
182   ttyUnlocker()  {
183     _was_locked = ttyLocker::release_tty_if_locked();
184   }
185   ~ttyUnlocker() {
186     if (_was_locked) {
187       ttyLocker::hold_tty();
188     }
189   }
190 };
191 
192 // for writing to strings; buffer will expand automatically.
193 // Buffer will always be zero-terminated.
194 class stringStream : public outputStream {
195  protected:
196   char*  buffer;
197   size_t buffer_pos;
198   size_t buffer_length;
199   bool   buffer_fixed;
200 
201   // zero terminate at buffer_pos.
202   void zero_terminate();
203 
204  public:
205   // Create a stringStream using an internal buffer of initially initial_bufsize size;
206   // will be enlarged on demand. There is no maximum cap.
207   stringStream(size_t initial_bufsize = 256);
208   // Creates a stringStream using a caller-provided buffer. Will truncate silently if
209   // it overflows.
210   stringStream(char* fixed_buffer, size_t fixed_buffer_size);
211   ~stringStream();
212   virtual void write(const char* c, size_t len);
213   // Return number of characters written into buffer, excluding terminating zero and
214   // subject to truncation in static buffer mode.
215   size_t      size() const { return buffer_pos; }
216   const char* base() const { return buffer; }
217   void  reset();
218   char* as_string() const;
219 };
220 
221 class fileStream : public outputStream {
222  protected:
223   FILE* _file;
224   bool  _need_close;
225  public:
226   fileStream() { _file = NULL; _need_close = false; }
227   fileStream(const char* file_name);
228   fileStream(const char* file_name, const char* opentype);
229   fileStream(FILE* file, bool need_close = false) { _file = file; _need_close = need_close; }
230   ~fileStream();
231   bool is_open() const { return _file != NULL; }
232   virtual void write(const char* c, size_t len);
<a name="1" id="anc1"></a><span class="line-modified">233   size_t read(void *data, size_t size, size_t count) { return _file != NULL ? ::fread(data, size, count, _file) : 0; }</span>
234   char* readln(char *data, int count);
<a name="2" id="anc2"></a><span class="line-modified">235   int eof() { return _file != NULL ? feof(_file) : -1; }</span>
236   long fileSize();
<a name="3" id="anc3"></a><span class="line-modified">237   void rewind() { if (_file != NULL) ::rewind(_file); }</span>
238   void flush();
239 };
240 
241 CDS_ONLY(extern fileStream*   classlist_file;)
242 
243 // unlike fileStream, fdStream does unbuffered I/O by calling
244 // open() and write() directly. It is async-safe, but output
245 // from multiple thread may be mixed together. Used by fatal
246 // error handler.
247 class fdStream : public outputStream {
248  protected:
249   int  _fd;
250  public:
251   fdStream(int fd = -1) : _fd(fd) { }
252   bool is_open() const { return _fd != -1; }
253   void set_fd(int fd) { _fd = fd; }
254   int fd() const { return _fd; }
255   virtual void write(const char* c, size_t len);
256   void flush() {};
257 };
258 
259 void ostream_init();
260 void ostream_init_log();
261 void ostream_exit();
262 void ostream_abort();
263 
264 // In the non-fixed buffer case an underlying buffer will be created and
265 // managed in C heap. Not MT-safe.
266 class bufferedStream : public outputStream {
267  protected:
268   char*  buffer;
269   size_t buffer_pos;
270   size_t buffer_max;
271   size_t buffer_length;
272   bool   buffer_fixed;
273   bool   truncated;
274  public:
275   bufferedStream(size_t initial_bufsize = 256, size_t bufmax = 1024*1024*10);
276   bufferedStream(char* fixed_buffer, size_t fixed_buffer_size, size_t bufmax = 1024*1024*10);
277   ~bufferedStream();
278   virtual void write(const char* c, size_t len);
279   size_t      size() { return buffer_pos; }
280   const char* base() { return buffer; }
281   void  reset() { buffer_pos = 0; _precount = 0; _position = 0; }
282   char* as_string();
283 };
284 
285 #define O_BUFLEN 2000   // max size of output of individual print() methods
286 
287 #ifndef PRODUCT
288 
289 class networkStream : public bufferedStream {
290 
291   private:
292     int _socket;
293 
294   public:
295     networkStream();
296     ~networkStream();
297 
298     bool connect(const char *host, short port);
299     bool is_open() const { return _socket != -1; }
300     int read(char *buf, size_t len);
301     void close();
302     virtual void flush();
303 };
304 
305 #endif
306 
307 #endif // SHARE_UTILITIES_OSTREAM_HPP
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
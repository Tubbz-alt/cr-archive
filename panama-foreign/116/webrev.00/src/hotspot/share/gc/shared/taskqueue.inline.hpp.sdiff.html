<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/taskqueue.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="taskqueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../shenandoah/shenandoahBarrierSet.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/taskqueue.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 40   for (uint i = 0; i &lt; n; i++) {
 41     _queues[i] = NULL;
 42   }
 43 }
 44 
 45 template &lt;class T, MEMFLAGS F&gt;
 46 inline GenericTaskQueueSet&lt;T, F&gt;::~GenericTaskQueueSet() {
 47   FREE_C_HEAP_ARRAY(T*, _queues);
 48 }
 49 
 50 template&lt;class E, MEMFLAGS F, unsigned int N&gt;
 51 inline void GenericTaskQueue&lt;E, F, N&gt;::initialize() {
 52   _elems = ArrayAllocator&lt;E&gt;::allocate(N, F);
 53 }
 54 
 55 template&lt;class E, MEMFLAGS F, unsigned int N&gt;
 56 inline GenericTaskQueue&lt;E, F, N&gt;::~GenericTaskQueue() {
 57   ArrayAllocator&lt;E&gt;::free(const_cast&lt;E*&gt;(_elems), N);
 58 }
 59 
<span class="line-removed"> 60 template&lt;class E, MEMFLAGS F, unsigned int N&gt;</span>
<span class="line-removed"> 61 bool GenericTaskQueue&lt;E, F, N&gt;::push_slow(E t, uint dirty_n_elems) {</span>
<span class="line-removed"> 62   if (dirty_n_elems == N - 1) {</span>
<span class="line-removed"> 63     // Actually means 0, so do the push.</span>
<span class="line-removed"> 64     uint localBot = _bottom;</span>
<span class="line-removed"> 65     // g++ complains if the volatile result of the assignment is</span>
<span class="line-removed"> 66     // unused, so we cast the volatile away.  We cannot cast directly</span>
<span class="line-removed"> 67     // to void, because gcc treats that as not using the result of the</span>
<span class="line-removed"> 68     // assignment.  However, casting to E&amp; means that we trigger an</span>
<span class="line-removed"> 69     // unused-value warning.  So, we cast the E&amp; to void.</span>
<span class="line-removed"> 70     (void)const_cast&lt;E&amp;&gt;(_elems[localBot] = t);</span>
<span class="line-removed"> 71     Atomic::release_store(&amp;_bottom, increment_index(localBot));</span>
<span class="line-removed"> 72     TASKQUEUE_STATS_ONLY(stats.record_push());</span>
<span class="line-removed"> 73     return true;</span>
<span class="line-removed"> 74   }</span>
<span class="line-removed"> 75   return false;</span>
<span class="line-removed"> 76 }</span>
<span class="line-removed"> 77 </span>
 78 template&lt;class E, MEMFLAGS F, unsigned int N&gt; inline bool
 79 GenericTaskQueue&lt;E, F, N&gt;::push(E t) {
 80   uint localBot = _bottom;
 81   assert(localBot &lt; N, &quot;_bottom out of range.&quot;);
 82   idx_t top = _age.top();
 83   uint dirty_n_elems = dirty_size(localBot, top);
<span class="line-modified"> 84   assert(dirty_n_elems &lt; N, &quot;n_elems out of range.&quot;);</span>










 85   if (dirty_n_elems &lt; max_elems()) {
 86     // g++ complains if the volatile result of the assignment is
 87     // unused, so we cast the volatile away.  We cannot cast directly
 88     // to void, because gcc treats that as not using the result of the
 89     // assignment.  However, casting to E&amp; means that we trigger an
 90     // unused-value warning.  So, we cast the E&amp; to void.
 91     (void) const_cast&lt;E&amp;&gt;(_elems[localBot] = t);
 92     Atomic::release_store(&amp;_bottom, increment_index(localBot));
 93     TASKQUEUE_STATS_ONLY(stats.record_push());
 94     return true;
<span class="line-removed"> 95   } else {</span>
<span class="line-removed"> 96     return push_slow(t, dirty_n_elems);</span>
 97   }

 98 }
 99 
100 template &lt;class E, MEMFLAGS F, unsigned int N&gt;
101 inline bool OverflowTaskQueue&lt;E, F, N&gt;::push(E t)
102 {
103   if (!taskqueue_t::push(t)) {
104     overflow_stack()-&gt;push(t);
105     TASKQUEUE_STATS_ONLY(stats.record_overflow(overflow_stack()-&gt;size()));
106   }
107   return true;
108 }
109 
110 template &lt;class E, MEMFLAGS F, unsigned int N&gt;
111 inline bool OverflowTaskQueue&lt;E, F, N&gt;::try_push_to_taskqueue(E t) {
112   return taskqueue_t::push(t);
113 }
114 
115 // pop_local_slow() is done by the owning thread and is trying to
116 // get the last task in the queue.  It will compete with pop_global()
117 // that will be used by other threads.  The tag age is incremented
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 40   for (uint i = 0; i &lt; n; i++) {
 41     _queues[i] = NULL;
 42   }
 43 }
 44 
 45 template &lt;class T, MEMFLAGS F&gt;
 46 inline GenericTaskQueueSet&lt;T, F&gt;::~GenericTaskQueueSet() {
 47   FREE_C_HEAP_ARRAY(T*, _queues);
 48 }
 49 
 50 template&lt;class E, MEMFLAGS F, unsigned int N&gt;
 51 inline void GenericTaskQueue&lt;E, F, N&gt;::initialize() {
 52   _elems = ArrayAllocator&lt;E&gt;::allocate(N, F);
 53 }
 54 
 55 template&lt;class E, MEMFLAGS F, unsigned int N&gt;
 56 inline GenericTaskQueue&lt;E, F, N&gt;::~GenericTaskQueue() {
 57   ArrayAllocator&lt;E&gt;::free(const_cast&lt;E*&gt;(_elems), N);
 58 }
 59 


















 60 template&lt;class E, MEMFLAGS F, unsigned int N&gt; inline bool
 61 GenericTaskQueue&lt;E, F, N&gt;::push(E t) {
 62   uint localBot = _bottom;
 63   assert(localBot &lt; N, &quot;_bottom out of range.&quot;);
 64   idx_t top = _age.top();
 65   uint dirty_n_elems = dirty_size(localBot, top);
<span class="line-modified"> 66   // A dirty_size of N-1 cannot happen in push.  Considering only push:</span>
<span class="line-added"> 67   // (1) dirty_n_elems is initially 0.</span>
<span class="line-added"> 68   // (2) push adds an element iff dirty_n_elems &lt; max_elems(), which is N - 2.</span>
<span class="line-added"> 69   // (3) only push adding an element can increase dirty_n_elems.</span>
<span class="line-added"> 70   // =&gt; dirty_n_elems &lt;= N - 2, by induction</span>
<span class="line-added"> 71   // =&gt; dirty_n_elems &lt; N - 1, invariant</span>
<span class="line-added"> 72   //</span>
<span class="line-added"> 73   // A pop_global that is concurrent with push cannot produce a state where</span>
<span class="line-added"> 74   // dirty_size == N-1.  pop_global only removes an element if dirty_elems &gt; 0,</span>
<span class="line-added"> 75   // so can&#39;t underflow to -1 (== N-1) with push.</span>
<span class="line-added"> 76   assert(dirty_n_elems &lt;= max_elems(), &quot;n_elems out of range.&quot;);</span>
 77   if (dirty_n_elems &lt; max_elems()) {
 78     // g++ complains if the volatile result of the assignment is
 79     // unused, so we cast the volatile away.  We cannot cast directly
 80     // to void, because gcc treats that as not using the result of the
 81     // assignment.  However, casting to E&amp; means that we trigger an
 82     // unused-value warning.  So, we cast the E&amp; to void.
 83     (void) const_cast&lt;E&amp;&gt;(_elems[localBot] = t);
 84     Atomic::release_store(&amp;_bottom, increment_index(localBot));
 85     TASKQUEUE_STATS_ONLY(stats.record_push());
 86     return true;


 87   }
<span class="line-added"> 88   return false;                 // Queue is full.</span>
 89 }
 90 
 91 template &lt;class E, MEMFLAGS F, unsigned int N&gt;
 92 inline bool OverflowTaskQueue&lt;E, F, N&gt;::push(E t)
 93 {
 94   if (!taskqueue_t::push(t)) {
 95     overflow_stack()-&gt;push(t);
 96     TASKQUEUE_STATS_ONLY(stats.record_overflow(overflow_stack()-&gt;size()));
 97   }
 98   return true;
 99 }
100 
101 template &lt;class E, MEMFLAGS F, unsigned int N&gt;
102 inline bool OverflowTaskQueue&lt;E, F, N&gt;::try_push_to_taskqueue(E t) {
103   return taskqueue_t::push(t);
104 }
105 
106 // pop_local_slow() is done by the owning thread and is trying to
107 // get the last task in the queue.  It will compete with pop_global()
108 // that will be used by other threads.  The tag age is incremented
</pre>
</td>
</tr>
</table>
<center><a href="taskqueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../shenandoah/shenandoahBarrierSet.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
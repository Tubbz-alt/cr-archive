<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahMarkCompact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPhaseTimings.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
196 
197   virtual void do_oop(narrowOop* p) {
198     ShouldNotReachHere();
199   }
200 };
201 
202 void ShenandoahNMethod::heal_nmethod(nmethod* nm) {
203   ShenandoahNMethod* data = gc_data(nm);
204   assert(data != NULL, &quot;Sanity&quot;);
205   assert(data-&gt;lock()-&gt;owned_by_self(), &quot;Must hold the lock&quot;);
206 
207   ShenandoahHeap* const heap = ShenandoahHeap::heap();
208   if (heap-&gt;is_concurrent_mark_in_progress()) {
209     if (heap-&gt;has_forwarded_objects()) {
210       ShenandoahKeepNMethodMetadataAliveClosure&lt;true&gt; cl;
211       data-&gt;oops_do(&amp;cl);
212     } else {
213       ShenandoahKeepNMethodMetadataAliveClosure&lt;false&gt; cl;
214       data-&gt;oops_do(&amp;cl);
215     }
<span class="line-modified">216   } else if (heap-&gt;is_concurrent_root_in_progress()) {</span>
217     ShenandoahEvacOOMScope evac_scope;
218     ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
219     data-&gt;oops_do(&amp;cl, true /*fix relocation*/);
220   } else {
221     // There is possibility that GC is cancelled when it arrives final mark.
222     // In this case, concurrent root phase is skipped and degenerated GC should be
223     // followed, where nmethods are disarmed.
224     assert(heap-&gt;cancelled_gc(), &quot;What else?&quot;);
225   }
226 }
227 
228 #ifdef ASSERT
229 void ShenandoahNMethod::assert_alive_and_correct() {
230   assert(_nm-&gt;is_alive(), &quot;only alive nmethods here&quot;);
231   ShenandoahHeap* heap = ShenandoahHeap::heap();
232   for (int c = 0; c &lt; _oops_count; c++) {
233     oop *loc = _oops[c];
234     assert(_nm-&gt;code_contains((address) loc) || _nm-&gt;oops_contains(loc), &quot;nmethod should contain the oop*&quot;);
235     oop o = RawAccess&lt;&gt;::oop_load(loc);
236     shenandoah_assert_correct_except(loc, o, o == NULL || heap-&gt;is_full_gc_move_in_progress());
</pre>
</td>
<td>
<hr />
<pre>
196 
197   virtual void do_oop(narrowOop* p) {
198     ShouldNotReachHere();
199   }
200 };
201 
202 void ShenandoahNMethod::heal_nmethod(nmethod* nm) {
203   ShenandoahNMethod* data = gc_data(nm);
204   assert(data != NULL, &quot;Sanity&quot;);
205   assert(data-&gt;lock()-&gt;owned_by_self(), &quot;Must hold the lock&quot;);
206 
207   ShenandoahHeap* const heap = ShenandoahHeap::heap();
208   if (heap-&gt;is_concurrent_mark_in_progress()) {
209     if (heap-&gt;has_forwarded_objects()) {
210       ShenandoahKeepNMethodMetadataAliveClosure&lt;true&gt; cl;
211       data-&gt;oops_do(&amp;cl);
212     } else {
213       ShenandoahKeepNMethodMetadataAliveClosure&lt;false&gt; cl;
214       data-&gt;oops_do(&amp;cl);
215     }
<span class="line-modified">216   } else if (heap-&gt;is_concurrent_weak_root_in_progress()) {</span>
217     ShenandoahEvacOOMScope evac_scope;
218     ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
219     data-&gt;oops_do(&amp;cl, true /*fix relocation*/);
220   } else {
221     // There is possibility that GC is cancelled when it arrives final mark.
222     // In this case, concurrent root phase is skipped and degenerated GC should be
223     // followed, where nmethods are disarmed.
224     assert(heap-&gt;cancelled_gc(), &quot;What else?&quot;);
225   }
226 }
227 
228 #ifdef ASSERT
229 void ShenandoahNMethod::assert_alive_and_correct() {
230   assert(_nm-&gt;is_alive(), &quot;only alive nmethods here&quot;);
231   ShenandoahHeap* heap = ShenandoahHeap::heap();
232   for (int c = 0; c &lt; _oops_count; c++) {
233     oop *loc = _oops[c];
234     assert(_nm-&gt;code_contains((address) loc) || _nm-&gt;oops_contains(loc), &quot;nmethod should contain the oop*&quot;);
235     oop o = RawAccess&lt;&gt;::oop_load(loc);
236     shenandoah_assert_correct_except(loc, o, o == NULL || heap-&gt;is_full_gc_move_in_progress());
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahMarkCompact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPhaseTimings.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
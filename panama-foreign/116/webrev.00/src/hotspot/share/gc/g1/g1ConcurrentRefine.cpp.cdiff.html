<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1ConcurrentRefine.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1CollectedHeap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefine.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentRefine.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 406,24 ***</span>
      dcqs.set_max_cards_padding(0);
    }
    dcqs.notify_if_necessary();
  }
  
<span class="line-modified">! G1ConcurrentRefine::RefinementStats G1ConcurrentRefine::total_refinement_stats() const {</span>
<span class="line-modified">!   struct CollectData : public ThreadClosure {</span>
<span class="line-modified">!     Tickspan _total_time;</span>
<span class="line-removed">-     size_t _total_cards;</span>
<span class="line-removed">-     CollectData() : _total_time(), _total_cards(0) {}</span>
      virtual void do_thread(Thread* t) {
        G1ConcurrentRefineThread* crt = static_cast&lt;G1ConcurrentRefineThread*&gt;(t);
<span class="line-modified">!       _total_time += crt-&gt;total_refinement_time();</span>
<span class="line-modified">!       _total_cards += crt-&gt;total_refined_cards();</span>
      }
    } collector;
<span class="line-modified">!   // Cast away const so we can call non-modifying closure on threads.</span>
<span class="line-modified">!   const_cast&lt;G1ConcurrentRefine*&gt;(this)-&gt;threads_do(&amp;collector);</span>
<span class="line-removed">-   return RefinementStats(collector._total_time, collector._total_cards);</span>
  }
  
  size_t G1ConcurrentRefine::activation_threshold(uint worker_id) const {
    Thresholds thresholds = calc_thresholds(_green_zone, _yellow_zone, worker_id);
    return activation_level(thresholds);
<span class="line-new-header">--- 406,22 ---</span>
      dcqs.set_max_cards_padding(0);
    }
    dcqs.notify_if_necessary();
  }
  
<span class="line-modified">! G1ConcurrentRefineStats G1ConcurrentRefine::get_and_reset_refinement_stats() {</span>
<span class="line-modified">!   struct CollectStats : public ThreadClosure {</span>
<span class="line-modified">!     G1ConcurrentRefineStats _total_stats;</span>
      virtual void do_thread(Thread* t) {
        G1ConcurrentRefineThread* crt = static_cast&lt;G1ConcurrentRefineThread*&gt;(t);
<span class="line-modified">!       G1ConcurrentRefineStats&amp; stats = *crt-&gt;refinement_stats();</span>
<span class="line-modified">!       _total_stats += stats;</span>
<span class="line-added">+       stats.reset();</span>
      }
    } collector;
<span class="line-modified">!   threads_do(&amp;collector);</span>
<span class="line-modified">!   return collector._total_stats;</span>
  }
  
  size_t G1ConcurrentRefine::activation_threshold(uint worker_id) const {
    Thresholds thresholds = calc_thresholds(_green_zone, _yellow_zone, worker_id);
    return activation_level(thresholds);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 443,11 ***</span>
      _thread_control.maybe_activate_next(worker_id);
    }
  }
  
  bool G1ConcurrentRefine::do_refinement_step(uint worker_id,
<span class="line-modified">!                                             size_t* total_refined_cards) {</span>
    G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();
  
    size_t curr_cards = dcqs.num_cards();
    // If the number of the cards falls down into the yellow zone,
    // that means that the transition period after the evacuation pause has ended.
<span class="line-new-header">--- 441,11 ---</span>
      _thread_control.maybe_activate_next(worker_id);
    }
  }
  
  bool G1ConcurrentRefine::do_refinement_step(uint worker_id,
<span class="line-modified">!                                             G1ConcurrentRefineStats* stats) {</span>
    G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();
  
    size_t curr_cards = dcqs.num_cards();
    // If the number of the cards falls down into the yellow zone,
    // that means that the transition period after the evacuation pause has ended.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 458,7 ***</span>
    maybe_activate_more_threads(worker_id, curr_cards);
  
    // Process the next buffer, if there are enough left.
    return dcqs.refine_completed_buffer_concurrently(worker_id + worker_id_offset(),
                                                     deactivation_threshold(worker_id),
<span class="line-modified">!                                                    total_refined_cards);</span>
  }
<span class="line-new-header">--- 456,7 ---</span>
    maybe_activate_more_threads(worker_id, curr_cards);
  
    // Process the next buffer, if there are enough left.
    return dcqs.refine_completed_buffer_concurrently(worker_id + worker_id_offset(),
                                                     deactivation_threshold(worker_id),
<span class="line-modified">!                                                    stats);</span>
  }
</pre>
<center><a href="g1CollectedHeap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefine.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
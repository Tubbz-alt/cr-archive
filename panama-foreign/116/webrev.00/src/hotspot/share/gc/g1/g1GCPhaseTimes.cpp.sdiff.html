<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1GCPhaseTimes.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1DirtyCardQueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1GCPhaseTimes.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1GCPhaseTimes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
140   _gc_par_phases[NonYoungFreeCSet] = new WorkerDataArray&lt;double&gt;(&quot;Non-Young Free Collection Set (ms):&quot;, max_gc_threads);
141   _gc_par_phases[RebuildFreeList] = new WorkerDataArray&lt;double&gt;(&quot;Parallel Rebuild Free List (ms):&quot;, max_gc_threads);
142 
143   reset();
144 }
145 
146 void G1GCPhaseTimes::reset() {
147   _cur_collection_initial_evac_time_ms = 0.0;
148   _cur_optional_evac_time_ms = 0.0;
149   _cur_collection_code_root_fixup_time_ms = 0.0;
150   _cur_strong_code_root_purge_time_ms = 0.0;
151   _cur_merge_heap_roots_time_ms = 0.0;
152   _cur_optional_merge_heap_roots_time_ms = 0.0;
153   _cur_prepare_merge_heap_roots_time_ms = 0.0;
154   _cur_optional_prepare_merge_heap_roots_time_ms = 0.0;
155   _cur_evac_fail_recalc_used = 0.0;
156   _cur_evac_fail_remove_self_forwards = 0.0;
157   _cur_string_deduplication_time_ms = 0.0;
158   _cur_prepare_tlab_time_ms = 0.0;
159   _cur_resize_tlab_time_ms = 0.0;

160   _cur_derived_pointer_table_update_time_ms = 0.0;
161   _cur_clear_ct_time_ms = 0.0;
162   _cur_expand_heap_time_ms = 0.0;
163   _cur_ref_proc_time_ms = 0.0;
164   _cur_collection_start_sec = 0.0;
165   _root_region_scan_wait_time_ms = 0.0;
166   _external_accounted_time_ms = 0.0;
167   _recorded_prepare_heap_roots_time_ms = 0.0;
168   _recorded_clear_claimed_marks_time_ms = 0.0;
169   _recorded_young_cset_choice_time_ms = 0.0;
170   _recorded_non_young_cset_choice_time_ms = 0.0;
171   _recorded_redirty_logged_cards_time_ms = 0.0;
172   _recorded_preserve_cm_referents_time_ms = 0.0;
173   _recorded_start_new_cset_time_ms = 0.0;
174   _recorded_total_free_cset_time_ms = 0.0;
175   _recorded_serial_free_cset_time_ms = 0.0;
176   _recorded_total_rebuild_freelist_time_ms = 0.0;
177   _recorded_serial_rebuild_freelist_time_ms = 0.0;
178   _cur_fast_reclaim_humongous_time_ms = 0.0;
179   _cur_region_register_time = 0.0;
</pre>
<hr />
<pre>
360 
361   if (lt.is_enabled()) {
362     LogStream ls(lt);
363     ls.print_cr(&quot;%s%s: &quot; TIME_FORMAT, indent(2), name, value);
364   } else if (lt2.is_enabled()) {
365     LogStream ls(lt2);
366     ls.print_cr(&quot;%s%s: &quot; TIME_FORMAT, indent(2), name, value);
367   }
368 }
369 
370 void G1GCPhaseTimes::trace_time(const char* name, double value) const {
371   log_trace(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT, indent(3), name, value);
372 }
373 
374 void G1GCPhaseTimes::trace_count(const char* name, size_t value) const {
375   log_trace(gc, phases)(&quot;%s%s: &quot; SIZE_FORMAT, indent(3), name, value);
376 }
377 
378 double G1GCPhaseTimes::print_pre_evacuate_collection_set() const {
379   const double sum_ms = _root_region_scan_wait_time_ms +


380                         _recorded_young_cset_choice_time_ms +
381                         _recorded_non_young_cset_choice_time_ms +
382                         _cur_region_register_time +
383                         _recorded_prepare_heap_roots_time_ms +
384                         _recorded_clear_claimed_marks_time_ms;
385 
386   info_time(&quot;Pre Evacuate Collection Set&quot;, sum_ms);
387 
388   if (_root_region_scan_wait_time_ms &gt; 0.0) {
389     debug_time(&quot;Root Region Scan Waiting&quot;, _root_region_scan_wait_time_ms);
390   }
391   debug_time(&quot;Prepare TLABs&quot;, _cur_prepare_tlab_time_ms);

392   debug_time(&quot;Choose Collection Set&quot;, (_recorded_young_cset_choice_time_ms + _recorded_non_young_cset_choice_time_ms));
393   debug_time(&quot;Region Register&quot;, _cur_region_register_time);
394   if (G1EagerReclaimHumongousObjects) {
395     trace_count(&quot;Humongous Total&quot;, _cur_fast_reclaim_humongous_total);
396     trace_count(&quot;Humongous Candidate&quot;, _cur_fast_reclaim_humongous_candidates);
397   }
398 
399   debug_time(&quot;Prepare Heap Roots&quot;, _recorded_prepare_heap_roots_time_ms);
400   if (_recorded_clear_claimed_marks_time_ms &gt; 0.0) {
401     debug_time(&quot;Clear Claimed Marks&quot;, _recorded_clear_claimed_marks_time_ms);
402   }
403   return sum_ms;
404 }
405 
406 double G1GCPhaseTimes::print_evacuate_optional_collection_set() const {
407   const double sum_ms = _cur_optional_evac_time_ms + _cur_optional_merge_heap_roots_time_ms;
408   if (sum_ms &gt; 0) {
409     info_time(&quot;Merge Optional Heap Roots&quot;, _cur_optional_merge_heap_roots_time_ms);
410 
411     debug_time(&quot;Prepare Optional Merge Heap Roots&quot;, _cur_optional_prepare_merge_heap_roots_time_ms);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
140   _gc_par_phases[NonYoungFreeCSet] = new WorkerDataArray&lt;double&gt;(&quot;Non-Young Free Collection Set (ms):&quot;, max_gc_threads);
141   _gc_par_phases[RebuildFreeList] = new WorkerDataArray&lt;double&gt;(&quot;Parallel Rebuild Free List (ms):&quot;, max_gc_threads);
142 
143   reset();
144 }
145 
146 void G1GCPhaseTimes::reset() {
147   _cur_collection_initial_evac_time_ms = 0.0;
148   _cur_optional_evac_time_ms = 0.0;
149   _cur_collection_code_root_fixup_time_ms = 0.0;
150   _cur_strong_code_root_purge_time_ms = 0.0;
151   _cur_merge_heap_roots_time_ms = 0.0;
152   _cur_optional_merge_heap_roots_time_ms = 0.0;
153   _cur_prepare_merge_heap_roots_time_ms = 0.0;
154   _cur_optional_prepare_merge_heap_roots_time_ms = 0.0;
155   _cur_evac_fail_recalc_used = 0.0;
156   _cur_evac_fail_remove_self_forwards = 0.0;
157   _cur_string_deduplication_time_ms = 0.0;
158   _cur_prepare_tlab_time_ms = 0.0;
159   _cur_resize_tlab_time_ms = 0.0;
<span class="line-added">160   _cur_concatenate_dirty_card_logs_time_ms = 0.0;</span>
161   _cur_derived_pointer_table_update_time_ms = 0.0;
162   _cur_clear_ct_time_ms = 0.0;
163   _cur_expand_heap_time_ms = 0.0;
164   _cur_ref_proc_time_ms = 0.0;
165   _cur_collection_start_sec = 0.0;
166   _root_region_scan_wait_time_ms = 0.0;
167   _external_accounted_time_ms = 0.0;
168   _recorded_prepare_heap_roots_time_ms = 0.0;
169   _recorded_clear_claimed_marks_time_ms = 0.0;
170   _recorded_young_cset_choice_time_ms = 0.0;
171   _recorded_non_young_cset_choice_time_ms = 0.0;
172   _recorded_redirty_logged_cards_time_ms = 0.0;
173   _recorded_preserve_cm_referents_time_ms = 0.0;
174   _recorded_start_new_cset_time_ms = 0.0;
175   _recorded_total_free_cset_time_ms = 0.0;
176   _recorded_serial_free_cset_time_ms = 0.0;
177   _recorded_total_rebuild_freelist_time_ms = 0.0;
178   _recorded_serial_rebuild_freelist_time_ms = 0.0;
179   _cur_fast_reclaim_humongous_time_ms = 0.0;
180   _cur_region_register_time = 0.0;
</pre>
<hr />
<pre>
361 
362   if (lt.is_enabled()) {
363     LogStream ls(lt);
364     ls.print_cr(&quot;%s%s: &quot; TIME_FORMAT, indent(2), name, value);
365   } else if (lt2.is_enabled()) {
366     LogStream ls(lt2);
367     ls.print_cr(&quot;%s%s: &quot; TIME_FORMAT, indent(2), name, value);
368   }
369 }
370 
371 void G1GCPhaseTimes::trace_time(const char* name, double value) const {
372   log_trace(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT, indent(3), name, value);
373 }
374 
375 void G1GCPhaseTimes::trace_count(const char* name, size_t value) const {
376   log_trace(gc, phases)(&quot;%s%s: &quot; SIZE_FORMAT, indent(3), name, value);
377 }
378 
379 double G1GCPhaseTimes::print_pre_evacuate_collection_set() const {
380   const double sum_ms = _root_region_scan_wait_time_ms +
<span class="line-added">381                         _cur_prepare_tlab_time_ms +</span>
<span class="line-added">382                         _cur_concatenate_dirty_card_logs_time_ms +</span>
383                         _recorded_young_cset_choice_time_ms +
384                         _recorded_non_young_cset_choice_time_ms +
385                         _cur_region_register_time +
386                         _recorded_prepare_heap_roots_time_ms +
387                         _recorded_clear_claimed_marks_time_ms;
388 
389   info_time(&quot;Pre Evacuate Collection Set&quot;, sum_ms);
390 
391   if (_root_region_scan_wait_time_ms &gt; 0.0) {
392     debug_time(&quot;Root Region Scan Waiting&quot;, _root_region_scan_wait_time_ms);
393   }
394   debug_time(&quot;Prepare TLABs&quot;, _cur_prepare_tlab_time_ms);
<span class="line-added">395   debug_time(&quot;Concatenate Dirty Card Logs&quot;, _cur_concatenate_dirty_card_logs_time_ms);</span>
396   debug_time(&quot;Choose Collection Set&quot;, (_recorded_young_cset_choice_time_ms + _recorded_non_young_cset_choice_time_ms));
397   debug_time(&quot;Region Register&quot;, _cur_region_register_time);
398   if (G1EagerReclaimHumongousObjects) {
399     trace_count(&quot;Humongous Total&quot;, _cur_fast_reclaim_humongous_total);
400     trace_count(&quot;Humongous Candidate&quot;, _cur_fast_reclaim_humongous_candidates);
401   }
402 
403   debug_time(&quot;Prepare Heap Roots&quot;, _recorded_prepare_heap_roots_time_ms);
404   if (_recorded_clear_claimed_marks_time_ms &gt; 0.0) {
405     debug_time(&quot;Clear Claimed Marks&quot;, _recorded_clear_claimed_marks_time_ms);
406   }
407   return sum_ms;
408 }
409 
410 double G1GCPhaseTimes::print_evacuate_optional_collection_set() const {
411   const double sum_ms = _cur_optional_evac_time_ms + _cur_optional_merge_heap_roots_time_ms;
412   if (sum_ms &gt; 0) {
413     info_time(&quot;Merge Optional Heap Roots&quot;, _cur_optional_merge_heap_roots_time_ms);
414 
415     debug_time(&quot;Prepare Optional Merge Heap Roots&quot;, _cur_optional_prepare_merge_heap_roots_time_ms);
</pre>
</td>
</tr>
</table>
<center><a href="g1DirtyCardQueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1GCPhaseTimes.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1CollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1BarrierSet.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectedHeap.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CollectedHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1052,14 +1052,15 @@</span>
  void G1CollectedHeap::abort_refinement() {
    if (_hot_card_cache-&gt;use_cache()) {
      _hot_card_cache-&gt;reset_hot_cache();
    }
  
<span class="udiff-line-modified-removed">-   // Discard all remembered set updates.</span>
<span class="udiff-line-modified-added">+   // Discard all remembered set updates and reset refinement statistics.</span>
    G1BarrierSet::dirty_card_queue_set().abandon_logs();
    assert(G1BarrierSet::dirty_card_queue_set().num_cards() == 0,
           &quot;DCQS should be empty&quot;);
<span class="udiff-line-added">+   concurrent_refine()-&gt;get_and_reset_refinement_stats();</span>
  }
  
  void G1CollectedHeap::verify_after_full_collection() {
    _hrm-&gt;verify_optional();
    _verifier-&gt;verify_region_sets_optional();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2682,13 +2683,26 @@</span>
    if (full || collector_state()-&gt;in_initial_mark_gc()) {
      increment_old_marking_cycles_started();
    }
  
    // Fill TLAB&#39;s and such
<span class="udiff-line-modified-removed">-   double start = os::elapsedTime();</span>
<span class="udiff-line-modified-removed">-   ensure_parsability(true);</span>
<span class="udiff-line-modified-removed">-   phase_times()-&gt;record_prepare_tlab_time_ms((os::elapsedTime() - start) * 1000.0);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     Ticks start = Ticks::now();</span>
<span class="udiff-line-modified-added">+     ensure_parsability(true);</span>
<span class="udiff-line-added">+     Tickspan dt = Ticks::now() - start;</span>
<span class="udiff-line-added">+     phase_times()-&gt;record_prepare_tlab_time_ms(dt.seconds() * MILLIUNITS);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!full) {</span>
<span class="udiff-line-added">+     // Flush dirty card queues to qset, so later phases don&#39;t need to account</span>
<span class="udiff-line-added">+     // for partially filled per-thread queues and such.  Not needed for full</span>
<span class="udiff-line-added">+     // collections, which ignore those logs.</span>
<span class="udiff-line-added">+     Ticks start = Ticks::now();</span>
<span class="udiff-line-added">+     G1BarrierSet::dirty_card_queue_set().concatenate_logs();</span>
<span class="udiff-line-added">+     Tickspan dt = Ticks::now() - start;</span>
<span class="udiff-line-added">+     phase_times()-&gt;record_concatenate_dirty_card_logs_time_ms(dt.seconds() * MILLIUNITS);</span>
<span class="udiff-line-added">+   }</span>
  }
  
  void G1CollectedHeap::gc_epilogue(bool full) {
    // Update common counters.
    if (full) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2757,24 +2771,10 @@</span>
      _cm_thread-&gt;set_started();
      CGC_lock-&gt;notify();
    }
  }
  
<span class="udiff-line-removed">- size_t G1CollectedHeap::pending_card_num() {</span>
<span class="udiff-line-removed">-   struct CountCardsClosure : public ThreadClosure {</span>
<span class="udiff-line-removed">-     size_t _cards;</span>
<span class="udiff-line-removed">-     CountCardsClosure() : _cards(0) {}</span>
<span class="udiff-line-removed">-     virtual void do_thread(Thread* t) {</span>
<span class="udiff-line-removed">-       _cards += G1ThreadLocalData::dirty_card_queue(t).size();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } count_from_threads;</span>
<span class="udiff-line-removed">-   Threads::threads_do(&amp;count_from_threads);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="udiff-line-removed">-   return dcqs.num_cards() + count_from_threads._cards;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool G1CollectedHeap::is_potential_eager_reclaim_candidate(HeapRegion* r) const {
    // We don&#39;t nominate objects with many remembered set entries, on
    // the assumption that such objects are likely still live.
    HeapRegionRemSet* rem_set = r-&gt;rem_set();
  
</pre>
<center><a href="g1BarrierSet.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectedHeap.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
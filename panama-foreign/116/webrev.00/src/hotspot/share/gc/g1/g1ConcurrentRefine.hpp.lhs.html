<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 26 #define SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 27 
<a name="2" id="anc2"></a>
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 #include &quot;utilities/ticks.hpp&quot;
 31 
 32 // Forward decl
 33 class G1ConcurrentRefine;
 34 class G1ConcurrentRefineThread;
 35 class outputStream;
 36 class ThreadClosure;
 37 
 38 // Helper class for refinement thread management. Used to start, stop and
 39 // iterate over them.
 40 class G1ConcurrentRefineThreadControl {
 41   G1ConcurrentRefine* _cr;
 42 
 43   G1ConcurrentRefineThread** _threads;
 44   uint _num_max_threads;
 45 
 46   // Create the refinement thread for the given worker id.
 47   // If initializing is true, ignore InjectGCWorkerCreationFailure.
 48   G1ConcurrentRefineThread* create_refinement_thread(uint worker_id, bool initializing);
 49 public:
 50   G1ConcurrentRefineThreadControl();
 51   ~G1ConcurrentRefineThreadControl();
 52 
 53   jint initialize(G1ConcurrentRefine* cr, uint num_max_threads);
 54 
 55   // If there is a &quot;successor&quot; thread that can be activated given the current id,
 56   // activate it.
 57   void maybe_activate_next(uint cur_worker_id);
 58 
 59   void print_on(outputStream* st) const;
 60   void worker_threads_do(ThreadClosure* tc);
 61   void stop();
 62 };
 63 
 64 // Controls refinement threads and their activation based on the number of
 65 // cards currently available in the global dirty card queue.
 66 // Refinement threads obtain work from the queue (a buffer at a time) based
 67 // on these thresholds. They are activated gradually based on the amount of
 68 // work to do.
 69 // Refinement thread n activates thread n+1 if the instance of this class determines there
 70 // is enough work available. Threads deactivate themselves if the current amount of
 71 // available cards falls below their individual threshold.
 72 class G1ConcurrentRefine : public CHeapObj&lt;mtGC&gt; {
 73   G1ConcurrentRefineThreadControl _thread_control;
 74   /*
 75    * The value of the completed dirty card queue length falls into one of 3 zones:
 76    * green, yellow, red. If the value is in [0, green) nothing is
 77    * done, the buffered cards are left unprocessed to enable the caching effect of the
 78    * dirtied cards. In the yellow zone [green, yellow) the concurrent refinement
 79    * threads are gradually activated. In [yellow, red) all threads are
 80    * running. If the length becomes red (max queue length) the mutators start
 81    * processing cards too.
 82    *
 83    * There are some interesting cases (when G1UseAdaptiveConcRefinement
 84    * is turned off):
 85    * 1) green = yellow = red = 0. In this case the mutator will process all
 86    *    cards. Except for those that are created by the deferred updates
 87    *    machinery during a collection.
 88    * 2) green = 0. Means no caching. Can be a good way to minimize the
 89    *    amount of time spent updating remembered sets during a collection.
 90    */
 91   size_t _green_zone;
 92   size_t _yellow_zone;
 93   size_t _red_zone;
 94   size_t _min_yellow_zone_size;
 95 
 96   G1ConcurrentRefine(size_t green_zone,
 97                      size_t yellow_zone,
 98                      size_t red_zone,
 99                      size_t min_yellow_zone_size);
100 
101   // Update green/yellow/red zone values based on how well goals are being met.
102   void update_zones(double logged_cards_scan_time,
103                     size_t processed_logged_cards,
104                     double goal_ms);
105 
106   static uint worker_id_offset();
107   void maybe_activate_more_threads(uint worker_id, size_t num_cur_cards);
108 
109   jint initialize();
110 public:
111   ~G1ConcurrentRefine();
112 
113   // Returns a G1ConcurrentRefine instance if succeeded to create/initialize the
114   // G1ConcurrentRefine instance. Otherwise, returns NULL with error code.
115   static G1ConcurrentRefine* create(jint* ecode);
116 
117   void stop();
118 
119   // Adjust refinement thresholds based on work done during the pause and the goal time.
120   void adjust(double logged_cards_scan_time, size_t processed_logged_cards, double goal_ms);
121 
<a name="3" id="anc3"></a><span class="line-modified">122   struct RefinementStats {</span>
<span class="line-modified">123     Tickspan _time;</span>
<span class="line-modified">124     size_t _cards;</span>
<span class="line-removed">125     RefinementStats(Tickspan time, size_t cards) : _time(time), _cards(cards) {}</span>
<span class="line-removed">126   };</span>
<span class="line-removed">127 </span>
<span class="line-removed">128   RefinementStats total_refinement_stats() const;</span>
129 
130   // Cards in the dirty card queue set.
131   size_t activation_threshold(uint worker_id) const;
132   size_t deactivation_threshold(uint worker_id) const;
133 
134   // Perform a single refinement step; called by the refinement
135   // threads.  Returns true if there was refinement work available.
<a name="4" id="anc4"></a><span class="line-modified">136   // Increments *total_refined_cards.</span>
<span class="line-modified">137   bool do_refinement_step(uint worker_id, size_t* total_refined_cards);</span>
138 
139   // Iterate over all concurrent refinement threads applying the given closure.
140   void threads_do(ThreadClosure *tc);
141 
142   // Maximum number of refinement threads.
143   static uint max_num_threads();
144 
145   void print_threads_on(outputStream* st) const;
146 
147   // Cards in the dirty card queue set.
148   size_t green_zone() const      { return _green_zone;  }
149   size_t yellow_zone() const     { return _yellow_zone; }
150   size_t red_zone() const        { return _red_zone;    }
151 };
152 
153 #endif // SHARE_GC_G1_G1CONCURRENTREFINE_HPP
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
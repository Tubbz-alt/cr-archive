<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1DirtyCardQueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1DirtyCardQueue.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1GCPhaseTimes.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1DirtyCardQueue.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -25,10 +25,11 @@</span>
  #ifndef SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
  #define SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
  
  #include &quot;gc/g1/g1BufferNodeList.hpp&quot;
  #include &quot;gc/g1/g1FreeIdSet.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/g1/g1ConcurrentRefineStats.hpp&quot;</span>
  #include &quot;gc/shared/ptrQueue.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/padded.hpp&quot;
  
  class G1ConcurrentRefineThread;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -36,10 +37,12 @@</span>
  class G1RedirtyCardsQueueSet;
  class Thread;
  
  // A ptrQueue whose elements are &quot;oops&quot;, pointers to object heads.
  class G1DirtyCardQueue: public PtrQueue {
<span class="udiff-line-added">+   G1ConcurrentRefineStats* _refinement_stats;</span>
<span class="udiff-line-added">+ </span>
  protected:
    virtual void handle_completed_buffer();
  
  public:
    G1DirtyCardQueue(G1DirtyCardQueueSet* qset);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -47,14 +50,22 @@</span>
    // Flush before destroying; queue may be used to capture pending work while
    // doing something else, with auto-flush on completion.
    ~G1DirtyCardQueue();
  
    // Process queue entries and release resources.
<span class="udiff-line-modified-removed">-   void flush() { flush_impl(); }</span>
<span class="udiff-line-modified-added">+   void flush();</span>
  
    inline G1DirtyCardQueueSet* dirty_card_qset() const;
  
<span class="udiff-line-added">+   G1ConcurrentRefineStats* refinement_stats() const {</span>
<span class="udiff-line-added">+     return _refinement_stats;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // To be called by the barrier set&#39;s on_thread_detach, to notify this</span>
<span class="udiff-line-added">+   // object of the corresponding state change of its owning thread.</span>
<span class="udiff-line-added">+   void on_thread_detach();</span>
<span class="udiff-line-added">+ </span>
    // Compiler support.
    static ByteSize byte_offset_of_index() {
      return PtrQueue::byte_offset_of_index&lt;G1DirtyCardQueue&gt;();
    }
    using PtrQueue::byte_width_of_index;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -213,13 +224,11 @@</span>
    // mutator must start doing some of the concurrent refinement work.
    size_t _max_cards;
    volatile size_t _padded_max_cards;
    static const size_t MaxCardsUnlimited = SIZE_MAX;
  
<span class="udiff-line-modified-removed">-   // Array of cumulative dirty cards refined by mutator threads.</span>
<span class="udiff-line-removed">-   // Array has an entry per id in _free_ids.</span>
<span class="udiff-line-removed">-   size_t* _mutator_refined_cards_counters;</span>
<span class="udiff-line-modified-added">+   G1ConcurrentRefineStats _detached_refinement_stats;</span>
  
    // Verify _num_cards == sum of cards in the completed queue.
    void verify_num_cards() const NOT_DEBUG_RETURN;
  
    // Thread-safe add a buffer to paused list for next safepoint.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -239,13 +248,14 @@</span>
    // Stops processing if SuspendibleThreadSet::should_yield() is true.
    // Returns true if the entire buffer was processed, false if there
    // is a pending yield request.  The node&#39;s index is updated to exclude
    // the processed elements, e.g. up to the element before processing
    // stopped, or one past the last element if the entire buffer was
<span class="udiff-line-modified-removed">-   // processed. Increments *total_refined_cards by the number of cards</span>
<span class="udiff-line-modified-removed">-   // processed and removed from the buffer.</span>
<span class="udiff-line-modified-removed">-   bool refine_buffer(BufferNode* node, uint worker_id, size_t* total_refined_cards);</span>
<span class="udiff-line-modified-added">+   // processed. Updates stats.</span>
<span class="udiff-line-modified-added">+   bool refine_buffer(BufferNode* node,</span>
<span class="udiff-line-modified-added">+                      uint worker_id,</span>
<span class="udiff-line-added">+                      G1ConcurrentRefineStats* stats);</span>
  
    // Deal with buffer after a call to refine_buffer.  If fully processed,
    // deallocate the buffer.  Otherwise, record it as paused.
    void handle_refined_buffer(BufferNode* node, bool fully_processed);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -294,38 +304,43 @@</span>
  
    // Helper for G1DirtyCardQueue::handle_completed_buffer().
    // Enqueue the buffer, and optionally perform refinement by the mutator.
    // Mutator refinement is only done by Java threads, and only if there
    // are more than max_cards (possibly padded) cards in the completed
<span class="udiff-line-modified-removed">-   // buffers.</span>
<span class="udiff-line-modified-added">+   // buffers.  Updates stats.</span>
    //
    // Mutator refinement, if performed, stops processing a buffer if
    // SuspendibleThreadSet::should_yield(), recording the incompletely
    // processed buffer for later processing of the remainder.
<span class="udiff-line-modified-removed">-   void handle_completed_buffer(BufferNode* node);</span>
<span class="udiff-line-modified-added">+   void handle_completed_buffer(BufferNode* node, G1ConcurrentRefineStats* stats);</span>
  
    // If there are more than stop_at cards in the completed buffers, pop
    // a buffer, refine its contents, and return true.  Otherwise return
<span class="udiff-line-modified-removed">-   // false.</span>
<span class="udiff-line-modified-added">+   // false.  Updates stats.</span>
    //
    // Stops processing a buffer if SuspendibleThreadSet::should_yield(),
    // recording the incompletely processed buffer for later processing of
    // the remainder.
<span class="udiff-line-removed">-   //</span>
<span class="udiff-line-removed">-   // Increments *total_refined_cards by the number of cards processed and</span>
<span class="udiff-line-removed">-   // removed from the buffer.</span>
    bool refine_completed_buffer_concurrently(uint worker_id,
                                              size_t stop_at,
<span class="udiff-line-modified-removed">-                                             size_t* total_refined_cards);</span>
<span class="udiff-line-modified-added">+                                             G1ConcurrentRefineStats* stats);</span>
  
    // If a full collection is happening, reset partial logs, and release
    // completed ones: the full collection will make them all irrelevant.
    void abandon_logs();
  
    // If any threads have partial logs, add them to the global list of logs.
    void concatenate_logs();
  
<span class="udiff-line-added">+   // Return the total of mutator refinement stats for all threads.</span>
<span class="udiff-line-added">+   // Also resets the stats for the threads.</span>
<span class="udiff-line-added">+   // precondition: at safepoint.</span>
<span class="udiff-line-added">+   G1ConcurrentRefineStats get_and_reset_refinement_stats();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Accumulate refinement stats from threads that are detaching.</span>
<span class="udiff-line-added">+   void record_detached_refinement_stats(G1ConcurrentRefineStats* stats);</span>
<span class="udiff-line-added">+ </span>
    // Threshold for mutator threads to also do refinement when there
    // are concurrent refinement threads.
    size_t max_cards() const;
  
    // Set threshold for mutator threads to also do refinement.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -334,13 +349,10 @@</span>
    // Artificially increase mutator refinement threshold.
    void set_max_cards_padding(size_t padding);
  
    // Discard artificial increase of mutator refinement threshold.
    void discard_max_cards_padding();
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Total dirty cards refined by mutator threads.</span>
<span class="udiff-line-removed">-   size_t total_mutator_refined_cards() const;</span>
  };
  
  inline G1DirtyCardQueueSet* G1DirtyCardQueue::dirty_card_qset() const {
    return static_cast&lt;G1DirtyCardQueueSet*&gt;(qset());
  }
</pre>
<center><a href="g1DirtyCardQueue.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1GCPhaseTimes.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
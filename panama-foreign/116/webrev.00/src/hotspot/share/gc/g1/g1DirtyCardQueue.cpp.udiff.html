<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1DirtyCardQueue.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentRefineThread.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1DirtyCardQueue.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1DirtyCardQueue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -24,43 +24,61 @@</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1BufferNodeList.hpp&quot;
  #include &quot;gc/g1/g1CardTableEntryClosure.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/g1/g1ConcurrentRefineStats.hpp&quot;</span>
  #include &quot;gc/g1/g1ConcurrentRefineThread.hpp&quot;
  #include &quot;gc/g1/g1DirtyCardQueue.hpp&quot;
  #include &quot;gc/g1/g1FreeIdSet.hpp&quot;
  #include &quot;gc/g1/g1RedirtyCardsQueue.hpp&quot;
  #include &quot;gc/g1/g1RemSet.hpp&quot;
  #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/mutex.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;runtime/mutexLocker.hpp&quot;</span>
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/threadSMR.hpp&quot;
  #include &quot;utilities/globalCounter.inline.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/quickSort.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/ticks.hpp&quot;</span>
  
  G1DirtyCardQueue::G1DirtyCardQueue(G1DirtyCardQueueSet* qset) :
    // Dirty card queues are always active, so we create them with their
    // active field set to true.
<span class="udiff-line-modified-removed">-   PtrQueue(qset, true /* active */)</span>
<span class="udiff-line-modified-added">+   PtrQueue(qset, true /* active */),</span>
<span class="udiff-line-added">+   _refinement_stats(new G1ConcurrentRefineStats())</span>
  { }
  
  G1DirtyCardQueue::~G1DirtyCardQueue() {
    flush();
<span class="udiff-line-added">+   delete _refinement_stats;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1DirtyCardQueue::flush() {</span>
<span class="udiff-line-added">+   _refinement_stats-&gt;inc_dirtied_cards(size());</span>
<span class="udiff-line-added">+   flush_impl();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1DirtyCardQueue::on_thread_detach() {</span>
<span class="udiff-line-added">+   assert(this == &amp;G1ThreadLocalData::dirty_card_queue(Thread::current()), &quot;precondition&quot;);</span>
<span class="udiff-line-added">+   flush();</span>
<span class="udiff-line-added">+   dirty_card_qset()-&gt;record_detached_refinement_stats(_refinement_stats);</span>
  }
  
  void G1DirtyCardQueue::handle_completed_buffer() {
    assert(!is_empty(), &quot;precondition&quot;);
<span class="udiff-line-added">+   _refinement_stats-&gt;inc_dirtied_cards(size());</span>
    BufferNode* node = BufferNode::make_node_from_buffer(_buf, index());
    allocate_buffer();
<span class="udiff-line-modified-removed">-   dirty_card_qset()-&gt;handle_completed_buffer(node);</span>
<span class="udiff-line-modified-added">+   dirty_card_qset()-&gt;handle_completed_buffer(node, _refinement_stats);</span>
  }
  
  // Assumed to be zero by concurrent threads.
  static uint par_ids_start() { return 0; }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -72,34 +90,24 @@</span>
    _paused(),
    _free_ids(par_ids_start(), num_par_ids()),
    _process_cards_threshold(ProcessCardsThresholdNever),
    _max_cards(MaxCardsUnlimited),
    _padded_max_cards(MaxCardsUnlimited),
<span class="udiff-line-modified-removed">-   _mutator_refined_cards_counters(NEW_C_HEAP_ARRAY(size_t, num_par_ids(), mtGC))</span>
<span class="udiff-line-modified-added">+   _detached_refinement_stats()</span>
  {
<span class="udiff-line-removed">-   ::memset(_mutator_refined_cards_counters, 0, num_par_ids() * sizeof(size_t));</span>
    _all_active = true;
  }
  
  G1DirtyCardQueueSet::~G1DirtyCardQueueSet() {
    abandon_completed_buffers();
<span class="udiff-line-removed">-   FREE_C_HEAP_ARRAY(size_t, _mutator_refined_cards_counters);</span>
  }
  
  // Determines how many mutator threads can process the buffers in parallel.
  uint G1DirtyCardQueueSet::num_par_ids() {
    return (uint)os::initial_active_processor_count();
  }
  
<span class="udiff-line-removed">- size_t G1DirtyCardQueueSet::total_mutator_refined_cards() const {</span>
<span class="udiff-line-removed">-   size_t sum = 0;</span>
<span class="udiff-line-removed">-   for (uint i = 0; i &lt; num_par_ids(); ++i) {</span>
<span class="udiff-line-removed">-     sum += _mutator_refined_cards_counters[i];</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return sum;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void G1DirtyCardQueueSet::handle_zero_index_for_thread(Thread* t) {
    G1ThreadLocalData::dirty_card_queue(t).handle_zero_index();
  }
  
  #ifdef ASSERT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -420,11 +428,11 @@</span>
  class G1RefineBufferedCards : public StackObj {
    BufferNode* const _node;
    CardTable::CardValue** const _node_buffer;
    const size_t _node_buffer_size;
    const uint _worker_id;
<span class="udiff-line-modified-removed">-   size_t* _total_refined_cards;</span>
<span class="udiff-line-modified-added">+   G1ConcurrentRefineStats* _stats;</span>
    G1RemSet* const _g1rs;
  
    static inline int compare_card(const CardTable::CardValue* p1,
                                   const CardTable::CardValue* p2) {
      return p2 - p1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -470,11 +478,12 @@</span>
      // dst points to the first retained clean card, or the end of the buffer
      // if all the cards were discarded.
      const size_t first_clean = dst - _node_buffer;
      assert(first_clean &gt;= start &amp;&amp; first_clean &lt;= _node_buffer_size, &quot;invariant&quot;);
      // Discarded cards are considered as refined.
<span class="udiff-line-modified-removed">-     *_total_refined_cards += first_clean - start;</span>
<span class="udiff-line-modified-added">+     _stats-&gt;inc_refined_cards(first_clean - start);</span>
<span class="udiff-line-added">+     _stats-&gt;inc_precleaned_cards(first_clean - start);</span>
      return first_clean;
    }
  
    bool refine_cleaned_cards(size_t start_index) {
      bool result = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -486,11 +495,11 @@</span>
          break;
        }
        _g1rs-&gt;refine_card_concurrently(_node_buffer[i], _worker_id);
      }
      _node-&gt;set_index(i);
<span class="udiff-line-modified-removed">-     *_total_refined_cards += i - start_index;</span>
<span class="udiff-line-modified-added">+     _stats-&gt;inc_refined_cards(i - start_index);</span>
      return result;
    }
  
    void redirty_unrefined_cards(size_t start) {
      for ( ; start &lt; _node_buffer_size; ++start) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -500,16 +509,16 @@</span>
  
  public:
    G1RefineBufferedCards(BufferNode* node,
                          size_t node_buffer_size,
                          uint worker_id,
<span class="udiff-line-modified-removed">-                         size_t* total_refined_cards) :</span>
<span class="udiff-line-modified-added">+                         G1ConcurrentRefineStats* stats) :</span>
      _node(node),
      _node_buffer(reinterpret_cast&lt;CardTable::CardValue**&gt;(BufferNode::make_buffer_from_node(node))),
      _node_buffer_size(node_buffer_size),
      _worker_id(worker_id),
<span class="udiff-line-modified-removed">-     _total_refined_cards(total_refined_cards),</span>
<span class="udiff-line-modified-added">+     _stats(stats),</span>
      _g1rs(G1CollectedHeap::heap()-&gt;rem_set()) {}
  
    bool refine() {
      size_t first_clean_index = clean_cards();
      if (first_clean_index == _node_buffer_size) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -530,16 +539,19 @@</span>
    }
  };
  
  bool G1DirtyCardQueueSet::refine_buffer(BufferNode* node,
                                          uint worker_id,
<span class="udiff-line-modified-removed">-                                         size_t* total_refined_cards) {</span>
<span class="udiff-line-modified-added">+                                         G1ConcurrentRefineStats* stats) {</span>
<span class="udiff-line-added">+   Ticks start_time = Ticks::now();</span>
    G1RefineBufferedCards buffered_cards(node,
                                         buffer_size(),
                                         worker_id,
<span class="udiff-line-modified-removed">-                                        total_refined_cards);</span>
<span class="udiff-line-modified-removed">-   return buffered_cards.refine();</span>
<span class="udiff-line-modified-added">+                                        stats);</span>
<span class="udiff-line-modified-added">+   bool result = buffered_cards.refine();</span>
<span class="udiff-line-added">+   stats-&gt;inc_refinement_time(Ticks::now() - start_time);</span>
<span class="udiff-line-added">+   return result;</span>
  }
  
  void G1DirtyCardQueueSet::handle_refined_buffer(BufferNode* node,
                                                  bool fully_processed) {
    if (fully_processed) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -553,11 +565,12 @@</span>
      // Record partially processed buffer, to be finished later.
      record_paused_buffer(node);
    }
  }
  
<span class="udiff-line-modified-removed">- void G1DirtyCardQueueSet::handle_completed_buffer(BufferNode* new_node) {</span>
<span class="udiff-line-modified-added">+ void G1DirtyCardQueueSet::handle_completed_buffer(BufferNode* new_node,</span>
<span class="udiff-line-added">+                                                   G1ConcurrentRefineStats* stats) {</span>
    enqueue_completed_buffer(new_node);
  
    // No need for mutator refinement if number of cards is below limit.
    if (Atomic::load(&amp;_num_cards) &lt;= Atomic::load(&amp;_padded_max_cards)) {
      return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -572,42 +585,43 @@</span>
    if (node == NULL) return;     // Didn&#39;t get a buffer to process.
  
    // Refine cards in buffer.
  
    uint worker_id = _free_ids.claim_par_id(); // temporarily claim an id
<span class="udiff-line-modified-removed">-   uint counter_index = worker_id - par_ids_start();</span>
<span class="udiff-line-removed">-   size_t* counter = &amp;_mutator_refined_cards_counters[counter_index];</span>
<span class="udiff-line-removed">-   bool fully_processed = refine_buffer(node, worker_id, counter);</span>
<span class="udiff-line-modified-added">+   bool fully_processed = refine_buffer(node, worker_id, stats);</span>
    _free_ids.release_par_id(worker_id); // release the id
  
    // Deal with buffer after releasing id, to let another thread use id.
    handle_refined_buffer(node, fully_processed);
  }
  
  bool G1DirtyCardQueueSet::refine_completed_buffer_concurrently(uint worker_id,
                                                                 size_t stop_at,
<span class="udiff-line-modified-removed">-                                                                size_t* total_refined_cards) {</span>
<span class="udiff-line-modified-added">+                                                                G1ConcurrentRefineStats* stats) {</span>
    // Not enough cards to trigger processing.
    if (Atomic::load(&amp;_num_cards) &lt;= stop_at) return false;
  
    BufferNode* node = get_completed_buffer();
    if (node == NULL) return false; // Didn&#39;t get a buffer to process.
  
<span class="udiff-line-modified-removed">-   bool fully_processed = refine_buffer(node, worker_id, total_refined_cards);</span>
<span class="udiff-line-modified-added">+   bool fully_processed = refine_buffer(node, worker_id, stats);</span>
    handle_refined_buffer(node, fully_processed);
    return true;
  }
  
  void G1DirtyCardQueueSet::abandon_logs() {
    assert_at_safepoint();
    abandon_completed_buffers();
<span class="udiff-line-added">+   _detached_refinement_stats.reset();</span>
  
    // Since abandon is done only at safepoints, we can safely manipulate
    // these queues.
    struct AbandonThreadLogClosure : public ThreadClosure {
      virtual void do_thread(Thread* t) {
<span class="udiff-line-modified-removed">-       G1ThreadLocalData::dirty_card_queue(t).reset();</span>
<span class="udiff-line-modified-added">+       G1DirtyCardQueue&amp; dcq = G1ThreadLocalData::dirty_card_queue(t);</span>
<span class="udiff-line-added">+       dcq.reset();</span>
<span class="udiff-line-added">+       dcq.refinement_stats()-&gt;reset();</span>
      }
    } closure;
    Threads::threads_do(&amp;closure);
  
    G1BarrierSet::shared_dirty_card_queue().reset();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -635,10 +649,44 @@</span>
    enqueue_all_paused_buffers();
    verify_num_cards();
    set_max_cards(old_limit);
  }
  
<span class="udiff-line-added">+ G1ConcurrentRefineStats G1DirtyCardQueueSet::get_and_reset_refinement_stats() {</span>
<span class="udiff-line-added">+   assert_at_safepoint();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Since we&#39;re at a safepoint, there aren&#39;t any races with recording of</span>
<span class="udiff-line-added">+   // detached refinement stats.  In particular, there&#39;s no risk of double</span>
<span class="udiff-line-added">+   // counting a thread that detaches after we&#39;ve examined it but before</span>
<span class="udiff-line-added">+   // we&#39;ve processed the detached stats.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Collect and reset stats for attached threads.</span>
<span class="udiff-line-added">+   struct CollectStats : public ThreadClosure {</span>
<span class="udiff-line-added">+     G1ConcurrentRefineStats _total_stats;</span>
<span class="udiff-line-added">+     virtual void do_thread(Thread* t) {</span>
<span class="udiff-line-added">+       G1DirtyCardQueue&amp; dcq = G1ThreadLocalData::dirty_card_queue(t);</span>
<span class="udiff-line-added">+       G1ConcurrentRefineStats&amp; stats = *dcq.refinement_stats();</span>
<span class="udiff-line-added">+       _total_stats += stats;</span>
<span class="udiff-line-added">+       stats.reset();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } closure;</span>
<span class="udiff-line-added">+   Threads::threads_do(&amp;closure);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Collect and reset stats from detached threads.</span>
<span class="udiff-line-added">+   MutexLocker ml(G1DetachedRefinementStats_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-added">+   closure._total_stats += _detached_refinement_stats;</span>
<span class="udiff-line-added">+   _detached_refinement_stats.reset();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return closure._total_stats;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1DirtyCardQueueSet::record_detached_refinement_stats(G1ConcurrentRefineStats* stats) {</span>
<span class="udiff-line-added">+   MutexLocker ml(G1DetachedRefinementStats_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-added">+   _detached_refinement_stats += *stats;</span>
<span class="udiff-line-added">+   stats-&gt;reset();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  size_t G1DirtyCardQueueSet::max_cards() const {
    return _max_cards;
  }
  
  void G1DirtyCardQueueSet::set_max_cards(size_t value) {
</pre>
<center><a href="g1ConcurrentRefineThread.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1DirtyCardQueue.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
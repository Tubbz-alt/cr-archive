<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1Policy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1GCPhaseTimes.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Policy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -29,10 +29,11 @@</span>
  #include &quot;gc/g1/g1CollectionSet.hpp&quot;
  #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/g1/g1ConcurrentRefineStats.hpp&quot;</span>
  #include &quot;gc/g1/g1CollectionSetChooser.hpp&quot;
  #include &quot;gc/g1/g1HeterogeneousHeapPolicy.hpp&quot;
  #include &quot;gc/g1/g1HotCardCache.hpp&quot;
  #include &quot;gc/g1/g1IHOPControl.hpp&quot;
  #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -41,11 +42,11 @@</span>
  #include &quot;gc/g1/g1YoungGenSizer.hpp&quot;
  #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;
  #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;logging/logStream.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;logging/log.hpp&quot;</span>
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -70,14 +71,10 @@</span>
    _young_gen_sizer(G1YoungGenSizer::create_gen_sizer()),
    _free_regions_at_end_of_collection(0),
    _rs_length(0),
    _rs_length_prediction(0),
    _pending_cards_at_gc_start(0),
<span class="udiff-line-removed">-   _pending_cards_at_prev_gc_end(0),</span>
<span class="udiff-line-removed">-   _total_mutator_refined_cards(0),</span>
<span class="udiff-line-removed">-   _total_concurrent_refined_cards(0),</span>
<span class="udiff-line-removed">-   _total_concurrent_refinement_time(),</span>
    _bytes_allocated_in_old_since_last_gc(0),
    _initial_mark_to_mixed(),
    _collection_set(NULL),
    _g1h(NULL),
    _phase_times(new G1GCPhaseTimes(gc_timer, ParallelGCThreads)),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -430,11 +427,11 @@</span>
    _full_collection_start_sec = os::elapsedTime();
    // Release the future to-space so that it is available for compaction into.
    collector_state()-&gt;set_in_young_only_phase(false);
    collector_state()-&gt;set_in_full_gc(true);
    _collection_set-&gt;clear_candidates();
<span class="udiff-line-modified-removed">-   record_concurrent_refinement_data(true /* is_full_collection */);</span>
<span class="udiff-line-modified-added">+   _pending_cards_at_gc_start = 0;</span>
  }
  
  void G1Policy::record_full_collection_end() {
    // Consider this like a collection pause for the purposes of allocation
    // since last pause.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -460,68 +457,66 @@</span>
  
    _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
    _survivor_surv_rate_group-&gt;reset();
    update_young_list_max_and_target_length();
    update_rs_length_prediction();
<span class="udiff-line-removed">-   _pending_cards_at_prev_gc_end = _g1h-&gt;pending_card_num();</span>
  
    _bytes_allocated_in_old_since_last_gc = 0;
  
    record_pause(FullGC, _full_collection_start_sec, end_sec);
  }
  
<span class="udiff-line-modified-removed">- void G1Policy::record_concurrent_refinement_data(bool is_full_collection) {</span>
<span class="udiff-line-modified-removed">-   _pending_cards_at_gc_start = _g1h-&gt;pending_card_num();</span>
<span class="udiff-line-modified-added">+ static void log_refinement_stats(const char* kind, const G1ConcurrentRefineStats&amp; stats) {</span>
<span class="udiff-line-modified-added">+   log_debug(gc, refine, stats)</span>
<span class="udiff-line-added">+            (&quot;%s refinement: %.2fms, refined: &quot; SIZE_FORMAT</span>
<span class="udiff-line-added">+             &quot;, precleaned: &quot; SIZE_FORMAT &quot;, dirtied: &quot; SIZE_FORMAT,</span>
<span class="udiff-line-added">+             kind,</span>
<span class="udiff-line-added">+             stats.refinement_time().seconds() * MILLIUNITS,</span>
<span class="udiff-line-added">+             stats.refined_cards(),</span>
<span class="udiff-line-added">+             stats.precleaned_cards(),</span>
<span class="udiff-line-added">+             stats.dirtied_cards());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1Policy::record_concurrent_refinement_stats() {</span>
<span class="udiff-line-added">+   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="udiff-line-added">+   _pending_cards_at_gc_start = dcqs.num_cards();</span>
  
<span class="udiff-line-modified-removed">-   // Record info about concurrent refinement thread processing.</span>
<span class="udiff-line-modified-added">+   // Collect per-thread stats, mostly from mutator activity.</span>
<span class="udiff-line-added">+   G1ConcurrentRefineStats mut_stats = dcqs.get_and_reset_refinement_stats();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Collect specialized concurrent refinement thread stats.</span>
    G1ConcurrentRefine* cr = _g1h-&gt;concurrent_refine();
<span class="udiff-line-modified-removed">-   G1ConcurrentRefine::RefinementStats cr_stats = cr-&gt;total_refinement_stats();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   Tickspan cr_time = cr_stats._time - _total_concurrent_refinement_time;</span>
<span class="udiff-line-modified-removed">-   _total_concurrent_refinement_time = cr_stats._time;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   size_t cr_cards = cr_stats._cards - _total_concurrent_refined_cards;</span>
<span class="udiff-line-modified-removed">-   _total_concurrent_refined_cards = cr_stats._cards;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   // Don&#39;t update rate if full collection.  We could be in an implicit full</span>
<span class="udiff-line-modified-removed">-   // collection after a non-full collection failure, in which case there</span>
<span class="udiff-line-modified-removed">-   // wasn&#39;t any mutator/cr-thread activity since last recording.  And if</span>
<span class="udiff-line-modified-removed">-   // we&#39;re in an explicit full collection, the time since the last GC can</span>
<span class="udiff-line-modified-removed">-   // be arbitrarily short, so not a very good sample.  Similarly, don&#39;t</span>
<span class="udiff-line-modified-removed">-   // update the rate if the current sample is empty or time is zero.</span>
<span class="udiff-line-removed">-   if (!is_full_collection &amp;&amp; (cr_cards &gt; 0) &amp;&amp; (cr_time &gt; Tickspan())) {</span>
<span class="udiff-line-removed">-     double rate = cr_cards / (cr_time.seconds() * MILLIUNITS);</span>
<span class="udiff-line-modified-added">+   G1ConcurrentRefineStats cr_stats = cr-&gt;get_and_reset_refinement_stats();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   G1ConcurrentRefineStats total_stats = mut_stats + cr_stats;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   log_refinement_stats(&quot;Mutator&quot;, mut_stats);</span>
<span class="udiff-line-modified-added">+   log_refinement_stats(&quot;Concurrent&quot;, cr_stats);</span>
<span class="udiff-line-modified-added">+   log_refinement_stats(&quot;Total&quot;, total_stats);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Record the rate at which cards were refined.</span>
<span class="udiff-line-modified-added">+   // Don&#39;t update the rate if the current sample is empty or time is zero.</span>
<span class="udiff-line-modified-added">+   Tickspan refinement_time = total_stats.refinement_time();</span>
<span class="udiff-line-modified-added">+   size_t refined_cards = total_stats.refined_cards();</span>
<span class="udiff-line-modified-added">+   if ((refined_cards &gt; 0) &amp;&amp; (refinement_time &gt; Tickspan())) {</span>
<span class="udiff-line-modified-added">+     double rate = refined_cards / (refinement_time.seconds() * MILLIUNITS);</span>
      _analytics-&gt;report_concurrent_refine_rate_ms(rate);
<span class="udiff-line-added">+     log_debug(gc, refine, stats)(&quot;Concurrent refinement rate: %.2f cards/ms&quot;, rate);</span>
    }
  
<span class="udiff-line-removed">-   // Record info about mutator thread processing.</span>
<span class="udiff-line-removed">-   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="udiff-line-removed">-   size_t mut_total_cards = dcqs.total_mutator_refined_cards();</span>
<span class="udiff-line-removed">-   size_t mut_cards = mut_total_cards - _total_mutator_refined_cards;</span>
<span class="udiff-line-removed">-   _total_mutator_refined_cards = mut_total_cards;</span>
<span class="udiff-line-removed">- </span>
    // Record mutator&#39;s card logging rate.
<span class="udiff-line-modified-removed">-   // Don&#39;t update if full collection; see above.</span>
<span class="udiff-line-modified-removed">-   if (!is_full_collection) {</span>
<span class="udiff-line-modified-removed">-     size_t total_cards = _pending_cards_at_gc_start + cr_cards + mut_cards;</span>
<span class="udiff-line-modified-removed">-     assert(_pending_cards_at_prev_gc_end &lt;= total_cards,</span>
<span class="udiff-line-modified-removed">-            &quot;untracked cards: last pending: &quot; SIZE_FORMAT</span>
<span class="udiff-line-modified-removed">-            &quot;, pending: &quot; SIZE_FORMAT &quot;, conc refine: &quot; SIZE_FORMAT</span>
<span class="udiff-line-modified-removed">-            &quot;, mut refine:&quot; SIZE_FORMAT,</span>
<span class="udiff-line-modified-removed">-            _pending_cards_at_prev_gc_end, _pending_cards_at_gc_start,</span>
<span class="udiff-line-modified-removed">-            cr_cards, mut_cards);</span>
<span class="udiff-line-modified-removed">-     size_t logged_cards = total_cards - _pending_cards_at_prev_gc_end;</span>
<span class="udiff-line-modified-removed">-     double logging_start_time = _analytics-&gt;prev_collection_pause_end_ms();</span>
<span class="udiff-line-removed">-     double logging_end_time = Ticks::now().seconds() * MILLIUNITS;</span>
<span class="udiff-line-removed">-     double logging_time = logging_end_time - logging_start_time;</span>
<span class="udiff-line-removed">-     // Unlike above for conc-refine rate, here we should not require a</span>
<span class="udiff-line-removed">-     // non-empty sample, since an application could go some time with only</span>
<span class="udiff-line-removed">-     // young-gen or filtered out writes.  But we&#39;ll ignore unusually short</span>
<span class="udiff-line-removed">-     // sample periods, as they may just pollute the predictions.</span>
<span class="udiff-line-removed">-     if (logging_time &gt; 1.0) {   // Require &gt; 1ms sample time.</span>
<span class="udiff-line-removed">-       _analytics-&gt;report_logged_cards_rate_ms(logged_cards / logging_time);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   double mut_start_time = _analytics-&gt;prev_collection_pause_end_ms();</span>
<span class="udiff-line-modified-added">+   double mut_end_time = phase_times()-&gt;cur_collection_start_sec() * MILLIUNITS;</span>
<span class="udiff-line-modified-added">+   double mut_time = mut_end_time - mut_start_time;</span>
<span class="udiff-line-modified-added">+   // Unlike above for conc-refine rate, here we should not require a</span>
<span class="udiff-line-modified-added">+   // non-empty sample, since an application could go some time with only</span>
<span class="udiff-line-modified-added">+   // young-gen or filtered out writes.  But we&#39;ll ignore unusually short</span>
<span class="udiff-line-modified-added">+   // sample periods, as they may just pollute the predictions.</span>
<span class="udiff-line-modified-added">+   if (mut_time &gt; 1.0) {   // Require &gt; 1ms sample time.</span>
<span class="udiff-line-modified-added">+     double dirtied_rate = total_stats.dirtied_cards() / mut_time;</span>
<span class="udiff-line-modified-added">+     _analytics-&gt;report_dirtied_cards_rate_ms(dirtied_rate);</span>
<span class="udiff-line-modified-added">+     log_debug(gc, refine, stats)(&quot;Generate dirty cards rate: %.2f cards/ms&quot;, dirtied_rate);</span>
    }
  }
  
  void G1Policy::record_collection_pause_start(double start_time_sec) {
    // We only need to do this here as the policy will only be applied
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -534,11 +529,11 @@</span>
           max_survivor_regions(), _g1h-&gt;num_used_regions(), _g1h-&gt;max_regions());
    assert_used_and_recalculate_used_equal(_g1h);
  
    phase_times()-&gt;record_cur_collection_start_sec(start_time_sec);
  
<span class="udiff-line-modified-removed">-   record_concurrent_refinement_data(false /* is_full_collection */);</span>
<span class="udiff-line-modified-added">+   record_concurrent_refinement_stats();</span>
  
    _collection_set-&gt;reset_bytes_used_before();
  
    // do that for any other surv rate groups
    _eden_surv_rate_group-&gt;stop_adding_regions();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -828,11 +823,10 @@</span>
      scan_logged_cards_time_goal_ms = 0;
    } else {
      scan_logged_cards_time_goal_ms -= merge_hcc_time_ms;
    }
  
<span class="udiff-line-removed">-   _pending_cards_at_prev_gc_end = _g1h-&gt;pending_card_num();</span>
    double const logged_cards_time = logged_cards_processing_time();
  
    log_debug(gc, ergo, refine)(&quot;Concurrent refinement times: Logged Cards Scan time goal: %1.2fms Logged Cards Scan time: %1.2fms HCC time: %1.2fms&quot;,
                                scan_logged_cards_time_goal_ms, logged_cards_time, merge_hcc_time_ms);
  
</pre>
<center><a href="g1GCPhaseTimes.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
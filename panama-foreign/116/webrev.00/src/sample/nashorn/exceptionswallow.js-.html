<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/sample/nashorn/exceptionswallow.js</title>
    <link rel="stylesheet" href="../../../style.css" />
  </head>
  <body>
    <pre>
  1 #// Usage: jjs exceptionswallow.js -- &lt;directory&gt;
  2 
  3 /*
  4  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  *
 10  *   - Redistributions of source code must retain the above copyright
 11  *     notice, this list of conditions and the following disclaimer.
 12  *
 13  *   - Redistributions in binary form must reproduce the above copyright
 14  *     notice, this list of conditions and the following disclaimer in the
 15  *     documentation and/or other materials provided with the distribution.
 16  *
 17  *   - Neither the name of Oracle nor the names of its
 18  *     contributors may be used to endorse or promote products derived
 19  *     from this software without specific prior written permission.
 20  *
 21  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS
 22  * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 23  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 24  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 25  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 26  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 27  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 28  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 29  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 30  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 31  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 
 34 // This example demonstrates Java subclassing by Java.extend
 35 // and javac Compiler and Tree API. This example looks for
 36 // empty catch blocks (&quot;exception swallow&quot;) and reports those.
 37 
 38 if (arguments.length == 0) {
 39     print(&quot;Usage: jjs exceptionswallow.js -- &lt;directory&gt;&quot;);
 40     exit(1);
 41 }
 42  
 43 // Java types used
 44 var File = Java.type(&quot;java.io.File&quot;);
 45 var Files = Java.type(&quot;java.nio.file.Files&quot;);
 46 var StringArray = Java.type(&quot;java.lang.String[]&quot;);
 47 var ToolProvider = Java.type(&quot;javax.tools.ToolProvider&quot;);
 48 var Tree = Java.type(&quot;com.sun.source.tree.Tree&quot;);
 49 var EmptyStatementTree = Java.type(&quot;com.sun.source.tree.EmptyStatementTree&quot;);
 50 var Trees = Java.type(&quot;com.sun.source.util.Trees&quot;);
 51 var TreeScanner = Java.type(&quot;com.sun.source.util.TreeScanner&quot;);
 52 
 53 // printEmptyCatch
 54 
 55 function printEmptyCatch() {
 56     // get the system compiler tool
 57     var compiler = ToolProvider.systemJavaCompiler;
 58     // get standard file manager
 59     var fileMgr = compiler.getStandardFileManager(null, null, null);
 60     // Using Java.to convert script array (arguments) to a Java String[]
 61     var compUnits = fileMgr.getJavaFileObjects(
 62         Java.to(arguments, StringArray));
 63     // create a new compilation task
 64     var task = compiler.getTask(null, fileMgr, null, null, null, compUnits);
 65 
 66     // SourcePositions object to get positions of AST nodes
 67     var sourcePositions = Trees.instance(task).sourcePositions;
 68 
 69     // subclass SimpleTreeVisitor - to print empty catch
 70     var EmptyCatchFinder = Java.extend(TreeScanner);
 71    
 72     function hasOnlyEmptyStats(stats) {
 73         var itr = stats.iterator();
 74         while (itr.hasNext()) {
 75             if (! (itr.next() instanceof EmptyStatementTree)) {
 76                 return false;
 77             }
 78         }
 79 
 80         return true;
 81     }
 82  
 83     var visitor = new EmptyCatchFinder() {
 84         // current CompilationUnitTree
 85         compUnit: null,
 86         // current LineMap (pos -&gt; line, column)
 87         lineMap: null,
 88         // current compilation unit&#39;s file name
 89         fileName: null,
 90 
 91         // overrides of TreeScanner methods
 92 
 93         visitCompilationUnit: function(node, p) {
 94             // capture info about current Compilation unit
 95             this.compUnit = node;
 96             this.lineMap = node.lineMap;
 97             this.fileName = node.sourceFile.name;
 98 
 99             // Using Java.super API to call super class method here
100             return Java.super(visitor).visitCompilationUnit(node, p);
101         },
102 
103         visitCatch: function (node, p) {
104             var stats = node.block.statements;
105             if (stats.empty || hasOnlyEmptyStats(stats)) {
106                 // print information on this empty catch
107                 var pos = sourcePositions.getStartPosition(this.compUnit, node);
108                 var line = this.lineMap.getLineNumber(pos);
109                 var col = this.lineMap.getColumnNumber(pos);
110                 print(&quot;Exception swallow&quot; + &quot; @ &quot; + this.fileName + &quot;:&quot; + line + &quot;:&quot; + col);
111                 // print(node);
112             }
113         }
114     }
115  
116     for each (var cu in task.parse()) {
117         cu.accept(visitor, null);
118     }
119 }
120  
121 // for each &quot;.java&quot; file in directory (recursively) and check it!
122 function main(dir) {
123     Files.walk(dir.toPath()).
124       forEach(function(p) {
125         var name = p.toFile().absolutePath;
126         if (name.endsWith(&quot;.java&quot;)) {
127             try {
128                 printEmptyCatch(p.toFile().getAbsolutePath());
129             } catch (e) {
130                 print(e);
131             }
132         }
133       });
134 }
135  
136 main(new File(arguments[0]));
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/sample/nashorn/find_nonfinals2.js</title>
    <link rel="stylesheet" href="../../../style.css" />
  </head>
  <body>
    <pre>
  1 #// Usage: jjs find_nonfinals2.js -- &lt;directory&gt;
  2 
  3 /*
  4  * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  *
 10  *   - Redistributions of source code must retain the above copyright
 11  *     notice, this list of conditions and the following disclaimer.
 12  *
 13  *   - Redistributions in binary form must reproduce the above copyright
 14  *     notice, this list of conditions and the following disclaimer in the
 15  *     documentation and/or other materials provided with the distribution.
 16  *
 17  *   - Neither the name of Oracle nor the names of its
 18  *     contributors may be used to endorse or promote products derived
 19  *     from this software without specific prior written permission.
 20  *
 21  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS
 22  * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 23  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 24  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 25  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 26  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 27  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 28  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 29  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 30  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 31  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 
 34 // This example demonstrates Java subclassing by Java.extend
 35 // and javac Compiler and Tree API. This example finds method
 36 // parameters without &quot;final&quot; keyword and prints info on those.
 37 
 38 if (arguments.length == 0) {
 39     print(&quot;Usage: jjs find_nonfinals2.js -- &lt;directory&gt;&quot;);
 40     exit(1);
 41 }
 42 
 43 // Java types used
 44 var File = Java.type(&quot;java.io.File&quot;);
 45 var Files = Java.type(&quot;java.nio.file.Files&quot;);
 46 var StringArray = Java.type(&quot;java.lang.String[]&quot;);
 47 var ToolProvider = Java.type(&quot;javax.tools.ToolProvider&quot;);
 48 var Tree = Java.type(&quot;com.sun.source.tree.Tree&quot;);
 49 var TreeScanner = Java.type(&quot;com.sun.source.util.TreeScanner&quot;);
 50 var Modifier = Java.type(&quot;javax.lang.model.element.Modifier&quot;);
 51 
 52 function checkNonFinalParams(p) {
 53     // get the system compiler tool
 54     var compiler = ToolProvider.systemJavaCompiler;
 55     // get standard file manager
 56     var fileMgr = compiler.getStandardFileManager(null, null, null);
 57     // Using Java.to convert script array (arguments) to a Java String[]
 58     var compUnits = fileMgr.getJavaFileObjects(
 59         Java.to(arguments, StringArray));
 60     // create a new compilation task
 61     var task = compiler.getTask(null, fileMgr, null, null, null, compUnits);
 62     // subclass SimpleTreeVisitor - to find non-final method params
 63     var NonFinalsFinder = Java.extend(TreeScanner);
 64 
 65     function printMethod(method) {
 66         print(method.modifiers + &quot; &quot;+ method.returnType + &quot; &quot; +
 67             method.name + &quot;(&quot; + method.parameters + &quot;)&quot;);
 68     }
 69 
 70     var pkgName, clsName, compUnitName, lineMap;
 71     var visitor = new NonFinalsFinder() {
 72         visitCompilationUnit: function(compUnit, p) {
 73             pkgName = compUnit.packageName;
 74             compUnitName = compUnit.sourceFile.name;
 75             lineMap = compUnit.lineMap;
 76             return Java.super(visitor).visitCompilationUnit(compUnit, p);
 77         },
 78 
 79         visitClass: function(clazz, p) {
 80             clsName = clazz.name;
 81             return Java.super(visitor).visitClass(clazz, p);
 82         },
 83 
 84         visitMethod: function (method, p) {
 85             var params = method.parameters;
 86             for each (var p in params) {
 87                 var modifiers = p.modifiers;
 88                 if (! modifiers.flags.contains(Modifier.FINAL)) {
 89                     print(compUnitName);
 90                     print(pkgName + &quot;.&quot; + clsName);
 91                     printMethod(method);
 92                     print(&quot;-&gt;&quot;, p,
 93                      &quot; @ &quot; + lineMap.getLineNumber(p.pos) + &quot;:&quot; +
 94                            lineMap.getColumnNumber(p.pos));
 95                 }
 96             }
 97         }
 98     }
 99 
100     for each (var cu in task.parse()) {
101         cu.accept(visitor, null);
102     }
103 }
104 
105 // for each &quot;.java&quot; file in directory (recursively).
106 function main(dir) {
107     var totalCount = 0;
108     Files.walk(dir.toPath()).
109       forEach(function(p) {
110         var name = p.toFile().absolutePath;
111         if (name.endsWith(&quot;.java&quot;)) {
112             checkNonFinalParams(p);
113         }
114       });
115 }
116 
117 main(new File(arguments[0]));
    </pre>
  </body>
</html>
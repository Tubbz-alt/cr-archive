<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/nio/ch/DatagramSocketAdaptor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;
 29 import java.io.UncheckedIOException;
 30 import java.lang.invoke.MethodHandle;
 31 import java.lang.invoke.MethodHandles;
 32 import java.lang.invoke.MethodHandles.Lookup;
 33 import java.lang.invoke.MethodType;
 34 import java.lang.invoke.VarHandle;
 35 import java.net.DatagramPacket;
 36 import java.net.DatagramSocket;
 37 import java.net.InetAddress;
 38 import java.net.InetSocketAddress;
 39 import java.net.NetworkInterface;
 40 import java.net.MulticastSocket;
 41 import java.net.SocketAddress;
 42 import java.net.SocketException;
 43 import java.net.SocketOption;
 44 import java.net.StandardSocketOptions;
 45 import java.nio.ByteBuffer;
 46 import java.nio.channels.AlreadyConnectedException;
 47 import java.nio.channels.ClosedChannelException;
 48 import java.nio.channels.DatagramChannel;
 49 import java.nio.channels.MembershipKey;
 50 import java.security.AccessController;
 51 import java.security.PrivilegedAction;
 52 import java.security.PrivilegedExceptionAction;
 53 import java.util.Objects;
 54 import java.util.Set;
 55 import java.util.concurrent.locks.ReentrantLock;
 56 
 57 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 58 
 59 /**
 60  * A multicast datagram socket based on a datagram channel.
 61  *
 62  * This class overrides every public method defined by java.net.DatagramSocket
 63  * and java.net.MulticastSocket. The methods in this class are defined in exactly
 64  * the same order as in java.net.DatagramSocket and java.net.MulticastSocket so
 65  * as to simplify tracking changes.
 66  */
 67 public class DatagramSocketAdaptor
 68     extends MulticastSocket
 69 {
 70     // The channel being adapted
 71     private final DatagramChannelImpl dc;
 72 
 73     // Timeout &quot;option&quot; value for receives
 74     private volatile int timeout;
 75 
 76     private DatagramSocketAdaptor(DatagramChannelImpl dc) throws IOException {
 77         super(/*SocketAddress*/null);
 78         this.dc = dc;
 79     }
 80 
 81     static DatagramSocket create(DatagramChannelImpl dc) {
 82         try {
 83             return new DatagramSocketAdaptor(dc);
 84         } catch (IOException e) {
 85             throw new Error(e);
 86         }
 87     }
 88 
 89     private void connectInternal(SocketAddress remote) throws SocketException {
 90         try {
 91             dc.connect(remote, false); // skips check for already connected
 92         } catch (ClosedChannelException e) {
 93             // ignore
 94         } catch (Exception x) {
 95             Net.translateToSocketException(x);
 96         }
 97     }
 98 
 99     @Override
100     public void bind(SocketAddress local) throws SocketException {
101         if (local != null) {
102             local = Net.asInetSocketAddress(local);
103         } else {
104             local = new InetSocketAddress(0);
105         }
106         try {
107             dc.bind(local);
108         } catch (Exception x) {
109             Net.translateToSocketException(x);
110         }
111     }
112 
113     @Override
114     public void connect(InetAddress address, int port) {
115         if (address == null)
116             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);
117         try {
118             connectInternal(new InetSocketAddress(address, port));
119         } catch (SocketException x) {
120             throw new UncheckedIOException(x);
121         }
122     }
123 
124     @Override
125     public void connect(SocketAddress remote) throws SocketException {
126         if (remote == null)
127             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);
128         connectInternal(Net.asInetSocketAddress(remote));
129     }
130 
131     @Override
132     public void disconnect() {
133         try {
134             dc.disconnect();
135         } catch (IOException x) {
136             throw new UncheckedIOException(x);
137         }
138     }
139 
140     @Override
141     public boolean isBound() {
142         return dc.localAddress() != null;
143     }
144 
145     @Override
146     public boolean isConnected() {
147         return dc.remoteAddress() != null;
148     }
149 
150     @Override
151     public InetAddress getInetAddress() {
152         InetSocketAddress remote = dc.remoteAddress();
153         return (remote != null) ? remote.getAddress() : null;
154     }
155 
156     @Override
157     public int getPort() {
158         InetSocketAddress remote = dc.remoteAddress();
159         return (remote != null) ? remote.getPort() : -1;
160     }
161 
162     @Override
163     public SocketAddress getRemoteSocketAddress() {
164         return dc.remoteAddress();
165     }
166 
167     @Override
168     public SocketAddress getLocalSocketAddress() {
169         InetSocketAddress local = dc.localAddress();
170         if (local == null || isClosed())
171             return null;
172 
173         InetAddress addr = local.getAddress();
174         if (addr.isAnyLocalAddress())
175             return local;
176 
177         SecurityManager sm = System.getSecurityManager();
178         if (sm != null) {
179             try {
180                 sm.checkConnect(addr.getHostAddress(), -1);
181             } catch (SecurityException x) {
182                 return new InetSocketAddress(local.getPort());
183             }
184         }
185         return local;
186     }
187 
188     @Override
189     public void send(DatagramPacket p) throws IOException {
190         ByteBuffer bb = null;
191         try {
192             InetSocketAddress target;
193             synchronized (p) {
194                 // copy bytes to temporary direct buffer
195                 int len = p.getLength();
196                 bb = Util.getTemporaryDirectBuffer(len);
197                 bb.put(p.getData(), p.getOffset(), len);
198                 bb.flip();
199 
200                 // target address
201                 if (p.getAddress() == null) {
202                     InetSocketAddress remote = dc.remoteAddress();
203                     if (remote == null) {
204                         // not specified by DatagramSocket
205                         throw new IllegalArgumentException(&quot;Address not set&quot;);
206                     }
207                     // set address/port to maintain compatibility with DatagramSocket
208                     p.setAddress(remote.getAddress());
209                     p.setPort(remote.getPort());
210                     target = remote;
211                 } else {
212                     // throws IllegalArgumentException if port not set
213                     target = (InetSocketAddress) p.getSocketAddress();
214                 }
215             }
216             // send datagram
217             try {
218                 dc.blockingSend(bb, target);
219             } catch (AlreadyConnectedException e) {
220                 throw new IllegalArgumentException(&quot;Connected and packet address differ&quot;);
221             } catch (ClosedChannelException e) {
222                 var exc = new SocketException(&quot;Socket closed&quot;);
223                 exc.initCause(e);
224                 throw exc;
225             }
226         } finally {
227             if (bb != null) {
228                 Util.offerFirstTemporaryDirectBuffer(bb);
229             }
230         }
231     }
232 
233     @Override
234     public void receive(DatagramPacket p) throws IOException {
235         // get temporary direct buffer with a capacity of p.bufLength
236         int bufLength = DatagramPackets.getBufLength(p);
237         ByteBuffer bb = Util.getTemporaryDirectBuffer(bufLength);
238         try {
239             long nanos = MILLISECONDS.toNanos(timeout);
240             SocketAddress sender = dc.blockingReceive(bb, nanos);
241             bb.flip();
242             synchronized (p) {
243                 // copy bytes to the DatagramPacket and set length
244                 int len = Math.min(bb.limit(), DatagramPackets.getBufLength(p));
245                 bb.get(p.getData(), p.getOffset(), len);
246                 DatagramPackets.setLength(p, len);
247 
248                 // sender address
249                 p.setSocketAddress(sender);
250             }
251         } catch (ClosedChannelException e) {
252             var exc = new SocketException(&quot;Socket closed&quot;);
253             exc.initCause(e);
254             throw exc;
255         } finally {
256             Util.offerFirstTemporaryDirectBuffer(bb);
257         }
258     }
259 
260     @Override
261     public InetAddress getLocalAddress() {
262         if (isClosed())
263             return null;
264         InetSocketAddress local = dc.localAddress();
265         if (local == null)
266             local = new InetSocketAddress(0);
267         InetAddress result = local.getAddress();
268         SecurityManager sm = System.getSecurityManager();
269         if (sm != null) {
270             try {
271                 sm.checkConnect(result.getHostAddress(), -1);
272             } catch (SecurityException x) {
273                 return new InetSocketAddress(0).getAddress();
274             }
275         }
276         return result;
277     }
278 
279     @Override
280     public int getLocalPort() {
281         if (isClosed())
282             return -1;
283         InetSocketAddress local = dc.localAddress();
284         if (local != null) {
285             return local.getPort();
286         }
287         return 0;
288     }
289 
290     @Override
291     public void setSoTimeout(int timeout) throws SocketException {
292         if (isClosed())
293             throw new SocketException(&quot;Socket is closed&quot;);
294         if (timeout &lt; 0)
295             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);
296         this.timeout = timeout;
297     }
298 
299     @Override
300     public int getSoTimeout() throws SocketException {
301         if (isClosed())
302             throw new SocketException(&quot;Socket is closed&quot;);
303         return timeout;
304     }
305 
306     private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
307         throws SocketException
308     {
309         try {
310             dc.setOption(name, value);
311         } catch (IOException x) {
312             Net.translateToSocketException(x);
313         }
314     }
315 
316     private void setIntOption(SocketOption&lt;Integer&gt; name, int value)
317         throws SocketException
318     {
319         try {
320             dc.setOption(name, value);
321         } catch (IOException x) {
322             Net.translateToSocketException(x);
323         }
324     }
325 
326     private boolean getBooleanOption(SocketOption&lt;Boolean&gt; name) throws SocketException {
327         try {
328             return dc.getOption(name).booleanValue();
329         } catch (IOException x) {
330             Net.translateToSocketException(x);
331             return false;       // keep compiler happy
332         }
333     }
334 
335     private int getIntOption(SocketOption&lt;Integer&gt; name) throws SocketException {
336         try {
337             return dc.getOption(name).intValue();
338         } catch (IOException x) {
339             Net.translateToSocketException(x);
340             return -1;          // keep compiler happy
341         }
342     }
343 
344     @Override
345     public void setSendBufferSize(int size) throws SocketException {
346         if (size &lt;= 0)
347             throw new IllegalArgumentException(&quot;Invalid send size&quot;);
348         setIntOption(StandardSocketOptions.SO_SNDBUF, size);
349     }
350 
351     @Override
352     public int getSendBufferSize() throws SocketException {
353         return getIntOption(StandardSocketOptions.SO_SNDBUF);
354     }
355 
356     @Override
357     public void setReceiveBufferSize(int size) throws SocketException {
358         if (size &lt;= 0)
359             throw new IllegalArgumentException(&quot;Invalid receive size&quot;);
360         setIntOption(StandardSocketOptions.SO_RCVBUF, size);
361     }
362 
363     @Override
364     public int getReceiveBufferSize() throws SocketException {
365         return getIntOption(StandardSocketOptions.SO_RCVBUF);
366     }
367 
368     @Override
369     public void setReuseAddress(boolean on) throws SocketException {
370         setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);
371     }
372 
373     @Override
374     public boolean getReuseAddress() throws SocketException {
375         return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);
376     }
377 
378     @Override
379     public void setBroadcast(boolean on) throws SocketException {
380         setBooleanOption(StandardSocketOptions.SO_BROADCAST, on);
381     }
382 
383     @Override
384     public boolean getBroadcast() throws SocketException {
385         return getBooleanOption(StandardSocketOptions.SO_BROADCAST);
386     }
387 
388     @Override
389     public void setTrafficClass(int tc) throws SocketException {
390         setIntOption(StandardSocketOptions.IP_TOS, tc);
391     }
392 
393     @Override
394     public int getTrafficClass() throws SocketException {
395         return getIntOption(StandardSocketOptions.IP_TOS);
396     }
397 
398     @Override
399     public void close() {
400         try {
401             dc.close();
402         } catch (IOException x) {
403             throw new Error(x);
404         }
405     }
406 
407     @Override
408     public boolean isClosed() {
409         return !dc.isOpen();
410     }
411 
412     @Override
413     public DatagramChannel getChannel() {
414         return dc;
415     }
416 
417     @Override
418     public &lt;T&gt; DatagramSocket setOption(SocketOption&lt;T&gt; name, T value) throws IOException {
419         dc.setOption(name, value);
420         return this;
421     }
422 
423     @Override
424     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
425         return dc.getOption(name);
426     }
427 
428     @Override
429     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
430         return dc.supportedOptions();
431     }
432 
433     // -- java.net.MulticastSocket --
434 
435     // used to coordinate changing TTL with the deprecated send method
436     private final ReentrantLock sendLock = new ReentrantLock();
437 
438     // cached outgoing interface (for use by setInterface/getInterface)
439     private final Object outgoingInterfaceLock = new Object();
440     private NetworkInterface outgoingNetworkInterface;
441     private InetAddress outgoingInetAddress;
442 
443     @Override
444     @Deprecated
445     public void setTTL(byte ttl) throws IOException {
446         setTimeToLive(Byte.toUnsignedInt(ttl));
447     }
448 
449     @Override
450     public void setTimeToLive(int ttl) throws IOException {
451         sendLock.lock();
452         try {
453             setIntOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl);
454         } finally {
455             sendLock.unlock();
456         }
457     }
458 
459     @Override
460     @Deprecated
461     public byte getTTL() throws IOException {
462         return (byte) getTimeToLive();
463     }
464 
465     @Override
466     public int getTimeToLive() throws IOException {
467         sendLock.lock();
468         try {
469             return getIntOption(StandardSocketOptions.IP_MULTICAST_TTL);
470         } finally {
471             sendLock.unlock();
472         }
473     }
474 
475     @Override
476     @Deprecated
477     public void joinGroup(InetAddress group) throws IOException {
478         Objects.requireNonNull(group);
479         try {
480             joinGroup(new InetSocketAddress(group, 0), null);
481         } catch (IllegalArgumentException iae) {
482             // 1-arg joinGroup does not specify IllegalArgumentException
483             throw (SocketException) new SocketException(&quot;joinGroup failed&quot;).initCause(iae);
484         }
485     }
486 
487     @Override
488     @Deprecated
489     public void leaveGroup(InetAddress group) throws IOException {
490         Objects.requireNonNull(group);
491         try {
492             leaveGroup(new InetSocketAddress(group, 0), null);
493         } catch (IllegalArgumentException iae) {
494             // 1-arg leaveGroup does not specify IllegalArgumentException
495             throw (SocketException) new SocketException(&quot;leaveGroup failed&quot;).initCause(iae);
496         }
497     }
498 
499     /**
500      * Checks a SocketAddress to ensure that it is a multicast address.
501      *
502      * @return the multicast group
503      * @throws IllegalArgumentException if group is null, an unsupported address
504      *         type, or an unresolved address
505      * @throws SocketException if group is not a multicast address
506      */
507     private static InetAddress checkGroup(SocketAddress mcastaddr) throws SocketException {
508         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))
509             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
510         InetAddress group = ((InetSocketAddress) mcastaddr).getAddress();
511         if (group == null)
512             throw new IllegalArgumentException(&quot;Unresolved address&quot;);
513         if (!group.isMulticastAddress())
514             throw new SocketException(&quot;Not a multicast address&quot;);
515         return group;
516     }
517 
518     @Override
519     public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {
520         InetAddress group = checkGroup(mcastaddr);
521         NetworkInterface ni = (netIf != null) ? netIf : defaultNetworkInterface();
522         if (isClosed())
523             throw new SocketException(&quot;Socket is closed&quot;);
524         synchronized (this) {
525             MembershipKey key = dc.findMembership(group, ni);
526             if (key != null) {
527                 // already a member but need to check permission anyway
528                 SecurityManager sm = System.getSecurityManager();
529                 if (sm != null)
530                     sm.checkMulticast(group);
531                 throw new SocketException(&quot;Already a member of group&quot;);
532             }
533             dc.join(group, ni);  // checks permission
534         }
535     }
536 
537     @Override
538     public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {
539         InetAddress group = checkGroup(mcastaddr);
540         NetworkInterface ni = (netIf != null) ? netIf : defaultNetworkInterface();
541         if (isClosed())
542             throw new SocketException(&quot;Socket is closed&quot;);
543         SecurityManager sm = System.getSecurityManager();
544         if (sm != null)
545             sm.checkMulticast(group);
546         synchronized (this) {
547             MembershipKey key = dc.findMembership(group, ni);
548             if (key == null)
549                 throw new SocketException(&quot;Not a member of group&quot;);
550             key.drop();
551         }
552     }
553 
554     @Override
555     @Deprecated
556     public void setInterface(InetAddress inf) throws SocketException {
557         if (inf == null)
558             throw new SocketException(&quot;Invalid value &#39;null&#39;&quot;);
559         NetworkInterface ni = NetworkInterface.getByInetAddress(inf);
560         if (ni == null) {
561             String address = inf.getHostAddress();
562             throw new SocketException(&quot;No network interface with address &quot; + address);
563         }
564         synchronized (outgoingInterfaceLock) {
565             // set interface and update cached values
566             setNetworkInterface(ni);
567             outgoingNetworkInterface = ni;
568             outgoingInetAddress = inf;
569         }
570     }
571 
572     @Override
573     @Deprecated
574     public InetAddress getInterface() throws SocketException {
575         synchronized (outgoingInterfaceLock) {
576             NetworkInterface ni = outgoingNetworkInterface();
577             if (ni != null) {
578                 if (ni.equals(outgoingNetworkInterface)) {
579                     return outgoingInetAddress;
580                 } else {
581                     // network interface has changed so update cached values
582                     PrivilegedAction&lt;InetAddress&gt; pa;
583                     pa = () -&gt; ni.inetAddresses().findFirst().orElse(null);
584                     InetAddress ia = AccessController.doPrivileged(pa);
585                     if (ia == null)
586                         throw new SocketException(&quot;Network interface has no IP address&quot;);
587                     outgoingNetworkInterface = ni;
588                     outgoingInetAddress = ia;
589                     return ia;
590                 }
591             }
592         }
593 
594         // no interface set
595         return anyInetAddress();
596     }
597 
598     @Override
599     public void setNetworkInterface(NetworkInterface netIf) throws SocketException {
600         try {
601             setOption(StandardSocketOptions.IP_MULTICAST_IF, netIf);
602         } catch (IOException e) {
603             Net.translateToSocketException(e);
604         }
605     }
606 
607     @Override
608     public NetworkInterface getNetworkInterface() throws SocketException {
609         NetworkInterface ni = outgoingNetworkInterface();
610         if (ni == null) {
611             // return NetworkInterface with index == 0 as placeholder
612             ni = anyNetworkInterface();
613         }
614         return ni;
615     }
616 
617     @Override
618     @Deprecated
619     public void setLoopbackMode(boolean disable) throws SocketException {
620         boolean enable = !disable;
621         setBooleanOption(StandardSocketOptions.IP_MULTICAST_LOOP, enable);
622     }
623 
624     @Override
625     @Deprecated
626     public boolean getLoopbackMode() throws SocketException {
627         boolean enabled = getBooleanOption(StandardSocketOptions.IP_MULTICAST_LOOP);
628         return !enabled;
629     }
630 
631     @Override
632     @Deprecated
633     public void send(DatagramPacket p, byte ttl) throws IOException {
634         sendLock.lock();
635         try {
636             int oldValue = getTimeToLive();
637             try {
638                 setTTL(ttl);
639                 send(p);
640             } finally {
641                 setTimeToLive(oldValue);
642             }
643         } finally {
644             sendLock.unlock();
645         }
646     }
647 
648     /**
649      * Returns the outgoing NetworkInterface or null if not set.
650      */
651     private NetworkInterface outgoingNetworkInterface() throws SocketException {
652         try {
653             return getOption(StandardSocketOptions.IP_MULTICAST_IF);
654         } catch (IOException e) {
655             Net.translateToSocketException(e);
656             return null; // keep compiler happy
657         }
658     }
659 
660     /**
661      * Returns the default NetworkInterface to use when joining or leaving a
662      * multicast group and a network interface is not specified.
663      * This method will return the outgoing NetworkInterface if set, otherwise
664      * the result of NetworkInterface.getDefault(), otherwise a NetworkInterface
665      * with index == 0 as a placeholder for &quot;any network interface&quot;.
666      */
667     private NetworkInterface defaultNetworkInterface() throws SocketException {
668         NetworkInterface ni = outgoingNetworkInterface();
669         if (ni == null)
670             ni = NetworkInterfaces.getDefault();   // macOS
671         if (ni == null)
672             ni = anyNetworkInterface();
673         return ni;
674     }
675 
676     /**
677      * Returns the placeholder for &quot;any network interface&quot;, its index is 0.
678      */
679     private NetworkInterface anyNetworkInterface() {
680         InetAddress[] addrs = new InetAddress[1];
681         addrs[0] = anyInetAddress();
682         return NetworkInterfaces.newNetworkInterface(addrs[0].getHostName(), 0, addrs);
683     }
684 
685     /**
686      * Returns the InetAddress representing anyLocalAddress.
687      */
688     private InetAddress anyInetAddress() {
689         return new InetSocketAddress(0).getAddress();
690     }
691 
692     /**
693      * Defines static methods to get/set DatagramPacket fields and workaround
694      * DatagramPacket deficiencies.
695      */
696     private static class DatagramPackets {
697         private static final VarHandle LENGTH;
698         private static final VarHandle BUF_LENGTH;
699         static {
700             try {
701                 PrivilegedExceptionAction&lt;Lookup&gt; pa = () -&gt;
702                     MethodHandles.privateLookupIn(DatagramPacket.class, MethodHandles.lookup());
703                 MethodHandles.Lookup l = AccessController.doPrivileged(pa);
704                 LENGTH = l.findVarHandle(DatagramPacket.class, &quot;length&quot;, int.class);
705                 BUF_LENGTH = l.findVarHandle(DatagramPacket.class, &quot;bufLength&quot;, int.class);
706             } catch (Exception e) {
707                 throw new ExceptionInInitializerError(e);
708             }
709         }
710 
711         /**
712          * Sets the DatagramPacket.length field. DatagramPacket.setLength cannot be
713          * used at this time because it sets both the length and bufLength fields.
714          */
715         static void setLength(DatagramPacket p, int value) {
716             synchronized (p) {
717                 LENGTH.set(p, value);
718             }
719         }
720 
721         /**
722          * Returns the value of the DatagramPacket.bufLength field.
723          */
724         static int getBufLength(DatagramPacket p) {
725             synchronized (p) {
726                 return (int) BUF_LENGTH.get(p);
727             }
728         }
729     }
730 
731     /**
732      * Defines static methods to invoke non-public NetworkInterface methods.
733      */
734     private static class NetworkInterfaces {
735         static final MethodHandle GET_DEFAULT;
736         static final MethodHandle CONSTRUCTOR;
737         static {
738             try {
739                 PrivilegedExceptionAction&lt;Lookup&gt; pa = () -&gt;
740                     MethodHandles.privateLookupIn(NetworkInterface.class, MethodHandles.lookup());
741                 MethodHandles.Lookup l = AccessController.doPrivileged(pa);
742                 MethodType methodType = MethodType.methodType(NetworkInterface.class);
743                 GET_DEFAULT = l.findStatic(NetworkInterface.class, &quot;getDefault&quot;, methodType);
744                 methodType = MethodType.methodType(void.class, String.class, int.class, InetAddress[].class);
745                 CONSTRUCTOR = l.findConstructor(NetworkInterface.class, methodType);
746             } catch (Exception e) {
747                 throw new ExceptionInInitializerError(e);
748             }
749         }
750 
751         /**
752          * Returns the default network interface or null.
753          */
754         static NetworkInterface getDefault() {
755             try {
756                 return (NetworkInterface) GET_DEFAULT.invokeExact();
757             } catch (Throwable e) {
758                 throw new InternalError(e);
759             }
760         }
761 
762         /**
763          * Creates a NetworkInterface with the given name index and addresses.
764          */
765         static NetworkInterface newNetworkInterface(String name, int index, InetAddress[] addrs) {
766             try {
767                 return (NetworkInterface) CONSTRUCTOR.invoke(name, index, addrs);
768             } catch (Throwable e) {
769                 throw new InternalError(e);
770             }
771         }
772     }
773 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/TransportContext.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="StatusResponseManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../timestamp/TSResponse.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/TransportContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 72     // handshake context
 73     HandshakeContext                handshakeContext = null;
 74 
 75     // connection reserved status for handshake.
 76     boolean                         secureRenegotiation = false;
 77     byte[]                          clientVerifyData;
 78     byte[]                          serverVerifyData;
 79 
 80     // connection sensitive configuration
 81     List&lt;NamedGroup&gt;                serverRequestedNamedGroups;
 82 
 83     CipherSuite cipherSuite;
 84     private static final byte[] emptyByteArray = new byte[0];
 85 
 86     // Please never use the transport parameter other than storing a
 87     // reference to this object.
 88     //
 89     // Called by SSLEngineImpl
 90     TransportContext(SSLContextImpl sslContext, SSLTransport transport,
 91             InputRecord inputRecord, OutputRecord outputRecord) {
<span class="line-modified"> 92         this(sslContext, transport, new SSLConfiguration(sslContext, true),</span>
 93                 inputRecord, outputRecord, true);
 94     }
 95 
 96     // Please never use the transport parameter other than storing a
 97     // reference to this object.
 98     //
 99     // Called by SSLSocketImpl
100     TransportContext(SSLContextImpl sslContext, SSLTransport transport,
101             InputRecord inputRecord, OutputRecord outputRecord,
102             boolean isClientMode) {
103         this(sslContext, transport,
104                 new SSLConfiguration(sslContext, isClientMode),
105                 inputRecord, outputRecord, false);
106     }
107 
108     // Please never use the transport parameter other than storing a
109     // reference to this object.
110     //
111     // Called by SSLSocketImpl with an existing SSLConfig
112     TransportContext(SSLContextImpl sslContext, SSLTransport transport,
113             SSLConfiguration sslConfig,
114             InputRecord inputRecord, OutputRecord outputRecord) {
115         this(sslContext, transport, (SSLConfiguration)sslConfig.clone(),
116                 inputRecord, outputRecord, false);
117     }
118 
119     private TransportContext(SSLContextImpl sslContext, SSLTransport transport,
120             SSLConfiguration sslConfig, InputRecord inputRecord,
121             OutputRecord outputRecord, boolean isUnsureMode) {
122         this.transport = transport;
123         this.sslContext = sslContext;
124         this.inputRecord = inputRecord;
125         this.outputRecord = outputRecord;
126         this.sslConfig = sslConfig;
127         if (this.sslConfig.maximumPacketSize == 0) {
128             this.sslConfig.maximumPacketSize = outputRecord.getMaxPacketSize();
129         }
130         this.isUnsureMode = isUnsureMode;
131 
132         // initial security parameters
<span class="line-modified">133         this.conSession = SSLSessionImpl.nullSession;</span>
134         this.protocolVersion = this.sslConfig.maximumProtocolVersion;
135         this.clientVerifyData = emptyByteArray;
136         this.serverVerifyData = emptyByteArray;
137 
138         this.acc = AccessController.getContext();
139         this.consumers = new HashMap&lt;&gt;();
140     }
141 
142     // Dispatch plaintext to a specific consumer.
143     void dispatch(Plaintext plaintext) throws IOException {
144         if (plaintext == null) {
145             return;
146         }
147 
148         ContentType ct = ContentType.valueOf(plaintext.contentType);
149         if (ct == null) {
150             throw fatal(Alert.UNEXPECTED_MESSAGE,
151                 &quot;Unknown content type: &quot; + plaintext.contentType);
152         }
153 
154         switch (ct) {
155             case HANDSHAKE:
156                 byte type = HandshakeContext.getHandshakeType(this,
157                         plaintext);
158                 if (handshakeContext == null) {
159                     if (type == SSLHandshake.KEY_UPDATE.id ||
160                             type == SSLHandshake.NEW_SESSION_TICKET.id) {
161                         if (!isNegotiated) {
162                             throw fatal(Alert.UNEXPECTED_MESSAGE,
163                                     &quot;Unexpected unnegotiated post-handshake&quot; +
164                                             &quot; message: &quot; +
165                                             SSLHandshake.nameOf(type));
166                         }
<span class="line-modified">167                         if (type == SSLHandshake.KEY_UPDATE.id &amp;&amp;</span>
<span class="line-modified">168                                 !protocolVersion.useTLS13PlusSpec()) {</span>
169                             throw fatal(Alert.UNEXPECTED_MESSAGE,
170                                     &quot;Unexpected post-handshake message: &quot; +
171                                     SSLHandshake.nameOf(type));
172                         }

173                         handshakeContext = new PostHandshakeContext(this);
174                     } else {
175                         handshakeContext = sslConfig.isClientMode ?
176                                 new ClientHandshakeContext(sslContext, this) :
177                                 new ServerHandshakeContext(sslContext, this);
178                         outputRecord.initHandshaker();
179                     }
180                 }
181                 handshakeContext.dispatch(type, plaintext);
182                 break;
183             case ALERT:
184                 Alert.alertConsumer.consume(this, plaintext.fragment);
185                 break;
186             default:
187                 SSLConsumer consumer = consumers.get(plaintext.contentType);
188                 if (consumer != null) {
189                     consumer.consume(this, plaintext.fragment);
190                 } else {
191                     throw fatal(Alert.UNEXPECTED_MESSAGE,
192                         &quot;Unexpected content: &quot; + plaintext.contentType);
</pre>
</td>
<td>
<hr />
<pre>
 72     // handshake context
 73     HandshakeContext                handshakeContext = null;
 74 
 75     // connection reserved status for handshake.
 76     boolean                         secureRenegotiation = false;
 77     byte[]                          clientVerifyData;
 78     byte[]                          serverVerifyData;
 79 
 80     // connection sensitive configuration
 81     List&lt;NamedGroup&gt;                serverRequestedNamedGroups;
 82 
 83     CipherSuite cipherSuite;
 84     private static final byte[] emptyByteArray = new byte[0];
 85 
 86     // Please never use the transport parameter other than storing a
 87     // reference to this object.
 88     //
 89     // Called by SSLEngineImpl
 90     TransportContext(SSLContextImpl sslContext, SSLTransport transport,
 91             InputRecord inputRecord, OutputRecord outputRecord) {
<span class="line-modified"> 92         this(sslContext, transport, new SSLConfiguration(sslContext, false),</span>
 93                 inputRecord, outputRecord, true);
 94     }
 95 
 96     // Please never use the transport parameter other than storing a
 97     // reference to this object.
 98     //
 99     // Called by SSLSocketImpl
100     TransportContext(SSLContextImpl sslContext, SSLTransport transport,
101             InputRecord inputRecord, OutputRecord outputRecord,
102             boolean isClientMode) {
103         this(sslContext, transport,
104                 new SSLConfiguration(sslContext, isClientMode),
105                 inputRecord, outputRecord, false);
106     }
107 
108     // Please never use the transport parameter other than storing a
109     // reference to this object.
110     //
111     // Called by SSLSocketImpl with an existing SSLConfig
112     TransportContext(SSLContextImpl sslContext, SSLTransport transport,
113             SSLConfiguration sslConfig,
114             InputRecord inputRecord, OutputRecord outputRecord) {
115         this(sslContext, transport, (SSLConfiguration)sslConfig.clone(),
116                 inputRecord, outputRecord, false);
117     }
118 
119     private TransportContext(SSLContextImpl sslContext, SSLTransport transport,
120             SSLConfiguration sslConfig, InputRecord inputRecord,
121             OutputRecord outputRecord, boolean isUnsureMode) {
122         this.transport = transport;
123         this.sslContext = sslContext;
124         this.inputRecord = inputRecord;
125         this.outputRecord = outputRecord;
126         this.sslConfig = sslConfig;
127         if (this.sslConfig.maximumPacketSize == 0) {
128             this.sslConfig.maximumPacketSize = outputRecord.getMaxPacketSize();
129         }
130         this.isUnsureMode = isUnsureMode;
131 
132         // initial security parameters
<span class="line-modified">133         this.conSession = new SSLSessionImpl();</span>
134         this.protocolVersion = this.sslConfig.maximumProtocolVersion;
135         this.clientVerifyData = emptyByteArray;
136         this.serverVerifyData = emptyByteArray;
137 
138         this.acc = AccessController.getContext();
139         this.consumers = new HashMap&lt;&gt;();
140     }
141 
142     // Dispatch plaintext to a specific consumer.
143     void dispatch(Plaintext plaintext) throws IOException {
144         if (plaintext == null) {
145             return;
146         }
147 
148         ContentType ct = ContentType.valueOf(plaintext.contentType);
149         if (ct == null) {
150             throw fatal(Alert.UNEXPECTED_MESSAGE,
151                 &quot;Unknown content type: &quot; + plaintext.contentType);
152         }
153 
154         switch (ct) {
155             case HANDSHAKE:
156                 byte type = HandshakeContext.getHandshakeType(this,
157                         plaintext);
158                 if (handshakeContext == null) {
159                     if (type == SSLHandshake.KEY_UPDATE.id ||
160                             type == SSLHandshake.NEW_SESSION_TICKET.id) {
161                         if (!isNegotiated) {
162                             throw fatal(Alert.UNEXPECTED_MESSAGE,
163                                     &quot;Unexpected unnegotiated post-handshake&quot; +
164                                             &quot; message: &quot; +
165                                             SSLHandshake.nameOf(type));
166                         }
<span class="line-modified">167 </span>
<span class="line-modified">168                         if (!PostHandshakeContext.isConsumable(this, type)) {</span>
169                             throw fatal(Alert.UNEXPECTED_MESSAGE,
170                                     &quot;Unexpected post-handshake message: &quot; +
171                                     SSLHandshake.nameOf(type));
172                         }
<span class="line-added">173 </span>
174                         handshakeContext = new PostHandshakeContext(this);
175                     } else {
176                         handshakeContext = sslConfig.isClientMode ?
177                                 new ClientHandshakeContext(sslContext, this) :
178                                 new ServerHandshakeContext(sslContext, this);
179                         outputRecord.initHandshaker();
180                     }
181                 }
182                 handshakeContext.dispatch(type, plaintext);
183                 break;
184             case ALERT:
185                 Alert.alertConsumer.consume(this, plaintext.fragment);
186                 break;
187             default:
188                 SSLConsumer consumer = consumers.get(plaintext.contentType);
189                 if (consumer != null) {
190                     consumer.consume(this, plaintext.fragment);
191                 } else {
192                     throw fatal(Alert.UNEXPECTED_MESSAGE,
193                         &quot;Unexpected content: &quot; + plaintext.contentType);
</pre>
</td>
</tr>
</table>
<center><a href="StatusResponseManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../timestamp/TSResponse.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
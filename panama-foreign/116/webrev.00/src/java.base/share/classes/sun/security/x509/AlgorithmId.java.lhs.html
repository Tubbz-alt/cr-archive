<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/x509/AlgorithmId.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.x509;
  27 
  28 import java.io.*;
  29 import java.security.spec.AlgorithmParameterSpec;
  30 import java.security.spec.InvalidParameterSpecException;
  31 import java.security.spec.MGF1ParameterSpec;
  32 import java.security.spec.PSSParameterSpec;
  33 import java.util.*;
  34 import java.security.*;
  35 
  36 import sun.security.rsa.PSSParameters;
  37 import sun.security.util.*;
  38 
  39 
  40 /**
  41  * This class identifies algorithms, such as cryptographic transforms, each
  42  * of which may be associated with parameters.  Instances of this base class
  43  * are used when this runtime environment has no special knowledge of the
  44  * algorithm type, and may also be used in other cases.  Equivalence is
  45  * defined according to OID and (where relevant) parameters.
  46  *
  47  * &lt;P&gt;Subclasses may be used, for example when the algorithm ID has
  48  * associated parameters which some code (e.g. code using public keys) needs
  49  * to have parsed.  Two examples of such algorithms are Diffie-Hellman key
  50  * exchange, and the Digital Signature Standard Algorithm (DSS/DSA).
  51  *
  52  * &lt;P&gt;The OID constants defined in this class correspond to some widely
  53  * used algorithms, for which conventional string names have been defined.
  54  * This class is not a general repository for OIDs, or for such string names.
  55  * Note that the mappings between algorithm IDs and algorithm names is
  56  * not one-to-one.
  57  *
  58  *
  59  * @author David Brownell
  60  * @author Amit Kapoor
  61  * @author Hemma Prafullchandra
  62  */
  63 public class AlgorithmId implements Serializable, DerEncoder {
  64 
  65     /** use serialVersionUID from JDK 1.1. for interoperability */
  66     @java.io.Serial
  67     private static final long serialVersionUID = 7205873507486557157L;
  68 
  69     /**
  70      * The object identitifer being used for this algorithm.
  71      */
  72     private ObjectIdentifier algid;
  73 
  74     // The (parsed) parameters
  75     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
  76     private AlgorithmParameters algParams;
  77     private boolean constructedFromDer = true;
  78 
  79     /**
  80      * Parameters for this algorithm.  These are stored in unparsed
  81      * DER-encoded form; subclasses can be made to automaticaly parse
  82      * them so there is fast access to these parameters.
  83      */
  84     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
  85     protected DerValue          params;
  86 
  87 
  88     /**
  89      * Constructs an algorithm ID which will be initialized
  90      * separately, for example by deserialization.
  91      * @deprecated use one of the other constructors.
  92      */
  93     @Deprecated
  94     public AlgorithmId() { }
  95 
  96     /**
  97      * Constructs a parameterless algorithm ID.
  98      *
  99      * @param oid the identifier for the algorithm
 100      */
 101     public AlgorithmId(ObjectIdentifier oid) {
 102         algid = oid;
 103     }
 104 
 105     /**
 106      * Constructs an algorithm ID with algorithm parameters.
 107      *
 108      * @param oid the identifier for the algorithm.
 109      * @param algparams the associated algorithm parameters.
 110      */
 111     public AlgorithmId(ObjectIdentifier oid, AlgorithmParameters algparams) {
 112         algid = oid;
 113         algParams = algparams;
 114         constructedFromDer = false;
 115     }
 116 
 117     private AlgorithmId(ObjectIdentifier oid, DerValue params)
 118             throws IOException {
 119         this.algid = oid;
 120         this.params = params;
 121         if (this.params != null) {
 122             decodeParams();
 123         }
 124     }
 125 
 126     protected void decodeParams() throws IOException {
<a name="1" id="anc1"></a><span class="line-modified"> 127         String algidString = algid.toString();</span>
 128         try {
<a name="2" id="anc2"></a><span class="line-modified"> 129             algParams = AlgorithmParameters.getInstance(algidString);</span>
 130         } catch (NoSuchAlgorithmException e) {
 131             /*
 132              * This algorithm parameter type is not supported, so we cannot
 133              * parse the parameters.
 134              */
 135             algParams = null;
 136             return;
 137         }
 138 
 139         // Decode (parse) the parameters
 140         algParams.init(params.toByteArray());
 141     }
 142 
 143     /**
 144      * Marshal a DER-encoded &quot;AlgorithmID&quot; sequence on the DER stream.
 145      */
 146     public final void encode(DerOutputStream out) throws IOException {
 147         derEncode(out);
 148     }
 149 
 150     /**
 151      * DER encode this object onto an output stream.
 152      * Implements the &lt;code&gt;DerEncoder&lt;/code&gt; interface.
 153      *
 154      * @param out
 155      * the output stream on which to write the DER encoding.
 156      *
 157      * @exception IOException on encoding error.
 158      */
 159     public void derEncode (OutputStream out) throws IOException {
 160         DerOutputStream bytes = new DerOutputStream();
 161         DerOutputStream tmp = new DerOutputStream();
 162 
 163         bytes.putOID(algid);
 164         // Setup params from algParams since no DER encoding is given
 165         if (constructedFromDer == false) {
 166             if (algParams != null) {
 167                 params = new DerValue(algParams.getEncoded());
 168             } else {
 169                 params = null;
 170             }
 171         }
 172         if (params == null) {
 173             // Changes backed out for compatibility with Solaris
 174 
 175             // Several AlgorithmId should omit the whole parameter part when
 176             // it&#39;s NULL. They are ---
 177             // RFC 3370 2.1: Implementations SHOULD generate SHA-1
 178             // AlgorithmIdentifiers with absent parameters.
 179             // RFC 3447 C1: When id-sha1, id-sha224, id-sha256, id-sha384 and
 180             // id-sha512 are used in an AlgorithmIdentifier the parameters
 181             // (which are optional) SHOULD be omitted.
 182             // RFC 3279 2.3.2: The id-dsa algorithm syntax includes optional
 183             // domain parameters... When omitted, the parameters component
 184             // MUST be omitted entirely
 185             // RFC 3370 3.1: When the id-dsa-with-sha1 algorithm identifier
 186             // is used, the AlgorithmIdentifier parameters field MUST be absent.
 187             /*if (
 188                 algid.equals((Object)SHA_oid) ||
 189                 algid.equals((Object)SHA224_oid) ||
 190                 algid.equals((Object)SHA256_oid) ||
 191                 algid.equals((Object)SHA384_oid) ||
 192                 algid.equals((Object)SHA512_oid) ||
 193                 algid.equals((Object)SHA512_224_oid) ||
 194                 algid.equals((Object)SHA512_256_oid) ||
 195                 algid.equals((Object)DSA_oid) ||
 196                 algid.equals((Object)sha1WithDSA_oid)) {
 197                 ; // no parameter part encoded
 198             } else {
 199                 bytes.putNull();
 200             }*/
 201             if (algid.equals(RSASSA_PSS_oid)) {
 202                 // RFC 4055 3.3: when an RSASSA-PSS key does not require
 203                 // parameter validation, field is absent.
 204             } else {
 205                 bytes.putNull();
 206             }
 207         } else {
 208             bytes.putDerValue(params);
 209         }
 210         tmp.write(DerValue.tag_Sequence, bytes);
 211         out.write(tmp.toByteArray());
 212     }
 213 
 214 
 215     /**
 216      * Returns the DER-encoded X.509 AlgorithmId as a byte array.
 217      */
 218     public final byte[] encode() throws IOException {
 219         DerOutputStream out = new DerOutputStream();
 220         derEncode(out);
 221         return out.toByteArray();
 222     }
 223 
 224     /**
 225      * Returns the ISO OID for this algorithm.  This is usually converted
 226      * to a string and used as part of an algorithm name, for example
 227      * &quot;OID.1.3.14.3.2.13&quot; style notation.  Use the &lt;code&gt;getName&lt;/code&gt;
 228      * call when you do not need to ensure cross-system portability
 229      * of algorithm names, or need a user friendly name.
 230      */
 231     public final ObjectIdentifier getOID () {
 232         return algid;
 233     }
 234 
 235     /**
 236      * Returns a name for the algorithm which may be more intelligible
 237      * to humans than the algorithm&#39;s OID, but which won&#39;t necessarily
 238      * be comprehensible on other systems.  For example, this might
 239      * return a name such as &quot;MD5withRSA&quot; for a signature algorithm on
 240      * some systems.  It also returns names like &quot;OID.1.2.3.4&quot;, when
 241      * no particular name for the algorithm is known.
 242      *
 243      * Note: for ecdsa-with-SHA2 plus hash algorithm (Ex: SHA-256), this method
 244      * returns the &quot;full&quot; signature algorithm (Ex: SHA256withECDSA) directly.
 245      */
 246     public String getName() {
 247         String algName = nameTable.get(algid);
 248         if (algName != null) {
 249             return algName;
 250         }
 251         if ((params != null) &amp;&amp; algid.equals((Object)specifiedWithECDSA_oid)) {
 252             try {
 253                 AlgorithmId paramsId =
 254                         AlgorithmId.parse(new DerValue(params.toByteArray()));
 255                 String paramsName = paramsId.getName();
 256                 algName = makeSigAlg(paramsName, &quot;EC&quot;);
 257             } catch (IOException e) {
 258                 // ignore
 259             }
 260         }
 261         return (algName == null) ? algid.toString() : algName;
 262     }
 263 
 264     public AlgorithmParameters getParameters() {
 265         return algParams;
 266     }
 267 
 268     /**
 269      * Returns the DER encoded parameter, which can then be
 270      * used to initialize java.security.AlgorithmParameters.
 271      *
 272      * Note: for ecdsa-with-SHA2 plus hash algorithm (Ex: SHA-256), this method
 273      * returns null because {@link #getName()} has already returned the &quot;full&quot;
 274      * signature algorithm (Ex: SHA256withECDSA).
 275      *
 276      * @return DER encoded parameters, or null not present.
 277      */
 278     public byte[] getEncodedParams() throws IOException {
 279         return (params == null || algid.equals(specifiedWithECDSA_oid))
 280                 ? null
 281                 : params.toByteArray();
 282     }
 283 
 284     /**
 285      * Returns true iff the argument indicates the same algorithm
 286      * with the same parameters.
 287      */
 288     public boolean equals(AlgorithmId other) {
 289         boolean paramsEqual = Objects.equals(other.params, params);
 290         return (algid.equals((Object)other.algid) &amp;&amp; paramsEqual);
 291     }
 292 
 293     /**
 294      * Compares this AlgorithmID to another.  If algorithm parameters are
 295      * available, they are compared.  Otherwise, just the object IDs
 296      * for the algorithm are compared.
 297      *
 298      * @param other preferably an AlgorithmId, else an ObjectIdentifier
 299      */
 300     public boolean equals(Object other) {
 301         if (this == other) {
 302             return true;
 303         }
 304         if (other instanceof AlgorithmId) {
 305             return equals((AlgorithmId) other);
 306         } else if (other instanceof ObjectIdentifier) {
 307             return equals((ObjectIdentifier) other);
 308         } else {
 309             return false;
 310         }
 311     }
 312 
 313     /**
 314      * Compares two algorithm IDs for equality.  Returns true iff
 315      * they are the same algorithm, ignoring algorithm parameters.
 316      */
 317     public final boolean equals(ObjectIdentifier id) {
 318         return algid.equals((Object)id);
 319     }
 320 
 321     /**
 322      * Returns a hashcode for this AlgorithmId.
 323      *
 324      * @return a hashcode for this AlgorithmId.
 325      */
 326     public int hashCode() {
 327         StringBuilder sbuf = new StringBuilder();
 328         sbuf.append(algid.toString());
 329         sbuf.append(paramsToString());
 330         return sbuf.toString().hashCode();
 331     }
 332 
 333     /**
 334      * Provides a human-readable description of the algorithm parameters.
 335      * This may be redefined by subclasses which parse those parameters.
 336      */
 337     protected String paramsToString() {
 338         if (params == null) {
 339             return &quot;&quot;;
 340         } else if (algParams != null) {
 341             return algParams.toString();
 342         } else {
 343             return &quot;, params unparsed&quot;;
 344         }
 345     }
 346 
 347     /**
 348      * Returns a string describing the algorithm and its parameters.
 349      */
 350     public String toString() {
 351         return getName() + paramsToString();
 352     }
 353 
 354     /**
 355      * Parse (unmarshal) an ID from a DER sequence input value.  This form
 356      * parsing might be used when expanding a value which has already been
 357      * partially unmarshaled as a set or sequence member.
 358      *
 359      * @exception IOException on error.
 360      * @param val the input value, which contains the algid and, if
 361      *          there are any parameters, those parameters.
 362      * @return an ID for the algorithm.  If the system is configured
 363      *          appropriately, this may be an instance of a class
 364      *          with some kind of special support for this algorithm.
 365      *          In that case, you may &quot;narrow&quot; the type of the ID.
 366      */
 367     public static AlgorithmId parse(DerValue val) throws IOException {
 368         if (val.tag != DerValue.tag_Sequence) {
 369             throw new IOException(&quot;algid parse error, not a sequence&quot;);
 370         }
 371 
 372         /*
 373          * Get the algorithm ID and any parameters.
 374          */
 375         ObjectIdentifier        algid;
 376         DerValue                params;
 377         DerInputStream          in = val.toDerInputStream();
 378 
 379         algid = in.getOID();
 380         if (in.available() == 0) {
 381             params = null;
 382         } else {
 383             params = in.getDerValue();
 384             if (params.tag == DerValue.tag_Null) {
 385                 if (params.length() != 0) {
 386                     throw new IOException(&quot;invalid NULL&quot;);
 387                 }
 388                 params = null;
 389             }
 390             if (in.available() != 0) {
 391                 throw new IOException(&quot;Invalid AlgorithmIdentifier: extra data&quot;);
 392             }
 393         }
 394 
 395         return new AlgorithmId(algid, params);
 396     }
 397 
 398     /**
 399      * Returns one of the algorithm IDs most commonly associated
 400      * with this algorithm name.
 401      *
 402      * @param algname the name being used
 403      * @deprecated use the short get form of this method.
 404      * @exception NoSuchAlgorithmException on error.
 405      */
 406     @Deprecated
 407     public static AlgorithmId getAlgorithmId(String algname)
 408             throws NoSuchAlgorithmException {
 409         return get(algname);
 410     }
 411 
 412     /**
 413      * Returns one of the algorithm IDs most commonly associated
 414      * with this algorithm name.
 415      *
 416      * @param algname the name being used
 417      * @exception NoSuchAlgorithmException on error.
 418      */
 419     public static AlgorithmId get(String algname)
 420             throws NoSuchAlgorithmException {
 421         ObjectIdentifier oid;
 422         try {
 423             oid = algOID(algname);
 424         } catch (IOException ioe) {
 425             throw new NoSuchAlgorithmException
 426                 (&quot;Invalid ObjectIdentifier &quot; + algname);
 427         }
 428 
 429         if (oid == null) {
 430             throw new NoSuchAlgorithmException
 431                 (&quot;unrecognized algorithm name: &quot; + algname);
 432         }
 433         return new AlgorithmId(oid);
 434     }
 435 
 436     /**
 437      * Returns one of the algorithm IDs most commonly associated
 438      * with this algorithm parameters.
 439      *
 440      * @param algparams the associated algorithm parameters.
 441      * @exception NoSuchAlgorithmException on error.
 442      */
 443     public static AlgorithmId get(AlgorithmParameters algparams)
 444             throws NoSuchAlgorithmException {
 445         ObjectIdentifier oid;
 446         String algname = algparams.getAlgorithm();
 447         try {
 448             oid = algOID(algname);
 449         } catch (IOException ioe) {
 450             throw new NoSuchAlgorithmException
 451                 (&quot;Invalid ObjectIdentifier &quot; + algname);
 452         }
 453         if (oid == null) {
 454             throw new NoSuchAlgorithmException
 455                 (&quot;unrecognized algorithm name: &quot; + algname);
 456         }
 457         return new AlgorithmId(oid, algparams);
 458     }
 459 
 460     /*
 461      * Translates from some common algorithm names to the
 462      * OID with which they&#39;re usually associated ... this mapping
 463      * is the reverse of the one below, except in those cases
 464      * where synonyms are supported or where a given algorithm
 465      * is commonly associated with multiple OIDs.
 466      *
 467      * XXX This method needs to be enhanced so that we can also pass the
 468      * scope of the algorithm name to it, e.g., the algorithm name &quot;DSA&quot;
 469      * may have a different OID when used as a &quot;Signature&quot; algorithm than when
 470      * used as a &quot;KeyPairGenerator&quot; algorithm.
 471      */
 472     private static ObjectIdentifier algOID(String name) throws IOException {
 473         // See if algname is in printable OID (&quot;dot-dot&quot;) notation
 474         if (name.indexOf(&#39;.&#39;) != -1) {
 475             if (name.startsWith(&quot;OID.&quot;)) {
 476                 return new ObjectIdentifier(name.substring(&quot;OID.&quot;.length()));
 477             } else {
 478                 return new ObjectIdentifier(name);
 479             }
 480         }
 481 
 482         // Digesting algorithms
 483         if (name.equalsIgnoreCase(&quot;MD5&quot;)) {
 484             return AlgorithmId.MD5_oid;
 485         }
 486         if (name.equalsIgnoreCase(&quot;MD2&quot;)) {
 487             return AlgorithmId.MD2_oid;
 488         }
 489         if (name.equalsIgnoreCase(&quot;SHA&quot;) || name.equalsIgnoreCase(&quot;SHA1&quot;)
 490             || name.equalsIgnoreCase(&quot;SHA-1&quot;)) {
 491             return AlgorithmId.SHA_oid;
 492         }
 493         if (name.equalsIgnoreCase(&quot;SHA-256&quot;) ||
 494             name.equalsIgnoreCase(&quot;SHA256&quot;)) {
 495             return AlgorithmId.SHA256_oid;
 496         }
 497         if (name.equalsIgnoreCase(&quot;SHA-384&quot;) ||
 498             name.equalsIgnoreCase(&quot;SHA384&quot;)) {
 499             return AlgorithmId.SHA384_oid;
 500         }
 501         if (name.equalsIgnoreCase(&quot;SHA-512&quot;) ||
 502             name.equalsIgnoreCase(&quot;SHA512&quot;)) {
 503             return AlgorithmId.SHA512_oid;
 504         }
 505         if (name.equalsIgnoreCase(&quot;SHA-224&quot;) ||
 506             name.equalsIgnoreCase(&quot;SHA224&quot;)) {
 507             return AlgorithmId.SHA224_oid;
 508         }
 509         if (name.equalsIgnoreCase(&quot;SHA-512/224&quot;) ||
 510             name.equalsIgnoreCase(&quot;SHA512/224&quot;)) {
 511             return AlgorithmId.SHA512_224_oid;
 512         }
 513         if (name.equalsIgnoreCase(&quot;SHA-512/256&quot;) ||
 514             name.equalsIgnoreCase(&quot;SHA512/256&quot;)) {
 515             return AlgorithmId.SHA512_256_oid;
 516         }
 517         // Various public key algorithms
 518         if (name.equalsIgnoreCase(&quot;RSA&quot;)) {
 519             return AlgorithmId.RSAEncryption_oid;
 520         }
 521         if (name.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {
 522             return AlgorithmId.RSASSA_PSS_oid;
 523         }
 524         if (name.equalsIgnoreCase(&quot;RSAES-OAEP&quot;)) {
 525             return AlgorithmId.RSAES_OAEP_oid;
 526         }
 527         if (name.equalsIgnoreCase(&quot;Diffie-Hellman&quot;)
 528             || name.equalsIgnoreCase(&quot;DH&quot;)) {
 529             return AlgorithmId.DH_oid;
 530         }
 531         if (name.equalsIgnoreCase(&quot;DSA&quot;)) {
 532             return AlgorithmId.DSA_oid;
 533         }
 534         if (name.equalsIgnoreCase(&quot;EC&quot;)) {
 535             return EC_oid;
 536         }
 537         if (name.equalsIgnoreCase(&quot;ECDH&quot;)) {
 538             return AlgorithmId.ECDH_oid;
 539         }
 540 
 541         // Secret key algorithms
 542         if (name.equalsIgnoreCase(&quot;AES&quot;)) {
 543             return AlgorithmId.AES_oid;
 544         }
 545 
 546         // Common signature types
 547         if (name.equalsIgnoreCase(&quot;MD5withRSA&quot;)
 548             || name.equalsIgnoreCase(&quot;MD5/RSA&quot;)) {
 549             return AlgorithmId.md5WithRSAEncryption_oid;
 550         }
 551         if (name.equalsIgnoreCase(&quot;MD2withRSA&quot;)
 552             || name.equalsIgnoreCase(&quot;MD2/RSA&quot;)) {
 553             return AlgorithmId.md2WithRSAEncryption_oid;
 554         }
 555         if (name.equalsIgnoreCase(&quot;SHAwithDSA&quot;)
 556             || name.equalsIgnoreCase(&quot;SHA1withDSA&quot;)
 557             || name.equalsIgnoreCase(&quot;SHA/DSA&quot;)
 558             || name.equalsIgnoreCase(&quot;SHA1/DSA&quot;)
 559             || name.equalsIgnoreCase(&quot;DSAWithSHA1&quot;)
 560             || name.equalsIgnoreCase(&quot;DSS&quot;)
 561             || name.equalsIgnoreCase(&quot;SHA-1/DSA&quot;)) {
 562             return AlgorithmId.sha1WithDSA_oid;
 563         }
 564         if (name.equalsIgnoreCase(&quot;SHA224WithDSA&quot;)) {
 565             return AlgorithmId.sha224WithDSA_oid;
 566         }
 567         if (name.equalsIgnoreCase(&quot;SHA256WithDSA&quot;)) {
 568             return AlgorithmId.sha256WithDSA_oid;
 569         }
 570         if (name.equalsIgnoreCase(&quot;SHA1WithRSA&quot;)
 571             || name.equalsIgnoreCase(&quot;SHA1/RSA&quot;)) {
 572             return AlgorithmId.sha1WithRSAEncryption_oid;
 573         }
 574         if (name.equalsIgnoreCase(&quot;SHA1withECDSA&quot;)
 575                 || name.equalsIgnoreCase(&quot;ECDSA&quot;)) {
 576             return AlgorithmId.sha1WithECDSA_oid;
 577         }
 578         if (name.equalsIgnoreCase(&quot;SHA224withECDSA&quot;)) {
 579             return AlgorithmId.sha224WithECDSA_oid;
 580         }
 581         if (name.equalsIgnoreCase(&quot;SHA256withECDSA&quot;)) {
 582             return AlgorithmId.sha256WithECDSA_oid;
 583         }
 584         if (name.equalsIgnoreCase(&quot;SHA384withECDSA&quot;)) {
 585             return AlgorithmId.sha384WithECDSA_oid;
 586         }
 587         if (name.equalsIgnoreCase(&quot;SHA512withECDSA&quot;)) {
 588             return AlgorithmId.sha512WithECDSA_oid;
 589         }
 590 
 591         return oidTable().get(name.toUpperCase(Locale.ENGLISH));
 592     }
 593 
 594     private static volatile Map&lt;String,ObjectIdentifier&gt; oidTable;
 595     private static final Map&lt;ObjectIdentifier,String&gt; nameTable;
 596 
 597     /** Returns the oidTable, lazily initializing it on first access. */
 598     private static Map&lt;String,ObjectIdentifier&gt; oidTable()
 599         throws IOException {
 600         // Double checked locking; safe because oidTable is volatile
 601         Map&lt;String,ObjectIdentifier&gt; tab;
 602         if ((tab = oidTable) == null) {
 603             synchronized (AlgorithmId.class) {
 604                 if ((tab = oidTable) == null)
 605                     oidTable = tab = computeOidTable();
 606             }
 607         }
 608         return tab;
 609     }
 610 
 611     /** Collects the algorithm names from the installed providers. */
 612     private static HashMap&lt;String,ObjectIdentifier&gt; computeOidTable()
 613         throws IOException {
 614         HashMap&lt;String,ObjectIdentifier&gt; tab = new HashMap&lt;&gt;();
 615         for (Provider provider : Security.getProviders()) {
 616             for (Object key : provider.keySet()) {
 617                 String alias = (String)key;
 618                 String upperCaseAlias = alias.toUpperCase(Locale.ENGLISH);
 619                 int index;
 620                 if (upperCaseAlias.startsWith(&quot;ALG.ALIAS&quot;) &amp;&amp;
 621                     (index=upperCaseAlias.indexOf(&quot;OID.&quot;, 0)) != -1) {
 622                     index += &quot;OID.&quot;.length();
 623                     if (index == alias.length()) {
 624                         // invalid alias entry
 625                         break;
 626                     }
 627                     String oidString = alias.substring(index);
 628                     String stdAlgName = provider.getProperty(alias);
 629                     if (stdAlgName != null) {
 630                         stdAlgName = stdAlgName.toUpperCase(Locale.ENGLISH);
 631                     }
 632                     if (stdAlgName != null &amp;&amp;
 633                         tab.get(stdAlgName) == null) {
 634                         tab.put(stdAlgName, new ObjectIdentifier(oidString));
 635                     }
 636                 }
 637             }
 638         }
 639         return tab;
 640     }
 641 
 642     /*****************************************************************/
 643 
 644     /*
 645      * HASHING ALGORITHMS
 646      */
 647 
 648     /**
 649      * Algorithm ID for the MD2 Message Digest Algorthm, from RFC 1319.
 650      * OID = 1.2.840.113549.2.2
 651      */
 652     public static final ObjectIdentifier MD2_oid =
 653         ObjectIdentifier.of(&quot;1.2.840.113549.2.2&quot;);
 654 
 655     /**
 656      * Algorithm ID for the MD5 Message Digest Algorthm, from RFC 1321.
 657      * OID = 1.2.840.113549.2.5
 658      */
 659     public static final ObjectIdentifier MD5_oid =
 660         ObjectIdentifier.of(&quot;1.2.840.113549.2.5&quot;);
 661 
 662     /**
 663      * Algorithm ID for the SHA1 Message Digest Algorithm, from FIPS 180-1.
 664      * This is sometimes called &quot;SHA&quot;, though that is often confusing since
 665      * many people refer to FIPS 180 (which has an error) as defining SHA.
 666      * OID = 1.3.14.3.2.26. Old SHA-0 OID: 1.3.14.3.2.18.
 667      */
 668     public static final ObjectIdentifier SHA_oid =
 669         ObjectIdentifier.of(&quot;1.3.14.3.2.26&quot;);
 670 
 671     public static final ObjectIdentifier SHA224_oid =
 672         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.4&quot;);
 673 
 674     public static final ObjectIdentifier SHA256_oid =
 675         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.1&quot;);
 676 
 677     public static final ObjectIdentifier SHA384_oid =
 678         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.2&quot;);
 679 
 680     public static final ObjectIdentifier SHA512_oid =
 681         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.3&quot;);
 682 
 683     public static final ObjectIdentifier SHA512_224_oid =
 684         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.5&quot;);
 685 
 686     public static final ObjectIdentifier SHA512_256_oid =
 687         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.6&quot;);
 688 
 689     /*
 690      * COMMON PUBLIC KEY TYPES
 691      */
 692     /*
 693      * Note the preferred OIDs are named simply with no &quot;OIW&quot; or
 694      * &quot;PKIX&quot; in them, even though they may point to data from these
 695      * specs; e.g. SHA_oid, DH_oid, DSA_oid, SHA1WithDSA_oid...
 696      */
 697     /**
 698      * Algorithm ID for Diffie Hellman Key agreement, from PKCS #3.
 699      * Parameters include public values P and G, and may optionally specify
 700      * the length of the private key X.  Alternatively, algorithm parameters
 701      * may be derived from another source such as a Certificate Authority&#39;s
 702      * certificate.
 703      * OID = 1.2.840.113549.1.3.1
 704      */
 705     public static final ObjectIdentifier DH_oid =
 706             ObjectIdentifier.of(&quot;1.2.840.113549.1.3.1&quot;);
 707 
 708     /**
 709      * Algorithm ID for the Diffie Hellman Key Agreement (DH), from RFC 3279.
 710      * Parameters may include public values P and G.
 711      * OID = 1.2.840.10046.2.1
 712      */
 713     public static final ObjectIdentifier DH_PKIX_oid =
 714             ObjectIdentifier.of(&quot;1.2.840.10046.2.1&quot;);
 715 
 716     /**
 717      * Algorithm ID for the Digital Signing Algorithm (DSA), from the
 718      * NIST OIW Stable Agreements part 12.
 719      * Parameters may include public values P, Q, and G; or these may be
 720      * derived from
 721      * another source such as a Certificate Authority&#39;s certificate.
 722      * OID = 1.3.14.3.2.12
 723      */
 724     public static final ObjectIdentifier DSA_OIW_oid =
 725             ObjectIdentifier.of(&quot;1.3.14.3.2.12&quot;);
 726 
 727     /**
 728      * Algorithm ID for the Digital Signing Algorithm (DSA), from RFC 3279.
 729      * Parameters may include public values P, Q, and G; or these may be
 730      * derived from another source such as a Certificate Authority&#39;s
 731      * certificate.
 732      * OID = 1.2.840.10040.4.1
 733      */
 734     public static final ObjectIdentifier DSA_oid =
 735             ObjectIdentifier.of(&quot;1.2.840.10040.4.1&quot;);
 736 
 737     /**
 738      * Algorithm ID for RSA keys used for any purpose, as defined in X.509.
 739      * The algorithm parameter is a single value, the number of bits in the
 740      * public modulus.
 741      * OID = 2.5.8.1.1
 742      */
 743     public static final ObjectIdentifier RSA_oid =
 744             ObjectIdentifier.of(&quot;2.5.8.1.1&quot;);
 745 
 746     public static final ObjectIdentifier EC_oid =
 747             ObjectIdentifier.of(&quot;1.2.840.10045.2.1&quot;);
 748     public static final ObjectIdentifier ECDH_oid =
 749             ObjectIdentifier.of(&quot;1.3.132.1.12&quot;);
 750     public static final ObjectIdentifier RSAEncryption_oid =
 751             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.1&quot;);
 752     public static final ObjectIdentifier RSAES_OAEP_oid =
 753             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.7&quot;);
 754     public static final ObjectIdentifier mgf1_oid =
 755             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.8&quot;);
 756     public static final ObjectIdentifier RSASSA_PSS_oid =
 757             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.10&quot;);
 758 
 759     /*
 760      * COMMON SECRET KEY TYPES
 761      */
 762     public static final ObjectIdentifier AES_oid =
 763             ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.1&quot;);
 764 
 765     /*
 766      * COMMON SIGNATURE ALGORITHMS
 767      */
 768     /**
 769      * Identifies a signing algorithm where an MD2 digest is encrypted
 770      * using an RSA private key; defined in PKCS #1.  Use of this
 771      * signing algorithm is discouraged due to MD2 vulnerabilities.
 772      * OID = 1.2.840.113549.1.1.2
 773      */
 774     public static final ObjectIdentifier md2WithRSAEncryption_oid =
 775         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.2&quot;);
 776 
 777     /**
 778      * Identifies a signing algorithm where an MD5 digest is
 779      * encrypted using an RSA private key; defined in PKCS #1.
 780      * OID = 1.2.840.113549.1.1.4
 781      */
 782     public static final ObjectIdentifier md5WithRSAEncryption_oid =
 783         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.4&quot;);
 784 
 785     /**
 786      * Identifies a signing algorithm where a SHA1 digest is
 787      * encrypted using an RSA private key; defined by RSA DSI.
 788      * OID = 1.2.840.113549.1.1.5
 789      */
 790     public static final ObjectIdentifier sha1WithRSAEncryption_oid =
 791         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.5&quot;);
 792 
 793     /**
 794      * Identifies a signing algorithm where a SHA1 digest is
 795      * encrypted using an RSA private key; defined in NIST OIW.
 796      * OID = 1.3.14.3.2.29
 797      */
 798     public static final ObjectIdentifier sha1WithRSAEncryption_OIW_oid =
 799         ObjectIdentifier.of(&quot;1.3.14.3.2.29&quot;);
 800 
 801     /**
 802      * Identifies a signing algorithm where a SHA224 digest is
 803      * encrypted using an RSA private key; defined by PKCS #1.
 804      * OID = 1.2.840.113549.1.1.14
 805      */
 806     public static final ObjectIdentifier sha224WithRSAEncryption_oid =
 807         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.14&quot;);
 808 
 809     /**
 810      * Identifies a signing algorithm where a SHA256 digest is
 811      * encrypted using an RSA private key; defined by PKCS #1.
 812      * OID = 1.2.840.113549.1.1.11
 813      */
 814     public static final ObjectIdentifier sha256WithRSAEncryption_oid =
 815         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.11&quot;);
 816 
 817     /**
 818      * Identifies a signing algorithm where a SHA384 digest is
 819      * encrypted using an RSA private key; defined by PKCS #1.
 820      * OID = 1.2.840.113549.1.1.12
 821      */
 822     public static final ObjectIdentifier sha384WithRSAEncryption_oid =
 823         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.12&quot;);
 824 
 825     /**
 826      * Identifies a signing algorithm where a SHA512 digest is
 827      * encrypted using an RSA private key; defined by PKCS #1.
 828      * OID = 1.2.840.113549.1.1.13
 829      */
 830     public static final ObjectIdentifier sha512WithRSAEncryption_oid =
 831         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.13&quot;);
 832 
 833     /**
 834      * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a
 835      * SHA digest is signed using the Digital Signing Algorithm (DSA).
 836      * This should not be used.
 837      * OID = 1.3.14.3.2.13
 838      */
 839     public static final ObjectIdentifier shaWithDSA_OIW_oid =
 840             ObjectIdentifier.of(&quot;1.3.14.3.2.13&quot;);
 841 
 842     /**
 843      * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a
 844      * SHA1 digest is signed using the Digital Signing Algorithm (DSA).
 845      * OID = 1.3.14.3.2.27
 846      */
 847     public static final ObjectIdentifier sha1WithDSA_OIW_oid =
 848             ObjectIdentifier.of(&quot;1.3.14.3.2.27&quot;);
 849 
 850     /**
 851      * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a
 852      * SHA1 digest is signed using the Digital Signing Algorithm (DSA).
 853      * OID = 1.2.840.10040.4.3
 854      */
 855     public static final ObjectIdentifier sha1WithDSA_oid =
 856             ObjectIdentifier.of(&quot;1.2.840.10040.4.3&quot;);
 857 
 858     public static final ObjectIdentifier sha512_224WithRSAEncryption_oid =
 859             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.15&quot;);
 860     public static final ObjectIdentifier sha512_256WithRSAEncryption_oid =
 861             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.16&quot;);
 862 
 863     public static final ObjectIdentifier sha224WithDSA_oid =
 864             ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.3.1&quot;);
 865     public static final ObjectIdentifier sha256WithDSA_oid =
 866             ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.3.2&quot;);
 867 
 868     public static final ObjectIdentifier sha1WithECDSA_oid =
 869             ObjectIdentifier.of(&quot;1.2.840.10045.4.1&quot;);
 870     public static final ObjectIdentifier sha224WithECDSA_oid =
 871             ObjectIdentifier.of(&quot;1.2.840.10045.4.3.1&quot;);
 872     public static final ObjectIdentifier sha256WithECDSA_oid =
 873             ObjectIdentifier.of(&quot;1.2.840.10045.4.3.2&quot;);
 874     public static final ObjectIdentifier sha384WithECDSA_oid =
 875             ObjectIdentifier.of(&quot;1.2.840.10045.4.3.3&quot;);
 876     public static final ObjectIdentifier sha512WithECDSA_oid =
 877             ObjectIdentifier.of(&quot;1.2.840.10045.4.3.4&quot;);
 878     public static final ObjectIdentifier specifiedWithECDSA_oid =
 879             ObjectIdentifier.of(&quot;1.2.840.10045.4.3&quot;);
 880 
 881     /**
 882      * Algorithm ID for the PBE encryption algorithms from PKCS#5 and
 883      * PKCS#12.
 884      */
 885     public static final ObjectIdentifier pbeWithMD5AndDES_oid =
 886             ObjectIdentifier.of(&quot;1.2.840.113549.1.5.3&quot;);
 887     public static final ObjectIdentifier pbeWithMD5AndRC2_oid =
 888             ObjectIdentifier.of(&quot;1.2.840.113549.1.5.6&quot;);
 889     public static final ObjectIdentifier pbeWithSHA1AndDES_oid =
 890             ObjectIdentifier.of(&quot;1.2.840.113549.1.5.10&quot;);
 891     public static final ObjectIdentifier pbeWithSHA1AndRC2_oid =
 892             ObjectIdentifier.of(&quot;1.2.840.113549.1.5.11&quot;);
 893     public static final ObjectIdentifier pbeWithSHA1AndRC4_128_oid =
 894             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.1&quot;);
 895     public static final ObjectIdentifier pbeWithSHA1AndRC4_40_oid =
 896             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.2&quot;);
 897     public static final ObjectIdentifier pbeWithSHA1AndDESede_oid =
 898             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.3&quot;);
 899     public static final ObjectIdentifier pbeWithSHA1AndRC2_128_oid =
 900             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.5&quot;);
 901     public static final ObjectIdentifier pbeWithSHA1AndRC2_40_oid =
 902             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.6&quot;);
 903 
 904     static {
 905         nameTable = new HashMap&lt;&gt;();
 906         nameTable.put(MD5_oid, &quot;MD5&quot;);
 907         nameTable.put(MD2_oid, &quot;MD2&quot;);
 908         nameTable.put(SHA_oid, &quot;SHA-1&quot;);
 909         nameTable.put(SHA224_oid, &quot;SHA-224&quot;);
 910         nameTable.put(SHA256_oid, &quot;SHA-256&quot;);
 911         nameTable.put(SHA384_oid, &quot;SHA-384&quot;);
 912         nameTable.put(SHA512_oid, &quot;SHA-512&quot;);
 913         nameTable.put(SHA512_224_oid, &quot;SHA-512/224&quot;);
 914         nameTable.put(SHA512_256_oid, &quot;SHA-512/256&quot;);
 915         nameTable.put(RSAEncryption_oid, &quot;RSA&quot;);
 916         nameTable.put(RSA_oid, &quot;RSA&quot;);
 917         nameTable.put(DH_oid, &quot;Diffie-Hellman&quot;);
 918         nameTable.put(DH_PKIX_oid, &quot;Diffie-Hellman&quot;);
 919         nameTable.put(DSA_oid, &quot;DSA&quot;);
 920         nameTable.put(DSA_OIW_oid, &quot;DSA&quot;);
 921         nameTable.put(EC_oid, &quot;EC&quot;);
 922         nameTable.put(ECDH_oid, &quot;ECDH&quot;);
 923 
 924         nameTable.put(AES_oid, &quot;AES&quot;);
 925 
 926         nameTable.put(sha1WithECDSA_oid, &quot;SHA1withECDSA&quot;);
 927         nameTable.put(sha224WithECDSA_oid, &quot;SHA224withECDSA&quot;);
 928         nameTable.put(sha256WithECDSA_oid, &quot;SHA256withECDSA&quot;);
 929         nameTable.put(sha384WithECDSA_oid, &quot;SHA384withECDSA&quot;);
 930         nameTable.put(sha512WithECDSA_oid, &quot;SHA512withECDSA&quot;);
 931         nameTable.put(md5WithRSAEncryption_oid, &quot;MD5withRSA&quot;);
 932         nameTable.put(md2WithRSAEncryption_oid, &quot;MD2withRSA&quot;);
 933         nameTable.put(sha1WithDSA_oid, &quot;SHA1withDSA&quot;);
 934         nameTable.put(sha1WithDSA_OIW_oid, &quot;SHA1withDSA&quot;);
 935         nameTable.put(shaWithDSA_OIW_oid, &quot;SHA1withDSA&quot;);
 936         nameTable.put(sha224WithDSA_oid, &quot;SHA224withDSA&quot;);
 937         nameTable.put(sha256WithDSA_oid, &quot;SHA256withDSA&quot;);
 938         nameTable.put(sha1WithRSAEncryption_oid, &quot;SHA1withRSA&quot;);
 939         nameTable.put(sha1WithRSAEncryption_OIW_oid, &quot;SHA1withRSA&quot;);
 940         nameTable.put(sha224WithRSAEncryption_oid, &quot;SHA224withRSA&quot;);
 941         nameTable.put(sha256WithRSAEncryption_oid, &quot;SHA256withRSA&quot;);
 942         nameTable.put(sha384WithRSAEncryption_oid, &quot;SHA384withRSA&quot;);
 943         nameTable.put(sha512WithRSAEncryption_oid, &quot;SHA512withRSA&quot;);
 944         nameTable.put(sha512_224WithRSAEncryption_oid, &quot;SHA512/224withRSA&quot;);
 945         nameTable.put(sha512_256WithRSAEncryption_oid, &quot;SHA512/256withRSA&quot;);
 946         nameTable.put(RSASSA_PSS_oid, &quot;RSASSA-PSS&quot;);
 947         nameTable.put(RSAES_OAEP_oid, &quot;RSAES-OAEP&quot;);
 948 
 949         nameTable.put(pbeWithMD5AndDES_oid, &quot;PBEWithMD5AndDES&quot;);
 950         nameTable.put(pbeWithMD5AndRC2_oid, &quot;PBEWithMD5AndRC2&quot;);
 951         nameTable.put(pbeWithSHA1AndDES_oid, &quot;PBEWithSHA1AndDES&quot;);
 952         nameTable.put(pbeWithSHA1AndRC2_oid, &quot;PBEWithSHA1AndRC2&quot;);
 953         nameTable.put(pbeWithSHA1AndRC4_128_oid, &quot;PBEWithSHA1AndRC4_128&quot;);
 954         nameTable.put(pbeWithSHA1AndRC4_40_oid, &quot;PBEWithSHA1AndRC4_40&quot;);
 955         nameTable.put(pbeWithSHA1AndDESede_oid, &quot;PBEWithSHA1AndDESede&quot;);
 956         nameTable.put(pbeWithSHA1AndRC2_128_oid, &quot;PBEWithSHA1AndRC2_128&quot;);
 957         nameTable.put(pbeWithSHA1AndRC2_40_oid, &quot;PBEWithSHA1AndRC2_40&quot;);
 958     }
 959 
 960     /**
 961      * Creates a signature algorithm name from a digest algorithm
 962      * name and a encryption algorithm name.
 963      */
 964     public static String makeSigAlg(String digAlg, String encAlg) {
 965         digAlg = digAlg.replace(&quot;-&quot;, &quot;&quot;);
 966         if (encAlg.equalsIgnoreCase(&quot;EC&quot;)) encAlg = &quot;ECDSA&quot;;
 967 
 968         return digAlg + &quot;with&quot; + encAlg;
 969     }
 970 
 971     /**
 972      * Extracts the encryption algorithm name from a signature
 973      * algorithm name.
 974      */
 975     public static String getEncAlgFromSigAlg(String signatureAlgorithm) {
 976         signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);
 977         int with = signatureAlgorithm.indexOf(&quot;WITH&quot;);
 978         String keyAlgorithm = null;
 979         if (with &gt; 0) {
 980             int and = signatureAlgorithm.indexOf(&quot;AND&quot;, with + 4);
 981             if (and &gt; 0) {
 982                 keyAlgorithm = signatureAlgorithm.substring(with + 4, and);
 983             } else {
 984                 keyAlgorithm = signatureAlgorithm.substring(with + 4);
 985             }
 986             if (keyAlgorithm.equalsIgnoreCase(&quot;ECDSA&quot;)) {
 987                 keyAlgorithm = &quot;EC&quot;;
 988             }
 989         }
 990         return keyAlgorithm;
 991     }
 992 
 993     /**
 994      * Extracts the digest algorithm name from a signature
 995      * algorithm name.
 996      */
 997     public static String getDigAlgFromSigAlg(String signatureAlgorithm) {
 998         signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);
 999         int with = signatureAlgorithm.indexOf(&quot;WITH&quot;);
1000         if (with &gt; 0) {
1001             return signatureAlgorithm.substring(0, with);
1002         }
1003         return null;
1004     }
1005 
1006     /**
1007      * Checks if a signature algorithm matches a key algorithm, i.e. a
1008      * signature can be initialized with a key.
1009      *
1010      * @param kAlg must not be null
1011      * @param sAlg must not be null
1012      * @throws IllegalArgumentException if they do not match
1013      */
1014     public static void checkKeyAndSigAlgMatch(String kAlg, String sAlg) {
1015         String sAlgUp = sAlg.toUpperCase(Locale.US);
1016         if ((sAlgUp.endsWith(&quot;WITHRSA&quot;) &amp;&amp; !kAlg.equalsIgnoreCase(&quot;RSA&quot;)) ||
1017                 (sAlgUp.endsWith(&quot;WITHECDSA&quot;) &amp;&amp; !kAlg.equalsIgnoreCase(&quot;EC&quot;)) ||
1018                 (sAlgUp.endsWith(&quot;WITHDSA&quot;) &amp;&amp; !kAlg.equalsIgnoreCase(&quot;DSA&quot;))) {
1019             throw new IllegalArgumentException(
1020                     &quot;key algorithm not compatible with signature algorithm&quot;);
1021         }
1022     }
1023 
1024     /**
1025      * Returns the default signature algorithm for a private key. The digest
1026      * part might evolve with time. Remember to update the spec of
1027      * {@link jdk.security.jarsigner.JarSigner.Builder#getDefaultSignatureAlgorithm(PrivateKey)}
1028      * if updated.
1029      *
1030      * @param k cannot be null
1031      * @return the default alg, might be null if unsupported
1032      */
1033     public static String getDefaultSigAlgForKey(PrivateKey k) {
1034         switch (k.getAlgorithm().toUpperCase(Locale.ENGLISH)) {
1035             case &quot;EC&quot;:
1036                 return ecStrength(KeyUtil.getKeySize(k))
1037                     + &quot;withECDSA&quot;;
1038             case &quot;DSA&quot;:
1039                 return ifcFfcStrength(KeyUtil.getKeySize(k))
1040                     + &quot;withDSA&quot;;
1041             case &quot;RSA&quot;:
1042                 return ifcFfcStrength(KeyUtil.getKeySize(k))
1043                     + &quot;withRSA&quot;;
1044             case &quot;RSASSA-PSS&quot;:
1045                 return &quot;RSASSA-PSS&quot;;
1046             default:
1047                 return null;
1048         }
1049     }
1050 
1051     // Most commonly used PSSParameterSpec and AlgorithmId
1052     private static class PSSParamsHolder {
1053 
1054         final static PSSParameterSpec PSS_256_SPEC = new PSSParameterSpec(
1055                 &quot;SHA-256&quot;, &quot;MGF1&quot;,
1056                 new MGF1ParameterSpec(&quot;SHA-256&quot;),
1057                 32, PSSParameterSpec.TRAILER_FIELD_BC);
1058         final static PSSParameterSpec PSS_384_SPEC = new PSSParameterSpec(
1059                 &quot;SHA-384&quot;, &quot;MGF1&quot;,
1060                 new MGF1ParameterSpec(&quot;SHA-384&quot;),
1061                 48, PSSParameterSpec.TRAILER_FIELD_BC);
1062         final static PSSParameterSpec PSS_512_SPEC = new PSSParameterSpec(
1063                 &quot;SHA-512&quot;, &quot;MGF1&quot;,
1064                 new MGF1ParameterSpec(&quot;SHA-512&quot;),
1065                 64, PSSParameterSpec.TRAILER_FIELD_BC);
1066 
1067         final static AlgorithmId PSS_256_ID;
1068         final static AlgorithmId PSS_384_ID;
1069         final static AlgorithmId PSS_512_ID;
1070 
1071         static {
1072             try {
1073                 PSS_256_ID = new AlgorithmId(RSASSA_PSS_oid,
1074                         new DerValue(PSSParameters.getEncoded(PSS_256_SPEC)));
1075                 PSS_384_ID = new AlgorithmId(RSASSA_PSS_oid,
1076                         new DerValue(PSSParameters.getEncoded(PSS_384_SPEC)));
1077                 PSS_512_ID = new AlgorithmId(RSASSA_PSS_oid,
1078                         new DerValue(PSSParameters.getEncoded(PSS_512_SPEC)));
1079             } catch (IOException e) {
1080                 throw new AssertionError(&quot;Should not happen&quot;, e);
1081             }
1082         }
1083     }
1084 
1085     public static AlgorithmId getWithParameterSpec(String algName,
1086             AlgorithmParameterSpec spec) throws NoSuchAlgorithmException {
1087 
1088         if (spec == null) {
1089             return AlgorithmId.get(algName);
1090         } else if (spec == PSSParamsHolder.PSS_256_SPEC) {
1091             return PSSParamsHolder.PSS_256_ID;
1092         } else if (spec == PSSParamsHolder.PSS_384_SPEC) {
1093             return PSSParamsHolder.PSS_384_ID;
1094         } else if (spec == PSSParamsHolder.PSS_512_SPEC) {
1095             return PSSParamsHolder.PSS_512_ID;
1096         } else {
1097             try {
1098                 AlgorithmParameters result =
1099                         AlgorithmParameters.getInstance(algName);
1100                 result.init(spec);
1101                 return get(result);
1102             } catch (InvalidParameterSpecException | NoSuchAlgorithmException e) {
1103                 throw new ProviderException(e);
1104             }
1105         }
1106     }
1107 
1108     public static PSSParameterSpec getDefaultAlgorithmParameterSpec(
1109             String sigAlg, PrivateKey k) {
1110         if (sigAlg.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {
1111             switch (ifcFfcStrength(KeyUtil.getKeySize(k))) {
1112                 case &quot;SHA256&quot;:
1113                     return PSSParamsHolder.PSS_256_SPEC;
1114                 case &quot;SHA384&quot;:
1115                     return PSSParamsHolder.PSS_384_SPEC;
1116                 case &quot;SHA512&quot;:
1117                     return PSSParamsHolder.PSS_512_SPEC;
1118                 default:
1119                     throw new AssertionError(&quot;Should not happen&quot;);
1120             }
1121         } else {
1122             return null;
1123         }
1124     }
1125 
1126     // Values from SP800-57 part 1 rev 4 tables 2 and 3
1127     private static String ecStrength (int bitLength) {
1128         if (bitLength &gt;= 512) { // 256 bits of strength
1129             return &quot;SHA512&quot;;
1130         } else if (bitLength &gt;= 384) {  // 192 bits of strength
1131             return &quot;SHA384&quot;;
1132         } else { // 128 bits of strength and less
1133             return &quot;SHA256&quot;;
1134         }
1135     }
1136 
1137     // Same values for RSA and DSA
1138     private static String ifcFfcStrength (int bitLength) {
1139         if (bitLength &gt; 7680) { // 256 bits
1140             return &quot;SHA512&quot;;
1141         } else if (bitLength &gt; 3072) {  // 192 bits
1142             return &quot;SHA384&quot;;
1143         } else  { // 128 bits and less
1144             return &quot;SHA256&quot;;
1145         }
1146     }
1147 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
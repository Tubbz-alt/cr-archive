diff a/src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java b/src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java
--- a/src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java
+++ b/src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java
@@ -75,15 +75,10 @@
  *
  * @author David Brownell
  */
 final class SSLSessionImpl extends ExtendedSSLSession {
 
-    /*
-     * we only really need a single null session
-     */
-    static final SSLSessionImpl         nullSession = new SSLSessionImpl();
-
     /*
      * The state of a single session, as described in section 7.1
      * of the SSLv3 spec.
      */
     private final ProtocolVersion       protocolVersion;
@@ -151,11 +146,11 @@
      * Create a new non-rejoinable session, using the default (null)
      * cipher spec.  This constructor returns a session which could
      * be used either by a client or by a server, as a connection is
      * first opened and before handshaking begins.
      */
-    private SSLSessionImpl() {
+    SSLSessionImpl() {
         this.protocolVersion = ProtocolVersion.NONE;
         this.cipherSuite = CipherSuite.C_NULL;
         this.sessionId = new SessionId(false, null);
         this.host = null;
         this.port = -1;
@@ -320,17 +315,13 @@
 
         boundValues = new ConcurrentHashMap<>();
         this.protocolVersion =
                 ProtocolVersion.valueOf(Short.toUnsignedInt(buf.getShort()));
 
-        if (protocolVersion.useTLS13PlusSpec()) {
-            this.sessionId = new SessionId(false, null);
-        } else {
-            // The CH session id may reset this if it's provided
-            this.sessionId = new SessionId(true,
-                    hc.sslContext.getSecureRandom());
-        }
+        // The CH session id may reset this if it's provided
+        this.sessionId = new SessionId(true,
+                hc.sslContext.getSecureRandom());
 
         this.cipherSuite =
                 CipherSuite.valueOf(Short.toUnsignedInt(buf.getShort()));
 
         // Local Supported signature algorithms
@@ -399,12 +390,12 @@
         i = buf.get();
         if (i == 0) {
             identificationProtocol = null;
         } else {
             b = new byte[i];
-            identificationProtocol =
-                    buf.get(b, 0, i).asCharBuffer().toString();
+            buf.get(b);
+            identificationProtocol = new String(b);
         }
 
         // SNI
         i = buf.get();  // length
         if (i == 0) {
@@ -455,11 +446,12 @@
         i = Byte.toUnsignedInt(buf.get());
         if (i == 0) {
             this.host = new String();
         } else {
             b = new byte[i];
-            this.host = buf.get(b).toString();
+            buf.get(b, 0, i);
+            this.host = new String(b);
         }
         this.port = Short.toUnsignedInt(buf.getShort());
 
         // Peer certs
         i = buf.get();
@@ -503,11 +495,12 @@
             case 2:
                 // pre-shared key
                 // Length of pre-shared key algorithm  (one byte)
                 i = buf.get();
                 b = new byte[i];
-                String alg = buf.get(b, 0, i).asCharBuffer().toString();
+                buf.get(b, 0 , i);
+                String alg = new String(b);
                 // Get length of encoding
                 i = Short.toUnsignedInt(buf.getShort());
                 // Get encoding
                 b = new byte[i];
                 buf.get(b);
@@ -630,12 +623,12 @@
         }
 
         // List of SNIServerName
         hos.putInt16(requestedServerNames.size());
         if (requestedServerNames.size() > 0) {
-            for (SNIServerName host : requestedServerNames) {
-                b = host.getEncoded();
+            for (SNIServerName sn : requestedServerNames) {
+                b = sn.getEncoded();
                 hos.putInt8(b.length);
                 hos.write(b, 0, b.length);
             }
         }
 
@@ -1220,19 +1213,10 @@
      */
     @Override
     public void invalidate() {
         sessionLock.lock();
         try {
-            //
-            // Can't invalidate the NULL session -- this would be
-            // attempted when we get a handshaking error on a brand
-            // new connection, with no "real" session yet.
-            //
-            if (this == nullSession) {
-                return;
-            }
-
             if (context != null) {
                 context.remove(sessionId);
                 context = null;
             }
 

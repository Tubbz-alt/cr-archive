<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/nio/ch/DatagramSocketAdaptor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;
 29 import java.io.UncheckedIOException;
 30 import java.lang.invoke.MethodHandle;
 31 import java.lang.invoke.MethodHandles;
 32 import java.lang.invoke.MethodHandles.Lookup;
 33 import java.lang.invoke.MethodType;
 34 import java.lang.invoke.VarHandle;
 35 import java.net.DatagramPacket;
 36 import java.net.DatagramSocket;
 37 import java.net.InetAddress;
 38 import java.net.InetSocketAddress;
 39 import java.net.NetworkInterface;
 40 import java.net.MulticastSocket;
 41 import java.net.SocketAddress;
 42 import java.net.SocketException;
 43 import java.net.SocketOption;
 44 import java.net.StandardSocketOptions;
 45 import java.nio.ByteBuffer;
 46 import java.nio.channels.AlreadyConnectedException;
 47 import java.nio.channels.ClosedChannelException;
 48 import java.nio.channels.DatagramChannel;
 49 import java.nio.channels.MembershipKey;
 50 import java.security.AccessController;
 51 import java.security.PrivilegedAction;
 52 import java.security.PrivilegedExceptionAction;
 53 import java.util.Objects;
 54 import java.util.Set;
 55 import java.util.concurrent.locks.ReentrantLock;
 56 
 57 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 58 
 59 /**
 60  * A multicast datagram socket based on a datagram channel.
 61  *
 62  * This class overrides every public method defined by java.net.DatagramSocket
 63  * and java.net.MulticastSocket. The methods in this class are defined in exactly
 64  * the same order as in java.net.DatagramSocket and java.net.MulticastSocket so
 65  * as to simplify tracking changes.
 66  */
 67 public class DatagramSocketAdaptor
 68     extends MulticastSocket
 69 {
 70     // The channel being adapted
 71     private final DatagramChannelImpl dc;
 72 
 73     // Timeout &quot;option&quot; value for receives
 74     private volatile int timeout;
 75 
 76     private DatagramSocketAdaptor(DatagramChannelImpl dc) throws IOException {
 77         super(/*SocketAddress*/null);
 78         this.dc = dc;
 79     }
 80 
 81     static DatagramSocket create(DatagramChannelImpl dc) {
 82         try {
 83             return new DatagramSocketAdaptor(dc);
 84         } catch (IOException e) {
 85             throw new Error(e);
 86         }
 87     }
 88 
 89     private void connectInternal(SocketAddress remote) throws SocketException {
 90         try {
 91             dc.connect(remote, false); // skips check for already connected
 92         } catch (ClosedChannelException e) {
 93             // ignore
 94         } catch (Exception x) {
 95             Net.translateToSocketException(x);
 96         }
 97     }
 98 
 99     @Override
100     public void bind(SocketAddress local) throws SocketException {
101         if (local != null) {
102             local = Net.asInetSocketAddress(local);
103         } else {
104             local = new InetSocketAddress(0);
105         }
106         try {
107             dc.bind(local);
108         } catch (Exception x) {
109             Net.translateToSocketException(x);
110         }
111     }
112 
113     @Override
114     public void connect(InetAddress address, int port) {
115         if (address == null)
116             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);
117         try {
118             connectInternal(new InetSocketAddress(address, port));
119         } catch (SocketException x) {
120             throw new UncheckedIOException(x);
121         }
122     }
123 
124     @Override
125     public void connect(SocketAddress remote) throws SocketException {
126         if (remote == null)
127             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);
128         connectInternal(Net.asInetSocketAddress(remote));
129     }
130 
131     @Override
132     public void disconnect() {
133         try {
134             dc.disconnect();
135         } catch (IOException x) {
136             throw new UncheckedIOException(x);
137         }
138     }
139 
140     @Override
141     public boolean isBound() {
142         return dc.localAddress() != null;
143     }
144 
145     @Override
146     public boolean isConnected() {
147         return dc.remoteAddress() != null;
148     }
149 
150     @Override
151     public InetAddress getInetAddress() {
152         InetSocketAddress remote = dc.remoteAddress();
153         return (remote != null) ? remote.getAddress() : null;
154     }
155 
156     @Override
157     public int getPort() {
158         InetSocketAddress remote = dc.remoteAddress();
159         return (remote != null) ? remote.getPort() : -1;
160     }
161 
162     @Override
163     public SocketAddress getRemoteSocketAddress() {
164         return dc.remoteAddress();
165     }
166 
167     @Override
168     public SocketAddress getLocalSocketAddress() {
169         try {
170             return dc.getLocalAddress();
171         } catch (ClosedChannelException e) {
172             return null;
173         } catch (Exception x) {
174             throw new Error(x);
175         }
176     }
177 
178     @Override
179     public void send(DatagramPacket p) throws IOException {
180         ByteBuffer bb = null;
181         try {
182             InetSocketAddress target;
183             synchronized (p) {
184                 // copy bytes to temporary direct buffer
185                 int len = p.getLength();
186                 bb = Util.getTemporaryDirectBuffer(len);
187                 bb.put(p.getData(), p.getOffset(), len);
188                 bb.flip();
189 
190                 // target address
191                 if (p.getAddress() == null) {
192                     InetSocketAddress remote = dc.remoteAddress();
193                     if (remote == null) {
194                         // not specified by DatagramSocket
195                         throw new IllegalArgumentException(&quot;Address not set&quot;);
196                     }
197                     // set address/port to maintain compatibility with DatagramSocket
198                     p.setAddress(remote.getAddress());
199                     p.setPort(remote.getPort());
200                     target = remote;
201                 } else {
202                     // throws IllegalArgumentException if port not set
203                     target = (InetSocketAddress) p.getSocketAddress();
204                 }
205             }
206             // send datagram
207             try {
208                 dc.blockingSend(bb, target);
209             } catch (AlreadyConnectedException e) {
210                 throw new IllegalArgumentException(&quot;Connected and packet address differ&quot;);
211             } catch (ClosedChannelException e) {
212                 var exc = new SocketException(&quot;Socket closed&quot;);
213                 exc.initCause(e);
214                 throw exc;
215             }
216         } finally {
217             if (bb != null) {
218                 Util.offerFirstTemporaryDirectBuffer(bb);
219             }
220         }
221     }
222 
223     @Override
224     public void receive(DatagramPacket p) throws IOException {
225         // get temporary direct buffer with a capacity of p.bufLength
226         int bufLength = DatagramPackets.getBufLength(p);
227         ByteBuffer bb = Util.getTemporaryDirectBuffer(bufLength);
228         try {
229             long nanos = MILLISECONDS.toNanos(timeout);
230             SocketAddress sender = dc.blockingReceive(bb, nanos);
231             bb.flip();
232             synchronized (p) {
233                 // copy bytes to the DatagramPacket and set length
234                 int len = Math.min(bb.limit(), DatagramPackets.getBufLength(p));
235                 bb.get(p.getData(), p.getOffset(), len);
236                 DatagramPackets.setLength(p, len);
237 
238                 // sender address
239                 p.setSocketAddress(sender);
240             }
241         } catch (ClosedChannelException e) {
242             var exc = new SocketException(&quot;Socket closed&quot;);
243             exc.initCause(e);
244             throw exc;
245         } finally {
246             Util.offerFirstTemporaryDirectBuffer(bb);
247         }
248     }
249 
250     @Override
251     public InetAddress getLocalAddress() {
252         if (isClosed())
253             return null;
254         InetSocketAddress local = dc.localAddress();
255         if (local == null)
256             local = new InetSocketAddress(0);
257         InetAddress result = local.getAddress();
258         SecurityManager sm = System.getSecurityManager();
259         if (sm != null) {
260             try {
261                 sm.checkConnect(result.getHostAddress(), -1);
262             } catch (SecurityException x) {
263                 return new InetSocketAddress(0).getAddress();
264             }
265         }
266         return result;
267     }
268 
269     @Override
270     public int getLocalPort() {
271         if (isClosed())
272             return -1;
273         InetSocketAddress local = dc.localAddress();
274         if (local != null) {
275             return local.getPort();
276         }
277         return 0;
278     }
279 
280     @Override
281     public void setSoTimeout(int timeout) throws SocketException {
282         if (isClosed())
283             throw new SocketException(&quot;Socket is closed&quot;);
284         if (timeout &lt; 0)
285             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);
286         this.timeout = timeout;
287     }
288 
289     @Override
290     public int getSoTimeout() throws SocketException {
291         if (isClosed())
292             throw new SocketException(&quot;Socket is closed&quot;);
293         return timeout;
294     }
295 
296     private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
297         throws SocketException
298     {
299         try {
300             dc.setOption(name, value);
301         } catch (IOException x) {
302             Net.translateToSocketException(x);
303         }
304     }
305 
306     private void setIntOption(SocketOption&lt;Integer&gt; name, int value)
307         throws SocketException
308     {
309         try {
310             dc.setOption(name, value);
311         } catch (IOException x) {
312             Net.translateToSocketException(x);
313         }
314     }
315 
316     private boolean getBooleanOption(SocketOption&lt;Boolean&gt; name) throws SocketException {
317         try {
318             return dc.getOption(name).booleanValue();
319         } catch (IOException x) {
320             Net.translateToSocketException(x);
321             return false;       // keep compiler happy
322         }
323     }
324 
325     private int getIntOption(SocketOption&lt;Integer&gt; name) throws SocketException {
326         try {
327             return dc.getOption(name).intValue();
328         } catch (IOException x) {
329             Net.translateToSocketException(x);
330             return -1;          // keep compiler happy
331         }
332     }
333 
334     @Override
335     public void setSendBufferSize(int size) throws SocketException {
336         if (size &lt;= 0)
337             throw new IllegalArgumentException(&quot;Invalid send size&quot;);
338         setIntOption(StandardSocketOptions.SO_SNDBUF, size);
339     }
340 
341     @Override
342     public int getSendBufferSize() throws SocketException {
343         return getIntOption(StandardSocketOptions.SO_SNDBUF);
344     }
345 
346     @Override
347     public void setReceiveBufferSize(int size) throws SocketException {
348         if (size &lt;= 0)
349             throw new IllegalArgumentException(&quot;Invalid receive size&quot;);
350         setIntOption(StandardSocketOptions.SO_RCVBUF, size);
351     }
352 
353     @Override
354     public int getReceiveBufferSize() throws SocketException {
355         return getIntOption(StandardSocketOptions.SO_RCVBUF);
356     }
357 
358     @Override
359     public void setReuseAddress(boolean on) throws SocketException {
360         setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);
361     }
362 
363     @Override
364     public boolean getReuseAddress() throws SocketException {
365         return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);
366     }
367 
368     @Override
369     public void setBroadcast(boolean on) throws SocketException {
370         setBooleanOption(StandardSocketOptions.SO_BROADCAST, on);
371     }
372 
373     @Override
374     public boolean getBroadcast() throws SocketException {
375         return getBooleanOption(StandardSocketOptions.SO_BROADCAST);
376     }
377 
378     @Override
379     public void setTrafficClass(int tc) throws SocketException {
380         setIntOption(StandardSocketOptions.IP_TOS, tc);
381     }
382 
383     @Override
384     public int getTrafficClass() throws SocketException {
385         return getIntOption(StandardSocketOptions.IP_TOS);
386     }
387 
388     @Override
389     public void close() {
390         try {
391             dc.close();
392         } catch (IOException x) {
393             throw new Error(x);
394         }
395     }
396 
397     @Override
398     public boolean isClosed() {
399         return !dc.isOpen();
400     }
401 
402     @Override
403     public DatagramChannel getChannel() {
404         return dc;
405     }
406 
407     @Override
408     public &lt;T&gt; DatagramSocket setOption(SocketOption&lt;T&gt; name, T value) throws IOException {
409         dc.setOption(name, value);
410         return this;
411     }
412 
413     @Override
414     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
415         return dc.getOption(name);
416     }
417 
418     @Override
419     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
420         return dc.supportedOptions();
421     }
422 
423     // -- java.net.MulticastSocket --
424 
425     // used to coordinate changing TTL with the deprecated send method
426     private final ReentrantLock sendLock = new ReentrantLock();
427 
428     // cached outgoing interface (for use by setInterface/getInterface)
429     private final Object outgoingInterfaceLock = new Object();
430     private NetworkInterface outgoingNetworkInterface;
431     private InetAddress outgoingInetAddress;
432 
433     @Override
434     @Deprecated
435     public void setTTL(byte ttl) throws IOException {
436         setTimeToLive(Byte.toUnsignedInt(ttl));
437     }
438 
439     @Override
440     public void setTimeToLive(int ttl) throws IOException {
441         sendLock.lock();
442         try {
443             setIntOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl);
444         } finally {
445             sendLock.unlock();
446         }
447     }
448 
449     @Override
450     @Deprecated
451     public byte getTTL() throws IOException {
452         return (byte) getTimeToLive();
453     }
454 
455     @Override
456     public int getTimeToLive() throws IOException {
457         sendLock.lock();
458         try {
459             return getIntOption(StandardSocketOptions.IP_MULTICAST_TTL);
460         } finally {
461             sendLock.unlock();
462         }
463     }
464 
465     @Override
466     @Deprecated
467     public void joinGroup(InetAddress group) throws IOException {
468         Objects.requireNonNull(group);
469         try {
470             joinGroup(new InetSocketAddress(group, 0), null);
471         } catch (IllegalArgumentException iae) {
472             // 1-arg joinGroup does not specify IllegalArgumentException
473             throw (SocketException) new SocketException(&quot;joinGroup failed&quot;).initCause(iae);
474         }
475     }
476 
477     @Override
478     @Deprecated
479     public void leaveGroup(InetAddress group) throws IOException {
480         Objects.requireNonNull(group);
481         try {
482             leaveGroup(new InetSocketAddress(group, 0), null);
483         } catch (IllegalArgumentException iae) {
484             // 1-arg leaveGroup does not specify IllegalArgumentException
485             throw (SocketException) new SocketException(&quot;leaveGroup failed&quot;).initCause(iae);
486         }
487     }
488 
489     /**
490      * Checks a SocketAddress to ensure that it is a multicast address.
491      *
492      * @return the multicast group
493      * @throws IllegalArgumentException if group is null, an unsupported address
494      *         type, or an unresolved address
495      * @throws SocketException if group is not a multicast address
496      */
497     private static InetAddress checkGroup(SocketAddress mcastaddr) throws SocketException {
498         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))
499             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
500         InetAddress group = ((InetSocketAddress) mcastaddr).getAddress();
501         if (group == null)
502             throw new IllegalArgumentException(&quot;Unresolved address&quot;);
503         if (!group.isMulticastAddress())
504             throw new SocketException(&quot;Not a multicast address&quot;);
505         return group;
506     }
507 
508     @Override
509     public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {
510         InetAddress group = checkGroup(mcastaddr);
511         NetworkInterface ni = (netIf != null) ? netIf : defaultNetworkInterface();
512         if (isClosed())
513             throw new SocketException(&quot;Socket is closed&quot;);
514         synchronized (this) {
515             MembershipKey key = dc.findMembership(group, ni);
516             if (key != null) {
517                 // already a member but need to check permission anyway
518                 SecurityManager sm = System.getSecurityManager();
519                 if (sm != null)
520                     sm.checkMulticast(group);
521                 throw new SocketException(&quot;Already a member of group&quot;);
522             }
523             dc.join(group, ni);  // checks permission
524         }
525     }
526 
527     @Override
528     public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {
529         InetAddress group = checkGroup(mcastaddr);
530         NetworkInterface ni = (netIf != null) ? netIf : defaultNetworkInterface();
531         if (isClosed())
532             throw new SocketException(&quot;Socket is closed&quot;);
533         SecurityManager sm = System.getSecurityManager();
534         if (sm != null)
535             sm.checkMulticast(group);
536         synchronized (this) {
537             MembershipKey key = dc.findMembership(group, ni);
538             if (key == null)
539                 throw new SocketException(&quot;Not a member of group&quot;);
540             key.drop();
541         }
542     }
543 
544     @Override
545     @Deprecated
546     public void setInterface(InetAddress inf) throws SocketException {
547         if (inf == null)
548             throw new SocketException(&quot;Invalid value &#39;null&#39;&quot;);
549         NetworkInterface ni = NetworkInterface.getByInetAddress(inf);
550         if (ni == null) {
551             String address = inf.getHostAddress();
552             throw new SocketException(&quot;No network interface with address &quot; + address);
553         }
554         synchronized (outgoingInterfaceLock) {
555             // set interface and update cached values
556             setNetworkInterface(ni);
557             outgoingNetworkInterface = ni;
558             outgoingInetAddress = inf;
559         }
560     }
561 
562     @Override
563     @Deprecated
564     public InetAddress getInterface() throws SocketException {
565         synchronized (outgoingInterfaceLock) {
566             NetworkInterface ni = outgoingNetworkInterface();
567             if (ni != null) {
568                 if (ni.equals(outgoingNetworkInterface)) {
569                     return outgoingInetAddress;
570                 } else {
571                     // network interface has changed so update cached values
572                     PrivilegedAction&lt;InetAddress&gt; pa;
573                     pa = () -&gt; ni.inetAddresses().findFirst().orElse(null);
574                     InetAddress ia = AccessController.doPrivileged(pa);
575                     if (ia == null)
576                         throw new SocketException(&quot;Network interface has no IP address&quot;);
577                     outgoingNetworkInterface = ni;
578                     outgoingInetAddress = ia;
579                     return ia;
580                 }
581             }
582         }
583 
584         // no interface set
585         return anyInetAddress();
586     }
587 
588     @Override
589     public void setNetworkInterface(NetworkInterface netIf) throws SocketException {
590         try {
591             setOption(StandardSocketOptions.IP_MULTICAST_IF, netIf);
592         } catch (IOException e) {
593             Net.translateToSocketException(e);
594         }
595     }
596 
597     @Override
598     public NetworkInterface getNetworkInterface() throws SocketException {
599         NetworkInterface ni = outgoingNetworkInterface();
600         if (ni == null) {
601             // return NetworkInterface with index == 0 as placeholder
602             ni = anyNetworkInterface();
603         }
604         return ni;
605     }
606 
607     @Override
608     @Deprecated
609     public void setLoopbackMode(boolean disable) throws SocketException {
610         boolean enable = !disable;
611         setBooleanOption(StandardSocketOptions.IP_MULTICAST_LOOP, enable);
612     }
613 
614     @Override
615     @Deprecated
616     public boolean getLoopbackMode() throws SocketException {
617         boolean enabled = getBooleanOption(StandardSocketOptions.IP_MULTICAST_LOOP);
618         return !enabled;
619     }
620 
621     @Override
622     @Deprecated
623     public void send(DatagramPacket p, byte ttl) throws IOException {
624         sendLock.lock();
625         try {
626             int oldValue = getTimeToLive();
627             try {
628                 setTTL(ttl);
629                 send(p);
630             } finally {
631                 setTimeToLive(oldValue);
632             }
633         } finally {
634             sendLock.unlock();
635         }
636     }
637 
638     /**
639      * Returns the outgoing NetworkInterface or null if not set.
640      */
641     private NetworkInterface outgoingNetworkInterface() throws SocketException {
642         try {
643             return getOption(StandardSocketOptions.IP_MULTICAST_IF);
644         } catch (IOException e) {
645             Net.translateToSocketException(e);
646             return null; // keep compiler happy
647         }
648     }
649 
650     /**
651      * Returns the default NetworkInterface to use when joining or leaving a
652      * multicast group and a network interface is not specified.
653      * This method will return the outgoing NetworkInterface if set, otherwise
654      * the result of NetworkInterface.getDefault(), otherwise a NetworkInterface
655      * with index == 0 as a placeholder for &quot;any network interface&quot;.
656      */
657     private NetworkInterface defaultNetworkInterface() throws SocketException {
658         NetworkInterface ni = outgoingNetworkInterface();
659         if (ni == null)
660             ni = NetworkInterfaces.getDefault();   // macOS
661         if (ni == null)
662             ni = anyNetworkInterface();
663         return ni;
664     }
665 
666     /**
667      * Returns the placeholder for &quot;any network interface&quot;, its index is 0.
668      */
669     private NetworkInterface anyNetworkInterface() {
670         InetAddress[] addrs = new InetAddress[1];
671         addrs[0] = anyInetAddress();
672         return NetworkInterfaces.newNetworkInterface(addrs[0].getHostName(), 0, addrs);
673     }
674 
675     /**
676      * Returns the InetAddress representing anyLocalAddress.
677      */
678     private InetAddress anyInetAddress() {
679         return new InetSocketAddress(0).getAddress();
680     }
681 
682     /**
683      * Defines static methods to get/set DatagramPacket fields and workaround
684      * DatagramPacket deficiencies.
685      */
686     private static class DatagramPackets {
687         private static final VarHandle LENGTH;
688         private static final VarHandle BUF_LENGTH;
689         static {
690             try {
691                 PrivilegedExceptionAction&lt;Lookup&gt; pa = () -&gt;
692                     MethodHandles.privateLookupIn(DatagramPacket.class, MethodHandles.lookup());
693                 MethodHandles.Lookup l = AccessController.doPrivileged(pa);
694                 LENGTH = l.findVarHandle(DatagramPacket.class, &quot;length&quot;, int.class);
695                 BUF_LENGTH = l.findVarHandle(DatagramPacket.class, &quot;bufLength&quot;, int.class);
696             } catch (Exception e) {
697                 throw new ExceptionInInitializerError(e);
698             }
699         }
700 
701         /**
702          * Sets the DatagramPacket.length field. DatagramPacket.setLength cannot be
703          * used at this time because it sets both the length and bufLength fields.
704          */
705         static void setLength(DatagramPacket p, int value) {
706             synchronized (p) {
707                 LENGTH.set(p, value);
708             }
709         }
710 
711         /**
712          * Returns the value of the DatagramPacket.bufLength field.
713          */
714         static int getBufLength(DatagramPacket p) {
715             synchronized (p) {
716                 return (int) BUF_LENGTH.get(p);
717             }
718         }
719     }
720 
721     /**
722      * Defines static methods to invoke non-public NetworkInterface methods.
723      */
724     private static class NetworkInterfaces {
725         static final MethodHandle GET_DEFAULT;
726         static final MethodHandle CONSTRUCTOR;
727         static {
728             try {
729                 PrivilegedExceptionAction&lt;Lookup&gt; pa = () -&gt;
730                     MethodHandles.privateLookupIn(NetworkInterface.class, MethodHandles.lookup());
731                 MethodHandles.Lookup l = AccessController.doPrivileged(pa);
732                 MethodType methodType = MethodType.methodType(NetworkInterface.class);
733                 GET_DEFAULT = l.findStatic(NetworkInterface.class, &quot;getDefault&quot;, methodType);
734                 methodType = MethodType.methodType(void.class, String.class, int.class, InetAddress[].class);
735                 CONSTRUCTOR = l.findConstructor(NetworkInterface.class, methodType);
736             } catch (Exception e) {
737                 throw new ExceptionInInitializerError(e);
738             }
739         }
740 
741         /**
742          * Returns the default network interface or null.
743          */
744         static NetworkInterface getDefault() {
745             try {
746                 return (NetworkInterface) GET_DEFAULT.invokeExact();
747             } catch (Throwable e) {
748                 throw new InternalError(e);
749             }
750         }
751 
752         /**
753          * Creates a NetworkInterface with the given name index and addresses.
754          */
755         static NetworkInterface newNetworkInterface(String name, int index, InetAddress[] addrs) {
756             try {
757                 return (NetworkInterface) CONSTRUCTOR.invoke(name, index, addrs);
758             } catch (Throwable e) {
759                 throw new InternalError(e);
760             }
761         }
762     }
763 }
    </pre>
  </body>
</html>
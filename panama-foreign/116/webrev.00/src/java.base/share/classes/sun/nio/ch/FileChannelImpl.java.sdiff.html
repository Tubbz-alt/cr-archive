<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DatagramSocketAdaptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../security/jca/ProviderConfig.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.io.UncheckedIOException;
  31 import java.lang.ref.Cleaner.Cleanable;
  32 import java.nio.ByteBuffer;
  33 import java.nio.MappedByteBuffer;
  34 import java.nio.channels.AsynchronousCloseException;
  35 import java.nio.channels.ClosedByInterruptException;
  36 import java.nio.channels.ClosedChannelException;
  37 import java.nio.channels.FileChannel;
  38 import java.nio.channels.FileLock;
  39 import java.nio.channels.FileLockInterruptionException;
  40 import java.nio.channels.NonReadableChannelException;
  41 import java.nio.channels.NonWritableChannelException;
  42 import java.nio.channels.ReadableByteChannel;
  43 import java.nio.channels.SelectableChannel;
  44 import java.nio.channels.WritableByteChannel;
  45 import java.util.Objects;
  46 
  47 import jdk.internal.access.JavaIOFileDescriptorAccess;
<span class="line-removed">  48 import jdk.internal.access.JavaNioAccess;</span>
  49 import jdk.internal.access.SharedSecrets;
  50 import jdk.internal.misc.ExtendedMapMode;
  51 import jdk.internal.misc.Unsafe;
  52 import jdk.internal.misc.VM;

  53 import jdk.internal.ref.Cleaner;
  54 import jdk.internal.ref.CleanerFactory;
  55 
  56 import jdk.internal.access.foreign.UnmapperProxy;
  57 
  58 public class FileChannelImpl
  59     extends FileChannel
  60 {
  61     // Memory allocation size for mapping buffers
  62     private static final long allocationGranularity;
  63 
  64     // Access to FileDescriptor internals
  65     private static final JavaIOFileDescriptorAccess fdAccess =
  66         SharedSecrets.getJavaIOFileDescriptorAccess();
  67 
  68     // Used to make native read and write calls
  69     private final FileDispatcher nd;
  70 
  71     // File descriptor
  72     private final FileDescriptor fd;
</pre>
<hr />
<pre>
 223             try {
 224                 beginBlocking();
 225                 ti = threads.add();
 226                 if (!isOpen())
 227                     return 0;
 228                 do {
 229                     n = IOUtil.read(fd, dst, -1, direct, alignment, nd);
 230                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 231                 return IOStatus.normalize(n);
 232             } finally {
 233                 threads.remove(ti);
 234                 endBlocking(n &gt; 0);
 235                 assert IOStatus.check(n);
 236             }
 237         }
 238     }
 239 
 240     public long read(ByteBuffer[] dsts, int offset, int length)
 241         throws IOException
 242     {
<span class="line-modified"> 243         if ((offset &lt; 0) || (length &lt; 0) || (offset &gt; dsts.length - length))</span>
<span class="line-removed"> 244             throw new IndexOutOfBoundsException();</span>
 245         ensureOpen();
 246         if (!readable)
 247             throw new NonReadableChannelException();
 248         synchronized (positionLock) {
 249             if (direct)
 250                 Util.checkChannelPositionAligned(position(), alignment);
 251             long n = 0;
 252             int ti = -1;
 253             try {
 254                 beginBlocking();
 255                 ti = threads.add();
 256                 if (!isOpen())
 257                     return 0;
 258                 do {
 259                     n = IOUtil.read(fd, dsts, offset, length,
 260                             direct, alignment, nd);
 261                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 262                 return IOStatus.normalize(n);
 263             } finally {
 264                 threads.remove(ti);
</pre>
<hr />
<pre>
 280             try {
 281                 beginBlocking();
 282                 ti = threads.add();
 283                 if (!isOpen())
 284                     return 0;
 285                 do {
 286                     n = IOUtil.write(fd, src, -1, direct, alignment, nd);
 287                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 288                 return IOStatus.normalize(n);
 289             } finally {
 290                 threads.remove(ti);
 291                 endBlocking(n &gt; 0);
 292                 assert IOStatus.check(n);
 293             }
 294         }
 295     }
 296 
 297     public long write(ByteBuffer[] srcs, int offset, int length)
 298         throws IOException
 299     {
<span class="line-modified"> 300         if ((offset &lt; 0) || (length &lt; 0) || (offset &gt; srcs.length - length))</span>
<span class="line-removed"> 301             throw new IndexOutOfBoundsException();</span>
 302         ensureOpen();
 303         if (!writable)
 304             throw new NonWritableChannelException();
 305         synchronized (positionLock) {
 306             if (direct)
 307                 Util.checkChannelPositionAligned(position(), alignment);
 308             long n = 0;
 309             int ti = -1;
 310             try {
 311                 beginBlocking();
 312                 ti = threads.add();
 313                 if (!isOpen())
 314                     return 0;
 315                 do {
 316                     n = IOUtil.write(fd, srcs, offset, length,
 317                             direct, alignment, nd);
 318                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 319                 return IOStatus.normalize(n);
 320             } finally {
 321                 threads.remove(ti);
</pre>
<hr />
<pre>
 772         if (!src.isOpen())
 773             throw new ClosedChannelException();
 774         if (!writable)
 775             throw new NonWritableChannelException();
 776         if ((position &lt; 0) || (count &lt; 0))
 777             throw new IllegalArgumentException();
 778         if (position &gt; size())
 779             return 0;
 780         if (src instanceof FileChannelImpl)
 781            return transferFromFileChannel((FileChannelImpl)src,
 782                                           position, count);
 783 
 784         return transferFromArbitraryChannel(src, position, count);
 785     }
 786 
 787     public int read(ByteBuffer dst, long position) throws IOException {
 788         if (dst == null)
 789             throw new NullPointerException();
 790         if (position &lt; 0)
 791             throw new IllegalArgumentException(&quot;Negative position&quot;);

 792         if (!readable)
 793             throw new NonReadableChannelException();
 794         if (direct)
 795             Util.checkChannelPositionAligned(position, alignment);
<span class="line-removed"> 796         ensureOpen();</span>
 797         if (nd.needsPositionLock()) {
 798             synchronized (positionLock) {
 799                 return readInternal(dst, position);
 800             }
 801         } else {
 802             return readInternal(dst, position);
 803         }
 804     }
 805 
 806     private int readInternal(ByteBuffer dst, long position) throws IOException {
 807         assert !nd.needsPositionLock() || Thread.holdsLock(positionLock);
 808         int n = 0;
 809         int ti = -1;
 810 
 811         try {
 812             beginBlocking();
 813             ti = threads.add();
 814             if (!isOpen())
 815                 return -1;
 816             do {
 817                 n = IOUtil.read(fd, dst, position, direct, alignment, nd);
 818             } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 819             return IOStatus.normalize(n);
 820         } finally {
 821             threads.remove(ti);
 822             endBlocking(n &gt; 0);
 823             assert IOStatus.check(n);
 824         }
 825     }
 826 
 827     public int write(ByteBuffer src, long position) throws IOException {
 828         if (src == null)
 829             throw new NullPointerException();
 830         if (position &lt; 0)
 831             throw new IllegalArgumentException(&quot;Negative position&quot;);

 832         if (!writable)
 833             throw new NonWritableChannelException();
 834         if (direct)
 835             Util.checkChannelPositionAligned(position, alignment);
<span class="line-removed"> 836         ensureOpen();</span>
 837         if (nd.needsPositionLock()) {
 838             synchronized (positionLock) {
 839                 return writeInternal(src, position);
 840             }
 841         } else {
 842             return writeInternal(src, position);
 843         }
 844     }
 845 
 846     private int writeInternal(ByteBuffer src, long position) throws IOException {
 847         assert !nd.needsPositionLock() || Thread.holdsLock(positionLock);
 848         int n = 0;
 849         int ti = -1;
 850         try {
 851             beginBlocking();
 852             ti = threads.add();
 853             if (!isOpen())
 854                 return -1;
 855             do {
 856                 n = IOUtil.write(fd, src, position, direct, alignment, nd);
</pre>
<hr />
<pre>
1156     }
1157 
1158     private void checkMode(MapMode mode, int prot, boolean isSync) {
1159         if (prot == MAP_INVALID) {
1160             throw new UnsupportedOperationException();
1161         }
1162         if ((mode != MapMode.READ_ONLY) &amp;&amp; mode != ExtendedMapMode.READ_ONLY_SYNC &amp;&amp; !writable)
1163             throw new NonWritableChannelException();
1164         if (!readable)
1165             throw new NonReadableChannelException();
1166         // reject SYNC request if writeback is not enabled for this platform
1167         if (isSync &amp;&amp; !Unsafe.isWritebackEnabled()) {
1168             throw new UnsupportedOperationException();
1169         }
1170     }
1171 
1172     /**
1173      * Invoked by sun.management.ManagementFactoryHelper to create the management
1174      * interface for mapped buffers.
1175      */
<span class="line-modified">1176     public static JavaNioAccess.BufferPool getMappedBufferPool() {</span>
<span class="line-modified">1177         return new JavaNioAccess.BufferPool() {</span>
1178             @Override
1179             public String getName() {
1180                 return &quot;mapped&quot;;
1181             }
1182             @Override
1183             public long getCount() {
1184                 return DefaultUnmapper.count;
1185             }
1186             @Override
1187             public long getTotalCapacity() {
1188                 return DefaultUnmapper.totalCapacity;
1189             }
1190             @Override
1191             public long getMemoryUsed() {
1192                 return DefaultUnmapper.totalSize;
1193             }
1194         };
1195     }
1196 
1197     /**
1198      * Invoked by sun.management.ManagementFactoryHelper to create the management
1199      * interface for sync mapped buffers.
1200      */
<span class="line-modified">1201     public static JavaNioAccess.BufferPool getSyncMappedBufferPool() {</span>
<span class="line-modified">1202         return new JavaNioAccess.BufferPool() {</span>
1203             @Override
1204             public String getName() {
1205                 return &quot;mapped - &#39;non-volatile memory&#39;&quot;;
1206             }
1207             @Override
1208             public long getCount() {
1209                 return SyncUnmapper.count;
1210             }
1211             @Override
1212             public long getTotalCapacity() {
1213                 return SyncUnmapper.totalCapacity;
1214             }
1215             @Override
1216             public long getMemoryUsed() {
1217                 return SyncUnmapper.totalSize;
1218             }
1219         };
1220     }
1221 
1222     // -- Locks --
</pre>
</td>
<td>
<hr />
<pre>
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.io.UncheckedIOException;
  31 import java.lang.ref.Cleaner.Cleanable;
  32 import java.nio.ByteBuffer;
  33 import java.nio.MappedByteBuffer;
  34 import java.nio.channels.AsynchronousCloseException;
  35 import java.nio.channels.ClosedByInterruptException;
  36 import java.nio.channels.ClosedChannelException;
  37 import java.nio.channels.FileChannel;
  38 import java.nio.channels.FileLock;
  39 import java.nio.channels.FileLockInterruptionException;
  40 import java.nio.channels.NonReadableChannelException;
  41 import java.nio.channels.NonWritableChannelException;
  42 import java.nio.channels.ReadableByteChannel;
  43 import java.nio.channels.SelectableChannel;
  44 import java.nio.channels.WritableByteChannel;
  45 import java.util.Objects;
  46 
  47 import jdk.internal.access.JavaIOFileDescriptorAccess;

  48 import jdk.internal.access.SharedSecrets;
  49 import jdk.internal.misc.ExtendedMapMode;
  50 import jdk.internal.misc.Unsafe;
  51 import jdk.internal.misc.VM;
<span class="line-added">  52 import jdk.internal.misc.VM.BufferPool;</span>
  53 import jdk.internal.ref.Cleaner;
  54 import jdk.internal.ref.CleanerFactory;
  55 
  56 import jdk.internal.access.foreign.UnmapperProxy;
  57 
  58 public class FileChannelImpl
  59     extends FileChannel
  60 {
  61     // Memory allocation size for mapping buffers
  62     private static final long allocationGranularity;
  63 
  64     // Access to FileDescriptor internals
  65     private static final JavaIOFileDescriptorAccess fdAccess =
  66         SharedSecrets.getJavaIOFileDescriptorAccess();
  67 
  68     // Used to make native read and write calls
  69     private final FileDispatcher nd;
  70 
  71     // File descriptor
  72     private final FileDescriptor fd;
</pre>
<hr />
<pre>
 223             try {
 224                 beginBlocking();
 225                 ti = threads.add();
 226                 if (!isOpen())
 227                     return 0;
 228                 do {
 229                     n = IOUtil.read(fd, dst, -1, direct, alignment, nd);
 230                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 231                 return IOStatus.normalize(n);
 232             } finally {
 233                 threads.remove(ti);
 234                 endBlocking(n &gt; 0);
 235                 assert IOStatus.check(n);
 236             }
 237         }
 238     }
 239 
 240     public long read(ByteBuffer[] dsts, int offset, int length)
 241         throws IOException
 242     {
<span class="line-modified"> 243         Objects.checkFromIndexSize(offset, length, dsts.length);</span>

 244         ensureOpen();
 245         if (!readable)
 246             throw new NonReadableChannelException();
 247         synchronized (positionLock) {
 248             if (direct)
 249                 Util.checkChannelPositionAligned(position(), alignment);
 250             long n = 0;
 251             int ti = -1;
 252             try {
 253                 beginBlocking();
 254                 ti = threads.add();
 255                 if (!isOpen())
 256                     return 0;
 257                 do {
 258                     n = IOUtil.read(fd, dsts, offset, length,
 259                             direct, alignment, nd);
 260                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 261                 return IOStatus.normalize(n);
 262             } finally {
 263                 threads.remove(ti);
</pre>
<hr />
<pre>
 279             try {
 280                 beginBlocking();
 281                 ti = threads.add();
 282                 if (!isOpen())
 283                     return 0;
 284                 do {
 285                     n = IOUtil.write(fd, src, -1, direct, alignment, nd);
 286                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 287                 return IOStatus.normalize(n);
 288             } finally {
 289                 threads.remove(ti);
 290                 endBlocking(n &gt; 0);
 291                 assert IOStatus.check(n);
 292             }
 293         }
 294     }
 295 
 296     public long write(ByteBuffer[] srcs, int offset, int length)
 297         throws IOException
 298     {
<span class="line-modified"> 299         Objects.checkFromIndexSize(offset, length, srcs.length);</span>

 300         ensureOpen();
 301         if (!writable)
 302             throw new NonWritableChannelException();
 303         synchronized (positionLock) {
 304             if (direct)
 305                 Util.checkChannelPositionAligned(position(), alignment);
 306             long n = 0;
 307             int ti = -1;
 308             try {
 309                 beginBlocking();
 310                 ti = threads.add();
 311                 if (!isOpen())
 312                     return 0;
 313                 do {
 314                     n = IOUtil.write(fd, srcs, offset, length,
 315                             direct, alignment, nd);
 316                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 317                 return IOStatus.normalize(n);
 318             } finally {
 319                 threads.remove(ti);
</pre>
<hr />
<pre>
 770         if (!src.isOpen())
 771             throw new ClosedChannelException();
 772         if (!writable)
 773             throw new NonWritableChannelException();
 774         if ((position &lt; 0) || (count &lt; 0))
 775             throw new IllegalArgumentException();
 776         if (position &gt; size())
 777             return 0;
 778         if (src instanceof FileChannelImpl)
 779            return transferFromFileChannel((FileChannelImpl)src,
 780                                           position, count);
 781 
 782         return transferFromArbitraryChannel(src, position, count);
 783     }
 784 
 785     public int read(ByteBuffer dst, long position) throws IOException {
 786         if (dst == null)
 787             throw new NullPointerException();
 788         if (position &lt; 0)
 789             throw new IllegalArgumentException(&quot;Negative position&quot;);
<span class="line-added"> 790         ensureOpen();</span>
 791         if (!readable)
 792             throw new NonReadableChannelException();
 793         if (direct)
 794             Util.checkChannelPositionAligned(position, alignment);

 795         if (nd.needsPositionLock()) {
 796             synchronized (positionLock) {
 797                 return readInternal(dst, position);
 798             }
 799         } else {
 800             return readInternal(dst, position);
 801         }
 802     }
 803 
 804     private int readInternal(ByteBuffer dst, long position) throws IOException {
 805         assert !nd.needsPositionLock() || Thread.holdsLock(positionLock);
 806         int n = 0;
 807         int ti = -1;
 808 
 809         try {
 810             beginBlocking();
 811             ti = threads.add();
 812             if (!isOpen())
 813                 return -1;
 814             do {
 815                 n = IOUtil.read(fd, dst, position, direct, alignment, nd);
 816             } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 817             return IOStatus.normalize(n);
 818         } finally {
 819             threads.remove(ti);
 820             endBlocking(n &gt; 0);
 821             assert IOStatus.check(n);
 822         }
 823     }
 824 
 825     public int write(ByteBuffer src, long position) throws IOException {
 826         if (src == null)
 827             throw new NullPointerException();
 828         if (position &lt; 0)
 829             throw new IllegalArgumentException(&quot;Negative position&quot;);
<span class="line-added"> 830         ensureOpen();</span>
 831         if (!writable)
 832             throw new NonWritableChannelException();
 833         if (direct)
 834             Util.checkChannelPositionAligned(position, alignment);

 835         if (nd.needsPositionLock()) {
 836             synchronized (positionLock) {
 837                 return writeInternal(src, position);
 838             }
 839         } else {
 840             return writeInternal(src, position);
 841         }
 842     }
 843 
 844     private int writeInternal(ByteBuffer src, long position) throws IOException {
 845         assert !nd.needsPositionLock() || Thread.holdsLock(positionLock);
 846         int n = 0;
 847         int ti = -1;
 848         try {
 849             beginBlocking();
 850             ti = threads.add();
 851             if (!isOpen())
 852                 return -1;
 853             do {
 854                 n = IOUtil.write(fd, src, position, direct, alignment, nd);
</pre>
<hr />
<pre>
1154     }
1155 
1156     private void checkMode(MapMode mode, int prot, boolean isSync) {
1157         if (prot == MAP_INVALID) {
1158             throw new UnsupportedOperationException();
1159         }
1160         if ((mode != MapMode.READ_ONLY) &amp;&amp; mode != ExtendedMapMode.READ_ONLY_SYNC &amp;&amp; !writable)
1161             throw new NonWritableChannelException();
1162         if (!readable)
1163             throw new NonReadableChannelException();
1164         // reject SYNC request if writeback is not enabled for this platform
1165         if (isSync &amp;&amp; !Unsafe.isWritebackEnabled()) {
1166             throw new UnsupportedOperationException();
1167         }
1168     }
1169 
1170     /**
1171      * Invoked by sun.management.ManagementFactoryHelper to create the management
1172      * interface for mapped buffers.
1173      */
<span class="line-modified">1174     public static BufferPool getMappedBufferPool() {</span>
<span class="line-modified">1175         return new BufferPool() {</span>
1176             @Override
1177             public String getName() {
1178                 return &quot;mapped&quot;;
1179             }
1180             @Override
1181             public long getCount() {
1182                 return DefaultUnmapper.count;
1183             }
1184             @Override
1185             public long getTotalCapacity() {
1186                 return DefaultUnmapper.totalCapacity;
1187             }
1188             @Override
1189             public long getMemoryUsed() {
1190                 return DefaultUnmapper.totalSize;
1191             }
1192         };
1193     }
1194 
1195     /**
1196      * Invoked by sun.management.ManagementFactoryHelper to create the management
1197      * interface for sync mapped buffers.
1198      */
<span class="line-modified">1199     public static BufferPool getSyncMappedBufferPool() {</span>
<span class="line-modified">1200         return new BufferPool() {</span>
1201             @Override
1202             public String getName() {
1203                 return &quot;mapped - &#39;non-volatile memory&#39;&quot;;
1204             }
1205             @Override
1206             public long getCount() {
1207                 return SyncUnmapper.count;
1208             }
1209             @Override
1210             public long getTotalCapacity() {
1211                 return SyncUnmapper.totalCapacity;
1212             }
1213             @Override
1214             public long getMemoryUsed() {
1215                 return SyncUnmapper.totalSize;
1216             }
1217         };
1218     }
1219 
1220     // -- Locks --
</pre>
</td>
</tr>
</table>
<center><a href="DatagramSocketAdaptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../security/jca/ProviderConfig.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
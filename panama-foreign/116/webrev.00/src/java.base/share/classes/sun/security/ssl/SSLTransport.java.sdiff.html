<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SSLTransport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SessionTicketExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLTransport.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
156                 // Only happens for DTLS protocols.
157                 //
158                 // Received a retransmitted flight, and need to retransmit the
159                 // previous delivered handshake flight messages.
160                 if (context.handshakeContext != null &amp;&amp;
161                     context.handshakeContext.sslConfig.enableRetransmissions &amp;&amp;
162                     context.sslContext.isDTLS()) {
163                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,verbose&quot;)) {
164                         SSLLogger.finest(&quot;retransmited handshake flight&quot;);
165                     }
166 
167                     context.outputRecord.launchRetransmission();
168                 }   // Otherwise, discard the retransmitted flight.
169             } else if (plainText != null &amp;&amp;
170                     plainText.contentType != ContentType.APPLICATION_DATA.id) {
171                 context.dispatch(plainText);
172             }
173 
174             if (plainText == null) {
175                 plainText = Plaintext.PLAINTEXT_NULL;
<span class="line-modified">176             } else {</span>
<span class="line-modified">177                 // Fill the destination buffers.</span>
<span class="line-modified">178                 if ((dsts != null) &amp;&amp; (dstsLength &gt; 0) &amp;&amp;</span>
<span class="line-modified">179                         (plainText.contentType ==</span>
<span class="line-modified">180                             ContentType.APPLICATION_DATA.id)) {</span>






181 






182                     ByteBuffer fragment = plainText.fragment;
183                     int remains = fragment.remaining();
184 
185                     // Should have enough room in the destination buffers.
186                     int limit = dstsOffset + dstsLength;
187                     for (int i = dstsOffset;
188                             ((i &lt; limit) &amp;&amp; (remains &gt; 0)); i++) {
189 
190                         int amount = Math.min(dsts[i].remaining(), remains);
191                         fragment.limit(fragment.position() + amount);
192                         dsts[i].put(fragment);
193                         remains -= amount;
194 
195                         if (!dsts[i].hasRemaining()) {
196                             dstsOffset++;
197                         }
198                     }
199 
200                     if (remains &gt; 0) {
201                         throw context.fatal(Alert.INTERNAL_ERROR,
</pre>
</td>
<td>
<hr />
<pre>
156                 // Only happens for DTLS protocols.
157                 //
158                 // Received a retransmitted flight, and need to retransmit the
159                 // previous delivered handshake flight messages.
160                 if (context.handshakeContext != null &amp;&amp;
161                     context.handshakeContext.sslConfig.enableRetransmissions &amp;&amp;
162                     context.sslContext.isDTLS()) {
163                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,verbose&quot;)) {
164                         SSLLogger.finest(&quot;retransmited handshake flight&quot;);
165                     }
166 
167                     context.outputRecord.launchRetransmission();
168                 }   // Otherwise, discard the retransmitted flight.
169             } else if (plainText != null &amp;&amp;
170                     plainText.contentType != ContentType.APPLICATION_DATA.id) {
171                 context.dispatch(plainText);
172             }
173 
174             if (plainText == null) {
175                 plainText = Plaintext.PLAINTEXT_NULL;
<span class="line-modified">176             } else if (plainText.contentType ==</span>
<span class="line-modified">177                             ContentType.APPLICATION_DATA.id) {</span>
<span class="line-modified">178                 // check handshake status</span>
<span class="line-modified">179                 //</span>
<span class="line-modified">180                 // Note that JDK does not support 0-RTT yet.  Otherwise, it is</span>
<span class="line-added">181                 // needed to check early_data.</span>
<span class="line-added">182                 if (!context.isNegotiated) {</span>
<span class="line-added">183                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,verbose&quot;)) {</span>
<span class="line-added">184                         SSLLogger.warning(&quot;unexpected application data &quot; +</span>
<span class="line-added">185                             &quot;before handshake completion&quot;);</span>
<span class="line-added">186                     }</span>
187 
<span class="line-added">188                     throw context.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-added">189                         &quot;Receiving application data before handshake complete&quot;);</span>
<span class="line-added">190                 }</span>
<span class="line-added">191 </span>
<span class="line-added">192                 // Fill the destination buffers.</span>
<span class="line-added">193                 if ((dsts != null) &amp;&amp; (dstsLength &gt; 0)) {</span>
194                     ByteBuffer fragment = plainText.fragment;
195                     int remains = fragment.remaining();
196 
197                     // Should have enough room in the destination buffers.
198                     int limit = dstsOffset + dstsLength;
199                     for (int i = dstsOffset;
200                             ((i &lt; limit) &amp;&amp; (remains &gt; 0)); i++) {
201 
202                         int amount = Math.min(dsts[i].remaining(), remains);
203                         fragment.limit(fragment.position() + amount);
204                         dsts[i].put(fragment);
205                         remains -= amount;
206 
207                         if (!dsts[i].hasRemaining()) {
208                             dstsOffset++;
209                         }
210                     }
211 
212                     if (remains &gt; 0) {
213                         throw context.fatal(Alert.INTERNAL_ERROR,
</pre>
</td>
</tr>
</table>
<center><a href="SSLSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SessionTicketExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
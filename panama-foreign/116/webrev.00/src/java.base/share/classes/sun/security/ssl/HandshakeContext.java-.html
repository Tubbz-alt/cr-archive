<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/HandshakeContext.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.BufferOverflowException;
 30 import java.nio.BufferUnderflowException;
 31 import java.nio.ByteBuffer;
 32 import java.security.AlgorithmConstraints;
 33 import java.security.CryptoPrimitive;
 34 import java.util.AbstractMap.SimpleImmutableEntry;
 35 import java.util.ArrayList;
 36 import java.util.Collections;
 37 import java.util.EnumMap;
 38 import java.util.EnumSet;
 39 import java.util.HashMap;
 40 import java.util.LinkedHashMap;
 41 import java.util.LinkedList;
 42 import java.util.List;
 43 import java.util.Map;
 44 import java.util.Queue;
 45 import javax.crypto.SecretKey;
 46 import javax.net.ssl.SNIServerName;
 47 import javax.net.ssl.SSLHandshakeException;
 48 import javax.security.auth.x500.X500Principal;
 49 import sun.security.ssl.NamedGroup.NamedGroupSpec;
 50 import static sun.security.ssl.NamedGroup.NamedGroupSpec.*;
 51 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 52 
 53 abstract class HandshakeContext implements ConnectionContext {
 54     // System properties
 55 
 56     // By default, disable the unsafe legacy session renegotiation.
 57     static final boolean allowUnsafeRenegotiation =
 58             Utilities.getBooleanProperty(
 59                     &quot;sun.security.ssl.allowUnsafeRenegotiation&quot;, false);
 60 
 61     // For maximum interoperability and backward compatibility, RFC 5746
 62     // allows server (or client) to accept ClientHello (or ServerHello)
 63     // message without the secure renegotiation_info extension or SCSV.
 64     //
 65     // For maximum security, RFC 5746 also allows server (or client) to
 66     // reject such message with a fatal &quot;handshake_failure&quot; alert.
 67     //
 68     // By default, allow such legacy hello messages.
 69     static final boolean allowLegacyHelloMessages =
 70             Utilities.getBooleanProperty(
 71                     &quot;sun.security.ssl.allowLegacyHelloMessages&quot;, true);
 72 
 73     // registered handshake message actors
 74     LinkedHashMap&lt;Byte, SSLConsumer&gt;  handshakeConsumers;
 75     final HashMap&lt;Byte, HandshakeProducer&gt;  handshakeProducers;
 76 
 77     // context
 78     final SSLContextImpl                    sslContext;
 79     final TransportContext                  conContext;
 80     final SSLConfiguration                  sslConfig;
 81 
 82     // consolidated parameters
 83     final List&lt;ProtocolVersion&gt;             activeProtocols;
 84     final List&lt;CipherSuite&gt;                 activeCipherSuites;
 85     final AlgorithmConstraints              algorithmConstraints;
 86     final ProtocolVersion                   maximumActiveProtocol;
 87 
 88     // output stream
 89     final HandshakeOutStream                handshakeOutput;
 90 
 91     // handshake transcript hash
 92     final HandshakeHash                     handshakeHash;
 93 
 94     // negotiated security parameters
 95     SSLSessionImpl                          handshakeSession;
 96     boolean                                 handshakeFinished;
 97     // boolean                                 isInvalidated;
 98 
 99     boolean                                 kickstartMessageDelivered;
100 
101     // Resumption
102     boolean                                 isResumption;
103     SSLSessionImpl                          resumingSession;
104     // Session is using stateless resumption
105     boolean                                 statelessResumption = false;
106 
107     final Queue&lt;Map.Entry&lt;Byte, ByteBuffer&gt;&gt; delegatedActions;
108     volatile boolean                        taskDelegated = false;
109     volatile Exception                      delegatedThrown = null;
110 
111     ProtocolVersion                         negotiatedProtocol;
112     CipherSuite                             negotiatedCipherSuite;
113     final List&lt;SSLPossession&gt;               handshakePossessions;
114     final List&lt;SSLCredentials&gt;              handshakeCredentials;
115     SSLKeyDerivation                        handshakeKeyDerivation;
116     SSLKeyExchange                          handshakeKeyExchange;
117     SecretKey                               baseReadSecret;
118     SecretKey                               baseWriteSecret;
119 
120     // protocol version being established
121     int                                     clientHelloVersion;
122     String                                  applicationProtocol;
123 
124     RandomCookie                            clientHelloRandom;
125     RandomCookie                            serverHelloRandom;
126     byte[]                                  certRequestContext;
127 
128     ////////////////////
129     // Extensions
130 
131     // the extensions used in the handshake
132     final Map&lt;SSLExtension, SSLExtension.SSLExtensionSpec&gt;
133                                             handshakeExtensions;
134 
135     // MaxFragmentLength
136     int                                     maxFragmentLength;
137 
138     // SignatureScheme
139     List&lt;SignatureScheme&gt;                   localSupportedSignAlgs;
140     List&lt;SignatureScheme&gt;                   peerRequestedSignatureSchemes;
141     List&lt;SignatureScheme&gt;                   peerRequestedCertSignSchemes;
142 
143     // Known authorities
144     X500Principal[]                         peerSupportedAuthorities = null;
145 
146     // SupportedGroups
147     List&lt;NamedGroup&gt;                        clientRequestedNamedGroups;
148 
149     // HelloRetryRequest
150     NamedGroup                              serverSelectedNamedGroup;
151 
152     // if server name indicator is negotiated
153     //
154     // May need a public API for the indication in the future.
155     List&lt;SNIServerName&gt;                     requestedServerNames;
156     SNIServerName                           negotiatedServerName;
157 
158     // OCSP Stapling info
159     boolean                                 staplingActive = false;
160 
161     protected HandshakeContext(SSLContextImpl sslContext,
162             TransportContext conContext) throws IOException {
163         this.sslContext = sslContext;
164         this.conContext = conContext;
165         this.sslConfig = (SSLConfiguration)conContext.sslConfig.clone();
166 
167         this.activeProtocols = getActiveProtocols(sslConfig.enabledProtocols,
168                 sslConfig.enabledCipherSuites, sslConfig.algorithmConstraints);
169         if (activeProtocols.isEmpty()) {
170             throw new SSLHandshakeException(
171                 &quot;No appropriate protocol (protocol is disabled or &quot; +
172                 &quot;cipher suites are inappropriate)&quot;);
173         }
174 
175         ProtocolVersion maximumVersion = ProtocolVersion.NONE;
176         for (ProtocolVersion pv : this.activeProtocols) {
177             if (maximumVersion == ProtocolVersion.NONE ||
178                     pv.compare(maximumVersion) &gt; 0) {
179                 maximumVersion = pv;
180             }
181         }
182         this.maximumActiveProtocol = maximumVersion;
183         this.activeCipherSuites = getActiveCipherSuites(this.activeProtocols,
184                 sslConfig.enabledCipherSuites, sslConfig.algorithmConstraints);
185         if (activeCipherSuites.isEmpty()) {
186             throw new SSLHandshakeException(&quot;No appropriate cipher suite&quot;);
187         }
188         this.algorithmConstraints =
189                 new SSLAlgorithmConstraints(sslConfig.algorithmConstraints);
190 
191         this.handshakeConsumers = new LinkedHashMap&lt;&gt;();
192         this.handshakeProducers = new HashMap&lt;&gt;();
193         this.handshakeHash = conContext.inputRecord.handshakeHash;
194         this.handshakeOutput = new HandshakeOutStream(conContext.outputRecord);
195 
196         this.handshakeFinished = false;
197         this.kickstartMessageDelivered = false;
198 
199         this.delegatedActions = new LinkedList&lt;&gt;();
200         this.handshakeExtensions = new HashMap&lt;&gt;();
201         this.handshakePossessions = new LinkedList&lt;&gt;();
202         this.handshakeCredentials = new LinkedList&lt;&gt;();
203         this.requestedServerNames = null;
204         this.negotiatedServerName = null;
205         this.negotiatedCipherSuite = conContext.cipherSuite;
206         initialize();
207     }
208 
209     /**
210      * Constructor for PostHandshakeContext
211      */
212     HandshakeContext(TransportContext conContext) {
213         this.sslContext = conContext.sslContext;
214         this.conContext = conContext;
215         this.sslConfig = conContext.sslConfig;
216 
217         this.negotiatedProtocol = conContext.protocolVersion;
218         this.negotiatedCipherSuite = conContext.cipherSuite;
219         this.handshakeOutput = new HandshakeOutStream(conContext.outputRecord);
220         this.delegatedActions = new LinkedList&lt;&gt;();
221 
222         this.handshakeProducers = null;
223         this.handshakeHash = null;
224         this.activeProtocols = null;
225         this.activeCipherSuites = null;
226         this.algorithmConstraints = null;
227         this.maximumActiveProtocol = null;
228         this.handshakeExtensions = Collections.emptyMap();  // Not in TLS13
229         this.handshakePossessions = null;
230         this.handshakeCredentials = null;
231     }
232 
233     // Initialize the non-final class variables.
234     private void initialize() {
235         ProtocolVersion inputHelloVersion;
236         ProtocolVersion outputHelloVersion;
237         if (conContext.isNegotiated) {
238             inputHelloVersion = conContext.protocolVersion;
239             outputHelloVersion = conContext.protocolVersion;
240         } else {
241             if (activeProtocols.contains(ProtocolVersion.SSL20Hello)) {
242                 inputHelloVersion = ProtocolVersion.SSL20Hello;
243 
244                 // Per TLS 1.3 protocol, implementation MUST NOT send an SSL
245                 // version 2.0 compatible CLIENT-HELLO.
246                 if (maximumActiveProtocol.useTLS13PlusSpec()) {
247                     outputHelloVersion = maximumActiveProtocol;
248                 } else {
249                     outputHelloVersion = ProtocolVersion.SSL20Hello;
250                 }
251             } else {
252                 inputHelloVersion = maximumActiveProtocol;
253                 outputHelloVersion = maximumActiveProtocol;
254             }
255         }
256 
257         conContext.inputRecord.setHelloVersion(inputHelloVersion);
258         conContext.outputRecord.setHelloVersion(outputHelloVersion);
259 
260         if (!conContext.isNegotiated) {
261             conContext.protocolVersion = maximumActiveProtocol;
262         }
263         conContext.outputRecord.setVersion(conContext.protocolVersion);
264     }
265 
266     private static List&lt;ProtocolVersion&gt; getActiveProtocols(
267             List&lt;ProtocolVersion&gt; enabledProtocols,
268             List&lt;CipherSuite&gt; enabledCipherSuites,
269             AlgorithmConstraints algorithmConstraints) {
270         boolean enabledSSL20Hello = false;
271         ArrayList&lt;ProtocolVersion&gt; protocols = new ArrayList&lt;&gt;(4);
272         for (ProtocolVersion protocol : enabledProtocols) {
273             if (!enabledSSL20Hello &amp;&amp; protocol == ProtocolVersion.SSL20Hello) {
274                 enabledSSL20Hello = true;
275                 continue;
276             }
277 
278             if (!algorithmConstraints.permits(
279                     EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
280                     protocol.name, null)) {
281                 // Ignore disabled protocol.
282                 continue;
283             }
284 
285             boolean found = false;
286             Map&lt;NamedGroupSpec, Boolean&gt; cachedStatus =
287                     new EnumMap&lt;&gt;(NamedGroupSpec.class);
288             for (CipherSuite suite : enabledCipherSuites) {
289                 if (suite.isAvailable() &amp;&amp; suite.supports(protocol)) {
290                     if (isActivatable(suite,
291                             algorithmConstraints, cachedStatus)) {
292                         protocols.add(protocol);
293                         found = true;
294                         break;
295                     }
296                 } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
297                     SSLLogger.fine(
298                         &quot;Ignore unsupported cipher suite: &quot; + suite +
299                              &quot; for &quot; + protocol);
300                 }
301             }
302 
303             if (!found &amp;&amp; (SSLLogger.isOn) &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
304                 SSLLogger.fine(
305                     &quot;No available cipher suite for &quot; + protocol);
306             }
307         }
308 
309         if (!protocols.isEmpty()) {
310             if (enabledSSL20Hello) {
311                 protocols.add(ProtocolVersion.SSL20Hello);
312             }
313             Collections.sort(protocols);
314         }
315 
316         return Collections.unmodifiableList(protocols);
317     }
318 
319     private static List&lt;CipherSuite&gt; getActiveCipherSuites(
320             List&lt;ProtocolVersion&gt; enabledProtocols,
321             List&lt;CipherSuite&gt; enabledCipherSuites,
322             AlgorithmConstraints algorithmConstraints) {
323 
324         List&lt;CipherSuite&gt; suites = new LinkedList&lt;&gt;();
325         if (enabledProtocols != null &amp;&amp; !enabledProtocols.isEmpty()) {
326             Map&lt;NamedGroupSpec, Boolean&gt; cachedStatus =
327                     new EnumMap&lt;&gt;(NamedGroupSpec.class);
328             for (CipherSuite suite : enabledCipherSuites) {
329                 if (!suite.isAvailable()) {
330                     continue;
331                 }
332 
333                 boolean isSupported = false;
334                 for (ProtocolVersion protocol : enabledProtocols) {
335                     if (!suite.supports(protocol)) {
336                         continue;
337                     }
338                     if (isActivatable(suite,
339                             algorithmConstraints, cachedStatus)) {
340                         suites.add(suite);
341                         isSupported = true;
342                         break;
343                     }
344                 }
345 
346                 if (!isSupported &amp;&amp;
347                         SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
348                     SSLLogger.finest(
349                             &quot;Ignore unsupported cipher suite: &quot; + suite);
350                 }
351             }
352         }
353 
354         return Collections.unmodifiableList(suites);
355     }
356 
357     /**
358      * Parse the handshake record and return the contentType
359      */
360     static byte getHandshakeType(TransportContext conContext,
361             Plaintext plaintext) throws IOException {
362         //     struct {
363         //         HandshakeType msg_type;    /* handshake type */
364         //         uint24 length;             /* bytes in message */
365         //         select (HandshakeType) {
366         //             ...
367         //         } body;
368         //     } Handshake;
369 
370         if (plaintext.contentType != ContentType.HANDSHAKE.id) {
371             throw conContext.fatal(Alert.INTERNAL_ERROR,
372                 &quot;Unexpected operation for record: &quot; + plaintext.contentType);
373         }
374 
375         if (plaintext.fragment == null || plaintext.fragment.remaining() &lt; 4) {
376             throw conContext.fatal(Alert.UNEXPECTED_MESSAGE,
377                     &quot;Invalid handshake message: insufficient data&quot;);
378         }
379 
380         byte handshakeType = (byte)Record.getInt8(plaintext.fragment);
381         int handshakeLen = Record.getInt24(plaintext.fragment);
382         if (handshakeLen != plaintext.fragment.remaining()) {
383             throw conContext.fatal(Alert.UNEXPECTED_MESSAGE,
384                     &quot;Invalid handshake message: insufficient handshake body&quot;);
385         }
386 
387         return handshakeType;
388     }
389 
390     void dispatch(byte handshakeType, Plaintext plaintext) throws IOException {
391         if (conContext.transport.useDelegatedTask()) {
392             boolean hasDelegated = !delegatedActions.isEmpty();
393             if (hasDelegated ||
394                    (handshakeType != SSLHandshake.FINISHED.id &amp;&amp;
395                     handshakeType != SSLHandshake.KEY_UPDATE.id &amp;&amp;
396                     handshakeType != SSLHandshake.NEW_SESSION_TICKET.id)) {
397                 if (!hasDelegated) {
398                     taskDelegated = false;
399                     delegatedThrown = null;
400                 }
401 
402                 // Clone the fragment for delegated actions.
403                 //
404                 // The plaintext may share the application buffers.  It is
405                 // fine to use shared buffers if no delegated actions.
406                 // However, for delegated actions, the shared buffers may be
407                 // polluted in application layer before the delegated actions
408                 // executed.
409                 ByteBuffer fragment = ByteBuffer.wrap(
410                         new byte[plaintext.fragment.remaining()]);
411                 fragment.put(plaintext.fragment);
412                 fragment = fragment.rewind();
413 
414                 delegatedActions.add(new SimpleImmutableEntry&lt;&gt;(
415                         handshakeType,
416                         fragment
417                     ));
418             } else {
419                 dispatch(handshakeType, plaintext.fragment);
420             }
421         } else {
422             dispatch(handshakeType, plaintext.fragment);
423         }
424     }
425 
426     void dispatch(byte handshakeType,
427             ByteBuffer fragment) throws IOException {
428         SSLConsumer consumer;
429         if (handshakeType == SSLHandshake.HELLO_REQUEST.id) {
430             // For TLS 1.2 and prior versions, the HelloRequest message MAY
431             // be sent by the server at any time.
432             consumer = SSLHandshake.HELLO_REQUEST;
433         } else {
434             consumer = handshakeConsumers.get(handshakeType);
435         }
436 
437         if (consumer == null) {
438             throw conContext.fatal(Alert.UNEXPECTED_MESSAGE,
439                     &quot;Unexpected handshake message: &quot; +
440                     SSLHandshake.nameOf(handshakeType));
441         }
442 
443         try {
444             consumer.consume(this, fragment);
445         } catch (UnsupportedOperationException unsoe) {
446             throw conContext.fatal(Alert.UNEXPECTED_MESSAGE,
447                     &quot;Unsupported handshake message: &quot; +
448                     SSLHandshake.nameOf(handshakeType), unsoe);
449         } catch (BufferUnderflowException | BufferOverflowException be) {
450             throw conContext.fatal(Alert.DECODE_ERROR,
451                     &quot;Illegal handshake message: &quot; +
452                     SSLHandshake.nameOf(handshakeType), be);
453         }
454 
455         // update handshake hash after handshake message consumption.
456         handshakeHash.consume();
457     }
458 
459     abstract void kickstart() throws IOException;
460 
461     /**
462      * Check if the given cipher suite is enabled and available within
463      * the current active cipher suites.
464      *
465      * Does not check if the required server certificates are available.
466      */
467     boolean isNegotiable(CipherSuite cs) {
468         return isNegotiable(activeCipherSuites, cs);
469     }
470 
471     /**
472      * Check if the given cipher suite is enabled and available within
473      * the proposed cipher suite list.
474      *
475      * Does not check if the required server certificates are available.
476      */
477     static final boolean isNegotiable(
478             List&lt;CipherSuite&gt; proposed, CipherSuite cs) {
479         return proposed.contains(cs) &amp;&amp; cs.isNegotiable();
480     }
481 
482     /**
483      * Check if the given cipher suite is enabled and available within
484      * the proposed cipher suite list and specific protocol version.
485      *
486      * Does not check if the required server certificates are available.
487      */
488     static final boolean isNegotiable(List&lt;CipherSuite&gt; proposed,
489             ProtocolVersion protocolVersion, CipherSuite cs) {
490         return proposed.contains(cs) &amp;&amp;
491                 cs.isNegotiable() &amp;&amp; cs.supports(protocolVersion);
492     }
493 
494     /**
495      * Check if the given protocol version is enabled and available.
496      */
497     boolean isNegotiable(ProtocolVersion protocolVersion) {
498         return activeProtocols.contains(protocolVersion);
499     }
500 
501     /**
502      * Set the active protocol version and propagate it to the SSLSocket
503      * and our handshake streams. Called from ClientHandshaker
504      * and ServerHandshaker with the negotiated protocol version.
505      */
506     void setVersion(ProtocolVersion protocolVersion) {
507         this.conContext.protocolVersion = protocolVersion;
508     }
509 
510     private static boolean isActivatable(CipherSuite suite,
511             AlgorithmConstraints algorithmConstraints,
512             Map&lt;NamedGroupSpec, Boolean&gt; cachedStatus) {
513 
514         if (algorithmConstraints.permits(
515                 EnumSet.of(CryptoPrimitive.KEY_AGREEMENT), suite.name, null)) {
516             if (suite.keyExchange == null) {
517                 // TLS 1.3, no definition of key exchange in cipher suite.
518                 return true;
519             }
520 
521             // Is at least one of the group types available?
522             boolean groupAvailable, retval = false;
523             NamedGroupSpec[] groupTypes = suite.keyExchange.groupTypes;
524             for (NamedGroupSpec groupType : groupTypes) {
525                 if (groupType != NAMED_GROUP_NONE) {
526                     Boolean checkedStatus = cachedStatus.get(groupType);
527                     if (checkedStatus == null) {
528                         groupAvailable = SupportedGroups.isActivatable(
529                                 algorithmConstraints, groupType);
530                         cachedStatus.put(groupType, groupAvailable);
531 
532                         if (!groupAvailable &amp;&amp;
533                                 SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
534                             SSLLogger.fine(
535                                     &quot;No activated named group in &quot; + groupType);
536                         }
537                     } else {
538                         groupAvailable = checkedStatus;
539                     }
540 
541                     retval |= groupAvailable;
542                 } else {
543                     retval |= true;
544                 }
545             }
546 
547             if (!retval &amp;&amp; SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
548                 SSLLogger.fine(&quot;No active named group(s), ignore &quot; + suite);
549             }
550 
551             return retval;
552 
553         } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
554             SSLLogger.fine(&quot;Ignore disabled cipher suite: &quot; + suite);
555         }
556 
557         return false;
558     }
559 
560     List&lt;SNIServerName&gt; getRequestedServerNames() {
561         if (requestedServerNames == null) {
562             return Collections.emptyList();
563         }
564         return requestedServerNames;
565     }
566 }
567 
    </pre>
  </body>
</html>
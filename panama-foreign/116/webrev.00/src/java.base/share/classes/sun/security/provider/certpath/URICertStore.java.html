<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/provider/certpath/URICertStore.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2006, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.provider.certpath;
 27 
 28 import java.io.InputStream;
 29 import java.io.IOException;
 30 import java.net.HttpURLConnection;
 31 import java.net.URI;
 32 import java.net.URLConnection;
 33 import java.security.InvalidAlgorithmParameterException;
 34 import java.security.NoSuchAlgorithmException;
 35 import java.security.Provider;
 36 import java.security.cert.CertificateException;
 37 import java.security.cert.CertificateFactory;
 38 import java.security.cert.CertSelector;
 39 import java.security.cert.CertStore;
 40 import java.security.cert.CertStoreException;
 41 import java.security.cert.CertStoreParameters;
 42 import java.security.cert.CertStoreSpi;
 43 import java.security.cert.CRLException;
 44 import java.security.cert.CRLSelector;
 45 import java.security.cert.URICertStoreParameters;
 46 import java.security.cert.X509Certificate;
 47 import java.security.cert.X509CRL;
 48 import java.util.ArrayList;
 49 import java.util.Collection;
 50 import java.util.Collections;
 51 import java.util.List;
 52 import java.util.Locale;
 53 import sun.security.action.GetIntegerAction;
 54 import sun.security.x509.AccessDescription;
 55 import sun.security.x509.GeneralNameInterface;
 56 import sun.security.x509.URIName;
 57 import sun.security.util.Cache;
 58 import sun.security.util.Debug;
 59 
 60 /**
 61  * A &lt;code&gt;CertStore&lt;/code&gt; that retrieves &lt;code&gt;Certificates&lt;/code&gt; or
 62  * &lt;code&gt;CRL&lt;/code&gt;s from a URI, for example, as specified in an X.509
 63  * AuthorityInformationAccess or CRLDistributionPoint extension.
 64  * &lt;p&gt;
 65  * For CRLs, this implementation retrieves a single DER encoded CRL per URI.
 66  * For Certificates, this implementation retrieves a single DER encoded CRL or
 67  * a collection of Certificates encoded as a PKCS#7 &quot;certs-only&quot; CMS message.
 68  * &lt;p&gt;
 69  * This &lt;code&gt;CertStore&lt;/code&gt; also implements Certificate/CRL caching.
 70  * Currently, the cache is shared between all applications in the VM and uses a
 71  * hardcoded policy. The cache has a maximum size of 185 entries, which are held
 72  * by SoftReferences. A request will be satisfied from the cache if we last
 73  * checked for an update within CHECK_INTERVAL (last 30 seconds). Otherwise,
 74  * we open an URLConnection to download the Certificate(s)/CRL using an
 75  * If-Modified-Since request (HTTP) if possible. Note that both positive and
 76  * negative responses are cached, i.e. if we are unable to open the connection
 77  * or the Certificate(s)/CRL cannot be parsed, we remember this result and
 78  * additional calls during the CHECK_INTERVAL period do not try to open another
 79  * connection.
 80  * &lt;p&gt;
 81  * The URICertStore is not currently a standard CertStore type. We should
 82  * consider adding a standard &quot;URI&quot; CertStore type.
 83  *
 84  * @author Andreas Sterbenz
 85  * @author Sean Mullan
 86  * @since 1.7
 87  */
 88 class URICertStore extends CertStoreSpi {
 89 
 90     private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);
 91 
 92     // interval between checks for update of cached Certificates/CRLs
 93     // (30 seconds)
 94     private static final int CHECK_INTERVAL = 30 * 1000;
 95 
 96     // size of the cache (see Cache class for sizing recommendations)
 97     private static final int CACHE_SIZE = 185;
 98 
 99     // X.509 certificate factory instance
100     private final CertificateFactory factory;
101 
102     // cached Collection of X509Certificates (may be empty, never null)
103     private Collection&lt;X509Certificate&gt; certs = Collections.emptySet();
104 
105     // cached X509CRL (may be null)
106     private X509CRL crl;
107 
108     // time we last checked for an update
109     private long lastChecked;
110 
111     // time server returned as last modified time stamp
112     // or 0 if not available
113     private long lastModified;
114 
115     // the URI of this CertStore
116     private URI uri;
117 
118     // true if URI is ldap
119     private boolean ldap = false;
120     private CertStore ldapCertStore;
121 
122     // Default maximum connect timeout in milliseconds (15 seconds)
123     // allowed when downloading CRLs
124     private static final int DEFAULT_CRL_CONNECT_TIMEOUT = 15000;
125 
126     // Default maximum read timeout in milliseconds (15 seconds)
127     // allowed when downloading CRLs
128     private static final int DEFAULT_CRL_READ_TIMEOUT = 15000;
129 
130     /**
131      * Integer value indicating the connect timeout, in seconds, to be
132      * used for the CRL download. A timeout of zero is interpreted as
133      * an infinite timeout.
134      */
135     private static final int CRL_CONNECT_TIMEOUT =
136         initializeTimeout(&quot;com.sun.security.crl.timeout&quot;,
137                           DEFAULT_CRL_CONNECT_TIMEOUT);
138 
139     /**
140      * Integer value indicating the read timeout, in seconds, to be
141      * used for the CRL download. A timeout of zero is interpreted as
142      * an infinite timeout.
143      */
144     private static final int CRL_READ_TIMEOUT =
145         initializeTimeout(&quot;com.sun.security.crl.readtimeout&quot;,
146                           DEFAULT_CRL_READ_TIMEOUT);
147 
148     /**
149      * Initialize the timeout length by getting the specified CRL timeout
150      * system property. If the property has not been set, or if its
151      * value is negative, set the timeout length to the specified default.
152      */
153     private static int initializeTimeout(String prop, int def) {
154         Integer tmp = GetIntegerAction.privilegedGetProperty(prop);
155         if (tmp == null || tmp &lt; 0) {
156             return def;
157         }
158         if (debug != null) {
159             debug.println(prop + &quot; set to &quot; + tmp + &quot; seconds&quot;);
160         }
161         // Convert to milliseconds, as the system property will be
162         // specified in seconds
163         return tmp * 1000;
164     }
165 
166     /**
167      * Creates a URICertStore.
168      *
169      * @param params specifying the URI
170      */
171     URICertStore(CertStoreParameters params)
172         throws InvalidAlgorithmParameterException, NoSuchAlgorithmException {
173         super(params);
174         if (!(params instanceof URICertStoreParameters)) {
175             throw new InvalidAlgorithmParameterException
176                 (&quot;params must be instanceof URICertStoreParameters&quot;);
177         }
178         this.uri = ((URICertStoreParameters) params).getURI();
179         // if ldap URI, use an LDAPCertStore to fetch certs and CRLs
180         if (uri.getScheme().toLowerCase(Locale.ENGLISH).equals(&quot;ldap&quot;)) {
181             ldap = true;
182             ldapCertStore = CertStore.getInstance(&quot;LDAP&quot;, params);
183         }
184         try {
185             factory = CertificateFactory.getInstance(&quot;X.509&quot;);
186         } catch (CertificateException e) {
187             throw new RuntimeException();
188         }
189     }
190 
191     /**
192      * Returns a URI CertStore. This method consults a cache of
193      * CertStores (shared per JVM) using the URI as a key.
194      */
195     private static final Cache&lt;URICertStoreParameters, CertStore&gt;
196         certStoreCache = Cache.newSoftMemoryCache(CACHE_SIZE);
197     static synchronized CertStore getInstance(URICertStoreParameters params)
198         throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {
199         if (debug != null) {
200             debug.println(&quot;CertStore URI:&quot; + params.getURI());
201         }
202         CertStore ucs = certStoreCache.get(params);
203         if (ucs == null) {
204             ucs = new UCS(new URICertStore(params), null, &quot;URI&quot;, params);
205             certStoreCache.put(params, ucs);
206         } else {
207             if (debug != null) {
208                 debug.println(&quot;URICertStore.getInstance: cache hit&quot;);
209             }
210         }
211         return ucs;
212     }
213 
214     /**
215      * Creates a CertStore from information included in the AccessDescription
216      * object of a certificate&#39;s Authority Information Access Extension.
217      */
218     static CertStore getInstance(AccessDescription ad) {
219         if (!ad.getAccessMethod().equals(
220                 AccessDescription.Ad_CAISSUERS_Id)) {
221             return null;
222         }
223         GeneralNameInterface gn = ad.getAccessLocation().getName();
224         if (!(gn instanceof URIName)) {
225             return null;
226         }
227         URI uri = ((URIName) gn).getURI();
228         try {
229             return URICertStore.getInstance(new URICertStoreParameters(uri));
230         } catch (Exception ex) {
231             if (debug != null) {
232                 debug.println(&quot;exception creating CertStore: &quot; + ex);
233                 ex.printStackTrace();
234             }
235             return null;
236         }
237     }
238 
239     /**
240      * Returns a &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;X509Certificate&lt;/code&gt;s that
241      * match the specified selector. If no &lt;code&gt;X509Certificate&lt;/code&gt;s
242      * match the selector, an empty &lt;code&gt;Collection&lt;/code&gt; will be returned.
243      *
244      * @param selector a &lt;code&gt;CertSelector&lt;/code&gt; used to select which
245      *  &lt;code&gt;X509Certificate&lt;/code&gt;s should be returned. Specify
246      *  &lt;code&gt;null&lt;/code&gt; to return all &lt;code&gt;X509Certificate&lt;/code&gt;s.
247      * @return a &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;X509Certificate&lt;/code&gt;s that
248      *         match the specified selector
249      * @throws CertStoreException if an exception occurs
250      */
251     @Override
252     @SuppressWarnings(&quot;unchecked&quot;)
253     public synchronized Collection&lt;X509Certificate&gt; engineGetCertificates
254         (CertSelector selector) throws CertStoreException {
255 
256         if (ldap) {
257             // caching mechanism, see the class description for more info.
258             return (Collection&lt;X509Certificate&gt;)
259                 ldapCertStore.getCertificates(selector);
260         }
261 
262         // Return the Certificates for this entry. It returns the cached value
263         // if it is still current and fetches the Certificates otherwise.
264         // For the caching details, see the top of this class.
265         long time = System.currentTimeMillis();
266         if (time - lastChecked &lt; CHECK_INTERVAL) {
267             if (debug != null) {
268                 debug.println(&quot;Returning certificates from cache&quot;);
269             }
270             return getMatchingCerts(certs, selector);
271         }
272         lastChecked = time;
273         try {
274             URLConnection connection = uri.toURL().openConnection();
275             if (lastModified != 0) {
276                 connection.setIfModifiedSince(lastModified);
277             }
278             long oldLastModified = lastModified;
279             try (InputStream in = connection.getInputStream()) {
280                 lastModified = connection.getLastModified();
281                 if (oldLastModified != 0) {
282                     if (oldLastModified == lastModified) {
283                         if (debug != null) {
284                             debug.println(&quot;Not modified, using cached copy&quot;);
285                         }
286                         return getMatchingCerts(certs, selector);
287                     } else if (connection instanceof HttpURLConnection) {
288                         // some proxy servers omit last modified
289                         HttpURLConnection hconn = (HttpURLConnection)connection;
290                         if (hconn.getResponseCode()
291                                     == HttpURLConnection.HTTP_NOT_MODIFIED) {
292                             if (debug != null) {
293                                 debug.println(&quot;Not modified, using cached copy&quot;);
294                             }
295                             return getMatchingCerts(certs, selector);
296                         }
297                     }
298                 }
299                 if (debug != null) {
300                     debug.println(&quot;Downloading new certificates...&quot;);
301                 }
302                 // Safe cast since factory is an X.509 certificate factory
303                 certs = (Collection&lt;X509Certificate&gt;)
304                     factory.generateCertificates(in);
305             }
306             return getMatchingCerts(certs, selector);
307         } catch (IOException | CertificateException e) {
308             if (debug != null) {
309                 debug.println(&quot;Exception fetching certificates:&quot;);
310                 e.printStackTrace();
311             }
312         }
313         // exception, forget previous values
314         lastModified = 0;
315         certs = Collections.emptySet();
316         return certs;
317     }
318 
319     /**
320      * Iterates over the specified Collection of X509Certificates and
321      * returns only those that match the criteria specified in the
322      * CertSelector.
323      */
324     private static Collection&lt;X509Certificate&gt; getMatchingCerts
325         (Collection&lt;X509Certificate&gt; certs, CertSelector selector) {
326         // if selector not specified, all certs match
327         if (selector == null) {
328             return certs;
329         }
330         List&lt;X509Certificate&gt; matchedCerts = new ArrayList&lt;&gt;(certs.size());
331         for (X509Certificate cert : certs) {
332             if (selector.match(cert)) {
333                 matchedCerts.add(cert);
334             }
335         }
336         return matchedCerts;
337     }
338 
339     /**
340      * Returns a &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;X509CRL&lt;/code&gt;s that
341      * match the specified selector. If no &lt;code&gt;X509CRL&lt;/code&gt;s
342      * match the selector, an empty &lt;code&gt;Collection&lt;/code&gt; will be returned.
343      *
344      * @param selector A &lt;code&gt;CRLSelector&lt;/code&gt; used to select which
345      *  &lt;code&gt;X509CRL&lt;/code&gt;s should be returned. Specify &lt;code&gt;null&lt;/code&gt;
346      *  to return all &lt;code&gt;X509CRL&lt;/code&gt;s.
347      * @return A &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;X509CRL&lt;/code&gt;s that
348      *         match the specified selector
349      * @throws CertStoreException if an exception occurs
350      */
351     @Override
352     @SuppressWarnings(&quot;unchecked&quot;)
353     public synchronized Collection&lt;X509CRL&gt; engineGetCRLs(CRLSelector selector)
354         throws CertStoreException {
355 
356         if (ldap) {
357             // Fetch the CRLs via LDAP. LDAPCertStore has its own
358             // caching mechanism, see the class description for more info.
359             try {
360                 return (Collection&lt;X509CRL&gt;) ldapCertStore.getCRLs(selector);
361             } catch (CertStoreException cse) {
362                 throw new PKIX.CertStoreTypeException(&quot;LDAP&quot;, cse);
363             }
364         }
365 
366         // Return the CRLs for this entry. It returns the cached value
367         // if it is still current and fetches the CRLs otherwise.
368         // For the caching details, see the top of this class.
369         long time = System.currentTimeMillis();
370         if (time - lastChecked &lt; CHECK_INTERVAL) {
371             if (debug != null) {
372                 debug.println(&quot;Returning CRL from cache&quot;);
373             }
374             return getMatchingCRLs(crl, selector);
375         }
376         lastChecked = time;
377         try {
378             URLConnection connection = uri.toURL().openConnection();
379             if (lastModified != 0) {
380                 connection.setIfModifiedSince(lastModified);
381             }
382             long oldLastModified = lastModified;
383             connection.setConnectTimeout(CRL_CONNECT_TIMEOUT);
384             connection.setReadTimeout(CRL_READ_TIMEOUT);
385             try (InputStream in = connection.getInputStream()) {
386                 lastModified = connection.getLastModified();
387                 if (oldLastModified != 0) {
388                     if (oldLastModified == lastModified) {
389                         if (debug != null) {
390                             debug.println(&quot;Not modified, using cached copy&quot;);
391                         }
392                         return getMatchingCRLs(crl, selector);
393                     } else if (connection instanceof HttpURLConnection) {
394                         // some proxy servers omit last modified
395                         HttpURLConnection hconn = (HttpURLConnection)connection;
396                         if (hconn.getResponseCode()
397                                     == HttpURLConnection.HTTP_NOT_MODIFIED) {
398                             if (debug != null) {
399                                 debug.println(&quot;Not modified, using cached copy&quot;);
400                             }
401                             return getMatchingCRLs(crl, selector);
402                         }
403                     }
404                 }
405                 if (debug != null) {
406                     debug.println(&quot;Downloading new CRL...&quot;);
407                 }
408                 crl = (X509CRL) factory.generateCRL(in);
409             }
410             return getMatchingCRLs(crl, selector);
411         } catch (IOException | CRLException e) {
412             if (debug != null) {
413                 debug.println(&quot;Exception fetching CRL:&quot;);
414                 e.printStackTrace();
415             }
416             // exception, forget previous values
417             lastModified = 0;
418             crl = null;
419             throw new PKIX.CertStoreTypeException(&quot;URI&quot;,
420                                                   new CertStoreException(e));
421         }
422     }
423 
424     /**
425      * Checks if the specified X509CRL matches the criteria specified in the
426      * CRLSelector.
427      */
428     private static Collection&lt;X509CRL&gt; getMatchingCRLs
429         (X509CRL crl, CRLSelector selector) {
430         if (selector == null || (crl != null &amp;&amp; selector.match(crl))) {
431             return Collections.singletonList(crl);
432         } else {
433             return Collections.emptyList();
434         }
435     }
436 
437     /**
438      * This class allows the URICertStore to be accessed as a CertStore.
439      */
440     private static class UCS extends CertStore {
441         protected UCS(CertStoreSpi spi, Provider p, String type,
442             CertStoreParameters params) {
443             super(spi, p, type, params);
444         }
445     }
446 }
    </pre>
  </body>
</html>
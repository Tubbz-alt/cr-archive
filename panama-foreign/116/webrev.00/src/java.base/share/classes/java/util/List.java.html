<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/List.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.util.function.UnaryOperator;
  29 
  30 /**
  31  * An ordered collection (also known as a &lt;i&gt;sequence&lt;/i&gt;).  The user of this
  32  * interface has precise control over where in the list each element is
  33  * inserted.  The user can access elements by their integer index (position in
  34  * the list), and search for elements in the list.&lt;p&gt;
  35  *
  36  * Unlike sets, lists typically allow duplicate elements.  More formally,
  37  * lists typically allow pairs of elements {@code e1} and {@code e2}
  38  * such that {@code e1.equals(e2)}, and they typically allow multiple
  39  * null elements if they allow null elements at all.  It is not inconceivable
  40  * that someone might wish to implement a list that prohibits duplicates, by
  41  * throwing runtime exceptions when the user attempts to insert them, but we
  42  * expect this usage to be rare.&lt;p&gt;
  43  *
  44  * The {@code List} interface places additional stipulations, beyond those
  45  * specified in the {@code Collection} interface, on the contracts of the
  46  * {@code iterator}, {@code add}, {@code remove}, {@code equals}, and
  47  * {@code hashCode} methods.  Declarations for other inherited methods are
  48  * also included here for convenience.&lt;p&gt;
  49  *
  50  * The {@code List} interface provides four methods for positional (indexed)
  51  * access to list elements.  Lists (like Java arrays) are zero based.  Note
  52  * that these operations may execute in time proportional to the index value
  53  * for some implementations (the {@code LinkedList} class, for
  54  * example). Thus, iterating over the elements in a list is typically
  55  * preferable to indexing through it if the caller does not know the
  56  * implementation.&lt;p&gt;
  57  *
  58  * The {@code List} interface provides a special iterator, called a
  59  * {@code ListIterator}, that allows element insertion and replacement, and
  60  * bidirectional access in addition to the normal operations that the
  61  * {@code Iterator} interface provides.  A method is provided to obtain a
  62  * list iterator that starts at a specified position in the list.&lt;p&gt;
  63  *
  64  * The {@code List} interface provides two methods to search for a specified
  65  * object.  From a performance standpoint, these methods should be used with
  66  * caution.  In many implementations they will perform costly linear
  67  * searches.&lt;p&gt;
  68  *
  69  * The {@code List} interface provides two methods to efficiently insert and
  70  * remove multiple elements at an arbitrary point in the list.&lt;p&gt;
  71  *
  72  * Note: While it is permissible for lists to contain themselves as elements,
  73  * extreme caution is advised: the {@code equals} and {@code hashCode}
  74  * methods are no longer well defined on such a list.
  75  *
  76  * &lt;p&gt;Some list implementations have restrictions on the elements that
  77  * they may contain.  For example, some implementations prohibit null elements,
  78  * and some have restrictions on the types of their elements.  Attempting to
  79  * add an ineligible element throws an unchecked exception, typically
  80  * {@code NullPointerException} or {@code ClassCastException}.  Attempting
  81  * to query the presence of an ineligible element may throw an exception,
  82  * or it may simply return false; some implementations will exhibit the former
  83  * behavior and some will exhibit the latter.  More generally, attempting an
  84  * operation on an ineligible element whose completion would not result in
  85  * the insertion of an ineligible element into the list may throw an
  86  * exception or it may succeed, at the option of the implementation.
  87  * Such exceptions are marked as &quot;optional&quot; in the specification for this
  88  * interface.
  89  *
  90  * &lt;h2&gt;&lt;a id=&quot;unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt;&lt;/h2&gt;
  91  * &lt;p&gt;The {@link List#of(Object...) List.of} and
  92  * {@link List#copyOf List.copyOf} static factory methods
  93  * provide a convenient way to create unmodifiable lists. The {@code List}
  94  * instances created by these methods have the following characteristics:
  95  *
  96  * &lt;ul&gt;
  97  * &lt;li&gt;They are &lt;a href=&quot;Collection.html#unmodifiable&quot;&gt;&lt;i&gt;unmodifiable&lt;/i&gt;&lt;/a&gt;. Elements cannot
  98  * be added, removed, or replaced. Calling any mutator method on the List
  99  * will always cause {@code UnsupportedOperationException} to be thrown.
 100  * However, if the contained elements are themselves mutable,
 101  * this may cause the List&#39;s contents to appear to change.
 102  * &lt;li&gt;They disallow {@code null} elements. Attempts to create them with
 103  * {@code null} elements result in {@code NullPointerException}.
 104  * &lt;li&gt;They are serializable if all elements are serializable.
 105  * &lt;li&gt;The order of elements in the list is the same as the order of the
 106  * provided arguments, or of the elements in the provided array.
 107  * &lt;li&gt;The lists and their {@link #subList(int, int) subList} views implement the
 108  * {@link RandomAccess} interface.
 109  * &lt;li&gt;They are &lt;a href=&quot;../lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;.
 110  * Callers should make no assumptions about the identity of the returned instances.
 111  * Factories are free to create new instances or reuse existing ones. Therefore,
 112  * identity-sensitive operations on these instances (reference equality ({@code ==}),
 113  * identity hash code, and synchronization) are unreliable and should be avoided.
 114  * &lt;li&gt;They are serialized as specified on the
 115  * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.util.CollSer&quot;&gt;Serialized Form&lt;/a&gt;
 116  * page.
 117  * &lt;/ul&gt;
 118  *
 119  * &lt;p&gt;This interface is a member of the
 120  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 121  * Java Collections Framework&lt;/a&gt;.
 122  *
 123  * @param &lt;E&gt; the type of elements in this list
 124  *
 125  * @author  Josh Bloch
 126  * @author  Neal Gafter
 127  * @see Collection
 128  * @see Set
 129  * @see ArrayList
 130  * @see LinkedList
 131  * @see Vector
 132  * @see Arrays#asList(Object[])
 133  * @see Collections#nCopies(int, Object)
 134  * @see Collections#EMPTY_LIST
 135  * @see AbstractList
 136  * @see AbstractSequentialList
 137  * @since 1.2
 138  */
 139 
 140 public interface List&lt;E&gt; extends Collection&lt;E&gt; {
 141     // Query Operations
 142 
 143     /**
 144      * Returns the number of elements in this list.  If this list contains
 145      * more than {@code Integer.MAX_VALUE} elements, returns
 146      * {@code Integer.MAX_VALUE}.
 147      *
 148      * @return the number of elements in this list
 149      */
 150     int size();
 151 
 152     /**
 153      * Returns {@code true} if this list contains no elements.
 154      *
 155      * @return {@code true} if this list contains no elements
 156      */
 157     boolean isEmpty();
 158 
 159     /**
 160      * Returns {@code true} if this list contains the specified element.
 161      * More formally, returns {@code true} if and only if this list contains
 162      * at least one element {@code e} such that
 163      * {@code Objects.equals(o, e)}.
 164      *
 165      * @param o element whose presence in this list is to be tested
 166      * @return {@code true} if this list contains the specified element
 167      * @throws ClassCastException if the type of the specified element
 168      *         is incompatible with this list
 169      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 170      * @throws NullPointerException if the specified element is null and this
 171      *         list does not permit null elements
 172      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 173      */
 174     boolean contains(Object o);
 175 
 176     /**
 177      * Returns an iterator over the elements in this list in proper sequence.
 178      *
 179      * @return an iterator over the elements in this list in proper sequence
 180      */
 181     Iterator&lt;E&gt; iterator();
 182 
 183     /**
 184      * Returns an array containing all of the elements in this list in proper
 185      * sequence (from first to last element).
 186      *
 187      * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
 188      * maintained by this list.  (In other words, this method must
 189      * allocate a new array even if this list is backed by an array).
 190      * The caller is thus free to modify the returned array.
 191      *
 192      * &lt;p&gt;This method acts as bridge between array-based and collection-based
 193      * APIs.
 194      *
 195      * @return an array containing all of the elements in this list in proper
 196      *         sequence
 197      * @see Arrays#asList(Object[])
 198      */
 199     Object[] toArray();
 200 
 201     /**
 202      * Returns an array containing all of the elements in this list in
 203      * proper sequence (from first to last element); the runtime type of
 204      * the returned array is that of the specified array.  If the list fits
 205      * in the specified array, it is returned therein.  Otherwise, a new
 206      * array is allocated with the runtime type of the specified array and
 207      * the size of this list.
 208      *
 209      * &lt;p&gt;If the list fits in the specified array with room to spare (i.e.,
 210      * the array has more elements than the list), the element in the array
 211      * immediately following the end of the list is set to {@code null}.
 212      * (This is useful in determining the length of the list &lt;i&gt;only&lt;/i&gt; if
 213      * the caller knows that the list does not contain any null elements.)
 214      *
 215      * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between
 216      * array-based and collection-based APIs.  Further, this method allows
 217      * precise control over the runtime type of the output array, and may,
 218      * under certain circumstances, be used to save allocation costs.
 219      *
 220      * &lt;p&gt;Suppose {@code x} is a list known to contain only strings.
 221      * The following code can be used to dump the list into a newly
 222      * allocated array of {@code String}:
 223      *
 224      * &lt;pre&gt;{@code
 225      *     String[] y = x.toArray(new String[0]);
 226      * }&lt;/pre&gt;
 227      *
 228      * Note that {@code toArray(new Object[0])} is identical in function to
 229      * {@code toArray()}.
 230      *
 231      * @param a the array into which the elements of this list are to
 232      *          be stored, if it is big enough; otherwise, a new array of the
 233      *          same runtime type is allocated for this purpose.
 234      * @return an array containing the elements of this list
 235      * @throws ArrayStoreException if the runtime type of the specified array
 236      *         is not a supertype of the runtime type of every element in
 237      *         this list
 238      * @throws NullPointerException if the specified array is null
 239      */
 240     &lt;T&gt; T[] toArray(T[] a);
 241 
 242 
 243     // Modification Operations
 244 
 245     /**
 246      * Appends the specified element to the end of this list (optional
 247      * operation).
 248      *
 249      * &lt;p&gt;Lists that support this operation may place limitations on what
 250      * elements may be added to this list.  In particular, some
 251      * lists will refuse to add null elements, and others will impose
 252      * restrictions on the type of elements that may be added.  List
 253      * classes should clearly specify in their documentation any restrictions
 254      * on what elements may be added.
 255      *
 256      * @param e element to be appended to this list
 257      * @return {@code true} (as specified by {@link Collection#add})
 258      * @throws UnsupportedOperationException if the {@code add} operation
 259      *         is not supported by this list
 260      * @throws ClassCastException if the class of the specified element
 261      *         prevents it from being added to this list
 262      * @throws NullPointerException if the specified element is null and this
 263      *         list does not permit null elements
 264      * @throws IllegalArgumentException if some property of this element
 265      *         prevents it from being added to this list
 266      */
 267     boolean add(E e);
 268 
 269     /**
 270      * Removes the first occurrence of the specified element from this list,
 271      * if it is present (optional operation).  If this list does not contain
 272      * the element, it is unchanged.  More formally, removes the element with
 273      * the lowest index {@code i} such that
 274      * {@code Objects.equals(o, get(i))}
 275      * (if such an element exists).  Returns {@code true} if this list
 276      * contained the specified element (or equivalently, if this list changed
 277      * as a result of the call).
 278      *
 279      * @param o element to be removed from this list, if present
 280      * @return {@code true} if this list contained the specified element
 281      * @throws ClassCastException if the type of the specified element
 282      *         is incompatible with this list
 283      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 284      * @throws NullPointerException if the specified element is null and this
 285      *         list does not permit null elements
 286      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 287      * @throws UnsupportedOperationException if the {@code remove} operation
 288      *         is not supported by this list
 289      */
 290     boolean remove(Object o);
 291 
 292 
 293     // Bulk Modification Operations
 294 
 295     /**
 296      * Returns {@code true} if this list contains all of the elements of the
 297      * specified collection.
 298      *
 299      * @param  c collection to be checked for containment in this list
 300      * @return {@code true} if this list contains all of the elements of the
 301      *         specified collection
 302      * @throws ClassCastException if the types of one or more elements
 303      *         in the specified collection are incompatible with this
 304      *         list
 305      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 306      * @throws NullPointerException if the specified collection contains one
 307      *         or more null elements and this list does not permit null
 308      *         elements
 309      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
 310      *         or if the specified collection is null
 311      * @see #contains(Object)
 312      */
 313     boolean containsAll(Collection&lt;?&gt; c);
 314 
 315     /**
 316      * Appends all of the elements in the specified collection to the end of
 317      * this list, in the order that they are returned by the specified
 318      * collection&#39;s iterator (optional operation).  The behavior of this
 319      * operation is undefined if the specified collection is modified while
 320      * the operation is in progress.  (Note that this will occur if the
 321      * specified collection is this list, and it&#39;s nonempty.)
 322      *
 323      * @param c collection containing elements to be added to this list
 324      * @return {@code true} if this list changed as a result of the call
 325      * @throws UnsupportedOperationException if the {@code addAll} operation
 326      *         is not supported by this list
 327      * @throws ClassCastException if the class of an element of the specified
 328      *         collection prevents it from being added to this list
 329      * @throws NullPointerException if the specified collection contains one
 330      *         or more null elements and this list does not permit null
 331      *         elements, or if the specified collection is null
 332      * @throws IllegalArgumentException if some property of an element of the
 333      *         specified collection prevents it from being added to this list
 334      * @see #add(Object)
 335      */
 336     boolean addAll(Collection&lt;? extends E&gt; c);
 337 
 338     /**
 339      * Inserts all of the elements in the specified collection into this
 340      * list at the specified position (optional operation).  Shifts the
 341      * element currently at that position (if any) and any subsequent
 342      * elements to the right (increases their indices).  The new elements
 343      * will appear in this list in the order that they are returned by the
 344      * specified collection&#39;s iterator.  The behavior of this operation is
 345      * undefined if the specified collection is modified while the
 346      * operation is in progress.  (Note that this will occur if the specified
 347      * collection is this list, and it&#39;s nonempty.)
 348      *
 349      * @param index index at which to insert the first element from the
 350      *              specified collection
 351      * @param c collection containing elements to be added to this list
 352      * @return {@code true} if this list changed as a result of the call
 353      * @throws UnsupportedOperationException if the {@code addAll} operation
 354      *         is not supported by this list
 355      * @throws ClassCastException if the class of an element of the specified
 356      *         collection prevents it from being added to this list
 357      * @throws NullPointerException if the specified collection contains one
 358      *         or more null elements and this list does not permit null
 359      *         elements, or if the specified collection is null
 360      * @throws IllegalArgumentException if some property of an element of the
 361      *         specified collection prevents it from being added to this list
 362      * @throws IndexOutOfBoundsException if the index is out of range
 363      *         ({@code index &lt; 0 || index &gt; size()})
 364      */
 365     boolean addAll(int index, Collection&lt;? extends E&gt; c);
 366 
 367     /**
 368      * Removes from this list all of its elements that are contained in the
 369      * specified collection (optional operation).
 370      *
 371      * @param c collection containing elements to be removed from this list
 372      * @return {@code true} if this list changed as a result of the call
 373      * @throws UnsupportedOperationException if the {@code removeAll} operation
 374      *         is not supported by this list
 375      * @throws ClassCastException if the class of an element of this list
 376      *         is incompatible with the specified collection
 377      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 378      * @throws NullPointerException if this list contains a null element and the
 379      *         specified collection does not permit null elements
 380      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
 381      *         or if the specified collection is null
 382      * @see #remove(Object)
 383      * @see #contains(Object)
 384      */
 385     boolean removeAll(Collection&lt;?&gt; c);
 386 
 387     /**
 388      * Retains only the elements in this list that are contained in the
 389      * specified collection (optional operation).  In other words, removes
 390      * from this list all of its elements that are not contained in the
 391      * specified collection.
 392      *
 393      * @param c collection containing elements to be retained in this list
 394      * @return {@code true} if this list changed as a result of the call
 395      * @throws UnsupportedOperationException if the {@code retainAll} operation
 396      *         is not supported by this list
 397      * @throws ClassCastException if the class of an element of this list
 398      *         is incompatible with the specified collection
 399      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 400      * @throws NullPointerException if this list contains a null element and the
 401      *         specified collection does not permit null elements
 402      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
 403      *         or if the specified collection is null
 404      * @see #remove(Object)
 405      * @see #contains(Object)
 406      */
 407     boolean retainAll(Collection&lt;?&gt; c);
 408 
 409     /**
 410      * Replaces each element of this list with the result of applying the
 411      * operator to that element.  Errors or runtime exceptions thrown by
 412      * the operator are relayed to the caller.
 413      *
 414      * @implSpec
 415      * The default implementation is equivalent to, for this {@code list}:
 416      * &lt;pre&gt;{@code
 417      *     final ListIterator&lt;E&gt; li = list.listIterator();
 418      *     while (li.hasNext()) {
 419      *         li.set(operator.apply(li.next()));
 420      *     }
 421      * }&lt;/pre&gt;
 422      *
 423      * If the list&#39;s list-iterator does not support the {@code set} operation
 424      * then an {@code UnsupportedOperationException} will be thrown when
 425      * replacing the first element.
 426      *
 427      * @param operator the operator to apply to each element
 428      * @throws UnsupportedOperationException if this list is unmodifiable.
 429      *         Implementations may throw this exception if an element
 430      *         cannot be replaced or if, in general, modification is not
 431      *         supported
 432      * @throws NullPointerException if the specified operator is null or
 433      *         if the operator result is a null value and this list does
 434      *         not permit null elements
 435      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 436      * @since 1.8
 437      */
 438     default void replaceAll(UnaryOperator&lt;E&gt; operator) {
 439         Objects.requireNonNull(operator);
 440         final ListIterator&lt;E&gt; li = this.listIterator();
 441         while (li.hasNext()) {
 442             li.set(operator.apply(li.next()));
 443         }
 444     }
 445 
 446     /**
 447      * Sorts this list according to the order induced by the specified
 448      * {@link Comparator}.  The sort is &lt;i&gt;stable&lt;/i&gt;: this method must not
 449      * reorder equal elements.
 450      *
 451      * &lt;p&gt;All elements in this list must be &lt;i&gt;mutually comparable&lt;/i&gt; using the
 452      * specified comparator (that is, {@code c.compare(e1, e2)} must not throw
 453      * a {@code ClassCastException} for any elements {@code e1} and {@code e2}
 454      * in the list).
 455      *
 456      * &lt;p&gt;If the specified comparator is {@code null} then all elements in this
 457      * list must implement the {@link Comparable} interface and the elements&#39;
 458      * {@linkplain Comparable natural ordering} should be used.
 459      *
 460      * &lt;p&gt;This list must be modifiable, but need not be resizable.
 461      *
 462      * @implSpec
 463      * The default implementation obtains an array containing all elements in
 464      * this list, sorts the array, and iterates over this list resetting each
 465      * element from the corresponding position in the array. (This avoids the
 466      * n&lt;sup&gt;2&lt;/sup&gt; log(n) performance that would result from attempting
 467      * to sort a linked list in place.)
 468      *
 469      * @implNote
 470      * This implementation is a stable, adaptive, iterative mergesort that
 471      * requires far fewer than n lg(n) comparisons when the input array is
 472      * partially sorted, while offering the performance of a traditional
 473      * mergesort when the input array is randomly ordered.  If the input array
 474      * is nearly sorted, the implementation requires approximately n
 475      * comparisons.  Temporary storage requirements vary from a small constant
 476      * for nearly sorted input arrays to n/2 object references for randomly
 477      * ordered input arrays.
 478      *
 479      * &lt;p&gt;The implementation takes equal advantage of ascending and
 480      * descending order in its input array, and can take advantage of
 481      * ascending and descending order in different parts of the same
 482      * input array.  It is well-suited to merging two or more sorted arrays:
 483      * simply concatenate the arrays and sort the resulting array.
 484      *
 485      * &lt;p&gt;The implementation was adapted from Tim Peters&#39;s list sort for Python
 486      * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
 487      * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy&#39;s &quot;Optimistic
 488      * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
 489      * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
 490      * January 1993.
 491      *
 492      * @param c the {@code Comparator} used to compare list elements.
 493      *          A {@code null} value indicates that the elements&#39;
 494      *          {@linkplain Comparable natural ordering} should be used
 495      * @throws ClassCastException if the list contains elements that are not
 496      *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator
 497      * @throws UnsupportedOperationException if the list&#39;s list-iterator does
 498      *         not support the {@code set} operation
 499      * @throws IllegalArgumentException
 500      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 501      *         if the comparator is found to violate the {@link Comparator}
 502      *         contract
 503      * @since 1.8
 504      */
 505     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 506     default void sort(Comparator&lt;? super E&gt; c) {
 507         Object[] a = this.toArray();
 508         Arrays.sort(a, (Comparator) c);
 509         ListIterator&lt;E&gt; i = this.listIterator();
 510         for (Object e : a) {
 511             i.next();
 512             i.set((E) e);
 513         }
 514     }
 515 
 516     /**
 517      * Removes all of the elements from this list (optional operation).
 518      * The list will be empty after this call returns.
 519      *
 520      * @throws UnsupportedOperationException if the {@code clear} operation
 521      *         is not supported by this list
 522      */
 523     void clear();
 524 
 525 
 526     // Comparison and hashing
 527 
 528     /**
 529      * Compares the specified object with this list for equality.  Returns
 530      * {@code true} if and only if the specified object is also a list, both
 531      * lists have the same size, and all corresponding pairs of elements in
 532      * the two lists are &lt;i&gt;equal&lt;/i&gt;.  (Two elements {@code e1} and
 533      * {@code e2} are &lt;i&gt;equal&lt;/i&gt; if {@code Objects.equals(e1, e2)}.)
 534      * In other words, two lists are defined to be
 535      * equal if they contain the same elements in the same order.  This
 536      * definition ensures that the equals method works properly across
 537      * different implementations of the {@code List} interface.
 538      *
 539      * @param o the object to be compared for equality with this list
 540      * @return {@code true} if the specified object is equal to this list
 541      */
 542     boolean equals(Object o);
 543 
 544     /**
 545      * Returns the hash code value for this list.  The hash code of a list
 546      * is defined to be the result of the following calculation:
 547      * &lt;pre&gt;{@code
 548      *     int hashCode = 1;
 549      *     for (E e : list)
 550      *         hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());
 551      * }&lt;/pre&gt;
 552      * This ensures that {@code list1.equals(list2)} implies that
 553      * {@code list1.hashCode()==list2.hashCode()} for any two lists,
 554      * {@code list1} and {@code list2}, as required by the general
 555      * contract of {@link Object#hashCode}.
 556      *
 557      * @return the hash code value for this list
 558      * @see Object#equals(Object)
 559      * @see #equals(Object)
 560      */
 561     int hashCode();
 562 
 563 
 564     // Positional Access Operations
 565 
 566     /**
 567      * Returns the element at the specified position in this list.
 568      *
 569      * @param index index of the element to return
 570      * @return the element at the specified position in this list
 571      * @throws IndexOutOfBoundsException if the index is out of range
 572      *         ({@code index &lt; 0 || index &gt;= size()})
 573      */
 574     E get(int index);
 575 
 576     /**
 577      * Replaces the element at the specified position in this list with the
 578      * specified element (optional operation).
 579      *
 580      * @param index index of the element to replace
 581      * @param element element to be stored at the specified position
 582      * @return the element previously at the specified position
 583      * @throws UnsupportedOperationException if the {@code set} operation
 584      *         is not supported by this list
 585      * @throws ClassCastException if the class of the specified element
 586      *         prevents it from being added to this list
 587      * @throws NullPointerException if the specified element is null and
 588      *         this list does not permit null elements
 589      * @throws IllegalArgumentException if some property of the specified
 590      *         element prevents it from being added to this list
 591      * @throws IndexOutOfBoundsException if the index is out of range
 592      *         ({@code index &lt; 0 || index &gt;= size()})
 593      */
 594     E set(int index, E element);
 595 
 596     /**
 597      * Inserts the specified element at the specified position in this list
 598      * (optional operation).  Shifts the element currently at that position
 599      * (if any) and any subsequent elements to the right (adds one to their
 600      * indices).
 601      *
 602      * @param index index at which the specified element is to be inserted
 603      * @param element element to be inserted
 604      * @throws UnsupportedOperationException if the {@code add} operation
 605      *         is not supported by this list
 606      * @throws ClassCastException if the class of the specified element
 607      *         prevents it from being added to this list
 608      * @throws NullPointerException if the specified element is null and
 609      *         this list does not permit null elements
 610      * @throws IllegalArgumentException if some property of the specified
 611      *         element prevents it from being added to this list
 612      * @throws IndexOutOfBoundsException if the index is out of range
 613      *         ({@code index &lt; 0 || index &gt; size()})
 614      */
 615     void add(int index, E element);
 616 
 617     /**
 618      * Removes the element at the specified position in this list (optional
 619      * operation).  Shifts any subsequent elements to the left (subtracts one
 620      * from their indices).  Returns the element that was removed from the
 621      * list.
 622      *
 623      * @param index the index of the element to be removed
 624      * @return the element previously at the specified position
 625      * @throws UnsupportedOperationException if the {@code remove} operation
 626      *         is not supported by this list
 627      * @throws IndexOutOfBoundsException if the index is out of range
 628      *         ({@code index &lt; 0 || index &gt;= size()})
 629      */
 630     E remove(int index);
 631 
 632 
 633     // Search Operations
 634 
 635     /**
 636      * Returns the index of the first occurrence of the specified element
 637      * in this list, or -1 if this list does not contain the element.
 638      * More formally, returns the lowest index {@code i} such that
 639      * {@code Objects.equals(o, get(i))},
 640      * or -1 if there is no such index.
 641      *
 642      * @param o element to search for
 643      * @return the index of the first occurrence of the specified element in
 644      *         this list, or -1 if this list does not contain the element
 645      * @throws ClassCastException if the type of the specified element
 646      *         is incompatible with this list
 647      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 648      * @throws NullPointerException if the specified element is null and this
 649      *         list does not permit null elements
 650      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 651      */
 652     int indexOf(Object o);
 653 
 654     /**
 655      * Returns the index of the last occurrence of the specified element
 656      * in this list, or -1 if this list does not contain the element.
 657      * More formally, returns the highest index {@code i} such that
 658      * {@code Objects.equals(o, get(i))},
 659      * or -1 if there is no such index.
 660      *
 661      * @param o element to search for
 662      * @return the index of the last occurrence of the specified element in
 663      *         this list, or -1 if this list does not contain the element
 664      * @throws ClassCastException if the type of the specified element
 665      *         is incompatible with this list
 666      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 667      * @throws NullPointerException if the specified element is null and this
 668      *         list does not permit null elements
 669      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 670      */
 671     int lastIndexOf(Object o);
 672 
 673 
 674     // List Iterators
 675 
 676     /**
 677      * Returns a list iterator over the elements in this list (in proper
 678      * sequence).
 679      *
 680      * @return a list iterator over the elements in this list (in proper
 681      *         sequence)
 682      */
 683     ListIterator&lt;E&gt; listIterator();
 684 
 685     /**
 686      * Returns a list iterator over the elements in this list (in proper
 687      * sequence), starting at the specified position in the list.
 688      * The specified index indicates the first element that would be
 689      * returned by an initial call to {@link ListIterator#next next}.
 690      * An initial call to {@link ListIterator#previous previous} would
 691      * return the element with the specified index minus one.
 692      *
 693      * @param index index of the first element to be returned from the
 694      *        list iterator (by a call to {@link ListIterator#next next})
 695      * @return a list iterator over the elements in this list (in proper
 696      *         sequence), starting at the specified position in the list
 697      * @throws IndexOutOfBoundsException if the index is out of range
 698      *         ({@code index &lt; 0 || index &gt; size()})
 699      */
 700     ListIterator&lt;E&gt; listIterator(int index);
 701 
 702     // View
 703 
 704     /**
 705      * Returns a view of the portion of this list between the specified
 706      * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.  (If
 707      * {@code fromIndex} and {@code toIndex} are equal, the returned list is
 708      * empty.)  The returned list is backed by this list, so non-structural
 709      * changes in the returned list are reflected in this list, and vice-versa.
 710      * The returned list supports all of the optional list operations supported
 711      * by this list.&lt;p&gt;
 712      *
 713      * This method eliminates the need for explicit range operations (of
 714      * the sort that commonly exist for arrays).  Any operation that expects
 715      * a list can be used as a range operation by passing a subList view
 716      * instead of a whole list.  For example, the following idiom
 717      * removes a range of elements from a list:
 718      * &lt;pre&gt;{@code
 719      *      list.subList(from, to).clear();
 720      * }&lt;/pre&gt;
 721      * Similar idioms may be constructed for {@code indexOf} and
 722      * {@code lastIndexOf}, and all of the algorithms in the
 723      * {@code Collections} class can be applied to a subList.&lt;p&gt;
 724      *
 725      * The semantics of the list returned by this method become undefined if
 726      * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in
 727      * any way other than via the returned list.  (Structural modifications are
 728      * those that change the size of this list, or otherwise perturb it in such
 729      * a fashion that iterations in progress may yield incorrect results.)
 730      *
 731      * @param fromIndex low endpoint (inclusive) of the subList
 732      * @param toIndex high endpoint (exclusive) of the subList
 733      * @return a view of the specified range within this list
 734      * @throws IndexOutOfBoundsException for an illegal endpoint index value
 735      *         ({@code fromIndex &lt; 0 || toIndex &gt; size ||
 736      *         fromIndex &gt; toIndex})
 737      */
 738     List&lt;E&gt; subList(int fromIndex, int toIndex);
 739 
 740     /**
 741      * Creates a {@link Spliterator} over the elements in this list.
 742      *
 743      * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED} and
 744      * {@link Spliterator#ORDERED}.  Implementations should document the
 745      * reporting of additional characteristic values.
 746      *
 747      * @implSpec
 748      * The default implementation creates a
 749      * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;
 750      * spliterator as follows:
 751      * &lt;ul&gt;
 752      * &lt;li&gt;If the list is an instance of {@link RandomAccess} then the default
 753      *     implementation creates a spliterator that traverses elements by
 754      *     invoking the method {@link List#get}.  If such invocation results or
 755      *     would result in an {@code IndexOutOfBoundsException} then the
 756      *     spliterator will &lt;em&gt;fail-fast&lt;/em&gt; and throw a
 757      *     {@code ConcurrentModificationException}.
 758      *     If the list is also an instance of {@link AbstractList} then the
 759      *     spliterator will use the list&#39;s {@link AbstractList#modCount modCount}
 760      *     field to provide additional &lt;em&gt;fail-fast&lt;/em&gt; behavior.
 761      * &lt;li&gt;Otherwise, the default implementation creates a spliterator from the
 762      *     list&#39;s {@code Iterator}.  The spliterator inherits the
 763      *     &lt;em&gt;fail-fast&lt;/em&gt; of the list&#39;s iterator.
 764      * &lt;/ul&gt;
 765      *
 766      * @implNote
 767      * The created {@code Spliterator} additionally reports
 768      * {@link Spliterator#SUBSIZED}.
 769      *
 770      * @return a {@code Spliterator} over the elements in this list
 771      * @since 1.8
 772      */
 773     @Override
 774     default Spliterator&lt;E&gt; spliterator() {
 775         if (this instanceof RandomAccess) {
 776             return new AbstractList.RandomAccessSpliterator&lt;&gt;(this);
 777         } else {
 778             return Spliterators.spliterator(this, Spliterator.ORDERED);
 779         }
 780     }
 781 
 782     /**
 783      * Returns an unmodifiable list containing zero elements.
 784      *
 785      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 786      *
 787      * @param &lt;E&gt; the {@code List}&#39;s element type
 788      * @return an empty {@code List}
 789      *
 790      * @since 9
 791      */
 792     @SuppressWarnings(&quot;unchecked&quot;)
 793     static &lt;E&gt; List&lt;E&gt; of() {
 794         return (List&lt;E&gt;) ImmutableCollections.EMPTY_LIST;
 795     }
 796 
 797     /**
 798      * Returns an unmodifiable list containing one element.
 799      *
 800      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 801      *
 802      * @param &lt;E&gt; the {@code List}&#39;s element type
 803      * @param e1 the single element
 804      * @return a {@code List} containing the specified element
 805      * @throws NullPointerException if the element is {@code null}
 806      *
 807      * @since 9
 808      */
 809     static &lt;E&gt; List&lt;E&gt; of(E e1) {
 810         return new ImmutableCollections.List12&lt;&gt;(e1);
 811     }
 812 
 813     /**
 814      * Returns an unmodifiable list containing two elements.
 815      *
 816      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 817      *
 818      * @param &lt;E&gt; the {@code List}&#39;s element type
 819      * @param e1 the first element
 820      * @param e2 the second element
 821      * @return a {@code List} containing the specified elements
 822      * @throws NullPointerException if an element is {@code null}
 823      *
 824      * @since 9
 825      */
 826     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2) {
 827         return new ImmutableCollections.List12&lt;&gt;(e1, e2);
 828     }
 829 
 830     /**
 831      * Returns an unmodifiable list containing three elements.
 832      *
 833      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 834      *
 835      * @param &lt;E&gt; the {@code List}&#39;s element type
 836      * @param e1 the first element
 837      * @param e2 the second element
 838      * @param e3 the third element
 839      * @return a {@code List} containing the specified elements
 840      * @throws NullPointerException if an element is {@code null}
 841      *
 842      * @since 9
 843      */
 844     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3) {
 845         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3);
 846     }
 847 
 848     /**
 849      * Returns an unmodifiable list containing four elements.
 850      *
 851      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 852      *
 853      * @param &lt;E&gt; the {@code List}&#39;s element type
 854      * @param e1 the first element
 855      * @param e2 the second element
 856      * @param e3 the third element
 857      * @param e4 the fourth element
 858      * @return a {@code List} containing the specified elements
 859      * @throws NullPointerException if an element is {@code null}
 860      *
 861      * @since 9
 862      */
 863     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4) {
 864         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4);
 865     }
 866 
 867     /**
 868      * Returns an unmodifiable list containing five elements.
 869      *
 870      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 871      *
 872      * @param &lt;E&gt; the {@code List}&#39;s element type
 873      * @param e1 the first element
 874      * @param e2 the second element
 875      * @param e3 the third element
 876      * @param e4 the fourth element
 877      * @param e5 the fifth element
 878      * @return a {@code List} containing the specified elements
 879      * @throws NullPointerException if an element is {@code null}
 880      *
 881      * @since 9
 882      */
 883     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5) {
 884         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5);
 885     }
 886 
 887     /**
 888      * Returns an unmodifiable list containing six elements.
 889      *
 890      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 891      *
 892      * @param &lt;E&gt; the {@code List}&#39;s element type
 893      * @param e1 the first element
 894      * @param e2 the second element
 895      * @param e3 the third element
 896      * @param e4 the fourth element
 897      * @param e5 the fifth element
 898      * @param e6 the sixth element
 899      * @return a {@code List} containing the specified elements
 900      * @throws NullPointerException if an element is {@code null}
 901      *
 902      * @since 9
 903      */
 904     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6) {
 905         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,
 906                                                 e6);
 907     }
 908 
 909     /**
 910      * Returns an unmodifiable list containing seven elements.
 911      *
 912      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 913      *
 914      * @param &lt;E&gt; the {@code List}&#39;s element type
 915      * @param e1 the first element
 916      * @param e2 the second element
 917      * @param e3 the third element
 918      * @param e4 the fourth element
 919      * @param e5 the fifth element
 920      * @param e6 the sixth element
 921      * @param e7 the seventh element
 922      * @return a {@code List} containing the specified elements
 923      * @throws NullPointerException if an element is {@code null}
 924      *
 925      * @since 9
 926      */
 927     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {
 928         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,
 929                                                 e6, e7);
 930     }
 931 
 932     /**
 933      * Returns an unmodifiable list containing eight elements.
 934      *
 935      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 936      *
 937      * @param &lt;E&gt; the {@code List}&#39;s element type
 938      * @param e1 the first element
 939      * @param e2 the second element
 940      * @param e3 the third element
 941      * @param e4 the fourth element
 942      * @param e5 the fifth element
 943      * @param e6 the sixth element
 944      * @param e7 the seventh element
 945      * @param e8 the eighth element
 946      * @return a {@code List} containing the specified elements
 947      * @throws NullPointerException if an element is {@code null}
 948      *
 949      * @since 9
 950      */
 951     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {
 952         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,
 953                                                 e6, e7, e8);
 954     }
 955 
 956     /**
 957      * Returns an unmodifiable list containing nine elements.
 958      *
 959      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 960      *
 961      * @param &lt;E&gt; the {@code List}&#39;s element type
 962      * @param e1 the first element
 963      * @param e2 the second element
 964      * @param e3 the third element
 965      * @param e4 the fourth element
 966      * @param e5 the fifth element
 967      * @param e6 the sixth element
 968      * @param e7 the seventh element
 969      * @param e8 the eighth element
 970      * @param e9 the ninth element
 971      * @return a {@code List} containing the specified elements
 972      * @throws NullPointerException if an element is {@code null}
 973      *
 974      * @since 9
 975      */
 976     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {
 977         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,
 978                                                 e6, e7, e8, e9);
 979     }
 980 
 981     /**
 982      * Returns an unmodifiable list containing ten elements.
 983      *
 984      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 985      *
 986      * @param &lt;E&gt; the {@code List}&#39;s element type
 987      * @param e1 the first element
 988      * @param e2 the second element
 989      * @param e3 the third element
 990      * @param e4 the fourth element
 991      * @param e5 the fifth element
 992      * @param e6 the sixth element
 993      * @param e7 the seventh element
 994      * @param e8 the eighth element
 995      * @param e9 the ninth element
 996      * @param e10 the tenth element
 997      * @return a {@code List} containing the specified elements
 998      * @throws NullPointerException if an element is {@code null}
 999      *
1000      * @since 9
1001      */
1002     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {
1003         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,
1004                                                 e6, e7, e8, e9, e10);
1005     }
1006 
1007     /**
1008      * Returns an unmodifiable list containing an arbitrary number of elements.
1009      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
1010      *
1011      * @apiNote
1012      * This method also accepts a single array as an argument. The element type of
1013      * the resulting list will be the component type of the array, and the size of
1014      * the list will be equal to the length of the array. To create a list with
1015      * a single element that is an array, do the following:
1016      *
1017      * &lt;pre&gt;{@code
1018      *     String[] array = ... ;
1019      *     List&lt;String[]&gt; list = List.&lt;String[]&gt;of(array);
1020      * }&lt;/pre&gt;
1021      *
1022      * This will cause the {@link List#of(Object) List.of(E)} method
1023      * to be invoked instead.
1024      *
1025      * @param &lt;E&gt; the {@code List}&#39;s element type
1026      * @param elements the elements to be contained in the list
1027      * @return a {@code List} containing the specified elements
1028      * @throws NullPointerException if an element is {@code null} or if the array is {@code null}
1029      *
1030      * @since 9
1031      */
1032     @SafeVarargs
1033     @SuppressWarnings(&quot;varargs&quot;)
1034     static &lt;E&gt; List&lt;E&gt; of(E... elements) {
1035         switch (elements.length) { // implicit null check of elements
1036             case 0:
1037                 @SuppressWarnings(&quot;unchecked&quot;)
1038                 var list = (List&lt;E&gt;) ImmutableCollections.EMPTY_LIST;
1039                 return list;
1040             case 1:
1041                 return new ImmutableCollections.List12&lt;&gt;(elements[0]);
1042             case 2:
1043                 return new ImmutableCollections.List12&lt;&gt;(elements[0], elements[1]);
1044             default:
1045                 return new ImmutableCollections.ListN&lt;&gt;(elements);
1046         }
1047     }
1048 
1049     /**
1050      * Returns an &lt;a href=&quot;#unmodifiable&quot;&gt;unmodifiable List&lt;/a&gt; containing the elements of
1051      * the given Collection, in its iteration order. The given Collection must not be null,
1052      * and it must not contain any null elements. If the given Collection is subsequently
1053      * modified, the returned List will not reflect such modifications.
1054      *
1055      * @implNote
1056      * If the given Collection is an &lt;a href=&quot;#unmodifiable&quot;&gt;unmodifiable List&lt;/a&gt;,
1057      * calling copyOf will generally not create a copy.
1058      *
1059      * @param &lt;E&gt; the {@code List}&#39;s element type
1060      * @param coll a {@code Collection} from which elements are drawn, must be non-null
1061      * @return a {@code List} containing the elements of the given {@code Collection}
1062      * @throws NullPointerException if coll is null, or if it contains any nulls
1063      * @since 10
1064      */
1065     static &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) {
1066         return ImmutableCollections.listCopy(coll);
1067     }
1068 }
    </pre>
  </body>
</html>
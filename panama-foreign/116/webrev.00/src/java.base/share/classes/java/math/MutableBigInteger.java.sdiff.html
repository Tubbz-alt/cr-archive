<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/math/MutableBigInteger.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../lang/invoke/MethodType.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../net/SocketPermission.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/math/MutableBigInteger.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2161         // Newton&#39;s iteration!
2162         long t = val;
2163         t *= 2 - val*t;
2164         t *= 2 - val*t;
2165         t *= 2 - val*t;
2166         t *= 2 - val*t;
2167         t *= 2 - val*t;
2168         assert(t * val == 1);
2169         return t;
2170     }
2171 
2172     /**
2173      * Calculate the multiplicative inverse of 2^k mod mod, where mod is odd.
2174      */
2175     static MutableBigInteger modInverseBP2(MutableBigInteger mod, int k) {
2176         // Copy the mod to protect original
2177         return fixup(new MutableBigInteger(1), new MutableBigInteger(mod), k);
2178     }
2179 
2180     /**
<span class="line-modified">2181      * Calculate the multiplicative inverse of this mod mod, where mod is odd.</span>
<span class="line-modified">2182      * This and mod are not changed by the calculation.</span>
2183      *
2184      * This method implements an algorithm due to Richard Schroeppel, that uses
2185      * the same intermediate representation as Montgomery Reduction
2186      * (&quot;Montgomery Form&quot;).  The algorithm is described in an unpublished
2187      * manuscript entitled &quot;Fast Modular Reciprocals.&quot;
2188      */
2189     private MutableBigInteger modInverse(MutableBigInteger mod) {
2190         MutableBigInteger p = new MutableBigInteger(mod);
2191         MutableBigInteger f = new MutableBigInteger(this);
2192         MutableBigInteger g = new MutableBigInteger(p);
2193         SignedMutableBigInteger c = new SignedMutableBigInteger(1);
2194         SignedMutableBigInteger d = new SignedMutableBigInteger();
2195         MutableBigInteger temp = null;
2196         SignedMutableBigInteger sTemp = null;
2197 
2198         int k = 0;
2199         // Right shift f k times until odd, left shift d k times
2200         if (f.isEven()) {
2201             int trailingZeros = f.getLowestSetBit();
2202             f.rightShift(trailingZeros);
</pre>
<hr />
<pre>
2216                 sTemp = d; d = c; c = sTemp;
2217             }
2218 
2219             // If f == g (mod 4)
2220             if (((f.value[f.offset + f.intLen - 1] ^
2221                  g.value[g.offset + g.intLen - 1]) &amp; 3) == 0) {
2222                 f.subtract(g);
2223                 c.signedSubtract(d);
2224             } else { // If f != g (mod 4)
2225                 f.add(g);
2226                 c.signedAdd(d);
2227             }
2228 
2229             // Right shift f k times until odd, left shift d k times
2230             int trailingZeros = f.getLowestSetBit();
2231             f.rightShift(trailingZeros);
2232             d.leftShift(trailingZeros);
2233             k += trailingZeros;
2234         }
2235 
<span class="line-modified">2236         while (c.sign &lt; 0)</span>
<span class="line-modified">2237            c.signedAdd(p);</span>










2238 
2239         return fixup(c, p, k);
2240     }
2241 
2242     /**
2243      * The Fixup Algorithm
2244      * Calculates X such that X = C * 2^(-k) (mod P)
2245      * Assumes C&lt;P and P is odd.
2246      */
2247     static MutableBigInteger fixup(MutableBigInteger c, MutableBigInteger p,
2248                                                                       int k) {
2249         MutableBigInteger temp = new MutableBigInteger();
2250         // Set r to the multiplicative inverse of p mod 2^32
2251         int r = -inverseMod32(p.value[p.offset+p.intLen-1]);
2252 
2253         for (int i=0, numWords = k &gt;&gt; 5; i &lt; numWords; i++) {
2254             // V = R * c (mod 2^j)
2255             int  v = r * c.value[c.offset + c.intLen-1];
2256             // c = c + (v * p)
2257             p.mul(v, temp);
2258             c.add(temp);
2259             // c = c / 2^j
2260             c.intLen--;
2261         }
2262         int numBits = k &amp; 0x1f;
2263         if (numBits != 0) {
2264             // V = R * c (mod 2^j)
2265             int v = r * c.value[c.offset + c.intLen-1];
2266             v &amp;= ((1&lt;&lt;numBits) - 1);
2267             // c = c + (v * p)
2268             p.mul(v, temp);
2269             c.add(temp);
2270             // c = c / 2^j
2271             c.rightShift(numBits);
2272         }
2273 
2274         // In theory, c may be greater than p at this point (Very rare!)
<span class="line-modified">2275         while (c.compare(p) &gt;= 0)</span>
<span class="line-modified">2276             c.subtract(p);</span>
2277 
2278         return c;
2279     }
2280 
2281     /**
2282      * Uses the extended Euclidean algorithm to compute the modInverse of base
2283      * mod a modulus that is a power of 2. The modulus is 2^k.
2284      */
2285     MutableBigInteger euclidModInverse(int k) {
2286         MutableBigInteger b = new MutableBigInteger(1);
2287         b.leftShift(k);
2288         MutableBigInteger mod = new MutableBigInteger(b);
2289 
2290         MutableBigInteger a = new MutableBigInteger(this);
2291         MutableBigInteger q = new MutableBigInteger();
2292         MutableBigInteger r = b.divide(a, q);
2293 
2294         MutableBigInteger swapper = b;
2295         // swap b &amp; r
2296         b = r;
</pre>
</td>
<td>
<hr />
<pre>
2161         // Newton&#39;s iteration!
2162         long t = val;
2163         t *= 2 - val*t;
2164         t *= 2 - val*t;
2165         t *= 2 - val*t;
2166         t *= 2 - val*t;
2167         t *= 2 - val*t;
2168         assert(t * val == 1);
2169         return t;
2170     }
2171 
2172     /**
2173      * Calculate the multiplicative inverse of 2^k mod mod, where mod is odd.
2174      */
2175     static MutableBigInteger modInverseBP2(MutableBigInteger mod, int k) {
2176         // Copy the mod to protect original
2177         return fixup(new MutableBigInteger(1), new MutableBigInteger(mod), k);
2178     }
2179 
2180     /**
<span class="line-modified">2181      * Calculate the multiplicative inverse of this modulo mod, where the mod</span>
<span class="line-modified">2182      * argument is odd.  This and mod are not changed by the calculation.</span>
2183      *
2184      * This method implements an algorithm due to Richard Schroeppel, that uses
2185      * the same intermediate representation as Montgomery Reduction
2186      * (&quot;Montgomery Form&quot;).  The algorithm is described in an unpublished
2187      * manuscript entitled &quot;Fast Modular Reciprocals.&quot;
2188      */
2189     private MutableBigInteger modInverse(MutableBigInteger mod) {
2190         MutableBigInteger p = new MutableBigInteger(mod);
2191         MutableBigInteger f = new MutableBigInteger(this);
2192         MutableBigInteger g = new MutableBigInteger(p);
2193         SignedMutableBigInteger c = new SignedMutableBigInteger(1);
2194         SignedMutableBigInteger d = new SignedMutableBigInteger();
2195         MutableBigInteger temp = null;
2196         SignedMutableBigInteger sTemp = null;
2197 
2198         int k = 0;
2199         // Right shift f k times until odd, left shift d k times
2200         if (f.isEven()) {
2201             int trailingZeros = f.getLowestSetBit();
2202             f.rightShift(trailingZeros);
</pre>
<hr />
<pre>
2216                 sTemp = d; d = c; c = sTemp;
2217             }
2218 
2219             // If f == g (mod 4)
2220             if (((f.value[f.offset + f.intLen - 1] ^
2221                  g.value[g.offset + g.intLen - 1]) &amp; 3) == 0) {
2222                 f.subtract(g);
2223                 c.signedSubtract(d);
2224             } else { // If f != g (mod 4)
2225                 f.add(g);
2226                 c.signedAdd(d);
2227             }
2228 
2229             // Right shift f k times until odd, left shift d k times
2230             int trailingZeros = f.getLowestSetBit();
2231             f.rightShift(trailingZeros);
2232             d.leftShift(trailingZeros);
2233             k += trailingZeros;
2234         }
2235 
<span class="line-modified">2236         if (c.compare(p) &gt;= 0) { // c has a larger magnitude than p</span>
<span class="line-modified">2237             MutableBigInteger remainder = c.divide(p,</span>
<span class="line-added">2238                 new MutableBigInteger());</span>
<span class="line-added">2239             // The previous line ignores the sign so we copy the data back</span>
<span class="line-added">2240             // into c which will restore the sign as needed (and converts</span>
<span class="line-added">2241             // it back to a SignedMutableBigInteger)</span>
<span class="line-added">2242             c.copyValue(remainder);</span>
<span class="line-added">2243         }</span>
<span class="line-added">2244 </span>
<span class="line-added">2245         if (c.sign &lt; 0) {</span>
<span class="line-added">2246             c.signedAdd(p);</span>
<span class="line-added">2247         }</span>
2248 
2249         return fixup(c, p, k);
2250     }
2251 
2252     /**
2253      * The Fixup Algorithm
2254      * Calculates X such that X = C * 2^(-k) (mod P)
2255      * Assumes C&lt;P and P is odd.
2256      */
2257     static MutableBigInteger fixup(MutableBigInteger c, MutableBigInteger p,
2258                                                                       int k) {
2259         MutableBigInteger temp = new MutableBigInteger();
2260         // Set r to the multiplicative inverse of p mod 2^32
2261         int r = -inverseMod32(p.value[p.offset+p.intLen-1]);
2262 
2263         for (int i=0, numWords = k &gt;&gt; 5; i &lt; numWords; i++) {
2264             // V = R * c (mod 2^j)
2265             int  v = r * c.value[c.offset + c.intLen-1];
2266             // c = c + (v * p)
2267             p.mul(v, temp);
2268             c.add(temp);
2269             // c = c / 2^j
2270             c.intLen--;
2271         }
2272         int numBits = k &amp; 0x1f;
2273         if (numBits != 0) {
2274             // V = R * c (mod 2^j)
2275             int v = r * c.value[c.offset + c.intLen-1];
2276             v &amp;= ((1&lt;&lt;numBits) - 1);
2277             // c = c + (v * p)
2278             p.mul(v, temp);
2279             c.add(temp);
2280             // c = c / 2^j
2281             c.rightShift(numBits);
2282         }
2283 
2284         // In theory, c may be greater than p at this point (Very rare!)
<span class="line-modified">2285         if (c.compare(p) &gt;= 0)</span>
<span class="line-modified">2286             c = c.divide(p, new MutableBigInteger());</span>
2287 
2288         return c;
2289     }
2290 
2291     /**
2292      * Uses the extended Euclidean algorithm to compute the modInverse of base
2293      * mod a modulus that is a power of 2. The modulus is 2^k.
2294      */
2295     MutableBigInteger euclidModInverse(int k) {
2296         MutableBigInteger b = new MutableBigInteger(1);
2297         b.leftShift(k);
2298         MutableBigInteger mod = new MutableBigInteger(b);
2299 
2300         MutableBigInteger a = new MutableBigInteger(this);
2301         MutableBigInteger q = new MutableBigInteger();
2302         MutableBigInteger r = b.divide(a, q);
2303 
2304         MutableBigInteger swapper = b;
2305         // swap b &amp; r
2306         b = r;
</pre>
</td>
</tr>
</table>
<center><a href="../lang/invoke/MethodType.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../net/SocketPermission.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
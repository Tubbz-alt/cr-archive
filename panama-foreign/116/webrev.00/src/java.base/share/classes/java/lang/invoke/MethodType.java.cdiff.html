<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/MethodType.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../VersionProps.java.template.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../math/MutableBigInteger.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodType.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 114,11 ***</span>
      private final @Stable Class&lt;?&gt;   rtype;
      private final @Stable Class&lt;?&gt;[] ptypes;
  
      // The remaining fields are caches of various sorts:
      private @Stable MethodTypeForm form; // erased form, plus cached data about primitives
<span class="line-modified">!     private @Stable MethodType wrapAlt;  // alternative wrapped/unwrapped version</span>
      private @Stable Invokers invokers;   // cache of handy higher-order adapters
      private @Stable String methodDescriptor;  // cache for toMethodDescriptorString
  
      /**
       * Constructor that performs no copying or validation.
<span class="line-new-header">--- 114,12 ---</span>
      private final @Stable Class&lt;?&gt;   rtype;
      private final @Stable Class&lt;?&gt;[] ptypes;
  
      // The remaining fields are caches of various sorts:
      private @Stable MethodTypeForm form; // erased form, plus cached data about primitives
<span class="line-modified">!     private @Stable Object wrapAlt;  // alternative wrapped/unwrapped version and</span>
<span class="line-added">+                                      // private communication for readObject and readResolve</span>
      private @Stable Invokers invokers;   // cache of handy higher-order adapters
      private @Stable String methodDescriptor;  // cache for toMethodDescriptorString
  
      /**
       * Constructor that performs no copying or validation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 709,11 ***</span>
          return unwrapWithNoPrims(noprims);
      }
  
      private static MethodType wrapWithPrims(MethodType pt) {
          assert(pt.hasPrimitives());
<span class="line-modified">!         MethodType wt = pt.wrapAlt;</span>
          if (wt == null) {
              // fill in lazily
              wt = MethodTypeForm.canonicalize(pt, MethodTypeForm.WRAP, MethodTypeForm.WRAP);
              assert(wt != null);
              pt.wrapAlt = wt;
<span class="line-new-header">--- 710,11 ---</span>
          return unwrapWithNoPrims(noprims);
      }
  
      private static MethodType wrapWithPrims(MethodType pt) {
          assert(pt.hasPrimitives());
<span class="line-modified">!         MethodType wt = (MethodType)pt.wrapAlt;</span>
          if (wt == null) {
              // fill in lazily
              wt = MethodTypeForm.canonicalize(pt, MethodTypeForm.WRAP, MethodTypeForm.WRAP);
              assert(wt != null);
              pt.wrapAlt = wt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 721,11 ***</span>
          return wt;
      }
  
      private static MethodType unwrapWithNoPrims(MethodType wt) {
          assert(!wt.hasPrimitives());
<span class="line-modified">!         MethodType uwt = wt.wrapAlt;</span>
          if (uwt == null) {
              // fill in lazily
              uwt = MethodTypeForm.canonicalize(wt, MethodTypeForm.UNWRAP, MethodTypeForm.UNWRAP);
              if (uwt == null)
                  uwt = wt;    // type has no wrappers or prims at all
<span class="line-new-header">--- 722,11 ---</span>
          return wt;
      }
  
      private static MethodType unwrapWithNoPrims(MethodType wt) {
          assert(!wt.hasPrimitives());
<span class="line-modified">!         MethodType uwt = (MethodType)wt.wrapAlt;</span>
          if (uwt == null) {
              // fill in lazily
              uwt = MethodTypeForm.canonicalize(wt, MethodTypeForm.UNWRAP, MethodTypeForm.UNWRAP);
              if (uwt == null)
                  uwt = wt;    // type has no wrappers or prims at all
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1246,31 ***</span>
       * @see #readResolve
       * @see #writeObject
       */
      @java.io.Serial
      private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
<span class="line-modified">!         // Assign temporary defaults in case this object escapes</span>
<span class="line-modified">!         MethodType_init(void.class, NO_PTYPES);</span>
  
          s.defaultReadObject();  // requires serialPersistentFields to be an empty array
  
          Class&lt;?&gt;   returnType     = (Class&lt;?&gt;)   s.readObject();
          Class&lt;?&gt;[] parameterArray = (Class&lt;?&gt;[]) s.readObject();
<span class="line-removed">-         parameterArray = parameterArray.clone();  // make sure it is unshared</span>
  
<span class="line-modified">!         // Assign deserialized values</span>
<span class="line-modified">!         MethodType_init(returnType, parameterArray);</span>
<span class="line-modified">!     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Initialization of state for deserialization only</span>
<span class="line-removed">-     private void MethodType_init(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {</span>
<span class="line-removed">-         // In order to communicate these values to readResolve, we must</span>
<span class="line-removed">-         // store them into the implementation-specific final fields.</span>
<span class="line-removed">-         checkRtype(rtype);</span>
<span class="line-removed">-         checkPtypes(ptypes);</span>
<span class="line-removed">-         UNSAFE.putReference(this, OffsetHolder.rtypeOffset, rtype);</span>
<span class="line-removed">-         UNSAFE.putReference(this, OffsetHolder.ptypesOffset, ptypes);</span>
      }
  
      // Support for resetting final fields while deserializing. Implement Holder
      // pattern to make the rarely needed offset calculation lazy.
      private static class OffsetHolder {
<span class="line-new-header">--- 1247,22 ---</span>
       * @see #readResolve
       * @see #writeObject
       */
      @java.io.Serial
      private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
<span class="line-modified">!         // Assign defaults in case this object escapes</span>
<span class="line-modified">!         UNSAFE.putReference(this, OffsetHolder.rtypeOffset, void.class);</span>
<span class="line-added">+         UNSAFE.putReference(this, OffsetHolder.ptypesOffset, NO_PTYPES);</span>
  
          s.defaultReadObject();  // requires serialPersistentFields to be an empty array
  
          Class&lt;?&gt;   returnType     = (Class&lt;?&gt;)   s.readObject();
          Class&lt;?&gt;[] parameterArray = (Class&lt;?&gt;[]) s.readObject();
  
<span class="line-modified">!         // Verify all operands, and make sure ptypes is unshared</span>
<span class="line-modified">!         // Cache the new MethodType for readResolve</span>
<span class="line-modified">!         wrapAlt = new MethodType[]{MethodType.methodType(returnType, parameterArray)};</span>
      }
  
      // Support for resetting final fields while deserializing. Implement Holder
      // pattern to make the rarely needed offset calculation lazy.
      private static class OffsetHolder {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1289,16 ***</span>
      @java.io.Serial
      private Object readResolve() {
          // Do not use a trusted path for deserialization:
          //    return makeImpl(rtype, ptypes, true);
          // Verify all operands, and make sure ptypes is unshared:
<span class="line-modified">!         try {</span>
<span class="line-modified">!             return methodType(rtype, ptypes);</span>
<span class="line-modified">!         } finally {</span>
<span class="line-modified">!             // Re-assign defaults in case this object escapes</span>
<span class="line-removed">-             MethodType_init(void.class, NO_PTYPES);</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Simple implementation of weak concurrent intern set.
       *
<span class="line-new-header">--- 1281,14 ---</span>
      @java.io.Serial
      private Object readResolve() {
          // Do not use a trusted path for deserialization:
          //    return makeImpl(rtype, ptypes, true);
          // Verify all operands, and make sure ptypes is unshared:
<span class="line-modified">!         // Return a new validated MethodType for the rtype and ptypes passed from readObject.</span>
<span class="line-modified">!         MethodType mt = ((MethodType[])wrapAlt)[0];</span>
<span class="line-modified">!         wrapAlt = null;</span>
<span class="line-modified">!         return mt;</span>
      }
  
      /**
       * Simple implementation of weak concurrent intern set.
       *
</pre>
<center><a href="../VersionProps.java.template.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../math/MutableBigInteger.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/util/zip/ZipFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util.zip;
  27 
  28 import java.io.Closeable;
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.EOFException;
  32 import java.io.File;
  33 import java.io.RandomAccessFile;
  34 import java.io.UncheckedIOException;
  35 import java.lang.ref.Cleaner.Cleanable;
  36 import java.nio.charset.Charset;
  37 import java.nio.file.InvalidPathException;
  38 import java.nio.file.attribute.BasicFileAttributes;
  39 import java.nio.file.Files;
  40 import java.util.ArrayDeque;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collections;
  44 import java.util.Deque;
  45 import java.util.Enumeration;
  46 import java.util.HashMap;
  47 import java.util.Iterator;
  48 import java.util.Objects;
  49 import java.util.NoSuchElementException;
  50 import java.util.Set;
  51 import java.util.Spliterator;
  52 import java.util.Spliterators;
  53 import java.util.WeakHashMap;
  54 import java.util.function.Consumer;
  55 import java.util.function.Function;
  56 import java.util.function.IntFunction;
  57 import java.util.jar.JarEntry;
  58 import java.util.stream.Stream;
  59 import java.util.stream.StreamSupport;
  60 import jdk.internal.access.JavaLangAccess;
  61 import jdk.internal.access.JavaUtilZipFileAccess;
  62 import jdk.internal.access.SharedSecrets;
  63 import jdk.internal.misc.VM;
  64 import jdk.internal.perf.PerfCounter;
  65 import jdk.internal.ref.CleanerFactory;
  66 import jdk.internal.vm.annotation.Stable;
  67 import sun.nio.cs.UTF_8;
  68 
  69 import static java.util.zip.ZipConstants64.*;
  70 import static java.util.zip.ZipUtils.*;
  71 
  72 /**
  73  * This class is used to read entries from a zip file.
  74  *
  75  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  76  * or method in this class will cause a {@link NullPointerException} to be
  77  * thrown.
  78  *
  79  * @apiNote
  80  * To release resources used by this {@code ZipFile}, the {@link #close()} method
  81  * should be called explicitly or by try-with-resources. Subclasses are responsible
  82  * for the cleanup of resources acquired by the subclass. Subclasses that override
  83  * {@link #finalize()} in order to perform cleanup should be modified to use alternative
  84  * cleanup mechanisms such as {@link java.lang.ref.Cleaner} and remove the overriding
  85  * {@code finalize} method.
  86  *
  87  * @author      David Connelly
  88  * @since 1.1
  89  */
  90 public class ZipFile implements ZipConstants, Closeable {
  91 
  92     private final String name;     // zip file name
  93     private volatile boolean closeRequested;
  94     private final @Stable ZipCoder zc;
  95 
  96     // The &quot;resource&quot; used by this zip file that needs to be
  97     // cleaned after use.
  98     // a) the input streams that need to be closed
  99     // b) the list of cached Inflater objects
 100     // c) the &quot;native&quot; source of this zip file.
 101     private final @Stable CleanableResource res;
 102 
 103     private static final int STORED = ZipEntry.STORED;
 104     private static final int DEFLATED = ZipEntry.DEFLATED;
 105 
 106     /**
 107      * Mode flag to open a zip file for reading.
 108      */
 109     public static final int OPEN_READ = 0x1;
 110 
 111     /**
 112      * Mode flag to open a zip file and mark it for deletion.  The file will be
 113      * deleted some time between the moment that it is opened and the moment
 114      * that it is closed, but its contents will remain accessible via the
 115      * {@code ZipFile} object until either the close method is invoked or the
 116      * virtual machine exits.
 117      */
 118     public static final int OPEN_DELETE = 0x4;
 119 
 120     /**
 121      * Opens a zip file for reading.
 122      *
 123      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 124      * method is called with the {@code name} argument as its argument
 125      * to ensure the read is allowed.
 126      *
 127      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 128      * decode the entry names and comments.
 129      *
 130      * @param name the name of the zip file
 131      * @throws ZipException if a ZIP format error has occurred
 132      * @throws IOException if an I/O error has occurred
 133      * @throws SecurityException if a security manager exists and its
 134      *         {@code checkRead} method doesn&#39;t allow read access to the file.
 135      *
 136      * @see SecurityManager#checkRead(java.lang.String)
 137      */
 138     public ZipFile(String name) throws IOException {
 139         this(new File(name), OPEN_READ);
 140     }
 141 
 142     /**
 143      * Opens a new {@code ZipFile} to read from the specified
 144      * {@code File} object in the specified mode.  The mode argument
 145      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
 146      *
 147      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 148      * method is called with the {@code name} argument as its argument to
 149      * ensure the read is allowed.
 150      *
 151      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 152      * decode the entry names and comments
 153      *
 154      * @param file the ZIP file to be opened for reading
 155      * @param mode the mode in which the file is to be opened
 156      * @throws ZipException if a ZIP format error has occurred
 157      * @throws IOException if an I/O error has occurred
 158      * @throws SecurityException if a security manager exists and
 159      *         its {@code checkRead} method
 160      *         doesn&#39;t allow read access to the file,
 161      *         or its {@code checkDelete} method doesn&#39;t allow deleting
 162      *         the file when the {@code OPEN_DELETE} flag is set.
 163      * @throws IllegalArgumentException if the {@code mode} argument is invalid
 164      * @see SecurityManager#checkRead(java.lang.String)
 165      * @since 1.3
 166      */
 167     public ZipFile(File file, int mode) throws IOException {
 168         this(file, mode, UTF_8.INSTANCE);
 169     }
 170 
 171     /**
 172      * Opens a ZIP file for reading given the specified File object.
 173      *
 174      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 175      * decode the entry names and comments.
 176      *
 177      * @param file the ZIP file to be opened for reading
 178      * @throws ZipException if a ZIP format error has occurred
 179      * @throws IOException if an I/O error has occurred
 180      */
 181     public ZipFile(File file) throws ZipException, IOException {
 182         this(file, OPEN_READ);
 183     }
 184 
 185     /**
 186      * Opens a new {@code ZipFile} to read from the specified
 187      * {@code File} object in the specified mode.  The mode argument
 188      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
 189      *
 190      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 191      * method is called with the {@code name} argument as its argument to
 192      * ensure the read is allowed.
 193      *
 194      * @param file the ZIP file to be opened for reading
 195      * @param mode the mode in which the file is to be opened
 196      * @param charset
 197      *        the {@linkplain java.nio.charset.Charset charset} to
 198      *        be used to decode the ZIP entry name and comment that are not
 199      *        encoded by using UTF-8 encoding (indicated by entry&#39;s general
 200      *        purpose flag).
 201      *
 202      * @throws ZipException if a ZIP format error has occurred
 203      * @throws IOException if an I/O error has occurred
 204      *
 205      * @throws SecurityException
 206      *         if a security manager exists and its {@code checkRead}
 207      *         method doesn&#39;t allow read access to the file,or its
 208      *         {@code checkDelete} method doesn&#39;t allow deleting the
 209      *         file when the {@code OPEN_DELETE} flag is set
 210      *
 211      * @throws IllegalArgumentException if the {@code mode} argument is invalid
 212      *
 213      * @see SecurityManager#checkRead(java.lang.String)
 214      *
 215      * @since 1.7
 216      */
 217     public ZipFile(File file, int mode, Charset charset) throws IOException
 218     {
 219         if (((mode &amp; OPEN_READ) == 0) ||
 220             ((mode &amp; ~(OPEN_READ | OPEN_DELETE)) != 0)) {
 221             throw new IllegalArgumentException(&quot;Illegal mode: 0x&quot;+
 222                                                Integer.toHexString(mode));
 223         }
 224         String name = file.getPath();
 225         SecurityManager sm = System.getSecurityManager();
 226         if (sm != null) {
 227             sm.checkRead(name);
 228             if ((mode &amp; OPEN_DELETE) != 0) {
 229                 sm.checkDelete(name);
 230             }
 231         }
 232         Objects.requireNonNull(charset, &quot;charset&quot;);
 233 
 234         this.zc = ZipCoder.get(charset);
 235         this.name = name;
 236         long t0 = System.nanoTime();
 237 
 238         this.res = new CleanableResource(this, file, mode);
 239 
 240         PerfCounter.getZipFileOpenTime().addElapsedTimeFrom(t0);
 241         PerfCounter.getZipFileCount().increment();
 242     }
 243 
 244     /**
 245      * Opens a zip file for reading.
 246      *
 247      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 248      * method is called with the {@code name} argument as its argument
 249      * to ensure the read is allowed.
 250      *
 251      * @param name the name of the zip file
 252      * @param charset
 253      *        the {@linkplain java.nio.charset.Charset charset} to
 254      *        be used to decode the ZIP entry name and comment that are not
 255      *        encoded by using UTF-8 encoding (indicated by entry&#39;s general
 256      *        purpose flag).
 257      *
 258      * @throws ZipException if a ZIP format error has occurred
 259      * @throws IOException if an I/O error has occurred
 260      * @throws SecurityException
 261      *         if a security manager exists and its {@code checkRead}
 262      *         method doesn&#39;t allow read access to the file
 263      *
 264      * @see SecurityManager#checkRead(java.lang.String)
 265      *
 266      * @since 1.7
 267      */
 268     public ZipFile(String name, Charset charset) throws IOException
 269     {
 270         this(new File(name), OPEN_READ, charset);
 271     }
 272 
 273     /**
 274      * Opens a ZIP file for reading given the specified File object.
 275      *
 276      * @param file the ZIP file to be opened for reading
 277      * @param charset
 278      *        The {@linkplain java.nio.charset.Charset charset} to be
 279      *        used to decode the ZIP entry name and comment (ignored if
 280      *        the &lt;a href=&quot;package-summary.html#lang_encoding&quot;&gt; language
 281      *        encoding bit&lt;/a&gt; of the ZIP entry&#39;s general purpose bit
 282      *        flag is set).
 283      *
 284      * @throws ZipException if a ZIP format error has occurred
 285      * @throws IOException if an I/O error has occurred
 286      *
 287      * @since 1.7
 288      */
 289     public ZipFile(File file, Charset charset) throws IOException
 290     {
 291         this(file, OPEN_READ, charset);
 292     }
 293 
 294     /**
 295      * Returns the zip file comment, or null if none.
 296      *
 297      * @return the comment string for the zip file, or null if none
 298      *
 299      * @throws IllegalStateException if the zip file has been closed
 300      *
 301      * @since 1.7
 302      */
 303     public String getComment() {
 304         synchronized (this) {
 305             ensureOpen();
 306             if (res.zsrc.comment == null) {
 307                 return null;
 308             }
 309             return zc.toString(res.zsrc.comment);
 310         }
 311     }
 312 
 313     /**
 314      * Returns the zip file entry for the specified name, or null
 315      * if not found.
 316      *
 317      * @param name the name of the entry
 318      * @return the zip file entry, or null if not found
 319      * @throws IllegalStateException if the zip file has been closed
 320      */
 321     public ZipEntry getEntry(String name) {
 322         return getEntry(name, ZipEntry::new);
 323     }
 324 
 325     /*
 326      * Returns the zip file entry for the specified name, or null
 327      * if not found.
 328      *
 329      * @param name the name of the entry
 330      * @param func the function that creates the returned entry
 331      *
 332      * @return the zip file entry, or null if not found
 333      * @throws IllegalStateException if the zip file has been closed
 334      */
 335     private ZipEntry getEntry(String name, Function&lt;String, ? extends ZipEntry&gt; func) {
 336         Objects.requireNonNull(name, &quot;name&quot;);
 337         synchronized (this) {
 338             ensureOpen();
 339             byte[] bname = zc.getBytes(name);
 340             int pos = res.zsrc.getEntryPos(bname, true);
 341             if (pos != -1) {
 342                 return getZipEntry(name, bname, pos, func);
 343             }
 344         }
 345         return null;
 346     }
 347 
 348     /**
 349      * Returns an input stream for reading the contents of the specified
 350      * zip file entry.
 351      * &lt;p&gt;
 352      * Closing this ZIP file will, in turn, close all input streams that
 353      * have been returned by invocations of this method.
 354      *
 355      * @param entry the zip file entry
 356      * @return the input stream for reading the contents of the specified
 357      * zip file entry.
 358      * @throws ZipException if a ZIP format error has occurred
 359      * @throws IOException if an I/O error has occurred
 360      * @throws IllegalStateException if the zip file has been closed
 361      */
 362     public InputStream getInputStream(ZipEntry entry) throws IOException {
 363         Objects.requireNonNull(entry, &quot;entry&quot;);
 364         int pos = -1;
 365         ZipFileInputStream in;
 366         Source zsrc = res.zsrc;
 367         Set&lt;InputStream&gt; istreams = res.istreams;
 368         synchronized (this) {
 369             ensureOpen();
 370             if (Objects.equals(lastEntryName, entry.name)) {
 371                 pos = lastEntryPos;
 372             } else if (!zc.isUTF8() &amp;&amp; (entry.flag &amp; USE_UTF8) != 0) {
 373                 pos = zsrc.getEntryPos(zc.getBytesUTF8(entry.name), false);
 374             } else {
 375                 pos = zsrc.getEntryPos(zc.getBytes(entry.name), false);
 376             }
 377             if (pos == -1) {
 378                 return null;
 379             }
 380             in = new ZipFileInputStream(zsrc.cen, pos);
 381             switch (CENHOW(zsrc.cen, pos)) {
 382             case STORED:
 383                 synchronized (istreams) {
 384                     istreams.add(in);
 385                 }
 386                 return in;
 387             case DEFLATED:
 388                 // Inflater likes a bit of slack
 389                 // MORE: Compute good size for inflater stream:
 390                 long size = CENLEN(zsrc.cen, pos) + 2;
 391                 if (size &gt; 65536) {
 392                     size = 8192;
 393                 }
 394                 if (size &lt;= 0) {
 395                     size = 4096;
 396                 }
 397                 InputStream is = new ZipFileInflaterInputStream(in, res, (int)size);
 398                 synchronized (istreams) {
 399                     istreams.add(is);
 400                 }
 401                 return is;
 402             default:
 403                 throw new ZipException(&quot;invalid compression method&quot;);
 404             }
 405         }
 406     }
 407 
 408     private static class InflaterCleanupAction implements Runnable {
 409         private final Inflater inf;
 410         private final CleanableResource res;
 411 
 412         InflaterCleanupAction(Inflater inf, CleanableResource res) {
 413             this.inf = inf;
 414             this.res = res;
 415         }
 416 
 417         @Override
 418         public void run() {
 419             res.releaseInflater(inf);
 420         }
 421     }
 422 
 423     private class ZipFileInflaterInputStream extends InflaterInputStream {
 424         private volatile boolean closeRequested;
 425         private boolean eof = false;
 426         private final Cleanable cleanable;
 427 
 428         ZipFileInflaterInputStream(ZipFileInputStream zfin,
 429                                    CleanableResource res, int size) {
 430             this(zfin, res, res.getInflater(), size);
 431         }
 432 
 433         private ZipFileInflaterInputStream(ZipFileInputStream zfin,
 434                                            CleanableResource res,
 435                                            Inflater inf, int size) {
 436             super(zfin, inf, size);
 437             this.cleanable = CleanerFactory.cleaner().register(this,
 438                     new InflaterCleanupAction(inf, res));
 439         }
 440 
 441         public void close() throws IOException {
 442             if (closeRequested)
 443                 return;
 444             closeRequested = true;
 445             super.close();
 446             synchronized (res.istreams) {
 447                 res.istreams.remove(this);
 448             }
 449             cleanable.clean();
 450         }
 451 
 452         // Override fill() method to provide an extra &quot;dummy&quot; byte
 453         // at the end of the input stream. This is required when
 454         // using the &quot;nowrap&quot; Inflater option.
 455         protected void fill() throws IOException {
 456             if (eof) {
 457                 throw new EOFException(&quot;Unexpected end of ZLIB input stream&quot;);
 458             }
 459             len = in.read(buf, 0, buf.length);
 460             if (len == -1) {
 461                 buf[0] = 0;
 462                 len = 1;
 463                 eof = true;
 464             }
 465             inf.setInput(buf, 0, len);
 466         }
 467 
 468         public int available() throws IOException {
 469             if (closeRequested)
 470                 return 0;
 471             long avail = ((ZipFileInputStream)in).size() - inf.getBytesWritten();
 472             return (avail &gt; (long) Integer.MAX_VALUE ?
 473                     Integer.MAX_VALUE : (int) avail);
 474         }
 475     }
 476 
 477     /**
 478      * Returns the path name of the ZIP file.
 479      * @return the path name of the ZIP file
 480      */
 481     public String getName() {
 482         return name;
 483     }
 484 
 485     private class ZipEntryIterator&lt;T extends ZipEntry&gt;
 486             implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; {
 487 
 488         private int i = 0;
 489         private final int entryCount;
 490         private final Function&lt;String, T&gt; gen;
 491 
 492         public ZipEntryIterator(int entryCount, Function&lt;String, T&gt; gen) {
 493             this.entryCount = entryCount;
 494             this.gen = gen;
 495         }
 496 
 497         @Override
 498         public boolean hasMoreElements() {
 499             return hasNext();
 500         }
 501 
 502         @Override
 503         public boolean hasNext() {
 504             return i &lt; entryCount;
 505         }
 506 
 507         @Override
 508         public T nextElement() {
 509             return next();
 510         }
 511 
 512         @Override
 513         @SuppressWarnings(&quot;unchecked&quot;)
 514         public T next() {
 515             synchronized (ZipFile.this) {
 516                 ensureOpen();
 517                 if (!hasNext()) {
 518                     throw new NoSuchElementException();
 519                 }
 520                 // each &quot;entry&quot; has 3 ints in table entries
 521                 return (T)getZipEntry(null, null, res.zsrc.getEntryPos(i++ * 3), gen);
 522             }
 523         }
 524 
 525         @Override
 526         public Iterator&lt;T&gt; asIterator() {
 527             return this;
 528         }
 529     }
 530 
 531     /**
 532      * Returns an enumeration of the ZIP file entries.
 533      * @return an enumeration of the ZIP file entries
 534      * @throws IllegalStateException if the zip file has been closed
 535      */
 536     public Enumeration&lt;? extends ZipEntry&gt; entries() {
 537         synchronized (this) {
 538             ensureOpen();
 539             return new ZipEntryIterator&lt;ZipEntry&gt;(res.zsrc.total, ZipEntry::new);
 540         }
 541     }
 542 
 543     private Enumeration&lt;JarEntry&gt; entries(Function&lt;String, JarEntry&gt; func) {
 544         synchronized (this) {
 545             ensureOpen();
 546             return new ZipEntryIterator&lt;JarEntry&gt;(res.zsrc.total, func);
 547         }
 548     }
 549 
 550     private class EntrySpliterator&lt;T&gt; extends Spliterators.AbstractSpliterator&lt;T&gt; {
 551         private int index;
 552         private final int fence;
 553         private final IntFunction&lt;T&gt; gen;
 554 
 555         EntrySpliterator(int index, int fence, IntFunction&lt;T&gt; gen) {
 556             super((long)fence,
 557                   Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.IMMUTABLE |
 558                   Spliterator.NONNULL);
 559             this.index = index;
 560             this.fence = fence;
 561             this.gen = gen;
 562         }
 563 
 564         @Override
 565         public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
 566             if (action == null)
 567                 throw new NullPointerException();
 568             if (index &gt;= 0 &amp;&amp; index &lt; fence) {
 569                 synchronized (ZipFile.this) {
 570                     ensureOpen();
 571                     action.accept(gen.apply(res.zsrc.getEntryPos(index++ * 3)));
 572                 }
 573                 return true;
 574             }
 575             return false;
 576         }
 577     }
 578 
 579     /**
 580      * Returns an ordered {@code Stream} over the ZIP file entries.
 581      *
 582      * Entries appear in the {@code Stream} in the order they appear in
 583      * the central directory of the ZIP file.
 584      *
 585      * @return an ordered {@code Stream} of entries in this ZIP file
 586      * @throws IllegalStateException if the zip file has been closed
 587      * @since 1.8
 588      */
 589     public Stream&lt;? extends ZipEntry&gt; stream() {
 590         synchronized (this) {
 591             ensureOpen();
 592             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
 593                 pos -&gt; getZipEntry(null, null, pos, ZipEntry::new)), false);
 594        }
 595     }
 596 
 597     private String getEntryName(int pos) {
 598         byte[] cen = res.zsrc.cen;
 599         int nlen = CENNAM(cen, pos);
 600         if (!zc.isUTF8() &amp;&amp; (CENFLG(cen, pos) &amp; USE_UTF8) != 0) {
 601             return zc.toStringUTF8(cen, pos + CENHDR, nlen);
 602         } else {
 603             return zc.toString(cen, pos + CENHDR, nlen);
 604         }
 605     }
 606 
 607     /*
 608      * Returns an ordered {@code Stream} over the zip file entry names.
 609      *
 610      * Entry names appear in the {@code Stream} in the order they appear in
 611      * the central directory of the ZIP file.
 612      *
 613      * @return an ordered {@code Stream} of entry names in this zip file
 614      * @throws IllegalStateException if the zip file has been closed
 615      * @since 10
 616      */
 617     private Stream&lt;String&gt; entryNameStream() {
 618         synchronized (this) {
 619             ensureOpen();
 620             return StreamSupport.stream(
 621                 new EntrySpliterator&lt;&gt;(0, res.zsrc.total, this::getEntryName), false);
 622         }
 623     }
 624 
 625     /*
 626      * Returns an ordered {@code Stream} over the zip file entries.
 627      *
 628      * Entries appear in the {@code Stream} in the order they appear in
 629      * the central directory of the jar file.
 630      *
 631      * @param func the function that creates the returned entry
 632      * @return an ordered {@code Stream} of entries in this zip file
 633      * @throws IllegalStateException if the zip file has been closed
 634      * @since 10
 635      */
 636     private Stream&lt;JarEntry&gt; stream(Function&lt;String, JarEntry&gt; func) {
 637         synchronized (this) {
 638             ensureOpen();
 639             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
 640                 pos -&gt; (JarEntry)getZipEntry(null, null, pos, func)), false);
 641         }
 642     }
 643 
 644     private String lastEntryName;
 645     private int lastEntryPos;
 646 
 647     /* Checks ensureOpen() before invoke this method */
 648     private ZipEntry getZipEntry(String name, byte[] bname, int pos,
 649                                  Function&lt;String, ? extends ZipEntry&gt; func) {
 650         byte[] cen = res.zsrc.cen;
 651         int nlen = CENNAM(cen, pos);
 652         int elen = CENEXT(cen, pos);
 653         int clen = CENCOM(cen, pos);
 654         int flag = CENFLG(cen, pos);
 655         if (name == null || bname.length != nlen) {
 656             // to use the entry name stored in cen, if the passed in name is
 657             // (1) null, invoked from iterator, or
 658             // (2) not equal to the name stored, a slash is appended during
 659             // getEntryPos() search.
 660             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {
 661                 name = zc.toStringUTF8(cen, pos + CENHDR, nlen);
 662             } else {
 663                 name = zc.toString(cen, pos + CENHDR, nlen);
 664             }
 665         }
 666         ZipEntry e = func.apply(name);    //ZipEntry e = new ZipEntry(name);
 667         e.flag = flag;
 668         e.xdostime = CENTIM(cen, pos);
 669         e.crc = CENCRC(cen, pos);
 670         e.size = CENLEN(cen, pos);
 671         e.csize = CENSIZ(cen, pos);
 672         e.method = CENHOW(cen, pos);
 673         if (elen != 0) {
 674             int start = pos + CENHDR + nlen;
 675             e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
 676         }
 677         if (clen != 0) {
 678             int start = pos + CENHDR + nlen + elen;
 679             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {
 680                 e.comment = zc.toStringUTF8(cen, start, clen);
 681             } else {
 682                 e.comment = zc.toString(cen, start, clen);
 683             }
 684         }
 685         lastEntryName = e.name;
 686         lastEntryPos = pos;
 687         return e;
 688     }
 689 
 690     /**
 691      * Returns the number of entries in the ZIP file.
 692      *
 693      * @return the number of entries in the ZIP file
 694      * @throws IllegalStateException if the zip file has been closed
 695      */
 696     public int size() {
 697         synchronized (this) {
 698             ensureOpen();
 699             return res.zsrc.total;
 700         }
 701     }
 702 
 703     private static class CleanableResource implements Runnable {
 704         // The outstanding inputstreams that need to be closed
 705         final Set&lt;InputStream&gt; istreams;
 706 
 707         // List of cached Inflater objects for decompression
 708         Deque&lt;Inflater&gt; inflaterCache;
 709 
 710         final Cleanable cleanable;
 711 
 712         Source zsrc;
 713 
 714         CleanableResource(ZipFile zf, File file, int mode) throws IOException {
 715             this.cleanable = CleanerFactory.cleaner().register(zf, this);
 716             this.istreams = Collections.newSetFromMap(new WeakHashMap&lt;&gt;());
 717             this.inflaterCache = new ArrayDeque&lt;&gt;();
 718             this.zsrc = Source.get(file, (mode &amp; OPEN_DELETE) != 0);
 719         }
 720 
 721         void clean() {
 722             cleanable.clean();
 723         }
 724 
 725         /*
 726          * Gets an inflater from the list of available inflaters or allocates
 727          * a new one.
 728          */
 729         Inflater getInflater() {
 730             Inflater inf;
 731             synchronized (inflaterCache) {
 732                 if ((inf = inflaterCache.poll()) != null) {
 733                     return inf;
 734                 }
 735             }
 736             return new Inflater(true);
 737         }
 738 
 739         /*
 740          * Releases the specified inflater to the list of available inflaters.
 741          */
 742         void releaseInflater(Inflater inf) {
 743             Deque&lt;Inflater&gt; inflaters = this.inflaterCache;
 744             if (inflaters != null) {
 745                 synchronized (inflaters) {
 746                     // double checked!
 747                     if (inflaters == this.inflaterCache) {
 748                         inf.reset();
 749                         inflaters.add(inf);
 750                         return;
 751                     }
 752                 }
 753             }
 754             // inflaters cache already closed - just end it.
 755             inf.end();
 756         }
 757 
 758         public void run() {
 759             IOException ioe = null;
 760 
 761             // Release cached inflaters and close the cache first
 762             Deque&lt;Inflater&gt; inflaters = this.inflaterCache;
 763             if (inflaters != null) {
 764                 synchronized (inflaters) {
 765                     // no need to double-check as only one thread gets a
 766                     // chance to execute run() (Cleaner guarantee)...
 767                     Inflater inf;
 768                     while ((inf = inflaters.poll()) != null) {
 769                         inf.end();
 770                     }
 771                     // close inflaters cache
 772                     this.inflaterCache = null;
 773                 }
 774             }
 775 
 776             // Close streams, release their inflaters
 777             if (istreams != null) {
 778                 synchronized (istreams) {
 779                     if (!istreams.isEmpty()) {
 780                         InputStream[] copy = istreams.toArray(new InputStream[0]);
 781                         istreams.clear();
 782                         for (InputStream is : copy) {
 783                             try {
 784                                 is.close();
 785                             } catch (IOException e) {
 786                                 if (ioe == null) ioe = e;
 787                                 else ioe.addSuppressed(e);
 788                             }
 789                         }
 790                     }
 791                 }
 792             }
 793 
 794             // Release zip src
 795             if (zsrc != null) {
 796                 synchronized (zsrc) {
 797                     try {
 798                         Source.release(zsrc);
 799                         zsrc = null;
 800                     } catch (IOException e) {
 801                         if (ioe == null) ioe = e;
 802                         else ioe.addSuppressed(e);
 803                     }
 804                 }
 805             }
 806             if (ioe != null) {
 807                 throw new UncheckedIOException(ioe);
 808             }
 809         }
 810 
 811         CleanableResource(File file, int mode)
 812             throws IOException {
 813             this.cleanable = null;
 814             this.istreams = Collections.newSetFromMap(new WeakHashMap&lt;&gt;());
 815             this.inflaterCache = new ArrayDeque&lt;&gt;();
 816             this.zsrc = Source.get(file, (mode &amp; OPEN_DELETE) != 0);
 817         }
 818 
 819     }
 820 
 821     /**
 822      * Closes the ZIP file.
 823      *
 824      * &lt;p&gt; Closing this ZIP file will close all of the input streams
 825      * previously returned by invocations of the {@link #getInputStream
 826      * getInputStream} method.
 827      *
 828      * @throws IOException if an I/O error has occurred
 829      */
 830     public void close() throws IOException {
 831         if (closeRequested) {
 832             return;
 833         }
 834         closeRequested = true;
 835 
 836         synchronized (this) {
 837             // Close streams, release their inflaters, release cached inflaters
 838             // and release zip source
 839             try {
 840                 res.clean();
 841             } catch (UncheckedIOException ioe) {
 842                 throw ioe.getCause();
 843             }
 844         }
 845     }
 846 
 847     private void ensureOpen() {
 848         if (closeRequested) {
 849             throw new IllegalStateException(&quot;zip file closed&quot;);
 850         }
 851         if (res.zsrc == null) {
 852             throw new IllegalStateException(&quot;The object is not initialized.&quot;);
 853         }
 854     }
 855 
 856     private void ensureOpenOrZipException() throws IOException {
 857         if (closeRequested) {
 858             throw new ZipException(&quot;ZipFile closed&quot;);
 859         }
 860     }
 861 
 862     /*
 863      * Inner class implementing the input stream used to read a
 864      * (possibly compressed) zip file entry.
 865      */
 866     private class ZipFileInputStream extends InputStream {
 867         private volatile boolean closeRequested;
 868         private   long pos;     // current position within entry data
 869         private   long startingPos; // Start position for the entry data
 870         protected long rem;     // number of remaining bytes within entry
 871         protected long size;    // uncompressed size of this entry
 872 
 873         ZipFileInputStream(byte[] cen, int cenpos) {
 874             rem = CENSIZ(cen, cenpos);
 875             size = CENLEN(cen, cenpos);
 876             pos = CENOFF(cen, cenpos);
 877             // zip64
 878             if (rem == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL ||
 879                 pos == ZIP64_MAGICVAL) {
 880                 checkZIP64(cen, cenpos);
 881             }
 882             // negative for lazy initialization, see getDataOffset();
 883             pos = - (pos + ZipFile.this.res.zsrc.locpos);
 884         }
 885 
 886         private void checkZIP64(byte[] cen, int cenpos) {
 887             int off = cenpos + CENHDR + CENNAM(cen, cenpos);
 888             int end = off + CENEXT(cen, cenpos);
 889             while (off + 4 &lt; end) {
 890                 int tag = get16(cen, off);
 891                 int sz = get16(cen, off + 2);
 892                 off += 4;
 893                 if (off + sz &gt; end)         // invalid data
 894                     break;
 895                 if (tag == EXTID_ZIP64) {
 896                     if (size == ZIP64_MAGICVAL) {
 897                         if (sz &lt; 8 || (off + 8) &gt; end)
 898                             break;
 899                         size = get64(cen, off);
 900                         sz -= 8;
 901                         off += 8;
 902                     }
 903                     if (rem == ZIP64_MAGICVAL) {
 904                         if (sz &lt; 8 || (off + 8) &gt; end)
 905                             break;
 906                         rem = get64(cen, off);
 907                         sz -= 8;
 908                         off += 8;
 909                     }
 910                     if (pos == ZIP64_MAGICVAL) {
 911                         if (sz &lt; 8 || (off + 8) &gt; end)
 912                             break;
 913                         pos = get64(cen, off);
 914                         sz -= 8;
 915                         off += 8;
 916                     }
 917                     break;
 918                 }
 919                 off += sz;
 920             }
 921         }
 922 
 923         /*
 924          * The Zip file spec explicitly allows the LOC extra data size to
 925          * be different from the CEN extra data size. Since we cannot trust
 926          * the CEN extra data size, we need to read the LOC to determine
 927          * the entry data offset.
 928          */
 929         private long initDataOffset() throws IOException {
 930             if (pos &lt;= 0) {
 931                 byte[] loc = new byte[LOCHDR];
 932                 pos = -pos;
 933                 int len = ZipFile.this.res.zsrc.readFullyAt(loc, 0, loc.length, pos);
 934                 if (len != LOCHDR) {
 935                     throw new ZipException(&quot;ZipFile error reading zip file&quot;);
 936                 }
 937                 if (LOCSIG(loc) != LOCSIG) {
 938                     throw new ZipException(&quot;ZipFile invalid LOC header (bad signature)&quot;);
 939                 }
 940                 pos += LOCHDR + LOCNAM(loc) + LOCEXT(loc);
 941                 startingPos = pos; // Save starting position for the entry
 942             }
 943             return pos;
 944         }
 945 
 946         public int read(byte b[], int off, int len) throws IOException {
 947             synchronized (ZipFile.this) {
 948                 ensureOpenOrZipException();
 949                 initDataOffset();
 950                 if (rem == 0) {
 951                     return -1;
 952                 }
 953                 if (len &gt; rem) {
 954                     len = (int) rem;
 955                 }
 956                 if (len &lt;= 0) {
 957                     return 0;
 958                 }
 959                 len = ZipFile.this.res.zsrc.readAt(b, off, len, pos);
 960                 if (len &gt; 0) {
 961                     pos += len;
 962                     rem -= len;
 963                 }
 964             }
 965             if (rem == 0) {
 966                 close();
 967             }
 968             return len;
 969         }
 970 
 971         public int read() throws IOException {
 972             byte[] b = new byte[1];
 973             if (read(b, 0, 1) == 1) {
 974                 return b[0] &amp; 0xff;
 975             } else {
 976                 return -1;
 977             }
 978         }
 979 
 980         public long skip(long n) throws IOException {
 981             synchronized (ZipFile.this) {
 982                 initDataOffset();
 983                 long newPos = pos + n;
 984                 if (n &gt; 0) {
 985                     // If we overflowed adding the skip value or are moving
 986                     // past EOF, set the skip value to number of bytes remaining
 987                     // to reach EOF
 988                     if (newPos &lt; 0 || n &gt; rem) {
 989                         n = rem;
 990                     }
 991                 } else if (newPos &lt; startingPos) {
 992                     // Tried to position before BOF so set position to the
 993                     // BOF and return the number of bytes we moved backwards
 994                     // to reach BOF
 995                     n = startingPos - pos;
 996                 }
 997                 pos += n;
 998                 rem -= n;
 999             }
1000             if (rem == 0) {
1001                 close();
1002             }
1003             return n;
1004         }
1005 
1006         public int available() {
1007             return rem &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) rem;
1008         }
1009 
1010         public long size() {
1011             return size;
1012         }
1013 
1014         public void close() {
1015             if (closeRequested) {
1016                 return;
1017             }
1018             closeRequested = true;
1019             rem = 0;
1020             synchronized (res.istreams) {
1021                 res.istreams.remove(this);
1022             }
1023         }
1024 
1025     }
1026 
1027     /**
1028      * Returns the names of all non-directory entries that begin with
1029      * &quot;META-INF/&quot; (case ignored). This method is used in JarFile, via
1030      * SharedSecrets, as an optimization when looking up manifest and
1031      * signature file entries. Returns null if no entries were found.
1032      */
1033     private String[] getMetaInfEntryNames() {
1034         synchronized (this) {
1035             ensureOpen();
1036             Source zsrc = res.zsrc;
1037             if (zsrc.metanames == null) {
1038                 return null;
1039             }
1040             String[] names = new String[zsrc.metanames.length];
1041             byte[] cen = zsrc.cen;
1042             for (int i = 0; i &lt; names.length; i++) {
1043                 int pos = zsrc.metanames[i];
1044                 names[i] = new String(cen, pos + CENHDR, CENNAM(cen, pos),
1045                                       UTF_8.INSTANCE);
1046             }
1047             return names;
1048         }
1049     }
1050 
1051     private static boolean isWindows;
1052     private static final JavaLangAccess JLA;
1053 
1054     static {
1055         SharedSecrets.setJavaUtilZipFileAccess(
1056             new JavaUtilZipFileAccess() {
1057                 @Override
1058                 public boolean startsWithLocHeader(ZipFile zip) {
1059                     return zip.res.zsrc.startsWithLoc;
1060                 }
1061                 @Override
1062                 public String[] getMetaInfEntryNames(ZipFile zip) {
1063                     return zip.getMetaInfEntryNames();
1064                 }
1065                 @Override
1066                 public JarEntry getEntry(ZipFile zip, String name,
1067                     Function&lt;String, JarEntry&gt; func) {
1068                     return (JarEntry)zip.getEntry(name, func);
1069                 }
1070                 @Override
1071                 public Enumeration&lt;JarEntry&gt; entries(ZipFile zip,
1072                     Function&lt;String, JarEntry&gt; func) {
1073                     return zip.entries(func);
1074                 }
1075                 @Override
1076                 public Stream&lt;JarEntry&gt; stream(ZipFile zip,
1077                     Function&lt;String, JarEntry&gt; func) {
1078                     return zip.stream(func);
1079                 }
1080                 @Override
1081                 public Stream&lt;String&gt; entryNameStream(ZipFile zip) {
1082                     return zip.entryNameStream();
1083                 }
1084              }
1085         );
1086         JLA = SharedSecrets.getJavaLangAccess();
1087         isWindows = VM.getSavedProperty(&quot;os.name&quot;).contains(&quot;Windows&quot;);
1088     }
1089 
1090     private static class Source {
1091         private final Key key;               // the key in files
1092         private int refs = 1;
1093 
1094         private RandomAccessFile zfile;      // zfile of the underlying zip file
1095         private byte[] cen;                  // CEN &amp; ENDHDR
1096         private long locpos;                 // position of first LOC header (usually 0)
1097         private byte[] comment;              // zip file comment
1098                                              // list of meta entries in META-INF dir
1099         private int[] metanames;
1100         private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)
1101 
1102         // A Hashmap for all entries.
1103         //
1104         // A cen entry of Zip/JAR file. As we have one for every entry in every active Zip/JAR,
1105         // We might have a lot of these in a typical system. In order to save space we don&#39;t
1106         // keep the name in memory, but merely remember a 32 bit {@code hash} value of the
1107         // entry name and its offset {@code pos} in the central directory hdeader.
1108         //
1109         // private static class Entry {
1110         //     int hash;       // 32 bit hashcode on name
1111         //     int next;       // hash chain: index into entries
1112         //     int pos;        // Offset of central directory file header
1113         // }
1114         // private Entry[] entries;             // array of hashed cen entry
1115         //
1116         // To reduce the total size of entries further, we use a int[] here to store 3 &quot;int&quot;
1117         // {@code hash}, {@code next and {@code &quot;pos for each entry. The entry can then be
1118         // referred by their index of their positions in the {@code entries}.
1119         //
1120         private int[] entries;                  // array of hashed cen entry
1121         private int addEntry(int index, int hash, int next, int pos) {
1122             entries[index++] = hash;
1123             entries[index++] = next;
1124             entries[index++] = pos;
1125             return index;
1126         }
1127         private int getEntryHash(int index) { return entries[index]; }
1128         private int getEntryNext(int index) { return entries[index + 1]; }
1129         private int getEntryPos(int index)  { return entries[index + 2]; }
1130         private static final int ZIP_ENDCHAIN  = -1;
1131         private int total;                   // total number of entries
1132         private int[] table;                 // Hash chain heads: indexes into entries
1133         private int tablelen;                // number of hash heads
1134 
1135         private static class Key {
1136             BasicFileAttributes attrs;
1137             File file;
1138 
1139             public Key(File file, BasicFileAttributes attrs) {
1140                 this.attrs = attrs;
1141                 this.file = file;
1142             }
1143 
1144             public int hashCode() {
1145                 long t = attrs.lastModifiedTime().toMillis();
1146                 return ((int)(t ^ (t &gt;&gt;&gt; 32))) + file.hashCode();
1147             }
1148 
1149             public boolean equals(Object obj) {
1150                 if (obj instanceof Key) {
1151                     Key key = (Key)obj;
1152                     if (!attrs.lastModifiedTime().equals(key.attrs.lastModifiedTime())) {
1153                         return false;
1154                     }
1155                     Object fk = attrs.fileKey();
1156                     if (fk != null) {
1157                         return fk.equals(key.attrs.fileKey());
1158                     } else {
1159                         return file.equals(key.file);
1160                     }
1161                 }
1162                 return false;
1163             }
1164         }
1165         private static final HashMap&lt;Key, Source&gt; files = new HashMap&lt;&gt;();
1166 
1167 
1168         static Source get(File file, boolean toDelete) throws IOException {
1169             final Key key;
1170             try {
1171                 key = new Key(file,
1172                         Files.readAttributes(file.toPath(), BasicFileAttributes.class));
1173             } catch (InvalidPathException ipe) {
1174                 throw new IOException(ipe);
1175             }
1176             Source src;
1177             synchronized (files) {
1178                 src = files.get(key);
1179                 if (src != null) {
1180                     src.refs++;
1181                     return src;
1182                 }
1183             }
1184             src = new Source(key, toDelete);
1185 
1186             synchronized (files) {
1187                 if (files.containsKey(key)) {    // someone else put in first
1188                     src.close();                 // close the newly created one
1189                     src = files.get(key);
1190                     src.refs++;
1191                     return src;
1192                 }
1193                 files.put(key, src);
1194                 return src;
1195             }
1196         }
1197 
1198         static void release(Source src) throws IOException {
1199             synchronized (files) {
1200                 if (src != null &amp;&amp; --src.refs == 0) {
1201                     files.remove(src.key);
1202                     src.close();
1203                 }
1204             }
1205         }
1206 
1207         private Source(Key key, boolean toDelete) throws IOException {
1208             this.key = key;
1209             if (toDelete) {
1210                 if (isWindows) {
1211                     this.zfile = SharedSecrets.getJavaIORandomAccessFileAccess()
1212                                               .openAndDelete(key.file, &quot;r&quot;);
1213                 } else {
1214                     this.zfile = new RandomAccessFile(key.file, &quot;r&quot;);
1215                     key.file.delete();
1216                 }
1217             } else {
1218                 this.zfile = new RandomAccessFile(key.file, &quot;r&quot;);
1219             }
1220             try {
1221                 initCEN(-1);
1222                 byte[] buf = new byte[4];
1223                 readFullyAt(buf, 0, 4, 0);
1224                 this.startsWithLoc = (LOCSIG(buf) == LOCSIG);
1225             } catch (IOException x) {
1226                 try {
1227                     this.zfile.close();
1228                 } catch (IOException xx) {}
1229                 throw x;
1230             }
1231         }
1232 
1233         private void close() throws IOException {
1234             zfile.close();
1235             zfile = null;
1236             cen = null;
1237             entries = null;
1238             table = null;
1239             metanames = null;
1240         }
1241 
1242         private static final int BUF_SIZE = 8192;
1243         private final int readFullyAt(byte[] buf, int off, int len, long pos)
1244             throws IOException
1245         {
1246             synchronized (zfile) {
1247                 zfile.seek(pos);
1248                 int N = len;
1249                 while (N &gt; 0) {
1250                     int n = Math.min(BUF_SIZE, N);
1251                     zfile.readFully(buf, off, n);
1252                     off += n;
1253                     N -= n;
1254                 }
1255                 return len;
1256             }
1257         }
1258 
1259         private final int readAt(byte[] buf, int off, int len, long pos)
1260             throws IOException
1261         {
1262             synchronized (zfile) {
1263                 zfile.seek(pos);
1264                 return zfile.read(buf, off, len);
1265             }
1266         }
1267 
1268         private static final int hashN(byte[] a, int off, int len) {
1269             int h = 1;
1270             while (len-- &gt; 0) {
1271                 h = 31 * h + a[off++];
1272             }
1273             return h;
1274         }
1275 
1276         private static final int hash_append(int hash, byte b) {
1277             return hash * 31 + b;
1278         }
1279 
1280         private static class End {
1281             int  centot;     // 4 bytes
1282             long cenlen;     // 4 bytes
1283             long cenoff;     // 4 bytes
1284             long endpos;     // 4 bytes
1285         }
1286 
1287         /*
1288          * Searches for end of central directory (END) header. The contents of
1289          * the END header will be read and placed in endbuf. Returns the file
1290          * position of the END header, otherwise returns -1 if the END header
1291          * was not found or an error occurred.
1292          */
1293         private End findEND() throws IOException {
1294             long ziplen = zfile.length();
1295             if (ziplen &lt;= 0)
1296                 zerror(&quot;zip file is empty&quot;);
1297             End end = new End();
1298             byte[] buf = new byte[READBLOCKSZ];
1299             long minHDR = (ziplen - END_MAXLEN) &gt; 0 ? ziplen - END_MAXLEN : 0;
1300             long minPos = minHDR - (buf.length - ENDHDR);
1301             for (long pos = ziplen - buf.length; pos &gt;= minPos; pos -= (buf.length - ENDHDR)) {
1302                 int off = 0;
1303                 if (pos &lt; 0) {
1304                     // Pretend there are some NUL bytes before start of file
1305                     off = (int)-pos;
1306                     Arrays.fill(buf, 0, off, (byte)0);
1307                 }
1308                 int len = buf.length - off;
1309                 if (readFullyAt(buf, off, len, pos + off) != len ) {
1310                     zerror(&quot;zip END header not found&quot;);
1311                 }
1312                 // Now scan the block backwards for END header signature
1313                 for (int i = buf.length - ENDHDR; i &gt;= 0; i--) {
1314                     if (buf[i+0] == (byte)&#39;P&#39;    &amp;&amp;
1315                         buf[i+1] == (byte)&#39;K&#39;    &amp;&amp;
1316                         buf[i+2] == (byte)&#39;\005&#39; &amp;&amp;
1317                         buf[i+3] == (byte)&#39;\006&#39;) {
1318                         // Found ENDSIG header
1319                         byte[] endbuf = Arrays.copyOfRange(buf, i, i + ENDHDR);
1320                         end.centot = ENDTOT(endbuf);
1321                         end.cenlen = ENDSIZ(endbuf);
1322                         end.cenoff = ENDOFF(endbuf);
1323                         end.endpos = pos + i;
1324                         int comlen = ENDCOM(endbuf);
1325                         if (end.endpos + ENDHDR + comlen != ziplen) {
1326                             // ENDSIG matched, however the size of file comment in it does
1327                             // not match the real size. One &quot;common&quot; cause for this problem
1328                             // is some &quot;extra&quot; bytes are padded at the end of the zipfile.
1329                             // Let&#39;s do some extra verification, we don&#39;t care about the
1330                             // performance in this situation.
1331                             byte[] sbuf = new byte[4];
1332                             long cenpos = end.endpos - end.cenlen;
1333                             long locpos = cenpos - end.cenoff;
1334                             if  (cenpos &lt; 0 ||
1335                                  locpos &lt; 0 ||
1336                                  readFullyAt(sbuf, 0, sbuf.length, cenpos) != 4 ||
1337                                  GETSIG(sbuf) != CENSIG ||
1338                                  readFullyAt(sbuf, 0, sbuf.length, locpos) != 4 ||
1339                                  GETSIG(sbuf) != LOCSIG) {
1340                                 continue;
1341                             }
1342                         }
1343                         if (comlen &gt; 0) {    // this zip file has comlen
1344                             comment = new byte[comlen];
1345                             if (readFullyAt(comment, 0, comlen, end.endpos + ENDHDR) != comlen) {
1346                                 zerror(&quot;zip comment read failed&quot;);
1347                             }
1348                         }
1349                         // must check for a zip64 end record; it is always permitted to be present
1350                         try {
1351                             byte[] loc64 = new byte[ZIP64_LOCHDR];
1352                             if (end.endpos &lt; ZIP64_LOCHDR ||
1353                                 readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)
1354                                 != loc64.length || GETSIG(loc64) != ZIP64_LOCSIG) {
1355                                 return end;
1356                             }
1357                             long end64pos = ZIP64_LOCOFF(loc64);
1358                             byte[] end64buf = new byte[ZIP64_ENDHDR];
1359                             if (readFullyAt(end64buf, 0, end64buf.length, end64pos)
1360                                 != end64buf.length || GETSIG(end64buf) != ZIP64_ENDSIG) {
1361                                 return end;
1362                             }
1363                             // end64 candidate found,
1364                             long cenlen64 = ZIP64_ENDSIZ(end64buf);
1365                             long cenoff64 = ZIP64_ENDOFF(end64buf);
1366                             long centot64 = ZIP64_ENDTOT(end64buf);
1367                             // double-check
1368                             if (cenlen64 != end.cenlen &amp;&amp; end.cenlen != ZIP64_MAGICVAL ||
1369                                 cenoff64 != end.cenoff &amp;&amp; end.cenoff != ZIP64_MAGICVAL ||
1370                                 centot64 != end.centot &amp;&amp; end.centot != ZIP64_MAGICCOUNT) {
1371                                 return end;
1372                             }
1373                             // to use the end64 values
1374                             end.cenlen = cenlen64;
1375                             end.cenoff = cenoff64;
1376                             end.centot = (int)centot64; // assume total &lt; 2g
1377                             end.endpos = end64pos;
1378                         } catch (IOException x) {}    // no zip64 loc/end
1379                         return end;
1380                     }
1381                 }
1382             }
1383             zerror(&quot;zip END header not found&quot;);
1384             return null; //make compiler happy
1385         }
1386 
1387         // Reads zip file central directory.
1388         private void initCEN(int knownTotal) throws IOException {
1389             if (knownTotal == -1) {
1390                 End end = findEND();
1391                 if (end.endpos == 0) {
1392                     locpos = 0;
1393                     total = 0;
1394                     entries  = new int[0];
1395                     cen = null;
1396                     return;         // only END header present
1397                 }
1398                 if (end.cenlen &gt; end.endpos)
1399                     zerror(&quot;invalid END header (bad central directory size)&quot;);
1400                 long cenpos = end.endpos - end.cenlen;     // position of CEN table
1401                 // Get position of first local file (LOC) header, taking into
1402                 // account that there may be a stub prefixed to the zip file.
1403                 locpos = cenpos - end.cenoff;
1404                 if (locpos &lt; 0) {
1405                     zerror(&quot;invalid END header (bad central directory offset)&quot;);
1406                 }
1407                 // read in the CEN and END
1408                 cen = new byte[(int)(end.cenlen + ENDHDR)];
1409                 if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
1410                     zerror(&quot;read CEN tables failed&quot;);
1411                 }
1412                 total = end.centot;
1413             } else {
1414                 total = knownTotal;
1415             }
1416             // hash table for entries
1417             entries  = new int[total * 3];
1418             tablelen = ((total/2) | 1); // Odd -&gt; fewer collisions
1419             table    =  new int[tablelen];
1420             Arrays.fill(table, ZIP_ENDCHAIN);
1421             int idx = 0;
1422             int hash = 0;
1423             int next = -1;
1424 
1425             // list for all meta entries
1426             ArrayList&lt;Integer&gt; metanamesList = null;
1427 
1428             // Iterate through the entries in the central directory
1429             int i = 0;
1430             int hsh = 0;
1431             int pos = 0;
1432             int limit = cen.length - ENDHDR;
1433             while (pos + CENHDR &lt;= limit) {
1434                 if (i &gt;= total) {
1435                     // This will only happen if the zip file has an incorrect
1436                     // ENDTOT field, which usually means it contains more than
1437                     // 65535 entries.
1438                     initCEN(countCENHeaders(cen, limit));
1439                     return;
1440                 }
1441                 if (CENSIG(cen, pos) != CENSIG)
1442                     zerror(&quot;invalid CEN header (bad signature)&quot;);
1443                 int method = CENHOW(cen, pos);
1444                 int nlen   = CENNAM(cen, pos);
1445                 int elen   = CENEXT(cen, pos);
1446                 int clen   = CENCOM(cen, pos);
1447                 if ((CENFLG(cen, pos) &amp; 1) != 0)
1448                     zerror(&quot;invalid CEN header (encrypted entry)&quot;);
1449                 if (method != STORED &amp;&amp; method != DEFLATED)
1450                     zerror(&quot;invalid CEN header (bad compression method: &quot; + method + &quot;)&quot;);
1451                 if (pos + CENHDR + nlen &gt; limit)
1452                     zerror(&quot;invalid CEN header (bad header size)&quot;);
1453                 // Record the CEN offset and the name hash in our hash cell.
1454                 hash = hashN(cen, pos + CENHDR, nlen);
1455                 hsh = (hash &amp; 0x7fffffff) % tablelen;
1456                 next = table[hsh];
1457                 table[hsh] = idx;
1458                 idx = addEntry(idx, hash, next, pos);
1459                 // Adds name to metanames.
1460                 if (isMetaName(cen, pos + CENHDR, nlen)) {
1461                     if (metanamesList == null)
1462                         metanamesList = new ArrayList&lt;&gt;(4);
1463                     metanamesList.add(pos);
1464                 }
1465                 // skip ext and comment
1466                 pos += (CENHDR + nlen + elen + clen);
1467                 i++;
1468             }
1469             total = i;
1470             if (metanamesList != null) {
1471                 metanames = new int[metanamesList.size()];
1472                 for (int j = 0, len = metanames.length; j &lt; len; j++) {
1473                     metanames[j] = metanamesList.get(j);
1474                 }
1475             }
1476             if (pos + ENDHDR != cen.length) {
1477                 zerror(&quot;invalid CEN header (bad header size)&quot;);
1478             }
1479         }
1480 
1481         private static void zerror(String msg) throws ZipException {
1482             throw new ZipException(msg);
1483         }
1484 
1485         /*
1486          * Returns the {@code pos} of the zip cen entry corresponding to the
1487          * specified entry name, or -1 if not found.
1488          */
1489         private int getEntryPos(byte[] name, boolean addSlash) {
1490             if (total == 0) {
1491                 return -1;
1492             }
1493             int hsh = hashN(name, 0, name.length);
1494             int idx = table[(hsh &amp; 0x7fffffff) % tablelen];
1495             /*
1496              * This while loop is an optimization where a double lookup
1497              * for name and name+/ is being performed. The name char
1498              * array has enough room at the end to try again with a
1499              * slash appended if the first table lookup does not succeed.
1500              */
1501             while (true) {
1502                 /*
1503                  * Search down the target hash chain for a entry whose
1504                  * 32 bit hash matches the hashed name.
1505                  */
1506                 while (idx != ZIP_ENDCHAIN) {
1507                     if (getEntryHash(idx) == hsh) {
1508                         // The CEN name must match the specfied one
1509                         int pos = getEntryPos(idx);
1510                         if (name.length == CENNAM(cen, pos)) {
1511                             boolean matched = true;
1512                             int nameoff = pos + CENHDR;
1513                             for (int i = 0; i &lt; name.length; i++) {
1514                                 if (name[i] != cen[nameoff++]) {
1515                                     matched = false;
1516                                     break;
1517                                 }
1518                             }
1519                             if (matched) {
1520                                 return pos;
1521                             }
1522                          }
1523                     }
1524                     idx = getEntryNext(idx);
1525                 }
1526                 /* If not addSlash, or slash is already there, we are done */
1527                 if (!addSlash  || name.length == 0 || name[name.length - 1] == &#39;/&#39;) {
1528                      return -1;
1529                 }
1530                 /* Add slash and try once more */
1531                 name = Arrays.copyOf(name, name.length + 1);
1532                 name[name.length - 1] = &#39;/&#39;;
1533                 hsh = hash_append(hsh, (byte)&#39;/&#39;);
1534                 //idx = table[hsh % tablelen];
1535                 idx = table[(hsh &amp; 0x7fffffff) % tablelen];
1536                 addSlash = false;
1537             }
1538         }
1539 
1540         /**
1541          * Returns true if the bytes represent a non-directory name
1542          * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
1543          */
1544         private static boolean isMetaName(byte[] name, int off, int len) {
1545             // Use the &quot;oldest ASCII trick in the book&quot;
1546             return len &gt; 9                     // &quot;META-INF/&quot;.length()
1547                 &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1548                 &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1549                 &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1550                 &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
1551                 &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;
1552                 &amp;&amp; (name[off++]       ) == &#39;-&#39;
1553                 &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1554                 &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1555                 &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;
1556                 &amp;&amp; (name[off]         ) == &#39;/&#39;;
1557         }
1558 
1559         /**
1560          * Returns the number of CEN headers in a central directory.
1561          * Will not throw, even if the zip file is corrupt.
1562          *
1563          * @param cen copy of the bytes in a zip file&#39;s central directory
1564          * @param size number of bytes in central directory
1565          */
1566         private static int countCENHeaders(byte[] cen, int size) {
1567             int count = 0;
1568             for (int p = 0;
1569                  p + CENHDR &lt;= size;
1570                  p += CENHDR + CENNAM(cen, p) + CENEXT(cen, p) + CENCOM(cen, p))
1571                 count++;
1572             return count;
1573         }
1574     }
1575 }
    </pre>
  </body>
</html>
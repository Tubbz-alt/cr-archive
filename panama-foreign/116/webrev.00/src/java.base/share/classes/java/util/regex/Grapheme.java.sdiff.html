<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/regex/Grapheme.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../jar/JarFile.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Pattern.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/regex/Grapheme.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.regex;
 27 
 28 import java.util.Objects;
 29 
 30 final class Grapheme {
 31 
 32     /**
<span class="line-modified"> 33      * Determines if there is an extended  grapheme cluster boundary between two</span>
<span class="line-modified"> 34      * continuing characters {@code cp1} and {@code cp2}.</span>
<span class="line-removed"> 35      * &lt;p&gt;</span>
<span class="line-removed"> 36      * See Unicode Standard Annex #29 Unicode Text Segmentation for the specification</span>
<span class="line-removed"> 37      * for the extended grapheme cluster boundary rules</span>
<span class="line-removed"> 38      * &lt;p&gt;</span>
<span class="line-removed"> 39      * Note: this method does not take care of stateful breaking.</span>
<span class="line-removed"> 40      */</span>
<span class="line-removed"> 41     static boolean isBoundary(int cp1, int cp2) {</span>
<span class="line-removed"> 42         return rules[getType(cp1)][getType(cp2)];</span>
<span class="line-removed"> 43     }</span>
<span class="line-removed"> 44 </span>
<span class="line-removed"> 45     /**</span>
<span class="line-removed"> 46      * Look for the next extended grapheme cluster boundary in a CharSequence. It assumes</span>
<span class="line-removed"> 47      * the start of the char sequence is a boundary.</span>
 48      * &lt;p&gt;
 49      * See Unicode Standard Annex #29 Unicode Text Segmentation for the specification
 50      * for the extended grapheme cluster boundary rules. The following implementation
 51      * is based on version 12.0 of the annex.
 52      * (http://www.unicode.org/reports/tr29/tr29-35.html)
 53      *
 54      * @param src the {@code CharSequence} to be scanned
 55      * @param off offset to start looking for the next boundary in the src
 56      * @param limit limit offset in the src (exclusive)
<span class="line-modified"> 57      * @return the next possible boundary</span>
 58      */
 59     static int nextBoundary(CharSequence src, int off, int limit) {
 60         Objects.checkFromToIndex(off, limit, src.length());
 61 
<span class="line-modified"> 62         int ch0 = Character.codePointAt(src, 0);</span>
<span class="line-modified"> 63         int ret = Character.charCount(ch0);</span>
<span class="line-removed"> 64         int ch1;</span>
 65         // indicates whether gb11 or gb12 is underway
<span class="line-modified"> 66         int t0 = getGraphemeType(ch0);</span>
 67         int riCount = t0 == RI ? 1 : 0;
 68         boolean gb11 = t0 == EXTENDED_PICTOGRAPHIC;
 69         while (ret &lt; limit) {
<span class="line-modified"> 70             ch1 = Character.codePointAt(src, ret);</span>
<span class="line-modified"> 71             int t1 = getGraphemeType(ch1);</span>
 72 
 73             if (gb11 &amp;&amp; t0 == ZWJ &amp;&amp; t1 == EXTENDED_PICTOGRAPHIC) {
 74                 // continue for gb11
 75             } else if (riCount % 2 == 1 &amp;&amp; t0 == RI &amp;&amp; t1 == RI) {
 76                 // continue for gb12
 77             } else if (rules[t0][t1]) {
 78                 if (ret &gt; off) {
 79                     break;
 80                 } else {
 81                     gb11 = t1 == EXTENDED_PICTOGRAPHIC;
 82                     riCount = 0;
 83                 }
 84             }
 85 
 86             riCount += (t1 == RI) ? 1 : 0;
 87             t0 = t1;
 88 
 89             ret += Character.charCount(ch1);
 90         }
 91         return ret;
</pre>
<hr />
<pre>
160     private static final int VCOUNT = 21;
161     private static final int TCOUNT = 28;
162     private static final int NCOUNT = VCOUNT * TCOUNT; // 588
163     private static final int SCOUNT = LCOUNT * NCOUNT; // 11172
164 
165     // #tr29: SpacingMark exceptions: The following (which have
166     // General_Category = Spacing_Mark and would otherwise be included)
167     // are specifically excluded
168     private static boolean isExcludedSpacingMark(int cp) {
169        return  cp == 0x102B || cp == 0x102C || cp == 0x1038 ||
170                cp &gt;= 0x1062 &amp;&amp; cp &lt;= 0x1064 ||
171                cp &gt;= 0x1062 &amp;&amp; cp &lt;= 0x106D ||
172                cp == 0x1083 ||
173                cp &gt;= 0x1087 &amp;&amp; cp &lt;= 0x108C ||
174                cp == 0x108F ||
175                cp &gt;= 0x109A &amp;&amp; cp &lt;= 0x109C ||
176                cp == 0x1A61 || cp == 0x1A63 || cp == 0x1A64 ||
177                cp == 0xAA7B || cp == 0xAA7D;
178     }
179 
<span class="line-modified">180     private static int getGraphemeType(int cp) {</span>

181         if (cp &lt; 0x007F) { // ASCII
182             if (cp &lt; 32) { // Control characters
183                 if (cp == 0x000D)
184                     return CR;
185                 if (cp == 0x000A)
186                     return LF;
187                 return CONTROL;
188             }
189             return OTHER;
190         }
<span class="line-removed">191         return getType(cp);</span>
<span class="line-removed">192     }</span>
193 
<span class="line-removed">194     @SuppressWarnings(&quot;fallthrough&quot;)</span>
<span class="line-removed">195     private static int getType(int cp) {</span>
196         if (EmojiData.isExtendedPictographic(cp)) {
197             return EXTENDED_PICTOGRAPHIC;
198         }
199 
200         int type = Character.getType(cp);
201         switch(type) {
202         case Character.UNASSIGNED:
203             // NOTE: #tr29 lists &quot;Unassigned and Default_Ignorable_Code_Point&quot; as Control
204             // but GraphemeBreakTest.txt lists u+0378/reserved-0378 as &quot;Other&quot;
205             // so type it as &quot;Other&quot; to make the test happy
206             if (cp == 0x0378)
207                 return OTHER;
208 
209         case Character.CONTROL:
210         case Character.LINE_SEPARATOR:
211         case Character.PARAGRAPH_SEPARATOR:
212         case Character.SURROGATE:
213             return CONTROL;
214         case Character.FORMAT:
215             if (cp == 0x200C ||
</pre>
</td>
<td>
<hr />
<pre>
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.regex;
 27 
 28 import java.util.Objects;
 29 
 30 final class Grapheme {
 31 
 32     /**
<span class="line-modified"> 33      * Look for the next extended grapheme cluster boundary in a CharSequence.</span>
<span class="line-modified"> 34      * It assumes the start of the char sequence at offset {@code off} is a boundary.</span>













 35      * &lt;p&gt;
 36      * See Unicode Standard Annex #29 Unicode Text Segmentation for the specification
 37      * for the extended grapheme cluster boundary rules. The following implementation
 38      * is based on version 12.0 of the annex.
 39      * (http://www.unicode.org/reports/tr29/tr29-35.html)
 40      *
 41      * @param src the {@code CharSequence} to be scanned
 42      * @param off offset to start looking for the next boundary in the src
 43      * @param limit limit offset in the src (exclusive)
<span class="line-modified"> 44      * @return the next grapheme boundary</span>
 45      */
 46     static int nextBoundary(CharSequence src, int off, int limit) {
 47         Objects.checkFromToIndex(off, limit, src.length());
 48 
<span class="line-modified"> 49         int ch0 = Character.codePointAt(src, off);</span>
<span class="line-modified"> 50         int ret = off + Character.charCount(ch0);</span>

 51         // indicates whether gb11 or gb12 is underway
<span class="line-modified"> 52         int t0 = getType(ch0);</span>
 53         int riCount = t0 == RI ? 1 : 0;
 54         boolean gb11 = t0 == EXTENDED_PICTOGRAPHIC;
 55         while (ret &lt; limit) {
<span class="line-modified"> 56             int ch1 = Character.codePointAt(src, ret);</span>
<span class="line-modified"> 57             int t1 = getType(ch1);</span>
 58 
 59             if (gb11 &amp;&amp; t0 == ZWJ &amp;&amp; t1 == EXTENDED_PICTOGRAPHIC) {
 60                 // continue for gb11
 61             } else if (riCount % 2 == 1 &amp;&amp; t0 == RI &amp;&amp; t1 == RI) {
 62                 // continue for gb12
 63             } else if (rules[t0][t1]) {
 64                 if (ret &gt; off) {
 65                     break;
 66                 } else {
 67                     gb11 = t1 == EXTENDED_PICTOGRAPHIC;
 68                     riCount = 0;
 69                 }
 70             }
 71 
 72             riCount += (t1 == RI) ? 1 : 0;
 73             t0 = t1;
 74 
 75             ret += Character.charCount(ch1);
 76         }
 77         return ret;
</pre>
<hr />
<pre>
146     private static final int VCOUNT = 21;
147     private static final int TCOUNT = 28;
148     private static final int NCOUNT = VCOUNT * TCOUNT; // 588
149     private static final int SCOUNT = LCOUNT * NCOUNT; // 11172
150 
151     // #tr29: SpacingMark exceptions: The following (which have
152     // General_Category = Spacing_Mark and would otherwise be included)
153     // are specifically excluded
154     private static boolean isExcludedSpacingMark(int cp) {
155        return  cp == 0x102B || cp == 0x102C || cp == 0x1038 ||
156                cp &gt;= 0x1062 &amp;&amp; cp &lt;= 0x1064 ||
157                cp &gt;= 0x1062 &amp;&amp; cp &lt;= 0x106D ||
158                cp == 0x1083 ||
159                cp &gt;= 0x1087 &amp;&amp; cp &lt;= 0x108C ||
160                cp == 0x108F ||
161                cp &gt;= 0x109A &amp;&amp; cp &lt;= 0x109C ||
162                cp == 0x1A61 || cp == 0x1A63 || cp == 0x1A64 ||
163                cp == 0xAA7B || cp == 0xAA7D;
164     }
165 
<span class="line-modified">166     @SuppressWarnings(&quot;fallthrough&quot;)</span>
<span class="line-added">167     private static int getType(int cp) {</span>
168         if (cp &lt; 0x007F) { // ASCII
169             if (cp &lt; 32) { // Control characters
170                 if (cp == 0x000D)
171                     return CR;
172                 if (cp == 0x000A)
173                     return LF;
174                 return CONTROL;
175             }
176             return OTHER;
177         }


178 


179         if (EmojiData.isExtendedPictographic(cp)) {
180             return EXTENDED_PICTOGRAPHIC;
181         }
182 
183         int type = Character.getType(cp);
184         switch(type) {
185         case Character.UNASSIGNED:
186             // NOTE: #tr29 lists &quot;Unassigned and Default_Ignorable_Code_Point&quot; as Control
187             // but GraphemeBreakTest.txt lists u+0378/reserved-0378 as &quot;Other&quot;
188             // so type it as &quot;Other&quot; to make the test happy
189             if (cp == 0x0378)
190                 return OTHER;
191 
192         case Character.CONTROL:
193         case Character.LINE_SEPARATOR:
194         case Character.PARAGRAPH_SEPARATOR:
195         case Character.SURROGATE:
196             return CONTROL;
197         case Character.FORMAT:
198             if (cp == 0x200C ||
</pre>
</td>
</tr>
</table>
<center><a href="../jar/JarFile.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Pattern.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
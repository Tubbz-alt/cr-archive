<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/regex/Pattern.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Grapheme.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../zip/ZipFile.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/regex/Pattern.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
4018             if (i &lt; matcher.to) {
4019                 return predicate.is(seq.charAt(i)) &amp;&amp;
4020                        next.match(matcher, i + 1, seq);
4021             } else {
4022                 matcher.hitEnd = true;
4023                 return false;
4024             }
4025         }
4026     }
4027 
4028     private static class NFCCharProperty extends Node {
4029         CharPredicate predicate;
4030         NFCCharProperty (CharPredicate predicate) {
4031             this.predicate = predicate;
4032         }
4033 
4034         boolean match(Matcher matcher, int i, CharSequence seq) {
4035             if (i &lt; matcher.to) {
4036                 int ch0 = Character.codePointAt(seq, i);
4037                 int n = Character.charCount(ch0);
<span class="line-modified">4038                 int j = i + n;</span>
<span class="line-modified">4039                 // Fast check if it&#39;s necessary to call Normalizer;</span>
<span class="line-removed">4040                 // testing Grapheme.isBoundary is enough for this case</span>
<span class="line-removed">4041                 while (j &lt; matcher.to) {</span>
<span class="line-removed">4042                     int ch1 = Character.codePointAt(seq, j);</span>
<span class="line-removed">4043                     if (Grapheme.isBoundary(ch0, ch1))</span>
<span class="line-removed">4044                         break;</span>
<span class="line-removed">4045                     ch0 = ch1;</span>
<span class="line-removed">4046                     j += Character.charCount(ch1);</span>
<span class="line-removed">4047                 }</span>
<span class="line-removed">4048                 if (i + n == j) {    // single, assume nfc cp</span>
4049                     if (predicate.is(ch0))
4050                         return next.match(matcher, j, seq);
4051                 } else {
4052                     while (i + n &lt; j) {
4053                         String nfc = Normalizer.normalize(
4054                             seq.toString().substring(i, j), Normalizer.Form.NFC);
4055                         if (nfc.codePointCount(0, nfc.length()) == 1) {
4056                             if (predicate.is(nfc.codePointAt(0)) &amp;&amp;
4057                                 next.match(matcher, j, seq)) {
4058                                 return true;
4059                             }
4060                         }
4061 
4062                         ch0 = Character.codePointBefore(seq, j);
4063                         j -= Character.charCount(ch0);
4064                     }
4065                 }
4066                 if (j &lt; matcher.to)
4067                     return false;
4068             }
</pre>
<hr />
<pre>
4092 
4093         boolean study(TreeInfo info) {
4094             info.minLength++;
4095             info.deterministic = false;
4096             return next.study(info);
4097         }
4098     }
4099 
4100     /**
4101      * Node class that handles grapheme boundaries
4102      */
4103     static class GraphemeBound extends Node {
4104         boolean match(Matcher matcher, int i, CharSequence seq) {
4105             int startIndex = matcher.from;
4106             int endIndex = matcher.to;
4107             if (matcher.transparentBounds) {
4108                 startIndex = 0;
4109                 endIndex = matcher.getTextLength();
4110             }
4111             if (i == startIndex) {
<span class="line-modified">4112                 return next.match(matcher, i, seq);</span>
<span class="line-modified">4113             }</span>
<span class="line-modified">4114             if (i &lt; endIndex) {</span>
<span class="line-modified">4115                 if (Character.isSurrogatePair(seq.charAt(i-1), seq.charAt(i)) ||</span>
<span class="line-modified">4116                     Grapheme.nextBoundary(seq,</span>
<span class="line-modified">4117                         i - Character.charCount(Character.codePointBefore(seq, i)),</span>
<span class="line-removed">4118                         i + Character.charCount(Character.codePointAt(seq, i))) &gt; i) {</span>
4119                     return false;
4120                 }
4121             } else {
4122                 matcher.hitEnd = true;
4123                 matcher.requireEnd = true;
4124             }
4125             return next.match(matcher, i, seq);
4126         }
4127     }
4128 
4129     /**
4130      * Base class for all Slice nodes
4131      */
4132     static class SliceNode extends Node {
4133         int[] buffer;
4134         SliceNode(int[] buf) {
4135             buffer = buf;
4136         }
4137         boolean study(TreeInfo info) {
4138             info.minLength += buffer.length;
</pre>
</td>
<td>
<hr />
<pre>
4018             if (i &lt; matcher.to) {
4019                 return predicate.is(seq.charAt(i)) &amp;&amp;
4020                        next.match(matcher, i + 1, seq);
4021             } else {
4022                 matcher.hitEnd = true;
4023                 return false;
4024             }
4025         }
4026     }
4027 
4028     private static class NFCCharProperty extends Node {
4029         CharPredicate predicate;
4030         NFCCharProperty (CharPredicate predicate) {
4031             this.predicate = predicate;
4032         }
4033 
4034         boolean match(Matcher matcher, int i, CharSequence seq) {
4035             if (i &lt; matcher.to) {
4036                 int ch0 = Character.codePointAt(seq, i);
4037                 int n = Character.charCount(ch0);
<span class="line-modified">4038                 int j = Grapheme.nextBoundary(seq, i, matcher.to);</span>
<span class="line-modified">4039                 if (i + n == j) { // single cp grapheme, assume nfc</span>









4040                     if (predicate.is(ch0))
4041                         return next.match(matcher, j, seq);
4042                 } else {
4043                     while (i + n &lt; j) {
4044                         String nfc = Normalizer.normalize(
4045                             seq.toString().substring(i, j), Normalizer.Form.NFC);
4046                         if (nfc.codePointCount(0, nfc.length()) == 1) {
4047                             if (predicate.is(nfc.codePointAt(0)) &amp;&amp;
4048                                 next.match(matcher, j, seq)) {
4049                                 return true;
4050                             }
4051                         }
4052 
4053                         ch0 = Character.codePointBefore(seq, j);
4054                         j -= Character.charCount(ch0);
4055                     }
4056                 }
4057                 if (j &lt; matcher.to)
4058                     return false;
4059             }
</pre>
<hr />
<pre>
4083 
4084         boolean study(TreeInfo info) {
4085             info.minLength++;
4086             info.deterministic = false;
4087             return next.study(info);
4088         }
4089     }
4090 
4091     /**
4092      * Node class that handles grapheme boundaries
4093      */
4094     static class GraphemeBound extends Node {
4095         boolean match(Matcher matcher, int i, CharSequence seq) {
4096             int startIndex = matcher.from;
4097             int endIndex = matcher.to;
4098             if (matcher.transparentBounds) {
4099                 startIndex = 0;
4100                 endIndex = matcher.getTextLength();
4101             }
4102             if (i == startIndex) {
<span class="line-modified">4103                 // continue with return below</span>
<span class="line-modified">4104             } else if (i &lt; endIndex) {</span>
<span class="line-modified">4105                 if (Character.isSurrogatePair(seq.charAt(i - 1), seq.charAt(i))) {</span>
<span class="line-modified">4106                     return false;</span>
<span class="line-modified">4107                 }</span>
<span class="line-modified">4108                 if (Grapheme.nextBoundary(seq, matcher.last, endIndex) &gt; i) {</span>

4109                     return false;
4110                 }
4111             } else {
4112                 matcher.hitEnd = true;
4113                 matcher.requireEnd = true;
4114             }
4115             return next.match(matcher, i, seq);
4116         }
4117     }
4118 
4119     /**
4120      * Base class for all Slice nodes
4121      */
4122     static class SliceNode extends Node {
4123         int[] buffer;
4124         SliceNode(int[] buf) {
4125             buffer = buf;
4126         }
4127         boolean study(TreeInfo info) {
4128             info.minLength += buffer.length;
</pre>
</td>
</tr>
</table>
<center><a href="Grapheme.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../zip/ZipFile.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/List.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.util.function.UnaryOperator;
  29 
  30 /**
  31  * An ordered collection (also known as a &lt;i&gt;sequence&lt;/i&gt;).  The user of this
  32  * interface has precise control over where in the list each element is
  33  * inserted.  The user can access elements by their integer index (position in
  34  * the list), and search for elements in the list.&lt;p&gt;
  35  *
  36  * Unlike sets, lists typically allow duplicate elements.  More formally,
  37  * lists typically allow pairs of elements {@code e1} and {@code e2}
  38  * such that {@code e1.equals(e2)}, and they typically allow multiple
  39  * null elements if they allow null elements at all.  It is not inconceivable
  40  * that someone might wish to implement a list that prohibits duplicates, by
  41  * throwing runtime exceptions when the user attempts to insert them, but we
  42  * expect this usage to be rare.&lt;p&gt;
  43  *
  44  * The {@code List} interface places additional stipulations, beyond those
  45  * specified in the {@code Collection} interface, on the contracts of the
  46  * {@code iterator}, {@code add}, {@code remove}, {@code equals}, and
  47  * {@code hashCode} methods.  Declarations for other inherited methods are
  48  * also included here for convenience.&lt;p&gt;
  49  *
  50  * The {@code List} interface provides four methods for positional (indexed)
  51  * access to list elements.  Lists (like Java arrays) are zero based.  Note
  52  * that these operations may execute in time proportional to the index value
  53  * for some implementations (the {@code LinkedList} class, for
  54  * example). Thus, iterating over the elements in a list is typically
  55  * preferable to indexing through it if the caller does not know the
  56  * implementation.&lt;p&gt;
  57  *
  58  * The {@code List} interface provides a special iterator, called a
  59  * {@code ListIterator}, that allows element insertion and replacement, and
  60  * bidirectional access in addition to the normal operations that the
  61  * {@code Iterator} interface provides.  A method is provided to obtain a
  62  * list iterator that starts at a specified position in the list.&lt;p&gt;
  63  *
  64  * The {@code List} interface provides two methods to search for a specified
  65  * object.  From a performance standpoint, these methods should be used with
  66  * caution.  In many implementations they will perform costly linear
  67  * searches.&lt;p&gt;
  68  *
  69  * The {@code List} interface provides two methods to efficiently insert and
  70  * remove multiple elements at an arbitrary point in the list.&lt;p&gt;
  71  *
  72  * Note: While it is permissible for lists to contain themselves as elements,
  73  * extreme caution is advised: the {@code equals} and {@code hashCode}
  74  * methods are no longer well defined on such a list.
  75  *
  76  * &lt;p&gt;Some list implementations have restrictions on the elements that
  77  * they may contain.  For example, some implementations prohibit null elements,
  78  * and some have restrictions on the types of their elements.  Attempting to
  79  * add an ineligible element throws an unchecked exception, typically
  80  * {@code NullPointerException} or {@code ClassCastException}.  Attempting
  81  * to query the presence of an ineligible element may throw an exception,
  82  * or it may simply return false; some implementations will exhibit the former
  83  * behavior and some will exhibit the latter.  More generally, attempting an
  84  * operation on an ineligible element whose completion would not result in
  85  * the insertion of an ineligible element into the list may throw an
  86  * exception or it may succeed, at the option of the implementation.
  87  * Such exceptions are marked as &quot;optional&quot; in the specification for this
  88  * interface.
  89  *
  90  * &lt;h2&gt;&lt;a id=&quot;unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt;&lt;/h2&gt;
  91  * &lt;p&gt;The {@link List#of(Object...) List.of} and
  92  * {@link List#copyOf List.copyOf} static factory methods
  93  * provide a convenient way to create unmodifiable lists. The {@code List}
  94  * instances created by these methods have the following characteristics:
  95  *
  96  * &lt;ul&gt;
  97  * &lt;li&gt;They are &lt;a href=&quot;Collection.html#unmodifiable&quot;&gt;&lt;i&gt;unmodifiable&lt;/i&gt;&lt;/a&gt;. Elements cannot
  98  * be added, removed, or replaced. Calling any mutator method on the List
  99  * will always cause {@code UnsupportedOperationException} to be thrown.
 100  * However, if the contained elements are themselves mutable,
 101  * this may cause the List&#39;s contents to appear to change.
 102  * &lt;li&gt;They disallow {@code null} elements. Attempts to create them with
 103  * {@code null} elements result in {@code NullPointerException}.
 104  * &lt;li&gt;They are serializable if all elements are serializable.
 105  * &lt;li&gt;The order of elements in the list is the same as the order of the
 106  * provided arguments, or of the elements in the provided array.
<a name="1" id="anc1"></a>

 107  * &lt;li&gt;They are &lt;a href=&quot;../lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;.
 108  * Callers should make no assumptions about the identity of the returned instances.
 109  * Factories are free to create new instances or reuse existing ones. Therefore,
 110  * identity-sensitive operations on these instances (reference equality ({@code ==}),
 111  * identity hash code, and synchronization) are unreliable and should be avoided.
 112  * &lt;li&gt;They are serialized as specified on the
 113  * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.util.CollSer&quot;&gt;Serialized Form&lt;/a&gt;
 114  * page.
 115  * &lt;/ul&gt;
 116  *
 117  * &lt;p&gt;This interface is a member of the
 118  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 119  * Java Collections Framework&lt;/a&gt;.
 120  *
 121  * @param &lt;E&gt; the type of elements in this list
 122  *
 123  * @author  Josh Bloch
 124  * @author  Neal Gafter
 125  * @see Collection
 126  * @see Set
 127  * @see ArrayList
 128  * @see LinkedList
 129  * @see Vector
 130  * @see Arrays#asList(Object[])
 131  * @see Collections#nCopies(int, Object)
 132  * @see Collections#EMPTY_LIST
 133  * @see AbstractList
 134  * @see AbstractSequentialList
 135  * @since 1.2
 136  */
 137 
 138 public interface List&lt;E&gt; extends Collection&lt;E&gt; {
 139     // Query Operations
 140 
 141     /**
 142      * Returns the number of elements in this list.  If this list contains
 143      * more than {@code Integer.MAX_VALUE} elements, returns
 144      * {@code Integer.MAX_VALUE}.
 145      *
 146      * @return the number of elements in this list
 147      */
 148     int size();
 149 
 150     /**
 151      * Returns {@code true} if this list contains no elements.
 152      *
 153      * @return {@code true} if this list contains no elements
 154      */
 155     boolean isEmpty();
 156 
 157     /**
 158      * Returns {@code true} if this list contains the specified element.
 159      * More formally, returns {@code true} if and only if this list contains
 160      * at least one element {@code e} such that
 161      * {@code Objects.equals(o, e)}.
 162      *
 163      * @param o element whose presence in this list is to be tested
 164      * @return {@code true} if this list contains the specified element
 165      * @throws ClassCastException if the type of the specified element
 166      *         is incompatible with this list
 167      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 168      * @throws NullPointerException if the specified element is null and this
 169      *         list does not permit null elements
 170      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 171      */
 172     boolean contains(Object o);
 173 
 174     /**
 175      * Returns an iterator over the elements in this list in proper sequence.
 176      *
 177      * @return an iterator over the elements in this list in proper sequence
 178      */
 179     Iterator&lt;E&gt; iterator();
 180 
 181     /**
 182      * Returns an array containing all of the elements in this list in proper
 183      * sequence (from first to last element).
 184      *
 185      * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
 186      * maintained by this list.  (In other words, this method must
 187      * allocate a new array even if this list is backed by an array).
 188      * The caller is thus free to modify the returned array.
 189      *
 190      * &lt;p&gt;This method acts as bridge between array-based and collection-based
 191      * APIs.
 192      *
 193      * @return an array containing all of the elements in this list in proper
 194      *         sequence
 195      * @see Arrays#asList(Object[])
 196      */
 197     Object[] toArray();
 198 
 199     /**
 200      * Returns an array containing all of the elements in this list in
 201      * proper sequence (from first to last element); the runtime type of
 202      * the returned array is that of the specified array.  If the list fits
 203      * in the specified array, it is returned therein.  Otherwise, a new
 204      * array is allocated with the runtime type of the specified array and
 205      * the size of this list.
 206      *
 207      * &lt;p&gt;If the list fits in the specified array with room to spare (i.e.,
 208      * the array has more elements than the list), the element in the array
 209      * immediately following the end of the list is set to {@code null}.
 210      * (This is useful in determining the length of the list &lt;i&gt;only&lt;/i&gt; if
 211      * the caller knows that the list does not contain any null elements.)
 212      *
 213      * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between
 214      * array-based and collection-based APIs.  Further, this method allows
 215      * precise control over the runtime type of the output array, and may,
 216      * under certain circumstances, be used to save allocation costs.
 217      *
 218      * &lt;p&gt;Suppose {@code x} is a list known to contain only strings.
 219      * The following code can be used to dump the list into a newly
 220      * allocated array of {@code String}:
 221      *
 222      * &lt;pre&gt;{@code
 223      *     String[] y = x.toArray(new String[0]);
 224      * }&lt;/pre&gt;
 225      *
 226      * Note that {@code toArray(new Object[0])} is identical in function to
 227      * {@code toArray()}.
 228      *
 229      * @param a the array into which the elements of this list are to
 230      *          be stored, if it is big enough; otherwise, a new array of the
 231      *          same runtime type is allocated for this purpose.
 232      * @return an array containing the elements of this list
 233      * @throws ArrayStoreException if the runtime type of the specified array
 234      *         is not a supertype of the runtime type of every element in
 235      *         this list
 236      * @throws NullPointerException if the specified array is null
 237      */
 238     &lt;T&gt; T[] toArray(T[] a);
 239 
 240 
 241     // Modification Operations
 242 
 243     /**
 244      * Appends the specified element to the end of this list (optional
 245      * operation).
 246      *
 247      * &lt;p&gt;Lists that support this operation may place limitations on what
 248      * elements may be added to this list.  In particular, some
 249      * lists will refuse to add null elements, and others will impose
 250      * restrictions on the type of elements that may be added.  List
 251      * classes should clearly specify in their documentation any restrictions
 252      * on what elements may be added.
 253      *
 254      * @param e element to be appended to this list
 255      * @return {@code true} (as specified by {@link Collection#add})
 256      * @throws UnsupportedOperationException if the {@code add} operation
 257      *         is not supported by this list
 258      * @throws ClassCastException if the class of the specified element
 259      *         prevents it from being added to this list
 260      * @throws NullPointerException if the specified element is null and this
 261      *         list does not permit null elements
 262      * @throws IllegalArgumentException if some property of this element
 263      *         prevents it from being added to this list
 264      */
 265     boolean add(E e);
 266 
 267     /**
 268      * Removes the first occurrence of the specified element from this list,
 269      * if it is present (optional operation).  If this list does not contain
 270      * the element, it is unchanged.  More formally, removes the element with
 271      * the lowest index {@code i} such that
 272      * {@code Objects.equals(o, get(i))}
 273      * (if such an element exists).  Returns {@code true} if this list
 274      * contained the specified element (or equivalently, if this list changed
 275      * as a result of the call).
 276      *
 277      * @param o element to be removed from this list, if present
 278      * @return {@code true} if this list contained the specified element
 279      * @throws ClassCastException if the type of the specified element
 280      *         is incompatible with this list
 281      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 282      * @throws NullPointerException if the specified element is null and this
 283      *         list does not permit null elements
 284      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 285      * @throws UnsupportedOperationException if the {@code remove} operation
 286      *         is not supported by this list
 287      */
 288     boolean remove(Object o);
 289 
 290 
 291     // Bulk Modification Operations
 292 
 293     /**
 294      * Returns {@code true} if this list contains all of the elements of the
 295      * specified collection.
 296      *
 297      * @param  c collection to be checked for containment in this list
 298      * @return {@code true} if this list contains all of the elements of the
 299      *         specified collection
 300      * @throws ClassCastException if the types of one or more elements
 301      *         in the specified collection are incompatible with this
 302      *         list
 303      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 304      * @throws NullPointerException if the specified collection contains one
 305      *         or more null elements and this list does not permit null
 306      *         elements
 307      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
 308      *         or if the specified collection is null
 309      * @see #contains(Object)
 310      */
 311     boolean containsAll(Collection&lt;?&gt; c);
 312 
 313     /**
 314      * Appends all of the elements in the specified collection to the end of
 315      * this list, in the order that they are returned by the specified
 316      * collection&#39;s iterator (optional operation).  The behavior of this
 317      * operation is undefined if the specified collection is modified while
 318      * the operation is in progress.  (Note that this will occur if the
 319      * specified collection is this list, and it&#39;s nonempty.)
 320      *
 321      * @param c collection containing elements to be added to this list
 322      * @return {@code true} if this list changed as a result of the call
 323      * @throws UnsupportedOperationException if the {@code addAll} operation
 324      *         is not supported by this list
 325      * @throws ClassCastException if the class of an element of the specified
 326      *         collection prevents it from being added to this list
 327      * @throws NullPointerException if the specified collection contains one
 328      *         or more null elements and this list does not permit null
 329      *         elements, or if the specified collection is null
 330      * @throws IllegalArgumentException if some property of an element of the
 331      *         specified collection prevents it from being added to this list
 332      * @see #add(Object)
 333      */
 334     boolean addAll(Collection&lt;? extends E&gt; c);
 335 
 336     /**
 337      * Inserts all of the elements in the specified collection into this
 338      * list at the specified position (optional operation).  Shifts the
 339      * element currently at that position (if any) and any subsequent
 340      * elements to the right (increases their indices).  The new elements
 341      * will appear in this list in the order that they are returned by the
 342      * specified collection&#39;s iterator.  The behavior of this operation is
 343      * undefined if the specified collection is modified while the
 344      * operation is in progress.  (Note that this will occur if the specified
 345      * collection is this list, and it&#39;s nonempty.)
 346      *
 347      * @param index index at which to insert the first element from the
 348      *              specified collection
 349      * @param c collection containing elements to be added to this list
 350      * @return {@code true} if this list changed as a result of the call
 351      * @throws UnsupportedOperationException if the {@code addAll} operation
 352      *         is not supported by this list
 353      * @throws ClassCastException if the class of an element of the specified
 354      *         collection prevents it from being added to this list
 355      * @throws NullPointerException if the specified collection contains one
 356      *         or more null elements and this list does not permit null
 357      *         elements, or if the specified collection is null
 358      * @throws IllegalArgumentException if some property of an element of the
 359      *         specified collection prevents it from being added to this list
 360      * @throws IndexOutOfBoundsException if the index is out of range
 361      *         ({@code index &lt; 0 || index &gt; size()})
 362      */
 363     boolean addAll(int index, Collection&lt;? extends E&gt; c);
 364 
 365     /**
 366      * Removes from this list all of its elements that are contained in the
 367      * specified collection (optional operation).
 368      *
 369      * @param c collection containing elements to be removed from this list
 370      * @return {@code true} if this list changed as a result of the call
 371      * @throws UnsupportedOperationException if the {@code removeAll} operation
 372      *         is not supported by this list
 373      * @throws ClassCastException if the class of an element of this list
 374      *         is incompatible with the specified collection
 375      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 376      * @throws NullPointerException if this list contains a null element and the
 377      *         specified collection does not permit null elements
 378      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
 379      *         or if the specified collection is null
 380      * @see #remove(Object)
 381      * @see #contains(Object)
 382      */
 383     boolean removeAll(Collection&lt;?&gt; c);
 384 
 385     /**
 386      * Retains only the elements in this list that are contained in the
 387      * specified collection (optional operation).  In other words, removes
 388      * from this list all of its elements that are not contained in the
 389      * specified collection.
 390      *
 391      * @param c collection containing elements to be retained in this list
 392      * @return {@code true} if this list changed as a result of the call
 393      * @throws UnsupportedOperationException if the {@code retainAll} operation
 394      *         is not supported by this list
 395      * @throws ClassCastException if the class of an element of this list
 396      *         is incompatible with the specified collection
 397      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 398      * @throws NullPointerException if this list contains a null element and the
 399      *         specified collection does not permit null elements
 400      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
 401      *         or if the specified collection is null
 402      * @see #remove(Object)
 403      * @see #contains(Object)
 404      */
 405     boolean retainAll(Collection&lt;?&gt; c);
 406 
 407     /**
 408      * Replaces each element of this list with the result of applying the
 409      * operator to that element.  Errors or runtime exceptions thrown by
 410      * the operator are relayed to the caller.
 411      *
 412      * @implSpec
 413      * The default implementation is equivalent to, for this {@code list}:
 414      * &lt;pre&gt;{@code
 415      *     final ListIterator&lt;E&gt; li = list.listIterator();
 416      *     while (li.hasNext()) {
 417      *         li.set(operator.apply(li.next()));
 418      *     }
 419      * }&lt;/pre&gt;
 420      *
 421      * If the list&#39;s list-iterator does not support the {@code set} operation
 422      * then an {@code UnsupportedOperationException} will be thrown when
 423      * replacing the first element.
 424      *
 425      * @param operator the operator to apply to each element
 426      * @throws UnsupportedOperationException if this list is unmodifiable.
 427      *         Implementations may throw this exception if an element
 428      *         cannot be replaced or if, in general, modification is not
 429      *         supported
 430      * @throws NullPointerException if the specified operator is null or
 431      *         if the operator result is a null value and this list does
 432      *         not permit null elements
 433      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 434      * @since 1.8
 435      */
 436     default void replaceAll(UnaryOperator&lt;E&gt; operator) {
 437         Objects.requireNonNull(operator);
 438         final ListIterator&lt;E&gt; li = this.listIterator();
 439         while (li.hasNext()) {
 440             li.set(operator.apply(li.next()));
 441         }
 442     }
 443 
 444     /**
 445      * Sorts this list according to the order induced by the specified
 446      * {@link Comparator}.  The sort is &lt;i&gt;stable&lt;/i&gt;: this method must not
 447      * reorder equal elements.
 448      *
 449      * &lt;p&gt;All elements in this list must be &lt;i&gt;mutually comparable&lt;/i&gt; using the
 450      * specified comparator (that is, {@code c.compare(e1, e2)} must not throw
 451      * a {@code ClassCastException} for any elements {@code e1} and {@code e2}
 452      * in the list).
 453      *
 454      * &lt;p&gt;If the specified comparator is {@code null} then all elements in this
 455      * list must implement the {@link Comparable} interface and the elements&#39;
 456      * {@linkplain Comparable natural ordering} should be used.
 457      *
 458      * &lt;p&gt;This list must be modifiable, but need not be resizable.
 459      *
 460      * @implSpec
 461      * The default implementation obtains an array containing all elements in
 462      * this list, sorts the array, and iterates over this list resetting each
 463      * element from the corresponding position in the array. (This avoids the
 464      * n&lt;sup&gt;2&lt;/sup&gt; log(n) performance that would result from attempting
 465      * to sort a linked list in place.)
 466      *
 467      * @implNote
 468      * This implementation is a stable, adaptive, iterative mergesort that
 469      * requires far fewer than n lg(n) comparisons when the input array is
 470      * partially sorted, while offering the performance of a traditional
 471      * mergesort when the input array is randomly ordered.  If the input array
 472      * is nearly sorted, the implementation requires approximately n
 473      * comparisons.  Temporary storage requirements vary from a small constant
 474      * for nearly sorted input arrays to n/2 object references for randomly
 475      * ordered input arrays.
 476      *
 477      * &lt;p&gt;The implementation takes equal advantage of ascending and
 478      * descending order in its input array, and can take advantage of
 479      * ascending and descending order in different parts of the same
 480      * input array.  It is well-suited to merging two or more sorted arrays:
 481      * simply concatenate the arrays and sort the resulting array.
 482      *
 483      * &lt;p&gt;The implementation was adapted from Tim Peters&#39;s list sort for Python
 484      * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
 485      * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy&#39;s &quot;Optimistic
 486      * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
 487      * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
 488      * January 1993.
 489      *
 490      * @param c the {@code Comparator} used to compare list elements.
 491      *          A {@code null} value indicates that the elements&#39;
 492      *          {@linkplain Comparable natural ordering} should be used
 493      * @throws ClassCastException if the list contains elements that are not
 494      *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator
 495      * @throws UnsupportedOperationException if the list&#39;s list-iterator does
 496      *         not support the {@code set} operation
 497      * @throws IllegalArgumentException
 498      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 499      *         if the comparator is found to violate the {@link Comparator}
 500      *         contract
 501      * @since 1.8
 502      */
 503     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 504     default void sort(Comparator&lt;? super E&gt; c) {
 505         Object[] a = this.toArray();
 506         Arrays.sort(a, (Comparator) c);
 507         ListIterator&lt;E&gt; i = this.listIterator();
 508         for (Object e : a) {
 509             i.next();
 510             i.set((E) e);
 511         }
 512     }
 513 
 514     /**
 515      * Removes all of the elements from this list (optional operation).
 516      * The list will be empty after this call returns.
 517      *
 518      * @throws UnsupportedOperationException if the {@code clear} operation
 519      *         is not supported by this list
 520      */
 521     void clear();
 522 
 523 
 524     // Comparison and hashing
 525 
 526     /**
 527      * Compares the specified object with this list for equality.  Returns
 528      * {@code true} if and only if the specified object is also a list, both
 529      * lists have the same size, and all corresponding pairs of elements in
 530      * the two lists are &lt;i&gt;equal&lt;/i&gt;.  (Two elements {@code e1} and
 531      * {@code e2} are &lt;i&gt;equal&lt;/i&gt; if {@code Objects.equals(e1, e2)}.)
 532      * In other words, two lists are defined to be
 533      * equal if they contain the same elements in the same order.  This
 534      * definition ensures that the equals method works properly across
 535      * different implementations of the {@code List} interface.
 536      *
 537      * @param o the object to be compared for equality with this list
 538      * @return {@code true} if the specified object is equal to this list
 539      */
 540     boolean equals(Object o);
 541 
 542     /**
 543      * Returns the hash code value for this list.  The hash code of a list
 544      * is defined to be the result of the following calculation:
 545      * &lt;pre&gt;{@code
 546      *     int hashCode = 1;
 547      *     for (E e : list)
 548      *         hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());
 549      * }&lt;/pre&gt;
 550      * This ensures that {@code list1.equals(list2)} implies that
 551      * {@code list1.hashCode()==list2.hashCode()} for any two lists,
 552      * {@code list1} and {@code list2}, as required by the general
 553      * contract of {@link Object#hashCode}.
 554      *
 555      * @return the hash code value for this list
 556      * @see Object#equals(Object)
 557      * @see #equals(Object)
 558      */
 559     int hashCode();
 560 
 561 
 562     // Positional Access Operations
 563 
 564     /**
 565      * Returns the element at the specified position in this list.
 566      *
 567      * @param index index of the element to return
 568      * @return the element at the specified position in this list
 569      * @throws IndexOutOfBoundsException if the index is out of range
 570      *         ({@code index &lt; 0 || index &gt;= size()})
 571      */
 572     E get(int index);
 573 
 574     /**
 575      * Replaces the element at the specified position in this list with the
 576      * specified element (optional operation).
 577      *
 578      * @param index index of the element to replace
 579      * @param element element to be stored at the specified position
 580      * @return the element previously at the specified position
 581      * @throws UnsupportedOperationException if the {@code set} operation
 582      *         is not supported by this list
 583      * @throws ClassCastException if the class of the specified element
 584      *         prevents it from being added to this list
 585      * @throws NullPointerException if the specified element is null and
 586      *         this list does not permit null elements
 587      * @throws IllegalArgumentException if some property of the specified
 588      *         element prevents it from being added to this list
 589      * @throws IndexOutOfBoundsException if the index is out of range
 590      *         ({@code index &lt; 0 || index &gt;= size()})
 591      */
 592     E set(int index, E element);
 593 
 594     /**
 595      * Inserts the specified element at the specified position in this list
 596      * (optional operation).  Shifts the element currently at that position
 597      * (if any) and any subsequent elements to the right (adds one to their
 598      * indices).
 599      *
 600      * @param index index at which the specified element is to be inserted
 601      * @param element element to be inserted
 602      * @throws UnsupportedOperationException if the {@code add} operation
 603      *         is not supported by this list
 604      * @throws ClassCastException if the class of the specified element
 605      *         prevents it from being added to this list
 606      * @throws NullPointerException if the specified element is null and
 607      *         this list does not permit null elements
 608      * @throws IllegalArgumentException if some property of the specified
 609      *         element prevents it from being added to this list
 610      * @throws IndexOutOfBoundsException if the index is out of range
 611      *         ({@code index &lt; 0 || index &gt; size()})
 612      */
 613     void add(int index, E element);
 614 
 615     /**
 616      * Removes the element at the specified position in this list (optional
 617      * operation).  Shifts any subsequent elements to the left (subtracts one
 618      * from their indices).  Returns the element that was removed from the
 619      * list.
 620      *
 621      * @param index the index of the element to be removed
 622      * @return the element previously at the specified position
 623      * @throws UnsupportedOperationException if the {@code remove} operation
 624      *         is not supported by this list
 625      * @throws IndexOutOfBoundsException if the index is out of range
 626      *         ({@code index &lt; 0 || index &gt;= size()})
 627      */
 628     E remove(int index);
 629 
 630 
 631     // Search Operations
 632 
 633     /**
 634      * Returns the index of the first occurrence of the specified element
 635      * in this list, or -1 if this list does not contain the element.
 636      * More formally, returns the lowest index {@code i} such that
 637      * {@code Objects.equals(o, get(i))},
 638      * or -1 if there is no such index.
 639      *
 640      * @param o element to search for
 641      * @return the index of the first occurrence of the specified element in
 642      *         this list, or -1 if this list does not contain the element
 643      * @throws ClassCastException if the type of the specified element
 644      *         is incompatible with this list
 645      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 646      * @throws NullPointerException if the specified element is null and this
 647      *         list does not permit null elements
 648      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 649      */
 650     int indexOf(Object o);
 651 
 652     /**
 653      * Returns the index of the last occurrence of the specified element
 654      * in this list, or -1 if this list does not contain the element.
 655      * More formally, returns the highest index {@code i} such that
 656      * {@code Objects.equals(o, get(i))},
 657      * or -1 if there is no such index.
 658      *
 659      * @param o element to search for
 660      * @return the index of the last occurrence of the specified element in
 661      *         this list, or -1 if this list does not contain the element
 662      * @throws ClassCastException if the type of the specified element
 663      *         is incompatible with this list
 664      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 665      * @throws NullPointerException if the specified element is null and this
 666      *         list does not permit null elements
 667      *         (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 668      */
 669     int lastIndexOf(Object o);
 670 
 671 
 672     // List Iterators
 673 
 674     /**
 675      * Returns a list iterator over the elements in this list (in proper
 676      * sequence).
 677      *
 678      * @return a list iterator over the elements in this list (in proper
 679      *         sequence)
 680      */
 681     ListIterator&lt;E&gt; listIterator();
 682 
 683     /**
 684      * Returns a list iterator over the elements in this list (in proper
 685      * sequence), starting at the specified position in the list.
 686      * The specified index indicates the first element that would be
 687      * returned by an initial call to {@link ListIterator#next next}.
 688      * An initial call to {@link ListIterator#previous previous} would
 689      * return the element with the specified index minus one.
 690      *
 691      * @param index index of the first element to be returned from the
 692      *        list iterator (by a call to {@link ListIterator#next next})
 693      * @return a list iterator over the elements in this list (in proper
 694      *         sequence), starting at the specified position in the list
 695      * @throws IndexOutOfBoundsException if the index is out of range
 696      *         ({@code index &lt; 0 || index &gt; size()})
 697      */
 698     ListIterator&lt;E&gt; listIterator(int index);
 699 
 700     // View
 701 
 702     /**
 703      * Returns a view of the portion of this list between the specified
 704      * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.  (If
 705      * {@code fromIndex} and {@code toIndex} are equal, the returned list is
 706      * empty.)  The returned list is backed by this list, so non-structural
 707      * changes in the returned list are reflected in this list, and vice-versa.
 708      * The returned list supports all of the optional list operations supported
 709      * by this list.&lt;p&gt;
 710      *
 711      * This method eliminates the need for explicit range operations (of
 712      * the sort that commonly exist for arrays).  Any operation that expects
 713      * a list can be used as a range operation by passing a subList view
 714      * instead of a whole list.  For example, the following idiom
 715      * removes a range of elements from a list:
 716      * &lt;pre&gt;{@code
 717      *      list.subList(from, to).clear();
 718      * }&lt;/pre&gt;
 719      * Similar idioms may be constructed for {@code indexOf} and
 720      * {@code lastIndexOf}, and all of the algorithms in the
 721      * {@code Collections} class can be applied to a subList.&lt;p&gt;
 722      *
 723      * The semantics of the list returned by this method become undefined if
 724      * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in
 725      * any way other than via the returned list.  (Structural modifications are
 726      * those that change the size of this list, or otherwise perturb it in such
 727      * a fashion that iterations in progress may yield incorrect results.)
 728      *
 729      * @param fromIndex low endpoint (inclusive) of the subList
 730      * @param toIndex high endpoint (exclusive) of the subList
 731      * @return a view of the specified range within this list
 732      * @throws IndexOutOfBoundsException for an illegal endpoint index value
 733      *         ({@code fromIndex &lt; 0 || toIndex &gt; size ||
 734      *         fromIndex &gt; toIndex})
 735      */
 736     List&lt;E&gt; subList(int fromIndex, int toIndex);
 737 
 738     /**
 739      * Creates a {@link Spliterator} over the elements in this list.
 740      *
 741      * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED} and
 742      * {@link Spliterator#ORDERED}.  Implementations should document the
 743      * reporting of additional characteristic values.
 744      *
 745      * @implSpec
 746      * The default implementation creates a
 747      * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;
 748      * spliterator as follows:
 749      * &lt;ul&gt;
 750      * &lt;li&gt;If the list is an instance of {@link RandomAccess} then the default
 751      *     implementation creates a spliterator that traverses elements by
 752      *     invoking the method {@link List#get}.  If such invocation results or
 753      *     would result in an {@code IndexOutOfBoundsException} then the
 754      *     spliterator will &lt;em&gt;fail-fast&lt;/em&gt; and throw a
 755      *     {@code ConcurrentModificationException}.
 756      *     If the list is also an instance of {@link AbstractList} then the
 757      *     spliterator will use the list&#39;s {@link AbstractList#modCount modCount}
 758      *     field to provide additional &lt;em&gt;fail-fast&lt;/em&gt; behavior.
 759      * &lt;li&gt;Otherwise, the default implementation creates a spliterator from the
 760      *     list&#39;s {@code Iterator}.  The spliterator inherits the
 761      *     &lt;em&gt;fail-fast&lt;/em&gt; of the list&#39;s iterator.
 762      * &lt;/ul&gt;
 763      *
 764      * @implNote
 765      * The created {@code Spliterator} additionally reports
 766      * {@link Spliterator#SUBSIZED}.
 767      *
 768      * @return a {@code Spliterator} over the elements in this list
 769      * @since 1.8
 770      */
 771     @Override
 772     default Spliterator&lt;E&gt; spliterator() {
 773         if (this instanceof RandomAccess) {
 774             return new AbstractList.RandomAccessSpliterator&lt;&gt;(this);
 775         } else {
 776             return Spliterators.spliterator(this, Spliterator.ORDERED);
 777         }
 778     }
 779 
 780     /**
 781      * Returns an unmodifiable list containing zero elements.
 782      *
 783      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 784      *
 785      * @param &lt;E&gt; the {@code List}&#39;s element type
 786      * @return an empty {@code List}
 787      *
 788      * @since 9
 789      */
 790     @SuppressWarnings(&quot;unchecked&quot;)
 791     static &lt;E&gt; List&lt;E&gt; of() {
 792         return (List&lt;E&gt;) ImmutableCollections.EMPTY_LIST;
 793     }
 794 
 795     /**
 796      * Returns an unmodifiable list containing one element.
 797      *
 798      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 799      *
 800      * @param &lt;E&gt; the {@code List}&#39;s element type
 801      * @param e1 the single element
 802      * @return a {@code List} containing the specified element
 803      * @throws NullPointerException if the element is {@code null}
 804      *
 805      * @since 9
 806      */
 807     static &lt;E&gt; List&lt;E&gt; of(E e1) {
 808         return new ImmutableCollections.List12&lt;&gt;(e1);
 809     }
 810 
 811     /**
 812      * Returns an unmodifiable list containing two elements.
 813      *
 814      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 815      *
 816      * @param &lt;E&gt; the {@code List}&#39;s element type
 817      * @param e1 the first element
 818      * @param e2 the second element
 819      * @return a {@code List} containing the specified elements
 820      * @throws NullPointerException if an element is {@code null}
 821      *
 822      * @since 9
 823      */
 824     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2) {
 825         return new ImmutableCollections.List12&lt;&gt;(e1, e2);
 826     }
 827 
 828     /**
 829      * Returns an unmodifiable list containing three elements.
 830      *
 831      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 832      *
 833      * @param &lt;E&gt; the {@code List}&#39;s element type
 834      * @param e1 the first element
 835      * @param e2 the second element
 836      * @param e3 the third element
 837      * @return a {@code List} containing the specified elements
 838      * @throws NullPointerException if an element is {@code null}
 839      *
 840      * @since 9
 841      */
 842     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3) {
 843         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3);
 844     }
 845 
 846     /**
 847      * Returns an unmodifiable list containing four elements.
 848      *
 849      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 850      *
 851      * @param &lt;E&gt; the {@code List}&#39;s element type
 852      * @param e1 the first element
 853      * @param e2 the second element
 854      * @param e3 the third element
 855      * @param e4 the fourth element
 856      * @return a {@code List} containing the specified elements
 857      * @throws NullPointerException if an element is {@code null}
 858      *
 859      * @since 9
 860      */
 861     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4) {
 862         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4);
 863     }
 864 
 865     /**
 866      * Returns an unmodifiable list containing five elements.
 867      *
 868      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 869      *
 870      * @param &lt;E&gt; the {@code List}&#39;s element type
 871      * @param e1 the first element
 872      * @param e2 the second element
 873      * @param e3 the third element
 874      * @param e4 the fourth element
 875      * @param e5 the fifth element
 876      * @return a {@code List} containing the specified elements
 877      * @throws NullPointerException if an element is {@code null}
 878      *
 879      * @since 9
 880      */
 881     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5) {
 882         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5);
 883     }
 884 
 885     /**
 886      * Returns an unmodifiable list containing six elements.
 887      *
 888      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 889      *
 890      * @param &lt;E&gt; the {@code List}&#39;s element type
 891      * @param e1 the first element
 892      * @param e2 the second element
 893      * @param e3 the third element
 894      * @param e4 the fourth element
 895      * @param e5 the fifth element
 896      * @param e6 the sixth element
 897      * @return a {@code List} containing the specified elements
 898      * @throws NullPointerException if an element is {@code null}
 899      *
 900      * @since 9
 901      */
 902     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6) {
 903         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,
 904                                                 e6);
 905     }
 906 
 907     /**
 908      * Returns an unmodifiable list containing seven elements.
 909      *
 910      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 911      *
 912      * @param &lt;E&gt; the {@code List}&#39;s element type
 913      * @param e1 the first element
 914      * @param e2 the second element
 915      * @param e3 the third element
 916      * @param e4 the fourth element
 917      * @param e5 the fifth element
 918      * @param e6 the sixth element
 919      * @param e7 the seventh element
 920      * @return a {@code List} containing the specified elements
 921      * @throws NullPointerException if an element is {@code null}
 922      *
 923      * @since 9
 924      */
 925     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {
 926         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,
 927                                                 e6, e7);
 928     }
 929 
 930     /**
 931      * Returns an unmodifiable list containing eight elements.
 932      *
 933      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 934      *
 935      * @param &lt;E&gt; the {@code List}&#39;s element type
 936      * @param e1 the first element
 937      * @param e2 the second element
 938      * @param e3 the third element
 939      * @param e4 the fourth element
 940      * @param e5 the fifth element
 941      * @param e6 the sixth element
 942      * @param e7 the seventh element
 943      * @param e8 the eighth element
 944      * @return a {@code List} containing the specified elements
 945      * @throws NullPointerException if an element is {@code null}
 946      *
 947      * @since 9
 948      */
 949     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {
 950         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,
 951                                                 e6, e7, e8);
 952     }
 953 
 954     /**
 955      * Returns an unmodifiable list containing nine elements.
 956      *
 957      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 958      *
 959      * @param &lt;E&gt; the {@code List}&#39;s element type
 960      * @param e1 the first element
 961      * @param e2 the second element
 962      * @param e3 the third element
 963      * @param e4 the fourth element
 964      * @param e5 the fifth element
 965      * @param e6 the sixth element
 966      * @param e7 the seventh element
 967      * @param e8 the eighth element
 968      * @param e9 the ninth element
 969      * @return a {@code List} containing the specified elements
 970      * @throws NullPointerException if an element is {@code null}
 971      *
 972      * @since 9
 973      */
 974     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {
 975         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,
 976                                                 e6, e7, e8, e9);
 977     }
 978 
 979     /**
 980      * Returns an unmodifiable list containing ten elements.
 981      *
 982      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
 983      *
 984      * @param &lt;E&gt; the {@code List}&#39;s element type
 985      * @param e1 the first element
 986      * @param e2 the second element
 987      * @param e3 the third element
 988      * @param e4 the fourth element
 989      * @param e5 the fifth element
 990      * @param e6 the sixth element
 991      * @param e7 the seventh element
 992      * @param e8 the eighth element
 993      * @param e9 the ninth element
 994      * @param e10 the tenth element
 995      * @return a {@code List} containing the specified elements
 996      * @throws NullPointerException if an element is {@code null}
 997      *
 998      * @since 9
 999      */
1000     static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {
1001         return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5,
1002                                                 e6, e7, e8, e9, e10);
1003     }
1004 
1005     /**
1006      * Returns an unmodifiable list containing an arbitrary number of elements.
1007      * See &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt; for details.
1008      *
1009      * @apiNote
1010      * This method also accepts a single array as an argument. The element type of
1011      * the resulting list will be the component type of the array, and the size of
1012      * the list will be equal to the length of the array. To create a list with
1013      * a single element that is an array, do the following:
1014      *
1015      * &lt;pre&gt;{@code
1016      *     String[] array = ... ;
1017      *     List&lt;String[]&gt; list = List.&lt;String[]&gt;of(array);
1018      * }&lt;/pre&gt;
1019      *
1020      * This will cause the {@link List#of(Object) List.of(E)} method
1021      * to be invoked instead.
1022      *
1023      * @param &lt;E&gt; the {@code List}&#39;s element type
1024      * @param elements the elements to be contained in the list
1025      * @return a {@code List} containing the specified elements
1026      * @throws NullPointerException if an element is {@code null} or if the array is {@code null}
1027      *
1028      * @since 9
1029      */
1030     @SafeVarargs
1031     @SuppressWarnings(&quot;varargs&quot;)
1032     static &lt;E&gt; List&lt;E&gt; of(E... elements) {
1033         switch (elements.length) { // implicit null check of elements
1034             case 0:
1035                 @SuppressWarnings(&quot;unchecked&quot;)
1036                 var list = (List&lt;E&gt;) ImmutableCollections.EMPTY_LIST;
1037                 return list;
1038             case 1:
1039                 return new ImmutableCollections.List12&lt;&gt;(elements[0]);
1040             case 2:
1041                 return new ImmutableCollections.List12&lt;&gt;(elements[0], elements[1]);
1042             default:
1043                 return new ImmutableCollections.ListN&lt;&gt;(elements);
1044         }
1045     }
1046 
1047     /**
1048      * Returns an &lt;a href=&quot;#unmodifiable&quot;&gt;unmodifiable List&lt;/a&gt; containing the elements of
1049      * the given Collection, in its iteration order. The given Collection must not be null,
1050      * and it must not contain any null elements. If the given Collection is subsequently
1051      * modified, the returned List will not reflect such modifications.
1052      *
1053      * @implNote
1054      * If the given Collection is an &lt;a href=&quot;#unmodifiable&quot;&gt;unmodifiable List&lt;/a&gt;,
1055      * calling copyOf will generally not create a copy.
1056      *
1057      * @param &lt;E&gt; the {@code List}&#39;s element type
1058      * @param coll a {@code Collection} from which elements are drawn, must be non-null
1059      * @return a {@code List} containing the elements of the given {@code Collection}
1060      * @throws NullPointerException if coll is null, or if it contains any nulls
1061      * @since 10
1062      */
1063     static &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) {
1064         return ImmutableCollections.listCopy(coll);
1065     }
1066 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
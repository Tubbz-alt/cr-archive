<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/nio/file/FileSystems.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.nio.file;
 27 
 28 import java.nio.file.spi.FileSystemProvider;
 29 import java.net.URI;
 30 import java.io.IOException;
 31 import java.security.AccessController;
 32 import java.security.PrivilegedAction;
 33 import java.lang.reflect.Constructor;
 34 import java.util.Collections;
 35 import java.util.Map;
 36 import java.util.ServiceConfigurationError;
 37 import java.util.ServiceLoader;
 38 
 39 import jdk.internal.misc.VM;
 40 import sun.nio.fs.DefaultFileSystemProvider;
 41 
 42 /**
 43  * Factory methods for file systems. This class defines the {@link #getDefault
 44  * getDefault} method to get the default file system and factory methods to
 45  * construct other types of file systems.
 46  *
 47  * &lt;p&gt; The first invocation of any of the methods defined by this class causes
 48  * the default {@link FileSystemProvider provider} to be loaded. The default
 49  * provider, identified by the URI scheme &quot;file&quot;, creates the {@link FileSystem}
 50  * that provides access to the file systems accessible to the Java virtual
 51  * machine. If the process of loading or initializing the default provider fails
 52  * then an unspecified error is thrown.
 53  *
 54  * &lt;p&gt; The first invocation of the {@link FileSystemProvider#installedProviders()
 55  * installedProviders} method, by way of invoking any of the {@code
 56  * newFileSystem} methods defined by this class, locates and loads all
 57  * installed file system providers. Installed providers are loaded using the
 58  * service-provider loading facility defined by the {@link ServiceLoader} class.
 59  * Installed providers are loaded using the system class loader. If the
 60  * system class loader cannot be found then the platform class loader is used.
 61  * Providers are typically installed by placing them in a JAR file on the
 62  * application class path, the JAR file contains a
 63  * provider-configuration file named {@code java.nio.file.spi.FileSystemProvider}
 64  * in the resource directory {@code META-INF/services}, and the file lists one or
 65  * more fully-qualified names of concrete subclass of {@link FileSystemProvider}
 66  * that have a zero argument constructor.
 67  * The ordering that installed providers are located is implementation specific.
 68  * If a provider is instantiated and its {@link FileSystemProvider#getScheme()
 69  * getScheme} returns the same URI scheme of a provider that was previously
 70  * instantiated then the most recently instantiated duplicate is discarded. URI
 71  * schemes are compared without regard to case. During construction a provider
 72  * may safely access files associated with the default provider but care needs
 73  * to be taken to avoid circular loading of other installed providers. If
 74  * circular loading of installed providers is detected then an unspecified error
 75  * is thrown.
 76  *
 77  * &lt;p&gt; This class also defines factory methods that allow a {@link ClassLoader}
 78  * to be specified when locating a provider. As with installed providers, the
 79  * provider classes are identified by placing the provider configuration file
 80  * in the resource directory {@code META-INF/services}.
 81  *
 82  * &lt;p&gt; If a thread initiates the loading of the installed file system providers
 83  * and another thread invokes a method that also attempts to load the providers
 84  * then the method will block until the loading completes.
 85  *
 86  * @since 1.7
 87  */
 88 
 89 public final class FileSystems {
 90     private FileSystems() { }
 91 
 92     // lazy initialization of default file system
 93     private static class DefaultFileSystemHolder {
 94         static final FileSystem defaultFileSystem = defaultFileSystem();
 95 
 96         // returns default file system
 97         private static FileSystem defaultFileSystem() {
 98             // load default provider
 99             FileSystemProvider provider = AccessController
100                 .doPrivileged(new PrivilegedAction&lt;&gt;() {
101                     public FileSystemProvider run() {
102                         return getDefaultProvider();
103                     }
104                 });
105 
106             // return file system
107             return provider.getFileSystem(URI.create(&quot;file:///&quot;));
108         }
109 
110         // returns default provider
111         private static FileSystemProvider getDefaultProvider() {
112             // start with the platform&#39;s default file system provider
113             FileSystemProvider provider = DefaultFileSystemProvider.instance();
114 
115             // if the property java.nio.file.spi.DefaultFileSystemProvider is
116             // set then its value is the name of the default provider (or a list)
117             String prop = &quot;java.nio.file.spi.DefaultFileSystemProvider&quot;;
118             String propValue = System.getProperty(prop);
119             if (propValue != null) {
120                 for (String cn: propValue.split(&quot;,&quot;)) {
121                     try {
122                         Class&lt;?&gt; c = Class
123                             .forName(cn, true, ClassLoader.getSystemClassLoader());
124                         Constructor&lt;?&gt; ctor = c
125                             .getDeclaredConstructor(FileSystemProvider.class);
126                         provider = (FileSystemProvider)ctor.newInstance(provider);
127 
128                         // must be &quot;file&quot;
129                         if (!provider.getScheme().equals(&quot;file&quot;))
130                             throw new Error(&quot;Default provider must use scheme &#39;file&#39;&quot;);
131 
132                     } catch (Exception x) {
133                         throw new Error(x);
134                     }
135                 }
136             }
137             return provider;
138         }
139     }
140 
141     /**
142      * Returns the default {@code FileSystem}. The default file system creates
143      * objects that provide access to the file systems accessible to the Java
144      * virtual machine. The &lt;em&gt;working directory&lt;/em&gt; of the file system is
145      * the current user directory, named by the system property {@code user.dir}.
146      * This allows for interoperability with the {@link java.io.File java.io.File}
147      * class.
148      *
149      * &lt;p&gt; The first invocation of any of the methods defined by this class
150      * locates the default {@link FileSystemProvider provider} object. Where the
151      * system property {@code java.nio.file.spi.DefaultFileSystemProvider} is
152      * not defined then the default provider is a system-default provider that
153      * is invoked to create the default file system.
154      *
155      * &lt;p&gt; If the system property {@code java.nio.file.spi.DefaultFileSystemProvider}
156      * is defined then it is taken to be a list of one or more fully-qualified
157      * names of concrete provider classes identified by the URI scheme
158      * {@code &quot;file&quot;}. Where the property is a list of more than one name then
159      * the names are separated by a comma. Each class is loaded, using the system
160      * class loader, and instantiated by invoking a one argument constructor
161      * whose formal parameter type is {@code FileSystemProvider}. The providers
162      * are loaded and instantiated in the order they are listed in the property.
163      * If this process fails or a provider&#39;s scheme is not equal to {@code &quot;file&quot;}
164      * then an unspecified error is thrown. URI schemes are normally compared
165      * without regard to case but for the default provider, the scheme is
166      * required to be {@code &quot;file&quot;}. The first provider class is instantiated
167      * by invoking it with a reference to the system-default provider.
168      * The second provider class is instantiated by invoking it with a reference
169      * to the first provider instance. The third provider class is instantiated
170      * by invoking it with a reference to the second instance, and so on. The
171      * last provider to be instantiated becomes the default provider; its {@code
172      * getFileSystem} method is invoked with the URI {@code &quot;file:///&quot;} to
173      * get a reference to the default file system.
174      *
175      * &lt;p&gt; Subsequent invocations of this method return the file system that was
176      * returned by the first invocation.
177      *
178      * @return  the default file system
179      */
180     public static FileSystem getDefault() {
181         if (VM.isModuleSystemInited()) {
182             return DefaultFileSystemHolder.defaultFileSystem;
183         } else {
184             // always use the platform&#39;s default file system during startup
185             return DefaultFileSystemProvider.theFileSystem();
186         }
187     }
188 
189     /**
190      * Returns a reference to an existing {@code FileSystem}.
191      *
192      * &lt;p&gt; This method iterates over the {@link FileSystemProvider#installedProviders()
193      * installed} providers to locate the provider that is identified by the URI
194      * {@link URI#getScheme scheme} of the given URI. URI schemes are compared
195      * without regard to case. The exact form of the URI is highly provider
196      * dependent. If found, the provider&#39;s {@link FileSystemProvider#getFileSystem
197      * getFileSystem} method is invoked to obtain a reference to the {@code
198      * FileSystem}.
199      *
200      * &lt;p&gt; Once a file system created by this provider is {@link FileSystem#close
201      * closed} it is provider-dependent if this method returns a reference to
202      * the closed file system or throws {@link FileSystemNotFoundException}.
203      * If the provider allows a new file system to be created with the same URI
204      * as a file system it previously created then this method throws the
205      * exception if invoked after the file system is closed (and before a new
206      * instance is created by the {@link #newFileSystem newFileSystem} method).
207      *
208      * &lt;p&gt; If a security manager is installed then a provider implementation
209      * may require to check a permission before returning a reference to an
210      * existing file system. In the case of the {@link FileSystems#getDefault
211      * default} file system, no permission check is required.
212      *
213      * @param   uri  the URI to locate the file system
214      *
215      * @return  the reference to the file system
216      *
217      * @throws  IllegalArgumentException
218      *          if the pre-conditions for the {@code uri} parameter are not met
219      * @throws  FileSystemNotFoundException
220      *          if the file system, identified by the URI, does not exist
221      * @throws  ProviderNotFoundException
222      *          if a provider supporting the URI scheme is not installed
223      * @throws  SecurityException
224      *          if a security manager is installed and it denies an unspecified
225      *          permission
226      */
227     public static FileSystem getFileSystem(URI uri) {
228         String scheme = uri.getScheme();
<a name="2" id="anc2"></a><span class="line-added">229         if (scheme == null) {</span>
<span class="line-added">230             throw new IllegalArgumentException(uri.toString());</span>
<span class="line-added">231         }</span>
232         for (FileSystemProvider provider: FileSystemProvider.installedProviders()) {
233             if (scheme.equalsIgnoreCase(provider.getScheme())) {
234                 return provider.getFileSystem(uri);
235             }
236         }
237         throw new ProviderNotFoundException(&quot;Provider \&quot;&quot; + scheme + &quot;\&quot; not found&quot;);
238     }
239 
240     /**
241      * Constructs a new file system that is identified by a {@link URI}
242      *
243      * &lt;p&gt; This method iterates over the {@link FileSystemProvider#installedProviders()
244      * installed} providers to locate the provider that is identified by the URI
245      * {@link URI#getScheme scheme} of the given URI. URI schemes are compared
246      * without regard to case. The exact form of the URI is highly provider
247      * dependent. If found, the provider&#39;s {@link FileSystemProvider#newFileSystem(URI,Map)
248      * newFileSystem(URI,Map)} method is invoked to construct the new file system.
249      *
250      * &lt;p&gt; Once a file system is {@link FileSystem#close closed} it is
251      * provider-dependent if the provider allows a new file system to be created
252      * with the same URI as a file system it previously created.
253      *
254      * &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
255      * Suppose there is a provider identified by the scheme {@code &quot;memory&quot;}
256      * installed:
257      * &lt;pre&gt;
258      *  FileSystem fs = FileSystems.newFileSystem(URI.create(&quot;memory:///?name=logfs&quot;),
259      *                                            Map.of(&quot;capacity&quot;, &quot;16G&quot;, &quot;blockSize&quot;, &quot;4k&quot;));
260      * &lt;/pre&gt;
261      *
262      * @param   uri
263      *          the URI identifying the file system
264      * @param   env
265      *          a map of provider specific properties to configure the file system;
266      *          may be empty
267      *
268      * @return  a new file system
269      *
270      * @throws  IllegalArgumentException
271      *          if the pre-conditions for the {@code uri} parameter are not met,
272      *          or the {@code env} parameter does not contain properties required
273      *          by the provider, or a property value is invalid
274      * @throws  FileSystemAlreadyExistsException
275      *          if the file system has already been created
276      * @throws  ProviderNotFoundException
277      *          if a provider supporting the URI scheme is not installed
278      * @throws  IOException
279      *          if an I/O error occurs creating the file system
280      * @throws  SecurityException
281      *          if a security manager is installed and it denies an unspecified
282      *          permission required by the file system provider implementation
283      */
284     public static FileSystem newFileSystem(URI uri, Map&lt;String,?&gt; env)
285         throws IOException
286     {
287         return newFileSystem(uri, env, null);
288     }
289 
290     /**
291      * Constructs a new file system that is identified by a {@link URI}
292      *
293      * &lt;p&gt; This method first attempts to locate an installed provider in exactly
294      * the same manner as the {@link #newFileSystem(URI,Map) newFileSystem(URI,Map)}
295      * method. If none of the installed providers support the URI scheme then an
296      * attempt is made to locate the provider using the given class loader. If a
297      * provider supporting the URI scheme is located then its {@link
298      * FileSystemProvider#newFileSystem(URI,Map) newFileSystem(URI,Map)} is
299      * invoked to construct the new file system.
300      *
301      * @param   uri
302      *          the URI identifying the file system
303      * @param   env
304      *          a map of provider specific properties to configure the file system;
305      *          may be empty
306      * @param   loader
307      *          the class loader to locate the provider or {@code null} to only
308      *          attempt to locate an installed provider
309      *
310      * @return  a new file system
311      *
312      * @throws  IllegalArgumentException
313      *          if the pre-conditions for the {@code uri} parameter are not met,
314      *          or the {@code env} parameter does not contain properties required
315      *          by the provider, or a property value is invalid
316      * @throws  FileSystemAlreadyExistsException
317      *          if the URI scheme identifies an installed provider and the file
318      *          system has already been created
319      * @throws  ProviderNotFoundException
320      *          if a provider supporting the URI scheme is not found
321      * @throws  ServiceConfigurationError
322      *          when an error occurs while loading a service provider
323      * @throws  IOException
324      *          an I/O error occurs creating the file system
325      * @throws  SecurityException
326      *          if a security manager is installed and it denies an unspecified
327      *          permission required by the file system provider implementation
328      */
329     public static FileSystem newFileSystem(URI uri, Map&lt;String,?&gt; env, ClassLoader loader)
330         throws IOException
331     {
332         String scheme = uri.getScheme();
333 
334         // check installed providers
335         for (FileSystemProvider provider : FileSystemProvider.installedProviders()) {
336             if (scheme.equalsIgnoreCase(provider.getScheme())) {
337                 try {
338                     return provider.newFileSystem(uri, env);
339                 } catch (UnsupportedOperationException uoe) {
340                 }
341             }
342         }
343 
344         // if not found, use service-provider loading facility
345         if (loader != null) {
346             ServiceLoader&lt;FileSystemProvider&gt; sl = ServiceLoader
347                 .load(FileSystemProvider.class, loader);
348             for (FileSystemProvider provider : sl) {
349                 if (scheme.equalsIgnoreCase(provider.getScheme())) {
350                     try {
351                         return provider.newFileSystem(uri, env);
352                     } catch (UnsupportedOperationException uoe) {
353                     }
354                 }
355             }
356         }
357 
358         throw new ProviderNotFoundException(&quot;Provider \&quot;&quot; + scheme + &quot;\&quot; not found&quot;);
359     }
360 
361     /**
362      * Constructs a new {@code FileSystem} to access the contents of a file as a
363      * file system.
364      *
365      * &lt;p&gt; This method makes use of specialized providers that create pseudo file
366      * systems where the contents of one or more files is treated as a file
367      * system.
368      *
369      * &lt;p&gt; This method first attempts to locate an installed provider in exactly
370      * the same manner as the {@link #newFileSystem(Path, Map, ClassLoader)
371      * newFileSystem(Path, Map, ClassLoader)} method with an empty map. If none
372      * of the installed providers return a {@code FileSystem} then an attempt is
373      * made to locate the provider using the given class loader. If a provider
374      * returns a file system then the lookup terminates and the file system is
375      * returned.
376      *
377      * @param   path
378      *          the path to the file
379      * @param   loader
380      *          the class loader to locate the provider or {@code null} to only
381      *          attempt to locate an installed provider
382      *
383      * @return  a new file system
384      *
385      * @throws  ProviderNotFoundException
386      *          if a provider supporting this file type cannot be located
387      * @throws  ServiceConfigurationError
388      *          when an error occurs while loading a service provider
389      * @throws  IOException
390      *          if an I/O error occurs
391      * @throws  SecurityException
392      *          if a security manager is installed and it denies an unspecified
393      *          permission
394      */
395     public static FileSystem newFileSystem(Path path,
396                                            ClassLoader loader)
397         throws IOException
398     {
399         return newFileSystem(path, Map.of(), loader);
400     }
401 
402     /**
403      * Constructs a new {@code FileSystem} to access the contents of a file as a
404      * file system.
405      *
406      * &lt;p&gt; This method makes use of specialized providers that create pseudo file
407      * systems where the contents of one or more files is treated as a file
408      * system.
409      *
410      * &lt;p&gt; This method first attempts to locate an installed provider in exactly
411      * the same manner as the {@link #newFileSystem(Path,Map,ClassLoader)
412      * newFileSystem(Path, Map, ClassLoader)} method. If found, the provider&#39;s
413      * {@link FileSystemProvider#newFileSystem(Path, Map) newFileSystem(Path, Map)}
414      * method is invoked to construct the new file system.
415      *
416      * @param   path
417      *          the path to the file
418      * @param   env
419      *          a map of provider specific properties to configure the file system;
420      *          may be empty
421      *
422      * @return  a new file system
423      *
424      * @throws  ProviderNotFoundException
425      *          if a provider supporting this file type cannot be located
426      * @throws  ServiceConfigurationError
427      *          when an error occurs while loading a service provider
428      * @throws  IOException
429      *          if an I/O error occurs
430      * @throws  SecurityException
431      *          if a security manager is installed and it denies an unspecified
432      *          permission
433      *
434      * @since 13
435      */
436     public static FileSystem newFileSystem(Path path, Map&lt;String,?&gt; env)
437         throws IOException
438     {
439         return newFileSystem(path, env, null);
440     }
441 
442     /**
443      * Constructs a new {@code FileSystem} to access the contents of a file as a
444      * file system.
445      *
446      * &lt;p&gt; This method makes use of specialized providers that create pseudo file
447      * systems where the contents of one or more files is treated as a file
448      * system.
449      *
450      * &lt;p&gt; This method first attempts to locate an installed provider in exactly
451      * the same manner as the {@link #newFileSystem(Path,Map,ClassLoader)
452      * newFileSystem(Path, Map, ClassLoader)} method. If found, the provider&#39;s
453      * {@link FileSystemProvider#newFileSystem(Path, Map) newFileSystem(Path, Map)}
454      * method is invoked with an empty map to construct the new file system.
455      *
456      * @param   path
457      *          the path to the file
458      *
459      * @return  a new file system
460      *
461      * @throws  ProviderNotFoundException
462      *          if a provider supporting this file type cannot be located
463      * @throws  ServiceConfigurationError
464      *          when an error occurs while loading a service provider
465      * @throws  IOException
466      *          if an I/O error occurs
467      * @throws  SecurityException
468      *          if a security manager is installed and it denies an unspecified
469      *          permission
470      *
471      * @since 13
472      */
473     public static FileSystem newFileSystem(Path path) throws IOException {
474         return newFileSystem(path, Map.of(), null);
475     }
476 
477     /**
478      * Constructs a new {@code FileSystem} to access the contents of a file as a
479      * file system.
480      *
481      * &lt;p&gt; This method makes use of specialized providers that create pseudo file
482      * systems where the contents of one or more files is treated as a file
483      * system.
484      *
485      * &lt;p&gt; This method iterates over the {@link FileSystemProvider#installedProviders()
486      * installed} providers. It invokes, in turn, each provider&#39;s {@link
487      * FileSystemProvider#newFileSystem(Path,Map) newFileSystem(Path,Map)}
488      * method. If a provider returns a file system then the iteration
489      * terminates and the file system is returned.
490      * If none of the installed providers return a {@code FileSystem} then
491      * an attempt is made to locate the provider using the given class loader.
492      * If a provider returns a file
493      * system, then the lookup terminates and the file system is returned.
494      *
495      * @param   path
496      *          the path to the file
497      * @param   env
498      *          a map of provider specific properties to configure the file system;
499      *          may be empty
500      * @param   loader
501      *          the class loader to locate the provider or {@code null} to only
502      *          attempt to locate an installed provider
503      *
504      * @return  a new file system
505      *
506      * @throws  ProviderNotFoundException
507      *          if a provider supporting this file type cannot be located
508      * @throws  ServiceConfigurationError
509      *          when an error occurs while loading a service provider
510      * @throws  IOException
511      *          if an I/O error occurs
512      * @throws  SecurityException
513      *          if a security manager is installed and it denies an unspecified
514      *          permission
515      *
516      * @since 13
517      */
518     public static FileSystem newFileSystem(Path path, Map&lt;String,?&gt; env,
519                                            ClassLoader loader)
520         throws IOException
521     {
522         if (path == null)
523             throw new NullPointerException();
524         // check installed providers
525         for (FileSystemProvider provider: FileSystemProvider.installedProviders()) {
526             try {
527                 return provider.newFileSystem(path, env);
528             } catch (UnsupportedOperationException uoe) {
529             }
530         }
531 
532         // if not found, use service-provider loading facility
533         if (loader != null) {
534             ServiceLoader&lt;FileSystemProvider&gt; sl = ServiceLoader
535                 .load(FileSystemProvider.class, loader);
536             for (FileSystemProvider provider: sl) {
537                 try {
538                     return provider.newFileSystem(path, env);
539                 } catch (UnsupportedOperationException uoe) {
540                 }
541             }
542         }
543 
544         throw new ProviderNotFoundException(&quot;Provider not found&quot;);
545     }
546 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
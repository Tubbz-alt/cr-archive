<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/Scanner.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="List.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jar/JarFile.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Scanner.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 411         Pattern bp = boolPattern;
 412         if (bp == null)
 413             boolPattern = bp = Pattern.compile(BOOLEAN_PATTERN,
 414                                           Pattern.CASE_INSENSITIVE);
 415         return bp;
 416     }
 417 
 418     /**
 419      * Fields and methods to match bytes, shorts, ints, and longs
 420      */
 421     private Pattern integerPattern;
 422     private String digits = &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;;
 423     private String non0Digit = &quot;[\\p{javaDigit}&amp;&amp;[^0]]&quot;;
 424     private int SIMPLE_GROUP_INDEX = 5;
 425     private String buildIntegerPatternString() {
 426         String radixDigits = digits.substring(0, radix);
 427         // \\p{javaDigit} is not guaranteed to be appropriate
 428         // here but what can we do? The final authority will be
 429         // whatever parse method is invoked, so ultimately the
 430         // Scanner will do the right thing
<span class="line-modified"> 431         String digit = &quot;((?i)[&quot;+radixDigits+&quot;]|\\p{javaDigit})&quot;;</span>
 432         String groupedNumeral = &quot;(&quot;+non0Digit+digit+&quot;?&quot;+digit+&quot;?(&quot;+
 433                                 groupSeparator+digit+digit+digit+&quot;)+)&quot;;
 434         // digit++ is the possessive form which is necessary for reducing
 435         // backtracking that would otherwise cause unacceptable performance
 436         String numeral = &quot;((&quot;+ digit+&quot;++)|&quot;+groupedNumeral+&quot;)&quot;;
 437         String javaStyleInteger = &quot;([-+]?(&quot; + numeral + &quot;))&quot;;
 438         String negativeInteger = negativePrefix + numeral + negativeSuffix;
 439         String positiveInteger = positivePrefix + numeral + positiveSuffix;
 440         return &quot;(&quot;+ javaStyleInteger + &quot;)|(&quot; +
 441             positiveInteger + &quot;)|(&quot; +
 442             negativeInteger + &quot;)&quot;;
 443     }
 444     private Pattern integerPattern() {
 445         if (integerPattern == null) {
 446             integerPattern = patternCache.forName(buildIntegerPatternString());
 447         }
 448         return integerPattern;
 449     }
 450 
 451     /**
</pre>
<hr />
<pre>
 461         Pattern sp = separatorPattern;
 462         if (sp == null)
 463             separatorPattern = sp = Pattern.compile(LINE_SEPARATOR_PATTERN);
 464         return sp;
 465     }
 466 
 467     private static Pattern linePattern() {
 468         Pattern lp = linePattern;
 469         if (lp == null)
 470             linePattern = lp = Pattern.compile(LINE_PATTERN);
 471         return lp;
 472     }
 473 
 474     /**
 475      * Fields and methods to match floats and doubles
 476      */
 477     private Pattern floatPattern;
 478     private Pattern decimalPattern;
 479     private void buildFloatAndDecimalPattern() {
 480         // \\p{javaDigit} may not be perfect, see above
<span class="line-modified"> 481         String digit = &quot;([0-9]|(\\p{javaDigit}))&quot;;</span>
 482         String exponent = &quot;([eE][+-]?&quot;+digit+&quot;+)?&quot;;
 483         String groupedNumeral = &quot;(&quot;+non0Digit+digit+&quot;?&quot;+digit+&quot;?(&quot;+
 484                                 groupSeparator+digit+digit+digit+&quot;)+)&quot;;
 485         // Once again digit++ is used for performance, as above
 486         String numeral = &quot;((&quot;+digit+&quot;++)|&quot;+groupedNumeral+&quot;)&quot;;
 487         String decimalNumeral = &quot;(&quot;+numeral+&quot;|&quot;+numeral +
 488             decimalSeparator + digit + &quot;*+|&quot;+ decimalSeparator +
 489             digit + &quot;++)&quot;;
 490         String nonNumber = &quot;(NaN|&quot;+nanString+&quot;|Infinity|&quot;+
 491                                infinityString+&quot;)&quot;;
 492         String positiveFloat = &quot;(&quot; + positivePrefix + decimalNumeral +
 493                             positiveSuffix + exponent + &quot;)&quot;;
 494         String negativeFloat = &quot;(&quot; + negativePrefix + decimalNumeral +
 495                             negativeSuffix + exponent + &quot;)&quot;;
 496         String decimal = &quot;(([-+]?&quot; + decimalNumeral + exponent + &quot;)|&quot;+
 497             positiveFloat + &quot;|&quot; + negativeFloat + &quot;)&quot;;
 498         String hexFloat =
 499             &quot;[-+]?0[xX][0-9a-fA-F]*\\.[0-9a-fA-F]+([pP][-+]?[0-9]+)?&quot;;
 500         String positiveNonNumber = &quot;(&quot; + positivePrefix + nonNumber +
 501                             positiveSuffix + &quot;)&quot;;
</pre>
<hr />
<pre>
1272         if (nf instanceof DecimalFormat) {
1273              df = (DecimalFormat) nf;
1274         } else {
1275 
1276             // In case where NumberFormat.getNumberInstance() returns
1277             // other instance (non DecimalFormat) based on the provider
1278             // used and java.text.spi.NumberFormatProvider implementations,
1279             // DecimalFormat constructor is used to obtain the instance
1280             LocaleProviderAdapter adapter = LocaleProviderAdapter
1281                     .getAdapter(NumberFormatProvider.class, locale);
1282             if (!(adapter instanceof ResourceBundleBasedAdapter)) {
1283                 adapter = LocaleProviderAdapter.getResourceBundleBased();
1284             }
1285             String[] all = adapter.getLocaleResources(locale)
1286                     .getNumberPatterns();
1287             df = new DecimalFormat(all[0], dfs);
1288         }
1289 
1290         // These must be literalized to avoid collision with regex
1291         // metacharacters such as dot or parenthesis
<span class="line-modified">1292         groupSeparator =   &quot;\\&quot; + dfs.getGroupingSeparator();</span>
<span class="line-modified">1293         decimalSeparator = &quot;\\&quot; + dfs.getDecimalSeparator();</span>
1294 
1295         // Quoting the nonzero length locale-specific things
1296         // to avoid potential conflict with metacharacters
<span class="line-modified">1297         nanString = &quot;\\Q&quot; + dfs.getNaN() + &quot;\\E&quot;;</span>
<span class="line-modified">1298         infinityString = &quot;\\Q&quot; + dfs.getInfinity() + &quot;\\E&quot;;</span>
1299         positivePrefix = df.getPositivePrefix();
1300         if (!positivePrefix.isEmpty())
<span class="line-modified">1301             positivePrefix = &quot;\\Q&quot; + positivePrefix + &quot;\\E&quot;;</span>
1302         negativePrefix = df.getNegativePrefix();
1303         if (!negativePrefix.isEmpty())
<span class="line-modified">1304             negativePrefix = &quot;\\Q&quot; + negativePrefix + &quot;\\E&quot;;</span>
1305         positiveSuffix = df.getPositiveSuffix();
1306         if (!positiveSuffix.isEmpty())
<span class="line-modified">1307             positiveSuffix = &quot;\\Q&quot; + positiveSuffix + &quot;\\E&quot;;</span>
1308         negativeSuffix = df.getNegativeSuffix();
1309         if (!negativeSuffix.isEmpty())
<span class="line-modified">1310             negativeSuffix = &quot;\\Q&quot; + negativeSuffix + &quot;\\E&quot;;</span>
1311 
1312         // Force rebuilding and recompilation of locale dependent
1313         // primitive patterns
1314         integerPattern = null;
1315         floatPattern = null;
1316 
1317         return this;
1318     }
1319 
1320     /**
1321      * Returns this scanner&#39;s default radix.
1322      *
1323      * &lt;p&gt;A scanner&#39;s radix affects elements of its default
1324      * number matching regular expressions; see
1325      * &lt;a href= &quot;#localized-numbers&quot;&gt;localized numbers&lt;/a&gt; above.
1326      *
1327      * @return the default radix of this scanner
1328      */
1329     public int radix() {
1330         return this.defaultRadix;
</pre>
</td>
<td>
<hr />
<pre>
 411         Pattern bp = boolPattern;
 412         if (bp == null)
 413             boolPattern = bp = Pattern.compile(BOOLEAN_PATTERN,
 414                                           Pattern.CASE_INSENSITIVE);
 415         return bp;
 416     }
 417 
 418     /**
 419      * Fields and methods to match bytes, shorts, ints, and longs
 420      */
 421     private Pattern integerPattern;
 422     private String digits = &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;;
 423     private String non0Digit = &quot;[\\p{javaDigit}&amp;&amp;[^0]]&quot;;
 424     private int SIMPLE_GROUP_INDEX = 5;
 425     private String buildIntegerPatternString() {
 426         String radixDigits = digits.substring(0, radix);
 427         // \\p{javaDigit} is not guaranteed to be appropriate
 428         // here but what can we do? The final authority will be
 429         // whatever parse method is invoked, so ultimately the
 430         // Scanner will do the right thing
<span class="line-modified"> 431         String digit = &quot;((?i)[&quot;+radixDigits+&quot;\\p{javaDigit}])&quot;;</span>
 432         String groupedNumeral = &quot;(&quot;+non0Digit+digit+&quot;?&quot;+digit+&quot;?(&quot;+
 433                                 groupSeparator+digit+digit+digit+&quot;)+)&quot;;
 434         // digit++ is the possessive form which is necessary for reducing
 435         // backtracking that would otherwise cause unacceptable performance
 436         String numeral = &quot;((&quot;+ digit+&quot;++)|&quot;+groupedNumeral+&quot;)&quot;;
 437         String javaStyleInteger = &quot;([-+]?(&quot; + numeral + &quot;))&quot;;
 438         String negativeInteger = negativePrefix + numeral + negativeSuffix;
 439         String positiveInteger = positivePrefix + numeral + positiveSuffix;
 440         return &quot;(&quot;+ javaStyleInteger + &quot;)|(&quot; +
 441             positiveInteger + &quot;)|(&quot; +
 442             negativeInteger + &quot;)&quot;;
 443     }
 444     private Pattern integerPattern() {
 445         if (integerPattern == null) {
 446             integerPattern = patternCache.forName(buildIntegerPatternString());
 447         }
 448         return integerPattern;
 449     }
 450 
 451     /**
</pre>
<hr />
<pre>
 461         Pattern sp = separatorPattern;
 462         if (sp == null)
 463             separatorPattern = sp = Pattern.compile(LINE_SEPARATOR_PATTERN);
 464         return sp;
 465     }
 466 
 467     private static Pattern linePattern() {
 468         Pattern lp = linePattern;
 469         if (lp == null)
 470             linePattern = lp = Pattern.compile(LINE_PATTERN);
 471         return lp;
 472     }
 473 
 474     /**
 475      * Fields and methods to match floats and doubles
 476      */
 477     private Pattern floatPattern;
 478     private Pattern decimalPattern;
 479     private void buildFloatAndDecimalPattern() {
 480         // \\p{javaDigit} may not be perfect, see above
<span class="line-modified"> 481         String digit = &quot;(([0-9\\p{javaDigit}]))&quot;;</span>
 482         String exponent = &quot;([eE][+-]?&quot;+digit+&quot;+)?&quot;;
 483         String groupedNumeral = &quot;(&quot;+non0Digit+digit+&quot;?&quot;+digit+&quot;?(&quot;+
 484                                 groupSeparator+digit+digit+digit+&quot;)+)&quot;;
 485         // Once again digit++ is used for performance, as above
 486         String numeral = &quot;((&quot;+digit+&quot;++)|&quot;+groupedNumeral+&quot;)&quot;;
 487         String decimalNumeral = &quot;(&quot;+numeral+&quot;|&quot;+numeral +
 488             decimalSeparator + digit + &quot;*+|&quot;+ decimalSeparator +
 489             digit + &quot;++)&quot;;
 490         String nonNumber = &quot;(NaN|&quot;+nanString+&quot;|Infinity|&quot;+
 491                                infinityString+&quot;)&quot;;
 492         String positiveFloat = &quot;(&quot; + positivePrefix + decimalNumeral +
 493                             positiveSuffix + exponent + &quot;)&quot;;
 494         String negativeFloat = &quot;(&quot; + negativePrefix + decimalNumeral +
 495                             negativeSuffix + exponent + &quot;)&quot;;
 496         String decimal = &quot;(([-+]?&quot; + decimalNumeral + exponent + &quot;)|&quot;+
 497             positiveFloat + &quot;|&quot; + negativeFloat + &quot;)&quot;;
 498         String hexFloat =
 499             &quot;[-+]?0[xX][0-9a-fA-F]*\\.[0-9a-fA-F]+([pP][-+]?[0-9]+)?&quot;;
 500         String positiveNonNumber = &quot;(&quot; + positivePrefix + nonNumber +
 501                             positiveSuffix + &quot;)&quot;;
</pre>
<hr />
<pre>
1272         if (nf instanceof DecimalFormat) {
1273              df = (DecimalFormat) nf;
1274         } else {
1275 
1276             // In case where NumberFormat.getNumberInstance() returns
1277             // other instance (non DecimalFormat) based on the provider
1278             // used and java.text.spi.NumberFormatProvider implementations,
1279             // DecimalFormat constructor is used to obtain the instance
1280             LocaleProviderAdapter adapter = LocaleProviderAdapter
1281                     .getAdapter(NumberFormatProvider.class, locale);
1282             if (!(adapter instanceof ResourceBundleBasedAdapter)) {
1283                 adapter = LocaleProviderAdapter.getResourceBundleBased();
1284             }
1285             String[] all = adapter.getLocaleResources(locale)
1286                     .getNumberPatterns();
1287             df = new DecimalFormat(all[0], dfs);
1288         }
1289 
1290         // These must be literalized to avoid collision with regex
1291         // metacharacters such as dot or parenthesis
<span class="line-modified">1292         groupSeparator =   &quot;\\x{&quot; + Integer.toHexString(dfs.getGroupingSeparator()) + &quot;}&quot;;</span>
<span class="line-modified">1293         decimalSeparator = &quot;\\x{&quot; + Integer.toHexString(dfs.getDecimalSeparator()) + &quot;}&quot;;</span>
1294 
1295         // Quoting the nonzero length locale-specific things
1296         // to avoid potential conflict with metacharacters
<span class="line-modified">1297         nanString = Pattern.quote(dfs.getNaN());</span>
<span class="line-modified">1298         infinityString = Pattern.quote(dfs.getInfinity());</span>
1299         positivePrefix = df.getPositivePrefix();
1300         if (!positivePrefix.isEmpty())
<span class="line-modified">1301             positivePrefix = Pattern.quote(positivePrefix);</span>
1302         negativePrefix = df.getNegativePrefix();
1303         if (!negativePrefix.isEmpty())
<span class="line-modified">1304             negativePrefix = Pattern.quote(negativePrefix);</span>
1305         positiveSuffix = df.getPositiveSuffix();
1306         if (!positiveSuffix.isEmpty())
<span class="line-modified">1307             positiveSuffix = Pattern.quote(positiveSuffix);</span>
1308         negativeSuffix = df.getNegativeSuffix();
1309         if (!negativeSuffix.isEmpty())
<span class="line-modified">1310             negativeSuffix = Pattern.quote(negativeSuffix);</span>
1311 
1312         // Force rebuilding and recompilation of locale dependent
1313         // primitive patterns
1314         integerPattern = null;
1315         floatPattern = null;
1316 
1317         return this;
1318     }
1319 
1320     /**
1321      * Returns this scanner&#39;s default radix.
1322      *
1323      * &lt;p&gt;A scanner&#39;s radix affects elements of its default
1324      * number matching regular expressions; see
1325      * &lt;a href= &quot;#localized-numbers&quot;&gt;localized numbers&lt;/a&gt; above.
1326      *
1327      * @return the default radix of this scanner
1328      */
1329     public int radix() {
1330         return this.defaultRadix;
</pre>
</td>
</tr>
</table>
<center><a href="List.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jar/JarFile.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
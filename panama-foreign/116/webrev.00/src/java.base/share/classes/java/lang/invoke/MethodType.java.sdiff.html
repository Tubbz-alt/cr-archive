<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodType.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../VersionProps.java.template.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../math/MutableBigInteger.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodType.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  99  * all classes named in the descriptor must be accessible, and will be loaded.
 100  * (But the classes need not be initialized, as is the case with a {@code CONSTANT_Class}.)
 101  * This loading may occur at any time before the {@code MethodType} object is first derived.
 102  * @author John Rose, JSR 292 EG
 103  * @since 1.7
 104  */
 105 public final
 106 class MethodType
 107         implements Constable,
 108                    TypeDescriptor.OfMethod&lt;Class&lt;?&gt;, MethodType&gt;,
 109                    java.io.Serializable {
 110     @java.io.Serial
 111     private static final long serialVersionUID = 292L;  // {rtype, {ptype...}}
 112 
 113     // The rtype and ptypes fields define the structural identity of the method type:
 114     private final @Stable Class&lt;?&gt;   rtype;
 115     private final @Stable Class&lt;?&gt;[] ptypes;
 116 
 117     // The remaining fields are caches of various sorts:
 118     private @Stable MethodTypeForm form; // erased form, plus cached data about primitives
<span class="line-modified"> 119     private @Stable MethodType wrapAlt;  // alternative wrapped/unwrapped version</span>

 120     private @Stable Invokers invokers;   // cache of handy higher-order adapters
 121     private @Stable String methodDescriptor;  // cache for toMethodDescriptorString
 122 
 123     /**
 124      * Constructor that performs no copying or validation.
 125      * Should only be called from the factory method makeImpl
 126      */
 127     private MethodType(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {
 128         this.rtype = rtype;
 129         this.ptypes = ptypes;
 130     }
 131 
 132     /*trusted*/ MethodTypeForm form() { return form; }
 133     /*trusted*/ Class&lt;?&gt; rtype() { return rtype; }
 134     /*trusted*/ Class&lt;?&gt;[] ptypes() { return ptypes; }
 135 
 136     void setForm(MethodTypeForm f) { form = f; }
 137 
 138     /** This number, mandated by the JVM spec as 255,
 139      *  is the maximum number of &lt;em&gt;slots&lt;/em&gt;
</pre>
<hr />
<pre>
 694      * @return a version of the original type with all primitive types replaced
 695      */
 696     public MethodType wrap() {
 697         return hasPrimitives() ? wrapWithPrims(this) : this;
 698     }
 699 
 700     /**
 701      * Converts all wrapper types to their corresponding primitive types.
 702      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 703      * All primitive types (including {@code void}) will remain unchanged.
 704      * A return type of {@code java.lang.Void} is changed to {@code void}.
 705      * @return a version of the original type with all wrapper types replaced
 706      */
 707     public MethodType unwrap() {
 708         MethodType noprims = !hasPrimitives() ? this : wrapWithPrims(this);
 709         return unwrapWithNoPrims(noprims);
 710     }
 711 
 712     private static MethodType wrapWithPrims(MethodType pt) {
 713         assert(pt.hasPrimitives());
<span class="line-modified"> 714         MethodType wt = pt.wrapAlt;</span>
 715         if (wt == null) {
 716             // fill in lazily
 717             wt = MethodTypeForm.canonicalize(pt, MethodTypeForm.WRAP, MethodTypeForm.WRAP);
 718             assert(wt != null);
 719             pt.wrapAlt = wt;
 720         }
 721         return wt;
 722     }
 723 
 724     private static MethodType unwrapWithNoPrims(MethodType wt) {
 725         assert(!wt.hasPrimitives());
<span class="line-modified"> 726         MethodType uwt = wt.wrapAlt;</span>
 727         if (uwt == null) {
 728             // fill in lazily
 729             uwt = MethodTypeForm.canonicalize(wt, MethodTypeForm.UNWRAP, MethodTypeForm.UNWRAP);
 730             if (uwt == null)
 731                 uwt = wt;    // type has no wrappers or prims at all
 732             wt.wrapAlt = uwt;
 733         }
 734         return uwt;
 735     }
 736 
 737     /**
 738      * Returns the parameter type at the specified index, within this method type.
 739      * @param num the index (zero-based) of the desired parameter type
 740      * @return the selected parameter type
 741      * @throws IndexOutOfBoundsException if {@code num} is not a valid index into {@code parameterArray()}
 742      */
 743     public Class&lt;?&gt; parameterType(int num) {
 744         return ptypes[num];
 745     }
 746     /**
</pre>
<hr />
<pre>
1231         s.defaultWriteObject();  // requires serialPersistentFields to be an empty array
1232         s.writeObject(returnType());
1233         s.writeObject(parameterArray());
1234     }
1235 
1236     /**
1237      * Reconstitute the {@code MethodType} instance from a stream (that is,
1238      * deserialize it).
1239      * This instance is a scratch object with bogus final fields.
1240      * It provides the parameters to the factory method called by
1241      * {@link #readResolve readResolve}.
1242      * After that call it is discarded.
1243      * @param s the stream to read the object from
1244      * @throws java.io.IOException if there is a problem reading the object
1245      * @throws ClassNotFoundException if one of the component classes cannot be resolved
1246      * @see #readResolve
1247      * @see #writeObject
1248      */
1249     @java.io.Serial
1250     private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
<span class="line-modified">1251         // Assign temporary defaults in case this object escapes</span>
<span class="line-modified">1252         MethodType_init(void.class, NO_PTYPES);</span>

1253 
1254         s.defaultReadObject();  // requires serialPersistentFields to be an empty array
1255 
1256         Class&lt;?&gt;   returnType     = (Class&lt;?&gt;)   s.readObject();
1257         Class&lt;?&gt;[] parameterArray = (Class&lt;?&gt;[]) s.readObject();
<span class="line-removed">1258         parameterArray = parameterArray.clone();  // make sure it is unshared</span>
1259 
<span class="line-modified">1260         // Assign deserialized values</span>
<span class="line-modified">1261         MethodType_init(returnType, parameterArray);</span>
<span class="line-modified">1262     }</span>
<span class="line-removed">1263 </span>
<span class="line-removed">1264     // Initialization of state for deserialization only</span>
<span class="line-removed">1265     private void MethodType_init(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {</span>
<span class="line-removed">1266         // In order to communicate these values to readResolve, we must</span>
<span class="line-removed">1267         // store them into the implementation-specific final fields.</span>
<span class="line-removed">1268         checkRtype(rtype);</span>
<span class="line-removed">1269         checkPtypes(ptypes);</span>
<span class="line-removed">1270         UNSAFE.putReference(this, OffsetHolder.rtypeOffset, rtype);</span>
<span class="line-removed">1271         UNSAFE.putReference(this, OffsetHolder.ptypesOffset, ptypes);</span>
1272     }
1273 
1274     // Support for resetting final fields while deserializing. Implement Holder
1275     // pattern to make the rarely needed offset calculation lazy.
1276     private static class OffsetHolder {
1277         static final long rtypeOffset
1278                 = UNSAFE.objectFieldOffset(MethodType.class, &quot;rtype&quot;);
1279 
1280         static final long ptypesOffset
1281                 = UNSAFE.objectFieldOffset(MethodType.class, &quot;ptypes&quot;);
1282     }
1283 
1284     /**
1285      * Resolves and initializes a {@code MethodType} object
1286      * after serialization.
1287      * @return the fully initialized {@code MethodType} object
1288      */
1289     @java.io.Serial
1290     private Object readResolve() {
1291         // Do not use a trusted path for deserialization:
1292         //    return makeImpl(rtype, ptypes, true);
1293         // Verify all operands, and make sure ptypes is unshared:
<span class="line-modified">1294         try {</span>
<span class="line-modified">1295             return methodType(rtype, ptypes);</span>
<span class="line-modified">1296         } finally {</span>
<span class="line-modified">1297             // Re-assign defaults in case this object escapes</span>
<span class="line-removed">1298             MethodType_init(void.class, NO_PTYPES);</span>
<span class="line-removed">1299         }</span>
1300     }
1301 
1302     /**
1303      * Simple implementation of weak concurrent intern set.
1304      *
1305      * @param &lt;T&gt; interned type
1306      */
1307     private static class ConcurrentWeakInternSet&lt;T&gt; {
1308 
1309         private final ConcurrentMap&lt;WeakEntry&lt;T&gt;, WeakEntry&lt;T&gt;&gt; map;
1310         private final ReferenceQueue&lt;T&gt; stale;
1311 
1312         public ConcurrentWeakInternSet() {
1313             this.map = new ConcurrentHashMap&lt;&gt;(512);
1314             this.stale = new ReferenceQueue&lt;&gt;();
1315         }
1316 
1317         /**
1318          * Get the existing interned element.
1319          * This method returns null if no element is interned.
</pre>
</td>
<td>
<hr />
<pre>
  99  * all classes named in the descriptor must be accessible, and will be loaded.
 100  * (But the classes need not be initialized, as is the case with a {@code CONSTANT_Class}.)
 101  * This loading may occur at any time before the {@code MethodType} object is first derived.
 102  * @author John Rose, JSR 292 EG
 103  * @since 1.7
 104  */
 105 public final
 106 class MethodType
 107         implements Constable,
 108                    TypeDescriptor.OfMethod&lt;Class&lt;?&gt;, MethodType&gt;,
 109                    java.io.Serializable {
 110     @java.io.Serial
 111     private static final long serialVersionUID = 292L;  // {rtype, {ptype...}}
 112 
 113     // The rtype and ptypes fields define the structural identity of the method type:
 114     private final @Stable Class&lt;?&gt;   rtype;
 115     private final @Stable Class&lt;?&gt;[] ptypes;
 116 
 117     // The remaining fields are caches of various sorts:
 118     private @Stable MethodTypeForm form; // erased form, plus cached data about primitives
<span class="line-modified"> 119     private @Stable Object wrapAlt;  // alternative wrapped/unwrapped version and</span>
<span class="line-added"> 120                                      // private communication for readObject and readResolve</span>
 121     private @Stable Invokers invokers;   // cache of handy higher-order adapters
 122     private @Stable String methodDescriptor;  // cache for toMethodDescriptorString
 123 
 124     /**
 125      * Constructor that performs no copying or validation.
 126      * Should only be called from the factory method makeImpl
 127      */
 128     private MethodType(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {
 129         this.rtype = rtype;
 130         this.ptypes = ptypes;
 131     }
 132 
 133     /*trusted*/ MethodTypeForm form() { return form; }
 134     /*trusted*/ Class&lt;?&gt; rtype() { return rtype; }
 135     /*trusted*/ Class&lt;?&gt;[] ptypes() { return ptypes; }
 136 
 137     void setForm(MethodTypeForm f) { form = f; }
 138 
 139     /** This number, mandated by the JVM spec as 255,
 140      *  is the maximum number of &lt;em&gt;slots&lt;/em&gt;
</pre>
<hr />
<pre>
 695      * @return a version of the original type with all primitive types replaced
 696      */
 697     public MethodType wrap() {
 698         return hasPrimitives() ? wrapWithPrims(this) : this;
 699     }
 700 
 701     /**
 702      * Converts all wrapper types to their corresponding primitive types.
 703      * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 704      * All primitive types (including {@code void}) will remain unchanged.
 705      * A return type of {@code java.lang.Void} is changed to {@code void}.
 706      * @return a version of the original type with all wrapper types replaced
 707      */
 708     public MethodType unwrap() {
 709         MethodType noprims = !hasPrimitives() ? this : wrapWithPrims(this);
 710         return unwrapWithNoPrims(noprims);
 711     }
 712 
 713     private static MethodType wrapWithPrims(MethodType pt) {
 714         assert(pt.hasPrimitives());
<span class="line-modified"> 715         MethodType wt = (MethodType)pt.wrapAlt;</span>
 716         if (wt == null) {
 717             // fill in lazily
 718             wt = MethodTypeForm.canonicalize(pt, MethodTypeForm.WRAP, MethodTypeForm.WRAP);
 719             assert(wt != null);
 720             pt.wrapAlt = wt;
 721         }
 722         return wt;
 723     }
 724 
 725     private static MethodType unwrapWithNoPrims(MethodType wt) {
 726         assert(!wt.hasPrimitives());
<span class="line-modified"> 727         MethodType uwt = (MethodType)wt.wrapAlt;</span>
 728         if (uwt == null) {
 729             // fill in lazily
 730             uwt = MethodTypeForm.canonicalize(wt, MethodTypeForm.UNWRAP, MethodTypeForm.UNWRAP);
 731             if (uwt == null)
 732                 uwt = wt;    // type has no wrappers or prims at all
 733             wt.wrapAlt = uwt;
 734         }
 735         return uwt;
 736     }
 737 
 738     /**
 739      * Returns the parameter type at the specified index, within this method type.
 740      * @param num the index (zero-based) of the desired parameter type
 741      * @return the selected parameter type
 742      * @throws IndexOutOfBoundsException if {@code num} is not a valid index into {@code parameterArray()}
 743      */
 744     public Class&lt;?&gt; parameterType(int num) {
 745         return ptypes[num];
 746     }
 747     /**
</pre>
<hr />
<pre>
1232         s.defaultWriteObject();  // requires serialPersistentFields to be an empty array
1233         s.writeObject(returnType());
1234         s.writeObject(parameterArray());
1235     }
1236 
1237     /**
1238      * Reconstitute the {@code MethodType} instance from a stream (that is,
1239      * deserialize it).
1240      * This instance is a scratch object with bogus final fields.
1241      * It provides the parameters to the factory method called by
1242      * {@link #readResolve readResolve}.
1243      * After that call it is discarded.
1244      * @param s the stream to read the object from
1245      * @throws java.io.IOException if there is a problem reading the object
1246      * @throws ClassNotFoundException if one of the component classes cannot be resolved
1247      * @see #readResolve
1248      * @see #writeObject
1249      */
1250     @java.io.Serial
1251     private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
<span class="line-modified">1252         // Assign defaults in case this object escapes</span>
<span class="line-modified">1253         UNSAFE.putReference(this, OffsetHolder.rtypeOffset, void.class);</span>
<span class="line-added">1254         UNSAFE.putReference(this, OffsetHolder.ptypesOffset, NO_PTYPES);</span>
1255 
1256         s.defaultReadObject();  // requires serialPersistentFields to be an empty array
1257 
1258         Class&lt;?&gt;   returnType     = (Class&lt;?&gt;)   s.readObject();
1259         Class&lt;?&gt;[] parameterArray = (Class&lt;?&gt;[]) s.readObject();

1260 
<span class="line-modified">1261         // Verify all operands, and make sure ptypes is unshared</span>
<span class="line-modified">1262         // Cache the new MethodType for readResolve</span>
<span class="line-modified">1263         wrapAlt = new MethodType[]{MethodType.methodType(returnType, parameterArray)};</span>









1264     }
1265 
1266     // Support for resetting final fields while deserializing. Implement Holder
1267     // pattern to make the rarely needed offset calculation lazy.
1268     private static class OffsetHolder {
1269         static final long rtypeOffset
1270                 = UNSAFE.objectFieldOffset(MethodType.class, &quot;rtype&quot;);
1271 
1272         static final long ptypesOffset
1273                 = UNSAFE.objectFieldOffset(MethodType.class, &quot;ptypes&quot;);
1274     }
1275 
1276     /**
1277      * Resolves and initializes a {@code MethodType} object
1278      * after serialization.
1279      * @return the fully initialized {@code MethodType} object
1280      */
1281     @java.io.Serial
1282     private Object readResolve() {
1283         // Do not use a trusted path for deserialization:
1284         //    return makeImpl(rtype, ptypes, true);
1285         // Verify all operands, and make sure ptypes is unshared:
<span class="line-modified">1286         // Return a new validated MethodType for the rtype and ptypes passed from readObject.</span>
<span class="line-modified">1287         MethodType mt = ((MethodType[])wrapAlt)[0];</span>
<span class="line-modified">1288         wrapAlt = null;</span>
<span class="line-modified">1289         return mt;</span>


1290     }
1291 
1292     /**
1293      * Simple implementation of weak concurrent intern set.
1294      *
1295      * @param &lt;T&gt; interned type
1296      */
1297     private static class ConcurrentWeakInternSet&lt;T&gt; {
1298 
1299         private final ConcurrentMap&lt;WeakEntry&lt;T&gt;, WeakEntry&lt;T&gt;&gt; map;
1300         private final ReferenceQueue&lt;T&gt; stale;
1301 
1302         public ConcurrentWeakInternSet() {
1303             this.map = new ConcurrentHashMap&lt;&gt;(512);
1304             this.stale = new ReferenceQueue&lt;&gt;();
1305         }
1306 
1307         /**
1308          * Get the existing interned element.
1309          * This method returns null if no element is interned.
</pre>
</td>
</tr>
</table>
<center><a href="../VersionProps.java.template.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../math/MutableBigInteger.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
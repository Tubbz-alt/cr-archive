<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/SocketPermission.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../math/MutableBigInteger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../nio/Bits.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/SocketPermission.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
  28 import java.io.IOException;
  29 import java.io.ObjectInputStream;
  30 import java.io.ObjectOutputStream;
  31 import java.io.ObjectStreamField;
  32 import java.io.Serializable;
  33 import java.net.InetAddress;
  34 import java.security.AccessController;
  35 import java.security.Permission;
  36 import java.security.PermissionCollection;
  37 import java.security.PrivilegedAction;
  38 import java.security.Security;
  39 import java.util.Collections;
<span class="line-removed">  40 import java.util.Comparator;</span>
  41 import java.util.Enumeration;
<span class="line-modified">  42 import java.util.Vector;</span>
  43 import java.util.StringJoiner;
  44 import java.util.StringTokenizer;
<span class="line-modified">  45 import java.util.concurrent.ConcurrentSkipListMap;</span>

  46 import sun.net.util.IPAddressUtil;
  47 import sun.net.PortConfig;
  48 import sun.security.util.RegisteredDomain;
  49 import sun.security.util.SecurityConstants;
  50 import sun.security.util.Debug;
  51 
  52 
  53 /**
  54  * This class represents access to a network via sockets.
  55  * A SocketPermission consists of a
  56  * host specification and a set of &quot;actions&quot; specifying ways to
  57  * connect to that host. The host is specified as
  58  * &lt;pre&gt;
  59  *    host = (hostname | IPv4address | iPv6reference) [:portrange]
  60  *    portrange = portnumber | -portnumber | portnumber-[portnumber]
  61  * &lt;/pre&gt;
  62  * The host is expressed as a DNS name, as a numerical IP address,
  63  * or as &quot;localhost&quot; (for the local machine).
  64  * The wildcard &quot;*&quot; may be included once in a DNS name host
  65  * specification. If it is included, it must be in the leftmost
</pre>
<hr />
<pre>
1332 
1333 if (init&#39;d with IP, key is IP as string)
1334 if wildcard, its the wild card
1335 else its the cname?
1336 
1337  *
1338  * @see java.security.Permission
1339  * @see java.security.Permissions
1340  * @see java.security.PermissionCollection
1341  *
1342  *
1343  * @author Roland Schemers
1344  *
1345  * @serial include
1346  */
1347 
1348 final class SocketPermissionCollection extends PermissionCollection
1349     implements Serializable
1350 {
1351     // Not serialized; see serialization section at end of class
<span class="line-modified">1352     // A ConcurrentSkipListMap is used to preserve order, so that most</span>
<span class="line-removed">1353     // recently added permissions are checked first (see JDK-4301064).</span>
<span class="line-removed">1354     private transient ConcurrentSkipListMap&lt;String, SocketPermission&gt; perms;</span>
1355 
1356     /**
<span class="line-modified">1357      * Create an empty SocketPermissions object.</span>
<span class="line-removed">1358      *</span>
1359      */
1360     public SocketPermissionCollection() {
<span class="line-modified">1361         perms = new ConcurrentSkipListMap&lt;&gt;(new SPCComparator());</span>
1362     }
1363 
1364     /**
1365      * Adds a permission to the SocketPermissions. The key for the hash is
1366      * the name in the case of wildcards, or all the IP addresses.
1367      *
1368      * @param permission the Permission object to add.
1369      *
1370      * @throws    IllegalArgumentException   if the permission is not a
1371      *                                       SocketPermission
1372      *
1373      * @throws    SecurityException   if this SocketPermissionCollection object
1374      *                                has been marked readonly
1375      */
1376     @Override
1377     public void add(Permission permission) {
1378         if (! (permission instanceof SocketPermission))
1379             throw new IllegalArgumentException(&quot;invalid permission: &quot;+
1380                                                permission);
1381         if (isReadOnly())
</pre>
<hr />
<pre>
1414      * Check and see if this collection of permissions implies the permissions
1415      * expressed in &quot;permission&quot;.
1416      *
1417      * @param permission the Permission object to compare
1418      *
1419      * @return true if &quot;permission&quot; is a proper subset of a permission in
1420      * the collection, false if not.
1421      */
1422     @Override
1423     public boolean implies(Permission permission)
1424     {
1425         if (! (permission instanceof SocketPermission))
1426                 return false;
1427 
1428         SocketPermission np = (SocketPermission) permission;
1429 
1430         int desired = np.getMask();
1431         int effective = 0;
1432         int needed = desired;
1433 












1434         //System.out.println(&quot;implies &quot;+np);
1435         for (SocketPermission x : perms.values()) {
1436             //System.out.println(&quot;  trying &quot;+x);
1437             if (((needed &amp; x.getMask()) != 0) &amp;&amp; x.impliesIgnoreMask(np)) {
1438                 effective |=  x.getMask();
1439                 if ((effective &amp; desired) == desired) {
1440                     return true;
1441                 }
1442                 needed = (desired &amp; ~effective);
1443             }
1444         }
1445         return false;
1446     }
1447 
1448     /**
1449      * Returns an enumeration of all the SocketPermission objects in the
1450      * container.
1451      *
1452      * @return an enumeration of all the SocketPermission objects.
1453      */
</pre>
<hr />
<pre>
1495         ObjectOutputStream.PutField pfields = out.putFields();
1496         pfields.put(&quot;permissions&quot;, permissions);
1497         out.writeFields();
1498     }
1499 
1500     /*
1501      * Reads in a Vector of SocketPermissions and saves them in the perms field.
1502      */
1503     @java.io.Serial
1504     private void readObject(ObjectInputStream in)
1505         throws IOException, ClassNotFoundException
1506     {
1507         // Don&#39;t call in.defaultReadObject()
1508 
1509         // Read in serialized fields
1510         ObjectInputStream.GetField gfields = in.readFields();
1511 
1512         // Get the one we want
1513         @SuppressWarnings(&quot;unchecked&quot;)
1514         Vector&lt;SocketPermission&gt; permissions = (Vector&lt;SocketPermission&gt;)gfields.get(&quot;permissions&quot;, null);
<span class="line-modified">1515         perms = new ConcurrentSkipListMap&lt;&gt;(new SPCComparator());</span>
1516         for (SocketPermission sp : permissions) {
1517             perms.put(sp.getName(), sp);
1518         }
1519     }
<span class="line-removed">1520 </span>
<span class="line-removed">1521     /**</span>
<span class="line-removed">1522      * A simple comparator that orders new non-equal entries at the beginning.</span>
<span class="line-removed">1523      */</span>
<span class="line-removed">1524     private static class SPCComparator implements Comparator&lt;String&gt; {</span>
<span class="line-removed">1525         @Override</span>
<span class="line-removed">1526         public int compare(String s1, String s2) {</span>
<span class="line-removed">1527             if (s1.equals(s2)) {</span>
<span class="line-removed">1528                 return 0;</span>
<span class="line-removed">1529             }</span>
<span class="line-removed">1530             return -1;</span>
<span class="line-removed">1531         }</span>
<span class="line-removed">1532     }</span>
1533 }
</pre>
</td>
<td>
<hr />
<pre>
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
  28 import java.io.IOException;
  29 import java.io.ObjectInputStream;
  30 import java.io.ObjectOutputStream;
  31 import java.io.ObjectStreamField;
  32 import java.io.Serializable;
  33 import java.net.InetAddress;
  34 import java.security.AccessController;
  35 import java.security.Permission;
  36 import java.security.PermissionCollection;
  37 import java.security.PrivilegedAction;
  38 import java.security.Security;
  39 import java.util.Collections;

  40 import java.util.Enumeration;
<span class="line-modified">  41 import java.util.Map;</span>
  42 import java.util.StringJoiner;
  43 import java.util.StringTokenizer;
<span class="line-modified">  44 import java.util.Vector;</span>
<span class="line-added">  45 import java.util.concurrent.ConcurrentHashMap;</span>
  46 import sun.net.util.IPAddressUtil;
  47 import sun.net.PortConfig;
  48 import sun.security.util.RegisteredDomain;
  49 import sun.security.util.SecurityConstants;
  50 import sun.security.util.Debug;
  51 
  52 
  53 /**
  54  * This class represents access to a network via sockets.
  55  * A SocketPermission consists of a
  56  * host specification and a set of &quot;actions&quot; specifying ways to
  57  * connect to that host. The host is specified as
  58  * &lt;pre&gt;
  59  *    host = (hostname | IPv4address | iPv6reference) [:portrange]
  60  *    portrange = portnumber | -portnumber | portnumber-[portnumber]
  61  * &lt;/pre&gt;
  62  * The host is expressed as a DNS name, as a numerical IP address,
  63  * or as &quot;localhost&quot; (for the local machine).
  64  * The wildcard &quot;*&quot; may be included once in a DNS name host
  65  * specification. If it is included, it must be in the leftmost
</pre>
<hr />
<pre>
1332 
1333 if (init&#39;d with IP, key is IP as string)
1334 if wildcard, its the wild card
1335 else its the cname?
1336 
1337  *
1338  * @see java.security.Permission
1339  * @see java.security.Permissions
1340  * @see java.security.PermissionCollection
1341  *
1342  *
1343  * @author Roland Schemers
1344  *
1345  * @serial include
1346  */
1347 
1348 final class SocketPermissionCollection extends PermissionCollection
1349     implements Serializable
1350 {
1351     // Not serialized; see serialization section at end of class
<span class="line-modified">1352     private transient Map&lt;String, SocketPermission&gt; perms;</span>


1353 
1354     /**
<span class="line-modified">1355      * Create an empty SocketPermissionCollection object.</span>

1356      */
1357     public SocketPermissionCollection() {
<span class="line-modified">1358         perms = new ConcurrentHashMap&lt;&gt;();</span>
1359     }
1360 
1361     /**
1362      * Adds a permission to the SocketPermissions. The key for the hash is
1363      * the name in the case of wildcards, or all the IP addresses.
1364      *
1365      * @param permission the Permission object to add.
1366      *
1367      * @throws    IllegalArgumentException   if the permission is not a
1368      *                                       SocketPermission
1369      *
1370      * @throws    SecurityException   if this SocketPermissionCollection object
1371      *                                has been marked readonly
1372      */
1373     @Override
1374     public void add(Permission permission) {
1375         if (! (permission instanceof SocketPermission))
1376             throw new IllegalArgumentException(&quot;invalid permission: &quot;+
1377                                                permission);
1378         if (isReadOnly())
</pre>
<hr />
<pre>
1411      * Check and see if this collection of permissions implies the permissions
1412      * expressed in &quot;permission&quot;.
1413      *
1414      * @param permission the Permission object to compare
1415      *
1416      * @return true if &quot;permission&quot; is a proper subset of a permission in
1417      * the collection, false if not.
1418      */
1419     @Override
1420     public boolean implies(Permission permission)
1421     {
1422         if (! (permission instanceof SocketPermission))
1423                 return false;
1424 
1425         SocketPermission np = (SocketPermission) permission;
1426 
1427         int desired = np.getMask();
1428         int effective = 0;
1429         int needed = desired;
1430 
<span class="line-added">1431         var hit = perms.get(np.getName());</span>
<span class="line-added">1432         if (hit != null) {</span>
<span class="line-added">1433             // fastpath, if the host was explicitly listed</span>
<span class="line-added">1434             if (((needed &amp; hit.getMask()) != 0) &amp;&amp; hit.impliesIgnoreMask(np)) {</span>
<span class="line-added">1435                 effective |= hit.getMask();</span>
<span class="line-added">1436                 if ((effective &amp; desired) == desired) {</span>
<span class="line-added">1437                     return true;</span>
<span class="line-added">1438                 }</span>
<span class="line-added">1439                 needed = (desired &amp; ~effective);</span>
<span class="line-added">1440             }</span>
<span class="line-added">1441         }</span>
<span class="line-added">1442 </span>
1443         //System.out.println(&quot;implies &quot;+np);
1444         for (SocketPermission x : perms.values()) {
1445             //System.out.println(&quot;  trying &quot;+x);
1446             if (((needed &amp; x.getMask()) != 0) &amp;&amp; x.impliesIgnoreMask(np)) {
1447                 effective |=  x.getMask();
1448                 if ((effective &amp; desired) == desired) {
1449                     return true;
1450                 }
1451                 needed = (desired &amp; ~effective);
1452             }
1453         }
1454         return false;
1455     }
1456 
1457     /**
1458      * Returns an enumeration of all the SocketPermission objects in the
1459      * container.
1460      *
1461      * @return an enumeration of all the SocketPermission objects.
1462      */
</pre>
<hr />
<pre>
1504         ObjectOutputStream.PutField pfields = out.putFields();
1505         pfields.put(&quot;permissions&quot;, permissions);
1506         out.writeFields();
1507     }
1508 
1509     /*
1510      * Reads in a Vector of SocketPermissions and saves them in the perms field.
1511      */
1512     @java.io.Serial
1513     private void readObject(ObjectInputStream in)
1514         throws IOException, ClassNotFoundException
1515     {
1516         // Don&#39;t call in.defaultReadObject()
1517 
1518         // Read in serialized fields
1519         ObjectInputStream.GetField gfields = in.readFields();
1520 
1521         // Get the one we want
1522         @SuppressWarnings(&quot;unchecked&quot;)
1523         Vector&lt;SocketPermission&gt; permissions = (Vector&lt;SocketPermission&gt;)gfields.get(&quot;permissions&quot;, null);
<span class="line-modified">1524         perms = new ConcurrentHashMap&lt;&gt;(permissions.size());</span>
1525         for (SocketPermission sp : permissions) {
1526             perms.put(sp.getName(), sp);
1527         }
1528     }













1529 }
</pre>
</td>
</tr>
</table>
<center><a href="../math/MutableBigInteger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../nio/Bits.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
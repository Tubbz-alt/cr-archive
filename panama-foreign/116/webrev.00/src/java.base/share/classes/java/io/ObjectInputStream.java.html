<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/io/ObjectInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.io.ObjectStreamClass.WeakClassKey;
  29 import java.io.ObjectStreamClass.RecordSupport;
  30 import java.lang.System.Logger;
  31 import java.lang.invoke.MethodHandle;
  32 import java.lang.ref.ReferenceQueue;
  33 import java.lang.reflect.Array;
  34 import java.lang.reflect.Modifier;
  35 import java.lang.reflect.Proxy;
  36 import java.security.AccessControlContext;
  37 import java.security.AccessController;
  38 import java.security.PrivilegedAction;
  39 import java.security.PrivilegedActionException;
  40 import java.security.PrivilegedExceptionAction;
  41 import java.util.Arrays;
  42 import java.util.Map;
  43 import java.util.Objects;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 import java.util.concurrent.ConcurrentMap;
  46 
  47 import static java.io.ObjectStreamClass.processQueue;
  48 
  49 import jdk.internal.access.SharedSecrets;
  50 import jdk.internal.misc.Unsafe;
  51 import sun.reflect.misc.ReflectUtil;
  52 
  53 /**
  54  * An ObjectInputStream deserializes primitive data and objects previously
  55  * written using an ObjectOutputStream.
  56  *
  57  * &lt;p&gt;&lt;strong&gt;Warning: Deserialization of untrusted data is inherently dangerous
  58  * and should be avoided. Untrusted data should be carefully validated according to the
  59  * &quot;Serialization and Deserialization&quot; section of the
  60  * {@extLink secure_coding_guidelines_javase Secure Coding Guidelines for Java SE}.
  61  * {@extLink serialization_filter_guide Serialization Filtering} describes best
  62  * practices for defensive use of serial filters.
  63  * &lt;/strong&gt;&lt;/p&gt;
  64  *
  65  * &lt;p&gt;ObjectOutputStream and ObjectInputStream can provide an application with
  66  * persistent storage for graphs of objects when used with a FileOutputStream
  67  * and FileInputStream respectively.  ObjectInputStream is used to recover
  68  * those objects previously serialized. Other uses include passing objects
  69  * between hosts using a socket stream or for marshaling and unmarshaling
  70  * arguments and parameters in a remote communication system.
  71  *
  72  * &lt;p&gt;ObjectInputStream ensures that the types of all objects in the graph
  73  * created from the stream match the classes present in the Java Virtual
  74  * Machine.  Classes are loaded as required using the standard mechanisms.
  75  *
  76  * &lt;p&gt;Only objects that support the java.io.Serializable or
  77  * java.io.Externalizable interface can be read from streams.
  78  *
  79  * &lt;p&gt;The method {@code readObject} is used to read an object from the
  80  * stream.  Java&#39;s safe casting should be used to get the desired type.  In
  81  * Java, strings and arrays are objects and are treated as objects during
  82  * serialization. When read they need to be cast to the expected type.
  83  *
  84  * &lt;p&gt;Primitive data types can be read from the stream using the appropriate
  85  * method on DataInput.
  86  *
  87  * &lt;p&gt;The default deserialization mechanism for objects restores the contents
  88  * of each field to the value and type it had when it was written.  Fields
  89  * declared as transient or static are ignored by the deserialization process.
  90  * References to other objects cause those objects to be read from the stream
  91  * as necessary.  Graphs of objects are restored correctly using a reference
  92  * sharing mechanism.  New objects are always allocated when deserializing,
  93  * which prevents existing objects from being overwritten.
  94  *
  95  * &lt;p&gt;Reading an object is analogous to running the constructors of a new
  96  * object.  Memory is allocated for the object and initialized to zero (NULL).
  97  * No-arg constructors are invoked for the non-serializable classes and then
  98  * the fields of the serializable classes are restored from the stream starting
  99  * with the serializable class closest to java.lang.object and finishing with
 100  * the object&#39;s most specific class.
 101  *
 102  * &lt;p&gt;For example to read from a stream as written by the example in
 103  * ObjectOutputStream:
 104  * &lt;br&gt;
 105  * &lt;pre&gt;
 106  *      FileInputStream fis = new FileInputStream(&quot;t.tmp&quot;);
 107  *      ObjectInputStream ois = new ObjectInputStream(fis);
 108  *
 109  *      int i = ois.readInt();
 110  *      String today = (String) ois.readObject();
 111  *      Date date = (Date) ois.readObject();
 112  *
 113  *      ois.close();
 114  * &lt;/pre&gt;
 115  *
 116  * &lt;p&gt;Classes control how they are serialized by implementing either the
 117  * java.io.Serializable or java.io.Externalizable interfaces.
 118  *
 119  * &lt;p&gt;Implementing the Serializable interface allows object serialization to
 120  * save and restore the entire state of the object and it allows classes to
 121  * evolve between the time the stream is written and the time it is read.  It
 122  * automatically traverses references between objects, saving and restoring
 123  * entire graphs.
 124  *
 125  * &lt;p&gt;Serializable classes that require special handling during the
 126  * serialization and deserialization process should implement the following
 127  * methods:
 128  *
 129  * &lt;pre&gt;
 130  * private void writeObject(java.io.ObjectOutputStream stream)
 131  *     throws IOException;
 132  * private void readObject(java.io.ObjectInputStream stream)
 133  *     throws IOException, ClassNotFoundException;
 134  * private void readObjectNoData()
 135  *     throws ObjectStreamException;
 136  * &lt;/pre&gt;
 137  *
 138  * &lt;p&gt;The readObject method is responsible for reading and restoring the state
 139  * of the object for its particular class using data written to the stream by
 140  * the corresponding writeObject method.  The method does not need to concern
 141  * itself with the state belonging to its superclasses or subclasses.  State is
 142  * restored by reading data from the ObjectInputStream for the individual
 143  * fields and making assignments to the appropriate fields of the object.
 144  * Reading primitive data types is supported by DataInput.
 145  *
 146  * &lt;p&gt;Any attempt to read object data which exceeds the boundaries of the
 147  * custom data written by the corresponding writeObject method will cause an
 148  * OptionalDataException to be thrown with an eof field value of true.
 149  * Non-object reads which exceed the end of the allotted data will reflect the
 150  * end of data in the same way that they would indicate the end of the stream:
 151  * bytewise reads will return -1 as the byte read or number of bytes read, and
 152  * primitive reads will throw EOFExceptions.  If there is no corresponding
 153  * writeObject method, then the end of default serialized data marks the end of
 154  * the allotted data.
 155  *
 156  * &lt;p&gt;Primitive and object read calls issued from within a readExternal method
 157  * behave in the same manner--if the stream is already positioned at the end of
 158  * data written by the corresponding writeExternal method, object reads will
 159  * throw OptionalDataExceptions with eof set to true, bytewise reads will
 160  * return -1, and primitive reads will throw EOFExceptions.  Note that this
 161  * behavior does not hold for streams written with the old
 162  * {@code ObjectStreamConstants.PROTOCOL_VERSION_1} protocol, in which the
 163  * end of data written by writeExternal methods is not demarcated, and hence
 164  * cannot be detected.
 165  *
 166  * &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
 167  * the object for its particular class in the event that the serialization
 168  * stream does not list the given class as a superclass of the object being
 169  * deserialized.  This may occur in cases where the receiving party uses a
 170  * different version of the deserialized instance&#39;s class than the sending
 171  * party, and the receiver&#39;s version extends classes that are not extended by
 172  * the sender&#39;s version.  This may also occur if the serialization stream has
 173  * been tampered; hence, readObjectNoData is useful for initializing
 174  * deserialized objects properly despite a &quot;hostile&quot; or incomplete source
 175  * stream.
 176  *
 177  * &lt;p&gt;Serialization does not read or assign values to the fields of any object
 178  * that does not implement the java.io.Serializable interface.  Subclasses of
 179  * Objects that are not serializable can be serializable. In this case the
 180  * non-serializable class must have a no-arg constructor to allow its fields to
 181  * be initialized.  In this case it is the responsibility of the subclass to
 182  * save and restore the state of the non-serializable class. It is frequently
 183  * the case that the fields of that class are accessible (public, package, or
 184  * protected) or that there are get and set methods that can be used to restore
 185  * the state.
 186  *
 187  * &lt;p&gt;The contents of the stream can be filtered during deserialization.
 188  * If a {@linkplain #setObjectInputFilter(ObjectInputFilter) filter is set}
 189  * on an ObjectInputStream, the {@link ObjectInputFilter} can check that
 190  * the classes, array lengths, number of references in the stream, depth, and
 191  * number of bytes consumed from the input stream are allowed and
 192  * if not, can terminate deserialization.
 193  * A {@linkplain ObjectInputFilter.Config#setSerialFilter(ObjectInputFilter) system-wide filter}
 194  * can be configured that is applied to each {@code ObjectInputStream} unless replaced
 195  * using {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}.
 196  *
 197  * &lt;p&gt;Any exception that occurs while deserializing an object will be caught by
 198  * the ObjectInputStream and abort the reading process.
 199  *
 200  * &lt;p&gt;Implementing the Externalizable interface allows the object to assume
 201  * complete control over the contents and format of the object&#39;s serialized
 202  * form.  The methods of the Externalizable interface, writeExternal and
 203  * readExternal, are called to save and restore the objects state.  When
 204  * implemented by a class they can write and read their own state using all of
 205  * the methods of ObjectOutput and ObjectInput.  It is the responsibility of
 206  * the objects to handle any versioning that occurs.
 207  *
 208  * &lt;p&gt;Enum constants are deserialized differently than ordinary serializable or
 209  * externalizable objects.  The serialized form of an enum constant consists
 210  * solely of its name; field values of the constant are not transmitted.  To
 211  * deserialize an enum constant, ObjectInputStream reads the constant name from
 212  * the stream; the deserialized constant is then obtained by calling the static
 213  * method {@code Enum.valueOf(Class, String)} with the enum constant&#39;s
 214  * base type and the received constant name as arguments.  Like other
 215  * serializable or externalizable objects, enum constants can function as the
 216  * targets of back references appearing subsequently in the serialization
 217  * stream.  The process by which enum constants are deserialized cannot be
 218  * customized: any class-specific readObject, readObjectNoData, and readResolve
 219  * methods defined by enum types are ignored during deserialization.
 220  * Similarly, any serialPersistentFields or serialVersionUID field declarations
 221  * are also ignored--all enum types have a fixed serialVersionUID of 0L.
 222  *
 223  * @implSpec
 224  * &lt;a id=&quot;record-serialization&quot;&gt;&lt;/a&gt;
 225  * Records are serialized differently than ordinary serializable or externalizable
 226  * objects. The serialized form of a record object is a sequence of values derived
 227  * from the record components. The stream format of a record object is the same as
 228  * that of an ordinary object in the stream. During deserialization, if the local
 229  * class equivalent of the specified stream class descriptor is a record class,
 230  * then first the stream fields are read and reconstructed to serve as the record&#39;s
 231  * component values; and second, a record object is created by invoking the
 232  * record&#39;s &lt;i&gt;canonical&lt;/i&gt; constructor with the component values as arguments (or the
 233  * default value for component&#39;s type if a component value is absent from the
 234  * stream).
 235  * Like other serializable or externalizable objects, record objects can function
 236  * as the target of back references appearing subsequently in the serialization
 237  * stream. However, a cycle in the graph where the record object is referred to,
 238  * either directly or transitively, by one of its components, is not preserved.
 239  * The record components are deserialized prior to the invocation of the record
 240  * constructor, hence this limitation (see
 241  * &lt;a href=&quot;{@docRoot}/../specs/serialization/serial-arch.html#cyclic-references&quot;&gt;
 242  * [Section 1.14, &quot;Circular References&quot;&lt;/a&gt; for additional information).
 243  * The process by which record objects are serialized or externalized cannot be
 244  * customized; any class-specific writeObject, readObject, readObjectNoData,
 245  * writeExternal, and readExternal methods defined by record classes are
 246  * ignored during serialization and deserialization. However, a substitute object
 247  * to be serialized or a designate replacement may be specified, by the
 248  * writeReplace and readResolve methods, respectively.  Any
 249  * serialPersistentFields field declaration is ignored. Documenting serializable
 250  * fields and data for record classes is unnecessary, since there is no variation
 251  * in the serial form, other than whether a substitute or replacement object is
 252  * used. The serialVersionUID of a record class is 0L unless explicitly
 253  * declared. The requirement for matching serialVersionUID values is waived for
 254  * record classes.
 255  *
 256  * @author      Mike Warres
 257  * @author      Roger Riggs
 258  * @see java.io.DataInput
 259  * @see java.io.ObjectOutputStream
 260  * @see java.io.Serializable
 261  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/input.html&quot;&gt;
 262  *     Object Serialization Specification, Section 3, Object Input Classes&lt;/a&gt;
 263  * @since   1.1
 264  */
 265 public class ObjectInputStream
 266     extends InputStream implements ObjectInput, ObjectStreamConstants
 267 {
 268     /** handle value representing null */
 269     private static final int NULL_HANDLE = -1;
 270 
 271     /** marker for unshared objects in internal handle table */
 272     private static final Object unsharedMarker = new Object();
 273 
 274     /**
 275      * immutable table mapping primitive type names to corresponding
 276      * class objects
 277      */
 278     private static final Map&lt;String, Class&lt;?&gt;&gt; primClasses =
 279         Map.of(&quot;boolean&quot;, boolean.class,
 280                &quot;byte&quot;, byte.class,
 281                &quot;char&quot;, char.class,
 282                &quot;short&quot;, short.class,
 283                &quot;int&quot;, int.class,
 284                &quot;long&quot;, long.class,
 285                &quot;float&quot;, float.class,
 286                &quot;double&quot;, double.class,
 287                &quot;void&quot;, void.class);
 288 
 289     private static class Caches {
 290         /** cache of subclass security audit results */
 291         static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =
 292             new ConcurrentHashMap&lt;&gt;();
 293 
 294         /** queue for WeakReferences to audited subclasses */
 295         static final ReferenceQueue&lt;Class&lt;?&gt;&gt; subclassAuditsQueue =
 296             new ReferenceQueue&lt;&gt;();
 297     }
 298 
 299     /*
 300      * Separate class to defer initialization of logging until needed.
 301      */
 302     private static class Logging {
 303         /*
 304          * Logger for ObjectInputFilter results.
 305          * Setup the filter logger if it is set to DEBUG or TRACE.
 306          * (Assuming it will not change).
 307          */
 308         static final System.Logger filterLogger;
 309 
 310         static {
 311             Logger filterLog = System.getLogger(&quot;java.io.serialization&quot;);
 312             filterLogger = (filterLog.isLoggable(Logger.Level.DEBUG)
 313                     || filterLog.isLoggable(Logger.Level.TRACE)) ? filterLog : null;
 314         }
 315     }
 316 
 317     /** filter stream for handling block data conversion */
 318     private final BlockDataInputStream bin;
 319     /** validation callback list */
 320     private final ValidationList vlist;
 321     /** recursion depth */
 322     private long depth;
 323     /** Total number of references to any type of object, class, enum, proxy, etc. */
 324     private long totalObjectRefs;
 325     /** whether stream is closed */
 326     private boolean closed;
 327 
 328     /** wire handle -&gt; obj/exception map */
 329     private final HandleTable handles;
 330     /** scratch field for passing handle values up/down call stack */
 331     private int passHandle = NULL_HANDLE;
 332     /** flag set when at end of field value block with no TC_ENDBLOCKDATA */
 333     private boolean defaultDataEnd = false;
 334 
 335     /** if true, invoke readObjectOverride() instead of readObject() */
 336     private final boolean enableOverride;
 337     /** if true, invoke resolveObject() */
 338     private boolean enableResolve;
 339 
 340     /**
 341      * Context during upcalls to class-defined readObject methods; holds
 342      * object currently being deserialized and descriptor for current class.
 343      * Null when not during readObject upcall.
 344      */
 345     private SerialCallbackContext curContext;
 346 
 347     /**
 348      * Filter of class descriptors and classes read from the stream;
 349      * may be null.
 350      */
 351     private ObjectInputFilter serialFilter;
 352 
 353     /**
 354      * Creates an ObjectInputStream that reads from the specified InputStream.
 355      * A serialization stream header is read from the stream and verified.
 356      * This constructor will block until the corresponding ObjectOutputStream
 357      * has written and flushed the header.
 358      *
 359      * &lt;p&gt;The serialization filter is initialized to the value of
 360      * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
 361      *
 362      * &lt;p&gt;If a security manager is installed, this constructor will check for
 363      * the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
 364      * directly or indirectly by the constructor of a subclass which overrides
 365      * the ObjectInputStream.readFields or ObjectInputStream.readUnshared
 366      * methods.
 367      *
 368      * @param   in input stream to read from
 369      * @throws  StreamCorruptedException if the stream header is incorrect
 370      * @throws  IOException if an I/O error occurs while reading stream header
 371      * @throws  SecurityException if untrusted subclass illegally overrides
 372      *          security-sensitive methods
 373      * @throws  NullPointerException if {@code in} is {@code null}
 374      * @see     ObjectInputStream#ObjectInputStream()
 375      * @see     ObjectInputStream#readFields()
 376      * @see     ObjectOutputStream#ObjectOutputStream(OutputStream)
 377      */
 378     public ObjectInputStream(InputStream in) throws IOException {
 379         verifySubclass();
 380         bin = new BlockDataInputStream(in);
 381         handles = new HandleTable(10);
 382         vlist = new ValidationList();
 383         serialFilter = ObjectInputFilter.Config.getSerialFilter();
 384         enableOverride = false;
 385         readStreamHeader();
 386         bin.setBlockDataMode(true);
 387     }
 388 
 389     /**
 390      * Provide a way for subclasses that are completely reimplementing
 391      * ObjectInputStream to not have to allocate private data just used by this
 392      * implementation of ObjectInputStream.
 393      *
 394      * &lt;p&gt;The serialization filter is initialized to the value of
 395      * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
 396      *
 397      * &lt;p&gt;If there is a security manager installed, this method first calls the
 398      * security manager&#39;s {@code checkPermission} method with the
 399      * {@code SerializablePermission(&quot;enableSubclassImplementation&quot;)}
 400      * permission to ensure it&#39;s ok to enable subclassing.
 401      *
 402      * @throws  SecurityException if a security manager exists and its
 403      *          {@code checkPermission} method denies enabling
 404      *          subclassing.
 405      * @throws  IOException if an I/O error occurs while creating this stream
 406      * @see SecurityManager#checkPermission
 407      * @see java.io.SerializablePermission
 408      */
 409     protected ObjectInputStream() throws IOException, SecurityException {
 410         SecurityManager sm = System.getSecurityManager();
 411         if (sm != null) {
 412             sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
 413         }
 414         bin = null;
 415         handles = null;
 416         vlist = null;
 417         serialFilter = ObjectInputFilter.Config.getSerialFilter();
 418         enableOverride = true;
 419     }
 420 
 421     /**
 422      * Read an object from the ObjectInputStream.  The class of the object, the
 423      * signature of the class, and the values of the non-transient and
 424      * non-static fields of the class and all of its supertypes are read.
 425      * Default deserializing for a class can be overridden using the writeObject
 426      * and readObject methods.  Objects referenced by this object are read
 427      * transitively so that a complete equivalent graph of objects is
 428      * reconstructed by readObject.
 429      *
 430      * &lt;p&gt;The root object is completely restored when all of its fields and the
 431      * objects it references are completely restored.  At this point the object
 432      * validation callbacks are executed in order based on their registered
 433      * priorities. The callbacks are registered by objects (in the readObject
 434      * special methods) as they are individually restored.
 435      *
 436      * &lt;p&gt;The serialization filter, when not {@code null}, is invoked for
 437      * each object (regular or class) read to reconstruct the root object.
 438      * See {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter} for details.
 439      *
 440      * &lt;p&gt;Exceptions are thrown for problems with the InputStream and for
 441      * classes that should not be deserialized.  All exceptions are fatal to
 442      * the InputStream and leave it in an indeterminate state; it is up to the
 443      * caller to ignore or recover the stream state.
 444      *
 445      * @throws  ClassNotFoundException Class of a serialized object cannot be
 446      *          found.
 447      * @throws  InvalidClassException Something is wrong with a class used by
 448      *          serialization.
 449      * @throws  StreamCorruptedException Control information in the
 450      *          stream is inconsistent.
 451      * @throws  OptionalDataException Primitive data was found in the
 452      *          stream instead of objects.
 453      * @throws  IOException Any of the usual Input/Output related exceptions.
 454      */
 455     public final Object readObject()
 456         throws IOException, ClassNotFoundException {
 457         return readObject(Object.class);
 458     }
 459 
 460     /**
 461      * Reads a String and only a string.
 462      *
 463      * @return  the String read
 464      * @throws  EOFException If end of file is reached.
 465      * @throws  IOException If other I/O error has occurred.
 466      */
 467     private String readString() throws IOException {
 468         try {
 469             return (String) readObject(String.class);
 470         } catch (ClassNotFoundException cnf) {
 471             throw new IllegalStateException(cnf);
 472         }
 473     }
 474 
 475     /**
 476      * Internal method to read an object from the ObjectInputStream of the expected type.
 477      * Called only from {@code readObject()} and {@code readString()}.
 478      * Only {@code Object.class} and {@code String.class} are supported.
 479      *
 480      * @param type the type expected; either Object.class or String.class
 481      * @return an object of the type
 482      * @throws  IOException Any of the usual Input/Output related exceptions.
 483      * @throws  ClassNotFoundException Class of a serialized object cannot be
 484      *          found.
 485      */
 486     private final Object readObject(Class&lt;?&gt; type)
 487         throws IOException, ClassNotFoundException
 488     {
 489         if (enableOverride) {
 490             return readObjectOverride();
 491         }
 492 
 493         if (! (type == Object.class || type == String.class))
 494             throw new AssertionError(&quot;internal error&quot;);
 495 
 496         // if nested read, passHandle contains handle of enclosing object
 497         int outerHandle = passHandle;
 498         try {
 499             Object obj = readObject0(type, false);
 500             handles.markDependency(outerHandle, passHandle);
 501             ClassNotFoundException ex = handles.lookupException(passHandle);
 502             if (ex != null) {
 503                 throw ex;
 504             }
 505             if (depth == 0) {
 506                 vlist.doCallbacks();
 507                 freeze();
 508             }
 509             return obj;
 510         } finally {
 511             passHandle = outerHandle;
 512             if (closed &amp;&amp; depth == 0) {
 513                 clear();
 514             }
 515         }
 516     }
 517 
 518     /**
 519      * This method is called by trusted subclasses of ObjectInputStream that
 520      * constructed ObjectInputStream using the protected no-arg constructor.
 521      * The subclass is expected to provide an override method with the modifier
 522      * &quot;final&quot;.
 523      *
 524      * @return  the Object read from the stream.
 525      * @throws  ClassNotFoundException Class definition of a serialized object
 526      *          cannot be found.
 527      * @throws  OptionalDataException Primitive data was found in the stream
 528      *          instead of objects.
 529      * @throws  IOException if I/O errors occurred while reading from the
 530      *          underlying stream
 531      * @see #ObjectInputStream()
 532      * @see #readObject()
 533      * @since 1.2
 534      */
 535     protected Object readObjectOverride()
 536         throws IOException, ClassNotFoundException
 537     {
 538         return null;
 539     }
 540 
 541     /**
 542      * Reads an &quot;unshared&quot; object from the ObjectInputStream.  This method is
 543      * identical to readObject, except that it prevents subsequent calls to
 544      * readObject and readUnshared from returning additional references to the
 545      * deserialized instance obtained via this call.  Specifically:
 546      * &lt;ul&gt;
 547      *   &lt;li&gt;If readUnshared is called to deserialize a back-reference (the
 548      *       stream representation of an object which has been written
 549      *       previously to the stream), an ObjectStreamException will be
 550      *       thrown.
 551      *
 552      *   &lt;li&gt;If readUnshared returns successfully, then any subsequent attempts
 553      *       to deserialize back-references to the stream handle deserialized
 554      *       by readUnshared will cause an ObjectStreamException to be thrown.
 555      * &lt;/ul&gt;
 556      * Deserializing an object via readUnshared invalidates the stream handle
 557      * associated with the returned object.  Note that this in itself does not
 558      * always guarantee that the reference returned by readUnshared is unique;
 559      * the deserialized object may define a readResolve method which returns an
 560      * object visible to other parties, or readUnshared may return a Class
 561      * object or enum constant obtainable elsewhere in the stream or through
 562      * external means. If the deserialized object defines a readResolve method
 563      * and the invocation of that method returns an array, then readUnshared
 564      * returns a shallow clone of that array; this guarantees that the returned
 565      * array object is unique and cannot be obtained a second time from an
 566      * invocation of readObject or readUnshared on the ObjectInputStream,
 567      * even if the underlying data stream has been manipulated.
 568      *
 569      * &lt;p&gt;The serialization filter, when not {@code null}, is invoked for
 570      * each object (regular or class) read to reconstruct the root object.
 571      * See {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter} for details.
 572      *
 573      * &lt;p&gt;ObjectInputStream subclasses which override this method can only be
 574      * constructed in security contexts possessing the
 575      * &quot;enableSubclassImplementation&quot; SerializablePermission; any attempt to
 576      * instantiate such a subclass without this permission will cause a
 577      * SecurityException to be thrown.
 578      *
 579      * @return  reference to deserialized object
 580      * @throws  ClassNotFoundException if class of an object to deserialize
 581      *          cannot be found
 582      * @throws  StreamCorruptedException if control information in the stream
 583      *          is inconsistent
 584      * @throws  ObjectStreamException if object to deserialize has already
 585      *          appeared in stream
 586      * @throws  OptionalDataException if primitive data is next in stream
 587      * @throws  IOException if an I/O error occurs during deserialization
 588      * @since   1.4
 589      */
 590     public Object readUnshared() throws IOException, ClassNotFoundException {
 591         // if nested read, passHandle contains handle of enclosing object
 592         int outerHandle = passHandle;
 593         try {
 594             Object obj = readObject0(Object.class, true);
 595             handles.markDependency(outerHandle, passHandle);
 596             ClassNotFoundException ex = handles.lookupException(passHandle);
 597             if (ex != null) {
 598                 throw ex;
 599             }
 600             if (depth == 0) {
 601                 vlist.doCallbacks();
 602                 freeze();
 603             }
 604             return obj;
 605         } finally {
 606             passHandle = outerHandle;
 607             if (closed &amp;&amp; depth == 0) {
 608                 clear();
 609             }
 610         }
 611     }
 612 
 613     /**
 614      * Read the non-static and non-transient fields of the current class from
 615      * this stream.  This may only be called from the readObject method of the
 616      * class being deserialized. It will throw the NotActiveException if it is
 617      * called otherwise.
 618      *
 619      * @throws  ClassNotFoundException if the class of a serialized object
 620      *          could not be found.
 621      * @throws  IOException if an I/O error occurs.
 622      * @throws  NotActiveException if the stream is not currently reading
 623      *          objects.
 624      */
 625     public void defaultReadObject()
 626         throws IOException, ClassNotFoundException
 627     {
 628         SerialCallbackContext ctx = curContext;
 629         if (ctx == null) {
 630             throw new NotActiveException(&quot;not in call to readObject&quot;);
 631         }
 632         Object curObj = ctx.getObj();
 633         ObjectStreamClass curDesc = ctx.getDesc();
 634         bin.setBlockDataMode(false);
 635         FieldValues vals = defaultReadFields(curObj, curDesc);
 636         if (curObj != null) {
 637             defaultCheckFieldValues(curObj, curDesc, vals);
 638             defaultSetFieldValues(curObj, curDesc, vals);
 639         }
 640         bin.setBlockDataMode(true);
 641         if (!curDesc.hasWriteObjectData()) {
 642             /*
 643              * Fix for 4360508: since stream does not contain terminating
 644              * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
 645              * knows to simulate end-of-custom-data behavior.
 646              */
 647             defaultDataEnd = true;
 648         }
 649         ClassNotFoundException ex = handles.lookupException(passHandle);
 650         if (ex != null) {
 651             throw ex;
 652         }
 653     }
 654 
 655     /**
 656      * Reads the persistent fields from the stream and makes them available by
 657      * name.
 658      *
 659      * @return  the {@code GetField} object representing the persistent
 660      *          fields of the object being deserialized
 661      * @throws  ClassNotFoundException if the class of a serialized object
 662      *          could not be found.
 663      * @throws  IOException if an I/O error occurs.
 664      * @throws  NotActiveException if the stream is not currently reading
 665      *          objects.
 666      * @since 1.2
 667      */
 668     public ObjectInputStream.GetField readFields()
 669         throws IOException, ClassNotFoundException
 670     {
 671         SerialCallbackContext ctx = curContext;
 672         if (ctx == null) {
 673             throw new NotActiveException(&quot;not in call to readObject&quot;);
 674         }
 675         ctx.checkAndSetUsed();
 676         ObjectStreamClass curDesc = ctx.getDesc();
 677         bin.setBlockDataMode(false);
 678         GetFieldImpl getField = new GetFieldImpl(curDesc);
 679         getField.readFields();
 680         bin.setBlockDataMode(true);
 681         if (!curDesc.hasWriteObjectData()) {
 682             /*
 683              * Fix for 4360508: since stream does not contain terminating
 684              * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
 685              * knows to simulate end-of-custom-data behavior.
 686              */
 687             defaultDataEnd = true;
 688         }
 689 
 690         return getField;
 691     }
 692 
 693     /**
 694      * Register an object to be validated before the graph is returned.  While
 695      * similar to resolveObject these validations are called after the entire
 696      * graph has been reconstituted.  Typically, a readObject method will
 697      * register the object with the stream so that when all of the objects are
 698      * restored a final set of validations can be performed.
 699      *
 700      * @param   obj the object to receive the validation callback.
 701      * @param   prio controls the order of callbacks;zero is a good default.
 702      *          Use higher numbers to be called back earlier, lower numbers for
 703      *          later callbacks. Within a priority, callbacks are processed in
 704      *          no particular order.
 705      * @throws  NotActiveException The stream is not currently reading objects
 706      *          so it is invalid to register a callback.
 707      * @throws  InvalidObjectException The validation object is null.
 708      */
 709     public void registerValidation(ObjectInputValidation obj, int prio)
 710         throws NotActiveException, InvalidObjectException
 711     {
 712         if (depth == 0) {
 713             throw new NotActiveException(&quot;stream inactive&quot;);
 714         }
 715         vlist.register(obj, prio);
 716     }
 717 
 718     /**
 719      * Load the local class equivalent of the specified stream class
 720      * description.  Subclasses may implement this method to allow classes to
 721      * be fetched from an alternate source.
 722      *
 723      * &lt;p&gt;The corresponding method in {@code ObjectOutputStream} is
 724      * {@code annotateClass}.  This method will be invoked only once for
 725      * each unique class in the stream.  This method can be implemented by
 726      * subclasses to use an alternate loading mechanism but must return a
 727      * {@code Class} object. Once returned, if the class is not an array
 728      * class, its serialVersionUID is compared to the serialVersionUID of the
 729      * serialized class, and if there is a mismatch, the deserialization fails
 730      * and an {@link InvalidClassException} is thrown.
 731      *
 732      * &lt;p&gt;The default implementation of this method in
 733      * {@code ObjectInputStream} returns the result of calling
 734      * &lt;pre&gt;
 735      *     Class.forName(desc.getName(), false, loader)
 736      * &lt;/pre&gt;
 737      * where {@code loader} is the first class loader on the current
 738      * thread&#39;s stack (starting from the currently executing method) that is
 739      * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
 740      * class loader} nor its ancestor; otherwise, {@code loader} is the
 741      * &lt;em&gt;platform class loader&lt;/em&gt;. If this call results in a
 742      * {@code ClassNotFoundException} and the name of the passed
 743      * {@code ObjectStreamClass} instance is the Java language keyword
 744      * for a primitive type or void, then the {@code Class} object
 745      * representing that primitive type or void will be returned
 746      * (e.g., an {@code ObjectStreamClass} with the name
 747      * {@code &quot;int&quot;} will be resolved to {@code Integer.TYPE}).
 748      * Otherwise, the {@code ClassNotFoundException} will be thrown to
 749      * the caller of this method.
 750      *
 751      * @param   desc an instance of class {@code ObjectStreamClass}
 752      * @return  a {@code Class} object corresponding to {@code desc}
 753      * @throws  IOException any of the usual Input/Output exceptions.
 754      * @throws  ClassNotFoundException if class of a serialized object cannot
 755      *          be found.
 756      */
 757     protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)
 758         throws IOException, ClassNotFoundException
 759     {
 760         String name = desc.getName();
 761         try {
 762             return Class.forName(name, false, latestUserDefinedLoader());
 763         } catch (ClassNotFoundException ex) {
 764             Class&lt;?&gt; cl = primClasses.get(name);
 765             if (cl != null) {
 766                 return cl;
 767             } else {
 768                 throw ex;
 769             }
 770         }
 771     }
 772 
 773     /**
 774      * Returns a proxy class that implements the interfaces named in a proxy
 775      * class descriptor; subclasses may implement this method to read custom
 776      * data from the stream along with the descriptors for dynamic proxy
 777      * classes, allowing them to use an alternate loading mechanism for the
 778      * interfaces and the proxy class.
 779      *
 780      * &lt;p&gt;This method is called exactly once for each unique proxy class
 781      * descriptor in the stream.
 782      *
 783      * &lt;p&gt;The corresponding method in {@code ObjectOutputStream} is
 784      * {@code annotateProxyClass}.  For a given subclass of
 785      * {@code ObjectInputStream} that overrides this method, the
 786      * {@code annotateProxyClass} method in the corresponding subclass of
 787      * {@code ObjectOutputStream} must write any data or objects read by
 788      * this method.
 789      *
 790      * &lt;p&gt;The default implementation of this method in
 791      * {@code ObjectInputStream} returns the result of calling
 792      * {@code Proxy.getProxyClass} with the list of {@code Class}
 793      * objects for the interfaces that are named in the {@code interfaces}
 794      * parameter.  The {@code Class} object for each interface name
 795      * {@code i} is the value returned by calling
 796      * &lt;pre&gt;
 797      *     Class.forName(i, false, loader)
 798      * &lt;/pre&gt;
 799      * where {@code loader} is the first class loader on the current
 800      * thread&#39;s stack (starting from the currently executing method) that is
 801      * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
 802      * class loader} nor its ancestor; otherwise, {@code loader} is the
 803      * &lt;em&gt;platform class loader&lt;/em&gt;.
 804      * Unless any of the resolved interfaces are non-public, this same value
 805      * of {@code loader} is also the class loader passed to
 806      * {@code Proxy.getProxyClass}; if non-public interfaces are present,
 807      * their class loader is passed instead (if more than one non-public
 808      * interface class loader is encountered, an
 809      * {@code IllegalAccessError} is thrown).
 810      * If {@code Proxy.getProxyClass} throws an
 811      * {@code IllegalArgumentException}, {@code resolveProxyClass}
 812      * will throw a {@code ClassNotFoundException} containing the
 813      * {@code IllegalArgumentException}.
 814      *
 815      * @param interfaces the list of interface names that were
 816      *                deserialized in the proxy class descriptor
 817      * @return  a proxy class for the specified interfaces
 818      * @throws        IOException any exception thrown by the underlying
 819      *                {@code InputStream}
 820      * @throws        ClassNotFoundException if the proxy class or any of the
 821      *                named interfaces could not be found
 822      * @see ObjectOutputStream#annotateProxyClass(Class)
 823      * @since 1.3
 824      */
 825     protected Class&lt;?&gt; resolveProxyClass(String[] interfaces)
 826         throws IOException, ClassNotFoundException
 827     {
 828         ClassLoader latestLoader = latestUserDefinedLoader();
 829         ClassLoader nonPublicLoader = null;
 830         boolean hasNonPublicInterface = false;
 831 
 832         // define proxy in class loader of non-public interface(s), if any
 833         Class&lt;?&gt;[] classObjs = new Class&lt;?&gt;[interfaces.length];
 834         for (int i = 0; i &lt; interfaces.length; i++) {
 835             Class&lt;?&gt; cl = Class.forName(interfaces[i], false, latestLoader);
 836             if ((cl.getModifiers() &amp; Modifier.PUBLIC) == 0) {
 837                 if (hasNonPublicInterface) {
 838                     if (nonPublicLoader != cl.getClassLoader()) {
 839                         throw new IllegalAccessError(
 840                             &quot;conflicting non-public interface class loaders&quot;);
 841                     }
 842                 } else {
 843                     nonPublicLoader = cl.getClassLoader();
 844                     hasNonPublicInterface = true;
 845                 }
 846             }
 847             classObjs[i] = cl;
 848         }
 849         try {
 850             @SuppressWarnings(&quot;deprecation&quot;)
 851             Class&lt;?&gt; proxyClass = Proxy.getProxyClass(
 852                 hasNonPublicInterface ? nonPublicLoader : latestLoader,
 853                 classObjs);
 854             return proxyClass;
 855         } catch (IllegalArgumentException e) {
 856             throw new ClassNotFoundException(null, e);
 857         }
 858     }
 859 
 860     /**
 861      * This method will allow trusted subclasses of ObjectInputStream to
 862      * substitute one object for another during deserialization. Replacing
 863      * objects is disabled until enableResolveObject is called. The
 864      * enableResolveObject method checks that the stream requesting to resolve
 865      * object can be trusted. Every reference to serializable objects is passed
 866      * to resolveObject.  To insure that the private state of objects is not
 867      * unintentionally exposed only trusted streams may use resolveObject.
 868      *
 869      * &lt;p&gt;This method is called after an object has been read but before it is
 870      * returned from readObject.  The default resolveObject method just returns
 871      * the same object.
 872      *
 873      * &lt;p&gt;When a subclass is replacing objects it must insure that the
 874      * substituted object is compatible with every field where the reference
 875      * will be stored.  Objects whose type is not a subclass of the type of the
 876      * field or array element abort the serialization by raising an exception
 877      * and the object is not be stored.
 878      *
 879      * &lt;p&gt;This method is called only once when each object is first
 880      * encountered.  All subsequent references to the object will be redirected
 881      * to the new object.
 882      *
 883      * @param   obj object to be substituted
 884      * @return  the substituted object
 885      * @throws  IOException Any of the usual Input/Output exceptions.
 886      */
 887     protected Object resolveObject(Object obj) throws IOException {
 888         return obj;
 889     }
 890 
 891     /**
 892      * Enables the stream to do replacement of objects read from the stream. When
 893      * enabled, the {@link #resolveObject} method is called for every object being
 894      * deserialized.
 895      *
 896      * &lt;p&gt;If object replacement is currently not enabled, and
 897      * {@code enable} is true, and there is a security manager installed,
 898      * this method first calls the security manager&#39;s
 899      * {@code checkPermission} method with the
 900      * {@code SerializablePermission(&quot;enableSubstitution&quot;)} permission to
 901      * ensure that the caller is permitted to enable the stream to do replacement
 902      * of objects read from the stream.
 903      *
 904      * @param   enable true for enabling use of {@code resolveObject} for
 905      *          every object being deserialized
 906      * @return  the previous setting before this method was invoked
 907      * @throws  SecurityException if a security manager exists and its
 908      *          {@code checkPermission} method denies enabling the stream
 909      *          to do replacement of objects read from the stream.
 910      * @see SecurityManager#checkPermission
 911      * @see java.io.SerializablePermission
 912      */
 913     protected boolean enableResolveObject(boolean enable)
 914         throws SecurityException
 915     {
 916         if (enable == enableResolve) {
 917             return enable;
 918         }
 919         if (enable) {
 920             SecurityManager sm = System.getSecurityManager();
 921             if (sm != null) {
 922                 sm.checkPermission(SUBSTITUTION_PERMISSION);
 923             }
 924         }
 925         enableResolve = enable;
 926         return !enableResolve;
 927     }
 928 
 929     /**
 930      * The readStreamHeader method is provided to allow subclasses to read and
 931      * verify their own stream headers. It reads and verifies the magic number
 932      * and version number.
 933      *
 934      * @throws  IOException if there are I/O errors while reading from the
 935      *          underlying {@code InputStream}
 936      * @throws  StreamCorruptedException if control information in the stream
 937      *          is inconsistent
 938      */
 939     protected void readStreamHeader()
 940         throws IOException, StreamCorruptedException
 941     {
 942         short s0 = bin.readShort();
 943         short s1 = bin.readShort();
 944         if (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) {
 945             throw new StreamCorruptedException(
 946                 String.format(&quot;invalid stream header: %04X%04X&quot;, s0, s1));
 947         }
 948     }
 949 
 950     /**
 951      * Read a class descriptor from the serialization stream.  This method is
 952      * called when the ObjectInputStream expects a class descriptor as the next
 953      * item in the serialization stream.  Subclasses of ObjectInputStream may
 954      * override this method to read in class descriptors that have been written
 955      * in non-standard formats (by subclasses of ObjectOutputStream which have
 956      * overridden the {@code writeClassDescriptor} method).  By default,
 957      * this method reads class descriptors according to the format defined in
 958      * the Object Serialization specification.
 959      *
 960      * @return  the class descriptor read
 961      * @throws  IOException If an I/O error has occurred.
 962      * @throws  ClassNotFoundException If the Class of a serialized object used
 963      *          in the class descriptor representation cannot be found
 964      * @see java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)
 965      * @since 1.3
 966      */
 967     protected ObjectStreamClass readClassDescriptor()
 968         throws IOException, ClassNotFoundException
 969     {
 970         ObjectStreamClass desc = new ObjectStreamClass();
 971         desc.readNonProxy(this);
 972         return desc;
 973     }
 974 
 975     /**
 976      * Reads a byte of data. This method will block if no input is available.
 977      *
 978      * @return  the byte read, or -1 if the end of the stream is reached.
 979      * @throws  IOException If an I/O error has occurred.
 980      */
 981     public int read() throws IOException {
 982         return bin.read();
 983     }
 984 
 985     /**
 986      * Reads into an array of bytes.  This method will block until some input
 987      * is available. Consider using java.io.DataInputStream.readFully to read
 988      * exactly &#39;length&#39; bytes.
 989      *
 990      * @param   buf the buffer into which the data is read
 991      * @param   off the start offset in the destination array {@code buf}
 992      * @param   len the maximum number of bytes read
 993      * @return  the actual number of bytes read, -1 is returned when the end of
 994      *          the stream is reached.
 995      * @throws  NullPointerException if {@code buf} is {@code null}.
 996      * @throws  IndexOutOfBoundsException if {@code off} is negative,
 997      *          {@code len} is negative, or {@code len} is greater than
 998      *          {@code buf.length - off}.
 999      * @throws  IOException If an I/O error has occurred.
1000      * @see java.io.DataInputStream#readFully(byte[],int,int)
1001      */
1002     public int read(byte[] buf, int off, int len) throws IOException {
1003         if (buf == null) {
1004             throw new NullPointerException();
1005         }
1006         int endoff = off + len;
1007         if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {
1008             throw new IndexOutOfBoundsException();
1009         }
1010         return bin.read(buf, off, len, false);
1011     }
1012 
1013     /**
1014      * Returns the number of bytes that can be read without blocking.
1015      *
1016      * @return  the number of available bytes.
1017      * @throws  IOException if there are I/O errors while reading from the
1018      *          underlying {@code InputStream}
1019      */
1020     public int available() throws IOException {
1021         return bin.available();
1022     }
1023 
1024     /**
1025      * Closes the input stream. Must be called to release any resources
1026      * associated with the stream.
1027      *
1028      * @throws  IOException If an I/O error has occurred.
1029      */
1030     public void close() throws IOException {
1031         /*
1032          * Even if stream already closed, propagate redundant close to
1033          * underlying stream to stay consistent with previous implementations.
1034          */
1035         closed = true;
1036         if (depth == 0) {
1037             clear();
1038         }
1039         bin.close();
1040     }
1041 
1042     /**
1043      * Reads in a boolean.
1044      *
1045      * @return  the boolean read.
1046      * @throws  EOFException If end of file is reached.
1047      * @throws  IOException If other I/O error has occurred.
1048      */
1049     public boolean readBoolean() throws IOException {
1050         return bin.readBoolean();
1051     }
1052 
1053     /**
1054      * Reads an 8 bit byte.
1055      *
1056      * @return  the 8 bit byte read.
1057      * @throws  EOFException If end of file is reached.
1058      * @throws  IOException If other I/O error has occurred.
1059      */
1060     public byte readByte() throws IOException  {
1061         return bin.readByte();
1062     }
1063 
1064     /**
1065      * Reads an unsigned 8 bit byte.
1066      *
1067      * @return  the 8 bit byte read.
1068      * @throws  EOFException If end of file is reached.
1069      * @throws  IOException If other I/O error has occurred.
1070      */
1071     public int readUnsignedByte()  throws IOException {
1072         return bin.readUnsignedByte();
1073     }
1074 
1075     /**
1076      * Reads a 16 bit char.
1077      *
1078      * @return  the 16 bit char read.
1079      * @throws  EOFException If end of file is reached.
1080      * @throws  IOException If other I/O error has occurred.
1081      */
1082     public char readChar()  throws IOException {
1083         return bin.readChar();
1084     }
1085 
1086     /**
1087      * Reads a 16 bit short.
1088      *
1089      * @return  the 16 bit short read.
1090      * @throws  EOFException If end of file is reached.
1091      * @throws  IOException If other I/O error has occurred.
1092      */
1093     public short readShort()  throws IOException {
1094         return bin.readShort();
1095     }
1096 
1097     /**
1098      * Reads an unsigned 16 bit short.
1099      *
1100      * @return  the 16 bit short read.
1101      * @throws  EOFException If end of file is reached.
1102      * @throws  IOException If other I/O error has occurred.
1103      */
1104     public int readUnsignedShort() throws IOException {
1105         return bin.readUnsignedShort();
1106     }
1107 
1108     /**
1109      * Reads a 32 bit int.
1110      *
1111      * @return  the 32 bit integer read.
1112      * @throws  EOFException If end of file is reached.
1113      * @throws  IOException If other I/O error has occurred.
1114      */
1115     public int readInt()  throws IOException {
1116         return bin.readInt();
1117     }
1118 
1119     /**
1120      * Reads a 64 bit long.
1121      *
1122      * @return  the read 64 bit long.
1123      * @throws  EOFException If end of file is reached.
1124      * @throws  IOException If other I/O error has occurred.
1125      */
1126     public long readLong()  throws IOException {
1127         return bin.readLong();
1128     }
1129 
1130     /**
1131      * Reads a 32 bit float.
1132      *
1133      * @return  the 32 bit float read.
1134      * @throws  EOFException If end of file is reached.
1135      * @throws  IOException If other I/O error has occurred.
1136      */
1137     public float readFloat() throws IOException {
1138         return bin.readFloat();
1139     }
1140 
1141     /**
1142      * Reads a 64 bit double.
1143      *
1144      * @return  the 64 bit double read.
1145      * @throws  EOFException If end of file is reached.
1146      * @throws  IOException If other I/O error has occurred.
1147      */
1148     public double readDouble() throws IOException {
1149         return bin.readDouble();
1150     }
1151 
1152     /**
1153      * Reads bytes, blocking until all bytes are read.
1154      *
1155      * @param   buf the buffer into which the data is read
1156      * @throws  NullPointerException If {@code buf} is {@code null}.
1157      * @throws  EOFException If end of file is reached.
1158      * @throws  IOException If other I/O error has occurred.
1159      */
1160     public void readFully(byte[] buf) throws IOException {
1161         bin.readFully(buf, 0, buf.length, false);
1162     }
1163 
1164     /**
1165      * Reads bytes, blocking until all bytes are read.
1166      *
1167      * @param   buf the buffer into which the data is read
1168      * @param   off the start offset into the data array {@code buf}
1169      * @param   len the maximum number of bytes to read
1170      * @throws  NullPointerException If {@code buf} is {@code null}.
1171      * @throws  IndexOutOfBoundsException If {@code off} is negative,
1172      *          {@code len} is negative, or {@code len} is greater than
1173      *          {@code buf.length - off}.
1174      * @throws  EOFException If end of file is reached.
1175      * @throws  IOException If other I/O error has occurred.
1176      */
1177     public void readFully(byte[] buf, int off, int len) throws IOException {
1178         int endoff = off + len;
1179         if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {
1180             throw new IndexOutOfBoundsException();
1181         }
1182         bin.readFully(buf, off, len, false);
1183     }
1184 
1185     /**
1186      * Skips bytes.
1187      *
1188      * @param   len the number of bytes to be skipped
1189      * @return  the actual number of bytes skipped.
1190      * @throws  IOException If an I/O error has occurred.
1191      */
1192     public int skipBytes(int len) throws IOException {
1193         return bin.skipBytes(len);
1194     }
1195 
1196     /**
1197      * Reads in a line that has been terminated by a \n, \r, \r\n or EOF.
1198      *
1199      * @return  a String copy of the line.
1200      * @throws  IOException if there are I/O errors while reading from the
1201      *          underlying {@code InputStream}
1202      * @deprecated This method does not properly convert bytes to characters.
1203      *          see DataInputStream for the details and alternatives.
1204      */
1205     @Deprecated
1206     public String readLine() throws IOException {
1207         return bin.readLine();
1208     }
1209 
1210     /**
1211      * Reads a String in
1212      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
1213      * format.
1214      *
1215      * @return  the String.
1216      * @throws  IOException if there are I/O errors while reading from the
1217      *          underlying {@code InputStream}
1218      * @throws  UTFDataFormatException if read bytes do not represent a valid
1219      *          modified UTF-8 encoding of a string
1220      */
1221     public String readUTF() throws IOException {
1222         return bin.readUTF();
1223     }
1224 
1225     /**
1226      * Returns the serialization filter for this stream.
1227      * The serialization filter is the most recent filter set in
1228      * {@link #setObjectInputFilter setObjectInputFilter} or
1229      * the initial system-wide filter from
1230      * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}.
1231      *
1232      * @return the serialization filter for the stream; may be null
1233      * @since 9
1234      */
1235     public final ObjectInputFilter getObjectInputFilter() {
1236         return serialFilter;
1237     }
1238 
1239     /**
1240      * Set the serialization filter for the stream.
1241      * The filter&#39;s {@link ObjectInputFilter#checkInput checkInput} method is called
1242      * for each class and reference in the stream.
1243      * The filter can check any or all of the class, the array length, the number
1244      * of references, the depth of the graph, and the size of the input stream.
1245      * The depth is the number of nested {@linkplain #readObject readObject}
1246      * calls starting with the reading of the root of the graph being deserialized
1247      * and the current object being deserialized.
1248      * The number of references is the cumulative number of objects and references
1249      * to objects already read from the stream including the current object being read.
1250      * The filter is invoked only when reading objects from the stream and for
1251      * not primitives.
1252      * &lt;p&gt;
1253      * If the filter returns {@link ObjectInputFilter.Status#REJECTED Status.REJECTED},
1254      * {@code null} or throws a {@link RuntimeException},
1255      * the active {@code readObject} or {@code readUnshared}
1256      * throws {@link InvalidClassException}, otherwise deserialization
1257      * continues uninterrupted.
1258      * &lt;p&gt;
1259      * The serialization filter is initialized to the value of
1260      * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}
1261      * when the {@code  ObjectInputStream} is constructed and can be set
1262      * to a custom filter only once.
1263      *
1264      * @implSpec
1265      * The filter, when not {@code null}, is invoked during {@link #readObject readObject}
1266      * and {@link #readUnshared readUnshared} for each object (regular or class) in the stream.
1267      * Strings are treated as primitives and do not invoke the filter.
1268      * The filter is called for:
1269      * &lt;ul&gt;
1270      *     &lt;li&gt;each object reference previously deserialized from the stream
1271      *     (class is {@code null}, arrayLength is -1),
1272      *     &lt;li&gt;each regular class (class is not {@code null}, arrayLength is -1),
1273      *     &lt;li&gt;each interface of a dynamic proxy and the dynamic proxy class itself
1274      *     (class is not {@code null}, arrayLength is -1),
1275      *     &lt;li&gt;each array is filtered using the array type and length of the array
1276      *     (class is the array type, arrayLength is the requested length),
1277      *     &lt;li&gt;each object replaced by its class&#39; {@code readResolve} method
1278      *         is filtered using the replacement object&#39;s class, if not {@code null},
1279      *         and if it is an array, the arrayLength, otherwise -1,
1280      *     &lt;li&gt;and each object replaced by {@link #resolveObject resolveObject}
1281      *         is filtered using the replacement object&#39;s class, if not {@code null},
1282      *         and if it is an array, the arrayLength, otherwise -1.
1283      * &lt;/ul&gt;
1284      *
1285      * When the {@link ObjectInputFilter#checkInput checkInput} method is invoked
1286      * it is given access to the current class, the array length,
1287      * the current number of references already read from the stream,
1288      * the depth of nested calls to {@link #readObject readObject} or
1289      * {@link #readUnshared readUnshared},
1290      * and the implementation dependent number of bytes consumed from the input stream.
1291      * &lt;p&gt;
1292      * Each call to {@link #readObject readObject} or
1293      * {@link #readUnshared readUnshared} increases the depth by 1
1294      * before reading an object and decreases by 1 before returning
1295      * normally or exceptionally.
1296      * The depth starts at {@code 1} and increases for each nested object and
1297      * decrements when each nested call returns.
1298      * The count of references in the stream starts at {@code 1} and
1299      * is increased before reading an object.
1300      *
1301      * @param filter the filter, may be null
1302      * @throws SecurityException if there is security manager and the
1303      *       {@code SerializablePermission(&quot;serialFilter&quot;)} is not granted
1304      * @throws IllegalStateException if the {@linkplain #getObjectInputFilter() current filter}
1305      *       is not {@code null} and is not the system-wide filter
1306      * @since 9
1307      */
1308     public final void setObjectInputFilter(ObjectInputFilter filter) {
1309         SecurityManager sm = System.getSecurityManager();
1310         if (sm != null) {
1311             sm.checkPermission(ObjectStreamConstants.SERIAL_FILTER_PERMISSION);
1312         }
1313         // Allow replacement of the system-wide filter if not already set
1314         if (serialFilter != null &amp;&amp;
1315                 serialFilter != ObjectInputFilter.Config.getSerialFilter()) {
1316             throw new IllegalStateException(&quot;filter can not be set more than once&quot;);
1317         }
1318         this.serialFilter = filter;
1319     }
1320 
1321     /**
1322      * Invoke the serialization filter if non-null.
1323      * If the filter rejects or an exception is thrown, throws InvalidClassException.
1324      *
1325      * @param clazz the class; may be null
1326      * @param arrayLength the array length requested; use {@code -1} if not creating an array
1327      * @throws InvalidClassException if it rejected by the filter or
1328      *        a {@link RuntimeException} is thrown
1329      */
1330     private void filterCheck(Class&lt;?&gt; clazz, int arrayLength)
1331             throws InvalidClassException {
1332         if (serialFilter != null) {
1333             RuntimeException ex = null;
1334             ObjectInputFilter.Status status;
1335             // Info about the stream is not available if overridden by subclass, return 0
1336             long bytesRead = (bin == null) ? 0 : bin.getBytesRead();
1337             try {
1338                 status = serialFilter.checkInput(new FilterValues(clazz, arrayLength,
1339                         totalObjectRefs, depth, bytesRead));
1340             } catch (RuntimeException e) {
1341                 // Preventive interception of an exception to log
1342                 status = ObjectInputFilter.Status.REJECTED;
1343                 ex = e;
1344             }
1345             if (Logging.filterLogger != null) {
1346                 // Debug logging of filter checks that fail; Tracing for those that succeed
1347                 Logging.filterLogger.log(status == null || status == ObjectInputFilter.Status.REJECTED
1348                                 ? Logger.Level.DEBUG
1349                                 : Logger.Level.TRACE,
1350                         &quot;ObjectInputFilter {0}: {1}, array length: {2}, nRefs: {3}, depth: {4}, bytes: {5}, ex: {6}&quot;,
1351                         status, clazz, arrayLength, totalObjectRefs, depth, bytesRead,
1352                         Objects.toString(ex, &quot;n/a&quot;));
1353             }
1354             if (status == null ||
1355                     status == ObjectInputFilter.Status.REJECTED) {
1356                 InvalidClassException ice = new InvalidClassException(&quot;filter status: &quot; + status);
1357                 ice.initCause(ex);
1358                 throw ice;
1359             }
1360         }
1361     }
1362 
1363     /**
1364      * Checks the given array type and length to ensure that creation of such
1365      * an array is permitted by this ObjectInputStream. The arrayType argument
1366      * must represent an actual array type.
1367      *
1368      * This private method is called via SharedSecrets.
1369      *
1370      * @param arrayType the array type
1371      * @param arrayLength the array length
1372      * @throws NullPointerException if arrayType is null
1373      * @throws IllegalArgumentException if arrayType isn&#39;t actually an array type
1374      * @throws NegativeArraySizeException if arrayLength is negative
1375      * @throws InvalidClassException if the filter rejects creation
1376      */
1377     private void checkArray(Class&lt;?&gt; arrayType, int arrayLength) throws InvalidClassException {
1378         if (! arrayType.isArray()) {
1379             throw new IllegalArgumentException(&quot;not an array type&quot;);
1380         }
1381 
1382         if (arrayLength &lt; 0) {
1383             throw new NegativeArraySizeException();
1384         }
1385 
1386         filterCheck(arrayType, arrayLength);
1387     }
1388 
1389     /**
1390      * Provide access to the persistent fields read from the input stream.
1391      */
1392     public abstract static class GetField {
1393         /**
1394          * Constructor for subclasses to call.
1395          */
1396         public GetField() {}
1397 
1398         /**
1399          * Get the ObjectStreamClass that describes the fields in the stream.
1400          *
1401          * @return  the descriptor class that describes the serializable fields
1402          */
1403         public abstract ObjectStreamClass getObjectStreamClass();
1404 
1405         /**
1406          * Return true if the named field is defaulted and has no value in this
1407          * stream.
1408          *
1409          * @param  name the name of the field
1410          * @return true, if and only if the named field is defaulted
1411          * @throws IOException if there are I/O errors while reading from
1412          *         the underlying {@code InputStream}
1413          * @throws IllegalArgumentException if {@code name} does not
1414          *         correspond to a serializable field
1415          */
1416         public abstract boolean defaulted(String name) throws IOException;
1417 
1418         /**
1419          * Get the value of the named boolean field from the persistent field.
1420          *
1421          * @param  name the name of the field
1422          * @param  val the default value to use if {@code name} does not
1423          *         have a value
1424          * @return the value of the named {@code boolean} field
1425          * @throws IOException if there are I/O errors while reading from the
1426          *         underlying {@code InputStream}
1427          * @throws IllegalArgumentException if type of {@code name} is
1428          *         not serializable or if the field type is incorrect
1429          */
1430         public abstract boolean get(String name, boolean val)
1431             throws IOException;
1432 
1433         /**
1434          * Get the value of the named byte field from the persistent field.
1435          *
1436          * @param  name the name of the field
1437          * @param  val the default value to use if {@code name} does not
1438          *         have a value
1439          * @return the value of the named {@code byte} field
1440          * @throws IOException if there are I/O errors while reading from the
1441          *         underlying {@code InputStream}
1442          * @throws IllegalArgumentException if type of {@code name} is
1443          *         not serializable or if the field type is incorrect
1444          */
1445         public abstract byte get(String name, byte val) throws IOException;
1446 
1447         /**
1448          * Get the value of the named char field from the persistent field.
1449          *
1450          * @param  name the name of the field
1451          * @param  val the default value to use if {@code name} does not
1452          *         have a value
1453          * @return the value of the named {@code char} field
1454          * @throws IOException if there are I/O errors while reading from the
1455          *         underlying {@code InputStream}
1456          * @throws IllegalArgumentException if type of {@code name} is
1457          *         not serializable or if the field type is incorrect
1458          */
1459         public abstract char get(String name, char val) throws IOException;
1460 
1461         /**
1462          * Get the value of the named short field from the persistent field.
1463          *
1464          * @param  name the name of the field
1465          * @param  val the default value to use if {@code name} does not
1466          *         have a value
1467          * @return the value of the named {@code short} field
1468          * @throws IOException if there are I/O errors while reading from the
1469          *         underlying {@code InputStream}
1470          * @throws IllegalArgumentException if type of {@code name} is
1471          *         not serializable or if the field type is incorrect
1472          */
1473         public abstract short get(String name, short val) throws IOException;
1474 
1475         /**
1476          * Get the value of the named int field from the persistent field.
1477          *
1478          * @param  name the name of the field
1479          * @param  val the default value to use if {@code name} does not
1480          *         have a value
1481          * @return the value of the named {@code int} field
1482          * @throws IOException if there are I/O errors while reading from the
1483          *         underlying {@code InputStream}
1484          * @throws IllegalArgumentException if type of {@code name} is
1485          *         not serializable or if the field type is incorrect
1486          */
1487         public abstract int get(String name, int val) throws IOException;
1488 
1489         /**
1490          * Get the value of the named long field from the persistent field.
1491          *
1492          * @param  name the name of the field
1493          * @param  val the default value to use if {@code name} does not
1494          *         have a value
1495          * @return the value of the named {@code long} field
1496          * @throws IOException if there are I/O errors while reading from the
1497          *         underlying {@code InputStream}
1498          * @throws IllegalArgumentException if type of {@code name} is
1499          *         not serializable or if the field type is incorrect
1500          */
1501         public abstract long get(String name, long val) throws IOException;
1502 
1503         /**
1504          * Get the value of the named float field from the persistent field.
1505          *
1506          * @param  name the name of the field
1507          * @param  val the default value to use if {@code name} does not
1508          *         have a value
1509          * @return the value of the named {@code float} field
1510          * @throws IOException if there are I/O errors while reading from the
1511          *         underlying {@code InputStream}
1512          * @throws IllegalArgumentException if type of {@code name} is
1513          *         not serializable or if the field type is incorrect
1514          */
1515         public abstract float get(String name, float val) throws IOException;
1516 
1517         /**
1518          * Get the value of the named double field from the persistent field.
1519          *
1520          * @param  name the name of the field
1521          * @param  val the default value to use if {@code name} does not
1522          *         have a value
1523          * @return the value of the named {@code double} field
1524          * @throws IOException if there are I/O errors while reading from the
1525          *         underlying {@code InputStream}
1526          * @throws IllegalArgumentException if type of {@code name} is
1527          *         not serializable or if the field type is incorrect
1528          */
1529         public abstract double get(String name, double val) throws IOException;
1530 
1531         /**
1532          * Get the value of the named Object field from the persistent field.
1533          *
1534          * @param  name the name of the field
1535          * @param  val the default value to use if {@code name} does not
1536          *         have a value
1537          * @return the value of the named {@code Object} field
1538          * @throws IOException if there are I/O errors while reading from the
1539          *         underlying {@code InputStream}
1540          * @throws IllegalArgumentException if type of {@code name} is
1541          *         not serializable or if the field type is incorrect
1542          */
1543         public abstract Object get(String name, Object val) throws IOException;
1544     }
1545 
1546     /**
1547      * Verifies that this (possibly subclass) instance can be constructed
1548      * without violating security constraints: the subclass must not override
1549      * security-sensitive non-final methods, or else the
1550      * &quot;enableSubclassImplementation&quot; SerializablePermission is checked.
1551      */
1552     private void verifySubclass() {
1553         Class&lt;?&gt; cl = getClass();
1554         if (cl == ObjectInputStream.class) {
1555             return;
1556         }
1557         SecurityManager sm = System.getSecurityManager();
1558         if (sm == null) {
1559             return;
1560         }
1561         processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);
1562         WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);
1563         Boolean result = Caches.subclassAudits.get(key);
1564         if (result == null) {
1565             result = auditSubclass(cl);
1566             Caches.subclassAudits.putIfAbsent(key, result);
1567         }
1568         if (!result) {
1569             sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
1570         }
1571     }
1572 
1573     /**
1574      * Performs reflective checks on given subclass to verify that it doesn&#39;t
1575      * override security-sensitive non-final methods.  Returns TRUE if subclass
1576      * is &quot;safe&quot;, FALSE otherwise.
1577      */
1578     private static Boolean auditSubclass(Class&lt;?&gt; subcl) {
1579         return AccessController.doPrivileged(
1580             new PrivilegedAction&lt;Boolean&gt;() {
1581                 public Boolean run() {
1582                     for (Class&lt;?&gt; cl = subcl;
1583                          cl != ObjectInputStream.class;
1584                          cl = cl.getSuperclass())
1585                     {
1586                         try {
1587                             cl.getDeclaredMethod(
1588                                 &quot;readUnshared&quot;, (Class[]) null);
1589                             return Boolean.FALSE;
1590                         } catch (NoSuchMethodException ex) {
1591                         }
1592                         try {
1593                             cl.getDeclaredMethod(&quot;readFields&quot;, (Class[]) null);
1594                             return Boolean.FALSE;
1595                         } catch (NoSuchMethodException ex) {
1596                         }
1597                     }
1598                     return Boolean.TRUE;
1599                 }
1600             }
1601         );
1602     }
1603 
1604     /**
1605      * Clears internal data structures.
1606      */
1607     private void clear() {
1608         handles.clear();
1609         vlist.clear();
1610     }
1611 
1612     /**
1613      * Underlying readObject implementation.
1614      * @param type a type expected to be deserialized; non-null
1615      * @param unshared true if the object can not be a reference to a shared object, otherwise false
1616      */
1617     private Object readObject0(Class&lt;?&gt; type, boolean unshared) throws IOException {
1618         boolean oldMode = bin.getBlockDataMode();
1619         if (oldMode) {
1620             int remain = bin.currentBlockRemaining();
1621             if (remain &gt; 0) {
1622                 throw new OptionalDataException(remain);
1623             } else if (defaultDataEnd) {
1624                 /*
1625                  * Fix for 4360508: stream is currently at the end of a field
1626                  * value block written via default serialization; since there
1627                  * is no terminating TC_ENDBLOCKDATA tag, simulate
1628                  * end-of-custom-data behavior explicitly.
1629                  */
1630                 throw new OptionalDataException(true);
1631             }
1632             bin.setBlockDataMode(false);
1633         }
1634 
1635         byte tc;
1636         while ((tc = bin.peekByte()) == TC_RESET) {
1637             bin.readByte();
1638             handleReset();
1639         }
1640 
1641         depth++;
1642         totalObjectRefs++;
1643         try {
1644             switch (tc) {
1645                 case TC_NULL:
1646                     return readNull();
1647 
1648                 case TC_REFERENCE:
1649                     // check the type of the existing object
1650                     return type.cast(readHandle(unshared));
1651 
1652                 case TC_CLASS:
1653                     if (type == String.class) {
1654                         throw new ClassCastException(&quot;Cannot cast a class to java.lang.String&quot;);
1655                     }
1656                     return readClass(unshared);
1657 
1658                 case TC_CLASSDESC:
1659                 case TC_PROXYCLASSDESC:
1660                     if (type == String.class) {
1661                         throw new ClassCastException(&quot;Cannot cast a class to java.lang.String&quot;);
1662                     }
1663                     return readClassDesc(unshared);
1664 
1665                 case TC_STRING:
1666                 case TC_LONGSTRING:
1667                     return checkResolve(readString(unshared));
1668 
1669                 case TC_ARRAY:
1670                     if (type == String.class) {
1671                         throw new ClassCastException(&quot;Cannot cast an array to java.lang.String&quot;);
1672                     }
1673                     return checkResolve(readArray(unshared));
1674 
1675                 case TC_ENUM:
1676                     if (type == String.class) {
1677                         throw new ClassCastException(&quot;Cannot cast an enum to java.lang.String&quot;);
1678                     }
1679                     return checkResolve(readEnum(unshared));
1680 
1681                 case TC_OBJECT:
1682                     if (type == String.class) {
1683                         throw new ClassCastException(&quot;Cannot cast an object to java.lang.String&quot;);
1684                     }
1685                     return checkResolve(readOrdinaryObject(unshared));
1686 
1687                 case TC_EXCEPTION:
1688                     if (type == String.class) {
1689                         throw new ClassCastException(&quot;Cannot cast an exception to java.lang.String&quot;);
1690                     }
1691                     IOException ex = readFatalException();
1692                     throw new WriteAbortedException(&quot;writing aborted&quot;, ex);
1693 
1694                 case TC_BLOCKDATA:
1695                 case TC_BLOCKDATALONG:
1696                     if (oldMode) {
1697                         bin.setBlockDataMode(true);
1698                         bin.peek();             // force header read
1699                         throw new OptionalDataException(
1700                             bin.currentBlockRemaining());
1701                     } else {
1702                         throw new StreamCorruptedException(
1703                             &quot;unexpected block data&quot;);
1704                     }
1705 
1706                 case TC_ENDBLOCKDATA:
1707                     if (oldMode) {
1708                         throw new OptionalDataException(true);
1709                     } else {
1710                         throw new StreamCorruptedException(
1711                             &quot;unexpected end of block data&quot;);
1712                     }
1713 
1714                 default:
1715                     throw new StreamCorruptedException(
1716                         String.format(&quot;invalid type code: %02X&quot;, tc));
1717             }
1718         } finally {
1719             depth--;
1720             bin.setBlockDataMode(oldMode);
1721         }
1722     }
1723 
1724     /**
1725      * If resolveObject has been enabled and given object does not have an
1726      * exception associated with it, calls resolveObject to determine
1727      * replacement for object, and updates handle table accordingly.  Returns
1728      * replacement object, or echoes provided object if no replacement
1729      * occurred.  Expects that passHandle is set to given object&#39;s handle prior
1730      * to calling this method.
1731      */
1732     private Object checkResolve(Object obj) throws IOException {
1733         if (!enableResolve || handles.lookupException(passHandle) != null) {
1734             return obj;
1735         }
1736         Object rep = resolveObject(obj);
1737         if (rep != obj) {
1738             // The type of the original object has been filtered but resolveObject
1739             // may have replaced it;  filter the replacement&#39;s type
1740             if (rep != null) {
1741                 if (rep.getClass().isArray()) {
1742                     filterCheck(rep.getClass(), Array.getLength(rep));
1743                 } else {
1744                     filterCheck(rep.getClass(), -1);
1745                 }
1746             }
1747             handles.setObject(passHandle, rep);
1748         }
1749         return rep;
1750     }
1751 
1752     /**
1753      * Reads string without allowing it to be replaced in stream.  Called from
1754      * within ObjectStreamClass.read().
1755      */
1756     String readTypeString() throws IOException {
1757         int oldHandle = passHandle;
1758         try {
1759             byte tc = bin.peekByte();
1760             switch (tc) {
1761                 case TC_NULL:
1762                     return (String) readNull();
1763 
1764                 case TC_REFERENCE:
1765                     return (String) readHandle(false);
1766 
1767                 case TC_STRING:
1768                 case TC_LONGSTRING:
1769                     return readString(false);
1770 
1771                 default:
1772                     throw new StreamCorruptedException(
1773                         String.format(&quot;invalid type code: %02X&quot;, tc));
1774             }
1775         } finally {
1776             passHandle = oldHandle;
1777         }
1778     }
1779 
1780     /**
1781      * Reads in null code, sets passHandle to NULL_HANDLE and returns null.
1782      */
1783     private Object readNull() throws IOException {
1784         if (bin.readByte() != TC_NULL) {
1785             throw new InternalError();
1786         }
1787         passHandle = NULL_HANDLE;
1788         return null;
1789     }
1790 
1791     /**
1792      * Reads in object handle, sets passHandle to the read handle, and returns
1793      * object associated with the handle.
1794      */
1795     private Object readHandle(boolean unshared) throws IOException {
1796         if (bin.readByte() != TC_REFERENCE) {
1797             throw new InternalError();
1798         }
1799         passHandle = bin.readInt() - baseWireHandle;
1800         if (passHandle &lt; 0 || passHandle &gt;= handles.size()) {
1801             throw new StreamCorruptedException(
1802                 String.format(&quot;invalid handle value: %08X&quot;, passHandle +
1803                 baseWireHandle));
1804         }
1805         if (unshared) {
1806             // REMIND: what type of exception to throw here?
1807             throw new InvalidObjectException(
1808                 &quot;cannot read back reference as unshared&quot;);
1809         }
1810 
1811         Object obj = handles.lookupObject(passHandle);
1812         if (obj == unsharedMarker) {
1813             // REMIND: what type of exception to throw here?
1814             throw new InvalidObjectException(
1815                 &quot;cannot read back reference to unshared object&quot;);
1816         }
1817         filterCheck(null, -1);       // just a check for number of references, depth, no class
1818         return obj;
1819     }
1820 
1821     /**
1822      * Reads in and returns class object.  Sets passHandle to class object&#39;s
1823      * assigned handle.  Returns null if class is unresolvable (in which case a
1824      * ClassNotFoundException will be associated with the class&#39; handle in the
1825      * handle table).
1826      */
1827     private Class&lt;?&gt; readClass(boolean unshared) throws IOException {
1828         if (bin.readByte() != TC_CLASS) {
1829             throw new InternalError();
1830         }
1831         ObjectStreamClass desc = readClassDesc(false);
1832         Class&lt;?&gt; cl = desc.forClass();
1833         passHandle = handles.assign(unshared ? unsharedMarker : cl);
1834 
1835         ClassNotFoundException resolveEx = desc.getResolveException();
1836         if (resolveEx != null) {
1837             handles.markException(passHandle, resolveEx);
1838         }
1839 
1840         handles.finish(passHandle);
1841         return cl;
1842     }
1843 
1844     /**
1845      * Reads in and returns (possibly null) class descriptor.  Sets passHandle
1846      * to class descriptor&#39;s assigned handle.  If class descriptor cannot be
1847      * resolved to a class in the local VM, a ClassNotFoundException is
1848      * associated with the class descriptor&#39;s handle.
1849      */
1850     private ObjectStreamClass readClassDesc(boolean unshared)
1851         throws IOException
1852     {
1853         byte tc = bin.peekByte();
1854         ObjectStreamClass descriptor;
1855         switch (tc) {
1856             case TC_NULL:
1857                 descriptor = (ObjectStreamClass) readNull();
1858                 break;
1859             case TC_REFERENCE:
1860                 descriptor = (ObjectStreamClass) readHandle(unshared);
1861                 // Should only reference initialized class descriptors
1862                 descriptor.checkInitialized();
1863                 break;
1864             case TC_PROXYCLASSDESC:
1865                 descriptor = readProxyDesc(unshared);
1866                 break;
1867             case TC_CLASSDESC:
1868                 descriptor = readNonProxyDesc(unshared);
1869                 break;
1870             default:
1871                 throw new StreamCorruptedException(
1872                     String.format(&quot;invalid type code: %02X&quot;, tc));
1873         }
1874         return descriptor;
1875     }
1876 
1877     private boolean isCustomSubclass() {
1878         // Return true if this class is a custom subclass of ObjectInputStream
1879         return getClass().getClassLoader()
1880                     != ObjectInputStream.class.getClassLoader();
1881     }
1882 
1883     /**
1884      * Reads in and returns class descriptor for a dynamic proxy class.  Sets
1885      * passHandle to proxy class descriptor&#39;s assigned handle.  If proxy class
1886      * descriptor cannot be resolved to a class in the local VM, a
1887      * ClassNotFoundException is associated with the descriptor&#39;s handle.
1888      */
1889     private ObjectStreamClass readProxyDesc(boolean unshared)
1890         throws IOException
1891     {
1892         if (bin.readByte() != TC_PROXYCLASSDESC) {
1893             throw new InternalError();
1894         }
1895 
1896         ObjectStreamClass desc = new ObjectStreamClass();
1897         int descHandle = handles.assign(unshared ? unsharedMarker : desc);
1898         passHandle = NULL_HANDLE;
1899 
1900         int numIfaces = bin.readInt();
1901         if (numIfaces &gt; 65535) {
1902             throw new InvalidObjectException(&quot;interface limit exceeded: &quot;
1903                     + numIfaces);
1904         }
1905         String[] ifaces = new String[numIfaces];
1906         for (int i = 0; i &lt; numIfaces; i++) {
1907             ifaces[i] = bin.readUTF();
1908         }
1909 
1910         Class&lt;?&gt; cl = null;
1911         ClassNotFoundException resolveEx = null;
1912         bin.setBlockDataMode(true);
1913         try {
1914             if ((cl = resolveProxyClass(ifaces)) == null) {
1915                 resolveEx = new ClassNotFoundException(&quot;null class&quot;);
1916             } else if (!Proxy.isProxyClass(cl)) {
1917                 throw new InvalidClassException(&quot;Not a proxy&quot;);
1918             } else {
1919                 // ReflectUtil.checkProxyPackageAccess makes a test
1920                 // equivalent to isCustomSubclass so there&#39;s no need
1921                 // to condition this call to isCustomSubclass == true here.
1922                 ReflectUtil.checkProxyPackageAccess(
1923                         getClass().getClassLoader(),
1924                         cl.getInterfaces());
1925                 // Filter the interfaces
1926                 for (Class&lt;?&gt; clazz : cl.getInterfaces()) {
1927                     filterCheck(clazz, -1);
1928                 }
1929             }
1930         } catch (ClassNotFoundException ex) {
1931             resolveEx = ex;
1932         }
1933 
1934         // Call filterCheck on the class before reading anything else
1935         filterCheck(cl, -1);
1936 
1937         skipCustomData();
1938 
1939         try {
1940             totalObjectRefs++;
1941             depth++;
1942             desc.initProxy(cl, resolveEx, readClassDesc(false));
1943         } finally {
1944             depth--;
1945         }
1946 
1947         handles.finish(descHandle);
1948         passHandle = descHandle;
1949         return desc;
1950     }
1951 
1952     /**
1953      * Reads in and returns class descriptor for a class that is not a dynamic
1954      * proxy class.  Sets passHandle to class descriptor&#39;s assigned handle.  If
1955      * class descriptor cannot be resolved to a class in the local VM, a
1956      * ClassNotFoundException is associated with the descriptor&#39;s handle.
1957      */
1958     private ObjectStreamClass readNonProxyDesc(boolean unshared)
1959         throws IOException
1960     {
1961         if (bin.readByte() != TC_CLASSDESC) {
1962             throw new InternalError();
1963         }
1964 
1965         ObjectStreamClass desc = new ObjectStreamClass();
1966         int descHandle = handles.assign(unshared ? unsharedMarker : desc);
1967         passHandle = NULL_HANDLE;
1968 
1969         ObjectStreamClass readDesc;
1970         try {
1971             readDesc = readClassDescriptor();
1972         } catch (ClassNotFoundException ex) {
1973             throw (IOException) new InvalidClassException(
1974                 &quot;failed to read class descriptor&quot;).initCause(ex);
1975         }
1976 
1977         Class&lt;?&gt; cl = null;
1978         ClassNotFoundException resolveEx = null;
1979         bin.setBlockDataMode(true);
1980         final boolean checksRequired = isCustomSubclass();
1981         try {
1982             if ((cl = resolveClass(readDesc)) == null) {
1983                 resolveEx = new ClassNotFoundException(&quot;null class&quot;);
1984             } else if (checksRequired) {
1985                 ReflectUtil.checkPackageAccess(cl);
1986             }
1987         } catch (ClassNotFoundException ex) {
1988             resolveEx = ex;
1989         }
1990 
1991         // Call filterCheck on the class before reading anything else
1992         filterCheck(cl, -1);
1993 
1994         skipCustomData();
1995 
1996         try {
1997             totalObjectRefs++;
1998             depth++;
1999             desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));
2000         } finally {
2001             depth--;
2002         }
2003 
2004         handles.finish(descHandle);
2005         passHandle = descHandle;
2006 
2007         return desc;
2008     }
2009 
2010     /**
2011      * Reads in and returns new string.  Sets passHandle to new string&#39;s
2012      * assigned handle.
2013      */
2014     private String readString(boolean unshared) throws IOException {
2015         String str;
2016         byte tc = bin.readByte();
2017         switch (tc) {
2018             case TC_STRING:
2019                 str = bin.readUTF();
2020                 break;
2021 
2022             case TC_LONGSTRING:
2023                 str = bin.readLongUTF();
2024                 break;
2025 
2026             default:
2027                 throw new StreamCorruptedException(
2028                     String.format(&quot;invalid type code: %02X&quot;, tc));
2029         }
2030         passHandle = handles.assign(unshared ? unsharedMarker : str);
2031         handles.finish(passHandle);
2032         return str;
2033     }
2034 
2035     /**
2036      * Reads in and returns array object, or null if array class is
2037      * unresolvable.  Sets passHandle to array&#39;s assigned handle.
2038      */
2039     private Object readArray(boolean unshared) throws IOException {
2040         if (bin.readByte() != TC_ARRAY) {
2041             throw new InternalError();
2042         }
2043 
2044         ObjectStreamClass desc = readClassDesc(false);
2045         int len = bin.readInt();
2046 
2047         filterCheck(desc.forClass(), len);
2048 
2049         Object array = null;
2050         Class&lt;?&gt; cl, ccl = null;
2051         if ((cl = desc.forClass()) != null) {
2052             ccl = cl.getComponentType();
2053             array = Array.newInstance(ccl, len);
2054         }
2055 
2056         int arrayHandle = handles.assign(unshared ? unsharedMarker : array);
2057         ClassNotFoundException resolveEx = desc.getResolveException();
2058         if (resolveEx != null) {
2059             handles.markException(arrayHandle, resolveEx);
2060         }
2061 
2062         if (ccl == null) {
2063             for (int i = 0; i &lt; len; i++) {
2064                 readObject0(Object.class, false);
2065             }
2066         } else if (ccl.isPrimitive()) {
2067             if (ccl == Integer.TYPE) {
2068                 bin.readInts((int[]) array, 0, len);
2069             } else if (ccl == Byte.TYPE) {
2070                 bin.readFully((byte[]) array, 0, len, true);
2071             } else if (ccl == Long.TYPE) {
2072                 bin.readLongs((long[]) array, 0, len);
2073             } else if (ccl == Float.TYPE) {
2074                 bin.readFloats((float[]) array, 0, len);
2075             } else if (ccl == Double.TYPE) {
2076                 bin.readDoubles((double[]) array, 0, len);
2077             } else if (ccl == Short.TYPE) {
2078                 bin.readShorts((short[]) array, 0, len);
2079             } else if (ccl == Character.TYPE) {
2080                 bin.readChars((char[]) array, 0, len);
2081             } else if (ccl == Boolean.TYPE) {
2082                 bin.readBooleans((boolean[]) array, 0, len);
2083             } else {
2084                 throw new InternalError();
2085             }
2086         } else {
2087             Object[] oa = (Object[]) array;
2088             for (int i = 0; i &lt; len; i++) {
2089                 oa[i] = readObject0(Object.class, false);
2090                 handles.markDependency(arrayHandle, passHandle);
2091             }
2092         }
2093 
2094         handles.finish(arrayHandle);
2095         passHandle = arrayHandle;
2096         return array;
2097     }
2098 
2099     /**
2100      * Reads in and returns enum constant, or null if enum type is
2101      * unresolvable.  Sets passHandle to enum constant&#39;s assigned handle.
2102      */
2103     private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException {
2104         if (bin.readByte() != TC_ENUM) {
2105             throw new InternalError();
2106         }
2107 
2108         ObjectStreamClass desc = readClassDesc(false);
2109         if (!desc.isEnum()) {
2110             throw new InvalidClassException(&quot;non-enum class: &quot; + desc);
2111         }
2112 
2113         int enumHandle = handles.assign(unshared ? unsharedMarker : null);
2114         ClassNotFoundException resolveEx = desc.getResolveException();
2115         if (resolveEx != null) {
2116             handles.markException(enumHandle, resolveEx);
2117         }
2118 
2119         String name = readString(false);
2120         Enum&lt;?&gt; result = null;
2121         Class&lt;?&gt; cl = desc.forClass();
2122         if (cl != null) {
2123             try {
2124                 @SuppressWarnings(&quot;unchecked&quot;)
2125                 Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);
2126                 result = en;
2127             } catch (IllegalArgumentException ex) {
2128                 throw (IOException) new InvalidObjectException(
2129                     &quot;enum constant &quot; + name + &quot; does not exist in &quot; +
2130                     cl).initCause(ex);
2131             }
2132             if (!unshared) {
2133                 handles.setObject(enumHandle, result);
2134             }
2135         }
2136 
2137         handles.finish(enumHandle);
2138         passHandle = enumHandle;
2139         return result;
2140     }
2141 
2142     @SuppressWarnings(&quot;preview&quot;)
2143     private static boolean isRecord(Class&lt;?&gt; cls) {
2144         return cls.isRecord();
2145     }
2146 
2147     /**
2148      * Reads and returns &quot;ordinary&quot; (i.e., not a String, Class,
2149      * ObjectStreamClass, array, or enum constant) object, or null if object&#39;s
2150      * class is unresolvable (in which case a ClassNotFoundException will be
2151      * associated with object&#39;s handle).  Sets passHandle to object&#39;s assigned
2152      * handle.
2153      */
2154     private Object readOrdinaryObject(boolean unshared)
2155         throws IOException
2156     {
2157         if (bin.readByte() != TC_OBJECT) {
2158             throw new InternalError();
2159         }
2160 
2161         ObjectStreamClass desc = readClassDesc(false);
2162         desc.checkDeserialize();
2163 
2164         Class&lt;?&gt; cl = desc.forClass();
2165         if (cl == String.class || cl == Class.class
2166                 || cl == ObjectStreamClass.class) {
2167             throw new InvalidClassException(&quot;invalid class descriptor&quot;);
2168         }
2169 
2170         Object obj;
2171         try {
2172             obj = desc.isInstantiable() ? desc.newInstance() : null;
2173         } catch (Exception ex) {
2174             throw (IOException) new InvalidClassException(
2175                 desc.forClass().getName(),
2176                 &quot;unable to create instance&quot;).initCause(ex);
2177         }
2178 
2179         passHandle = handles.assign(unshared ? unsharedMarker : obj);
2180         ClassNotFoundException resolveEx = desc.getResolveException();
2181         if (resolveEx != null) {
2182             handles.markException(passHandle, resolveEx);
2183         }
2184 
2185         final boolean isRecord = cl != null &amp;&amp; isRecord(cl) ? true : false;
2186         if (isRecord) {
2187             assert obj == null;
2188             obj = readRecord(desc);
2189             handles.setObject(passHandle, obj);
2190         } else if (desc.isExternalizable()) {
2191             readExternalData((Externalizable) obj, desc);
2192         } else {
2193             readSerialData(obj, desc);
2194         }
2195 
2196         handles.finish(passHandle);
2197 
2198         if (obj != null &amp;&amp;
2199             handles.lookupException(passHandle) == null &amp;&amp;
2200             desc.hasReadResolveMethod())
2201         {
2202             Object rep = desc.invokeReadResolve(obj);
2203             if (unshared &amp;&amp; rep.getClass().isArray()) {
2204                 rep = cloneArray(rep);
2205             }
2206             if (rep != obj) {
2207                 // Filter the replacement object
2208                 if (rep != null) {
2209                     if (rep.getClass().isArray()) {
2210                         filterCheck(rep.getClass(), Array.getLength(rep));
2211                     } else {
2212                         filterCheck(rep.getClass(), -1);
2213                     }
2214                 }
2215                 handles.setObject(passHandle, obj = rep);
2216             }
2217         }
2218 
2219         return obj;
2220     }
2221 
2222     /**
2223      * If obj is non-null, reads externalizable data by invoking readExternal()
2224      * method of obj; otherwise, attempts to skip over externalizable data.
2225      * Expects that passHandle is set to obj&#39;s handle before this method is
2226      * called.
2227      */
2228     private void readExternalData(Externalizable obj, ObjectStreamClass desc)
2229         throws IOException
2230     {
2231         SerialCallbackContext oldContext = curContext;
2232         if (oldContext != null)
2233             oldContext.check();
2234         curContext = null;
2235         try {
2236             boolean blocked = desc.hasBlockExternalData();
2237             if (blocked) {
2238                 bin.setBlockDataMode(true);
2239             }
2240             if (obj != null) {
2241                 try {
2242                     obj.readExternal(this);
2243                 } catch (ClassNotFoundException ex) {
2244                     /*
2245                      * In most cases, the handle table has already propagated
2246                      * a CNFException to passHandle at this point; this mark
2247                      * call is included to address cases where the readExternal
2248                      * method has cons&#39;ed and thrown a new CNFException of its
2249                      * own.
2250                      */
2251                      handles.markException(passHandle, ex);
2252                 }
2253             }
2254             if (blocked) {
2255                 skipCustomData();
2256             }
2257         } finally {
2258             if (oldContext != null)
2259                 oldContext.check();
2260             curContext = oldContext;
2261         }
2262         /*
2263          * At this point, if the externalizable data was not written in
2264          * block-data form and either the externalizable class doesn&#39;t exist
2265          * locally (i.e., obj == null) or readExternal() just threw a
2266          * CNFException, then the stream is probably in an inconsistent state,
2267          * since some (or all) of the externalizable data may not have been
2268          * consumed.  Since there&#39;s no &quot;correct&quot; action to take in this case,
2269          * we mimic the behavior of past serialization implementations and
2270          * blindly hope that the stream is in sync; if it isn&#39;t and additional
2271          * externalizable data remains in the stream, a subsequent read will
2272          * most likely throw a StreamCorruptedException.
2273          */
2274     }
2275 
2276     /** Reads a record. */
2277     private Object readRecord(ObjectStreamClass desc) throws IOException {
2278         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
2279         if (slots.length != 1) {
2280             // skip any superclass stream field values
2281             for (int i = 0; i &lt; slots.length-1; i++) {
2282                 ObjectStreamClass slotDesc = slots[i].desc;
2283                 if (slots[i].hasData) {
2284                     defaultReadFields(null, slotDesc);
2285                 }
2286             }
2287         }
2288 
2289         FieldValues fieldValues = defaultReadFields(null, desc);
2290 
2291         // retrieve the canonical constructor
2292         MethodHandle ctrMH = desc.getRecordConstructor();
2293 
2294         // bind the stream field values
2295         ctrMH = RecordSupport.bindCtrValues(ctrMH, desc, fieldValues);
2296 
2297         try {
2298             return ctrMH.invoke();
2299         } catch (Exception e) {
2300             InvalidObjectException ioe = new InvalidObjectException(e.getMessage());
2301             ioe.initCause(e);
2302             throw ioe;
2303         } catch (Error e) {
2304             throw e;
2305         } catch (Throwable t) {
2306             ObjectStreamException ose = new InvalidObjectException(
2307                     &quot;ReflectiveOperationException during deserialization&quot;);
2308             ose.initCause(t);
2309             throw ose;
2310         }
2311     }
2312 
2313     /**
2314      * Reads (or attempts to skip, if obj is null or is tagged with a
2315      * ClassNotFoundException) instance data for each serializable class of
2316      * object in stream, from superclass to subclass.  Expects that passHandle
2317      * is set to obj&#39;s handle before this method is called.
2318      */
2319     private void readSerialData(Object obj, ObjectStreamClass desc)
2320         throws IOException
2321     {
2322         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
2323         // Best effort Failure Atomicity; slotValues will be non-null if field
2324         // values can be set after reading all field data in the hierarchy.
2325         // Field values can only be set after reading all data if there are no
2326         // user observable methods in the hierarchy, readObject(NoData). The
2327         // top most Serializable class in the hierarchy can be skipped.
2328         FieldValues[] slotValues = null;
2329 
2330         boolean hasSpecialReadMethod = false;
2331         for (int i = 1; i &lt; slots.length; i++) {
2332             ObjectStreamClass slotDesc = slots[i].desc;
2333             if (slotDesc.hasReadObjectMethod()
2334                   || slotDesc.hasReadObjectNoDataMethod()) {
2335                 hasSpecialReadMethod = true;
2336                 break;
2337             }
2338         }
2339         // No special read methods, can store values and defer setting.
2340         if (!hasSpecialReadMethod)
2341             slotValues = new FieldValues[slots.length];
2342 
2343         for (int i = 0; i &lt; slots.length; i++) {
2344             ObjectStreamClass slotDesc = slots[i].desc;
2345 
2346             if (slots[i].hasData) {
2347                 if (obj == null || handles.lookupException(passHandle) != null) {
2348                     defaultReadFields(null, slotDesc); // skip field values
2349                 } else if (slotDesc.hasReadObjectMethod()) {
2350                     ThreadDeath t = null;
2351                     boolean reset = false;
2352                     SerialCallbackContext oldContext = curContext;
2353                     if (oldContext != null)
2354                         oldContext.check();
2355                     try {
2356                         curContext = new SerialCallbackContext(obj, slotDesc);
2357 
2358                         bin.setBlockDataMode(true);
2359                         slotDesc.invokeReadObject(obj, this);
2360                     } catch (ClassNotFoundException ex) {
2361                         /*
2362                          * In most cases, the handle table has already
2363                          * propagated a CNFException to passHandle at this
2364                          * point; this mark call is included to address cases
2365                          * where the custom readObject method has cons&#39;ed and
2366                          * thrown a new CNFException of its own.
2367                          */
2368                         handles.markException(passHandle, ex);
2369                     } finally {
2370                         do {
2371                             try {
2372                                 curContext.setUsed();
2373                                 if (oldContext!= null)
2374                                     oldContext.check();
2375                                 curContext = oldContext;
2376                                 reset = true;
2377                             } catch (ThreadDeath x) {
2378                                 t = x;  // defer until reset is true
2379                             }
2380                         } while (!reset);
2381                         if (t != null)
2382                             throw t;
2383                     }
2384 
2385                     /*
2386                      * defaultDataEnd may have been set indirectly by custom
2387                      * readObject() method when calling defaultReadObject() or
2388                      * readFields(); clear it to restore normal read behavior.
2389                      */
2390                     defaultDataEnd = false;
2391                 } else {
2392                     FieldValues vals = defaultReadFields(obj, slotDesc);
2393                     if (slotValues != null) {
2394                         slotValues[i] = vals;
2395                     } else if (obj != null) {
2396                         defaultCheckFieldValues(obj, slotDesc, vals);
2397                         defaultSetFieldValues(obj, slotDesc, vals);
2398                     }
2399                 }
2400 
2401                 if (slotDesc.hasWriteObjectData()) {
2402                     skipCustomData();
2403                 } else {
2404                     bin.setBlockDataMode(false);
2405                 }
2406             } else {
2407                 if (obj != null &amp;&amp;
2408                     slotDesc.hasReadObjectNoDataMethod() &amp;&amp;
2409                     handles.lookupException(passHandle) == null)
2410                 {
2411                     slotDesc.invokeReadObjectNoData(obj);
2412                 }
2413             }
2414         }
2415 
2416         if (obj != null &amp;&amp; slotValues != null) {
2417             // Check that the non-primitive types are assignable for all slots
2418             // before assigning.
2419             for (int i = 0; i &lt; slots.length; i++) {
2420                 if (slotValues[i] != null)
2421                     defaultCheckFieldValues(obj, slots[i].desc, slotValues[i]);
2422             }
2423             for (int i = 0; i &lt; slots.length; i++) {
2424                 if (slotValues[i] != null)
2425                     defaultSetFieldValues(obj, slots[i].desc, slotValues[i]);
2426             }
2427         }
2428     }
2429 
2430     /**
2431      * Skips over all block data and objects until TC_ENDBLOCKDATA is
2432      * encountered.
2433      */
2434     private void skipCustomData() throws IOException {
2435         int oldHandle = passHandle;
2436         for (;;) {
2437             if (bin.getBlockDataMode()) {
2438                 bin.skipBlockData();
2439                 bin.setBlockDataMode(false);
2440             }
2441             switch (bin.peekByte()) {
2442                 case TC_BLOCKDATA:
2443                 case TC_BLOCKDATALONG:
2444                     bin.setBlockDataMode(true);
2445                     break;
2446 
2447                 case TC_ENDBLOCKDATA:
2448                     bin.readByte();
2449                     passHandle = oldHandle;
2450                     return;
2451 
2452                 default:
2453                     readObject0(Object.class, false);
2454                     break;
2455             }
2456         }
2457     }
2458 
2459     /*package-private*/ class FieldValues {
2460         final byte[] primValues;
2461         final Object[] objValues;
2462 
2463         FieldValues(byte[] primValues, Object[] objValues) {
2464             this.primValues = primValues;
2465             this.objValues = objValues;
2466         }
2467     }
2468 
2469     /**
2470      * Reads in values of serializable fields declared by given class
2471      * descriptor. Expects that passHandle is set to obj&#39;s handle before this
2472      * method is called.
2473      */
2474     private FieldValues defaultReadFields(Object obj, ObjectStreamClass desc)
2475         throws IOException
2476     {
2477         Class&lt;?&gt; cl = desc.forClass();
2478         if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) {
2479             throw new ClassCastException();
2480         }
2481 
2482         byte[] primVals = null;
2483         int primDataSize = desc.getPrimDataSize();
2484         if (primDataSize &gt; 0) {
2485             primVals = new byte[primDataSize];
2486             bin.readFully(primVals, 0, primDataSize, false);
2487         }
2488 
2489         Object[] objVals = null;
2490         int numObjFields = desc.getNumObjFields();
2491         if (numObjFields &gt; 0) {
2492             int objHandle = passHandle;
2493             ObjectStreamField[] fields = desc.getFields(false);
2494             objVals = new Object[numObjFields];
2495             int numPrimFields = fields.length - objVals.length;
2496             for (int i = 0; i &lt; objVals.length; i++) {
2497                 ObjectStreamField f = fields[numPrimFields + i];
2498                 objVals[i] = readObject0(Object.class, f.isUnshared());
2499                 if (f.getField() != null) {
2500                     handles.markDependency(objHandle, passHandle);
2501                 }
2502             }
2503             passHandle = objHandle;
2504         }
2505 
2506         return new FieldValues(primVals, objVals);
2507     }
2508 
2509     /** Throws ClassCastException if any value is not assignable. */
2510     private void defaultCheckFieldValues(Object obj, ObjectStreamClass desc,
2511                                          FieldValues values) {
2512         Object[] objectValues = values.objValues;
2513         if (objectValues != null)
2514             desc.checkObjFieldValueTypes(obj, objectValues);
2515     }
2516 
2517     /** Sets field values in obj. */
2518     private void defaultSetFieldValues(Object obj, ObjectStreamClass desc,
2519                                        FieldValues values) {
2520         byte[] primValues = values.primValues;
2521         Object[] objectValues = values.objValues;
2522 
2523         if (primValues != null)
2524             desc.setPrimFieldValues(obj, primValues);
2525         if (objectValues != null)
2526             desc.setObjFieldValues(obj, objectValues);
2527     }
2528 
2529     /**
2530      * Reads in and returns IOException that caused serialization to abort.
2531      * All stream state is discarded prior to reading in fatal exception.  Sets
2532      * passHandle to fatal exception&#39;s handle.
2533      */
2534     private IOException readFatalException() throws IOException {
2535         if (bin.readByte() != TC_EXCEPTION) {
2536             throw new InternalError();
2537         }
2538         clear();
2539         return (IOException) readObject0(Object.class, false);
2540     }
2541 
2542     /**
2543      * If recursion depth is 0, clears internal data structures; otherwise,
2544      * throws a StreamCorruptedException.  This method is called when a
2545      * TC_RESET typecode is encountered.
2546      */
2547     private void handleReset() throws StreamCorruptedException {
2548         if (depth &gt; 0) {
2549             throw new StreamCorruptedException(
2550                 &quot;unexpected reset; recursion depth: &quot; + depth);
2551         }
2552         clear();
2553     }
2554 
2555     /**
2556      * Returns the first non-null and non-platform class loader (not counting
2557      * class loaders of generated reflection implementation classes) up the
2558      * execution stack, or the platform class loader if only code from the
2559      * bootstrap and platform class loader is on the stack.
2560      */
2561     private static ClassLoader latestUserDefinedLoader() {
2562         return jdk.internal.misc.VM.latestUserDefinedLoader();
2563     }
2564 
2565     /**
2566      * Default GetField implementation.
2567      */
2568     private class GetFieldImpl extends GetField {
2569 
2570         /** class descriptor describing serializable fields */
2571         private final ObjectStreamClass desc;
2572         /** primitive field values */
2573         private final byte[] primVals;
2574         /** object field values */
2575         private final Object[] objVals;
2576         /** object field value handles */
2577         private final int[] objHandles;
2578 
2579         /**
2580          * Creates GetFieldImpl object for reading fields defined in given
2581          * class descriptor.
2582          */
2583         GetFieldImpl(ObjectStreamClass desc) {
2584             this.desc = desc;
2585             primVals = new byte[desc.getPrimDataSize()];
2586             objVals = new Object[desc.getNumObjFields()];
2587             objHandles = new int[objVals.length];
2588         }
2589 
2590         public ObjectStreamClass getObjectStreamClass() {
2591             return desc;
2592         }
2593 
2594         public boolean defaulted(String name) throws IOException {
2595             return (getFieldOffset(name, null) &lt; 0);
2596         }
2597 
2598         public boolean get(String name, boolean val) throws IOException {
2599             int off = getFieldOffset(name, Boolean.TYPE);
2600             return (off &gt;= 0) ? Bits.getBoolean(primVals, off) : val;
2601         }
2602 
2603         public byte get(String name, byte val) throws IOException {
2604             int off = getFieldOffset(name, Byte.TYPE);
2605             return (off &gt;= 0) ? primVals[off] : val;
2606         }
2607 
2608         public char get(String name, char val) throws IOException {
2609             int off = getFieldOffset(name, Character.TYPE);
2610             return (off &gt;= 0) ? Bits.getChar(primVals, off) : val;
2611         }
2612 
2613         public short get(String name, short val) throws IOException {
2614             int off = getFieldOffset(name, Short.TYPE);
2615             return (off &gt;= 0) ? Bits.getShort(primVals, off) : val;
2616         }
2617 
2618         public int get(String name, int val) throws IOException {
2619             int off = getFieldOffset(name, Integer.TYPE);
2620             return (off &gt;= 0) ? Bits.getInt(primVals, off) : val;
2621         }
2622 
2623         public float get(String name, float val) throws IOException {
2624             int off = getFieldOffset(name, Float.TYPE);
2625             return (off &gt;= 0) ? Bits.getFloat(primVals, off) : val;
2626         }
2627 
2628         public long get(String name, long val) throws IOException {
2629             int off = getFieldOffset(name, Long.TYPE);
2630             return (off &gt;= 0) ? Bits.getLong(primVals, off) : val;
2631         }
2632 
2633         public double get(String name, double val) throws IOException {
2634             int off = getFieldOffset(name, Double.TYPE);
2635             return (off &gt;= 0) ? Bits.getDouble(primVals, off) : val;
2636         }
2637 
2638         public Object get(String name, Object val) throws IOException {
2639             int off = getFieldOffset(name, Object.class);
2640             if (off &gt;= 0) {
2641                 int objHandle = objHandles[off];
2642                 handles.markDependency(passHandle, objHandle);
2643                 return (handles.lookupException(objHandle) == null) ?
2644                     objVals[off] : null;
2645             } else {
2646                 return val;
2647             }
2648         }
2649 
2650         /**
2651          * Reads primitive and object field values from stream.
2652          */
2653         void readFields() throws IOException {
2654             bin.readFully(primVals, 0, primVals.length, false);
2655 
2656             int oldHandle = passHandle;
2657             ObjectStreamField[] fields = desc.getFields(false);
2658             int numPrimFields = fields.length - objVals.length;
2659             for (int i = 0; i &lt; objVals.length; i++) {
2660                 objVals[i] =
2661                     readObject0(Object.class, fields[numPrimFields + i].isUnshared());
2662                 objHandles[i] = passHandle;
2663             }
2664             passHandle = oldHandle;
2665         }
2666 
2667         /**
2668          * Returns offset of field with given name and type.  A specified type
2669          * of null matches all types, Object.class matches all non-primitive
2670          * types, and any other non-null type matches assignable types only.
2671          * If no matching field is found in the (incoming) class
2672          * descriptor but a matching field is present in the associated local
2673          * class descriptor, returns -1.  Throws IllegalArgumentException if
2674          * neither incoming nor local class descriptor contains a match.
2675          */
2676         private int getFieldOffset(String name, Class&lt;?&gt; type) {
2677             ObjectStreamField field = desc.getField(name, type);
2678             if (field != null) {
2679                 return field.getOffset();
2680             } else if (desc.getLocalDesc().getField(name, type) != null) {
2681                 return -1;
2682             } else {
2683                 throw new IllegalArgumentException(&quot;no such field &quot; + name +
2684                                                    &quot; with type &quot; + type);
2685             }
2686         }
2687     }
2688 
2689     /**
2690      * Prioritized list of callbacks to be performed once object graph has been
2691      * completely deserialized.
2692      */
2693     private static class ValidationList {
2694 
2695         private static class Callback {
2696             final ObjectInputValidation obj;
2697             final int priority;
2698             Callback next;
2699             final AccessControlContext acc;
2700 
2701             Callback(ObjectInputValidation obj, int priority, Callback next,
2702                 AccessControlContext acc)
2703             {
2704                 this.obj = obj;
2705                 this.priority = priority;
2706                 this.next = next;
2707                 this.acc = acc;
2708             }
2709         }
2710 
2711         /** linked list of callbacks */
2712         private Callback list;
2713 
2714         /**
2715          * Creates new (empty) ValidationList.
2716          */
2717         ValidationList() {
2718         }
2719 
2720         /**
2721          * Registers callback.  Throws InvalidObjectException if callback
2722          * object is null.
2723          */
2724         void register(ObjectInputValidation obj, int priority)
2725             throws InvalidObjectException
2726         {
2727             if (obj == null) {
2728                 throw new InvalidObjectException(&quot;null callback&quot;);
2729             }
2730 
2731             Callback prev = null, cur = list;
2732             while (cur != null &amp;&amp; priority &lt; cur.priority) {
2733                 prev = cur;
2734                 cur = cur.next;
2735             }
2736             AccessControlContext acc = AccessController.getContext();
2737             if (prev != null) {
2738                 prev.next = new Callback(obj, priority, cur, acc);
2739             } else {
2740                 list = new Callback(obj, priority, list, acc);
2741             }
2742         }
2743 
2744         /**
2745          * Invokes all registered callbacks and clears the callback list.
2746          * Callbacks with higher priorities are called first; those with equal
2747          * priorities may be called in any order.  If any of the callbacks
2748          * throws an InvalidObjectException, the callback process is terminated
2749          * and the exception propagated upwards.
2750          */
2751         void doCallbacks() throws InvalidObjectException {
2752             try {
2753                 while (list != null) {
2754                     AccessController.doPrivileged(
2755                         new PrivilegedExceptionAction&lt;Void&gt;()
2756                     {
2757                         public Void run() throws InvalidObjectException {
2758                             list.obj.validateObject();
2759                             return null;
2760                         }
2761                     }, list.acc);
2762                     list = list.next;
2763                 }
2764             } catch (PrivilegedActionException ex) {
2765                 list = null;
2766                 throw (InvalidObjectException) ex.getException();
2767             }
2768         }
2769 
2770         /**
2771          * Resets the callback list to its initial (empty) state.
2772          */
2773         public void clear() {
2774             list = null;
2775         }
2776     }
2777 
2778     /**
2779      * Hold a snapshot of values to be passed to an ObjectInputFilter.
2780      */
2781     static class FilterValues implements ObjectInputFilter.FilterInfo {
2782         final Class&lt;?&gt; clazz;
2783         final long arrayLength;
2784         final long totalObjectRefs;
2785         final long depth;
2786         final long streamBytes;
2787 
2788         public FilterValues(Class&lt;?&gt; clazz, long arrayLength, long totalObjectRefs,
2789                             long depth, long streamBytes) {
2790             this.clazz = clazz;
2791             this.arrayLength = arrayLength;
2792             this.totalObjectRefs = totalObjectRefs;
2793             this.depth = depth;
2794             this.streamBytes = streamBytes;
2795         }
2796 
2797         @Override
2798         public Class&lt;?&gt; serialClass() {
2799             return clazz;
2800         }
2801 
2802         @Override
2803         public long arrayLength() {
2804             return arrayLength;
2805         }
2806 
2807         @Override
2808         public long references() {
2809             return totalObjectRefs;
2810         }
2811 
2812         @Override
2813         public long depth() {
2814             return depth;
2815         }
2816 
2817         @Override
2818         public long streamBytes() {
2819             return streamBytes;
2820         }
2821     }
2822 
2823     /**
2824      * Input stream supporting single-byte peek operations.
2825      */
2826     private static class PeekInputStream extends InputStream {
2827 
2828         /** underlying stream */
2829         private final InputStream in;
2830         /** peeked byte */
2831         private int peekb = -1;
2832         /** total bytes read from the stream */
2833         private long totalBytesRead = 0;
2834 
2835         /**
2836          * Creates new PeekInputStream on top of given underlying stream.
2837          */
2838         PeekInputStream(InputStream in) {
2839             this.in = in;
2840         }
2841 
2842         /**
2843          * Peeks at next byte value in stream.  Similar to read(), except
2844          * that it does not consume the read value.
2845          */
2846         int peek() throws IOException {
2847             if (peekb &gt;= 0) {
2848                 return peekb;
2849             }
2850             peekb = in.read();
2851             totalBytesRead += peekb &gt;= 0 ? 1 : 0;
2852             return peekb;
2853         }
2854 
2855         public int read() throws IOException {
2856             if (peekb &gt;= 0) {
2857                 int v = peekb;
2858                 peekb = -1;
2859                 return v;
2860             } else {
2861                 int nbytes = in.read();
2862                 totalBytesRead += nbytes &gt;= 0 ? 1 : 0;
2863                 return nbytes;
2864             }
2865         }
2866 
2867         public int read(byte[] b, int off, int len) throws IOException {
2868             int nbytes;
2869             if (len == 0) {
2870                 return 0;
2871             } else if (peekb &lt; 0) {
2872                 nbytes = in.read(b, off, len);
2873                 totalBytesRead += nbytes &gt;= 0 ? nbytes : 0;
2874                 return nbytes;
2875             } else {
2876                 b[off++] = (byte) peekb;
2877                 len--;
2878                 peekb = -1;
2879                 nbytes = in.read(b, off, len);
2880                 totalBytesRead += nbytes &gt;= 0 ? nbytes : 0;
2881                 return (nbytes &gt;= 0) ? (nbytes + 1) : 1;
2882             }
2883         }
2884 
2885         void readFully(byte[] b, int off, int len) throws IOException {
2886             int n = 0;
2887             while (n &lt; len) {
2888                 int count = read(b, off + n, len - n);
2889                 if (count &lt; 0) {
2890                     throw new EOFException();
2891                 }
2892                 n += count;
2893             }
2894         }
2895 
2896         public long skip(long n) throws IOException {
2897             if (n &lt;= 0) {
2898                 return 0;
2899             }
2900             int skipped = 0;
2901             if (peekb &gt;= 0) {
2902                 peekb = -1;
2903                 skipped++;
2904                 n--;
2905             }
2906             n = skipped + in.skip(n);
2907             totalBytesRead += n;
2908             return n;
2909         }
2910 
2911         public int available() throws IOException {
2912             return in.available() + ((peekb &gt;= 0) ? 1 : 0);
2913         }
2914 
2915         public void close() throws IOException {
2916             in.close();
2917         }
2918 
2919         public long getBytesRead() {
2920             return totalBytesRead;
2921         }
2922     }
2923 
2924     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
2925 
2926     /**
2927      * Performs a &quot;freeze&quot; action, required to adhere to final field semantics.
2928      *
2929      * &lt;p&gt; This method can be called unconditionally before returning the graph,
2930      * from the topmost readObject call, since it is expected that the
2931      * additional cost of the freeze action is negligible compared to
2932      * reconstituting even the most simple graph.
2933      *
2934      * &lt;p&gt; Nested calls to readObject do not issue freeze actions because the
2935      * sub-graph returned from a nested call is not guaranteed to be fully
2936      * initialized yet (possible cycles).
2937      */
2938     private void freeze() {
2939         // Issue a StoreStore|StoreLoad fence, which is at least sufficient
2940         // to provide final-freeze semantics.
2941         UNSAFE.storeFence();
2942     }
2943 
2944     /**
2945      * Input stream with two modes: in default mode, inputs data written in the
2946      * same format as DataOutputStream; in &quot;block data&quot; mode, inputs data
2947      * bracketed by block data markers (see object serialization specification
2948      * for details).  Buffering depends on block data mode: when in default
2949      * mode, no data is buffered in advance; when in block data mode, all data
2950      * for the current data block is read in at once (and buffered).
2951      */
2952     private class BlockDataInputStream
2953         extends InputStream implements DataInput
2954     {
2955         /** maximum data block length */
2956         private static final int MAX_BLOCK_SIZE = 1024;
2957         /** maximum data block header length */
2958         private static final int MAX_HEADER_SIZE = 5;
2959         /** (tunable) length of char buffer (for reading strings) */
2960         private static final int CHAR_BUF_SIZE = 256;
2961         /** readBlockHeader() return value indicating header read may block */
2962         private static final int HEADER_BLOCKED = -2;
2963 
2964         /** buffer for reading general/block data */
2965         private final byte[] buf = new byte[MAX_BLOCK_SIZE];
2966         /** buffer for reading block data headers */
2967         private final byte[] hbuf = new byte[MAX_HEADER_SIZE];
2968         /** char buffer for fast string reads */
2969         private final char[] cbuf = new char[CHAR_BUF_SIZE];
2970 
2971         /** block data mode */
2972         private boolean blkmode = false;
2973 
2974         // block data state fields; values meaningful only when blkmode true
2975         /** current offset into buf */
2976         private int pos = 0;
2977         /** end offset of valid data in buf, or -1 if no more block data */
2978         private int end = -1;
2979         /** number of bytes in current block yet to be read from stream */
2980         private int unread = 0;
2981 
2982         /** underlying stream (wrapped in peekable filter stream) */
2983         private final PeekInputStream in;
2984         /** loopback stream (for data reads that span data blocks) */
2985         private final DataInputStream din;
2986 
2987         /**
2988          * Creates new BlockDataInputStream on top of given underlying stream.
2989          * Block data mode is turned off by default.
2990          */
2991         BlockDataInputStream(InputStream in) {
2992             this.in = new PeekInputStream(in);
2993             din = new DataInputStream(this);
2994         }
2995 
2996         /**
2997          * Sets block data mode to the given mode (true == on, false == off)
2998          * and returns the previous mode value.  If the new mode is the same as
2999          * the old mode, no action is taken.  Throws IllegalStateException if
3000          * block data mode is being switched from on to off while unconsumed
3001          * block data is still present in the stream.
3002          */
3003         boolean setBlockDataMode(boolean newmode) throws IOException {
3004             if (blkmode == newmode) {
3005                 return blkmode;
3006             }
3007             if (newmode) {
3008                 pos = 0;
3009                 end = 0;
3010                 unread = 0;
3011             } else if (pos &lt; end) {
3012                 throw new IllegalStateException(&quot;unread block data&quot;);
3013             }
3014             blkmode = newmode;
3015             return !blkmode;
3016         }
3017 
3018         /**
3019          * Returns true if the stream is currently in block data mode, false
3020          * otherwise.
3021          */
3022         boolean getBlockDataMode() {
3023             return blkmode;
3024         }
3025 
3026         /**
3027          * If in block data mode, skips to the end of the current group of data
3028          * blocks (but does not unset block data mode).  If not in block data
3029          * mode, throws an IllegalStateException.
3030          */
3031         void skipBlockData() throws IOException {
3032             if (!blkmode) {
3033                 throw new IllegalStateException(&quot;not in block data mode&quot;);
3034             }
3035             while (end &gt;= 0) {
3036                 refill();
3037             }
3038         }
3039 
3040         /**
3041          * Attempts to read in the next block data header (if any).  If
3042          * canBlock is false and a full header cannot be read without possibly
3043          * blocking, returns HEADER_BLOCKED, else if the next element in the
3044          * stream is a block data header, returns the block data length
3045          * specified by the header, else returns -1.
3046          */
3047         private int readBlockHeader(boolean canBlock) throws IOException {
3048             if (defaultDataEnd) {
3049                 /*
3050                  * Fix for 4360508: stream is currently at the end of a field
3051                  * value block written via default serialization; since there
3052                  * is no terminating TC_ENDBLOCKDATA tag, simulate
3053                  * end-of-custom-data behavior explicitly.
3054                  */
3055                 return -1;
3056             }
3057             try {
3058                 for (;;) {
3059                     int avail = canBlock ? Integer.MAX_VALUE : in.available();
3060                     if (avail == 0) {
3061                         return HEADER_BLOCKED;
3062                     }
3063 
3064                     int tc = in.peek();
3065                     switch (tc) {
3066                         case TC_BLOCKDATA:
3067                             if (avail &lt; 2) {
3068                                 return HEADER_BLOCKED;
3069                             }
3070                             in.readFully(hbuf, 0, 2);
3071                             return hbuf[1] &amp; 0xFF;
3072 
3073                         case TC_BLOCKDATALONG:
3074                             if (avail &lt; 5) {
3075                                 return HEADER_BLOCKED;
3076                             }
3077                             in.readFully(hbuf, 0, 5);
3078                             int len = Bits.getInt(hbuf, 1);
3079                             if (len &lt; 0) {
3080                                 throw new StreamCorruptedException(
3081                                     &quot;illegal block data header length: &quot; +
3082                                     len);
3083                             }
3084                             return len;
3085 
3086                         /*
3087                          * TC_RESETs may occur in between data blocks.
3088                          * Unfortunately, this case must be parsed at a lower
3089                          * level than other typecodes, since primitive data
3090                          * reads may span data blocks separated by a TC_RESET.
3091                          */
3092                         case TC_RESET:
3093                             in.read();
3094                             handleReset();
3095                             break;
3096 
3097                         default:
3098                             if (tc &gt;= 0 &amp;&amp; (tc &lt; TC_BASE || tc &gt; TC_MAX)) {
3099                                 throw new StreamCorruptedException(
3100                                     String.format(&quot;invalid type code: %02X&quot;,
3101                                     tc));
3102                             }
3103                             return -1;
3104                     }
3105                 }
3106             } catch (EOFException ex) {
3107                 throw new StreamCorruptedException(
3108                     &quot;unexpected EOF while reading block data header&quot;);
3109             }
3110         }
3111 
3112         /**
3113          * Refills internal buffer buf with block data.  Any data in buf at the
3114          * time of the call is considered consumed.  Sets the pos, end, and
3115          * unread fields to reflect the new amount of available block data; if
3116          * the next element in the stream is not a data block, sets pos and
3117          * unread to 0 and end to -1.
3118          */
3119         private void refill() throws IOException {
3120             try {
3121                 do {
3122                     pos = 0;
3123                     if (unread &gt; 0) {
3124                         int n =
3125                             in.read(buf, 0, Math.min(unread, MAX_BLOCK_SIZE));
3126                         if (n &gt;= 0) {
3127                             end = n;
3128                             unread -= n;
3129                         } else {
3130                             throw new StreamCorruptedException(
3131                                 &quot;unexpected EOF in middle of data block&quot;);
3132                         }
3133                     } else {
3134                         int n = readBlockHeader(true);
3135                         if (n &gt;= 0) {
3136                             end = 0;
3137                             unread = n;
3138                         } else {
3139                             end = -1;
3140                             unread = 0;
3141                         }
3142                     }
3143                 } while (pos == end);
3144             } catch (IOException ex) {
3145                 pos = 0;
3146                 end = -1;
3147                 unread = 0;
3148                 throw ex;
3149             }
3150         }
3151 
3152         /**
3153          * If in block data mode, returns the number of unconsumed bytes
3154          * remaining in the current data block.  If not in block data mode,
3155          * throws an IllegalStateException.
3156          */
3157         int currentBlockRemaining() {
3158             if (blkmode) {
3159                 return (end &gt;= 0) ? (end - pos) + unread : 0;
3160             } else {
3161                 throw new IllegalStateException();
3162             }
3163         }
3164 
3165         /**
3166          * Peeks at (but does not consume) and returns the next byte value in
3167          * the stream, or -1 if the end of the stream/block data (if in block
3168          * data mode) has been reached.
3169          */
3170         int peek() throws IOException {
3171             if (blkmode) {
3172                 if (pos == end) {
3173                     refill();
3174                 }
3175                 return (end &gt;= 0) ? (buf[pos] &amp; 0xFF) : -1;
3176             } else {
3177                 return in.peek();
3178             }
3179         }
3180 
3181         /**
3182          * Peeks at (but does not consume) and returns the next byte value in
3183          * the stream, or throws EOFException if end of stream/block data has
3184          * been reached.
3185          */
3186         byte peekByte() throws IOException {
3187             int val = peek();
3188             if (val &lt; 0) {
3189                 throw new EOFException();
3190             }
3191             return (byte) val;
3192         }
3193 
3194 
3195         /* ----------------- generic input stream methods ------------------ */
3196         /*
3197          * The following methods are equivalent to their counterparts in
3198          * InputStream, except that they interpret data block boundaries and
3199          * read the requested data from within data blocks when in block data
3200          * mode.
3201          */
3202 
3203         public int read() throws IOException {
3204             if (blkmode) {
3205                 if (pos == end) {
3206                     refill();
3207                 }
3208                 return (end &gt;= 0) ? (buf[pos++] &amp; 0xFF) : -1;
3209             } else {
3210                 return in.read();
3211             }
3212         }
3213 
3214         public int read(byte[] b, int off, int len) throws IOException {
3215             return read(b, off, len, false);
3216         }
3217 
3218         public long skip(long len) throws IOException {
3219             long remain = len;
3220             while (remain &gt; 0) {
3221                 if (blkmode) {
3222                     if (pos == end) {
3223                         refill();
3224                     }
3225                     if (end &lt; 0) {
3226                         break;
3227                     }
3228                     int nread = (int) Math.min(remain, end - pos);
3229                     remain -= nread;
3230                     pos += nread;
3231                 } else {
3232                     int nread = (int) Math.min(remain, MAX_BLOCK_SIZE);
3233                     if ((nread = in.read(buf, 0, nread)) &lt; 0) {
3234                         break;
3235                     }
3236                     remain -= nread;
3237                 }
3238             }
3239             return len - remain;
3240         }
3241 
3242         public int available() throws IOException {
3243             if (blkmode) {
3244                 if ((pos == end) &amp;&amp; (unread == 0)) {
3245                     int n;
3246                     while ((n = readBlockHeader(false)) == 0) ;
3247                     switch (n) {
3248                         case HEADER_BLOCKED:
3249                             break;
3250 
3251                         case -1:
3252                             pos = 0;
3253                             end = -1;
3254                             break;
3255 
3256                         default:
3257                             pos = 0;
3258                             end = 0;
3259                             unread = n;
3260                             break;
3261                     }
3262                 }
3263                 // avoid unnecessary call to in.available() if possible
3264                 int unreadAvail = (unread &gt; 0) ?
3265                     Math.min(in.available(), unread) : 0;
3266                 return (end &gt;= 0) ? (end - pos) + unreadAvail : 0;
3267             } else {
3268                 return in.available();
3269             }
3270         }
3271 
3272         public void close() throws IOException {
3273             if (blkmode) {
3274                 pos = 0;
3275                 end = -1;
3276                 unread = 0;
3277             }
3278             in.close();
3279         }
3280 
3281         /**
3282          * Attempts to read len bytes into byte array b at offset off.  Returns
3283          * the number of bytes read, or -1 if the end of stream/block data has
3284          * been reached.  If copy is true, reads values into an intermediate
3285          * buffer before copying them to b (to avoid exposing a reference to
3286          * b).
3287          */
3288         int read(byte[] b, int off, int len, boolean copy) throws IOException {
3289             if (len == 0) {
3290                 return 0;
3291             } else if (blkmode) {
3292                 if (pos == end) {
3293                     refill();
3294                 }
3295                 if (end &lt; 0) {
3296                     return -1;
3297                 }
3298                 int nread = Math.min(len, end - pos);
3299                 System.arraycopy(buf, pos, b, off, nread);
3300                 pos += nread;
3301                 return nread;
3302             } else if (copy) {
3303                 int nread = in.read(buf, 0, Math.min(len, MAX_BLOCK_SIZE));
3304                 if (nread &gt; 0) {
3305                     System.arraycopy(buf, 0, b, off, nread);
3306                 }
3307                 return nread;
3308             } else {
3309                 return in.read(b, off, len);
3310             }
3311         }
3312 
3313         /* ----------------- primitive data input methods ------------------ */
3314         /*
3315          * The following methods are equivalent to their counterparts in
3316          * DataInputStream, except that they interpret data block boundaries
3317          * and read the requested data from within data blocks when in block
3318          * data mode.
3319          */
3320 
3321         public void readFully(byte[] b) throws IOException {
3322             readFully(b, 0, b.length, false);
3323         }
3324 
3325         public void readFully(byte[] b, int off, int len) throws IOException {
3326             readFully(b, off, len, false);
3327         }
3328 
3329         public void readFully(byte[] b, int off, int len, boolean copy)
3330             throws IOException
3331         {
3332             while (len &gt; 0) {
3333                 int n = read(b, off, len, copy);
3334                 if (n &lt; 0) {
3335                     throw new EOFException();
3336                 }
3337                 off += n;
3338                 len -= n;
3339             }
3340         }
3341 
3342         public int skipBytes(int n) throws IOException {
3343             return din.skipBytes(n);
3344         }
3345 
3346         public boolean readBoolean() throws IOException {
3347             int v = read();
3348             if (v &lt; 0) {
3349                 throw new EOFException();
3350             }
3351             return (v != 0);
3352         }
3353 
3354         public byte readByte() throws IOException {
3355             int v = read();
3356             if (v &lt; 0) {
3357                 throw new EOFException();
3358             }
3359             return (byte) v;
3360         }
3361 
3362         public int readUnsignedByte() throws IOException {
3363             int v = read();
3364             if (v &lt; 0) {
3365                 throw new EOFException();
3366             }
3367             return v;
3368         }
3369 
3370         public char readChar() throws IOException {
3371             if (!blkmode) {
3372                 pos = 0;
3373                 in.readFully(buf, 0, 2);
3374             } else if (end - pos &lt; 2) {
3375                 return din.readChar();
3376             }
3377             char v = Bits.getChar(buf, pos);
3378             pos += 2;
3379             return v;
3380         }
3381 
3382         public short readShort() throws IOException {
3383             if (!blkmode) {
3384                 pos = 0;
3385                 in.readFully(buf, 0, 2);
3386             } else if (end - pos &lt; 2) {
3387                 return din.readShort();
3388             }
3389             short v = Bits.getShort(buf, pos);
3390             pos += 2;
3391             return v;
3392         }
3393 
3394         public int readUnsignedShort() throws IOException {
3395             if (!blkmode) {
3396                 pos = 0;
3397                 in.readFully(buf, 0, 2);
3398             } else if (end - pos &lt; 2) {
3399                 return din.readUnsignedShort();
3400             }
3401             int v = Bits.getShort(buf, pos) &amp; 0xFFFF;
3402             pos += 2;
3403             return v;
3404         }
3405 
3406         public int readInt() throws IOException {
3407             if (!blkmode) {
3408                 pos = 0;
3409                 in.readFully(buf, 0, 4);
3410             } else if (end - pos &lt; 4) {
3411                 return din.readInt();
3412             }
3413             int v = Bits.getInt(buf, pos);
3414             pos += 4;
3415             return v;
3416         }
3417 
3418         public float readFloat() throws IOException {
3419             if (!blkmode) {
3420                 pos = 0;
3421                 in.readFully(buf, 0, 4);
3422             } else if (end - pos &lt; 4) {
3423                 return din.readFloat();
3424             }
3425             float v = Bits.getFloat(buf, pos);
3426             pos += 4;
3427             return v;
3428         }
3429 
3430         public long readLong() throws IOException {
3431             if (!blkmode) {
3432                 pos = 0;
3433                 in.readFully(buf, 0, 8);
3434             } else if (end - pos &lt; 8) {
3435                 return din.readLong();
3436             }
3437             long v = Bits.getLong(buf, pos);
3438             pos += 8;
3439             return v;
3440         }
3441 
3442         public double readDouble() throws IOException {
3443             if (!blkmode) {
3444                 pos = 0;
3445                 in.readFully(buf, 0, 8);
3446             } else if (end - pos &lt; 8) {
3447                 return din.readDouble();
3448             }
3449             double v = Bits.getDouble(buf, pos);
3450             pos += 8;
3451             return v;
3452         }
3453 
3454         public String readUTF() throws IOException {
3455             return readUTFBody(readUnsignedShort());
3456         }
3457 
3458         @SuppressWarnings(&quot;deprecation&quot;)
3459         public String readLine() throws IOException {
3460             return din.readLine();      // deprecated, not worth optimizing
3461         }
3462 
3463         /* -------------- primitive data array input methods --------------- */
3464         /*
3465          * The following methods read in spans of primitive data values.
3466          * Though equivalent to calling the corresponding primitive read
3467          * methods repeatedly, these methods are optimized for reading groups
3468          * of primitive data values more efficiently.
3469          */
3470 
3471         void readBooleans(boolean[] v, int off, int len) throws IOException {
3472             int stop, endoff = off + len;
3473             while (off &lt; endoff) {
3474                 if (!blkmode) {
3475                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE);
3476                     in.readFully(buf, 0, span);
3477                     stop = off + span;
3478                     pos = 0;
3479                 } else if (end - pos &lt; 1) {
3480                     v[off++] = din.readBoolean();
3481                     continue;
3482                 } else {
3483                     stop = Math.min(endoff, off + end - pos);
3484                 }
3485 
3486                 while (off &lt; stop) {
3487                     v[off++] = Bits.getBoolean(buf, pos++);
3488                 }
3489             }
3490         }
3491 
3492         void readChars(char[] v, int off, int len) throws IOException {
3493             int stop, endoff = off + len;
3494             while (off &lt; endoff) {
3495                 if (!blkmode) {
3496                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 1);
3497                     in.readFully(buf, 0, span &lt;&lt; 1);
3498                     stop = off + span;
3499                     pos = 0;
3500                 } else if (end - pos &lt; 2) {
3501                     v[off++] = din.readChar();
3502                     continue;
3503                 } else {
3504                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 1));
3505                 }
3506 
3507                 while (off &lt; stop) {
3508                     v[off++] = Bits.getChar(buf, pos);
3509                     pos += 2;
3510                 }
3511             }
3512         }
3513 
3514         void readShorts(short[] v, int off, int len) throws IOException {
3515             int stop, endoff = off + len;
3516             while (off &lt; endoff) {
3517                 if (!blkmode) {
3518                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 1);
3519                     in.readFully(buf, 0, span &lt;&lt; 1);
3520                     stop = off + span;
3521                     pos = 0;
3522                 } else if (end - pos &lt; 2) {
3523                     v[off++] = din.readShort();
3524                     continue;
3525                 } else {
3526                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 1));
3527                 }
3528 
3529                 while (off &lt; stop) {
3530                     v[off++] = Bits.getShort(buf, pos);
3531                     pos += 2;
3532                 }
3533             }
3534         }
3535 
3536         void readInts(int[] v, int off, int len) throws IOException {
3537             int stop, endoff = off + len;
3538             while (off &lt; endoff) {
3539                 if (!blkmode) {
3540                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);
3541                     in.readFully(buf, 0, span &lt;&lt; 2);
3542                     stop = off + span;
3543                     pos = 0;
3544                 } else if (end - pos &lt; 4) {
3545                     v[off++] = din.readInt();
3546                     continue;
3547                 } else {
3548                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 2));
3549                 }
3550 
3551                 while (off &lt; stop) {
3552                     v[off++] = Bits.getInt(buf, pos);
3553                     pos += 4;
3554                 }
3555             }
3556         }
3557 
3558         void readFloats(float[] v, int off, int len) throws IOException {
3559             int stop, endoff = off + len;
3560             while (off &lt; endoff) {
3561                 if (!blkmode) {
3562                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);
3563                     in.readFully(buf, 0, span &lt;&lt; 2);
3564                     stop = off + span;
3565                     pos = 0;
3566                 } else if (end - pos &lt; 4) {
3567                     v[off++] = din.readFloat();
3568                     continue;
3569                 } else {
3570                     stop = Math.min(endoff, ((end - pos) &gt;&gt; 2));
3571                 }
3572 
3573                 while (off &lt; stop) {
3574                     v[off++] = Bits.getFloat(buf, pos);
3575                     pos += 4;
3576                 }
3577             }
3578         }
3579 
3580         void readLongs(long[] v, int off, int len) throws IOException {
3581             int stop, endoff = off + len;
3582             while (off &lt; endoff) {
3583                 if (!blkmode) {
3584                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);
3585                     in.readFully(buf, 0, span &lt;&lt; 3);
3586                     stop = off + span;
3587                     pos = 0;
3588                 } else if (end - pos &lt; 8) {
3589                     v[off++] = din.readLong();
3590                     continue;
3591                 } else {
3592                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 3));
3593                 }
3594 
3595                 while (off &lt; stop) {
3596                     v[off++] = Bits.getLong(buf, pos);
3597                     pos += 8;
3598                 }
3599             }
3600         }
3601 
3602         void readDoubles(double[] v, int off, int len) throws IOException {
3603             int stop, endoff = off + len;
3604             while (off &lt; endoff) {
3605                 if (!blkmode) {
3606                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);
3607                     in.readFully(buf, 0, span &lt;&lt; 3);
3608                     stop = off + span;
3609                     pos = 0;
3610                 } else if (end - pos &lt; 8) {
3611                     v[off++] = din.readDouble();
3612                     continue;
3613                 } else {
3614                     stop = Math.min(endoff - off, ((end - pos) &gt;&gt; 3));
3615                 }
3616 
3617                 while (off &lt; stop) {
3618                     v[off++] = Bits.getDouble(buf, pos);
3619                     pos += 8;
3620                 }
3621             }
3622         }
3623 
3624         /**
3625          * Reads in string written in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
3626          * identical to standard UTF, except that it uses an 8 byte header
3627          * (instead of the standard 2 bytes) to convey the UTF encoding length.
3628          */
3629         String readLongUTF() throws IOException {
3630             return readUTFBody(readLong());
3631         }
3632 
3633         /**
3634          * Reads in the &quot;body&quot; (i.e., the UTF representation minus the 2-byte
3635          * or 8-byte length header) of a UTF encoding, which occupies the next
3636          * utflen bytes.
3637          */
3638         private String readUTFBody(long utflen) throws IOException {
3639             StringBuilder sbuf;
3640             if (utflen &gt; 0 &amp;&amp; utflen &lt; Integer.MAX_VALUE) {
3641                 // a reasonable initial capacity based on the UTF length
3642                 int initialCapacity = Math.min((int)utflen, 0xFFFF);
3643                 sbuf = new StringBuilder(initialCapacity);
3644             } else {
3645                 sbuf = new StringBuilder();
3646             }
3647 
3648             if (!blkmode) {
3649                 end = pos = 0;
3650             }
3651 
3652             while (utflen &gt; 0) {
3653                 int avail = end - pos;
3654                 if (avail &gt;= 3 || (long) avail == utflen) {
3655                     utflen -= readUTFSpan(sbuf, utflen);
3656                 } else {
3657                     if (blkmode) {
3658                         // near block boundary, read one byte at a time
3659                         utflen -= readUTFChar(sbuf, utflen);
3660                     } else {
3661                         // shift and refill buffer manually
3662                         if (avail &gt; 0) {
3663                             System.arraycopy(buf, pos, buf, 0, avail);
3664                         }
3665                         pos = 0;
3666                         end = (int) Math.min(MAX_BLOCK_SIZE, utflen);
3667                         in.readFully(buf, avail, end - avail);
3668                     }
3669                 }
3670             }
3671 
3672             return sbuf.toString();
3673         }
3674 
3675         /**
3676          * Reads span of UTF-encoded characters out of internal buffer
3677          * (starting at offset pos and ending at or before offset end),
3678          * consuming no more than utflen bytes.  Appends read characters to
3679          * sbuf.  Returns the number of bytes consumed.
3680          */
3681         private long readUTFSpan(StringBuilder sbuf, long utflen)
3682             throws IOException
3683         {
3684             int cpos = 0;
3685             int start = pos;
3686             int avail = Math.min(end - pos, CHAR_BUF_SIZE);
3687             // stop short of last char unless all of utf bytes in buffer
3688             int stop = pos + ((utflen &gt; avail) ? avail - 2 : (int) utflen);
3689             boolean outOfBounds = false;
3690 
3691             try {
3692                 while (pos &lt; stop) {
3693                     int b1, b2, b3;
3694                     b1 = buf[pos++] &amp; 0xFF;
3695                     switch (b1 &gt;&gt; 4) {
3696                         case 0:
3697                         case 1:
3698                         case 2:
3699                         case 3:
3700                         case 4:
3701                         case 5:
3702                         case 6:
3703                         case 7:   // 1 byte format: 0xxxxxxx
3704                             cbuf[cpos++] = (char) b1;
3705                             break;
3706 
3707                         case 12:
3708                         case 13:  // 2 byte format: 110xxxxx 10xxxxxx
3709                             b2 = buf[pos++];
3710                             if ((b2 &amp; 0xC0) != 0x80) {
3711                                 throw new UTFDataFormatException();
3712                             }
3713                             cbuf[cpos++] = (char) (((b1 &amp; 0x1F) &lt;&lt; 6) |
3714                                                    ((b2 &amp; 0x3F) &lt;&lt; 0));
3715                             break;
3716 
3717                         case 14:  // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx
3718                             b3 = buf[pos + 1];
3719                             b2 = buf[pos + 0];
3720                             pos += 2;
3721                             if ((b2 &amp; 0xC0) != 0x80 || (b3 &amp; 0xC0) != 0x80) {
3722                                 throw new UTFDataFormatException();
3723                             }
3724                             cbuf[cpos++] = (char) (((b1 &amp; 0x0F) &lt;&lt; 12) |
3725                                                    ((b2 &amp; 0x3F) &lt;&lt; 6) |
3726                                                    ((b3 &amp; 0x3F) &lt;&lt; 0));
3727                             break;
3728 
3729                         default:  // 10xx xxxx, 1111 xxxx
3730                             throw new UTFDataFormatException();
3731                     }
3732                 }
3733             } catch (ArrayIndexOutOfBoundsException ex) {
3734                 outOfBounds = true;
3735             } finally {
3736                 if (outOfBounds || (pos - start) &gt; utflen) {
3737                     /*
3738                      * Fix for 4450867: if a malformed utf char causes the
3739                      * conversion loop to scan past the expected end of the utf
3740                      * string, only consume the expected number of utf bytes.
3741                      */
3742                     pos = start + (int) utflen;
3743                     throw new UTFDataFormatException();
3744                 }
3745             }
3746 
3747             sbuf.append(cbuf, 0, cpos);
3748             return pos - start;
3749         }
3750 
3751         /**
3752          * Reads in single UTF-encoded character one byte at a time, appends
3753          * the character to sbuf, and returns the number of bytes consumed.
3754          * This method is used when reading in UTF strings written in block
3755          * data mode to handle UTF-encoded characters which (potentially)
3756          * straddle block-data boundaries.
3757          */
3758         private int readUTFChar(StringBuilder sbuf, long utflen)
3759             throws IOException
3760         {
3761             int b1, b2, b3;
3762             b1 = readByte() &amp; 0xFF;
3763             switch (b1 &gt;&gt; 4) {
3764                 case 0:
3765                 case 1:
3766                 case 2:
3767                 case 3:
3768                 case 4:
3769                 case 5:
3770                 case 6:
3771                 case 7:     // 1 byte format: 0xxxxxxx
3772                     sbuf.append((char) b1);
3773                     return 1;
3774 
3775                 case 12:
3776                 case 13:    // 2 byte format: 110xxxxx 10xxxxxx
3777                     if (utflen &lt; 2) {
3778                         throw new UTFDataFormatException();
3779                     }
3780                     b2 = readByte();
3781                     if ((b2 &amp; 0xC0) != 0x80) {
3782                         throw new UTFDataFormatException();
3783                     }
3784                     sbuf.append((char) (((b1 &amp; 0x1F) &lt;&lt; 6) |
3785                                         ((b2 &amp; 0x3F) &lt;&lt; 0)));
3786                     return 2;
3787 
3788                 case 14:    // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx
3789                     if (utflen &lt; 3) {
3790                         if (utflen == 2) {
3791                             readByte();         // consume remaining byte
3792                         }
3793                         throw new UTFDataFormatException();
3794                     }
3795                     b2 = readByte();
3796                     b3 = readByte();
3797                     if ((b2 &amp; 0xC0) != 0x80 || (b3 &amp; 0xC0) != 0x80) {
3798                         throw new UTFDataFormatException();
3799                     }
3800                     sbuf.append((char) (((b1 &amp; 0x0F) &lt;&lt; 12) |
3801                                         ((b2 &amp; 0x3F) &lt;&lt; 6) |
3802                                         ((b3 &amp; 0x3F) &lt;&lt; 0)));
3803                     return 3;
3804 
3805                 default:   // 10xx xxxx, 1111 xxxx
3806                     throw new UTFDataFormatException();
3807             }
3808         }
3809 
3810         /**
3811          * Returns the number of bytes read from the input stream.
3812          * @return the number of bytes read from the input stream
3813          */
3814         long getBytesRead() {
3815             return in.getBytesRead();
3816         }
3817     }
3818 
3819     /**
3820      * Unsynchronized table which tracks wire handle to object mappings, as
3821      * well as ClassNotFoundExceptions associated with deserialized objects.
3822      * This class implements an exception-propagation algorithm for
3823      * determining which objects should have ClassNotFoundExceptions associated
3824      * with them, taking into account cycles and discontinuities (e.g., skipped
3825      * fields) in the object graph.
3826      *
3827      * &lt;p&gt;General use of the table is as follows: during deserialization, a
3828      * given object is first assigned a handle by calling the assign method.
3829      * This method leaves the assigned handle in an &quot;open&quot; state, wherein
3830      * dependencies on the exception status of other handles can be registered
3831      * by calling the markDependency method, or an exception can be directly
3832      * associated with the handle by calling markException.  When a handle is
3833      * tagged with an exception, the HandleTable assumes responsibility for
3834      * propagating the exception to any other objects which depend
3835      * (transitively) on the exception-tagged object.
3836      *
3837      * &lt;p&gt;Once all exception information/dependencies for the handle have been
3838      * registered, the handle should be &quot;closed&quot; by calling the finish method
3839      * on it.  The act of finishing a handle allows the exception propagation
3840      * algorithm to aggressively prune dependency links, lessening the
3841      * performance/memory impact of exception tracking.
3842      *
3843      * &lt;p&gt;Note that the exception propagation algorithm used depends on handles
3844      * being assigned/finished in LIFO order; however, for simplicity as well
3845      * as memory conservation, it does not enforce this constraint.
3846      */
3847     // REMIND: add full description of exception propagation algorithm?
3848     private static class HandleTable {
3849 
3850         /* status codes indicating whether object has associated exception */
3851         private static final byte STATUS_OK = 1;
3852         private static final byte STATUS_UNKNOWN = 2;
3853         private static final byte STATUS_EXCEPTION = 3;
3854 
3855         /** array mapping handle -&gt; object status */
3856         byte[] status;
3857         /** array mapping handle -&gt; object/exception (depending on status) */
3858         Object[] entries;
3859         /** array mapping handle -&gt; list of dependent handles (if any) */
3860         HandleList[] deps;
3861         /** lowest unresolved dependency */
3862         int lowDep = -1;
3863         /** number of handles in table */
3864         int size = 0;
3865 
3866         /**
3867          * Creates handle table with the given initial capacity.
3868          */
3869         HandleTable(int initialCapacity) {
3870             status = new byte[initialCapacity];
3871             entries = new Object[initialCapacity];
3872             deps = new HandleList[initialCapacity];
3873         }
3874 
3875         /**
3876          * Assigns next available handle to given object, and returns assigned
3877          * handle.  Once object has been completely deserialized (and all
3878          * dependencies on other objects identified), the handle should be
3879          * &quot;closed&quot; by passing it to finish().
3880          */
3881         int assign(Object obj) {
3882             if (size &gt;= entries.length) {
3883                 grow();
3884             }
3885             status[size] = STATUS_UNKNOWN;
3886             entries[size] = obj;
3887             return size++;
3888         }
3889 
3890         /**
3891          * Registers a dependency (in exception status) of one handle on
3892          * another.  The dependent handle must be &quot;open&quot; (i.e., assigned, but
3893          * not finished yet).  No action is taken if either dependent or target
3894          * handle is NULL_HANDLE. Additionally, no action is taken if the
3895          * dependent and target are the same.
3896          */
3897         void markDependency(int dependent, int target) {
3898             if (dependent == target || dependent == NULL_HANDLE || target == NULL_HANDLE) {
3899                 return;
3900             }
3901             switch (status[dependent]) {
3902 
3903                 case STATUS_UNKNOWN:
3904                     switch (status[target]) {
3905                         case STATUS_OK:
3906                             // ignore dependencies on objs with no exception
3907                             break;
3908 
3909                         case STATUS_EXCEPTION:
3910                             // eagerly propagate exception
3911                             markException(dependent,
3912                                 (ClassNotFoundException) entries[target]);
3913                             break;
3914 
3915                         case STATUS_UNKNOWN:
3916                             // add to dependency list of target
3917                             if (deps[target] == null) {
3918                                 deps[target] = new HandleList();
3919                             }
3920                             deps[target].add(dependent);
3921 
3922                             // remember lowest unresolved target seen
3923                             if (lowDep &lt; 0 || lowDep &gt; target) {
3924                                 lowDep = target;
3925                             }
3926                             break;
3927 
3928                         default:
3929                             throw new InternalError();
3930                     }
3931                     break;
3932 
3933                 case STATUS_EXCEPTION:
3934                     break;
3935 
3936                 default:
3937                     throw new InternalError();
3938             }
3939         }
3940 
3941         /**
3942          * Associates a ClassNotFoundException (if one not already associated)
3943          * with the currently active handle and propagates it to other
3944          * referencing objects as appropriate.  The specified handle must be
3945          * &quot;open&quot; (i.e., assigned, but not finished yet).
3946          */
3947         void markException(int handle, ClassNotFoundException ex) {
3948             switch (status[handle]) {
3949                 case STATUS_UNKNOWN:
3950                     status[handle] = STATUS_EXCEPTION;
3951                     entries[handle] = ex;
3952 
3953                     // propagate exception to dependents
3954                     HandleList dlist = deps[handle];
3955                     if (dlist != null) {
3956                         int ndeps = dlist.size();
3957                         for (int i = 0; i &lt; ndeps; i++) {
3958                             markException(dlist.get(i), ex);
3959                         }
3960                         deps[handle] = null;
3961                     }
3962                     break;
3963 
3964                 case STATUS_EXCEPTION:
3965                     break;
3966 
3967                 default:
3968                     throw new InternalError();
3969             }
3970         }
3971 
3972         /**
3973          * Marks given handle as finished, meaning that no new dependencies
3974          * will be marked for handle.  Calls to the assign and finish methods
3975          * must occur in LIFO order.
3976          */
3977         void finish(int handle) {
3978             int end;
3979             if (lowDep &lt; 0) {
3980                 // no pending unknowns, only resolve current handle
3981                 end = handle + 1;
3982             } else if (lowDep &gt;= handle) {
3983                 // pending unknowns now clearable, resolve all upward handles
3984                 end = size;
3985                 lowDep = -1;
3986             } else {
3987                 // unresolved backrefs present, can&#39;t resolve anything yet
3988                 return;
3989             }
3990 
3991             // change STATUS_UNKNOWN -&gt; STATUS_OK in selected span of handles
3992             for (int i = handle; i &lt; end; i++) {
3993                 switch (status[i]) {
3994                     case STATUS_UNKNOWN:
3995                         status[i] = STATUS_OK;
3996                         deps[i] = null;
3997                         break;
3998 
3999                     case STATUS_OK:
4000                     case STATUS_EXCEPTION:
4001                         break;
4002 
4003                     default:
4004                         throw new InternalError();
4005                 }
4006             }
4007         }
4008 
4009         /**
4010          * Assigns a new object to the given handle.  The object previously
4011          * associated with the handle is forgotten.  This method has no effect
4012          * if the given handle already has an exception associated with it.
4013          * This method may be called at any time after the handle is assigned.
4014          */
4015         void setObject(int handle, Object obj) {
4016             switch (status[handle]) {
4017                 case STATUS_UNKNOWN:
4018                 case STATUS_OK:
4019                     entries[handle] = obj;
4020                     break;
4021 
4022                 case STATUS_EXCEPTION:
4023                     break;
4024 
4025                 default:
4026                     throw new InternalError();
4027             }
4028         }
4029 
4030         /**
4031          * Looks up and returns object associated with the given handle.
4032          * Returns null if the given handle is NULL_HANDLE, or if it has an
4033          * associated ClassNotFoundException.
4034          */
4035         Object lookupObject(int handle) {
4036             return (handle != NULL_HANDLE &amp;&amp;
4037                     status[handle] != STATUS_EXCEPTION) ?
4038                 entries[handle] : null;
4039         }
4040 
4041         /**
4042          * Looks up and returns ClassNotFoundException associated with the
4043          * given handle.  Returns null if the given handle is NULL_HANDLE, or
4044          * if there is no ClassNotFoundException associated with the handle.
4045          */
4046         ClassNotFoundException lookupException(int handle) {
4047             return (handle != NULL_HANDLE &amp;&amp;
4048                     status[handle] == STATUS_EXCEPTION) ?
4049                 (ClassNotFoundException) entries[handle] : null;
4050         }
4051 
4052         /**
4053          * Resets table to its initial state.
4054          */
4055         void clear() {
4056             Arrays.fill(status, 0, size, (byte) 0);
4057             Arrays.fill(entries, 0, size, null);
4058             Arrays.fill(deps, 0, size, null);
4059             lowDep = -1;
4060             size = 0;
4061         }
4062 
4063         /**
4064          * Returns number of handles registered in table.
4065          */
4066         int size() {
4067             return size;
4068         }
4069 
4070         /**
4071          * Expands capacity of internal arrays.
4072          */
4073         private void grow() {
4074             int newCapacity = (entries.length &lt;&lt; 1) + 1;
4075 
4076             byte[] newStatus = new byte[newCapacity];
4077             Object[] newEntries = new Object[newCapacity];
4078             HandleList[] newDeps = new HandleList[newCapacity];
4079 
4080             System.arraycopy(status, 0, newStatus, 0, size);
4081             System.arraycopy(entries, 0, newEntries, 0, size);
4082             System.arraycopy(deps, 0, newDeps, 0, size);
4083 
4084             status = newStatus;
4085             entries = newEntries;
4086             deps = newDeps;
4087         }
4088 
4089         /**
4090          * Simple growable list of (integer) handles.
4091          */
4092         private static class HandleList {
4093             private int[] list = new int[4];
4094             private int size = 0;
4095 
4096             public HandleList() {
4097             }
4098 
4099             public void add(int handle) {
4100                 if (size &gt;= list.length) {
4101                     int[] newList = new int[list.length &lt;&lt; 1];
4102                     System.arraycopy(list, 0, newList, 0, list.length);
4103                     list = newList;
4104                 }
4105                 list[size++] = handle;
4106             }
4107 
4108             public int get(int index) {
4109                 if (index &gt;= size) {
4110                     throw new ArrayIndexOutOfBoundsException();
4111                 }
4112                 return list[index];
4113             }
4114 
4115             public int size() {
4116                 return size;
4117             }
4118         }
4119     }
4120 
4121     /**
4122      * Method for cloning arrays in case of using unsharing reading
4123      */
4124     private static Object cloneArray(Object array) {
4125         if (array instanceof Object[]) {
4126             return ((Object[]) array).clone();
4127         } else if (array instanceof boolean[]) {
4128             return ((boolean[]) array).clone();
4129         } else if (array instanceof byte[]) {
4130             return ((byte[]) array).clone();
4131         } else if (array instanceof char[]) {
4132             return ((char[]) array).clone();
4133         } else if (array instanceof double[]) {
4134             return ((double[]) array).clone();
4135         } else if (array instanceof float[]) {
4136             return ((float[]) array).clone();
4137         } else if (array instanceof int[]) {
4138             return ((int[]) array).clone();
4139         } else if (array instanceof long[]) {
4140             return ((long[]) array).clone();
4141         } else if (array instanceof short[]) {
4142             return ((short[]) array).clone();
4143         } else {
4144             throw new AssertionError();
4145         }
4146     }
4147 
4148     static {
4149         SharedSecrets.setJavaObjectInputStreamAccess(ObjectInputStream::checkArray);
4150         SharedSecrets.setJavaObjectInputStreamReadString(ObjectInputStream::readString);
4151     }
4152 
4153 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/zip/ZipFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util.zip;
  27 
  28 import java.io.Closeable;
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.EOFException;
  32 import java.io.File;
  33 import java.io.RandomAccessFile;
  34 import java.io.UncheckedIOException;
  35 import java.lang.ref.Cleaner.Cleanable;
  36 import java.nio.charset.Charset;
  37 import java.nio.file.InvalidPathException;
  38 import java.nio.file.attribute.BasicFileAttributes;
  39 import java.nio.file.Files;
  40 import java.util.ArrayDeque;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collections;
  44 import java.util.Deque;
  45 import java.util.Enumeration;
  46 import java.util.HashMap;
  47 import java.util.Iterator;
  48 import java.util.Objects;
  49 import java.util.NoSuchElementException;
  50 import java.util.Set;
  51 import java.util.Spliterator;
  52 import java.util.Spliterators;
  53 import java.util.TreeSet;
  54 import java.util.WeakHashMap;
  55 import java.util.function.Consumer;
  56 import java.util.function.Function;
  57 import java.util.function.IntFunction;
  58 import java.util.jar.JarEntry;
  59 import java.util.jar.JarFile;
  60 import java.util.stream.Stream;
  61 import java.util.stream.StreamSupport;
  62 import jdk.internal.access.JavaUtilZipFileAccess;
  63 import jdk.internal.access.SharedSecrets;
  64 import jdk.internal.misc.VM;
  65 import jdk.internal.perf.PerfCounter;
  66 import jdk.internal.ref.CleanerFactory;
  67 import jdk.internal.vm.annotation.Stable;
  68 import sun.nio.cs.UTF_8;
  69 
  70 import static java.util.zip.ZipConstants64.*;
  71 import static java.util.zip.ZipUtils.*;
  72 
  73 /**
  74  * This class is used to read entries from a zip file.
  75  *
  76  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  77  * or method in this class will cause a {@link NullPointerException} to be
  78  * thrown.
  79  *
  80  * @apiNote
  81  * To release resources used by this {@code ZipFile}, the {@link #close()} method
  82  * should be called explicitly or by try-with-resources. Subclasses are responsible
  83  * for the cleanup of resources acquired by the subclass. Subclasses that override
  84  * {@link #finalize()} in order to perform cleanup should be modified to use alternative
  85  * cleanup mechanisms such as {@link java.lang.ref.Cleaner} and remove the overriding
  86  * {@code finalize} method.
  87  *
  88  * @author      David Connelly
  89  * @since 1.1
  90  */
  91 public class ZipFile implements ZipConstants, Closeable {
  92 
  93     private final String name;     // zip file name
  94     private volatile boolean closeRequested;
  95     private final @Stable ZipCoder zc;
  96 
  97     // The &quot;resource&quot; used by this zip file that needs to be
  98     // cleaned after use.
  99     // a) the input streams that need to be closed
 100     // b) the list of cached Inflater objects
 101     // c) the &quot;native&quot; source of this zip file.
 102     private final @Stable CleanableResource res;
 103 
 104     private static final int STORED = ZipEntry.STORED;
 105     private static final int DEFLATED = ZipEntry.DEFLATED;
 106 
 107     /**
 108      * Mode flag to open a zip file for reading.
 109      */
 110     public static final int OPEN_READ = 0x1;
 111 
 112     /**
 113      * Mode flag to open a zip file and mark it for deletion.  The file will be
 114      * deleted some time between the moment that it is opened and the moment
 115      * that it is closed, but its contents will remain accessible via the
 116      * {@code ZipFile} object until either the close method is invoked or the
 117      * virtual machine exits.
 118      */
 119     public static final int OPEN_DELETE = 0x4;
 120 
 121     /**
 122      * Opens a zip file for reading.
 123      *
 124      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 125      * method is called with the {@code name} argument as its argument
 126      * to ensure the read is allowed.
 127      *
 128      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 129      * decode the entry names and comments.
 130      *
 131      * @param name the name of the zip file
 132      * @throws ZipException if a ZIP format error has occurred
 133      * @throws IOException if an I/O error has occurred
 134      * @throws SecurityException if a security manager exists and its
 135      *         {@code checkRead} method doesn&#39;t allow read access to the file.
 136      *
 137      * @see SecurityManager#checkRead(java.lang.String)
 138      */
 139     public ZipFile(String name) throws IOException {
 140         this(new File(name), OPEN_READ);
 141     }
 142 
 143     /**
 144      * Opens a new {@code ZipFile} to read from the specified
 145      * {@code File} object in the specified mode.  The mode argument
 146      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
 147      *
 148      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 149      * method is called with the {@code name} argument as its argument to
 150      * ensure the read is allowed.
 151      *
 152      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 153      * decode the entry names and comments
 154      *
 155      * @param file the ZIP file to be opened for reading
 156      * @param mode the mode in which the file is to be opened
 157      * @throws ZipException if a ZIP format error has occurred
 158      * @throws IOException if an I/O error has occurred
 159      * @throws SecurityException if a security manager exists and
 160      *         its {@code checkRead} method
 161      *         doesn&#39;t allow read access to the file,
 162      *         or its {@code checkDelete} method doesn&#39;t allow deleting
 163      *         the file when the {@code OPEN_DELETE} flag is set.
 164      * @throws IllegalArgumentException if the {@code mode} argument is invalid
 165      * @see SecurityManager#checkRead(java.lang.String)
 166      * @since 1.3
 167      */
 168     public ZipFile(File file, int mode) throws IOException {
 169         this(file, mode, UTF_8.INSTANCE);
 170     }
 171 
 172     /**
 173      * Opens a ZIP file for reading given the specified File object.
 174      *
 175      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 176      * decode the entry names and comments.
 177      *
 178      * @param file the ZIP file to be opened for reading
 179      * @throws ZipException if a ZIP format error has occurred
 180      * @throws IOException if an I/O error has occurred
 181      */
 182     public ZipFile(File file) throws ZipException, IOException {
 183         this(file, OPEN_READ);
 184     }
 185 
 186     /**
 187      * Opens a new {@code ZipFile} to read from the specified
 188      * {@code File} object in the specified mode.  The mode argument
 189      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
 190      *
 191      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 192      * method is called with the {@code name} argument as its argument to
 193      * ensure the read is allowed.
 194      *
 195      * @param file the ZIP file to be opened for reading
 196      * @param mode the mode in which the file is to be opened
 197      * @param charset
 198      *        the {@linkplain java.nio.charset.Charset charset} to
 199      *        be used to decode the ZIP entry name and comment that are not
 200      *        encoded by using UTF-8 encoding (indicated by entry&#39;s general
 201      *        purpose flag).
 202      *
 203      * @throws ZipException if a ZIP format error has occurred
 204      * @throws IOException if an I/O error has occurred
 205      *
 206      * @throws SecurityException
 207      *         if a security manager exists and its {@code checkRead}
 208      *         method doesn&#39;t allow read access to the file,or its
 209      *         {@code checkDelete} method doesn&#39;t allow deleting the
 210      *         file when the {@code OPEN_DELETE} flag is set
 211      *
 212      * @throws IllegalArgumentException if the {@code mode} argument is invalid
 213      *
 214      * @see SecurityManager#checkRead(java.lang.String)
 215      *
 216      * @since 1.7
 217      */
 218     public ZipFile(File file, int mode, Charset charset) throws IOException
 219     {
 220         if (((mode &amp; OPEN_READ) == 0) ||
 221             ((mode &amp; ~(OPEN_READ | OPEN_DELETE)) != 0)) {
 222             throw new IllegalArgumentException(&quot;Illegal mode: 0x&quot;+
 223                                                Integer.toHexString(mode));
 224         }
 225         String name = file.getPath();
 226         SecurityManager sm = System.getSecurityManager();
 227         if (sm != null) {
 228             sm.checkRead(name);
 229             if ((mode &amp; OPEN_DELETE) != 0) {
 230                 sm.checkDelete(name);
 231             }
 232         }
 233         Objects.requireNonNull(charset, &quot;charset&quot;);
 234 
 235         this.zc = ZipCoder.get(charset);
 236         this.name = name;
 237         long t0 = System.nanoTime();
 238 
 239         this.res = new CleanableResource(this, file, mode);
 240 
 241         PerfCounter.getZipFileOpenTime().addElapsedTimeFrom(t0);
 242         PerfCounter.getZipFileCount().increment();
 243     }
 244 
 245     /**
 246      * Opens a zip file for reading.
 247      *
 248      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 249      * method is called with the {@code name} argument as its argument
 250      * to ensure the read is allowed.
 251      *
 252      * @param name the name of the zip file
 253      * @param charset
 254      *        the {@linkplain java.nio.charset.Charset charset} to
 255      *        be used to decode the ZIP entry name and comment that are not
 256      *        encoded by using UTF-8 encoding (indicated by entry&#39;s general
 257      *        purpose flag).
 258      *
 259      * @throws ZipException if a ZIP format error has occurred
 260      * @throws IOException if an I/O error has occurred
 261      * @throws SecurityException
 262      *         if a security manager exists and its {@code checkRead}
 263      *         method doesn&#39;t allow read access to the file
 264      *
 265      * @see SecurityManager#checkRead(java.lang.String)
 266      *
 267      * @since 1.7
 268      */
 269     public ZipFile(String name, Charset charset) throws IOException
 270     {
 271         this(new File(name), OPEN_READ, charset);
 272     }
 273 
 274     /**
 275      * Opens a ZIP file for reading given the specified File object.
 276      *
 277      * @param file the ZIP file to be opened for reading
 278      * @param charset
 279      *        The {@linkplain java.nio.charset.Charset charset} to be
 280      *        used to decode the ZIP entry name and comment (ignored if
 281      *        the &lt;a href=&quot;package-summary.html#lang_encoding&quot;&gt; language
 282      *        encoding bit&lt;/a&gt; of the ZIP entry&#39;s general purpose bit
 283      *        flag is set).
 284      *
 285      * @throws ZipException if a ZIP format error has occurred
 286      * @throws IOException if an I/O error has occurred
 287      *
 288      * @since 1.7
 289      */
 290     public ZipFile(File file, Charset charset) throws IOException
 291     {
 292         this(file, OPEN_READ, charset);
 293     }
 294 
 295     /**
 296      * Returns the zip file comment, or null if none.
 297      *
 298      * @return the comment string for the zip file, or null if none
 299      *
 300      * @throws IllegalStateException if the zip file has been closed
 301      *
 302      * @since 1.7
 303      */
 304     public String getComment() {
 305         synchronized (this) {
 306             ensureOpen();
 307             if (res.zsrc.comment == null) {
 308                 return null;
 309             }
 310             return zc.toString(res.zsrc.comment);
 311         }
 312     }
 313 
 314     /**
 315      * Returns the zip file entry for the specified name, or null
 316      * if not found.
 317      *
 318      * @param name the name of the entry
 319      * @return the zip file entry, or null if not found
 320      * @throws IllegalStateException if the zip file has been closed
 321      */
 322     public ZipEntry getEntry(String name) {
 323         return getEntry(name, ZipEntry::new);
 324     }
 325 
 326     /*
 327      * Returns the zip file entry for the specified name, or null
 328      * if not found.
 329      *
 330      * @param name the name of the entry
 331      * @param func the function that creates the returned entry
 332      *
 333      * @return the zip file entry, or null if not found
 334      * @throws IllegalStateException if the zip file has been closed
 335      */
 336     private ZipEntry getEntry(String name, Function&lt;String, ? extends ZipEntry&gt; func) {
 337         Objects.requireNonNull(name, &quot;name&quot;);
 338         synchronized (this) {
 339             ensureOpen();
 340             byte[] bname = zc.getBytes(name);
 341             int pos = res.zsrc.getEntryPos(bname, true);
 342             if (pos != -1) {
 343                 return getZipEntry(name, bname, pos, func);
 344             }
 345         }
 346         return null;
 347     }
 348 
 349     /**
 350      * Returns an input stream for reading the contents of the specified
 351      * zip file entry.
 352      * &lt;p&gt;
 353      * Closing this ZIP file will, in turn, close all input streams that
 354      * have been returned by invocations of this method.
 355      *
 356      * @param entry the zip file entry
 357      * @return the input stream for reading the contents of the specified
 358      * zip file entry.
 359      * @throws ZipException if a ZIP format error has occurred
 360      * @throws IOException if an I/O error has occurred
 361      * @throws IllegalStateException if the zip file has been closed
 362      */
 363     public InputStream getInputStream(ZipEntry entry) throws IOException {
 364         Objects.requireNonNull(entry, &quot;entry&quot;);
 365         int pos = -1;
 366         ZipFileInputStream in;
 367         Source zsrc = res.zsrc;
 368         Set&lt;InputStream&gt; istreams = res.istreams;
 369         synchronized (this) {
 370             ensureOpen();
 371             if (Objects.equals(lastEntryName, entry.name)) {
 372                 pos = lastEntryPos;
 373             } else if (!zc.isUTF8() &amp;&amp; (entry.flag &amp; USE_UTF8) != 0) {
 374                 pos = zsrc.getEntryPos(zc.getBytesUTF8(entry.name), false);
 375             } else {
 376                 pos = zsrc.getEntryPos(zc.getBytes(entry.name), false);
 377             }
 378             if (pos == -1) {
 379                 return null;
 380             }
 381             in = new ZipFileInputStream(zsrc.cen, pos);
 382             switch (CENHOW(zsrc.cen, pos)) {
 383             case STORED:
 384                 synchronized (istreams) {
 385                     istreams.add(in);
 386                 }
 387                 return in;
 388             case DEFLATED:
 389                 // Inflater likes a bit of slack
 390                 // MORE: Compute good size for inflater stream:
 391                 long size = CENLEN(zsrc.cen, pos) + 2;
 392                 if (size &gt; 65536) {
 393                     size = 8192;
 394                 }
 395                 if (size &lt;= 0) {
 396                     size = 4096;
 397                 }
 398                 InputStream is = new ZipFileInflaterInputStream(in, res, (int)size);
 399                 synchronized (istreams) {
 400                     istreams.add(is);
 401                 }
 402                 return is;
 403             default:
 404                 throw new ZipException(&quot;invalid compression method&quot;);
 405             }
 406         }
 407     }
 408 
 409     private static class InflaterCleanupAction implements Runnable {
 410         private final Inflater inf;
 411         private final CleanableResource res;
 412 
 413         InflaterCleanupAction(Inflater inf, CleanableResource res) {
 414             this.inf = inf;
 415             this.res = res;
 416         }
 417 
 418         @Override
 419         public void run() {
 420             res.releaseInflater(inf);
 421         }
 422     }
 423 
 424     private class ZipFileInflaterInputStream extends InflaterInputStream {
 425         private volatile boolean closeRequested;
 426         private boolean eof = false;
 427         private final Cleanable cleanable;
 428 
 429         ZipFileInflaterInputStream(ZipFileInputStream zfin,
 430                                    CleanableResource res, int size) {
 431             this(zfin, res, res.getInflater(), size);
 432         }
 433 
 434         private ZipFileInflaterInputStream(ZipFileInputStream zfin,
 435                                            CleanableResource res,
 436                                            Inflater inf, int size) {
 437             super(zfin, inf, size);
 438             this.cleanable = CleanerFactory.cleaner().register(this,
 439                     new InflaterCleanupAction(inf, res));
 440         }
 441 
 442         public void close() throws IOException {
 443             if (closeRequested)
 444                 return;
 445             closeRequested = true;
 446             super.close();
 447             synchronized (res.istreams) {
 448                 res.istreams.remove(this);
 449             }
 450             cleanable.clean();
 451         }
 452 
 453         // Override fill() method to provide an extra &quot;dummy&quot; byte
 454         // at the end of the input stream. This is required when
 455         // using the &quot;nowrap&quot; Inflater option.
 456         protected void fill() throws IOException {
 457             if (eof) {
 458                 throw new EOFException(&quot;Unexpected end of ZLIB input stream&quot;);
 459             }
 460             len = in.read(buf, 0, buf.length);
 461             if (len == -1) {
 462                 buf[0] = 0;
 463                 len = 1;
 464                 eof = true;
 465             }
 466             inf.setInput(buf, 0, len);
 467         }
 468 
 469         public int available() throws IOException {
 470             if (closeRequested)
 471                 return 0;
 472             long avail = ((ZipFileInputStream)in).size() - inf.getBytesWritten();
 473             return (avail &gt; (long) Integer.MAX_VALUE ?
 474                     Integer.MAX_VALUE : (int) avail);
 475         }
 476     }
 477 
 478     /**
 479      * Returns the path name of the ZIP file.
 480      * @return the path name of the ZIP file
 481      */
 482     public String getName() {
 483         return name;
 484     }
 485 
 486     private class ZipEntryIterator&lt;T extends ZipEntry&gt;
 487             implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; {
 488 
 489         private int i = 0;
 490         private final int entryCount;
 491         private final Function&lt;String, T&gt; gen;
 492 
 493         public ZipEntryIterator(int entryCount, Function&lt;String, T&gt; gen) {
 494             this.entryCount = entryCount;
 495             this.gen = gen;
 496         }
 497 
 498         @Override
 499         public boolean hasMoreElements() {
 500             return hasNext();
 501         }
 502 
 503         @Override
 504         public boolean hasNext() {
 505             return i &lt; entryCount;
 506         }
 507 
 508         @Override
 509         public T nextElement() {
 510             return next();
 511         }
 512 
 513         @Override
 514         @SuppressWarnings(&quot;unchecked&quot;)
 515         public T next() {
 516             synchronized (ZipFile.this) {
 517                 ensureOpen();
 518                 if (!hasNext()) {
 519                     throw new NoSuchElementException();
 520                 }
 521                 // each &quot;entry&quot; has 3 ints in table entries
 522                 return (T)getZipEntry(null, null, res.zsrc.getEntryPos(i++ * 3), gen);
 523             }
 524         }
 525 
 526         @Override
 527         public Iterator&lt;T&gt; asIterator() {
 528             return this;
 529         }
 530     }
 531 
 532     /**
 533      * Returns an enumeration of the ZIP file entries.
 534      * @return an enumeration of the ZIP file entries
 535      * @throws IllegalStateException if the zip file has been closed
 536      */
 537     public Enumeration&lt;? extends ZipEntry&gt; entries() {
 538         synchronized (this) {
 539             ensureOpen();
 540             return new ZipEntryIterator&lt;ZipEntry&gt;(res.zsrc.total, ZipEntry::new);
 541         }
 542     }
 543 
 544     private Enumeration&lt;JarEntry&gt; entries(Function&lt;String, JarEntry&gt; func) {
 545         synchronized (this) {
 546             ensureOpen();
 547             return new ZipEntryIterator&lt;JarEntry&gt;(res.zsrc.total, func);
 548         }
 549     }
 550 
 551     private class EntrySpliterator&lt;T&gt; extends Spliterators.AbstractSpliterator&lt;T&gt; {
 552         private int index;
 553         private final int fence;
 554         private final IntFunction&lt;T&gt; gen;
 555 
 556         EntrySpliterator(int index, int fence, IntFunction&lt;T&gt; gen) {
 557             super((long)fence,
 558                   Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.IMMUTABLE |
 559                   Spliterator.NONNULL);
 560             this.index = index;
 561             this.fence = fence;
 562             this.gen = gen;
 563         }
 564 
 565         @Override
 566         public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
 567             if (action == null)
 568                 throw new NullPointerException();
 569             if (index &gt;= 0 &amp;&amp; index &lt; fence) {
 570                 synchronized (ZipFile.this) {
 571                     ensureOpen();
 572                     action.accept(gen.apply(res.zsrc.getEntryPos(index++ * 3)));
 573                 }
 574                 return true;
 575             }
 576             return false;
 577         }
 578     }
 579 
 580     /**
 581      * Returns an ordered {@code Stream} over the ZIP file entries.
 582      *
 583      * Entries appear in the {@code Stream} in the order they appear in
 584      * the central directory of the ZIP file.
 585      *
 586      * @return an ordered {@code Stream} of entries in this ZIP file
 587      * @throws IllegalStateException if the zip file has been closed
 588      * @since 1.8
 589      */
 590     public Stream&lt;? extends ZipEntry&gt; stream() {
 591         synchronized (this) {
 592             ensureOpen();
 593             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
 594                 pos -&gt; getZipEntry(null, null, pos, ZipEntry::new)), false);
 595        }
 596     }
 597 
 598     private String getEntryName(int pos) {
 599         byte[] cen = res.zsrc.cen;
 600         int nlen = CENNAM(cen, pos);
 601         if (!zc.isUTF8() &amp;&amp; (CENFLG(cen, pos) &amp; USE_UTF8) != 0) {
 602             return zc.toStringUTF8(cen, pos + CENHDR, nlen);
 603         } else {
 604             return zc.toString(cen, pos + CENHDR, nlen);
 605         }
 606     }
 607 
 608     /*
 609      * Returns an ordered {@code Stream} over the zip file entry names.
 610      *
 611      * Entry names appear in the {@code Stream} in the order they appear in
 612      * the central directory of the ZIP file.
 613      *
 614      * @return an ordered {@code Stream} of entry names in this zip file
 615      * @throws IllegalStateException if the zip file has been closed
 616      * @since 10
 617      */
 618     private Stream&lt;String&gt; entryNameStream() {
 619         synchronized (this) {
 620             ensureOpen();
 621             return StreamSupport.stream(
 622                 new EntrySpliterator&lt;&gt;(0, res.zsrc.total, this::getEntryName), false);
 623         }
 624     }
 625 
 626     /*
 627      * Returns an ordered {@code Stream} over the zip file entries.
 628      *
 629      * Entries appear in the {@code Stream} in the order they appear in
 630      * the central directory of the jar file.
 631      *
 632      * @param func the function that creates the returned entry
 633      * @return an ordered {@code Stream} of entries in this zip file
 634      * @throws IllegalStateException if the zip file has been closed
 635      * @since 10
 636      */
 637     private Stream&lt;JarEntry&gt; stream(Function&lt;String, JarEntry&gt; func) {
 638         synchronized (this) {
 639             ensureOpen();
 640             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
 641                 pos -&gt; (JarEntry)getZipEntry(null, null, pos, func)), false);
 642         }
 643     }
 644 
 645     private String lastEntryName;
 646     private int lastEntryPos;
 647 
 648     /* Checks ensureOpen() before invoke this method */
 649     private ZipEntry getZipEntry(String name, byte[] bname, int pos,
 650                                  Function&lt;String, ? extends ZipEntry&gt; func) {
 651         byte[] cen = res.zsrc.cen;
 652         int nlen = CENNAM(cen, pos);
 653         int elen = CENEXT(cen, pos);
 654         int clen = CENCOM(cen, pos);
 655         int flag = CENFLG(cen, pos);
 656         if (name == null || bname.length != nlen) {
 657             // to use the entry name stored in cen, if the passed in name is
 658             // (1) null, invoked from iterator, or
 659             // (2) not equal to the name stored, a slash is appended during
 660             // getEntryPos() search.
 661             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {
 662                 name = zc.toStringUTF8(cen, pos + CENHDR, nlen);
 663             } else {
 664                 name = zc.toString(cen, pos + CENHDR, nlen);
 665             }
 666         }
 667         ZipEntry e = func.apply(name);    //ZipEntry e = new ZipEntry(name);
 668         e.flag = flag;
 669         e.xdostime = CENTIM(cen, pos);
 670         e.crc = CENCRC(cen, pos);
 671         e.size = CENLEN(cen, pos);
 672         e.csize = CENSIZ(cen, pos);
 673         e.method = CENHOW(cen, pos);
 674         if (elen != 0) {
 675             int start = pos + CENHDR + nlen;
 676             e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
 677         }
 678         if (clen != 0) {
 679             int start = pos + CENHDR + nlen + elen;
 680             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {
 681                 e.comment = zc.toStringUTF8(cen, start, clen);
 682             } else {
 683                 e.comment = zc.toString(cen, start, clen);
 684             }
 685         }
 686         lastEntryName = e.name;
 687         lastEntryPos = pos;
 688         return e;
 689     }
 690 
 691     /**
 692      * Returns the number of entries in the ZIP file.
 693      *
 694      * @return the number of entries in the ZIP file
 695      * @throws IllegalStateException if the zip file has been closed
 696      */
 697     public int size() {
 698         synchronized (this) {
 699             ensureOpen();
 700             return res.zsrc.total;
 701         }
 702     }
 703 
 704     private static class CleanableResource implements Runnable {
 705         // The outstanding inputstreams that need to be closed
 706         final Set&lt;InputStream&gt; istreams;
 707 
 708         // List of cached Inflater objects for decompression
 709         Deque&lt;Inflater&gt; inflaterCache;
 710 
 711         final Cleanable cleanable;
 712 
 713         Source zsrc;
 714 
 715         CleanableResource(ZipFile zf, File file, int mode) throws IOException {
 716             this.cleanable = CleanerFactory.cleaner().register(zf, this);
 717             this.istreams = Collections.newSetFromMap(new WeakHashMap&lt;&gt;());
 718             this.inflaterCache = new ArrayDeque&lt;&gt;();
 719             this.zsrc = Source.get(file, (mode &amp; OPEN_DELETE) != 0);
 720         }
 721 
 722         void clean() {
 723             cleanable.clean();
 724         }
 725 
 726         /*
 727          * Gets an inflater from the list of available inflaters or allocates
 728          * a new one.
 729          */
 730         Inflater getInflater() {
 731             Inflater inf;
 732             synchronized (inflaterCache) {
 733                 if ((inf = inflaterCache.poll()) != null) {
 734                     return inf;
 735                 }
 736             }
 737             return new Inflater(true);
 738         }
 739 
 740         /*
 741          * Releases the specified inflater to the list of available inflaters.
 742          */
 743         void releaseInflater(Inflater inf) {
 744             Deque&lt;Inflater&gt; inflaters = this.inflaterCache;
 745             if (inflaters != null) {
 746                 synchronized (inflaters) {
 747                     // double checked!
 748                     if (inflaters == this.inflaterCache) {
 749                         inf.reset();
 750                         inflaters.add(inf);
 751                         return;
 752                     }
 753                 }
 754             }
 755             // inflaters cache already closed - just end it.
 756             inf.end();
 757         }
 758 
 759         public void run() {
 760             IOException ioe = null;
 761 
 762             // Release cached inflaters and close the cache first
 763             Deque&lt;Inflater&gt; inflaters = this.inflaterCache;
 764             if (inflaters != null) {
 765                 synchronized (inflaters) {
 766                     // no need to double-check as only one thread gets a
 767                     // chance to execute run() (Cleaner guarantee)...
 768                     Inflater inf;
 769                     while ((inf = inflaters.poll()) != null) {
 770                         inf.end();
 771                     }
 772                     // close inflaters cache
 773                     this.inflaterCache = null;
 774                 }
 775             }
 776 
 777             // Close streams, release their inflaters
 778             if (istreams != null) {
 779                 synchronized (istreams) {
 780                     if (!istreams.isEmpty()) {
 781                         InputStream[] copy = istreams.toArray(new InputStream[0]);
 782                         istreams.clear();
 783                         for (InputStream is : copy) {
 784                             try {
 785                                 is.close();
 786                             } catch (IOException e) {
 787                                 if (ioe == null) ioe = e;
 788                                 else ioe.addSuppressed(e);
 789                             }
 790                         }
 791                     }
 792                 }
 793             }
 794 
 795             // Release zip src
 796             if (zsrc != null) {
 797                 synchronized (zsrc) {
 798                     try {
 799                         Source.release(zsrc);
 800                         zsrc = null;
 801                     } catch (IOException e) {
 802                         if (ioe == null) ioe = e;
 803                         else ioe.addSuppressed(e);
 804                     }
 805                 }
 806             }
 807             if (ioe != null) {
 808                 throw new UncheckedIOException(ioe);
 809             }
 810         }
 811 
 812         CleanableResource(File file, int mode)
 813             throws IOException {
 814             this.cleanable = null;
 815             this.istreams = Collections.newSetFromMap(new WeakHashMap&lt;&gt;());
 816             this.inflaterCache = new ArrayDeque&lt;&gt;();
 817             this.zsrc = Source.get(file, (mode &amp; OPEN_DELETE) != 0);
 818         }
 819 
 820     }
 821 
 822     /**
 823      * Closes the ZIP file.
 824      *
 825      * &lt;p&gt; Closing this ZIP file will close all of the input streams
 826      * previously returned by invocations of the {@link #getInputStream
 827      * getInputStream} method.
 828      *
 829      * @throws IOException if an I/O error has occurred
 830      */
 831     public void close() throws IOException {
 832         if (closeRequested) {
 833             return;
 834         }
 835         closeRequested = true;
 836 
 837         synchronized (this) {
 838             // Close streams, release their inflaters, release cached inflaters
 839             // and release zip source
 840             try {
 841                 res.clean();
 842             } catch (UncheckedIOException ioe) {
 843                 throw ioe.getCause();
 844             }
 845         }
 846     }
 847 
 848     private void ensureOpen() {
 849         if (closeRequested) {
 850             throw new IllegalStateException(&quot;zip file closed&quot;);
 851         }
 852         if (res.zsrc == null) {
 853             throw new IllegalStateException(&quot;The object is not initialized.&quot;);
 854         }
 855     }
 856 
 857     private void ensureOpenOrZipException() throws IOException {
 858         if (closeRequested) {
 859             throw new ZipException(&quot;ZipFile closed&quot;);
 860         }
 861     }
 862 
 863     /*
 864      * Inner class implementing the input stream used to read a
 865      * (possibly compressed) zip file entry.
 866      */
 867     private class ZipFileInputStream extends InputStream {
 868         private volatile boolean closeRequested;
 869         private   long pos;     // current position within entry data
 870         private   long startingPos; // Start position for the entry data
 871         protected long rem;     // number of remaining bytes within entry
 872         protected long size;    // uncompressed size of this entry
 873 
 874         ZipFileInputStream(byte[] cen, int cenpos) {
 875             rem = CENSIZ(cen, cenpos);
 876             size = CENLEN(cen, cenpos);
 877             pos = CENOFF(cen, cenpos);
 878             // zip64
 879             if (rem == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL ||
 880                 pos == ZIP64_MAGICVAL) {
 881                 checkZIP64(cen, cenpos);
 882             }
 883             // negative for lazy initialization, see getDataOffset();
 884             pos = - (pos + ZipFile.this.res.zsrc.locpos);
 885         }
 886 
 887         private void checkZIP64(byte[] cen, int cenpos) {
 888             int off = cenpos + CENHDR + CENNAM(cen, cenpos);
 889             int end = off + CENEXT(cen, cenpos);
 890             while (off + 4 &lt; end) {
 891                 int tag = get16(cen, off);
 892                 int sz = get16(cen, off + 2);
 893                 off += 4;
 894                 if (off + sz &gt; end)         // invalid data
 895                     break;
 896                 if (tag == EXTID_ZIP64) {
 897                     if (size == ZIP64_MAGICVAL) {
 898                         if (sz &lt; 8 || (off + 8) &gt; end)
 899                             break;
 900                         size = get64(cen, off);
 901                         sz -= 8;
 902                         off += 8;
 903                     }
 904                     if (rem == ZIP64_MAGICVAL) {
 905                         if (sz &lt; 8 || (off + 8) &gt; end)
 906                             break;
 907                         rem = get64(cen, off);
 908                         sz -= 8;
 909                         off += 8;
 910                     }
 911                     if (pos == ZIP64_MAGICVAL) {
 912                         if (sz &lt; 8 || (off + 8) &gt; end)
 913                             break;
 914                         pos = get64(cen, off);
 915                         sz -= 8;
 916                         off += 8;
 917                     }
 918                     break;
 919                 }
 920                 off += sz;
 921             }
 922         }
 923 
 924         /*
 925          * The Zip file spec explicitly allows the LOC extra data size to
 926          * be different from the CEN extra data size. Since we cannot trust
 927          * the CEN extra data size, we need to read the LOC to determine
 928          * the entry data offset.
 929          */
 930         private long initDataOffset() throws IOException {
 931             if (pos &lt;= 0) {
 932                 byte[] loc = new byte[LOCHDR];
 933                 pos = -pos;
 934                 int len = ZipFile.this.res.zsrc.readFullyAt(loc, 0, loc.length, pos);
 935                 if (len != LOCHDR) {
 936                     throw new ZipException(&quot;ZipFile error reading zip file&quot;);
 937                 }
 938                 if (LOCSIG(loc) != LOCSIG) {
 939                     throw new ZipException(&quot;ZipFile invalid LOC header (bad signature)&quot;);
 940                 }
 941                 pos += LOCHDR + LOCNAM(loc) + LOCEXT(loc);
 942                 startingPos = pos; // Save starting position for the entry
 943             }
 944             return pos;
 945         }
 946 
 947         public int read(byte b[], int off, int len) throws IOException {
 948             synchronized (ZipFile.this) {
 949                 ensureOpenOrZipException();
 950                 initDataOffset();
 951                 if (rem == 0) {
 952                     return -1;
 953                 }
 954                 if (len &gt; rem) {
 955                     len = (int) rem;
 956                 }
 957                 if (len &lt;= 0) {
 958                     return 0;
 959                 }
 960                 len = ZipFile.this.res.zsrc.readAt(b, off, len, pos);
 961                 if (len &gt; 0) {
 962                     pos += len;
 963                     rem -= len;
 964                 }
 965             }
 966             if (rem == 0) {
 967                 close();
 968             }
 969             return len;
 970         }
 971 
 972         public int read() throws IOException {
 973             byte[] b = new byte[1];
 974             if (read(b, 0, 1) == 1) {
 975                 return b[0] &amp; 0xff;
 976             } else {
 977                 return -1;
 978             }
 979         }
 980 
 981         public long skip(long n) throws IOException {
 982             synchronized (ZipFile.this) {
 983                 initDataOffset();
 984                 long newPos = pos + n;
 985                 if (n &gt; 0) {
 986                     // If we overflowed adding the skip value or are moving
 987                     // past EOF, set the skip value to number of bytes remaining
 988                     // to reach EOF
 989                     if (newPos &lt; 0 || n &gt; rem) {
 990                         n = rem;
 991                     }
 992                 } else if (newPos &lt; startingPos) {
 993                     // Tried to position before BOF so set position to the
 994                     // BOF and return the number of bytes we moved backwards
 995                     // to reach BOF
 996                     n = startingPos - pos;
 997                 }
 998                 pos += n;
 999                 rem -= n;
1000             }
1001             if (rem == 0) {
1002                 close();
1003             }
1004             return n;
1005         }
1006 
1007         public int available() {
1008             return rem &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) rem;
1009         }
1010 
1011         public long size() {
1012             return size;
1013         }
1014 
1015         public void close() {
1016             if (closeRequested) {
1017                 return;
1018             }
1019             closeRequested = true;
1020             rem = 0;
1021             synchronized (res.istreams) {
1022                 res.istreams.remove(this);
1023             }
1024         }
1025 
1026     }
1027 
1028     /**
1029      * Returns the names of all non-directory entries that begin with
1030      * &quot;META-INF/&quot; (case ignored). This method is used in JarFile, via
1031      * SharedSecrets, as an optimization when looking up manifest and
1032      * signature file entries. Returns null if no entries were found.
1033      */
1034     private String[] getMetaInfEntryNames() {
1035         synchronized (this) {
1036             ensureOpen();
1037             Source zsrc = res.zsrc;
1038             if (zsrc.metanames == null) {
1039                 return null;
1040             }
1041             String[] names = new String[zsrc.metanames.length];
1042             byte[] cen = zsrc.cen;
1043             for (int i = 0; i &lt; names.length; i++) {
1044                 int pos = zsrc.metanames[i];
1045                 names[i] = new String(cen, pos + CENHDR, CENNAM(cen, pos),
1046                                       UTF_8.INSTANCE);
1047             }
1048             return names;
1049         }
1050     }
1051 
1052     /**
1053      * Returns the versions for which there exists a non-directory
1054      * entry that begin with &quot;META-INF/versions/&quot; (case ignored).
1055      * This method is used in JarFile, via SharedSecrets, as an
1056      * optimization when looking up potentially versioned entries.
1057      * Returns an empty array if no versioned entries exist.
1058      */
1059     private int[] getMetaInfVersions() {
1060         synchronized (this) {
1061             ensureOpen();
1062             return res.zsrc.metaVersions;
1063         }
1064     }
1065 
1066     private static boolean isWindows;
1067 
1068     static {
1069         SharedSecrets.setJavaUtilZipFileAccess(
1070             new JavaUtilZipFileAccess() {
1071                 @Override
1072                 public boolean startsWithLocHeader(ZipFile zip) {
1073                     return zip.res.zsrc.startsWithLoc;
1074                 }
1075                 @Override
1076                 public String[] getMetaInfEntryNames(JarFile jar) {
1077                     return ((ZipFile)jar).getMetaInfEntryNames();
1078                 }
1079                 @Override
1080                 public int[] getMetaInfVersions(JarFile jar) {
1081                     return ((ZipFile)jar).getMetaInfVersions();
1082                 }
1083                 @Override
1084                 public JarEntry getEntry(ZipFile zip, String name,
1085                     Function&lt;String, JarEntry&gt; func) {
1086                     return (JarEntry)zip.getEntry(name, func);
1087                 }
1088                 @Override
1089                 public Enumeration&lt;JarEntry&gt; entries(ZipFile zip,
1090                     Function&lt;String, JarEntry&gt; func) {
1091                     return zip.entries(func);
1092                 }
1093                 @Override
1094                 public Stream&lt;JarEntry&gt; stream(ZipFile zip,
1095                     Function&lt;String, JarEntry&gt; func) {
1096                     return zip.stream(func);
1097                 }
1098                 @Override
1099                 public Stream&lt;String&gt; entryNameStream(ZipFile zip) {
1100                     return zip.entryNameStream();
1101                 }
1102              }
1103         );
1104         isWindows = VM.getSavedProperty(&quot;os.name&quot;).contains(&quot;Windows&quot;);
1105     }
1106 
1107     private static class Source {
1108         // &quot;META-INF/&quot;.length()
1109         private static final int META_INF_LENGTH = 9;
1110         private static final int[] EMPTY_META_VERSIONS = new int[0];
1111 
1112         private final Key key;               // the key in files
1113         private int refs = 1;
1114 
1115         private RandomAccessFile zfile;      // zfile of the underlying zip file
1116         private byte[] cen;                  // CEN &amp; ENDHDR
1117         private long locpos;                 // position of first LOC header (usually 0)
1118         private byte[] comment;              // zip file comment
1119                                              // list of meta entries in META-INF dir
1120         private int[] metanames;
1121         private int[] metaVersions;          // list of unique versions found in META-INF/versions/
1122         private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)
1123 
1124         // A Hashmap for all entries.
1125         //
1126         // A cen entry of Zip/JAR file. As we have one for every entry in every active Zip/JAR,
1127         // We might have a lot of these in a typical system. In order to save space we don&#39;t
1128         // keep the name in memory, but merely remember a 32 bit {@code hash} value of the
1129         // entry name and its offset {@code pos} in the central directory hdeader.
1130         //
1131         // private static class Entry {
1132         //     int hash;       // 32 bit hashcode on name
1133         //     int next;       // hash chain: index into entries
1134         //     int pos;        // Offset of central directory file header
1135         // }
1136         // private Entry[] entries;             // array of hashed cen entry
1137         //
1138         // To reduce the total size of entries further, we use a int[] here to store 3 &quot;int&quot;
1139         // {@code hash}, {@code next and {@code &quot;pos for each entry. The entry can then be
1140         // referred by their index of their positions in the {@code entries}.
1141         //
1142         private int[] entries;                  // array of hashed cen entry
1143         private int addEntry(int index, int hash, int next, int pos) {
1144             entries[index++] = hash;
1145             entries[index++] = next;
1146             entries[index++] = pos;
1147             return index;
1148         }
1149         private int getEntryHash(int index) { return entries[index]; }
1150         private int getEntryNext(int index) { return entries[index + 1]; }
1151         private int getEntryPos(int index)  { return entries[index + 2]; }
1152         private static final int ZIP_ENDCHAIN  = -1;
1153         private int total;                   // total number of entries
1154         private int[] table;                 // Hash chain heads: indexes into entries
1155         private int tablelen;                // number of hash heads
1156 
1157         private static class Key {
1158             BasicFileAttributes attrs;
1159             File file;
1160 
1161             public Key(File file, BasicFileAttributes attrs) {
1162                 this.attrs = attrs;
1163                 this.file = file;
1164             }
1165 
1166             public int hashCode() {
1167                 long t = attrs.lastModifiedTime().toMillis();
1168                 return ((int)(t ^ (t &gt;&gt;&gt; 32))) + file.hashCode();
1169             }
1170 
1171             public boolean equals(Object obj) {
1172                 if (obj instanceof Key) {
1173                     Key key = (Key)obj;
1174                     if (!attrs.lastModifiedTime().equals(key.attrs.lastModifiedTime())) {
1175                         return false;
1176                     }
1177                     Object fk = attrs.fileKey();
1178                     if (fk != null) {
1179                         return fk.equals(key.attrs.fileKey());
1180                     } else {
1181                         return file.equals(key.file);
1182                     }
1183                 }
1184                 return false;
1185             }
1186         }
1187         private static final HashMap&lt;Key, Source&gt; files = new HashMap&lt;&gt;();
1188 
1189 
1190         static Source get(File file, boolean toDelete) throws IOException {
1191             final Key key;
1192             try {
1193                 key = new Key(file,
1194                         Files.readAttributes(file.toPath(), BasicFileAttributes.class));
1195             } catch (InvalidPathException ipe) {
1196                 throw new IOException(ipe);
1197             }
1198             Source src;
1199             synchronized (files) {
1200                 src = files.get(key);
1201                 if (src != null) {
1202                     src.refs++;
1203                     return src;
1204                 }
1205             }
1206             src = new Source(key, toDelete);
1207 
1208             synchronized (files) {
1209                 if (files.containsKey(key)) {    // someone else put in first
1210                     src.close();                 // close the newly created one
1211                     src = files.get(key);
1212                     src.refs++;
1213                     return src;
1214                 }
1215                 files.put(key, src);
1216                 return src;
1217             }
1218         }
1219 
1220         static void release(Source src) throws IOException {
1221             synchronized (files) {
1222                 if (src != null &amp;&amp; --src.refs == 0) {
1223                     files.remove(src.key);
1224                     src.close();
1225                 }
1226             }
1227         }
1228 
1229         private Source(Key key, boolean toDelete) throws IOException {
1230             this.key = key;
1231             if (toDelete) {
1232                 if (isWindows) {
1233                     this.zfile = SharedSecrets.getJavaIORandomAccessFileAccess()
1234                                               .openAndDelete(key.file, &quot;r&quot;);
1235                 } else {
1236                     this.zfile = new RandomAccessFile(key.file, &quot;r&quot;);
1237                     key.file.delete();
1238                 }
1239             } else {
1240                 this.zfile = new RandomAccessFile(key.file, &quot;r&quot;);
1241             }
1242             try {
1243                 initCEN(-1);
1244                 byte[] buf = new byte[4];
1245                 readFullyAt(buf, 0, 4, 0);
1246                 this.startsWithLoc = (LOCSIG(buf) == LOCSIG);
1247             } catch (IOException x) {
1248                 try {
1249                     this.zfile.close();
1250                 } catch (IOException xx) {}
1251                 throw x;
1252             }
1253         }
1254 
1255         private void close() throws IOException {
1256             zfile.close();
1257             zfile = null;
1258             cen = null;
1259             entries = null;
1260             table = null;
1261             metanames = null;
1262             metaVersions = EMPTY_META_VERSIONS;
1263         }
1264 
1265         private static final int BUF_SIZE = 8192;
1266         private final int readFullyAt(byte[] buf, int off, int len, long pos)
1267             throws IOException
1268         {
1269             synchronized (zfile) {
1270                 zfile.seek(pos);
1271                 int N = len;
1272                 while (N &gt; 0) {
1273                     int n = Math.min(BUF_SIZE, N);
1274                     zfile.readFully(buf, off, n);
1275                     off += n;
1276                     N -= n;
1277                 }
1278                 return len;
1279             }
1280         }
1281 
1282         private final int readAt(byte[] buf, int off, int len, long pos)
1283             throws IOException
1284         {
1285             synchronized (zfile) {
1286                 zfile.seek(pos);
1287                 return zfile.read(buf, off, len);
1288             }
1289         }
1290 
1291         private static final int hashN(byte[] a, int off, int len) {
1292             int h = 1;
1293             while (len-- &gt; 0) {
1294                 h = 31 * h + a[off++];
1295             }
1296             return h;
1297         }
1298 
1299         private static final int hashAppend(int hash, byte b) {
1300             return hash * 31 + b;
1301         }
1302 
1303         private static class End {
1304             int  centot;     // 4 bytes
1305             long cenlen;     // 4 bytes
1306             long cenoff;     // 4 bytes
1307             long endpos;     // 4 bytes
1308         }
1309 
1310         /*
1311          * Searches for end of central directory (END) header. The contents of
1312          * the END header will be read and placed in endbuf. Returns the file
1313          * position of the END header, otherwise returns -1 if the END header
1314          * was not found or an error occurred.
1315          */
1316         private End findEND() throws IOException {
1317             long ziplen = zfile.length();
1318             if (ziplen &lt;= 0)
1319                 zerror(&quot;zip file is empty&quot;);
1320             End end = new End();
1321             byte[] buf = new byte[READBLOCKSZ];
1322             long minHDR = (ziplen - END_MAXLEN) &gt; 0 ? ziplen - END_MAXLEN : 0;
1323             long minPos = minHDR - (buf.length - ENDHDR);
1324             for (long pos = ziplen - buf.length; pos &gt;= minPos; pos -= (buf.length - ENDHDR)) {
1325                 int off = 0;
1326                 if (pos &lt; 0) {
1327                     // Pretend there are some NUL bytes before start of file
1328                     off = (int)-pos;
1329                     Arrays.fill(buf, 0, off, (byte)0);
1330                 }
1331                 int len = buf.length - off;
1332                 if (readFullyAt(buf, off, len, pos + off) != len ) {
1333                     zerror(&quot;zip END header not found&quot;);
1334                 }
1335                 // Now scan the block backwards for END header signature
1336                 for (int i = buf.length - ENDHDR; i &gt;= 0; i--) {
1337                     if (buf[i+0] == (byte)&#39;P&#39;    &amp;&amp;
1338                         buf[i+1] == (byte)&#39;K&#39;    &amp;&amp;
1339                         buf[i+2] == (byte)&#39;\005&#39; &amp;&amp;
1340                         buf[i+3] == (byte)&#39;\006&#39;) {
1341                         // Found ENDSIG header
1342                         byte[] endbuf = Arrays.copyOfRange(buf, i, i + ENDHDR);
1343                         end.centot = ENDTOT(endbuf);
1344                         end.cenlen = ENDSIZ(endbuf);
1345                         end.cenoff = ENDOFF(endbuf);
1346                         end.endpos = pos + i;
1347                         int comlen = ENDCOM(endbuf);
1348                         if (end.endpos + ENDHDR + comlen != ziplen) {
1349                             // ENDSIG matched, however the size of file comment in it does
1350                             // not match the real size. One &quot;common&quot; cause for this problem
1351                             // is some &quot;extra&quot; bytes are padded at the end of the zipfile.
1352                             // Let&#39;s do some extra verification, we don&#39;t care about the
1353                             // performance in this situation.
1354                             byte[] sbuf = new byte[4];
1355                             long cenpos = end.endpos - end.cenlen;
1356                             long locpos = cenpos - end.cenoff;
1357                             if  (cenpos &lt; 0 ||
1358                                  locpos &lt; 0 ||
1359                                  readFullyAt(sbuf, 0, sbuf.length, cenpos) != 4 ||
1360                                  GETSIG(sbuf) != CENSIG ||
1361                                  readFullyAt(sbuf, 0, sbuf.length, locpos) != 4 ||
1362                                  GETSIG(sbuf) != LOCSIG) {
1363                                 continue;
1364                             }
1365                         }
1366                         if (comlen &gt; 0) {    // this zip file has comlen
1367                             comment = new byte[comlen];
1368                             if (readFullyAt(comment, 0, comlen, end.endpos + ENDHDR) != comlen) {
1369                                 zerror(&quot;zip comment read failed&quot;);
1370                             }
1371                         }
1372                         // must check for a zip64 end record; it is always permitted to be present
1373                         try {
1374                             byte[] loc64 = new byte[ZIP64_LOCHDR];
1375                             if (end.endpos &lt; ZIP64_LOCHDR ||
1376                                 readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)
1377                                 != loc64.length || GETSIG(loc64) != ZIP64_LOCSIG) {
1378                                 return end;
1379                             }
1380                             long end64pos = ZIP64_LOCOFF(loc64);
1381                             byte[] end64buf = new byte[ZIP64_ENDHDR];
1382                             if (readFullyAt(end64buf, 0, end64buf.length, end64pos)
1383                                 != end64buf.length || GETSIG(end64buf) != ZIP64_ENDSIG) {
1384                                 return end;
1385                             }
1386                             // end64 candidate found,
1387                             long cenlen64 = ZIP64_ENDSIZ(end64buf);
1388                             long cenoff64 = ZIP64_ENDOFF(end64buf);
1389                             long centot64 = ZIP64_ENDTOT(end64buf);
1390                             // double-check
1391                             if (cenlen64 != end.cenlen &amp;&amp; end.cenlen != ZIP64_MAGICVAL ||
1392                                 cenoff64 != end.cenoff &amp;&amp; end.cenoff != ZIP64_MAGICVAL ||
1393                                 centot64 != end.centot &amp;&amp; end.centot != ZIP64_MAGICCOUNT) {
1394                                 return end;
1395                             }
1396                             // to use the end64 values
1397                             end.cenlen = cenlen64;
1398                             end.cenoff = cenoff64;
1399                             end.centot = (int)centot64; // assume total &lt; 2g
1400                             end.endpos = end64pos;
1401                         } catch (IOException x) {}    // no zip64 loc/end
1402                         return end;
1403                     }
1404                 }
1405             }
1406             zerror(&quot;zip END header not found&quot;);
1407             return null; //make compiler happy
1408         }
1409 
1410         // Reads zip file central directory.
1411         private void initCEN(int knownTotal) throws IOException {
1412             if (knownTotal == -1) {
1413                 End end = findEND();
1414                 if (end.endpos == 0) {
1415                     locpos = 0;
1416                     total = 0;
1417                     entries  = new int[0];
1418                     cen = null;
1419                     return;         // only END header present
1420                 }
1421                 if (end.cenlen &gt; end.endpos)
1422                     zerror(&quot;invalid END header (bad central directory size)&quot;);
1423                 long cenpos = end.endpos - end.cenlen;     // position of CEN table
1424                 // Get position of first local file (LOC) header, taking into
1425                 // account that there may be a stub prefixed to the zip file.
1426                 locpos = cenpos - end.cenoff;
1427                 if (locpos &lt; 0) {
1428                     zerror(&quot;invalid END header (bad central directory offset)&quot;);
1429                 }
1430                 // read in the CEN and END
1431                 cen = new byte[(int)(end.cenlen + ENDHDR)];
1432                 if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
1433                     zerror(&quot;read CEN tables failed&quot;);
1434                 }
1435                 total = end.centot;
1436             } else {
1437                 total = knownTotal;
1438             }
1439             // hash table for entries
1440             entries  = new int[total * 3];
1441             tablelen = ((total/2) | 1); // Odd -&gt; fewer collisions
1442             table    =  new int[tablelen];
1443             Arrays.fill(table, ZIP_ENDCHAIN);
1444             int idx = 0;
1445             int hash = 0;
1446             int next = -1;
1447 
1448             // list for all meta entries
1449             ArrayList&lt;Integer&gt; metanamesList = null;
1450             // Set of all version numbers seen in META-INF/versions/
1451             Set&lt;Integer&gt; metaVersionsSet = null;
1452 
1453             // Iterate through the entries in the central directory
1454             int i = 0;
1455             int hsh = 0;
1456             int pos = 0;
1457             int limit = cen.length - ENDHDR;
1458             while (pos + CENHDR &lt;= limit) {
1459                 if (i &gt;= total) {
1460                     // This will only happen if the zip file has an incorrect
1461                     // ENDTOT field, which usually means it contains more than
1462                     // 65535 entries.
1463                     initCEN(countCENHeaders(cen, limit));
1464                     return;
1465                 }
1466                 if (CENSIG(cen, pos) != CENSIG)
1467                     zerror(&quot;invalid CEN header (bad signature)&quot;);
1468                 int method = CENHOW(cen, pos);
1469                 int nlen   = CENNAM(cen, pos);
1470                 int elen   = CENEXT(cen, pos);
1471                 int clen   = CENCOM(cen, pos);
1472                 if ((CENFLG(cen, pos) &amp; 1) != 0)
1473                     zerror(&quot;invalid CEN header (encrypted entry)&quot;);
1474                 if (method != STORED &amp;&amp; method != DEFLATED)
1475                     zerror(&quot;invalid CEN header (bad compression method: &quot; + method + &quot;)&quot;);
1476                 if (pos + CENHDR + nlen &gt; limit)
1477                     zerror(&quot;invalid CEN header (bad header size)&quot;);
1478                 // Record the CEN offset and the name hash in our hash cell.
1479                 hash = hashN(cen, pos + CENHDR, nlen);
1480                 hsh = (hash &amp; 0x7fffffff) % tablelen;
1481                 next = table[hsh];
1482                 table[hsh] = idx;
1483                 idx = addEntry(idx, hash, next, pos);
1484                 // Adds name to metanames.
1485                 if (isMetaName(cen, pos + CENHDR, nlen)) {
1486                     if (metanamesList == null)
1487                         metanamesList = new ArrayList&lt;&gt;(4);
1488                     metanamesList.add(pos);
1489 
1490                     // If this is a versioned entry, parse the version
1491                     // and store it for later. This optimizes lookup
1492                     // performance in multi-release jar files
1493                     int version = getMetaVersion(cen,
1494                         pos + CENHDR + META_INF_LENGTH, nlen - META_INF_LENGTH);
1495                     if (version &gt; 0) {
1496                         if (metaVersionsSet == null)
1497                             metaVersionsSet = new TreeSet&lt;&gt;();
1498                         metaVersionsSet.add(version);
1499                     }
1500                 }
1501                 // skip ext and comment
1502                 pos += (CENHDR + nlen + elen + clen);
1503                 i++;
1504             }
1505             total = i;
1506             if (metanamesList != null) {
1507                 metanames = new int[metanamesList.size()];
1508                 for (int j = 0, len = metanames.length; j &lt; len; j++) {
1509                     metanames[j] = metanamesList.get(j);
1510                 }
1511             }
1512             if (metaVersionsSet != null) {
1513                 metaVersions = new int[metaVersionsSet.size()];
1514                 int c = 0;
1515                 for (Integer version : metaVersionsSet) {
1516                     metaVersions[c++] = version;
1517                 }
1518             } else {
1519                 metaVersions = EMPTY_META_VERSIONS;
1520             }
1521             if (pos + ENDHDR != cen.length) {
1522                 zerror(&quot;invalid CEN header (bad header size)&quot;);
1523             }
1524         }
1525 
1526         private static void zerror(String msg) throws ZipException {
1527             throw new ZipException(msg);
1528         }
1529 
1530         /*
1531          * Returns the {@code pos} of the zip cen entry corresponding to the
1532          * specified entry name, or -1 if not found.
1533          */
1534         private int getEntryPos(byte[] name, boolean addSlash) {
1535             if (total == 0) {
1536                 return -1;
1537             }
1538             int hsh = hashN(name, 0, name.length);
1539             int idx = table[(hsh &amp; 0x7fffffff) % tablelen];
1540             boolean appendSlash = false;
1541             /*
1542              * This while loop is an optimization where a double lookup
1543              * for name and name+/ is being performed. The name byte
1544              * array will be updated with an added slash only if the first
1545              * table lookup fails and there is a matching hash value for
1546              * name+/.
1547              */
1548             while (true) {
1549                 /*
1550                  * Search down the target hash chain for a entry whose
1551                  * 32 bit hash matches the hashed name.
1552                  */
1553                 while (idx != ZIP_ENDCHAIN) {
1554                     if (getEntryHash(idx) == hsh) {
1555                         if (appendSlash) {
1556                             name = Arrays.copyOf(name, name.length + 1);
1557                             name[name.length - 1] = &#39;/&#39;;
1558                             appendSlash = false;
1559                         }
1560                         // The CEN name must match the specfied one
1561                         int pos = getEntryPos(idx);
1562                         if (name.length == CENNAM(cen, pos)) {
1563                             boolean matched = true;
1564                             int nameoff = pos + CENHDR;
1565                             for (int i = 0; i &lt; name.length; i++) {
1566                                 if (name[i] != cen[nameoff++]) {
1567                                     matched = false;
1568                                     break;
1569                                 }
1570                             }
1571                             if (matched) {
1572                                 return pos;
1573                             }
1574                          }
1575                     }
1576                     idx = getEntryNext(idx);
1577                 }
1578                 /* If not addSlash, or slash is already there, we are done */
1579                 if (!addSlash  || name.length == 0 || name[name.length - 1] == &#39;/&#39;) {
1580                      return -1;
1581                 }
1582                 // Add a slash to the hash code
1583                 hsh = hashAppend(hsh, (byte)&#39;/&#39;);
1584                 // If we find a match on the new hash code, we need to append a
1585                 // slash when comparing
1586                 appendSlash = true;
1587                 idx = table[(hsh &amp; 0x7fffffff) % tablelen];
1588                 addSlash = false;
1589             }
1590         }
1591 
1592         /**
1593          * Returns true if the bytes represent a non-directory name
1594          * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
1595          */
1596         private static boolean isMetaName(byte[] name, int off, int len) {
1597             // Use the &quot;oldest ASCII trick in the book&quot;
1598             return len &gt; META_INF_LENGTH       // &quot;META-INF/&quot;.length()
1599                 &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1600                 &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1601                 &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1602                 &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
1603                 &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;
1604                 &amp;&amp; (name[off++]       ) == &#39;-&#39;
1605                 &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1606                 &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1607                 &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;
1608                 &amp;&amp; (name[off]         ) == &#39;/&#39;;
1609         }
1610 
1611         /*
1612          * If the bytes represents a non-directory name beginning
1613          * with &quot;versions/&quot;, continuing with a positive integer,
1614          * followed by a &#39;/&#39;, then return that integer value.
1615          * Otherwise, return 0
1616          */
1617         private static int getMetaVersion(byte[] name, int off, int len) {
1618             int nend = off + len;
1619             if (!(len &gt; 10                         // &quot;versions//&quot;.length()
1620                     &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1621                     &amp;&amp; (name[off++] | 0x20) == &#39;v&#39;
1622                     &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1623                     &amp;&amp; (name[off++] | 0x20) == &#39;r&#39;
1624                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;
1625                     &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1626                     &amp;&amp; (name[off++] | 0x20) == &#39;o&#39;
1627                     &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1628                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;
1629                     &amp;&amp; (name[off++]         ) == &#39;/&#39;)) {
1630                 return 0;
1631             }
1632             int version = 0;
1633             while (off &lt; nend) {
1634                 final byte c = name[off++];
1635                 if (c == &#39;/&#39;) {
1636                     return version;
1637                 }
1638                 if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {
1639                     return 0;
1640                 }
1641                 version = version * 10 + c - &#39;0&#39;;
1642                 // Check for overflow and leading zeros
1643                 if (version &lt;= 0) {
1644                     return 0;
1645                 }
1646             }
1647             return 0;
1648         }
1649 
1650         /**
1651          * Returns the number of CEN headers in a central directory.
1652          * Will not throw, even if the zip file is corrupt.
1653          *
1654          * @param cen copy of the bytes in a zip file&#39;s central directory
1655          * @param size number of bytes in central directory
1656          */
1657         private static int countCENHeaders(byte[] cen, int size) {
1658             int count = 0;
1659             for (int p = 0;
1660                  p + CENHDR &lt;= size;
1661                  p += CENHDR + CENNAM(cen, p) + CENEXT(cen, p) + CENCOM(cen, p))
1662                 count++;
1663             return count;
1664         }
1665     }
1666 }
    </pre>
  </body>
</html>
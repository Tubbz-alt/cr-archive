<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/com/sun/crypto/provider/JceKeyStore.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HmacCore.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeyGeneratorCore.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/com/sun/crypto/provider/JceKeyStore.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 64 
 65 public final class JceKeyStore extends KeyStoreSpi {
 66 
 67     private static final Debug debug = Debug.getInstance(&quot;keystore&quot;);
 68     private static final int JCEKS_MAGIC = 0xcececece;
 69     private static final int JKS_MAGIC = 0xfeedfeed;
 70     private static final int VERSION_1 = 0x01;
 71     private static final int VERSION_2 = 0x02;
 72 
 73     // Private key and supporting certificate chain
 74     private static final class PrivateKeyEntry {
 75         Date date; // the creation date of this entry
 76         byte[] protectedKey;
 77         Certificate[] chain;
 78     };
 79 
 80     // Secret key
 81     private static final class SecretKeyEntry {
 82         Date date; // the creation date of this entry
 83         SealedObject sealedKey;






 84     }
 85 
 86     // Trusted certificate
 87     private static final class TrustedCertEntry {
 88         Date date; // the creation date of this entry
 89         Certificate cert;
 90     };
 91 
 92     /**
 93      * Private keys and certificates are stored in a hashtable.
 94      * Hash entries are keyed by alias names.
 95      */
 96     private Hashtable&lt;String, Object&gt; entries = new Hashtable&lt;String, Object&gt;();
 97 
 98     /**
 99      * Returns the key associated with the given alias, using the given
100      * password to recover it.
101      *
102      * @param alias the alias name
103      * @param password the password for recovering the key
</pre>
<hr />
<pre>
119 
120         if (!((entry instanceof PrivateKeyEntry) ||
121               (entry instanceof SecretKeyEntry))) {
122             return null;
123         }
124 
125         KeyProtector keyProtector = new KeyProtector(password);
126 
127         if (entry instanceof PrivateKeyEntry) {
128             byte[] encrBytes = ((PrivateKeyEntry)entry).protectedKey;
129             EncryptedPrivateKeyInfo encrInfo;
130             try {
131                 encrInfo = new EncryptedPrivateKeyInfo(encrBytes);
132             } catch (IOException ioe) {
133                 throw new UnrecoverableKeyException(&quot;Private key not stored &quot;
134                                                     + &quot;as PKCS #8 &quot; +
135                                                     &quot;EncryptedPrivateKeyInfo&quot;);
136             }
137             key = keyProtector.recover(encrInfo);
138         } else {
<span class="line-modified">139             key =</span>
<span class="line-modified">140                 keyProtector.unseal(((SecretKeyEntry)entry).sealedKey);</span>
141         }
142 
143         return key;
144     }
145 
146     /**
147      * Returns the certificate chain associated with the given alias.
148      *
149      * @param alias the alias name
150      *
151      * @return the certificate chain (ordered with the user&#39;s certificate first
152      * and the root certificate authority last), or null if the given alias
153      * does not exist or does not contain a certificate chain (i.e., the given
154      * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a
155      * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).
156      */
157     public Certificate[] engineGetCertificateChain(String alias)
158     {
159         Certificate[] chain = null;
160 
</pre>
<hr />
<pre>
265                     // protect the private key
266                     entry.protectedKey = keyProtector.protect((PrivateKey)key);
267 
268                     // clone the chain
269                     if ((chain != null) &amp;&amp;
270                         (chain.length !=0)) {
271                         entry.chain = chain.clone();
272                     } else {
273                         entry.chain = null;
274                     }
275 
276                     // store the entry
277                     entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
278 
279                 } else {
280                     SecretKeyEntry entry = new SecretKeyEntry();
281                     entry.date = new Date();
282 
283                     // seal and store the key
284                     entry.sealedKey = keyProtector.seal(key);

285                     entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
286                 }
287 
288             } catch (Exception e) {
289                 throw new KeyStoreException(e.getMessage());
290             }
291         }
292     }
293 
294     /**
295      * Assigns the given key (that has already been protected) to the given
296      * alias.
297      *
298      * &lt;p&gt;If the protected key is of type
299      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
300      * it must be accompanied by a certificate chain certifying the
301      * corresponding public key.
302      *
303      * &lt;p&gt;If the given alias already exists, the keystore information
304      * associated with it is overridden by the given key (and possibly
</pre>
<hr />
<pre>
674      * @exception NoSuchAlgorithmException if the algorithm used to check
675      * the integrity of the keystore cannot be found
676      * @exception CertificateException if any of the certificates in the
677      * keystore could not be loaded
678      */
679     public void engineLoad(InputStream stream, char[] password)
680         throws IOException, NoSuchAlgorithmException, CertificateException
681     {
682         synchronized(entries) {
683             DataInputStream dis;
684             MessageDigest md = null;
685             CertificateFactory cf = null;
686             Hashtable&lt;String, CertificateFactory&gt; cfs = null;
687             ByteArrayInputStream bais = null;
688             byte[] encoded = null;
689             int trustedKeyCount = 0, privateKeyCount = 0, secretKeyCount = 0;
690 
691             if (stream == null)
692                 return;
693 




694             if (password != null) {
695                 md = getPreKeyedHash(password);
696                 dis = new DataInputStream(new DigestInputStream(stream, md));
697             } else {
698                 dis = new DataInputStream(stream);
699             }
700             // NOTE: don&#39;t pass dis to ois at this point or it&#39;ll fail to load
701             // the keystore!!!
702             ObjectInputStream ois = null;
703 
704             try {
705                 // Body format: see store method
706 
707                 int xMagic = dis.readInt();
708                 int xVersion = dis.readInt();
709 
710                 // Accept the following keystore implementations:
711                 // - JCEKS (this implementation), versions 1 and 2
712                 // - JKS (Sun&#39;s keystore implementation in JDK 1.2),
713                 //   versions 1 and 2
</pre>
<hr />
<pre>
812                         entries.put(alias, entry);
813 
814                     } else if (tag == 3) { // secret-key entry
815                         secretKeyCount++;
816                         SecretKeyEntry entry = new SecretKeyEntry();
817 
818                         // read the alias
819                         alias = dis.readUTF();
820 
821                         // read the (entry creation) date
822                         entry.date = new Date(dis.readLong());
823 
824                         // read the sealed key
825                         try {
826                             ois = new ObjectInputStream(dis);
827                             final ObjectInputStream ois2 = ois;
828                             // Set a deserialization checker
829                             AccessController.doPrivileged(
830                                 (PrivilegedAction&lt;Void&gt;)() -&gt; {
831                                     ois2.setObjectInputFilter(
<span class="line-modified">832                                         new DeserializationChecker());</span>
833                                     return null;
834                             });
835                             entry.sealedKey = (SealedObject)ois.readObject();

836                             // NOTE: don&#39;t close ois here since we are still
837                             // using dis!!!
838                         } catch (ClassNotFoundException cnfe) {
839                             throw new IOException(cnfe.getMessage());
840                         } catch (InvalidClassException ice) {
841                             throw new IOException(&quot;Invalid secret key format&quot;);
842                         }
843 
844                         // Add the entry to the list
845                         entries.put(alias, entry);
846 
847                     } else {
848                         throw new IOException(&quot;Unrecognized keystore entry: &quot; +
849                                 tag);
850                     }
851                 }
852 
853                 if (debug != null) {
854                     debug.println(&quot;JceKeyStore load: private key count: &quot; +
855                         privateKeyCount + &quot;. trusted key count: &quot; +
</pre>
<hr />
<pre>
909      * Probe the first few bytes of the keystore data stream for a valid
910      * JCEKS keystore encoding.
911      */
912     @Override
913     public boolean engineProbe(InputStream stream) throws IOException {
914         DataInputStream dataStream;
915         if (stream instanceof DataInputStream) {
916             dataStream = (DataInputStream)stream;
917         } else {
918             dataStream = new DataInputStream(stream);
919         }
920 
921         return JCEKS_MAGIC == dataStream.readInt();
922     }
923 
924     /*
925      * An ObjectInputFilter that checks the format of the secret key being
926      * deserialized.
927      */
928     private static class DeserializationChecker implements ObjectInputFilter {

929         private static final int MAX_NESTED_DEPTH = 2;
930 








931         @Override
932         public ObjectInputFilter.Status
933             checkInput(ObjectInputFilter.FilterInfo info) {
934 
935             // First run a custom filter
936             long nestedDepth = info.depth();
937             if ((nestedDepth == 1 &amp;&amp;
938                         info.serialClass() != SealedObjectForKeyProtector.class) ||

939                     (nestedDepth &gt; MAX_NESTED_DEPTH &amp;&amp;
940                         info.serialClass() != null &amp;&amp;
941                         info.serialClass() != Object.class)) {
942                 return Status.REJECTED;
943             }
944 
945             // Next run the default filter, if available
946             ObjectInputFilter defaultFilter =
947                 ObjectInputFilter.Config.getSerialFilter();
948             if (defaultFilter != null) {
949                 return defaultFilter.checkInput(info);
950             }
951 
952             return Status.UNDECIDED;
953         }
954     }
955 }
</pre>
</td>
<td>
<hr />
<pre>
 64 
 65 public final class JceKeyStore extends KeyStoreSpi {
 66 
 67     private static final Debug debug = Debug.getInstance(&quot;keystore&quot;);
 68     private static final int JCEKS_MAGIC = 0xcececece;
 69     private static final int JKS_MAGIC = 0xfeedfeed;
 70     private static final int VERSION_1 = 0x01;
 71     private static final int VERSION_2 = 0x02;
 72 
 73     // Private key and supporting certificate chain
 74     private static final class PrivateKeyEntry {
 75         Date date; // the creation date of this entry
 76         byte[] protectedKey;
 77         Certificate[] chain;
 78     };
 79 
 80     // Secret key
 81     private static final class SecretKeyEntry {
 82         Date date; // the creation date of this entry
 83         SealedObject sealedKey;
<span class="line-added"> 84 </span>
<span class="line-added"> 85         // Maximum possible length of sealedKey. Used to detect malicious</span>
<span class="line-added"> 86         // input data. This field is set to the file length of the keystore</span>
<span class="line-added"> 87         // at loading. It is useless when creating a new SecretKeyEntry</span>
<span class="line-added"> 88         // to be store in a keystore.</span>
<span class="line-added"> 89         int maxLength;</span>
 90     }
 91 
 92     // Trusted certificate
 93     private static final class TrustedCertEntry {
 94         Date date; // the creation date of this entry
 95         Certificate cert;
 96     };
 97 
 98     /**
 99      * Private keys and certificates are stored in a hashtable.
100      * Hash entries are keyed by alias names.
101      */
102     private Hashtable&lt;String, Object&gt; entries = new Hashtable&lt;String, Object&gt;();
103 
104     /**
105      * Returns the key associated with the given alias, using the given
106      * password to recover it.
107      *
108      * @param alias the alias name
109      * @param password the password for recovering the key
</pre>
<hr />
<pre>
125 
126         if (!((entry instanceof PrivateKeyEntry) ||
127               (entry instanceof SecretKeyEntry))) {
128             return null;
129         }
130 
131         KeyProtector keyProtector = new KeyProtector(password);
132 
133         if (entry instanceof PrivateKeyEntry) {
134             byte[] encrBytes = ((PrivateKeyEntry)entry).protectedKey;
135             EncryptedPrivateKeyInfo encrInfo;
136             try {
137                 encrInfo = new EncryptedPrivateKeyInfo(encrBytes);
138             } catch (IOException ioe) {
139                 throw new UnrecoverableKeyException(&quot;Private key not stored &quot;
140                                                     + &quot;as PKCS #8 &quot; +
141                                                     &quot;EncryptedPrivateKeyInfo&quot;);
142             }
143             key = keyProtector.recover(encrInfo);
144         } else {
<span class="line-modified">145             SecretKeyEntry ske = ((SecretKeyEntry)entry);</span>
<span class="line-modified">146             key = keyProtector.unseal(ske.sealedKey, ske.maxLength);</span>
147         }
148 
149         return key;
150     }
151 
152     /**
153      * Returns the certificate chain associated with the given alias.
154      *
155      * @param alias the alias name
156      *
157      * @return the certificate chain (ordered with the user&#39;s certificate first
158      * and the root certificate authority last), or null if the given alias
159      * does not exist or does not contain a certificate chain (i.e., the given
160      * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a
161      * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).
162      */
163     public Certificate[] engineGetCertificateChain(String alias)
164     {
165         Certificate[] chain = null;
166 
</pre>
<hr />
<pre>
271                     // protect the private key
272                     entry.protectedKey = keyProtector.protect((PrivateKey)key);
273 
274                     // clone the chain
275                     if ((chain != null) &amp;&amp;
276                         (chain.length !=0)) {
277                         entry.chain = chain.clone();
278                     } else {
279                         entry.chain = null;
280                     }
281 
282                     // store the entry
283                     entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
284 
285                 } else {
286                     SecretKeyEntry entry = new SecretKeyEntry();
287                     entry.date = new Date();
288 
289                     // seal and store the key
290                     entry.sealedKey = keyProtector.seal(key);
<span class="line-added">291                     entry.maxLength = Integer.MAX_VALUE;</span>
292                     entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
293                 }
294 
295             } catch (Exception e) {
296                 throw new KeyStoreException(e.getMessage());
297             }
298         }
299     }
300 
301     /**
302      * Assigns the given key (that has already been protected) to the given
303      * alias.
304      *
305      * &lt;p&gt;If the protected key is of type
306      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
307      * it must be accompanied by a certificate chain certifying the
308      * corresponding public key.
309      *
310      * &lt;p&gt;If the given alias already exists, the keystore information
311      * associated with it is overridden by the given key (and possibly
</pre>
<hr />
<pre>
681      * @exception NoSuchAlgorithmException if the algorithm used to check
682      * the integrity of the keystore cannot be found
683      * @exception CertificateException if any of the certificates in the
684      * keystore could not be loaded
685      */
686     public void engineLoad(InputStream stream, char[] password)
687         throws IOException, NoSuchAlgorithmException, CertificateException
688     {
689         synchronized(entries) {
690             DataInputStream dis;
691             MessageDigest md = null;
692             CertificateFactory cf = null;
693             Hashtable&lt;String, CertificateFactory&gt; cfs = null;
694             ByteArrayInputStream bais = null;
695             byte[] encoded = null;
696             int trustedKeyCount = 0, privateKeyCount = 0, secretKeyCount = 0;
697 
698             if (stream == null)
699                 return;
700 
<span class="line-added">701             byte[] allData = stream.readAllBytes();</span>
<span class="line-added">702             int fullLength = allData.length;</span>
<span class="line-added">703 </span>
<span class="line-added">704             stream = new ByteArrayInputStream(allData);</span>
705             if (password != null) {
706                 md = getPreKeyedHash(password);
707                 dis = new DataInputStream(new DigestInputStream(stream, md));
708             } else {
709                 dis = new DataInputStream(stream);
710             }
711             // NOTE: don&#39;t pass dis to ois at this point or it&#39;ll fail to load
712             // the keystore!!!
713             ObjectInputStream ois = null;
714 
715             try {
716                 // Body format: see store method
717 
718                 int xMagic = dis.readInt();
719                 int xVersion = dis.readInt();
720 
721                 // Accept the following keystore implementations:
722                 // - JCEKS (this implementation), versions 1 and 2
723                 // - JKS (Sun&#39;s keystore implementation in JDK 1.2),
724                 //   versions 1 and 2
</pre>
<hr />
<pre>
823                         entries.put(alias, entry);
824 
825                     } else if (tag == 3) { // secret-key entry
826                         secretKeyCount++;
827                         SecretKeyEntry entry = new SecretKeyEntry();
828 
829                         // read the alias
830                         alias = dis.readUTF();
831 
832                         // read the (entry creation) date
833                         entry.date = new Date(dis.readLong());
834 
835                         // read the sealed key
836                         try {
837                             ois = new ObjectInputStream(dis);
838                             final ObjectInputStream ois2 = ois;
839                             // Set a deserialization checker
840                             AccessController.doPrivileged(
841                                 (PrivilegedAction&lt;Void&gt;)() -&gt; {
842                                     ois2.setObjectInputFilter(
<span class="line-modified">843                                         new DeserializationChecker(fullLength));</span>
844                                     return null;
845                             });
846                             entry.sealedKey = (SealedObject)ois.readObject();
<span class="line-added">847                             entry.maxLength = fullLength;</span>
848                             // NOTE: don&#39;t close ois here since we are still
849                             // using dis!!!
850                         } catch (ClassNotFoundException cnfe) {
851                             throw new IOException(cnfe.getMessage());
852                         } catch (InvalidClassException ice) {
853                             throw new IOException(&quot;Invalid secret key format&quot;);
854                         }
855 
856                         // Add the entry to the list
857                         entries.put(alias, entry);
858 
859                     } else {
860                         throw new IOException(&quot;Unrecognized keystore entry: &quot; +
861                                 tag);
862                     }
863                 }
864 
865                 if (debug != null) {
866                     debug.println(&quot;JceKeyStore load: private key count: &quot; +
867                         privateKeyCount + &quot;. trusted key count: &quot; +
</pre>
<hr />
<pre>
921      * Probe the first few bytes of the keystore data stream for a valid
922      * JCEKS keystore encoding.
923      */
924     @Override
925     public boolean engineProbe(InputStream stream) throws IOException {
926         DataInputStream dataStream;
927         if (stream instanceof DataInputStream) {
928             dataStream = (DataInputStream)stream;
929         } else {
930             dataStream = new DataInputStream(stream);
931         }
932 
933         return JCEKS_MAGIC == dataStream.readInt();
934     }
935 
936     /*
937      * An ObjectInputFilter that checks the format of the secret key being
938      * deserialized.
939      */
940     private static class DeserializationChecker implements ObjectInputFilter {
<span class="line-added">941 </span>
942         private static final int MAX_NESTED_DEPTH = 2;
943 
<span class="line-added">944         // Full length of keystore, anything inside a SecretKeyEntry should not</span>
<span class="line-added">945         // be bigger. Otherwise, must be illegal.</span>
<span class="line-added">946         private final int fullLength;</span>
<span class="line-added">947 </span>
<span class="line-added">948         public DeserializationChecker(int fullLength) {</span>
<span class="line-added">949             this.fullLength = fullLength;</span>
<span class="line-added">950         }</span>
<span class="line-added">951 </span>
952         @Override
953         public ObjectInputFilter.Status
954             checkInput(ObjectInputFilter.FilterInfo info) {
955 
956             // First run a custom filter
957             long nestedDepth = info.depth();
958             if ((nestedDepth == 1 &amp;&amp;
959                         info.serialClass() != SealedObjectForKeyProtector.class) ||
<span class="line-added">960                     info.arrayLength() &gt; fullLength ||</span>
961                     (nestedDepth &gt; MAX_NESTED_DEPTH &amp;&amp;
962                         info.serialClass() != null &amp;&amp;
963                         info.serialClass() != Object.class)) {
964                 return Status.REJECTED;
965             }
966 
967             // Next run the default filter, if available
968             ObjectInputFilter defaultFilter =
969                 ObjectInputFilter.Config.getSerialFilter();
970             if (defaultFilter != null) {
971                 return defaultFilter.checkInput(info);
972             }
973 
974             return Status.UNDECIDED;
975         }
976     }
977 }
</pre>
</td>
</tr>
</table>
<center><a href="HmacCore.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeyGeneratorCore.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
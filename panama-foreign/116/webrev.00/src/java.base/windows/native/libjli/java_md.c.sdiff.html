<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/native/libjli/java_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../libjava/canonicalize_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../java.desktop/macosx/classes/com/apple/laf/AquaLookAndFeel.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libjli/java_md.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 234          * The makefiles will provide the correct lib contained in quotes in the
 235          * macro MSVCR_DLL_NAME.
 236          */
 237 #ifdef MSVCR_DLL_NAME
 238         if (GetJREPath(crtpath, MAXPATHLEN)) {
 239             if (JLI_StrLen(crtpath) + JLI_StrLen(&quot;\\bin\\&quot;) +
 240                     JLI_StrLen(MSVCR_DLL_NAME) &gt;= MAXPATHLEN) {
 241                 JLI_ReportErrorMessage(JRE_ERROR11);
 242                 return JNI_FALSE;
 243             }
 244             (void)JLI_StrCat(crtpath, &quot;\\bin\\&quot; MSVCR_DLL_NAME);   /* Add crt dll */
 245             JLI_TraceLauncher(&quot;CRT path is %s\n&quot;, crtpath);
 246             if (_access(crtpath, 0) == 0) {
 247                 if (LoadLibrary(crtpath) == 0) {
 248                     JLI_ReportErrorMessage(DLL_ERROR4, crtpath);
 249                     return JNI_FALSE;
 250                 }
 251             }
 252         }
 253 #endif /* MSVCR_DLL_NAME */

















 254 #ifdef MSVCP_DLL_NAME
 255         if (GetJREPath(crtpath, MAXPATHLEN)) {
 256             if (JLI_StrLen(crtpath) + JLI_StrLen(&quot;\\bin\\&quot;) +
 257                     JLI_StrLen(MSVCP_DLL_NAME) &gt;= MAXPATHLEN) {
 258                 JLI_ReportErrorMessage(JRE_ERROR11);
 259                 return JNI_FALSE;
 260             }
 261             (void)JLI_StrCat(crtpath, &quot;\\bin\\&quot; MSVCP_DLL_NAME);   /* Add prt dll */
 262             JLI_TraceLauncher(&quot;PRT path is %s\n&quot;, crtpath);
 263             if (_access(crtpath, 0) == 0) {
 264                 if (LoadLibrary(crtpath) == 0) {
 265                     JLI_ReportErrorMessage(DLL_ERROR4, crtpath);
 266                     return JNI_FALSE;
 267                 }
 268             }
 269         }
 270 #endif /* MSVCP_DLL_NAME */
 271         loaded = 1;
 272     }
 273     return JNI_TRUE;
</pre>
<hr />
<pre>
 487     /* force a null terminator, if something is amiss */
 488     if (rc &lt; 0) {
 489         /* apply ansi semantics */
 490         buffer[size - 1] = &#39;\0&#39;;
 491         return (int)size;
 492     } else if (rc == size) {
 493         /* force a null terminator */
 494         buffer[size - 1] = &#39;\0&#39;;
 495     }
 496     return rc;
 497 }
 498 
 499 static errno_t convert_to_unicode(const char* path, const wchar_t* prefix, wchar_t** wpath) {
 500     int unicode_path_len;
 501     size_t prefix_len, wpath_len;
 502 
 503     /*
 504      * Get required buffer size to convert to Unicode.
 505      * The return value includes the terminating null character.
 506      */
<span class="line-modified"> 507     unicode_path_len = MultiByteToWideChar(CP_THREAD_ACP, MB_ERR_INVALID_CHARS,</span>
 508                                            path, -1, NULL, 0);
 509     if (unicode_path_len == 0) {
 510         return EINVAL;
 511     }
 512 
 513     prefix_len = wcslen(prefix);
 514     wpath_len = prefix_len + unicode_path_len;
 515     *wpath = (wchar_t*)JLI_MemAlloc(wpath_len * sizeof(wchar_t));
 516     if (*wpath == NULL) {
 517         return ENOMEM;
 518     }
 519 
 520     wcsncpy(*wpath, prefix, prefix_len);
<span class="line-modified"> 521     if (MultiByteToWideChar(CP_THREAD_ACP, MB_ERR_INVALID_CHARS,</span>
 522                             path, -1, &amp;((*wpath)[prefix_len]), (int)wpath_len) == 0) {
 523         JLI_MemFree(*wpath);
 524         *wpath = NULL;
 525         return EINVAL;
 526     }
 527 
 528     return ERROR_SUCCESS;
 529 }
 530 
 531 /* taken from hotspot and slightly adjusted for jli lib;
 532  * creates a UNC/ELP path from input &#39;path&#39;
 533  * the return buffer is allocated in C heap and needs to be freed using
 534  * JLI_MemFree by the caller.
 535  */
 536 static wchar_t* create_unc_path(const char* path, errno_t* err) {
 537     wchar_t* wpath = NULL;
 538     size_t converted_chars = 0;
 539     size_t path_len = strlen(path) + 1; /* includes the terminating NULL */
 540     if (path[0] == &#39;\\&#39; &amp;&amp; path[1] == &#39;\\&#39;) {
 541         if (path[2] == &#39;?&#39; &amp;&amp; path[3] == &#39;\\&#39;) {
</pre>
</td>
<td>
<hr />
<pre>
 234          * The makefiles will provide the correct lib contained in quotes in the
 235          * macro MSVCR_DLL_NAME.
 236          */
 237 #ifdef MSVCR_DLL_NAME
 238         if (GetJREPath(crtpath, MAXPATHLEN)) {
 239             if (JLI_StrLen(crtpath) + JLI_StrLen(&quot;\\bin\\&quot;) +
 240                     JLI_StrLen(MSVCR_DLL_NAME) &gt;= MAXPATHLEN) {
 241                 JLI_ReportErrorMessage(JRE_ERROR11);
 242                 return JNI_FALSE;
 243             }
 244             (void)JLI_StrCat(crtpath, &quot;\\bin\\&quot; MSVCR_DLL_NAME);   /* Add crt dll */
 245             JLI_TraceLauncher(&quot;CRT path is %s\n&quot;, crtpath);
 246             if (_access(crtpath, 0) == 0) {
 247                 if (LoadLibrary(crtpath) == 0) {
 248                     JLI_ReportErrorMessage(DLL_ERROR4, crtpath);
 249                     return JNI_FALSE;
 250                 }
 251             }
 252         }
 253 #endif /* MSVCR_DLL_NAME */
<span class="line-added"> 254 #ifdef VCRUNTIME_1_DLL_NAME</span>
<span class="line-added"> 255         if (GetJREPath(crtpath, MAXPATHLEN)) {</span>
<span class="line-added"> 256             if (JLI_StrLen(crtpath) + JLI_StrLen(&quot;\\bin\\&quot;) +</span>
<span class="line-added"> 257                     JLI_StrLen(VCRUNTIME_1_DLL_NAME) &gt;= MAXPATHLEN) {</span>
<span class="line-added"> 258                 JLI_ReportErrorMessage(JRE_ERROR11);</span>
<span class="line-added"> 259                 return JNI_FALSE;</span>
<span class="line-added"> 260             }</span>
<span class="line-added"> 261             (void)JLI_StrCat(crtpath, &quot;\\bin\\&quot; VCRUNTIME_1_DLL_NAME);   /* Add crt dll */</span>
<span class="line-added"> 262             JLI_TraceLauncher(&quot;CRT path is %s\n&quot;, crtpath);</span>
<span class="line-added"> 263             if (_access(crtpath, 0) == 0) {</span>
<span class="line-added"> 264                 if (LoadLibrary(crtpath) == 0) {</span>
<span class="line-added"> 265                     JLI_ReportErrorMessage(DLL_ERROR4, crtpath);</span>
<span class="line-added"> 266                     return JNI_FALSE;</span>
<span class="line-added"> 267                 }</span>
<span class="line-added"> 268             }</span>
<span class="line-added"> 269         }</span>
<span class="line-added"> 270 #endif /* VCRUNTIME_1_DLL_NAME */</span>
 271 #ifdef MSVCP_DLL_NAME
 272         if (GetJREPath(crtpath, MAXPATHLEN)) {
 273             if (JLI_StrLen(crtpath) + JLI_StrLen(&quot;\\bin\\&quot;) +
 274                     JLI_StrLen(MSVCP_DLL_NAME) &gt;= MAXPATHLEN) {
 275                 JLI_ReportErrorMessage(JRE_ERROR11);
 276                 return JNI_FALSE;
 277             }
 278             (void)JLI_StrCat(crtpath, &quot;\\bin\\&quot; MSVCP_DLL_NAME);   /* Add prt dll */
 279             JLI_TraceLauncher(&quot;PRT path is %s\n&quot;, crtpath);
 280             if (_access(crtpath, 0) == 0) {
 281                 if (LoadLibrary(crtpath) == 0) {
 282                     JLI_ReportErrorMessage(DLL_ERROR4, crtpath);
 283                     return JNI_FALSE;
 284                 }
 285             }
 286         }
 287 #endif /* MSVCP_DLL_NAME */
 288         loaded = 1;
 289     }
 290     return JNI_TRUE;
</pre>
<hr />
<pre>
 504     /* force a null terminator, if something is amiss */
 505     if (rc &lt; 0) {
 506         /* apply ansi semantics */
 507         buffer[size - 1] = &#39;\0&#39;;
 508         return (int)size;
 509     } else if (rc == size) {
 510         /* force a null terminator */
 511         buffer[size - 1] = &#39;\0&#39;;
 512     }
 513     return rc;
 514 }
 515 
 516 static errno_t convert_to_unicode(const char* path, const wchar_t* prefix, wchar_t** wpath) {
 517     int unicode_path_len;
 518     size_t prefix_len, wpath_len;
 519 
 520     /*
 521      * Get required buffer size to convert to Unicode.
 522      * The return value includes the terminating null character.
 523      */
<span class="line-modified"> 524     unicode_path_len = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS,</span>
 525                                            path, -1, NULL, 0);
 526     if (unicode_path_len == 0) {
 527         return EINVAL;
 528     }
 529 
 530     prefix_len = wcslen(prefix);
 531     wpath_len = prefix_len + unicode_path_len;
 532     *wpath = (wchar_t*)JLI_MemAlloc(wpath_len * sizeof(wchar_t));
 533     if (*wpath == NULL) {
 534         return ENOMEM;
 535     }
 536 
 537     wcsncpy(*wpath, prefix, prefix_len);
<span class="line-modified"> 538     if (MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS,</span>
 539                             path, -1, &amp;((*wpath)[prefix_len]), (int)wpath_len) == 0) {
 540         JLI_MemFree(*wpath);
 541         *wpath = NULL;
 542         return EINVAL;
 543     }
 544 
 545     return ERROR_SUCCESS;
 546 }
 547 
 548 /* taken from hotspot and slightly adjusted for jli lib;
 549  * creates a UNC/ELP path from input &#39;path&#39;
 550  * the return buffer is allocated in C heap and needs to be freed using
 551  * JLI_MemFree by the caller.
 552  */
 553 static wchar_t* create_unc_path(const char* path, errno_t* err) {
 554     wchar_t* wpath = NULL;
 555     size_t converted_chars = 0;
 556     size_t path_len = strlen(path) + 1; /* includes the terminating NULL */
 557     if (path[0] == &#39;\\&#39; &amp;&amp; path[1] == &#39;\\&#39;) {
 558         if (path[2] == &#39;?&#39; &amp;&amp; path[3] == &#39;\\&#39;) {
</pre>
</td>
</tr>
</table>
<center><a href="../libjava/canonicalize_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../java.desktop/macosx/classes/com/apple/laf/AquaLookAndFeel.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/VersionPropsPlugin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.tools.jlink.internal.plugins;
 27 
 28 import java.util.Map;
 29 
 30 import jdk.internal.org.objectweb.asm.ClassReader;
 31 import jdk.internal.org.objectweb.asm.ClassVisitor;
 32 import jdk.internal.org.objectweb.asm.ClassWriter;
 33 import jdk.internal.org.objectweb.asm.MethodVisitor;
 34 import jdk.internal.org.objectweb.asm.Opcodes;
 35 import jdk.tools.jlink.plugin.Plugin;
 36 import jdk.tools.jlink.plugin.ResourcePool;
 37 import jdk.tools.jlink.plugin.ResourcePoolBuilder;
 38 import jdk.tools.jlink.plugin.ResourcePoolEntry;
 39 
 40 /**
 41  * Base plugin to update a static field in java.lang.VersionProps
 42  *
 43  * Fields to be updated must not be final such that values are not constant
 44  * replaced at compile time and initialization code is generated.
 45  * We assume that the initialization code only has ldcs, method calls and
 46  * field instructions.
 47  */
 48 abstract class VersionPropsPlugin implements Plugin {
 49 
 50     private static final String VERSION_PROPS_CLASS
 51         = &quot;/java.base/java/lang/VersionProps.class&quot;;
 52 
 53     private final String name;
 54     private final String field;
 55     private String value;
 56 
 57     /**
 58      * @param field The name of the java.lang.VersionProps field to be redefined
 59      * @param option The option name
 60      */
 61     protected VersionPropsPlugin(String field, String option) {
 62         this.field = field;
 63         this.name = option;
 64     }
 65 
 66     /**
 67      * Shorthand constructor for when the option name can be derived from the
 68      * name of the field.
 69      *
 70      * @param field The name of the java.lang.VersionProps field to be redefined
 71      */
 72     protected VersionPropsPlugin(String field) {
 73         this(field, field.toLowerCase().replace(&#39;_&#39;, &#39;-&#39;));
 74     }
 75 
 76     @Override
 77     public String getName() {
 78         return name;
 79     }
 80 
 81     @Override
 82     public String getDescription() {
 83         return PluginsResourceBundle.getDescription(name);
 84     }
 85 
 86     @Override
 87     public Category getType() {
 88         return Category.TRANSFORMER;
 89     }
 90 
 91     @Override
 92     public boolean hasArguments() {
 93         return true;
 94     }
 95 
 96     @Override
 97     public boolean hasRawArgument() {
 98         return true;
 99     }
100 
101     @Override
102     public String getArgumentsDescription() {
103        return PluginsResourceBundle.getArgument(name);
104     }
105 
106     @Override
107     public void configure(Map&lt;String, String&gt; config) {
108         var v = config.get(name);
109         if (v == null)
110             throw new AssertionError();
111         value = v;
112     }
113 
114     private boolean redefined = false;
115 
116     private byte[] redefine(byte[] classFile) {
117 
118         var cr = new ClassReader(classFile);
119         var cw = new ClassWriter(0);
120 
121         cr.accept(new ClassVisitor(Opcodes.ASM7, cw) {
122 
123                 @Override
124                 public MethodVisitor visitMethod(int access,
125                                                  String name,
126                                                  String desc,
127                                                  String sig,
128                                                  String[] xs)
129                 {
130                     if (name.equals(&quot;&lt;clinit&gt;&quot;))
131                         return new MethodVisitor(Opcodes.ASM7,
132                                                  super.visitMethod(access,
133                                                                    name,
134                                                                    desc,
135                                                                    sig,
136                                                                    xs))
137                             {
138                                 private Object pendingLDC = null;
139 
140                                 private void flushPendingLDC() {
141                                     if (pendingLDC != null) {
142                                         super.visitLdcInsn(pendingLDC);
143                                         pendingLDC = null;
144                                     }
145                                 }
146 
147                                 @Override
148                                 public void visitLdcInsn(Object value) {
149                                     flushPendingLDC();
150                                     pendingLDC = value;
151                                 }
152 
153                                 @Override
154                                 public void visitMethodInsn(int opcode,
155                                                             String owner,
156                                                             String name,
157                                                             String descriptor,
158                                                             boolean isInterface) {
159                                     flushPendingLDC();
160                                     super.visitMethodInsn(opcode, owner, name,
161                                                           descriptor, isInterface);
162                                 }
163 
164                                 @Override
165                                 public void visitFieldInsn(int opcode,
166                                                            String owner,
167                                                            String name,
168                                                            String desc)
169                                 {
170                                     if (opcode == Opcodes.PUTSTATIC
171                                         &amp;&amp; name.equals(field))
172                                     {
173                                         // assert that there is a pending ldc
174                                         // for the old value
175                                         if (pendingLDC == null) {
176                                             throw new AssertionError(&quot;No load &quot; +
177                                                 &quot;instruction found for field &quot; + field +
178                                                 &quot; in static initializer of &quot; +
179                                                 VERSION_PROPS_CLASS);
180                                         }
181                                         // forget about it
182                                         pendingLDC = null;
183                                         // and add an ldc for the new value
184                                         super.visitLdcInsn(value);
185                                         redefined = true;
186                                     } else {
187                                         flushPendingLDC();
188                                     }
189                                     super.visitFieldInsn(opcode, owner,
190                                                          name, desc);
191                                 }
192 
193                         };
194                     else
195                         return super.visitMethod(access, name, desc, sig, xs);
196                 }
197 
198             }, 0);
199 
200         return cw.toByteArray();
201 
202     }
203 
204     @Override
205     public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {
206         in.transformAndCopy(res -&gt; {
207                 if (res.type().equals(ResourcePoolEntry.Type.CLASS_OR_RESOURCE)) {
208                     if (res.path().equals(VERSION_PROPS_CLASS)) {
209                         return res.copyWithContent(redefine(res.contentBytes()));
210                     }
211                 }
212                 return res;
213             }, out);
214         if (!redefined)
215             throw new AssertionError(field);
216         return out.build();
217     }
218 
219 }
    </pre>
  </body>
</html>
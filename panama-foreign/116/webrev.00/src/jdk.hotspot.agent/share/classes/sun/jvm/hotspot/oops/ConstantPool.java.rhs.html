<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ConstantPool.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.oops;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.runtime.*;
 31 import sun.jvm.hotspot.types.*;
 32 import sun.jvm.hotspot.utilities.*;
<a name="2" id="anc2"></a><span class="line-added"> 33 import sun.jvm.hotspot.utilities.Observable;</span>
<span class="line-added"> 34 import sun.jvm.hotspot.utilities.Observer;</span>
 35 
 36 // A ConstantPool is an oop containing class constants
 37 // as described in the class file
 38 
 39 public class ConstantPool extends Metadata implements ClassConstants {
 40   private class CPSlot {
 41     private Address ptr;
 42 
 43     CPSlot(Address ptr) {
 44       this.ptr = ptr;
 45     }
 46 
 47     public Symbol getSymbol() {
 48       // (Lowest bit == 1) -&gt; this is an pseudo string.
 49       return Symbol.create(ptr.andWithMask(~1));
 50     }
 51   }
 52   private class CPKlassSlot {
 53     private int name_index;
 54     private int resolved_klass_index;
 55     private static final int temp_resolved_klass_index = 0xffff;
 56 
 57     public CPKlassSlot(int n, int rk) {
 58       name_index = n;
 59       resolved_klass_index = rk;
 60     }
 61     public int getNameIndex() {
 62       return name_index;
 63     }
 64     public int getResolvedKlassIndex() {
 65       if (Assert.ASSERTS_ENABLED) {
 66         Assert.that(resolved_klass_index != temp_resolved_klass_index, &quot;constant pool merging was incomplete&quot;);
 67       }
 68       return resolved_klass_index;
 69     }
 70   }
 71 
 72   // Used for debugging this code
 73   private static final boolean DEBUG = false;
 74 
 75   protected void debugMessage(String message) {
 76     System.out.println(message);
 77   }
 78 
 79   static {
 80     VM.registerVMInitializedObserver(new Observer() {
 81         public void update(Observable o, Object data) {
 82           initialize(VM.getVM().getTypeDataBase());
 83         }
 84       });
 85   }
 86 
 87   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
 88     Type type   = db.lookupType(&quot;ConstantPool&quot;);
 89     tags        = type.getAddressField(&quot;_tags&quot;);
 90     operands    = type.getAddressField(&quot;_operands&quot;);
 91     cache       = type.getAddressField(&quot;_cache&quot;);
 92     poolHolder  = new MetadataField(type.getAddressField(&quot;_pool_holder&quot;), 0);
 93     length      = new CIntField(type.getCIntegerField(&quot;_length&quot;), 0);
 94     resolved_klasses = type.getAddressField(&quot;_resolved_klasses&quot;);
 95     headerSize  = type.getSize();
 96     elementSize = 0;
 97     // fetch constants:
 98     INDY_BSM_OFFSET = db.lookupIntConstant(&quot;ConstantPool::_indy_bsm_offset&quot;).intValue();
 99     INDY_ARGC_OFFSET = db.lookupIntConstant(&quot;ConstantPool::_indy_argc_offset&quot;).intValue();
100     INDY_ARGV_OFFSET = db.lookupIntConstant(&quot;ConstantPool::_indy_argv_offset&quot;).intValue();
101   }
102 
103   public ConstantPool(Address addr) {
104     super(addr);
105   }
106 
107   public boolean isConstantPool()      { return true; }
108 
109   private static AddressField tags;
110   private static AddressField operands;
111   private static AddressField cache;
112   private static AddressField resolved_klasses;
113   private static MetadataField poolHolder;
114   private static CIntField length; // number of elements in oop
115 
116   private static long headerSize;
117   private static long elementSize;
118 
119   private static int INDY_BSM_OFFSET;
120   private static int INDY_ARGC_OFFSET;
121   private static int INDY_ARGV_OFFSET;
122 
123   public U1Array           getTags()       { return new U1Array(tags.getValue(getAddress())); }
124   public U2Array           getOperands()   { return new U2Array(operands.getValue(getAddress())); }
125   public ConstantPoolCache getCache()      {
126     Address addr = cache.getValue(getAddress());
127     return (ConstantPoolCache) VMObjectFactory.newObject(ConstantPoolCache.class, addr);
128   }
129   public InstanceKlass     getPoolHolder() { return (InstanceKlass)poolHolder.getValue(this); }
130   public int               getLength()     { return (int)length.getValue(getAddress()); }
131   public Oop               getResolvedReferences() {
132     return getCache().getResolvedReferences();
133   }
134   public KlassArray        getResolvedKlasses() {
135     return new KlassArray(resolved_klasses.getValue(getAddress()));
136   }
137 
138   public U2Array referenceMap() {
139     return getCache().referenceMap();
140   }
141 
142   public int objectToCPIndex(int index) {
143     return referenceMap().at(index);
144   }
145 
146   private long getElementSize() {
147     if (elementSize !=0 ) {
148       return elementSize;
149     } else {
150       elementSize = VM.getVM().getOopSize();
151     }
152     return elementSize;
153   }
154 
155   private long indexOffset(long index) {
156     if (Assert.ASSERTS_ENABLED) {
157       Assert.that(index &gt;= 0 &amp;&amp; index &lt; getLength(),  &quot;invalid cp index &quot; + index + &quot; &quot; + getLength());
158     }
159     return (index * getElementSize()) + headerSize;
160   }
161 
162   public ConstantTag getTagAt(long index) {
163     return new ConstantTag((byte)getTags().at((int) index));
164   }
165 
166   public CPSlot getSlotAt(long index) {
167     return new CPSlot(getAddressAtRaw(index));
168   }
169 
170   public CPKlassSlot getKlassSlotAt(long index) {
171     if (Assert.ASSERTS_ENABLED) {
172       Assert.that(getTagAt(index).isUnresolvedKlass() || getTagAt(index).isKlass(), &quot;Corrupted constant pool&quot;);
173     }
174     int value = getIntAt(index);
175     int name_index = extractHighShortFromInt(value);
176     int resolved_klass_index = extractLowShortFromInt(value);
177     return new CPKlassSlot(name_index, resolved_klass_index);
178   }
179 
180   public Address getAddressAtRaw(long index) {
181     return getAddress().getAddressAt(indexOffset(index));
182   }
183 
184   public Symbol getSymbolAt(long index) {
185     return Symbol.create(getAddressAtRaw(index));
186   }
187 
188   public int getIntAt(long index){
189     return getAddress().getJIntAt(indexOffset(index));
190   }
191 
192   public float getFloatAt(long index){
193     return getAddress().getJFloatAt(indexOffset(index));
194   }
195 
196   public long getLongAt(long index) {
197     int oneHalf = getAddress().getJIntAt(indexOffset(index + 1));
198     int otherHalf   = getAddress().getJIntAt(indexOffset(index));
199     // buildLongFromIntsPD accepts higher address value, lower address value
200     // in that order.
201     return VM.getVM().buildLongFromIntsPD(oneHalf, otherHalf);
202   }
203 
204   public double getDoubleAt(long index) {
205     return Double.longBitsToDouble(getLongAt(index));
206   }
207 
208   public int getFieldOrMethodAt(int which) {
209     if (DEBUG) {
210       System.err.print(&quot;ConstantPool.getFieldOrMethodAt(&quot; + which + &quot;): new index = &quot;);
211     }
212     int i = -1;
213     ConstantPoolCache cache = getCache();
214     if (cache == null) {
215       i = which;
216     } else {
217       // change byte-ordering and go via cache
218       i = cache.getEntryAt(0xFFFF &amp; which).getConstantPoolIndex();
219     }
220     if (Assert.ASSERTS_ENABLED) {
221       Assert.that(getTagAt(i).isFieldOrMethod(), &quot;Corrupted constant pool&quot;);
222     }
223     if (DEBUG) {
224       System.err.println(i);
225     }
226     int res = getIntAt(i);
227     if (DEBUG) {
228       System.err.println(&quot;ConstantPool.getFieldOrMethodAt(&quot; + i + &quot;): result = &quot; + res);
229     }
230     return res;
231   }
232 
233   public int[] getNameAndTypeAt(int which) {
234     if (Assert.ASSERTS_ENABLED) {
235       Assert.that(getTagAt(which).isNameAndType(), &quot;Corrupted constant pool: &quot; + which + &quot; &quot; + getTagAt(which));
236     }
237     int i = getIntAt(which);
238     if (DEBUG) {
239       System.err.println(&quot;ConstantPool.getNameAndTypeAt(&quot; + which + &quot;): result = &quot; + i);
240     }
241     return new int[] { extractLowShortFromInt(i), extractHighShortFromInt(i) };
242   }
243 
244   public Symbol getNameRefAt(int which) {
245     return implGetNameRefAt(which, false);
246   }
247 
248   public Symbol uncachedGetNameRefAt(int which) {
249     return implGetNameRefAt(which, true);
250   }
251 
252   private Symbol implGetNameRefAt(int which, boolean uncached) {
253     int signatureIndex = getNameRefIndexAt(implNameAndTypeRefIndexAt(which, uncached));
254     return getSymbolAt(signatureIndex);
255   }
256 
257   public Symbol getSignatureRefAt(int which) {
258     return implGetSignatureRefAt(which, false);
259   }
260 
261   public Symbol uncachedGetSignatureRefAt(int which) {
262     return implGetSignatureRefAt(which, true);
263   }
264 
265   private Symbol implGetSignatureRefAt(int which, boolean uncached) {
266     int signatureIndex = getSignatureRefIndexAt(implNameAndTypeRefIndexAt(which, uncached));
267     return getSymbolAt(signatureIndex);
268   }
269 
270   public static boolean isInvokedynamicIndex(int i) { return (i &lt; 0); }
271 
272   public static int  decodeInvokedynamicIndex(int i) { Assert.that(isInvokedynamicIndex(i),  &quot;&quot;); return ~i; }
273 
274   // The invokedynamic points at a CP cache entry.  This entry points back
275   // at the original CP entry (CONSTANT_InvokeDynamic) and also (via f2) at an entry
276   // in the resolved_references array (which provides the appendix argument).
277   public int invokedynamicCPCacheIndex(int index) {
278     Assert.that(isInvokedynamicIndex(index), &quot;should be a invokedynamic index&quot;);
279     return decodeInvokedynamicIndex(index);
280   }
281 
282   ConstantPoolCacheEntry invokedynamicCPCacheEntryAt(int index) {
283     // decode index that invokedynamic points to.
284     int cpCacheIndex = invokedynamicCPCacheIndex(index);
285     return getCache().getEntryAt(cpCacheIndex);
286   }
287 
288   private int implNameAndTypeRefIndexAt(int which, boolean uncached) {
289     int i = which;
290     if (!uncached &amp;&amp; getCache() != null) {
291       if (isInvokedynamicIndex(which)) {
292         // Invokedynamic index is index into resolved_references
293         int poolIndex = invokedynamicCPCacheEntryAt(which).getConstantPoolIndex();
294         poolIndex = invokeDynamicNameAndTypeRefIndexAt(poolIndex);
295         Assert.that(getTagAt(poolIndex).isNameAndType(), &quot;&quot;);
296         return poolIndex;
297       }
298       // change byte-ordering and go via cache
299       i = remapInstructionOperandFromCache(which);
300     } else {
301       if (getTagAt(which).isInvokeDynamic() || getTagAt(which).isDynamicConstant()) {
302         int poolIndex = invokeDynamicNameAndTypeRefIndexAt(which);
303         Assert.that(getTagAt(poolIndex).isNameAndType(), &quot;&quot;);
304         return poolIndex;
305       }
306     }
307     // assert(tag_at(i).is_field_or_method(), &quot;Corrupted constant pool&quot;);
308     // assert(!tag_at(i).is_invoke_dynamic(), &quot;Must be handled above&quot;);
309     int refIndex = getIntAt(i);
310     return extractHighShortFromInt(refIndex);
311   }
312 
313   private int remapInstructionOperandFromCache(int operand) {
314     int cpc_index = operand;
315     // DEBUG_ONLY(cpc_index -= CPCACHE_INDEX_TAG);
316     // assert((int)(u2)cpc_index == cpc_index, &quot;clean u2&quot;);
317     int member_index = getCache().getEntryAt(cpc_index).getConstantPoolIndex();
318     return member_index;
319   }
320 
321   public int invokeDynamicNameAndTypeRefIndexAt(int which) {
322     // assert(tag_at(which).is_invoke_dynamic(), &quot;Corrupted constant pool&quot;);
323     return extractHighShortFromInt(getIntAt(which));
324   }
325 
326   // returns null, if not resolved.
327   public Klass getKlassAt(int which) {
328     if( ! getTagAt(which).isKlass()) return null;
329     int resolved_klass_index = getKlassSlotAt(which).getResolvedKlassIndex();
330     KlassArray resolved_klasses = getResolvedKlasses();
331     return resolved_klasses.getAt(resolved_klass_index);
332   }
333 
334   public Symbol getKlassNameAt(int which) {
335     int name_index = getKlassSlotAt(which).getNameIndex();
336     return getSymbolAt(name_index);
337   }
338 
339   public Symbol getUnresolvedStringAt(int which) {
340     return getSlotAt(which).getSymbol();
341   }
342 
343   // returns null, if not resolved.
344   public Klass getFieldOrMethodKlassRefAt(int which) {
345     int refIndex = getFieldOrMethodAt(which);
346     int klassIndex = extractLowShortFromInt(refIndex);
347     return getKlassAt(klassIndex);
348   }
349 
350   // returns null, if not resolved.
351   public Method getMethodRefAt(int which) {
352     Klass klass = getFieldOrMethodKlassRefAt(which);
353     if (klass == null) return null;
354     Symbol name = getNameRefAt(which);
355     Symbol sig  = getSignatureRefAt(which);
356     // Consider the super class for arrays. (java.lang.Object)
357     if (klass.isArrayKlass()) {
358        klass = klass.getJavaSuper();
359     }
360     return ((InstanceKlass)klass).findMethod(name.asString(), sig.asString());
361   }
362 
363   // returns null, if not resolved.
364   public Field getFieldRefAt(int which) {
365     InstanceKlass klass = (InstanceKlass)getFieldOrMethodKlassRefAt(which);
366     if (klass == null) return null;
367     Symbol name = getNameRefAt(which);
368     Symbol sig  = getSignatureRefAt(which);
369     return klass.findField(name.asString(), sig.asString());
370   }
371 
372   public int getNameAndTypeRefIndexAt(int index) {
373     return implNameAndTypeRefIndexAt(index, false);
374   }
375 
376   /** Lookup for entries consisting of (name_index, signature_index) */
377   public int getNameRefIndexAt(int index) {
378     int[] refIndex = getNameAndTypeAt(index);
379     if (DEBUG) {
380       System.err.println(&quot;ConstantPool.getNameRefIndexAt(&quot; + index + &quot;): refIndex = &quot; + refIndex[0]+&quot;/&quot;+refIndex[1]);
381     }
382     int i = refIndex[0];
383     if (DEBUG) {
384       System.err.println(&quot;ConstantPool.getNameRefIndexAt(&quot; + index + &quot;): result = &quot; + i);
385     }
386     return i;
387   }
388 
389   /** Lookup for entries consisting of (name_index, signature_index) */
390   public int getSignatureRefIndexAt(int index) {
391     int[] refIndex = getNameAndTypeAt(index);
392     if (DEBUG) {
393       System.err.println(&quot;ConstantPool.getSignatureRefIndexAt(&quot; + index + &quot;): refIndex = &quot; + refIndex[0]+&quot;/&quot;+refIndex[1]);
394     }
395     int i = refIndex[1];
396     if (DEBUG) {
397       System.err.println(&quot;ConstantPool.getSignatureRefIndexAt(&quot; + index + &quot;): result = &quot; + i);
398     }
399     return i;
400   }
401 
402   /** Lookup for MethodHandle entries. */
403   public int getMethodHandleIndexAt(int i) {
404     if (Assert.ASSERTS_ENABLED) {
405       Assert.that(getTagAt(i).isMethodHandle(), &quot;Corrupted constant pool&quot;);
406     }
407     int res = extractHighShortFromInt(getIntAt(i));
408     if (DEBUG) {
409       System.err.println(&quot;ConstantPool.getMethodHandleIndexAt(&quot; + i + &quot;): result = &quot; + res);
410     }
411     return res;
412   }
413 
414   /** Lookup for MethodHandle entries. */
415   public int getMethodHandleRefKindAt(int i) {
416     if (Assert.ASSERTS_ENABLED) {
417       Assert.that(getTagAt(i).isMethodHandle(), &quot;Corrupted constant pool&quot;);
418     }
419     int res = extractLowShortFromInt(getIntAt(i));
420     if (DEBUG) {
421       System.err.println(&quot;ConstantPool.getMethodHandleRefKindAt(&quot; + i + &quot;): result = &quot; + res);
422     }
423     return res;
424   }
425 
426   /** Lookup for MethodType entries. */
427   public int getMethodTypeIndexAt(int i) {
428     if (Assert.ASSERTS_ENABLED) {
429       Assert.that(getTagAt(i).isMethodType(), &quot;Corrupted constant pool&quot;);
430     }
431     int res = getIntAt(i);
432     if (DEBUG) {
433       System.err.println(&quot;ConstantPool.getMethodHandleTypeAt(&quot; + i + &quot;): result = &quot; + res);
434     }
435     return res;
436   }
437 
438   /** Lookup for multi-operand (InvokeDynamic, Dynamic) entries. */
439   public short[] getBootstrapSpecifierAt(int i) {
440     if (Assert.ASSERTS_ENABLED) {
441       Assert.that(getTagAt(i).isInvokeDynamic() || getTagAt(i).isDynamicConstant(), &quot;Corrupted constant pool&quot;);
442     }
443     int bsmSpec = extractLowShortFromInt(this.getIntAt(i));
444     U2Array operands = getOperands();
445     if (operands == null)  return null;  // safety first
446     int basePos = VM.getVM().buildIntFromShorts(operands.at(bsmSpec * 2 + 0),
447                                                 operands.at(bsmSpec * 2 + 1));
448     int argv = basePos + INDY_ARGV_OFFSET;
449     int argc = operands.at(basePos + INDY_ARGC_OFFSET);
450     int endPos = argv + argc;
451     short[] values = new short[endPos - basePos];
452     for (int j = 0; j &lt; values.length; j++) {
453         values[j] = operands.at(basePos+j);
454     }
455     return values;
456   }
457 
458   final private static String[] nameForTag = new String[] {
459   };
460 
461   private String nameForTag(int tag) {
462     switch (tag) {
463     case JVM_CONSTANT_Utf8:               return &quot;JVM_CONSTANT_Utf8&quot;;
464     case JVM_CONSTANT_Unicode:            return &quot;JVM_CONSTANT_Unicode&quot;;
465     case JVM_CONSTANT_Integer:            return &quot;JVM_CONSTANT_Integer&quot;;
466     case JVM_CONSTANT_Float:              return &quot;JVM_CONSTANT_Float&quot;;
467     case JVM_CONSTANT_Long:               return &quot;JVM_CONSTANT_Long&quot;;
468     case JVM_CONSTANT_Double:             return &quot;JVM_CONSTANT_Double&quot;;
469     case JVM_CONSTANT_Class:              return &quot;JVM_CONSTANT_Class&quot;;
470     case JVM_CONSTANT_String:             return &quot;JVM_CONSTANT_String&quot;;
471     case JVM_CONSTANT_Fieldref:           return &quot;JVM_CONSTANT_Fieldref&quot;;
472     case JVM_CONSTANT_Methodref:          return &quot;JVM_CONSTANT_Methodref&quot;;
473     case JVM_CONSTANT_InterfaceMethodref: return &quot;JVM_CONSTANT_InterfaceMethodref&quot;;
474     case JVM_CONSTANT_NameAndType:        return &quot;JVM_CONSTANT_NameAndType&quot;;
475     case JVM_CONSTANT_MethodHandle:       return &quot;JVM_CONSTANT_MethodHandle&quot;;
476     case JVM_CONSTANT_MethodType:         return &quot;JVM_CONSTANT_MethodType&quot;;
477     case JVM_CONSTANT_Dynamic:            return &quot;JVM_CONSTANT_Dynamic&quot;;
478     case JVM_CONSTANT_InvokeDynamic:      return &quot;JVM_CONSTANT_InvokeDynamic&quot;;
479     case JVM_CONSTANT_Invalid:            return &quot;JVM_CONSTANT_Invalid&quot;;
480     case JVM_CONSTANT_UnresolvedClass:    return &quot;JVM_CONSTANT_UnresolvedClass&quot;;
481     case JVM_CONSTANT_ClassIndex:         return &quot;JVM_CONSTANT_ClassIndex&quot;;
482     case JVM_CONSTANT_StringIndex:        return &quot;JVM_CONSTANT_StringIndex&quot;;
483     case JVM_CONSTANT_UnresolvedClassInError:    return &quot;JVM_CONSTANT_UnresolvedClassInError&quot;;
484     case JVM_CONSTANT_MethodHandleInError:return &quot;JVM_CONSTANT_MethodHandleInError&quot;;
485     case JVM_CONSTANT_MethodTypeInError:  return &quot;JVM_CONSTANT_MethodTypeInError&quot;;
486     }
487     throw new InternalError(&quot;Unknown tag: &quot; + tag);
488   }
489 
490   public void iterateFields(MetadataVisitor visitor) {
491     super.iterateFields(visitor);
492     visitor.doMetadata(poolHolder, true);
493 
494       final int length = (int) getLength();
495       // zero&#39;th pool entry is always invalid. ignore it.
496       for (int index = 1; index &lt; length; index++) {
497       int ctag = (int) getTags().at((int) index);
498         switch (ctag) {
499         case JVM_CONSTANT_ClassIndex:
500         case JVM_CONSTANT_StringIndex:
501         case JVM_CONSTANT_Integer:
502           visitor.doInt(new IntField(new NamedFieldIdentifier(nameForTag(ctag)), indexOffset(index), true), true);
503           break;
504 
505         case JVM_CONSTANT_Float:
506           visitor.doFloat(new FloatField(new NamedFieldIdentifier(nameForTag(ctag)), indexOffset(index), true), true);
507           break;
508 
509         case JVM_CONSTANT_Long:
510           visitor.doLong(new LongField(new NamedFieldIdentifier(nameForTag(ctag)), indexOffset(index), true), true);
511           // long entries occupy two slots
512           index++;
513           break;
514 
515         case JVM_CONSTANT_Double:
516           visitor.doDouble(new DoubleField(new NamedFieldIdentifier(nameForTag(ctag)), indexOffset(index), true), true);
517           // double entries occupy two slots
518           index++;
519           break;
520 
521         case JVM_CONSTANT_UnresolvedClassInError:
522         case JVM_CONSTANT_UnresolvedClass:
523         case JVM_CONSTANT_Class:
524         case JVM_CONSTANT_Utf8:
525           visitor.doOop(new OopField(new NamedFieldIdentifier(nameForTag(ctag)), indexOffset(index), true), true);
526           break;
527 
528         case JVM_CONSTANT_Fieldref:
529         case JVM_CONSTANT_Methodref:
530         case JVM_CONSTANT_InterfaceMethodref:
531         case JVM_CONSTANT_NameAndType:
532         case JVM_CONSTANT_MethodHandle:
533         case JVM_CONSTANT_MethodType:
534         case JVM_CONSTANT_Dynamic:
535         case JVM_CONSTANT_InvokeDynamic:
536           visitor.doInt(new IntField(new NamedFieldIdentifier(nameForTag(ctag)), indexOffset(index), true), true);
537           break;
538         }
539       }
540     }
541 
542   public void writeBytes(OutputStream os) throws IOException {
543           // Map between any modified UTF-8 and it&#39;s constant pool index.
<a name="3" id="anc3"></a><span class="line-modified">544           Map&lt;String, Short&gt; utf8ToIndex = new HashMap&lt;&gt;();</span>
545       DataOutputStream dos = new DataOutputStream(os);
546       U1Array tags = getTags();
547       int len = (int)getLength();
548       int ci = 0; // constant pool index
549 
550       // collect all modified UTF-8 Strings from Constant Pool
551 
552       for (ci = 1; ci &lt; len; ci++) {
553           int cpConstType = tags.at(ci);
554           if(cpConstType == JVM_CONSTANT_Utf8) {
555               Symbol sym = getSymbolAt(ci);
<a name="4" id="anc4"></a><span class="line-modified">556               utf8ToIndex.put(sym.asString(), (short) ci);</span>
557           }
558           else if(cpConstType == JVM_CONSTANT_Long ||
559                   cpConstType == JVM_CONSTANT_Double) {
560               ci++;
561           }
562       }
563 
564 
565       for(ci = 1; ci &lt; len; ci++) {
566           int cpConstType = tags.at(ci);
567           // write cp_info
568           // write constant type
569           switch(cpConstType) {
570               case JVM_CONSTANT_Utf8: {
571                   dos.writeByte(cpConstType);
572                   Symbol sym = getSymbolAt(ci);
573                   dos.writeShort((short)sym.getLength());
574                   dos.write(sym.asByteArray());
575                   if (DEBUG) debugMessage(&quot;CP[&quot; + ci + &quot;] = modified UTF-8 &quot; + sym.asString());
576                   break;
577               }
578 
579               case JVM_CONSTANT_Unicode:
580                   throw new IllegalArgumentException(&quot;Unicode constant!&quot;);
581 
582               case JVM_CONSTANT_Integer:
583                   dos.writeByte(cpConstType);
584                   dos.writeInt(getIntAt(ci));
585                   if (DEBUG) debugMessage(&quot;CP[&quot; + ci + &quot;] = int &quot; + getIntAt(ci));
586                   break;
587 
588               case JVM_CONSTANT_Float:
589                   dos.writeByte(cpConstType);
590                   dos.writeFloat(getFloatAt(ci));
591                   if (DEBUG) debugMessage(&quot;CP[&quot; + ci + &quot;] = float &quot; + getFloatAt(ci));
592                   break;
593 
594               case JVM_CONSTANT_Long: {
595                   dos.writeByte(cpConstType);
596                   long l = getLongAt(ci);
597                   // long entries occupy two pool entries
598                   ci++;
599                   dos.writeLong(l);
600                   break;
601               }
602 
603               case JVM_CONSTANT_Double:
604                   dos.writeByte(cpConstType);
605                   dos.writeDouble(getDoubleAt(ci));
606                   // double entries occupy two pool entries
607                   ci++;
608                   break;
609 
610               case JVM_CONSTANT_Class: {
611                   dos.writeByte(cpConstType);
612                   // Klass already resolved. ConstantPool constains Klass*.
613                   Klass refKls = (Klass)Metadata.instantiateWrapperFor(getAddressAtRaw(ci));
614                   String klassName = refKls.getName().asString();
615                   Short s = (Short) utf8ToIndex.get(klassName);
616                   dos.writeShort(s.shortValue());
617                   if (DEBUG) debugMessage(&quot;CP[&quot; + ci  + &quot;] = class &quot; + s);
618                   break;
619               }
620 
621               // case JVM_CONSTANT_ClassIndex:
622               case JVM_CONSTANT_UnresolvedClassInError:
623               case JVM_CONSTANT_UnresolvedClass: {
624                   dos.writeByte(JVM_CONSTANT_Class);
625                   String klassName = getSymbolAt(ci).asString();
626                   Short s = (Short) utf8ToIndex.get(klassName);
627                   dos.writeShort(s.shortValue());
628                   if (DEBUG) debugMessage(&quot;CP[&quot; + ci + &quot;] = class &quot; + s);
629                   break;
630               }
631 
632               case JVM_CONSTANT_String: {
633                   dos.writeByte(cpConstType);
634                   String str = getUnresolvedStringAt(ci).asString();
635                   Short s = (Short) utf8ToIndex.get(str);
636                   dos.writeShort(s.shortValue());
637                   if (DEBUG) debugMessage(&quot;CP[&quot; + ci + &quot;] = string &quot; + s);
638                   break;
639               }
640 
641               // all external, internal method/field references
642               case JVM_CONSTANT_Fieldref:
643               case JVM_CONSTANT_Methodref:
644               case JVM_CONSTANT_InterfaceMethodref: {
645                   dos.writeByte(cpConstType);
646                   int value = getIntAt(ci);
647                   short klassIndex = (short) extractLowShortFromInt(value);
648                   short nameAndTypeIndex = (short) extractHighShortFromInt(value);
649                   dos.writeShort(klassIndex);
650                   dos.writeShort(nameAndTypeIndex);
651                   if (DEBUG) debugMessage(&quot;CP[&quot; + ci + &quot;] = ref klass = &quot; +
652                                           klassIndex + &quot;, N&amp;T = &quot; + nameAndTypeIndex);
653                   break;
654               }
655 
656               case JVM_CONSTANT_NameAndType: {
657                   dos.writeByte(cpConstType);
658                   int value = getIntAt(ci);
659                   short nameIndex = (short) extractLowShortFromInt(value);
660                   short signatureIndex = (short) extractHighShortFromInt(value);
661                   dos.writeShort(nameIndex);
662                   dos.writeShort(signatureIndex);
663                   if (DEBUG) debugMessage(&quot;CP[&quot; + ci + &quot;] = N&amp;T name = &quot; + nameIndex
664                                           + &quot;, type = &quot; + signatureIndex);
665                   break;
666               }
667 
668               case JVM_CONSTANT_MethodHandle: {
669                   dos.writeByte(cpConstType);
670                   int value = getIntAt(ci);
671                   byte refKind = (byte) extractLowShortFromInt(value);
672                   short memberIndex = (short) extractHighShortFromInt(value);
673                   dos.writeByte(refKind);
674                   dos.writeShort(memberIndex);
675                   if (DEBUG) debugMessage(&quot;CP[&quot; + ci + &quot;] = MH kind = &quot; +
676                                           refKind + &quot;, mem = &quot; + memberIndex);
677                   break;
678               }
679 
680               case JVM_CONSTANT_MethodType: {
681                   dos.writeByte(cpConstType);
682                   int value = getIntAt(ci);
683                   short refIndex = (short) value;
684                   dos.writeShort(refIndex);
685                   if (DEBUG) debugMessage(&quot;CP[&quot; + ci + &quot;] = MT index = &quot; + refIndex);
686                   break;
687               }
688 
689               case JVM_CONSTANT_InvokeDynamic: {
690                   dos.writeByte(cpConstType);
691                   int value = getIntAt(ci);
692                   short bsmIndex = (short) extractLowShortFromInt(value);
693                   short nameAndTypeIndex = (short) extractHighShortFromInt(value);
694                   dos.writeShort(bsmIndex);
695                   dos.writeShort(nameAndTypeIndex);
696                   if (DEBUG) debugMessage(&quot;CP[&quot; + ci + &quot;] = INDY bsm = &quot; +
697                                           bsmIndex + &quot;, N&amp;T = &quot; + nameAndTypeIndex);
698                   break;
699               }
700 
701               default:
702                   throw new InternalError(&quot;Unknown tag: &quot; + cpConstType);
703           } // switch
704       }
705       dos.flush();
706       return;
707   }
708 
709   public void printValueOn(PrintStream tty) {
710     tty.print(&quot;ConstantPool for &quot; + getPoolHolder().getName().asString());
711   }
712 
713   public long getSize() {
714     return alignSize(headerSize + getLength());
715   }
716 
717   //----------------------------------------------------------------------
718   // Internals only below this point
719   //
720 
721   private static int extractHighShortFromInt(int val) {
722     // must stay in sync with ConstantPool::name_and_type_at_put, method_at_put, etc.
723     return (val &gt;&gt; 16) &amp; 0xFFFF;
724   }
725 
726   private static int extractLowShortFromInt(int val) {
727     // must stay in sync with ConstantPool::name_and_type_at_put, method_at_put, etc.
728     return val &amp; 0xFFFF;
729   }
730 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
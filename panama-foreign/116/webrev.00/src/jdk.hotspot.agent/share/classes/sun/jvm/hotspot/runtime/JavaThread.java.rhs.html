<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/JavaThread.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.runtime;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.oops.*;
 31 import sun.jvm.hotspot.types.*;
 32 import sun.jvm.hotspot.utilities.*;
<a name="2" id="anc2"></a><span class="line-added"> 33 import sun.jvm.hotspot.utilities.Observable;</span>
<span class="line-added"> 34 import sun.jvm.hotspot.utilities.Observer;</span>
 35 
 36 /** This is an abstract class because there are certain OS- and
 37     CPU-specific operations (like the setting and getting of the last
 38     Java frame pointer) which need to be factored out. These
 39     operations are implemented by, for example,
 40     SolarisSPARCJavaThread, and the concrete subclasses are
 41     instantiated by the JavaThreadFactory in the Threads class. */
 42 
 43 public class JavaThread extends Thread {
 44   private static final boolean DEBUG = System.getProperty(&quot;sun.jvm.hotspot.runtime.JavaThread.DEBUG&quot;) != null;
 45 
 46   private static sun.jvm.hotspot.types.OopField threadObjField;
 47   private static AddressField  anchorField;
 48   private static AddressField  lastJavaSPField;
 49   private static AddressField  lastJavaPCField;
 50   private static CIntegerField threadStateField;
 51   private static AddressField  osThreadField;
 52   private static AddressField  stackBaseField;
 53   private static CIntegerField stackSizeField;
 54   private static CIntegerField terminatedField;
 55 
 56   private static JavaThreadPDAccess access;
 57 
 58   // JavaThreadStates read from underlying process
 59   private static int           UNINITIALIZED;
 60   private static int           NEW;
 61   private static int           NEW_TRANS;
 62   private static int           IN_NATIVE;
 63   private static int           IN_NATIVE_TRANS;
 64   private static int           IN_VM;
 65   private static int           IN_VM_TRANS;
 66   private static int           IN_JAVA;
 67   private static int           IN_JAVA_TRANS;
 68   private static int           BLOCKED;
 69   private static int           BLOCKED_TRANS;
 70 
 71   private static int           NOT_TERMINATED;
 72   private static int           EXITING;
 73 
 74   private static final String  ADDRESS_FORMAT = VM.getVM().isLP64() ? &quot;0x%016x&quot; : &quot;0x%08x&quot;;
 75 
 76   static {
 77     VM.registerVMInitializedObserver(new Observer() {
 78         public void update(Observable o, Object data) {
 79           initialize(VM.getVM().getTypeDataBase());
 80         }
 81       });
 82   }
 83 
 84   private static synchronized void initialize(TypeDataBase db) {
 85     Type type = db.lookupType(&quot;JavaThread&quot;);
 86     Type anchorType = db.lookupType(&quot;JavaFrameAnchor&quot;);
 87 
 88     threadObjField    = type.getOopField(&quot;_threadObj&quot;);
 89     anchorField       = type.getAddressField(&quot;_anchor&quot;);
 90     lastJavaSPField   = anchorType.getAddressField(&quot;_last_Java_sp&quot;);
 91     lastJavaPCField   = anchorType.getAddressField(&quot;_last_Java_pc&quot;);
 92     threadStateField  = type.getCIntegerField(&quot;_thread_state&quot;);
 93     osThreadField     = type.getAddressField(&quot;_osthread&quot;);
 94     stackBaseField    = type.getAddressField(&quot;_stack_base&quot;);
 95     stackSizeField    = type.getCIntegerField(&quot;_stack_size&quot;);
 96     terminatedField   = type.getCIntegerField(&quot;_terminated&quot;);
 97 
 98     UNINITIALIZED     = db.lookupIntConstant(&quot;_thread_uninitialized&quot;).intValue();
 99     NEW               = db.lookupIntConstant(&quot;_thread_new&quot;).intValue();
100     NEW_TRANS         = db.lookupIntConstant(&quot;_thread_new_trans&quot;).intValue();
101     IN_NATIVE         = db.lookupIntConstant(&quot;_thread_in_native&quot;).intValue();
102     IN_NATIVE_TRANS   = db.lookupIntConstant(&quot;_thread_in_native_trans&quot;).intValue();
103     IN_VM             = db.lookupIntConstant(&quot;_thread_in_vm&quot;).intValue();
104     IN_VM_TRANS       = db.lookupIntConstant(&quot;_thread_in_vm_trans&quot;).intValue();
105     IN_JAVA           = db.lookupIntConstant(&quot;_thread_in_Java&quot;).intValue();
106     IN_JAVA_TRANS     = db.lookupIntConstant(&quot;_thread_in_Java_trans&quot;).intValue();
107     BLOCKED           = db.lookupIntConstant(&quot;_thread_blocked&quot;).intValue();
108     BLOCKED_TRANS     = db.lookupIntConstant(&quot;_thread_blocked_trans&quot;).intValue();
109 
110     NOT_TERMINATED    = db.lookupIntConstant(&quot;JavaThread::_not_terminated&quot;).intValue();
111     EXITING           = db.lookupIntConstant(&quot;JavaThread::_thread_exiting&quot;).intValue();
112 
113   }
114 
115   public JavaThread(Address addr) {
116     super(addr);
117   }
118 
119   void setThreadPDAccess(JavaThreadPDAccess access) {
120     this.access = access;
121   }
122 
123   /** NOTE: for convenience, this differs in definition from the underlying VM.
124       Only &quot;pure&quot; JavaThreads return true; CompilerThreads, the CodeCacheSweeperThread,
125       JVMDIDebuggerThreads return false.
126       FIXME:
127       consider encapsulating platform-specific functionality in an
128       object instead of using inheritance (which is the primary reason
129       we can&#39;t traverse CompilerThreads, etc; didn&#39;t want to have, for
130       example, &quot;SolarisSPARCCompilerThread&quot;.) */
131   public boolean isJavaThread() { return true; }
132 
133   public boolean isExiting () {
134       return (getTerminated() == EXITING) || isTerminated();
135   }
136 
137   public boolean isTerminated() {
138       return (getTerminated() != NOT_TERMINATED) &amp;&amp; (getTerminated() != EXITING);
139   }
140 
141   public static AddressField getAnchorField() { return anchorField; }
142 
143   /** Get the last Java stack pointer */
144   public Address getLastJavaSP() {
145     Address sp = lastJavaSPField.getValue(addr.addOffsetTo(anchorField.getOffset()));
146     return sp;
147   }
148 
149   public Address getLastJavaPC() {
150     Address pc = lastJavaPCField.getValue(addr.addOffsetTo(anchorField.getOffset()));
151     return pc;
152   }
153 
154   /** Abstract accessor to last Java frame pointer, implemented by
155       OS/CPU-specific JavaThread implementation. May return null if
156       there is no frame pointer or if it is not necessary on this
157       platform. */
158   public Address getLastJavaFP(){
159         return access.getLastJavaFP(addr);
160   }
161 
162   /** Abstract accessor to last Java pc, implemented by
163       OS/CPU-specific JavaThread implementation. May return null if
164       there is no frame pointer or if it is not necessary on this
165       platform. */
166 
167   /*
168   public Address getLastJavaPC(){
169         return access.getLastJavaPC(addr);
170   }
171   */
172 
173   // FIXME: not yet implementable
174   //  public abstract void    setLastJavaFP(Address fp);
175 
176   /** A stack pointer older than any java frame stack pointer. Only
177       needed on some platforms; for example, see
178       thread_solaris_sparc.hpp. */
179   public Address getBaseOfStackPointer(){
180         return access.getBaseOfStackPointer(addr);
181   }
182   // FIXME: not yet implementable
183   //  public abstract void    setBaseOfStackPointer(Address fp);
184 
185   /** Tells whether the last Java frame is set */
186   public boolean hasLastJavaFrame() {
187     return (getLastJavaSP() != null);
188   }
189 
190   /** Accessing frames */
191   public Frame getLastFrame() {
192     // FIXME: would need to implement runtime routine
193     // &quot;cacheStatePD(boolean)&quot; for reflective system to be able to
194     // flush register windows on SPARC
195     return cookLastFrame(getLastFramePD());
196   }
197 
198   /** Internal routine implemented by platform-dependent subclasses */
199   protected Frame getLastFramePD(){
200         return access.getLastFramePD(this, addr);
201   }
202 
203   /** Accessing frames. Returns the last Java VFrame or null if none
204       was present. (NOTE that this is mostly unusable in a debugging
205       system; see getLastJavaVFrameDbg, below, which provides very
206       different functionality.) */
207   public JavaVFrame getLastJavaVFrame(RegisterMap regMap) {
208     if (Assert.ASSERTS_ENABLED) {
209       Assert.that(regMap != null, &quot;a map must be given&quot;);
210     }
211     Frame f = getLastFrame();
212     if (f == null) {
213       return null;
214     }
215     for (VFrame vf = VFrame.newVFrame(f, regMap, this); vf != null; vf = vf.sender()) {
216       if (vf.isJavaFrame()) {
217         return (JavaVFrame) vf;
218       }
219     }
220     return null;
221   }
222 
223   /** This should only be used by a debugger. Uses the current frame
224       guess to attempt to get the topmost JavaVFrame.
225       (getLastJavaVFrame, as a port of the VM&#39;s routine, assumes the
226       VM is at a safepoint.) */
227   public JavaVFrame getLastJavaVFrameDbg() {
228     RegisterMap regMap = newRegisterMap(true);
229     sun.jvm.hotspot.runtime.Frame f = getCurrentFrameGuess();
230     if (f == null) return null;
231     boolean imprecise = true;
232     if (f.isInterpretedFrame() &amp;&amp; !f.isInterpretedFrameValid()) {
233        if (DEBUG) {
234          System.out.println(&quot;Correcting for invalid interpreter frame&quot;);
235        }
236        f = f.sender(regMap);
237        imprecise = false;
238     }
239     VFrame vf = VFrame.newVFrame(f, regMap, this, true, imprecise);
240     if (vf == null) {
241       if (DEBUG) {
242         System.out.println(&quot; (Unable to create vframe for topmost frame guess)&quot;);
243       }
244       return null;
245     }
246     return vf.isJavaFrame() ? (JavaVFrame)vf : vf.javaSender();
247   }
248 
249   /** In this system, a JavaThread is the top-level factory for a
250       RegisterMap, since the JavaThread implementation is already
251       platform-specific and RegisterMap is also necessarily
252       platform-specific. The updateMap argument indicates whether the
253       register map needs to be updated, for example during stack
254       traversal -- see frame.hpp. */
255   public RegisterMap newRegisterMap(boolean updateMap){
256         return access.newRegisterMap(this, updateMap);
257   }
258 
259   /** This is only designed to be used by the debugging system.
260       Returns a &quot;best guess&quot; of the topmost frame on the stack. This
261       guess should be as &quot;raw&quot; as possible. For example, if the
262       topmost frame is an interpreter frame (the return PC is in the
263       interpreter) but is not a valid frame (i.e., the BCI has not yet
264       been set up) this should still return the topmost frame and not
265       the sender. Validity checks are done at higher levels. */
266   public  Frame getCurrentFrameGuess(){
267         return access.getCurrentFrameGuess(this, addr);
268   }
269 
270   /** Also only intended for use by the debugging system. Provides the
271       same effect of OSThread::print(); that is, prints a value which
272       allows the user to intuitively understand which native OS thread
273       maps to this Java thread. Does not print a newline or leading or
274       trailing spaces. */
275   public  void printThreadIDOn(PrintStream tty) {
276         access.printThreadIDOn(addr,tty);
277   }
278 
279   public void printThreadID() {
280     printThreadIDOn(System.out);
281   }
282 
283   public ThreadProxy getThreadProxy() {
284     return access.getThreadProxy(addr);
285   }
286 
287   //
288   // Safepoint support
289   //
290 
291   public JavaThreadState getThreadState() {
292     int val = (int) threadStateField.getValue(addr);
293     if (val == UNINITIALIZED) {
294       return JavaThreadState.UNINITIALIZED;
295     } else if (val == NEW) {
296       return JavaThreadState.NEW;
297     } else if (val == NEW_TRANS) {
298       return JavaThreadState.NEW_TRANS;
299     } else if (val == IN_NATIVE) {
300       return JavaThreadState.IN_NATIVE;
301     } else if (val == IN_NATIVE_TRANS) {
302       return JavaThreadState.IN_NATIVE_TRANS;
303     } else if (val == IN_VM) {
304       return JavaThreadState.IN_VM;
305     } else if (val == IN_VM_TRANS) {
306       return JavaThreadState.IN_VM_TRANS;
307     } else if (val == IN_JAVA) {
308       return JavaThreadState.IN_JAVA;
309     } else if (val == IN_JAVA_TRANS) {
310       return JavaThreadState.IN_JAVA_TRANS;
311     } else if (val == BLOCKED) {
312       return JavaThreadState.BLOCKED;
313     } else if (val == BLOCKED_TRANS) {
314       return JavaThreadState.BLOCKED_TRANS;
315     } else {
316       throw new RuntimeException(&quot;Illegal thread state &quot; + val);
317     }
318   }
319   // FIXME: not yet implementable
320   // public void setThreadState(JavaThreadState s);
321 
322   //
323   // Miscellaneous operations
324   //
325 
326   public OSThread getOSThread() {
327     return (OSThread) VMObjectFactory.newObject(OSThread.class, osThreadField.getValue(addr));
328   }
329 
330   public Address getStackBase() {
331     return stackBaseField.getValue(addr);
332   }
333 
334   public long getStackBaseValue() {
335     return VM.getVM().getAddressValue(getStackBase());
336   }
337 
338   public long getStackSize() {
339     return stackSizeField.getValue(addr);
340   }
341 
342   public int getTerminated() {
343       return (int) terminatedField.getValue(addr);
344   }
345 
346   /** Gets the Java-side thread object for this JavaThread */
347   public Oop getThreadObj() {
348     Oop obj = null;
349     try {
350       obj = VM.getVM().getObjectHeap().newOop(threadObjField.getValue(addr));
351     } catch (Exception e) {
352       e.printStackTrace();
353     }
354     return obj;
355   }
356 
357   /** Get the Java-side name of this thread */
358   public String getThreadName() {
359     Oop threadObj = getThreadObj();
360     if (threadObj == null) {
361         return &quot;&lt;null&gt;&quot;;
362     }
363     return OopUtilities.threadOopGetName(threadObj);
364   }
365 
366   //
367   // Oop traversal
368   //
369 
370   public void oopsDo(AddressVisitor oopVisitor) {
371     super.oopsDo(oopVisitor);
372 
373     // FIXME: add in the rest of the routine from the VM
374 
375     // Traverse the execution stack
376     for(StackFrameStream fst = new StackFrameStream(this); !fst.isDone(); fst.next()) {
377       fst.getCurrent().oopsDo(oopVisitor, fst.getRegisterMap());
378     }
379   }
380 
381   public boolean isInStack(Address a) {
382     if (Assert.ASSERTS_ENABLED) {
383       Assert.that(VM.getVM().isDebugging(), &quot;Not yet implemented for non-debugging system&quot;);
384     }
385     Address sp      = lastSPDbg();
386     Address stackBase = getStackBase();
387     // Be robust
388     if (sp == null) return false;
389     return stackBase.greaterThan(a) &amp;&amp; sp.lessThanOrEqual(a);
390   }
391 
392   public boolean isLockOwned(Address a) {
393     Address stackBase = getStackBase();
394     Address stackLimit = stackBase.addOffsetTo(-getStackSize());
395 
396     return stackBase.greaterThan(a) &amp;&amp; stackLimit.lessThanOrEqual(a);
397 
398     // FIXME: should traverse MonitorArray/MonitorChunks as in VM
399   }
400 
401   public Oop getCurrentParkBlocker() {
402     Oop threadObj = getThreadObj();
403     if (threadObj != null) {
404       return OopUtilities.threadOopGetParkBlocker(threadObj);
405     }
406     return null;
407   }
408 
409   public void printInfoOn(PrintStream tty) {
410 
411     tty.println(&quot;State: &quot; + getThreadState().toString());
412     // Attempt to figure out the addresses covered by Java frames.
413     // NOTE: we should make this a method and let the Stackwalk panel use the result too.
414     //
415     sun.jvm.hotspot.runtime.Frame tmpFrame = getCurrentFrameGuess();
416     if (tmpFrame != null ) {
417       Address sp = tmpFrame.getSP();
418       Address maxSP = sp;
419       Address minSP = sp;
420       RegisterMap tmpMap = newRegisterMap(false);
421       while ((tmpFrame != null) &amp;&amp; (!tmpFrame.isFirstFrame())) {
422           tmpFrame = tmpFrame.sender(tmpMap);
423           if (tmpFrame != null) {
424             sp = tmpFrame.getSP();
425             maxSP = AddressOps.max(maxSP, sp);
426             minSP = AddressOps.min(minSP, sp);
427           }
428       }
429       tty.println(&quot;Stack in use by Java: &quot; + minSP + &quot; .. &quot; + maxSP);
430     } else {
431       tty.println(&quot;No Java frames present&quot;);
432     }
433     tty.println(&quot;Base of Stack: &quot; + getStackBase());
434     tty.println(&quot;Last_Java_SP: &quot; + getLastJavaSP());
435     tty.println(&quot;Last_Java_FP: &quot; + getLastJavaFP());
436     tty.println(&quot;Last_Java_PC: &quot; + getLastJavaPC());
437     // More stuff like saved_execption_pc, safepoint_state, ...
438     access.printInfoOn(addr, tty);
439 
440   }
441 
442   ///////////////////////////////
443   //                           //
444   // FIXME: add more accessors //
445   //                           //
446   ///////////////////////////////
447 
448   //--------------------------------------------------------------------------------
449   // Internals only below this point
450   //
451 
452   private Frame cookLastFrame(Frame fr) {
453     if (fr == null) {
454       return null;
455     }
456 
457     Address pc        = fr.getPC();
458 
459     if (Assert.ASSERTS_ENABLED) {
460       if (pc == null) {
461         Assert.that(VM.getVM().isDebugging(), &quot;must have PC&quot;);
462       }
463     }
464     return fr;
465   }
466 
467   private Address lastSPDbg() {
468     return access.getLastSP(addr);
469   }
470 
471 
472   public void printThreadInfoOn(PrintStream out){
473     Oop threadOop = this.getThreadObj();
474 
475     out.print(&quot;\&quot;&quot;);
476     out.print(this.getThreadName());
477     out.print(&quot;\&quot; #&quot;);
478     out.print(OopUtilities.threadOopGetTID(threadOop));
479     if(OopUtilities.threadOopGetDaemon(threadOop)){
480       out.print(&quot; daemon&quot;);
481     }
482     out.print(&quot; prio=&quot;);
483     out.print(OopUtilities.threadOopGetPriority(threadOop));
484     out.print(&quot; tid=&quot;);
485     out.print(this.getAddress());
486     out.print(&quot; nid=&quot;);
487     out.print(String.format(&quot;0x%x &quot;,this.getOSThread().threadId()));
488     out.print(getOSThread().getThreadState().getPrintVal());
489     out.print(&quot; [&quot;);
490     if(this.getLastJavaSP() == null){
491       out.print(String.format(ADDRESS_FORMAT,0L));
492     } else {
493       out.print(this.getLastJavaSP().andWithMask(~0xFFF));
494     }
495     out.println(&quot;]&quot;);
496     out.print(&quot;   java.lang.Thread.State: &quot;);
497     out.println(OopUtilities.threadOopGetThreadStatusName(threadOop));
498     out.print(&quot;   JavaThread state: _thread_&quot;);
499     out.println(this.getThreadState().toString().toLowerCase());
500   }
501 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
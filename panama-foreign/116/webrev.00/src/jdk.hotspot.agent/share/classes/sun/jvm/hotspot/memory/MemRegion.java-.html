<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/memory/MemRegion.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2001, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.memory;
 26 
 27 import java.util.*;
 28 
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.runtime.*;
 31 import sun.jvm.hotspot.types.*;
 32 import sun.jvm.hotspot.utilities.*;
 33 
 34 /** A very simple data structure representing a contigous region of
 35     address space. */
 36 
 37 public class MemRegion implements Cloneable {
 38   private Address start;
 39   private long byteSize;
 40 
 41   private static AddressField  startField;
 42   private static CIntegerField wordSizeField;
 43 
 44   static {
 45     VM.registerVMInitializedObserver(new Observer() {
 46         public void update(Observable o, Object data) {
 47           initialize(VM.getVM().getTypeDataBase());
 48         }
 49       });
 50   }
 51 
 52   private static synchronized void initialize(TypeDataBase db) {
 53     Type type = db.lookupType(&quot;MemRegion&quot;);
 54 
 55     startField    = type.getAddressField(&quot;_start&quot;);
 56     wordSizeField = type.getCIntegerField(&quot;_word_size&quot;);
 57   }
 58 
 59   public MemRegion() {
 60   }
 61 
 62   /** This constructor takes a &quot;MemRegion*&quot; in the target process */
 63   public MemRegion(Address memRegionAddr) {
 64     this(startField.getValue(memRegionAddr),
 65          wordSizeField.getValue(memRegionAddr));
 66   }
 67 
 68   public MemRegion(Address start, long wordSize) {
 69     setStart(start);
 70     setWordSize(wordSize);
 71   }
 72 
 73   public MemRegion(Address start, Address limit) {
 74     setStart(start);
 75     byteSize = limit.minus(start);
 76   }
 77 
 78   public Object clone() {
 79     return new MemRegion(start, byteSize);
 80   }
 81 
 82   public MemRegion copy() {
 83     return (MemRegion) clone();
 84   }
 85 
 86   public MemRegion intersection(MemRegion mr2) {
 87     MemRegion res = new MemRegion();
 88     if (AddressOps.gt(mr2.start(), start())) {
 89       res.setStart(mr2.start());
 90     } else {
 91       res.setStart(start());
 92     }
 93     Address resEnd;
 94     Address end = end();
 95     Address mr2End = mr2.end();
 96     if (AddressOps.lt(end, mr2End)) {
 97       resEnd = end;
 98     } else {
 99       resEnd = mr2End;
100     }
101     if (AddressOps.lt(resEnd, res.start())) {
102       res.setStart(null);
103       res.setWordSize(0);
104     } else {
105       res.setEnd(resEnd);
106     }
107     return res;
108   }
109 
110   public MemRegion union(MemRegion mr2) {
111     MemRegion res = new MemRegion();
112     if (AddressOps.lt(mr2.start(), start())) {
113       res.setStart(mr2.start());
114     } else {
115       res.setStart(start());
116     }
117     Address resEnd;
118     Address end = end();
119     Address mr2End = mr2.end();
120     if (AddressOps.gt(end, mr2End)) {
121       resEnd = end;
122     } else {
123       resEnd = mr2End;
124     }
125     res.setEnd(resEnd);
126     return res;
127   }
128 
129   public Address start() {
130     return start;
131   }
132 
133   public OopHandle startAsOopHandle() {
134     return start().addOffsetToAsOopHandle(0);
135   }
136 
137   public Address end() {
138     return start.addOffsetTo(byteSize);
139   }
140 
141   public OopHandle endAsOopHandle() {
142     return end().addOffsetToAsOopHandle(0);
143   }
144 
145   public void setStart(Address start) {
146     this.start = start;
147   }
148 
149   public void setEnd(Address end) {
150     byteSize = end.minus(start);
151   }
152 
153   public void setWordSize(long wordSize) {
154     byteSize = VM.getVM().getAddressSize() * wordSize;
155   }
156 
157   public boolean contains(MemRegion mr2) {
158     return AddressOps.lte(start, mr2.start) &amp;&amp; AddressOps.gte(end(), mr2.end());
159   }
160 
161   public boolean contains(Address addr) {
162     return AddressOps.gte(addr, start()) &amp;&amp; AddressOps.lt(addr, end());
163   }
164 
165   public long byteSize() {
166     return byteSize;
167   }
168 
169   public long wordSize() {
170     return byteSize / VM.getVM().getAddressSize();
171   }
172 }
    </pre>
  </body>
</html>
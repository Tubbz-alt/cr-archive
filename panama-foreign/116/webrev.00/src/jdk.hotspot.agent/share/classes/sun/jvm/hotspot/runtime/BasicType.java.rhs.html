<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/BasicType.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.runtime;
 26 
<a name="2" id="anc2"></a>
 27 import sun.jvm.hotspot.types.TypeDataBase;
 28 
 29 
 30 /** Encapsulates the BasicType enum in globalDefinitions.hpp in the
 31     VM. */
 32 
 33 public class BasicType {
 34   public static final BasicType T_BOOLEAN = new BasicType();
 35   public static final BasicType T_CHAR = new BasicType();
 36   public static final BasicType T_FLOAT = new BasicType();
 37   public static final BasicType T_DOUBLE = new BasicType();
 38   public static final BasicType T_BYTE = new BasicType();
 39   public static final BasicType T_SHORT = new BasicType();
 40   public static final BasicType T_INT = new BasicType();
 41   public static final BasicType T_LONG = new BasicType();
 42   public static final BasicType T_OBJECT = new BasicType();
 43   public static final BasicType T_ARRAY = new BasicType();
 44   public static final BasicType T_VOID = new BasicType();
 45   public static final BasicType T_ADDRESS = new BasicType();
 46   public static final BasicType T_NARROWOOP = new BasicType();
 47   public static final BasicType T_METADATA = new BasicType();
 48   public static final BasicType T_NARROWKLASS = new BasicType();
 49   public static final BasicType T_CONFLICT = new BasicType();
 50   public static final BasicType T_ILLEGAL = new BasicType();
 51 
 52   static {
 53     VM.registerVMInitializedObserver(
 54         (o, d) -&gt; initialize(VM.getVM().getTypeDataBase()));
 55   }
 56 
 57   private static synchronized void initialize(TypeDataBase db) {
 58     T_BOOLEAN.setType(db.lookupIntConstant(&quot;T_BOOLEAN&quot;).intValue());
 59     T_CHAR.setType(db.lookupIntConstant(&quot;T_CHAR&quot;).intValue());
 60     T_FLOAT.setType(db.lookupIntConstant(&quot;T_FLOAT&quot;).intValue());
 61     T_DOUBLE.setType(db.lookupIntConstant(&quot;T_DOUBLE&quot;).intValue());
 62     T_BYTE.setType(db.lookupIntConstant(&quot;T_BYTE&quot;).intValue());
 63     T_SHORT.setType(db.lookupIntConstant(&quot;T_SHORT&quot;).intValue());
 64     T_INT.setType(db.lookupIntConstant(&quot;T_INT&quot;).intValue());
 65     T_LONG.setType(db.lookupIntConstant(&quot;T_LONG&quot;).intValue());
 66     T_OBJECT.setType(db.lookupIntConstant(&quot;T_OBJECT&quot;).intValue());
 67     T_ARRAY.setType(db.lookupIntConstant(&quot;T_ARRAY&quot;).intValue());
 68     T_VOID.setType(db.lookupIntConstant(&quot;T_VOID&quot;).intValue());
 69     T_ADDRESS.setType(db.lookupIntConstant(&quot;T_ADDRESS&quot;).intValue());
 70     T_NARROWOOP.setType(db.lookupIntConstant(&quot;T_NARROWOOP&quot;).intValue());
 71     T_METADATA.setType(db.lookupIntConstant(&quot;T_METADATA&quot;).intValue());
 72     T_NARROWKLASS.setType(db.lookupIntConstant(&quot;T_NARROWKLASS&quot;).intValue());
 73     T_CONFLICT.setType(db.lookupIntConstant(&quot;T_CONFLICT&quot;).intValue());
 74     T_ILLEGAL.setType(db.lookupIntConstant(&quot;T_ILLEGAL&quot;).intValue());
 75   }
 76 
 77   public static int getTBoolean() {
 78     return T_BOOLEAN.getType();
 79   }
 80 
 81   public static int getTChar() {
 82     return T_CHAR.getType();
 83   }
 84 
 85   public static int getTFloat() {
 86     return T_FLOAT.getType();
 87   }
 88 
 89   public static int getTDouble() {
 90     return T_DOUBLE.getType();
 91   }
 92 
 93   public static int getTByte() {
 94     return T_BYTE.getType();
 95   }
 96 
 97   public static int getTShort() {
 98     return T_SHORT.getType();
 99   }
100 
101   public static int getTInt() {
102     return T_INT.getType();
103   }
104 
105   public static int getTLong() {
106     return T_LONG.getType();
107   }
108 
109   public static int getTObject() {
110     return T_OBJECT.getType();
111   }
112 
113   public static int getTArray() {
114     return T_ARRAY.getType();
115   }
116 
117   public static int getTVoid() {
118     return T_VOID.getType();
119   }
120 
121   public static int getTAddress() {
122     return T_ADDRESS.getType();
123   }
124 
125   public static int getTNarrowOop() {
126     return T_NARROWOOP.getType();
127   }
128 
129   public static int getTMetadata() {
130     return T_METADATA.getType();
131   }
132 
133   public static int getTNarrowKlass() {
134     return T_NARROWKLASS.getType();
135   }
136 
137   /** For stack value type with conflicting contents */
138   public static int getTConflict() {
139     return T_CONFLICT.getType();
140   }
141 
142   public static int getTIllegal() {
143     return T_ILLEGAL.getType();
144   }
145 
146   public static BasicType intToBasicType(int i) {
147     if (i == T_BOOLEAN.getType()) {
148       return T_BOOLEAN;
149     } else if (i == T_CHAR.getType()) {
150       return T_CHAR;
151     } else if (i == T_FLOAT.getType()) {
152       return T_FLOAT;
153     } else if (i == T_DOUBLE.getType()) {
154       return T_DOUBLE;
155     } else if (i == T_BYTE.getType()) {
156       return T_BYTE;
157     } else if (i == T_SHORT.getType()) {
158       return T_SHORT;
159     } else if (i == T_INT.getType()) {
160       return T_INT;
161     } else if (i == T_LONG.getType()) {
162       return T_LONG;
163     } else if (i == T_OBJECT.getType()) {
164       return T_OBJECT;
165     } else if (i == T_ARRAY.getType()) {
166       return T_ARRAY;
167     } else if (i == T_VOID.getType()) {
168       return T_VOID;
169     } else if (i == T_ADDRESS.getType()) {
170       return T_ADDRESS;
171     } else if (i == T_NARROWOOP.getType()) {
172       return T_NARROWOOP;
173     } else if (i == T_METADATA.getType()) {
174       return T_METADATA;
175     } else if (i == T_NARROWKLASS.getType()) {
176       return T_NARROWKLASS;
177     } else {
178       return T_ILLEGAL;
179     }
180   }
181 
182   public static BasicType charToBasicType(char c) {
183     switch( c ) {
184     case &#39;B&#39;: return T_BYTE;
185     case &#39;C&#39;: return T_CHAR;
186     case &#39;D&#39;: return T_DOUBLE;
187     case &#39;F&#39;: return T_FLOAT;
188     case &#39;I&#39;: return T_INT;
189     case &#39;J&#39;: return T_LONG;
190     case &#39;S&#39;: return T_SHORT;
191     case &#39;Z&#39;: return T_BOOLEAN;
192     case &#39;V&#39;: return T_VOID;
193     case &#39;L&#39;: return T_OBJECT;
194     case &#39;[&#39;: return T_ARRAY;
195     }
196     return T_ILLEGAL;
197   }
198 
199   public static int charToType(char c) {
200     return charToBasicType(c).getType();
201   }
202 
203   public int getType() {
204     return type;
205   }
206 
207   public String getName() {
208     if (type == T_BOOLEAN.getType()) {
209       return &quot;boolean&quot;;
210     } else if (type == T_CHAR.getType()) {
211       return &quot;char&quot;;
212     } else if (type == T_FLOAT.getType()) {
213       return &quot;float&quot;;
214     } else if (type == T_DOUBLE.getType()) {
215       return &quot;double&quot;;
216     } else if (type == T_BYTE.getType()) {
217       return &quot;byte&quot;;
218     } else if (type == T_SHORT.getType()) {
219       return &quot;short&quot;;
220     } else if (type == T_INT.getType()) {
221       return &quot;int&quot;;
222     } else if (type == T_LONG.getType()) {
223       return &quot;long&quot;;
224     } else if (type == T_OBJECT.getType()) {
225       return &quot;object&quot;;
226     } else if (type == T_ARRAY.getType()) {
227       return &quot;array&quot;;
228     } else if (type == T_VOID.getType()) {
229       return &quot;void&quot;;
230     } else if (type == T_ADDRESS.getType()) {
231       return &quot;address&quot;;
232     } else if (type == T_NARROWOOP.getType()) {
233       return &quot;narrow oop&quot;;
234     } else if (type == T_METADATA.getType()) {
235       return &quot;metadata&quot;;
236     } else if (type == T_NARROWKLASS.getType()) {
237       return &quot;narrow klass&quot;;
238     } else if (type == T_CONFLICT.getType()) {
239       return &quot;conflict&quot;;
240     } else {
241       return &quot;ILLEGAL TYPE&quot;;
242     }
243   }
244 
245   //-- Internals only below this point
246   private BasicType() {
247   }
248 
249   private void setType(int type) {
250     this.type = type;
251   }
252 
253   private int type;
254 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/cdbg/basic/BasicCDebugInfoDataBase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.debugger.cdbg.basic;
 26 
 27 import java.util.*;
 28 import sun.jvm.hotspot.debugger.*;
 29 import sun.jvm.hotspot.debugger.cdbg.*;
 30 import sun.jvm.hotspot.utilities.AddressOps;
 31 import sun.jvm.hotspot.utilities.Assert;
 32 
 33 public class BasicCDebugInfoDataBase implements CDebugInfoDataBase {
 34   private static final int INITIALIZED_STATE  = 0;
 35   private static final int CONSTRUCTION_STATE = 1;
 36   private static final int RESOLVED_STATE     = 2;
 37   private static final int COMPLETE_STATE     = 3;
 38 
 39   private int state = INITIALIZED_STATE;
 40 
 41   ///////////
 42   // Types //
 43   ///////////
 44 
 45   // Used only during construction
 46   private Map&lt;Object, Type&gt; lazyTypeMap;
 47 
 48   // Used during construction and at run time for iteration
 49   private List&lt;Type&gt; types;
 50 
 51   // Used only during runtime
 52   private Map&lt;String, Type&gt; nameToTypeMap;
 53 
 54   /////////////
 55   // Symbols //
 56   /////////////
 57 
 58   // Used only during construction
 59   private Map&lt;Object, BlockSym&gt; lazySymMap;
 60 
 61   // List of blocks in increasing order by starting address. These can
 62   // then be binary searched.
 63   private List&lt;BlockSym&gt; blocks;
 64 
 65   // Name-to-global symbol table
 66   private Map&lt;String, GlobalSym&gt; nameToSymMap;
 67 
 68   //////////////////
 69   // Line numbers //
 70   //////////////////
 71 
 72   private BasicLineNumberMapping lineNumbers;
 73 
 74   /** Supports lazy instantiation and references between types and
 75       symbols via insertion using arbitrary Object keys that are
 76       wrapped by LazyTypes. Once the database has been fully
 77       constructed and all types are present, one should call
 78       resolveTypes(), which will resolve all LazyTypes down to
 79       concrete types (and signal an error if some lazy types were
 80       unresolved). */
 81   public void beginConstruction() {
 82     if (Assert.ASSERTS_ENABLED) {
 83       Assert.that(state == INITIALIZED_STATE, &quot;wrong state&quot;);
 84     }
 85     state   = CONSTRUCTION_STATE;
 86 
 87     // Types
 88     lazyTypeMap  = new HashMap&lt;&gt;();
 89     types        = new ArrayList&lt;&gt;();
 90 
 91     // Symbols
 92     lazySymMap   = new HashMap&lt;&gt;();
 93     blocks       = new ArrayList&lt;&gt;();
 94     nameToSymMap = new HashMap&lt;&gt;();
 95 
 96     // Line numbers
 97     lineNumbers  = new BasicLineNumberMapping();
 98   }
 99 
100   /** Add a type which may later in construction be referred to via a
101       LazyType with this key. lazyKey may be null. */
102   public void addType(Object lazyKey, Type type) {
103     if (Assert.ASSERTS_ENABLED) {
104       Assert.that(state == CONSTRUCTION_STATE, &quot;wrong state&quot;);
105     }
106     if (lazyKey != null) {
107       if (lazyTypeMap.put(lazyKey, type) != null) {
108         throw new RuntimeException(&quot;Type redefined for lazy key &quot; + lazyKey);
109       }
110     } else {
111       types.add(type);
112     }
113   }
114 
115   public void resolve(ResolveListener listener) {
116     if (Assert.ASSERTS_ENABLED) {
117       Assert.that(state == CONSTRUCTION_STATE, &quot;wrong state&quot;);
118     }
119     // Go through all types in lazyTypeMap and types.
120     // Resolve all LazyTypes.
121     resolveLazyMap(listener);
122     for (ListIterator&lt;Type&gt; iter = types.listIterator(); iter.hasNext(); ) {
123       BasicType t = (BasicType) iter.next();
124       BasicType t2 = (BasicType) t.resolveTypes(this, listener);
125       if (t != t2) {
126         iter.set(t2);
127       }
128     }
129     // Go through all symbols and resolve references to types and
130     // references to other symbols
131     for (Iterator iter = blocks.iterator(); iter.hasNext(); ) {
132       ((BasicSym) iter.next()).resolve(this, listener);
133     }
134     for (Iterator iter = nameToSymMap.values().iterator(); iter.hasNext(); ) {
135       ((BasicSym) iter.next()).resolve(this, listener);
136     }
137 
138     // Sort blocks in ascending order of starting address (but do not
139     // change ordering among blocks with the same starting address)
140     Collections.sort(blocks, new Comparator&lt;&gt;() {
141         public int compare(BlockSym b1, BlockSym b2) {
142           Address a1 = b1.getAddress();
143           Address a2 = b2.getAddress();
144           if (AddressOps.lt(a1, a2)) { return -1; }
145           if (AddressOps.gt(a1, a2)) { return 1; }
146           return 0;
147         }
148       });
149 
150     state = RESOLVED_STATE;
151   }
152 
153   public void endConstruction() {
154     if (Assert.ASSERTS_ENABLED) {
155       Assert.that(state == RESOLVED_STATE, &quot;wrong state&quot;);
156     }
157     // Move all types to type list
158     for (Iterator&lt;Type&gt; iter = lazyTypeMap.values().iterator(); iter.hasNext(); ) {
159       types.add(iter.next());
160     }
161     // Build name-to-type map
162     nameToTypeMap = new HashMap&lt;&gt;();
163     for (Iterator iter = types.iterator(); iter.hasNext(); ) {
164       Type t = (Type) iter.next();
165       if (!t.isConst() &amp;&amp; !t.isVolatile()) {
166         nameToTypeMap.put(t.getName(), t);
167       }
168     }
169     // Lose lazy maps
170     lazyTypeMap = null;
171     lazySymMap  = null;
172     // Sort and finish line number information
173     lineNumbers.sort();
174     // FIXME: on some platforms it might not be necessary to call
175     // recomputeEndPCs(). Will have to see what stabs information
176     // looks like. Should make configurable whether we make this call
177     // or not.
178     lineNumbers.recomputeEndPCs();
179 
180     state = COMPLETE_STATE;
181   }
182 
183   public Type lookupType(String name) {
184     return lookupType(name, 0);
185   }
186 
187   public Type lookupType(String name, int cvAttributes) {
188     if (Assert.ASSERTS_ENABLED) {
189       Assert.that(state == COMPLETE_STATE, &quot;wrong state&quot;);
190     }
191     BasicType t = (BasicType) nameToTypeMap.get(name);
192     if (t != null) {
193       if (cvAttributes != 0) {
194         t = (BasicType) t.getCVVariant(cvAttributes);
195       }
196     }
197     return t;
198   }
199 
200   public void iterate(TypeVisitor v) {
201     if (Assert.ASSERTS_ENABLED) {
202       Assert.that(state == COMPLETE_STATE, &quot;wrong state&quot;);
203     }
204     for (Iterator iter = types.iterator(); iter.hasNext(); ) {
205       BasicType t = (BasicType) iter.next();
206       t.visit(v);
207     }
208   }
209 
210   /** Add a BlockSym to the debug information database. The given
211       BlockSym may be referred to by a LazyBlockSym wrapping the given
212       Object key, which must be non-null. Any references to other
213       blocks (for example, the parent scope) should be made with
214       LazyBlockSyms. These references will be resolved after the
215       database is built. */
216   public void addBlock(Object key, BlockSym block) {
217     if (Assert.ASSERTS_ENABLED) {
218       Assert.that(key != null, &quot;key must be non-null&quot;);
219     }
220     lazySymMap.put(key, block);
221     blocks.add(block);
222   }
223 
224   public void addGlobalSym(GlobalSym sym) {
225     nameToSymMap.put(sym.getName(), sym);
226   }
227 
228   public BlockSym debugInfoForPC(Address pc) {
229     return searchBlocks(pc, 0, blocks.size() - 1);
230   }
231 
232   public GlobalSym lookupSym(String name) {
233     return (GlobalSym) nameToSymMap.get(name);
234   }
235 
236   public void addLineNumberInfo(BasicLineNumberInfo info) {
237     lineNumbers.addLineNumberInfo(info);
238   }
239 
240   public LineNumberInfo lineNumberForPC(Address pc) throws DebuggerException {
241     return lineNumbers.lineNumberForPC(pc);
242   }
243 
244   public void iterate(LineNumberVisitor v) {
245     lineNumbers.iterate(v);
246   }
247 
248   //----------------------------------------------------------------------
249   // Internals only below this point
250   //
251 
252   /** Intended only to be used by the BasicType implementation. */
253   public Type resolveType(Type containingType, Type targetType, ResolveListener listener, String detail) {
254     BasicType basicTargetType = (BasicType) targetType;
255     if (Assert.ASSERTS_ENABLED) {
256       Assert.that(state == CONSTRUCTION_STATE, &quot;wrong state&quot;);
257     }
258     if (basicTargetType.isLazy()) {
259       BasicType resolved = (BasicType) lazyTypeMap.get(((LazyType) targetType).getKey());
260       // FIXME: would like to have an assert here that the target is
261       // non-null, but apparently have bugs here with forward
262       // references of pointer types
263       if (resolved == null) {
264         listener.resolveFailed(containingType, (LazyType) targetType, detail + &quot; because target type was not found&quot;);
265         return targetType;
266       }
267       if (resolved.isLazy()) {
268         // Might happen for const/var variants for forward references
269         if (resolved.isConst() || resolved.isVolatile()) {
270           resolved = (BasicType) resolved.resolveTypes(this, listener);
271         }
272         if (resolved.isLazy()) {
273           listener.resolveFailed(containingType, (LazyType) targetType,
274                                  detail + &quot; because target type (with key &quot; +
275                                  ((Integer) ((LazyType) resolved).getKey()).intValue() +
276                                  (resolved.isConst() ? &quot;, const&quot; : &quot;, not const&quot;) +
277                                  (resolved.isVolatile() ? &quot;, volatile&quot; : &quot;, not volatile&quot;) +
278                                  &quot;) was lazy&quot;);
279         }
280       }
281       return resolved;
282     }
283     return targetType;
284   }
285 
286   /** Intended only to be usd by the BasicSym implementation. */
287   public Type resolveType(Sym containingSymbol, Type targetType, ResolveListener listener, String detail) {
288     BasicType basicTargetType = (BasicType) targetType;
289     if (Assert.ASSERTS_ENABLED) {
290       Assert.that(state == CONSTRUCTION_STATE, &quot;wrong state&quot;);
291     }
292     if (basicTargetType.isLazy()) {
293       BasicType resolved = (BasicType) lazyTypeMap.get(((LazyType) targetType).getKey());
294       // FIXME: would like to have an assert here that the target is
295       // non-null, but apparently have bugs here
296       if (resolved == null) {
297         listener.resolveFailed(containingSymbol, (LazyType) targetType, detail);
298         return targetType;
299       }
300       if (resolved.isLazy()) {
301         // Might happen for const/var variants for forward references
302         if (resolved.isConst() || resolved.isVolatile()) {
303           resolved = (BasicType) resolved.resolveTypes(this, listener);
304         }
305         if (resolved.isLazy()) {
306           listener.resolveFailed(containingSymbol, (LazyType) targetType, detail);
307         }
308       }
309       return resolved;
310     }
311     return targetType;
312   }
313 
314   /** Intended only to be usd by the BasicSym implementation. */
315   public Sym resolveSym(Sym containingSymbol, Sym targetSym, ResolveListener listener, String detail) {
316     if (targetSym == null) return null;
317     BasicSym basicTargetSym = (BasicSym) targetSym;
318     if (Assert.ASSERTS_ENABLED) {
319       Assert.that(state == CONSTRUCTION_STATE, &quot;wrong state&quot;);
320     }
321     if (basicTargetSym.isLazy()) {
322       BasicSym resolved = (BasicSym) lazySymMap.get(((LazyBlockSym) targetSym).getKey());
323       // FIXME: would like to have an assert here that the target is
324       // non-null, but apparently have bugs here
325       if (resolved == null) {
326         listener.resolveFailed(containingSymbol, (LazyBlockSym) targetSym, detail);
327         return targetSym;
328       }
329       if (resolved.isLazy()) {
330         listener.resolveFailed(containingSymbol, (LazyBlockSym) targetSym, detail);
331       }
332       return resolved;
333     }
334     return targetSym;
335   }
336 
337   private void resolveLazyMap(ResolveListener listener) {
338     for (Iterator&lt;Map.Entry&lt;Object, Type&gt;&gt; iter = lazyTypeMap.entrySet().iterator(); iter.hasNext(); ) {
339       Map.Entry&lt;Object, Type&gt; entry = iter.next();
340       BasicType t = (BasicType) entry.getValue();
341       BasicType t2 = (BasicType) t.resolveTypes(this, listener);
342       if (t2 != t) {
343         entry.setValue(t2);
344       }
345     }
346   }
347 
348   /** Find the block whose starting address is closest to but less
349       than the given address. */
350   private BlockSym searchBlocks(Address addr, int lowIdx, int highIdx) {
351     if (highIdx &lt; lowIdx) return null;
352     if ((lowIdx == highIdx) || (lowIdx == highIdx - 1)) {
353       // Base case: start with highIdx and walk backward. See whether
354       // addr is greater than any of the blocks&#39; starting addresses,
355       // and if so, return that block.
356       Address lastAddr = null;
357       BlockSym ret = null;
358       for (int i = highIdx; i &gt;= 0; --i) {
359         BlockSym block = (BlockSym) blocks.get(i);
360         if (AddressOps.lte(block.getAddress(), addr)) {
361           if ((lastAddr == null) || (AddressOps.equal(block.getAddress(), lastAddr))) {
362             lastAddr = block.getAddress();
363             ret = block;
364           } else {
365             break;
366           }
367         }
368       }
369       return ret;
370     }
371     int midIdx = (lowIdx + highIdx) &gt;&gt; 1;
372     BlockSym block = (BlockSym) blocks.get(midIdx);
373     // See address relationship
374     if (AddressOps.lte(block.getAddress(), addr)) {
375       // Always move search up
376       return searchBlocks(addr, midIdx, highIdx);
377     } else {
378       // Always move search down
379       return searchBlocks(addr, lowIdx, midIdx);
380     }
381   }
382 }
    </pre>
  </body>
</html>
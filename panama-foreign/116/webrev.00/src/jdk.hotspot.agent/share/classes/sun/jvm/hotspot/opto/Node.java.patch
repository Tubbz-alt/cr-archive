diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/opto/Node.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/opto/Node.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/opto/Node.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/opto/Node.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -29,10 +29,12 @@
 import java.util.*;
 import sun.jvm.hotspot.debugger.*;
 import sun.jvm.hotspot.runtime.*;
 import sun.jvm.hotspot.oops.*;
 import sun.jvm.hotspot.types.*;
+import sun.jvm.hotspot.utilities.Observable;
+import sun.jvm.hotspot.utilities.Observer;
 
 public class Node extends VMObject {
   static {
     VM.registerVMInitializedObserver(new Observer() {
         public void update(Observable o, Object data) {
@@ -51,36 +53,36 @@
     outField = type.getAddressField("_out");
     inField = type.getAddressField("_in");
 
     nodeType = db.lookupType("Node");
 
-    virtualConstructor = new VirtualBaseConstructor(db, nodeType, "sun.jvm.hotspot.opto", Node.class);
+    virtualConstructor = new VirtualBaseConstructor<>(db, nodeType, "sun.jvm.hotspot.opto", Node.class);
   }
 
   private static CIntField outmaxField;
   private static CIntField outcntField;
   private static CIntField maxField;
   private static CIntField cntField;
   private static CIntField idxField;
   private static AddressField outField;
   private static AddressField inField;
 
-  private static VirtualBaseConstructor virtualConstructor;
+  private static VirtualBaseConstructor<Node> virtualConstructor;
 
   private static Type nodeType;
 
-  static HashMap nodes = new HashMap();
+  static HashMap<Address, Node> nodes = new HashMap<>();
 
   static HashMap constructors = new HashMap();
 
   static abstract class Instantiator {
     abstract Node create(Address addr);
   }
 
   static public Node create(Address addr) {
     if (addr == null) return null;
-    Node result = (Node)nodes.get(addr);
+    Node result = nodes.get(addr);
     if (result == null) {
       result = (Node)virtualConstructor.instantiateWrapperFor(addr);
       nodes.put(addr, result);
     }
     return result;
@@ -131,13 +133,13 @@
       }
     }
     return _in[i];
   }
 
-  public ArrayList collect(int d, boolean onlyCtrl) {
+  public ArrayList<Node> collect(int d, boolean onlyCtrl) {
     int depth = Math.abs(d);
-    ArrayList nstack = new ArrayList();
+    ArrayList<Node> nstack = new ArrayList<>();
     BitSet set = new BitSet();
 
     nstack.add(this);
     set.set(idx());
     int begin = 0;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/code/Location.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.code;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 
 30 import sun.jvm.hotspot.runtime.*;
 31 import sun.jvm.hotspot.types.*;
 32 import sun.jvm.hotspot.utilities.*;
<a name="2" id="anc2"></a><span class="line-added"> 33 import sun.jvm.hotspot.utilities.Observable;</span>
<span class="line-added"> 34 import sun.jvm.hotspot.utilities.Observer;</span>
 35 
 36 /** &lt;P&gt; A Location describes a concrete machine variable location
 37     (such as integer or floating point register or a stack-held
 38     variable). Used when generating debug-information for
 39     nmethods. &lt;/P&gt;
 40 
 41     &lt;P&gt; Encoding: &lt;/P&gt;
 42     &lt;PRE&gt;
 43     bits:
 44     Type:   [3..0]
 45     Where:  [4]
 46     Offset: [31..5]
 47     &lt;/PRE&gt;
 48 */
 49 
 50 public class Location {
 51   static {
 52     VM.registerVMInitializedObserver(new Observer() {
 53         public void update(Observable o, Object data) {
 54           initialize(VM.getVM().getTypeDataBase());
 55         }
 56       });
 57   }
 58 
 59   private static void initialize(TypeDataBase db) {
 60     if (Assert.ASSERTS_ENABLED) {
 61       Assert.that(!VM.getVM().isCore(), &quot;Debug info not used in core build&quot;);
 62     }
 63 
 64     OFFSET_MASK  = db.lookupIntConstant(&quot;Location::OFFSET_MASK&quot;).intValue();
 65     OFFSET_SHIFT = db.lookupIntConstant(&quot;Location::OFFSET_SHIFT&quot;).intValue();
 66     TYPE_MASK    = db.lookupIntConstant(&quot;Location::TYPE_MASK&quot;).intValue();
 67     TYPE_SHIFT   = db.lookupIntConstant(&quot;Location::TYPE_SHIFT&quot;).intValue();
 68     WHERE_MASK   = db.lookupIntConstant(&quot;Location::WHERE_MASK&quot;).intValue();
 69     WHERE_SHIFT  = db.lookupIntConstant(&quot;Location::WHERE_SHIFT&quot;).intValue();
 70 
 71     // Location::Type constants
 72     TYPE_NORMAL = db.lookupIntConstant(&quot;Location::normal&quot;).intValue();
 73     TYPE_OOP = db.lookupIntConstant(&quot;Location::oop&quot;).intValue();
 74     TYPE_NARROWOOP = db.lookupIntConstant(&quot;Location::narrowoop&quot;).intValue();
 75     TYPE_INT_IN_LONG = db.lookupIntConstant(&quot;Location::int_in_long&quot;).intValue();
 76     TYPE_LNG = db.lookupIntConstant(&quot;Location::lng&quot;).intValue();
 77     TYPE_FLOAT_IN_DBL = db.lookupIntConstant(&quot;Location::float_in_dbl&quot;).intValue();
 78     TYPE_DBL = db.lookupIntConstant(&quot;Location::dbl&quot;).intValue();
 79     TYPE_ADDR = db.lookupIntConstant(&quot;Location::addr&quot;).intValue();
 80     TYPE_INVALID = db.lookupIntConstant(&quot;Location::invalid&quot;).intValue();
 81 
 82     // Location::Where constants
 83     WHERE_ON_STACK = db.lookupIntConstant(&quot;Location::on_stack&quot;).intValue();
 84     WHERE_IN_REGISTER = db.lookupIntConstant(&quot;Location::in_register&quot;).intValue();
 85   }
 86 
 87   private int value;
 88 
 89   // type safe enum for &quot;Where&quot;
 90   public static class Where {
 91     public static final Where ON_STACK    = new Where(&quot;on_stack&quot;);
 92     public static final Where IN_REGISTER = new Where(&quot;in_register&quot;);
 93 
 94     private Where(String value) {
 95       this.value = value;
 96     }
 97 
 98     public String toString() {
 99       return value;
100     }
101 
102     private String value;
103 
104     public int getValue() {
105       if (this == ON_STACK) {
106          return WHERE_ON_STACK;
107       } else if (this == IN_REGISTER) {
108          return WHERE_IN_REGISTER;
109       } else {
110          throw new RuntimeException(&quot;should not reach here&quot;);
111       }
112     }
113   }
114 
115   // type safe enum for &quot;Type&quot;
116   public static class Type {
117     /** Ints, floats, double halves */
118     public static final Type NORMAL       = new Type(&quot;normal&quot;);
119     /** Oop (please GC me!) */
120     public static final Type OOP          = new Type(&quot;oop&quot;);
121     /** NarrowOop (please GC me!) */
122     public static final Type NARROWOOP    = new Type(&quot;narrowoop&quot;);
123     /** Long held in one register */
124     public static final Type INT_IN_LONG  = new Type(&quot;int_in_long&quot;);
125     /** Long held in one register */
126     public static final Type LNG          = new Type(&quot;lng&quot;);
127     /** Float held in double register */
128     public static final Type FLOAT_IN_DBL = new Type(&quot;float_in_dbl&quot;);
129     /** Double held in one register */
130     public static final Type DBL          = new Type(&quot;dbl&quot;);
131     /** JSR return address */
132     public static final Type ADDR         = new Type(&quot;addr&quot;);
133     /** Invalid location */
134     public static final Type INVALID      = new Type(&quot;invalid&quot;);
135 
136     private Type(String value) {
137       this.value = value;
138     }
139     private String value;
140 
141     public String toString() {
142       return value;
143     }
144 
145     public int getValue() {
146       if (this == NORMAL) {
147         return TYPE_NORMAL;
148       } else if (this == OOP) {
149         return TYPE_OOP;
150       } else if (this == NARROWOOP) {
151         return TYPE_NARROWOOP;
152       } else if (this == INT_IN_LONG) {
153         return TYPE_INT_IN_LONG;
154       } else if (this == LNG) {
155         return TYPE_LNG;
156       } else if (this == FLOAT_IN_DBL) {
157         return TYPE_FLOAT_IN_DBL;
158       } else if (this == DBL) {
159         return TYPE_DBL;
160       } else if (this == ADDR) {
161         return TYPE_ADDR;
162       } else if (this == INVALID) {
163         return TYPE_INVALID;
164       } else {
165         throw new RuntimeException(&quot;should not reach here&quot;);
166       }
167     }
168   }
169 
170   private static int OFFSET_MASK;
171   private static int OFFSET_SHIFT;
172   private static int TYPE_MASK;
173   private static int TYPE_SHIFT;
174   private static int WHERE_MASK;
175   private static int WHERE_SHIFT;
176 
177   // constants in Type enum
178   private static int TYPE_NORMAL;
179   private static int TYPE_OOP;
180   private static int TYPE_NARROWOOP;
181   private static int TYPE_INT_IN_LONG;
182   private static int TYPE_LNG;
183   private static int TYPE_FLOAT_IN_DBL;
184   private static int TYPE_DBL;
185   private static int TYPE_ADDR;
186   private static int TYPE_INVALID;
187 
188   // constants in Where enum
189   private static int WHERE_ON_STACK;
190   private static int WHERE_IN_REGISTER;
191 
192   /** Create a bit-packed Location */
193   Location(Where where, Type type, int offset) {
194     setWhere(where);
195     setType(type);
196     setOffset(offset);
197   }
198 
199   public Where getWhere() {
200     int where = (value &amp; WHERE_MASK) &gt;&gt; WHERE_SHIFT;
201     if (where == WHERE_ON_STACK) {
202        return Where.ON_STACK;
203     } else if (where == WHERE_IN_REGISTER) {
204        return Where.IN_REGISTER;
205     } else {
206        throw new RuntimeException(&quot;should not reach here&quot;);
207     }
208   }
209 
210   public Type getType() {
211     int type = (value &amp; TYPE_MASK) &gt;&gt; TYPE_SHIFT;
212     if (type == TYPE_NORMAL) {
213        return Type.NORMAL;
214     } else if (type == TYPE_OOP) {
215        return Type.OOP;
216     } else if (type == TYPE_NARROWOOP) {
217        return Type.NARROWOOP;
218     } else if (type == TYPE_INT_IN_LONG) {
219        return Type.INT_IN_LONG;
220     } else if (type == TYPE_LNG) {
221        return Type.LNG;
222     } else if (type == TYPE_FLOAT_IN_DBL) {
223        return Type.FLOAT_IN_DBL;
224     } else if (type == TYPE_DBL) {
225        return Type.DBL;
226     } else if (type == TYPE_ADDR) {
227        return Type.ADDR;
228     } else if (type == TYPE_INVALID) {
229        return Type.INVALID;
230     } else {
231        throw new RuntimeException(&quot;should not reach here&quot;);
232     }
233   }
234 
235   public short getOffset() {
236     return (short) ((value &amp; OFFSET_MASK) &gt;&gt; OFFSET_SHIFT);
237   }
238 
239   public boolean isRegister() {
240     return getWhere() == Where.IN_REGISTER;
241   }
242 
243   public boolean isStack() {
244     return getWhere() == Where.ON_STACK;
245   }
246 
247   public boolean holdsOop() {
248     return getType() == Type.OOP;
249   }
250 
251   public boolean holdsNarrowOop() {
252     return getType() == Type.NARROWOOP;
253   }
254 
255   public boolean holdsInt() {
256     return getType() == Type.INT_IN_LONG;
257   }
258 
259   public boolean holdsLong() {
260     return getType() == Type.LNG;
261   }
262 
263   public boolean holdsFloat() {
264     return getType() == Type.FLOAT_IN_DBL;
265   }
266 
267   public boolean holdsDouble() {
268     return getType() == Type.DBL;
269   }
270 
271   public boolean holdsAddr() {
272     return getType() == Type.ADDR;
273   }
274 
275   public boolean isIllegal() {
276     return getType() == Type.INVALID;
277   }
278 
279   public int getStackOffset() {
280     if (Assert.ASSERTS_ENABLED) {
281       Assert.that(getWhere() == Where.ON_STACK, &quot;wrong Where&quot;);
282     }
283     return getOffset() * (int)VM.getVM().getIntSize();
284   }
285 
286   public int getRegisterNumber() {
287     if (Assert.ASSERTS_ENABLED) {
288       Assert.that(getWhere() == Where.IN_REGISTER, &quot;wrong Where&quot;);
289     }
290     return getOffset();
291   }
292 
293   public void print() {
294     printOn(System.out);
295   }
296 
297   public void printOn(PrintStream tty) {
298     tty.print(&quot;Value &quot; + value + &quot;, &quot;);
299     if (isIllegal()) {
300       tty.print(&quot;Illegal&quot;);
301     } else {
302       Where w = getWhere();
303       if (w == Where.ON_STACK) {
304         tty.print(&quot;stack[&quot; + getStackOffset() + &quot;]&quot;);
305       } else if (w == Where.IN_REGISTER) {
306         tty.print(&quot;reg &quot; + getRegisterNumber());
307       }
308 
309       Type type = getType();
310       if (type == Type.NORMAL) {
311       } else if (type == Type.OOP) {
312         tty.print(&quot;,oop&quot;);
313       } else if (type == Type.NARROWOOP) {
314         tty.print(&quot;,narrowoop&quot;);
315       } else if (type == Type.INT_IN_LONG) {
316         tty.print(&quot;,int&quot;);
317       } else if (type == Type.LNG) {
318         tty.print(&quot;,long&quot;);
319       } else if (type == Type.FLOAT_IN_DBL) {
320         tty.print(&quot;,float&quot;);
321       } else if (type == Type.DBL) {
322         tty.print(&quot;,double&quot;);
323       } else if (type == Type.ADDR) {
324         tty.print(&quot;,address&quot;);
325       } else if (type == Type.INVALID) {
326         tty.print(&quot;,invalid&quot;);
327       }
328     }
329   }
330 
331   /** Serialization of debugging information */
332   public Location(DebugInfoReadStream stream) {
333     value = stream.readInt();
334   }
335 
336   // FIXME: not yet implementable
337   // void write_on(DebugInfoWriteStream* stream);
338 
339 
340   //-----------------------------------------------------------------------------
341   // Internals only below this point
342   //
343 
344   private void setWhere(Where where) {
345     value |= ((where.getValue() &lt;&lt; WHERE_SHIFT) &amp; WHERE_MASK);
346   }
347 
348   private void setType(Type type) {
349     value |= ((type.getValue() &lt;&lt; TYPE_SHIFT) &amp; TYPE_MASK);
350   }
351 
352   private void setOffset(int offset) {
353     value |= ((offset &lt;&lt; OFFSET_SHIFT) &amp; OFFSET_MASK);
354   }
355 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
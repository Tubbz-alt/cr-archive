diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/ui/AnnotatedMemoryPanel.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/ui/AnnotatedMemoryPanel.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/ui/AnnotatedMemoryPanel.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/ui/AnnotatedMemoryPanel.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -53,11 +53,11 @@
   private int paintCount;
   private String unmappedAddrString;
   // Type of this is an IntervalTree indexed by Interval<Address> and
   // with user data of type Annotation
   private IntervalTree annotations =
-    new IntervalTree(new Comparator() {
+    new IntervalTree(new Comparator<>() {
         public int compare(Object o1, Object o2) {
           Address a1 = (Address) o1;
           Address a2 = (Address) o2;
 
           if ((a1 == null) && (a2 == null)) {
@@ -80,11 +80,11 @@
   // can scroll annotations
   private Address lastStartAddr;
   // This contains the list of currently-visible IntervalNodes, in
   // sorted order by their low endpoint, in the form of a
   // List<Annotation>. These annotations have already been laid out.
-  private java.util.List visibleAnnotations;
+  private java.util.List<Annotation> visibleAnnotations;
   // Darker colors than defaults for better readability
   private static Color[] colors = {
     new Color(0.0f, 0.0f, 0.6f), // blue
     new Color(0.6f, 0.0f, 0.6f), // magenta
     new Color(0.0f, 0.8f, 0.0f), // green
@@ -199,11 +199,11 @@
     // Query for visible annotations (little slop to ensure we get the
     // top and bottom)
     // FIXME: it would be nice to have a more static layout; that is,
     // if something scrolls off the bottom of the screen, other
     // annotations still visible shouldn't change position
-    java.util.List va =
+    java.util.List<IntervalNode> va =
       annotations.findAllNodesIntersecting(new Interval(startAddr.addOffsetTo(-addressSize),
                                                         endAddr.addOffsetTo(2 * addressSize)));
 
     // Render them
     int curLineX = lineStartX;
@@ -212,16 +212,16 @@
     if (g instanceof Graphics2D) {
       Stroke stroke = new BasicStroke(3.0f);
       ((Graphics2D) g).setStroke(stroke);
     }
 
-    Stack drawStack = new Stack();
+    Stack<AnnoX> drawStack = new Stack<>();
 
     layoutAnnotations(va, g, curTextX, startAddr, lineHeight);
 
-    for (Iterator iter = visibleAnnotations.iterator(); iter.hasNext(); ) {
-      Annotation anno   = (Annotation) iter.next();
+    for (Iterator<Annotation> iter = visibleAnnotations.iterator(); iter.hasNext(); ) {
+      Annotation anno   = iter.next();
       Interval interval = anno.getInterval();
 
       if (!drawStack.empty()) {
         // See whether we can pop any items off the stack
         boolean shouldContinue = true;
@@ -291,11 +291,11 @@
       unmappedAddrString = "??????????";
     }
     setLayout(new BorderLayout());
     setupScrollBar(addrValue, addrLow, addrHigh);
     add(scrollBar, BorderLayout.EAST);
-    visibleAnnotations = new ArrayList();
+    visibleAnnotations = new ArrayList<>();
     setBackground(Color.white);
     addHierarchyBoundsListener(new HierarchyBoundsListener() {
         public void ancestorMoved(HierarchyEvent e) {
         }
 
@@ -436,21 +436,21 @@
     return a.toString();
   }
 
   /** Scrolls the visible annotations by the given Y amount */
   private void scrollAnnotations(int y) {
-    for (Iterator iter = visibleAnnotations.iterator(); iter.hasNext(); ) {
-      Annotation anno = (Annotation) iter.next();
+    for (Iterator<Annotation> iter = visibleAnnotations.iterator(); iter.hasNext(); ) {
+      Annotation anno = iter.next();
       anno.setY(anno.getY() + y);
     }
   }
 
   /** Takes the list of currently-visible annotations (in the form of
       a List<IntervalNode>) and lays them out given the current
       visible position and the already-visible annotations. Does not
       perturb the layouts of the currently-visible annotations. */
-  private void layoutAnnotations(java.util.List va,
+  private void layoutAnnotations(java.util.List<IntervalNode> va,
                                  Graphics g,
                                  int x,
                                  Address startAddr,
                                  int lineHeight) {
     // Handle degenerate case early: no visible annotations.
@@ -488,19 +488,19 @@
     Annotation firstConstraintAnnotation = null;
     // The index from which we search forward in the
     // visibleAnnotations list. This reduces the amount of work we do.
     int searchIndex = 0;
     // The new set of annotations
-    java.util.List newAnnos = new ArrayList();
+    java.util.List<Annotation> newAnnos = new ArrayList<>();
 
-    for (Iterator iter = va.iterator(); iter.hasNext(); ) {
+    for (Iterator<IntervalNode> iter = va.iterator(); iter.hasNext(); ) {
       Annotation anno = (Annotation) ((IntervalNode) iter.next()).getData();
 
       // Search forward for this one
       boolean found = false;
       for (int i = searchIndex; i < visibleAnnotations.size(); i++) {
-        Annotation el = (Annotation) visibleAnnotations.get(i);
+        Annotation el = visibleAnnotations.get(i);
         // See whether we can abort the search unsuccessfully because
         // we went forward too far
         if (el.getLowAddress().greaterThan(anno.getLowAddress())) {
           break;
         }

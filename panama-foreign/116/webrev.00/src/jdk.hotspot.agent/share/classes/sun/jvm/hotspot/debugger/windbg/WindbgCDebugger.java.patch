diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/windbg/WindbgCDebugger.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/windbg/WindbgCDebugger.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/windbg/WindbgCDebugger.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/windbg/WindbgCDebugger.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -42,25 +42,25 @@
 
   WindbgCDebugger(WindbgDebugger dbg) {
     this.dbg = dbg;
   }
 
-  public List getThreadList() throws DebuggerException {
+  public List<ThreadProxy> getThreadList() throws DebuggerException {
     return dbg.getThreadList();
   }
 
-  public List/*<LoadObject>*/ getLoadObjectList() throws DebuggerException{
+  public List<LoadObject> getLoadObjectList() throws DebuggerException{
     return dbg.getLoadObjectList();
   }
 
   public LoadObject loadObjectContainingPC(Address pc) throws DebuggerException {
     // FIXME: could keep sorted list of these to be able to do binary
     // searches, for better scalability
     if (pc == null) {
       return null;
     }
-    List objs = getLoadObjectList();
+    List<LoadObject> objs = getLoadObjectList();
     for (Iterator iter = objs.iterator(); iter.hasNext(); ) {
       LoadObject obj = (LoadObject) iter.next();
       if (AddressOps.lte(obj.getBase(), pc) && (pc.minus(obj.getBase()) < obj.getSize())) {
         return obj;
       }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/soql/JSJavaVM.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSJavaTypeArrayKlass.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSList.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/soql/JSJavaVM.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 37     private static final int FIELD_HEAP         = 4;
 38     private static final int FIELD_OS           = 5;
 39     private static final int FIELD_SYS_PROPS    = 6;
 40     private static final int FIELD_THREADS      = 7;
 41     private static final int FIELD_TYPE         = 8;
 42     private static final int FIELD_VERSION      = 9;
 43     private static final int FIELD_CLASS_PATH   = 10;
 44     private static final int FIELD_BOOT_CLASS_PATH  = 11;
 45     private static final int FIELD_USER_DIR     = 12;
 46     private static final int FIELD_UNDEFINED    = -1;
 47 
 48     public JSJavaVM(JSJavaFactory factory) {
 49         this.factory = factory;
 50         this.vm = VM.getVM();
 51     }
 52 
 53     public Object get(String name) {
 54         int fieldID = getFieldID(name);
 55         switch (fieldID) {
 56         case FIELD_ADDRESS_SIZE:
<span class="line-modified"> 57             return new Long(getVMBit());</span>
 58         case FIELD_BUILD_INFO:
 59             return vm.getVMInternalInfo();
 60         case FIELD_CPU:
 61             return vm.getCPU();
 62         case FIELD_FLAGS:
 63             return getFlags();
 64         case FIELD_HEAP:
 65             return getHeap();
 66         case FIELD_OS:
 67             return vm.getOS();
 68         case FIELD_SYS_PROPS:
 69             return getSysProps();
 70         case FIELD_THREADS:
 71             return getThreads();
 72         case FIELD_TYPE:
 73             return getType();
 74         case FIELD_VERSION:
 75             return vm.getVMRelease();
 76         case FIELD_CLASS_PATH:
 77             return getClassPath();
</pre>
<hr />
<pre>
102 
103     public void put(String name, Object value) {
104         if (getFieldID(name) == FIELD_UNDEFINED) {
105             super.put(name, value);
106         }
107     }
108 
109     public String toString() {
110         StringBuffer buf = new StringBuffer();
111         buf.append(&quot;Java Hotspot &quot;);
112         buf.append(getType());
113         buf.append(&#39; &#39;);
114         buf.append(getVMBit());
115         buf.append(&quot; bit VM (build &quot;);
116         buf.append(vm.getVMRelease());
117         buf.append(&quot;)&quot;);
118         return buf.toString();
119     }
120 
121     //-- Internals only below this point
<span class="line-modified">122     private static Map fields = new HashMap();</span>
123     private static void addField(String name, int fieldId) {
<span class="line-modified">124         fields.put(name, new Integer(fieldId));</span>
125     }
126 
127     private static int getFieldID(String name) {
128         Integer res = (Integer) fields.get(name);
129         return (res != null)? res.intValue() : FIELD_UNDEFINED;
130     }
131 
132     static {
133         addField(&quot;addressSize&quot;, FIELD_ADDRESS_SIZE);
134         addField(&quot;buildInfo&quot;, FIELD_BUILD_INFO);
135         addField(&quot;cpu&quot;, FIELD_CPU);
136         addField(&quot;flags&quot;, FIELD_FLAGS);
137         addField(&quot;heap&quot;, FIELD_HEAP);
138         addField(&quot;os&quot;, FIELD_OS);
139         addField(&quot;sysProps&quot;, FIELD_SYS_PROPS);
140         addField(&quot;threads&quot;, FIELD_THREADS);
141         addField(&quot;type&quot;, FIELD_TYPE);
142         addField(&quot;version&quot;, FIELD_VERSION);
143         addField(&quot;classPath&quot;, FIELD_CLASS_PATH);
144         addField(&quot;userDir&quot;, FIELD_USER_DIR);
145     }
146 
147     private long getVMBit() {
148         // address size in bits
149         return vm.getAddressSize() * 8;
150     }
151 
152     private synchronized JSMap getFlags() {
153         if (flagsCache == null) {
154             VM.Flag[] flags = vm.getCommandLineFlags();
<span class="line-modified">155             Map map = new HashMap();</span>
156             if (flags != null) {
157                 for (int f = 0; f &lt; flags.length; f++) {
158                     VM.Flag flag = flags[f];
159                     map.put(flag.getName(), flag.getValue());
160                 }
161             }
162             flagsCache = factory.newJSMap(map);
163         }
164         return flagsCache;
165     }
166 
167     private synchronized JSJavaHeap getHeap() {
168         if (heapCache == null) {
169             heapCache = factory.newJSJavaHeap();
170         }
171         return heapCache;
172     }
173 
174     private synchronized JSMap getSysProps() {
175         if (sysPropsCache == null) {
176             Properties props = vm.getSystemProperties();
<span class="line-modified">177             Map map = new HashMap();</span>
178             if (props != null) {
179                 Enumeration e = props.propertyNames();
180                 while (e.hasMoreElements()) {
181                     String key = (String) e.nextElement();
182                     map.put(key, props.getProperty(key));
183                 }
184             }
185             sysPropsCache = factory.newJSMap(map);
186         }
187         return sysPropsCache;
188     }
189 
190     private synchronized JSList getThreads() {
191         if (threadsCache == null) {
<span class="line-modified">192             List threadsList = new ArrayList(0);</span>
193             threadsCache = factory.newJSList(threadsList);
194             Threads threads = VM.getVM().getThreads();
195             for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
196                 JavaThread thread = threads.getJavaThreadAt(i);
197                 threadsList.add(thread);
198             }
199         }
200         return threadsCache;
201     }
202 
203     private String getType() {
204         if (vm.isClientCompiler()) {
205             return &quot;Client&quot;;
206         } else if (vm.isServerCompiler()) {
207             return &quot;Server&quot;;
208         } else {
209             return &quot;Core&quot;;
210         }
211     }
212 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 37     private static final int FIELD_HEAP         = 4;
 38     private static final int FIELD_OS           = 5;
 39     private static final int FIELD_SYS_PROPS    = 6;
 40     private static final int FIELD_THREADS      = 7;
 41     private static final int FIELD_TYPE         = 8;
 42     private static final int FIELD_VERSION      = 9;
 43     private static final int FIELD_CLASS_PATH   = 10;
 44     private static final int FIELD_BOOT_CLASS_PATH  = 11;
 45     private static final int FIELD_USER_DIR     = 12;
 46     private static final int FIELD_UNDEFINED    = -1;
 47 
 48     public JSJavaVM(JSJavaFactory factory) {
 49         this.factory = factory;
 50         this.vm = VM.getVM();
 51     }
 52 
 53     public Object get(String name) {
 54         int fieldID = getFieldID(name);
 55         switch (fieldID) {
 56         case FIELD_ADDRESS_SIZE:
<span class="line-modified"> 57             return getVMBit();</span>
 58         case FIELD_BUILD_INFO:
 59             return vm.getVMInternalInfo();
 60         case FIELD_CPU:
 61             return vm.getCPU();
 62         case FIELD_FLAGS:
 63             return getFlags();
 64         case FIELD_HEAP:
 65             return getHeap();
 66         case FIELD_OS:
 67             return vm.getOS();
 68         case FIELD_SYS_PROPS:
 69             return getSysProps();
 70         case FIELD_THREADS:
 71             return getThreads();
 72         case FIELD_TYPE:
 73             return getType();
 74         case FIELD_VERSION:
 75             return vm.getVMRelease();
 76         case FIELD_CLASS_PATH:
 77             return getClassPath();
</pre>
<hr />
<pre>
102 
103     public void put(String name, Object value) {
104         if (getFieldID(name) == FIELD_UNDEFINED) {
105             super.put(name, value);
106         }
107     }
108 
109     public String toString() {
110         StringBuffer buf = new StringBuffer();
111         buf.append(&quot;Java Hotspot &quot;);
112         buf.append(getType());
113         buf.append(&#39; &#39;);
114         buf.append(getVMBit());
115         buf.append(&quot; bit VM (build &quot;);
116         buf.append(vm.getVMRelease());
117         buf.append(&quot;)&quot;);
118         return buf.toString();
119     }
120 
121     //-- Internals only below this point
<span class="line-modified">122     private static Map&lt;String, Integer&gt; fields = new HashMap&lt;&gt;();</span>
123     private static void addField(String name, int fieldId) {
<span class="line-modified">124         fields.put(name, fieldId);</span>
125     }
126 
127     private static int getFieldID(String name) {
128         Integer res = (Integer) fields.get(name);
129         return (res != null)? res.intValue() : FIELD_UNDEFINED;
130     }
131 
132     static {
133         addField(&quot;addressSize&quot;, FIELD_ADDRESS_SIZE);
134         addField(&quot;buildInfo&quot;, FIELD_BUILD_INFO);
135         addField(&quot;cpu&quot;, FIELD_CPU);
136         addField(&quot;flags&quot;, FIELD_FLAGS);
137         addField(&quot;heap&quot;, FIELD_HEAP);
138         addField(&quot;os&quot;, FIELD_OS);
139         addField(&quot;sysProps&quot;, FIELD_SYS_PROPS);
140         addField(&quot;threads&quot;, FIELD_THREADS);
141         addField(&quot;type&quot;, FIELD_TYPE);
142         addField(&quot;version&quot;, FIELD_VERSION);
143         addField(&quot;classPath&quot;, FIELD_CLASS_PATH);
144         addField(&quot;userDir&quot;, FIELD_USER_DIR);
145     }
146 
147     private long getVMBit() {
148         // address size in bits
149         return vm.getAddressSize() * 8;
150     }
151 
152     private synchronized JSMap getFlags() {
153         if (flagsCache == null) {
154             VM.Flag[] flags = vm.getCommandLineFlags();
<span class="line-modified">155             Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>
156             if (flags != null) {
157                 for (int f = 0; f &lt; flags.length; f++) {
158                     VM.Flag flag = flags[f];
159                     map.put(flag.getName(), flag.getValue());
160                 }
161             }
162             flagsCache = factory.newJSMap(map);
163         }
164         return flagsCache;
165     }
166 
167     private synchronized JSJavaHeap getHeap() {
168         if (heapCache == null) {
169             heapCache = factory.newJSJavaHeap();
170         }
171         return heapCache;
172     }
173 
174     private synchronized JSMap getSysProps() {
175         if (sysPropsCache == null) {
176             Properties props = vm.getSystemProperties();
<span class="line-modified">177             Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>
178             if (props != null) {
179                 Enumeration e = props.propertyNames();
180                 while (e.hasMoreElements()) {
181                     String key = (String) e.nextElement();
182                     map.put(key, props.getProperty(key));
183                 }
184             }
185             sysPropsCache = factory.newJSMap(map);
186         }
187         return sysPropsCache;
188     }
189 
190     private synchronized JSList getThreads() {
191         if (threadsCache == null) {
<span class="line-modified">192             List&lt;JavaThread&gt; threadsList = new ArrayList&lt;&gt;(0);</span>
193             threadsCache = factory.newJSList(threadsList);
194             Threads threads = VM.getVM().getThreads();
195             for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
196                 JavaThread thread = threads.getJavaThreadAt(i);
197                 threadsList.add(thread);
198             }
199         }
200         return threadsCache;
201     }
202 
203     private String getType() {
204         if (vm.isClientCompiler()) {
205             return &quot;Client&quot;;
206         } else if (vm.isServerCompiler()) {
207             return &quot;Server&quot;;
208         } else {
209             return &quot;Core&quot;;
210         }
211     }
212 
</pre>
</td>
</tr>
</table>
<center><a href="JSJavaTypeArrayKlass.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSList.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
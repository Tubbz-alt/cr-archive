<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/ci/ciInstanceKlass.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.ci;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.memory.SystemDictionary;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.oops.*;
 33 import sun.jvm.hotspot.types.Type;
 34 import sun.jvm.hotspot.types.TypeDataBase;
 35 import sun.jvm.hotspot.types.WrongTypeException;
 36 import sun.jvm.hotspot.utilities.Observable;
 37 import sun.jvm.hotspot.utilities.Observer;
 38 
 39 public class ciInstanceKlass extends ciKlass {
 40   static {
 41     VM.registerVMInitializedObserver(new Observer() {
 42         public void update(Observable o, Object data) {
 43           initialize(VM.getVM().getTypeDataBase());
 44         }
 45       });
 46   }
 47 
 48   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
 49     Type type      = db.lookupType(&quot;ciInstanceKlass&quot;);
 50     initStateField = new CIntField(type.getCIntegerField(&quot;_init_state&quot;), 0);
 51     isSharedField = new CIntField(type.getCIntegerField(&quot;_is_shared&quot;), 0);
 52     CLASS_STATE_LINKED = db.lookupIntConstant(&quot;InstanceKlass::linked&quot;).intValue();
 53     CLASS_STATE_FULLY_INITIALIZED = db.lookupIntConstant(&quot;InstanceKlass::fully_initialized&quot;).intValue();
 54   }
 55 
 56   private static CIntField initStateField;
 57   private static CIntField isSharedField;
 58   private static int CLASS_STATE_LINKED;
 59   private static int CLASS_STATE_FULLY_INITIALIZED;
 60 
 61   public ciInstanceKlass(Address addr) {
 62     super(addr);
 63   }
 64 
 65   public int initState() {
 66     int initState = (int)initStateField.getValue(getAddress());
 67     if (isShared() &amp;&amp; initState &lt; CLASS_STATE_LINKED) {
 68       InstanceKlass ik = (InstanceKlass)getMetadata();
 69       initState = ik.getInitStateAsInt();
 70     }
 71     return initState;
 72   }
 73 
 74   public boolean isShared() {
 75     return isSharedField.getValue(getAddress()) != 0;
 76   }
 77 
 78   public boolean isLinked() {
 79     return initState() &gt;= CLASS_STATE_LINKED;
 80   }
 81 
 82   public boolean isInitialized() {
 83     return initState() == CLASS_STATE_FULLY_INITIALIZED;
 84   }
 85 
 86   public void dumpReplayData(PrintStream out) {
 87     InstanceKlass ik = (InstanceKlass)getMetadata();
 88     ConstantPool cp = ik.getConstants();
 89 
 90     // Try to record related loaded classes
 91     Klass sub = ik.getSubklassKlass();
 92     while (sub != null) {
 93       if (sub instanceof InstanceKlass) {
 94         out.println(&quot;instanceKlass &quot; + sub.getName().asString());
 95       }
 96       sub = sub.getNextSiblingKlass();
 97     }
 98 
 99     final int length = (int) cp.getLength();
100     out.print(&quot;ciInstanceKlass &quot; + name() + &quot; &quot; + (isLinked() ? 1 : 0) + &quot; &quot; + (isInitialized() ? 1 : 0) + &quot; &quot; + length);
101     for (int index = 1; index &lt; length; index++) {
102       out.print(&quot; &quot; + cp.getTags().at(index));
103     }
104     out.println();
105     if (isInitialized()) {
106       Field[] staticFields = ik.getStaticFields();
107       for (int i = 0; i &lt; staticFields.length; i++) {
108         Field f = staticFields[i];
109         Oop mirror = ik.getJavaMirror();
110         if (f.isFinal() &amp;&amp; !f.hasInitialValue()) {
111           out.print(&quot;staticfield &quot; + name() + &quot; &quot; +
112                     OopUtilities.escapeString(f.getID().getName()) + &quot; &quot; +
113                     f.getFieldType().getSignature().asString() + &quot; &quot;);
114           if (f instanceof ByteField) {
115             ByteField bf = (ByteField)f;
116             out.println(bf.getValue(mirror));
117           } else if (f instanceof BooleanField) {
118             BooleanField bf = (BooleanField)f;
119             out.println(bf.getValue(mirror) ? 1 : 0);
120           } else if (f instanceof ShortField) {
121             ShortField bf = (ShortField)f;
122             out.println(bf.getValue(mirror));
123           } else if (f instanceof CharField) {
124             CharField bf = (CharField)f;
125             out.println(bf.getValue(mirror) &amp; 0xffff);
126           } else if (f instanceof IntField) {
127             IntField bf = (IntField)f;
128             out.println(bf.getValue(mirror));
129           } else  if (f instanceof LongField) {
130             LongField bf = (LongField)f;
131             out.println(bf.getValue(mirror));
132           } else if (f instanceof FloatField) {
133             FloatField bf = (FloatField)f;
134             out.println(Float.floatToRawIntBits(bf.getValue(mirror)));
135           } else if (f instanceof DoubleField) {
136             DoubleField bf = (DoubleField)f;
137             out.println(Double.doubleToRawLongBits(bf.getValue(mirror)));
138           } else if (f instanceof OopField) {
139             OopField bf = (OopField)f;
140             Oop value = bf.getValue(mirror);
141             if (value == null) {
142               out.println(&quot;null&quot;);
143             } else if (value.isInstance()) {
144               Instance inst = (Instance)value;
145               if (inst.isA(SystemDictionary.getStringKlass())) {
146                 out.println(&quot;\&quot;&quot; + OopUtilities.stringOopToEscapedString(inst) + &quot;\&quot;&quot;);
147               } else {
148                 out.println(inst.getKlass().getName().asString());
149               }
150             } else if (value.isObjArray()) {
151               ObjArray oa = (ObjArray)value;
152               Klass ek = (ObjArrayKlass)oa.getKlass();
153               out.println(oa.getLength() + &quot; &quot; + ek.getName().asString());
154             } else if (value.isTypeArray()) {
155               TypeArray ta = (TypeArray)value;
156               out.println(ta.getLength());
157             } else {
158               out.println(value);
159             }
160           }
161         }
162       }
163     }
164   }
165 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/soql/JSJavaFrame.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSJavaField.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSJavaHeap.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/soql/JSJavaFrame.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 32 public class JSJavaFrame extends DefaultScriptObject {
 33     private static final int FIELD_METHOD      = 0;
 34     private static final int FIELD_BCI         = 1;
 35     private static final int FIELD_LINE_NUMBER = 2;
 36     private static final int FIELD_LOCALS      = 3;
 37     private static final int FIELD_THIS_OBJECT = 4;
 38     private static final int FIELD_THREAD      = 5;
 39     private static final int FIELD_UNDEFINED   = -1;
 40 
 41     public JSJavaFrame(JavaVFrame jvf, JSJavaFactory fac) {
 42         this.jvf = jvf;
 43         this.factory = fac;
 44     }
 45 
 46     public Object get(String name) {
 47         int fieldID = getFieldID(name);
 48         switch (fieldID) {
 49         case FIELD_METHOD:
 50             return getMethod();
 51         case FIELD_BCI:
<span class="line-modified"> 52             return new Integer(getBCI());</span>
 53         case FIELD_LINE_NUMBER:
<span class="line-modified"> 54             return new Integer(getLineNumber());</span>
 55         case FIELD_LOCALS:
 56             return getLocals();
 57         case FIELD_THIS_OBJECT:
 58             return getThisObject();
 59         case FIELD_THREAD:
 60             return getThread();
 61         case FIELD_UNDEFINED:
 62         default:
 63             return super.get(name);
 64         }
 65     }
 66 
 67     public Object[] getIds() {
 68        Object[] fieldNames = fields.keySet().toArray();
 69        Object[] superFields = super.getIds();
 70        Object[] res = new Object[fieldNames.length + superFields.length];
 71        System.arraycopy(fieldNames, 0, res, 0, fieldNames.length);
 72        System.arraycopy(superFields, 0, res, fieldNames.length, superFields.length);
 73        return res;
 74    }
</pre>
<hr />
<pre>
 83 
 84     public void put(String name, Object value) {
 85         if (getFieldID(name) == FIELD_UNDEFINED) {
 86             super.put(name, value);
 87         }
 88     }
 89 
 90     public String toString() {
 91         StringBuffer buf = new StringBuffer();
 92         buf.append(&quot;Frame (method=&quot;);
 93         buf.append(jvf.getMethod().externalNameAndSignature());
 94         buf.append(&quot;, bci=&quot;);
 95         buf.append(getBCI());
 96         buf.append(&quot;, line=&quot;);
 97         buf.append(getLineNumber());
 98         buf.append(&#39;)&#39;);
 99         return buf.toString();
100     }
101 
102     //-- Internals only below this point
<span class="line-modified">103     private static Map fields = new HashMap();</span>
104     private static void addField(String name, int fieldId) {
<span class="line-modified">105         fields.put(name, new Integer(fieldId));</span>
106     }
107 
108     private static int getFieldID(String name) {
109         Integer res = (Integer) fields.get(name);
110         return (res != null)? res.intValue() : FIELD_UNDEFINED;
111     }
112 
113     static {
114         addField(&quot;method&quot;, FIELD_METHOD);
115         addField(&quot;bci&quot;, FIELD_BCI);
116         addField(&quot;line&quot;, FIELD_LINE_NUMBER);
117         addField(&quot;locals&quot;, FIELD_LOCALS);
118         addField(&quot;thisObject&quot;, FIELD_THIS_OBJECT);
119         addField(&quot;thread&quot;, FIELD_THREAD);
120     }
121 
122     private JSJavaMethod getMethod() {
123         return factory.newJSJavaMethod(jvf.getMethod());
124     }
125 
126     private int getBCI() {
127         return jvf.getBCI();
128     }
129 
130     private int getLineNumber() {
131         int bci = jvf.getBCI();
132         if (bci == -1) {
133             return 0;
134         } else {
135             int lineNum = jvf.getMethod().getLineNumberFromBCI(bci);
136             return (lineNum &lt;= 0)? 0 : lineNum;
137         }
138     }
139 
140     private synchronized JSMap getLocals() {
141         if (localsCache == null) {
<span class="line-modified">142             Map map = new HashMap();</span>
143             localsCache = factory.newJSMap(map);
144             StackValueCollection values = jvf.getLocals();
145             Method method = jvf.getMethod();
146             if (method.isNative() || ! method.hasLocalVariableTable() ||
147                 values == null) {
148                 return localsCache;
149             }
150 
151             LocalVariableTableElement[] localVars = method.getLocalVariableTable();
152             int bci = getBCI();
<span class="line-modified">153             List visibleVars = new ArrayList(0);</span>
154             for (int i = 0; i &lt; localVars.length; i++) {
155                 LocalVariableTableElement cur = localVars[i];
156                 int startBCI = cur.getStartBCI();
157                 if (startBCI &lt;= bci &amp;&amp; bci &lt; startBCI + cur.getLength()) {
158                     visibleVars.add(cur);
159                 }
160             }
161 
162             OopHandle handle = null;
163             ObjectHeap heap = VM.getVM().getObjectHeap();
164             for (Iterator varItr = visibleVars.iterator(); varItr.hasNext();) {
165                 LocalVariableTableElement cur = (LocalVariableTableElement) varItr.next();
166                 String name =  method.getConstants().getSymbolAt(cur.getNameCPIndex()).asString();
167                 int slot = cur.getSlot();
168 
169                 String signature = method.getConstants().getSymbolAt(cur.getDescriptorCPIndex()).asString();
170                 BasicType variableType = BasicType.charToBasicType(signature.charAt(0));
171                 Object value = null;
172                 if (variableType == BasicType.T_BOOLEAN) {
<span class="line-modified">173                     value = Boolean.valueOf(values.booleanAt(slot));</span>
174                 } else if (variableType == BasicType.T_CHAR) {
<span class="line-modified">175                     value = new Character(values.charAt(slot));</span>
176                 } else if (variableType == BasicType.T_FLOAT) {
<span class="line-modified">177                     value = new Float(values.floatAt(slot));</span>
178                 } else if (variableType == BasicType.T_DOUBLE) {
<span class="line-modified">179                     value = new Double(values.doubleAt(slot));</span>
180                 } else if (variableType == BasicType.T_BYTE) {
<span class="line-modified">181                     value = new Byte(values.byteAt(slot));</span>
182                 } else if (variableType == BasicType.T_SHORT) {
<span class="line-modified">183                     value = new Short(values.shortAt(slot));</span>
184                 } else if (variableType == BasicType.T_INT) {
<span class="line-modified">185                     value = new Integer(values.intAt(slot));</span>
186                 } else if (variableType == BasicType.T_LONG) {
<span class="line-modified">187                     value = new Long(values.longAt(slot));</span>
188                 } else if (variableType == BasicType.T_OBJECT ||
189                        variableType == BasicType.T_ARRAY) {
190                     handle = values.oopHandleAt(slot);
191                     value = factory.newJSJavaObject(heap.newOop(handle));
192                 } else {
193                     // ignore
194                 }
195                 map.put(name, value);
196             }
197         }
198         return localsCache;
199     }
200 
201     private JSJavaObject getThisObject() {
202         Method method = jvf.getMethod();
203         if (method.isStatic()) {
204             return null;
205         }
206         StackValueCollection values = jvf.getLocals();
207         if (values != null) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 32 public class JSJavaFrame extends DefaultScriptObject {
 33     private static final int FIELD_METHOD      = 0;
 34     private static final int FIELD_BCI         = 1;
 35     private static final int FIELD_LINE_NUMBER = 2;
 36     private static final int FIELD_LOCALS      = 3;
 37     private static final int FIELD_THIS_OBJECT = 4;
 38     private static final int FIELD_THREAD      = 5;
 39     private static final int FIELD_UNDEFINED   = -1;
 40 
 41     public JSJavaFrame(JavaVFrame jvf, JSJavaFactory fac) {
 42         this.jvf = jvf;
 43         this.factory = fac;
 44     }
 45 
 46     public Object get(String name) {
 47         int fieldID = getFieldID(name);
 48         switch (fieldID) {
 49         case FIELD_METHOD:
 50             return getMethod();
 51         case FIELD_BCI:
<span class="line-modified"> 52             return getBCI();</span>
 53         case FIELD_LINE_NUMBER:
<span class="line-modified"> 54             return getLineNumber();</span>
 55         case FIELD_LOCALS:
 56             return getLocals();
 57         case FIELD_THIS_OBJECT:
 58             return getThisObject();
 59         case FIELD_THREAD:
 60             return getThread();
 61         case FIELD_UNDEFINED:
 62         default:
 63             return super.get(name);
 64         }
 65     }
 66 
 67     public Object[] getIds() {
 68        Object[] fieldNames = fields.keySet().toArray();
 69        Object[] superFields = super.getIds();
 70        Object[] res = new Object[fieldNames.length + superFields.length];
 71        System.arraycopy(fieldNames, 0, res, 0, fieldNames.length);
 72        System.arraycopy(superFields, 0, res, fieldNames.length, superFields.length);
 73        return res;
 74    }
</pre>
<hr />
<pre>
 83 
 84     public void put(String name, Object value) {
 85         if (getFieldID(name) == FIELD_UNDEFINED) {
 86             super.put(name, value);
 87         }
 88     }
 89 
 90     public String toString() {
 91         StringBuffer buf = new StringBuffer();
 92         buf.append(&quot;Frame (method=&quot;);
 93         buf.append(jvf.getMethod().externalNameAndSignature());
 94         buf.append(&quot;, bci=&quot;);
 95         buf.append(getBCI());
 96         buf.append(&quot;, line=&quot;);
 97         buf.append(getLineNumber());
 98         buf.append(&#39;)&#39;);
 99         return buf.toString();
100     }
101 
102     //-- Internals only below this point
<span class="line-modified">103     private static Map&lt;String, Integer&gt; fields = new HashMap&lt;&gt;();</span>
104     private static void addField(String name, int fieldId) {
<span class="line-modified">105         fields.put(name, fieldId);</span>
106     }
107 
108     private static int getFieldID(String name) {
109         Integer res = (Integer) fields.get(name);
110         return (res != null)? res.intValue() : FIELD_UNDEFINED;
111     }
112 
113     static {
114         addField(&quot;method&quot;, FIELD_METHOD);
115         addField(&quot;bci&quot;, FIELD_BCI);
116         addField(&quot;line&quot;, FIELD_LINE_NUMBER);
117         addField(&quot;locals&quot;, FIELD_LOCALS);
118         addField(&quot;thisObject&quot;, FIELD_THIS_OBJECT);
119         addField(&quot;thread&quot;, FIELD_THREAD);
120     }
121 
122     private JSJavaMethod getMethod() {
123         return factory.newJSJavaMethod(jvf.getMethod());
124     }
125 
126     private int getBCI() {
127         return jvf.getBCI();
128     }
129 
130     private int getLineNumber() {
131         int bci = jvf.getBCI();
132         if (bci == -1) {
133             return 0;
134         } else {
135             int lineNum = jvf.getMethod().getLineNumberFromBCI(bci);
136             return (lineNum &lt;= 0)? 0 : lineNum;
137         }
138     }
139 
140     private synchronized JSMap getLocals() {
141         if (localsCache == null) {
<span class="line-modified">142             Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span>
143             localsCache = factory.newJSMap(map);
144             StackValueCollection values = jvf.getLocals();
145             Method method = jvf.getMethod();
146             if (method.isNative() || ! method.hasLocalVariableTable() ||
147                 values == null) {
148                 return localsCache;
149             }
150 
151             LocalVariableTableElement[] localVars = method.getLocalVariableTable();
152             int bci = getBCI();
<span class="line-modified">153             List&lt;LocalVariableTableElement&gt; visibleVars = new ArrayList&lt;&gt;(0);</span>
154             for (int i = 0; i &lt; localVars.length; i++) {
155                 LocalVariableTableElement cur = localVars[i];
156                 int startBCI = cur.getStartBCI();
157                 if (startBCI &lt;= bci &amp;&amp; bci &lt; startBCI + cur.getLength()) {
158                     visibleVars.add(cur);
159                 }
160             }
161 
162             OopHandle handle = null;
163             ObjectHeap heap = VM.getVM().getObjectHeap();
164             for (Iterator varItr = visibleVars.iterator(); varItr.hasNext();) {
165                 LocalVariableTableElement cur = (LocalVariableTableElement) varItr.next();
166                 String name =  method.getConstants().getSymbolAt(cur.getNameCPIndex()).asString();
167                 int slot = cur.getSlot();
168 
169                 String signature = method.getConstants().getSymbolAt(cur.getDescriptorCPIndex()).asString();
170                 BasicType variableType = BasicType.charToBasicType(signature.charAt(0));
171                 Object value = null;
172                 if (variableType == BasicType.T_BOOLEAN) {
<span class="line-modified">173                     value = values.booleanAt(slot);</span>
174                 } else if (variableType == BasicType.T_CHAR) {
<span class="line-modified">175                     value = values.charAt(slot);</span>
176                 } else if (variableType == BasicType.T_FLOAT) {
<span class="line-modified">177                     value = values.floatAt(slot);</span>
178                 } else if (variableType == BasicType.T_DOUBLE) {
<span class="line-modified">179                     value = values.doubleAt(slot);</span>
180                 } else if (variableType == BasicType.T_BYTE) {
<span class="line-modified">181                     value = values.byteAt(slot);</span>
182                 } else if (variableType == BasicType.T_SHORT) {
<span class="line-modified">183                     value = values.shortAt(slot);</span>
184                 } else if (variableType == BasicType.T_INT) {
<span class="line-modified">185                     value = values.intAt(slot);</span>
186                 } else if (variableType == BasicType.T_LONG) {
<span class="line-modified">187                     value = values.longAt(slot);</span>
188                 } else if (variableType == BasicType.T_OBJECT ||
189                        variableType == BasicType.T_ARRAY) {
190                     handle = values.oopHandleAt(slot);
191                     value = factory.newJSJavaObject(heap.newOop(handle));
192                 } else {
193                     // ignore
194                 }
195                 map.put(name, value);
196             }
197         }
198         return localsCache;
199     }
200 
201     private JSJavaObject getThisObject() {
202         Method method = jvf.getMethod();
203         if (method.isStatic()) {
204             return null;
205         }
206         StackValueCollection values = jvf.getLocals();
207         if (values != null) {
</pre>
</td>
</tr>
</table>
<center><a href="JSJavaField.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSJavaHeap.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
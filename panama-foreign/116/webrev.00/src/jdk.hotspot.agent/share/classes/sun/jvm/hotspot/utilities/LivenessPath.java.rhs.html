<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/LivenessPath.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.utilities;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.oops.*;
 30 
 31 /** Describes a path from an object back to the root which is keeping
 32     it alive. Elements of the path are (object, field) pairs, where
 33     the object is expressed as a @link{sun.jvm.hotspot.oops.Oop}, and
 34     where the field is expressed as a
 35     @link{sun.jvm.hotspot.oops.FieldIdentifier}. If the element
 36     reflects a root, the Oop will be null. If the element is the end
 37     of the path, the FieldIdentifier will be null. */
 38 
 39 public class LivenessPath {
 40   LivenessPath() {
<a name="2" id="anc2"></a><span class="line-modified"> 41     stack = new Stack&lt;&gt;();</span>
 42   }
 43 
 44   /** Number of elements in the path */
 45   public int size() {
 46     return stack.size();
 47   }
 48 
 49   /** Fetch the element at the given index; 0-based */
 50   public LivenessPathElement get(int index) throws ArrayIndexOutOfBoundsException {
 51     return (LivenessPathElement) stack.get(index);
 52   }
 53 
 54   public void printOn(PrintStream tty) {
 55     for (int j = 0; j &lt; size(); j++) {
 56       LivenessPathElement el = get(j);
 57       tty.print(&quot;  - &quot;);
 58       if (el.getObj() != null) {
 59         Oop.printOopValueOn(el.getObj(), tty);
 60       }
 61       if (el.getField() != null) {
 62         if (el.getObj() != null) {
 63           tty.print(&quot;, field &quot;);
 64         }
 65         tty.print(el.getField().getName());
 66       }
 67       tty.println();
 68     }
 69   }
 70 
 71   /** Indicates whether this path is &quot;complete&quot;, i.e., whether the
 72       last element is a root. Convenience routine for LivenessAnalysis. */
 73   boolean isComplete() {
 74     if (size() == 0)
 75       return false;
 76     return peek().isRoot();
 77   }
 78 
 79   // Convenience routine for LivenessAnalysis
 80   LivenessPathElement peek() {
 81     return (LivenessPathElement) stack.peek();
 82   }
 83 
 84   // Convenience routine for LivenessAnalysis
 85   void push(LivenessPathElement el) {
 86     stack.push(el);
 87   }
 88 
 89   // Convenience routine for LivenessAnalysis
 90   void pop() {
 91     stack.pop();
 92   }
 93 
 94   // Make a copy of the contents of the path -- the
 95   // LivenessPathElements are not duplicated, only the containing path
 96   LivenessPath copy() {
 97     LivenessPath dup = new LivenessPath();
 98     for (int i = 0; i &lt; stack.size(); i++) {
 99       dup.stack.push(stack.get(i));
100     }
101     return dup;
102   }
103 
104   //---------------------------------------------------------------------------
105   // Internals only below this point
106   //
<a name="3" id="anc3"></a><span class="line-modified">107   private Stack&lt;LivenessPathElement&gt; stack;</span>
108 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/soql/JSJavaInstanceKlass.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/soql/JSJavaInstanceKlass.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/soql/JSJavaInstanceKlass.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/soql/JSJavaInstanceKlass.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -50,12 +50,12 @@
    private static final int FIELD_STATICS            = 18;
    private static final int FIELD_UNDEFINED          = -1;
 
    public JSJavaInstanceKlass(InstanceKlass kls, JSJavaFactory fac) {
       super(kls, fac);
-      this.instanceFields = new HashMap();
-      this.staticFields = new HashMap();
+      this.instanceFields = new HashMap<>();
+      this.staticFields = new HashMap<>();
    }
 
    public final InstanceKlass getInstanceKlass() {
       return (InstanceKlass) getKlass();
    }
@@ -157,13 +157,13 @@
 
    public String[] getInstanceFieldNames() {
       if (instanceFieldNames == null) {
          InstanceKlass current = getInstanceKlass();
          while (current != null) {
-            List tmp = current.getImmediateFields();
-            for (Iterator itr = tmp.iterator(); itr.hasNext();) {
-               Field fld = (Field) itr.next();
+            List<Field> tmp = current.getImmediateFields();
+            for (Iterator<Field> itr = tmp.iterator(); itr.hasNext();) {
+               Field fld = itr.next();
                if (!fld.isStatic()) {
                   String name = fld.getID().getName();
                   if (instanceFields.get(name) == null) {
                      instanceFields.put(name, fld);
                   }
@@ -188,13 +188,13 @@
    }
 
    public String[] getStaticFieldNames() {
       if (staticFieldNames == null) {
          InstanceKlass current = getInstanceKlass();
-         List tmp = current.getImmediateFields();
-         for (Iterator itr = tmp.iterator(); itr.hasNext();) {
-            Field fld = (Field) itr.next();
+         List<Field> tmp = current.getImmediateFields();
+         for (Iterator<Field> itr = tmp.iterator(); itr.hasNext();) {
+            Field fld = itr.next();
             if (fld.isStatic()) {
                staticFields.put(fld.getID().getName(), fld);
             }
          }
 
@@ -212,13 +212,13 @@
       Field fld = findStaticField(name);
       return (fld != null)? true: false;
    }
 
    //-- Intenals only below this point
-   private static Map fields = new HashMap();
+   private static Map<String, Integer> fields = new HashMap<>();
    private static void addField(String name, int fieldId) {
-      fields.put(name, new Integer(fieldId));
+      fields.put(name, fieldId);
    }
 
    private static int getFieldID(String name) {
       Integer res = (Integer) fields.get(name);
       return (res != null)? res.intValue() : FIELD_UNDEFINED;
@@ -253,25 +253,25 @@
    private Object getFieldValue(Field fld, String name, Oop oop) {
        FieldType fd = fld.getFieldType();
        if (fd.isObject() || fd.isArray()) {
          return factory.newJSJavaObject(((OopField)fld).getValue(oop));
        } else if (fd.isByte()) {
-          return new Byte(((ByteField)fld).getValue(oop));
+          return ((ByteField) fld).getValue(oop);
        } else if (fd.isChar()) {
           return new String(new char[] { ((CharField)fld).getValue(oop) });
        } else if (fd.isDouble()) {
-          return new Double(((DoubleField)fld).getValue(oop));
+          return ((DoubleField) fld).getValue(oop);
        } else if (fd.isFloat()) {
-          return new Float(((FloatField)fld).getValue(oop));
+          return ((FloatField) fld).getValue(oop);
        } else if (fd.isInt()) {
-          return new Integer(((IntField)fld).getValue(oop));
+          return ((IntField) fld).getValue(oop);
        } else if (fd.isLong()) {
-          return new Long(((LongField)fld).getValue(oop));
+          return ((LongField) fld).getValue(oop);
        } else if (fd.isShort()) {
-          return new Short(((ShortField)fld).getValue(oop));
+          return ((ShortField) fld).getValue(oop);
        } else if (fd.isBoolean()) {
-          return Boolean.valueOf(((BooleanField)fld).getValue(oop));
+          return ((BooleanField) fld).getValue(oop);
        } else {
           if (Assert.ASSERTS_ENABLED) {
              Assert.that(false, "invalid field type for " + name);
           }
           return null;
@@ -281,25 +281,25 @@
    private Object getFieldValue(Field fld, String name, InstanceKlass oop) {
        FieldType fd = fld.getFieldType();
        if (fd.isObject() || fd.isArray()) {
          return factory.newJSJavaObject(((OopField)fld).getValue(oop));
        } else if (fd.isByte()) {
-          return new Byte(((ByteField)fld).getValue(oop));
+          return ((ByteField) fld).getValue(oop);
        } else if (fd.isChar()) {
           return new String(new char[] { ((CharField)fld).getValue(oop) });
        } else if (fd.isDouble()) {
-          return new Double(((DoubleField)fld).getValue(oop));
+          return ((DoubleField) fld).getValue(oop);
        } else if (fd.isFloat()) {
-          return new Float(((FloatField)fld).getValue(oop));
+          return ((FloatField) fld).getValue(oop);
        } else if (fd.isInt()) {
-          return new Integer(((IntField)fld).getValue(oop));
+          return ((IntField) fld).getValue(oop);
        } else if (fd.isLong()) {
-          return new Long(((LongField)fld).getValue(oop));
+          return ((LongField) fld).getValue(oop);
        } else if (fd.isShort()) {
-          return new Short(((ShortField)fld).getValue(oop));
+          return ((ShortField) fld).getValue(oop);
        } else if (fd.isBoolean()) {
-          return Boolean.valueOf(((BooleanField)fld).getValue(oop));
+          return ((BooleanField) fld).getValue(oop);
        } else {
           if (Assert.ASSERTS_ENABLED) {
              Assert.that(false, "invalid field type for " + name);
           }
           return null;
@@ -311,13 +311,13 @@
       if (fld != null) {
          return fld;
       } else {
          InstanceKlass current = getInstanceKlass();
          while (current != null) {
-            List tmp = current.getImmediateFields();
-            for (Iterator itr = tmp.iterator(); itr.hasNext();) {
-               fld = (Field) itr.next();
+            List<Field> tmp = current.getImmediateFields();
+            for (Iterator<Field> itr = tmp.iterator(); itr.hasNext();) {
+               fld = itr.next();
                if (fld.getID().getName().equals(name) && !fld.isStatic()) {
                    instanceFields.put(name, fld);
                    return fld;
                }
             }
@@ -336,13 +336,13 @@
       } else {
          // static fields are searched only in current.
          // Direct/indirect super classes and interfaces
          // are not included in search.
          InstanceKlass current = getInstanceKlass();
-         List tmp = current.getImmediateFields();
-         for (Iterator itr = tmp.iterator(); itr.hasNext();) {
-            fld = (Field) itr.next();
+         List<Field> tmp = current.getImmediateFields();
+         for (Iterator<Field> itr = tmp.iterator(); itr.hasNext();) {
+            fld = itr.next();
             if (fld.getID().getName().equals(name) && fld.isStatic()) {
                staticFields.put(name, fld);
                return fld;
             }
          }
@@ -351,31 +351,31 @@
       }
    }
 
    private JSList getInterfaces() {
       InstanceKlass ik = getInstanceKlass();
-      List intfs = ik.getDirectImplementedInterfaces();
-      List res = new ArrayList(0);
-      for (Iterator itr = intfs.iterator(); itr.hasNext();) {
-          Klass k = (Klass) itr.next();
+      List<Klass> intfs = ik.getDirectImplementedInterfaces();
+      List<Instance> res = new ArrayList<>(0);
+      for (Iterator<Klass> itr = intfs.iterator(); itr.hasNext();) {
+          Klass k = itr.next();
           res.add(k.getJavaMirror());
       }
       return factory.newJSList(res);
    }
 
    private JSMap getStatics() {
       String[] names = getStaticFieldNames();
-      Map map = new HashMap();
+      Map<String, Object> map = new HashMap<>();
       for (int i=0; i < names.length; i++) {
          try {
             map.put(names[i], getStaticFieldValue(names[i]));
          } catch (NoSuchFieldException exp) {}
       }
       return factory.newJSMap(map);
   }
 
-   private Map           instanceFields;
-   private Map           staticFields;
+   private Map<String, Field> instanceFields;
+   private Map<String, Field> staticFields;
    private String[]      instanceFieldNames;
    private String[]      staticFieldNames;
    private AccessFlags   accFlags;
 }

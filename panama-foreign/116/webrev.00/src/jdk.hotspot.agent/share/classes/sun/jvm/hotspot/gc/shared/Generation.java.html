<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/gc/shared/Generation.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.gc.shared;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.memory.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.types.*;
 33 import sun.jvm.hotspot.utilities.Observable;
 34 import sun.jvm.hotspot.utilities.Observer;
 35 
 36 /** &lt;P&gt; The (supported) Generation hierarchy currently looks like this: &lt;/P&gt;
 37 
 38     &lt;ul&gt;
 39     &lt;li&gt; Generation
 40       &lt;ul&gt;
 41       &lt;li&gt; CardGeneration
 42         &lt;ul&gt;
 43         &lt;li&gt; TenuredGeneration
 44         &lt;/ul&gt;
 45       &lt;li&gt; DefNewGeneration
 46       &lt;/ul&gt;
 47     &lt;/ul&gt;
 48 */
 49 
 50 
 51 public abstract class Generation extends VMObject {
 52   private static long          reservedFieldOffset;
 53   private static long          virtualSpaceFieldOffset;
 54   protected static final int  K = 1024;
 55   // Fields for class StatRecord
 56   private static Field         statRecordField;
 57   private static CIntegerField invocationField;
 58 
 59   // constants from Name enum
 60   private static int NAME_DEF_NEW;
 61   private static int NAME_PAR_NEW;
 62   private static int NAME_MARK_SWEEP_COMPACT;
 63   private static int NAME_CONCURRENT_MARK_SWEEP;
 64   private static int NAME_OTHER;
 65 
 66   static {
 67     VM.registerVMInitializedObserver(new Observer() {
 68         public void update(Observable o, Object data) {
 69           initialize(VM.getVM().getTypeDataBase());
 70         }
 71       });
 72   }
 73 
 74   private static synchronized void initialize(TypeDataBase db) {
 75     Type type = db.lookupType(&quot;Generation&quot;);
 76 
 77     reservedFieldOffset     = type.getField(&quot;_reserved&quot;).getOffset();
 78     virtualSpaceFieldOffset = type.getField(&quot;_virtual_space&quot;).getOffset();
 79     // StatRecord
 80     statRecordField         = type.getField(&quot;_stat_record&quot;);
 81     type                    = db.lookupType(&quot;Generation::StatRecord&quot;);
 82     invocationField         = type.getCIntegerField(&quot;invocations&quot;);
 83 
 84     // constants from Generation::Name
 85     NAME_DEF_NEW = db.lookupIntConstant(&quot;Generation::DefNew&quot;).intValue();
 86     NAME_MARK_SWEEP_COMPACT = db.lookupIntConstant(&quot;Generation::MarkSweepCompact&quot;).intValue();
 87     NAME_OTHER = db.lookupIntConstant(&quot;Generation::Other&quot;).intValue();
 88   }
 89 
 90   public Generation(Address addr) {
 91     super(addr);
 92   }
 93 
 94   public static class Name {
 95     public static final Name DEF_NEW = new Name(&quot;DefNew&quot;);
 96     public static final Name MARK_SWEEP_COMPACT = new Name(&quot;MarkSweepCompact&quot;);
 97     public static final Name OTHER = new Name(&quot;Other&quot;);
 98 
 99     private Name(String value) {
100       this.value = value;
101     }
102 
103     private String value;
104     public String toString() {
105       return value;
106     }
107   }
108 
109   public Generation.Name kind() {
110     return Generation.Name.OTHER;
111   }
112 
113   static Generation.Name nameForEnum(int value) {
114      if (value == NAME_DEF_NEW) {
115         return Name.DEF_NEW;
116      } else if (value == NAME_MARK_SWEEP_COMPACT) {
117         return Name.MARK_SWEEP_COMPACT;
118      } else if (value == NAME_OTHER) {
119         return Name.OTHER;
120      } else {
121         throw new RuntimeException(&quot;should not reach here&quot;);
122      }
123   }
124 
125   public int invocations() {
126     return getStatRecord().getInvocations();
127   }
128 
129   /** The maximum number of object bytes the generation can currently
130       hold. */
131   public abstract long capacity();
132 
133   /** The number of used bytes in the gen. */
134   public abstract long used();
135 
136   /** The number of free bytes in the gen. */
137   public abstract long free();
138 
139   /** The largest number of contiguous free words in the generation,
140       including expansion. (VM&#39;s version assumes it is called at a
141       safepoint.)  */
142   public abstract long contiguousAvailable();
143 
144   public MemRegion reserved() {
145     return new MemRegion(addr.addOffsetTo(reservedFieldOffset));
146   }
147 
148   /** Returns a region guaranteed to contain all the objects in the
149       generation. */
150   public MemRegion usedRegion() {
151     return reserved();
152   }
153 
154   /* Returns &quot;TRUE&quot; iff &quot;p&quot; points into an allocated object in the
155      generation. */
156   public boolean isIn(Address p) {
157     GenerationIsInClosure blk = new GenerationIsInClosure(p);
158     spaceIterate(blk);
159     return (blk.space() != null);
160   }
161 
162   /** Returns &quot;TRUE&quot; iff &quot;p&quot; points into the reserved area of the
163      generation. */
164   public boolean isInReserved(Address p) {
165     return reserved().contains(p);
166   }
167 
168   protected VirtualSpace virtualSpace() {
169     return (VirtualSpace) VMObjectFactory.newObject(VirtualSpace.class, addr.addOffsetTo(virtualSpaceFieldOffset));
170   }
171 
172   public abstract String name();
173 
174   /** Equivalent to spaceIterate(blk, false) */
175   public void spaceIterate(SpaceClosure blk) {
176     spaceIterate(blk, false);
177   }
178 
179   /** Iteration - do not use for time critical operations */
180   public abstract void spaceIterate(SpaceClosure blk, boolean usedOnly);
181   public abstract void liveRegionsIterate(LiveRegionsClosure closure);
182 
183   public void print() { printOn(System.out); }
184   public abstract void printOn(PrintStream tty);
185 
186   public static class StatRecord extends VMObject {
187     public StatRecord(Address addr) {
188       super(addr);
189     }
190 
191     public int getInvocations() {
192       return (int) invocationField.getValue(addr);
193     }
194 
195   }
196 
197   private StatRecord getStatRecord() {
198     return (StatRecord) VMObjectFactory.newObject(Generation.StatRecord.class, addr.addOffsetTo(statRecordField.getOffset()));
199   }
200 }
    </pre>
  </body>
</html>
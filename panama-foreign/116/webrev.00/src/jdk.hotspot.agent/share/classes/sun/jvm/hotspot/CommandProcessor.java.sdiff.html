<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/CommandProcessor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../com/sun/java/swing/ui/WizardDlg.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HSDB.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/CommandProcessor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 111 public class CommandProcessor {
 112 
 113     volatile boolean quit;
 114 
 115     public abstract static class DebuggerInterface {
 116         public abstract HotSpotAgent getAgent();
 117         public abstract boolean isAttached();
 118         public abstract void attach(String pid);
 119         public abstract void attach(String java, String core);
 120         public abstract void detach();
 121         public abstract void reattach();
 122     }
 123 
 124     public static class BootFilter implements ClassFilter {
 125         public boolean canInclude(InstanceKlass kls) {
 126             return kls.getClassLoader() == null;
 127         }
 128     }
 129 
 130     public static class NonBootFilter implements ClassFilter {
<span class="line-modified"> 131         private HashMap emitted = new HashMap();</span>
 132         public boolean canInclude(InstanceKlass kls) {
 133             if (kls.getClassLoader() == null) return false;
 134             if (emitted.get(kls.getName()) != null) {
 135                 // Since multiple class loaders are being shoved
 136                 // together duplicate classes are a possibilty.  For
 137                 // now just ignore them.
 138                 return false;
 139             }
 140             emitted.put(kls.getName(), kls);
 141             return true;
 142         }
 143     }
 144 
 145     static class Tokens {
 146         final String input;
 147         int i;
 148         String[] tokens;
 149         int length;
 150 
 151         String[] splitWhitespace(String cmd) {
 152             String[] t = cmd.split(&quot;\\s&quot;);
 153             if (t.length == 1 &amp;&amp; t[0].length() == 0) {
 154                 return new String[0];
 155             }
 156             return t;
 157         }
 158 
<span class="line-modified"> 159         void add(String s, ArrayList t) {</span>
 160             if (s.length() &gt; 0) {
 161                 t.add(s);
 162             }
 163         }
 164 
 165         Tokens(String cmd) {
 166             input = cmd;
 167 
 168             // check for quoting
 169             int quote = cmd.indexOf(&#39;&quot;&#39;);
<span class="line-modified"> 170             ArrayList t = new ArrayList();</span>
 171             if (quote != -1) {
 172                 while (cmd.length() &gt; 0) {
 173                     if (quote != -1) {
 174                         int endquote = cmd.indexOf(&#39;&quot;&#39;, quote + 1);
 175                         if (endquote == -1) {
 176                             throw new RuntimeException(&quot;mismatched quotes: &quot; + input);
 177                         }
 178 
 179                         String before = cmd.substring(0, quote).trim();
 180                         String quoted = cmd.substring(quote + 1, endquote);
 181                         cmd = cmd.substring(endquote + 1).trim();
 182                         if (before.length() &gt; 0) {
 183                             String[] w = splitWhitespace(before);
 184                             for (int i = 0; i &lt; w.length; i++) {
 185                                 add(w[i], t);
 186                             }
 187                         }
 188                         add(quoted, t);
 189                         quote = cmd.indexOf(&#39;&quot;&#39;);
 190                     } else {
</pre>
<hr />
<pre>
 665                         if (name != null &amp;&amp; !printed) {
 666                             out.println(&quot;Couldn&#39;t find flag: &quot; + name);
 667                         }
 668                     }
 669                 }
 670             }
 671         },
 672         new Command(&quot;help&quot;, &quot;help [ command ]&quot;, true) {
 673             public void doit(Tokens t) {
 674                 int tokens = t.countTokens();
 675                 Command cmd = null;
 676                 if (tokens == 1) {
 677                     cmd = findCommand(t.nextToken());
 678                 }
 679 
 680                 if (cmd != null) {
 681                     cmd.usage();
 682                 } else if (tokens == 0) {
 683                     out.println(&quot;Available commands:&quot;);
 684                     Object[] keys = commands.keySet().toArray();
<span class="line-modified"> 685                     Arrays.sort(keys, new Comparator() {</span>
 686                              public int compare(Object o1, Object o2) {
 687                                  return o1.toString().compareTo(o2.toString());
 688                              }
 689                           });
 690                     for (int i = 0; i &lt; keys.length; i++) {
 691                         out.print(&quot;  &quot;);
 692                         out.println(((Command)commands.get(keys[i])).usage);
 693                     }
 694                 }
 695             }
 696         },
 697         new Command(&quot;history&quot;, &quot;history&quot;, true) {
 698             public void doit(Tokens t) {
 699                 int tokens = t.countTokens();
 700                 if (tokens != 0 &amp;&amp; (tokens != 1 || !t.nextToken().equals(&quot;-h&quot;))) {
 701                     usage();
 702                     return;
 703                 }
 704                 boolean printIndex = tokens == 0;
 705                 for (int i = 0; i &lt; history.size(); i++) {
</pre>
<hr />
<pre>
 976                                         ilt.print(out);
 977                                     }
 978                                 }
 979                             }
 980                         }
 981                     }
 982                 }
 983             }
 984         },
 985         new Command(&quot;vmstructsdump&quot;, &quot;vmstructsdump&quot;, false) {
 986             public void doit(Tokens t) {
 987                 if (t.countTokens() != 0) {
 988                     usage();
 989                     return;
 990                 }
 991 
 992                 // Dump a copy of the type database in a form that can
 993                 // be read back.
 994                 Iterator i = agent.getTypeDataBase().getTypes();
 995                 // Make sure the types are emitted in an order than can be read back in
<span class="line-modified"> 996                 HashSet emitted = new HashSet();</span>
<span class="line-modified"> 997                 Stack pending = new Stack();</span>
 998                 while (i.hasNext()) {
 999                     Type n = (Type)i.next();
1000                     if (emitted.contains(n.getName())) {
1001                         continue;
1002                     }
1003 
1004                     while (n != null &amp;&amp; !emitted.contains(n.getName())) {
1005                         pending.push(n);
1006                         n = n.getSuperclass();
1007                     }
1008                     while (!pending.empty()) {
1009                         n = (Type)pending.pop();
1010                         dumpType(n);
1011                         emitted.add(n.getName());
1012                     }
1013                 }
1014                 i = agent.getTypeDataBase().getTypes();
1015                 while (i.hasNext()) {
1016                     dumpFields((Type)i.next(), false);
1017                 }
</pre>
<hr />
<pre>
1188                     while (base != null &amp;&amp; base.lessThan(end)) {
1189                         long step = stride;
1190                         OopHandle handle = base.addOffsetToAsOopHandle(0);
1191                         if (RobustOopDeterminator.oopLooksValid(handle)) {
1192                             try {
1193                                 Oop oop = VM.getVM().getObjectHeap().newOop(handle);
1194                                 if (klass == null || oop.getKlass().isSubtypeOf(klass))
1195                                     out.println(handle.toString() + &quot; &quot; + oop.getKlass().getName().asString());
1196                                 step = oop.getObjectSize();
1197                             } catch (UnknownOopException ex) {
1198                                 // ok
1199                             } catch (RuntimeException ex) {
1200                                 ex.printStackTrace();
1201                             }
1202                         }
1203                         base = base.addOffsetTo(step);
1204                     }
1205                 }
1206             }
1207         },
<span class="line-modified">1208         new Command(&quot;intConstant&quot;, &quot;intConstant [ name [ value ] ]&quot;, true) {</span>
1209             public void doit(Tokens t) {
1210                 if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 2) {
1211                     usage();
1212                     return;
1213                 }
1214                 HotSpotTypeDataBase db = (HotSpotTypeDataBase)agent.getTypeDataBase();
1215                 if (t.countTokens() == 1) {
1216                     String name = t.nextToken();
1217                     out.println(&quot;intConstant &quot; + name + &quot; &quot; + db.lookupIntConstant(name));
1218                 } else if (t.countTokens() == 0) {
1219                     Iterator i = db.getIntConstants();
1220                     while (i.hasNext()) {
1221                         String name = (String)i.next();
1222                         out.println(&quot;intConstant &quot; + name + &quot; &quot; + db.lookupIntConstant(name));
1223                     }
1224                 } else if (t.countTokens() == 2) {
1225                     String name = t.nextToken();
1226                     Integer value = Integer.valueOf(t.nextToken());
1227                     db.addIntConstant(name, value);
1228                 }
1229             }
1230         },
<span class="line-modified">1231         new Command(&quot;longConstant&quot;, &quot;longConstant [ name [ value ] ]&quot;, true) {</span>
1232             public void doit(Tokens t) {
1233                 if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 2) {
1234                     usage();
1235                     return;
1236                 }
1237                 HotSpotTypeDataBase db = (HotSpotTypeDataBase)agent.getTypeDataBase();
1238                 if (t.countTokens() == 1) {
1239                     String name = t.nextToken();
1240                     out.println(&quot;longConstant &quot; + name + &quot; &quot; + db.lookupLongConstant(name));
1241                 } else if (t.countTokens() == 0) {
1242                     Iterator i = db.getLongConstants();
1243                     while (i.hasNext()) {
1244                         String name = (String)i.next();
1245                         out.println(&quot;longConstant &quot; + name + &quot; &quot; + db.lookupLongConstant(name));
1246                     }
1247                 } else if (t.countTokens() == 2) {
1248                     String name = t.nextToken();
1249                     Long value = Long.valueOf(t.nextToken());
1250                     db.addLongConstant(name, value);
1251                 }
1252             }
1253         },
<span class="line-modified">1254         new Command(&quot;field&quot;, &quot;field [ type [ name fieldtype isStatic offset address ] ]&quot;, true) {</span>
1255             public void doit(Tokens t) {
1256                 if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 6) {
1257                     usage();
1258                     return;
1259                 }
1260                 if (t.countTokens() == 1) {
1261                     Type type = agent.getTypeDataBase().lookupType(t.nextToken());
1262                     dumpFields(type);
1263                 } else if (t.countTokens() == 0) {
1264                     Iterator i = agent.getTypeDataBase().getTypes();
1265                     while (i.hasNext()) {
1266                         dumpFields((Type)i.next());
1267                     }
1268                 } else {
1269                     BasicType containingType = (BasicType)agent.getTypeDataBase().lookupType(t.nextToken());
1270 
1271                     String fieldName = t.nextToken();
1272 
1273                     // The field&#39;s Type must already be in the database -- no exceptions
1274                     Type fieldType = agent.getTypeDataBase().lookupType(t.nextToken());
</pre>
<hr />
<pre>
1306 
1307                     // Create field by type
1308                     HotSpotTypeDataBase db = (HotSpotTypeDataBase)agent.getTypeDataBase();
1309                     db.createField(containingType,
1310                                    fieldName, fieldType,
1311                                    isStatic,
1312                                    offset,
1313                                    staticAddress);
1314 
1315                 }
1316             }
1317 
1318         },
1319         new Command(&quot;tokenize&quot;, &quot;tokenize ...&quot;, true) {
1320             public void doit(Tokens t) {
1321                 while (t.hasMoreTokens()) {
1322                     out.println(&quot;\&quot;&quot; + t.nextToken() + &quot;\&quot;&quot;);
1323                 }
1324             }
1325         },
<span class="line-modified">1326         new Command(&quot;type&quot;, &quot;type [ type [ name super isOop isInteger isUnsigned size ] ]&quot;, true) {</span>
1327             public void doit(Tokens t) {
1328                 if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 6) {
1329                     usage();
1330                     return;
1331                 }
1332                 if (t.countTokens() == 6) {
1333                     String typeName = t.nextToken();
1334                     String superclassName = t.nextToken();
1335                     if (superclassName.equals(&quot;null&quot;)) {
1336                         superclassName = null;
1337                     }
1338                     boolean isOop = Boolean.valueOf(t.nextToken()).booleanValue();
1339                     boolean isInteger = Boolean.valueOf(t.nextToken()).booleanValue();
1340                     boolean isUnsigned = Boolean.valueOf(t.nextToken()).booleanValue();
1341                     long size = Long.parseLong(t.nextToken());
1342 
1343                     BasicType type = null;
1344                     try {
1345                         type = (BasicType)agent.getTypeDataBase().lookupType(typeName);
1346                     } catch (RuntimeException e) {
</pre>
<hr />
<pre>
1372                             }
1373                         }
1374                         if (type.getSize() != size) {
1375                             if (type.getSize() == -1) {
1376                                 type.setSize(size);
1377                             }
1378                             throw new RuntimeException(&quot;size mismatch in type definition: &quot; + t.input);
1379                         }
1380                         return;
1381                     }
1382 
1383                     // Create type
1384                     HotSpotTypeDataBase db = (HotSpotTypeDataBase)agent.getTypeDataBase();
1385                     db.createType(typeName, superclassName, isOop, isInteger, isUnsigned, size);
1386                 } else if (t.countTokens() == 1) {
1387                     Type type = agent.getTypeDataBase().lookupType(t.nextToken());
1388                     dumpType(type);
1389                 } else {
1390                     Iterator i = agent.getTypeDataBase().getTypes();
1391                     // Make sure the types are emitted in an order than can be read back in
<span class="line-modified">1392                     HashSet emitted = new HashSet();</span>
<span class="line-modified">1393                     Stack pending = new Stack();</span>
1394                     while (i.hasNext()) {
1395                         Type n = (Type)i.next();
1396                         if (emitted.contains(n.getName())) {
1397                             continue;
1398                         }
1399 
1400                         while (n != null &amp;&amp; !emitted.contains(n.getName())) {
1401                             pending.push(n);
1402                             n = n.getSuperclass();
1403                         }
1404                         while (!pending.empty()) {
1405                             n = (Type)pending.pop();
1406                             dumpType(n);
1407                             emitted.add(n.getName());
1408                         }
1409                     }
1410                 }
1411             }
1412 
1413         },
</pre>
<hr />
<pre>
1623                 if (t.countTokens() != 0) {
1624                     usage();
1625                 } else {
1626                     Threads threads = VM.getVM().getThreads();
1627                     for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
1628                         JavaThread thread = threads.getJavaThreadAt(i);
1629                         thread.printThreadIDOn(out);
1630                         out.println(&quot; &quot; + thread.getThreadName());
1631                         thread.printInfoOn(out);
1632                         out.println(&quot;\n...&quot;);
1633                     }
1634                 }
1635             }
1636         },
1637 
1638         new Command(&quot;livenmethods&quot;, false) {
1639             public void doit(Tokens t) {
1640                 if (t.countTokens() != 0) {
1641                     usage();
1642                 } else {
<span class="line-modified">1643                     ArrayList nmethods = new ArrayList();</span>
1644                     Threads threads = VM.getVM().getThreads();
1645                     HTMLGenerator gen = new HTMLGenerator(false);
1646                     for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
1647                         JavaThread thread = threads.getJavaThreadAt(i);
1648                         try {
1649                             for (JavaVFrame vf = thread.getLastJavaVFrameDbg(); vf != null; vf = vf.javaSender()) {
1650                                 if (vf instanceof CompiledVFrame) {
1651                                     NMethod c = ((CompiledVFrame)vf).getCode();
1652                                     if (!nmethods.contains(c)) {
1653                                         nmethods.add(c);
1654                                         out.println(gen.genHTML(c));
1655                                     }
1656                                 }
1657                             }
1658                         } catch (Exception e) {
1659                             e.printStackTrace();
1660                         }
1661                     }
1662                 }
1663             }
</pre>
<hr />
<pre>
1815             }
1816         },
1817         new Command(&quot;classes&quot;, &quot;classes&quot;, false) {
1818             public void doit(Tokens t) {
1819                 if (t.countTokens() != 0) {
1820                     usage();
1821                     return;
1822                 }
1823                 ClassLoaderDataGraph cldg = VM.getVM().getClassLoaderDataGraph();
1824                 cldg.classesDo(new ClassLoaderDataGraph.ClassVisitor() {
1825                         public void visit(Klass k) {
1826                             System.out.println(k.getName().asString() + &quot; @&quot; + k.getAddress());
1827                         }
1828                     }
1829                 );
1830             }
1831         },
1832     };
1833 
1834     private boolean verboseExceptions = false;
<span class="line-modified">1835     private ArrayList history = new ArrayList();</span>
<span class="line-modified">1836     private HashMap commands = new HashMap();</span>
1837     private boolean doEcho = false;
1838 
1839     private Command findCommand(String key) {
1840         return (Command)commands.get(key);
1841     }
1842 
1843     public void printPrompt() {
1844         out.print(&quot;hsdb&gt; &quot;);
1845     }
1846 
1847     private DebuggerInterface debugger;
1848     private HotSpotAgent agent;
1849     private JSJavaScriptEngine jsengine;
1850     private BufferedReader in;
1851     private PrintStream out;
1852     private PrintStream err;
1853 
1854     // called before debuggee attach
1855     private void preAttach() {
1856         // nothing for now..
</pre>
</td>
<td>
<hr />
<pre>
 111 public class CommandProcessor {
 112 
 113     volatile boolean quit;
 114 
 115     public abstract static class DebuggerInterface {
 116         public abstract HotSpotAgent getAgent();
 117         public abstract boolean isAttached();
 118         public abstract void attach(String pid);
 119         public abstract void attach(String java, String core);
 120         public abstract void detach();
 121         public abstract void reattach();
 122     }
 123 
 124     public static class BootFilter implements ClassFilter {
 125         public boolean canInclude(InstanceKlass kls) {
 126             return kls.getClassLoader() == null;
 127         }
 128     }
 129 
 130     public static class NonBootFilter implements ClassFilter {
<span class="line-modified"> 131         private HashMap&lt;Symbol, InstanceKlass&gt; emitted = new HashMap&lt;&gt;();</span>
 132         public boolean canInclude(InstanceKlass kls) {
 133             if (kls.getClassLoader() == null) return false;
 134             if (emitted.get(kls.getName()) != null) {
 135                 // Since multiple class loaders are being shoved
 136                 // together duplicate classes are a possibilty.  For
 137                 // now just ignore them.
 138                 return false;
 139             }
 140             emitted.put(kls.getName(), kls);
 141             return true;
 142         }
 143     }
 144 
 145     static class Tokens {
 146         final String input;
 147         int i;
 148         String[] tokens;
 149         int length;
 150 
 151         String[] splitWhitespace(String cmd) {
 152             String[] t = cmd.split(&quot;\\s&quot;);
 153             if (t.length == 1 &amp;&amp; t[0].length() == 0) {
 154                 return new String[0];
 155             }
 156             return t;
 157         }
 158 
<span class="line-modified"> 159         void add(String s, ArrayList&lt;String&gt; t) {</span>
 160             if (s.length() &gt; 0) {
 161                 t.add(s);
 162             }
 163         }
 164 
 165         Tokens(String cmd) {
 166             input = cmd;
 167 
 168             // check for quoting
 169             int quote = cmd.indexOf(&#39;&quot;&#39;);
<span class="line-modified"> 170             ArrayList&lt;String&gt; t = new ArrayList&lt;&gt;();</span>
 171             if (quote != -1) {
 172                 while (cmd.length() &gt; 0) {
 173                     if (quote != -1) {
 174                         int endquote = cmd.indexOf(&#39;&quot;&#39;, quote + 1);
 175                         if (endquote == -1) {
 176                             throw new RuntimeException(&quot;mismatched quotes: &quot; + input);
 177                         }
 178 
 179                         String before = cmd.substring(0, quote).trim();
 180                         String quoted = cmd.substring(quote + 1, endquote);
 181                         cmd = cmd.substring(endquote + 1).trim();
 182                         if (before.length() &gt; 0) {
 183                             String[] w = splitWhitespace(before);
 184                             for (int i = 0; i &lt; w.length; i++) {
 185                                 add(w[i], t);
 186                             }
 187                         }
 188                         add(quoted, t);
 189                         quote = cmd.indexOf(&#39;&quot;&#39;);
 190                     } else {
</pre>
<hr />
<pre>
 665                         if (name != null &amp;&amp; !printed) {
 666                             out.println(&quot;Couldn&#39;t find flag: &quot; + name);
 667                         }
 668                     }
 669                 }
 670             }
 671         },
 672         new Command(&quot;help&quot;, &quot;help [ command ]&quot;, true) {
 673             public void doit(Tokens t) {
 674                 int tokens = t.countTokens();
 675                 Command cmd = null;
 676                 if (tokens == 1) {
 677                     cmd = findCommand(t.nextToken());
 678                 }
 679 
 680                 if (cmd != null) {
 681                     cmd.usage();
 682                 } else if (tokens == 0) {
 683                     out.println(&quot;Available commands:&quot;);
 684                     Object[] keys = commands.keySet().toArray();
<span class="line-modified"> 685                     Arrays.sort(keys, new Comparator&lt;&gt;() {</span>
 686                              public int compare(Object o1, Object o2) {
 687                                  return o1.toString().compareTo(o2.toString());
 688                              }
 689                           });
 690                     for (int i = 0; i &lt; keys.length; i++) {
 691                         out.print(&quot;  &quot;);
 692                         out.println(((Command)commands.get(keys[i])).usage);
 693                     }
 694                 }
 695             }
 696         },
 697         new Command(&quot;history&quot;, &quot;history&quot;, true) {
 698             public void doit(Tokens t) {
 699                 int tokens = t.countTokens();
 700                 if (tokens != 0 &amp;&amp; (tokens != 1 || !t.nextToken().equals(&quot;-h&quot;))) {
 701                     usage();
 702                     return;
 703                 }
 704                 boolean printIndex = tokens == 0;
 705                 for (int i = 0; i &lt; history.size(); i++) {
</pre>
<hr />
<pre>
 976                                         ilt.print(out);
 977                                     }
 978                                 }
 979                             }
 980                         }
 981                     }
 982                 }
 983             }
 984         },
 985         new Command(&quot;vmstructsdump&quot;, &quot;vmstructsdump&quot;, false) {
 986             public void doit(Tokens t) {
 987                 if (t.countTokens() != 0) {
 988                     usage();
 989                     return;
 990                 }
 991 
 992                 // Dump a copy of the type database in a form that can
 993                 // be read back.
 994                 Iterator i = agent.getTypeDataBase().getTypes();
 995                 // Make sure the types are emitted in an order than can be read back in
<span class="line-modified"> 996                 HashSet&lt;String&gt; emitted = new HashSet&lt;&gt;();</span>
<span class="line-modified"> 997                 Stack&lt;Type&gt; pending = new Stack&lt;&gt;();</span>
 998                 while (i.hasNext()) {
 999                     Type n = (Type)i.next();
1000                     if (emitted.contains(n.getName())) {
1001                         continue;
1002                     }
1003 
1004                     while (n != null &amp;&amp; !emitted.contains(n.getName())) {
1005                         pending.push(n);
1006                         n = n.getSuperclass();
1007                     }
1008                     while (!pending.empty()) {
1009                         n = (Type)pending.pop();
1010                         dumpType(n);
1011                         emitted.add(n.getName());
1012                     }
1013                 }
1014                 i = agent.getTypeDataBase().getTypes();
1015                 while (i.hasNext()) {
1016                     dumpFields((Type)i.next(), false);
1017                 }
</pre>
<hr />
<pre>
1188                     while (base != null &amp;&amp; base.lessThan(end)) {
1189                         long step = stride;
1190                         OopHandle handle = base.addOffsetToAsOopHandle(0);
1191                         if (RobustOopDeterminator.oopLooksValid(handle)) {
1192                             try {
1193                                 Oop oop = VM.getVM().getObjectHeap().newOop(handle);
1194                                 if (klass == null || oop.getKlass().isSubtypeOf(klass))
1195                                     out.println(handle.toString() + &quot; &quot; + oop.getKlass().getName().asString());
1196                                 step = oop.getObjectSize();
1197                             } catch (UnknownOopException ex) {
1198                                 // ok
1199                             } catch (RuntimeException ex) {
1200                                 ex.printStackTrace();
1201                             }
1202                         }
1203                         base = base.addOffsetTo(step);
1204                     }
1205                 }
1206             }
1207         },
<span class="line-modified">1208         new Command(&quot;intConstant&quot;, &quot;intConstant [ name [ value ] ]&quot;, false) {</span>
1209             public void doit(Tokens t) {
1210                 if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 2) {
1211                     usage();
1212                     return;
1213                 }
1214                 HotSpotTypeDataBase db = (HotSpotTypeDataBase)agent.getTypeDataBase();
1215                 if (t.countTokens() == 1) {
1216                     String name = t.nextToken();
1217                     out.println(&quot;intConstant &quot; + name + &quot; &quot; + db.lookupIntConstant(name));
1218                 } else if (t.countTokens() == 0) {
1219                     Iterator i = db.getIntConstants();
1220                     while (i.hasNext()) {
1221                         String name = (String)i.next();
1222                         out.println(&quot;intConstant &quot; + name + &quot; &quot; + db.lookupIntConstant(name));
1223                     }
1224                 } else if (t.countTokens() == 2) {
1225                     String name = t.nextToken();
1226                     Integer value = Integer.valueOf(t.nextToken());
1227                     db.addIntConstant(name, value);
1228                 }
1229             }
1230         },
<span class="line-modified">1231         new Command(&quot;longConstant&quot;, &quot;longConstant [ name [ value ] ]&quot;, false) {</span>
1232             public void doit(Tokens t) {
1233                 if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 2) {
1234                     usage();
1235                     return;
1236                 }
1237                 HotSpotTypeDataBase db = (HotSpotTypeDataBase)agent.getTypeDataBase();
1238                 if (t.countTokens() == 1) {
1239                     String name = t.nextToken();
1240                     out.println(&quot;longConstant &quot; + name + &quot; &quot; + db.lookupLongConstant(name));
1241                 } else if (t.countTokens() == 0) {
1242                     Iterator i = db.getLongConstants();
1243                     while (i.hasNext()) {
1244                         String name = (String)i.next();
1245                         out.println(&quot;longConstant &quot; + name + &quot; &quot; + db.lookupLongConstant(name));
1246                     }
1247                 } else if (t.countTokens() == 2) {
1248                     String name = t.nextToken();
1249                     Long value = Long.valueOf(t.nextToken());
1250                     db.addLongConstant(name, value);
1251                 }
1252             }
1253         },
<span class="line-modified">1254         new Command(&quot;field&quot;, &quot;field [ type [ name fieldtype isStatic offset address ] ]&quot;, false) {</span>
1255             public void doit(Tokens t) {
1256                 if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 6) {
1257                     usage();
1258                     return;
1259                 }
1260                 if (t.countTokens() == 1) {
1261                     Type type = agent.getTypeDataBase().lookupType(t.nextToken());
1262                     dumpFields(type);
1263                 } else if (t.countTokens() == 0) {
1264                     Iterator i = agent.getTypeDataBase().getTypes();
1265                     while (i.hasNext()) {
1266                         dumpFields((Type)i.next());
1267                     }
1268                 } else {
1269                     BasicType containingType = (BasicType)agent.getTypeDataBase().lookupType(t.nextToken());
1270 
1271                     String fieldName = t.nextToken();
1272 
1273                     // The field&#39;s Type must already be in the database -- no exceptions
1274                     Type fieldType = agent.getTypeDataBase().lookupType(t.nextToken());
</pre>
<hr />
<pre>
1306 
1307                     // Create field by type
1308                     HotSpotTypeDataBase db = (HotSpotTypeDataBase)agent.getTypeDataBase();
1309                     db.createField(containingType,
1310                                    fieldName, fieldType,
1311                                    isStatic,
1312                                    offset,
1313                                    staticAddress);
1314 
1315                 }
1316             }
1317 
1318         },
1319         new Command(&quot;tokenize&quot;, &quot;tokenize ...&quot;, true) {
1320             public void doit(Tokens t) {
1321                 while (t.hasMoreTokens()) {
1322                     out.println(&quot;\&quot;&quot; + t.nextToken() + &quot;\&quot;&quot;);
1323                 }
1324             }
1325         },
<span class="line-modified">1326         new Command(&quot;type&quot;, &quot;type [ type [ name super isOop isInteger isUnsigned size ] ]&quot;, false) {</span>
1327             public void doit(Tokens t) {
1328                 if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 6) {
1329                     usage();
1330                     return;
1331                 }
1332                 if (t.countTokens() == 6) {
1333                     String typeName = t.nextToken();
1334                     String superclassName = t.nextToken();
1335                     if (superclassName.equals(&quot;null&quot;)) {
1336                         superclassName = null;
1337                     }
1338                     boolean isOop = Boolean.valueOf(t.nextToken()).booleanValue();
1339                     boolean isInteger = Boolean.valueOf(t.nextToken()).booleanValue();
1340                     boolean isUnsigned = Boolean.valueOf(t.nextToken()).booleanValue();
1341                     long size = Long.parseLong(t.nextToken());
1342 
1343                     BasicType type = null;
1344                     try {
1345                         type = (BasicType)agent.getTypeDataBase().lookupType(typeName);
1346                     } catch (RuntimeException e) {
</pre>
<hr />
<pre>
1372                             }
1373                         }
1374                         if (type.getSize() != size) {
1375                             if (type.getSize() == -1) {
1376                                 type.setSize(size);
1377                             }
1378                             throw new RuntimeException(&quot;size mismatch in type definition: &quot; + t.input);
1379                         }
1380                         return;
1381                     }
1382 
1383                     // Create type
1384                     HotSpotTypeDataBase db = (HotSpotTypeDataBase)agent.getTypeDataBase();
1385                     db.createType(typeName, superclassName, isOop, isInteger, isUnsigned, size);
1386                 } else if (t.countTokens() == 1) {
1387                     Type type = agent.getTypeDataBase().lookupType(t.nextToken());
1388                     dumpType(type);
1389                 } else {
1390                     Iterator i = agent.getTypeDataBase().getTypes();
1391                     // Make sure the types are emitted in an order than can be read back in
<span class="line-modified">1392                     HashSet&lt;String&gt; emitted = new HashSet&lt;&gt;();</span>
<span class="line-modified">1393                     Stack&lt;Type&gt; pending = new Stack&lt;&gt;();</span>
1394                     while (i.hasNext()) {
1395                         Type n = (Type)i.next();
1396                         if (emitted.contains(n.getName())) {
1397                             continue;
1398                         }
1399 
1400                         while (n != null &amp;&amp; !emitted.contains(n.getName())) {
1401                             pending.push(n);
1402                             n = n.getSuperclass();
1403                         }
1404                         while (!pending.empty()) {
1405                             n = (Type)pending.pop();
1406                             dumpType(n);
1407                             emitted.add(n.getName());
1408                         }
1409                     }
1410                 }
1411             }
1412 
1413         },
</pre>
<hr />
<pre>
1623                 if (t.countTokens() != 0) {
1624                     usage();
1625                 } else {
1626                     Threads threads = VM.getVM().getThreads();
1627                     for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
1628                         JavaThread thread = threads.getJavaThreadAt(i);
1629                         thread.printThreadIDOn(out);
1630                         out.println(&quot; &quot; + thread.getThreadName());
1631                         thread.printInfoOn(out);
1632                         out.println(&quot;\n...&quot;);
1633                     }
1634                 }
1635             }
1636         },
1637 
1638         new Command(&quot;livenmethods&quot;, false) {
1639             public void doit(Tokens t) {
1640                 if (t.countTokens() != 0) {
1641                     usage();
1642                 } else {
<span class="line-modified">1643                     ArrayList&lt;NMethod&gt; nmethods = new ArrayList&lt;&gt;();</span>
1644                     Threads threads = VM.getVM().getThreads();
1645                     HTMLGenerator gen = new HTMLGenerator(false);
1646                     for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
1647                         JavaThread thread = threads.getJavaThreadAt(i);
1648                         try {
1649                             for (JavaVFrame vf = thread.getLastJavaVFrameDbg(); vf != null; vf = vf.javaSender()) {
1650                                 if (vf instanceof CompiledVFrame) {
1651                                     NMethod c = ((CompiledVFrame)vf).getCode();
1652                                     if (!nmethods.contains(c)) {
1653                                         nmethods.add(c);
1654                                         out.println(gen.genHTML(c));
1655                                     }
1656                                 }
1657                             }
1658                         } catch (Exception e) {
1659                             e.printStackTrace();
1660                         }
1661                     }
1662                 }
1663             }
</pre>
<hr />
<pre>
1815             }
1816         },
1817         new Command(&quot;classes&quot;, &quot;classes&quot;, false) {
1818             public void doit(Tokens t) {
1819                 if (t.countTokens() != 0) {
1820                     usage();
1821                     return;
1822                 }
1823                 ClassLoaderDataGraph cldg = VM.getVM().getClassLoaderDataGraph();
1824                 cldg.classesDo(new ClassLoaderDataGraph.ClassVisitor() {
1825                         public void visit(Klass k) {
1826                             System.out.println(k.getName().asString() + &quot; @&quot; + k.getAddress());
1827                         }
1828                     }
1829                 );
1830             }
1831         },
1832     };
1833 
1834     private boolean verboseExceptions = false;
<span class="line-modified">1835     private ArrayList&lt;String&gt; history = new ArrayList&lt;&gt;();</span>
<span class="line-modified">1836     private HashMap&lt;String, Command&gt; commands = new HashMap&lt;&gt;();</span>
1837     private boolean doEcho = false;
1838 
1839     private Command findCommand(String key) {
1840         return (Command)commands.get(key);
1841     }
1842 
1843     public void printPrompt() {
1844         out.print(&quot;hsdb&gt; &quot;);
1845     }
1846 
1847     private DebuggerInterface debugger;
1848     private HotSpotAgent agent;
1849     private JSJavaScriptEngine jsengine;
1850     private BufferedReader in;
1851     private PrintStream out;
1852     private PrintStream err;
1853 
1854     // called before debuggee attach
1855     private void preAttach() {
1856         // nothing for now..
</pre>
</td>
</tr>
</table>
<center><a href="../../../com/sun/java/swing/ui/WizardDlg.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HSDB.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/VM.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Threads.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VMReg.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/VM.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 package sun.jvm.hotspot.runtime;
  26 
  27 import java.io.*;
  28 import java.net.*;
  29 import java.util.*;
  30 import java.util.regex.*;
  31 import sun.jvm.hotspot.code.*;
  32 import sun.jvm.hotspot.c1.*;
  33 import sun.jvm.hotspot.code.*;
  34 import sun.jvm.hotspot.debugger.*;
  35 import sun.jvm.hotspot.interpreter.*;
  36 import sun.jvm.hotspot.memory.*;
  37 import sun.jvm.hotspot.oops.*;
  38 import sun.jvm.hotspot.types.*;
  39 import sun.jvm.hotspot.utilities.*;
  40 import sun.jvm.hotspot.runtime.*;
  41 import sun.jvm.hotspot.classfile.*;


  42 
  43 /** &lt;P&gt; This class encapsulates the global state of the VM; the
  44     universe, object heap, interpreter, etc. It is a Singleton and
  45     must be initialized with a call to initialize() before calling
  46     getVM(). &lt;/P&gt;
  47 
  48     &lt;P&gt; Many auxiliary classes (i.e., most of the VMObjects) keep
  49     needed field offsets in the form of static Field objects. In a
  50     debugging system, the VM might be shutdown and re-initialized (on
  51     a differently-configured build, i.e., 32- vs. 64-bit), and all old
  52     cached state (including fields and field offsets) must be
  53     flushed. &lt;/P&gt;
  54 
  55     &lt;P&gt; An Observer pattern is used to implement the initialization of
  56     such classes. Each such class, in its static initializer,
  57     registers an Observer with the VM class via
  58     VM.registerVMInitializedObserver(). This Observer is guaranteed to
  59     be notified whenever the VM is initialized (or re-initialized). To
  60     implement the first-time initialization, the observer is also
  61     notified when it registers itself with the VM. (For bootstrapping
  62     reasons, this implies that the constructor of VM can not
  63     instantiate any such objects, since VM.soleInstance will not have
  64     been set yet. This is a bootstrapping issue which may have to be
  65     revisited later.) &lt;/P&gt;
  66 */
  67 
  68 public class VM {
  69   private static VM    soleInstance;
<span class="line-modified">  70   private static List  vmInitializedObservers = new ArrayList();</span>
<span class="line-modified">  71   private List         vmResumedObservers   = new ArrayList();</span>
<span class="line-modified">  72   private List         vmSuspendedObservers = new ArrayList();</span>
  73   private TypeDataBase db;
  74   private boolean      isBigEndian;
  75   /** This is only present if in a debugging system */
  76   private JVMDebugger  debugger;
  77   private long         stackBias;
  78   private long         logAddressSize;
  79   private Universe     universe;
  80   private ObjectHeap   heap;
  81   private SystemDictionary dict;
  82   private ClassLoaderDataGraph cldGraph;
  83   private Threads      threads;
  84   private ObjectSynchronizer synchronizer;
  85   private JNIHandles   handles;
  86   private Interpreter  interpreter;
  87   private StubRoutines stubRoutines;
  88   private FileMapInfo  fileMapInfo;
  89   private Bytes        bytes;
  90 
  91   /** Flag indicating if JVMTI support is included in the build */
  92   private boolean      isJvmtiSupported;
</pre>
<hr />
<pre>
 117   private static int   Flags_VALUE_ORIGIN_MASK;
 118   private static int   Flags_ORIG_COMMAND_LINE;
 119   /** This is only present in a non-core build */
 120   private CodeCache    codeCache;
 121   /** This is only present in a C1 build */
 122   private Runtime1     runtime1;
 123   /** These constants come from globalDefinitions.hpp */
 124   private int          invocationEntryBCI;
 125   private ReversePtrs  revPtrs;
 126   private VMRegImpl    vmregImpl;
 127   private int          reserveForAllocationPrefetch;
 128 
 129   // System.getProperties from debuggee VM
 130   private Properties   sysProps;
 131 
 132   // VM version strings come from Abstract_VM_Version class
 133   private String       vmRelease;
 134   private String       vmInternalInfo;
 135 
 136   private Flag[] commandLineFlags;
<span class="line-modified"> 137   private Map flagsMap;</span>
 138 
 139   private static Type intType;
 140   private static Type uintType;
 141   private static Type intxType;
 142   private static Type uintxType;
 143   private static Type sizetType;
 144   private static Type uint64tType;
 145   private static CIntegerType boolType;
 146   private Boolean sharingEnabled;
 147   private Boolean compressedOopsEnabled;
 148   private Boolean compressedKlassPointersEnabled;
 149 
 150   // command line flags supplied to VM - see struct JVMFlag in jvmFlag.hpp
 151   public static final class Flag {
 152      private String type;
 153      private String name;
 154      private Address addr;
 155      private int flags;
 156 
 157      private Flag(String type, String name, Address addr, int flags) {
</pre>
<hr />
<pre>
 981       return (flag == null) ? false: flag.getBool();
 982   }
 983 
 984   public boolean getCommandLineBooleanFlag(String name) {
 985     Flag flag = getCommandLineFlag(name);
 986     return (flag == null) ? Boolean.FALSE:
 987       (flag.getBool()? Boolean.TRUE: Boolean.FALSE);
 988   }
 989 
 990   // returns null, if not available.
 991   public Flag[] getCommandLineFlags() {
 992     if (commandLineFlags == null) {
 993        readCommandLineFlags();
 994     }
 995 
 996     return commandLineFlags;
 997   }
 998 
 999   public Flag getCommandLineFlag(String name) {
1000     if (flagsMap == null) {
<span class="line-modified">1001       flagsMap = new HashMap();</span>
1002       Flag[] flags = getCommandLineFlags();
1003       for (int i = 0; i &lt; flags.length; i++) {
1004         flagsMap.put(flags[i].getName(), flags[i]);
1005       }
1006     }
1007     return (Flag) flagsMap.get(name);
1008   }
1009 
1010   private void readCommandLineFlags() {
1011     // get command line flags
1012     TypeDataBase db = getTypeDataBase();
1013     Type flagType = db.lookupType(&quot;JVMFlag&quot;);
1014     int numFlags = (int) flagType.getCIntegerField(&quot;numFlags&quot;).getValue();
1015     // NOTE: last flag contains null values.
1016     commandLineFlags = new Flag[numFlags - 1];
1017 
1018     Address flagAddr = flagType.getAddressField(&quot;flags&quot;).getValue();
1019 
1020     AddressField typeFld = flagType.getAddressField(&quot;_type&quot;);
1021     AddressField nameFld = flagType.getAddressField(&quot;_name&quot;);
1022     AddressField addrFld = flagType.getAddressField(&quot;_addr&quot;);
1023     CIntField flagsFld = new CIntField(flagType.getCIntegerField(&quot;_flags&quot;), 0);
1024 
1025     long flagSize = flagType.getSize(); // sizeof(Flag)
1026 
1027     // NOTE: last flag contains null values.
1028     for (int f = 0; f &lt; numFlags - 1; f++) {
1029       String type = CStringUtilities.getString(typeFld.getValue(flagAddr));
1030       String name = CStringUtilities.getString(nameFld.getValue(flagAddr));
1031       Address addr = addrFld.getValue(flagAddr);
1032       int flags = (int)flagsFld.getValue(flagAddr);
1033       commandLineFlags[f] = new Flag(type, name, addr, flags);
1034       flagAddr = flagAddr.addOffsetTo(flagSize);
1035     }
1036 
1037     // sort flags by name
<span class="line-modified">1038     Arrays.sort(commandLineFlags, new Comparator() {</span>
<span class="line-modified">1039         public int compare(Object o1, Object o2) {</span>
<span class="line-removed">1040           Flag f1 = (Flag) o1;</span>
<span class="line-removed">1041           Flag f2 = (Flag) o2;</span>
1042           return f1.getName().compareTo(f2.getName());
1043         }
1044       });
1045   }
1046 
1047   public String getSystemProperty(String key) {
1048     Properties props = getSystemProperties();
1049     return (props != null)? props.getProperty(key) : null;
1050   }
1051 
1052   public Properties getSystemProperties() {
1053     if (sysProps == null) {
1054        readSystemProperties();
1055     }
1056     return sysProps;
1057   }
1058 
1059   private void readSystemProperties() {
1060     final InstanceKlass systemKls = getSystemDictionary().getSystemKlass();
1061     systemKls.iterateStaticFields(new DefaultOopVisitor() {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 package sun.jvm.hotspot.runtime;
  26 
  27 import java.io.*;
  28 import java.net.*;
  29 import java.util.*;
  30 import java.util.regex.*;
  31 import sun.jvm.hotspot.code.*;
  32 import sun.jvm.hotspot.c1.*;
  33 import sun.jvm.hotspot.code.*;
  34 import sun.jvm.hotspot.debugger.*;
  35 import sun.jvm.hotspot.interpreter.*;
  36 import sun.jvm.hotspot.memory.*;
  37 import sun.jvm.hotspot.oops.*;
  38 import sun.jvm.hotspot.types.*;
  39 import sun.jvm.hotspot.utilities.*;
  40 import sun.jvm.hotspot.runtime.*;
  41 import sun.jvm.hotspot.classfile.*;
<span class="line-added">  42 import sun.jvm.hotspot.utilities.Observable;</span>
<span class="line-added">  43 import sun.jvm.hotspot.utilities.Observer;</span>
  44 
  45 /** &lt;P&gt; This class encapsulates the global state of the VM; the
  46     universe, object heap, interpreter, etc. It is a Singleton and
  47     must be initialized with a call to initialize() before calling
  48     getVM(). &lt;/P&gt;
  49 
  50     &lt;P&gt; Many auxiliary classes (i.e., most of the VMObjects) keep
  51     needed field offsets in the form of static Field objects. In a
  52     debugging system, the VM might be shutdown and re-initialized (on
  53     a differently-configured build, i.e., 32- vs. 64-bit), and all old
  54     cached state (including fields and field offsets) must be
  55     flushed. &lt;/P&gt;
  56 
  57     &lt;P&gt; An Observer pattern is used to implement the initialization of
  58     such classes. Each such class, in its static initializer,
  59     registers an Observer with the VM class via
  60     VM.registerVMInitializedObserver(). This Observer is guaranteed to
  61     be notified whenever the VM is initialized (or re-initialized). To
  62     implement the first-time initialization, the observer is also
  63     notified when it registers itself with the VM. (For bootstrapping
  64     reasons, this implies that the constructor of VM can not
  65     instantiate any such objects, since VM.soleInstance will not have
  66     been set yet. This is a bootstrapping issue which may have to be
  67     revisited later.) &lt;/P&gt;
  68 */
  69 
  70 public class VM {
  71   private static VM    soleInstance;
<span class="line-modified">  72   private static List&lt;Observer&gt; vmInitializedObservers = new ArrayList&lt;&gt;();</span>
<span class="line-modified">  73   private List&lt;Observer&gt; vmResumedObservers   = new ArrayList&lt;&gt;();</span>
<span class="line-modified">  74   private List&lt;Observer&gt; vmSuspendedObservers = new ArrayList&lt;&gt;();</span>
  75   private TypeDataBase db;
  76   private boolean      isBigEndian;
  77   /** This is only present if in a debugging system */
  78   private JVMDebugger  debugger;
  79   private long         stackBias;
  80   private long         logAddressSize;
  81   private Universe     universe;
  82   private ObjectHeap   heap;
  83   private SystemDictionary dict;
  84   private ClassLoaderDataGraph cldGraph;
  85   private Threads      threads;
  86   private ObjectSynchronizer synchronizer;
  87   private JNIHandles   handles;
  88   private Interpreter  interpreter;
  89   private StubRoutines stubRoutines;
  90   private FileMapInfo  fileMapInfo;
  91   private Bytes        bytes;
  92 
  93   /** Flag indicating if JVMTI support is included in the build */
  94   private boolean      isJvmtiSupported;
</pre>
<hr />
<pre>
 119   private static int   Flags_VALUE_ORIGIN_MASK;
 120   private static int   Flags_ORIG_COMMAND_LINE;
 121   /** This is only present in a non-core build */
 122   private CodeCache    codeCache;
 123   /** This is only present in a C1 build */
 124   private Runtime1     runtime1;
 125   /** These constants come from globalDefinitions.hpp */
 126   private int          invocationEntryBCI;
 127   private ReversePtrs  revPtrs;
 128   private VMRegImpl    vmregImpl;
 129   private int          reserveForAllocationPrefetch;
 130 
 131   // System.getProperties from debuggee VM
 132   private Properties   sysProps;
 133 
 134   // VM version strings come from Abstract_VM_Version class
 135   private String       vmRelease;
 136   private String       vmInternalInfo;
 137 
 138   private Flag[] commandLineFlags;
<span class="line-modified"> 139   private Map&lt;String, Flag&gt; flagsMap;</span>
 140 
 141   private static Type intType;
 142   private static Type uintType;
 143   private static Type intxType;
 144   private static Type uintxType;
 145   private static Type sizetType;
 146   private static Type uint64tType;
 147   private static CIntegerType boolType;
 148   private Boolean sharingEnabled;
 149   private Boolean compressedOopsEnabled;
 150   private Boolean compressedKlassPointersEnabled;
 151 
 152   // command line flags supplied to VM - see struct JVMFlag in jvmFlag.hpp
 153   public static final class Flag {
 154      private String type;
 155      private String name;
 156      private Address addr;
 157      private int flags;
 158 
 159      private Flag(String type, String name, Address addr, int flags) {
</pre>
<hr />
<pre>
 983       return (flag == null) ? false: flag.getBool();
 984   }
 985 
 986   public boolean getCommandLineBooleanFlag(String name) {
 987     Flag flag = getCommandLineFlag(name);
 988     return (flag == null) ? Boolean.FALSE:
 989       (flag.getBool()? Boolean.TRUE: Boolean.FALSE);
 990   }
 991 
 992   // returns null, if not available.
 993   public Flag[] getCommandLineFlags() {
 994     if (commandLineFlags == null) {
 995        readCommandLineFlags();
 996     }
 997 
 998     return commandLineFlags;
 999   }
1000 
1001   public Flag getCommandLineFlag(String name) {
1002     if (flagsMap == null) {
<span class="line-modified">1003       flagsMap = new HashMap&lt;&gt;();</span>
1004       Flag[] flags = getCommandLineFlags();
1005       for (int i = 0; i &lt; flags.length; i++) {
1006         flagsMap.put(flags[i].getName(), flags[i]);
1007       }
1008     }
1009     return (Flag) flagsMap.get(name);
1010   }
1011 
1012   private void readCommandLineFlags() {
1013     // get command line flags
1014     TypeDataBase db = getTypeDataBase();
1015     Type flagType = db.lookupType(&quot;JVMFlag&quot;);
1016     int numFlags = (int) flagType.getCIntegerField(&quot;numFlags&quot;).getValue();
1017     // NOTE: last flag contains null values.
1018     commandLineFlags = new Flag[numFlags - 1];
1019 
1020     Address flagAddr = flagType.getAddressField(&quot;flags&quot;).getValue();
1021 
1022     AddressField typeFld = flagType.getAddressField(&quot;_type&quot;);
1023     AddressField nameFld = flagType.getAddressField(&quot;_name&quot;);
1024     AddressField addrFld = flagType.getAddressField(&quot;_addr&quot;);
1025     CIntField flagsFld = new CIntField(flagType.getCIntegerField(&quot;_flags&quot;), 0);
1026 
1027     long flagSize = flagType.getSize(); // sizeof(Flag)
1028 
1029     // NOTE: last flag contains null values.
1030     for (int f = 0; f &lt; numFlags - 1; f++) {
1031       String type = CStringUtilities.getString(typeFld.getValue(flagAddr));
1032       String name = CStringUtilities.getString(nameFld.getValue(flagAddr));
1033       Address addr = addrFld.getValue(flagAddr);
1034       int flags = (int)flagsFld.getValue(flagAddr);
1035       commandLineFlags[f] = new Flag(type, name, addr, flags);
1036       flagAddr = flagAddr.addOffsetTo(flagSize);
1037     }
1038 
1039     // sort flags by name
<span class="line-modified">1040     Arrays.sort(commandLineFlags, new Comparator&lt;&gt;() {</span>
<span class="line-modified">1041         public int compare(Flag f1, Flag f2) {</span>


1042           return f1.getName().compareTo(f2.getName());
1043         }
1044       });
1045   }
1046 
1047   public String getSystemProperty(String key) {
1048     Properties props = getSystemProperties();
1049     return (props != null)? props.getProperty(key) : null;
1050   }
1051 
1052   public Properties getSystemProperties() {
1053     if (sysProps == null) {
1054        readSystemProperties();
1055     }
1056     return sysProps;
1057   }
1058 
1059   private void readSystemProperties() {
1060     final InstanceKlass systemKls = getSystemDictionary().getSystemKlass();
1061     systemKls.iterateStaticFields(new DefaultOopVisitor() {
</pre>
</td>
</tr>
</table>
<center><a href="Threads.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VMReg.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/Klass.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.oops;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.classfile.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.types.*;
 33 import sun.jvm.hotspot.utilities.Observable;
 34 import sun.jvm.hotspot.utilities.Observer;
 35 
 36 public class Klass extends Metadata implements ClassConstants {
 37   static {
 38     VM.registerVMInitializedObserver(new Observer() {
 39         public void update(Observable o, Object data) {
 40           initialize(VM.getVM().getTypeDataBase());
 41         }
 42       });
 43   }
 44 
 45   // anon-enum constants for _layout_helper.
 46   public static int LH_INSTANCE_SLOW_PATH_BIT;
 47   public static int LH_LOG2_ELEMENT_SIZE_SHIFT;
 48   public static int LH_ELEMENT_TYPE_SHIFT;
 49   public static int LH_HEADER_SIZE_SHIFT;
 50   public static int LH_ARRAY_TAG_SHIFT;
 51   public static int LH_ARRAY_TAG_TYPE_VALUE;
 52   public static int LH_ARRAY_TAG_OBJ_VALUE;
 53 
 54   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
 55     Type type    = db.lookupType(&quot;Klass&quot;);
 56     javaMirrorFieldOffset = type.getField(&quot;_java_mirror&quot;).getOffset();
 57     superField   = new MetadataField(type.getAddressField(&quot;_super&quot;), 0);
 58     layoutHelper = new IntField(type.getJIntField(&quot;_layout_helper&quot;), 0);
 59     name         = type.getAddressField(&quot;_name&quot;);
 60     accessFlags  = new CIntField(type.getCIntegerField(&quot;_access_flags&quot;), 0);
 61     try {
 62       traceIDField  = type.getField(&quot;_trace_id&quot;);
 63     } catch(Exception e) {
 64     }
 65     subklass     = new MetadataField(type.getAddressField(&quot;_subklass&quot;), 0);
 66     nextSibling  = new MetadataField(type.getAddressField(&quot;_next_sibling&quot;), 0);
 67     nextLink     = new MetadataField(type.getAddressField(&quot;_next_link&quot;), 0);
 68     vtableLen    = new CIntField(type.getCIntegerField(&quot;_vtable_len&quot;), 0);
 69     classLoaderData = type.getAddressField(&quot;_class_loader_data&quot;);
 70 
 71     LH_INSTANCE_SLOW_PATH_BIT  = db.lookupIntConstant(&quot;Klass::_lh_instance_slow_path_bit&quot;).intValue();
 72     LH_LOG2_ELEMENT_SIZE_SHIFT = db.lookupIntConstant(&quot;Klass::_lh_log2_element_size_shift&quot;).intValue();
 73     LH_ELEMENT_TYPE_SHIFT      = db.lookupIntConstant(&quot;Klass::_lh_element_type_shift&quot;).intValue();
 74     LH_HEADER_SIZE_SHIFT       = db.lookupIntConstant(&quot;Klass::_lh_header_size_shift&quot;).intValue();
 75     LH_ARRAY_TAG_SHIFT         = db.lookupIntConstant(&quot;Klass::_lh_array_tag_shift&quot;).intValue();
 76     LH_ARRAY_TAG_TYPE_VALUE    = db.lookupIntConstant(&quot;Klass::_lh_array_tag_type_value&quot;).intValue();
 77     LH_ARRAY_TAG_OBJ_VALUE     = db.lookupIntConstant(&quot;Klass::_lh_array_tag_obj_value&quot;).intValue();
 78   }
 79 
 80 
 81   public Klass(Address addr) {
 82     super(addr);
 83   }
 84 
 85   // jvmdi support - see also class_status in VM code
 86   public int getClassStatus() {
 87     return 0; // overridden in derived classes
 88   }
 89 
 90   public boolean isKlass()             { return true; }
 91   public boolean isArrayKlass()        { return false; }
 92 
 93   // Fields
 94   private static long javaMirrorFieldOffset;
 95   private static MetadataField  superField;
 96   private static IntField layoutHelper;
 97   private static AddressField  name;
 98   private static CIntField accessFlags;
 99   private static MetadataField  subklass;
100   private static MetadataField  nextSibling;
101   private static MetadataField  nextLink;
102   private static sun.jvm.hotspot.types.Field traceIDField;
103   private static CIntField vtableLen;
104   private static AddressField classLoaderData;
105 
106   protected Symbol getSymbol(AddressField field) {
107     return Symbol.create(addr.getAddressAt(field.getOffset()));
108   }
109 
110   // Accessors for declared fields
111   public Instance getJavaMirror() {
112     Address addr = getAddress().addOffsetTo(javaMirrorFieldOffset);
113     VMOopHandle vmOopHandle = VMObjectFactory.newObject(VMOopHandle.class, addr);
114     return vmOopHandle.resolve();
115   }
116   public Klass    getSuper()            { return (Klass)    superField.getValue(this);   }
117   public Klass    getJavaSuper()        { return null;  }
118   public int      getLayoutHelper()     { return (int)           layoutHelper.getValue(this); }
119   public Symbol   getName()             { return            getSymbol(name); }
120   public long     getAccessFlags()      { return            accessFlags.getValue(this);  }
121   // Convenience routine
122   public AccessFlags getAccessFlagsObj(){ return new AccessFlags(getAccessFlags());      }
123   public Klass    getSubklassKlass()    { return (Klass)    subklass.getValue(this);     }
124   public Klass    getNextSiblingKlass() { return (Klass)    nextSibling.getValue(this);  }
125   public Klass    getNextLinkKlass()    { return (Klass)    nextLink.getValue(this);  }
126   public long     getVtableLen()        { return            vtableLen.getValue(this); }
127 
128   public ClassLoaderData getClassLoaderData() { return ClassLoaderData.instantiateWrapperFor(classLoaderData.getValue(getAddress())); }
129   public Oop             getClassLoader()     { return   getClassLoaderData().getClassLoader(); }
130 
131   public long traceID() {
132     if (traceIDField == null) return 0;
133     return traceIDField.getJLong(addr);
134   }
135 
136   // computed access flags - takes care of inner classes etc.
137   // This is closer to actual source level than getAccessFlags() etc.
138   public long computeModifierFlags() {
139     return 0L; // Unless overridden, modifier_flags is 0.
140   }
141 
142   // same as JVM_GetClassModifiers
143   public final long getClassModifiers() {
144     // unlike the VM counterpart we never have to deal with primitive type,
145     // because we operator on Klass and not an instance of java.lang.Class.
146     long flags = computeModifierFlags();
147     if (isSuper()) {
148        flags |= JVM_ACC_SUPER;
149     }
150     return flags;
151   }
152 
153   // subclass check
154   public boolean isSubclassOf(Klass k) {
155     if (k != null) {
156       Klass t = this;
157       // Run up the super chain and check
158       while (t != null) {
159         if (t.equals(k)) return true;
160         t = t.getSuper();
161       }
162     }
163     return false;
164   }
165 
166   // subtype check
167   public boolean isSubtypeOf(Klass k) {
168     return computeSubtypeOf(k);
169   }
170 
171   boolean computeSubtypeOf(Klass k) {
172     return isSubclassOf(k);
173   }
174 
175   // Find LCA (Least Common Ancester) in class heirarchy
176   public Klass lca( Klass k2 ) {
177     Klass k1 = this;
178     while ( true ) {
179       if ( k1.isSubtypeOf(k2) ) return k2;
180       if ( k2.isSubtypeOf(k1) ) return k1;
181       k1 = k1.getSuper();
182       k2 = k2.getSuper();
183     }
184   }
185 
186   public void printValueOn(PrintStream tty) {
187     tty.print(&quot;Klass&quot;);
188   }
189 
190   public void iterateFields(MetadataVisitor visitor) {
191       // visitor.doOop(javaMirror, true);
192     visitor.doMetadata(superField, true);
193       visitor.doInt(layoutHelper, true);
194       // visitor.doOop(name, true);
195       visitor.doCInt(accessFlags, true);
196     visitor.doMetadata(subklass, true);
197     visitor.doMetadata(nextSibling, true);
198     visitor.doCInt(vtableLen, true);
199     }
200 
201   public long getObjectSize() {
202     throw new RuntimeException(&quot;should not reach here&quot;);
203   }
204 
205   /** Array class with specific rank */
206   public Klass arrayKlass(int rank)       { return arrayKlassImpl(false, rank); }
207   /** Array class with this klass as element type */
208   public Klass arrayKlass()               { return arrayKlassImpl(false);       }
209   /** These will return null instead of allocating on the heap */
210   public Klass arrayKlassOrNull(int rank) { return arrayKlassImpl(true, rank);  }
211   public Klass arrayKlassOrNull()         { return arrayKlassImpl(true);        }
212 
213   public Klass arrayKlassImpl(boolean orNull, int rank) {
214     throw new RuntimeException(&quot;array_klass should be dispatched to InstanceKlass, ObjArrayKlass or TypeArrayKlass&quot;);
215   }
216 
217   public Klass arrayKlassImpl(boolean orNull) {
218     throw new RuntimeException(&quot;array_klass should be dispatched to InstanceKlass, ObjArrayKlass or TypeArrayKlass&quot;);
219   }
220 
221   // This returns the name in the form java/lang/String which isn&#39;t really a signature
222   // The subclasses override this to produce the correct form, eg
223   //   Ljava/lang/String; For ArrayKlasses getName itself is the signature.
224   public String signature() { return getName().asString(); }
225 
226   // Convenience routines
227   public boolean isPublic()                 { return getAccessFlagsObj().isPublic(); }
228   public boolean isFinal()                  { return getAccessFlagsObj().isFinal(); }
229   public boolean isInterface()              { return getAccessFlagsObj().isInterface(); }
230   public boolean isAbstract()               { return getAccessFlagsObj().isAbstract(); }
231   public boolean isSuper()                  { return getAccessFlagsObj().isSuper(); }
232   public boolean isSynthetic()              { return getAccessFlagsObj().isSynthetic(); }
233   public boolean hasFinalizer()             { return getAccessFlagsObj().hasFinalizer(); }
234   public boolean isCloneable()              { return getAccessFlagsObj().isCloneable(); }
235   public boolean hasVanillaConstructor()    { return getAccessFlagsObj().hasVanillaConstructor(); }
236   public boolean hasMirandaMethods ()       { return getAccessFlagsObj().hasMirandaMethods(); }
237 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/proc/ProcDebuggerLocal.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ProcDebugger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../remote/RemoteDebuggerClient.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/proc/ProcDebuggerLocal.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
117             // tunable from the outside, i.e., via the UI. This is a 16 MB
118             // cache divided on SPARC into 2048 8K pages and on x86 into
119             // 4096 4K pages; the page size must be adjusted to be the OS&#39;s
120             // page size.
121 
122             cachePageSize = getPageSize();
123             cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);
124             initCache(cachePageSize, cacheNumPages);
125         }
126 
127         resetNativePointers();
128         clearCacheFields();
129     }
130 
131     /** FIXME: implement this with a Runtime.exec() of ps followed by
132      * parsing of its output */
133     public boolean hasProcessList() throws DebuggerException {
134         return false;
135     }
136 
<span class="line-modified">137     public List getProcessList() throws DebuggerException {</span>
138         throw new DebuggerException(&quot;Not yet supported&quot;);
139     }
140 
141 
142     /** From the Debugger interface via JVMDebugger */
143     public synchronized void attach(int processID) throws DebuggerException {
144         checkAttached();
145         isCore = false;
<span class="line-modified">146         attach0(new Integer(processID).toString());</span>
147         attached = true;
148         suspended = true;
149     }
150 
151     /** From the Debugger interface via JVMDebugger */
152     public synchronized void attach
153     (String executableName, String coreFileName) throws DebuggerException {
154         checkAttached();
155         isCore = true;
<span class="line-modified">156         topFrameCache = new HashMap();</span>
157         attach0(executableName, coreFileName);
158         attached = true;
159         suspended = true;
160     }
161 
162     /** From the Debugger interface via JVMDebugger */
163     public synchronized boolean detach() {
164         if (! attached) {
165             return false;
166         }
167 
168         try {
169             if (p_ps_prochandle == 0L) {
170                 return false;
171             }
172             detach0();
173             clearCache();
174             return true;
175         } catch (Exception e) {
176             e.printStackTrace();
</pre>
<hr />
<pre>
422         return getThreadIntegerRegisterSet0(tid);
423     }
424 
425     //--------------------------------------------------------------------------------
426     // Address access. Can not be package private, but should only be
427     // accessed by the architecture-specific subpackages.
428 
429     /** From the ProcDebugger interface */
430     public long getAddressValue(Address addr) {
431         if (addr == null) return 0;
432         return ((ProcAddress) addr).getValue();
433     }
434 
435     /** From the ProcDebugger interface */
436     public Address newAddress(long value) {
437         if (value == 0) return null;
438         return new ProcAddress(this, value);
439     }
440 
441     /** From the ProcDebugger interface */
<span class="line-modified">442     public synchronized List getThreadList() throws DebuggerException {</span>
443         requireAttach();
<span class="line-modified">444         List res = null;</span>
445         if (isCore &amp;&amp; (threadListCache != null)) {
446             res = threadListCache;
447         } else {
<span class="line-modified">448             res = new ArrayList();</span>
449             fillThreadList0(res);
450             if (isCore) {
451                 threadListCache = res;
452             }
453         }
454         return res;
455     }
456 
457     /** From the ProcDebugger interface */
<span class="line-modified">458     public synchronized List getLoadObjectList() throws DebuggerException {</span>
459         requireAttach();
460         if (!suspended) {
461             throw new DebuggerException(&quot;Process not suspended&quot;);
462         }
463 
464         if (loadObjectCache == null) {
465             updateLoadObjectCache();
466         }
467         return loadObjectCache;
468     }
469 
470     /** From the ProcDebugger interface */
471     public synchronized CFrame topFrameForThread(ThreadProxy thread)
472     throws DebuggerException {
473         requireAttach();
474         CFrame res = null;
475         if (isCore &amp;&amp; ((res = (CFrame) topFrameCache.get(thread)) != null)) {
476             return res;
477         } else {
478             ThreadContext context = thread.getContext();
</pre>
<hr />
<pre>
488             return res;
489         }
490     }
491 
492     /** From the ProcDebugger interface */
493     public synchronized ClosestSymbol lookup(long address) {
494         requireAttach();
495         return lookupByAddress0(address);
496     }
497 
498     /** From the ProcDebugger interface */
499     public String demangle(String name) {
500         return demangle0(name);
501     }
502 
503     //------------- Internals only below this point --------------------
504     //
505     //
506 
507     private void updateLoadObjectCache() {
<span class="line-modified">508         List res = new ArrayList();</span>
<span class="line-modified">509         nameToDsoMap = new HashMap();</span>
510         fillLoadObjectList0(res);
511         loadObjectCache = sortLoadObjects(res);
512     }
513 
514     // sort load objects by base address
<span class="line-modified">515     private static List sortLoadObjects(List in) {</span>
516         // sort the list by base address
<span class="line-modified">517         Object[] arr = in.toArray();</span>
518         Arrays.sort(arr, loadObjectComparator);
519         return Arrays.asList(arr);
520     }
521 
522     private long lookupByName(String objectName, String symbolName)
523     throws DebuggerException {
524         // NOTE: this assumes that process is suspended (which is probably
525         // necessary assumption given that DSOs can be loaded/unloaded as
526         // process runs). Should update documentation.
527         if (nameToDsoMap == null) {
528             getLoadObjectList();
529         }
530         SharedObject dso = (SharedObject) nameToDsoMap.get(objectName);
531         // The DSO can be null because we use this to search through known
532         // DSOs in HotSpotTypeDataBase (for example)
533         if (dso != null) {
534             ProcAddress addr = (ProcAddress) dso.lookupSymbol(symbolName);
535             if (addr != null) {
536                 return addr.getValue();
537             }
</pre>
<hr />
<pre>
597         p_td_thr_getgregs      = 0L;
598 
599         // part of class sharing workaround
600         classes_jsa_fd         = -1;
601         p_file_map_header      = 0L;
602     }
603 
604     // native methods and native helpers
605 
606     // attach, detach
607     private native void attach0(String pid) throws DebuggerException;
608     private native void attach0(String executableFile, String coreFileName) throws DebuggerException;
609     private native void detach0() throws DebuggerException;
610 
611     // address size, page size
612     private native int getRemoteProcessAddressSize0() throws DebuggerException;
613     private native int getPageSize0() throws DebuggerException;
614 
615     // threads, stacks
616     private native long[] getThreadIntegerRegisterSet0(long tid) throws DebuggerException;
<span class="line-modified">617     private native void   fillThreadList0(List l) throws DebuggerException;</span>
618 
619     // fills stack frame list given reg set of the top frame and top frame
620     private native ProcCFrame fillCFrameList0(long[] regs) throws DebuggerException;
621 
622     // helper called by fillCFrameList0
623     private ProcCFrame createSenderFrame(ProcCFrame f, long pc, long fp) {
624         ProcCFrame sender = new ProcCFrame(this, newAddress(pc), newAddress(fp));
625         if (f != null) {
626             f.setSender(sender);
627         }
628         return sender;
629     }
630 
631     // shared objects
<span class="line-modified">632     private native void fillLoadObjectList0(List l) throws DebuggerException;</span>
633 
634     // helper called by fillLoadObjectList0
635     private LoadObject createLoadObject(String fileName, long textsize, long base) {
636         File f = new File(fileName);
637         Address baseAddr = newAddress(base);
638         SharedObject res = findDSOByName(fileName);
639         if (res != null) {
640             // already in cache. just change the base, if needed
641             Address oldBase = res.getBase();
642             if (! baseAddr.equals(oldBase)) {
643                 res.setBase(baseAddr);
644             }
645         } else {
646             // new shared object.
647             res = new SharedObject(this, fileName, f.length(), baseAddr);
648         }
649         nameToDsoMap.put(f.getName(), res);
650         return res;
651     }
652 
</pre>
<hr />
<pre>
672 
673     // init JNI ids to fields, methods
674     private native static void initIDs() throws DebuggerException;
675     private static LoadObjectComparator loadObjectComparator;
676 
677     static {
678         System.loadLibrary(&quot;saproc&quot;);
679         initIDs();
680         loadObjectComparator = new LoadObjectComparator();
681     }
682 
683     private boolean unalignedAccessesOkay;
684     private ProcThreadFactory threadFactory;
685 
686     // indices of PC and FP registers in gregset
687     private int pcRegIndex;
688     private int fpRegIndex;
689 
690     // Symbol lookup support
691     // This is a map of library names to DSOs
<span class="line-modified">692     private Map nameToDsoMap;  // Map&lt;String, SharedObject&gt;</span>
693 
694     // C/C++ debugging support
<span class="line-modified">695     private List/*&lt;LoadObject&gt;*/ loadObjects;</span>
696     private CDebugger cdbg;
697 
698     // ProcessControl support
699     private boolean suspended;
700 
701     // libproc handle
702     private long p_ps_prochandle;
703 
704     // libthread.so&#39;s dlopen handle, thread agent
705     // and function pointers
706     private long libthread_db_handle;
707     private long p_td_thragent_t;
708     private long p_td_init;
709     private long p_td_ta_new;
710     private long p_td_ta_delete;
711     private long p_td_ta_thr_iter;
712     private long p_td_thr_get_info;
713     private long p_td_ta_map_id2thr;
714     private long p_td_thr_getgregs;
715 
716     // part of class sharing workaround
717     private int classes_jsa_fd;
718     private long p_file_map_header;
719 
720     private boolean attached = false;
721     private boolean isCore;
722 
723     // for core files, we cache load object list, thread list, top frames etc.
724     // for processes we cache load object list and sync. it during suspend.
<span class="line-modified">725     private List threadListCache;</span>
<span class="line-modified">726     private List loadObjectCache;</span>
<span class="line-modified">727     private Map  topFrameCache;      // Map&lt;ThreadProxy, CFrame&gt;</span>
728 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
117             // tunable from the outside, i.e., via the UI. This is a 16 MB
118             // cache divided on SPARC into 2048 8K pages and on x86 into
119             // 4096 4K pages; the page size must be adjusted to be the OS&#39;s
120             // page size.
121 
122             cachePageSize = getPageSize();
123             cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);
124             initCache(cachePageSize, cacheNumPages);
125         }
126 
127         resetNativePointers();
128         clearCacheFields();
129     }
130 
131     /** FIXME: implement this with a Runtime.exec() of ps followed by
132      * parsing of its output */
133     public boolean hasProcessList() throws DebuggerException {
134         return false;
135     }
136 
<span class="line-modified">137     public List&lt;ProcessInfo&gt; getProcessList() throws DebuggerException {</span>
138         throw new DebuggerException(&quot;Not yet supported&quot;);
139     }
140 
141 
142     /** From the Debugger interface via JVMDebugger */
143     public synchronized void attach(int processID) throws DebuggerException {
144         checkAttached();
145         isCore = false;
<span class="line-modified">146         attach0(Integer.toString(processID));</span>
147         attached = true;
148         suspended = true;
149     }
150 
151     /** From the Debugger interface via JVMDebugger */
152     public synchronized void attach
153     (String executableName, String coreFileName) throws DebuggerException {
154         checkAttached();
155         isCore = true;
<span class="line-modified">156         topFrameCache = new HashMap&lt;&gt;();</span>
157         attach0(executableName, coreFileName);
158         attached = true;
159         suspended = true;
160     }
161 
162     /** From the Debugger interface via JVMDebugger */
163     public synchronized boolean detach() {
164         if (! attached) {
165             return false;
166         }
167 
168         try {
169             if (p_ps_prochandle == 0L) {
170                 return false;
171             }
172             detach0();
173             clearCache();
174             return true;
175         } catch (Exception e) {
176             e.printStackTrace();
</pre>
<hr />
<pre>
422         return getThreadIntegerRegisterSet0(tid);
423     }
424 
425     //--------------------------------------------------------------------------------
426     // Address access. Can not be package private, but should only be
427     // accessed by the architecture-specific subpackages.
428 
429     /** From the ProcDebugger interface */
430     public long getAddressValue(Address addr) {
431         if (addr == null) return 0;
432         return ((ProcAddress) addr).getValue();
433     }
434 
435     /** From the ProcDebugger interface */
436     public Address newAddress(long value) {
437         if (value == 0) return null;
438         return new ProcAddress(this, value);
439     }
440 
441     /** From the ProcDebugger interface */
<span class="line-modified">442     public synchronized List&lt;ThreadProxy&gt; getThreadList() throws DebuggerException {</span>
443         requireAttach();
<span class="line-modified">444         List&lt;ThreadProxy&gt; res = null;</span>
445         if (isCore &amp;&amp; (threadListCache != null)) {
446             res = threadListCache;
447         } else {
<span class="line-modified">448             res = new ArrayList&lt;&gt;();</span>
449             fillThreadList0(res);
450             if (isCore) {
451                 threadListCache = res;
452             }
453         }
454         return res;
455     }
456 
457     /** From the ProcDebugger interface */
<span class="line-modified">458     public synchronized List&lt;LoadObject&gt; getLoadObjectList() throws DebuggerException {</span>
459         requireAttach();
460         if (!suspended) {
461             throw new DebuggerException(&quot;Process not suspended&quot;);
462         }
463 
464         if (loadObjectCache == null) {
465             updateLoadObjectCache();
466         }
467         return loadObjectCache;
468     }
469 
470     /** From the ProcDebugger interface */
471     public synchronized CFrame topFrameForThread(ThreadProxy thread)
472     throws DebuggerException {
473         requireAttach();
474         CFrame res = null;
475         if (isCore &amp;&amp; ((res = (CFrame) topFrameCache.get(thread)) != null)) {
476             return res;
477         } else {
478             ThreadContext context = thread.getContext();
</pre>
<hr />
<pre>
488             return res;
489         }
490     }
491 
492     /** From the ProcDebugger interface */
493     public synchronized ClosestSymbol lookup(long address) {
494         requireAttach();
495         return lookupByAddress0(address);
496     }
497 
498     /** From the ProcDebugger interface */
499     public String demangle(String name) {
500         return demangle0(name);
501     }
502 
503     //------------- Internals only below this point --------------------
504     //
505     //
506 
507     private void updateLoadObjectCache() {
<span class="line-modified">508         List&lt;LoadObject&gt; res = new ArrayList&lt;&gt;();</span>
<span class="line-modified">509         nameToDsoMap = new HashMap&lt;&gt;();</span>
510         fillLoadObjectList0(res);
511         loadObjectCache = sortLoadObjects(res);
512     }
513 
514     // sort load objects by base address
<span class="line-modified">515     private static List&lt;LoadObject&gt; sortLoadObjects(List&lt;LoadObject&gt; in) {</span>
516         // sort the list by base address
<span class="line-modified">517         LoadObject[] arr = in.toArray(new LoadObject[0]);</span>
518         Arrays.sort(arr, loadObjectComparator);
519         return Arrays.asList(arr);
520     }
521 
522     private long lookupByName(String objectName, String symbolName)
523     throws DebuggerException {
524         // NOTE: this assumes that process is suspended (which is probably
525         // necessary assumption given that DSOs can be loaded/unloaded as
526         // process runs). Should update documentation.
527         if (nameToDsoMap == null) {
528             getLoadObjectList();
529         }
530         SharedObject dso = (SharedObject) nameToDsoMap.get(objectName);
531         // The DSO can be null because we use this to search through known
532         // DSOs in HotSpotTypeDataBase (for example)
533         if (dso != null) {
534             ProcAddress addr = (ProcAddress) dso.lookupSymbol(symbolName);
535             if (addr != null) {
536                 return addr.getValue();
537             }
</pre>
<hr />
<pre>
597         p_td_thr_getgregs      = 0L;
598 
599         // part of class sharing workaround
600         classes_jsa_fd         = -1;
601         p_file_map_header      = 0L;
602     }
603 
604     // native methods and native helpers
605 
606     // attach, detach
607     private native void attach0(String pid) throws DebuggerException;
608     private native void attach0(String executableFile, String coreFileName) throws DebuggerException;
609     private native void detach0() throws DebuggerException;
610 
611     // address size, page size
612     private native int getRemoteProcessAddressSize0() throws DebuggerException;
613     private native int getPageSize0() throws DebuggerException;
614 
615     // threads, stacks
616     private native long[] getThreadIntegerRegisterSet0(long tid) throws DebuggerException;
<span class="line-modified">617     private native void   fillThreadList0(List&lt;ThreadProxy&gt; l) throws DebuggerException;</span>
618 
619     // fills stack frame list given reg set of the top frame and top frame
620     private native ProcCFrame fillCFrameList0(long[] regs) throws DebuggerException;
621 
622     // helper called by fillCFrameList0
623     private ProcCFrame createSenderFrame(ProcCFrame f, long pc, long fp) {
624         ProcCFrame sender = new ProcCFrame(this, newAddress(pc), newAddress(fp));
625         if (f != null) {
626             f.setSender(sender);
627         }
628         return sender;
629     }
630 
631     // shared objects
<span class="line-modified">632     private native void fillLoadObjectList0(List&lt;LoadObject&gt; l) throws DebuggerException;</span>
633 
634     // helper called by fillLoadObjectList0
635     private LoadObject createLoadObject(String fileName, long textsize, long base) {
636         File f = new File(fileName);
637         Address baseAddr = newAddress(base);
638         SharedObject res = findDSOByName(fileName);
639         if (res != null) {
640             // already in cache. just change the base, if needed
641             Address oldBase = res.getBase();
642             if (! baseAddr.equals(oldBase)) {
643                 res.setBase(baseAddr);
644             }
645         } else {
646             // new shared object.
647             res = new SharedObject(this, fileName, f.length(), baseAddr);
648         }
649         nameToDsoMap.put(f.getName(), res);
650         return res;
651     }
652 
</pre>
<hr />
<pre>
672 
673     // init JNI ids to fields, methods
674     private native static void initIDs() throws DebuggerException;
675     private static LoadObjectComparator loadObjectComparator;
676 
677     static {
678         System.loadLibrary(&quot;saproc&quot;);
679         initIDs();
680         loadObjectComparator = new LoadObjectComparator();
681     }
682 
683     private boolean unalignedAccessesOkay;
684     private ProcThreadFactory threadFactory;
685 
686     // indices of PC and FP registers in gregset
687     private int pcRegIndex;
688     private int fpRegIndex;
689 
690     // Symbol lookup support
691     // This is a map of library names to DSOs
<span class="line-modified">692     private Map&lt;String, SharedObject&gt; nameToDsoMap;</span>
693 
694     // C/C++ debugging support
<span class="line-modified">695     private List&lt;LoadObject&gt; loadObjects;</span>
696     private CDebugger cdbg;
697 
698     // ProcessControl support
699     private boolean suspended;
700 
701     // libproc handle
702     private long p_ps_prochandle;
703 
704     // libthread.so&#39;s dlopen handle, thread agent
705     // and function pointers
706     private long libthread_db_handle;
707     private long p_td_thragent_t;
708     private long p_td_init;
709     private long p_td_ta_new;
710     private long p_td_ta_delete;
711     private long p_td_ta_thr_iter;
712     private long p_td_thr_get_info;
713     private long p_td_ta_map_id2thr;
714     private long p_td_thr_getgregs;
715 
716     // part of class sharing workaround
717     private int classes_jsa_fd;
718     private long p_file_map_header;
719 
720     private boolean attached = false;
721     private boolean isCore;
722 
723     // for core files, we cache load object list, thread list, top frames etc.
724     // for processes we cache load object list and sync. it during suspend.
<span class="line-modified">725     private List&lt;ThreadProxy&gt; threadListCache;</span>
<span class="line-modified">726     private List&lt;LoadObject&gt; loadObjectCache;</span>
<span class="line-modified">727     private Map&lt;ThreadProxy, CFrame&gt; topFrameCache;</span>
728 }
</pre>
</td>
</tr>
</table>
<center><a href="ProcDebugger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../remote/RemoteDebuggerClient.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
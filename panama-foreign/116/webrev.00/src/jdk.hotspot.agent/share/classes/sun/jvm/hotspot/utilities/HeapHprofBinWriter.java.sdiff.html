<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/HeapHprofBinWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HeapGXLWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntArray.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/HeapHprofBinWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 620 
 621     private void writeClassDumpRecord(Klass k) throws IOException {
 622         out.writeByte((byte)HPROF_GC_CLASS_DUMP);
 623         writeObjectID(k.getJavaMirror());
 624         out.writeInt(DUMMY_STACK_TRACE_ID);
 625         Klass superKlass = k.getJavaSuper();
 626         if (superKlass != null) {
 627             writeObjectID(superKlass.getJavaMirror());
 628         } else {
 629             writeObjectID(null);
 630         }
 631 
 632         if (k instanceof InstanceKlass) {
 633             InstanceKlass ik = (InstanceKlass) k;
 634             writeObjectID(ik.getClassLoader());
 635             writeObjectID(null);  // ik.getJavaMirror().getSigners());
 636             writeObjectID(null);  // ik.getJavaMirror().getProtectionDomain());
 637             // two reserved id fields
 638             writeObjectID(null);
 639             writeObjectID(null);
<span class="line-modified"> 640             List fields = getInstanceFields(ik);</span>
 641             int instSize = getSizeForFields(fields);
 642             classDataCache.put(ik, new ClassData(instSize, fields));
 643             out.writeInt(instSize);
 644 
 645             // For now, ignore constant pool - HAT ignores too!
 646             // output number of cp entries as zero.
 647             out.writeShort((short) 0);
 648 
<span class="line-modified"> 649             List declaredFields = ik.getImmediateFields();</span>
<span class="line-modified"> 650             List staticFields = new ArrayList();</span>
<span class="line-modified"> 651             List instanceFields = new ArrayList();</span>
<span class="line-modified"> 652             Iterator itr = null;</span>
 653             for (itr = declaredFields.iterator(); itr.hasNext();) {
<span class="line-modified"> 654                 Field field = (Field) itr.next();</span>
 655                 if (field.isStatic()) {
 656                     staticFields.add(field);
 657                 } else {
 658                     instanceFields.add(field);
 659                 }
 660             }
 661 
 662             // dump static field descriptors
 663             writeFieldDescriptors(staticFields, ik);
 664 
 665             // dump instance field descriptors
 666             writeFieldDescriptors(instanceFields, null);
 667         } else {
 668             if (k instanceof ObjArrayKlass) {
 669                 ObjArrayKlass oak = (ObjArrayKlass) k;
 670                 Klass bottomKlass = oak.getBottomKlass();
 671                 if (bottomKlass instanceof InstanceKlass) {
 672                     InstanceKlass ik = (InstanceKlass) bottomKlass;
 673                     writeObjectID(ik.getClassLoader());
 674                     writeObjectID(null); // ik.getJavaMirror().getSigners());
</pre>
<hr />
<pre>
 938     }
 939 
 940     protected void writeInstance(Instance instance) throws IOException {
 941         Klass klass = instance.getKlass();
 942         if (klass.getClassLoaderData() == null) {
 943             // Ignoring this object since the corresponding Klass is not loaded.
 944             // Might be a dormant archive object.
 945             return;
 946         }
 947 
 948         out.writeByte((byte) HPROF_GC_INSTANCE_DUMP);
 949         writeObjectID(instance);
 950         out.writeInt(DUMMY_STACK_TRACE_ID);
 951         writeObjectID(klass.getJavaMirror());
 952 
 953         ClassData cd = (ClassData) classDataCache.get(klass);
 954 
 955         if (Assert.ASSERTS_ENABLED) {
 956             Assert.that(cd != null, &quot;can not get class data for &quot; + klass.getName().asString() + klass.getAddress());
 957         }
<span class="line-modified"> 958         List fields = cd.fields;</span>
 959         int size = cd.instSize;
 960         out.writeInt(size);
<span class="line-modified"> 961         for (Iterator itr = fields.iterator(); itr.hasNext();) {</span>
<span class="line-modified"> 962             writeField((Field) itr.next(), instance);</span>
 963         }
 964     }
 965 
 966     //-- Internals only below this point
 967 
<span class="line-modified"> 968     private void writeFieldDescriptors(List fields, InstanceKlass ik)</span>
 969         throws IOException {
 970         // ik == null for instance fields.
 971         out.writeShort((short) fields.size());
<span class="line-modified"> 972         for (Iterator itr = fields.iterator(); itr.hasNext();) {</span>
<span class="line-modified"> 973             Field field = (Field) itr.next();</span>
 974             Symbol name = field.getName();
 975             writeSymbolID(name);
 976             char typeCode = (char) field.getSignature().getByteAt(0);
 977             int kind = signatureToHprofKind(typeCode);
 978             out.writeByte((byte)kind);
 979             if (ik != null) {
 980                 // static field
 981                 writeField(field, ik.getJavaMirror());
 982             }
 983         }
 984     }
 985 
 986     public static int signatureToHprofKind(char ch) {
 987         switch (ch) {
 988         case JVM_SIGNATURE_CLASS:
 989         case JVM_SIGNATURE_ARRAY:
 990             return HPROF_NORMAL_OBJECT;
 991         case JVM_SIGNATURE_BOOLEAN:
 992             return HPROF_BOOLEAN;
 993         case JVM_SIGNATURE_CHAR:
</pre>
<hr />
<pre>
1052         }
1053     }
1054 
1055     private void writeHeader(int tag, int len) throws IOException {
1056         out.writeByte((byte)tag);
1057         out.writeInt(0); // current ticks
1058         out.writeInt(len);
1059     }
1060 
1061     private void writeDummyTrace() throws IOException {
1062         writeHeader(HPROF_TRACE, 3 * 4);
1063         out.writeInt(DUMMY_STACK_TRACE_ID);
1064         out.writeInt(0);
1065         out.writeInt(0);
1066     }
1067 
1068     private void writeClassSymbols(Klass k) throws IOException {
1069         writeSymbol(k.getName());
1070         if (k instanceof InstanceKlass) {
1071             InstanceKlass ik = (InstanceKlass) k;
<span class="line-modified">1072             List declaredFields = ik.getImmediateFields();</span>
<span class="line-modified">1073             for (Iterator itr = declaredFields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">1074                 Field field = (Field) itr.next();</span>
1075                 writeSymbol(field.getName());
1076             }
1077         }
1078     }
1079 
1080     private void writeSymbols() throws IOException {
1081         // Write all the symbols that are used by the classes
1082         ClassLoaderDataGraph cldGraph = VM.getVM().getClassLoaderDataGraph();
1083         try {
1084              cldGraph.classesDo(new ClassLoaderDataGraph.ClassVisitor() {
1085                             public void visit(Klass k) {
1086                                 try {
1087                                     writeClassSymbols(k);
1088                                 } catch (IOException e) {
1089                                     throw new RuntimeException(e);
1090                                 }
1091                             }
1092                         });
1093         } catch (RuntimeException re) {
1094             handleRuntimeException(re);
</pre>
<hr />
<pre>
1157 
1158     private void writeSymbolID(Symbol sym) throws IOException {
1159         assert names.contains(sym);
1160         long address = (sym != null) ? getAddressValue(sym.getAddress()) : getAddressValue(null);
1161         writeObjectID(address);
1162     }
1163 
1164     private void writeObjectID(long address) throws IOException {
1165         if (OBJ_ID_SIZE == 4) {
1166             out.writeInt((int) address);
1167         } else {
1168             out.writeLong(address);
1169         }
1170     }
1171 
1172     private long getAddressValue(Address addr) {
1173         return (addr == null)? 0L : dbg.getAddressValue(addr);
1174     }
1175 
1176     // get all declared as well as inherited (directly/indirectly) fields
<span class="line-modified">1177     private static List/*&lt;Field&gt;*/ getInstanceFields(InstanceKlass ik) {</span>
1178         InstanceKlass klass = ik;
<span class="line-modified">1179         List res = new ArrayList();</span>
1180         while (klass != null) {
<span class="line-modified">1181             List curFields = klass.getImmediateFields();</span>
<span class="line-modified">1182             for (Iterator itr = curFields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">1183                 Field f = (Field) itr.next();</span>
1184                 if (! f.isStatic()) {
1185                     res.add(f);
1186                 }
1187             }
1188             klass = (InstanceKlass) klass.getSuper();
1189         }
1190         return res;
1191     }
1192 
1193     // get size in bytes (in stream) required for given fields.  Note
1194     // that this is not the same as object size in heap. The size in
1195     // heap will include size of padding/alignment bytes as well.
<span class="line-modified">1196     private int getSizeForFields(List fields) {</span>
1197         int size = 0;
<span class="line-modified">1198         for (Iterator itr = fields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">1199             Field field = (Field) itr.next();</span>
1200             char typeCode = (char) field.getSignature().getByteAt(0);
1201             switch (typeCode) {
1202             case JVM_SIGNATURE_BOOLEAN:
1203             case JVM_SIGNATURE_BYTE:
1204                 size++;
1205                 break;
1206             case JVM_SIGNATURE_CHAR:
1207             case JVM_SIGNATURE_SHORT:
1208                 size += 2;
1209                 break;
1210             case JVM_SIGNATURE_INT:
1211             case JVM_SIGNATURE_FLOAT:
1212                 size += 4;
1213                 break;
1214             case JVM_SIGNATURE_CLASS:
1215             case JVM_SIGNATURE_ARRAY:
1216                 size += OBJ_ID_SIZE;
1217                 break;
1218             case JVM_SIGNATURE_LONG:
1219             case JVM_SIGNATURE_DOUBLE:
</pre>
<hr />
<pre>
1248     private long BYTE_BASE_OFFSET;
1249     private long CHAR_BASE_OFFSET;
1250     private long SHORT_BASE_OFFSET;
1251     private long INT_BASE_OFFSET;
1252     private long LONG_BASE_OFFSET;
1253     private long FLOAT_BASE_OFFSET;
1254     private long DOUBLE_BASE_OFFSET;
1255     private long OBJECT_BASE_OFFSET;
1256 
1257     private long BOOLEAN_SIZE;
1258     private long BYTE_SIZE;
1259     private long CHAR_SIZE;
1260     private long SHORT_SIZE;
1261     private long INT_SIZE;
1262     private long LONG_SIZE;
1263     private long FLOAT_SIZE;
1264     private long DOUBLE_SIZE;
1265 
1266     private static class ClassData {
1267         int instSize;
<span class="line-modified">1268         List fields;</span>
1269 
<span class="line-modified">1270         ClassData(int instSize, List fields) {</span>
1271             this.instSize = instSize;
1272             this.fields = fields;
1273         }
1274     }
1275 
<span class="line-modified">1276     private Map classDataCache = new HashMap(); // &lt;InstanceKlass, ClassData&gt;</span>
1277 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 620 
 621     private void writeClassDumpRecord(Klass k) throws IOException {
 622         out.writeByte((byte)HPROF_GC_CLASS_DUMP);
 623         writeObjectID(k.getJavaMirror());
 624         out.writeInt(DUMMY_STACK_TRACE_ID);
 625         Klass superKlass = k.getJavaSuper();
 626         if (superKlass != null) {
 627             writeObjectID(superKlass.getJavaMirror());
 628         } else {
 629             writeObjectID(null);
 630         }
 631 
 632         if (k instanceof InstanceKlass) {
 633             InstanceKlass ik = (InstanceKlass) k;
 634             writeObjectID(ik.getClassLoader());
 635             writeObjectID(null);  // ik.getJavaMirror().getSigners());
 636             writeObjectID(null);  // ik.getJavaMirror().getProtectionDomain());
 637             // two reserved id fields
 638             writeObjectID(null);
 639             writeObjectID(null);
<span class="line-modified"> 640             List&lt;Field&gt; fields = getInstanceFields(ik);</span>
 641             int instSize = getSizeForFields(fields);
 642             classDataCache.put(ik, new ClassData(instSize, fields));
 643             out.writeInt(instSize);
 644 
 645             // For now, ignore constant pool - HAT ignores too!
 646             // output number of cp entries as zero.
 647             out.writeShort((short) 0);
 648 
<span class="line-modified"> 649             List&lt;Field&gt; declaredFields = ik.getImmediateFields();</span>
<span class="line-modified"> 650             List&lt;Field&gt; staticFields = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 651             List&lt;Field&gt; instanceFields = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 652             Iterator&lt;Field&gt; itr = null;</span>
 653             for (itr = declaredFields.iterator(); itr.hasNext();) {
<span class="line-modified"> 654                 Field field = itr.next();</span>
 655                 if (field.isStatic()) {
 656                     staticFields.add(field);
 657                 } else {
 658                     instanceFields.add(field);
 659                 }
 660             }
 661 
 662             // dump static field descriptors
 663             writeFieldDescriptors(staticFields, ik);
 664 
 665             // dump instance field descriptors
 666             writeFieldDescriptors(instanceFields, null);
 667         } else {
 668             if (k instanceof ObjArrayKlass) {
 669                 ObjArrayKlass oak = (ObjArrayKlass) k;
 670                 Klass bottomKlass = oak.getBottomKlass();
 671                 if (bottomKlass instanceof InstanceKlass) {
 672                     InstanceKlass ik = (InstanceKlass) bottomKlass;
 673                     writeObjectID(ik.getClassLoader());
 674                     writeObjectID(null); // ik.getJavaMirror().getSigners());
</pre>
<hr />
<pre>
 938     }
 939 
 940     protected void writeInstance(Instance instance) throws IOException {
 941         Klass klass = instance.getKlass();
 942         if (klass.getClassLoaderData() == null) {
 943             // Ignoring this object since the corresponding Klass is not loaded.
 944             // Might be a dormant archive object.
 945             return;
 946         }
 947 
 948         out.writeByte((byte) HPROF_GC_INSTANCE_DUMP);
 949         writeObjectID(instance);
 950         out.writeInt(DUMMY_STACK_TRACE_ID);
 951         writeObjectID(klass.getJavaMirror());
 952 
 953         ClassData cd = (ClassData) classDataCache.get(klass);
 954 
 955         if (Assert.ASSERTS_ENABLED) {
 956             Assert.that(cd != null, &quot;can not get class data for &quot; + klass.getName().asString() + klass.getAddress());
 957         }
<span class="line-modified"> 958         List&lt;Field&gt; fields = cd.fields;</span>
 959         int size = cd.instSize;
 960         out.writeInt(size);
<span class="line-modified"> 961         for (Iterator&lt;Field&gt; itr = fields.iterator(); itr.hasNext();) {</span>
<span class="line-modified"> 962             writeField(itr.next(), instance);</span>
 963         }
 964     }
 965 
 966     //-- Internals only below this point
 967 
<span class="line-modified"> 968     private void writeFieldDescriptors(List&lt;Field&gt; fields, InstanceKlass ik)</span>
 969         throws IOException {
 970         // ik == null for instance fields.
 971         out.writeShort((short) fields.size());
<span class="line-modified"> 972         for (Iterator&lt;Field&gt; itr = fields.iterator(); itr.hasNext();) {</span>
<span class="line-modified"> 973             Field field = itr.next();</span>
 974             Symbol name = field.getName();
 975             writeSymbolID(name);
 976             char typeCode = (char) field.getSignature().getByteAt(0);
 977             int kind = signatureToHprofKind(typeCode);
 978             out.writeByte((byte)kind);
 979             if (ik != null) {
 980                 // static field
 981                 writeField(field, ik.getJavaMirror());
 982             }
 983         }
 984     }
 985 
 986     public static int signatureToHprofKind(char ch) {
 987         switch (ch) {
 988         case JVM_SIGNATURE_CLASS:
 989         case JVM_SIGNATURE_ARRAY:
 990             return HPROF_NORMAL_OBJECT;
 991         case JVM_SIGNATURE_BOOLEAN:
 992             return HPROF_BOOLEAN;
 993         case JVM_SIGNATURE_CHAR:
</pre>
<hr />
<pre>
1052         }
1053     }
1054 
1055     private void writeHeader(int tag, int len) throws IOException {
1056         out.writeByte((byte)tag);
1057         out.writeInt(0); // current ticks
1058         out.writeInt(len);
1059     }
1060 
1061     private void writeDummyTrace() throws IOException {
1062         writeHeader(HPROF_TRACE, 3 * 4);
1063         out.writeInt(DUMMY_STACK_TRACE_ID);
1064         out.writeInt(0);
1065         out.writeInt(0);
1066     }
1067 
1068     private void writeClassSymbols(Klass k) throws IOException {
1069         writeSymbol(k.getName());
1070         if (k instanceof InstanceKlass) {
1071             InstanceKlass ik = (InstanceKlass) k;
<span class="line-modified">1072             List&lt;Field&gt; declaredFields = ik.getImmediateFields();</span>
<span class="line-modified">1073             for (Iterator&lt;Field&gt; itr = declaredFields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">1074                 Field field = itr.next();</span>
1075                 writeSymbol(field.getName());
1076             }
1077         }
1078     }
1079 
1080     private void writeSymbols() throws IOException {
1081         // Write all the symbols that are used by the classes
1082         ClassLoaderDataGraph cldGraph = VM.getVM().getClassLoaderDataGraph();
1083         try {
1084              cldGraph.classesDo(new ClassLoaderDataGraph.ClassVisitor() {
1085                             public void visit(Klass k) {
1086                                 try {
1087                                     writeClassSymbols(k);
1088                                 } catch (IOException e) {
1089                                     throw new RuntimeException(e);
1090                                 }
1091                             }
1092                         });
1093         } catch (RuntimeException re) {
1094             handleRuntimeException(re);
</pre>
<hr />
<pre>
1157 
1158     private void writeSymbolID(Symbol sym) throws IOException {
1159         assert names.contains(sym);
1160         long address = (sym != null) ? getAddressValue(sym.getAddress()) : getAddressValue(null);
1161         writeObjectID(address);
1162     }
1163 
1164     private void writeObjectID(long address) throws IOException {
1165         if (OBJ_ID_SIZE == 4) {
1166             out.writeInt((int) address);
1167         } else {
1168             out.writeLong(address);
1169         }
1170     }
1171 
1172     private long getAddressValue(Address addr) {
1173         return (addr == null)? 0L : dbg.getAddressValue(addr);
1174     }
1175 
1176     // get all declared as well as inherited (directly/indirectly) fields
<span class="line-modified">1177     private static List&lt;Field&gt; getInstanceFields(InstanceKlass ik) {</span>
1178         InstanceKlass klass = ik;
<span class="line-modified">1179         List&lt;Field&gt; res = new ArrayList&lt;&gt;();</span>
1180         while (klass != null) {
<span class="line-modified">1181             List&lt;Field&gt; curFields = klass.getImmediateFields();</span>
<span class="line-modified">1182             for (Iterator&lt;Field&gt; itr = curFields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">1183                 Field f = itr.next();</span>
1184                 if (! f.isStatic()) {
1185                     res.add(f);
1186                 }
1187             }
1188             klass = (InstanceKlass) klass.getSuper();
1189         }
1190         return res;
1191     }
1192 
1193     // get size in bytes (in stream) required for given fields.  Note
1194     // that this is not the same as object size in heap. The size in
1195     // heap will include size of padding/alignment bytes as well.
<span class="line-modified">1196     private int getSizeForFields(List&lt;Field&gt; fields) {</span>
1197         int size = 0;
<span class="line-modified">1198         for (Iterator&lt;Field&gt; itr = fields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">1199             Field field = itr.next();</span>
1200             char typeCode = (char) field.getSignature().getByteAt(0);
1201             switch (typeCode) {
1202             case JVM_SIGNATURE_BOOLEAN:
1203             case JVM_SIGNATURE_BYTE:
1204                 size++;
1205                 break;
1206             case JVM_SIGNATURE_CHAR:
1207             case JVM_SIGNATURE_SHORT:
1208                 size += 2;
1209                 break;
1210             case JVM_SIGNATURE_INT:
1211             case JVM_SIGNATURE_FLOAT:
1212                 size += 4;
1213                 break;
1214             case JVM_SIGNATURE_CLASS:
1215             case JVM_SIGNATURE_ARRAY:
1216                 size += OBJ_ID_SIZE;
1217                 break;
1218             case JVM_SIGNATURE_LONG:
1219             case JVM_SIGNATURE_DOUBLE:
</pre>
<hr />
<pre>
1248     private long BYTE_BASE_OFFSET;
1249     private long CHAR_BASE_OFFSET;
1250     private long SHORT_BASE_OFFSET;
1251     private long INT_BASE_OFFSET;
1252     private long LONG_BASE_OFFSET;
1253     private long FLOAT_BASE_OFFSET;
1254     private long DOUBLE_BASE_OFFSET;
1255     private long OBJECT_BASE_OFFSET;
1256 
1257     private long BOOLEAN_SIZE;
1258     private long BYTE_SIZE;
1259     private long CHAR_SIZE;
1260     private long SHORT_SIZE;
1261     private long INT_SIZE;
1262     private long LONG_SIZE;
1263     private long FLOAT_SIZE;
1264     private long DOUBLE_SIZE;
1265 
1266     private static class ClassData {
1267         int instSize;
<span class="line-modified">1268         List&lt;Field&gt; fields;</span>
1269 
<span class="line-modified">1270         ClassData(int instSize, List&lt;Field&gt; fields) {</span>
1271             this.instSize = instSize;
1272             this.fields = fields;
1273         }
1274     }
1275 
<span class="line-modified">1276     private Map&lt;InstanceKlass, ClassData&gt; classDataCache = new HashMap&lt;&gt;();</span>
1277 }
</pre>
</td>
</tr>
</table>
<center><a href="HeapGXLWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntArray.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
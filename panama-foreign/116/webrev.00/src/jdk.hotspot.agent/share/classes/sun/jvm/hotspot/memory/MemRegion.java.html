<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/memory/MemRegion.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.memory;
 26 
 27 import java.util.*;
 28 
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.runtime.*;
 31 import sun.jvm.hotspot.types.*;
 32 import sun.jvm.hotspot.utilities.*;
 33 import sun.jvm.hotspot.utilities.Observable;
 34 import sun.jvm.hotspot.utilities.Observer;
 35 
 36 /** A very simple data structure representing a contigous region of
 37     address space. */
 38 
 39 public class MemRegion implements Cloneable {
 40   private Address start;
 41   private long byteSize;
 42 
 43   private static AddressField  startField;
 44   private static CIntegerField wordSizeField;
 45 
 46   static {
 47     VM.registerVMInitializedObserver(new Observer() {
 48         public void update(Observable o, Object data) {
 49           initialize(VM.getVM().getTypeDataBase());
 50         }
 51       });
 52   }
 53 
 54   private static synchronized void initialize(TypeDataBase db) {
 55     Type type = db.lookupType(&quot;MemRegion&quot;);
 56 
 57     startField    = type.getAddressField(&quot;_start&quot;);
 58     wordSizeField = type.getCIntegerField(&quot;_word_size&quot;);
 59   }
 60 
 61   public MemRegion() {
 62   }
 63 
 64   /** This constructor takes a &quot;MemRegion*&quot; in the target process */
 65   public MemRegion(Address memRegionAddr) {
 66     this(startField.getValue(memRegionAddr),
 67          wordSizeField.getValue(memRegionAddr));
 68   }
 69 
 70   public MemRegion(Address start, long wordSize) {
 71     setStart(start);
 72     setWordSize(wordSize);
 73   }
 74 
 75   public MemRegion(Address start, Address limit) {
 76     setStart(start);
 77     byteSize = limit.minus(start);
 78   }
 79 
 80   public Object clone() {
 81     return new MemRegion(start, byteSize);
 82   }
 83 
 84   public MemRegion copy() {
 85     return (MemRegion) clone();
 86   }
 87 
 88   public MemRegion intersection(MemRegion mr2) {
 89     MemRegion res = new MemRegion();
 90     if (AddressOps.gt(mr2.start(), start())) {
 91       res.setStart(mr2.start());
 92     } else {
 93       res.setStart(start());
 94     }
 95     Address resEnd;
 96     Address end = end();
 97     Address mr2End = mr2.end();
 98     if (AddressOps.lt(end, mr2End)) {
 99       resEnd = end;
100     } else {
101       resEnd = mr2End;
102     }
103     if (AddressOps.lt(resEnd, res.start())) {
104       res.setStart(null);
105       res.setWordSize(0);
106     } else {
107       res.setEnd(resEnd);
108     }
109     return res;
110   }
111 
112   public MemRegion union(MemRegion mr2) {
113     MemRegion res = new MemRegion();
114     if (AddressOps.lt(mr2.start(), start())) {
115       res.setStart(mr2.start());
116     } else {
117       res.setStart(start());
118     }
119     Address resEnd;
120     Address end = end();
121     Address mr2End = mr2.end();
122     if (AddressOps.gt(end, mr2End)) {
123       resEnd = end;
124     } else {
125       resEnd = mr2End;
126     }
127     res.setEnd(resEnd);
128     return res;
129   }
130 
131   public Address start() {
132     return start;
133   }
134 
135   public OopHandle startAsOopHandle() {
136     return start().addOffsetToAsOopHandle(0);
137   }
138 
139   public Address end() {
140     return start.addOffsetTo(byteSize);
141   }
142 
143   public OopHandle endAsOopHandle() {
144     return end().addOffsetToAsOopHandle(0);
145   }
146 
147   public void setStart(Address start) {
148     this.start = start;
149   }
150 
151   public void setEnd(Address end) {
152     byteSize = end.minus(start);
153   }
154 
155   public void setWordSize(long wordSize) {
156     byteSize = VM.getVM().getAddressSize() * wordSize;
157   }
158 
159   public boolean contains(MemRegion mr2) {
160     return AddressOps.lte(start, mr2.start) &amp;&amp; AddressOps.gte(end(), mr2.end());
161   }
162 
163   public boolean contains(Address addr) {
164     return AddressOps.gte(addr, start()) &amp;&amp; AddressOps.lt(addr, end());
165   }
166 
167   public long byteSize() {
168     return byteSize;
169   }
170 
171   public long wordSize() {
172     return byteSize / VM.getVM().getAddressSize();
173   }
174 }
    </pre>
  </body>
</html>
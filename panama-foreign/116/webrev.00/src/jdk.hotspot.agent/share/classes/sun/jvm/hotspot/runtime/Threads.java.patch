diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -39,10 +39,12 @@
 import sun.jvm.hotspot.runtime.linux_ppc64.LinuxPPC64JavaThreadPDAccess;
 import sun.jvm.hotspot.runtime.linux_sparc.LinuxSPARCJavaThreadPDAccess;
 import sun.jvm.hotspot.runtime.bsd_x86.BsdX86JavaThreadPDAccess;
 import sun.jvm.hotspot.runtime.bsd_amd64.BsdAMD64JavaThreadPDAccess;
 import sun.jvm.hotspot.utilities.*;
+import sun.jvm.hotspot.utilities.Observable;
+import sun.jvm.hotspot.utilities.Observer;
 
 class ThreadsList extends VMObject {
     private static AddressField  threadsField;
     private static CIntegerField lengthField;
 
@@ -124,11 +126,11 @@
             } else {
               try {
                 access = (JavaThreadPDAccess)
                   Class.forName("sun.jvm.hotspot.runtime.linux_" +
                      cpu.toLowerCase() + ".Linux" + cpu.toUpperCase() +
-                     "JavaThreadPDAccess").newInstance();
+                     "JavaThreadPDAccess").getDeclaredConstructor().newInstance();
               } catch (Exception e) {
                 throw new RuntimeException("OS/CPU combination " + os + "/" + cpu +
                                            " not yet supported");
               }
             }
@@ -233,12 +235,12 @@
         return owningThreadFromMonitor(monitor.owner());
     }
 
     // refer to Threads::get_pending_threads
     // Get list of Java threads that are waiting to enter the specified monitor.
-    public List getPendingThreads(ObjectMonitor monitor) {
-        List pendingThreads = new ArrayList();
+    public List<JavaThread> getPendingThreads(ObjectMonitor monitor) {
+        List<JavaThread> pendingThreads = new ArrayList<>();
         for (int i = 0; i < getNumberOfThreads(); i++) {
             JavaThread thread = getJavaThreadAt(i);
             if (thread.isCompilerThread() || thread.isCodeCacheSweeperThread()) {
                 continue;
             }
@@ -249,12 +251,12 @@
         }
         return pendingThreads;
     }
 
     // Get list of Java threads that have called Object.wait on the specified monitor.
-    public List getWaitingThreads(ObjectMonitor monitor) {
-        List pendingThreads = new ArrayList();
+    public List<JavaThread> getWaitingThreads(ObjectMonitor monitor) {
+        List<JavaThread> pendingThreads = new ArrayList<>();
         for (int i = 0; i < getNumberOfThreads(); i++) {
             JavaThread thread = getJavaThreadAt(i);
             ObjectMonitor waiting = thread.getCurrentWaitingMonitor();
             if (monitor.equals(waiting)) {
                 pendingThreads.add(thread);

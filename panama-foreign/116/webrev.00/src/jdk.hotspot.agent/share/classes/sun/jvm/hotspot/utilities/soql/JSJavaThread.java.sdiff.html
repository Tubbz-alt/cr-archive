<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/soql/JSJavaThread.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSJavaScriptEngine.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSJavaTypeArrayKlass.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/soql/JSJavaThread.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2009, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 80         res[flds.length] = &quot;frames&quot;;
 81         res[flds.length + 1] = &quot;monitors&quot;;
 82         return res;
 83     }
 84 
 85     protected boolean hasField(String name) {
 86         if (name.equals(&quot;frames&quot;) || name.equals(&quot;monitors&quot;)) {
 87             return true;
 88         } else {
 89             return super.hasField(name);
 90         }
 91     }
 92 
 93     //-- Internals only below this point
 94     private String getName() {
 95         return OopUtilities.threadOopGetName(getOop());
 96     }
 97 
 98     private synchronized JSList getFrames() {
 99         if (framesCache == null) {
<span class="line-modified">100             final List list = new ArrayList(0);</span>
101             if (jthread != null) {
102                 JavaVFrame jvf = jthread.getLastJavaVFrameDbg();
103                 while (jvf != null) {
104                     list.add(jvf);
105                     jvf = jvf.javaSender();
106                 }
107             }
108             framesCache = factory.newJSList(list);
109         }
110         return framesCache;
111     }
112 
113     private synchronized JSList getOwnedMonitors() {
114         if (monitorsCache == null) {
<span class="line-modified">115             final List ownedMonitors = new ArrayList(0);</span>
116             if (jthread != null) {
<span class="line-modified">117                 List lockedObjects = new ArrayList(); // List&lt;OopHandle&gt;</span>
118 
119                 ObjectMonitor waitingMonitor = jthread.getCurrentWaitingMonitor();
120                 OopHandle waitingObj = null;
121                 if (waitingMonitor != null) {
122                    // save object of current wait() call (if any) for later comparison
123                    waitingObj = waitingMonitor.object();
124                 }
125 
126                 ObjectMonitor pendingMonitor = jthread.getCurrentPendingMonitor();
127                 OopHandle pendingObj = null;
128                 if (pendingMonitor != null) {
129                     // save object of current enter() call (if any) for later comparison
130                     pendingObj = pendingMonitor.object();
131                 }
132 
133                 JavaVFrame frame = jthread.getLastJavaVFrameDbg();
134                 while (frame != null) {
<span class="line-modified">135                     List frameMonitors = frame.getMonitors();  // List&lt;MonitorInfo&gt;</span>
<span class="line-modified">136                     for (Iterator miItr = frameMonitors.iterator(); miItr.hasNext(); ) {</span>
<span class="line-modified">137                         MonitorInfo mi = (MonitorInfo) miItr.next();</span>
138 
139                         if (mi.eliminated() &amp;&amp; frame.isCompiledFrame()) {
140                           continue; // skip eliminated monitor
141                         }
142                         OopHandle obj = mi.owner();
143                         if (obj == null) {
144                             // this monitor doesn&#39;t have an owning object so skip it
145                             continue;
146                         }
147 
148                         if (obj.equals(waitingObj)) {
149                            // the thread is waiting on this monitor so it isn&#39;t really owned
150                            continue;
151                         }
152 
153                         if (obj.equals(pendingObj)) {
154                             // the thread is pending on this monitor so it isn&#39;t really owned
155                             continue;
156                         }
157 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 80         res[flds.length] = &quot;frames&quot;;
 81         res[flds.length + 1] = &quot;monitors&quot;;
 82         return res;
 83     }
 84 
 85     protected boolean hasField(String name) {
 86         if (name.equals(&quot;frames&quot;) || name.equals(&quot;monitors&quot;)) {
 87             return true;
 88         } else {
 89             return super.hasField(name);
 90         }
 91     }
 92 
 93     //-- Internals only below this point
 94     private String getName() {
 95         return OopUtilities.threadOopGetName(getOop());
 96     }
 97 
 98     private synchronized JSList getFrames() {
 99         if (framesCache == null) {
<span class="line-modified">100             final List&lt;JavaVFrame&gt; list = new ArrayList&lt;&gt;(0);</span>
101             if (jthread != null) {
102                 JavaVFrame jvf = jthread.getLastJavaVFrameDbg();
103                 while (jvf != null) {
104                     list.add(jvf);
105                     jvf = jvf.javaSender();
106                 }
107             }
108             framesCache = factory.newJSList(list);
109         }
110         return framesCache;
111     }
112 
113     private synchronized JSList getOwnedMonitors() {
114         if (monitorsCache == null) {
<span class="line-modified">115             final List&lt;Oop&gt; ownedMonitors = new ArrayList&lt;&gt;(0);</span>
116             if (jthread != null) {
<span class="line-modified">117                 List&lt;OopHandle&gt; lockedObjects = new ArrayList&lt;&gt;();</span>
118 
119                 ObjectMonitor waitingMonitor = jthread.getCurrentWaitingMonitor();
120                 OopHandle waitingObj = null;
121                 if (waitingMonitor != null) {
122                    // save object of current wait() call (if any) for later comparison
123                    waitingObj = waitingMonitor.object();
124                 }
125 
126                 ObjectMonitor pendingMonitor = jthread.getCurrentPendingMonitor();
127                 OopHandle pendingObj = null;
128                 if (pendingMonitor != null) {
129                     // save object of current enter() call (if any) for later comparison
130                     pendingObj = pendingMonitor.object();
131                 }
132 
133                 JavaVFrame frame = jthread.getLastJavaVFrameDbg();
134                 while (frame != null) {
<span class="line-modified">135                     List&lt;MonitorInfo&gt; frameMonitors = frame.getMonitors();</span>
<span class="line-modified">136                     for (Iterator&lt;MonitorInfo&gt; miItr = frameMonitors.iterator(); miItr.hasNext(); ) {</span>
<span class="line-modified">137                         MonitorInfo mi = miItr.next();</span>
138 
139                         if (mi.eliminated() &amp;&amp; frame.isCompiledFrame()) {
140                           continue; // skip eliminated monitor
141                         }
142                         OopHandle obj = mi.owner();
143                         if (obj == null) {
144                             // this monitor doesn&#39;t have an owning object so skip it
145                             continue;
146                         }
147 
148                         if (obj.equals(waitingObj)) {
149                            // the thread is waiting on this monitor so it isn&#39;t really owned
150                            continue;
151                         }
152 
153                         if (obj.equals(pendingObj)) {
154                             // the thread is pending on this monitor so it isn&#39;t really owned
155                             continue;
156                         }
157 
</pre>
</td>
</tr>
</table>
<center><a href="JSJavaScriptEngine.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSJavaTypeArrayKlass.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
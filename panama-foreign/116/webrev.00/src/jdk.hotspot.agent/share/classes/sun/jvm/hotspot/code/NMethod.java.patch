diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/code/NMethod.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/code/NMethod.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/code/NMethod.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/code/NMethod.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -29,10 +29,12 @@
 import sun.jvm.hotspot.debugger.*;
 import sun.jvm.hotspot.oops.*;
 import sun.jvm.hotspot.runtime.*;
 import sun.jvm.hotspot.types.*;
 import sun.jvm.hotspot.utilities.*;
+import sun.jvm.hotspot.utilities.Observable;
+import sun.jvm.hotspot.utilities.Observer;
 
 public class NMethod extends CompiledMethod {
   private static long          pcDescSize;
   /** != InvocationEntryBci if this nmethod is an on-stack replacement method */
   private static CIntegerField entryBCIField;
@@ -414,12 +416,12 @@
     PCDesc pd = getPCDescNearDbg(pc);
     if (pd == null) return null;
     return new ScopeDesc(this, pd.getScopeDecodeOffset(), pd.getObjDecodeOffset(), pd.getReexecute());
   }
 
-  public Map/*<Address, PCDesc>*/ getSafepoints() {
-    Map safepoints = new HashMap(); // Map<Address, PCDesc>
+  public Map<sun.jvm.hotspot.debugger.Address, PCDesc> getSafepoints() {
+    Map<sun.jvm.hotspot.debugger.Address, PCDesc> safepoints = new HashMap<>();
     sun.jvm.hotspot.debugger.Address p = null;
     for (p = scopesPCsBegin(); p.lessThan(scopesPCsEnd());
          p = p.addOffsetTo(pcDescSize)) {
        PCDesc pcDesc = new PCDesc(p);
        sun.jvm.hotspot.debugger.Address pc = pcDesc.getRealPC(this);
@@ -472,11 +474,11 @@
            method.getName().asString() +
            method.getSignature().asString();
   }
 
   public void dumpReplayData(PrintStream out) {
-    HashMap h = new HashMap();
+    HashMap<Metadata, Metadata> h = new HashMap<>();
     for (int i = 1; i < getMetadataLength(); i++) {
       Metadata meta = Metadata.instantiateWrapperFor(getMetadataAt(i));
       System.err.println(meta);
       if (h.get(meta) != null) continue;
       h.put(meta, meta);

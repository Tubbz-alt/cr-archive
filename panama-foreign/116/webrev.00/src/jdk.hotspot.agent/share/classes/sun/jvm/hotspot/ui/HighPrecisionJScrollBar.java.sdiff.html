<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/ui/HighPrecisionJScrollBar.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FindInHeapPanel.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HistoryComboBox.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/ui/HighPrecisionJScrollBar.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 34     minimum, maximum, unit increment, etc. Interaction with the
 35     buttons and track is accurate to unit and block increments;
 36     however, if the scale of the scrollbar (defined by
 37     getMaximumHP().subtract(getMinimumHP())) is very large, each
 38     interaction with the thumb will necessarily cause extremely large
 39     motion of the value. */
 40 
 41 public class HighPrecisionJScrollBar extends JScrollBar {
 42   private BigInteger valueHP;
 43   private BigInteger visibleHP;
 44   private BigInteger minimumHP;
 45   private BigInteger maximumHP;
 46   private BigInteger unitIncrementHP;
 47   private BigInteger blockIncrementHP;
 48   private BigDecimal scaleFactor;
 49   private BigInteger rangeHP;
 50   // The underlying scrollbar runs a range from 0..BIG_RANGE-1
 51   private static final int BIG_RANGE = 10000;
 52   // Do we need to scale HP values up/down to fit in 0..BIG_RANGE-1?
 53   private boolean    down;
<span class="line-modified"> 54   private java.util.List changeListeners = new ArrayList();</span>
 55   // Number of digits after decimal point to use when scaling between
 56   // high and low precision
 57   private static final int SCALE = 20;
 58 
 59 
 60   // This is a hack to allow us to differentiate between clicks on the
 61   // arrow and track since we can&#39;t get useful information from
 62   // JScrollBars&#39; AdjustmentListener (bug in design of BasicUI
 63   // classes; FIXME: file RFE.)
 64   private static final int UNIT_INCREMENT  = 1;
 65   private static final int BLOCK_INCREMENT = 2;
 66   private static final int MINIMUM = 0;
 67   private static final int MAXIMUM = 65536;
 68   private boolean updating = false;
 69   private int lastValueSeen = -1;
 70 
 71   public HighPrecisionJScrollBar() {
 72     super();
 73     initialize();
 74     installListener();
</pre>
<hr />
<pre>
243     setVisibleAmountHP(new BigInteger(Integer.toString(getVisibleAmount())));
244     setValueHP(value);
245   }
246 
247   private void initialize() {
248     BigInteger min = new BigInteger(Integer.toString(getMinimum()));
249     BigInteger max = new BigInteger(Integer.toString(getMaximum()));
250     initialize(min, min, max);
251   }
252 
253   private void setRange(BigInteger minimum, BigInteger maximum) {
254     if (minimum.compareTo(maximum) &gt; 0 ) {
255       throw new RuntimeException(&quot;Bad scrollbar range &quot; + minimum + &quot; &gt; &quot; + maximum);
256     }
257     minimumHP = minimum;
258     maximumHP = maximum;
259     rangeHP = maximum.subtract(minimum).add(BigInteger.ONE);
260     BigInteger range2 = new BigInteger(Integer.toString(BIG_RANGE));
261     if (rangeHP.compareTo(range2) &gt;= 0 ) {
262       down = true;
<span class="line-modified">263       scaleFactor = new BigDecimal(rangeHP, SCALE).divide(new BigDecimal(range2, SCALE), BigDecimal.ROUND_DOWN).max(new BigDecimal(BigInteger.ONE));</span>
264     } else {
265       down = false;
<span class="line-modified">266       scaleFactor = new BigDecimal(range2, SCALE).divide(new BigDecimal(rangeHP, SCALE), BigDecimal.ROUND_DOWN).max(new BigDecimal(BigInteger.ONE));</span>
267     }
268     // FIXME: should put in original scaling algorithm (shifting by
269     // number of bits) as alternative when scale between low and high
270     // precision is very large
271   }
272 
273   // A range update is complete. Rescale our computed values and
274   // inform the underlying scrollBar as needed.
275   private void updateScrollBarValues() {
276     setValueHP(getValueHP());
277     setVisibleAmountHP(getVisibleAmountHP());
278     setBlockIncrementHP(getBlockIncrementHP());
279     setUnitIncrementHP(getUnitIncrementHP());
280   }
281 
282   private BigDecimal getScaleFactor() {
283     return scaleFactor;
284   }
285 
286 
287   // Value scaling routines
288   private BigInteger scaleToHP(int i) {
289     BigDecimal ib = new BigDecimal(Integer.toString(i));
290     if (down) return ib.multiply(getScaleFactor()).toBigInteger();
<span class="line-modified">291     else return ib.divide(getScaleFactor(), BigDecimal.ROUND_DOWN).toBigInteger();</span>
292   }
293 
294   private int scaleToUnderlying(BigInteger i) {
295     BigDecimal d = new BigDecimal(i);
<span class="line-modified">296     if (down) return d.divide(getScaleFactor(), BigDecimal.ROUND_DOWN).intValue();</span>
297     else return d.multiply(getScaleFactor()).intValue();
298   }
299 
300   // Range scaling routines
301   private BigInteger toHPRange(int i) {
302     return scaleToHP(i).add(minimumHP);
303     // return ib.shiftLeft(Math.max(2, maximumHP.bitLength() - 33));
304   }
305 
306   private int toUnderlyingRange(BigInteger i) {
307     return scaleToUnderlying(i.subtract(minimumHP));
308     // return i.shiftRight(Math.max(2, maximumHP.bitLength() - 33)).intValue();
309   }
310 
311   private void installListener() {
312     super.addAdjustmentListener(new AdjustmentListener() {
313         public void adjustmentValueChanged(AdjustmentEvent e) {
314           if (updating) {
315             return;
316           }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 34     minimum, maximum, unit increment, etc. Interaction with the
 35     buttons and track is accurate to unit and block increments;
 36     however, if the scale of the scrollbar (defined by
 37     getMaximumHP().subtract(getMinimumHP())) is very large, each
 38     interaction with the thumb will necessarily cause extremely large
 39     motion of the value. */
 40 
 41 public class HighPrecisionJScrollBar extends JScrollBar {
 42   private BigInteger valueHP;
 43   private BigInteger visibleHP;
 44   private BigInteger minimumHP;
 45   private BigInteger maximumHP;
 46   private BigInteger unitIncrementHP;
 47   private BigInteger blockIncrementHP;
 48   private BigDecimal scaleFactor;
 49   private BigInteger rangeHP;
 50   // The underlying scrollbar runs a range from 0..BIG_RANGE-1
 51   private static final int BIG_RANGE = 10000;
 52   // Do we need to scale HP values up/down to fit in 0..BIG_RANGE-1?
 53   private boolean    down;
<span class="line-modified"> 54   private java.util.List&lt;ChangeListener&gt; changeListeners = new ArrayList&lt;&gt;();</span>
 55   // Number of digits after decimal point to use when scaling between
 56   // high and low precision
 57   private static final int SCALE = 20;
 58 
 59 
 60   // This is a hack to allow us to differentiate between clicks on the
 61   // arrow and track since we can&#39;t get useful information from
 62   // JScrollBars&#39; AdjustmentListener (bug in design of BasicUI
 63   // classes; FIXME: file RFE.)
 64   private static final int UNIT_INCREMENT  = 1;
 65   private static final int BLOCK_INCREMENT = 2;
 66   private static final int MINIMUM = 0;
 67   private static final int MAXIMUM = 65536;
 68   private boolean updating = false;
 69   private int lastValueSeen = -1;
 70 
 71   public HighPrecisionJScrollBar() {
 72     super();
 73     initialize();
 74     installListener();
</pre>
<hr />
<pre>
243     setVisibleAmountHP(new BigInteger(Integer.toString(getVisibleAmount())));
244     setValueHP(value);
245   }
246 
247   private void initialize() {
248     BigInteger min = new BigInteger(Integer.toString(getMinimum()));
249     BigInteger max = new BigInteger(Integer.toString(getMaximum()));
250     initialize(min, min, max);
251   }
252 
253   private void setRange(BigInteger minimum, BigInteger maximum) {
254     if (minimum.compareTo(maximum) &gt; 0 ) {
255       throw new RuntimeException(&quot;Bad scrollbar range &quot; + minimum + &quot; &gt; &quot; + maximum);
256     }
257     minimumHP = minimum;
258     maximumHP = maximum;
259     rangeHP = maximum.subtract(minimum).add(BigInteger.ONE);
260     BigInteger range2 = new BigInteger(Integer.toString(BIG_RANGE));
261     if (rangeHP.compareTo(range2) &gt;= 0 ) {
262       down = true;
<span class="line-modified">263       scaleFactor = new BigDecimal(rangeHP, SCALE).divide(new BigDecimal(range2, SCALE), RoundingMode.DOWN).max(new BigDecimal(BigInteger.ONE));</span>
264     } else {
265       down = false;
<span class="line-modified">266       scaleFactor = new BigDecimal(range2, SCALE).divide(new BigDecimal(rangeHP, SCALE), RoundingMode.DOWN).max(new BigDecimal(BigInteger.ONE));</span>
267     }
268     // FIXME: should put in original scaling algorithm (shifting by
269     // number of bits) as alternative when scale between low and high
270     // precision is very large
271   }
272 
273   // A range update is complete. Rescale our computed values and
274   // inform the underlying scrollBar as needed.
275   private void updateScrollBarValues() {
276     setValueHP(getValueHP());
277     setVisibleAmountHP(getVisibleAmountHP());
278     setBlockIncrementHP(getBlockIncrementHP());
279     setUnitIncrementHP(getUnitIncrementHP());
280   }
281 
282   private BigDecimal getScaleFactor() {
283     return scaleFactor;
284   }
285 
286 
287   // Value scaling routines
288   private BigInteger scaleToHP(int i) {
289     BigDecimal ib = new BigDecimal(Integer.toString(i));
290     if (down) return ib.multiply(getScaleFactor()).toBigInteger();
<span class="line-modified">291     else return ib.divide(getScaleFactor(), RoundingMode.DOWN).toBigInteger();</span>
292   }
293 
294   private int scaleToUnderlying(BigInteger i) {
295     BigDecimal d = new BigDecimal(i);
<span class="line-modified">296     if (down) return d.divide(getScaleFactor(), RoundingMode.DOWN).intValue();</span>
297     else return d.multiply(getScaleFactor()).intValue();
298   }
299 
300   // Range scaling routines
301   private BigInteger toHPRange(int i) {
302     return scaleToHP(i).add(minimumHP);
303     // return ib.shiftLeft(Math.max(2, maximumHP.bitLength() - 33));
304   }
305 
306   private int toUnderlyingRange(BigInteger i) {
307     return scaleToUnderlying(i.subtract(minimumHP));
308     // return i.shiftRight(Math.max(2, maximumHP.bitLength() - 33)).intValue();
309   }
310 
311   private void installListener() {
312     super.addAdjustmentListener(new AdjustmentListener() {
313         public void adjustmentValueChanged(AdjustmentEvent e) {
314           if (updating) {
315             return;
316           }
</pre>
</td>
</tr>
</table>
<center><a href="FindInHeapPanel.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HistoryComboBox.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
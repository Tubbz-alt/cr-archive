<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/aarch64/AARCH64Frame.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2015, 2019, Red Hat Inc.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 package sun.jvm.hotspot.runtime.aarch64;
 27 
 28 import java.util.*;
 29 import sun.jvm.hotspot.code.*;
 30 import sun.jvm.hotspot.compiler.*;
 31 import sun.jvm.hotspot.debugger.*;
 32 import sun.jvm.hotspot.oops.*;
 33 import sun.jvm.hotspot.runtime.*;
 34 import sun.jvm.hotspot.types.*;
 35 import sun.jvm.hotspot.utilities.*;
 36 
 37 /** Specialization of and implementation of abstract methods of the
 38     Frame class for the aarch64 family of CPUs. */
 39 
 40 public class AARCH64Frame extends Frame {
 41   private static final boolean DEBUG;
 42   static {
 43     DEBUG = System.getProperty(&quot;sun.jvm.hotspot.runtime.aarch64.AARCH64Frame.DEBUG&quot;) != null;
 44   }
 45 
 46   // All frames
 47   private static final int LINK_OFFSET                =  0;
 48   private static final int RETURN_ADDR_OFFSET         =  1;
 49   private static final int SENDER_SP_OFFSET           =  2;
 50 
 51   // Interpreter frames
 52   private static final int INTERPRETER_FRAME_SENDER_SP_OFFSET = -1;
 53   private static final int INTERPRETER_FRAME_LAST_SP_OFFSET   = INTERPRETER_FRAME_SENDER_SP_OFFSET - 1;
 54   private static final int INTERPRETER_FRAME_METHOD_OFFSET    = INTERPRETER_FRAME_LAST_SP_OFFSET - 1;
 55   private static       int INTERPRETER_FRAME_MDX_OFFSET;         // Non-core builds only
 56   private static       int INTERPRETER_FRAME_PADDING_OFFSET;
 57   private static       int INTERPRETER_FRAME_MIRROR_OFFSET;
 58   private static       int INTERPRETER_FRAME_CACHE_OFFSET;
 59   private static       int INTERPRETER_FRAME_LOCALS_OFFSET;
 60   private static       int INTERPRETER_FRAME_BCX_OFFSET;
 61   private static       int INTERPRETER_FRAME_INITIAL_SP_OFFSET;
 62   private static       int INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET;
 63   private static       int INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET;
 64 
 65   // Entry frames
 66   private static       int ENTRY_FRAME_CALL_WRAPPER_OFFSET = -8;
 67 
 68   // Native frames
 69   private static final int NATIVE_FRAME_INITIAL_PARAM_OFFSET =  2;
 70 
 71   private static VMReg fp = new VMReg(29);
 72 
 73   static {
 74     VM.registerVMInitializedObserver(new Observer() {
 75         public void update(Observable o, Object data) {
 76           initialize(VM.getVM().getTypeDataBase());
 77         }
 78       });
 79   }
 80 
 81   private static synchronized void initialize(TypeDataBase db) {
 82     INTERPRETER_FRAME_MDX_OFFSET                  = INTERPRETER_FRAME_METHOD_OFFSET - 1;
 83     INTERPRETER_FRAME_PADDING_OFFSET              = INTERPRETER_FRAME_MDX_OFFSET - 1;
 84     INTERPRETER_FRAME_MIRROR_OFFSET               = INTERPRETER_FRAME_PADDING_OFFSET - 1;
 85     INTERPRETER_FRAME_CACHE_OFFSET                = INTERPRETER_FRAME_MIRROR_OFFSET - 1;
 86     INTERPRETER_FRAME_LOCALS_OFFSET               = INTERPRETER_FRAME_CACHE_OFFSET - 1;
 87     INTERPRETER_FRAME_BCX_OFFSET                  = INTERPRETER_FRAME_LOCALS_OFFSET - 1;
 88     INTERPRETER_FRAME_INITIAL_SP_OFFSET           = INTERPRETER_FRAME_BCX_OFFSET - 1;
 89     INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET    = INTERPRETER_FRAME_INITIAL_SP_OFFSET;
 90     INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET = INTERPRETER_FRAME_INITIAL_SP_OFFSET;
 91   }
 92 
 93 
 94   // an additional field beyond sp and pc:
 95   Address raw_fp; // frame pointer
 96   private Address raw_unextendedSP;
 97 
 98   private AARCH64Frame() {
 99   }
100 
101   private void adjustForDeopt() {
102     if ( pc != null) {
103       // Look for a deopt pc and if it is deopted convert to original pc
104       CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);
105       if (cb != null &amp;&amp; cb.isJavaMethod()) {
106         NMethod nm = (NMethod) cb;
107         if (pc.equals(nm.deoptHandlerBegin())) {
108           if (Assert.ASSERTS_ENABLED) {
109             Assert.that(this.getUnextendedSP() != null, &quot;null SP in Java frame&quot;);
110           }
111           // adjust pc if frame is deoptimized.
112           pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());
113           deoptimized = true;
114         }
115       }
116     }
117   }
118 
119   public AARCH64Frame(Address raw_sp, Address raw_fp, Address pc) {
120     this.raw_sp = raw_sp;
121     this.raw_unextendedSP = raw_sp;
122     this.raw_fp = raw_fp;
123     this.pc = pc;
124     adjustUnextendedSP();
125 
126     // Frame must be fully constructed before this call
127     adjustForDeopt();
128 
129     if (DEBUG) {
130       System.out.println(&quot;AARCH64Frame(sp, fp, pc): &quot; + this);
131       dumpStack();
132     }
133   }
134 
135   public AARCH64Frame(Address raw_sp, Address raw_fp) {
136     this.raw_sp = raw_sp;
137     this.raw_unextendedSP = raw_sp;
138     this.raw_fp = raw_fp;
139 
140     // We cannot assume SP[-1] always contains a valid return PC (e.g. if
141     // the callee is a C/C++ compiled frame). If the PC is not known to
142     // Java then this.pc is null.
143     Address savedPC = raw_sp.getAddressAt(-1 * VM.getVM().getAddressSize());
144     if (VM.getVM().isJavaPCDbg(savedPC)) {
145       this.pc = savedPC;
146     }
147 
148     adjustUnextendedSP();
149 
150     // Frame must be fully constructed before this call
151     adjustForDeopt();
152 
153     if (DEBUG) {
154       System.out.println(&quot;AARCH64Frame(sp, fp): &quot; + this);
155       dumpStack();
156     }
157   }
158 
159   public AARCH64Frame(Address raw_sp, Address raw_unextendedSp, Address raw_fp, Address pc) {
160     this.raw_sp = raw_sp;
161     this.raw_unextendedSP = raw_unextendedSp;
162     this.raw_fp = raw_fp;
163     this.pc = pc;
164     adjustUnextendedSP();
165 
166     // Frame must be fully constructed before this call
167     adjustForDeopt();
168 
169     if (DEBUG) {
170       System.out.println(&quot;AARCH64Frame(sp, unextendedSP, fp, pc): &quot; + this);
171       dumpStack();
172     }
173 
174   }
175 
176   public Object clone() {
177     AARCH64Frame frame = new AARCH64Frame();
178     frame.raw_sp = raw_sp;
179     frame.raw_unextendedSP = raw_unextendedSP;
180     frame.raw_fp = raw_fp;
181     frame.pc = pc;
182     frame.deoptimized = deoptimized;
183     return frame;
184   }
185 
186   public boolean equals(Object arg) {
187     if (arg == null) {
188       return false;
189     }
190 
191     if (!(arg instanceof AARCH64Frame)) {
192       return false;
193     }
194 
195     AARCH64Frame other = (AARCH64Frame) arg;
196 
197     return (AddressOps.equal(getSP(), other.getSP()) &amp;&amp;
198             AddressOps.equal(getUnextendedSP(), other.getUnextendedSP()) &amp;&amp;
199             AddressOps.equal(getFP(), other.getFP()) &amp;&amp;
200             AddressOps.equal(getPC(), other.getPC()));
201   }
202 
203   public int hashCode() {
204     if (raw_sp == null) {
205       return 0;
206     }
207 
208     return raw_sp.hashCode();
209   }
210 
211   public String toString() {
212     return &quot;sp: &quot; + (getSP() == null? &quot;null&quot; : getSP().toString()) +
213          &quot;, unextendedSP: &quot; + (getUnextendedSP() == null? &quot;null&quot; : getUnextendedSP().toString()) +
214          &quot;, fp: &quot; + (getFP() == null? &quot;null&quot; : getFP().toString()) +
215          &quot;, pc: &quot; + (pc == null? &quot;null&quot; : pc.toString());
216   }
217 
218   // accessors for the instance variables
219   public Address getFP() { return raw_fp; }
220   public Address getSP() { return raw_sp; }
221   public Address getID() { return raw_sp; }
222 
223   // FIXME: not implemented yet
224   public boolean isSignalHandlerFrameDbg() { return false; }
225   public int     getSignalNumberDbg()      { return 0;     }
226   public String  getSignalNameDbg()        { return null;  }
227 
228   public boolean isInterpretedFrameValid() {
229     if (Assert.ASSERTS_ENABLED) {
230       Assert.that(isInterpretedFrame(), &quot;Not an interpreted frame&quot;);
231     }
232 
233     // These are reasonable sanity checks
234     if (getFP() == null || getFP().andWithMask(0x3) != null) {
235       return false;
236     }
237 
238     if (getSP() == null || getSP().andWithMask(0x3) != null) {
239       return false;
240     }
241 
242     if (getFP().addOffsetTo(INTERPRETER_FRAME_INITIAL_SP_OFFSET * VM.getVM().getAddressSize()).lessThan(getSP())) {
243       return false;
244     }
245 
246     // These are hacks to keep us out of trouble.
247     // The problem with these is that they mask other problems
248     if (getFP().lessThanOrEqual(getSP())) {
249       // this attempts to deal with unsigned comparison above
250       return false;
251     }
252 
253     if (getFP().minus(getSP()) &gt; 4096 * VM.getVM().getAddressSize()) {
254       // stack frames shouldn&#39;t be large.
255       return false;
256     }
257 
258     return true;
259   }
260 
261   // FIXME: not applicable in current system
262   //  void    patch_pc(Thread* thread, address pc);
263 
264   public Frame sender(RegisterMap regMap, CodeBlob cb) {
265     AARCH64RegisterMap map = (AARCH64RegisterMap) regMap;
266 
267     if (Assert.ASSERTS_ENABLED) {
268       Assert.that(map != null, &quot;map must be set&quot;);
269     }
270 
271     // Default is we done have to follow them. The sender_for_xxx will
272     // update it accordingly
273     map.setIncludeArgumentOops(false);
274 
275     if (isEntryFrame())       return senderForEntryFrame(map);
276     if (isInterpretedFrame()) return senderForInterpreterFrame(map);
277 
278     if(cb == null) {
279       cb = VM.getVM().getCodeCache().findBlob(getPC());
280     } else {
281       if (Assert.ASSERTS_ENABLED) {
282         Assert.that(cb.equals(VM.getVM().getCodeCache().findBlob(getPC())), &quot;Must be the same&quot;);
283       }
284     }
285 
286     if (cb != null) {
287       return senderForCompiledFrame(map, cb);
288     }
289 
290     // Must be native-compiled frame, i.e. the marshaling code for native
291     // methods that exists in the core system.
292     return new AARCH64Frame(getSenderSP(), getLink(), getSenderPC());
293   }
294 
295   private Frame senderForEntryFrame(AARCH64RegisterMap map) {
296     if (DEBUG) {
297       System.out.println(&quot;senderForEntryFrame&quot;);
298     }
299     if (Assert.ASSERTS_ENABLED) {
300       Assert.that(map != null, &quot;map must be set&quot;);
301     }
302     // Java frame called from C; skip all C frames and return top C
303     // frame of that chunk as the sender
304     AARCH64JavaCallWrapper jcw = (AARCH64JavaCallWrapper) getEntryFrameCallWrapper();
305     if (Assert.ASSERTS_ENABLED) {
306       Assert.that(!entryFrameIsFirst(), &quot;next Java fp must be non zero&quot;);
307       Assert.that(jcw.getLastJavaSP().greaterThan(getSP()), &quot;must be above this frame on stack&quot;);
308     }
309     AARCH64Frame fr;
310     if (jcw.getLastJavaPC() != null) {
311       fr = new AARCH64Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP(), jcw.getLastJavaPC());
312     } else {
313       fr = new AARCH64Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP());
314     }
315     map.clear();
316     if (Assert.ASSERTS_ENABLED) {
317       Assert.that(map.getIncludeArgumentOops(), &quot;should be set by clear&quot;);
318     }
319     return fr;
320   }
321 
322   //------------------------------------------------------------------------------
323   // frame::adjust_unextended_sp
324   private void adjustUnextendedSP() {
325     // If we are returning to a compiled MethodHandle call site, the
326     // saved_fp will in fact be a saved value of the unextended SP.  The
327     // simplest way to tell whether we are returning to such a call site
328     // is as follows:
329 
330     CodeBlob cb = cb();
331     NMethod senderNm = (cb == null) ? null : cb.asNMethodOrNull();
332     if (senderNm != null) {
333       // If the sender PC is a deoptimization point, get the original
334       // PC.  For MethodHandle call site the unextended_sp is stored in
335       // saved_fp.
336       if (senderNm.isDeoptMhEntry(getPC())) {
337         // DEBUG_ONLY(verifyDeoptMhOriginalPc(senderNm, getFP()));
338         raw_unextendedSP = getFP();
339       }
340       else if (senderNm.isDeoptEntry(getPC())) {
341         // DEBUG_ONLY(verifyDeoptOriginalPc(senderNm, raw_unextendedSp));
342       }
343       else if (senderNm.isMethodHandleReturn(getPC())) {
344         raw_unextendedSP = getFP();
345       }
346     }
347   }
348 
349   private Frame senderForInterpreterFrame(AARCH64RegisterMap map) {
350     if (DEBUG) {
351       System.out.println(&quot;senderForInterpreterFrame&quot;);
352     }
353     Address unextendedSP = addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);
354     Address sp = addressOfStackSlot(SENDER_SP_OFFSET);
355     // We do not need to update the callee-save register mapping because above
356     // us is either another interpreter frame or a converter-frame, but never
357     // directly a compiled frame.
358     // 11/24/04 SFG. With the removal of adapter frames this is no longer true.
359     // However c2 no longer uses callee save register for java calls so there
360     // are no callee register to find.
361 
362     if (map.getUpdateMap())
363       updateMapWithSavedLink(map, addressOfStackSlot(LINK_OFFSET));
364 
365     return new AARCH64Frame(sp, unextendedSP, getLink(), getSenderPC());
366   }
367 
368   private void updateMapWithSavedLink(RegisterMap map, Address savedFPAddr) {
369     map.setLocation(fp, savedFPAddr);
370   }
371 
372   private Frame senderForCompiledFrame(AARCH64RegisterMap map, CodeBlob cb) {
373     if (DEBUG) {
374       System.out.println(&quot;senderForCompiledFrame&quot;);
375     }
376 
377     //
378     // NOTE: some of this code is (unfortunately) duplicated  AARCH64CurrentFrameGuess
379     //
380 
381     if (Assert.ASSERTS_ENABLED) {
382       Assert.that(map != null, &quot;map must be set&quot;);
383     }
384 
385     // frame owned by optimizing compiler
386     if (Assert.ASSERTS_ENABLED) {
387         Assert.that(cb.getFrameSize() &gt;= 0, &quot;must have non-zero frame size&quot;);
388     }
389     Address senderSP = getUnextendedSP().addOffsetTo(cb.getFrameSize());
390 
391     // The return_address is always the word on the stack
392     Address senderPC = senderSP.getAddressAt(-1 * VM.getVM().getAddressSize());
393 
394     // This is the saved value of FP which may or may not really be an FP.
395     // It is only an FP if the sender is an interpreter frame.
396     Address savedFPAddr = senderSP.addOffsetTo(- SENDER_SP_OFFSET * VM.getVM().getAddressSize());
397 
398     if (map.getUpdateMap()) {
399       // Tell GC to use argument oopmaps for some runtime stubs that need it.
400       // For C1, the runtime stub might not have oop maps, so set this flag
401       // outside of update_register_map.
402       map.setIncludeArgumentOops(cb.callerMustGCArguments());
403 
404       if (cb.getOopMaps() != null) {
405         ImmutableOopMapSet.updateRegisterMap(this, cb, map, true);
406       }
407 
408       // Since the prolog does the save and restore of FP there is no oopmap
409       // for it so we must fill in its location as if there was an oopmap entry
410       // since if our caller was compiled code there could be live jvm state in it.
411       updateMapWithSavedLink(map, savedFPAddr);
412     }
413 
414     return new AARCH64Frame(senderSP, savedFPAddr.getAddressAt(0), senderPC);
415   }
416 
417   protected boolean hasSenderPD() {
418     return true;
419   }
420 
421   public long frameSize() {
422     return (getSenderSP().minus(getSP()) / VM.getVM().getAddressSize());
423   }
424 
425     public Address getLink() {
426         try {
427             if (DEBUG) {
428                 System.out.println(&quot;Reading link at &quot; + addressOfStackSlot(LINK_OFFSET)
429                         + &quot; = &quot; + addressOfStackSlot(LINK_OFFSET).getAddressAt(0));
430             }
431             return addressOfStackSlot(LINK_OFFSET).getAddressAt(0);
432         } catch (Exception e) {
433             if (DEBUG)
434                 System.out.println(&quot;Returning null&quot;);
435             return null;
436         }
437     }
438 
439   // FIXME: not implementable yet
440   //inline void      frame::set_link(intptr_t* addr)  { *(intptr_t **)addr_at(link_offset) = addr; }
441 
442   public Address getUnextendedSP() { return raw_unextendedSP; }
443 
444   // Return address:
445   public Address getSenderPCAddr() { return addressOfStackSlot(RETURN_ADDR_OFFSET); }
446   public Address getSenderPC()     { return getSenderPCAddr().getAddressAt(0);      }
447 
448   // return address of param, zero origin index.
449   public Address getNativeParamAddr(int idx) {
450     return addressOfStackSlot(NATIVE_FRAME_INITIAL_PARAM_OFFSET + idx);
451   }
452 
453   public Address getSenderSP()     { return addressOfStackSlot(SENDER_SP_OFFSET); }
454 
455   public Address addressOfInterpreterFrameLocals() {
456     return addressOfStackSlot(INTERPRETER_FRAME_LOCALS_OFFSET);
457   }
458 
459   private Address addressOfInterpreterFrameBCX() {
460     return addressOfStackSlot(INTERPRETER_FRAME_BCX_OFFSET);
461   }
462 
463   public int getInterpreterFrameBCI() {
464     // FIXME: this is not atomic with respect to GC and is unsuitable
465     // for use in a non-debugging, or reflective, system. Need to
466     // figure out how to express this.
467     Address bcp = addressOfInterpreterFrameBCX().getAddressAt(0);
468     Address methodHandle = addressOfInterpreterFrameMethod().getAddressAt(0);
469     Method method = (Method)Metadata.instantiateWrapperFor(methodHandle);
470     return bcpToBci(bcp, method);
471   }
472 
473   public Address addressOfInterpreterFrameMDX() {
474     return addressOfStackSlot(INTERPRETER_FRAME_MDX_OFFSET);
475   }
476 
477   // FIXME
478   //inline int frame::interpreter_frame_monitor_size() {
479   //  return BasicObjectLock::size();
480   //}
481 
482   // expression stack
483   // (the max_stack arguments are used by the GC; see class FrameClosure)
484 
485   public Address addressOfInterpreterFrameExpressionStack() {
486     Address monitorEnd = interpreterFrameMonitorEnd().address();
487     return monitorEnd.addOffsetTo(-1 * VM.getVM().getAddressSize());
488   }
489 
490   public int getInterpreterFrameExpressionStackDirection() { return -1; }
491 
492   // top of expression stack
493   public Address addressOfInterpreterFrameTOS() {
494     return getSP();
495   }
496 
497   /** Expression stack from top down */
498   public Address addressOfInterpreterFrameTOSAt(int slot) {
499     return addressOfInterpreterFrameTOS().addOffsetTo(slot * VM.getVM().getAddressSize());
500   }
501 
502   public Address getInterpreterFrameSenderSP() {
503     if (Assert.ASSERTS_ENABLED) {
504       Assert.that(isInterpretedFrame(), &quot;interpreted frame expected&quot;);
505     }
506     return addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);
507   }
508 
509   // Monitors
510   public BasicObjectLock interpreterFrameMonitorBegin() {
511     return new BasicObjectLock(addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET));
512   }
513 
514   public BasicObjectLock interpreterFrameMonitorEnd() {
515     Address result = addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET).getAddressAt(0);
516     if (Assert.ASSERTS_ENABLED) {
517       // make sure the pointer points inside the frame
518       Assert.that(AddressOps.gt(getFP(), result), &quot;result must &lt;  than frame pointer&quot;);
519       Assert.that(AddressOps.lte(getSP(), result), &quot;result must &gt;= than stack pointer&quot;);
520     }
521     return new BasicObjectLock(result);
522   }
523 
524   public int interpreterFrameMonitorSize() {
525     return BasicObjectLock.size();
526   }
527 
528   // Method
529   public Address addressOfInterpreterFrameMethod() {
530     return addressOfStackSlot(INTERPRETER_FRAME_METHOD_OFFSET);
531   }
532 
533   // Constant pool cache
534   public Address addressOfInterpreterFrameCPCache() {
535     return addressOfStackSlot(INTERPRETER_FRAME_CACHE_OFFSET);
536   }
537 
538   // Entry frames
539   public JavaCallWrapper getEntryFrameCallWrapper() {
540     return new AARCH64JavaCallWrapper(addressOfStackSlot(ENTRY_FRAME_CALL_WRAPPER_OFFSET).getAddressAt(0));
541   }
542 
543   protected Address addressOfSavedOopResult() {
544     // offset is 2 for compiler2 and 3 for compiler1
545     return getSP().addOffsetTo((VM.getVM().isClientCompiler() ? 2 : 3) *
546                                VM.getVM().getAddressSize());
547   }
548 
549   protected Address addressOfSavedReceiver() {
550     return getSP().addOffsetTo(-4 * VM.getVM().getAddressSize());
551   }
552 
553   private void dumpStack() {
554     for (Address addr = getSP().addOffsetTo(-4 * VM.getVM().getAddressSize());
555          AddressOps.lt(addr, getSP());
556          addr = addr.addOffsetTo(VM.getVM().getAddressSize())) {
557       System.out.println(addr + &quot;: &quot; + addr.getAddressAt(0));
558     }
559     System.out.println(&quot;-----------------------&quot;);
560     for (Address addr = getSP();
561          AddressOps.lte(addr, getSP().addOffsetTo(20 * VM.getVM().getAddressSize()));
562          addr = addr.addOffsetTo(VM.getVM().getAddressSize())) {
563       System.out.println(addr + &quot;: &quot; + addr.getAddressAt(0));
564     }
565   }
566 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/code/NMethod.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandlesAdapterBlob.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ObjectValue.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/code/NMethod.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.code;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.oops.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.types.*;
 33 import sun.jvm.hotspot.utilities.*;


 34 
 35 public class NMethod extends CompiledMethod {
 36   private static long          pcDescSize;
 37   /** != InvocationEntryBci if this nmethod is an on-stack replacement method */
 38   private static CIntegerField entryBCIField;
 39   /** To support simple linked-list chaining of nmethods */
 40   private static AddressField  osrLinkField;
 41 
 42   /** Offsets for different nmethod parts */
 43   private static CIntegerField exceptionOffsetField;
 44   private static CIntegerField origPCOffsetField;
 45   private static CIntegerField stubOffsetField;
 46   private static CIntegerField oopsOffsetField;
 47   private static CIntegerField metadataOffsetField;
 48   private static CIntegerField scopesPCsOffsetField;
 49   private static CIntegerField dependenciesOffsetField;
 50   private static CIntegerField handlerTableOffsetField;
 51   private static CIntegerField nulChkTableOffsetField;
 52   private static CIntegerField nmethodEndOffsetField;
 53 
</pre>
<hr />
<pre>
399     if (!approximate) {
400       return pc.getPCOffset() == pc_offset;
401     } else {
402       PCDesc prev = new PCDesc(pc.getAddress().addOffsetTo(-pcDescSize));
403        return prev.getPCOffset() &lt; pc_offset &amp;&amp; pc_offset &lt;= pc.getPCOffset();
404     }
405   }
406 
407   /** This is only for use by the debugging system, and is only
408       intended for use in the topmost frame, where we are not
409       guaranteed to be at a PC for which we have a PCDesc. It finds
410       the ScopeDesc closest to the current PC. NOTE that this may
411       return NULL for compiled methods which don&#39;t have any
412       ScopeDescs! */
413   public ScopeDesc getScopeDescNearDbg(Address pc) {
414     PCDesc pd = getPCDescNearDbg(pc);
415     if (pd == null) return null;
416     return new ScopeDesc(this, pd.getScopeDecodeOffset(), pd.getObjDecodeOffset(), pd.getReexecute());
417   }
418 
<span class="line-modified">419   public Map/*&lt;Address, PCDesc&gt;*/ getSafepoints() {</span>
<span class="line-modified">420     Map safepoints = new HashMap(); // Map&lt;Address, PCDesc&gt;</span>
421     sun.jvm.hotspot.debugger.Address p = null;
422     for (p = scopesPCsBegin(); p.lessThan(scopesPCsEnd());
423          p = p.addOffsetTo(pcDescSize)) {
424        PCDesc pcDesc = new PCDesc(p);
425        sun.jvm.hotspot.debugger.Address pc = pcDesc.getRealPC(this);
426        safepoints.put(pc, pcDesc);
427     }
428     return safepoints;
429   }
430 
431   // FIXME: add getPCOffsetForBCI()
432   // FIXME: add embeddedOopAt()
433   // FIXME: add isDependentOn()
434   // FIXME: add isPatchableAt()
435 
436   /** Support for code generation. Only here for proof-of-concept. */
437   public static int getEntryPointOffset()            { return (int) entryPointField.getOffset();            }
438   public static int getVerifiedEntryPointOffset()    { return (int) verifiedEntryPointField.getOffset();    }
439   public static int getOSREntryPointOffset()         { return (int) osrEntryPointField.getOffset();         }
440   public static int getEntryBCIOffset()              { return (int) entryBCIField.getOffset();              }
</pre>
<hr />
<pre>
457     return &quot;NMethod for &quot; +
458             method.getMethodHolder().getName().asString() + &quot;.&quot; +
459             method.getName().asString() + method.getSignature().asString() + &quot;==&gt;n&quot; +
460             super.toString();
461   }
462 
463   public String flagsToString() {
464     // FIXME need access to flags...
465     return &quot;&quot;;
466   }
467 
468   public String getName() {
469     Method method = getMethod();
470     return &quot;NMethod for &quot; +
471            method.getMethodHolder().getName().asString() + &quot;.&quot; +
472            method.getName().asString() +
473            method.getSignature().asString();
474   }
475 
476   public void dumpReplayData(PrintStream out) {
<span class="line-modified">477     HashMap h = new HashMap();</span>
478     for (int i = 1; i &lt; getMetadataLength(); i++) {
479       Metadata meta = Metadata.instantiateWrapperFor(getMetadataAt(i));
480       System.err.println(meta);
481       if (h.get(meta) != null) continue;
482       h.put(meta, meta);
483       if (meta instanceof InstanceKlass) {
484         ((InstanceKlass)meta).dumpReplayData(out);
485       } else if (meta instanceof Method) {
486         ((Method)meta).dumpReplayData(out);
487         MethodData mdo = ((Method)meta).getMethodData();
488         if (mdo != null) {
489           mdo.dumpReplayData(out);
490         }
491       }
492     }
493     Method method = getMethod();
494     if (h.get(method) == null) {
495       method.dumpReplayData(out);
496       MethodData mdo = method.getMethodData();
497       if (mdo != null) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.code;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.oops.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.types.*;
 33 import sun.jvm.hotspot.utilities.*;
<span class="line-added"> 34 import sun.jvm.hotspot.utilities.Observable;</span>
<span class="line-added"> 35 import sun.jvm.hotspot.utilities.Observer;</span>
 36 
 37 public class NMethod extends CompiledMethod {
 38   private static long          pcDescSize;
 39   /** != InvocationEntryBci if this nmethod is an on-stack replacement method */
 40   private static CIntegerField entryBCIField;
 41   /** To support simple linked-list chaining of nmethods */
 42   private static AddressField  osrLinkField;
 43 
 44   /** Offsets for different nmethod parts */
 45   private static CIntegerField exceptionOffsetField;
 46   private static CIntegerField origPCOffsetField;
 47   private static CIntegerField stubOffsetField;
 48   private static CIntegerField oopsOffsetField;
 49   private static CIntegerField metadataOffsetField;
 50   private static CIntegerField scopesPCsOffsetField;
 51   private static CIntegerField dependenciesOffsetField;
 52   private static CIntegerField handlerTableOffsetField;
 53   private static CIntegerField nulChkTableOffsetField;
 54   private static CIntegerField nmethodEndOffsetField;
 55 
</pre>
<hr />
<pre>
401     if (!approximate) {
402       return pc.getPCOffset() == pc_offset;
403     } else {
404       PCDesc prev = new PCDesc(pc.getAddress().addOffsetTo(-pcDescSize));
405        return prev.getPCOffset() &lt; pc_offset &amp;&amp; pc_offset &lt;= pc.getPCOffset();
406     }
407   }
408 
409   /** This is only for use by the debugging system, and is only
410       intended for use in the topmost frame, where we are not
411       guaranteed to be at a PC for which we have a PCDesc. It finds
412       the ScopeDesc closest to the current PC. NOTE that this may
413       return NULL for compiled methods which don&#39;t have any
414       ScopeDescs! */
415   public ScopeDesc getScopeDescNearDbg(Address pc) {
416     PCDesc pd = getPCDescNearDbg(pc);
417     if (pd == null) return null;
418     return new ScopeDesc(this, pd.getScopeDecodeOffset(), pd.getObjDecodeOffset(), pd.getReexecute());
419   }
420 
<span class="line-modified">421   public Map&lt;sun.jvm.hotspot.debugger.Address, PCDesc&gt; getSafepoints() {</span>
<span class="line-modified">422     Map&lt;sun.jvm.hotspot.debugger.Address, PCDesc&gt; safepoints = new HashMap&lt;&gt;();</span>
423     sun.jvm.hotspot.debugger.Address p = null;
424     for (p = scopesPCsBegin(); p.lessThan(scopesPCsEnd());
425          p = p.addOffsetTo(pcDescSize)) {
426        PCDesc pcDesc = new PCDesc(p);
427        sun.jvm.hotspot.debugger.Address pc = pcDesc.getRealPC(this);
428        safepoints.put(pc, pcDesc);
429     }
430     return safepoints;
431   }
432 
433   // FIXME: add getPCOffsetForBCI()
434   // FIXME: add embeddedOopAt()
435   // FIXME: add isDependentOn()
436   // FIXME: add isPatchableAt()
437 
438   /** Support for code generation. Only here for proof-of-concept. */
439   public static int getEntryPointOffset()            { return (int) entryPointField.getOffset();            }
440   public static int getVerifiedEntryPointOffset()    { return (int) verifiedEntryPointField.getOffset();    }
441   public static int getOSREntryPointOffset()         { return (int) osrEntryPointField.getOffset();         }
442   public static int getEntryBCIOffset()              { return (int) entryBCIField.getOffset();              }
</pre>
<hr />
<pre>
459     return &quot;NMethod for &quot; +
460             method.getMethodHolder().getName().asString() + &quot;.&quot; +
461             method.getName().asString() + method.getSignature().asString() + &quot;==&gt;n&quot; +
462             super.toString();
463   }
464 
465   public String flagsToString() {
466     // FIXME need access to flags...
467     return &quot;&quot;;
468   }
469 
470   public String getName() {
471     Method method = getMethod();
472     return &quot;NMethod for &quot; +
473            method.getMethodHolder().getName().asString() + &quot;.&quot; +
474            method.getName().asString() +
475            method.getSignature().asString();
476   }
477 
478   public void dumpReplayData(PrintStream out) {
<span class="line-modified">479     HashMap&lt;Metadata, Metadata&gt; h = new HashMap&lt;&gt;();</span>
480     for (int i = 1; i &lt; getMetadataLength(); i++) {
481       Metadata meta = Metadata.instantiateWrapperFor(getMetadataAt(i));
482       System.err.println(meta);
483       if (h.get(meta) != null) continue;
484       h.put(meta, meta);
485       if (meta instanceof InstanceKlass) {
486         ((InstanceKlass)meta).dumpReplayData(out);
487       } else if (meta instanceof Method) {
488         ((Method)meta).dumpReplayData(out);
489         MethodData mdo = ((Method)meta).getMethodData();
490         if (mdo != null) {
491           mdo.dumpReplayData(out);
492         }
493       }
494     }
495     Method method = getMethod();
496     if (h.get(method) == null) {
497       method.dumpReplayData(out);
498       MethodData mdo = method.getMethodData();
499       if (mdo != null) {
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandlesAdapterBlob.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ObjectValue.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/cdbg/basic/BasicType.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.debugger.cdbg.basic;
 26 
 27 import java.util.*;
 28 import sun.jvm.hotspot.debugger.*;
 29 import sun.jvm.hotspot.debugger.cdbg.*;
 30 
 31 public abstract class BasicType implements Type, CVAttributes {
 32   private String name;
 33   private int    size;
 34   private int    cvAttributes;
 35   // Types keep a list of const/volatile qualified variants of themselves
 36   private List   cvVariants;
 37 
 38   protected BasicType(String name, int size) {
 39     this(name, size, 0);
 40   }
 41 
 42   protected BasicType(String name, int size, int cvAttributes) {
 43     this.name = name;
 44     this.size = size;
 45     this.cvAttributes = cvAttributes;
 46   }
 47 
 48   public String       getName()    { return name; }
 49 
 50   /** For use during resolution only */
 51   protected void      setName(String name) { this.name = name; }
 52 
 53   public int          getSize()    { return size; }
 54 
 55   public BitType      asBit()      { return null; }
 56   public IntType      asInt()      { return null; }
 57   public EnumType     asEnum()     { return null; }
 58   public FloatType    asFloat()    { return null; }
 59   public DoubleType   asDouble()   { return null; }
 60   public PointerType  asPointer()  { return null; }
 61   public ArrayType    asArray()    { return null; }
 62   public RefType      asRef()      { return null; }
 63   public CompoundType asCompound() { return null; }
 64   public FunctionType asFunction() { return null; }
 65   public MemberFunctionType asMemberFunction() { return null; }
 66   public VoidType     asVoid()     { return null; }
 67 
 68   public boolean      isBit()      { return (asBit()      != null); }
 69   public boolean      isInt()      { return (asInt()      != null); }
 70   public boolean      isEnum()     { return (asEnum()     != null); }
 71   public boolean      isFloat()    { return (asFloat()    != null); }
 72   public boolean      isDouble()   { return (asDouble()   != null); }
 73   public boolean      isPointer()  { return (asPointer()  != null); }
 74   public boolean      isArray()    { return (asArray()    != null); }
 75   public boolean      isRef()      { return (asRef()      != null); }
 76   public boolean      isCompound() { return (asCompound() != null); }
 77   public boolean      isFunction() { return (asFunction() != null); }
 78   public boolean      isMemberFunction() { return (asMemberFunction() != null); }
 79   public boolean      isVoid()     { return (asVoid()     != null); }
 80 
 81   public boolean      isConst()    { return ((cvAttributes &amp; CONST) != 0); }
 82   public boolean      isVolatile() { return ((cvAttributes &amp; VOLATILE) != 0); }
 83 
 84   Type resolveTypes(BasicCDebugInfoDataBase db, ResolveListener listener) {
 85     if (cvVariants != null) {
 86       for (ListIterator iter = cvVariants.listIterator(); iter.hasNext(); ) {
 87         iter.set(db.resolveType(this, (BasicType) iter.next(), listener, &quot;resolving const/var variants&quot;));
 88       }
 89     }
 90     return this;
 91   }
 92   public boolean       isLazy() { return false; }
 93   public void          iterateObject(Address a, ObjectVisitor v) {
 94     iterateObject(a, v, null);
 95   }
 96   public abstract void iterateObject(Address a, ObjectVisitor v, FieldIdentifier f);
 97   public Type          getCVVariant(int cvAttributes) {
 98     Type t = findCVVariant(cvAttributes);
 99     if (t != null) return t;
100     t = createCVVariant(cvAttributes);
101     addCVVariant(t);
102     return t;
103   }
104 
105   public String toString() {
106     return getName();
107   }
108 
109   private   int           getCVAttributes() { return cvAttributes; }
110   protected abstract Type createCVVariant(int cvAttributes);
111   protected Type          findCVVariant(int cvAttributes) {
112     if (cvVariants != null) {
113       for (Iterator iter = cvVariants.iterator(); iter.hasNext(); ) {
114         BasicType t = (BasicType) iter.next();
115         if (t.getCVAttributes() == cvAttributes) return t;
116       }
117     }
118     return null;
119   }
120   protected void addCVVariant(Type t) {
121     if (cvVariants == null) {
122       cvVariants = new ArrayList();
123     }
124     cvVariants.add(t);
125   }
126 
127   public abstract void visit(TypeVisitor v);
128 }
    </pre>
  </body>
</html>
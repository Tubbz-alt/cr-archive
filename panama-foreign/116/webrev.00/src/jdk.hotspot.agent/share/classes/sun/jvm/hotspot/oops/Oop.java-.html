<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/Oop.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.oops;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.utilities.*;
 30 import sun.jvm.hotspot.debugger.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.types.*;
 33 
 34 // Oop represents the superclass for all types of
 35 // objects in the HotSpot object heap.
 36 
 37 public class Oop {
 38   static {
 39     VM.registerVMInitializedObserver(new Observer() {
 40         public void update(Observable o, Object data) {
 41           initialize(VM.getVM().getTypeDataBase());
 42         }
 43       });
 44   }
 45 
 46   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
 47     Type type  = db.lookupType(&quot;oopDesc&quot;);
 48     mark       = new CIntField(type.getCIntegerField(&quot;_mark&quot;), 0);
 49     klass      = new MetadataField(type.getAddressField(&quot;_metadata._klass&quot;), 0);
 50     compressedKlass  = new NarrowKlassField(type.getAddressField(&quot;_metadata._compressed_klass&quot;), 0);
 51     headerSize = type.getSize();
 52   }
 53 
 54   private OopHandle  handle;
 55   private ObjectHeap heap;
 56 
 57   Oop(OopHandle handle, ObjectHeap heap) {
 58     this.handle = handle;
 59     this.heap   = heap;
 60   }
 61 
 62   ObjectHeap getHeap()   { return heap; }
 63 
 64   /** Should not be used or needed by most clients outside this
 65       package; is needed, however, by {@link
 66       sun.jvm.hotspot.utilities.MarkBits}. */
 67   public OopHandle getHandle() { return handle; }
 68 
 69   private static long headerSize;
 70   public  static long getHeaderSize() { return headerSize; } // Header size in bytes.
 71 
 72   private static CIntField mark;
 73   private static MetadataField  klass;
 74   private static NarrowKlassField compressedKlass;
 75 
 76   // Accessors for declared fields
 77   public Mark  getMark()   { return new Mark(getHandle()); }
 78   public Klass getKlass() {
 79     if (VM.getVM().isCompressedKlassPointersEnabled()) {
 80       return (Klass)compressedKlass.getValue(getHandle());
 81     } else {
 82       return (Klass)klass.getValue(getHandle());
 83     }
 84   }
 85 
 86   public boolean isA(Klass k) {
 87     return getKlass().isSubtypeOf(k);
 88   }
 89 
 90   // Returns the byte size of this object
 91   public long getObjectSize() {
 92     Klass k = getKlass();
 93     // All other types should be overriding getObjectSize directly
 94     return ((InstanceKlass)k).getObjectSize(this);
 95   }
 96 
 97   // Type test operations
 98   public boolean isInstance()          { return false; }
 99   public boolean isInstanceRef()       { return false; }
100   public boolean isArray()             { return false; }
101   public boolean isObjArray()          { return false; }
102   public boolean isTypeArray()         { return false; }
103   public boolean isThread()            { return false; }
104 
105   // Align the object size.
106   public static long alignObjectSize(long size) {
107     return VM.getVM().alignUp(size, VM.getVM().getMinObjAlignmentInBytes());
108   }
109 
110   // All vm&#39;s align longs, so pad out certain offsets.
111   public static long alignObjectOffset(long offset) {
112     return VM.getVM().alignUp(offset, VM.getVM().getBytesPerLong());
113   }
114 
115   public boolean equals(Object obj) {
116     if (obj != null &amp;&amp; (obj instanceof Oop)) {
117       return getHandle().equals(((Oop) obj).getHandle());
118     }
119     return false;
120  }
121 
122   public int hashCode() { return getHandle().hashCode(); }
123 
124   /** Identity hash in the target VM */
125   public long identityHash() {
126     Mark mark = getMark();
127     if (mark.isUnlocked() &amp;&amp; (!mark.hasNoHash())) {
128       return (int) mark.hash();
129     } else if (mark.isMarked()) {
130       return (int) mark.hash();
131     } else {
132       return slowIdentityHash();
133     }
134   }
135 
136   public long slowIdentityHash() {
137     return VM.getVM().getObjectSynchronizer().identityHashValueFor(this);
138   }
139 
140   public void iterate(OopVisitor visitor, boolean doVMFields) {
141     visitor.setObj(this);
142     visitor.prologue();
143     iterateFields(visitor, doVMFields);
144     visitor.epilogue();
145   }
146 
147   void iterateFields(OopVisitor visitor, boolean doVMFields) {
148     if (doVMFields) {
149       visitor.doCInt(mark, true);
150       if (VM.getVM().isCompressedKlassPointersEnabled()) {
151         visitor.doMetadata(compressedKlass, true);
152       } else {
153         visitor.doMetadata(klass, true);
154       }
155     }
156   }
157 
158   public void print()      { printOn(System.out); }
159   public void printValue() { printValueOn(System.out); }
160   public void printRaw()   { printRawOn(System.out); }
161 
162   public static void printOopValueOn(Oop obj, PrintStream tty) {
163     if (obj == null) {
164       tty.print(&quot;null&quot;);
165     } else {
166       obj.printValueOn(tty);
167       tty.print(&quot; @ &quot; + VM.getVM().getUniverse().heap().oopAddressDescription(obj.getHandle()));
168     }
169   }
170 
171   public static void printOopAddressOn(Oop obj, PrintStream tty) {
172     if (obj == null) {
173       tty.print(&quot;null&quot;);
174     } else {
175       tty.print(obj.getHandle().toString());
176     }
177   }
178 
179   public void printOn(PrintStream tty) {
180     OopPrinter printer = new OopPrinter(tty);
181     iterate(printer, true);
182   }
183 
184   public void printValueOn(PrintStream tty) {
185     try {
186       tty.print(&quot;Oop for &quot; + getKlass().getName().asString());
187     } catch (java.lang.NullPointerException e) {
188       tty.print(&quot;Oop&quot;);
189     }
190   }
191 
192   public void printRawOn(PrintStream tty) {
193     tty.print(&quot;Dumping raw memory for &quot;);
194     printValueOn(tty);
195     tty.println();
196     long size = getObjectSize() * 4;
197     for (long i = 0; i &lt; size; i += 4) {
198       long memVal = getHandle().getCIntegerAt(i, 4, true);
199       tty.println(Long.toHexString(memVal));
200     }
201   }
202 
203   public boolean verify() { return true;}
204 
205   public static Klass getKlassForOopHandle(OopHandle handle) {
206     if (handle == null) {
207       return null;
208     }
209     if (VM.getVM().isCompressedKlassPointersEnabled()) {
210       return (Klass)Metadata.instantiateWrapperFor(handle.getCompKlassAddressAt(compressedKlass.getOffset()));
211     } else {
212       return (Klass)Metadata.instantiateWrapperFor(handle.getAddressAt(klass.getOffset()));
213     }
214   }
215 };
    </pre>
  </body>
</html>
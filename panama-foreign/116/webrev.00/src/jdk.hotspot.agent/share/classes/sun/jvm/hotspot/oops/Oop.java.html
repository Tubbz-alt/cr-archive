<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/Oop.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.oops;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.utilities.*;
 30 import sun.jvm.hotspot.debugger.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.types.*;
 33 import sun.jvm.hotspot.utilities.Observable;
 34 import sun.jvm.hotspot.utilities.Observer;
 35 
 36 // Oop represents the superclass for all types of
 37 // objects in the HotSpot object heap.
 38 
 39 public class Oop {
 40   static {
 41     VM.registerVMInitializedObserver(new Observer() {
 42         public void update(Observable o, Object data) {
 43           initialize(VM.getVM().getTypeDataBase());
 44         }
 45       });
 46   }
 47 
 48   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
 49     Type type  = db.lookupType(&quot;oopDesc&quot;);
 50     mark       = new CIntField(type.getCIntegerField(&quot;_mark&quot;), 0);
 51     klass      = new MetadataField(type.getAddressField(&quot;_metadata._klass&quot;), 0);
 52     compressedKlass  = new NarrowKlassField(type.getAddressField(&quot;_metadata._compressed_klass&quot;), 0);
 53     headerSize = type.getSize();
 54   }
 55 
 56   private OopHandle  handle;
 57   private ObjectHeap heap;
 58 
 59   Oop(OopHandle handle, ObjectHeap heap) {
 60     this.handle = handle;
 61     this.heap   = heap;
 62   }
 63 
 64   ObjectHeap getHeap()   { return heap; }
 65 
 66   /** Should not be used or needed by most clients outside this
 67       package; is needed, however, by {@link
 68       sun.jvm.hotspot.utilities.MarkBits}. */
 69   public OopHandle getHandle() { return handle; }
 70 
 71   private static long headerSize;
 72   public  static long getHeaderSize() { return headerSize; } // Header size in bytes.
 73 
 74   private static CIntField mark;
 75   private static MetadataField  klass;
 76   private static NarrowKlassField compressedKlass;
 77 
 78   // Accessors for declared fields
 79   public Mark  getMark()   { return new Mark(getHandle()); }
 80   public Klass getKlass() {
 81     if (VM.getVM().isCompressedKlassPointersEnabled()) {
 82       return (Klass)compressedKlass.getValue(getHandle());
 83     } else {
 84       return (Klass)klass.getValue(getHandle());
 85     }
 86   }
 87 
 88   public boolean isA(Klass k) {
 89     return getKlass().isSubtypeOf(k);
 90   }
 91 
 92   // Returns the byte size of this object
 93   public long getObjectSize() {
 94     Klass k = getKlass();
 95     // All other types should be overriding getObjectSize directly
 96     return ((InstanceKlass)k).getObjectSize(this);
 97   }
 98 
 99   // Type test operations
100   public boolean isInstance()          { return false; }
101   public boolean isInstanceRef()       { return false; }
102   public boolean isArray()             { return false; }
103   public boolean isObjArray()          { return false; }
104   public boolean isTypeArray()         { return false; }
105   public boolean isThread()            { return false; }
106 
107   // Align the object size.
108   public static long alignObjectSize(long size) {
109     return VM.getVM().alignUp(size, VM.getVM().getMinObjAlignmentInBytes());
110   }
111 
112   // All vm&#39;s align longs, so pad out certain offsets.
113   public static long alignObjectOffset(long offset) {
114     return VM.getVM().alignUp(offset, VM.getVM().getBytesPerLong());
115   }
116 
117   public boolean equals(Object obj) {
118     if (obj != null &amp;&amp; (obj instanceof Oop)) {
119       return getHandle().equals(((Oop) obj).getHandle());
120     }
121     return false;
122  }
123 
124   public int hashCode() { return getHandle().hashCode(); }
125 
126   /** Identity hash in the target VM */
127   public long identityHash() {
128     Mark mark = getMark();
129     if (mark.isUnlocked() &amp;&amp; (!mark.hasNoHash())) {
130       return (int) mark.hash();
131     } else if (mark.isMarked()) {
132       return (int) mark.hash();
133     } else {
134       return slowIdentityHash();
135     }
136   }
137 
138   public long slowIdentityHash() {
139     return VM.getVM().getObjectSynchronizer().identityHashValueFor(this);
140   }
141 
142   public void iterate(OopVisitor visitor, boolean doVMFields) {
143     visitor.setObj(this);
144     visitor.prologue();
145     iterateFields(visitor, doVMFields);
146     visitor.epilogue();
147   }
148 
149   void iterateFields(OopVisitor visitor, boolean doVMFields) {
150     if (doVMFields) {
151       visitor.doCInt(mark, true);
152       if (VM.getVM().isCompressedKlassPointersEnabled()) {
153         visitor.doMetadata(compressedKlass, true);
154       } else {
155         visitor.doMetadata(klass, true);
156       }
157     }
158   }
159 
160   public void print()      { printOn(System.out); }
161   public void printValue() { printValueOn(System.out); }
162   public void printRaw()   { printRawOn(System.out); }
163 
164   public static void printOopValueOn(Oop obj, PrintStream tty) {
165     if (obj == null) {
166       tty.print(&quot;null&quot;);
167     } else {
168       obj.printValueOn(tty);
169       tty.print(&quot; @ &quot; + VM.getVM().getUniverse().heap().oopAddressDescription(obj.getHandle()));
170     }
171   }
172 
173   public static void printOopAddressOn(Oop obj, PrintStream tty) {
174     if (obj == null) {
175       tty.print(&quot;null&quot;);
176     } else {
177       tty.print(obj.getHandle().toString());
178     }
179   }
180 
181   public void printOn(PrintStream tty) {
182     OopPrinter printer = new OopPrinter(tty);
183     iterate(printer, true);
184   }
185 
186   public void printValueOn(PrintStream tty) {
187     try {
188       tty.print(&quot;Oop for &quot; + getKlass().getName().asString());
189     } catch (java.lang.NullPointerException e) {
190       tty.print(&quot;Oop&quot;);
191     }
192   }
193 
194   public void printRawOn(PrintStream tty) {
195     tty.print(&quot;Dumping raw memory for &quot;);
196     printValueOn(tty);
197     tty.println();
198     long size = getObjectSize() * 4;
199     for (long i = 0; i &lt; size; i += 4) {
200       long memVal = getHandle().getCIntegerAt(i, 4, true);
201       tty.println(Long.toHexString(memVal));
202     }
203   }
204 
205   public boolean verify() { return true;}
206 
207   public static Klass getKlassForOopHandle(OopHandle handle) {
208     if (handle == null) {
209       return null;
210     }
211     if (VM.getVM().isCompressedKlassPointersEnabled()) {
212       return (Klass)Metadata.instantiateWrapperFor(handle.getCompKlassAddressAt(compressedKlass.getOffset()));
213     } else {
214       return (Klass)Metadata.instantiateWrapperFor(handle.getAddressAt(klass.getOffset()));
215     }
216   }
217 };
    </pre>
  </body>
</html>
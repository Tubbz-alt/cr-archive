diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/CommandProcessor.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/CommandProcessor.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/CommandProcessor.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/CommandProcessor.java
@@ -126,11 +126,11 @@
             return kls.getClassLoader() == null;
         }
     }
 
     public static class NonBootFilter implements ClassFilter {
-        private HashMap emitted = new HashMap();
+        private HashMap<Symbol, InstanceKlass> emitted = new HashMap<>();
         public boolean canInclude(InstanceKlass kls) {
             if (kls.getClassLoader() == null) return false;
             if (emitted.get(kls.getName()) != null) {
                 // Since multiple class loaders are being shoved
                 // together duplicate classes are a possibilty.  For
@@ -154,22 +154,22 @@
                 return new String[0];
             }
             return t;
         }
 
-        void add(String s, ArrayList t) {
+        void add(String s, ArrayList<String> t) {
             if (s.length() > 0) {
                 t.add(s);
             }
         }
 
         Tokens(String cmd) {
             input = cmd;
 
             // check for quoting
             int quote = cmd.indexOf('"');
-            ArrayList t = new ArrayList();
+            ArrayList<String> t = new ArrayList<>();
             if (quote != -1) {
                 while (cmd.length() > 0) {
                     if (quote != -1) {
                         int endquote = cmd.indexOf('"', quote + 1);
                         if (endquote == -1) {
@@ -680,11 +680,11 @@
                 if (cmd != null) {
                     cmd.usage();
                 } else if (tokens == 0) {
                     out.println("Available commands:");
                     Object[] keys = commands.keySet().toArray();
-                    Arrays.sort(keys, new Comparator() {
+                    Arrays.sort(keys, new Comparator<>() {
                              public int compare(Object o1, Object o2) {
                                  return o1.toString().compareTo(o2.toString());
                              }
                           });
                     for (int i = 0; i < keys.length; i++) {
@@ -991,12 +991,12 @@
 
                 // Dump a copy of the type database in a form that can
                 // be read back.
                 Iterator i = agent.getTypeDataBase().getTypes();
                 // Make sure the types are emitted in an order than can be read back in
-                HashSet emitted = new HashSet();
-                Stack pending = new Stack();
+                HashSet<String> emitted = new HashSet<>();
+                Stack<Type> pending = new Stack<>();
                 while (i.hasNext()) {
                     Type n = (Type)i.next();
                     if (emitted.contains(n.getName())) {
                         continue;
                     }
@@ -1203,11 +1203,11 @@
                         base = base.addOffsetTo(step);
                     }
                 }
             }
         },
-        new Command("intConstant", "intConstant [ name [ value ] ]", true) {
+        new Command("intConstant", "intConstant [ name [ value ] ]", false) {
             public void doit(Tokens t) {
                 if (t.countTokens() != 1 && t.countTokens() != 0 && t.countTokens() != 2) {
                     usage();
                     return;
                 }
@@ -1226,11 +1226,11 @@
                     Integer value = Integer.valueOf(t.nextToken());
                     db.addIntConstant(name, value);
                 }
             }
         },
-        new Command("longConstant", "longConstant [ name [ value ] ]", true) {
+        new Command("longConstant", "longConstant [ name [ value ] ]", false) {
             public void doit(Tokens t) {
                 if (t.countTokens() != 1 && t.countTokens() != 0 && t.countTokens() != 2) {
                     usage();
                     return;
                 }
@@ -1249,11 +1249,11 @@
                     Long value = Long.valueOf(t.nextToken());
                     db.addLongConstant(name, value);
                 }
             }
         },
-        new Command("field", "field [ type [ name fieldtype isStatic offset address ] ]", true) {
+        new Command("field", "field [ type [ name fieldtype isStatic offset address ] ]", false) {
             public void doit(Tokens t) {
                 if (t.countTokens() != 1 && t.countTokens() != 0 && t.countTokens() != 6) {
                     usage();
                     return;
                 }
@@ -1321,11 +1321,11 @@
                 while (t.hasMoreTokens()) {
                     out.println("\"" + t.nextToken() + "\"");
                 }
             }
         },
-        new Command("type", "type [ type [ name super isOop isInteger isUnsigned size ] ]", true) {
+        new Command("type", "type [ type [ name super isOop isInteger isUnsigned size ] ]", false) {
             public void doit(Tokens t) {
                 if (t.countTokens() != 1 && t.countTokens() != 0 && t.countTokens() != 6) {
                     usage();
                     return;
                 }
@@ -1387,12 +1387,12 @@
                     Type type = agent.getTypeDataBase().lookupType(t.nextToken());
                     dumpType(type);
                 } else {
                     Iterator i = agent.getTypeDataBase().getTypes();
                     // Make sure the types are emitted in an order than can be read back in
-                    HashSet emitted = new HashSet();
-                    Stack pending = new Stack();
+                    HashSet<String> emitted = new HashSet<>();
+                    Stack<Type> pending = new Stack<>();
                     while (i.hasNext()) {
                         Type n = (Type)i.next();
                         if (emitted.contains(n.getName())) {
                             continue;
                         }
@@ -1638,11 +1638,11 @@
         new Command("livenmethods", false) {
             public void doit(Tokens t) {
                 if (t.countTokens() != 0) {
                     usage();
                 } else {
-                    ArrayList nmethods = new ArrayList();
+                    ArrayList<NMethod> nmethods = new ArrayList<>();
                     Threads threads = VM.getVM().getThreads();
                     HTMLGenerator gen = new HTMLGenerator(false);
                     for (int i = 0; i < threads.getNumberOfThreads(); i++) {
                         JavaThread thread = threads.getJavaThreadAt(i);
                         try {
@@ -1830,12 +1830,12 @@
             }
         },
     };
 
     private boolean verboseExceptions = false;
-    private ArrayList history = new ArrayList();
-    private HashMap commands = new HashMap();
+    private ArrayList<String> history = new ArrayList<>();
+    private HashMap<String, Command> commands = new HashMap<>();
     private boolean doEcho = false;
 
     private Command findCommand(String key) {
         return (Command)commands.get(key);
     }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/cdbg/basic/BasicCDebugInfoDataBase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BasicBlockSym.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BasicCompoundType.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/cdbg/basic/BasicCDebugInfoDataBase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 26 
 27 import java.util.*;
 28 import sun.jvm.hotspot.debugger.*;
 29 import sun.jvm.hotspot.debugger.cdbg.*;
 30 import sun.jvm.hotspot.utilities.AddressOps;
 31 import sun.jvm.hotspot.utilities.Assert;
 32 
 33 public class BasicCDebugInfoDataBase implements CDebugInfoDataBase {
 34   private static final int INITIALIZED_STATE  = 0;
 35   private static final int CONSTRUCTION_STATE = 1;
 36   private static final int RESOLVED_STATE     = 2;
 37   private static final int COMPLETE_STATE     = 3;
 38 
 39   private int state = INITIALIZED_STATE;
 40 
 41   ///////////
 42   // Types //
 43   ///////////
 44 
 45   // Used only during construction
<span class="line-modified"> 46   private Map lazyTypeMap;</span>
 47 
 48   // Used during construction and at run time for iteration
<span class="line-modified"> 49   private List types;</span>
 50 
 51   // Used only during runtime
<span class="line-modified"> 52   private Map nameToTypeMap;</span>
 53 
 54   /////////////
 55   // Symbols //
 56   /////////////
 57 
 58   // Used only during construction
<span class="line-modified"> 59   private Map lazySymMap;</span>
 60 
 61   // List of blocks in increasing order by starting address. These can
 62   // then be binary searched.
<span class="line-modified"> 63   private List blocks;</span>
 64 
 65   // Name-to-global symbol table
<span class="line-modified"> 66   private Map nameToSymMap;</span>
 67 
 68   //////////////////
 69   // Line numbers //
 70   //////////////////
 71 
 72   private BasicLineNumberMapping lineNumbers;
 73 
 74   /** Supports lazy instantiation and references between types and
 75       symbols via insertion using arbitrary Object keys that are
 76       wrapped by LazyTypes. Once the database has been fully
 77       constructed and all types are present, one should call
 78       resolveTypes(), which will resolve all LazyTypes down to
 79       concrete types (and signal an error if some lazy types were
 80       unresolved). */
 81   public void beginConstruction() {
 82     if (Assert.ASSERTS_ENABLED) {
 83       Assert.that(state == INITIALIZED_STATE, &quot;wrong state&quot;);
 84     }
 85     state   = CONSTRUCTION_STATE;
 86 
 87     // Types
<span class="line-modified"> 88     lazyTypeMap  = new HashMap();</span>
<span class="line-modified"> 89     types        = new ArrayList();</span>
 90 
 91     // Symbols
<span class="line-modified"> 92     lazySymMap   = new HashMap();</span>
<span class="line-modified"> 93     blocks       = new ArrayList();</span>
<span class="line-modified"> 94     nameToSymMap = new HashMap();</span>
 95 
 96     // Line numbers
 97     lineNumbers  = new BasicLineNumberMapping();
 98   }
 99 
100   /** Add a type which may later in construction be referred to via a
101       LazyType with this key. lazyKey may be null. */
102   public void addType(Object lazyKey, Type type) {
103     if (Assert.ASSERTS_ENABLED) {
104       Assert.that(state == CONSTRUCTION_STATE, &quot;wrong state&quot;);
105     }
106     if (lazyKey != null) {
107       if (lazyTypeMap.put(lazyKey, type) != null) {
108         throw new RuntimeException(&quot;Type redefined for lazy key &quot; + lazyKey);
109       }
110     } else {
111       types.add(type);
112     }
113   }
114 
115   public void resolve(ResolveListener listener) {
116     if (Assert.ASSERTS_ENABLED) {
117       Assert.that(state == CONSTRUCTION_STATE, &quot;wrong state&quot;);
118     }
119     // Go through all types in lazyTypeMap and types.
120     // Resolve all LazyTypes.
121     resolveLazyMap(listener);
<span class="line-modified">122     for (ListIterator iter = types.listIterator(); iter.hasNext(); ) {</span>
123       BasicType t = (BasicType) iter.next();
124       BasicType t2 = (BasicType) t.resolveTypes(this, listener);
125       if (t != t2) {
126         iter.set(t2);
127       }
128     }
129     // Go through all symbols and resolve references to types and
130     // references to other symbols
131     for (Iterator iter = blocks.iterator(); iter.hasNext(); ) {
132       ((BasicSym) iter.next()).resolve(this, listener);
133     }
134     for (Iterator iter = nameToSymMap.values().iterator(); iter.hasNext(); ) {
135       ((BasicSym) iter.next()).resolve(this, listener);
136     }
137 
138     // Sort blocks in ascending order of starting address (but do not
139     // change ordering among blocks with the same starting address)
<span class="line-modified">140     Collections.sort(blocks, new Comparator() {</span>
<span class="line-modified">141         public int compare(Object o1, Object o2) {</span>
<span class="line-removed">142           BlockSym b1 = (BlockSym) o1;</span>
<span class="line-removed">143           BlockSym b2 = (BlockSym) o2;</span>
144           Address a1 = b1.getAddress();
145           Address a2 = b2.getAddress();
146           if (AddressOps.lt(a1, a2)) { return -1; }
147           if (AddressOps.gt(a1, a2)) { return 1; }
148           return 0;
149         }
150       });
151 
152     state = RESOLVED_STATE;
153   }
154 
155   public void endConstruction() {
156     if (Assert.ASSERTS_ENABLED) {
157       Assert.that(state == RESOLVED_STATE, &quot;wrong state&quot;);
158     }
159     // Move all types to type list
<span class="line-modified">160     for (Iterator iter = lazyTypeMap.values().iterator(); iter.hasNext(); ) {</span>
161       types.add(iter.next());
162     }
163     // Build name-to-type map
<span class="line-modified">164     nameToTypeMap = new HashMap();</span>
165     for (Iterator iter = types.iterator(); iter.hasNext(); ) {
166       Type t = (Type) iter.next();
167       if (!t.isConst() &amp;&amp; !t.isVolatile()) {
168         nameToTypeMap.put(t.getName(), t);
169       }
170     }
171     // Lose lazy maps
172     lazyTypeMap = null;
173     lazySymMap  = null;
174     // Sort and finish line number information
175     lineNumbers.sort();
176     // FIXME: on some platforms it might not be necessary to call
177     // recomputeEndPCs(). Will have to see what stabs information
178     // looks like. Should make configurable whether we make this call
179     // or not.
180     lineNumbers.recomputeEndPCs();
181 
182     state = COMPLETE_STATE;
183   }
184 
</pre>
<hr />
<pre>
320     if (Assert.ASSERTS_ENABLED) {
321       Assert.that(state == CONSTRUCTION_STATE, &quot;wrong state&quot;);
322     }
323     if (basicTargetSym.isLazy()) {
324       BasicSym resolved = (BasicSym) lazySymMap.get(((LazyBlockSym) targetSym).getKey());
325       // FIXME: would like to have an assert here that the target is
326       // non-null, but apparently have bugs here
327       if (resolved == null) {
328         listener.resolveFailed(containingSymbol, (LazyBlockSym) targetSym, detail);
329         return targetSym;
330       }
331       if (resolved.isLazy()) {
332         listener.resolveFailed(containingSymbol, (LazyBlockSym) targetSym, detail);
333       }
334       return resolved;
335     }
336     return targetSym;
337   }
338 
339   private void resolveLazyMap(ResolveListener listener) {
<span class="line-modified">340     for (Iterator iter = lazyTypeMap.entrySet().iterator(); iter.hasNext(); ) {</span>
<span class="line-modified">341       Map.Entry entry = (Map.Entry) iter.next();</span>
342       BasicType t = (BasicType) entry.getValue();
343       BasicType t2 = (BasicType) t.resolveTypes(this, listener);
344       if (t2 != t) {
345         entry.setValue(t2);
346       }
347     }
348   }
349 
350   /** Find the block whose starting address is closest to but less
351       than the given address. */
352   private BlockSym searchBlocks(Address addr, int lowIdx, int highIdx) {
353     if (highIdx &lt; lowIdx) return null;
354     if ((lowIdx == highIdx) || (lowIdx == highIdx - 1)) {
355       // Base case: start with highIdx and walk backward. See whether
356       // addr is greater than any of the blocks&#39; starting addresses,
357       // and if so, return that block.
358       Address lastAddr = null;
359       BlockSym ret = null;
360       for (int i = highIdx; i &gt;= 0; --i) {
361         BlockSym block = (BlockSym) blocks.get(i);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 26 
 27 import java.util.*;
 28 import sun.jvm.hotspot.debugger.*;
 29 import sun.jvm.hotspot.debugger.cdbg.*;
 30 import sun.jvm.hotspot.utilities.AddressOps;
 31 import sun.jvm.hotspot.utilities.Assert;
 32 
 33 public class BasicCDebugInfoDataBase implements CDebugInfoDataBase {
 34   private static final int INITIALIZED_STATE  = 0;
 35   private static final int CONSTRUCTION_STATE = 1;
 36   private static final int RESOLVED_STATE     = 2;
 37   private static final int COMPLETE_STATE     = 3;
 38 
 39   private int state = INITIALIZED_STATE;
 40 
 41   ///////////
 42   // Types //
 43   ///////////
 44 
 45   // Used only during construction
<span class="line-modified"> 46   private Map&lt;Object, Type&gt; lazyTypeMap;</span>
 47 
 48   // Used during construction and at run time for iteration
<span class="line-modified"> 49   private List&lt;Type&gt; types;</span>
 50 
 51   // Used only during runtime
<span class="line-modified"> 52   private Map&lt;String, Type&gt; nameToTypeMap;</span>
 53 
 54   /////////////
 55   // Symbols //
 56   /////////////
 57 
 58   // Used only during construction
<span class="line-modified"> 59   private Map&lt;Object, BlockSym&gt; lazySymMap;</span>
 60 
 61   // List of blocks in increasing order by starting address. These can
 62   // then be binary searched.
<span class="line-modified"> 63   private List&lt;BlockSym&gt; blocks;</span>
 64 
 65   // Name-to-global symbol table
<span class="line-modified"> 66   private Map&lt;String, GlobalSym&gt; nameToSymMap;</span>
 67 
 68   //////////////////
 69   // Line numbers //
 70   //////////////////
 71 
 72   private BasicLineNumberMapping lineNumbers;
 73 
 74   /** Supports lazy instantiation and references between types and
 75       symbols via insertion using arbitrary Object keys that are
 76       wrapped by LazyTypes. Once the database has been fully
 77       constructed and all types are present, one should call
 78       resolveTypes(), which will resolve all LazyTypes down to
 79       concrete types (and signal an error if some lazy types were
 80       unresolved). */
 81   public void beginConstruction() {
 82     if (Assert.ASSERTS_ENABLED) {
 83       Assert.that(state == INITIALIZED_STATE, &quot;wrong state&quot;);
 84     }
 85     state   = CONSTRUCTION_STATE;
 86 
 87     // Types
<span class="line-modified"> 88     lazyTypeMap  = new HashMap&lt;&gt;();</span>
<span class="line-modified"> 89     types        = new ArrayList&lt;&gt;();</span>
 90 
 91     // Symbols
<span class="line-modified"> 92     lazySymMap   = new HashMap&lt;&gt;();</span>
<span class="line-modified"> 93     blocks       = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 94     nameToSymMap = new HashMap&lt;&gt;();</span>
 95 
 96     // Line numbers
 97     lineNumbers  = new BasicLineNumberMapping();
 98   }
 99 
100   /** Add a type which may later in construction be referred to via a
101       LazyType with this key. lazyKey may be null. */
102   public void addType(Object lazyKey, Type type) {
103     if (Assert.ASSERTS_ENABLED) {
104       Assert.that(state == CONSTRUCTION_STATE, &quot;wrong state&quot;);
105     }
106     if (lazyKey != null) {
107       if (lazyTypeMap.put(lazyKey, type) != null) {
108         throw new RuntimeException(&quot;Type redefined for lazy key &quot; + lazyKey);
109       }
110     } else {
111       types.add(type);
112     }
113   }
114 
115   public void resolve(ResolveListener listener) {
116     if (Assert.ASSERTS_ENABLED) {
117       Assert.that(state == CONSTRUCTION_STATE, &quot;wrong state&quot;);
118     }
119     // Go through all types in lazyTypeMap and types.
120     // Resolve all LazyTypes.
121     resolveLazyMap(listener);
<span class="line-modified">122     for (ListIterator&lt;Type&gt; iter = types.listIterator(); iter.hasNext(); ) {</span>
123       BasicType t = (BasicType) iter.next();
124       BasicType t2 = (BasicType) t.resolveTypes(this, listener);
125       if (t != t2) {
126         iter.set(t2);
127       }
128     }
129     // Go through all symbols and resolve references to types and
130     // references to other symbols
131     for (Iterator iter = blocks.iterator(); iter.hasNext(); ) {
132       ((BasicSym) iter.next()).resolve(this, listener);
133     }
134     for (Iterator iter = nameToSymMap.values().iterator(); iter.hasNext(); ) {
135       ((BasicSym) iter.next()).resolve(this, listener);
136     }
137 
138     // Sort blocks in ascending order of starting address (but do not
139     // change ordering among blocks with the same starting address)
<span class="line-modified">140     Collections.sort(blocks, new Comparator&lt;&gt;() {</span>
<span class="line-modified">141         public int compare(BlockSym b1, BlockSym b2) {</span>


142           Address a1 = b1.getAddress();
143           Address a2 = b2.getAddress();
144           if (AddressOps.lt(a1, a2)) { return -1; }
145           if (AddressOps.gt(a1, a2)) { return 1; }
146           return 0;
147         }
148       });
149 
150     state = RESOLVED_STATE;
151   }
152 
153   public void endConstruction() {
154     if (Assert.ASSERTS_ENABLED) {
155       Assert.that(state == RESOLVED_STATE, &quot;wrong state&quot;);
156     }
157     // Move all types to type list
<span class="line-modified">158     for (Iterator&lt;Type&gt; iter = lazyTypeMap.values().iterator(); iter.hasNext(); ) {</span>
159       types.add(iter.next());
160     }
161     // Build name-to-type map
<span class="line-modified">162     nameToTypeMap = new HashMap&lt;&gt;();</span>
163     for (Iterator iter = types.iterator(); iter.hasNext(); ) {
164       Type t = (Type) iter.next();
165       if (!t.isConst() &amp;&amp; !t.isVolatile()) {
166         nameToTypeMap.put(t.getName(), t);
167       }
168     }
169     // Lose lazy maps
170     lazyTypeMap = null;
171     lazySymMap  = null;
172     // Sort and finish line number information
173     lineNumbers.sort();
174     // FIXME: on some platforms it might not be necessary to call
175     // recomputeEndPCs(). Will have to see what stabs information
176     // looks like. Should make configurable whether we make this call
177     // or not.
178     lineNumbers.recomputeEndPCs();
179 
180     state = COMPLETE_STATE;
181   }
182 
</pre>
<hr />
<pre>
318     if (Assert.ASSERTS_ENABLED) {
319       Assert.that(state == CONSTRUCTION_STATE, &quot;wrong state&quot;);
320     }
321     if (basicTargetSym.isLazy()) {
322       BasicSym resolved = (BasicSym) lazySymMap.get(((LazyBlockSym) targetSym).getKey());
323       // FIXME: would like to have an assert here that the target is
324       // non-null, but apparently have bugs here
325       if (resolved == null) {
326         listener.resolveFailed(containingSymbol, (LazyBlockSym) targetSym, detail);
327         return targetSym;
328       }
329       if (resolved.isLazy()) {
330         listener.resolveFailed(containingSymbol, (LazyBlockSym) targetSym, detail);
331       }
332       return resolved;
333     }
334     return targetSym;
335   }
336 
337   private void resolveLazyMap(ResolveListener listener) {
<span class="line-modified">338     for (Iterator&lt;Map.Entry&lt;Object, Type&gt;&gt; iter = lazyTypeMap.entrySet().iterator(); iter.hasNext(); ) {</span>
<span class="line-modified">339       Map.Entry&lt;Object, Type&gt; entry = iter.next();</span>
340       BasicType t = (BasicType) entry.getValue();
341       BasicType t2 = (BasicType) t.resolveTypes(this, listener);
342       if (t2 != t) {
343         entry.setValue(t2);
344       }
345     }
346   }
347 
348   /** Find the block whose starting address is closest to but less
349       than the given address. */
350   private BlockSym searchBlocks(Address addr, int lowIdx, int highIdx) {
351     if (highIdx &lt; lowIdx) return null;
352     if ((lowIdx == highIdx) || (lowIdx == highIdx - 1)) {
353       // Base case: start with highIdx and walk backward. See whether
354       // addr is greater than any of the blocks&#39; starting addresses,
355       // and if so, return that block.
356       Address lastAddr = null;
357       BlockSym ret = null;
358       for (int i = highIdx; i &gt;= 0; --i) {
359         BlockSym block = (BlockSym) blocks.get(i);
</pre>
</td>
</tr>
</table>
<center><a href="BasicBlockSym.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BasicCompoundType.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
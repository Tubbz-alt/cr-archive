<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/x86/X86Frame.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.runtime.x86;
 26 
 27 import java.util.*;
 28 import sun.jvm.hotspot.code.*;
 29 import sun.jvm.hotspot.compiler.*;
 30 import sun.jvm.hotspot.debugger.*;
 31 import sun.jvm.hotspot.oops.*;
 32 import sun.jvm.hotspot.runtime.*;
 33 import sun.jvm.hotspot.types.*;
 34 import sun.jvm.hotspot.utilities.*;
 35 
 36 /** Specialization of and implementation of abstract methods of the
 37     Frame class for the x86 family of CPUs. */
 38 
 39 public class X86Frame extends Frame {
 40   private static final boolean DEBUG;
 41   static {
 42     DEBUG = System.getProperty(&quot;sun.jvm.hotspot.runtime.x86.X86Frame.DEBUG&quot;) != null;
 43   }
 44 
 45   // All frames
 46   private static final int LINK_OFFSET                =  0;
 47   private static final int RETURN_ADDR_OFFSET         =  1;
 48   private static final int SENDER_SP_OFFSET           =  2;
 49 
 50   // Interpreter frames
 51   private static final int INTERPRETER_FRAME_SENDER_SP_OFFSET = -1;
 52   private static final int INTERPRETER_FRAME_LAST_SP_OFFSET   = INTERPRETER_FRAME_SENDER_SP_OFFSET - 1;
 53   private static final int INTERPRETER_FRAME_METHOD_OFFSET    = INTERPRETER_FRAME_LAST_SP_OFFSET - 1;
 54   private static       int INTERPRETER_FRAME_MIRROR_OFFSET;
 55   private static       int INTERPRETER_FRAME_MDX_OFFSET;         // Non-core builds only
 56   private static       int INTERPRETER_FRAME_CACHE_OFFSET;
 57   private static       int INTERPRETER_FRAME_LOCALS_OFFSET;
 58   private static       int INTERPRETER_FRAME_BCX_OFFSET;
 59   private static       int INTERPRETER_FRAME_INITIAL_SP_OFFSET;
 60   private static       int INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET;
 61   private static       int INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET;
 62 
 63   // Entry frames
 64   private static       int ENTRY_FRAME_CALL_WRAPPER_OFFSET;
 65 
 66   private static VMReg rbp;
 67 
 68   static {
 69     VM.registerVMInitializedObserver(new Observer() {
 70         public void update(Observable o, Object data) {
 71           initialize(VM.getVM().getTypeDataBase());
 72         }
 73       });
 74   }
 75 
 76   private static synchronized void initialize(TypeDataBase db) {
 77     INTERPRETER_FRAME_MIRROR_OFFSET               = INTERPRETER_FRAME_METHOD_OFFSET - 1;
 78     INTERPRETER_FRAME_MDX_OFFSET                  = INTERPRETER_FRAME_MIRROR_OFFSET - 1;
 79     INTERPRETER_FRAME_CACHE_OFFSET                = INTERPRETER_FRAME_MDX_OFFSET - 1;
 80     INTERPRETER_FRAME_LOCALS_OFFSET               = INTERPRETER_FRAME_CACHE_OFFSET - 1;
 81     INTERPRETER_FRAME_BCX_OFFSET                  = INTERPRETER_FRAME_LOCALS_OFFSET - 1;
 82     INTERPRETER_FRAME_INITIAL_SP_OFFSET           = INTERPRETER_FRAME_BCX_OFFSET - 1;
 83     INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET    = INTERPRETER_FRAME_INITIAL_SP_OFFSET;
 84     INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET = INTERPRETER_FRAME_INITIAL_SP_OFFSET;
 85 
 86     ENTRY_FRAME_CALL_WRAPPER_OFFSET = db.lookupIntConstant(&quot;frame::entry_frame_call_wrapper_offset&quot;);
 87     if (VM.getVM().getAddressSize() == 4) {
 88       rbp = new VMReg(5);
 89     } else {
 90       rbp = new VMReg(5 &lt;&lt; 1);
 91     }
 92   }
 93 
 94 
 95   // an additional field beyond sp and pc:
 96   Address raw_fp; // frame pointer
 97   private Address raw_unextendedSP;
 98   private Address live_bcp;
 99 
100   private X86Frame() {
101   }
102 
103   private void adjustForDeopt() {
104     if ( pc != null) {
105       // Look for a deopt pc and if it is deopted convert to original pc
106       CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);
107       if (cb != null &amp;&amp; cb.isJavaMethod()) {
108         NMethod nm = (NMethod) cb;
109         if (pc.equals(nm.deoptHandlerBegin())) {
110           if (Assert.ASSERTS_ENABLED) {
111             Assert.that(this.getUnextendedSP() != null, &quot;null SP in Java frame&quot;);
112           }
113           // adjust pc if frame is deoptimized.
114           pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());
115           deoptimized = true;
116         }
117       }
118     }
119   }
120 
121   private void initFrame(Address raw_sp, Address raw_fp, Address pc, Address raw_unextendedSp, Address live_bcp) {
122     this.raw_sp = raw_sp;
123     this.raw_fp = raw_fp;
124     if (raw_unextendedSp == null) {
125         this.raw_unextendedSP = raw_sp;
126     } else {
127         this.raw_unextendedSP = raw_unextendedSp;
128     }
129     if (pc == null) {
130         this.pc = raw_sp.getAddressAt(-1 * VM.getVM().getAddressSize());
131     } else {
132         this.pc = pc;
133     }
134     this.live_bcp = live_bcp;
135     adjustUnextendedSP();
136 
137     // Frame must be fully constructed before this call
138     adjustForDeopt();
139 }
140 
141 
142   public X86Frame(Address raw_sp, Address raw_fp, Address pc) {
143     initFrame(raw_sp, raw_fp, pc, null, null);
144 
145     if (DEBUG) {
146       System.out.println(&quot;X86Frame(sp, fp, pc): &quot; + this);
147       dumpStack();
148     }
149   }
150 
151   public X86Frame(Address raw_sp, Address raw_fp) {
152     initFrame(raw_sp, raw_fp, null, null, null);
153 
154     if (DEBUG) {
155       System.out.println(&quot;X86Frame(sp, fp): &quot; + this);
156       dumpStack();
157     }
158   }
159 
160   public X86Frame(Address raw_sp, Address raw_unextendedSp, Address raw_fp, Address pc) {
161     initFrame(raw_sp, raw_fp, pc, raw_unextendedSp, null);
162 
163     if (DEBUG) {
164       System.out.println(&quot;X86Frame(sp, unextendedSP, fp, pc): &quot; + this);
165       dumpStack();
166     }
167   }
168 
169   public X86Frame(Address raw_sp, Address raw_fp, Address pc, Address raw_unextendedSp, Address live_bcp) {
170     initFrame(raw_sp, raw_fp, pc, raw_unextendedSp, live_bcp);
171 
172     if (DEBUG) {
173       System.out.println(&quot;X86Frame(sp, fp, pc, unextendedSP, live_bcp): &quot; + this);
174       dumpStack();
175     }
176   }
177 
178   public Object clone() {
179     X86Frame frame = new X86Frame();
180     frame.raw_sp = raw_sp;
181     frame.raw_unextendedSP = raw_unextendedSP;
182     frame.raw_fp = raw_fp;
183     frame.pc = pc;
184     frame.deoptimized = deoptimized;
185     frame.live_bcp = live_bcp;
186     return frame;
187   }
188 
189   public boolean equals(Object arg) {
190     if (arg == null) {
191       return false;
192     }
193 
194     if (!(arg instanceof X86Frame)) {
195       return false;
196     }
197 
198     X86Frame other = (X86Frame) arg;
199 
200     return (AddressOps.equal(getSP(), other.getSP()) &amp;&amp;
201             AddressOps.equal(getUnextendedSP(), other.getUnextendedSP()) &amp;&amp;
202             AddressOps.equal(getFP(), other.getFP()) &amp;&amp;
203             AddressOps.equal(getPC(), other.getPC()));
204   }
205 
206   public int hashCode() {
207     if (raw_sp == null) {
208       return 0;
209     }
210 
211     return raw_sp.hashCode();
212   }
213 
214   public String toString() {
215     return &quot;sp: &quot; + (getSP() == null? &quot;null&quot; : getSP().toString()) +
216          &quot;, unextendedSP: &quot; + (getUnextendedSP() == null? &quot;null&quot; : getUnextendedSP().toString()) +
217          &quot;, fp: &quot; + (getFP() == null? &quot;null&quot; : getFP().toString()) +
218          &quot;, pc: &quot; + (pc == null? &quot;null&quot; : pc.toString());
219   }
220 
221   // accessors for the instance variables
222   public Address getFP() { return raw_fp; }
223   public Address getSP() { return raw_sp; }
224   public Address getID() { return raw_sp; }
225 
226   // FIXME: not implemented yet (should be done for Solaris/X86)
227   public boolean isSignalHandlerFrameDbg() { return false; }
228   public int     getSignalNumberDbg()      { return 0;     }
229   public String  getSignalNameDbg()        { return null;  }
230 
231   public boolean isInterpretedFrameValid() {
232     if (Assert.ASSERTS_ENABLED) {
233       Assert.that(isInterpretedFrame(), &quot;Not an interpreted frame&quot;);
234     }
235 
236     // These are reasonable sanity checks
237     if (getFP() == null || getFP().andWithMask(0x3) != null) {
238       return false;
239     }
240 
241     if (getSP() == null || getSP().andWithMask(0x3) != null) {
242       return false;
243     }
244 
245     if (getFP().addOffsetTo(INTERPRETER_FRAME_INITIAL_SP_OFFSET * VM.getVM().getAddressSize()).lessThan(getSP())) {
246       return false;
247     }
248 
249     // These are hacks to keep us out of trouble.
250     // The problem with these is that they mask other problems
251     if (getFP().lessThanOrEqual(getSP())) {
252       // this attempts to deal with unsigned comparison above
253       return false;
254     }
255 
256     if (getFP().minus(getSP()) &gt; 4096 * VM.getVM().getAddressSize()) {
257       // stack frames shouldn&#39;t be large.
258       return false;
259     }
260 
261     return true;
262   }
263 
264   // FIXME: not applicable in current system
265   //  void    patch_pc(Thread* thread, address pc);
266 
267   public Frame sender(RegisterMap regMap, CodeBlob cb) {
268     X86RegisterMap map = (X86RegisterMap) regMap;
269 
270     if (Assert.ASSERTS_ENABLED) {
271       Assert.that(map != null, &quot;map must be set&quot;);
272     }
273 
274     // Default is we done have to follow them. The sender_for_xxx will
275     // update it accordingly
276     map.setIncludeArgumentOops(false);
277 
278     if (isEntryFrame())       return senderForEntryFrame(map);
279     if (isInterpretedFrame()) return senderForInterpreterFrame(map);
280 
281     if(cb == null) {
282       cb = VM.getVM().getCodeCache().findBlob(getPC());
283     } else {
284       if (Assert.ASSERTS_ENABLED) {
285         Assert.that(cb.equals(VM.getVM().getCodeCache().findBlob(getPC())), &quot;Must be the same&quot;);
286       }
287     }
288 
289     if (cb != null) {
290       return senderForCompiledFrame(map, cb);
291     }
292 
293     // Must be native-compiled frame, i.e. the marshaling code for native
294     // methods that exists in the core system.
295     return new X86Frame(getSenderSP(), getLink(), getSenderPC());
296   }
297 
298   private Frame senderForEntryFrame(X86RegisterMap map) {
299     if (DEBUG) {
300       System.out.println(&quot;senderForEntryFrame&quot;);
301     }
302     if (Assert.ASSERTS_ENABLED) {
303       Assert.that(map != null, &quot;map must be set&quot;);
304     }
305     // Java frame called from C; skip all C frames and return top C
306     // frame of that chunk as the sender
307     X86JavaCallWrapper jcw = (X86JavaCallWrapper) getEntryFrameCallWrapper();
308     if (Assert.ASSERTS_ENABLED) {
309       Assert.that(!entryFrameIsFirst(), &quot;next Java fp must be non zero&quot;);
310       Assert.that(jcw.getLastJavaSP().greaterThan(getSP()), &quot;must be above this frame on stack&quot;);
311     }
312     X86Frame fr;
313     if (jcw.getLastJavaPC() != null) {
314       fr = new X86Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP(), jcw.getLastJavaPC());
315     } else {
316       fr = new X86Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP());
317     }
318     map.clear();
319     if (Assert.ASSERTS_ENABLED) {
320       Assert.that(map.getIncludeArgumentOops(), &quot;should be set by clear&quot;);
321     }
322     return fr;
323   }
324 
325   //------------------------------------------------------------------------------
326   // frame::adjust_unextended_sp
327   private void adjustUnextendedSP() {
328     // On x86, sites calling method handle intrinsics and lambda forms are treated
329     // as any other call site. Therefore, no special action is needed when we are
330     // returning to any of these call sites.
331 
332     CodeBlob cb = cb();
333     NMethod senderNm = (cb == null) ? null : cb.asNMethodOrNull();
334     if (senderNm != null) {
335       // If the sender PC is a deoptimization point, get the original PC.
336       if (senderNm.isDeoptEntry(getPC()) ||
337           senderNm.isDeoptMhEntry(getPC())) {
338         // DEBUG_ONLY(verifyDeoptriginalPc(senderNm, raw_unextendedSp));
339       }
340     }
341   }
342 
343   private Frame senderForInterpreterFrame(X86RegisterMap map) {
344     if (DEBUG) {
345       System.out.println(&quot;senderForInterpreterFrame&quot;);
346     }
347     Address unextendedSP = addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);
348     Address sp = addressOfStackSlot(SENDER_SP_OFFSET);
349     // We do not need to update the callee-save register mapping because above
350     // us is either another interpreter frame or a converter-frame, but never
351     // directly a compiled frame.
352     // 11/24/04 SFG. With the removal of adapter frames this is no longer true.
353     // However c2 no longer uses callee save register for java calls so there
354     // are no callee register to find.
355 
356     if (map.getUpdateMap())
357       updateMapWithSavedLink(map, addressOfStackSlot(LINK_OFFSET));
358 
359     return new X86Frame(sp, unextendedSP, getLink(), getSenderPC());
360   }
361 
362   private void updateMapWithSavedLink(RegisterMap map, Address savedFPAddr) {
363     map.setLocation(rbp, savedFPAddr);
364   }
365 
366   private Frame senderForCompiledFrame(X86RegisterMap map, CodeBlob cb) {
367     if (DEBUG) {
368       System.out.println(&quot;senderForCompiledFrame&quot;);
369     }
370 
371     //
372     // NOTE: some of this code is (unfortunately) duplicated in X86CurrentFrameGuess
373     //
374 
375     if (Assert.ASSERTS_ENABLED) {
376       Assert.that(map != null, &quot;map must be set&quot;);
377     }
378 
379     // frame owned by optimizing compiler
380     if (Assert.ASSERTS_ENABLED) {
381         Assert.that(cb.getFrameSize() &gt;= 0, &quot;must have non-zero frame size&quot;);
382     }
383     Address senderSP = getUnextendedSP().addOffsetTo(cb.getFrameSize());
384 
385     // On Intel the return_address is always the word on the stack
386     Address senderPC = senderSP.getAddressAt(-1 * VM.getVM().getAddressSize());
387 
388     // This is the saved value of EBP which may or may not really be an FP.
389     // It is only an FP if the sender is an interpreter frame (or C1?).
390     Address savedFPAddr = senderSP.addOffsetTo(- SENDER_SP_OFFSET * VM.getVM().getAddressSize());
391 
392     if (map.getUpdateMap()) {
393       // Tell GC to use argument oopmaps for some runtime stubs that need it.
394       // For C1, the runtime stub might not have oop maps, so set this flag
395       // outside of update_register_map.
396       map.setIncludeArgumentOops(cb.callerMustGCArguments());
397 
398       if (cb.getOopMaps() != null) {
399         ImmutableOopMapSet.updateRegisterMap(this, cb, map, true);
400       }
401 
402       // Since the prolog does the save and restore of EBP there is no oopmap
403       // for it so we must fill in its location as if there was an oopmap entry
404       // since if our caller was compiled code there could be live jvm state in it.
405       updateMapWithSavedLink(map, savedFPAddr);
406     }
407 
408     return new X86Frame(senderSP, savedFPAddr.getAddressAt(0), senderPC);
409   }
410 
411   protected boolean hasSenderPD() {
412     // FIXME
413     // Check for null ebp? Need to do some tests.
414     return true;
415   }
416 
417   public long frameSize() {
418     return (getSenderSP().minus(getSP()) / VM.getVM().getAddressSize());
419   }
420 
421   public Address getLink() {
422     return addressOfStackSlot(LINK_OFFSET).getAddressAt(0);
423   }
424 
425   public Address getUnextendedSP() { return raw_unextendedSP; }
426 
427   // Return address:
428   public Address getSenderPCAddr() { return addressOfStackSlot(RETURN_ADDR_OFFSET); }
429   public Address getSenderPC()     { return getSenderPCAddr().getAddressAt(0);      }
430 
431   public Address getSenderSP()     { return addressOfStackSlot(SENDER_SP_OFFSET); }
432 
433   public Address addressOfInterpreterFrameLocals() {
434     return addressOfStackSlot(INTERPRETER_FRAME_LOCALS_OFFSET);
435   }
436 
437   private Address addressOfInterpreterFrameBCX() {
438     return addressOfStackSlot(INTERPRETER_FRAME_BCX_OFFSET);
439   }
440 
441   public int getInterpreterFrameBCI() {
442     // FIXME: this is not atomic with respect to GC and is unsuitable
443     // for use in a non-debugging, or reflective, system. Need to
444     // figure out how to express this.
445     Address bcp = addressOfInterpreterFrameBCX().getAddressAt(0);
446 
447     // If we are in the top level frame then the bcp  may have been set for us. If so then let it
448     // take priority. If we are in a top level interpreter frame, the bcp is live in R13 (on x86)
449     // and not saved in the BCX stack slot.
450     if (live_bcp != null) {
451         bcp = live_bcp;
452     }
453 
454     Address methodHandle = addressOfInterpreterFrameMethod().getAddressAt(0);
455     Method method = (Method)Metadata.instantiateWrapperFor(methodHandle);
456     return bcpToBci(bcp, method);
457   }
458 
459   public Address addressOfInterpreterFrameMDX() {
460     return addressOfStackSlot(INTERPRETER_FRAME_MDX_OFFSET);
461   }
462 
463   // FIXME
464   //inline int frame::interpreter_frame_monitor_size() {
465   //  return BasicObjectLock::size();
466   //}
467 
468   // expression stack
469   // (the max_stack arguments are used by the GC; see class FrameClosure)
470 
471   public Address addressOfInterpreterFrameExpressionStack() {
472     Address monitorEnd = interpreterFrameMonitorEnd().address();
473     return monitorEnd.addOffsetTo(-1 * VM.getVM().getAddressSize());
474   }
475 
476   public int getInterpreterFrameExpressionStackDirection() { return -1; }
477 
478   // top of expression stack
479   public Address addressOfInterpreterFrameTOS() {
480     return getSP();
481   }
482 
483   /** Expression stack from top down */
484   public Address addressOfInterpreterFrameTOSAt(int slot) {
485     return addressOfInterpreterFrameTOS().addOffsetTo(slot * VM.getVM().getAddressSize());
486   }
487 
488   public Address getInterpreterFrameSenderSP() {
489     if (Assert.ASSERTS_ENABLED) {
490       Assert.that(isInterpretedFrame(), &quot;interpreted frame expected&quot;);
491     }
492     return addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);
493   }
494 
495   // Monitors
496   public BasicObjectLock interpreterFrameMonitorBegin() {
497     return new BasicObjectLock(addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET));
498   }
499 
500   public BasicObjectLock interpreterFrameMonitorEnd() {
501     Address result = addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET).getAddressAt(0);
502     if (Assert.ASSERTS_ENABLED) {
503       // make sure the pointer points inside the frame
504       Assert.that(AddressOps.gt(getFP(), result), &quot;result must &lt;  than frame pointer&quot;);
505       Assert.that(AddressOps.lte(getSP(), result), &quot;result must &gt;= than stack pointer&quot;);
506     }
507     return new BasicObjectLock(result);
508   }
509 
510   public int interpreterFrameMonitorSize() {
511     return BasicObjectLock.size();
512   }
513 
514   // Method
515   public Address addressOfInterpreterFrameMethod() {
516     return addressOfStackSlot(INTERPRETER_FRAME_METHOD_OFFSET);
517   }
518 
519   // Constant pool cache
520   public Address addressOfInterpreterFrameCPCache() {
521     return addressOfStackSlot(INTERPRETER_FRAME_CACHE_OFFSET);
522   }
523 
524   // Entry frames
525   public JavaCallWrapper getEntryFrameCallWrapper() {
526     return new X86JavaCallWrapper(addressOfStackSlot(ENTRY_FRAME_CALL_WRAPPER_OFFSET).getAddressAt(0));
527   }
528 
529   protected Address addressOfSavedOopResult() {
530     // offset is 2 for compiler2 and 3 for compiler1
531     return getSP().addOffsetTo((VM.getVM().isClientCompiler() ? 2 : 3) *
532                                VM.getVM().getAddressSize());
533   }
534 
535   protected Address addressOfSavedReceiver() {
536     return getSP().addOffsetTo(-4 * VM.getVM().getAddressSize());
537   }
538 
539   private void dumpStack() {
540     if (getFP() != null) {
541       for (Address addr = getSP().addOffsetTo(-5 * VM.getVM().getAddressSize());
542            AddressOps.lte(addr, getFP().addOffsetTo(5 * VM.getVM().getAddressSize()));
543            addr = addr.addOffsetTo(VM.getVM().getAddressSize())) {
544         System.out.println(addr + &quot;: &quot; + addr.getAddressAt(0));
545       }
546     } else {
547       for (Address addr = getSP().addOffsetTo(-5 * VM.getVM().getAddressSize());
548            AddressOps.lte(addr, getSP().addOffsetTo(20 * VM.getVM().getAddressSize()));
549            addr = addr.addOffsetTo(VM.getVM().getAddressSize())) {
550         System.out.println(addr + &quot;: &quot; + addr.getAddressAt(0));
551       }
552     }
553   }
554 }
    </pre>
  </body>
</html>
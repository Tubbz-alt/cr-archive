<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/parser/TokenType.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.parser;
 27 
 28 import static jdk.nashorn.internal.parser.TokenKind.BINARY;
 29 import static jdk.nashorn.internal.parser.TokenKind.BRACKET;
 30 import static jdk.nashorn.internal.parser.TokenKind.FUTURE;
 31 import static jdk.nashorn.internal.parser.TokenKind.FUTURESTRICT;
 32 import static jdk.nashorn.internal.parser.TokenKind.IR;
 33 import static jdk.nashorn.internal.parser.TokenKind.KEYWORD;
 34 import static jdk.nashorn.internal.parser.TokenKind.LITERAL;
 35 import static jdk.nashorn.internal.parser.TokenKind.SPECIAL;
 36 import static jdk.nashorn.internal.parser.TokenKind.UNARY;
 37 
 38 import java.util.Locale;
 39 
 40 /**
 41  * Description of all the JavaScript tokens.
 42  */
 43 @SuppressWarnings(&quot;javadoc&quot;)
 44 public enum TokenType {
 45     ERROR                (SPECIAL,  null),
 46     EOF                  (SPECIAL,  null),
 47     EOL                  (SPECIAL,  null),
 48     COMMENT              (SPECIAL,  null),
 49     // comments of the form //@ foo=bar or //# foo=bar
 50     // These comments are treated as special instructions
 51     // to the lexer, parser or codegenerator.
 52     DIRECTIVE_COMMENT    (SPECIAL,  null),
 53 
 54     NOT            (UNARY,   &quot;!&quot;,    14, false),
 55     NE             (BINARY,  &quot;!=&quot;,    9, true),
 56     NE_STRICT      (BINARY,  &quot;!==&quot;,   9, true),
 57     MOD            (BINARY,  &quot;%&quot;,    13, true),
 58     ASSIGN_MOD     (BINARY,  &quot;%=&quot;,    2, false),
 59     BIT_AND        (BINARY,  &quot;&amp;&quot;,     8, true),
 60     AND            (BINARY,  &quot;&amp;&amp;&quot;,    5, true),
 61     ASSIGN_BIT_AND (BINARY,  &quot;&amp;=&quot;,    2, false),
 62     LPAREN         (BRACKET, &quot;(&quot;,    16, true),
 63     RPAREN         (BRACKET, &quot;)&quot;,     0, true),
 64     MUL            (BINARY,  &quot;*&quot;,    13, true),
 65     ASSIGN_MUL     (BINARY,  &quot;*=&quot;,    2, false),
 66     POS            (UNARY,   &quot;+&quot;,    14, false),
 67     ADD            (BINARY,  &quot;+&quot;,    12, true),
 68     INCPREFIX      (UNARY,   &quot;++&quot;,   15, true),
 69     ASSIGN_ADD     (BINARY,  &quot;+=&quot;,    2, false),
 70     COMMARIGHT     (BINARY,  &quot;,&quot;,     1, true),
 71     NEG            (UNARY,   &quot;-&quot;,    14, false),
 72     SUB            (BINARY,  &quot;-&quot;,    12, true),
 73     DECPREFIX      (UNARY,   &quot;--&quot;,   15, true),
 74     ASSIGN_SUB     (BINARY,  &quot;-=&quot;,    2, false),
 75     PERIOD         (BRACKET, &quot;.&quot;,    17, true),
 76     DIV            (BINARY,  &quot;/&quot;,    13, true),
 77     ASSIGN_DIV     (BINARY,  &quot;/=&quot;,    2, false),
 78     COLON          (BINARY,  &quot;:&quot;),
 79     SEMICOLON      (BINARY,  &quot;;&quot;),
 80     LT             (BINARY,  &quot;&lt;&quot;,    10, true),
 81     SHL            (BINARY,  &quot;&lt;&lt;&quot;,   11, true),
 82     ASSIGN_SHL     (BINARY,  &quot;&lt;&lt;=&quot;,   2, false),
 83     LE             (BINARY,  &quot;&lt;=&quot;,   10, true),
 84     ASSIGN         (BINARY,  &quot;=&quot;,     2, false),
 85     EQ             (BINARY,  &quot;==&quot;,    9, true),
 86     EQ_STRICT      (BINARY,  &quot;===&quot;,   9, true),
 87     ARROW          (BINARY,  &quot;=&gt;&quot;,    2, true),
 88     GT             (BINARY,  &quot;&gt;&quot;,    10, true),
 89     GE             (BINARY,  &quot;&gt;=&quot;,   10, true),
 90     SAR            (BINARY,  &quot;&gt;&gt;&quot;,   11, true),
 91     ASSIGN_SAR     (BINARY,  &quot;&gt;&gt;=&quot;,   2, false),
 92     SHR            (BINARY,  &quot;&gt;&gt;&gt;&quot;,  11, true),
 93     ASSIGN_SHR     (BINARY,  &quot;&gt;&gt;&gt;=&quot;,  2, false),
 94     TERNARY        (BINARY,  &quot;?&quot;,     3, false),
 95     LBRACKET       (BRACKET, &quot;[&quot;,    17, true),
 96     RBRACKET       (BRACKET, &quot;]&quot;,     0, true),
 97     BIT_XOR        (BINARY,  &quot;^&quot;,     7, true),
 98     ASSIGN_BIT_XOR (BINARY,  &quot;^=&quot;,    2, false),
 99     LBRACE         (BRACKET,  &quot;{&quot;),
100     BIT_OR         (BINARY,  &quot;|&quot;,     6, true),
101     ASSIGN_BIT_OR  (BINARY,  &quot;|=&quot;,    2, false),
102     OR             (BINARY,  &quot;||&quot;,    4, true),
103     RBRACE         (BRACKET, &quot;}&quot;),
104     BIT_NOT        (UNARY,   &quot;~&quot;,     14, false),
105     ELLIPSIS       (UNARY,   &quot;...&quot;),
106 
107     // ECMA 7.6.1.1 Keywords, 7.6.1.2 Future Reserved Words.
108     // All other Java keywords are commented out.
109 
110 //  ABSTRACT       (FUTURE,   &quot;abstract&quot;),
111 //  BOOLEAN        (FUTURE,   &quot;boolean&quot;),
112     BREAK          (KEYWORD,  &quot;break&quot;),
113 //  BYTE           (FUTURE,   &quot;byte&quot;),
114     CASE           (KEYWORD,  &quot;case&quot;),
115     CATCH          (KEYWORD,  &quot;catch&quot;),
116 //  CHAR           (FUTURE,   &quot;char&quot;),
117     CLASS          (FUTURE,   &quot;class&quot;),
118     CONST          (KEYWORD,  &quot;const&quot;),
119     CONTINUE       (KEYWORD,  &quot;continue&quot;),
120     DEBUGGER       (KEYWORD,  &quot;debugger&quot;),
121     DEFAULT        (KEYWORD,  &quot;default&quot;),
122     DELETE         (UNARY,    &quot;delete&quot;,     14, false),
123     DO             (KEYWORD,  &quot;do&quot;),
124 //  DOUBLE         (FUTURE,   &quot;double&quot;),
125 //  EACH           (KEYWORD,  &quot;each&quot;),  // Contextual.
126     ELSE           (KEYWORD,  &quot;else&quot;),
127     ENUM           (FUTURE,   &quot;enum&quot;),
128     EXPORT         (FUTURE,   &quot;export&quot;),
129     EXTENDS        (FUTURE,   &quot;extends&quot;),
130     FALSE          (LITERAL,  &quot;false&quot;),
131 //  FINAL          (FUTURE,   &quot;final&quot;),
132     FINALLY        (KEYWORD,  &quot;finally&quot;),
133 //  FLOAT          (FUTURE,   &quot;float&quot;),
134     FOR            (KEYWORD,  &quot;for&quot;),
135     FUNCTION       (KEYWORD,  &quot;function&quot;),
136 //  GET            (KEYWORD,  &quot;get&quot;), // Contextual.
137 //  GOTO           (FUTURE,   &quot;goto&quot;),
138     IF             (KEYWORD,   &quot;if&quot;),
139     IMPLEMENTS     (FUTURESTRICT,   &quot;implements&quot;),
140     IMPORT         (FUTURE,   &quot;import&quot;),
141     IN             (BINARY,   &quot;in&quot;,         10, true),
142     INSTANCEOF     (BINARY,   &quot;instanceof&quot;, 10, true),
143 //  INT            (FUTURE,   &quot;int&quot;),
144     INTERFACE      (FUTURESTRICT,   &quot;interface&quot;),
145     LET            (FUTURESTRICT,   &quot;let&quot;),
146 //  LONG           (FUTURE,   &quot;long&quot;),
147 //  NATIVE         (FUTURE,   &quot;native&quot;),
148     NEW            (UNARY,    &quot;new&quot;,        17, false),
149     NULL           (LITERAL,  &quot;null&quot;),
150     PACKAGE        (FUTURESTRICT,   &quot;package&quot;),
151     PRIVATE        (FUTURESTRICT,   &quot;private&quot;),
152     PROTECTED      (FUTURESTRICT,   &quot;protected&quot;),
153     PUBLIC         (FUTURESTRICT,   &quot;public&quot;),
154     RETURN         (KEYWORD,  &quot;return&quot;),
155 //  SET            (KEYWORD,  &quot;set&quot;), // Contextual.
156 //  SHORT          (FUTURE,   &quot;short&quot;),
157     STATIC         (FUTURESTRICT,   &quot;static&quot;),
158     SUPER          (FUTURE,   &quot;super&quot;),
159     SWITCH         (KEYWORD,  &quot;switch&quot;),
160 //  SYNCHRONIZED   (FUTURE,   &quot;synchronized&quot;),
161     THIS           (KEYWORD,  &quot;this&quot;),
162     THROW          (KEYWORD,  &quot;throw&quot;),
163 //  THROWS         (FUTURE,   &quot;throws&quot;),
164 //  TRANSIENT      (FUTURE,   &quot;transient&quot;),
165     TRUE           (LITERAL,  &quot;true&quot;),
166     TRY            (KEYWORD,  &quot;try&quot;),
167     TYPEOF         (UNARY,    &quot;typeof&quot;,     14, false),
168     VAR            (KEYWORD,  &quot;var&quot;),
169     VOID           (UNARY,    &quot;void&quot;,       14, false),
170 //  VOLATILE       (FUTURE,   &quot;volatile&quot;),
171     WHILE          (KEYWORD,  &quot;while&quot;),
172     WITH           (KEYWORD,  &quot;with&quot;),
173     YIELD          (FUTURESTRICT,  &quot;yield&quot;),
174 
175     DECIMAL        (LITERAL,  null),
176     HEXADECIMAL    (LITERAL,  null),
177     OCTAL_LEGACY   (LITERAL,  null),
178     OCTAL          (LITERAL,  null),
179     BINARY_NUMBER  (LITERAL,  null),
180     FLOATING       (LITERAL,  null),
181     STRING         (LITERAL,  null),
182     ESCSTRING      (LITERAL,  null),
183     EXECSTRING     (LITERAL,  null),
184     IDENT          (LITERAL,  null),
185     REGEX          (LITERAL,  null),
186     XML            (LITERAL,  null),
187     OBJECT         (LITERAL,  null),
188     ARRAY          (LITERAL,  null),
189     TEMPLATE       (LITERAL,  null),
190     TEMPLATE_HEAD  (LITERAL,  null),
191     TEMPLATE_MIDDLE(LITERAL,  null),
192     TEMPLATE_TAIL  (LITERAL,  null),
193 
194     DECPOSTFIX     (IR,       null),
195     INCPOSTFIX     (IR,       null),
196     SPREAD_ARGUMENT(IR,       null),
197     SPREAD_ARRAY   (IR,       null),
198     YIELD_STAR     (IR,       null);
199 
200     /** Next token kind in token lookup table. */
201     private TokenType next;
202 
203     /** Classification of token. */
204     private final TokenKind kind;
205 
206     /** Printable name of token. */
207     private final String name;
208 
209     /** Operator precedence. */
210     private final int precedence;
211 
212     /** Left associativity */
213     private final boolean isLeftAssociative;
214 
215     /** Cache values to avoid cloning. */
216     private static final TokenType[] values;
217 
218     TokenType(final TokenKind kind, final String name) {
219         next              = null;
220         this.kind         = kind;
221         this.name         = name;
222         precedence        = 0;
223         isLeftAssociative = false;
224     }
225 
226     TokenType(final TokenKind kind, final String name, final int precedence, final boolean isLeftAssociative) {
227         next                   = null;
228         this.kind              = kind;
229         this.name              = name;
230         this.precedence        = precedence;
231         this.isLeftAssociative = isLeftAssociative;
232     }
233 
234     /**
235      * Determines if the token has greater precedence than other.
236      *
237      * @param other  Compare token.
238      * @param isLeft Is to the left of the other.
239      *
240      * @return {@code true} if greater precedence.
241      */
242     public boolean needsParens(final TokenType other, final boolean isLeft) {
243         return other.precedence != 0 &amp;&amp;
244                (precedence &gt; other.precedence ||
245                precedence == other.precedence &amp;&amp; isLeftAssociative &amp;&amp; !isLeft);
246     }
247 
248     /**
249      * Determines if the type is a valid operator.
250      *
251      * @param noIn {@code true} if IN operator should be ignored.
252      *
253      * @return {@code true} if valid operator.
254      */
255     public boolean isOperator(final boolean noIn) {
256         return kind == BINARY &amp;&amp; (!noIn || this != IN) &amp;&amp; precedence != 0;
257     }
258 
259     public int getLength() {
260         assert name != null : &quot;Token name not set&quot;;
261         return name.length();
262     }
263 
264     public String getName() {
265         return name;
266     }
267 
268     public String getNameOrType() {
269         return name == null ? super.name().toLowerCase(Locale.ENGLISH) : name;
270     }
271 
272     public TokenType getNext() {
273         return next;
274     }
275 
276     public void setNext(final TokenType next) {
277         this.next = next;
278     }
279 
280     public TokenKind getKind() {
281         return kind;
282     }
283 
284     public int getPrecedence() {
285         return precedence;
286     }
287 
288     public boolean isLeftAssociative() {
289         return isLeftAssociative;
290     }
291 
292     boolean startsWith(final char c) {
293         return name != null &amp;&amp; name.length() &gt; 0 &amp;&amp; name.charAt(0) == c;
294     }
295 
296     static TokenType[] getValues() {
297        return values;
298     }
299 
300     @Override
301     public String toString() {
302         return getNameOrType();
303     }
304 
305     static {
306         // Avoid cloning of enumeration.
307         values = TokenType.values();
308     }
309 }
    </pre>
  </body>
</html>
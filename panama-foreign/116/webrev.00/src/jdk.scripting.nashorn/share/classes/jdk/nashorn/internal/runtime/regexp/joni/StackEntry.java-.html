<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/regexp/joni/StackEntry.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Permission is hereby granted, free of charge, to any person obtaining a copy of
  3  * this software and associated documentation files (the &quot;Software&quot;), to deal in
  4  * the Software without restriction, including without limitation the rights to
  5  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
  6  * of the Software, and to permit persons to whom the Software is furnished to do
  7  * so, subject to the following conditions:
  8  *
  9  * The above copyright notice and this permission notice shall be included in all
 10  * copies or substantial portions of the Software.
 11  *
 12  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 13  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 14  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 15  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 16  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 17  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 18  * SOFTWARE.
 19  */
 20 package jdk.nashorn.internal.runtime.regexp.joni;
 21 
 22 final class StackEntry {
 23     int type;
 24     private int E1, E2, E3, E4;
 25 
 26     // first union member
 27     /* byte code position */
 28     void setStatePCode(final int pcode) {
 29         E1 = pcode;
 30     }
 31     int getStatePCode() {
 32         return E1;
 33     }
 34     /* string position */
 35     void setStatePStr(final int pstr) {
 36         E2 = pstr;
 37     }
 38     int getStatePStr() {
 39         return E2;
 40     }
 41     /* previous char position of pstr */
 42     void setStatePStrPrev(final int pstrPrev) {
 43         E3 = pstrPrev;
 44     }
 45     int getStatePStrPrev() {
 46         return E3;
 47     }
 48 
 49     void setStateCheck(final int check) {
 50         E4 = check;
 51     }
 52     int getStateCheck() {
 53         return E4;
 54     }
 55 
 56     // second union member
 57     /* for OP_REPEAT_INC, OP_REPEAT_INC_NG */
 58     void setRepeatCount(final int count) {
 59         E1 = count;
 60     }
 61     int getRepeatCount() {
 62         return E1;
 63     }
 64     void decreaseRepeatCount() {
 65         E1--;
 66     }
 67     void increaseRepeatCount() {
 68         E1++;
 69     }
 70     /* byte code position (head of repeated target) */
 71     void setRepeatPCode(final int pcode) {
 72         E2 = pcode;
 73     }
 74     int getRepeatPCode() {
 75         return E2;
 76     }
 77     /* repeat id */
 78     void setRepeatNum(final int num) {
 79         E3 = num;
 80     }
 81     int getRepeatNum() {
 82         return E3;
 83     }
 84 
 85     // third union member
 86     /* index of stack */ /*int repeat_inc struct*/
 87     void setSi(final int si) {
 88         E1 = si;
 89     }
 90     int getSi() {
 91         return E1;
 92     }
 93 
 94     // fourth union member
 95     /* memory num */
 96     void setMemNum(final int num) {
 97         E1 = num;
 98     }
 99     int getMemNum() {
100         return E1;
101     }
102     /* start/end position */
103     void setMemPstr(final int pstr) {
104         E2 = pstr;
105     }
106     int getMemPStr() {
107         return E2;
108     }
109 
110     /* Following information is set, if this stack type is MEM-START */
111     /* prev. info (for backtrack  &quot;(...)*&quot; ) */
112     void setMemStart(final int start) {
113         E3 = start;
114     }
115     int getMemStart() {
116         return E3;
117     }
118     /* prev. info (for backtrack  &quot;(...)*&quot; ) */
119     void setMemEnd(final int end) {
120         E4 = end;
121     }
122     int getMemEnd() {
123         return E4;
124     }
125 
126     // fifth union member
127     /* null check id */
128     void setNullCheckNum(final int num) {
129         E1 = num;
130     }
131     int getNullCheckNum() {
132         return E1;
133     }
134     /* start position */
135     void setNullCheckPStr(final int pstr) {
136         E2 = pstr;
137     }
138     int getNullCheckPStr() {
139         return E2;
140     }
141 
142     // sixth union member
143     /* byte code position */
144     void setCallFrameRetAddr(final int addr) {
145         E1 = addr;
146     }
147     int getCallFrameRetAddr() {
148         return E1;
149     }
150     /* null check id */
151     void setCallFrameNum(final int num) {
152         E2 = num;
153     }
154     int getCallFrameNum() {
155         return E2;
156     }
157     /* string position */
158     void setCallFramePStr(final int pstr) {
159         E3 = pstr;
160     }
161     int getCallFramePStr() {
162         return E3;
163     }
164 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/Undefined.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.runtime;
 27 
 28 import static jdk.nashorn.internal.lookup.Lookup.MH;
 29 import static jdk.nashorn.internal.runtime.ECMAErrors.typeError;
 30 
 31 import java.lang.invoke.MethodHandle;
 32 import java.lang.invoke.MethodHandles;
 33 import jdk.dynalink.CallSiteDescriptor;
 34 import jdk.dynalink.NamedOperation;
 35 import jdk.dynalink.linker.GuardedInvocation;
 36 import jdk.dynalink.linker.support.Guards;
 37 import jdk.nashorn.internal.runtime.linker.NashornCallSiteDescriptor;
 38 
 39 /**
 40  * Unique instance of this class is used to represent JavaScript undefined.
 41  */
 42 public final class Undefined extends DefaultPropertyAccess {
 43 
 44     private Undefined() {
 45     }
 46 
 47     private static final Undefined UNDEFINED = new Undefined();
 48     private static final Undefined EMPTY     = new Undefined();
 49 
 50     // Guard used for indexed property access/set on the Undefined instance
 51     private static final MethodHandle UNDEFINED_GUARD = Guards.getIdentityGuard(UNDEFINED);
 52 
 53     /**
 54      * Get the value of {@code undefined}, this is represented as a global singleton
 55      * instance of this class. It can always be reference compared
 56      *
 57      * @return the undefined object
 58      */
 59     public static Undefined getUndefined() {
 60         return UNDEFINED;
 61     }
 62 
 63     /**
 64      * Get the value of {@code empty}. This is represented as a global singleton
 65      * instanceof this class. It can always be reference compared.
 66      * &lt;p&gt;
 67      * We need empty to differentiate behavior in things like array iterators
 68      * &lt;p&gt;
 69      * @return the empty object
 70      */
 71     public static Undefined getEmpty() {
 72         return EMPTY;
 73     }
 74 
 75     /**
 76      * Get the class name of Undefined
 77      * @return &quot;Undefined&quot;
 78      */
 79     @SuppressWarnings(&quot;static-method&quot;)
 80     public String getClassName() {
 81         return &quot;Undefined&quot;;
 82     }
 83 
 84     @Override
 85     public String toString() {
 86         return &quot;undefined&quot;;
 87     }
 88 
 89     /**
 90      * Lookup the appropriate method for an invoke dynamic call.
 91      * @param desc The invoke dynamic callsite descriptor.
 92      * @return GuardedInvocation to be invoked at call site.
 93      */
 94     public static GuardedInvocation lookup(final CallSiteDescriptor desc) {
 95         switch (NashornCallSiteDescriptor.getStandardOperation(desc)) {
 96         case CALL:
 97         case NEW:
 98             final String name = NashornCallSiteDescriptor.getOperand(desc);
 99             final String msg = name != null? &quot;not.a.function&quot; : &quot;cant.call.undefined&quot;;
100             throw typeError(msg, name);
101         case GET:
102             // NOTE: we support GET:ELEMENT and SET:ELEMENT as JavaScript doesn&#39;t distinguish items from properties. Nashorn itself
103             // emits &quot;GET:PROPERTY|ELEMENT|METHOD:identifier&quot; for &quot;&lt;expr&gt;.&lt;identifier&gt;&quot; and &quot;GET:ELEMENT|PROPERTY|METHOD&quot; for &quot;&lt;expr&gt;[&lt;expr&gt;]&quot;, but we are
104             // more flexible here and dispatch not on operation name (getProp vs. getElem), but rather on whether the
105             // operation has an associated name or not.
106             if (!(desc.getOperation() instanceof NamedOperation)) {
107                 return findGetIndexMethod(desc);
108             }
109             return findGetMethod(desc);
110         case SET:
111             if (!(desc.getOperation() instanceof NamedOperation)) {
112                 return findSetIndexMethod(desc);
113             }
114             return findSetMethod(desc);
115         case REMOVE:
116             if (!(desc.getOperation() instanceof NamedOperation)) {
117                 return findDeleteIndexMethod(desc);
118             }
119             return findDeleteMethod(desc);
120         default:
121         }
122         return null;
123     }
124 
125     private static ECMAException lookupTypeError(final String msg, final CallSiteDescriptor desc) {
126         final String name = NashornCallSiteDescriptor.getOperand(desc);
127         return typeError(msg, name != null &amp;&amp; !name.isEmpty()? name : null);
128     }
129 
130     private static final MethodHandle GET_METHOD = findOwnMH(&quot;get&quot;, Object.class, Object.class);
131     private static final MethodHandle SET_METHOD = MH.insertArguments(findOwnMH(&quot;set&quot;, void.class, Object.class, Object.class, int.class), 3, NashornCallSiteDescriptor.CALLSITE_STRICT);
132     private static final MethodHandle DELETE_METHOD = MH.insertArguments(findOwnMH(&quot;delete&quot;, boolean.class, Object.class, boolean.class), 2, false);
133 
134     private static GuardedInvocation findGetMethod(final CallSiteDescriptor desc) {
135         return new GuardedInvocation(MH.insertArguments(GET_METHOD, 1, NashornCallSiteDescriptor.getOperand(desc)), UNDEFINED_GUARD).asType(desc);
136     }
137 
138     private static GuardedInvocation findGetIndexMethod(final CallSiteDescriptor desc) {
139         return new GuardedInvocation(GET_METHOD, UNDEFINED_GUARD).asType(desc);
140     }
141 
142     private static GuardedInvocation findSetMethod(final CallSiteDescriptor desc) {
143         return new GuardedInvocation(MH.insertArguments(SET_METHOD, 1, NashornCallSiteDescriptor.getOperand(desc)), UNDEFINED_GUARD).asType(desc);
144     }
145 
146     private static GuardedInvocation findSetIndexMethod(final CallSiteDescriptor desc) {
147         return new GuardedInvocation(SET_METHOD, UNDEFINED_GUARD).asType(desc);
148     }
149 
150     private static GuardedInvocation findDeleteMethod(final CallSiteDescriptor desc) {
151         return new GuardedInvocation(MH.insertArguments(DELETE_METHOD, 1, NashornCallSiteDescriptor.getOperand(desc)), UNDEFINED_GUARD).asType(desc);
152     }
153 
154     private static GuardedInvocation findDeleteIndexMethod(final CallSiteDescriptor desc) {
155         return new GuardedInvocation(DELETE_METHOD, UNDEFINED_GUARD).asType(desc);
156     }
157 
158 
159     @Override
160     public Object get(final Object key) {
161         throw typeError(&quot;cant.read.property.of.undefined&quot;, ScriptRuntime.safeToString(key));
162     }
163 
164     @Override
165     public void set(final Object key, final Object value, final int flags) {
166         throw typeError(&quot;cant.set.property.of.undefined&quot;, ScriptRuntime.safeToString(key));
167     }
168 
169     @Override
170     public boolean delete(final Object key, final boolean strict) {
171         throw typeError(&quot;cant.delete.property.of.undefined&quot;, ScriptRuntime.safeToString(key));
172     }
173 
174     @Override
175     public boolean has(final Object key) {
176         return false;
177     }
178 
179     @Override
180     public boolean hasOwnProperty(final Object key) {
181         return false;
182     }
183 
184     private static MethodHandle findOwnMH(final String name, final Class&lt;?&gt; rtype, final Class&lt;?&gt;... types) {
185         return MH.findVirtual(MethodHandles.lookup(), Undefined.class, name, MH.type(rtype, types));
186     }
187 }
    </pre>
  </body>
</html>
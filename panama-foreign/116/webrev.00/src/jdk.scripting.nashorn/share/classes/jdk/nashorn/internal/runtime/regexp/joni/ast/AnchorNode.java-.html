<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/regexp/joni/ast/AnchorNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Permission is hereby granted, free of charge, to any person obtaining a copy of
  3  * this software and associated documentation files (the &quot;Software&quot;), to deal in
  4  * the Software without restriction, including without limitation the rights to
  5  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
  6  * of the Software, and to permit persons to whom the Software is furnished to do
  7  * so, subject to the following conditions:
  8  *
  9  * The above copyright notice and this permission notice shall be included in all
 10  * copies or substantial portions of the Software.
 11  *
 12  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 13  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 14  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 15  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 16  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 17  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 18  * SOFTWARE.
 19  */
 20 package jdk.nashorn.internal.runtime.regexp.joni.ast;
 21 
 22 import jdk.nashorn.internal.runtime.regexp.joni.constants.AnchorType;
 23 
 24 @SuppressWarnings(&quot;javadoc&quot;)
 25 public final class AnchorNode extends Node implements AnchorType {
 26     public int type;
 27     public Node target;
 28     public int charLength;
 29 
 30     public AnchorNode(final int type) {
 31         this.type = type;
 32         charLength = -1;
 33     }
 34 
 35     @Override
 36     public int getType() {
 37         return ANCHOR;
 38     }
 39 
 40     @Override
 41     protected void setChild(final Node newChild) {
 42         target = newChild;
 43     }
 44 
 45     @Override
 46     protected Node getChild() {
 47         return target;
 48     }
 49 
 50     public void setTarget(final Node tgt) {
 51         target = tgt;
 52         tgt.parent = this;
 53     }
 54 
 55     @Override
 56     public String getName() {
 57         return &quot;Anchor&quot;;
 58     }
 59 
 60     @Override
 61     public String toString(final int level) {
 62         final StringBuilder value = new StringBuilder();
 63         value.append(&quot;\n  type: &quot;).append(typeToString());
 64         value.append(&quot;\n  target: &quot;).append(pad(target, level + 1));
 65         return value.toString();
 66     }
 67 
 68     public String typeToString() {
 69         final StringBuilder sb = new StringBuilder();
 70         if (isType(BEGIN_BUF)) {
 71             sb.append(&quot;BEGIN_BUF &quot;);
 72         }
 73         if (isType(BEGIN_LINE)) {
 74             sb.append(&quot;BEGIN_LINE &quot;);
 75         }
 76         if (isType(BEGIN_POSITION)) {
 77             sb.append(&quot;BEGIN_POSITION &quot;);
 78         }
 79         if (isType(END_BUF)) {
 80             sb.append(&quot;END_BUF &quot;);
 81         }
 82         if (isType(SEMI_END_BUF)) {
 83             sb.append(&quot;SEMI_END_BUF &quot;);
 84         }
 85         if (isType(END_LINE)) {
 86             sb.append(&quot;END_LINE &quot;);
 87         }
 88         if (isType(WORD_BOUND)) {
 89             sb.append(&quot;WORD_BOUND &quot;);
 90         }
 91         if (isType(NOT_WORD_BOUND)) {
 92             sb.append(&quot;NOT_WORD_BOUND &quot;);
 93         }
 94         if (isType(WORD_BEGIN)) {
 95             sb.append(&quot;WORD_BEGIN &quot;);
 96         }
 97         if (isType(WORD_END)) {
 98             sb.append(&quot;WORD_END &quot;);
 99         }
100         if (isType(PREC_READ)) {
101             sb.append(&quot;PREC_READ &quot;);
102         }
103         if (isType(PREC_READ_NOT)) {
104             sb.append(&quot;PREC_READ_NOT &quot;);
105         }
106         if (isType(LOOK_BEHIND)) {
107             sb.append(&quot;LOOK_BEHIND &quot;);
108         }
109         if (isType(LOOK_BEHIND_NOT)) {
110             sb.append(&quot;LOOK_BEHIND_NOT &quot;);
111         }
112         if (isType(ANYCHAR_STAR)) {
113             sb.append(&quot;ANYCHAR_STAR &quot;);
114         }
115         if (isType(ANYCHAR_STAR_ML)) {
116             sb.append(&quot;ANYCHAR_STAR_ML &quot;);
117         }
118         return sb.toString();
119     }
120 
121     private boolean isType(final int t) {
122         return (this.type &amp; t) != 0;
123     }
124 
125 }
    </pre>
  </body>
</html>
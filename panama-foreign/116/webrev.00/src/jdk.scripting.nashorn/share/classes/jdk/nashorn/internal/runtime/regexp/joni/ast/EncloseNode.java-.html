<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/regexp/joni/ast/EncloseNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Permission is hereby granted, free of charge, to any person obtaining a copy of
  3  * this software and associated documentation files (the &quot;Software&quot;), to deal in
  4  * the Software without restriction, including without limitation the rights to
  5  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
  6  * of the Software, and to permit persons to whom the Software is furnished to do
  7  * so, subject to the following conditions:
  8  *
  9  * The above copyright notice and this permission notice shall be included in all
 10  * copies or substantial portions of the Software.
 11  *
 12  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 13  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 14  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 15  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 16  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 17  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 18  * SOFTWARE.
 19  */
 20 package jdk.nashorn.internal.runtime.regexp.joni.ast;
 21 
 22 import jdk.nashorn.internal.runtime.regexp.joni.Option;
 23 import jdk.nashorn.internal.runtime.regexp.joni.constants.EncloseType;
 24 
 25 @SuppressWarnings(&quot;javadoc&quot;)
 26 public final class EncloseNode extends StateNode implements EncloseType {
 27 
 28     public final int type;                // enclose type
 29     public int regNum;
 30     public int option;
 31     public Node target;             /* EncloseNode : ENCLOSE_MEMORY */
 32     public int callAddr;            // AbsAddrType
 33     public int minLength;           // OnigDistance
 34     public int maxLength;           // OnigDistance
 35     public int charLength;
 36     public int optCount;            // referenced count in optimize_node_left()
 37 
 38     // node_new_enclose / onig_node_new_enclose
 39     public EncloseNode(final int type) {
 40         this.type = type;
 41         callAddr = -1;
 42     }
 43 
 44     // node_new_enclose_memory
 45     public EncloseNode() {
 46         this(MEMORY);
 47     }
 48 
 49     // node_new_option
 50     public EncloseNode(final int option, final int i) {
 51         this(OPTION);
 52         this.option = option;
 53     }
 54 
 55     @Override
 56     public int getType() {
 57         return ENCLOSE;
 58     }
 59 
 60     @Override
 61     protected void setChild(final Node newChild) {
 62         target = newChild;
 63     }
 64 
 65     @Override
 66     protected Node getChild() {
 67         return target;
 68     }
 69 
 70     public void setTarget(final Node tgt) {
 71         target = tgt;
 72         tgt.parent = this;
 73     }
 74 
 75     @Override
 76     public String getName() {
 77         return &quot;Enclose&quot;;
 78     }
 79 
 80     @Override
 81     public String toString(final int level) {
 82         final StringBuilder value = new StringBuilder(super.toString(level));
 83         value.append(&quot;\n  type: &quot;).append(typeToString());
 84         value.append(&quot;\n  regNum: &quot;).append(regNum);
 85         value.append(&quot;\n  option: &quot;).append(Option.toString(option));
 86         value.append(&quot;\n  target: &quot;).append(pad(target, level + 1));
 87         value.append(&quot;\n  callAddr: &quot;).append(callAddr);
 88         value.append(&quot;\n  minLength: &quot;).append(minLength);
 89         value.append(&quot;\n  maxLength: &quot;).append(maxLength);
 90         value.append(&quot;\n  charLength: &quot;).append(charLength);
 91         value.append(&quot;\n  optCount: &quot;).append(optCount);
 92 
 93         return value.toString();
 94     }
 95 
 96     public String typeToString() {
 97         final StringBuilder types = new StringBuilder();
 98         if (isStopBacktrack()) types.append(&quot;STOP_BACKTRACK &quot;);
 99         if (isMemory()) types.append(&quot;MEMORY &quot;);
100         if (isOption()) types.append(&quot;OPTION &quot;);
101 
102         return types.toString();
103     }
104 
105     public boolean isMemory() {
106         return (type &amp; MEMORY) != 0;
107     }
108 
109     public boolean isOption() {
110         return (type &amp; OPTION) != 0;
111     }
112 
113     public boolean isStopBacktrack() {
114         return (type &amp; STOP_BACKTRACK) != 0;
115     }
116 
117 }
    </pre>
  </body>
</html>
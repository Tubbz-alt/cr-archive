<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/linker/NashornBeansLinker.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.runtime.linker;
 27 
 28 import static jdk.nashorn.internal.lookup.Lookup.MH;
 29 
 30 import java.lang.invoke.MethodHandle;
 31 import java.lang.invoke.MethodHandles;
 32 import java.lang.invoke.MethodType;
 33 import java.lang.reflect.Method;
 34 import java.lang.reflect.Modifier;
 35 import java.util.function.Supplier;
 36 import jdk.dynalink.CallSiteDescriptor;
 37 import jdk.dynalink.NamedOperation;
 38 import jdk.dynalink.Operation;
 39 import jdk.dynalink.SecureLookupSupplier;
 40 import jdk.dynalink.StandardNamespace;
 41 import jdk.dynalink.StandardOperation;
 42 import jdk.dynalink.beans.BeansLinker;
 43 import jdk.dynalink.linker.ConversionComparator.Comparison;
 44 import jdk.dynalink.linker.GuardedInvocation;
 45 import jdk.dynalink.linker.GuardingDynamicLinker;
 46 import jdk.dynalink.linker.LinkRequest;
 47 import jdk.dynalink.linker.LinkerServices;
 48 import jdk.dynalink.linker.MethodHandleTransformer;
 49 import jdk.dynalink.linker.support.DefaultInternalObjectFilter;
 50 import jdk.dynalink.linker.support.Lookup;
 51 import jdk.dynalink.linker.support.SimpleLinkRequest;
 52 import jdk.nashorn.api.scripting.ScriptUtils;
 53 import jdk.nashorn.internal.runtime.ConsString;
 54 import jdk.nashorn.internal.runtime.Context;
 55 import jdk.nashorn.internal.runtime.ScriptObject;
 56 import jdk.nashorn.internal.runtime.options.Options;
 57 
 58 /**
 59  * This linker delegates to a {@code BeansLinker} but passes it a special linker services object that has a modified
 60  * {@code compareConversion} method that favors conversion of {@link ConsString} to either {@link String} or
 61  * {@link CharSequence}. It also provides a {@link #createHiddenObjectFilter()} method for use with bootstrap that will
 62  * ensure that we never pass internal engine objects that should not be externally observable (currently ConsString and
 63  * ScriptObject) to Java APIs, but rather that we flatten it into a String. We can&#39;t just add this functionality as
 64  * custom converters via {@code GuaardingTypeConverterFactory}, since they are not consulted when
 65  * the target method handle parameter signature is {@code Object}. This linker also makes sure that primitive
 66  * {@link String} operations can be invoked on a {@link ConsString}, and allows invocation of objects implementing
 67  * the {@link FunctionalInterface} attribute.
 68  */
 69 public class NashornBeansLinker implements GuardingDynamicLinker {
 70     // System property to control whether to wrap ScriptObject-&gt;ScriptObjectMirror for
 71     // Object type arguments of Java method calls, field set and array set.
 72     private static final boolean MIRROR_ALWAYS = Options.getBooleanProperty(&quot;nashorn.mirror.always&quot;, true);
 73 
 74     private static final Operation GET_METHOD = StandardOperation.GET.withNamespace(StandardNamespace.METHOD);
 75     private static final MethodType GET_METHOD_TYPE = MethodType.methodType(Object.class, Object.class);
 76 
 77     private static final MethodHandle EXPORT_ARGUMENT;
 78     private static final MethodHandle IMPORT_RESULT;
 79     private static final MethodHandle FILTER_CONSSTRING;
 80 
 81     static {
 82         final Lookup lookup  = new Lookup(MethodHandles.lookup());
 83         EXPORT_ARGUMENT      = lookup.findOwnStatic(&quot;exportArgument&quot;, Object.class, Object.class);
 84         IMPORT_RESULT        = lookup.findOwnStatic(&quot;importResult&quot;, Object.class, Object.class);
 85         FILTER_CONSSTRING    = lookup.findOwnStatic(&quot;consStringFilter&quot;, Object.class, Object.class);
 86     }
 87 
 88     // cache of @FunctionalInterface method of implementor classes
 89     private static final ClassValue&lt;String&gt; FUNCTIONAL_IFACE_METHOD_NAME = new ClassValue&lt;String&gt;() {
 90         @Override
 91         protected String computeValue(final Class&lt;?&gt; type) {
 92             return findFunctionalInterfaceMethodName(type);
 93         }
 94     };
 95 
 96     private final BeansLinker beansLinker;
 97 
 98     NashornBeansLinker(final BeansLinker beansLinker) {
 99         this.beansLinker = beansLinker;
100     }
101 
102     @Override
103     public GuardedInvocation getGuardedInvocation(final LinkRequest linkRequest, final LinkerServices linkerServices) throws Exception {
104         final Object self = linkRequest.getReceiver();
105         final CallSiteDescriptor desc = linkRequest.getCallSiteDescriptor();
106         if (self instanceof ConsString) {
107             // In order to treat ConsString like a java.lang.String we need a link request with a string receiver.
108             final Object[] arguments = linkRequest.getArguments();
109             arguments[0] = &quot;&quot;;
110             final LinkRequest forgedLinkRequest = linkRequest.replaceArguments(desc, arguments);
111             final GuardedInvocation invocation = getGuardedInvocation(beansLinker, forgedLinkRequest, linkerServices);
112             // If an invocation is found we add a filter that makes it work for both Strings and ConsStrings.
113             return invocation == null ? null : invocation.filterArguments(0, FILTER_CONSSTRING);
114         }
115 
116         if (self != null &amp;&amp; NamedOperation.getBaseOperation(desc.getOperation()) == StandardOperation.CALL) {
117             // Support CALL on any object that supports some @FunctionalInterface
118             // annotated interface. This way Java method, constructor references or
119             // implementations of java.util.function.* interfaces can be called as though
120             // those are script functions.
121             final String name = getFunctionalInterfaceMethodName(self.getClass());
122             if (name != null) {
123                 // Obtain the method
124                 final CallSiteDescriptor getMethodDesc = new CallSiteDescriptor(
125                         NashornCallSiteDescriptor.getLookupInternal(desc),
126                         GET_METHOD.named(name), GET_METHOD_TYPE);
127                 final GuardedInvocation getMethodInv = linkerServices.getGuardedInvocation(
128                         new SimpleLinkRequest(getMethodDesc, false, self));
129                 final Object method;
130                 try {
131                     method = getMethodInv.getInvocation().invokeExact(self);
132                 } catch (final Exception|Error e) {
133                     throw e;
134                 } catch (final Throwable t) {
135                     throw new RuntimeException(t);
136                 }
137 
138                 final Object[] args = linkRequest.getArguments();
139                 args[1] = args[0]; // callee (the functional object) becomes this
140                 args[0] = method; // the method becomes the callee
141 
142                 final MethodType callType = desc.getMethodType();
143 
144                 final CallSiteDescriptor newDesc = desc.changeMethodType(
145                         desc.getMethodType().changeParameterType(0, Object.class).changeParameterType(1, callType.parameterType(0)));
146                 final GuardedInvocation gi = getGuardedInvocation(beansLinker, linkRequest.replaceArguments(newDesc, args),
147                         new NashornBeansLinkerServices(linkerServices));
148 
149                 // Bind to the method, drop the original &quot;this&quot; and use original &quot;callee&quot; as this:
150                 final MethodHandle inv = gi.getInvocation()  // (method, this, args...)
151                                            .bindTo(method);  // (this, args...)
152                 final MethodHandle calleeToThis = MH.dropArguments(inv, 1, callType.parameterType(1)); // (callee-&gt;this, &lt;drop&gt;, args...)
153                 return gi.replaceMethods(calleeToThis, gi.getGuard());
154             }
155         }
156         return getGuardedInvocation(beansLinker, linkRequest, linkerServices);
157     }
158 
159     /**
160      * Delegates to the specified linker but injects its linker services wrapper so that it will apply all special
161      * conversions that this class does.
162      * @param delegateLinker the linker to which the actual work is delegated to.
163      * @param linkRequest the delegated link request
164      * @param linkerServices the original link services that will be augmented with special conversions
165      * @return the guarded invocation from the delegate, possibly augmented with special conversions
166      * @throws Exception if the delegate throws an exception
167      */
168     public static GuardedInvocation getGuardedInvocation(final GuardingDynamicLinker delegateLinker, final LinkRequest linkRequest, final LinkerServices linkerServices) throws Exception {
169         return delegateLinker.getGuardedInvocation(linkRequest, new NashornBeansLinkerServices(linkerServices));
170     }
171 
172     @SuppressWarnings(&quot;unused&quot;)
173     private static Object exportArgument(final Object arg) {
174         return exportArgument(arg, MIRROR_ALWAYS);
175     }
176 
177     static Object exportArgument(final Object arg, final boolean mirrorAlways) {
178         if (arg instanceof ConsString) {
179             return arg.toString();
180         } else if (mirrorAlways &amp;&amp; arg instanceof ScriptObject) {
181             return ScriptUtils.wrap(arg);
182         } else {
183             return arg;
184         }
185     }
186 
187     @SuppressWarnings(&quot;unused&quot;)
188     private static Object importResult(final Object arg) {
189         return ScriptUtils.unwrap(arg);
190     }
191 
192     @SuppressWarnings(&quot;unused&quot;)
193     private static Object consStringFilter(final Object arg) {
194         return arg instanceof ConsString ? arg.toString() : arg;
195     }
196 
197     private static String findFunctionalInterfaceMethodName(final Class&lt;?&gt; clazz) {
198         if (clazz == null) {
199             return null;
200         }
201 
202         for (final Class&lt;?&gt; iface : clazz.getInterfaces()) {
203             // check accessibility up-front
204             if (! Context.isAccessibleClass(iface)) {
205                 continue;
206             }
207 
208             // check for @FunctionalInterface
209             if (iface.isAnnotationPresent(FunctionalInterface.class)) {
210                 // return the first abstract method
211                 for (final Method m : iface.getMethods()) {
212                     if (Modifier.isAbstract(m.getModifiers()) &amp;&amp; !isOverridableObjectMethod(m)) {
213                         return m.getName();
214                     }
215                 }
216             }
217         }
218 
219         // did not find here, try super class
220         return findFunctionalInterfaceMethodName(clazz.getSuperclass());
221     }
222 
223     // is this an overridable java.lang.Object method?
224     private static boolean isOverridableObjectMethod(final Method m) {
225         switch (m.getName()) {
226             case &quot;equals&quot;:
227                 if (m.getReturnType() == boolean.class) {
228                     final Class&lt;?&gt;[] params = m.getParameterTypes();
229                     return params.length == 1 &amp;&amp; params[0] == Object.class;
230                 }
231                 return false;
232             case &quot;hashCode&quot;:
233                 return m.getReturnType() == int.class &amp;&amp; m.getParameterCount() == 0;
234             case &quot;toString&quot;:
235                 return m.getReturnType() == String.class &amp;&amp; m.getParameterCount() == 0;
236         }
237         return false;
238     }
239 
240     // Returns @FunctionalInterface annotated interface&#39;s single abstract
241     // method name. If not found, returns null.
242     static String getFunctionalInterfaceMethodName(final Class&lt;?&gt; clazz) {
243         return FUNCTIONAL_IFACE_METHOD_NAME.get(clazz);
244     }
245 
246     static MethodHandleTransformer createHiddenObjectFilter() {
247         return new DefaultInternalObjectFilter(EXPORT_ARGUMENT, MIRROR_ALWAYS ? IMPORT_RESULT : null);
248     }
249 
250     private static class NashornBeansLinkerServices implements LinkerServices {
251         private final LinkerServices linkerServices;
252 
253         NashornBeansLinkerServices(final LinkerServices linkerServices) {
254             this.linkerServices = linkerServices;
255         }
256 
257         @Override
258         public MethodHandle asType(final MethodHandle handle, final MethodType fromType) {
259             return linkerServices.asType(handle, fromType);
260         }
261 
262         @Override
263         public MethodHandle getTypeConverter(final Class&lt;?&gt; sourceType, final Class&lt;?&gt; targetType) {
264             return linkerServices.getTypeConverter(sourceType, targetType);
265         }
266 
267         @Override
268         public boolean canConvert(final Class&lt;?&gt; from, final Class&lt;?&gt; to) {
269             return linkerServices.canConvert(from, to);
270         }
271 
272         @Override
273         public GuardedInvocation getGuardedInvocation(final LinkRequest linkRequest) throws Exception {
274             return linkerServices.getGuardedInvocation(linkRequest);
275         }
276 
277         @Override
278         public Comparison compareConversion(final Class&lt;?&gt; sourceType, final Class&lt;?&gt; targetType1, final Class&lt;?&gt; targetType2) {
279             if (sourceType == ConsString.class) {
280                 if (String.class == targetType1 || CharSequence.class == targetType1) {
281                     return Comparison.TYPE_1_BETTER;
282                 }
283 
284                 if (String.class == targetType2 || CharSequence.class == targetType2) {
285                     return Comparison.TYPE_2_BETTER;
286                 }
287             }
288             return linkerServices.compareConversion(sourceType, targetType1, targetType2);
289         }
290 
291         @Override
292         public MethodHandle filterInternalObjects(final MethodHandle target) {
293             return linkerServices.filterInternalObjects(target);
294         }
295 
296         @Override
297         public &lt;T&gt; T getWithLookup(final Supplier&lt;T&gt; operation, final SecureLookupSupplier lookupSupplier) {
298             return linkerServices.getWithLookup(operation, lookupSupplier);
299         }
300     }
301 }
    </pre>
  </body>
</html>
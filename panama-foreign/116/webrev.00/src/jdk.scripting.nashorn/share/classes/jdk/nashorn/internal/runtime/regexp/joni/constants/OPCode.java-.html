<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/regexp/joni/constants/OPCode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Permission is hereby granted, free of charge, to any person obtaining a copy of
  3  * this software and associated documentation files (the &quot;Software&quot;), to deal in
  4  * the Software without restriction, including without limitation the rights to
  5  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
  6  * of the Software, and to permit persons to whom the Software is furnished to do
  7  * so, subject to the following conditions:
  8  *
  9  * The above copyright notice and this permission notice shall be included in all
 10  * copies or substantial portions of the Software.
 11  *
 12  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 13  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 14  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 15  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 16  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 17  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 18  * SOFTWARE.
 19  */
 20 package jdk.nashorn.internal.runtime.regexp.joni.constants;
 21 
 22 @SuppressWarnings(&quot;javadoc&quot;)
 23 public interface OPCode {
 24     final int FINISH                        = 0;            /* matching process terminator (no more alternative) */
 25     final int END                           = 1;            /* pattern code terminator (success end) */
 26 
 27     final int EXACT1                        = 2;            /* single byte, N = 1 */
 28     final int EXACT2                        = 3;            /* single byte, N = 2 */
 29     final int EXACT3                        = 4;            /* single byte, N = 3 */
 30     final int EXACT4                        = 5;            /* single byte, N = 4 */
 31     final int EXACT5                        = 6;            /* single byte, N = 5 */
 32     final int EXACTN                        = 7;            /* single byte */
 33 
 34     final int EXACT1_IC                     = 14;           /* single byte, N = 1, ignore case */
 35     final int EXACTN_IC                     = 15;           /* single byte,        ignore case */
 36 
 37     final int CCLASS                        = 16;
 38     final int CCLASS_MB                     = 17;
 39     final int CCLASS_MIX                    = 18;
 40     final int CCLASS_NOT                    = 19;
 41     final int CCLASS_MB_NOT                 = 20;
 42     final int CCLASS_MIX_NOT                = 21;
 43     final int CCLASS_NODE                   = 22;           /* pointer to CClassNode node */
 44 
 45     final int ANYCHAR                       = 23;           /* &quot;.&quot;  */
 46     final int ANYCHAR_ML                    = 24;           /* &quot;.&quot;  multi-line */
 47     final int ANYCHAR_STAR                  = 25;           /* &quot;.*&quot; */
 48     final int ANYCHAR_ML_STAR               = 26;           /* &quot;.*&quot; multi-line */
 49     final int ANYCHAR_STAR_PEEK_NEXT        = 27;
 50     final int ANYCHAR_ML_STAR_PEEK_NEXT     = 28;
 51 
 52     final int WORD                          = 29;
 53     final int NOT_WORD                      = 30;
 54     final int WORD_BOUND                    = 31;
 55     final int NOT_WORD_BOUND                = 32;
 56     final int WORD_BEGIN                    = 33;
 57     final int WORD_END                      = 34;
 58 
 59     final int BEGIN_BUF                     = 35;
 60     final int END_BUF                       = 36;
 61     final int BEGIN_LINE                    = 37;
 62     final int END_LINE                      = 38;
 63     final int SEMI_END_BUF                  = 39;
 64     final int BEGIN_POSITION                = 40;
 65 
 66     final int BACKREF1                      = 41;
 67     final int BACKREF2                      = 42;
 68     final int BACKREFN                      = 43;
 69     final int BACKREFN_IC                   = 44;
 70     final int BACKREF_MULTI                 = 45;
 71     final int BACKREF_MULTI_IC              = 46;
 72     final int BACKREF_WITH_LEVEL            = 47;           /* \k&lt;xxx+n&gt;, \k&lt;xxx-n&gt; */
 73 
 74     final int MEMORY_START                  = 48;
 75     final int MEMORY_START_PUSH             = 49;           /* push back-tracker to stack */
 76     final int MEMORY_END_PUSH               = 50;           /* push back-tracker to stack */
 77     final int MEMORY_END_PUSH_REC           = 51;           /* push back-tracker to stack */
 78     final int MEMORY_END                    = 52;
 79     final int MEMORY_END_REC                = 53;           /* push marker to stack */
 80 
 81     final int FAIL                          = 54;           /* pop stack and move */
 82     final int JUMP                          = 55;
 83     final int PUSH                          = 56;
 84     final int POP                           = 57;
 85     final int PUSH_OR_JUMP_EXACT1           = 58;           /* if match exact then push, else jump. */
 86     final int PUSH_IF_PEEK_NEXT             = 59;           /* if match exact then push, else none. */
 87 
 88     final int REPEAT                        = 60;           /* {n,m} */
 89     final int REPEAT_NG                     = 61;           /* {n,m}? (non greedy) */
 90     final int REPEAT_INC                    = 62;
 91     final int REPEAT_INC_NG                 = 63;           /* non greedy */
 92     final int REPEAT_INC_SG                 = 64;           /* search and get in stack */
 93     final int REPEAT_INC_NG_SG              = 65;           /* search and get in stack (non greedy) */
 94 
 95     final int NULL_CHECK_START              = 66;           /* null loop checker start */
 96     final int NULL_CHECK_END                = 67;           /* null loop checker end   */
 97     final int NULL_CHECK_END_MEMST          = 68;           /* null loop checker end (with capture status) */
 98     final int NULL_CHECK_END_MEMST_PUSH     = 69;           /* with capture status and push check-end */
 99 
100     final int PUSH_POS                      = 70;           /* (?=...)  start */
101     final int POP_POS                       = 71;           /* (?=...)  end   */
102     final int PUSH_POS_NOT                  = 72;           /* (?!...)  start */
103     final int FAIL_POS                      = 73;           /* (?!...)  end   */
104     final int PUSH_STOP_BT                  = 74;           /* (?&gt;...)  start */
105     final int POP_STOP_BT                   = 75;           /* (?&gt;...)  end   */
106     final int LOOK_BEHIND                   = 76;           /* (?&lt;=...) start (no needs end opcode) */
107     final int PUSH_LOOK_BEHIND_NOT          = 77;           /* (?&lt;!...) start */
108     final int FAIL_LOOK_BEHIND_NOT          = 78;           /* (?&lt;!...) end   */
109 
110     final int CALL                          = 79;           /* \g&lt;name&gt; */
111     final int RETURN                        = 80;
112 
113     final int STATE_CHECK_PUSH              = 81;           /* combination explosion check and push */
114     final int STATE_CHECK_PUSH_OR_JUMP      = 82;           /* check ok -&gt; push, else jump  */
115     final int STATE_CHECK                   = 83;           /* check only */
116     final int STATE_CHECK_ANYCHAR_STAR      = 84;
117     final int STATE_CHECK_ANYCHAR_ML_STAR   = 85;
118 
119       /* no need: IS_DYNAMIC_OPTION() == 0 */
120     final int SET_OPTION_PUSH               = 86;           /* set option and push recover option */
121     final int SET_OPTION                    = 87;           /* set option */
122 
123 }
    </pre>
  </body>
</html>
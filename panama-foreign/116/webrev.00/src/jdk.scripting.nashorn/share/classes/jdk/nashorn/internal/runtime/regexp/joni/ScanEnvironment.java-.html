<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/regexp/joni/ScanEnvironment.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Permission is hereby granted, free of charge, to any person obtaining a copy of
  3  * this software and associated documentation files (the &quot;Software&quot;), to deal in
  4  * the Software without restriction, including without limitation the rights to
  5  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
  6  * of the Software, and to permit persons to whom the Software is furnished to do
  7  * so, subject to the following conditions:
  8  *
  9  * The above copyright notice and this permission notice shall be included in all
 10  * copies or substantial portions of the Software.
 11  *
 12  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 13  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 14  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 15  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 16  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 17  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 18  * SOFTWARE.
 19  */
 20 package jdk.nashorn.internal.runtime.regexp.joni;
 21 
 22 import static jdk.nashorn.internal.runtime.regexp.joni.BitStatus.bsClear;
 23 import jdk.nashorn.internal.runtime.regexp.joni.ast.Node;
 24 import jdk.nashorn.internal.runtime.regexp.joni.exception.ErrorMessages;
 25 import jdk.nashorn.internal.runtime.regexp.joni.exception.InternalException;
 26 
 27 @SuppressWarnings(&quot;javadoc&quot;)
 28 public final class ScanEnvironment {
 29 
 30     private static final int SCANENV_MEMNODES_SIZE = 8;
 31 
 32     int option;
 33     final int caseFoldFlag;
 34     final public Syntax syntax;
 35     int captureHistory;
 36     int btMemStart;
 37     int btMemEnd;
 38     int backrefedMem;
 39 
 40     final public Regex reg;
 41 
 42     public int numMem;
 43 
 44     public Node memNodes[];
 45 
 46 
 47     public ScanEnvironment(final Regex regex, final Syntax syntax) {
 48         this.reg = regex;
 49         option = regex.options;
 50         caseFoldFlag = regex.caseFoldFlag;
 51         this.syntax = syntax;
 52     }
 53 
 54     public void clear() {
 55         captureHistory = bsClear();
 56         btMemStart = bsClear();
 57         btMemEnd = bsClear();
 58         backrefedMem = bsClear();
 59 
 60         numMem = 0;
 61         memNodes = null;
 62     }
 63 
 64     public int addMemEntry() {
 65         if (numMem &gt;= Config.MAX_CAPTURE_GROUP_NUM) {
 66             throw new InternalException(ErrorMessages.ERR_TOO_MANY_CAPTURE_GROUPS);
 67         }
 68         if (numMem++ == 0) {
 69             memNodes = new Node[SCANENV_MEMNODES_SIZE];
 70         } else if (numMem &gt;= memNodes.length) {
 71             final Node[]tmp = new Node[memNodes.length &lt;&lt; 1];
 72             System.arraycopy(memNodes, 0, tmp, 0, memNodes.length);
 73             memNodes = tmp;
 74         }
 75 
 76         return numMem;
 77     }
 78 
 79     public void setMemNode(final int num, final Node node) {
 80         if (numMem &gt;= num) {
 81             memNodes[num] = node;
 82         } else {
 83             throw new InternalException(ErrorMessages.ERR_PARSER_BUG);
 84         }
 85     }
 86 
 87     public int convertBackslashValue(final int c) {
 88         if (syntax.opEscControlChars()) {
 89             switch (c) {
 90             case &#39;n&#39;: return &#39;\n&#39;;
 91             case &#39;t&#39;: return &#39;\t&#39;;
 92             case &#39;r&#39;: return &#39;\r&#39;;
 93             case &#39;f&#39;: return &#39;\f&#39;;
 94             case &#39;a&#39;: return &#39;\007&#39;;
 95             case &#39;b&#39;: return &#39;\010&#39;;
 96             case &#39;e&#39;: return &#39;\033&#39;;
 97             case &#39;v&#39;:
 98                 if (syntax.op2EscVVtab())
 99                  {
100                     return 11; // ???
101                 }
102                 break;
103             default:
104                 break;
105             }
106         }
107         return c;
108     }
109 
110     void ccEscWarn(final String s) {
111         if (Config.USE_WARN) {
112             if (syntax.warnCCOpNotEscaped() &amp;&amp; syntax.backSlashEscapeInCC()) {
113                 reg.warnings.warn(&quot;character class has &#39;&quot; + s + &quot;&#39; without escape&quot;);
114             }
115         }
116     }
117 
118 }
    </pre>
  </body>
</html>
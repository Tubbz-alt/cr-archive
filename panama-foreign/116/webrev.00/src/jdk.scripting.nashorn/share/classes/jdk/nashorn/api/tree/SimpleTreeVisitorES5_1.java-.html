<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/api/tree/SimpleTreeVisitorES5_1.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.api.tree;
 27 
 28 /**
 29  * A simple implementation of the TreeVisitor for ECMAScript edition 5.1.
 30  *
 31  * &lt;p&gt;The visit methods corresponding to ES 5.1 language constructs walk the
 32  * &quot;components&quot; of the given tree by calling accept method passing the
 33  * current visitor and the additional parameter.
 34  *
 35  * &lt;p&gt;For constructs introduced in later versions, {@code visitUnknown}
 36  * is called instead which throws {@link UnknownTreeException}.
 37  *
 38  * &lt;p&gt; Methods in this class may be overridden subject to their
 39  * general contract.  Note that annotating methods in concrete
 40  * subclasses with {@link java.lang.Override @Override} will help
 41  * ensure that methods are overridden as intended.
 42  *
 43  * @deprecated Nashorn JavaScript script engine and APIs, and the jjs tool
 44  * are deprecated with the intent to remove them in a future release.
 45  *
 46  * @param &lt;R&gt; the return type of this visitor&#39;s methods.  Use {@link
 47  *            Void} for visitors that do not need to return results.
 48  * @param &lt;P&gt; the type of the additional parameter to this visitor&#39;s
 49  *            methods.  Use {@code Void} for visitors that do not need an
 50  *            additional parameter.
 51  */
 52 @Deprecated(since=&quot;11&quot;, forRemoval=true)
 53 public class SimpleTreeVisitorES5_1&lt;R, P&gt; implements TreeVisitor&lt;R, P&gt; {
 54     @Override
 55     public R visitAssignment(final AssignmentTree node, final P r) {
 56         node.getVariable().accept(this, r);
 57         node.getExpression().accept(this, r);
 58         return null;
 59     }
 60 
 61     @Override
 62     public R visitCompoundAssignment(final CompoundAssignmentTree node, final P r) {
 63         node.getVariable().accept(this, r);
 64         node.getExpression().accept(this, r);
 65         return null;
 66     }
 67 
 68     /**
 69      * Visits a {@code ModuleTree} tree by calling {@code
 70      * visitUnknown}.
 71      *
 72      * @param node  {@inheritDoc}
 73      * @param p  {@inheritDoc}
 74      * @return the result of {@code visitUnknown}
 75      */
 76     @Override
 77     public R visitModule(final ModuleTree node, final P p) {
 78         return visitUnknown(node, p);
 79     }
 80 
 81     /**
 82      * Visits an {@code ExportEntryTree} tree by calling {@code
 83      * visitUnknown}.
 84      *
 85      * @param node  {@inheritDoc}
 86      * @param p  {@inheritDoc}
 87      * @return the result of {@code visitUnknown}
 88      */
 89     @Override
 90     public R visitExportEntry(final ExportEntryTree node, final P p) {
 91         return visitUnknown(node, p);
 92     }
 93 
 94     /**
 95      * Visits an {@code ImportEntryTree} tree by calling {@code
 96      * visitUnknown}.
 97      *
 98      * @param node  {@inheritDoc}
 99      * @param p  {@inheritDoc}
100      * @return the result of {@code visitUnknown}
101      */
102     @Override
103     public R visitImportEntry(final ImportEntryTree node, final P p) {
104         return visitUnknown(node, p);
105     }
106 
107     @Override
108     public R visitBinary(final BinaryTree node, final P r) {
109         node.getLeftOperand().accept(this, r);
110         node.getRightOperand().accept(this, r);
111         return null;
112     }
113 
114     @Override
115     public R visitBlock(final BlockTree node, final P r) {
116         node.getStatements().forEach((tree) -&gt; {
117             tree.accept(this, r);
118         });
119         return null;
120     }
121 
122     @Override
123     public R visitBreak(final BreakTree node, final P r) {
124         return null;
125     }
126 
127     @Override
128     public R visitCase(final CaseTree node, final P r) {
129         final Tree caseVal = node.getExpression();
130         if (caseVal != null) {
131             caseVal.accept(this, r);
132         }
133 
134         node.getStatements().forEach((tree) -&gt; {
135             tree.accept(this, r);
136         });
137         return null;
138     }
139 
140     @Override
141     public R visitCatch(final CatchTree node, final P r) {
142         final Tree cond = node.getCondition();
143         if (cond != null) {
144             cond.accept(this, r);
145         }
146         node.getParameter().accept(this, r);
147         node.getBlock().accept(this, r);
148         return null;
149     }
150 
151     /**
152      * Visits a {@code ClassDeclarationTree} tree by calling {@code
153      * visitUnknown}.
154      *
155      * @param node  {@inheritDoc}
156      * @param p  {@inheritDoc}
157      * @return the result of {@code visitUnknown}
158      */
159     @Override
160     public R visitClassDeclaration(final ClassDeclarationTree node, final P p) {
161         return visitUnknown(node, p);
162     }
163 
164     /**
165      * Visits a {@code ClassExpressionTree} tree by calling {@code
166      * visitUnknown}.
167      *
168      * @param node  {@inheritDoc}
169      * @param p  {@inheritDoc}
170      * @return the result of {@code visitUnknown}
171      */
172     @Override
173     public R visitClassExpression(final ClassExpressionTree node, final P p) {
174         return visitUnknown(node, p);
175     }
176 
177     @Override
178     public R visitConditionalExpression(final ConditionalExpressionTree node, final P r) {
179         node.getCondition().accept(this, r);
180         node.getTrueExpression().accept(this, r);
181         node.getFalseExpression().accept(this, r);
182         return null;
183     }
184 
185     @Override
186     public R visitContinue(final ContinueTree node, final P r) {
187         return null;
188     }
189 
190     @Override
191     public R visitDebugger(final DebuggerTree node, final P r) {
192         return null;
193     }
194 
195     @Override
196     public R visitDoWhileLoop(final DoWhileLoopTree node, final P r) {
197         node.getStatement().accept(this, r);
198         node.getCondition().accept(this, r);
199         return null;
200     }
201 
202     @Override
203     public R visitErroneous(final ErroneousTree node, final P r) {
204         return null;
205     }
206 
207     @Override
208     public R visitExpressionStatement(final ExpressionStatementTree node, final P r) {
209         node.getExpression().accept(this, r);
210         return null;
211     }
212 
213     @Override
214     public R visitForLoop(final ForLoopTree node, final P r) {
215         final Tree init = node.getInitializer();
216         if (init != null) {
217             init.accept(this, r);
218         }
219 
220         final Tree cond = node.getCondition();
221         if (cond != null) {
222             cond.accept(this, r);
223         }
224 
225         final Tree update = node.getUpdate();
226         if (update != null) {
227             update.accept(this, r);
228         }
229 
230         node.getStatement().accept(this, r);
231         return null;
232     }
233 
234     @Override
235     public R visitForInLoop(final ForInLoopTree node, final P r) {
236         node.getVariable().accept(this, r);
237         node.getExpression().accept(this, r);
238         final StatementTree stat = node.getStatement();
239         if (stat != null) {
240             stat.accept(this, r);
241         }
242         return null;
243     }
244 
245     /**
246      * Visits a {@code ForOfLoopTree} tree by calling {@code
247      * visitUnknown}.
248      *
249      * @param node  {@inheritDoc}
250      * @param p  {@inheritDoc}
251      * @return the result of {@code visitUnknown}
252      */
253     @Override
254     public R visitForOfLoop(final ForOfLoopTree node, final P p) {
255         return visitUnknown(node, p);
256     }
257 
258     @Override
259     public R visitFunctionCall(final FunctionCallTree node, final P r) {
260         node.getFunctionSelect().accept(this, r);
261         node.getArguments().forEach((tree) -&gt; {
262             tree.accept(this, r);
263         });
264         return null;
265     }
266 
267     @Override
268     public R visitFunctionDeclaration(final FunctionDeclarationTree node, final P r) {
269         node.getParameters().forEach((tree) -&gt; {
270             tree.accept(this, r);
271         });
272         node.getBody().accept(this, r);
273         return null;
274     }
275 
276     @Override
277     public R visitFunctionExpression(final FunctionExpressionTree node, final P r) {
278         node.getParameters().forEach((tree) -&gt; {
279             tree.accept(this, r);
280         });
281         node.getBody().accept(this, r);
282         return null;
283     }
284 
285     @Override
286     public R visitIdentifier(final IdentifierTree node, final P r) {
287         return null;
288     }
289 
290     @Override
291     public R visitIf(final IfTree node, final P r) {
292         node.getCondition().accept(this, r);
293         node.getThenStatement().accept(this, r);
294         final Tree elseStat = node.getElseStatement();
295         if (elseStat != null) {
296             elseStat.accept(this, r);
297         }
298         return null;
299     }
300 
301     @Override
302     public R visitArrayAccess(final ArrayAccessTree node, final P r) {
303         node.getExpression().accept(this, r);
304         node.getIndex().accept(this, r);
305         return null;
306     }
307 
308     @Override
309     public R visitArrayLiteral(final ArrayLiteralTree node, final P r) {
310         node.getElements().stream().filter((tree) -&gt; (tree != null)).forEach((tree) -&gt; {
311             tree.accept(this, r);
312         });
313         return null;
314     }
315 
316     @Override
317     public R visitLabeledStatement(final LabeledStatementTree node, final P r) {
318         node.getStatement().accept(this, r);
319         return null;
320     }
321 
322     @Override
323     public R visitLiteral(final LiteralTree node, final P r) {
324         return null;
325     }
326 
327     @Override
328     public R visitParenthesized(final ParenthesizedTree node, final P r) {
329         node.getExpression().accept(this, r);
330         return null;
331     }
332 
333     @Override
334     public R visitReturn(final ReturnTree node, final P r) {
335         final Tree retExpr = node.getExpression();
336         if (retExpr != null) {
337             retExpr.accept(this, r);
338         }
339         return null;
340     }
341 
342     @Override
343     public R visitMemberSelect(final MemberSelectTree node, final P r) {
344         node.getExpression().accept(this, r);
345         return null;
346     }
347 
348     @Override
349     public R visitNew(final NewTree node, final P r) {
350         node.getConstructorExpression().accept(this, r);
351         return null;
352     }
353 
354     @Override
355     public R visitObjectLiteral(final ObjectLiteralTree node, final P r) {
356         node.getProperties().forEach((tree) -&gt; {
357             tree.accept(this, r);
358         });
359         return null;
360     }
361 
362     @Override
363     public R visitProperty(final PropertyTree node, final P r) {
364         final FunctionExpressionTree getter = node.getGetter();
365         if (getter != null) {
366             getter.accept(this, r);
367         }
368         final ExpressionTree key = node.getKey();
369         if (key != null) {
370             key.accept(this, r);
371         }
372 
373         final FunctionExpressionTree setter = node.getSetter();
374         if (setter != null) {
375             setter.accept(this, r);
376         }
377 
378         final ExpressionTree value = node.getValue();
379         if (value != null) {
380             value.accept(this, r);
381         }
382         return null;
383     }
384 
385     @Override
386     public R visitRegExpLiteral(final RegExpLiteralTree node, final P r) {
387         return null;
388     }
389 
390     /**
391      * Visits a {@code TemplateLiteralTree} tree by calling {@code
392      * visitUnknown}.
393      *
394      * @param node  {@inheritDoc}
395      * @param p  {@inheritDoc}
396      * @return the result of {@code visitUnknown}
397      */
398     @Override
399     public R visitTemplateLiteral(final TemplateLiteralTree node, final P p) {
400         return visitUnknown(node, p);
401     }
402 
403     @Override
404     public R visitEmptyStatement(final EmptyStatementTree node, final P r) {
405         return null;
406     }
407 
408     /**
409      * Visits a {@code SpreadTree} tree by calling {@code
410      * visitUnknown}.
411      *
412      * @param node  {@inheritDoc}
413      * @param p  {@inheritDoc}
414      * @return the result of {@code visitUnknown}
415      */
416     @Override
417     public R visitSpread(final SpreadTree node, final P p) {
418         return visitUnknown(node, p);
419     }
420 
421     @Override
422     public R visitSwitch(final SwitchTree node, final P r) {
423         node.getExpression().accept(this, r);
424         node.getCases().forEach((tree) -&gt; {
425             tree.accept(this, r);
426         });
427         return null;
428     }
429 
430     @Override
431     public R visitThrow(final ThrowTree node, final P r) {
432         node.getExpression().accept(this, r);
433         return null;
434     }
435 
436     @Override
437     public R visitCompilationUnit(final CompilationUnitTree node, final P r) {
438         node.getSourceElements().forEach((tree) -&gt; {
439             tree.accept(this, r);
440         });
441         return null;
442     }
443 
444     @Override
445     public R visitTry(final TryTree node, final P r) {
446         node.getBlock().accept(this, r);
447         node.getCatches().forEach((tree) -&gt; {
448             tree.accept(this, r);
449         });
450 
451         final Tree finallyBlock = node.getFinallyBlock();
452         if (finallyBlock != null) {
453             finallyBlock.accept(this, r);
454         }
455         return null;
456     }
457 
458     @Override
459     public R visitInstanceOf(final InstanceOfTree node, final P r) {
460         node.getType().accept(this, r);
461         node.getExpression().accept(this, r);
462         return null;
463     }
464 
465     @Override
466     public R visitUnary(final UnaryTree node, final P r) {
467         node.getExpression().accept(this, r);
468         return null;
469     }
470 
471     @Override
472     public R visitVariable(final VariableTree node, final P r) {
473         if (node.getInitializer() != null) {
474             node.getInitializer().accept(this, r);
475         }
476         return null;
477     }
478 
479     @Override
480     public R visitWhileLoop(final WhileLoopTree node, final P r) {
481         node.getCondition().accept(this, r);
482         node.getStatement().accept(this, r);
483         return null;
484     }
485 
486     @Override
487     public R visitWith(final WithTree node, final P r) {
488         node.getScope().accept(this, r);
489         node.getStatement().accept(this, r);
490         return null;
491     }
492 
493     /**
494      * Visits a {@code YieldTree} tree by calling {@code
495      * visitUnknown}.
496      *
497      * @param node  {@inheritDoc}
498      * @param p  {@inheritDoc}
499      * @return the result of {@code visitUnknown}
500      */
501     @Override
502     public R visitYield(final YieldTree node, final P p) {
503         return visitUnknown(node, p);
504     }
505 
506     /**
507      * {@inheritDoc}
508      *
509      * @implSpec The default implementation of this method in {@code
510      * SimpleTreeVisitorES5_1} will always throw {@code
511      * UnknownTypeException}. This behavior is not required of a
512      * subclass.
513      *
514      * @param node  {@inheritDoc}
515      * @param p  {@inheritDoc}
516      * @return abnormal return by throwing exception always
517      * @throws UnknownTreeException
518      *  a visitor implementation may optionally throw this exception
519      */
520     @Override
521     public R visitUnknown(final Tree node, final P p) {
522         // unknown in ECMAScript 5.1 edition
523         throw new UnknownTreeException(node, p);
524     }
525 }
    </pre>
  </body>
</html>
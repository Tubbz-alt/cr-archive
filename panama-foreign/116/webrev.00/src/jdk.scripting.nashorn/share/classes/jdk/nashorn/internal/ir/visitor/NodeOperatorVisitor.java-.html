<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/ir/visitor/NodeOperatorVisitor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.nashorn.internal.ir.visitor;
  27 
  28 import jdk.nashorn.internal.ir.BinaryNode;
  29 import jdk.nashorn.internal.ir.LexicalContext;
  30 import jdk.nashorn.internal.ir.Node;
  31 import jdk.nashorn.internal.ir.UnaryNode;
  32 
  33 /**
  34  * Like NodeVisitor but navigating further into operators.
  35  * @param &lt;T&gt; Lexical context class for this NodeOperatorVisitor
  36  */
  37 public abstract class NodeOperatorVisitor&lt;T extends LexicalContext&gt; extends NodeVisitor&lt;T&gt; {
  38     /**
  39      * Constructor
  40      *
  41      * @param lc a custom lexical context
  42      */
  43     public NodeOperatorVisitor(final T lc) {
  44         super(lc);
  45     }
  46 
  47     @Override
  48     public boolean enterUnaryNode(final UnaryNode unaryNode) {
  49         switch (unaryNode.tokenType()) {
  50         case POS:
  51             return enterPOS(unaryNode);
  52         case BIT_NOT:
  53             return enterBIT_NOT(unaryNode);
  54         case DELETE:
  55             return enterDELETE(unaryNode);
  56         case NEW:
  57             return enterNEW(unaryNode);
  58         case NOT:
  59             return enterNOT(unaryNode);
  60         case NEG:
  61             return enterNEG(unaryNode);
  62         case TYPEOF:
  63             return enterTYPEOF(unaryNode);
  64         case VOID:
  65             return enterVOID(unaryNode);
  66         case DECPREFIX:
  67         case DECPOSTFIX:
  68         case INCPREFIX:
  69         case INCPOSTFIX:
  70             return enterDECINC(unaryNode);
  71         default:
  72             return super.enterUnaryNode(unaryNode);
  73         }
  74     }
  75 
  76     @Override
  77     public final Node leaveUnaryNode(final UnaryNode unaryNode) {
  78         switch (unaryNode.tokenType()) {
  79         case POS:
  80             return leavePOS(unaryNode);
  81         case BIT_NOT:
  82             return leaveBIT_NOT(unaryNode);
  83         case DELETE:
  84             return leaveDELETE(unaryNode);
  85         case NEW:
  86             return leaveNEW(unaryNode);
  87         case NOT:
  88             return leaveNOT(unaryNode);
  89         case NEG:
  90             return leaveNEG(unaryNode);
  91         case TYPEOF:
  92             return leaveTYPEOF(unaryNode);
  93         case VOID:
  94             return leaveVOID(unaryNode);
  95         case DECPREFIX:
  96         case DECPOSTFIX:
  97         case INCPREFIX:
  98         case INCPOSTFIX:
  99             return leaveDECINC(unaryNode);
 100         default:
 101             return super.leaveUnaryNode(unaryNode);
 102         }
 103     }
 104 
 105     @Override
 106     public final boolean enterBinaryNode(final BinaryNode binaryNode) {
 107         switch (binaryNode.tokenType()) {
 108         case ADD:
 109             return enterADD(binaryNode);
 110         case AND:
 111             return enterAND(binaryNode);
 112         case ASSIGN:
 113             return enterASSIGN(binaryNode);
 114         case ASSIGN_ADD:
 115             return enterASSIGN_ADD(binaryNode);
 116         case ASSIGN_BIT_AND:
 117             return enterASSIGN_BIT_AND(binaryNode);
 118         case ASSIGN_BIT_OR:
 119             return enterASSIGN_BIT_OR(binaryNode);
 120         case ASSIGN_BIT_XOR:
 121             return enterASSIGN_BIT_XOR(binaryNode);
 122         case ASSIGN_DIV:
 123             return enterASSIGN_DIV(binaryNode);
 124         case ASSIGN_MOD:
 125             return enterASSIGN_MOD(binaryNode);
 126         case ASSIGN_MUL:
 127             return enterASSIGN_MUL(binaryNode);
 128         case ASSIGN_SAR:
 129             return enterASSIGN_SAR(binaryNode);
 130         case ASSIGN_SHL:
 131             return enterASSIGN_SHL(binaryNode);
 132         case ASSIGN_SHR:
 133             return enterASSIGN_SHR(binaryNode);
 134         case ASSIGN_SUB:
 135             return enterASSIGN_SUB(binaryNode);
 136         case ARROW:
 137             return enterARROW(binaryNode);
 138         case BIT_AND:
 139             return enterBIT_AND(binaryNode);
 140         case BIT_OR:
 141             return enterBIT_OR(binaryNode);
 142         case BIT_XOR:
 143             return enterBIT_XOR(binaryNode);
 144         case COMMARIGHT:
 145             return enterCOMMARIGHT(binaryNode);
 146         case DIV:
 147             return enterDIV(binaryNode);
 148         case EQ:
 149             return enterEQ(binaryNode);
 150         case EQ_STRICT:
 151             return enterEQ_STRICT(binaryNode);
 152         case GE:
 153             return enterGE(binaryNode);
 154         case GT:
 155             return enterGT(binaryNode);
 156         case IN:
 157             return enterIN(binaryNode);
 158         case INSTANCEOF:
 159             return enterINSTANCEOF(binaryNode);
 160         case LE:
 161             return enterLE(binaryNode);
 162         case LT:
 163             return enterLT(binaryNode);
 164         case MOD:
 165             return enterMOD(binaryNode);
 166         case MUL:
 167             return enterMUL(binaryNode);
 168         case NE:
 169             return enterNE(binaryNode);
 170         case NE_STRICT:
 171             return enterNE_STRICT(binaryNode);
 172         case OR:
 173             return enterOR(binaryNode);
 174         case SAR:
 175             return enterSAR(binaryNode);
 176         case SHL:
 177             return enterSHL(binaryNode);
 178         case SHR:
 179             return enterSHR(binaryNode);
 180         case SUB:
 181             return enterSUB(binaryNode);
 182         default:
 183             return super.enterBinaryNode(binaryNode);
 184         }
 185     }
 186 
 187     @Override
 188     public final Node leaveBinaryNode(final BinaryNode binaryNode) {
 189         switch (binaryNode.tokenType()) {
 190         case ADD:
 191             return leaveADD(binaryNode);
 192         case AND:
 193             return leaveAND(binaryNode);
 194         case ASSIGN:
 195             return leaveASSIGN(binaryNode);
 196         case ASSIGN_ADD:
 197             return leaveASSIGN_ADD(binaryNode);
 198         case ASSIGN_BIT_AND:
 199             return leaveASSIGN_BIT_AND(binaryNode);
 200         case ASSIGN_BIT_OR:
 201             return leaveASSIGN_BIT_OR(binaryNode);
 202         case ASSIGN_BIT_XOR:
 203             return leaveASSIGN_BIT_XOR(binaryNode);
 204         case ASSIGN_DIV:
 205             return leaveASSIGN_DIV(binaryNode);
 206         case ASSIGN_MOD:
 207             return leaveASSIGN_MOD(binaryNode);
 208         case ASSIGN_MUL:
 209             return leaveASSIGN_MUL(binaryNode);
 210         case ASSIGN_SAR:
 211             return leaveASSIGN_SAR(binaryNode);
 212         case ASSIGN_SHL:
 213             return leaveASSIGN_SHL(binaryNode);
 214         case ASSIGN_SHR:
 215             return leaveASSIGN_SHR(binaryNode);
 216         case ASSIGN_SUB:
 217             return leaveASSIGN_SUB(binaryNode);
 218         case ARROW:
 219             return leaveARROW(binaryNode);
 220         case BIT_AND:
 221             return leaveBIT_AND(binaryNode);
 222         case BIT_OR:
 223             return leaveBIT_OR(binaryNode);
 224         case BIT_XOR:
 225             return leaveBIT_XOR(binaryNode);
 226         case COMMARIGHT:
 227             return leaveCOMMARIGHT(binaryNode);
 228         case DIV:
 229             return leaveDIV(binaryNode);
 230         case EQ:
 231             return leaveEQ(binaryNode);
 232         case EQ_STRICT:
 233             return leaveEQ_STRICT(binaryNode);
 234         case GE:
 235             return leaveGE(binaryNode);
 236         case GT:
 237             return leaveGT(binaryNode);
 238         case IN:
 239             return leaveIN(binaryNode);
 240         case INSTANCEOF:
 241             return leaveINSTANCEOF(binaryNode);
 242         case LE:
 243             return leaveLE(binaryNode);
 244         case LT:
 245             return leaveLT(binaryNode);
 246         case MOD:
 247             return leaveMOD(binaryNode);
 248         case MUL:
 249             return leaveMUL(binaryNode);
 250         case NE:
 251             return leaveNE(binaryNode);
 252         case NE_STRICT:
 253             return leaveNE_STRICT(binaryNode);
 254         case OR:
 255             return leaveOR(binaryNode);
 256         case SAR:
 257             return leaveSAR(binaryNode);
 258         case SHL:
 259             return leaveSHL(binaryNode);
 260         case SHR:
 261             return leaveSHR(binaryNode);
 262         case SUB:
 263             return leaveSUB(binaryNode);
 264         default:
 265             return super.leaveBinaryNode(binaryNode);
 266         }
 267     }
 268 
 269     /*
 270      * Unary entries and exists.
 271      */
 272 
 273     /**
 274      * Unary enter - callback for entering a unary +
 275      *
 276      * @param  unaryNode the node
 277      * @return true if traversal should continue and node children be traversed, false otherwise
 278      */
 279     public boolean enterPOS(final UnaryNode unaryNode) {
 280         return enterDefault(unaryNode);
 281     }
 282 
 283     /**
 284      * Unary leave - callback for leaving a unary +
 285      *
 286      * @param  unaryNode the node
 287      * @return processed node, which will replace the original one, or the original node
 288      */
 289      public Node leavePOS(final UnaryNode unaryNode) {
 290         return leaveDefault(unaryNode);
 291     }
 292 
 293     /**
 294      * Unary enter - callback for entering a ~ operator
 295      *
 296      * @param  unaryNode the node
 297      * @return true if traversal should continue and node children be traversed, false otherwise
 298      */
 299     public boolean enterBIT_NOT(final UnaryNode unaryNode) {
 300         return enterDefault(unaryNode);
 301     }
 302 
 303     /**
 304      * Unary leave - callback for leaving a unary ~
 305      *
 306      * @param  unaryNode the node
 307      * @return processed node, which will replace the original one, or the original node
 308      */
 309     public Node leaveBIT_NOT(final UnaryNode unaryNode) {
 310         return leaveDefault(unaryNode);
 311     }
 312 
 313     /**
 314      * Unary enter - callback for entering a ++ or -- operator
 315      *
 316      * @param  unaryNode the node
 317      * @return true if traversal should continue and node children be traversed, false otherwise
 318      */
 319     public boolean enterDECINC(final UnaryNode unaryNode) {
 320         return enterDefault(unaryNode);
 321     }
 322 
 323     /**
 324      * Unary leave - callback for leaving a ++ or -- operator
 325      *
 326      * @param  unaryNode the node
 327      * @return processed node, which will replace the original one, or the original node
 328      */
 329      public Node leaveDECINC(final UnaryNode unaryNode) {
 330         return leaveDefault(unaryNode);
 331     }
 332 
 333     /**
 334      * Unary enter - callback for entering a delete operator
 335      *
 336      * @param  unaryNode the node
 337      * @return processed node
 338      */
 339     public boolean enterDELETE(final UnaryNode unaryNode) {
 340         return enterDefault(unaryNode);
 341     }
 342 
 343     /**
 344      * Unary leave - callback for leaving a delete operator
 345      *
 346      * @param  unaryNode the node
 347      * @return processed node, which will replace the original one, or the original node
 348      */
 349      public Node leaveDELETE(final UnaryNode unaryNode) {
 350         return leaveDefault(unaryNode);
 351     }
 352 
 353     /**
 354      * Unary enter - callback for entering a new operator
 355      *
 356      * @param  unaryNode the node
 357      * @return true if traversal should continue and node children be traversed, false otherwise
 358      */
 359     public boolean enterNEW(final UnaryNode unaryNode) {
 360         return enterDefault(unaryNode);
 361     }
 362 
 363     /**
 364      * Unary leave - callback for leaving a new operator
 365      *
 366      * @param  unaryNode the node
 367      * @return processed node, which will replace the original one, or the original node
 368      */
 369      public Node leaveNEW(final UnaryNode unaryNode) {
 370         return leaveDefault(unaryNode);
 371     }
 372 
 373     /**
 374      * Unary enter - callback for entering a ! operator
 375      *
 376      * @param  unaryNode the node
 377      * @return true if traversal should continue and node children be traversed, false otherwise
 378      */
 379     public boolean enterNOT(final UnaryNode unaryNode) {
 380         return enterDefault(unaryNode);
 381     }
 382 
 383     /**
 384      * Unary leave - callback for leaving a ! operator
 385      *
 386      * @param  unaryNode the node
 387      * @return processed node, which will replace the original one, or the original node
 388      */
 389      public Node leaveNOT(final UnaryNode unaryNode) {
 390         return leaveDefault(unaryNode);
 391     }
 392 
 393     /**
 394      * Unary enter - callback for entering a unary -
 395      *
 396      * @param  unaryNode the node
 397      * @return true if traversal should continue and node children be traversed, false otherwise
 398      */
 399     public boolean enterNEG(final UnaryNode unaryNode) {
 400         return enterDefault(unaryNode);
 401     }
 402 
 403     /**
 404      * Unary leave - callback for leaving a unary -
 405      *
 406      * @param  unaryNode the node
 407      * @return processed node, which will replace the original one, or the original node
 408      */
 409     public Node leaveNEG(final UnaryNode unaryNode) {
 410         return leaveDefault(unaryNode);
 411     }
 412 
 413     /**
 414      * Unary enter - callback for entering a typeof
 415      *
 416      * @param  unaryNode the node
 417      * @return true if traversal should continue and node children be traversed, false otherwise
 418      */
 419     public boolean enterTYPEOF(final UnaryNode unaryNode) {
 420         return enterDefault(unaryNode);
 421     }
 422 
 423     /**
 424      * Unary leave - callback for leaving a typeof operator
 425      *
 426      * @param  unaryNode the node
 427      * @return processed node, which will replace the original one, or the original node
 428      */
 429      public Node leaveTYPEOF(final UnaryNode unaryNode) {
 430         return leaveDefault(unaryNode);
 431     }
 432 
 433     /**
 434      * Unary enter - callback for entering a void
 435      *
 436      * @param  unaryNode the node
 437      * @return true if traversal should continue and node children be traversed, false otherwise
 438      */
 439     public boolean enterVOID(final UnaryNode unaryNode) {
 440         return enterDefault(unaryNode);
 441     }
 442 
 443     /**
 444      * Unary leave - callback for leaving a void
 445      *
 446      * @param  unaryNode the node
 447      * @return processed node, which will replace the original one, or the original node
 448      */
 449      public Node leaveVOID(final UnaryNode unaryNode) {
 450         return leaveDefault(unaryNode);
 451     }
 452 
 453     /**
 454      * Binary enter - callback for entering + operator
 455      *
 456      * @param  binaryNode the node
 457      * @return true if traversal should continue and node children be traversed, false otherwise
 458      */
 459     public boolean enterADD(final BinaryNode binaryNode) {
 460         return enterDefault(binaryNode);
 461     }
 462 
 463     /**
 464      * Binary leave - callback for leaving a + operator
 465      *
 466      * @param  binaryNode the node
 467      * @return processed node, which will replace the original one, or the original node
 468      */
 469      public Node leaveADD(final BinaryNode binaryNode) {
 470         return leaveDefault(binaryNode);
 471     }
 472 
 473     /**
 474      * Binary enter - callback for entering {@literal &amp;&amp;} operator
 475      *
 476      * @param  binaryNode the node
 477      * @return true if traversal should continue and node children be traversed, false otherwise
 478      */
 479     public boolean enterAND(final BinaryNode binaryNode) {
 480         return enterDefault(binaryNode);
 481     }
 482 
 483     /**
 484      * Binary leave - callback for leaving a {@literal &amp;&amp;} operator
 485      *
 486      * @param  binaryNode the node
 487      * @return processed node, which will replace the original one, or the original node
 488      */
 489     public Node leaveAND(final BinaryNode binaryNode) {
 490         return leaveDefault(binaryNode);
 491     }
 492 
 493     /**
 494      * Binary enter - callback for entering an assignment
 495      *
 496      * @param  binaryNode the node
 497      * @return true if traversal should continue and node children be traversed, false otherwise
 498      */
 499     public boolean enterASSIGN(final BinaryNode binaryNode) {
 500         return enterDefault(binaryNode);
 501     }
 502 
 503     /**
 504      * Binary leave - callback for leaving an assignment
 505      *
 506      * @param  binaryNode the node
 507      * @return processed node, which will replace the original one, or the original node
 508      */
 509     public Node leaveASSIGN(final BinaryNode binaryNode) {
 510         return leaveDefault(binaryNode);
 511     }
 512 
 513     /**
 514      * Binary enter - callback for entering += operator
 515      *
 516      * @param  binaryNode the node
 517      * @return true if traversal should continue and node children be traversed, false otherwise
 518      */
 519     public boolean enterASSIGN_ADD(final BinaryNode binaryNode) {
 520         return enterDefault(binaryNode);
 521     }
 522 
 523     /**
 524      * Binary leave - callback for leaving a += operator
 525      *
 526      * @param  binaryNode the node
 527      * @return processed node, which will replace the original one, or the original node
 528      */
 529     public Node leaveASSIGN_ADD(final BinaryNode binaryNode) {
 530         return leaveDefault(binaryNode);
 531     }
 532 
 533     /**
 534      * Binary enter - callback for entering {@literal &amp;=} operator
 535      *
 536      * @param  binaryNode the node
 537      * @return true if traversal should continue and node children be traversed, false otherwise
 538      */
 539     public boolean enterASSIGN_BIT_AND(final BinaryNode binaryNode) {
 540         return enterDefault(binaryNode);
 541     }
 542 
 543     /**
 544      * Binary leave - callback for leaving a {@literal &amp;=} operator
 545      *
 546      * @param  binaryNode the node
 547      * @return processed node, which will replace the original one, or the original node
 548      */
 549     public Node leaveASSIGN_BIT_AND(final BinaryNode binaryNode) {
 550         return leaveDefault(binaryNode);
 551     }
 552 
 553     /**
 554      * Binary enter - callback for entering |= operator
 555      *
 556      * @param  binaryNode the node
 557      * @return true if traversal should continue and node children be traversed, false otherwise
 558      */
 559     public boolean enterASSIGN_BIT_OR(final BinaryNode binaryNode) {
 560         return enterDefault(binaryNode);
 561     }
 562 
 563     /**
 564      * Binary leave - callback for leaving a |= operator
 565      *
 566      * @param  binaryNode the node
 567      * @return processed node, which will replace the original one, or the original node
 568      */
 569     public Node leaveASSIGN_BIT_OR(final BinaryNode binaryNode) {
 570         return leaveDefault(binaryNode);
 571     }
 572 
 573     /**
 574      * Binary enter - callback for entering ^= operator
 575      *
 576      * @param  binaryNode the node
 577      * @return true if traversal should continue and node children be traversed, false otherwise
 578      */
 579     public boolean enterASSIGN_BIT_XOR(final BinaryNode binaryNode) {
 580         return enterDefault(binaryNode);
 581     }
 582 
 583     /**
 584      * Binary leave - callback for leaving a ^= operator
 585      *
 586      * @param  binaryNode the node
 587      * @return processed node, which will replace the original one, or the original node
 588      */
 589     public Node leaveASSIGN_BIT_XOR(final BinaryNode binaryNode) {
 590         return leaveDefault(binaryNode);
 591     }
 592 
 593     /**
 594      * Binary enter - callback for entering /= operator
 595      *
 596      * @param  binaryNode the node
 597      * @return true if traversal should continue and node children be traversed, false otherwise
 598      */
 599     public boolean enterASSIGN_DIV(final BinaryNode binaryNode) {
 600         return enterDefault(binaryNode);
 601     }
 602 
 603     /**
 604      * Binary leave - callback for leaving a /= operator
 605      *
 606      * @param  binaryNode the node
 607      * @return processed node, which will replace the original one, or the original node
 608      */
 609     public Node leaveASSIGN_DIV(final BinaryNode binaryNode) {
 610         return leaveDefault(binaryNode);
 611     }
 612 
 613     /**
 614      * Binary enter - callback for entering %= operator
 615      *
 616      * @param  binaryNode the node
 617      * @return true if traversal should continue and node children be traversed, false otherwise
 618      */
 619     public boolean enterASSIGN_MOD(final BinaryNode binaryNode) {
 620         return enterDefault(binaryNode);
 621     }
 622 
 623     /**
 624      * Binary leave - callback for leaving a %= operator
 625      *
 626      * @param  binaryNode the node
 627      * @return processed node, which will replace the original one, or the original node
 628      */
 629     public Node leaveASSIGN_MOD(final BinaryNode binaryNode) {
 630         return leaveDefault(binaryNode);
 631     }
 632 
 633     /**
 634      * Binary enter - callback for entering *= operator
 635      *
 636      * @param  binaryNode the node
 637      * @return true if traversal should continue and node children be traversed, false otherwise
 638      */
 639     public boolean enterASSIGN_MUL(final BinaryNode binaryNode) {
 640         return enterDefault(binaryNode);
 641     }
 642 
 643     /**
 644      * Binary leave - callback for leaving a *= operator
 645      *
 646      * @param  binaryNode the node
 647      * @return processed node, which will replace the original one, or the original node
 648      */
 649     public Node leaveASSIGN_MUL(final BinaryNode binaryNode) {
 650         return leaveDefault(binaryNode);
 651     }
 652 
 653     /**
 654      * Binary enter - callback for entering {@literal &gt;&gt;=} operator
 655      *
 656      * @param  binaryNode the node
 657      * @return true if traversal should continue and node children be traversed, false otherwise
 658      */
 659     public boolean enterASSIGN_SAR(final BinaryNode binaryNode) {
 660         return enterDefault(binaryNode);
 661     }
 662 
 663     /**
 664      * Binary leave - callback for leaving a {@literal &gt;&gt;=} operator
 665      *
 666      * @param  binaryNode the node
 667      * @return processed node, which will replace the original one, or the original node
 668      */
 669     public Node leaveASSIGN_SAR(final BinaryNode binaryNode) {
 670         return leaveDefault(binaryNode);
 671     }
 672 
 673     /**
 674      * Binary enter - callback for entering a {@literal &lt;&lt;=} operator
 675      *
 676      * @param  binaryNode the node
 677      * @return true if traversal should continue and node children be traversed, false otherwise
 678      */
 679     public boolean enterASSIGN_SHL(final BinaryNode binaryNode) {
 680         return enterDefault(binaryNode);
 681     }
 682 
 683     /**
 684      * Binary leave - callback for leaving a {@literal &lt;&lt;=} operator
 685      *
 686      * @param  binaryNode the node
 687      * @return processed node, which will replace the original one, or the original node
 688      */
 689     public Node leaveASSIGN_SHL(final BinaryNode binaryNode) {
 690         return leaveDefault(binaryNode);
 691     }
 692 
 693     /**
 694      * Binary enter - callback for entering {@literal &gt;&gt;&gt;=} operator
 695      *
 696      * @param  binaryNode the node
 697      * @return true if traversal should continue and node children be traversed, false otherwise
 698      */
 699     public boolean enterASSIGN_SHR(final BinaryNode binaryNode) {
 700         return enterDefault(binaryNode);
 701     }
 702 
 703     /**
 704      * Binary leave - callback for leaving a {@literal &gt;&gt;&gt;=} operator
 705      *
 706      * @param  binaryNode the node
 707      * @return processed node, which will replace the original one, or the original node
 708      */
 709     public Node leaveASSIGN_SHR(final BinaryNode binaryNode) {
 710         return leaveDefault(binaryNode);
 711     }
 712 
 713     /**
 714      * Binary enter - callback for entering -= operator
 715      *
 716      * @param  binaryNode the node
 717      * @return true if traversal should continue and node children be traversed, false otherwise
 718      */
 719     public boolean enterASSIGN_SUB(final BinaryNode binaryNode) {
 720         return enterDefault(binaryNode);
 721     }
 722 
 723     /**
 724      * Binary leave - callback for leaving a -= operator
 725      *
 726      * @param  binaryNode the node
 727      * @return processed node, which will replace the original one, or the original node
 728      */
 729     public Node leaveASSIGN_SUB(final BinaryNode binaryNode) {
 730         return leaveDefault(binaryNode);
 731     }
 732 
 733     /**
 734      * Binary enter - callback for entering a arrow operator
 735      *
 736      * @param  binaryNode the node
 737      * @return true if traversal should continue and node children be traversed, false otherwise
 738      */
 739     public boolean enterARROW(final BinaryNode binaryNode) {
 740         return enterDefault(binaryNode);
 741     }
 742 
 743     /**
 744      * Binary leave - callback for leaving a arrow operator
 745      *
 746      * @param  binaryNode the node
 747      * @return processed node, which will replace the original one, or the original node
 748      */
 749     public Node leaveARROW(final BinaryNode binaryNode) {
 750         return leaveDefault(binaryNode);
 751     }
 752 
 753     /**
 754      * Binary enter - callback for entering {@literal &amp;} operator
 755      *
 756      * @param  binaryNode the node
 757      * @return true if traversal should continue and node children be traversed, false otherwise
 758      */
 759     public boolean enterBIT_AND(final BinaryNode binaryNode) {
 760         return enterDefault(binaryNode);
 761     }
 762 
 763     /**
 764      * Binary leave - callback for leaving a {@literal &amp;} operator
 765      *
 766      * @param  binaryNode the node
 767      * @return processed node, which will replace the original one, or the original node
 768      */
 769     public Node leaveBIT_AND(final BinaryNode binaryNode) {
 770         return leaveDefault(binaryNode);
 771     }
 772 
 773     /**
 774      * Binary enter - callback for entering | operator
 775      *
 776      * @param  binaryNode the node
 777      * @return true if traversal should continue and node children be traversed, false otherwise
 778      */
 779     public boolean enterBIT_OR(final BinaryNode binaryNode) {
 780         return enterDefault(binaryNode);
 781     }
 782 
 783     /**
 784      * Binary leave - callback for leaving a | operator
 785      *
 786      * @param  binaryNode the node
 787      * @return processed node, which will replace the original one, or the original node
 788      */
 789     public Node leaveBIT_OR(final BinaryNode binaryNode) {
 790         return leaveDefault(binaryNode);
 791     }
 792 
 793     /**
 794      * Binary enter - callback for entering ^ operator
 795      *
 796      * @param  binaryNode the node
 797      * @return true if traversal should continue and node children be traversed, false otherwise
 798      */
 799     public boolean enterBIT_XOR(final BinaryNode binaryNode) {
 800         return enterDefault(binaryNode);
 801     }
 802 
 803     /**
 804      * Binary leave - callback for leaving a  operator
 805      *
 806      * @param  binaryNode the node
 807      * @return processed node, which will replace the original one, or the original node
 808      */
 809     public Node leaveBIT_XOR(final BinaryNode binaryNode) {
 810         return leaveDefault(binaryNode);
 811     }
 812 
 813     /**
 814      * Binary enter - callback for entering comma right operator
 815      * (a, b) where the result is b
 816      *
 817      * @param  binaryNode the node
 818      * @return true if traversal should continue and node children be traversed, false otherwise
 819      */
 820     public boolean enterCOMMARIGHT(final BinaryNode binaryNode) {
 821         return enterDefault(binaryNode);
 822     }
 823 
 824     /**
 825      * Binary leave - callback for leaving a comma left operator
 826      * (a, b) where the result is b
 827      *
 828      * @param  binaryNode the node
 829      * @return processed node, which will replace the original one, or the original node
 830      */
 831     public Node leaveCOMMARIGHT(final BinaryNode binaryNode) {
 832         return leaveDefault(binaryNode);
 833     }
 834 
 835     /**
 836      * Binary enter - callback for entering a division
 837      *
 838      * @param  binaryNode the node
 839      * @return true if traversal should continue and node children be traversed, false otherwise
 840      */
 841     public boolean enterDIV(final BinaryNode binaryNode) {
 842         return enterDefault(binaryNode);
 843     }
 844 
 845     /**
 846      * Binary leave - callback for leaving a division
 847      *
 848      * @param  binaryNode the node
 849      * @return processed node, which will replace the original one, or the original node
 850      */
 851     public Node leaveDIV(final BinaryNode binaryNode) {
 852         return leaveDefault(binaryNode);
 853     }
 854 
 855     /**
 856      * Binary enter - callback for entering == operator
 857      *
 858      * @param  binaryNode the node
 859      * @return true if traversal should continue and node children be traversed, false otherwise
 860      */
 861     public boolean enterEQ(final BinaryNode binaryNode) {
 862         return enterDefault(binaryNode);
 863     }
 864 
 865     /**
 866      * Binary leave - callback for leaving == operator
 867      *
 868      * @param  binaryNode the node
 869      * @return processed node, which will replace the original one, or the original node
 870      */
 871     public Node leaveEQ(final BinaryNode binaryNode) {
 872         return leaveDefault(binaryNode);
 873     }
 874 
 875     /**
 876      * Binary enter - callback for entering === operator
 877      *
 878      * @param  binaryNode the node
 879      * @return true if traversal should continue and node children be traversed, false otherwise
 880      */
 881     public boolean enterEQ_STRICT(final BinaryNode binaryNode) {
 882         return enterDefault(binaryNode);
 883     }
 884 
 885     /**
 886      * Binary leave - callback for leaving === operator
 887      *
 888      * @param  binaryNode the node
 889      * @return processed node, which will replace the original one, or the original node
 890      */
 891     public Node leaveEQ_STRICT(final BinaryNode binaryNode) {
 892         return leaveDefault(binaryNode);
 893     }
 894 
 895     /**
 896      * Binary enter - callback for entering {@literal &gt;=} operator
 897      *
 898      * @param  binaryNode the node
 899      * @return true if traversal should continue and node children be traversed, false otherwise
 900      */
 901     public boolean enterGE(final BinaryNode binaryNode) {
 902         return enterDefault(binaryNode);
 903     }
 904 
 905     /**
 906      * Binary leave - callback for leaving {@literal &gt;=} operator
 907      *
 908      * @param  binaryNode the node
 909      * @return processed node, which will replace the original one, or the original node
 910      */
 911     public Node leaveGE(final BinaryNode binaryNode) {
 912         return leaveDefault(binaryNode);
 913     }
 914 
 915     /**
 916      * Binary enter - callback for entering {@literal &gt;} operator
 917      *
 918      * @param  binaryNode the node
 919      * @return true if traversal should continue and node children be traversed, false otherwise
 920      */
 921     public boolean enterGT(final BinaryNode binaryNode) {
 922         return enterDefault(binaryNode);
 923     }
 924 
 925     /**
 926      * Binary leave - callback for leaving {@literal &gt;} operator
 927      *
 928      * @param  binaryNode the node
 929      * @return processed node, which will replace the original one, or the original node
 930      */
 931     public Node leaveGT(final BinaryNode binaryNode) {
 932         return leaveDefault(binaryNode);
 933     }
 934 
 935     /**
 936      * Binary enter - callback for entering in operator
 937      *
 938      * @param  binaryNode the node
 939      * @return true if traversal should continue and node children be traversed, false otherwise
 940      */
 941     public boolean enterIN(final BinaryNode binaryNode) {
 942         return enterDefault(binaryNode);
 943     }
 944 
 945     /**
 946      * Binary leave - callback for leaving in operator
 947      *
 948      * @param  binaryNode the node
 949      * @return processed node, which will replace the original one, or the original node
 950      */
 951     public Node leaveIN(final BinaryNode binaryNode) {
 952         return leaveDefault(binaryNode);
 953     }
 954 
 955     /**
 956      * Binary enter - callback for entering instanceof operator
 957      *
 958      * @param  binaryNode the node
 959      * @return true if traversal should continue and node children be traversed, false otherwise
 960      */
 961     public boolean enterINSTANCEOF(final BinaryNode binaryNode) {
 962         return enterDefault(binaryNode);
 963     }
 964 
 965     /**
 966      * Binary leave - callback for leaving instanceof operator
 967      *
 968      * @param  binaryNode the node
 969      * @return processed node, which will replace the original one, or the original node
 970      */
 971     public Node leaveINSTANCEOF(final BinaryNode binaryNode) {
 972         return leaveDefault(binaryNode);
 973     }
 974 
 975     /**
 976      * Binary enter - callback for entering {@literal &lt;=} operator
 977      *
 978      * @param  binaryNode the node
 979      * @return true if traversal should continue and node children be traversed, false otherwise
 980      */
 981     public boolean enterLE(final BinaryNode binaryNode) {
 982         return enterDefault(binaryNode);
 983     }
 984 
 985     /**
 986      * Binary leave - callback for leaving {@literal &lt;=} operator
 987      *
 988      * @param  binaryNode the node
 989      * @return processed node, which will replace the original one, or the original node
 990      */
 991     public Node leaveLE(final BinaryNode binaryNode) {
 992         return leaveDefault(binaryNode);
 993     }
 994 
 995     /**
 996      * Binary enter - callback for entering {@literal &lt;} operator
 997      *
 998      * @param  binaryNode the node
 999      * @return true if traversal should continue and node children be traversed, false otherwise
1000      */
1001     public boolean enterLT(final BinaryNode binaryNode) {
1002         return enterDefault(binaryNode);
1003     }
1004 
1005     /**
1006      * Binary leave - callback for leaving {@literal &lt;} operator
1007      *
1008      * @param  binaryNode the node
1009      * @return processed node, which will replace the original one, or the original node
1010      */
1011     public Node leaveLT(final BinaryNode binaryNode) {
1012         return leaveDefault(binaryNode);
1013     }
1014     /**
1015      * Binary enter - callback for entering % operator
1016      *
1017      * @param  binaryNode the node
1018      * @return true if traversal should continue and node children be traversed, false otherwise
1019      */
1020     public boolean enterMOD(final BinaryNode binaryNode) {
1021         return enterDefault(binaryNode);
1022     }
1023 
1024     /**
1025      * Binary leave - callback for leaving % operator
1026      *
1027      * @param  binaryNode the node
1028      * @return processed node, which will replace the original one, or the original node
1029      */
1030     public Node leaveMOD(final BinaryNode binaryNode) {
1031         return leaveDefault(binaryNode);
1032     }
1033 
1034     /**
1035      * Binary enter - callback for entering * operator
1036      *
1037      * @param  binaryNode the node
1038      * @return true if traversal should continue and node children be traversed, false otherwise
1039      */
1040     public boolean enterMUL(final BinaryNode binaryNode) {
1041         return enterDefault(binaryNode);
1042     }
1043 
1044     /**
1045      * Binary leave - callback for leaving * operator
1046      *
1047      * @param  binaryNode the node
1048      * @return processed node, which will replace the original one, or the original node
1049      */
1050     public Node leaveMUL(final BinaryNode binaryNode) {
1051         return leaveDefault(binaryNode);
1052     }
1053 
1054     /**
1055      * Binary enter - callback for entering != operator
1056      *
1057      * @param  binaryNode the node
1058      * @return true if traversal should continue and node children be traversed, false otherwise
1059      */
1060     public boolean enterNE(final BinaryNode binaryNode) {
1061         return enterDefault(binaryNode);
1062     }
1063 
1064     /**
1065      * Binary leave - callback for leaving != operator
1066      *
1067      * @param  binaryNode the node
1068      * @return processed node, which will replace the original one, or the original node
1069      */
1070     public Node leaveNE(final BinaryNode binaryNode) {
1071         return leaveDefault(binaryNode);
1072     }
1073 
1074     /**
1075      * Binary enter - callback for entering a !== operator
1076      *
1077      * @param  binaryNode the node
1078      * @return true if traversal should continue and node children be traversed, false otherwise
1079      */
1080     public boolean enterNE_STRICT(final BinaryNode binaryNode) {
1081         return enterDefault(binaryNode);
1082     }
1083 
1084     /**
1085      * Binary leave - callback for leaving !== operator
1086      *
1087      * @param  binaryNode the node
1088      * @return processed node, which will replace the original one, or the original node
1089      */
1090     public Node leaveNE_STRICT(final BinaryNode binaryNode) {
1091         return leaveDefault(binaryNode);
1092     }
1093 
1094     /**
1095      * Binary enter - callback for entering || operator
1096      *
1097      * @param  binaryNode the node
1098      * @return true if traversal should continue and node children be traversed, false otherwise
1099      */
1100     public boolean enterOR(final BinaryNode binaryNode) {
1101         return enterDefault(binaryNode);
1102     }
1103 
1104     /**
1105      * Binary leave - callback for leaving || operator
1106      *
1107      * @param  binaryNode the node
1108      * @return processed node, which will replace the original one, or the original node
1109      */
1110     public Node leaveOR(final BinaryNode binaryNode) {
1111         return leaveDefault(binaryNode);
1112     }
1113 
1114     /**
1115      * Binary enter - callback for entering {@literal &gt;&gt;} operator
1116      *
1117      * @param  binaryNode the node
1118      * @return true if traversal should continue and node children be traversed, false otherwise
1119      */
1120     public boolean enterSAR(final BinaryNode binaryNode) {
1121         return enterDefault(binaryNode);
1122     }
1123 
1124     /**
1125      * Binary leave - callback for leaving {@literal &gt;&gt;} operator
1126      *
1127      * @param  binaryNode the node
1128      * @return processed node, which will replace the original one, or the original node
1129      */
1130     public Node leaveSAR(final BinaryNode binaryNode) {
1131         return leaveDefault(binaryNode);
1132     }
1133 
1134     /**
1135      * Binary enter - callback for entering {@literal &lt;&lt;} operator
1136      *
1137      * @param  binaryNode the node
1138      * @return true if traversal should continue and node children be traversed, false otherwise
1139      */
1140     public boolean enterSHL(final BinaryNode binaryNode) {
1141         return enterDefault(binaryNode);
1142     }
1143 
1144     /**
1145      * Binary leave - callback for leaving {@literal &lt;&lt;} operator
1146      *
1147      * @param  binaryNode the node
1148      * @return processed node, which will replace the original one, or the original node
1149      */
1150     public Node leaveSHL(final BinaryNode binaryNode) {
1151         return leaveDefault(binaryNode);
1152     }
1153     /**
1154      * Binary enter - callback for entering {@literal &gt;&gt;&gt;} operator
1155      *
1156      * @param  binaryNode the node
1157      * @return true if traversal should continue and node children be traversed, false otherwise
1158      */
1159     public boolean enterSHR(final BinaryNode binaryNode) {
1160         return enterDefault(binaryNode);
1161     }
1162 
1163     /**
1164      * Binary leave - callback for leaving {@literal &gt;&gt;&gt;} operator
1165      *
1166      * @param  binaryNode the node
1167      * @return processed node, which will replace the original one, or the original node
1168      */
1169     public Node leaveSHR(final BinaryNode binaryNode) {
1170         return leaveDefault(binaryNode);
1171     }
1172 
1173     /**
1174      * Binary enter - callback for entering - operator
1175      *
1176      * @param  binaryNode the node
1177      * @return true if traversal should continue and node children be traversed, false otherwise
1178      */
1179     public boolean enterSUB(final BinaryNode binaryNode) {
1180         return enterDefault(binaryNode);
1181     }
1182 
1183     /**
1184      * Binary leave - callback for leaving - operator
1185      *
1186      * @param  binaryNode the node
1187      * @return processed node, which will replace the original one, or the original node
1188      */
1189     public Node leaveSUB(final BinaryNode binaryNode) {
1190         return leaveDefault(binaryNode);
1191     }
1192 }
    </pre>
  </body>
</html>
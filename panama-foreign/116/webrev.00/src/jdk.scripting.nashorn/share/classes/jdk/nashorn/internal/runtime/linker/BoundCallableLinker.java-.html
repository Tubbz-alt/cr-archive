<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/linker/BoundCallableLinker.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.runtime.linker;
 27 
 28 import java.lang.invoke.MethodHandle;
 29 import java.lang.invoke.MethodHandles;
 30 import java.lang.invoke.MethodType;
 31 import java.util.Arrays;
 32 import jdk.dynalink.CallSiteDescriptor;
 33 import jdk.dynalink.NamedOperation;
 34 import jdk.dynalink.Operation;
 35 import jdk.dynalink.StandardOperation;
 36 import jdk.dynalink.linker.GuardedInvocation;
 37 import jdk.dynalink.linker.LinkRequest;
 38 import jdk.dynalink.linker.LinkerServices;
 39 import jdk.dynalink.linker.TypeBasedGuardingDynamicLinker;
 40 import jdk.dynalink.linker.support.Guards;
 41 
 42 /**
 43  * Links {@link BoundCallable} objects. Passes through to linker services for linking a callable (for either
 44  * StandardOperation.CALL or .NEW, and modifies the returned invocation to deal with the receiver and argument binding.
 45  */
 46 final class BoundCallableLinker implements TypeBasedGuardingDynamicLinker {
 47     @Override
 48     public boolean canLinkType(final Class&lt;?&gt; type) {
 49         return type == BoundCallable.class;
 50     }
 51 
 52     @Override
 53     public GuardedInvocation getGuardedInvocation(final LinkRequest linkRequest, final LinkerServices linkerServices) throws Exception {
 54         final Object objBoundCallable = linkRequest.getReceiver();
 55         if(!(objBoundCallable instanceof BoundCallable)) {
 56             return null;
 57         }
 58 
 59         final CallSiteDescriptor descriptor = linkRequest.getCallSiteDescriptor();
 60         final Operation operation = NamedOperation.getBaseOperation(descriptor.getOperation());
 61         // We need to distinguish NEW from CALL because CALL sites have parameter list of the form
 62         // &quot;callee, this, args&quot;, while NEW sites have &quot;callee, args&quot; -- they lack the &quot;this&quot; parameter.
 63         final boolean isCall;
 64         if (operation == StandardOperation.NEW) {
 65             isCall = false;
 66         } else if (operation == StandardOperation.CALL) {
 67             isCall = true;
 68         } else {
 69             // Only CALL and NEW are supported.
 70             return null;
 71         }
 72         final BoundCallable boundCallable = (BoundCallable)objBoundCallable;
 73         final Object callable = boundCallable.getCallable();
 74         final Object boundThis = boundCallable.getBoundThis();
 75 
 76         // We need to ask the linker services for a delegate invocation on the target callable.
 77 
 78         // Replace arguments (boundCallable[, this], args) =&gt; (callable[, boundThis], boundArgs, args) when delegating
 79         final Object[] args = linkRequest.getArguments();
 80         final Object[] boundArgs = boundCallable.getBoundArgs();
 81         final int argsLen = args.length;
 82         final int boundArgsLen = boundArgs.length;
 83         final Object[] newArgs = new Object[argsLen + boundArgsLen];
 84         newArgs[0] = callable;
 85         final int firstArgIndex;
 86         if (isCall) {
 87             newArgs[1] = boundThis;
 88             firstArgIndex = 2;
 89         } else {
 90             firstArgIndex = 1;
 91         }
 92         System.arraycopy(boundArgs, 0, newArgs, firstArgIndex, boundArgsLen);
 93         System.arraycopy(args, firstArgIndex, newArgs, firstArgIndex + boundArgsLen, argsLen - firstArgIndex);
 94 
 95         // Use R(T0, T1, T2, ...) =&gt; R(callable.class, boundThis.class, boundArg0.class, ..., boundArgn.class, T2, ...)
 96         // call site type when delegating to underlying linker (for NEW, there&#39;s no this).
 97         final MethodType type = descriptor.getMethodType();
 98         // Use R(T0, ...) =&gt; R(callable.class, ...)
 99         MethodType newMethodType = descriptor.getMethodType().changeParameterType(0, callable.getClass());
100         if (isCall) {
101             // R(callable.class, T1, ...) =&gt; R(callable.class, boundThis.class, ...)
102             newMethodType = newMethodType.changeParameterType(1, boundThis == null? Object.class : boundThis.getClass());
103         }
104         // R(callable.class[, boundThis.class], T2, ...) =&gt; R(callable.class[, boundThis.class], boundArg0.class, ..., boundArgn.class, T2, ...)
105         for(int i = boundArgs.length; i-- &gt; 0;) {
106             newMethodType = newMethodType.insertParameterTypes(firstArgIndex, boundArgs[i] == null ? Object.class : boundArgs[i].getClass());
107         }
108         final CallSiteDescriptor newDescriptor = descriptor.changeMethodType(newMethodType);
109 
110         // Delegate to target&#39;s linker
111         final GuardedInvocation inv = linkerServices.getGuardedInvocation(linkRequest.replaceArguments(newDescriptor, newArgs));
112         if(inv == null) {
113             return null;
114         }
115 
116         // Bind (callable[, boundThis], boundArgs) to the delegate handle
117         final MethodHandle boundHandle = MethodHandles.insertArguments(inv.getInvocation(), 0,
118                 Arrays.copyOf(newArgs, firstArgIndex + boundArgs.length));
119         final Class&lt;?&gt; p0Type = type.parameterType(0);
120         final MethodHandle droppingHandle;
121         if (isCall) {
122             // Ignore incoming boundCallable and this
123             droppingHandle = MethodHandles.dropArguments(boundHandle, 0, p0Type, type.parameterType(1));
124         } else {
125             // Ignore incoming boundCallable
126             droppingHandle = MethodHandles.dropArguments(boundHandle, 0, p0Type);
127         }
128         // Identity guard on boundCallable object
129         final MethodHandle newGuard = Guards.getIdentityGuard(boundCallable);
130         return inv.replaceMethods(droppingHandle, newGuard.asType(newGuard.type().changeParameterType(0, p0Type)));
131     }
132 }
    </pre>
  </body>
</html>
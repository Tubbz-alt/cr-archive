<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/codegen/AssignSymbols.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.codegen;
 27 
 28 import static jdk.nashorn.internal.codegen.CompilerConstants.ARGUMENTS;
 29 import static jdk.nashorn.internal.codegen.CompilerConstants.ARGUMENTS_VAR;
 30 import static jdk.nashorn.internal.codegen.CompilerConstants.CALLEE;
 31 import static jdk.nashorn.internal.codegen.CompilerConstants.EXCEPTION_PREFIX;
 32 import static jdk.nashorn.internal.codegen.CompilerConstants.ITERATOR_PREFIX;
 33 import static jdk.nashorn.internal.codegen.CompilerConstants.RETURN;
 34 import static jdk.nashorn.internal.codegen.CompilerConstants.SCOPE;
 35 import static jdk.nashorn.internal.codegen.CompilerConstants.SWITCH_TAG_PREFIX;
 36 import static jdk.nashorn.internal.codegen.CompilerConstants.THIS;
 37 import static jdk.nashorn.internal.codegen.CompilerConstants.VARARGS;
 38 import static jdk.nashorn.internal.ir.Symbol.HAS_OBJECT_VALUE;
 39 import static jdk.nashorn.internal.ir.Symbol.IS_CONST;
 40 import static jdk.nashorn.internal.ir.Symbol.IS_FUNCTION_SELF;
 41 import static jdk.nashorn.internal.ir.Symbol.IS_GLOBAL;
 42 import static jdk.nashorn.internal.ir.Symbol.IS_INTERNAL;
 43 import static jdk.nashorn.internal.ir.Symbol.IS_LET;
 44 import static jdk.nashorn.internal.ir.Symbol.IS_PARAM;
 45 import static jdk.nashorn.internal.ir.Symbol.IS_PROGRAM_LEVEL;
 46 import static jdk.nashorn.internal.ir.Symbol.IS_SCOPE;
 47 import static jdk.nashorn.internal.ir.Symbol.IS_THIS;
 48 import static jdk.nashorn.internal.ir.Symbol.IS_VAR;
 49 import static jdk.nashorn.internal.ir.Symbol.KINDMASK;
 50 
 51 import java.util.ArrayDeque;
 52 import java.util.ArrayList;
 53 import java.util.Deque;
 54 import java.util.HashMap;
 55 import java.util.HashSet;
 56 import java.util.Iterator;
 57 import java.util.List;
 58 import java.util.ListIterator;
 59 import java.util.Map;
 60 import java.util.Set;
 61 import jdk.nashorn.internal.ir.AccessNode;
 62 import jdk.nashorn.internal.ir.BaseNode;
 63 import jdk.nashorn.internal.ir.BinaryNode;
 64 import jdk.nashorn.internal.ir.Block;
 65 import jdk.nashorn.internal.ir.CatchNode;
 66 import jdk.nashorn.internal.ir.Expression;
 67 import jdk.nashorn.internal.ir.ForNode;
 68 import jdk.nashorn.internal.ir.FunctionNode;
 69 import jdk.nashorn.internal.ir.IdentNode;
 70 import jdk.nashorn.internal.ir.IndexNode;
 71 import jdk.nashorn.internal.ir.LexicalContextNode;
 72 import jdk.nashorn.internal.ir.LiteralNode;
 73 import jdk.nashorn.internal.ir.Node;
 74 import jdk.nashorn.internal.ir.RuntimeNode;
 75 import jdk.nashorn.internal.ir.RuntimeNode.Request;
 76 import jdk.nashorn.internal.ir.Splittable;
 77 import jdk.nashorn.internal.ir.Statement;
 78 import jdk.nashorn.internal.ir.SwitchNode;
 79 import jdk.nashorn.internal.ir.Symbol;
 80 import jdk.nashorn.internal.ir.TryNode;
 81 import jdk.nashorn.internal.ir.UnaryNode;
 82 import jdk.nashorn.internal.ir.VarNode;
 83 import jdk.nashorn.internal.ir.WithNode;
 84 import jdk.nashorn.internal.ir.visitor.SimpleNodeVisitor;
 85 import jdk.nashorn.internal.parser.TokenType;
 86 import jdk.nashorn.internal.runtime.Context;
 87 import jdk.nashorn.internal.runtime.ECMAErrors;
 88 import jdk.nashorn.internal.runtime.ErrorManager;
 89 import jdk.nashorn.internal.runtime.JSErrorType;
 90 import jdk.nashorn.internal.runtime.ParserException;
 91 import jdk.nashorn.internal.runtime.Source;
 92 import jdk.nashorn.internal.runtime.logging.DebugLogger;
 93 import jdk.nashorn.internal.runtime.logging.Loggable;
 94 import jdk.nashorn.internal.runtime.logging.Logger;
 95 
 96 /**
 97  * This visitor assigns symbols to identifiers denoting variables. It does few more minor calculations that are only
 98  * possible after symbols have been assigned; such is the transformation of &quot;delete&quot; and &quot;typeof&quot; operators into runtime
 99  * nodes and counting of number of properties assigned to &quot;this&quot; in constructor functions. This visitor is also notable
100  * for what it doesn&#39;t do, most significantly it does no type calculations as in JavaScript variables can change types
101  * during runtime and as such symbols don&#39;t have types. Calculation of expression types is performed by a separate
102  * visitor.
103  */
104 @Logger(name=&quot;symbols&quot;)
105 final class AssignSymbols extends SimpleNodeVisitor implements Loggable {
106     private final DebugLogger log;
107     private final boolean     debug;
108 
109     private static boolean isParamOrVar(final IdentNode identNode) {
110         final Symbol symbol = identNode.getSymbol();
111         return symbol.isParam() || symbol.isVar();
112     }
113 
114     private static String name(final Node node) {
115         final String cn = node.getClass().getName();
116         final int lastDot = cn.lastIndexOf(&#39;.&#39;);
117         if (lastDot == -1) {
118             return cn;
119         }
120         return cn.substring(lastDot + 1);
121     }
122 
123     /**
124      * Checks if various symbols that were provisionally marked as needing a slot ended up unused, and marks them as not
125      * needing a slot after all.
126      * @param functionNode the function node
127      * @return the passed in node, for easy chaining
128      */
129     private static FunctionNode removeUnusedSlots(final FunctionNode functionNode) {
130         if (!functionNode.needsCallee()) {
131             functionNode.compilerConstant(CALLEE).setNeedsSlot(false);
132         }
133         if (!(functionNode.hasScopeBlock() || functionNode.needsParentScope())) {
134             functionNode.compilerConstant(SCOPE).setNeedsSlot(false);
135         }
136         // Named function expressions that end up not referencing themselves won&#39;t need a local slot for the self symbol.
137         if(functionNode.isNamedFunctionExpression() &amp;&amp; !functionNode.usesSelfSymbol()) {
138             final Symbol selfSymbol = functionNode.getBody().getExistingSymbol(functionNode.getIdent().getName());
139             if(selfSymbol != null &amp;&amp; selfSymbol.isFunctionSelf()) {
140                 selfSymbol.setNeedsSlot(false);
141                 selfSymbol.clearFlag(Symbol.IS_VAR);
142             }
143         }
144         return functionNode;
145     }
146 
147     private final Deque&lt;Set&lt;String&gt;&gt; thisProperties = new ArrayDeque&lt;&gt;();
148     private final Map&lt;String, Symbol&gt; globalSymbols = new HashMap&lt;&gt;(); //reuse the same global symbol
149     private final Compiler compiler;
150     private final boolean isOnDemand;
151 
152     public AssignSymbols(final Compiler compiler) {
153         this.compiler = compiler;
154         this.log   = initLogger(compiler.getContext());
155         this.debug = log.isEnabled();
156         this.isOnDemand = compiler.isOnDemandCompilation();
157     }
158 
159     @Override
160     public DebugLogger getLogger() {
161         return log;
162     }
163 
164     @Override
165     public DebugLogger initLogger(final Context context) {
166         return context.getLogger(this.getClass());
167     }
168 
169     /**
170      * Define symbols for all variable declarations at the top of the function scope. This way we can get around
171      * problems like
172      *
173      * while (true) {
174      *   break;
175      *   if (true) {
176      *     var s;
177      *   }
178      * }
179      *
180      * to an arbitrary nesting depth.
181      *
182      * see NASHORN-73
183      *
184      * @param functionNode the FunctionNode we are entering
185      * @param body the body of the FunctionNode we are entering
186      */
187     private void acceptDeclarations(final FunctionNode functionNode, final Block body) {
188         // This visitor will assign symbol to all declared variables.
189         body.accept(new SimpleNodeVisitor() {
190             @Override
191             protected boolean enterDefault(final Node node) {
192                 // Don&#39;t bother visiting expressions; var is a statement, it can&#39;t be inside an expression.
193                 // This will also prevent visiting nested functions (as FunctionNode is an expression).
194                 return !(node instanceof Expression);
195             }
196 
197             @Override
198             public Node leaveVarNode(final VarNode varNode) {
199                 final IdentNode ident  = varNode.getName();
200                 final boolean blockScoped = varNode.isBlockScoped();
201                 if (blockScoped &amp;&amp; lc.inUnprotectedSwitchContext()) {
202                     throwUnprotectedSwitchError(varNode);
203                 }
204                 final Block block = blockScoped ? lc.getCurrentBlock() : body;
205                 final Symbol symbol = defineSymbol(block, ident.getName(), ident, varNode.getSymbolFlags());
206                 if (varNode.isFunctionDeclaration()) {
207                     symbol.setIsFunctionDeclaration();
208                 }
209                 return varNode.setName(ident.setSymbol(symbol));
210             }
211         });
212     }
213 
214     private IdentNode compilerConstantIdentifier(final CompilerConstants cc) {
215         return createImplicitIdentifier(cc.symbolName()).setSymbol(lc.getCurrentFunction().compilerConstant(cc));
216     }
217 
218     /**
219      * Creates an ident node for an implicit identifier within the function (one not declared in the script source
220      * code). These identifiers are defined with function&#39;s token and finish.
221      * @param name the name of the identifier
222      * @return an ident node representing the implicit identifier.
223      */
224     private IdentNode createImplicitIdentifier(final String name) {
225         final FunctionNode fn = lc.getCurrentFunction();
226         return new IdentNode(fn.getToken(), fn.getFinish(), name);
227     }
228 
229     private Symbol createSymbol(final String name, final int flags) {
230         if ((flags &amp; Symbol.KINDMASK) == IS_GLOBAL) {
231             //reuse global symbols so they can be hashed
232             Symbol global = globalSymbols.get(name);
233             if (global == null) {
234                 global = new Symbol(name, flags);
235                 globalSymbols.put(name, global);
236             }
237             return global;
238         }
239         return new Symbol(name, flags);
240     }
241 
242     /**
243      * Creates a synthetic initializer for a variable (a var statement that doesn&#39;t occur in the source code). Typically
244      * used to create assignment of {@code :callee} to the function name symbol in self-referential function
245      * expressions as well as for assignment of {@code :arguments} to {@code arguments}.
246      *
247      * @param name the ident node identifying the variable to initialize
248      * @param initConstant the compiler constant it is initialized to
249      * @param fn the function node the assignment is for
250      * @return a var node with the appropriate assignment
251      */
252     private VarNode createSyntheticInitializer(final IdentNode name, final CompilerConstants initConstant, final FunctionNode fn) {
253         final IdentNode init = compilerConstantIdentifier(initConstant);
254         assert init.getSymbol() != null &amp;&amp; init.getSymbol().isBytecodeLocal();
255 
256         final VarNode synthVar = new VarNode(fn.getLineNumber(), fn.getToken(), fn.getFinish(), name, init);
257 
258         final Symbol nameSymbol = fn.getBody().getExistingSymbol(name.getName());
259         assert nameSymbol != null;
260 
261         return (VarNode)synthVar.setName(name.setSymbol(nameSymbol)).accept(this);
262     }
263 
264     private FunctionNode createSyntheticInitializers(final FunctionNode functionNode) {
265         final List&lt;VarNode&gt; syntheticInitializers = new ArrayList&lt;&gt;(2);
266 
267         // Must visit the new var nodes in the context of the body. We could also just set the new statements into the
268         // block and then revisit the entire block, but that seems to be too much double work.
269         final Block body = functionNode.getBody();
270         lc.push(body);
271         try {
272             if (functionNode.usesSelfSymbol()) {
273                 // &quot;var fn = :callee&quot;
274                 syntheticInitializers.add(createSyntheticInitializer(functionNode.getIdent(), CALLEE, functionNode));
275             }
276 
277             if (functionNode.needsArguments()) {
278                 // &quot;var arguments = :arguments&quot;
279                 syntheticInitializers.add(createSyntheticInitializer(createImplicitIdentifier(ARGUMENTS_VAR.symbolName()),
280                         ARGUMENTS, functionNode));
281             }
282 
283             if (syntheticInitializers.isEmpty()) {
284                 return functionNode;
285             }
286 
287             for(final ListIterator&lt;VarNode&gt; it = syntheticInitializers.listIterator(); it.hasNext();) {
288                 it.set((VarNode)it.next().accept(this));
289             }
290         } finally {
291             lc.pop(body);
292         }
293 
294         final List&lt;Statement&gt; stmts = body.getStatements();
295         final List&lt;Statement&gt; newStatements = new ArrayList&lt;&gt;(stmts.size() + syntheticInitializers.size());
296         newStatements.addAll(syntheticInitializers);
297         newStatements.addAll(stmts);
298         return functionNode.setBody(lc, body.setStatements(lc, newStatements));
299     }
300 
301     /**
302      * Defines a new symbol in the given block.
303      *
304      * @param block        the block in which to define the symbol
305      * @param name         name of symbol.
306      * @param origin       origin node
307      * @param symbolFlags  Symbol flags.
308      *
309      * @return Symbol for given name or null for redefinition.
310      */
311     private Symbol defineSymbol(final Block block, final String name, final Node origin, final int symbolFlags) {
312         int    flags  = symbolFlags;
313         final boolean isBlockScope = (flags &amp; IS_LET) != 0 || (flags &amp; IS_CONST) != 0;
314         final boolean isGlobal     = (flags &amp; KINDMASK) == IS_GLOBAL;
315 
316         Symbol symbol;
317         final FunctionNode function;
318         if (isBlockScope) {
319             // block scoped variables always live in current block, no need to look for existing symbols in parent blocks.
320             symbol = block.getExistingSymbol(name);
321             function = lc.getCurrentFunction();
322         } else {
323             symbol = findSymbol(block, name);
324             function = lc.getFunction(block);
325         }
326 
327         // Global variables are implicitly always scope variables too.
328         if (isGlobal) {
329             flags |= IS_SCOPE;
330         }
331 
332         if (lc.getCurrentFunction().isProgram()) {
333             flags |= IS_PROGRAM_LEVEL;
334         }
335 
336         final boolean isParam = (flags &amp; KINDMASK) == IS_PARAM;
337         final boolean isVar =   (flags &amp; KINDMASK) == IS_VAR;
338 
339         if (symbol != null) {
340             // Symbol was already defined. Check if it needs to be redefined.
341             if (isParam) {
342                 if (!isLocal(function, symbol)) {
343                     // Not defined in this function. Create a new definition.
344                     symbol = null;
345                 } else if (symbol.isParam()) {
346                     // Duplicate parameter. Null return will force an error.
347                     throwParserException(ECMAErrors.getMessage(&quot;syntax.error.duplicate.parameter&quot;, name), origin);
348                 }
349             } else if (isVar) {
350                 if (isBlockScope) {
351                     // Check redeclaration in same block
352                     if (symbol.hasBeenDeclared()) {
353                         throwParserException(ECMAErrors.getMessage(&quot;syntax.error.redeclare.variable&quot;, name), origin);
354                     } else {
355                         symbol.setHasBeenDeclared();
356                         // Set scope flag on top-level block scoped symbols
357                         if (function.isProgram() &amp;&amp; function.getBody() == block) {
358                             symbol.setIsScope();
359                         }
360                     }
361                 } else if ((flags &amp; IS_INTERNAL) != 0) {
362                     // Always create a new definition.
363                     symbol = null;
364                 } else {
365                     // Found LET or CONST in parent scope of same function - s SyntaxError
366                     if (symbol.isBlockScoped() &amp;&amp; isLocal(lc.getCurrentFunction(), symbol)) {
367                         throwParserException(ECMAErrors.getMessage(&quot;syntax.error.redeclare.variable&quot;, name), origin);
368                     }
369                     // Not defined in this function. Create a new definition.
370                     if (!isLocal(function, symbol) || symbol.less(IS_VAR)) {
371                         symbol = null;
372                     }
373                 }
374             }
375         }
376 
377         if (symbol == null) {
378             // If not found, then create a new one.
379             final Block symbolBlock;
380 
381             // Determine where to create it.
382             if (isVar &amp;&amp; ((flags &amp; IS_INTERNAL) != 0 || isBlockScope)) {
383                 symbolBlock = block; //internal vars are always defined in the block closest to them
384             } else if (isGlobal) {
385                 symbolBlock = lc.getOutermostFunction().getBody();
386             } else {
387                 symbolBlock = lc.getFunctionBody(function);
388             }
389 
390             // Create and add to appropriate block.
391             symbol = createSymbol(name, flags);
392             symbolBlock.putSymbol(symbol);
393 
394             if ((flags &amp; IS_SCOPE) == 0) {
395                 // Initial assumption; symbol can lose its slot later
396                 symbol.setNeedsSlot(true);
397             }
398         } else if (symbol.less(flags)) {
399             symbol.setFlags(flags);
400         }
401 
402         return symbol;
403     }
404 
405     private &lt;T extends Node&gt; T end(final T node) {
406         return end(node, true);
407     }
408 
409     private &lt;T extends Node&gt; T end(final T node, final boolean printNode) {
410         if (debug) {
411             final StringBuilder sb = new StringBuilder();
412 
413             sb.append(&quot;[LEAVE &quot;).
414                 append(name(node)).
415                 append(&quot;] &quot;).
416                 append(printNode ? node.toString() : &quot;&quot;).
417                 append(&quot; in &#39;&quot;).
418                 append(lc.getCurrentFunction().getName()).
419                 append(&#39;\&#39;&#39;);
420 
421             if (node instanceof IdentNode) {
422                 final Symbol symbol = ((IdentNode)node).getSymbol();
423                 if (symbol == null) {
424                     sb.append(&quot; &lt;NO SYMBOL&gt;&quot;);
425                 } else {
426                     sb.append(&quot; &lt;symbol=&quot;).append(symbol).append(&#39;&gt;&#39;);
427                 }
428             }
429 
430             log.unindent();
431             log.info(sb);
432         }
433 
434         return node;
435     }
436 
437     @Override
438     public boolean enterBlock(final Block block) {
439         start(block);
440 
441         if (lc.isFunctionBody()) {
442             assert !block.hasSymbols();
443             final FunctionNode fn = lc.getCurrentFunction();
444             if (isUnparsedFunction(fn)) {
445                 // It&#39;s a skipped nested function. Just mark the symbols being used by it as being in use.
446                 for(final String name: compiler.getScriptFunctionData(fn.getId()).getExternalSymbolNames()) {
447                     nameIsUsed(name, null);
448                 }
449                 // Don&#39;t bother descending into it, it must be empty anyway.
450                 assert block.getStatements().isEmpty();
451                 return false;
452             }
453 
454             enterFunctionBody();
455         }
456 
457         return true;
458     }
459 
460     private boolean isUnparsedFunction(final FunctionNode fn) {
461         return isOnDemand &amp;&amp; fn != lc.getOutermostFunction();
462     }
463 
464     @Override
465     public boolean enterCatchNode(final CatchNode catchNode) {
466         final IdentNode exception = catchNode.getExceptionIdentifier();
467         final Block     block     = lc.getCurrentBlock();
468 
469         start(catchNode);
470 
471         // define block-local exception variable
472         final String exname = exception.getName();
473         // If the name of the exception starts with &quot;:e&quot;, this is a synthetic catch block, likely a catch-all. Its
474         // symbol is naturally internal, and should be treated as such.
475         final boolean isInternal = exname.startsWith(EXCEPTION_PREFIX.symbolName());
476         // IS_LET flag is required to make sure symbol is not visible outside catch block. However, we need to
477         // clear the IS_LET flag after creation to allow redefinition of symbol inside the catch block.
478         final Symbol symbol = defineSymbol(block, exname, catchNode, IS_VAR | IS_LET | (isInternal ? IS_INTERNAL : 0) | HAS_OBJECT_VALUE);
479         symbol.clearFlag(IS_LET);
480 
481         return true;
482     }
483 
484     private void enterFunctionBody() {
485         final FunctionNode functionNode = lc.getCurrentFunction();
486         final Block body = lc.getCurrentBlock();
487 
488         initFunctionWideVariables(functionNode, body);
489         acceptDeclarations(functionNode, body);
490         defineFunctionSelfSymbol(functionNode, body);
491     }
492 
493     private void defineFunctionSelfSymbol(final FunctionNode functionNode, final Block body) {
494         // Function self-symbol is only declared as a local variable for named function expressions. Declared functions
495         // don&#39;t need it as they are local variables in their declaring scope.
496         if (!functionNode.isNamedFunctionExpression()) {
497             return;
498         }
499 
500         final String name = functionNode.getIdent().getName();
501         assert name != null; // As it&#39;s a named function expression.
502 
503         if (body.getExistingSymbol(name) != null) {
504             // Body already has a declaration for the name. It&#39;s either a parameter &quot;function x(x)&quot; or a
505             // top-level variable &quot;function x() { ... var x; ... }&quot;.
506             return;
507         }
508 
509         defineSymbol(body, name, functionNode, IS_VAR | IS_FUNCTION_SELF | HAS_OBJECT_VALUE);
510         if(functionNode.allVarsInScope()) { // basically, has deep eval
511             // We must conservatively presume that eval&#39;d code can dynamically use the function symbol.
512             lc.setFlag(functionNode, FunctionNode.USES_SELF_SYMBOL);
513         }
514     }
515 
516     @Override
517     public boolean enterFunctionNode(final FunctionNode functionNode) {
518         start(functionNode, false);
519 
520         thisProperties.push(new HashSet&lt;String&gt;());
521 
522         // Every function has a body, even the ones skipped on reparse (they have an empty one). We&#39;re
523         // asserting this as even for those, enterBlock() must be invoked to correctly process symbols that
524         // are used in them.
525         assert functionNode.getBody() != null;
526 
527         return true;
528     }
529 
530     @Override
531     public boolean enterVarNode(final VarNode varNode) {
532         start(varNode);
533         // Normally, a symbol assigned in a var statement is not live for its RHS. Since we also represent function
534         // declarations as VarNodes, they are exception to the rule, as they need to have the symbol visible to the
535         // body of the declared function for self-reference.
536         if (varNode.isFunctionDeclaration()) {
537             defineVarIdent(varNode);
538         }
539         return true;
540     }
541 
542     @Override
543     public Node leaveVarNode(final VarNode varNode) {
544         if (!varNode.isFunctionDeclaration()) {
545             defineVarIdent(varNode);
546         }
547         return super.leaveVarNode(varNode);
548     }
549 
550     private void defineVarIdent(final VarNode varNode) {
551         final IdentNode ident = varNode.getName();
552         final int flags;
553         if (!varNode.isBlockScoped() &amp;&amp; lc.getCurrentFunction().isProgram()) {
554             flags = IS_SCOPE;
555         } else {
556             flags = 0;
557         }
558         defineSymbol(lc.getCurrentBlock(), ident.getName(), ident, varNode.getSymbolFlags() | flags);
559     }
560 
561     private Symbol exceptionSymbol() {
562         return newObjectInternal(EXCEPTION_PREFIX);
563     }
564 
565     /**
566      * This has to run before fix assignment types, store any type specializations for
567      * parameters, then turn them into objects for the generic version of this method.
568      *
569      * @param functionNode functionNode
570      */
571     private FunctionNode finalizeParameters(final FunctionNode functionNode) {
572         final List&lt;IdentNode&gt; newParams = new ArrayList&lt;&gt;();
573         final boolean isVarArg = functionNode.isVarArg();
574 
575         final Block body = functionNode.getBody();
576         for (final IdentNode param : functionNode.getParameters()) {
577             final Symbol paramSymbol = body.getExistingSymbol(param.getName());
578             assert paramSymbol != null;
579             assert paramSymbol.isParam() : paramSymbol + &quot; &quot; + paramSymbol.getFlags();
580             newParams.add(param.setSymbol(paramSymbol));
581 
582             // parameters should not be slots for a function that uses variable arity signature
583             if (isVarArg) {
584                 paramSymbol.setNeedsSlot(false);
585             }
586         }
587 
588         return functionNode.setParameters(lc, newParams);
589     }
590 
591     /**
592      * Search for symbol in the lexical context starting from the given block.
593      * @param name Symbol name.
594      * @return Found symbol or null if not found.
595      */
596     private Symbol findSymbol(final Block block, final String name) {
597         for (final Iterator&lt;Block&gt; blocks = lc.getBlocks(block); blocks.hasNext();) {
598             final Symbol symbol = blocks.next().getExistingSymbol(name);
599             if (symbol != null) {
600                 return symbol;
601             }
602         }
603         return null;
604     }
605 
606     /**
607      * Marks the current function as one using any global symbol. The function and all its parent functions will all be
608      * marked as needing parent scope.
609      * @see FunctionNode#needsParentScope()
610      */
611     private void functionUsesGlobalSymbol() {
612         for (final Iterator&lt;FunctionNode&gt; fns = lc.getFunctions(); fns.hasNext();) {
613             lc.setFlag(fns.next(), FunctionNode.USES_ANCESTOR_SCOPE);
614         }
615     }
616 
617     /**
618      * Marks the current function as one using a scoped symbol. The block defining the symbol will be marked as needing
619      * its own scope to hold the variable. If the symbol is defined outside of the current function, it and all
620      * functions up to (but not including) the function containing the defining block will be marked as needing parent
621      * function scope.
622      * @see FunctionNode#needsParentScope()
623      */
624     private void functionUsesScopeSymbol(final Symbol symbol) {
625         final String name = symbol.getName();
626         for (final Iterator&lt;LexicalContextNode&gt; contextNodeIter = lc.getAllNodes(); contextNodeIter.hasNext(); ) {
627             final LexicalContextNode node = contextNodeIter.next();
628             if (node instanceof Block) {
629                 final Block block = (Block)node;
630                 if (block.getExistingSymbol(name) != null) {
631                     assert lc.contains(block);
632                     lc.setBlockNeedsScope(block);
633                     break;
634                 }
635             } else if (node instanceof FunctionNode) {
636                 lc.setFlag(node, FunctionNode.USES_ANCESTOR_SCOPE);
637             }
638         }
639     }
640 
641     /**
642      * Declares that the current function is using the symbol.
643      * @param symbol the symbol used by the current function.
644      */
645     private void functionUsesSymbol(final Symbol symbol) {
646         assert symbol != null;
647         if (symbol.isScope()) {
648             if (symbol.isGlobal()) {
649                 functionUsesGlobalSymbol();
650             } else {
651                 functionUsesScopeSymbol(symbol);
652             }
653         } else {
654             assert !symbol.isGlobal(); // Every global is also scope
655         }
656     }
657 
658     private void initCompileConstant(final CompilerConstants cc, final Block block, final int flags) {
659         defineSymbol(block, cc.symbolName(), null, flags).setNeedsSlot(true);
660     }
661 
662     private void initFunctionWideVariables(final FunctionNode functionNode, final Block body) {
663         initCompileConstant(CALLEE, body, IS_PARAM | IS_INTERNAL | HAS_OBJECT_VALUE);
664         initCompileConstant(THIS, body, IS_PARAM | IS_THIS | HAS_OBJECT_VALUE);
665 
666         if (functionNode.isVarArg()) {
667             initCompileConstant(VARARGS, body, IS_PARAM | IS_INTERNAL | HAS_OBJECT_VALUE);
668             if (functionNode.needsArguments()) {
669                 initCompileConstant(ARGUMENTS, body, IS_VAR | IS_INTERNAL | HAS_OBJECT_VALUE);
670                 defineSymbol(body, ARGUMENTS_VAR.symbolName(), null, IS_VAR | HAS_OBJECT_VALUE);
671             }
672         }
673 
674         initParameters(functionNode, body);
675         initCompileConstant(SCOPE, body, IS_VAR | IS_INTERNAL | HAS_OBJECT_VALUE);
676         initCompileConstant(RETURN, body, IS_VAR | IS_INTERNAL);
677     }
678 
679     /**
680      * Initialize parameters for function node.
681      * @param functionNode the function node
682      */
683     private void initParameters(final FunctionNode functionNode, final Block body) {
684         final boolean isVarArg = functionNode.isVarArg();
685         final boolean scopeParams = functionNode.allVarsInScope() || isVarArg;
686         for (final IdentNode param : functionNode.getParameters()) {
687             final Symbol symbol = defineSymbol(body, param.getName(), param, IS_PARAM);
688             if(scopeParams) {
689                 // NOTE: this &quot;set is scope&quot; is a poor substitute for clear expression of where the symbol is stored.
690                 // It will force creation of scopes where they would otherwise not necessarily be needed (functions
691                 // using arguments object and other variable arity functions). Tracked by JDK-8038942.
692                 symbol.setIsScope();
693                 assert symbol.hasSlot();
694                 if(isVarArg) {
695                     symbol.setNeedsSlot(false);
696                 }
697             }
698         }
699     }
700 
701     /**
702      * Is the symbol local to (that is, defined in) the specified function?
703      * @param function the function
704      * @param symbol the symbol
705      * @return true if the symbol is defined in the specified function
706      */
707     private boolean isLocal(final FunctionNode function, final Symbol symbol) {
708         final FunctionNode definingFn = lc.getDefiningFunction(symbol);
709         assert definingFn != null;
710         return definingFn == function;
711     }
712 
713     @Override
714     public Node leaveBinaryNode(final BinaryNode binaryNode) {
715         if (binaryNode.isTokenType(TokenType.ASSIGN)) {
716             return leaveASSIGN(binaryNode);
717         }
718         return super.leaveBinaryNode(binaryNode);
719     }
720 
721     private Node leaveASSIGN(final BinaryNode binaryNode) {
722         // If we&#39;re assigning a property of the this object (&quot;this.foo = ...&quot;), record it.
723         final Expression lhs = binaryNode.lhs();
724         if (lhs instanceof AccessNode) {
725             final AccessNode accessNode = (AccessNode) lhs;
726             final Expression base = accessNode.getBase();
727             if (base instanceof IdentNode) {
728                 final Symbol symbol = ((IdentNode)base).getSymbol();
729                 if(symbol.isThis()) {
730                     thisProperties.peek().add(accessNode.getProperty());
731                 }
732             }
733         }
734         return binaryNode;
735     }
736 
737     @Override
738     public Node leaveUnaryNode(final UnaryNode unaryNode) {
739         if (unaryNode.tokenType() == TokenType.TYPEOF) {
740             return leaveTYPEOF(unaryNode);
741         } else {
742             return super.leaveUnaryNode(unaryNode);
743         }
744     }
745 
746     @Override
747     public Node leaveForNode(final ForNode forNode) {
748         if (forNode.isForInOrOf()) {
749             return forNode.setIterator(lc, newObjectInternal(ITERATOR_PREFIX)); //NASHORN-73
750         }
751 
752         return end(forNode);
753     }
754 
755     @Override
756     public Node leaveFunctionNode(final FunctionNode functionNode) {
757         final FunctionNode finalizedFunction;
758         if (isUnparsedFunction(functionNode)) {
759             finalizedFunction = functionNode;
760         } else {
761             finalizedFunction =
762                markProgramBlock(
763                removeUnusedSlots(
764                createSyntheticInitializers(
765                finalizeParameters(
766                        lc.applyTopFlags(functionNode))))
767                        .setThisProperties(lc, thisProperties.pop().size()));
768         }
769         return finalizedFunction;
770     }
771 
772     @Override
773     public Node leaveIdentNode(final IdentNode identNode) {
774         if (identNode.isPropertyName()) {
775             return identNode;
776         }
777 
778         final Symbol symbol = nameIsUsed(identNode.getName(), identNode);
779 
780         if (!identNode.isInitializedHere()) {
781             symbol.increaseUseCount();
782         }
783 
784         IdentNode newIdentNode = identNode.setSymbol(symbol);
785 
786         // If a block-scoped var is used before its declaration mark it as dead.
787         // We can only statically detect this for local vars, cross-function symbols require runtime checks.
788         if (symbol.isBlockScoped() &amp;&amp; !symbol.hasBeenDeclared() &amp;&amp; !identNode.isDeclaredHere() &amp;&amp; isLocal(lc.getCurrentFunction(), symbol)) {
789             newIdentNode = newIdentNode.markDead();
790         }
791 
792         return end(newIdentNode);
793     }
794 
795     private Symbol nameIsUsed(final String name, final IdentNode origin) {
796         final Block block = lc.getCurrentBlock();
797 
798         Symbol symbol = findSymbol(block, name);
799 
800         //If an existing symbol with the name is found, use that otherwise, declare a new one
801         if (symbol != null) {
802             log.info(&quot;Existing symbol = &quot;, symbol);
803             if (symbol.isFunctionSelf()) {
804                 final FunctionNode functionNode = lc.getDefiningFunction(symbol);
805                 assert functionNode != null;
806                 assert lc.getFunctionBody(functionNode).getExistingSymbol(CALLEE.symbolName()) != null;
807                 lc.setFlag(functionNode, FunctionNode.USES_SELF_SYMBOL);
808             }
809 
810             // if symbol is non-local or we&#39;re in a with block, we need to put symbol in scope (if it isn&#39;t already)
811             maybeForceScope(symbol);
812         } else {
813             log.info(&quot;No symbol exists. Declare as global: &quot;, name);
814             symbol = defineSymbol(block, name, origin, IS_GLOBAL | IS_SCOPE);
815         }
816 
817         functionUsesSymbol(symbol);
818         return symbol;
819     }
820 
821     @Override
822     public Node leaveSwitchNode(final SwitchNode switchNode) {
823         // We only need a symbol for the tag if it&#39;s not an integer switch node
824         if(!switchNode.isUniqueInteger()) {
825             return switchNode.setTag(lc, newObjectInternal(SWITCH_TAG_PREFIX));
826         }
827         return switchNode;
828     }
829 
830     @Override
831     public Node leaveTryNode(final TryNode tryNode) {
832         assert tryNode.getFinallyBody() == null;
833 
834         end(tryNode);
835 
836         return tryNode.setException(lc, exceptionSymbol());
837     }
838 
839     private Node leaveTYPEOF(final UnaryNode unaryNode) {
840         final Expression rhs = unaryNode.getExpression();
841 
842         final List&lt;Expression&gt; args = new ArrayList&lt;&gt;();
843         if (rhs instanceof IdentNode &amp;&amp; !isParamOrVar((IdentNode)rhs)) {
844             args.add(compilerConstantIdentifier(SCOPE));
845             args.add(LiteralNode.newInstance(rhs, ((IdentNode)rhs).getName())); //null
846         } else {
847             args.add(rhs);
848             args.add(LiteralNode.newInstance(unaryNode)); //null, do not reuse token of identifier rhs, it can be e.g. &#39;this&#39;
849         }
850 
851         final Node runtimeNode = new RuntimeNode(unaryNode, Request.TYPEOF, args);
852 
853         end(unaryNode);
854 
855         return runtimeNode;
856     }
857 
858     private FunctionNode markProgramBlock(final FunctionNode functionNode) {
859         if (isOnDemand || !functionNode.isProgram()) {
860             return functionNode;
861         }
862 
863         return functionNode.setBody(lc, functionNode.getBody().setFlag(lc, Block.IS_GLOBAL_SCOPE));
864     }
865 
866     /**
867      * If the symbol isn&#39;t already a scope symbol, but it needs to be (see {@link #symbolNeedsToBeScope(Symbol)}, it is
868      * promoted to a scope symbol and its block marked as needing a scope.
869      * @param symbol the symbol that might be scoped
870      */
871     private void maybeForceScope(final Symbol symbol) {
872         if (!symbol.isScope() &amp;&amp; symbolNeedsToBeScope(symbol)) {
873             Symbol.setSymbolIsScope(lc, symbol);
874         }
875     }
876 
877     private Symbol newInternal(final CompilerConstants cc, final int flags) {
878         return defineSymbol(lc.getCurrentBlock(), lc.getCurrentFunction().uniqueName(cc.symbolName()), null, IS_VAR | IS_INTERNAL | flags); //NASHORN-73
879     }
880 
881     private Symbol newObjectInternal(final CompilerConstants cc) {
882         return newInternal(cc, HAS_OBJECT_VALUE);
883     }
884 
885     private boolean start(final Node node) {
886         return start(node, true);
887     }
888 
889     private boolean start(final Node node, final boolean printNode) {
890         if (debug) {
891             final StringBuilder sb = new StringBuilder();
892 
893             sb.append(&quot;[ENTER &quot;).
894                 append(name(node)).
895                 append(&quot;] &quot;).
896                 append(printNode ? node.toString() : &quot;&quot;).
897                 append(&quot; in &#39;&quot;).
898                 append(lc.getCurrentFunction().getName()).
899                 append(&quot;&#39;&quot;);
900             log.info(sb);
901             log.indent();
902         }
903 
904         return true;
905     }
906 
907     /**
908      * Determines if the symbol has to be a scope symbol. In general terms, it has to be a scope symbol if it can only
909      * be reached from the current block by traversing a function node, a split node, or a with node.
910      * @param symbol the symbol checked for needing to be a scope symbol
911      * @return true if the symbol has to be a scope symbol.
912      */
913     private boolean symbolNeedsToBeScope(final Symbol symbol) {
914         if (symbol.isThis() || symbol.isInternal()) {
915             return false;
916         }
917 
918         final FunctionNode func = lc.getCurrentFunction();
919         if ( func.allVarsInScope() || (!symbol.isBlockScoped() &amp;&amp; func.isProgram())) {
920             return true;
921         }
922 
923         boolean previousWasBlock = false;
924         for (final Iterator&lt;LexicalContextNode&gt; it = lc.getAllNodes(); it.hasNext();) {
925             final LexicalContextNode node = it.next();
926             if (node instanceof FunctionNode || isSplitLiteral(node)) {
927                 // We reached the function boundary or a splitting boundary without seeing a definition for the symbol.
928                 // It needs to be in scope.
929                 return true;
930             } else if (node instanceof WithNode) {
931                 if (previousWasBlock) {
932                     // We reached a WithNode; the symbol must be scoped. Note that if the WithNode was not immediately
933                     // preceded by a block, this means we&#39;re currently processing its expression, not its body,
934                     // therefore it doesn&#39;t count.
935                     return true;
936                 }
937                 previousWasBlock = false;
938             } else if (node instanceof Block) {
939                 if (((Block)node).getExistingSymbol(symbol.getName()) == symbol) {
940                     // We reached the block that defines the symbol without reaching either the function boundary, or a
941                     // WithNode. The symbol need not be scoped.
942                     return false;
943                 }
944                 previousWasBlock = true;
945             } else {
946                 previousWasBlock = false;
947             }
948         }
949         throw new AssertionError();
950     }
951 
952     private static boolean isSplitLiteral(final LexicalContextNode expr) {
953         return expr instanceof Splittable &amp;&amp; ((Splittable) expr).getSplitRanges() != null;
954     }
955 
956     private void throwUnprotectedSwitchError(final VarNode varNode) {
957         // Block scoped declarations in switch statements without explicit blocks should be declared
958         // in a common block that contains all the case clauses. We cannot support this without a
959         // fundamental rewrite of how switch statements are handled (case nodes contain blocks and are
960         // directly contained by switch node). As a temporary solution we throw a reference error here.
961         final String msg = ECMAErrors.getMessage(&quot;syntax.error.unprotected.switch.declaration&quot;, varNode.isLet() ? &quot;let&quot; : &quot;const&quot;);
962         throwParserException(msg, varNode);
963     }
964 
965     private void throwParserException(final String message, final Node origin) {
966         if (origin == null) {
967             throw new ParserException(message);
968         }
969         final Source source = compiler.getSource();
970         final long token = origin.getToken();
971         final int line = source.getLine(origin.getStart());
972         final int column = source.getColumn(origin.getStart());
973         final String formatted = ErrorManager.format(message, source, line, column, token);
974         throw new ParserException(JSErrorType.SYNTAX_ERROR, formatted, source, line, column, token);
975     }
976 }
    </pre>
  </body>
</html>
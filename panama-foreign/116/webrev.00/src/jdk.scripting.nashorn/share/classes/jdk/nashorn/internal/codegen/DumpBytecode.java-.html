<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/codegen/DumpBytecode.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.codegen;
 27 
 28 import java.io.File;
 29 import java.io.FileOutputStream;
 30 import java.io.IOException;
 31 import java.io.PrintWriter;
 32 import jdk.nashorn.internal.runtime.ECMAErrors;
 33 import jdk.nashorn.internal.runtime.ScriptEnvironment;
 34 import jdk.nashorn.internal.runtime.logging.DebugLogger;
 35 
 36 /**
 37  * Class that facilitates printing bytecode and dumping it to disk.
 38  */
 39 public final class DumpBytecode {
 40     /**
 41      * Dump bytecode to console and potentially disk.
 42      * @param env the script environment defining options for printing bytecode
 43      * @param logger a logger used to write diagnostics about bytecode dumping
 44      * @param bytecode the actual code to dump
 45      * @param className the name of the class being dumped
 46      */
 47     public static void dumpBytecode(final ScriptEnvironment env, final DebugLogger logger, final byte[] bytecode, final String className) {
 48         File dir = null;
 49         try {
 50             // should could be printed to stderr for generate class?
 51             if (env._print_code) {
 52 
 53                 final StringBuilder sb = new StringBuilder();
 54                 sb.append(&quot;class: &quot;).append(className).
 55                     append(&#39;\n&#39;).
 56                     append(ClassEmitter.disassemble(bytecode)).
 57                     append(&quot;=====&quot;);
 58 
 59                 if (env._print_code_dir != null) {
 60 
 61                     String name = className;
 62                     final int dollar = name.lastIndexOf(&#39;$&#39;);
 63                     if (dollar != -1) {
 64                         name = name.substring(dollar + 1);
 65                     }
 66 
 67                     dir = new File(env._print_code_dir);
 68                     if (!dir.exists() &amp;&amp; !dir.mkdirs()) {
 69                         throw new IOException(dir.toString());
 70                     }
 71 
 72                     File file;
 73                     String fileName;
 74                     int uniqueId = 0;
 75                     do {
 76                         fileName = name + (uniqueId == 0 ? &quot;&quot; : &quot;_&quot; + uniqueId) + &quot;.bytecode&quot;;
 77                         file = new File(env._print_code_dir, fileName);
 78                         uniqueId++;
 79                     } while (file.exists());
 80 
 81                     try (final PrintWriter pw = new PrintWriter(new FileOutputStream(file))) {
 82                         pw.print(sb.toString());
 83                         pw.flush();
 84                     }
 85                 } else {
 86                     env.getErr().println(sb);
 87                 }
 88             }
 89 
 90 
 91             // should code be dumped to disk
 92             if (env._dest_dir != null) {
 93                 final String fileName = className.replace(&#39;.&#39;, File.separatorChar) + &quot;.class&quot;;
 94                 final int    index    = fileName.lastIndexOf(File.separatorChar);
 95 
 96                 if (index != -1) {
 97                     dir = new File(env._dest_dir, fileName.substring(0, index));
 98                 } else {
 99                     dir = new File(env._dest_dir);
100                 }
101 
102                 if (!dir.exists() &amp;&amp; !dir.mkdirs()) {
103                     throw new IOException(dir.toString());
104                 }
105                 final File file = new File(env._dest_dir, fileName);
106                 try (final FileOutputStream fos = new FileOutputStream(file)) {
107                     fos.write(bytecode);
108                 }
109                 logger.info(&quot;Wrote class to &#39;&quot; + file.getAbsolutePath() + &#39;\&#39;&#39;);
110             }
111         } catch (final IOException e) {
112             logger.warning(&quot;Skipping class dump for &quot;,
113                     className,
114                     &quot;: &quot;,
115                     ECMAErrors.getMessage(
116                         &quot;io.error.cant.write&quot;,
117                         dir.toString()));
118         }
119     }
120 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/StructureLoader.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.runtime;
 27 
 28 import static jdk.nashorn.internal.codegen.Compiler.SCRIPTS_PACKAGE;
 29 import static jdk.nashorn.internal.codegen.Compiler.binaryName;
 30 import static jdk.nashorn.internal.codegen.CompilerConstants.JS_OBJECT_DUAL_FIELD_PREFIX;
 31 import static jdk.nashorn.internal.codegen.CompilerConstants.JS_OBJECT_SINGLE_FIELD_PREFIX;
 32 
 33 import java.lang.module.ModuleDescriptor;
 34 import java.lang.module.ModuleDescriptor.Modifier;
 35 import java.security.ProtectionDomain;
 36 import java.util.Set;
 37 import jdk.nashorn.internal.codegen.ObjectClassGenerator;
 38 
 39 /**
 40  * Responsible for on the fly construction of structure classes.
 41  */
 42 final class StructureLoader extends NashornLoader {
 43     private static final String SINGLE_FIELD_PREFIX = binaryName(SCRIPTS_PACKAGE) + &#39;.&#39; + JS_OBJECT_SINGLE_FIELD_PREFIX.symbolName();
 44     private static final String DUAL_FIELD_PREFIX   = binaryName(SCRIPTS_PACKAGE) + &#39;.&#39; + JS_OBJECT_DUAL_FIELD_PREFIX.symbolName();
 45 
 46     private final Module structuresModule;
 47 
 48     /**
 49      * Constructor.
 50      */
 51     StructureLoader(final ClassLoader parent) {
 52         super(parent);
 53 
 54         // new structures module, it&#39;s exports, read edges
 55         structuresModule = createModule(&quot;jdk.scripting.nashorn.structures&quot;);
 56 
 57         // specific exports from nashorn to the structures module
 58         NASHORN_MODULE.addExports(SCRIPTS_PKG, structuresModule);
 59         NASHORN_MODULE.addExports(RUNTIME_PKG, structuresModule);
 60 
 61         // nashorn has to read fields from classes of the new module
 62         NASHORN_MODULE.addReads(structuresModule);
 63     }
 64 
 65     private Module createModule(final String moduleName) {
 66         final ModuleDescriptor descriptor =
 67             ModuleDescriptor.newModule(moduleName, Set.of(Modifier.SYNTHETIC))
 68                             .requires(NASHORN_MODULE.getName())
 69                             .packages(Set.of(SCRIPTS_PKG))
 70                             .build();
 71 
 72         final Module mod = Context.createModuleTrusted(descriptor, this);
 73         loadModuleManipulator();
 74         return mod;
 75     }
 76 
 77     /**
 78      * Returns true if the class name represents a structure object with dual primitive/object fields.
 79      * @param name a class name
 80      * @return true if a dual field structure class
 81      */
 82     private static boolean isDualFieldStructure(final String name) {
 83         return name.startsWith(DUAL_FIELD_PREFIX);
 84     }
 85 
 86     /**
 87      * Returns true if the class name represents a structure object with single object-only fields.
 88      * @param name a class name
 89      * @return true if a single field structure class
 90      */
 91     static boolean isSingleFieldStructure(final String name) {
 92         return name.startsWith(SINGLE_FIELD_PREFIX);
 93     }
 94 
 95     /**
 96      * Returns true if the class name represents a Nashorn structure object.
 97      * @param name a class name
 98      * @return true if a structure class
 99      */
100     static boolean isStructureClass(final String name) {
101         return isDualFieldStructure(name) || isSingleFieldStructure(name);
102     }
103 
104     Module getModule() {
105         return structuresModule;
106     }
107 
108     @Override
109     protected Class&lt;?&gt; findClass(final String name) throws ClassNotFoundException {
110         if (isDualFieldStructure(name)) {
111             return generateClass(name, name.substring(DUAL_FIELD_PREFIX.length()), true);
112         } else if (isSingleFieldStructure(name)) {
113             return generateClass(name, name.substring(SINGLE_FIELD_PREFIX.length()), false);
114         }
115         return super.findClass(name);
116     }
117 
118     /**
119      * Generate a layout class.
120      * @param name       Name of class.
121      * @param descriptor Layout descriptor.
122      * @return Generated class.
123      */
124     private Class&lt;?&gt; generateClass(final String name, final String descriptor, final boolean dualFields) {
125         final Context context = Context.getContextTrusted();
126 
127         final byte[] code = new ObjectClassGenerator(context, dualFields).generate(descriptor);
128         return defineClass(name, code, 0, code.length, new ProtectionDomain(null, getPermissions(null)));
129     }
130 }
    </pre>
  </body>
</html>
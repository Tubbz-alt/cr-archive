<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/objects/NativeArrayBuffer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.objects;
 27 
 28 import static jdk.nashorn.internal.runtime.ECMAErrors.typeError;
 29 
 30 import java.nio.ByteBuffer;
 31 
 32 import jdk.nashorn.internal.objects.annotations.Attribute;
 33 import jdk.nashorn.internal.objects.annotations.Constructor;
 34 import jdk.nashorn.internal.objects.annotations.Function;
 35 import jdk.nashorn.internal.objects.annotations.Getter;
 36 import jdk.nashorn.internal.objects.annotations.ScriptClass;
 37 import jdk.nashorn.internal.objects.annotations.SpecializedFunction;
 38 import jdk.nashorn.internal.objects.annotations.Where;
 39 import jdk.nashorn.internal.runtime.JSType;
 40 import jdk.nashorn.internal.runtime.PropertyMap;
 41 import jdk.nashorn.internal.runtime.ScriptObject;
 42 import jdk.nashorn.internal.runtime.ScriptRuntime;
 43 
 44 /**
 45  * NativeArrayBuffer - ArrayBuffer as described in the JS typed
 46  * array spec
 47  */
 48 @ScriptClass(&quot;ArrayBuffer&quot;)
 49 public final class NativeArrayBuffer extends ScriptObject {
 50     private final ByteBuffer nb;
 51 
 52     // initialized by nasgen
 53     private static PropertyMap $nasgenmap$;
 54 
 55     /**
 56      * Constructor
 57      * @param nb native byte buffer to wrap
 58      * @param global global instance
 59      */
 60     protected NativeArrayBuffer(final ByteBuffer nb, final Global global) {
 61         super(global.getArrayBufferPrototype(), $nasgenmap$);
 62         this.nb = nb;
 63     }
 64 
 65     /**
 66      * Constructor
 67      * @param nb native byte buffer to wrap
 68      */
 69     protected NativeArrayBuffer(final ByteBuffer nb) {
 70         this(nb, Global.instance());
 71     }
 72 
 73     /**
 74      * Constructor
 75      * @param byteLength byteLength for buffer
 76      */
 77     protected NativeArrayBuffer(final int byteLength) {
 78         this(ByteBuffer.allocateDirect(byteLength));
 79     }
 80 
 81     /**
 82      * Clone constructor
 83      * Used only for slice
 84      * @param other original buffer
 85      * @param begin begin byte index
 86      * @param end   end byte index
 87      */
 88     protected NativeArrayBuffer(final NativeArrayBuffer other, final int begin, final int end) {
 89         this(cloneBuffer(other.getNioBuffer(), begin, end));
 90     }
 91 
 92     /**
 93      * Constructor
 94      * @param newObj is this invoked with new
 95      * @param self   self reference
 96      * @param args   arguments to constructor
 97      * @return new NativeArrayBuffer
 98      */
 99     @Constructor(arity = 1)
100     public static NativeArrayBuffer constructor(final boolean newObj, final Object self, final Object... args) {
101         if (!newObj) {
102             throw typeError(&quot;constructor.requires.new&quot;, &quot;ArrayBuffer&quot;);
103         }
104 
105         if (args.length == 0) {
106             return new NativeArrayBuffer(0);
107         }
108 
109         final Object arg0 = args[0];
110         if (arg0 instanceof ByteBuffer) {
111             return new NativeArrayBuffer((ByteBuffer)arg0);
112         } else {
113             return new NativeArrayBuffer(JSType.toInt32(arg0));
114         }
115     }
116 
117     private static ByteBuffer cloneBuffer(final ByteBuffer original, final int begin, final int end) {
118         final ByteBuffer clone = ByteBuffer.allocateDirect(original.capacity());
119         original.rewind();//copy from the beginning
120         clone.put(original);
121         original.rewind();
122         clone.flip();
123         clone.position(begin);
124         clone.limit(end);
125         return clone.slice();
126     }
127 
128     ByteBuffer getNioBuffer() {
129         return nb;
130     }
131 
132     @Override
133     public String getClassName() {
134         return &quot;ArrayBuffer&quot;;
135     }
136 
137     /**
138      * Byte length for native array buffer
139      * @param self native array buffer
140      * @return byte length
141      */
142     @Getter(attributes = Attribute.NOT_ENUMERABLE | Attribute.NOT_WRITABLE | Attribute.NOT_CONFIGURABLE)
143     public static int byteLength(final Object self) {
144         return ((NativeArrayBuffer)self).getByteLength();
145     }
146 
147     /**
148      * Returns true if an object is an ArrayBufferView
149      *
150      * @param self self
151      * @param obj  object to check
152      *
153      * @return true if obj is an ArrayBufferView
154      */
155     @Function(attributes = Attribute.NOT_ENUMERABLE, where = Where.CONSTRUCTOR)
156     public static boolean isView(final Object self, final Object obj) {
157         return obj instanceof ArrayBufferView;
158     }
159 
160     /**
161      * Slice function
162      * @param self   native array buffer
163      * @param begin0 start byte index
164      * @param end0   end byte index
165      * @return new array buffer, sliced
166      */
167     @Function(attributes = Attribute.NOT_ENUMERABLE)
168     public static NativeArrayBuffer slice(final Object self, final Object begin0, final Object end0) {
169         final NativeArrayBuffer arrayBuffer = (NativeArrayBuffer)self;
170         final int               byteLength  = arrayBuffer.getByteLength();
171         final int               begin       = adjustIndex(JSType.toInt32(begin0), byteLength);
172         final int               end         = adjustIndex(end0 != ScriptRuntime.UNDEFINED ? JSType.toInt32(end0) : byteLength, byteLength);
173         return new NativeArrayBuffer(arrayBuffer, begin, Math.max(end, begin));
174     }
175 
176     /**
177      * Specialized slice function
178      * @param self   native array buffer
179      * @param begin  start byte index
180      * @param end    end byte index
181      * @return new array buffer, sliced
182      */
183     @SpecializedFunction
184     public static Object slice(final Object self, final int begin, final int end) {
185         final NativeArrayBuffer arrayBuffer = (NativeArrayBuffer)self;
186         final int byteLength  = arrayBuffer.getByteLength();
187         return new NativeArrayBuffer(arrayBuffer, adjustIndex(begin, byteLength), Math.max(adjustIndex(end, byteLength), begin));
188     }
189 
190     /**
191      * Specialized slice function
192      * @param self   native array buffer
193      * @param begin  start byte index
194      * @return new array buffer, sliced
195      */
196     @SpecializedFunction
197     public static Object slice(final Object self, final int begin) {
198         return slice(self, begin, ((NativeArrayBuffer)self).getByteLength());
199     }
200 
201     /**
202      * If index is negative, it refers to an index from the end of the array, as
203      * opposed to from the beginning. The index is clamped to the valid index
204      * range for the array.
205      *
206      * @param index  The index.
207      * @param length The length of the array.
208      * @return valid index index in the range [0, length).
209      */
210     static int adjustIndex(final int index, final int length) {
211         return index &lt; 0 ? clamp(index + length, length) : clamp(index, length);
212     }
213 
214     /**
215      * Clamp index into the range [0, length).
216      */
217     private static int clamp(final int index, final int length) {
218         if (index &lt; 0) {
219             return 0;
220         } else if (index &gt; length) {
221             return length;
222         }
223         return index;
224     }
225 
226     int getByteLength() {
227         return nb.limit();
228     }
229 
230     ByteBuffer getBuffer() {
231        return nb;
232     }
233 
234     ByteBuffer getBuffer(final int offset) {
235         return nb.duplicate().position(offset);
236     }
237 
238     ByteBuffer getBuffer(final int offset, final int length) {
239         return getBuffer(offset).limit(length);
240     }
241 }
    </pre>
  </body>
</html>
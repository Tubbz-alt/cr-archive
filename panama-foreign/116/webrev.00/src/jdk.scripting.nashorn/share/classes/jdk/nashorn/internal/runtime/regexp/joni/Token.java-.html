<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/regexp/joni/Token.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Permission is hereby granted, free of charge, to any person obtaining a copy of
  3  * this software and associated documentation files (the &quot;Software&quot;), to deal in
  4  * the Software without restriction, including without limitation the rights to
  5  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
  6  * of the Software, and to permit persons to whom the Software is furnished to do
  7  * so, subject to the following conditions:
  8  *
  9  * The above copyright notice and this permission notice shall be included in all
 10  * copies or substantial portions of the Software.
 11  *
 12  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 13  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 14  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 15  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 16  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 17  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 18  * SOFTWARE.
 19  */
 20 package jdk.nashorn.internal.runtime.regexp.joni;
 21 
 22 import jdk.nashorn.internal.runtime.regexp.joni.constants.TokenType;
 23 
 24 final class Token {
 25     TokenType type;
 26     boolean escaped;
 27     int backP;
 28 
 29     // union fields
 30     private int INT1, INT2, INT3, INT4;
 31 
 32     // union accessors
 33     int getC() {
 34         return INT1;
 35     }
 36     void setC(final int c) {
 37         INT1 = c;
 38     }
 39 
 40     int getCode() {
 41         return INT1;
 42     }
 43     void setCode(final int code) {
 44         INT1 = code;
 45     }
 46 
 47     int getAnchor() {
 48         return INT1;
 49     }
 50     void setAnchor(final int anchor) {
 51         INT1 = anchor;
 52     }
 53 
 54     // repeat union member
 55     int getRepeatLower() {
 56         return INT1;
 57     }
 58     void setRepeatLower(final int lower) {
 59         INT1 = lower;
 60     }
 61 
 62     int getRepeatUpper() {
 63         return INT2;
 64     }
 65     void setRepeatUpper(final int upper) {
 66         INT2 = upper;
 67     }
 68 
 69     boolean getRepeatGreedy() {
 70         return INT3 != 0;
 71     }
 72     void setRepeatGreedy(final boolean greedy) {
 73         INT3 = greedy ? 1 : 0;
 74     }
 75 
 76     boolean getRepeatPossessive() {
 77         return INT4 != 0;
 78     }
 79     void setRepeatPossessive(final boolean possessive) {
 80         INT4 = possessive ? 1 : 0;
 81     }
 82 
 83     int getBackrefRef() {
 84         return INT2;
 85     }
 86     void setBackrefRef(final int ref1) {
 87         INT2 = ref1;
 88     }
 89 
 90     // prop union member
 91     int getPropCType() {
 92         return INT1;
 93     }
 94     void setPropCType(final int ctype) {
 95         INT1 = ctype;
 96     }
 97 
 98     boolean getPropNot() {
 99         return INT2 != 0;
100     }
101     void setPropNot(final boolean not) {
102         INT2 = not ? 1 : 0;
103     }
104 }
    </pre>
  </body>
</html>
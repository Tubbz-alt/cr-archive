<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/UserAccessorProperty.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.runtime;
 27 import static jdk.nashorn.internal.lookup.Lookup.MH;
 28 import static jdk.nashorn.internal.runtime.ECMAErrors.typeError;
 29 import static jdk.nashorn.internal.runtime.ScriptRuntime.UNDEFINED;
 30 import static jdk.nashorn.internal.runtime.UnwarrantedOptimismException.INVALID_PROGRAM_POINT;
 31 import static jdk.nashorn.internal.runtime.linker.NashornCallSiteDescriptor.CALLSITE_PROGRAM_POINT_SHIFT;
 32 
 33 import java.lang.invoke.MethodHandle;
 34 import java.lang.invoke.MethodHandles;
 35 import java.lang.invoke.MethodType;
 36 import java.util.concurrent.Callable;
 37 import jdk.nashorn.internal.lookup.Lookup;
 38 import jdk.nashorn.internal.runtime.linker.Bootstrap;
 39 import jdk.nashorn.internal.runtime.linker.NashornCallSiteDescriptor;
 40 
 41 /**
 42  * Property with user defined getters/setters. Actual getter and setter
 43  * functions are stored in underlying ScriptObject. Only the &#39;slot&#39; info is
 44  * stored in the property.
 45  */
 46 public final class UserAccessorProperty extends SpillProperty {
 47 
 48     private static final long serialVersionUID = -5928687246526840321L;
 49 
 50     static final class Accessors {
 51         Object getter;
 52         Object setter;
 53 
 54         Accessors(final Object getter, final Object setter) {
 55             set(getter, setter);
 56         }
 57 
 58         final void set(final Object getter, final Object setter) {
 59             this.getter = getter;
 60             this.setter = setter;
 61         }
 62 
 63         @Override
 64         public String toString() {
 65             return &quot;[getter=&quot; + getter + &quot; setter=&quot; + setter + &#39;]&#39;;
 66         }
 67     }
 68 
 69     private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
 70 
 71     /** Getter method handle */
 72     private final static MethodHandle INVOKE_OBJECT_GETTER = findOwnMH_S(&quot;invokeObjectGetter&quot;, Object.class, Accessors.class, MethodHandle.class, Object.class);
 73     private final static MethodHandle INVOKE_INT_GETTER  = findOwnMH_S(&quot;invokeIntGetter&quot;, int.class, Accessors.class, MethodHandle.class, int.class, Object.class);
 74     private final static MethodHandle INVOKE_NUMBER_GETTER  = findOwnMH_S(&quot;invokeNumberGetter&quot;, double.class, Accessors.class, MethodHandle.class, int.class, Object.class);
 75 
 76     /** Setter method handle */
 77     private final static MethodHandle INVOKE_OBJECT_SETTER = findOwnMH_S(&quot;invokeObjectSetter&quot;, void.class, Accessors.class, MethodHandle.class, String.class, Object.class, Object.class);
 78     private final static MethodHandle INVOKE_INT_SETTER = findOwnMH_S(&quot;invokeIntSetter&quot;, void.class, Accessors.class, MethodHandle.class, String.class, Object.class, int.class);
 79     private final static MethodHandle INVOKE_NUMBER_SETTER = findOwnMH_S(&quot;invokeNumberSetter&quot;, void.class, Accessors.class, MethodHandle.class, String.class, Object.class, double.class);
 80 
 81     private static final Object OBJECT_GETTER_INVOKER_KEY = new Object();
 82     private static MethodHandle getObjectGetterInvoker() {
 83         return Context.getGlobal().getDynamicInvoker(OBJECT_GETTER_INVOKER_KEY, new Callable&lt;MethodHandle&gt;() {
 84             @Override
 85             public MethodHandle call() throws Exception {
 86                 return getINVOKE_UA_GETTER(Object.class, INVALID_PROGRAM_POINT);
 87             }
 88         });
 89     }
 90 
 91     static MethodHandle getINVOKE_UA_GETTER(final Class&lt;?&gt; returnType, final int programPoint) {
 92         if (UnwarrantedOptimismException.isValid(programPoint)) {
 93             final int flags = NashornCallSiteDescriptor.CALL | NashornCallSiteDescriptor.CALLSITE_OPTIMISTIC | programPoint &lt;&lt; CALLSITE_PROGRAM_POINT_SHIFT;
 94             return Bootstrap.createDynamicInvoker(&quot;&quot;, flags, returnType, Object.class, Object.class);
 95         } else {
 96             return Bootstrap.createDynamicCallInvoker(Object.class, Object.class, Object.class);
 97         }
 98     }
 99 
100     private static final Object OBJECT_SETTER_INVOKER_KEY = new Object();
101     private static MethodHandle getObjectSetterInvoker() {
102         return Context.getGlobal().getDynamicInvoker(OBJECT_SETTER_INVOKER_KEY, new Callable&lt;MethodHandle&gt;() {
103             @Override
104             public MethodHandle call() throws Exception {
105                 return getINVOKE_UA_SETTER(Object.class);
106             }
107         });
108     }
109 
110     static MethodHandle getINVOKE_UA_SETTER(final Class&lt;?&gt; valueType) {
111         return Bootstrap.createDynamicCallInvoker(void.class, Object.class, Object.class, valueType);
112     }
113 
114     /**
115      * Constructor
116      *
117      * @param key   property key
118      * @param flags property flags
119      * @param slot  spill slot
120      */
121     UserAccessorProperty(final Object key, final int flags, final int slot) {
122         // Always set accessor property flag for this class
123         super(key, flags | IS_ACCESSOR_PROPERTY, slot);
124     }
125 
126     private UserAccessorProperty(final UserAccessorProperty property) {
127         super(property);
128     }
129 
130     private UserAccessorProperty(final UserAccessorProperty property, final Class&lt;?&gt; newType) {
131         super(property, newType);
132     }
133 
134     @Override
135     public Property copy() {
136         return new UserAccessorProperty(this);
137     }
138 
139     @Override
140     public Property copy(final Class&lt;?&gt; newType) {
141         return new UserAccessorProperty(this, newType);
142     }
143 
144     void setAccessors(final ScriptObject sobj, final PropertyMap map, final Accessors gs) {
145         try {
146             //invoke the getter and find out
147             super.getSetter(Object.class, map).invokeExact((Object)sobj, (Object)gs);
148         } catch (final Error | RuntimeException t) {
149             throw t;
150         } catch (final Throwable t) {
151             throw new RuntimeException(t);
152         }
153     }
154 
155     //pick the getter setter out of the correct spill slot in sobj
156     Accessors getAccessors(final ScriptObject sobj) {
157         try {
158             //invoke the super getter with this spill slot
159             //get the getter setter from the correct spill slot
160             final Object gs = super.getGetter(Object.class).invokeExact((Object)sobj);
161             return (Accessors)gs;
162         } catch (final Error | RuntimeException t) {
163             throw t;
164         } catch (final Throwable t) {
165             throw new RuntimeException(t);
166         }
167     }
168 
169     @Override
170     protected Class&lt;?&gt; getLocalType() {
171         return Object.class;
172     }
173 
174     @Override
175     public boolean hasGetterFunction(final ScriptObject sobj) {
176         return getAccessors(sobj).getter != null;
177     }
178 
179     @Override
180     public boolean hasSetterFunction(final ScriptObject sobj) {
181         return getAccessors(sobj).setter != null;
182     }
183 
184     @Override
185     public int getIntValue(final ScriptObject self, final ScriptObject owner) {
186         return (int)getObjectValue(self, owner);
187     }
188 
189     @Override
190     public double getDoubleValue(final ScriptObject self, final ScriptObject owner) {
191         return (double)getObjectValue(self, owner);
192     }
193 
194     @Override
195     public Object getObjectValue(final ScriptObject self, final ScriptObject owner) {
196         try {
197             return invokeObjectGetter(getAccessors((owner != null) ? owner : self), getObjectGetterInvoker(), self);
198         } catch (final Error | RuntimeException t) {
199             throw t;
200         } catch (final Throwable t) {
201             throw new RuntimeException(t);
202         }
203     }
204 
205     @Override
206     public void setValue(final ScriptObject self, final ScriptObject owner, final int value, final boolean strict) {
207         setValue(self, owner, (Object) value, strict);
208     }
209 
210     @Override
211     public void setValue(final ScriptObject self, final ScriptObject owner, final double value, final boolean strict) {
212         setValue(self, owner, (Object) value, strict);
213     }
214 
215     @Override
216     public void setValue(final ScriptObject self, final ScriptObject owner, final Object value, final boolean strict) {
217         try {
218             invokeObjectSetter(getAccessors((owner != null) ? owner : self), getObjectSetterInvoker(), strict ? getKey().toString() : null, self, value);
219         } catch (final Error | RuntimeException t) {
220             throw t;
221         } catch (final Throwable t) {
222             throw new RuntimeException(t);
223         }
224     }
225 
226     @Override
227     public MethodHandle getGetter(final Class&lt;?&gt; type) {
228         //this returns a getter on the format (Accessors, Object receiver)
229         return Lookup.filterReturnType(INVOKE_OBJECT_GETTER, type);
230     }
231 
232     @Override
233     public MethodHandle getOptimisticGetter(final Class&lt;?&gt; type, final int programPoint) {
234         if (type == int.class) {
235             return INVOKE_INT_GETTER;
236         } else if (type == double.class) {
237             return INVOKE_NUMBER_GETTER;
238         } else {
239             assert type == Object.class;
240             return INVOKE_OBJECT_GETTER;
241         }
242     }
243 
244     @Override
245     void initMethodHandles(final Class&lt;?&gt; structure) {
246         throw new UnsupportedOperationException();
247     }
248 
249     @Override
250     public ScriptFunction getGetterFunction(final ScriptObject sobj) {
251         final Object value = getAccessors(sobj).getter;
252         return (value instanceof ScriptFunction) ? (ScriptFunction)value : null;
253     }
254 
255     @Override
256     public MethodHandle getSetter(final Class&lt;?&gt; type, final PropertyMap currentMap) {
257         if (type == int.class) {
258             return INVOKE_INT_SETTER;
259         } else if (type == double.class) {
260             return INVOKE_NUMBER_SETTER;
261         } else {
262             assert type == Object.class;
263             return INVOKE_OBJECT_SETTER;
264         }
265     }
266 
267     @Override
268     public ScriptFunction getSetterFunction(final ScriptObject sobj) {
269         final Object value = getAccessors(sobj).setter;
270         return (value instanceof ScriptFunction) ? (ScriptFunction)value : null;
271     }
272 
273     /**
274      * Get the getter for the {@code Accessors} object.
275      * This is the the super {@code Object} type getter with {@code Accessors} return type.
276      *
277      * @return The getter handle for the Accessors
278      */
279     MethodHandle getAccessorsGetter() {
280         return super.getGetter(Object.class).asType(MethodType.methodType(Accessors.class, Object.class));
281     }
282 
283     // User defined getter and setter are always called by StandardOperation.CALL. Note that the user
284     // getter/setter may be inherited. If so, proto is bound during lookup. In either
285     // inherited or self case, slot is also bound during lookup. Actual ScriptFunction
286     // to be called is retrieved everytime and applied.
287     @SuppressWarnings(&quot;unused&quot;)
288     private static Object invokeObjectGetter(final Accessors gs, final MethodHandle invoker, final Object self) throws Throwable {
289         final Object func = gs.getter;
290         if (func instanceof ScriptFunction) {
291             return invoker.invokeExact(func, self);
292         }
293 
294         return UNDEFINED;
295     }
296 
297     @SuppressWarnings(&quot;unused&quot;)
298     private static int invokeIntGetter(final Accessors gs, final MethodHandle invoker, final int programPoint, final Object self) throws Throwable {
299         final Object func = gs.getter;
300         if (func instanceof ScriptFunction) {
301             return (int) invoker.invokeExact(func, self);
302         }
303 
304         throw new UnwarrantedOptimismException(UNDEFINED, programPoint);
305     }
306 
307     @SuppressWarnings(&quot;unused&quot;)
308     private static double invokeNumberGetter(final Accessors gs, final MethodHandle invoker, final int programPoint, final Object self) throws Throwable {
309         final Object func = gs.getter;
310         if (func instanceof ScriptFunction) {
311             return (double) invoker.invokeExact(func, self);
312         }
313 
314         throw new UnwarrantedOptimismException(UNDEFINED, programPoint);
315     }
316 
317     @SuppressWarnings(&quot;unused&quot;)
318     private static void invokeObjectSetter(final Accessors gs, final MethodHandle invoker, final String name, final Object self, final Object value) throws Throwable {
319         final Object func = gs.setter;
320         if (func instanceof ScriptFunction) {
321             invoker.invokeExact(func, self, value);
322         } else if (name != null) {
323             throw typeError(&quot;property.has.no.setter&quot;, name, ScriptRuntime.safeToString(self));
324         }
325     }
326 
327     @SuppressWarnings(&quot;unused&quot;)
328     private static void invokeIntSetter(final Accessors gs, final MethodHandle invoker, final String name, final Object self, final int value) throws Throwable {
329         final Object func = gs.setter;
330         if (func instanceof ScriptFunction) {
331             invoker.invokeExact(func, self, value);
332         } else if (name != null) {
333             throw typeError(&quot;property.has.no.setter&quot;, name, ScriptRuntime.safeToString(self));
334         }
335     }
336 
337     @SuppressWarnings(&quot;unused&quot;)
338     private static void invokeNumberSetter(final Accessors gs, final MethodHandle invoker, final String name, final Object self, final double value) throws Throwable {
339         final Object func = gs.setter;
340         if (func instanceof ScriptFunction) {
341             invoker.invokeExact(func, self, value);
342         } else if (name != null) {
343             throw typeError(&quot;property.has.no.setter&quot;, name, ScriptRuntime.safeToString(self));
344         }
345     }
346 
347     private static MethodHandle findOwnMH_S(final String name, final Class&lt;?&gt; rtype, final Class&lt;?&gt;... types) {
348         return MH.findStatic(LOOKUP, UserAccessorProperty.class, name, MH.type(rtype, types));
349     }
350 
351 }
    </pre>
  </body>
</html>
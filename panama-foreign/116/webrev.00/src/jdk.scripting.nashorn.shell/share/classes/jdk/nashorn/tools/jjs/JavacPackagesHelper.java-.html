<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.scripting.nashorn.shell/share/classes/jdk/nashorn/tools/jjs/JavacPackagesHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.tools.jjs;
 27 
 28 import java.io.IOException;
 29 import java.io.File;
 30 import java.util.Collections;
 31 import java.util.EnumSet;
 32 import java.util.HashSet;
 33 import java.util.List;
 34 import java.util.Set;
 35 import java.util.stream.Collectors;
 36 import java.util.stream.Stream;
 37 import javax.tools.JavaCompiler;
 38 import javax.tools.JavaFileManager.Location;
 39 import javax.tools.JavaFileObject;
 40 import javax.tools.StandardJavaFileManager;
 41 import javax.tools.StandardLocation;
 42 import javax.tools.ToolProvider;
 43 import jdk.nashorn.internal.runtime.Context;
 44 
 45 /**
 46  * A javac package helper that uses javac to complete package names.
 47  */
 48 final class JavacPackagesHelper extends PackagesHelper {
 49     // JavaCompiler may be null on certain platforms (eg. JRE)
 50     private static final JavaCompiler compiler;
 51     static {
 52         // Use javac only if security manager is not around!
 53         compiler = System.getSecurityManager() == null? ToolProvider.getSystemJavaCompiler() : null;
 54     }
 55 
 56     /**
 57      * Is this class available?
 58      *
 59      * @return true if javac is available
 60      */
 61     static boolean isAvailable() {
 62         return compiler != null;
 63     }
 64 
 65     private final boolean modulePathSet;
 66     private final StandardJavaFileManager fm;
 67     private final Set&lt;JavaFileObject.Kind&gt; fileKinds;
 68 
 69     /**
 70      * Construct a new JavacPackagesHelper.
 71      *
 72      * @param context the current Nashorn Context
 73      */
 74     JavacPackagesHelper(final Context context) throws IOException {
 75         super(context);
 76         final String modulePath = context.getEnv()._module_path;
 77         this.modulePathSet = modulePath != null &amp;&amp; !modulePath.isEmpty();
 78         if (isAvailable()) {
 79             final String classPath = context.getEnv()._classpath;
 80             fm = compiler.getStandardFileManager(null, null, null);
 81             fileKinds = EnumSet.of(JavaFileObject.Kind.CLASS);
 82 
 83             if (this.modulePathSet) {
 84                 fm.setLocation(StandardLocation.MODULE_PATH, getFiles(modulePath));
 85             }
 86 
 87             if (classPath != null &amp;&amp; !classPath.isEmpty()) {
 88                 fm.setLocation(StandardLocation.CLASS_PATH, getFiles(classPath));
 89             } else {
 90                 // no classpath set. Make sure that it is empty and not any default like &quot;.&quot;
 91                 fm.setLocation(StandardLocation.CLASS_PATH, Collections.&lt;File&gt;emptyList());
 92             }
 93         } else {
 94             // javac is not available - caller should have checked!
 95             throw new IllegalStateException(&quot;JavacPackagesHelper is not available!&quot;);
 96         }
 97     }
 98 
 99 
100     @Override
101     void close() throws IOException {
102         if (fm != null) {
103             fm.close();
104         }
105     }
106 
107     @Override
108     Set&lt;String&gt; listPackage(final String pkg) throws IOException {
109         final Set&lt;String&gt; props = new HashSet&lt;&gt;();
110         listPackage(StandardLocation.PLATFORM_CLASS_PATH, pkg, props);
111         if (this.modulePathSet) {
112             for (Set&lt;Location&gt; locs : fm.listLocationsForModules(StandardLocation.MODULE_PATH)) {
113                 for (Location loc : locs) {
114                     listPackage(loc, pkg, props);
115                 }
116             }
117         }
118         listPackage(StandardLocation.CLASS_PATH, pkg, props);
119         return props;
120     }
121 
122     private void listPackage(final Location loc, final String pkg, final Set&lt;String&gt; props)
123             throws IOException {
124         for (JavaFileObject file : fm.list(loc, pkg, fileKinds, true)) {
125             final String binaryName = fm.inferBinaryName(loc, file);
126             // does not start with the given package prefix
127             if (!binaryName.startsWith(pkg + &quot;.&quot;)) {
128                 continue;
129             }
130 
131             final int nextDot = binaryName.indexOf(&#39;.&#39;, pkg.length() + 1);
132             final int start = pkg.length() + 1;
133 
134             if (nextDot != -1) {
135                 // subpackage - eg. &quot;regex&quot; for &quot;java.util&quot;
136                 final String pkgName = binaryName.substring(start, nextDot);
137                 if (isPackageAccessible(binaryName.substring(0, nextDot))) {
138                     props.add(binaryName.substring(start, nextDot));
139                 }
140             } else {
141                 // class - filter out nested, inner, anonymous, local classes.
142                 // Dynalink supported public nested classes as properties of
143                 // StaticClass object anyway. We don&#39;t want to expose those
144                 // &quot;$&quot; internal names as properties of package object.
145 
146                 final String clsName = binaryName.substring(start);
147                 if (clsName.indexOf(&#39;$&#39;) == -1 &amp;&amp; isClassAccessible(binaryName)) {
148                     props.add(clsName);
149                 }
150             }
151         }
152     }
153 
154     // return list of File objects for the given class path
155     private static List&lt;File&gt; getFiles(final String classPath) {
156         return Stream.of(classPath.split(File.pathSeparator))
157                     .map(File::new)
158                     .collect(Collectors.toList());
159     }
160 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.instrument/share/classes/java/lang/instrument/package-info.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * Copyright 2003 Wily Technology, Inc.
 28  */
 29 
 30 /**
 31  * Provides services that allow Java programming language agents to instrument
 32  * programs running on the JVM. The mechanism for instrumentation is modification
 33  * of the byte-codes of methods.
 34  *
 35  * &lt;p&gt; An agent is deployed as a JAR file. An attribute in the JAR file manifest
 36  * specifies the agent class which will be loaded to start the agent. Agents can
 37  * be started in several ways:
 38  *
 39  * &lt;ol&gt;
 40  *   &lt;li&gt;&lt;p&gt; For implementations that support a command-line interface, an agent
 41  *   can be started by specifying an option on the command-line. &lt;/p&gt;&lt;/li&gt;
 42  *
 43  *   &lt;li&gt;&lt;p&gt; An implementation may support a mechanism to start agents some time
 44  *   after the VM has started. For example, an implementation may provide a
 45  *   mechanism that allows a tool to &lt;i&gt;attach&lt;/i&gt; to a running application, and
 46  *   initiate the loading of the tool&#39;s agent into the running application. &lt;/p&gt;&lt;/li&gt;
 47  *
 48  *   &lt;li&gt;&lt;p&gt; An agent may be packaged with an application in an executable JAR
 49  *   file.&lt;/p&gt;&lt;/li&gt;
 50  * &lt;/ol&gt;
 51  *
 52  * &lt;p&gt; Each of these ways to start an agent is described below.
 53  *
 54  *
 55  * &lt;h2&gt;Starting an Agent from the Command-Line Interface&lt;/h2&gt;
 56  *
 57  * &lt;p&gt; Where an implementation provides a means to start agents from the
 58  * command-line interface, an agent is started by adding the following option
 59  * to the command-line:
 60  *
 61  * &lt;blockquote&gt;{@code
 62  *     -javaagent:&lt;jarpath&gt;[=&lt;options&gt;]
 63  * }&lt;/blockquote&gt;
 64  *
 65  * where &lt;i&gt;{@code &lt;jarpath&gt;}&lt;/i&gt; is the path to the agent JAR file and
 66  * &lt;i&gt;{@code &lt;options&gt;}&lt;/i&gt; is the agent options.
 67  *
 68  * &lt;p&gt; The manifest of the agent JAR file must contain the attribute {@code
 69  * Premain-Class} in its main manifest. The value of this attribute is the
 70  * name of the &lt;i&gt;agent class&lt;/i&gt;. The agent class must implement a public
 71  * static {@code premain} method similar in principle to the {@code main}
 72  * application entry point. After the Java Virtual Machine (JVM) has
 73  * initialized, the {@code premain} method will be called, then the real
 74  * application {@code main} method. The {@code premain} method must return
 75  * in order for the startup to proceed.
 76  *
 77  * &lt;p&gt; The {@code premain} method has one of two possible signatures. The
 78  * JVM first attempts to invoke the following method on the agent class:
 79  *
 80  * &lt;blockquote&gt;{@code
 81  *     public static void premain(String agentArgs, Instrumentation inst)
 82  * }&lt;/blockquote&gt;
 83  *
 84  * &lt;p&gt; If the agent class does not implement this method then the JVM will
 85  * attempt to invoke:
 86  * &lt;blockquote&gt;{@code
 87  *     public static void premain(String agentArgs)
 88  * }&lt;/blockquote&gt;
 89 
 90  * &lt;p&gt; The agent class may also have an {@code agentmain} method for use when
 91  * the agent is started after VM startup (see below). When the agent is started
 92  * using a command-line option, the {@code agentmain} method is not invoked.
 93  *
 94  * &lt;p&gt; Each agent is passed its agent options via the {@code agentArgs} parameter.
 95  * The agent options are passed as a single string, any additional parsing
 96  * should be performed by the agent itself.
 97  *
 98  * &lt;p&gt; If the agent cannot be started (for example, because the agent class
 99  * cannot be loaded, or because the agent class does not have an appropriate
100  * {@code premain} method), the JVM will abort. If a {@code premain} method
101  * throws an uncaught exception, the JVM will abort.
102  *
103  * &lt;p&gt; An implementation is not required to provide a way to start agents
104  * from the command-line interface. When it does, then it supports the
105  * {@code -javaagent} option as specified above. The {@code -javaagent} option
106  * may be used multiple times on the same command-line, thus starting multiple
107  * agents. The {@code premain} methods will be called in the order that the
108  * agents are specified on the command line. More than one agent may use the
109  * same &lt;i&gt;{@code &lt;jarpath&gt;}&lt;/i&gt;.
110  *
111  * &lt;p&gt; There are no modeling restrictions on what the agent {@code premain}
112  * method may do. Anything application {@code main} can do, including creating
113  * threads, is legal from {@code premain}.
114  *
115  *
116  * &lt;h2&gt;Starting an Agent After VM Startup&lt;/h2&gt;
117  *
118  * &lt;p&gt; An implementation may provide a mechanism to start agents sometime after
119  * the the VM has started. The details as to how this is initiated are
120  * implementation specific but typically the application has already started and
121  * its {@code main} method has already been invoked. In cases where an
122  * implementation supports the starting of agents after the VM has started the
123  * following applies:
124  *
125  * &lt;ol&gt;
126  *
127  *   &lt;li&gt;&lt;p&gt; The manifest of the agent JAR must contain the attribute {@code
128  *   Agent-Class} in its main manfiest. The value of this attribute is the name
129  *   of the &lt;i&gt;agent class&lt;/i&gt;. &lt;/p&gt;&lt;/li&gt;
130  *
131  *   &lt;li&gt;&lt;p&gt; The agent class must implement a public static {@code agentmain}
132  *   method. &lt;/p&gt;&lt;/li&gt;
133  *
134  * &lt;/ol&gt;
135  *
136  * &lt;p&gt; The {@code agentmain} method has one of two possible signatures. The JVM
137  * first attempts to invoke the following method on the agent class:
138  *
139  * &lt;blockquote&gt;{@code
140  *     public static void agentmain(String agentArgs, Instrumentation inst)
141  * }&lt;/blockquote&gt;
142  *
143  * &lt;p&gt; If the agent class does not implement this method then the JVM will
144  * attempt to invoke:
145  *
146  * &lt;blockquote&gt;{@code
147  *     public static void agentmain(String agentArgs)
148  * }&lt;/blockquote&gt;
149  *
150  * &lt;p&gt; The agent class may also have a {@code premain} method for use when the
151  * agent is started using a command-line option. When the agent is started after
152  * VM startup the {@code premain} method is not invoked.
153  *
154  * &lt;p&gt; The agent is passed its agent options via the {@code agentArgs}
155  * parameter. The agent options are passed as a single string, any additional
156  * parsing should be performed by the agent itself.
157  *
158  * &lt;p&gt; The {@code agentmain} method should do any necessary initialization
159  * required to start the agent. When startup is complete the method should
160  * return. If the agent cannot be started (for example, because the agent class
161  * cannot be loaded, or because the agent class does not have a conformant
162  * {@code agentmain} method), the JVM will not abort. If the {@code agentmain}
163  * method throws an uncaught exception it will be ignored (but may be logged
164  * by the JVM for troubleshooting purposes).
165  *
166  *
167  * &lt;h2&gt;Including an Agent in an Executable JAR file&lt;/h2&gt;
168  *
169  * &lt;p&gt; The JAR File Specification defines manifest attributes for standalone
170  * applications that are packaged as &lt;em&gt;executable JAR files&lt;/em&gt;. If an
171  * implementation supports a mechanism to start an application as an executable
172  * JAR then the main manifest may include the {@code Launcher-Agent-Class}
173  * attribute to specify the class name of an agent to start before the application
174  * {@code main} method is invoked. The Java virtual machine attempts to
175  * invoke the following method on the agent class:
176  *
177  * &lt;blockquote&gt;{@code
178  *     public static void agentmain(String agentArgs, Instrumentation inst)
179  * }&lt;/blockquote&gt;
180  *
181  * &lt;p&gt; If the agent class does not implement this method then the JVM will
182  * attempt to invoke:
183  *
184  * &lt;blockquote&gt;{@code
185  *     public static void agentmain(String agentArgs)
186  * }&lt;/blockquote&gt;
187  *
188  * &lt;p&gt; The value of the {@code agentArgs} parameter is always the empty string.
189  *
190  * &lt;p&gt; The {@code agentmain} method should do any necessary initialization
191  * required to start the agent and return. If the agent cannot be started, for
192  * example the agent class cannot be loaded, the agent class does not define a
193  * conformant {@code agentmain} method, or the {@code agentmain} method throws
194  * an uncaught exception or error, the JVM will abort.
195  *
196  *
197  * &lt;h2&gt; Loading agent classes and the modules/classes available to the agent
198  * class &lt;/h2&gt;
199  *
200  * &lt;p&gt; Classes loaded from the agent JAR file are loaded by the
201  * {@linkplain ClassLoader#getSystemClassLoader() system class loader} and are
202  * members of the system class loader&#39;s {@linkplain ClassLoader#getUnnamedModule()
203  * unnamed module}. The system class loader typically defines the class containing
204  * the application {@code main} method too.
205  *
206  * &lt;p&gt; The classes visible to the agent class are the classes visible to the system
207  * class loader and minimally include:
208  *
209  * &lt;ul&gt;
210  *
211  *   &lt;li&gt;&lt;p&gt; The classes in packages exported by the modules in the {@linkplain
212  *   ModuleLayer#boot() boot layer}. Whether the boot layer contains all platform
213  *   modules or not will depend on the initial module or how the application was
214  *   started. &lt;/p&gt;&lt;/li&gt;
215  *
216  *   &lt;li&gt;&lt;p&gt; The classes that can be defined by the system class loader (typically
217  *   the class path) to be members of its unnamed module. &lt;/p&gt;&lt;/li&gt;
218  *
219  *   &lt;li&gt;&lt;p&gt; Any classes that the agent arranges to be defined by the bootstrap
220  *   class loader to be members of its unnamed module. &lt;/p&gt;&lt;/li&gt;
221  *
222  * &lt;/ul&gt;
223  *
224  * &lt;p&gt; If agent classes need to link to classes in platform (or other) modules
225  * that are not in the boot layer then the application may need to be started in
226  * a way that ensures that these modules are in the boot layer. In the JDK
227  * implementation for example, the {@code --add-modules} command line option can
228  * be used to add modules to the set of root modules to resolve at startup. &lt;/p&gt;
229  *
230  * &lt;p&gt; Supporting classes that the agent arranges to be loaded by the bootstrap
231  * class loader (by means of {@link Instrumentation#appendToBootstrapClassLoaderSearch
232  * appendToBootstrapClassLoaderSearch} or the {@code Boot-Class-Path} attribute
233  * specified below), must link only to classes defined to the bootstrap class loader.
234  * There is no guarantee that all platform classes can be defined by the boot
235  * class loader.
236  *
237  * &lt;p&gt; If a custom system class loader is configured (by means of the system property
238  * {@code java.system.class.loader} as specified in the {@link
239  * ClassLoader#getSystemClassLoader() getSystemClassLoader} method) then it must
240  * define the {@code appendToClassPathForInstrumentation} method as specified in
241  * {@link Instrumentation#appendToSystemClassLoaderSearch appendToSystemClassLoaderSearch}.
242  * In other words, a custom system class loader must support the mechanism to
243  * add an agent JAR file to the system class loader search.
244  *
245  * &lt;h2&gt;Manifest Attributes&lt;/h2&gt;
246  *
247  * &lt;p&gt; The following manifest attributes are defined for an agent JAR file:
248  *
249  * &lt;blockquote&gt;&lt;dl&gt;
250  *
251  * &lt;dt&gt;{@code Premain-Class}&lt;/dt&gt;
252  * &lt;dd&gt; When an agent is specified at JVM launch time this attribute specifies
253  * the agent class. That is, the class containing the {@code premain} method.
254  * When an agent is specified at JVM launch time this attribute is required. If
255  * the attribute is not present the JVM will abort. Note: this is a class name,
256  * not a file name or path. &lt;/dd&gt;
257  *
258  * &lt;dt&gt;{@code Agent-Class}&lt;/dt&gt;
259  * &lt;dd&gt; If an implementation supports a mechanism to start agents sometime after
260  * the VM has started then this attribute specifies the agent class. That is,
261  * the class containing the {@code agentmain} method. This attribute is required
262  * if it is not present the agent will not be started. Note: this is a class name,
263  * not a file name or path. &lt;/dd&gt;
264  *
265  * &lt;dt&gt;{@code Launcher-Agent-Class}&lt;/dt&gt;
266  * &lt;dd&gt; If an implementation supports a mechanism to start an application as an
267  * executable JAR then the main manifest may include this attribute to specify
268  * the class name of an agent to start before the application {@code main}
269  * method is invoked. &lt;/dd&gt;
270  *
271  * &lt;dt&gt;{@code Boot-Class-Path}&lt;/dt&gt;
272  * &lt;dd&gt; A list of paths to be searched by the bootstrap class loader. Paths
273  * represent directories or libraries (commonly referred to as JAR or zip
274  * libraries on many platforms). These paths are searched by the bootstrap class
275  * loader after the platform specific mechanisms of locating a class have failed.
276  * Paths are searched in the order listed. Paths in the list are separated by one
277  * or more spaces. A path takes the syntax of the path component of a hierarchical
278  * URI. The path is absolute if it begins with a slash character (&#39;/&#39;), otherwise
279  * it is relative. A relative path is resolved against the absolute path of the
280  * agent JAR file. Malformed and non-existent paths are ignored. When an agent is
281  * started sometime after the VM has started then paths that do not represent a
282  * JAR file are ignored. This attribute is optional. &lt;/dd&gt;
283  *
284  * &lt;dt&gt;{@code Can-Redefine-Classes}&lt;/dt&gt;
285  * &lt;dd&gt; Boolean ({@code true} or {@code false}, case irrelevant). Is the ability
286  * to redefine classes needed by this agent. Values other than {@code true} are
287  * considered {@code false}. This attribute is optional, the default is {@code
288  * false}. &lt;/dd&gt;
289  *
290  * &lt;dt&gt;{@code Can-Retransform-Classes}&lt;/dt&gt;
291  * &lt;dd&gt; Boolean ({@code true} or {@code false}, case irrelevant). Is the ability
292  * to retransform classes needed by this agent. Values other than {@code true}
293  * are considered {@code false}. This attribute is optional, the default is
294  * {@code false}. &lt;/dd&gt;
295  *
296  * &lt;dt&gt;{@code Can-Set-Native-Method-Prefix}&lt;/dt&gt;
297  * &lt;dd&gt; Boolean ({@code true} or {@code false}, case irrelevant). Is the ability
298  * to set native method prefix needed by this agent. Values other than {@code
299  * true} are considered {@code false}. This attribute is optional, the default
300  * is {@code false}. &lt;/dd&gt;
301  *
302  * &lt;/dl&gt;&lt;/blockquote&gt;
303  *
304  * &lt;p&gt; An agent JAR file may have both the {@code Premain-Class} and {@code
305  * Agent-Class} attributes present in the manifest. When the agent is started
306  * on the command-line using the {@code -javaagent} option then the {@code
307  * Premain-Class} attribute specifies the name of the agent class and the {@code
308  * Agent-Class} attribute is ignored. Similarly, if the agent is started sometime
309  * after the VM has started, then the {@code Agent-Class} attribute specifies
310  * the name of the agent class (the value of {@code Premain-Class} attribute is
311  * ignored).
312  *
313  *
314  * &lt;h2&gt;Instrumenting code in modules&lt;/h2&gt;
315  *
316  * &lt;p&gt; As an aid to agents that deploy supporting classes on the search path of
317  * the bootstrap class loader, or the search path of the class loader that loads
318  * the main agent class, the Java virtual machine arranges for the module of
319  * transformed classes to read the unnamed module of both class loaders.
320  *
321  * @since 1.5
322  * @revised 1.6
323  * @revised 9
324  */
325 
326 package java.lang.instrument;
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.instrument/share/classes/java/lang/instrument/package-info.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * Copyright 2003 Wily Technology, Inc.
 28  */
 29 
 30 /**
 31  * Provides services that allow Java programming language agents to instrument
 32  * programs running on the JVM. The mechanism for instrumentation is modification
 33  * of the byte-codes of methods.
 34  *
<a name="1" id="anc1"></a><span class="line-added"> 35  * &lt;p&gt; Note: developers/admininstrators are responsible for verifying</span>
<span class="line-added"> 36  * the trustworthiness of content and structure of the Java Agents they deploy,</span>
<span class="line-added"> 37  * since those are able to arbitrarily transform the bytecode from other JAR files.</span>
<span class="line-added"> 38  * Since that happens after the Jars containing the bytecode have been verified</span>
<span class="line-added"> 39  * as trusted, the trustworthiness of a Java Agent can determine the trust towards</span>
<span class="line-added"> 40  * the entire program.</span>
<span class="line-added"> 41  *</span>
 42  * &lt;p&gt; An agent is deployed as a JAR file. An attribute in the JAR file manifest
 43  * specifies the agent class which will be loaded to start the agent. Agents can
 44  * be started in several ways:
 45  *
 46  * &lt;ol&gt;
 47  *   &lt;li&gt;&lt;p&gt; For implementations that support a command-line interface, an agent
 48  *   can be started by specifying an option on the command-line. &lt;/p&gt;&lt;/li&gt;
 49  *
 50  *   &lt;li&gt;&lt;p&gt; An implementation may support a mechanism to start agents some time
 51  *   after the VM has started. For example, an implementation may provide a
 52  *   mechanism that allows a tool to &lt;i&gt;attach&lt;/i&gt; to a running application, and
 53  *   initiate the loading of the tool&#39;s agent into the running application. &lt;/p&gt;&lt;/li&gt;
 54  *
 55  *   &lt;li&gt;&lt;p&gt; An agent may be packaged with an application in an executable JAR
 56  *   file.&lt;/p&gt;&lt;/li&gt;
 57  * &lt;/ol&gt;
 58  *
 59  * &lt;p&gt; Each of these ways to start an agent is described below.
 60  *
 61  *
 62  * &lt;h2&gt;Starting an Agent from the Command-Line Interface&lt;/h2&gt;
 63  *
 64  * &lt;p&gt; Where an implementation provides a means to start agents from the
 65  * command-line interface, an agent is started by adding the following option
 66  * to the command-line:
 67  *
 68  * &lt;blockquote&gt;{@code
 69  *     -javaagent:&lt;jarpath&gt;[=&lt;options&gt;]
 70  * }&lt;/blockquote&gt;
 71  *
 72  * where &lt;i&gt;{@code &lt;jarpath&gt;}&lt;/i&gt; is the path to the agent JAR file and
 73  * &lt;i&gt;{@code &lt;options&gt;}&lt;/i&gt; is the agent options.
 74  *
 75  * &lt;p&gt; The manifest of the agent JAR file must contain the attribute {@code
 76  * Premain-Class} in its main manifest. The value of this attribute is the
 77  * name of the &lt;i&gt;agent class&lt;/i&gt;. The agent class must implement a public
 78  * static {@code premain} method similar in principle to the {@code main}
 79  * application entry point. After the Java Virtual Machine (JVM) has
 80  * initialized, the {@code premain} method will be called, then the real
 81  * application {@code main} method. The {@code premain} method must return
 82  * in order for the startup to proceed.
 83  *
 84  * &lt;p&gt; The {@code premain} method has one of two possible signatures. The
 85  * JVM first attempts to invoke the following method on the agent class:
 86  *
 87  * &lt;blockquote&gt;{@code
 88  *     public static void premain(String agentArgs, Instrumentation inst)
 89  * }&lt;/blockquote&gt;
 90  *
 91  * &lt;p&gt; If the agent class does not implement this method then the JVM will
 92  * attempt to invoke:
 93  * &lt;blockquote&gt;{@code
 94  *     public static void premain(String agentArgs)
 95  * }&lt;/blockquote&gt;
 96 
 97  * &lt;p&gt; The agent class may also have an {@code agentmain} method for use when
 98  * the agent is started after VM startup (see below). When the agent is started
 99  * using a command-line option, the {@code agentmain} method is not invoked.
100  *
101  * &lt;p&gt; Each agent is passed its agent options via the {@code agentArgs} parameter.
102  * The agent options are passed as a single string, any additional parsing
103  * should be performed by the agent itself.
104  *
105  * &lt;p&gt; If the agent cannot be started (for example, because the agent class
106  * cannot be loaded, or because the agent class does not have an appropriate
107  * {@code premain} method), the JVM will abort. If a {@code premain} method
108  * throws an uncaught exception, the JVM will abort.
109  *
110  * &lt;p&gt; An implementation is not required to provide a way to start agents
111  * from the command-line interface. When it does, then it supports the
112  * {@code -javaagent} option as specified above. The {@code -javaagent} option
113  * may be used multiple times on the same command-line, thus starting multiple
114  * agents. The {@code premain} methods will be called in the order that the
115  * agents are specified on the command line. More than one agent may use the
116  * same &lt;i&gt;{@code &lt;jarpath&gt;}&lt;/i&gt;.
117  *
118  * &lt;p&gt; There are no modeling restrictions on what the agent {@code premain}
119  * method may do. Anything application {@code main} can do, including creating
120  * threads, is legal from {@code premain}.
121  *
122  *
123  * &lt;h2&gt;Starting an Agent After VM Startup&lt;/h2&gt;
124  *
125  * &lt;p&gt; An implementation may provide a mechanism to start agents sometime after
126  * the the VM has started. The details as to how this is initiated are
127  * implementation specific but typically the application has already started and
128  * its {@code main} method has already been invoked. In cases where an
129  * implementation supports the starting of agents after the VM has started the
130  * following applies:
131  *
132  * &lt;ol&gt;
133  *
134  *   &lt;li&gt;&lt;p&gt; The manifest of the agent JAR must contain the attribute {@code
135  *   Agent-Class} in its main manfiest. The value of this attribute is the name
136  *   of the &lt;i&gt;agent class&lt;/i&gt;. &lt;/p&gt;&lt;/li&gt;
137  *
138  *   &lt;li&gt;&lt;p&gt; The agent class must implement a public static {@code agentmain}
139  *   method. &lt;/p&gt;&lt;/li&gt;
140  *
141  * &lt;/ol&gt;
142  *
143  * &lt;p&gt; The {@code agentmain} method has one of two possible signatures. The JVM
144  * first attempts to invoke the following method on the agent class:
145  *
146  * &lt;blockquote&gt;{@code
147  *     public static void agentmain(String agentArgs, Instrumentation inst)
148  * }&lt;/blockquote&gt;
149  *
150  * &lt;p&gt; If the agent class does not implement this method then the JVM will
151  * attempt to invoke:
152  *
153  * &lt;blockquote&gt;{@code
154  *     public static void agentmain(String agentArgs)
155  * }&lt;/blockquote&gt;
156  *
157  * &lt;p&gt; The agent class may also have a {@code premain} method for use when the
158  * agent is started using a command-line option. When the agent is started after
159  * VM startup the {@code premain} method is not invoked.
160  *
161  * &lt;p&gt; The agent is passed its agent options via the {@code agentArgs}
162  * parameter. The agent options are passed as a single string, any additional
163  * parsing should be performed by the agent itself.
164  *
165  * &lt;p&gt; The {@code agentmain} method should do any necessary initialization
166  * required to start the agent. When startup is complete the method should
167  * return. If the agent cannot be started (for example, because the agent class
168  * cannot be loaded, or because the agent class does not have a conformant
169  * {@code agentmain} method), the JVM will not abort. If the {@code agentmain}
170  * method throws an uncaught exception it will be ignored (but may be logged
171  * by the JVM for troubleshooting purposes).
172  *
173  *
174  * &lt;h2&gt;Including an Agent in an Executable JAR file&lt;/h2&gt;
175  *
176  * &lt;p&gt; The JAR File Specification defines manifest attributes for standalone
177  * applications that are packaged as &lt;em&gt;executable JAR files&lt;/em&gt;. If an
178  * implementation supports a mechanism to start an application as an executable
179  * JAR then the main manifest may include the {@code Launcher-Agent-Class}
180  * attribute to specify the class name of an agent to start before the application
181  * {@code main} method is invoked. The Java virtual machine attempts to
182  * invoke the following method on the agent class:
183  *
184  * &lt;blockquote&gt;{@code
185  *     public static void agentmain(String agentArgs, Instrumentation inst)
186  * }&lt;/blockquote&gt;
187  *
188  * &lt;p&gt; If the agent class does not implement this method then the JVM will
189  * attempt to invoke:
190  *
191  * &lt;blockquote&gt;{@code
192  *     public static void agentmain(String agentArgs)
193  * }&lt;/blockquote&gt;
194  *
195  * &lt;p&gt; The value of the {@code agentArgs} parameter is always the empty string.
196  *
197  * &lt;p&gt; The {@code agentmain} method should do any necessary initialization
198  * required to start the agent and return. If the agent cannot be started, for
199  * example the agent class cannot be loaded, the agent class does not define a
200  * conformant {@code agentmain} method, or the {@code agentmain} method throws
201  * an uncaught exception or error, the JVM will abort.
202  *
203  *
204  * &lt;h2&gt; Loading agent classes and the modules/classes available to the agent
205  * class &lt;/h2&gt;
206  *
207  * &lt;p&gt; Classes loaded from the agent JAR file are loaded by the
208  * {@linkplain ClassLoader#getSystemClassLoader() system class loader} and are
209  * members of the system class loader&#39;s {@linkplain ClassLoader#getUnnamedModule()
210  * unnamed module}. The system class loader typically defines the class containing
211  * the application {@code main} method too.
212  *
213  * &lt;p&gt; The classes visible to the agent class are the classes visible to the system
214  * class loader and minimally include:
215  *
216  * &lt;ul&gt;
217  *
218  *   &lt;li&gt;&lt;p&gt; The classes in packages exported by the modules in the {@linkplain
219  *   ModuleLayer#boot() boot layer}. Whether the boot layer contains all platform
220  *   modules or not will depend on the initial module or how the application was
221  *   started. &lt;/p&gt;&lt;/li&gt;
222  *
223  *   &lt;li&gt;&lt;p&gt; The classes that can be defined by the system class loader (typically
224  *   the class path) to be members of its unnamed module. &lt;/p&gt;&lt;/li&gt;
225  *
226  *   &lt;li&gt;&lt;p&gt; Any classes that the agent arranges to be defined by the bootstrap
227  *   class loader to be members of its unnamed module. &lt;/p&gt;&lt;/li&gt;
228  *
229  * &lt;/ul&gt;
230  *
231  * &lt;p&gt; If agent classes need to link to classes in platform (or other) modules
232  * that are not in the boot layer then the application may need to be started in
233  * a way that ensures that these modules are in the boot layer. In the JDK
234  * implementation for example, the {@code --add-modules} command line option can
235  * be used to add modules to the set of root modules to resolve at startup. &lt;/p&gt;
236  *
237  * &lt;p&gt; Supporting classes that the agent arranges to be loaded by the bootstrap
238  * class loader (by means of {@link Instrumentation#appendToBootstrapClassLoaderSearch
239  * appendToBootstrapClassLoaderSearch} or the {@code Boot-Class-Path} attribute
240  * specified below), must link only to classes defined to the bootstrap class loader.
241  * There is no guarantee that all platform classes can be defined by the boot
242  * class loader.
243  *
244  * &lt;p&gt; If a custom system class loader is configured (by means of the system property
245  * {@code java.system.class.loader} as specified in the {@link
246  * ClassLoader#getSystemClassLoader() getSystemClassLoader} method) then it must
247  * define the {@code appendToClassPathForInstrumentation} method as specified in
248  * {@link Instrumentation#appendToSystemClassLoaderSearch appendToSystemClassLoaderSearch}.
249  * In other words, a custom system class loader must support the mechanism to
250  * add an agent JAR file to the system class loader search.
251  *
252  * &lt;h2&gt;Manifest Attributes&lt;/h2&gt;
253  *
254  * &lt;p&gt; The following manifest attributes are defined for an agent JAR file:
255  *
256  * &lt;blockquote&gt;&lt;dl&gt;
257  *
258  * &lt;dt&gt;{@code Premain-Class}&lt;/dt&gt;
259  * &lt;dd&gt; When an agent is specified at JVM launch time this attribute specifies
260  * the agent class. That is, the class containing the {@code premain} method.
261  * When an agent is specified at JVM launch time this attribute is required. If
262  * the attribute is not present the JVM will abort. Note: this is a class name,
263  * not a file name or path. &lt;/dd&gt;
264  *
265  * &lt;dt&gt;{@code Agent-Class}&lt;/dt&gt;
266  * &lt;dd&gt; If an implementation supports a mechanism to start agents sometime after
267  * the VM has started then this attribute specifies the agent class. That is,
268  * the class containing the {@code agentmain} method. This attribute is required
269  * if it is not present the agent will not be started. Note: this is a class name,
270  * not a file name or path. &lt;/dd&gt;
271  *
272  * &lt;dt&gt;{@code Launcher-Agent-Class}&lt;/dt&gt;
273  * &lt;dd&gt; If an implementation supports a mechanism to start an application as an
274  * executable JAR then the main manifest may include this attribute to specify
275  * the class name of an agent to start before the application {@code main}
276  * method is invoked. &lt;/dd&gt;
277  *
278  * &lt;dt&gt;{@code Boot-Class-Path}&lt;/dt&gt;
279  * &lt;dd&gt; A list of paths to be searched by the bootstrap class loader. Paths
280  * represent directories or libraries (commonly referred to as JAR or zip
281  * libraries on many platforms). These paths are searched by the bootstrap class
282  * loader after the platform specific mechanisms of locating a class have failed.
283  * Paths are searched in the order listed. Paths in the list are separated by one
284  * or more spaces. A path takes the syntax of the path component of a hierarchical
285  * URI. The path is absolute if it begins with a slash character (&#39;/&#39;), otherwise
286  * it is relative. A relative path is resolved against the absolute path of the
287  * agent JAR file. Malformed and non-existent paths are ignored. When an agent is
288  * started sometime after the VM has started then paths that do not represent a
289  * JAR file are ignored. This attribute is optional. &lt;/dd&gt;
290  *
291  * &lt;dt&gt;{@code Can-Redefine-Classes}&lt;/dt&gt;
292  * &lt;dd&gt; Boolean ({@code true} or {@code false}, case irrelevant). Is the ability
293  * to redefine classes needed by this agent. Values other than {@code true} are
294  * considered {@code false}. This attribute is optional, the default is {@code
295  * false}. &lt;/dd&gt;
296  *
297  * &lt;dt&gt;{@code Can-Retransform-Classes}&lt;/dt&gt;
298  * &lt;dd&gt; Boolean ({@code true} or {@code false}, case irrelevant). Is the ability
299  * to retransform classes needed by this agent. Values other than {@code true}
300  * are considered {@code false}. This attribute is optional, the default is
301  * {@code false}. &lt;/dd&gt;
302  *
303  * &lt;dt&gt;{@code Can-Set-Native-Method-Prefix}&lt;/dt&gt;
304  * &lt;dd&gt; Boolean ({@code true} or {@code false}, case irrelevant). Is the ability
305  * to set native method prefix needed by this agent. Values other than {@code
306  * true} are considered {@code false}. This attribute is optional, the default
307  * is {@code false}. &lt;/dd&gt;
308  *
309  * &lt;/dl&gt;&lt;/blockquote&gt;
310  *
311  * &lt;p&gt; An agent JAR file may have both the {@code Premain-Class} and {@code
312  * Agent-Class} attributes present in the manifest. When the agent is started
313  * on the command-line using the {@code -javaagent} option then the {@code
314  * Premain-Class} attribute specifies the name of the agent class and the {@code
315  * Agent-Class} attribute is ignored. Similarly, if the agent is started sometime
316  * after the VM has started, then the {@code Agent-Class} attribute specifies
317  * the name of the agent class (the value of {@code Premain-Class} attribute is
318  * ignored).
319  *
320  *
321  * &lt;h2&gt;Instrumenting code in modules&lt;/h2&gt;
322  *
323  * &lt;p&gt; As an aid to agents that deploy supporting classes on the search path of
324  * the bootstrap class loader, or the search path of the class loader that loads
325  * the main agent class, the Java virtual machine arranges for the module of
326  * transformed classes to read the unnamed module of both class loaders.
327  *
328  * @since 1.5
329  * @revised 1.6
330  * @revised 9
331  */
332 
333 package java.lang.instrument;
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.instrument/share/native/libinstrument/InvocationAdapter.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * Copyright 2003 Wily Technology, Inc.
 28  */
 29 
 30 #include    &lt;string.h&gt;
 31 #include    &lt;stdlib.h&gt;
 32 
 33 #include    &quot;jni.h&quot;
 34 
 35 #include    &quot;jdk_util.h&quot;
 36 
 37 #include    &quot;Utilities.h&quot;
 38 #include    &quot;JPLISAssert.h&quot;
 39 #include    &quot;JPLISAgent.h&quot;
 40 #include    &quot;JavaExceptions.h&quot;
 41 
 42 #include    &quot;EncodingSupport.h&quot;
 43 #include    &quot;FileSystemSupport.h&quot;
 44 #include    &quot;JarFacade.h&quot;
 45 #include    &quot;PathCharsValidator.h&quot;
 46 
 47 /**
 48  * This module contains the direct interface points with the JVMTI.
 49  * The OnLoad handler is here, along with the various event handlers.
 50  */
 51 
 52 static int
 53 appendClassPath(JPLISAgent* agent,
 54                 const char* jarfile);
 55 
 56 static void
 57 appendBootClassPath(JPLISAgent* agent,
 58                     const char* jarfile,
 59                     const char* pathList);
 60 
 61 
 62 /*
 63  * Parse -javaagent tail, of the form name[=options], into name
 64  * and options. Returned values are heap allocated and options maybe
 65  * NULL. Returns 0 if parse succeeds, -1 if allocation fails.
 66  */
 67 static int
 68 parseArgumentTail(char* tail, char** name, char** options) {
 69     int len;
 70     char* pos;
 71 
 72     pos = strchr(tail, &#39;=&#39;);
 73     len = (pos == NULL) ? (int)strlen(tail) : (int)(pos - tail);
 74 
 75     *name = (char*)malloc(len+1);
 76     if (*name == NULL) {
 77         return -1;
 78     }
 79     memcpy(*name, tail, len);
 80     (*name)[len] = &#39;\0&#39;;
 81 
 82     if (pos == NULL) {
 83         *options = NULL;
 84     } else {
 85         char * str = (char*)malloc( (int)strlen(pos + 1) + 1 );
 86         if (str == NULL) {
 87             free(*name);
 88             return -1;
 89         }
 90         strcpy(str, pos +1);
 91         *options = str;
 92     }
 93     return 0;
 94 }
 95 
 96 /*
 97  * Get the value of an attribute in an attribute list. Returns NULL
 98  * if attribute not found.
 99  */
100 jboolean
101 getBooleanAttribute(const jarAttribute* attributes, const char* name) {
102     char* attributeValue = getAttribute(attributes, name);
103     return attributeValue != NULL &amp;&amp; strcasecmp(attributeValue, &quot;true&quot;) == 0;
104 }
105 
106 /*
107  * Parse any capability settings in the JAR manifest and
108  * convert them to JVM TI capabilities.
109  */
110 void
111 convertCapabilityAttributes(const jarAttribute* attributes, JPLISAgent* agent) {
112     /* set redefineClasses capability */
113     if (getBooleanAttribute(attributes, &quot;Can-Redefine-Classes&quot;)) {
114         addRedefineClassesCapability(agent);
115     }
116 
117     /* create an environment which has the retransformClasses capability */
118     if (getBooleanAttribute(attributes, &quot;Can-Retransform-Classes&quot;)) {
119         retransformableEnvironment(agent);
120     }
121 
122     /* set setNativeMethodPrefix capability */
123     if (getBooleanAttribute(attributes, &quot;Can-Set-Native-Method-Prefix&quot;)) {
124         addNativeMethodPrefixCapability(agent);
125     }
126 
127     /* for retransformClasses testing, set capability to use original method order */
128     if (getBooleanAttribute(attributes, &quot;Can-Maintain-Original-Method-Order&quot;)) {
129         addOriginalMethodOrderCapability(agent);
130     }
131 }
132 
133 /*
134  *  This will be called once for every -javaagent on the command line.
135  *  Each call to Agent_OnLoad will create its own agent and agent data.
136  *
137  *  The argument tail string provided to Agent_OnLoad will be of form
138  *  &lt;jarfile&gt;[=&lt;options&gt;]. The tail string is split into the jarfile and
139  *  options components. The jarfile manifest is parsed and the value of the
140  *  Premain-Class attribute will become the agent&#39;s premain class. The jar
141  *  file is then added to the system class path, and if the Boot-Class-Path
142  *  attribute is present then all relative URLs in the value are processed
143  *  to create boot class path segments to append to the boot class path.
144  */
145 JNIEXPORT jint JNICALL
146 DEF_Agent_OnLoad(JavaVM *vm, char *tail, void * reserved) {
147     JPLISInitializationError initerror  = JPLIS_INIT_ERROR_NONE;
148     jint                     result     = JNI_OK;
149     JPLISAgent *             agent      = NULL;
150 
151     initerror = createNewJPLISAgent(vm, &amp;agent);
152     if ( initerror == JPLIS_INIT_ERROR_NONE ) {
153         int             oldLen, newLen;
154         char *          jarfile;
155         char *          options;
156         jarAttribute*   attributes;
157         char *          premainClass;
158         char *          bootClassPath;
159 
160         /*
161          * Parse &lt;jarfile&gt;[=options] into jarfile and options
162          */
163         if (parseArgumentTail(tail, &amp;jarfile, &amp;options) != 0) {
164             fprintf(stderr, &quot;-javaagent: memory allocation failure.\n&quot;);
165             return JNI_ERR;
166         }
167 
168         /*
169          * Agent_OnLoad is specified to provide the agent options
170          * argument tail in modified UTF8. However for 1.5.0 this is
171          * actually in the platform encoding - see 5049313.
172          *
173          * Open zip/jar file and parse archive. If can&#39;t be opened or
174          * not a zip file return error. Also if Premain-Class attribute
175          * isn&#39;t present we return an error.
176          */
177         attributes = readAttributes(jarfile);
178         if (attributes == NULL) {
179             fprintf(stderr, &quot;Error opening zip file or JAR manifest missing : %s\n&quot;, jarfile);
180             free(jarfile);
181             if (options != NULL) free(options);
182             return JNI_ERR;
183         }
184 
185         premainClass = getAttribute(attributes, &quot;Premain-Class&quot;);
186         if (premainClass == NULL) {
187             fprintf(stderr, &quot;Failed to find Premain-Class manifest attribute in %s\n&quot;,
188                 jarfile);
189             free(jarfile);
190             if (options != NULL) free(options);
191             freeAttributes(attributes);
192             return JNI_ERR;
193         }
194 
195         /* Save the jarfile name */
196         agent-&gt;mJarfile = jarfile;
197 
198         /*
199          * The value of the Premain-Class attribute becomes the agent
200          * class name. The manifest is in UTF8 so need to convert to
201          * modified UTF8 (see JNI spec).
202          */
203         oldLen = (int)strlen(premainClass);
204         newLen = modifiedUtf8LengthOfUtf8(premainClass, oldLen);
205         /*
206          * According to JVMS class name is represented as CONSTANT_Utf8_info,
207          * so its length is u2 (i.e. must be &lt;= 0xFFFF).
208          */
209         if (newLen &gt; 0xFFFF) {
210             fprintf(stderr, &quot;-javaagent: Premain-Class value is too big\n&quot;);
211             free(jarfile);
212             if (options != NULL) free(options);
213             freeAttributes(attributes);
214             return JNI_ERR;
215         }
216         if (newLen == oldLen) {
217             premainClass = strdup(premainClass);
218         } else {
219             char* str = (char*)malloc( newLen+1 );
220             if (str != NULL) {
221                 convertUtf8ToModifiedUtf8(premainClass, oldLen, str, newLen);
222             }
223             premainClass = str;
224         }
225         if (premainClass == NULL) {
226             fprintf(stderr, &quot;-javaagent: memory allocation failed\n&quot;);
227             free(jarfile);
228             if (options != NULL) free(options);
229             freeAttributes(attributes);
230             return JNI_ERR;
231         }
232 
233         /*
234          * If the Boot-Class-Path attribute is specified then we process
235          * each relative URL and add it to the bootclasspath.
236          */
237         bootClassPath = getAttribute(attributes, &quot;Boot-Class-Path&quot;);
238         if (bootClassPath != NULL) {
239             appendBootClassPath(agent, jarfile, bootClassPath);
240         }
241 
242         /*
243          * Convert JAR attributes into agent capabilities
244          */
245         convertCapabilityAttributes(attributes, agent);
246 
247         /*
248          * Track (record) the agent class name and options data
249          */
250         initerror = recordCommandLineData(agent, premainClass, options);
251 
252         /*
253          * Clean-up
254          */
255         if (options != NULL) free(options);
256         freeAttributes(attributes);
257         free(premainClass);
258     }
259 
260     switch (initerror) {
261     case JPLIS_INIT_ERROR_NONE:
262       result = JNI_OK;
263       break;
264     case JPLIS_INIT_ERROR_CANNOT_CREATE_NATIVE_AGENT:
265       result = JNI_ERR;
266       fprintf(stderr, &quot;java.lang.instrument/-javaagent: cannot create native agent.\n&quot;);
267       break;
268     case JPLIS_INIT_ERROR_FAILURE:
269       result = JNI_ERR;
270       fprintf(stderr, &quot;java.lang.instrument/-javaagent: initialization of native agent failed.\n&quot;);
271       break;
272     case JPLIS_INIT_ERROR_ALLOCATION_FAILURE:
273       result = JNI_ERR;
274       fprintf(stderr, &quot;java.lang.instrument/-javaagent: allocation failure.\n&quot;);
275       break;
276     case JPLIS_INIT_ERROR_AGENT_CLASS_NOT_SPECIFIED:
277       result = JNI_ERR;
278       fprintf(stderr, &quot;-javaagent: agent class not specified.\n&quot;);
279       break;
280     default:
281       result = JNI_ERR;
282       fprintf(stderr, &quot;java.lang.instrument/-javaagent: unknown error\n&quot;);
283       break;
284     }
285     return result;
286 }
287 
288 /*
289  * Agent_OnAttach returns a jint. 0/JNI_OK indicates success and non-0
290  * indicates an error. To allow the attach mechanism throw an
291  * AgentInitializationException with a reasonable exception message we define
292  * a few specific errors here.
293  */
294 #define AGENT_ERROR_BADJAR    ((jint)100)  /* Agent JAR not found or no Agent-Class attribute */
295 #define AGENT_ERROR_NOTONCP   ((jint)101)  /* Unable to add JAR file to system class path */
296 #define AGENT_ERROR_STARTFAIL ((jint)102)  /* No agentmain method or agentmain failed */
297 
298 /*
299  *  This will be called once each time a tool attaches to the VM and loads
300  *  the JPLIS library.
301  */
302 JNIEXPORT jint JNICALL
303 DEF_Agent_OnAttach(JavaVM* vm, char *args, void * reserved) {
304     JPLISInitializationError initerror  = JPLIS_INIT_ERROR_NONE;
305     jint                     result     = JNI_OK;
306     JPLISAgent *             agent      = NULL;
307     JNIEnv *                 jni_env    = NULL;
308 
309     /*
310      * Need JNIEnv - guaranteed to be called from thread that is already
311      * attached to VM
312      */
313     result = (*vm)-&gt;GetEnv(vm, (void**)&amp;jni_env, JNI_VERSION_1_2);
314     jplis_assert(result==JNI_OK);
315 
316     initerror = createNewJPLISAgent(vm, &amp;agent);
317     if ( initerror == JPLIS_INIT_ERROR_NONE ) {
318         int             oldLen, newLen;
319         char *          jarfile;
320         char *          options;
321         jarAttribute*   attributes;
322         char *          agentClass;
323         char *          bootClassPath;
324         jboolean        success;
325 
326         /*
327          * Parse &lt;jarfile&gt;[=options] into jarfile and options
328          */
329         if (parseArgumentTail(args, &amp;jarfile, &amp;options) != 0) {
330             return JNI_ENOMEM;
331         }
332 
333         /*
334          * Open the JAR file and parse the manifest
335          */
336         attributes = readAttributes( jarfile );
337         if (attributes == NULL) {
338             fprintf(stderr, &quot;Error opening zip file or JAR manifest missing: %s\n&quot;, jarfile);
339             free(jarfile);
340             if (options != NULL) free(options);
341             return AGENT_ERROR_BADJAR;
342         }
343 
344         agentClass = getAttribute(attributes, &quot;Agent-Class&quot;);
345         if (agentClass == NULL) {
346             fprintf(stderr, &quot;Failed to find Agent-Class manifest attribute from %s\n&quot;,
347                 jarfile);
348             free(jarfile);
349             if (options != NULL) free(options);
350             freeAttributes(attributes);
351             return AGENT_ERROR_BADJAR;
352         }
353 
354         /*
355          * Add the jarfile to the system class path
356          */
357         if (appendClassPath(agent, jarfile)) {
358             fprintf(stderr, &quot;Unable to add %s to system class path &quot;
359                 &quot;- not supported by system class loader or configuration error!\n&quot;,
360                 jarfile);
361             free(jarfile);
362             if (options != NULL) free(options);
363             freeAttributes(attributes);
364             return AGENT_ERROR_NOTONCP;
365         }
366 
367         /*
368          * The value of the Agent-Class attribute becomes the agent
369          * class name. The manifest is in UTF8 so need to convert to
370          * modified UTF8 (see JNI spec).
371          */
372         oldLen = (int)strlen(agentClass);
373         newLen = modifiedUtf8LengthOfUtf8(agentClass, oldLen);
374         /*
375          * According to JVMS class name is represented as CONSTANT_Utf8_info,
376          * so its length is u2 (i.e. must be &lt;= 0xFFFF).
377          */
378         if (newLen &gt; 0xFFFF) {
379             fprintf(stderr, &quot;Agent-Class value is too big\n&quot;);
380             free(jarfile);
381             if (options != NULL) free(options);
382             freeAttributes(attributes);
383             return AGENT_ERROR_BADJAR;
384         }
385         if (newLen == oldLen) {
386             agentClass = strdup(agentClass);
387         } else {
388             char* str = (char*)malloc( newLen+1 );
389             if (str != NULL) {
390                 convertUtf8ToModifiedUtf8(agentClass, oldLen, str, newLen);
391             }
392             agentClass = str;
393         }
394         if (agentClass == NULL) {
395             free(jarfile);
396             if (options != NULL) free(options);
397             freeAttributes(attributes);
398             return JNI_ENOMEM;
399         }
400 
401         /*
402          * If the Boot-Class-Path attribute is specified then we process
403          * each URL - in the live phase only JAR files will be added.
404          */
405         bootClassPath = getAttribute(attributes, &quot;Boot-Class-Path&quot;);
406         if (bootClassPath != NULL) {
407             appendBootClassPath(agent, jarfile, bootClassPath);
408         }
409 
410         /*
411          * Convert JAR attributes into agent capabilities
412          */
413         convertCapabilityAttributes(attributes, agent);
414 
415         /*
416          * Create the java.lang.instrument.Instrumentation instance
417          */
418         success = createInstrumentationImpl(jni_env, agent);
419         jplis_assert(success);
420 
421         /*
422          * Setup ClassFileLoadHook handler.
423          */
424         if (success) {
425             success = setLivePhaseEventHandlers(agent);
426             jplis_assert(success);
427         }
428 
429         /*
430          * Start the agent
431          */
432         if (success) {
433             success = startJavaAgent(agent,
434                                      jni_env,
435                                      agentClass,
436                                      options,
437                                      agent-&gt;mAgentmainCaller);
438         }
439 
440         if (!success) {
441             fprintf(stderr, &quot;Agent failed to start!\n&quot;);
442             result = AGENT_ERROR_STARTFAIL;
443         }
444 
445         /*
446          * Clean-up
447          */
448         free(jarfile);
449         if (options != NULL) free(options);
450         free(agentClass);
451         freeAttributes(attributes);
452     }
453 
454     return result;
455 }
456 
457 
458 JNIEXPORT void JNICALL
459 DEF_Agent_OnUnload(JavaVM *vm) {
460 }
461 
462 /**
463  * Invoked by the java launcher to load an agent in the main executable JAR.
464  * The Launcher-Agent-Class attribute in the main manifest of the JAR file
465  * is the agent class.
466  *
467  * Returns JNI_OK if the agent is loaded and initialized; JNI_ERR if this
468  * function fails, possibly with a pending exception.
469  */
470 jint loadAgent(JNIEnv* env, jstring path) {
471     JavaVM* vm;
472     JPLISAgent* agent;
473     const char* jarfile = NULL;
474     jarAttribute* attributes = NULL;
475     char* agentClass = NULL;
476     char* bootClassPath;
477     int oldLen, newLen;
478     jint result = JNI_ERR;
479 
480     if ((*env)-&gt;GetJavaVM(env, &amp;vm) &lt; 0) {
481         return JNI_ERR;
482     }
483 
484     // create JPLISAgent with JVMTI environment
485     if (createNewJPLISAgent(vm, &amp;agent) != JPLIS_INIT_ERROR_NONE) {
486         return JNI_ERR;
487     }
488 
489     // get path to JAR file as UTF-8 string
490     jarfile = (*env)-&gt;GetStringUTFChars(env, path, NULL);
491     if (jarfile == NULL) {
492         return JNI_ERR;
493     }
494 
495     // read the attributes in the main section of JAR manifest
496     attributes = readAttributes(jarfile);
497     if (attributes == NULL) {
498         goto releaseAndReturn;
499     }
500 
501     // Launcher-Agent-Class is required
502     agentClass = getAttribute(attributes, &quot;Launcher-Agent-Class&quot;);
503     if (agentClass == NULL) {
504         goto releaseAndReturn;
505     }
506 
507     // The value of Launcher-Agent-Class is in UTF-8, convert it to modified UTF-8
508     oldLen = (int) strlen(agentClass);
509     newLen = modifiedUtf8LengthOfUtf8(agentClass, oldLen);
510     /*
511      * According to JVMS class name is represented as CONSTANT_Utf8_info,
512      * so its length is u2 (i.e. must be &lt;= 0xFFFF).
513      */
514     if (newLen &gt; 0xFFFF) {
515         goto releaseAndReturn;
516     }
517     if (newLen == oldLen) {
518         agentClass = strdup(agentClass);
519     } else {
520         char* str = (char*) malloc(newLen + 1);
521         if (str != NULL) {
522             convertUtf8ToModifiedUtf8(agentClass, oldLen, str, newLen);
523         }
524         agentClass = str;
525     }
526     if (agentClass == NULL) {
527          jthrowable oome = createThrowable(env, &quot;java/lang/OutOfMemoryError&quot;, NULL);
528          if (oome != NULL) (*env)-&gt;Throw(env, oome);
529          goto releaseAndReturn;
530     }
531 
532     // Boot-Class-Path
533     bootClassPath = getAttribute(attributes, &quot;Boot-Class-Path&quot;);
534     if (bootClassPath != NULL) {
535         appendBootClassPath(agent, jarfile, bootClassPath);
536     }
537 
538     // Can-XXXX capabilities
539     convertCapabilityAttributes(attributes, agent);
540 
541     // Create the java.lang.instrument.Instrumentation object
542     if (!createInstrumentationImpl(env, agent)) {
543         goto releaseAndReturn;
544     }
545 
546     // Enable the ClassFileLoadHook
547     if (!setLivePhaseEventHandlers(agent)) {
548         goto releaseAndReturn;
549     }
550 
551     // invoke the agentmain method
552     if (!startJavaAgent(agent, env, agentClass, &quot;&quot;, agent-&gt;mAgentmainCaller)) {
553         goto releaseAndReturn;
554     }
555 
556     // initialization complete
557     result = JNI_OK;
558 
559     releaseAndReturn:
560         if (agentClass != NULL) {
561             free(agentClass);
562         }
563         if (attributes != NULL) {
564             freeAttributes(attributes);
565         }
566         if (jarfile != NULL) {
567             (*env)-&gt;ReleaseStringUTFChars(env, path, jarfile);
568         }
569 
570     return result;
571 }
572 
573 /*
574  *  JVMTI callback support
575  *
576  *  We have two &quot;stages&quot; of callback support.
577  *  At OnLoad time, we install a VMInit handler.
578  *  When the VMInit handler runs, we remove the VMInit handler and install a
579  *  ClassFileLoadHook handler.
580  */
581 
582 void JNICALL
583 eventHandlerVMInit( jvmtiEnv *      jvmtienv,
584                     JNIEnv *        jnienv,
585                     jthread         thread) {
586     JPLISEnvironment * environment  = NULL;
587     jboolean           success      = JNI_FALSE;
588 
589     environment = getJPLISEnvironment(jvmtienv);
590 
591     /* process the premain calls on the all the JPL agents */
592     if (environment == NULL) {
593         abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART &quot;, getting JPLIS environment failed&quot;);
594     }
595     jthrowable outstandingException = NULL;
596     /*
597      * Add the jarfile to the system class path
598      */
599     JPLISAgent * agent = environment-&gt;mAgent;
600     if (appendClassPath(agent, agent-&gt;mJarfile)) {
601         fprintf(stderr, &quot;Unable to add %s to system class path - &quot;
602                 &quot;the system class loader does not define the &quot;
603                 &quot;appendToClassPathForInstrumentation method or the method failed\n&quot;,
604                 agent-&gt;mJarfile);
605         free((void *)agent-&gt;mJarfile);
606         abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART &quot;, appending to system class path failed&quot;);
607     }
608     free((void *)agent-&gt;mJarfile);
609     agent-&gt;mJarfile = NULL;
610 
611     outstandingException = preserveThrowable(jnienv);
612     success = processJavaStart( environment-&gt;mAgent, jnienv);
613     restoreThrowable(jnienv, outstandingException);
614 
615     /* if we fail to start cleanly, bring down the JVM */
616     if ( !success ) {
617         abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART &quot;, processJavaStart failed&quot;);
618     }
619 }
620 
621 void JNICALL
622 eventHandlerClassFileLoadHook(  jvmtiEnv *              jvmtienv,
623                                 JNIEnv *                jnienv,
624                                 jclass                  class_being_redefined,
625                                 jobject                 loader,
626                                 const char*             name,
627                                 jobject                 protectionDomain,
628                                 jint                    class_data_len,
629                                 const unsigned char*    class_data,
630                                 jint*                   new_class_data_len,
631                                 unsigned char**         new_class_data) {
632     JPLISEnvironment * environment  = NULL;
633 
634     environment = getJPLISEnvironment(jvmtienv);
635 
636     /* if something is internally inconsistent (no agent), just silently return without touching the buffer */
637     if ( environment != NULL ) {
638         jthrowable outstandingException = preserveThrowable(jnienv);
639         transformClassFile( environment-&gt;mAgent,
640                             jnienv,
641                             loader,
642                             name,
643                             class_being_redefined,
644                             protectionDomain,
645                             class_data_len,
646                             class_data,
647                             new_class_data_len,
648                             new_class_data,
649                             environment-&gt;mIsRetransformer);
650         restoreThrowable(jnienv, outstandingException);
651     }
652 }
653 
654 
655 
656 
657 /*
658  * URLs in Boot-Class-Path attributes are separated by one or more spaces.
659  * This function splits the attribute value into a list of path segments.
660  * The attribute value is in UTF8 but cannot contain NUL. Also non US-ASCII
661  * characters must be escaped (URI syntax) so safe to iterate through the
662  * value as a C string.
663  */
664 static void
665 splitPathList(const char* str, int* pathCount, char*** paths) {
666     int count = 0;
667     char** segments = NULL;
668     char** new_segments;
669     char* c = (char*) str;
670     while (*c != &#39;\0&#39;) {
671         while (*c == &#39; &#39;) c++;          /* skip leading spaces */
672         if (*c == &#39;\0&#39;) {
673             break;
674         }
675         new_segments = (char**)realloc(segments, (count+1)*sizeof(char*));
676         if (new_segments == NULL) {
677             jplis_assert(0);
678             free(segments);
679             count = 0;
680             segments = NULL;
681             break;
682         }
683         segments = new_segments;
684         segments[count++] = c;
685         c = strchr(c, &#39; &#39;);
686         if (c == NULL) {
687             break;
688         }
689         *c = &#39;\0&#39;;
690         c++;
691     }
692     *pathCount = count;
693     *paths = segments;
694 }
695 
696 
697 /* URI path decoding - ported from src/share/classes/java/net/URI.java */
698 
699 static int
700 decodeNibble(char c) {
701     if ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;))
702         return c - &#39;0&#39;;
703     if ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;f&#39;))
704         return c - &#39;a&#39; + 10;
705     if ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;F&#39;))
706         return c - &#39;A&#39; + 10;
707     return -1;
708 }
709 
710 static int
711 decodeByte(char c1, char c2) {
712     return (((decodeNibble(c1) &amp; 0xf) &lt;&lt; 4) | ((decodeNibble(c2) &amp; 0xf) &lt;&lt; 0));
713 }
714 
715 /*
716  * Evaluates all escapes in s.  Assumes that escapes are well-formed
717  * syntactically, i.e., of the form %XX.
718  * If the path does not require decoding the original path is
719  * returned. Otherwise the decoded path (heap allocated) is returned,
720  * along with the length of the decoded path. Note that the return
721  * string will not be null terminated after decoding.
722  */
723 static
724 char *decodePath(const char *s, int* decodedLen) {
725     int n;
726     char *result;
727     char *resultp;
728     int c;
729     int i;
730 
731     n = (int)strlen(s);
732     if (n == 0) {
733         *decodedLen = 0;
734         return (char*)s;
735     }
736     if (strchr(s, &#39;%&#39;) == NULL) {
737         *decodedLen = n;
738         return (char*)s; /* no escapes, we are done */
739     }
740 
741     resultp = result = calloc(n+1, 1);
742     if (result == NULL) {
743         *decodedLen = 0;
744         return NULL;
745     }
746     c = s[0];
747     for (i = 0; i &lt; n;) {
748         if (c != &#39;%&#39;) {
749             *resultp++ = c;
750             if (++i &gt;= n)
751                 break;
752             c = s[i];
753             continue;
754         }
755         for (;;) {
756             char b1 = s[++i];
757             char b2 = s[++i];
758             int decoded = decodeByte(b1, b2);
759             *resultp++ = decoded;
760             if (++i &gt;= n)
761                 break;
762             c = s[i];
763             if (c != &#39;%&#39;)
764                 break;
765         }
766     }
767     *decodedLen = (int)(resultp - result);
768     return result; // not null terminated.
769 }
770 
771 /*
772  * Append the given jar file to the system class path. This should succeed in the
773  * onload phase but may fail in the live phase if the system class loader doesn&#39;t
774  * support appending to the class path.
775  */
776 static int
777 appendClassPath( JPLISAgent* agent,
778                  const char* jarfile ) {
779     jvmtiEnv* jvmtienv = jvmti(agent);
780     jvmtiError jvmtierr;
781 
782     jvmtierr = (*jvmtienv)-&gt;AddToSystemClassLoaderSearch(jvmtienv, jarfile);
783     check_phase_ret_1(jvmtierr);
784 
785     switch (jvmtierr) {
786         case JVMTI_ERROR_NONE :
787             return 0;
788         case JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED :
789             fprintf(stderr, &quot;System class loader does not define &quot;
790                 &quot;the appendToClassPathForInstrumentation method\n&quot;);
791             break;
792         default:
793             fprintf(stderr, &quot;Unexpected error (%d) returned by &quot;
794                 &quot;AddToSystemClassLoaderSearch\n&quot;, jvmtierr);
795             break;
796     }
797     return -1;
798 }
799 
800 
801 /*
802  * res = func, free&#39;ing the previous value of &#39;res&#39; if function
803  * returns a new result.
804  */
805 #define TRANSFORM(res,func) {    \
806     char* tmp = func;            \
807     if (tmp != res) {            \
808         free(res);               \
809         res = tmp;               \
810     }                            \
811     jplis_assert((void*)res != (void*)NULL);     \
812 }
813 
814 /*
815  * This function takes the value of the Boot-Class-Path attribute,
816  * splits it into the individual path segments, and then combines it
817  * with the path to the jar file to create the path to be added
818  * to the bootclasspath.
819  *
820  * Each individual path segment starts out as a UTF8 string. Additionally
821  * as the path is specified to use URI path syntax all non US-ASCII
822  * characters are escaped. Once the URI path is decoded we get a UTF8
823  * string which must then be converted to the platform encoding (as it
824  * will be combined with the platform path of the jar file). Once
825  * converted it is then normalized (remove duplicate slashes, etc.).
826  * If the resulting path is an absolute path (starts with a slash for
827  * example) then the path will be added to the bootclasspath. Otherwise
828  * if it&#39;s not absolute then we get the canoncial path of the agent jar
829  * file and then resolve the path in the context of the base path of
830  * the agent jar.
831  */
832 static void
833 appendBootClassPath( JPLISAgent* agent,
834                      const char* jarfile,
835                      const char* pathList ) {
836     char canonicalPath[MAXPATHLEN];
837     char *parent = NULL;
838     int haveBasePath = 0;
839 
840     int count, i;
841     char **paths;
842     jvmtiEnv* jvmtienv = jvmti(agent);
843     jvmtiError jvmtierr;
844 
845     /*
846      * Split the attribute value into the individual path segments
847      * and process each in sequence
848      */
849     splitPathList(pathList, &amp;count, &amp;paths);
850 
851     for (i=0; i&lt;count; i++) {
852         int len;
853         char* path;
854         char* pos;
855 
856         /*
857          * The path segment at this point is a pointer into the attribute
858          * value. As it will go through a number of transformation (tossing away
859          * the previous results as we go along) it make it easier if the path
860          * starts out as a heap allocated string.
861          */
862         path = strdup(paths[i]);
863         jplis_assert(path != (char*)NULL);
864 
865         /*
866          * The attribute is specified to be a list of relative URIs so in theory
867          * there could be a query component - if so, get rid of it.
868          */
869         pos = strchr(path, &#39;?&#39;);
870         if (pos != NULL) {
871             *pos = &#39;\0&#39;;
872         }
873 
874         /*
875          * Check for characters that are not allowed in the path component of
876          * a URI.
877          */
878         if (validatePathChars(path)) {
879             fprintf(stderr, &quot;WARNING: illegal character in Boot-Class-Path value: %s\n&quot;,
880                path);
881             free(path);
882             continue;
883         }
884 
885 
886         /*
887          * Next decode any escaped characters. The result is a UTF8 string.
888          */
889         TRANSFORM(path, decodePath(path,&amp;len));
890 
891         /*
892          * Convert to the platform encoding
893          */
894         {
895             char platform[MAXPATHLEN];
896             int new_len = convertUft8ToPlatformString(path, len, platform, MAXPATHLEN);
897             free(path);
898             if (new_len  &lt; 0) {
899                 /* bogus value - exceeds maximum path size or unable to convert */
900                 continue;
901             }
902             path = strdup(platform);
903             jplis_assert(path != (char*)NULL);
904         }
905 
906         /*
907          * Post-process the URI path - needed on Windows to transform
908          * /c:/foo to c:/foo.
909          */
910         TRANSFORM(path, fromURIPath(path));
911 
912         /*
913          * Normalize the path - no duplicate slashes (except UNCs on Windows), trailing
914          * slash removed.
915          */
916         TRANSFORM(path, normalize(path));
917 
918         /*
919          * If the path is an absolute path then add to the bootclassloader
920          * search path. Otherwise we get the canonical path of the agent jar
921          * and then use its base path (directory) to resolve the given path
922          * segment.
923          *
924          * NOTE: JVMTI is specified to use modified UTF8 strings (like JNI).
925          * In 1.5.0 the AddToBootstrapClassLoaderSearch takes a platform string
926          * - see 5049313.
927          */
928         if (isAbsolute(path)) {
929             jvmtierr = (*jvmtienv)-&gt;AddToBootstrapClassLoaderSearch(jvmtienv, path);
930         } else {
931             char* resolved;
932 
933             if (!haveBasePath) {
934                 if (JDK_Canonicalize((char*)jarfile, canonicalPath, sizeof(canonicalPath)) != 0) {
935                     fprintf(stderr, &quot;WARNING: unable to canonicalize %s\n&quot;, jarfile);
936                     free(path);
937                     continue;
938                 }
939                 parent = basePath(canonicalPath);
940                 jplis_assert(parent != (char*)NULL);
941                 haveBasePath = 1;
942             }
943 
944             resolved = resolve(parent, path);
945             jvmtierr = (*jvmtienv)-&gt;AddToBootstrapClassLoaderSearch(jvmtienv, resolved);
946         }
947 
948         /* print warning if boot class path not updated */
949         if (jvmtierr != JVMTI_ERROR_NONE) {
950             check_phase_blob_ret(jvmtierr, free(path));
951 
952             fprintf(stderr, &quot;WARNING: %s not added to bootstrap class loader search: &quot;, path);
953             switch (jvmtierr) {
954                 case JVMTI_ERROR_ILLEGAL_ARGUMENT :
955                     fprintf(stderr, &quot;Illegal argument or not JAR file\n&quot;);
956                     break;
957                 default:
958                     fprintf(stderr, &quot;Unexpected error: %d\n&quot;, jvmtierr);
959             }
960         }
961 
962         /* finished with the path */
963         free(path);
964     }
965 
966 
967     /* clean-up */
968     if (haveBasePath &amp;&amp; parent != canonicalPath) {
969         free(parent);
970     }
971 }
    </pre>
  </body>
</html>
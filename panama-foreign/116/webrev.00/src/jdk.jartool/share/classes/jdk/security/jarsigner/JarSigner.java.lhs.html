<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jartool/share/classes/jdk/security/jarsigner/JarSigner.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.security.jarsigner;
  27 
  28 import com.sun.jarsigner.ContentSigner;
  29 import com.sun.jarsigner.ContentSignerParameters;
  30 import sun.security.tools.PathList;
  31 import sun.security.tools.jarsigner.TimestampedSigner;
  32 import sun.security.util.ManifestDigester;
  33 import sun.security.util.SignatureFileVerifier;
  34 import sun.security.x509.AlgorithmId;
  35 
  36 import java.io.*;
<a name="1" id="anc1"></a>
  37 import java.net.SocketTimeoutException;
  38 import java.net.URI;
  39 import java.net.URL;
  40 import java.net.URLClassLoader;
  41 import java.security.*;
  42 import java.security.cert.CertPath;
  43 import java.security.cert.Certificate;
  44 import java.security.cert.CertificateException;
  45 import java.security.cert.X509Certificate;
  46 import java.util.*;
  47 import java.util.function.BiConsumer;
  48 import java.util.jar.Attributes;
  49 import java.util.jar.JarEntry;
  50 import java.util.jar.JarFile;
  51 import java.util.jar.Manifest;
  52 import java.util.zip.ZipEntry;
  53 import java.util.zip.ZipFile;
  54 import java.util.zip.ZipOutputStream;
  55 
  56 /**
  57  * An immutable utility class to sign a jar file.
  58  * &lt;p&gt;
  59  * A caller creates a {@code JarSigner.Builder} object, (optionally) sets
  60  * some parameters, and calls {@link JarSigner.Builder#build build} to create
  61  * a {@code JarSigner} object. This {@code JarSigner} object can then
  62  * be used to sign a jar file.
  63  * &lt;p&gt;
  64  * Unless otherwise stated, calling a method of {@code JarSigner} or
  65  * {@code JarSigner.Builder} with a null argument will throw
  66  * a {@link NullPointerException}.
  67  * &lt;p&gt;
  68  * Example:
  69  * &lt;pre&gt;
  70  * JarSigner signer = new JarSigner.Builder(key, certPath)
  71  *         .digestAlgorithm(&quot;SHA-1&quot;)
  72  *         .signatureAlgorithm(&quot;SHA1withDSA&quot;)
  73  *         .build();
  74  * try (ZipFile in = new ZipFile(inputFile);
  75  *         FileOutputStream out = new FileOutputStream(outputFile)) {
  76  *     signer.sign(in, out);
  77  * }
  78  * &lt;/pre&gt;
  79  *
  80  * @since 9
  81  */
  82 public final class JarSigner {
  83 
  84     /**
  85      * A mutable builder class that can create an immutable {@code JarSigner}
  86      * from various signing-related parameters.
  87      *
  88      * @since 9
  89      */
  90     public static class Builder {
  91 
  92         // Signer materials:
  93         final PrivateKey privateKey;
  94         final X509Certificate[] certChain;
  95 
  96         // JarSigner options:
  97         // Support multiple digestalg internally. Can be null, but not empty
  98         String[] digestalg;
  99         String sigalg;
 100         // Precisely should be one provider for each digestalg, maybe later
 101         Provider digestProvider;
 102         Provider sigProvider;
 103         URI tsaUrl;
 104         String signerName;
 105         BiConsumer&lt;String,String&gt; handler;
 106 
 107         // Implementation-specific properties:
 108         String tSAPolicyID;
 109         String tSADigestAlg;
 110         boolean signManifest = true;
 111         boolean externalSF = true;
 112         String altSignerPath;
 113         String altSigner;
 114 
 115         /**
 116          * Creates a {@code JarSigner.Builder} object with
 117          * a {@link KeyStore.PrivateKeyEntry} object.
 118          *
 119          * @param entry the {@link KeyStore.PrivateKeyEntry} of the signer.
 120          */
 121         public Builder(KeyStore.PrivateKeyEntry entry) {
 122             this.privateKey = entry.getPrivateKey();
 123             try {
 124                 // called internally, no need to clone
 125                 Certificate[] certs = entry.getCertificateChain();
 126                 this.certChain = Arrays.copyOf(certs, certs.length,
 127                         X509Certificate[].class);
 128             } catch (ArrayStoreException ase) {
 129                 // Wrong type, not X509Certificate. Won&#39;t document.
 130                 throw new IllegalArgumentException(
 131                         &quot;Entry does not contain X509Certificate&quot;);
 132             }
 133         }
 134 
 135         /**
 136          * Creates a {@code JarSigner.Builder} object with a private key and
 137          * a certification path.
 138          *
 139          * @param privateKey the private key of the signer.
 140          * @param certPath the certification path of the signer.
 141          * @throws IllegalArgumentException if {@code certPath} is empty, or
 142          *      the {@code privateKey} algorithm does not match the algorithm
 143          *      of the {@code PublicKey} in the end entity certificate
 144          *      (the first certificate in {@code certPath}).
 145          */
 146         public Builder(PrivateKey privateKey, CertPath certPath) {
 147             List&lt;? extends Certificate&gt; certs = certPath.getCertificates();
 148             if (certs.isEmpty()) {
 149                 throw new IllegalArgumentException(&quot;certPath cannot be empty&quot;);
 150             }
 151             if (!privateKey.getAlgorithm().equals
 152                     (certs.get(0).getPublicKey().getAlgorithm())) {
 153                 throw new IllegalArgumentException
 154                         (&quot;private key algorithm does not match &quot; +
 155                                 &quot;algorithm of public key in end entity &quot; +
 156                                 &quot;certificate (the 1st in certPath)&quot;);
 157             }
 158             this.privateKey = privateKey;
 159             try {
 160                 this.certChain = certs.toArray(new X509Certificate[certs.size()]);
 161             } catch (ArrayStoreException ase) {
 162                 // Wrong type, not X509Certificate.
 163                 throw new IllegalArgumentException(
 164                         &quot;Entry does not contain X509Certificate&quot;);
 165             }
 166         }
 167 
 168         /**
 169          * Sets the digest algorithm. If no digest algorithm is specified,
 170          * the default algorithm returned by {@link #getDefaultDigestAlgorithm}
 171          * will be used.
 172          *
 173          * @param algorithm the standard name of the algorithm. See
 174          *      the {@code MessageDigest} section in the &lt;a href=
 175          *      &quot;{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms&quot;&gt;
 176          *      Java Cryptography Architecture Standard Algorithm Name
 177          *      Documentation&lt;/a&gt; for information about standard algorithm names.
 178          * @return the {@code JarSigner.Builder} itself.
 179          * @throws NoSuchAlgorithmException if {@code algorithm} is not available.
 180          */
 181         public Builder digestAlgorithm(String algorithm) throws NoSuchAlgorithmException {
 182             MessageDigest.getInstance(Objects.requireNonNull(algorithm));
 183             this.digestalg = new String[]{algorithm};
 184             this.digestProvider = null;
 185             return this;
 186         }
 187 
 188         /**
 189          * Sets the digest algorithm from the specified provider.
 190          * If no digest algorithm is specified, the default algorithm
 191          * returned by {@link #getDefaultDigestAlgorithm} will be used.
 192          *
 193          * @param algorithm the standard name of the algorithm. See
 194          *      the {@code MessageDigest} section in the &lt;a href=
 195          *      &quot;{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms&quot;&gt;
 196          *      Java Cryptography Architecture Standard Algorithm Name
 197          *      Documentation&lt;/a&gt; for information about standard algorithm names.
 198          * @param provider the provider.
 199          * @return the {@code JarSigner.Builder} itself.
 200          * @throws NoSuchAlgorithmException if {@code algorithm} is not
 201          *      available in the specified provider.
 202          */
 203         public Builder digestAlgorithm(String algorithm, Provider provider)
 204                 throws NoSuchAlgorithmException {
 205             MessageDigest.getInstance(
 206                     Objects.requireNonNull(algorithm),
 207                     Objects.requireNonNull(provider));
 208             this.digestalg = new String[]{algorithm};
 209             this.digestProvider = provider;
 210             return this;
 211         }
 212 
 213         /**
 214          * Sets the signature algorithm. If no signature algorithm
 215          * is specified, the default signature algorithm returned by
 216          * {@link #getDefaultSignatureAlgorithm} for the private key
 217          * will be used.
 218          *
 219          * @param algorithm the standard name of the algorithm. See
 220          *      the {@code Signature} section in the &lt;a href=
 221          *      &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 222          *      Java Cryptography Architecture Standard Algorithm Name
 223          *      Documentation&lt;/a&gt; for information about standard algorithm names.
 224          * @return the {@code JarSigner.Builder} itself.
 225          * @throws NoSuchAlgorithmException if {@code algorithm} is not available.
 226          * @throws IllegalArgumentException if {@code algorithm} is not
 227          *      compatible with the algorithm of the signer&#39;s private key.
 228          */
 229         public Builder signatureAlgorithm(String algorithm)
 230                 throws NoSuchAlgorithmException {
 231             // Check availability
 232             Signature.getInstance(Objects.requireNonNull(algorithm));
 233             AlgorithmId.checkKeyAndSigAlgMatch(
 234                     privateKey.getAlgorithm(), algorithm);
 235             this.sigalg = algorithm;
 236             this.sigProvider = null;
 237             return this;
 238         }
 239 
 240         /**
 241          * Sets the signature algorithm from the specified provider. If no
 242          * signature algorithm is specified, the default signature algorithm
 243          * returned by {@link #getDefaultSignatureAlgorithm} for the private
 244          * key will be used.
 245          *
 246          * @param algorithm the standard name of the algorithm. See
 247          *      the {@code Signature} section in the &lt;a href=
 248          *      &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 249          *      Java Cryptography Architecture Standard Algorithm Name
 250          *      Documentation&lt;/a&gt; for information about standard algorithm names.
 251          * @param provider  the provider.
 252          * @return the {@code JarSigner.Builder} itself.
 253          * @throws NoSuchAlgorithmException if {@code algorithm} is not
 254          *      available in the specified provider.
 255          * @throws IllegalArgumentException if {@code algorithm} is not
 256          *      compatible with the algorithm of the signer&#39;s private key.
 257          */
 258         public Builder signatureAlgorithm(String algorithm, Provider provider)
 259                 throws NoSuchAlgorithmException {
 260             // Check availability
 261             Signature.getInstance(
 262                     Objects.requireNonNull(algorithm),
 263                     Objects.requireNonNull(provider));
 264             AlgorithmId.checkKeyAndSigAlgMatch(
 265                     privateKey.getAlgorithm(), algorithm);
 266             this.sigalg = algorithm;
 267             this.sigProvider = provider;
 268             return this;
 269         }
 270 
 271         /**
 272          * Sets the URI of the Time Stamping Authority (TSA).
 273          *
 274          * @param uri the URI.
 275          * @return the {@code JarSigner.Builder} itself.
 276          */
 277         public Builder tsa(URI uri) {
 278             this.tsaUrl = Objects.requireNonNull(uri);
 279             return this;
 280         }
 281 
 282         /**
 283          * Sets the signer name. The name will be used as the base name for
 284          * the signature files. All lowercase characters will be converted to
 285          * uppercase for signature file names. If a signer name is not
 286          * specified, the string &quot;SIGNER&quot; will be used.
 287          *
 288          * @param name the signer name.
 289          * @return the {@code JarSigner.Builder} itself.
 290          * @throws IllegalArgumentException if {@code name} is empty or has
 291          *      a size bigger than 8, or it contains characters not from the
 292          *      set &quot;a-zA-Z0-9_-&quot;.
 293          */
 294         public Builder signerName(String name) {
 295             if (name.isEmpty() || name.length() &gt; 8) {
 296                 throw new IllegalArgumentException(&quot;Name too long&quot;);
 297             }
 298 
 299             name = name.toUpperCase(Locale.ENGLISH);
 300 
 301             for (int j = 0; j &lt; name.length(); j++) {
 302                 char c = name.charAt(j);
 303                 if (!
 304                         ((c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) ||
 305                                 (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) ||
 306                                 (c == &#39;-&#39;) ||
 307                                 (c == &#39;_&#39;))) {
 308                     throw new IllegalArgumentException(
 309                             &quot;Invalid characters in name&quot;);
 310                 }
 311             }
 312             this.signerName = name;
 313             return this;
 314         }
 315 
 316         /**
 317          * Sets en event handler that will be triggered when a {@link JarEntry}
 318          * is to be added, signed, or updated during the signing process.
 319          * &lt;p&gt;
 320          * The handler can be used to display signing progress. The first
 321          * argument of the handler can be &quot;adding&quot;, &quot;signing&quot;, or &quot;updating&quot;,
 322          * and the second argument is the name of the {@link JarEntry}
 323          * being processed.
 324          *
 325          * @param handler the event handler.
 326          * @return the {@code JarSigner.Builder} itself.
 327          */
 328         public Builder eventHandler(BiConsumer&lt;String,String&gt; handler) {
 329             this.handler = Objects.requireNonNull(handler);
 330             return this;
 331         }
 332 
 333         /**
 334          * Sets an additional implementation-specific property indicated by
 335          * the specified key.
 336          *
 337          * @implNote This implementation supports the following properties:
 338          * &lt;ul&gt;
 339          * &lt;li&gt;&quot;tsaDigestAlg&quot;: algorithm of digest data in the timestamping
 340          * request. The default value is the same as the result of
 341          * {@link #getDefaultDigestAlgorithm}.
 342          * &lt;li&gt;&quot;tsaPolicyId&quot;: TSAPolicyID for Timestamping Authority.
 343          * No default value.
 344          * &lt;li&gt;&quot;internalsf&quot;: &quot;true&quot; if the .SF file is included inside the
 345          * signature block, &quot;false&quot; otherwise. Default &quot;false&quot;.
 346          * &lt;li&gt;&quot;sectionsonly&quot;: &quot;true&quot; if the .SF file only contains the hash
 347          * value for each section of the manifest and not for the whole
 348          * manifest, &quot;false&quot; otherwise. Default &quot;false&quot;.
 349          * &lt;/ul&gt;
 350          * All property names are case-insensitive.
 351          *
 352          * @param key the name of the property.
 353          * @param value the value of the property.
 354          * @return the {@code JarSigner.Builder} itself.
 355          * @throws UnsupportedOperationException if the key is not supported
 356          *      by this implementation.
 357          * @throws IllegalArgumentException if the value is not accepted as
 358          *      a legal value for this key.
 359          */
 360         public Builder setProperty(String key, String value) {
 361             Objects.requireNonNull(key);
 362             Objects.requireNonNull(value);
 363             switch (key.toLowerCase(Locale.US)) {
 364                 case &quot;tsadigestalg&quot;:
 365                     try {
 366                         MessageDigest.getInstance(value);
 367                     } catch (NoSuchAlgorithmException nsae) {
 368                         throw new IllegalArgumentException(
 369                                 &quot;Invalid tsadigestalg&quot;, nsae);
 370                     }
 371                     this.tSADigestAlg = value;
 372                     break;
 373                 case &quot;tsapolicyid&quot;:
 374                     this.tSAPolicyID = value;
 375                     break;
 376                 case &quot;internalsf&quot;:
 377                     switch (value) {
 378                         case &quot;true&quot;:
 379                             externalSF = false;
 380                             break;
 381                         case &quot;false&quot;:
 382                             externalSF = true;
 383                             break;
 384                         default:
 385                             throw new IllegalArgumentException(
 386                                 &quot;Invalid internalsf value&quot;);
 387                     }
 388                     break;
 389                 case &quot;sectionsonly&quot;:
 390                     switch (value) {
 391                         case &quot;true&quot;:
 392                             signManifest = false;
 393                             break;
 394                         case &quot;false&quot;:
 395                             signManifest = true;
 396                             break;
 397                         default:
 398                             throw new IllegalArgumentException(
 399                                 &quot;Invalid signManifest value&quot;);
 400                     }
 401                     break;
 402                 case &quot;altsignerpath&quot;:
 403                     altSignerPath = value;
 404                     break;
 405                 case &quot;altsigner&quot;:
 406                     altSigner = value;
 407                     break;
 408                 default:
 409                     throw new UnsupportedOperationException(
 410                             &quot;Unsupported key &quot; + key);
 411             }
 412             return this;
 413         }
 414 
 415         /**
 416          * Gets the default digest algorithm.
 417          *
 418          * @implNote This implementation returns &quot;SHA-256&quot;. The value may
 419          * change in the future.
 420          *
 421          * @return the default digest algorithm.
 422          */
 423         public static String getDefaultDigestAlgorithm() {
 424             return &quot;SHA-256&quot;;
 425         }
 426 
 427         /**
 428          * Gets the default signature algorithm for a private key.
 429          * For example, SHA256withRSA for a 2048-bit RSA key, and
 430          * SHA384withECDSA for a 384-bit EC key.
 431          *
 432          * @implNote This implementation makes use of comparable strengths
 433          * as defined in Tables 2 and 3 of NIST SP 800-57 Part 1-Rev.4.
 434          * Specifically, if a DSA or RSA key with a key size greater than 7680
 435          * bits, or an EC key with a key size greater than or equal to 512 bits,
 436          * SHA-512 will be used as the hash function for the signature.
 437          * If a DSA or RSA key has a key size greater than 3072 bits, or an
 438          * EC key has a key size greater than or equal to 384 bits, SHA-384 will
 439          * be used. Otherwise, SHA-256 will be used. The value may
 440          * change in the future.
 441          *
 442          * @param key the private key.
 443          * @return the default signature algorithm. Returns null if a default
 444          *      signature algorithm cannot be found. In this case,
 445          *      {@link #signatureAlgorithm} must be called to specify a
 446          *      signature algorithm. Otherwise, the {@link #build} method
 447          *      will throw an {@link IllegalArgumentException}.
 448          */
 449         public static String getDefaultSignatureAlgorithm(PrivateKey key) {
 450             return AlgorithmId.getDefaultSigAlgForKey(Objects.requireNonNull(key));
 451         }
 452 
 453         /**
 454          * Builds a {@code JarSigner} object from the parameters set by the
 455          * setter methods.
 456          * &lt;p&gt;
 457          * This method does not modify internal state of this {@code Builder}
 458          * object and can be called multiple times to generate multiple
 459          * {@code JarSigner} objects. After this method is called, calling
 460          * any method on this {@code Builder} will have no effect on
 461          * the newly built {@code JarSigner} object.
 462          *
 463          * @return the {@code JarSigner} object.
 464          * @throws IllegalArgumentException if a signature algorithm is not
 465          *      set and cannot be derived from the private key using the
 466          *      {@link #getDefaultSignatureAlgorithm} method.
 467          */
 468         public JarSigner build() {
 469             return new JarSigner(this);
 470         }
 471     }
 472 
 473     private static final String META_INF = &quot;META-INF/&quot;;
 474 
 475     // All fields in Builder are duplicated here as final. Those not
 476     // provided but has a default value will be filled with default value.
 477 
 478     // Precisely, a final array field can still be modified if only
 479     // reference is copied, no clone is done because we are concerned about
 480     // casual change instead of malicious attack.
 481 
 482     // Signer materials:
 483     private final PrivateKey privateKey;
 484     private final X509Certificate[] certChain;
 485 
 486     // JarSigner options:
 487     private final String[] digestalg;
 488     private final String sigalg;
 489     private final Provider digestProvider;
 490     private final Provider sigProvider;
 491     private final URI tsaUrl;
 492     private final String signerName;
 493     private final BiConsumer&lt;String,String&gt; handler;
 494 
 495     // Implementation-specific properties:
 496     private final String tSAPolicyID;
 497     private final String tSADigestAlg;
 498     private final boolean signManifest; // &quot;sign&quot; the whole manifest
 499     private final boolean externalSF; // leave the .SF out of the PKCS7 block
 500     private final String altSignerPath;
 501     private final String altSigner;
 502 
 503     private JarSigner(JarSigner.Builder builder) {
 504 
 505         this.privateKey = builder.privateKey;
 506         this.certChain = builder.certChain;
 507         if (builder.digestalg != null) {
 508             // No need to clone because builder only accepts one alg now
 509             this.digestalg = builder.digestalg;
 510         } else {
 511             this.digestalg = new String[] {
 512                     Builder.getDefaultDigestAlgorithm() };
 513         }
 514         this.digestProvider = builder.digestProvider;
 515         if (builder.sigalg != null) {
 516             this.sigalg = builder.sigalg;
 517         } else {
 518             this.sigalg = JarSigner.Builder
 519                     .getDefaultSignatureAlgorithm(privateKey);
 520             if (this.sigalg == null) {
 521                 throw new IllegalArgumentException(
 522                         &quot;No signature alg for &quot; + privateKey.getAlgorithm());
 523             }
 524         }
 525         this.sigProvider = builder.sigProvider;
 526         this.tsaUrl = builder.tsaUrl;
 527 
 528         if (builder.signerName == null) {
 529             this.signerName = &quot;SIGNER&quot;;
 530         } else {
 531             this.signerName = builder.signerName;
 532         }
 533         this.handler = builder.handler;
 534 
 535         if (builder.tSADigestAlg != null) {
 536             this.tSADigestAlg = builder.tSADigestAlg;
 537         } else {
 538             this.tSADigestAlg = Builder.getDefaultDigestAlgorithm();
 539         }
 540         this.tSAPolicyID = builder.tSAPolicyID;
 541         this.signManifest = builder.signManifest;
 542         this.externalSF = builder.externalSF;
 543         this.altSigner = builder.altSigner;
 544         this.altSignerPath = builder.altSignerPath;
 545     }
 546 
 547     /**
 548      * Signs a file into an {@link OutputStream}. This method will not close
 549      * {@code file} or {@code os}.
 550      * &lt;p&gt;
 551      * If an I/O error or signing error occurs during the signing, then it may
 552      * do so after some bytes have been written. Consequently, the output
 553      * stream may be in an inconsistent state. It is strongly recommended that
 554      * it be promptly closed in this case.
 555      *
 556      * @param file the file to sign.
 557      * @param os the output stream.
 558      * @throws JarSignerException if the signing fails.
 559      */
 560     public void sign(ZipFile file, OutputStream os) {
 561         try {
 562             sign0(Objects.requireNonNull(file),
 563                     Objects.requireNonNull(os));
 564         } catch (SocketTimeoutException | CertificateException e) {
 565             // CertificateException is thrown when the received cert from TSA
 566             // has no id-kp-timeStamping in its Extended Key Usages extension.
 567             throw new JarSignerException(&quot;Error applying timestamp&quot;, e);
 568         } catch (IOException ioe) {
 569             throw new JarSignerException(&quot;I/O error&quot;, ioe);
 570         } catch (NoSuchAlgorithmException | InvalidKeyException e) {
 571             throw new JarSignerException(&quot;Error in signer materials&quot;, e);
 572         } catch (SignatureException se) {
 573             throw new JarSignerException(&quot;Error creating signature&quot;, se);
 574         }
 575     }
 576 
 577     /**
 578      * Returns the digest algorithm for this {@code JarSigner}.
 579      * &lt;p&gt;
 580      * The return value is never null.
 581      *
 582      * @return the digest algorithm.
 583      */
 584     public String getDigestAlgorithm() {
 585         return digestalg[0];
 586     }
 587 
 588     /**
 589      * Returns the signature algorithm for this {@code JarSigner}.
 590      * &lt;p&gt;
 591      * The return value is never null.
 592      *
 593      * @return the signature algorithm.
 594      */
 595     public String getSignatureAlgorithm() {
 596         return sigalg;
 597     }
 598 
 599     /**
 600      * Returns the URI of the Time Stamping Authority (TSA).
 601      *
 602      * @return the URI of the TSA.
 603      */
 604     public URI getTsa() {
 605         return tsaUrl;
 606     }
 607 
 608     /**
 609      * Returns the signer name of this {@code JarSigner}.
 610      * &lt;p&gt;
 611      * The return value is never null.
 612      *
 613      * @return the signer name.
 614      */
 615     public String getSignerName() {
 616         return signerName;
 617     }
 618 
 619     /**
 620      * Returns the value of an additional implementation-specific property
 621      * indicated by the specified key. If a property is not set but has a
 622      * default value, the default value will be returned.
 623      *
 624      * @implNote See {@link JarSigner.Builder#setProperty} for a list of
 625      * properties this implementation supports. All property names are
 626      * case-insensitive.
 627      *
 628      * @param key the name of the property.
 629      * @return the value for the property.
 630      * @throws UnsupportedOperationException if the key is not supported
 631      *      by this implementation.
 632      */
 633     public String getProperty(String key) {
 634         Objects.requireNonNull(key);
 635         switch (key.toLowerCase(Locale.US)) {
 636             case &quot;tsadigestalg&quot;:
 637                 return tSADigestAlg;
 638             case &quot;tsapolicyid&quot;:
 639                 return tSAPolicyID;
 640             case &quot;internalsf&quot;:
 641                 return Boolean.toString(!externalSF);
 642             case &quot;sectionsonly&quot;:
 643                 return Boolean.toString(!signManifest);
 644             case &quot;altsignerpath&quot;:
 645                 return altSignerPath;
 646             case &quot;altsigner&quot;:
 647                 return altSigner;
 648             default:
 649                 throw new UnsupportedOperationException(
 650                         &quot;Unsupported key &quot; + key);
 651         }
 652     }
 653 
 654     private void sign0(ZipFile zipFile, OutputStream os)
 655             throws IOException, CertificateException, NoSuchAlgorithmException,
 656             SignatureException, InvalidKeyException {
 657         MessageDigest[] digests;
 658         try {
 659             digests = new MessageDigest[digestalg.length];
 660             for (int i = 0; i &lt; digestalg.length; i++) {
 661                 if (digestProvider == null) {
 662                     digests[i] = MessageDigest.getInstance(digestalg[i]);
 663                 } else {
 664                     digests[i] = MessageDigest.getInstance(
 665                             digestalg[i], digestProvider);
 666                 }
 667             }
 668         } catch (NoSuchAlgorithmException asae) {
 669             // Should not happen. User provided alg were checked, and default
 670             // alg should always be available.
 671             throw new AssertionError(asae);
 672         }
 673 
 674         ZipOutputStream zos = new ZipOutputStream(os);
 675 
 676         Manifest manifest = new Manifest();
 677         byte[] mfRawBytes = null;
 678 
 679         // Check if manifest exists
 680         ZipEntry mfFile = getManifestFile(zipFile);
 681         boolean mfCreated = mfFile == null;
 682         if (!mfCreated) {
 683             // Manifest exists. Read its raw bytes.
 684             mfRawBytes = zipFile.getInputStream(mfFile).readAllBytes();
 685             manifest.read(new ByteArrayInputStream(mfRawBytes));
 686         } else {
 687             // Create new manifest
 688             Attributes mattr = manifest.getMainAttributes();
 689             mattr.putValue(Attributes.Name.MANIFEST_VERSION.toString(),
 690                     &quot;1.0&quot;);
 691             String javaVendor = System.getProperty(&quot;java.vendor&quot;);
 692             String jdkVersion = System.getProperty(&quot;java.version&quot;);
 693             mattr.putValue(&quot;Created-By&quot;, jdkVersion + &quot; (&quot; + javaVendor
 694                     + &quot;)&quot;);
 695             mfFile = new ZipEntry(JarFile.MANIFEST_NAME);
 696         }
 697 
 698         /*
 699          * For each entry in jar
 700          * (except for signature-related META-INF entries),
 701          * do the following:
 702          *
 703          * - if entry is not contained in manifest, add it to manifest;
 704          * - if entry is contained in manifest, calculate its hash and
 705          *   compare it with the one in the manifest; if they are
 706          *   different, replace the hash in the manifest with the newly
 707          *   generated one. (This may invalidate existing signatures!)
 708          */
 709         Vector&lt;ZipEntry&gt; mfFiles = new Vector&lt;&gt;();
 710 
 711         boolean wasSigned = false;
 712 
 713         for (Enumeration&lt;? extends ZipEntry&gt; enum_ = zipFile.entries();
 714              enum_.hasMoreElements(); ) {
 715             ZipEntry ze = enum_.nextElement();
 716 
 717             if (ze.getName().startsWith(META_INF)) {
 718                 // Store META-INF files in vector, so they can be written
 719                 // out first
 720                 mfFiles.addElement(ze);
 721 
 722                 String zeNameUp = ze.getName().toUpperCase(Locale.ENGLISH);
 723                 if (SignatureFileVerifier.isBlockOrSF(zeNameUp)
 724                     // no need to preserve binary manifest portions
 725                     // if the only existing signature will be replaced
 726                         &amp;&amp; !zeNameUp.startsWith(SignatureFile
 727                             .getBaseSignatureFilesName(signerName))) {
 728                     wasSigned = true;
 729                 }
 730 
 731                 if (SignatureFileVerifier.isSigningRelated(ze.getName())) {
 732                     // ignore signature-related and manifest files
 733                     continue;
 734                 }
 735             }
 736 
 737             if (manifest.getAttributes(ze.getName()) != null) {
 738                 // jar entry is contained in manifest, check and
 739                 // possibly update its digest attributes
 740                 updateDigests(ze, zipFile, digests, manifest);
 741             } else if (!ze.isDirectory()) {
 742                 // Add entry to manifest
 743                 Attributes attrs = getDigestAttributes(ze, zipFile, digests);
 744                 manifest.getEntries().put(ze.getName(), attrs);
 745             }
 746         }
 747 
 748         /*
 749          * Note:
 750          *
 751          * The Attributes object is based on HashMap and can handle
 752          * continuation lines. Therefore, even if the contents are not changed
 753          * (in a Map view), the bytes that it write() may be different from
 754          * the original bytes that it read() from. Since the signature is
 755          * based on raw bytes, we must retain the exact bytes.
 756          */
 757         boolean mfModified;
 758         ByteArrayOutputStream baos = new ByteArrayOutputStream();
 759         if (mfCreated || !wasSigned) {
 760             mfModified = true;
 761             manifest.write(baos);
 762             mfRawBytes = baos.toByteArray();
 763         } else {
 764 
 765             // the manifest before updating
 766             Manifest oldManifest = new Manifest(
 767                     new ByteArrayInputStream(mfRawBytes));
 768             mfModified = !oldManifest.equals(manifest);
 769             if (!mfModified) {
 770                 // leave whole manifest (mfRawBytes) unmodified
 771             } else {
 772                 // reproduce the manifest raw bytes for unmodified sections
 773                 manifest.write(baos);
 774                 byte[] mfNewRawBytes = baos.toByteArray();
 775                 baos.reset();
 776 
 777                 ManifestDigester oldMd = new ManifestDigester(mfRawBytes);
 778                 ManifestDigester newMd = new ManifestDigester(mfNewRawBytes);
 779 
 780                 // main attributes
 781                 if (manifest.getMainAttributes().equals(
 782                         oldManifest.getMainAttributes())
 783                         &amp;&amp; (manifest.getEntries().isEmpty() ||
 784                             oldMd.getMainAttsEntry().isProperlyDelimited())) {
 785                     oldMd.getMainAttsEntry().reproduceRaw(baos);
 786                 } else {
 787                     newMd.getMainAttsEntry().reproduceRaw(baos);
 788                 }
 789 
 790                 // individual sections
 791                 for (Map.Entry&lt;String,Attributes&gt; entry :
 792                         manifest.getEntries().entrySet()) {
 793                     String sectionName = entry.getKey();
 794                     Attributes entryAtts = entry.getValue();
 795                     if (entryAtts.equals(oldManifest.getAttributes(sectionName))
 796                             &amp;&amp; oldMd.get(sectionName).isProperlyDelimited()) {
 797                         oldMd.get(sectionName).reproduceRaw(baos);
 798                     } else {
 799                         newMd.get(sectionName).reproduceRaw(baos);
 800                     }
 801                 }
 802 
 803                 mfRawBytes = baos.toByteArray();
 804             }
 805         }
 806 
 807         // Write out the manifest
 808         if (mfModified) {
 809             // manifest file has new length
 810             mfFile = new ZipEntry(JarFile.MANIFEST_NAME);
 811         }
 812         if (handler != null) {
 813             if (mfCreated || !mfModified) {
 814                 handler.accept(&quot;adding&quot;, mfFile.getName());
 815             } else {
 816                 handler.accept(&quot;updating&quot;, mfFile.getName());
 817             }
 818         }
 819         zos.putNextEntry(mfFile);
 820         zos.write(mfRawBytes);
 821 
 822         // Calculate SignatureFile (&quot;.SF&quot;) and SignatureBlockFile
 823         ManifestDigester manDig = new ManifestDigester(mfRawBytes);
 824         SignatureFile sf = new SignatureFile(digests, manifest, manDig,
 825                 signerName, signManifest);
 826 
 827         byte[] block;
 828 
 829         Signature signer;
 830         if (sigProvider == null ) {
 831             signer = Signature.getInstance(sigalg);
 832         } else {
 833             signer = Signature.getInstance(sigalg, sigProvider);
 834         }
 835         signer.initSign(privateKey);
 836 
 837         baos.reset();
 838         sf.write(baos);
 839         byte[] content = baos.toByteArray();
 840 
 841         signer.update(content);
 842         byte[] signature = signer.sign();
 843 
<a name="2" id="anc2"></a><span class="line-modified"> 844         @SuppressWarnings(&quot;deprecation&quot;)</span>
 845         ContentSigner signingMechanism = null;
 846         if (altSigner != null) {
 847             signingMechanism = loadSigningMechanism(altSigner,
 848                     altSignerPath);
 849         }
 850 
<a name="3" id="anc3"></a><span class="line-modified"> 851         @SuppressWarnings(&quot;deprecation&quot;)</span>
 852         ContentSignerParameters params =
 853                 new JarSignerParameters(null, tsaUrl, tSAPolicyID,
 854                         tSADigestAlg, signature,
 855                         signer.getAlgorithm(), certChain, content, zipFile);
 856         block = sf.generateBlock(params, externalSF, signingMechanism);
 857 
 858         String sfFilename = sf.getMetaName();
 859         String bkFilename = sf.getBlockName(privateKey);
 860 
 861         ZipEntry sfFile = new ZipEntry(sfFilename);
 862         ZipEntry bkFile = new ZipEntry(bkFilename);
 863 
 864         long time = System.currentTimeMillis();
 865         sfFile.setTime(time);
 866         bkFile.setTime(time);
 867 
 868         // signature file
 869         zos.putNextEntry(sfFile);
 870         sf.write(zos);
 871 
 872         if (handler != null) {
 873             if (zipFile.getEntry(sfFilename) != null) {
 874                 handler.accept(&quot;updating&quot;, sfFilename);
 875             } else {
 876                 handler.accept(&quot;adding&quot;, sfFilename);
 877             }
 878         }
 879 
 880         // signature block file
 881         zos.putNextEntry(bkFile);
 882         zos.write(block);
 883 
 884         if (handler != null) {
 885             if (zipFile.getEntry(bkFilename) != null) {
 886                 handler.accept(&quot;updating&quot;, bkFilename);
 887             } else {
 888                 handler.accept(&quot;adding&quot;, bkFilename);
 889             }
 890         }
 891 
 892         // Write out all other META-INF files that we stored in the
 893         // vector
 894         for (int i = 0; i &lt; mfFiles.size(); i++) {
 895             ZipEntry ze = mfFiles.elementAt(i);
 896             if (!ze.getName().equalsIgnoreCase(JarFile.MANIFEST_NAME)
 897                     &amp;&amp; !ze.getName().equalsIgnoreCase(sfFilename)
 898                     &amp;&amp; !ze.getName().equalsIgnoreCase(bkFilename)) {
 899                 if (ze.getName().startsWith(SignatureFile
 900                         .getBaseSignatureFilesName(signerName))
 901                         &amp;&amp; SignatureFileVerifier.isBlockOrSF(ze.getName())) {
 902                     if (handler != null) {
 903                         handler.accept(&quot;updating&quot;, ze.getName());
 904                     }
 905                     continue;
 906                 }
 907                 if (handler != null) {
 908                     if (manifest.getAttributes(ze.getName()) != null) {
 909                         handler.accept(&quot;signing&quot;, ze.getName());
 910                     } else if (!ze.isDirectory()) {
 911                         handler.accept(&quot;adding&quot;, ze.getName());
 912                     }
 913                 }
 914                 writeEntry(zipFile, zos, ze);
 915             }
 916         }
 917 
 918         // Write out all other files
 919         for (Enumeration&lt;? extends ZipEntry&gt; enum_ = zipFile.entries();
 920              enum_.hasMoreElements(); ) {
 921             ZipEntry ze = enum_.nextElement();
 922 
 923             if (!ze.getName().startsWith(META_INF)) {
 924                 if (handler != null) {
 925                     if (manifest.getAttributes(ze.getName()) != null) {
 926                         handler.accept(&quot;signing&quot;, ze.getName());
 927                     } else {
 928                         handler.accept(&quot;adding&quot;, ze.getName());
 929                     }
 930                 }
 931                 writeEntry(zipFile, zos, ze);
 932             }
 933         }
 934         zipFile.close();
 935         zos.close();
 936     }
 937 
 938     private void writeEntry(ZipFile zf, ZipOutputStream os, ZipEntry ze)
 939             throws IOException {
 940         ZipEntry ze2 = new ZipEntry(ze.getName());
 941         ze2.setMethod(ze.getMethod());
 942         ze2.setTime(ze.getTime());
 943         ze2.setComment(ze.getComment());
 944         ze2.setExtra(ze.getExtra());
 945         if (ze.getMethod() == ZipEntry.STORED) {
 946             ze2.setSize(ze.getSize());
 947             ze2.setCrc(ze.getCrc());
 948         }
 949         os.putNextEntry(ze2);
 950         writeBytes(zf, ze, os);
 951     }
 952 
 953     private void writeBytes
 954             (ZipFile zf, ZipEntry ze, ZipOutputStream os) throws IOException {
 955         try (InputStream is = zf.getInputStream(ze)) {
 956             is.transferTo(os);
 957         }
 958     }
 959 
 960     private void updateDigests(ZipEntry ze, ZipFile zf,
 961                                   MessageDigest[] digests,
 962                                   Manifest mf) throws IOException {
 963         Attributes attrs = mf.getAttributes(ze.getName());
 964         String[] base64Digests = getDigests(ze, zf, digests);
 965 
 966         for (int i = 0; i &lt; digests.length; i++) {
 967             // The entry name to be written into attrs
 968             String name = null;
 969             try {
 970                 // Find if the digest already exists. An algorithm could have
 971                 // different names. For example, last time it was SHA, and this
 972                 // time it&#39;s SHA-1.
 973                 AlgorithmId aid = AlgorithmId.get(digests[i].getAlgorithm());
 974                 for (Object key : attrs.keySet()) {
 975                     if (key instanceof Attributes.Name) {
 976                         String n = key.toString();
 977                         if (n.toUpperCase(Locale.ENGLISH).endsWith(&quot;-DIGEST&quot;)) {
 978                             String tmp = n.substring(0, n.length() - 7);
 979                             if (AlgorithmId.get(tmp).equals(aid)) {
 980                                 name = n;
 981                                 break;
 982                             }
 983                         }
 984                     }
 985                 }
 986             } catch (NoSuchAlgorithmException nsae) {
 987                 // Ignored. Writing new digest entry.
 988             }
 989 
 990             if (name == null) {
 991                 name = digests[i].getAlgorithm() + &quot;-Digest&quot;;
 992             }
 993             attrs.putValue(name, base64Digests[i]);
 994         }
 995     }
 996 
 997     private Attributes getDigestAttributes(
 998             ZipEntry ze, ZipFile zf, MessageDigest[] digests)
 999             throws IOException {
1000 
1001         String[] base64Digests = getDigests(ze, zf, digests);
1002         Attributes attrs = new Attributes();
1003 
1004         for (int i = 0; i &lt; digests.length; i++) {
1005             attrs.putValue(digests[i].getAlgorithm() + &quot;-Digest&quot;,
1006                     base64Digests[i]);
1007         }
1008         return attrs;
1009     }
1010 
1011     /*
1012      * Returns manifest entry from given jar file, or null if given jar file
1013      * does not have a manifest entry.
1014      */
1015     private ZipEntry getManifestFile(ZipFile zf) {
1016         ZipEntry ze = zf.getEntry(JarFile.MANIFEST_NAME);
1017         if (ze == null) {
1018             // Check all entries for matching name
1019             Enumeration&lt;? extends ZipEntry&gt; enum_ = zf.entries();
1020             while (enum_.hasMoreElements() &amp;&amp; ze == null) {
1021                 ze = enum_.nextElement();
1022                 if (!JarFile.MANIFEST_NAME.equalsIgnoreCase
1023                         (ze.getName())) {
1024                     ze = null;
1025                 }
1026             }
1027         }
1028         return ze;
1029     }
1030 
1031     private String[] getDigests(
1032             ZipEntry ze, ZipFile zf, MessageDigest[] digests)
1033             throws IOException {
1034 
1035         int n, i;
1036         try (InputStream is = zf.getInputStream(ze)) {
1037             long left = ze.getSize();
1038             byte[] buffer = new byte[8192];
1039             while ((left &gt; 0)
1040                     &amp;&amp; (n = is.read(buffer, 0, buffer.length)) != -1) {
1041                 for (i = 0; i &lt; digests.length; i++) {
1042                     digests[i].update(buffer, 0, n);
1043                 }
1044                 left -= n;
1045             }
1046         }
1047 
1048         // complete the digests
1049         String[] base64Digests = new String[digests.length];
1050         for (i = 0; i &lt; digests.length; i++) {
1051             base64Digests[i] = Base64.getEncoder()
1052                     .encodeToString(digests[i].digest());
1053         }
1054         return base64Digests;
1055     }
1056 
1057     /*
1058      * Try to load the specified signing mechanism.
1059      * The URL class loader is used.
1060      */
<a name="4" id="anc4"></a><span class="line-modified">1061     @SuppressWarnings(&quot;deprecation&quot;)</span>
1062     private ContentSigner loadSigningMechanism(String signerClassName,
1063                                                String signerClassPath) {
1064 
<a name="5" id="anc5"></a>




1065         // construct class loader
1066         String cpString;   // make sure env.class.path defaults to dot
1067 
1068         // do prepends to get correct ordering
1069         cpString = PathList.appendPath(
1070                 System.getProperty(&quot;env.class.path&quot;), null);
1071         cpString = PathList.appendPath(
1072                 System.getProperty(&quot;java.class.path&quot;), cpString);
1073         cpString = PathList.appendPath(signerClassPath, cpString);
1074         URL[] urls = PathList.pathToURLs(cpString);
1075         ClassLoader appClassLoader = new URLClassLoader(urls);
1076 
1077         try {
1078             // attempt to find signer
1079             Class&lt;?&gt; signerClass = appClassLoader.loadClass(signerClassName);
<a name="6" id="anc6"></a><span class="line-modified">1080             Object signer = signerClass.newInstance();</span>
1081             return (ContentSigner) signer;
1082         } catch (ClassNotFoundException|InstantiationException|
<a name="7" id="anc7"></a><span class="line-modified">1083                 IllegalAccessException|ClassCastException e) {</span>

1084             throw new IllegalArgumentException(
1085                     &quot;Invalid altSigner or altSignerPath&quot;, e);
1086         }
1087     }
1088 
1089     static class SignatureFile {
1090 
1091         /**
1092          * SignatureFile
1093          */
1094         Manifest sf;
1095 
1096         /**
1097          * .SF base name
1098          */
1099         String baseName;
1100 
1101         public SignatureFile(MessageDigest digests[],
1102                              Manifest mf,
1103                              ManifestDigester md,
1104                              String baseName,
1105                              boolean signManifest) {
1106 
1107             this.baseName = baseName;
1108 
1109             String version = System.getProperty(&quot;java.version&quot;);
1110             String javaVendor = System.getProperty(&quot;java.vendor&quot;);
1111 
1112             sf = new Manifest();
1113             Attributes mattr = sf.getMainAttributes();
1114 
1115             mattr.putValue(Attributes.Name.SIGNATURE_VERSION.toString(), &quot;1.0&quot;);
1116             mattr.putValue(&quot;Created-By&quot;, version + &quot; (&quot; + javaVendor + &quot;)&quot;);
1117 
1118             if (signManifest) {
1119                 for (MessageDigest digest: digests) {
1120                     mattr.putValue(digest.getAlgorithm() + &quot;-Digest-Manifest&quot;,
1121                             Base64.getEncoder().encodeToString(
1122                                     md.manifestDigest(digest)));
1123                 }
1124             }
1125 
1126             // create digest of the manifest main attributes
1127             ManifestDigester.Entry mde = md.getMainAttsEntry(false);
1128             if (mde != null) {
1129                 for (MessageDigest digest : digests) {
1130                     mattr.putValue(digest.getAlgorithm() + &quot;-Digest-&quot; +
1131                             ManifestDigester.MF_MAIN_ATTRS,
1132                             Base64.getEncoder().encodeToString(mde.digest(digest)));
1133                 }
1134             } else {
1135                 throw new IllegalStateException
1136                         (&quot;ManifestDigester failed to create &quot; +
1137                                 &quot;Manifest-Main-Attribute entry&quot;);
1138             }
1139 
1140             // go through the manifest entries and create the digests
1141             Map&lt;String, Attributes&gt; entries = sf.getEntries();
1142             for (String name: mf.getEntries().keySet()) {
1143                 mde = md.get(name, false);
1144                 if (mde != null) {
1145                     Attributes attr = new Attributes();
1146                     for (MessageDigest digest: digests) {
1147                         attr.putValue(digest.getAlgorithm() + &quot;-Digest&quot;,
1148                                 Base64.getEncoder().encodeToString(
1149                                         mde.digest(digest)));
1150                     }
1151                     entries.put(name, attr);
1152                 }
1153             }
1154         }
1155 
1156         // Write .SF file
1157         public void write(OutputStream out) throws IOException {
1158             sf.write(out);
1159         }
1160 
1161         private static String getBaseSignatureFilesName(String baseName) {
1162             return &quot;META-INF/&quot; + baseName + &quot;.&quot;;
1163         }
1164 
1165         // get .SF file name
1166         public String getMetaName() {
1167             return getBaseSignatureFilesName(baseName) + &quot;SF&quot;;
1168         }
1169 
1170         // get .DSA (or .DSA, .EC) file name
1171         public String getBlockName(PrivateKey privateKey) {
1172             String keyAlgorithm = privateKey.getAlgorithm();
1173             return getBaseSignatureFilesName(baseName) + keyAlgorithm;
1174         }
1175 
1176         // Generates the PKCS#7 content of block file
<a name="8" id="anc8"></a><span class="line-modified">1177         @SuppressWarnings(&quot;deprecation&quot;)</span>
1178         public byte[] generateBlock(ContentSignerParameters params,
1179                                     boolean externalSF,
1180                                     ContentSigner signingMechanism)
1181                 throws NoSuchAlgorithmException,
1182                        IOException, CertificateException {
1183 
1184             if (signingMechanism == null) {
1185                 signingMechanism = new TimestampedSigner();
1186             }
1187             return signingMechanism.generateSignedData(
1188                     params,
1189                     externalSF,
1190                     params.getTimestampingAuthority() != null
1191                         || params.getTimestampingAuthorityCertificate() != null);
1192         }
1193     }
1194 
<a name="9" id="anc9"></a><span class="line-modified">1195     @SuppressWarnings(&quot;deprecation&quot;)</span>
1196     class JarSignerParameters implements ContentSignerParameters {
1197 
1198         private String[] args;
1199         private URI tsa;
1200         private byte[] signature;
1201         private String signatureAlgorithm;
1202         private X509Certificate[] signerCertificateChain;
1203         private byte[] content;
1204         private ZipFile source;
1205         private String tSAPolicyID;
1206         private String tSADigestAlg;
1207 
1208         JarSignerParameters(String[] args, URI tsa,
1209                             String tSAPolicyID, String tSADigestAlg,
1210                             byte[] signature, String signatureAlgorithm,
1211                             X509Certificate[] signerCertificateChain,
1212                             byte[] content, ZipFile source) {
1213 
1214             Objects.requireNonNull(signature);
1215             Objects.requireNonNull(signatureAlgorithm);
1216             Objects.requireNonNull(signerCertificateChain);
1217 
1218             this.args = args;
1219             this.tsa = tsa;
1220             this.tSAPolicyID = tSAPolicyID;
1221             this.tSADigestAlg = tSADigestAlg;
1222             this.signature = signature;
1223             this.signatureAlgorithm = signatureAlgorithm;
1224             this.signerCertificateChain = signerCertificateChain;
1225             this.content = content;
1226             this.source = source;
1227         }
1228 
1229         public String[] getCommandLine() {
1230             return args;
1231         }
1232 
1233         public URI getTimestampingAuthority() {
1234             return tsa;
1235         }
1236 
1237         public X509Certificate getTimestampingAuthorityCertificate() {
1238             // We don&#39;t use this param. Always provide tsaURI.
1239             return null;
1240         }
1241 
1242         public String getTSAPolicyID() {
1243             return tSAPolicyID;
1244         }
1245 
1246         public String getTSADigestAlg() {
1247             return tSADigestAlg;
1248         }
1249 
1250         public byte[] getSignature() {
1251             return signature;
1252         }
1253 
1254         public String getSignatureAlgorithm() {
1255             return signatureAlgorithm;
1256         }
1257 
1258         public X509Certificate[] getSignerCertificateChain() {
1259             return signerCertificateChain;
1260         }
1261 
1262         public byte[] getContent() {
1263             return content;
1264         }
1265 
1266         public ZipFile getSource() {
1267             return source;
1268         }
1269     }
1270 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
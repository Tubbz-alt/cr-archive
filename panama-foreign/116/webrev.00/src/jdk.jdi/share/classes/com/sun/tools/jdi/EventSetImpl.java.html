<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jdi/share/classes/com/sun/tools/jdi/EventSetImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.jdi;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Collection;
 30 import java.util.Iterator;
 31 import java.util.NoSuchElementException;
 32 import java.util.Spliterator;
 33 import java.util.Spliterators;
 34 
 35 import com.sun.jdi.Field;
 36 import com.sun.jdi.InternalException;
 37 import com.sun.jdi.Locatable;
 38 import com.sun.jdi.Location;
 39 import com.sun.jdi.Method;
 40 import com.sun.jdi.ObjectReference;
 41 import com.sun.jdi.ReferenceType;
 42 import com.sun.jdi.ThreadReference;
 43 import com.sun.jdi.VMDisconnectedException;
 44 import com.sun.jdi.Value;
 45 import com.sun.jdi.VirtualMachine;
 46 import com.sun.jdi.event.AccessWatchpointEvent;
 47 import com.sun.jdi.event.BreakpointEvent;
 48 import com.sun.jdi.event.ClassPrepareEvent;
 49 import com.sun.jdi.event.ClassUnloadEvent;
 50 import com.sun.jdi.event.Event;
 51 import com.sun.jdi.event.EventIterator;
 52 import com.sun.jdi.event.EventSet;
 53 import com.sun.jdi.event.ExceptionEvent;
 54 import com.sun.jdi.event.MethodEntryEvent;
 55 import com.sun.jdi.event.MethodExitEvent;
 56 import com.sun.jdi.event.ModificationWatchpointEvent;
 57 import com.sun.jdi.event.MonitorContendedEnterEvent;
 58 import com.sun.jdi.event.MonitorContendedEnteredEvent;
 59 import com.sun.jdi.event.MonitorWaitEvent;
 60 import com.sun.jdi.event.MonitorWaitedEvent;
 61 import com.sun.jdi.event.StepEvent;
 62 import com.sun.jdi.event.ThreadDeathEvent;
 63 import com.sun.jdi.event.ThreadStartEvent;
 64 import com.sun.jdi.event.VMDeathEvent;
 65 import com.sun.jdi.event.VMDisconnectEvent;
 66 import com.sun.jdi.event.VMStartEvent;
 67 import com.sun.jdi.event.WatchpointEvent;
 68 import com.sun.jdi.request.EventRequest;
 69 
 70 enum EventDestination {UNKNOWN_EVENT, INTERNAL_EVENT, CLIENT_EVENT};
 71 
 72 /*
 73  * An EventSet is normally created by the transport reader thread when
 74  * it reads a JDWP Composite command.  The constructor doesn&#39;t unpack
 75  * the events contained in the Composite command and create EventImpls
 76  * for them because that process might involve calling back into the back-end
 77  * which should not be done by the transport reader thread.  Instead,
 78  * the raw bytes of the packet are read and stored in the EventSet.
 79  * The EventSet is then added to each EventQueue. When an EventSet is
 80  * removed from an EventQueue, the EventSetImpl.build() method is called.
 81  * This method reads the packet bytes and creates the actual EventImpl objects.
 82  * build() also filters out events for our internal handler and puts them in
 83  * their own EventSet.  This means that the EventImpls that are in the EventSet
 84  * that is on the queues are all for client requests.
 85  */
 86 public class EventSetImpl extends ArrayList&lt;Event&gt; implements EventSet {
 87     private static final long serialVersionUID = -4857338819787924570L;
 88     private VirtualMachineImpl vm; // we implement Mirror
 89     private Packet pkt;
 90     private byte suspendPolicy;
 91     private EventSetImpl internalEventSet;
 92 
 93     public String toString() {
 94         String string = &quot;event set, policy:&quot; + suspendPolicy +
 95                         &quot;, count:&quot; + this.size() + &quot; = {&quot;;
 96         boolean first = true;
 97         for (Event event : this) {
 98             if (!first) {
 99                 string += &quot;, &quot;;
100             }
101             string += event.toString();
102             first = false;
103         }
104         string += &quot;}&quot;;
105         return string;
106     }
107 
108     abstract class EventImpl extends MirrorImpl implements Event {
109 
110         private final byte eventCmd;
111         private final int requestID;
112         // This is set only for client requests, not internal requests.
113         private final EventRequest request;
114 
115         /**
116          * Constructor for events.
117          */
118         protected EventImpl(JDWP.Event.Composite.Events.EventsCommon evt,
119                             int requestID) {
120             super(EventSetImpl.this.vm);
121             this.eventCmd = evt.eventKind();
122             this.requestID = requestID;
123             EventRequestManagerImpl ermi = EventSetImpl.this.
124                 vm.eventRequestManagerImpl();
125             this.request =  ermi.request(eventCmd, requestID);
126         }
127 
128         /*
129          * Override superclass back to default equality
130          */
131         public boolean equals(Object obj) {
132             return this == obj;
133         }
134 
135         public int hashCode() {
136             return System.identityHashCode(this);
137         }
138 
139         /**
140          * Constructor for VM disconnected events.
141          */
142         protected EventImpl(byte eventCmd) {
143             super(EventSetImpl.this.vm);
144             this.eventCmd = eventCmd;
145             this.requestID = 0;
146             this.request = null;
147         }
148 
149         public EventRequest request() {
150             return request;
151         }
152 
153         int requestID() {
154             return requestID;
155         }
156 
157         EventDestination destination() {
158             /*
159              * We need to decide if this event is for
160              * 1. an internal request
161              * 2. a client request that is no longer available, ie
162              *    it has been deleted, or disabled and re-enabled
163              *    which gives it a new ID.
164              * 3. a current client request that is disabled
165              * 4. a current enabled client request.
166              *
167              * We will filter this set into a set
168              * that contains only 1s for our internal queue
169              * and a set that contains only 4s for our client queue.
170              * If we get an EventSet that contains only 2 and 3
171              * then we have to resume it if it is not SUSPEND_NONE
172              * because no one else will.
173              */
174             if (requestID == 0) {
175                 /* An unsolicited event.  These have traditionally
176                  * been treated as client events.
177                  */
178                 return EventDestination.CLIENT_EVENT;
179             }
180 
181             // Is this an event for a current client request?
182             if (request == null) {
183                 // Nope.  Is it an event for an internal request?
184                 EventRequestManagerImpl ermi = this.vm.getInternalEventRequestManager();
185                 if (ermi.request(eventCmd, requestID) != null) {
186                     // Yep
187                     return EventDestination.INTERNAL_EVENT;
188                 }
189                 return EventDestination.UNKNOWN_EVENT;
190             }
191 
192             // We found a client request
193             if (request.isEnabled()) {
194                 return EventDestination.CLIENT_EVENT;
195             }
196             return EventDestination.UNKNOWN_EVENT;
197         }
198 
199         abstract String eventName();
200 
201         public String toString() {
202             return eventName();
203         }
204 
205     }
206 
207     abstract class ThreadedEventImpl extends EventImpl {
208         private ThreadReference thread;
209 
210         ThreadedEventImpl(JDWP.Event.Composite.Events.EventsCommon evt,
211                           int requestID, ThreadReference thread) {
212             super(evt, requestID);
213             this.thread = thread;
214         }
215 
216         public ThreadReference thread() {
217             return thread;
218         }
219 
220         public String toString() {
221             return eventName() + &quot; in thread &quot; + thread.name();
222         }
223     }
224 
225     abstract class LocatableEventImpl extends ThreadedEventImpl
226                                       implements Locatable {
227         private Location location;
228 
229         LocatableEventImpl(JDWP.Event.Composite.Events.EventsCommon evt,
230                            int requestID,
231                            ThreadReference thread, Location location) {
232             super(evt, requestID, thread);
233             this.location = location;
234         }
235 
236         public Location location() {
237             return location;
238         }
239 
240         /**
241          * For MethodEntry and MethodExit
242          */
243         public Method method() {
244             return location.method();
245         }
246 
247         public String toString() {
248             return eventName() + &quot;@&quot; +
249                    ((location() == null) ? &quot; null&quot; : location().toString()) +
250                    &quot; in thread &quot; + thread().name();
251         }
252     }
253 
254     class BreakpointEventImpl extends LocatableEventImpl
255                               implements BreakpointEvent {
256         BreakpointEventImpl(JDWP.Event.Composite.Events.Breakpoint evt) {
257             super(evt, evt.requestID, evt.thread, evt.location);
258         }
259 
260         String eventName() {
261             return &quot;BreakpointEvent&quot;;
262         }
263     }
264 
265     class StepEventImpl extends LocatableEventImpl implements StepEvent {
266         StepEventImpl(JDWP.Event.Composite.Events.SingleStep evt) {
267             super(evt, evt.requestID, evt.thread, evt.location);
268         }
269 
270         String eventName() {
271             return &quot;StepEvent&quot;;
272         }
273     }
274 
275     class MethodEntryEventImpl extends LocatableEventImpl
276                                implements MethodEntryEvent {
277         MethodEntryEventImpl(JDWP.Event.Composite.Events.MethodEntry evt) {
278             super(evt, evt.requestID, evt.thread, evt.location);
279         }
280 
281         String eventName() {
282             return &quot;MethodEntryEvent&quot;;
283         }
284     }
285 
286     class MethodExitEventImpl extends LocatableEventImpl
287                             implements MethodExitEvent {
288         private Value returnVal = null;
289 
290         MethodExitEventImpl(JDWP.Event.Composite.Events.MethodExit evt) {
291             super(evt, evt.requestID, evt.thread, evt.location);
292         }
293 
294         MethodExitEventImpl(JDWP.Event.Composite.Events.MethodExitWithReturnValue evt) {
295             super(evt, evt.requestID, evt.thread, evt.location);
296             returnVal = evt.value;
297         }
298 
299         String eventName() {
300             return &quot;MethodExitEvent&quot;;
301         }
302 
303         public Value returnValue() {
304             if (!this.vm.canGetMethodReturnValues()) {
305                 throw new UnsupportedOperationException(
306                 &quot;target does not support return values in MethodExit events&quot;);
307             }
308             return returnVal;
309         }
310 
311     }
312 
313     class MonitorContendedEnterEventImpl extends LocatableEventImpl
314                             implements MonitorContendedEnterEvent {
315         private ObjectReference monitor = null;
316 
317         MonitorContendedEnterEventImpl(JDWP.Event.Composite.Events.MonitorContendedEnter evt) {
318             super(evt, evt.requestID, evt.thread, evt.location);
319             this.monitor = evt.object;
320         }
321 
322         String eventName() {
323             return &quot;MonitorContendedEnter&quot;;
324         }
325 
326         public ObjectReference  monitor() {
327             return monitor;
328         };
329 
330     }
331 
332     class MonitorContendedEnteredEventImpl extends LocatableEventImpl
333                             implements MonitorContendedEnteredEvent {
334         private ObjectReference monitor = null;
335 
336         MonitorContendedEnteredEventImpl(JDWP.Event.Composite.Events.MonitorContendedEntered evt) {
337             super(evt, evt.requestID, evt.thread, evt.location);
338             this.monitor = evt.object;
339         }
340 
341         String eventName() {
342             return &quot;MonitorContendedEntered&quot;;
343         }
344 
345         public ObjectReference  monitor() {
346             return monitor;
347         };
348 
349     }
350 
351     class MonitorWaitEventImpl extends LocatableEventImpl
352                             implements MonitorWaitEvent {
353         private ObjectReference monitor = null;
354         private long timeout;
355 
356         MonitorWaitEventImpl(JDWP.Event.Composite.Events.MonitorWait evt) {
357             super(evt, evt.requestID, evt.thread, evt.location);
358             this.monitor = evt.object;
359             this.timeout = evt.timeout;
360         }
361 
362         String eventName() {
363             return &quot;MonitorWait&quot;;
364         }
365 
366         public ObjectReference  monitor() {
367             return monitor;
368         };
369 
370         public long timeout() {
371             return timeout;
372         }
373     }
374 
375     class MonitorWaitedEventImpl extends LocatableEventImpl
376                             implements MonitorWaitedEvent {
377         private ObjectReference monitor = null;
378         private boolean timed_out;
379 
380         MonitorWaitedEventImpl(JDWP.Event.Composite.Events.MonitorWaited evt) {
381             super(evt, evt.requestID, evt.thread, evt.location);
382             this.monitor = evt.object;
383             this.timed_out = evt.timed_out;
384         }
385 
386         String eventName() {
387             return &quot;MonitorWaited&quot;;
388         }
389 
390         public ObjectReference  monitor() {
391             return monitor;
392         };
393 
394         public boolean timedout() {
395             return timed_out;
396         }
397     }
398 
399     class ClassPrepareEventImpl extends ThreadedEventImpl
400                             implements ClassPrepareEvent {
401         private ReferenceType referenceType;
402 
403         ClassPrepareEventImpl(JDWP.Event.Composite.Events.ClassPrepare evt) {
404             super(evt, evt.requestID, evt.thread);
405             referenceType = this.vm.referenceType(evt.typeID, evt.refTypeTag,
406                                                   evt.signature);
407             ((ReferenceTypeImpl)referenceType).setStatus(evt.status);
408         }
409 
410         public ReferenceType referenceType() {
411             return referenceType;
412         }
413 
414         String eventName() {
415             return &quot;ClassPrepareEvent&quot;;
416         }
417     }
418 
419     class ClassUnloadEventImpl extends EventImpl implements ClassUnloadEvent {
420         private String classSignature;
421 
422         ClassUnloadEventImpl(JDWP.Event.Composite.Events.ClassUnload evt) {
423             super(evt, evt.requestID);
424             this.classSignature = evt.signature;
425         }
426 
427         public String className() {
428             assert classSignature.startsWith(&quot;L&quot;) &amp;&amp; classSignature.endsWith(&quot;;&quot;);
429             return classSignature.substring(1, classSignature.length()-1)
430                 .replace(&#39;/&#39;, &#39;.&#39;);
431         }
432 
433         public String classSignature() {
434             return classSignature;
435         }
436 
437         String eventName() {
438             return &quot;ClassUnloadEvent&quot;;
439         }
440     }
441 
442     class ExceptionEventImpl extends LocatableEventImpl
443                                              implements ExceptionEvent {
444         private ObjectReference exception;
445         private Location catchLocation;
446 
447         ExceptionEventImpl(JDWP.Event.Composite.Events.Exception evt) {
448             super(evt, evt.requestID, evt.thread, evt.location);
449             this.exception = evt.exception;
450             this.catchLocation = evt.catchLocation;
451         }
452 
453         public ObjectReference exception() {
454             return exception;
455         }
456 
457         public Location catchLocation() {
458             return catchLocation;
459         }
460 
461         String eventName() {
462             return &quot;ExceptionEvent&quot;;
463         }
464     }
465 
466     class ThreadDeathEventImpl extends ThreadedEventImpl
467                                         implements ThreadDeathEvent {
468         ThreadDeathEventImpl(JDWP.Event.Composite.Events.ThreadDeath evt) {
469             super(evt, evt.requestID, evt.thread);
470         }
471 
472         String eventName() {
473             return &quot;ThreadDeathEvent&quot;;
474         }
475     }
476 
477     class ThreadStartEventImpl extends ThreadedEventImpl
478                                         implements ThreadStartEvent {
479         ThreadStartEventImpl(JDWP.Event.Composite.Events.ThreadStart evt) {
480             super(evt, evt.requestID, evt.thread);
481         }
482 
483         String eventName() {
484             return &quot;ThreadStartEvent&quot;;
485         }
486     }
487 
488     class VMStartEventImpl extends ThreadedEventImpl
489                                         implements VMStartEvent {
490         VMStartEventImpl(JDWP.Event.Composite.Events.VMStart evt) {
491             super(evt, evt.requestID, evt.thread);
492         }
493 
494         String eventName() {
495             return &quot;VMStartEvent&quot;;
496         }
497     }
498 
499     class VMDeathEventImpl extends EventImpl implements VMDeathEvent {
500 
501         VMDeathEventImpl(JDWP.Event.Composite.Events.VMDeath evt) {
502             super(evt, evt.requestID);
503         }
504 
505         String eventName() {
506             return &quot;VMDeathEvent&quot;;
507         }
508     }
509 
510     class VMDisconnectEventImpl extends EventImpl
511                                          implements VMDisconnectEvent {
512 
513         VMDisconnectEventImpl() {
514             super((byte)JDWP.EventKind.VM_DISCONNECTED);
515         }
516 
517         String eventName() {
518             return &quot;VMDisconnectEvent&quot;;
519         }
520     }
521 
522     abstract class WatchpointEventImpl extends LocatableEventImpl
523                                             implements WatchpointEvent {
524         private final ReferenceTypeImpl refType;
525         private final long fieldID;
526         private final ObjectReference object;
527         private Field field = null;
528 
529         WatchpointEventImpl(JDWP.Event.Composite.Events.EventsCommon evt,
530                             int requestID,
531                             ThreadReference thread, Location location,
532                             byte refTypeTag, long typeID, long fieldID,
533                             ObjectReference object) {
534             super(evt, requestID, thread, location);
535             this.refType = this.vm.referenceType(typeID, refTypeTag);
536             this.fieldID = fieldID;
537             this.object = object;
538         }
539 
540         public Field field() {
541             if (field == null) {
542                 field = refType.getFieldMirror(fieldID);
543             }
544             return field;
545         }
546 
547         public ObjectReference object() {
548             return object;
549         }
550 
551         public Value valueCurrent() {
552             if (object == null) {
553                 return refType.getValue(field());
554             } else {
555                 return object.getValue(field());
556             }
557         }
558     }
559 
560     class AccessWatchpointEventImpl extends WatchpointEventImpl
561                                             implements AccessWatchpointEvent {
562 
563         AccessWatchpointEventImpl(JDWP.Event.Composite.Events.FieldAccess evt) {
564             super(evt, evt.requestID, evt.thread, evt.location,
565                   evt.refTypeTag, evt.typeID, evt.fieldID, evt.object);
566         }
567 
568         String eventName() {
569             return &quot;AccessWatchpoint&quot;;
570         }
571     }
572 
573     class ModificationWatchpointEventImpl extends WatchpointEventImpl
574                            implements ModificationWatchpointEvent {
575         Value newValue;
576 
577         ModificationWatchpointEventImpl(
578                         JDWP.Event.Composite.Events.FieldModification evt) {
579             super(evt, evt.requestID, evt.thread, evt.location,
580                   evt.refTypeTag, evt.typeID, evt.fieldID, evt.object);
581             this.newValue = evt.valueToBe;
582         }
583 
584         public Value valueToBe() {
585             return newValue;
586         }
587 
588         String eventName() {
589             return &quot;ModificationWatchpoint&quot;;
590         }
591     }
592 
593     /**
594      * Events are constructed on the thread which reads all data from the
595      * transport. This means that the packet cannot be converted to real
596      * JDI objects as that may involve further communications with the
597      * back end which would deadlock.
598      *
599      * Hence the {@link #build()} method below called by EventQueue.
600      */
601     EventSetImpl(VirtualMachine aVm, Packet pkt) {
602         super();
603 
604         // From &quot;MirrorImpl&quot;:
605         // Yes, its a bit of a hack. But by doing it this
606         // way, this is the only place we have to change
607         // typing to substitute a new impl.
608         vm = (VirtualMachineImpl)aVm;
609 
610         this.pkt = pkt;
611     }
612 
613     /**
614      * Constructor for special events like VM disconnected
615      */
616     EventSetImpl(VirtualMachine aVm, byte eventCmd) {
617         this(aVm, null);
618         suspendPolicy = JDWP.SuspendPolicy.NONE;
619         switch (eventCmd) {
620             case JDWP.EventKind.VM_DISCONNECTED:
621                 addEvent(new VMDisconnectEventImpl());
622                 break;
623 
624             default:
625                 throw new InternalException(&quot;Bad singleton event code&quot;);
626         }
627     }
628 
629     private void addEvent(EventImpl evt) {
630         // Note that this class has a public add method that throws
631         // an exception so that clients can&#39;t modify the EventSet
632         super.add(evt);
633     }
634 
635     /*
636      * Complete the construction of an EventSet.  This is called from
637      * an event handler thread.  It upacks the JDWP events inside
638      * the packet and creates EventImpls for them.  The EventSet is already
639      * on EventQueues when this is called, so it has to be synch.
640      */
641     synchronized void build() {
642         if (pkt == null) {
643             return;
644         }
645         PacketStream ps = new PacketStream(vm, pkt);
646         JDWP.Event.Composite compEvt = new JDWP.Event.Composite(vm, ps);
647         suspendPolicy = compEvt.suspendPolicy;
648         if ((vm.traceFlags &amp; VirtualMachine.TRACE_EVENTS) != 0) {
649             switch(suspendPolicy) {
650                 case JDWP.SuspendPolicy.ALL:
651                     vm.printTrace(&quot;EventSet: SUSPEND_ALL&quot;);
652                     break;
653 
654                 case JDWP.SuspendPolicy.EVENT_THREAD:
655                     vm.printTrace(&quot;EventSet: SUSPEND_EVENT_THREAD&quot;);
656                     break;
657 
658                 case JDWP.SuspendPolicy.NONE:
659                     vm.printTrace(&quot;EventSet: SUSPEND_NONE&quot;);
660                     break;
661             }
662         }
663 
664         ThreadReference fix6485605 = null;
665         for (int i = 0; i &lt; compEvt.events.length; i++) {
666             EventImpl evt = createEvent(compEvt.events[i]);
667             if ((vm.traceFlags &amp; VirtualMachine.TRACE_EVENTS) != 0) {
668                 try {
669                     vm.printTrace(&quot;Event: &quot; + evt);
670                 } catch (VMDisconnectedException ee) {
671                     // ignore - see bug 6502716
672                 }
673             }
674 
675             switch (evt.destination()) {
676                 case UNKNOWN_EVENT:
677                     // Ignore disabled, deleted, unknown events, but
678                     // save the thread if there is one since we might
679                     // have to resume it.  Note that events for different
680                     // threads can&#39;t be in the same event set.
681                     if (evt instanceof ThreadedEventImpl &amp;&amp;
682                         suspendPolicy == JDWP.SuspendPolicy.EVENT_THREAD) {
683                         fix6485605 = ((ThreadedEventImpl)evt).thread();
684                     }
685                     continue;
686                 case CLIENT_EVENT:
687                     addEvent(evt);
688                     break;
689                 case INTERNAL_EVENT:
690                     if (internalEventSet == null) {
691                         internalEventSet = new EventSetImpl(this.vm, null);
692                     }
693                     internalEventSet.addEvent(evt);
694                     break;
695                 default:
696                     throw new InternalException(&quot;Invalid event destination&quot;);
697             }
698         }
699         pkt = null; // No longer needed - free it up
700 
701         // Avoid hangs described in 6296125, 6293795
702         if (super.size() == 0) {
703             // This set has no client events.  If we don&#39;t do
704             // needed resumes, no one else is going to.
705             if (suspendPolicy == JDWP.SuspendPolicy.ALL) {
706                 vm.resume();
707             } else if (suspendPolicy == JDWP.SuspendPolicy.EVENT_THREAD) {
708                 // See bug 6485605.
709                 if (fix6485605 != null) {
710                     fix6485605.resume();
711                 } else {
712                     // apparently, there is nothing to resume.
713                 }
714             }
715             suspendPolicy = JDWP.SuspendPolicy.NONE;
716 
717         }
718 
719     }
720 
721     /**
722      * Filter out internal events
723      */
724     EventSet userFilter() {
725         return this;
726     }
727 
728     /**
729      * Filter out user events.
730      */
731     EventSet internalFilter() {
732         return this.internalEventSet;
733     }
734 
735     EventImpl createEvent(JDWP.Event.Composite.Events evt) {
736         JDWP.Event.Composite.Events.EventsCommon comm = evt.aEventsCommon;
737         switch (evt.eventKind) {
738             case JDWP.EventKind.THREAD_START:
739                 return new ThreadStartEventImpl(
740                       (JDWP.Event.Composite.Events.ThreadStart)comm);
741 
742             case JDWP.EventKind.THREAD_END:
743                 return new ThreadDeathEventImpl(
744                       (JDWP.Event.Composite.Events.ThreadDeath)comm);
745 
746             case JDWP.EventKind.EXCEPTION:
747                 return new ExceptionEventImpl(
748                       (JDWP.Event.Composite.Events.Exception)comm);
749 
750             case JDWP.EventKind.BREAKPOINT:
751                 return new BreakpointEventImpl(
752                       (JDWP.Event.Composite.Events.Breakpoint)comm);
753 
754             case JDWP.EventKind.METHOD_ENTRY:
755                 return new MethodEntryEventImpl(
756                       (JDWP.Event.Composite.Events.MethodEntry)comm);
757 
758             case JDWP.EventKind.METHOD_EXIT:
759                 return new MethodExitEventImpl(
760                       (JDWP.Event.Composite.Events.MethodExit)comm);
761 
762             case JDWP.EventKind.METHOD_EXIT_WITH_RETURN_VALUE:
763                 return new MethodExitEventImpl(
764                       (JDWP.Event.Composite.Events.MethodExitWithReturnValue)comm);
765 
766             case JDWP.EventKind.FIELD_ACCESS:
767                 return new AccessWatchpointEventImpl(
768                       (JDWP.Event.Composite.Events.FieldAccess)comm);
769 
770             case JDWP.EventKind.FIELD_MODIFICATION:
771                 return new ModificationWatchpointEventImpl(
772                       (JDWP.Event.Composite.Events.FieldModification)comm);
773 
774             case JDWP.EventKind.SINGLE_STEP:
775                 return new StepEventImpl(
776                       (JDWP.Event.Composite.Events.SingleStep)comm);
777 
778             case JDWP.EventKind.CLASS_PREPARE:
779                 return new ClassPrepareEventImpl(
780                       (JDWP.Event.Composite.Events.ClassPrepare)comm);
781 
782             case JDWP.EventKind.CLASS_UNLOAD:
783                 return new ClassUnloadEventImpl(
784                       (JDWP.Event.Composite.Events.ClassUnload)comm);
785 
786             case JDWP.EventKind.MONITOR_CONTENDED_ENTER:
787                 return new MonitorContendedEnterEventImpl(
788                       (JDWP.Event.Composite.Events.MonitorContendedEnter)comm);
789 
790             case JDWP.EventKind.MONITOR_CONTENDED_ENTERED:
791                 return new MonitorContendedEnteredEventImpl(
792                       (JDWP.Event.Composite.Events.MonitorContendedEntered)comm);
793 
794             case JDWP.EventKind.MONITOR_WAIT:
795                 return new MonitorWaitEventImpl(
796                       (JDWP.Event.Composite.Events.MonitorWait)comm);
797 
798             case JDWP.EventKind.MONITOR_WAITED:
799                 return new MonitorWaitedEventImpl(
800                       (JDWP.Event.Composite.Events.MonitorWaited)comm);
801 
802             case JDWP.EventKind.VM_START:
803                 return new VMStartEventImpl(
804                       (JDWP.Event.Composite.Events.VMStart)comm);
805 
806             case JDWP.EventKind.VM_DEATH:
807                 return new VMDeathEventImpl(
808                       (JDWP.Event.Composite.Events.VMDeath)comm);
809 
810             default:
811                 // Ignore unknown event types
812                 System.err.println(&quot;Ignoring event cmd &quot; +
813                                    evt.eventKind + &quot; from the VM&quot;);
814                 return null;
815         }
816     }
817 
818     public VirtualMachine virtualMachine() {
819         return vm;
820     }
821 
822     public int suspendPolicy() {
823         return EventRequestManagerImpl.JDWPtoJDISuspendPolicy(suspendPolicy);
824     }
825 
826     private ThreadReference eventThread() {
827         for (Event event : this) {
828             if (event instanceof ThreadedEventImpl) {
829                 return ((ThreadedEventImpl)event).thread();
830             }
831         }
832         return null;
833     }
834 
835     public void resume() {
836         switch (suspendPolicy()) {
837             case EventRequest.SUSPEND_ALL:
838                 vm.resume();
839                 break;
840             case EventRequest.SUSPEND_EVENT_THREAD:
841                 ThreadReference thread = eventThread();
842                 if (thread == null) {
843                     throw new InternalException(&quot;Inconsistent suspend policy&quot;);
844                 }
845                 thread.resume();
846                 break;
847             case EventRequest.SUSPEND_NONE:
848                 // Do nothing
849                 break;
850             default:
851                 throw new InternalException(&quot;Invalid suspend policy&quot;);
852         }
853     }
854 
855     public Iterator&lt;Event&gt; iterator() {
856         return new Itr();
857     }
858 
859     public EventIterator eventIterator() {
860         return new Itr();
861     }
862 
863     public class Itr implements EventIterator {
864         /**
865          * Index of element to be returned by subsequent call to next.
866          */
867         int cursor = 0;
868 
869         public boolean hasNext() {
870             return cursor != size();
871         }
872 
873         public Event next() {
874             try {
875                 Event nxt = get(cursor);
876                 ++cursor;
877                 return nxt;
878             } catch(IndexOutOfBoundsException e) {
879                 throw new NoSuchElementException();
880             }
881         }
882 
883         public Event nextEvent() {
884             return next();
885         }
886 
887         public void remove() {
888             throw new UnsupportedOperationException();
889         }
890     }
891 
892     @Override
893     public Spliterator&lt;Event&gt; spliterator() {
894         return Spliterators.spliterator(this, Spliterator.DISTINCT);
895     }
896 
897     /* below make this unmodifiable */
898 
899     public boolean add(Event o){
900         throw new UnsupportedOperationException();
901     }
902     public boolean remove(Object o) {
903         throw new UnsupportedOperationException();
904     }
905     public boolean addAll(Collection&lt;? extends Event&gt; coll) {
906         throw new UnsupportedOperationException();
907     }
908     public boolean removeAll(Collection&lt;?&gt; coll) {
909         throw new UnsupportedOperationException();
910     }
911     public boolean retainAll(Collection&lt;?&gt; coll) {
912         throw new UnsupportedOperationException();
913     }
914     public void clear() {
915         throw new UnsupportedOperationException();
916     }
917 }
    </pre>
  </body>
</html>
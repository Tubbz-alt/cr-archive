<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/unix/classes/sun/awt/X11/XToolkit.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.awt.X11;
  27 
  28 import java.awt.AWTError;
  29 import java.awt.AWTException;
  30 import java.awt.Button;
  31 import java.awt.Canvas;
  32 import java.awt.Checkbox;
  33 import java.awt.CheckboxMenuItem;
  34 import java.awt.Choice;
  35 import java.awt.Color;
  36 import java.awt.Component;
  37 import java.awt.Cursor;
  38 import java.awt.Desktop;
  39 import java.awt.Dialog;
  40 import java.awt.Dimension;
  41 import java.awt.EventQueue;
  42 import java.awt.FileDialog;
  43 import java.awt.Frame;
  44 import java.awt.GraphicsConfiguration;
  45 import java.awt.GraphicsDevice;
  46 import java.awt.GraphicsEnvironment;
  47 import java.awt.HeadlessException;
  48 import java.awt.Image;
  49 import java.awt.Insets;
  50 import java.awt.JobAttributes;
  51 import java.awt.Label;
  52 import java.awt.Menu;
  53 import java.awt.MenuBar;
  54 import java.awt.MenuItem;
  55 import java.awt.PageAttributes;
  56 import java.awt.Panel;
  57 import java.awt.Point;
  58 import java.awt.PopupMenu;
  59 import java.awt.PrintJob;
  60 import java.awt.Rectangle;
  61 import java.awt.ScrollPane;
  62 import java.awt.Scrollbar;
  63 import java.awt.SystemColor;
  64 import java.awt.SystemTray;
  65 import java.awt.Taskbar;
  66 import java.awt.TextArea;
  67 import java.awt.TextField;
  68 import java.awt.Toolkit;
  69 import java.awt.TrayIcon;
  70 import java.awt.Window;
  71 import java.awt.datatransfer.Clipboard;
  72 import java.awt.dnd.DragGestureEvent;
  73 import java.awt.dnd.DragGestureListener;
  74 import java.awt.dnd.DragGestureRecognizer;
  75 import java.awt.dnd.DragSource;
  76 import java.awt.dnd.InvalidDnDOperationException;
  77 import java.awt.dnd.MouseDragGestureRecognizer;
  78 import java.awt.dnd.peer.DragSourceContextPeer;
  79 import java.awt.event.InputEvent;
  80 import java.awt.event.KeyEvent;
  81 import java.awt.event.MouseEvent;
  82 import java.awt.font.TextAttribute;
  83 import java.awt.im.InputMethodHighlight;
  84 import java.awt.im.spi.InputMethodDescriptor;
  85 import java.awt.peer.ButtonPeer;
  86 import java.awt.peer.CanvasPeer;
  87 import java.awt.peer.CheckboxMenuItemPeer;
  88 import java.awt.peer.CheckboxPeer;
  89 import java.awt.peer.ChoicePeer;
  90 import java.awt.peer.DesktopPeer;
  91 import java.awt.peer.DialogPeer;
  92 import java.awt.peer.FileDialogPeer;
  93 import java.awt.peer.FontPeer;
  94 import java.awt.peer.FramePeer;
  95 import java.awt.peer.KeyboardFocusManagerPeer;
  96 import java.awt.peer.LabelPeer;
  97 import java.awt.peer.ListPeer;
  98 import java.awt.peer.MenuBarPeer;
  99 import java.awt.peer.MenuItemPeer;
 100 import java.awt.peer.MenuPeer;
 101 import java.awt.peer.MouseInfoPeer;
 102 import java.awt.peer.PanelPeer;
 103 import java.awt.peer.PopupMenuPeer;
 104 import java.awt.peer.RobotPeer;
 105 import java.awt.peer.ScrollPanePeer;
 106 import java.awt.peer.ScrollbarPeer;
 107 import java.awt.peer.SystemTrayPeer;
 108 import java.awt.peer.TaskbarPeer;
 109 import java.awt.peer.TextAreaPeer;
 110 import java.awt.peer.TextFieldPeer;
 111 import java.awt.peer.TrayIconPeer;
 112 import java.awt.peer.WindowPeer;
 113 import java.beans.PropertyChangeListener;
 114 import java.security.AccessController;
 115 import java.security.PrivilegedAction;
 116 import java.util.ArrayList;
 117 import java.util.Collection;
 118 import java.util.HashMap;
 119 import java.util.Iterator;
 120 import java.util.LinkedList;
 121 import java.util.Map;
 122 import java.util.NoSuchElementException;
 123 import java.util.Properties;
 124 import java.util.Set;
 125 import java.util.SortedMap;
 126 import java.util.TreeMap;
 127 import java.util.Vector;
 128 
 129 import javax.swing.LookAndFeel;
 130 import javax.swing.UIDefaults;
 131 
 132 import sun.awt.AWTAccessor;
 133 import sun.awt.AWTPermissions;
 134 import sun.awt.AppContext;
 135 import sun.awt.DisplayChangedListener;
 136 import sun.awt.LightweightFrame;
 137 import sun.awt.SunToolkit;
 138 import sun.awt.UNIXToolkit;
 139 import sun.awt.X11GraphicsConfig;
 140 import sun.awt.X11GraphicsDevice;
 141 import sun.awt.X11GraphicsEnvironment;
 142 import sun.awt.XSettings;
 143 import sun.awt.datatransfer.DataTransferer;
 144 import sun.awt.util.PerformanceLogger;
 145 import sun.awt.util.ThreadGroupUtils;
 146 import sun.font.FontConfigManager;
 147 import sun.java2d.SunGraphicsEnvironment;
 148 import sun.print.PrintJob2D;
 149 import sun.security.action.GetBooleanAction;
 150 import sun.security.action.GetPropertyAction;
 151 import sun.util.logging.PlatformLogger;
 152 
 153 import static sun.awt.X11.XlibUtil.scaleDown;
 154 
 155 public final class XToolkit extends UNIXToolkit implements Runnable {
 156     private static final PlatformLogger log = PlatformLogger.getLogger(&quot;sun.awt.X11.XToolkit&quot;);
 157     private static final PlatformLogger eventLog = PlatformLogger.getLogger(&quot;sun.awt.X11.event.XToolkit&quot;);
 158     private static final PlatformLogger timeoutTaskLog = PlatformLogger.getLogger(&quot;sun.awt.X11.timeoutTask.XToolkit&quot;);
 159     private static final PlatformLogger keyEventLog = PlatformLogger.getLogger(&quot;sun.awt.X11.kye.XToolkit&quot;);
 160     private static final PlatformLogger backingStoreLog = PlatformLogger.getLogger(&quot;sun.awt.X11.backingStore.XToolkit&quot;);
 161 
 162     //There is 400 ms is set by default on Windows and 500 by default on KDE and GNOME.
 163     //We use the same hardcoded constant.
 164     private static final int AWT_MULTICLICK_DEFAULT_TIME = 500;
 165 
 166     static final boolean PRIMARY_LOOP = false;
 167     static final boolean SECONDARY_LOOP = true;
 168 
 169     private static String awtAppClassName = null;
 170 
 171     // the system clipboard - CLIPBOARD selection
 172     XClipboard clipboard;
 173     // the system selection - PRIMARY selection
 174     XClipboard selection;
 175 
 176     // Dynamic Layout Resize client code setting
 177     protected static boolean dynamicLayoutSetting = false;
 178 
 179     //Is it allowed to generate events assigned to extra mouse buttons.
 180     //Set to true by default.
 181     private static boolean areExtraMouseButtonsEnabled = true;
 182 
 183     /**
 184      * True when the x settings have been loaded.
 185      */
 186     private boolean loadedXSettings;
 187 
 188     /**
 189     * XSETTINGS for the default screen.
 190      * &lt;p&gt;
 191      */
 192     private XSettings xs;
 193 
 194     private FontConfigManager fcManager = new FontConfigManager();
 195 
 196     static int arrowCursor;
 197     static TreeMap&lt;Long, XBaseWindow&gt; winMap = new TreeMap&lt;&gt;();
 198     static HashMap&lt;Object, Object&gt; specialPeerMap = new HashMap&lt;&gt;();
 199     static HashMap&lt;Long, Collection&lt;XEventDispatcher&gt;&gt; winToDispatcher = new HashMap&lt;&gt;();
 200     static UIDefaults uidefaults;
 201     static final X11GraphicsEnvironment localEnv;
 202     private static final X11GraphicsDevice device;
 203     private static final long display;
 204     static int awt_multiclick_time;
 205     static boolean securityWarningEnabled;
 206 
 207     /**
 208      * Dimensions of default virtual screen in pixels. These values are used to
 209      * limit the maximum size of the window.
 210      */
 211     private static volatile int maxWindowWidthInPixels = -1;
 212     private static volatile int maxWindowHeightInPixels = -1;
 213 
<a name="1" id="anc1"></a>
 214     private static XMouseInfoPeer xPeer;
 215 
 216     /**
 217      * Should we check &quot;_NET_WM_STRUT/_NET_WM_STRUT_PARTIAL&quot; during insets
 218      * calculation.
 219      */
 220     private static Boolean checkSTRUT;
 221 
 222     static {
 223         initSecurityWarning();
 224         if (GraphicsEnvironment.isHeadless()) {
 225             localEnv = null;
 226             device = null;
 227             display = 0;
 228         } else {
 229             localEnv = (X11GraphicsEnvironment) GraphicsEnvironment
 230                 .getLocalGraphicsEnvironment();
 231             device = (X11GraphicsDevice) localEnv.getDefaultScreenDevice();
 232             display = device.getDisplay();
 233             setupModifierMap();
 234             initIDs();
 235             setBackingStoreType();
 236         }
 237     }
 238 
 239     /*
 240      * Return (potentially) platform specific display timeout for the
 241      * tray icon
 242      */
 243     static native long getTrayIconDisplayTimeout();
 244 
 245     private static native void initIDs();
 246     static native void waitForEvents(long nextTaskTime);
 247     static Thread toolkitThread;
 248     static boolean isToolkitThread() {
 249         return Thread.currentThread() == toolkitThread;
 250     }
 251 
 252     static void initSecurityWarning() {
 253         // Enable warning only for internal builds
 254         String runtime = AccessController.doPrivileged(
 255                              new GetPropertyAction(&quot;java.runtime.version&quot;));
 256         securityWarningEnabled = (runtime != null &amp;&amp; runtime.contains(&quot;internal&quot;));
 257     }
 258 
 259     static boolean isSecurityWarningEnabled() {
 260         return securityWarningEnabled;
 261     }
 262 
 263     static native void awt_output_flush();
 264 
 265     static void  awtFUnlock() {
 266         awtUnlock();
 267         awt_output_flush();
 268     }
 269 
 270 
 271     private native void nativeLoadSystemColors(int[] systemColors);
 272 
 273     static UIDefaults getUIDefaults() {
 274         if (uidefaults == null) {
 275             initUIDefaults();
 276         }
 277         return uidefaults;
 278     }
 279 
 280     @Override
 281     public void loadSystemColors(int[] systemColors) {
 282         nativeLoadSystemColors(systemColors);
 283         MotifColorUtilities.loadSystemColors(systemColors);
 284     }
 285 
 286 
 287 
 288     static void initUIDefaults() {
 289         try {
 290             // Load Defaults from MotifLookAndFeel
 291 
 292             // This dummy load is necessary to get SystemColor initialized. !!!!!!
 293             Color c = SystemColor.text;
 294 
 295             LookAndFeel lnf = new XAWTLookAndFeel();
 296             uidefaults = lnf.getDefaults();
 297         }
 298         catch (Exception e)
 299         {
 300             e.printStackTrace();
 301         }
 302     }
 303 
 304     /**
 305      * Returns the X11 Display of the default screen device.
 306      *
 307      * @return X11 Display
 308      * @throws AWTError thrown if local GraphicsEnvironment is null, which
 309      *         means we are in the headless environment
 310      */
 311     public static long getDisplay() {
 312         if (localEnv == null) {
 313             throw new AWTError(&quot;Local GraphicsEnvironment must not be null&quot;);
 314         }
 315         return display;
 316     }
 317 
 318     public static long getDefaultRootWindow() {
 319         awtLock();
 320         try {
 321             long res = XlibWrapper.RootWindow(XToolkit.getDisplay(),
 322                 XlibWrapper.DefaultScreen(XToolkit.getDisplay()));
 323 
 324             if (res == 0) {
 325                throw new IllegalStateException(&quot;Root window must not be null&quot;);
 326             }
 327             return res;
 328         } finally {
 329             awtUnlock();
 330         }
 331     }
 332 
 333     void init() {
 334         awtLock();
 335         try {
 336             XlibWrapper.XSupportsLocale();
 337             if (XlibWrapper.XSetLocaleModifiers(&quot;&quot;) == null) {
 338                 log.finer(&quot;X locale modifiers are not supported, using default&quot;);
 339             }
 340             tryXKB();
 341 
<a name="2" id="anc2"></a>


 342             arrowCursor = XlibWrapper.XCreateFontCursor(XToolkit.getDisplay(),
 343                 XCursorFontConstants.XC_arrow);
 344             final String extraButtons = &quot;sun.awt.enableExtraMouseButtons&quot;;
 345             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 346                 areExtraMouseButtonsEnabled =
 347                     Boolean.parseBoolean(System.getProperty(extraButtons, &quot;true&quot;));
 348                 //set system property if not yet assigned
 349                 System.setProperty(extraButtons, &quot;&quot;+areExtraMouseButtonsEnabled);
 350                 return null;
 351             });
 352             // Detect display mode changes
 353             XlibWrapper.XSelectInput(XToolkit.getDisplay(), XToolkit.getDefaultRootWindow(), XConstants.StructureNotifyMask);
 354             XToolkit.addEventDispatcher(XToolkit.getDefaultRootWindow(), new XEventDispatcher() {
 355                 @Override
 356                 public void dispatchEvent(XEvent ev) {
 357                     if (ev.get_type() == XConstants.ConfigureNotify) {
 358                         awtUnlock();
 359                         try {
 360                             ((X11GraphicsEnvironment)GraphicsEnvironment.
 361                              getLocalGraphicsEnvironment()).
 362                                 displayChanged();
 363                         } finally {
 364                             awtLock();
 365                         }
 366                     }
 367                 }
 368             });
 369         } finally {
 370             awtUnlock();
 371         }
 372         PrivilegedAction&lt;Void&gt; a = () -&gt; {
 373             Runnable r = () -&gt; {
 374                 XSystemTrayPeer peer = XSystemTrayPeer.getPeerInstance();
 375                 if (peer != null) {
 376                     peer.dispose();
 377                 }
 378                 if (xs != null) {
 379                     ((XAWTXSettings)xs).dispose();
 380                 }
 381                 freeXKB();
 382                 if (log.isLoggable(PlatformLogger.Level.FINE)) {
 383                     dumpPeers();
 384                 }
 385             };
 386             String name = &quot;XToolkt-Shutdown-Thread&quot;;
 387             Thread shutdownThread = new Thread(
 388                     ThreadGroupUtils.getRootThreadGroup(), r, name, 0, false);
 389             shutdownThread.setContextClassLoader(null);
 390             Runtime.getRuntime().addShutdownHook(shutdownThread);
 391             return null;
 392         };
 393         AccessController.doPrivileged(a);
 394     }
 395 
 396     static String getCorrectXIDString(String val) {
 397         if (val != null) {
 398             return val.replace(&#39;.&#39;, &#39;-&#39;);
 399         } else {
 400             return val;
 401         }
 402     }
 403 
 404     static native String getEnv(String key);
 405 
 406 
 407     static String getAWTAppClassName() {
 408         return awtAppClassName;
 409     }
 410 
 411     public XToolkit() {
 412         super();
 413         if (PerformanceLogger.loggingEnabled()) {
 414             PerformanceLogger.setTime(&quot;XToolkit construction&quot;);
 415         }
 416 
 417         if (!GraphicsEnvironment.isHeadless()) {
 418             String mainClassName = null;
 419 
 420             StackTraceElement[] trace = (new Throwable()).getStackTrace();
 421             int bottom = trace.length - 1;
 422             if (bottom &gt;= 0) {
 423                 mainClassName = trace[bottom].getClassName();
 424             }
 425             if (mainClassName == null || mainClassName.isEmpty()) {
 426                 mainClassName = &quot;AWT&quot;;
 427             }
 428             awtAppClassName = getCorrectXIDString(mainClassName);
 429 
 430             init();
 431             XWM.init();
 432 
 433             toolkitThread = AccessController.doPrivileged((PrivilegedAction&lt;Thread&gt;) () -&gt; {
 434                 String name = &quot;AWT-XAWT&quot;;
 435                 Thread thread = new Thread(
 436                         ThreadGroupUtils.getRootThreadGroup(), this, name,
 437                         0, false);
 438                 thread.setContextClassLoader(null);
 439                 thread.setPriority(Thread.NORM_PRIORITY + 1);
 440                 thread.setDaemon(true);
 441                 return thread;
 442             });
 443             toolkitThread.start();
 444         }
 445     }
 446 
 447     @Override
 448     public ButtonPeer createButton(Button target) {
 449         ButtonPeer peer = new XButtonPeer(target);
 450         targetCreatedPeer(target, peer);
 451         return peer;
 452     }
 453 
 454     @Override
 455     public FramePeer createLightweightFrame(LightweightFrame target) {
 456         FramePeer peer = new XLightweightFramePeer(target);
 457         targetCreatedPeer(target, peer);
 458         return peer;
 459     }
 460 
 461     @Override
 462     public FramePeer createFrame(Frame target) {
 463         FramePeer peer = new XFramePeer(target);
 464         targetCreatedPeer(target, peer);
 465         return peer;
 466     }
 467 
 468     static void addToWinMap(long window, XBaseWindow xwin)
 469     {
 470         synchronized(winMap) {
 471             winMap.put(Long.valueOf(window),xwin);
 472         }
 473     }
 474 
 475     static void removeFromWinMap(long window, XBaseWindow xwin) {
 476         synchronized(winMap) {
 477             winMap.remove(Long.valueOf(window));
 478         }
 479     }
 480     static XBaseWindow windowToXWindow(long window) {
 481         synchronized(winMap) {
 482             return winMap.get(Long.valueOf(window));
 483         }
 484     }
 485 
 486     static void addEventDispatcher(long window, XEventDispatcher dispatcher) {
 487         synchronized(winToDispatcher) {
 488             Long key = Long.valueOf(window);
 489             Collection&lt;XEventDispatcher&gt; dispatchers = winToDispatcher.get(key);
 490             if (dispatchers == null) {
 491                 dispatchers = new Vector&lt;&gt;();
 492                 winToDispatcher.put(key, dispatchers);
 493             }
 494             dispatchers.add(dispatcher);
 495         }
 496     }
 497     static void removeEventDispatcher(long window, XEventDispatcher dispatcher) {
 498         synchronized(winToDispatcher) {
 499             Long key = Long.valueOf(window);
 500             Collection&lt;XEventDispatcher&gt; dispatchers = winToDispatcher.get(key);
 501             if (dispatchers != null) {
 502                 dispatchers.remove(dispatcher);
 503             }
 504         }
 505     }
 506 
 507     private Point lastCursorPos;
 508 
 509     /**
 510      * Returns whether there is last remembered cursor position.  The
 511      * position is remembered from X mouse events on our peers.  The
 512      * position is stored in {@code p}.
 513      * @return true, if there is remembered last cursor position,
 514      * false otherwise
 515      */
 516     boolean getLastCursorPos(Point p) {
 517         awtLock();
 518         try {
 519             if (lastCursorPos == null) {
 520                 return false;
 521             }
 522             p.setLocation(lastCursorPos);
 523             return true;
 524         } finally {
 525             awtUnlock();
 526         }
 527     }
 528 
 529     private void processGlobalMotionEvent(XEvent e, XBaseWindow win) {
 530         // Only our windows guaranteely generate MotionNotify, so we
 531         // should track enter/leave, to catch the moment when to
 532         // switch to XQueryPointer
 533         if (e.get_type() == XConstants.MotionNotify) {
 534             XMotionEvent ev = e.get_xmotion();
 535             awtLock();
 536             try {
 537                 if (lastCursorPos == null) {
 538                     lastCursorPos = new Point(win.scaleDown(ev.get_x_root()),
 539                                               win.scaleDown(ev.get_y_root()));
 540                 } else {
 541                     lastCursorPos.setLocation(win.scaleDown(ev.get_x_root()),
 542                                               win.scaleDown(ev.get_y_root()));
 543                 }
 544             } finally {
 545                 awtUnlock();
 546             }
 547         } else if (e.get_type() == XConstants.LeaveNotify) {
 548             // Leave from our window
 549             awtLock();
 550             try {
 551                 lastCursorPos = null;
 552             } finally {
 553                 awtUnlock();
 554             }
 555         } else if (e.get_type() == XConstants.EnterNotify) {
 556             // Entrance into our window
 557             XCrossingEvent ev = e.get_xcrossing();
 558             awtLock();
 559             try {
 560                 if (lastCursorPos == null) {
 561                     lastCursorPos = new Point(win.scaleDown(ev.get_x_root()),
 562                                               win.scaleDown(ev.get_y_root()));
 563                 } else {
 564                     lastCursorPos.setLocation(win.scaleDown(ev.get_x_root()),
 565                                               win.scaleDown(ev.get_y_root()));
 566                 }
 567             } finally {
 568                 awtUnlock();
 569             }
 570         }
 571     }
 572 
 573     public interface XEventListener {
 574         public void eventProcessed(XEvent e);
 575     }
 576 
 577     private Collection&lt;XEventListener&gt; listeners = new LinkedList&lt;XEventListener&gt;();
 578 
 579     public void addXEventListener(XEventListener listener) {
 580         synchronized (listeners) {
 581             listeners.add(listener);
 582         }
 583     }
 584 
 585     private void notifyListeners(XEvent xev) {
 586         synchronized (listeners) {
 587             if (listeners.size() == 0) return;
 588 
 589             XEvent copy = xev.clone();
 590             try {
 591                 for (XEventListener listener : listeners) {
 592                     listener.eventProcessed(copy);
 593                 }
 594             } finally {
 595                 copy.dispose();
 596             }
 597         }
 598     }
 599 
 600     private void dispatchEvent(XEvent ev) {
 601         final XAnyEvent xany = ev.get_xany();
 602 
 603         XBaseWindow baseWindow = windowToXWindow(xany.get_window());
 604         if (baseWindow != null &amp;&amp; (ev.get_type() == XConstants.MotionNotify
 605                 || ev.get_type() == XConstants.EnterNotify
 606                 || ev.get_type() == XConstants.LeaveNotify)) {
 607             processGlobalMotionEvent(ev, baseWindow);
 608         }
 609 
 610         if( ev.get_type() == XConstants.MappingNotify ) {
 611             // The &#39;window&#39; field in this event is unused.
 612             // This application itself does nothing to initiate such an event
 613             // (no calls of XChangeKeyboardMapping etc.).
 614             // SunRay server sends this event to the application once on every
 615             // keyboard (not just layout) change which means, quite seldom.
 616             XlibWrapper.XRefreshKeyboardMapping(ev.pData);
 617             resetKeyboardSniffer();
 618             setupModifierMap();
 619         }
 620         XBaseWindow.dispatchToWindow(ev);
 621 
 622         Collection&lt;XEventDispatcher&gt; dispatchers = null;
 623         synchronized(winToDispatcher) {
 624             Long key = Long.valueOf(xany.get_window());
 625             dispatchers = winToDispatcher.get(key);
 626             if (dispatchers != null) { // Clone it to avoid synchronization during dispatching
 627                 dispatchers = new Vector&lt;&gt;(dispatchers);
 628             }
 629         }
 630         if (dispatchers != null) {
 631             Iterator&lt;XEventDispatcher&gt; iter = dispatchers.iterator();
 632             while (iter.hasNext()) {
 633                 XEventDispatcher disp = iter.next();
 634                 disp.dispatchEvent(ev);
 635             }
 636         }
 637         notifyListeners(ev);
 638     }
 639 
 640     static void processException(Throwable thr) {
 641         if (log.isLoggable(PlatformLogger.Level.WARNING)) {
 642             log.warning(&quot;Exception on Toolkit thread&quot;, thr);
 643         }
 644     }
 645 
 646     static native void awt_toolkit_init();
 647 
 648     @Override
 649     public void run() {
 650         awt_toolkit_init();
 651         run(PRIMARY_LOOP);
 652     }
 653 
 654     public void run(boolean loop)
 655     {
 656         XEvent ev = new XEvent();
 657         while(true) {
 658             // Fix for 6829923: we should gracefully handle toolkit thread interruption
 659             if (Thread.currentThread().isInterrupted()) {
 660                 // We expect interruption from the AppContext.dispose() method only.
 661                 // If the thread is interrupted from another place, let&#39;s skip it
 662                 // for compatibility reasons. Probably some time later we&#39;ll remove
 663                 // the check for AppContext.isDisposed() and will unconditionally
 664                 // break the loop here.
 665                 if (AppContext.getAppContext().isDisposed()) {
 666                     break;
 667                 }
 668             }
 669             awtLock();
 670             try {
 671                 if (loop == SECONDARY_LOOP) {
 672                     // In the secondary loop we may have already acquired awt_lock
 673                     // several times, so waitForEvents() might be unable to release
 674                     // the awt_lock and this causes lock up.
 675                     // For now, we just avoid waitForEvents in the secondary loop.
 676                     if (!XlibWrapper.XNextSecondaryLoopEvent(getDisplay(),ev.pData)) {
 677                         break;
 678                     }
 679                 } else {
 680                     callTimeoutTasks();
 681                     // If no events are queued, waitForEvents() causes calls to
 682                     // awtUnlock(), awtJNI_ThreadYield, poll, awtLock(),
 683                     // so it spends most of its time in poll, without holding the lock.
 684                     while ((XlibWrapper.XEventsQueued(getDisplay(), XConstants.QueuedAfterReading) == 0) &amp;&amp;
 685                            (XlibWrapper.XEventsQueued(getDisplay(), XConstants.QueuedAfterFlush) == 0)) {
 686                         callTimeoutTasks();
 687                         waitForEvents(getNextTaskTime());
 688                     }
 689                     XlibWrapper.XNextEvent(getDisplay(),ev.pData);
 690                 }
 691 
 692                 if (ev.get_type() != XConstants.NoExpose) {
 693                     eventNumber++;
 694                 }
 695                 if (awt_UseXKB_Calls &amp;&amp; ev.get_type() ==  awt_XKBBaseEventCode) {
 696                     processXkbChanges(ev);
 697                 }
 698 
 699                 if (XDropTargetEventProcessor.processEvent(ev) ||
 700                     XDragSourceContextPeer.processEvent(ev)) {
 701                     continue;
 702                 }
 703 
 704                 if (eventLog.isLoggable(PlatformLogger.Level.FINER)) {
 705                     eventLog.finer(&quot;{0}&quot;, ev);
 706                 }
 707 
 708                 // Check if input method consumes the event
 709                 long w = 0;
 710                 if (windowToXWindow(ev.get_xany().get_window()) != null) {
 711                     Component owner =
 712                         XKeyboardFocusManagerPeer.getInstance().getCurrentFocusOwner();
 713                     if (owner != null) {
 714                         XWindow ownerWindow = AWTAccessor.getComponentAccessor().getPeer(owner);
 715                         if (ownerWindow != null) {
 716                             w = ownerWindow.getContentWindow();
 717                         }
 718                     }
 719                 }
 720                 if (keyEventLog.isLoggable(PlatformLogger.Level.FINE) &amp;&amp; (
 721                         ev.get_type() == XConstants.KeyPress
 722                                 || ev.get_type() == XConstants.KeyRelease)) {
 723                     keyEventLog.fine(&quot;before XFilterEvent:&quot; + ev);
 724                 }
 725                 if (XlibWrapper.XFilterEvent(ev.getPData(), w)) {
 726                     continue;
 727                 }
 728                 if (keyEventLog.isLoggable(PlatformLogger.Level.FINE) &amp;&amp; (
 729                         ev.get_type() == XConstants.KeyPress
 730                                 || ev.get_type() == XConstants.KeyRelease)) {
 731                     keyEventLog.fine(
 732                             &quot;after XFilterEvent:&quot; + ev); // IS THIS CORRECT?
 733                 }
 734 
 735                 dispatchEvent(ev);
 736             } catch (ThreadDeath td) {
 737                 XBaseWindow.ungrabInput();
 738                 return;
 739             } catch (Throwable thr) {
 740                 XBaseWindow.ungrabInput();
 741                 processException(thr);
 742             } finally {
 743                 awtUnlock();
 744             }
 745         }
 746     }
 747 
 748     /**
 749      * Listener installed to detect display changes.
 750      */
 751     private static final DisplayChangedListener displayChangedHandler =
 752             new DisplayChangedListener() {
 753                 @Override
 754                 public void displayChanged() {
 755                     // 7045370: Reset the cached values
 756                     XToolkit.maxWindowWidthInPixels = -1;
 757                     XToolkit.maxWindowHeightInPixels = -1;
 758                 }
 759 
 760                 @Override
 761                 public void paletteChanged() {
 762                 }
 763             };
 764 
 765     static {
 766         GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
 767         if (ge instanceof SunGraphicsEnvironment) {
 768             ((SunGraphicsEnvironment) ge).addDisplayChangedListener(
 769                     displayChangedHandler);
 770         }
 771     }
 772 
 773     private static void initScreenSize() {
 774         if (maxWindowWidthInPixels == -1 || maxWindowHeightInPixels == -1) {
 775             awtLock();
 776             try {
 777                 XWindowAttributes pattr = new XWindowAttributes();
 778                 try {
 779                     XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
 780                                                      XToolkit.getDefaultRootWindow(),
 781                                                      pattr.pData);
 782                     maxWindowWidthInPixels = pattr.get_width();
 783                     maxWindowHeightInPixels = pattr.get_height();
 784                 } finally {
 785                     pattr.dispose();
 786                 }
 787             } finally {
 788                 awtUnlock();
 789             }
 790         }
 791     }
 792 
 793     static int getMaxWindowWidthInPixels() {
 794         initScreenSize();
 795         return maxWindowWidthInPixels;
 796     }
 797 
 798     static int getMaxWindowHeightInPixels() {
 799         initScreenSize();
 800         return maxWindowHeightInPixels;
 801     }
 802 
 803     private static Rectangle getWorkArea(long root, int scale)
 804     {
 805         XAtom XA_NET_WORKAREA = XAtom.get(&quot;_NET_WORKAREA&quot;);
 806 
 807         long native_ptr = Native.allocateLongArray(4);
 808         try
 809         {
 810             boolean workareaPresent = XA_NET_WORKAREA.getAtomData(root,
 811                 XAtom.XA_CARDINAL, native_ptr, 4);
 812             if (workareaPresent)
 813             {
 814                 int rootX = (int)Native.getLong(native_ptr, 0);
 815                 int rootY = (int)Native.getLong(native_ptr, 1);
 816                 int rootWidth = (int)Native.getLong(native_ptr, 2);
 817                 int rootHeight = (int)Native.getLong(native_ptr, 3);
 818 
 819                 return new Rectangle(scaleDown(rootX, scale),
 820                                      scaleDown(rootY, scale),
 821                                      scaleDown(rootWidth, scale),
 822                                      scaleDown(rootHeight, scale));
 823             }
 824         }
 825         finally
 826         {
 827             XlibWrapper.unsafe.freeMemory(native_ptr);
 828         }
 829 
 830         return null;
 831     }
 832 
 833     /*
 834      * If the current window manager supports _NET protocol then the screen
 835      * insets are calculated using _NET_WORKAREA property of the root window.
 836      * &lt;p&gt;
 837      * Note that _NET_WORKAREA is a rectangular area and it does not work
 838      * well in the Xinerama mode.
 839      * &lt;p&gt;
 840      * We will trust the part of this rectangular area only if it starts at the
 841      * requested graphics configuration. Below is an example when the
 842      * _NET_WORKAREA intersects with the requested graphics configuration but
 843      * produces wrong result.
 844      *
 845      *         //&lt;-x1,y1///////
 846      *         //            // ////////////////
 847      *         //  SCREEN1   // // SCREEN2    //
 848      *         // ********** // //     x2,y2-&gt;//
 849      *         //////////////// //            //
 850      *                          ////////////////
 851      *
 852      * When two screens overlap and the first contains a dock(*****), then
 853      * _NET_WORKAREA may start at point x1,y1 and end at point x2,y2.
 854      */
 855     @Override
 856     public Insets getScreenInsets(final GraphicsConfiguration gc) {
 857         GraphicsDevice gd = gc.getDevice();
 858         XNETProtocol np = XWM.getWM().getNETProtocol();
 859         if (np == null || !(gd instanceof X11GraphicsDevice) || !np.active()) {
 860             return super.getScreenInsets(gc);
 861         }
 862 
 863         XToolkit.awtLock();
 864         try
 865         {
 866             X11GraphicsEnvironment x11ge = (X11GraphicsEnvironment)
 867                     GraphicsEnvironment.getLocalGraphicsEnvironment();
 868             X11GraphicsConfig x11gc = (X11GraphicsConfig) gc;
 869             long root = XlibUtil.getRootWindow(x11gc.getDevice().getScreen());
 870             int scale = x11gc.getScale();
 871             if (x11ge.runningXinerama() &amp;&amp; checkSTRUT()) {
 872                 // implementation based on _NET_WM_STRUT/_NET_WM_STRUT_PARTIAL
 873                 Rectangle rootBounds = XlibUtil.getWindowGeometry(root, scale);
 874                 Insets insets = getScreenInsetsManually(root, rootBounds,
 875                                                         gc.getBounds(), scale);
 876                 if ((insets.left | insets.top | insets.bottom | insets.right) != 0
 877                         || rootBounds == null) {
 878                     return insets;
 879                 }
 880             }
 881             Rectangle workArea = XToolkit.getWorkArea(root, scale);
 882             Rectangle screen = gc.getBounds();
 883             if (workArea != null &amp;&amp; screen.contains(workArea.getLocation())) {
 884                 workArea = workArea.intersection(screen);
 885                 int top = workArea.y - screen.y;
 886                 int left = workArea.x - screen.x;
 887                 int bottom = screen.height - workArea.height - top;
 888                 int right = screen.width - workArea.width - left;
 889                 return new Insets(top, left, bottom, right);
 890             }
 891             // Note that it is better to return zeros than inadequate values
 892             return new Insets(0, 0, 0, 0);
 893         }
 894         finally
 895         {
 896             XToolkit.awtUnlock();
 897         }
 898     }
 899 
 900     /**
 901      * Returns the value of &quot;sun.awt.X11.checkSTRUT&quot; property. Default value is
 902      * {@code false}.
 903      */
 904     private static boolean checkSTRUT() {
 905         if (checkSTRUT == null) {
 906             checkSTRUT = AccessController.doPrivileged(
 907                     new GetBooleanAction(&quot;sun.awt.X11.checkSTRUT&quot;));
 908         }
 909         return checkSTRUT;
 910     }
 911 
 912     /*
 913      * Manual calculation of screen insets: get all the windows with
 914      * _NET_WM_STRUT/_NET_WM_STRUT_PARTIAL hints and add these
 915      * hints&#39; values to screen insets.
 916      *
 917      * This method should be called under XToolkit.awtLock()
 918      *
 919      * This method is unused by default because of two reasons:
 920      *  - Iteration over windows may be extremely slow, and execution of
 921      *    getScreenInsets() can be x100 slower than in one monitor config.
 922      *  - _NET_WM_STRUT/_NET_WM_STRUT_PARTIAL are hints for the applications.
 923      *    WM should take into account these hints when &quot;_NET_WORKAREA&quot; is
 924      *    calculated, but the system panels do not necessarily contain these
 925      *    hints(Gnome 3 for example).
 926      */
 927     private Insets getScreenInsetsManually(long root, Rectangle rootBounds,
 928                                            Rectangle screenBounds, int scale)
 929     {
 930         /*
 931          * During the manual calculation of screen insets we iterate
 932          * all the X windows hierarchy starting from root window. This
 933          * constant is the max level inspected in this hierarchy.
 934          * 3 is a heuristic value: I suppose any the toolbar-like
 935          * window is a child of either root or desktop window.
 936          */
 937         final int MAX_NESTED_LEVEL = 3;
 938 
 939         XAtom XA_NET_WM_STRUT = XAtom.get(&quot;_NET_WM_STRUT&quot;);
 940         XAtom XA_NET_WM_STRUT_PARTIAL = XAtom.get(&quot;_NET_WM_STRUT_PARTIAL&quot;);
 941 
 942         Insets insets = new Insets(0, 0, 0, 0);
 943 
 944         java.util.List&lt;Object&gt; search = new LinkedList&lt;&gt;();
 945         search.add(root);
 946         search.add(0);
 947         while (!search.isEmpty())
 948         {
 949             long window = (Long)search.remove(0);
 950             int windowLevel = (Integer)search.remove(0);
 951 
 952             /*
 953              * Note that most of the modern window managers unmap
 954              * application window if it is iconified. Thus, any
 955              * _NET_WM_STRUT[_PARTIAL] hints for iconified windows
 956              * are not included to the screen insets.
 957              */
 958             if (XlibUtil.getWindowMapState(window) == XConstants.IsUnmapped)
 959             {
 960                 continue;
 961             }
 962 
 963             long native_ptr = Native.allocateLongArray(4);
 964             try
 965             {
 966                 // first, check if _NET_WM_STRUT or _NET_WM_STRUT_PARTIAL are present
 967                 // if both are set on the window, _NET_WM_STRUT_PARTIAL is used (see _NET spec)
 968                 boolean strutPresent = XA_NET_WM_STRUT_PARTIAL.getAtomData(window, XAtom.XA_CARDINAL, native_ptr, 4);
 969                 if (!strutPresent)
 970                 {
 971                     strutPresent = XA_NET_WM_STRUT.getAtomData(window, XAtom.XA_CARDINAL, native_ptr, 4);
 972                 }
 973                 if (strutPresent)
 974                 {
 975                     // second, verify that window is located on the proper screen
 976                     Rectangle windowBounds = XlibUtil.getWindowGeometry(window,
 977                                                                         scale);
 978                     if (windowLevel &gt; 1)
 979                     {
 980                         windowBounds = XlibUtil.translateCoordinates(window, root,
 981                                                                      windowBounds,
 982                                                                      scale);
 983                     }
 984                     // if _NET_WM_STRUT_PARTIAL is present, we should use its values to detect
 985                     // if the struts area intersects with screenBounds, however some window
 986                     // managers don&#39;t set this hint correctly, so we just get intersection with windowBounds
 987                     if (windowBounds != null &amp;&amp; windowBounds.intersects(screenBounds))
 988                     {
 989                         int left = scaleDown((int)Native.getLong(native_ptr, 0), scale);
 990                         int right = scaleDown((int)Native.getLong(native_ptr, 1), scale);
 991                         int top = scaleDown((int)Native.getLong(native_ptr, 2), scale);
 992                         int bottom = scaleDown((int)Native.getLong(native_ptr, 3), scale);
 993 
 994                         /*
 995                          * struts could be relative to root window bounds, so
 996                          * make them relative to the screen bounds in this case
 997                          */
 998                         left = rootBounds.x + left &gt; screenBounds.x ?
 999                                 rootBounds.x + left - screenBounds.x : 0;
1000                         right = rootBounds.x + rootBounds.width - right &lt;
1001                                 screenBounds.x + screenBounds.width ?
1002                                 screenBounds.x + screenBounds.width -
1003                                 (rootBounds.x + rootBounds.width - right) : 0;
1004                         top = rootBounds.y + top &gt; screenBounds.y ?
1005                                 rootBounds.y + top - screenBounds.y : 0;
1006                         bottom = rootBounds.y + rootBounds.height - bottom &lt;
1007                                 screenBounds.y + screenBounds.height ?
1008                                 screenBounds.y + screenBounds.height -
1009                                 (rootBounds.y + rootBounds.height - bottom) : 0;
1010 
1011                         insets.left = Math.max(left, insets.left);
1012                         insets.right = Math.max(right, insets.right);
1013                         insets.top = Math.max(top, insets.top);
1014                         insets.bottom = Math.max(bottom, insets.bottom);
1015                     }
1016                 }
1017             }
1018             finally
1019             {
1020                 XlibWrapper.unsafe.freeMemory(native_ptr);
1021             }
1022 
1023             if (windowLevel &lt; MAX_NESTED_LEVEL)
1024             {
1025                 Set&lt;Long&gt; children = XlibUtil.getChildWindows(window);
1026                 for (long child : children)
1027                 {
1028                     search.add(child);
1029                     search.add(windowLevel + 1);
1030                 }
1031             }
1032         }
1033 
1034         return insets;
1035     }
1036 
1037     /*
1038      * The current implementation of disabling background erasing for
1039      * canvases is that we don&#39;t set any native background color
1040      * (with XSetWindowBackground) for the canvas window. However,
1041      * this color is set in the peer constructor - see
1042      * XWindow.postInit() for details. That&#39;s why this method from
1043      * SunToolkit is not overridden in XToolkit: it&#39;s too late to
1044      * disable background erasing :(
1045      */
1046     /*
1047     @Override
1048     public void disableBackgroundErase(Canvas canvas) {
1049         XCanvasPeer peer = (XCanvasPeer)canvas.getPeer();
1050         if (peer == null) {
1051             throw new IllegalStateException(&quot;Canvas must have a valid peer&quot;);
1052         }
1053         peer.disableBackgroundErase();
1054     }
1055     */
1056 
1057     // Need this for XMenuItemPeer.
1058     protected static Object targetToPeer(Object target) {
1059         Object p=null;
1060         if (target != null &amp;&amp; !GraphicsEnvironment.isHeadless()) {
1061             p = specialPeerMap.get(target);
1062         }
1063         if (p != null) return p;
1064         else
1065             return SunToolkit.targetToPeer(target);
1066     }
1067 
1068     // Need this for XMenuItemPeer.
1069     protected static void targetDisposedPeer(Object target, Object peer) {
1070         SunToolkit.targetDisposedPeer(target, peer);
1071     }
1072 
1073     @Override
1074     public RobotPeer createRobot(GraphicsDevice screen) throws AWTException {
1075         if (screen instanceof X11GraphicsDevice) {
1076             return new XRobotPeer((X11GraphicsDevice) screen);
1077         }
1078         return super.createRobot(screen);
1079     }
1080 
1081   /*
1082      * On X, support for dynamic layout on resizing is governed by the
1083      * window manager.  If the window manager supports it, it happens
1084      * automatically.  The setter method for this property is
1085      * irrelevant on X.
1086      */
1087     @Override
1088     public void setDynamicLayout(boolean b) {
1089         dynamicLayoutSetting = b;
1090     }
1091 
1092     @Override
1093     protected boolean isDynamicLayoutSet() {
1094         return dynamicLayoutSetting;
1095     }
1096 
1097     /* Called from isDynamicLayoutActive() and from
1098      * lazilyLoadDynamicLayoutSupportedProperty()
1099      */
1100     protected boolean isDynamicLayoutSupported() {
1101         return XWM.getWM().supportsDynamicLayout();
1102     }
1103 
1104     @Override
1105     public boolean isDynamicLayoutActive() {
1106         return isDynamicLayoutSupported();
1107     }
1108 
1109     @Override
1110     public FontPeer getFontPeer(String name, int style){
1111         return new XFontPeer(name, style);
1112     }
1113 
1114     @Override
1115     public DragSourceContextPeer createDragSourceContextPeer(DragGestureEvent dge) throws InvalidDnDOperationException {
1116         final LightweightFrame f = SunToolkit.getLightweightFrame(dge.getComponent());
1117         if (f != null) {
1118             return f.createDragSourceContextPeer(dge);
1119         }
1120 
1121         return XDragSourceContextPeer.createDragSourceContextPeer(dge);
1122     }
1123 
1124     @Override
1125     @SuppressWarnings(&quot;unchecked&quot;)
1126     public &lt;T extends DragGestureRecognizer&gt; T
1127     createDragGestureRecognizer(Class&lt;T&gt; recognizerClass,
1128                     DragSource ds,
1129                     Component c,
1130                     int srcActions,
1131                     DragGestureListener dgl)
1132     {
1133         final LightweightFrame f = SunToolkit.getLightweightFrame(c);
1134         if (f != null) {
1135             return f.createDragGestureRecognizer(recognizerClass, ds, c, srcActions, dgl);
1136         }
1137 
1138         if (MouseDragGestureRecognizer.class.equals(recognizerClass))
1139             return (T)new XMouseDragGestureRecognizer(ds, c, srcActions, dgl);
1140         else
1141             return null;
1142     }
1143 
1144     @Override
1145     public CheckboxMenuItemPeer createCheckboxMenuItem(CheckboxMenuItem target) {
1146         XCheckboxMenuItemPeer peer = new XCheckboxMenuItemPeer(target);
1147         //vb157120: looks like we don&#39;t need to map menu items
1148         //in new menus implementation
1149         //targetCreatedPeer(target, peer);
1150         return peer;
1151     }
1152 
1153     @Override
1154     public MenuItemPeer createMenuItem(MenuItem target) {
1155         XMenuItemPeer peer = new XMenuItemPeer(target);
1156         //vb157120: looks like we don&#39;t need to map menu items
1157         //in new menus implementation
1158         //targetCreatedPeer(target, peer);
1159         return peer;
1160     }
1161 
1162     @Override
1163     public TextFieldPeer createTextField(TextField target) {
1164         TextFieldPeer  peer = new XTextFieldPeer(target);
1165         targetCreatedPeer(target, peer);
1166         return peer;
1167     }
1168 
1169     @Override
1170     public LabelPeer createLabel(Label target) {
1171         LabelPeer  peer = new XLabelPeer(target);
1172         targetCreatedPeer(target, peer);
1173         return peer;
1174     }
1175 
1176     @Override
1177     public ListPeer createList(java.awt.List target) {
1178         ListPeer peer = new XListPeer(target);
1179         targetCreatedPeer(target, peer);
1180         return peer;
1181     }
1182 
1183     @Override
1184     public CheckboxPeer createCheckbox(Checkbox target) {
1185         CheckboxPeer peer = new XCheckboxPeer(target);
1186         targetCreatedPeer(target, peer);
1187         return peer;
1188     }
1189 
1190     @Override
1191     public ScrollbarPeer createScrollbar(Scrollbar target) {
1192         XScrollbarPeer peer = new XScrollbarPeer(target);
1193         targetCreatedPeer(target, peer);
1194         return peer;
1195     }
1196 
1197     @Override
1198     public ScrollPanePeer createScrollPane(ScrollPane target) {
1199         XScrollPanePeer peer = new XScrollPanePeer(target);
1200         targetCreatedPeer(target, peer);
1201         return peer;
1202     }
1203 
1204     @Override
1205     public TextAreaPeer createTextArea(TextArea target) {
1206         TextAreaPeer peer = new XTextAreaPeer(target);
1207         targetCreatedPeer(target, peer);
1208         return peer;
1209     }
1210 
1211     @Override
1212     public ChoicePeer createChoice(Choice target) {
1213         XChoicePeer peer = new XChoicePeer(target);
1214         targetCreatedPeer(target, peer);
1215         return peer;
1216     }
1217 
1218     @Override
1219     public CanvasPeer createCanvas(Canvas target) {
1220         XCanvasPeer peer = (isXEmbedServerRequested() ? new XEmbedCanvasPeer(target) : new XCanvasPeer(target));
1221         targetCreatedPeer(target, peer);
1222         return peer;
1223     }
1224 
1225     @Override
1226     public PanelPeer createPanel(Panel target) {
1227         PanelPeer peer = new XPanelPeer(target);
1228         targetCreatedPeer(target, peer);
1229         return peer;
1230     }
1231 
1232     @Override
1233     public WindowPeer createWindow(Window target) {
1234         WindowPeer peer = new XWindowPeer(target);
1235         targetCreatedPeer(target, peer);
1236         return peer;
1237     }
1238 
1239     @Override
1240     public DialogPeer createDialog(Dialog target) {
1241         DialogPeer peer = new XDialogPeer(target);
1242         targetCreatedPeer(target, peer);
1243         return peer;
1244     }
1245 
1246     private static Boolean sunAwtDisableGtkFileDialogs = null;
1247 
1248     /**
1249      * Returns the value of &quot;sun.awt.disableGtkFileDialogs&quot; property. Default
1250      * value is {@code false}.
1251      */
1252     public static synchronized boolean getSunAwtDisableGtkFileDialogs() {
1253         if (sunAwtDisableGtkFileDialogs == null) {
1254             sunAwtDisableGtkFileDialogs = AccessController.doPrivileged(
1255                                               new GetBooleanAction(&quot;sun.awt.disableGtkFileDialogs&quot;));
1256         }
1257         return sunAwtDisableGtkFileDialogs.booleanValue();
1258     }
1259 
1260     @Override
1261     public FileDialogPeer createFileDialog(FileDialog target) {
1262         FileDialogPeer peer = null;
1263         // The current GtkFileChooser is available from GTK+ 2.4
1264         if (!getSunAwtDisableGtkFileDialogs() &amp;&amp;
1265                       (checkGtkVersion(2, 4, 0) || checkGtkVersion(3, 0, 0))) {
1266             peer = new GtkFileDialogPeer(target);
1267         } else {
1268             peer = new XFileDialogPeer(target);
1269         }
1270         targetCreatedPeer(target, peer);
1271         return peer;
1272     }
1273 
1274     @Override
1275     public MenuBarPeer createMenuBar(MenuBar target) {
1276         XMenuBarPeer peer = new XMenuBarPeer(target);
1277         targetCreatedPeer(target, peer);
1278         return peer;
1279     }
1280 
1281     @Override
1282     public MenuPeer createMenu(Menu target) {
1283         XMenuPeer peer = new XMenuPeer(target);
1284         //vb157120: looks like we don&#39;t need to map menu items
1285         //in new menus implementation
1286         //targetCreatedPeer(target, peer);
1287         return peer;
1288     }
1289 
1290     @Override
1291     public PopupMenuPeer createPopupMenu(PopupMenu target) {
1292         XPopupMenuPeer peer = new XPopupMenuPeer(target);
1293         targetCreatedPeer(target, peer);
1294         return peer;
1295     }
1296 
1297     @Override
1298     public synchronized MouseInfoPeer getMouseInfoPeer() {
1299         if (xPeer == null) {
1300             xPeer = new XMouseInfoPeer();
1301         }
1302         return xPeer;
1303     }
1304 
1305     public XEmbeddedFramePeer createEmbeddedFrame(XEmbeddedFrame target)
1306     {
1307         XEmbeddedFramePeer peer = new XEmbeddedFramePeer(target);
1308         targetCreatedPeer(target, peer);
1309         return peer;
1310     }
1311 
1312     XEmbedChildProxyPeer createEmbedProxy(XEmbedChildProxy target) {
1313         XEmbedChildProxyPeer peer = new XEmbedChildProxyPeer(target);
1314         targetCreatedPeer(target, peer);
1315         return peer;
1316     }
1317 
1318     @Override
1319     public KeyboardFocusManagerPeer getKeyboardFocusManagerPeer() throws HeadlessException {
1320         return XKeyboardFocusManagerPeer.getInstance();
1321     }
1322 
1323     /**
1324      * Returns a new custom cursor.
1325      */
1326     @Override
1327     public Cursor createCustomCursor(Image cursor, Point hotSpot, String name)
1328       throws IndexOutOfBoundsException {
1329         return new XCustomCursor(cursor, hotSpot, name);
1330     }
1331 
1332     @Override
1333     public TrayIconPeer createTrayIcon(TrayIcon target)
1334       throws HeadlessException, AWTException
1335     {
1336         TrayIconPeer peer = new XTrayIconPeer(target);
1337         targetCreatedPeer(target, peer);
1338         return peer;
1339     }
1340 
1341     @Override
1342     public SystemTrayPeer createSystemTray(SystemTray target) throws HeadlessException {
1343         SystemTrayPeer peer = new XSystemTrayPeer(target);
1344         return peer;
1345     }
1346 
1347     @Override
1348     public boolean isTraySupported() {
1349         XSystemTrayPeer peer = XSystemTrayPeer.getPeerInstance();
1350         if (peer != null) {
1351             return peer.isAvailable();
1352         }
1353         return false;
1354     }
1355 
1356     @Override
1357     public DataTransferer getDataTransferer() {
1358         return XDataTransferer.getInstanceImpl();
1359     }
1360 
1361     /**
1362      * Returns the supported cursor size
1363      */
1364     @Override
1365     public Dimension getBestCursorSize(int preferredWidth, int preferredHeight) {
1366         return XCustomCursor.getBestCursorSize(
1367                                                java.lang.Math.max(1,preferredWidth), java.lang.Math.max(1,preferredHeight));
1368     }
1369 
1370 
1371     @Override
1372     public int getMaximumCursorColors() {
1373         return 2;  // Black and white.
1374     }
1375 
1376     @Override
1377     public Map&lt;TextAttribute, ?&gt; mapInputMethodHighlight( InputMethodHighlight highlight) {
1378         return XInputMethod.mapInputMethodHighlight(highlight);
1379     }
1380     @Override
1381     public boolean getLockingKeyState(int key) {
1382         if (! (key == KeyEvent.VK_CAPS_LOCK || key == KeyEvent.VK_NUM_LOCK ||
1383                key == KeyEvent.VK_SCROLL_LOCK || key == KeyEvent.VK_KANA_LOCK)) {
1384             throw new IllegalArgumentException(&quot;invalid key for Toolkit.getLockingKeyState&quot;);
1385         }
1386         awtLock();
1387         try {
1388             return getModifierState( key );
1389         } finally {
1390             awtUnlock();
1391         }
1392     }
1393 
1394     @Override
1395     public  Clipboard getSystemClipboard() {
1396         SecurityManager security = System.getSecurityManager();
1397         if (security != null) {
1398             security.checkPermission(AWTPermissions.ACCESS_CLIPBOARD_PERMISSION);
1399         }
1400         synchronized (this) {
1401             if (clipboard == null) {
1402                 clipboard = new XClipboard(&quot;System&quot;, &quot;CLIPBOARD&quot;);
1403             }
1404         }
1405         return clipboard;
1406     }
1407 
1408     @Override
1409     public Clipboard getSystemSelection() {
1410         SecurityManager security = System.getSecurityManager();
1411         if (security != null) {
1412             security.checkPermission(AWTPermissions.ACCESS_CLIPBOARD_PERMISSION);
1413         }
1414         synchronized (this) {
1415             if (selection == null) {
1416                 selection = new XClipboard(&quot;Selection&quot;, &quot;PRIMARY&quot;);
1417             }
1418         }
1419         return selection;
1420     }
1421 
1422     @Override
1423     public void beep() {
1424         awtLock();
1425         try {
1426             XlibWrapper.XBell(getDisplay(), 0);
1427             XlibWrapper.XFlush(getDisplay());
1428         } finally {
1429             awtUnlock();
1430         }
1431     }
1432 
1433     @Override
1434     public PrintJob getPrintJob(final Frame frame, final String doctitle,
1435                                 final Properties props) {
1436 
1437         if (frame == null) {
1438             throw new NullPointerException(&quot;frame must not be null&quot;);
1439         }
1440 
1441         PrintJob2D printJob = new PrintJob2D(frame, doctitle, props);
1442 
1443         if (printJob.printDialog() == false) {
1444             printJob = null;
1445         }
1446         return printJob;
1447     }
1448 
1449     @Override
1450     public PrintJob getPrintJob(final Frame frame, final String doctitle,
1451                 final JobAttributes jobAttributes,
1452                 final PageAttributes pageAttributes)
1453     {
1454         if (frame == null) {
1455             throw new NullPointerException(&quot;frame must not be null&quot;);
1456         }
1457 
1458         PrintJob2D printJob = new PrintJob2D(frame, doctitle,
1459                                              jobAttributes, pageAttributes);
1460 
1461         if (printJob.printDialog() == false) {
1462             printJob = null;
1463         }
1464 
1465         return printJob;
1466     }
1467 
1468     static void XSync() {
1469         awtLock();
1470         try {
1471             XlibWrapper.XSync(getDisplay(),0);
1472         } finally {
1473             awtUnlock();
1474         }
1475     }
1476 
1477     @Override
1478     public int getScreenResolution() {
1479         long display = getDisplay();
1480         awtLock();
1481         try {
1482             return (int) ((XlibWrapper.DisplayWidth(display,
1483                 XlibWrapper.DefaultScreen(display)) * 25.4) /
1484                     XlibWrapper.DisplayWidthMM(display,
1485                 XlibWrapper.DefaultScreen(display)));
1486         } finally {
1487             awtUnlock();
1488         }
1489     }
1490 
1491     static native long getDefaultXColormap();
<a name="3" id="anc3"></a>
1492 
1493     /**
1494      * Returns a new input method adapter descriptor for native input methods.
1495      */
1496     @Override
1497     public InputMethodDescriptor getInputMethodAdapterDescriptor() throws AWTException {
1498         return new XInputMethodDescriptor();
1499     }
1500 
1501     /**
1502      * Returns whether enableInputMethods should be set to true for peered
1503      * TextComponent instances on this platform. True by default.
1504      */
1505     @Override
1506     public boolean enableInputMethodsForTextComponent() {
1507         return true;
1508     }
1509 
1510     static int getMultiClickTime() {
1511         if (awt_multiclick_time == 0) {
1512             initializeMultiClickTime();
1513         }
1514         return awt_multiclick_time;
1515     }
1516     static void initializeMultiClickTime() {
1517         awtLock();
1518         try {
1519             try {
1520                 String multiclick_time_query = XlibWrapper.XGetDefault(XToolkit.getDisplay(), &quot;*&quot;, &quot;multiClickTime&quot;);
1521                 if (multiclick_time_query != null) {
1522                     awt_multiclick_time = (int)Long.parseLong(multiclick_time_query);
1523                 } else {
1524                     multiclick_time_query = XlibWrapper.XGetDefault(XToolkit.getDisplay(),
1525                                                                     &quot;OpenWindows&quot;, &quot;MultiClickTimeout&quot;);
1526                     if (multiclick_time_query != null) {
1527                         /* Note: OpenWindows.MultiClickTimeout is in tenths of
1528                            a second, so we need to multiply by 100 to convert to
1529                            milliseconds */
1530                         awt_multiclick_time = (int)Long.parseLong(multiclick_time_query) * 100;
1531                     } else {
1532                         awt_multiclick_time = AWT_MULTICLICK_DEFAULT_TIME;
1533                     }
1534                 }
1535             } catch (NumberFormatException nf) {
1536                 awt_multiclick_time = AWT_MULTICLICK_DEFAULT_TIME;
1537             } catch (NullPointerException npe) {
1538                 awt_multiclick_time = AWT_MULTICLICK_DEFAULT_TIME;
1539             }
1540         } finally {
1541             awtUnlock();
1542         }
1543         if (awt_multiclick_time == 0) {
1544             awt_multiclick_time = AWT_MULTICLICK_DEFAULT_TIME;
1545         }
1546     }
1547 
1548     @Override
1549     public boolean isFrameStateSupported(int state)
1550       throws HeadlessException
1551     {
1552         if (state == Frame.NORMAL || state == Frame.ICONIFIED) {
1553             return true;
1554         } else {
1555             return XWM.getWM().supportsExtendedState(state);
1556         }
1557     }
1558 
1559     static void dumpPeers() {
1560         if (log.isLoggable(PlatformLogger.Level.FINE)) {
1561             log.fine(&quot;Mapped windows:&quot;);
1562             winMap.forEach((k, v) -&gt; {
1563                 log.fine(k + &quot;-&gt;&quot; + v);
1564                 if (v instanceof XComponentPeer) {
1565                     Component target = (Component)((XComponentPeer)v).getTarget();
1566                     log.fine(&quot;\ttarget: &quot; + target);
1567                 }
1568             });
1569 
1570             SunToolkit.dumpPeers(log);
1571 
1572             log.fine(&quot;Mapped special peers:&quot;);
1573             specialPeerMap.forEach((k, v) -&gt; {
1574                 log.fine(k + &quot;-&gt;&quot; + v);
1575             });
1576 
1577             log.fine(&quot;Mapped dispatchers:&quot;);
1578             winToDispatcher.forEach((k, v) -&gt; {
1579                 log.fine(k + &quot;-&gt;&quot; + v);
1580             });
1581         }
1582     }
1583 
1584     /* Protected with awt_lock. */
1585     private static boolean initialized;
1586     private static boolean timeStampUpdated;
1587     private static long timeStamp;
1588 
1589     private static final XEventDispatcher timeFetcher =
1590     new XEventDispatcher() {
1591             @Override
1592             public void dispatchEvent(XEvent ev) {
1593                 switch (ev.get_type()) {
1594                   case XConstants.PropertyNotify:
1595                       XPropertyEvent xpe = ev.get_xproperty();
1596 
1597                       awtLock();
1598                       try {
1599                           timeStamp = xpe.get_time();
1600                           timeStampUpdated = true;
1601                           awtLockNotifyAll();
1602                       } finally {
1603                           awtUnlock();
1604                       }
1605 
1606                       break;
1607                 }
1608             }
1609         };
1610 
1611     private static XAtom _XA_JAVA_TIME_PROPERTY_ATOM;
1612 
1613     static long getCurrentServerTime() {
1614         awtLock();
1615         try {
1616             try {
1617                 if (!initialized) {
1618                     XToolkit.addEventDispatcher(XBaseWindow.getXAWTRootWindow().getWindow(),
1619                                                 timeFetcher);
1620                     _XA_JAVA_TIME_PROPERTY_ATOM = XAtom.get(&quot;_SUNW_JAVA_AWT_TIME&quot;);
1621                     initialized = true;
1622                 }
1623                 timeStampUpdated = false;
1624                 XlibWrapper.XChangeProperty(XToolkit.getDisplay(),
1625                                             XBaseWindow.getXAWTRootWindow().getWindow(),
1626                                             _XA_JAVA_TIME_PROPERTY_ATOM.getAtom(), XAtom.XA_ATOM, 32,
1627                                             XConstants.PropModeAppend,
1628                                             0, 0);
1629                 XlibWrapper.XFlush(XToolkit.getDisplay());
1630 
1631                 if (isToolkitThread()) {
1632                     XEvent event = new XEvent();
1633                     try {
1634                         XlibWrapper.XWindowEvent(XToolkit.getDisplay(),
1635                                                  XBaseWindow.getXAWTRootWindow().getWindow(),
1636                                                  XConstants.PropertyChangeMask,
1637                                                  event.pData);
1638                         timeFetcher.dispatchEvent(event);
1639                     }
1640                     finally {
1641                         event.dispose();
1642                     }
1643                 }
1644                 else {
1645                     while (!timeStampUpdated) {
1646                         awtLockWait();
1647                     }
1648                 }
1649             } catch (InterruptedException ie) {
1650             // Note: the returned timeStamp can be incorrect in this case.
1651                 if (log.isLoggable(PlatformLogger.Level.FINE)) {
1652                     log.fine(&quot;Catched exception, timeStamp may not be correct (ie = &quot; + ie + &quot;)&quot;);
1653                 }
1654             }
1655         } finally {
1656             awtUnlock();
1657         }
1658         return timeStamp;
1659     }
1660     @Override
1661     protected void initializeDesktopProperties() {
1662         desktopProperties.put(&quot;DnD.Autoscroll.initialDelay&quot;,
1663                               Integer.valueOf(50));
1664         desktopProperties.put(&quot;DnD.Autoscroll.interval&quot;,
1665                               Integer.valueOf(50));
1666         desktopProperties.put(&quot;DnD.Autoscroll.cursorHysteresis&quot;,
1667                               Integer.valueOf(5));
1668         desktopProperties.put(&quot;Shell.shellFolderManager&quot;,
1669                               &quot;sun.awt.shell.ShellFolderManager&quot;);
1670         // Don&#39;t want to call getMultiClickTime() if we are headless
1671         if (!GraphicsEnvironment.isHeadless()) {
1672             desktopProperties.put(&quot;awt.multiClickInterval&quot;,
1673                                   Integer.valueOf(getMultiClickTime()));
1674             desktopProperties.put(&quot;awt.mouse.numButtons&quot;,
1675                                   Integer.valueOf(getNumberOfButtons()));
1676             if(SunGraphicsEnvironment.isUIScaleEnabled()) {
1677                 addPropertyChangeListener(&quot;gnome.Xft/DPI&quot;, evt -&gt;
1678                                                      localEnv.displayChanged());
1679             }
1680         }
1681     }
1682 
1683     /**
1684      * This method runs through the XPointer and XExtendedPointer array.
1685      * XExtendedPointer has priority because on some systems XPointer
1686      * (which is assigned to the virtual pointer) reports the maximum
1687      * capabilities of the mouse pointer (i.e. 32 physical buttons).
1688      */
1689     private native int getNumberOfButtonsImpl();
1690 
1691     @Override
1692     public int getNumberOfButtons(){
1693         awtLock();
1694         try {
1695             if (numberOfButtons == 0) {
1696                 numberOfButtons = getNumberOfButtonsImpl();
1697                 numberOfButtons = (numberOfButtons &gt; MAX_BUTTONS_SUPPORTED)? MAX_BUTTONS_SUPPORTED : numberOfButtons;
1698                 //4th and 5th buttons are for wheel and shouldn&#39;t be reported as buttons.
1699                 //If we have more than 3 physical buttons and a wheel, we report N-2 buttons.
1700                 //If we have 3 physical buttons and a wheel, we report 3 buttons.
1701                 //If we have 1,2,3 physical buttons, we report it as is i.e. 1,2 or 3 respectively.
1702                 if (numberOfButtons &gt;=5) {
1703                     numberOfButtons -= 2;
1704                 } else if (numberOfButtons == 4 || numberOfButtons ==5){
1705                     numberOfButtons = 3;
1706                 }
1707             }
1708             //Assume don&#39;t have to re-query the number again and again.
1709             return numberOfButtons;
1710         } finally {
1711             awtUnlock();
1712         }
1713     }
1714 
1715     static int getNumberOfButtonsForMask() {
1716         return Math.min(XConstants.MAX_BUTTONS, ((SunToolkit) (Toolkit.getDefaultToolkit())).getNumberOfButtons());
1717     }
1718 
1719     private static final String prefix  = &quot;DnD.Cursor.&quot;;
1720     private static final String postfix = &quot;.32x32&quot;;
1721     private static final String dndPrefix  = &quot;DnD.&quot;;
1722 
1723     @Override
1724     protected Object lazilyLoadDesktopProperty(String name) {
1725         if (name.startsWith(prefix)) {
1726             String cursorName = name.substring(prefix.length(), name.length()) + postfix;
1727 
1728             try {
1729                 return Cursor.getSystemCustomCursor(cursorName);
1730             } catch (AWTException awte) {
1731                 throw new RuntimeException(&quot;cannot load system cursor: &quot; + cursorName, awte);
1732             }
1733         }
1734 
1735         if (name.equals(&quot;awt.dynamicLayoutSupported&quot;)) {
1736             return  Boolean.valueOf(isDynamicLayoutSupported());
1737         }
1738 
1739         if (initXSettingsIfNeeded(name)) {
1740             return desktopProperties.get(name);
1741         }
1742 
1743         return super.lazilyLoadDesktopProperty(name);
1744     }
1745 
1746     @Override
1747     public synchronized void addPropertyChangeListener(String name, PropertyChangeListener pcl) {
1748         if (name == null) {
1749             // See JavaDoc for the Toolkit.addPropertyChangeListener() method
1750             return;
1751         }
1752         initXSettingsIfNeeded(name);
1753         super.addPropertyChangeListener(name, pcl);
1754     }
1755 
1756     /**
1757      * Initializes XAWTXSettings if a property for a given property name is provided by
1758      * XSettings and they are not initialized yet.
1759      *
1760      * @return true if the method has initialized XAWTXSettings.
1761      */
1762     private boolean initXSettingsIfNeeded(final String propName) {
1763         if (!loadedXSettings &amp;&amp;
1764             (propName.startsWith(&quot;gnome.&quot;) ||
1765              propName.equals(SunToolkit.DESKTOPFONTHINTS) ||
1766              propName.startsWith(dndPrefix)))
1767         {
1768             loadedXSettings = true;
1769             if (!GraphicsEnvironment.isHeadless()) {
1770                 loadXSettings();
1771                 /* If no desktop font hint could be retrieved, check for
1772                  * KDE running KWin and retrieve settings from fontconfig.
1773                  * If that isn&#39;t found let SunToolkit will see if there&#39;s a
1774                  * system property set by a user.
1775                  */
1776                 if (desktopProperties.get(SunToolkit.DESKTOPFONTHINTS) == null) {
1777                     if (XWM.isKDE2()) {
1778                         Object hint = FontConfigManager.getFontConfigAAHint();
1779                         if (hint != null) {
1780                             /* set the fontconfig/KDE property so that
1781                              * getDesktopHints() below will see it
1782                              * and set the public property.
1783                              */
1784                             desktopProperties.put(UNIXToolkit.FONTCONFIGAAHINT,
1785                                                   hint);
1786                         }
1787                     }
1788                     desktopProperties.put(SunToolkit.DESKTOPFONTHINTS,
1789                                           SunToolkit.getDesktopFontHints());
1790                 }
1791 
1792                 return true;
1793             }
1794         }
1795         return false;
1796     }
1797 
1798     private void loadXSettings() {
1799        xs = new XAWTXSettings();
1800     }
1801 
1802     /**
1803      * Callback from the native side indicating some, or all, of the
1804      * desktop properties have changed and need to be reloaded.
1805      * {@code data} is the byte array directly from the x server and
1806      * may be in little endian format.
1807      * &lt;p&gt;
1808      * NB: This could be called from any thread if triggered by
1809      * {@code loadXSettings}.  It is called from the System EDT
1810      * if triggered by an XSETTINGS change.
1811      */
1812     void parseXSettings(int screen_XXX_ignored,Map&lt;String, Object&gt; updatedSettings) {
1813 
1814         if (updatedSettings == null || updatedSettings.isEmpty()) {
1815             return;
1816         }
1817 
1818         Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; i = updatedSettings.entrySet().iterator();
1819         while (i.hasNext()) {
1820             Map.Entry&lt;String, Object&gt; e = i.next();
1821             String name = e.getKey();
1822 
1823             name = &quot;gnome.&quot; + name;
1824             setDesktopProperty(name, e.getValue());
1825             if (log.isLoggable(PlatformLogger.Level.FINE)) {
1826                 log.fine(&quot;name = &quot; + name + &quot; value = &quot; + e.getValue());
1827             }
1828 
1829             // XXX: we probably want to do something smarter.  In
1830             // particular, &quot;Net&quot; properties are of interest to the
1831             // &quot;core&quot; AWT itself.  E.g.
1832             //
1833             // Net/DndDragThreshold -&gt; ???
1834             // Net/DoubleClickTime  -&gt; awt.multiClickInterval
1835         }
1836 
1837         setDesktopProperty(SunToolkit.DESKTOPFONTHINTS,
1838                            SunToolkit.getDesktopFontHints());
1839 
1840         Integer dragThreshold = null;
1841         synchronized (this) {
1842             dragThreshold = (Integer)desktopProperties.get(&quot;gnome.Net/DndDragThreshold&quot;);
1843         }
1844         if (dragThreshold != null) {
1845             setDesktopProperty(&quot;DnD.gestureMotionThreshold&quot;, dragThreshold);
1846         }
1847 
1848     }
1849 
1850 
1851 
1852     static int altMask;
1853     static int metaMask;
1854     static int numLockMask;
1855     static int modeSwitchMask;
1856     static int modLockIsShiftLock;
1857 
1858     /* Like XKeysymToKeycode, but ensures that keysym is the primary
1859     * symbol on the keycode returned.  Returns zero otherwise.
1860     */
1861     static int keysymToPrimaryKeycode(long sym) {
1862         awtLock();
1863         try {
1864             int code = XlibWrapper.XKeysymToKeycode(getDisplay(), sym);
1865             if (code == 0) {
1866                 return 0;
1867             }
1868             long primary = XlibWrapper.XKeycodeToKeysym(getDisplay(), code, 0);
1869             if (sym != primary) {
1870                 return 0;
1871             }
1872             return code;
1873         } finally {
1874             awtUnlock();
1875         }
1876     }
1877     static boolean getModifierState( int jkc ) {
1878         int iKeyMask = 0;
1879         long ks = XKeysym.javaKeycode2Keysym( jkc );
1880         int  kc = XlibWrapper.XKeysymToKeycode(getDisplay(), ks);
1881         if (kc == 0) {
1882             return false;
1883         }
1884         awtLock();
1885         try {
1886             XModifierKeymap modmap = new XModifierKeymap(
1887                  XlibWrapper.XGetModifierMapping(getDisplay()));
1888 
1889             int nkeys = modmap.get_max_keypermod();
1890 
1891             long map_ptr = modmap.get_modifiermap();
1892             for( int k = 0; k &lt; 8; k++ ) {
1893                 for (int i = 0; i &lt; nkeys; ++i) {
1894                     int keycode = Native.getUByte(map_ptr, k * nkeys + i);
1895                     if (keycode == 0) {
1896                         continue; // ignore zero keycode
1897                     }
1898                     if (kc == keycode) {
1899                         iKeyMask = 1 &lt;&lt; k;
1900                         break;
1901                     }
1902                 }
1903                 if( iKeyMask != 0 ) {
1904                     break;
1905                 }
1906             }
1907             XlibWrapper.XFreeModifiermap(modmap.pData);
1908             if (iKeyMask == 0 ) {
1909                 return false;
1910             }
1911             // Now we know to which modifier is assigned the keycode
1912             // correspondent to the keysym correspondent to the java
1913             // keycode. We are going to check a state of this modifier.
1914             // If a modifier is a weird one, we cannot help it.
1915             long window = 0;
1916             try{
1917                 // get any application window
1918                 window = winMap.firstKey().longValue();
1919             }catch(NoSuchElementException nex) {
1920                 // get root window
1921                 window = getDefaultRootWindow();
1922             }
1923             boolean res = XlibWrapper.XQueryPointer(getDisplay(), window,
1924                                             XlibWrapper.larg1, //root
1925                                             XlibWrapper.larg2, //child
1926                                             XlibWrapper.larg3, //root_x
1927                                             XlibWrapper.larg4, //root_y
1928                                             XlibWrapper.larg5, //child_x
1929                                             XlibWrapper.larg6, //child_y
1930                                             XlibWrapper.larg7);//mask
1931             int mask = Native.getInt(XlibWrapper.larg7);
1932             return ((mask &amp; iKeyMask) != 0);
1933         } finally {
1934             awtUnlock();
1935         }
1936     }
1937 
1938     /* Assign meaning - alt, meta, etc. - to X modifiers mod1 ... mod5.
1939      * Only consider primary symbols on keycodes attached to modifiers.
1940      */
1941     static void setupModifierMap() {
1942         final int metaL = keysymToPrimaryKeycode(XKeySymConstants.XK_Meta_L);
1943         final int metaR = keysymToPrimaryKeycode(XKeySymConstants.XK_Meta_R);
1944         final int altL = keysymToPrimaryKeycode(XKeySymConstants.XK_Alt_L);
1945         final int altR = keysymToPrimaryKeycode(XKeySymConstants.XK_Alt_R);
1946         final int numLock = keysymToPrimaryKeycode(XKeySymConstants.XK_Num_Lock);
1947         final int modeSwitch = keysymToPrimaryKeycode(XKeySymConstants.XK_Mode_switch);
1948         final int shiftLock = keysymToPrimaryKeycode(XKeySymConstants.XK_Shift_Lock);
1949         final int capsLock  = keysymToPrimaryKeycode(XKeySymConstants.XK_Caps_Lock);
1950 
1951         final int[] modmask = { XConstants.ShiftMask, XConstants.LockMask, XConstants.ControlMask, XConstants.Mod1Mask,
1952             XConstants.Mod2Mask, XConstants.Mod3Mask, XConstants.Mod4Mask, XConstants.Mod5Mask };
1953 
1954         log.fine(&quot;In setupModifierMap&quot;);
1955         awtLock();
1956         try {
1957             XModifierKeymap modmap = new XModifierKeymap(
1958                  XlibWrapper.XGetModifierMapping(getDisplay()));
1959 
1960             int nkeys = modmap.get_max_keypermod();
1961 
1962             long map_ptr = modmap.get_modifiermap();
1963 
1964             for (int modn = XConstants.Mod1MapIndex;
1965                  modn &lt;= XConstants.Mod5MapIndex;
1966                  ++modn)
1967             {
1968                 for (int i = 0; i &lt; nkeys; ++i) {
1969                     /* for each keycode attached to this modifier */
1970                     int keycode = Native.getUByte(map_ptr, modn * nkeys + i);
1971 
1972                     if (keycode == 0) {
1973                         break;
1974                     }
1975                     if (metaMask == 0 &amp;&amp;
1976                         (keycode == metaL || keycode == metaR))
1977                     {
1978                         metaMask = modmask[modn];
1979                         break;
1980                     }
1981                     if (altMask == 0 &amp;&amp; (keycode == altL || keycode == altR)) {
1982                         altMask = modmask[modn];
1983                         break;
1984                     }
1985                     if (numLockMask == 0 &amp;&amp; keycode == numLock) {
1986                         numLockMask = modmask[modn];
1987                         break;
1988                     }
1989                     if (modeSwitchMask == 0 &amp;&amp; keycode == modeSwitch) {
1990                         modeSwitchMask = modmask[modn];
1991                         break;
1992                     }
1993                     continue;
1994                 }
1995             }
1996             modLockIsShiftLock = 0;
1997             for (int j = 0; j &lt; nkeys; ++j) {
1998                 int keycode = Native.getUByte(map_ptr, XConstants.LockMapIndex * nkeys + j);
1999                 if (keycode == 0) {
2000                     break;
2001                 }
2002                 if (keycode == shiftLock) {
2003                     modLockIsShiftLock = 1;
2004                     break;
2005                 }
2006                 if (keycode == capsLock) {
2007                     break;
2008                 }
2009             }
2010             XlibWrapper.XFreeModifiermap(modmap.pData);
2011         } finally {
2012             awtUnlock();
2013         }
2014         if (log.isLoggable(PlatformLogger.Level.FINE)) {
2015             log.fine(&quot;metaMask = &quot; + metaMask);
2016             log.fine(&quot;altMask = &quot; + altMask);
2017             log.fine(&quot;numLockMask = &quot; + numLockMask);
2018             log.fine(&quot;modeSwitchMask = &quot; + modeSwitchMask);
2019             log.fine(&quot;modLockIsShiftLock = &quot; + modLockIsShiftLock);
2020         }
2021     }
2022 
2023 
2024     private static SortedMap&lt;Long, java.util.List&lt;Runnable&gt;&gt; timeoutTasks;
2025 
2026     /**
2027      * Removed the task from the list of waiting-to-be called tasks.
2028      * If the task has been scheduled several times removes only first one.
2029      */
2030     static void remove(Runnable task) {
2031         if (task == null) {
2032             throw new NullPointerException(&quot;task is null&quot;);
2033         }
2034         awtLock();
2035         try {
2036             if (timeoutTaskLog.isLoggable(PlatformLogger.Level.FINER)) {
2037                 timeoutTaskLog.finer(&quot;Removing task &quot; + task);
2038             }
2039             if (timeoutTasks == null) {
2040                 if (timeoutTaskLog.isLoggable(PlatformLogger.Level.FINER)) {
2041                     timeoutTaskLog.finer(&quot;Task is not scheduled&quot;);
2042                 }
2043                 return;
2044             }
2045             Collection&lt;java.util.List&lt;Runnable&gt;&gt; values = timeoutTasks.values();
2046             Iterator&lt;java.util.List&lt;Runnable&gt;&gt; iter = values.iterator();
2047             while (iter.hasNext()) {
2048                 java.util.List&lt;Runnable&gt; list = iter.next();
2049                 boolean removed = false;
2050                 if (list.contains(task)) {
2051                     list.remove(task);
2052                     if (list.isEmpty()) {
2053                         iter.remove();
2054                     }
2055                     break;
2056                 }
2057             }
2058         } finally {
2059             awtUnlock();
2060         }
2061     }
2062 
2063     static native void wakeup_poll();
2064 
2065     /**
2066      * Registers a Runnable which {@code run()} method will be called
2067      * once on the toolkit thread when a specified interval of time elapses.
2068      *
2069      * @param task a Runnable which {@code run} method will be called
2070      *        on the toolkit thread when {@code interval} milliseconds
2071      *        elapse
2072      * @param interval an interal in milliseconds
2073      *
2074      * @throws NullPointerException if {@code task} is {@code null}
2075      * @throws IllegalArgumentException if {@code interval} is not positive
2076      */
2077     static void schedule(Runnable task, long interval) {
2078         if (task == null) {
2079             throw new NullPointerException(&quot;task is null&quot;);
2080         }
2081         if (interval &lt;= 0) {
2082             throw new IllegalArgumentException(&quot;interval &quot; + interval + &quot; is not positive&quot;);
2083         }
2084 
2085         awtLock();
2086         try {
2087             if (timeoutTaskLog.isLoggable(PlatformLogger.Level.FINER)) {
2088                 timeoutTaskLog.finer(&quot;XToolkit.schedule(): current time={0}&quot; +
2089                                      &quot;;  interval={1}&quot; +
2090                                      &quot;;  task being added={2}&quot; + &quot;;  tasks before addition={3}&quot;,
2091                                      Long.valueOf(System.currentTimeMillis()), Long.valueOf(interval), task, timeoutTasks);
2092             }
2093 
2094             if (timeoutTasks == null) {
2095                 timeoutTasks = new TreeMap&lt;&gt;();
2096             }
2097 
2098             Long time = Long.valueOf(System.currentTimeMillis() + interval);
2099             java.util.List&lt;Runnable&gt; tasks = timeoutTasks.get(time);
2100             if (tasks == null) {
2101                 tasks = new ArrayList&lt;&gt;(1);
2102                 timeoutTasks.put(time, tasks);
2103             }
2104             tasks.add(task);
2105 
2106 
2107             if (timeoutTasks.get(timeoutTasks.firstKey()) == tasks &amp;&amp; tasks.size() == 1) {
2108                 // Added task became first task - poll won&#39;t know
2109                 // about it so we need to wake it up
2110                 wakeup_poll();
2111             }
2112         }  finally {
2113             awtUnlock();
2114         }
2115     }
2116 
2117     private long getNextTaskTime() {
2118         awtLock();
2119         try {
2120             if (timeoutTasks == null || timeoutTasks.isEmpty()) {
2121                 return -1L;
2122             }
2123             return timeoutTasks.firstKey();
2124         } finally {
2125             awtUnlock();
2126         }
2127     }
2128 
2129     /**
2130      * Executes mature timeout tasks registered with schedule().
2131      * Called from run() under awtLock.
2132      */
2133     private static void callTimeoutTasks() {
2134         if (timeoutTaskLog.isLoggable(PlatformLogger.Level.FINER)) {
2135             timeoutTaskLog.finer(&quot;XToolkit.callTimeoutTasks(): current time={0}&quot; +
2136                                  &quot;;  tasks={1}&quot;, Long.valueOf(System.currentTimeMillis()), timeoutTasks);
2137         }
2138 
2139         if (timeoutTasks == null || timeoutTasks.isEmpty()) {
2140             return;
2141         }
2142 
2143         Long currentTime = Long.valueOf(System.currentTimeMillis());
2144         Long time = timeoutTasks.firstKey();
2145 
2146         while (time.compareTo(currentTime) &lt;= 0) {
2147             java.util.List&lt;Runnable&gt; tasks = timeoutTasks.remove(time);
2148 
2149             for (Iterator&lt;Runnable&gt; iter = tasks.iterator(); iter.hasNext();) {
2150                 Runnable task = iter.next();
2151 
2152                 if (timeoutTaskLog.isLoggable(PlatformLogger.Level.FINER)) {
2153                     timeoutTaskLog.finer(&quot;XToolkit.callTimeoutTasks(): current time={0}&quot; +
2154                                          &quot;;  about to run task={1}&quot;, Long.valueOf(currentTime), task);
2155                 }
2156 
2157                 try {
2158                     task.run();
2159                 } catch (ThreadDeath td) {
2160                     throw td;
2161                 } catch (Throwable thr) {
2162                     processException(thr);
2163                 }
2164             }
2165 
2166             if (timeoutTasks.isEmpty()) {
2167                 break;
2168             }
2169             time = timeoutTasks.firstKey();
2170         }
2171     }
2172 
<a name="4" id="anc4"></a>



2173     static boolean isLeftMouseButton(MouseEvent me) {
2174         switch (me.getID()) {
2175           case MouseEvent.MOUSE_PRESSED:
2176           case MouseEvent.MOUSE_RELEASED:
2177               return (me.getButton() == MouseEvent.BUTTON1);
2178           case MouseEvent.MOUSE_ENTERED:
2179           case MouseEvent.MOUSE_EXITED:
2180           case MouseEvent.MOUSE_CLICKED:
2181           case MouseEvent.MOUSE_DRAGGED:
2182               return ((me.getModifiersEx() &amp; InputEvent.BUTTON1_DOWN_MASK) != 0);
2183         }
2184         return false;
2185     }
2186 
2187     static boolean isRightMouseButton(MouseEvent me) {
2188         int numButtons = ((Integer)getDefaultToolkit().getDesktopProperty(&quot;awt.mouse.numButtons&quot;)).intValue();
2189         switch (me.getID()) {
2190           case MouseEvent.MOUSE_PRESSED:
2191           case MouseEvent.MOUSE_RELEASED:
2192               return ((numButtons == 2 &amp;&amp; me.getButton() == MouseEvent.BUTTON2) ||
2193                        (numButtons &gt; 2 &amp;&amp; me.getButton() == MouseEvent.BUTTON3));
2194           case MouseEvent.MOUSE_ENTERED:
2195           case MouseEvent.MOUSE_EXITED:
2196           case MouseEvent.MOUSE_CLICKED:
2197           case MouseEvent.MOUSE_DRAGGED:
2198               return ((numButtons == 2 &amp;&amp; (me.getModifiersEx() &amp; InputEvent.BUTTON2_DOWN_MASK) != 0) ||
2199                       (numButtons &gt; 2 &amp;&amp; (me.getModifiersEx() &amp; InputEvent.BUTTON3_DOWN_MASK) != 0));
2200         }
2201         return false;
2202     }
2203 
2204     static long reset_time_utc;
2205     static final long WRAP_TIME_MILLIS = 0x00000000FFFFFFFFL;
2206 
2207     /*
2208      * This function converts between the X server time (number of milliseconds
2209      * since the last server reset) and the UTC time for the &#39;when&#39; field of an
2210      * InputEvent (or another event type with a timestamp).
2211      */
2212     static long nowMillisUTC_offset(long server_offset) {
2213         // ported from awt_util.c
2214         /*
2215          * Because Time is of type &#39;unsigned long&#39;, it is possible that Time will
2216          * never wrap when using 64-bit Xlib. However, if a 64-bit client
2217          * connects to a 32-bit server, I suspect the values will still wrap. So
2218          * we should not attempt to remove the wrap checking even if _LP64 is
2219          * true.
2220          */
2221 
2222         long current_time_utc = System.currentTimeMillis();
2223         if (log.isLoggable(PlatformLogger.Level.FINER)) {
2224             log.finer(&quot;reset_time=&quot; + reset_time_utc + &quot;, current_time=&quot; + current_time_utc
2225                       + &quot;, server_offset=&quot; + server_offset + &quot;, wrap_time=&quot; + WRAP_TIME_MILLIS);
2226         }
2227 
2228         if ((current_time_utc - reset_time_utc) &gt; WRAP_TIME_MILLIS) {
2229             reset_time_utc = System.currentTimeMillis() - getCurrentServerTime();
2230         }
2231 
2232         if (log.isLoggable(PlatformLogger.Level.FINER)) {
2233             log.finer(&quot;result = &quot; + (reset_time_utc + server_offset));
2234         }
2235         return reset_time_utc + server_offset;
2236     }
2237 
2238     /**
2239      * @see sun.awt.SunToolkit#needsXEmbedImpl
2240      */
2241     @Override
2242     protected boolean needsXEmbedImpl() {
2243         // XToolkit implements supports for XEmbed-client protocol and
2244         // requires the supports from the embedding host for it to work.
2245         return true;
2246     }
2247 
2248     @Override
2249     public boolean isModalityTypeSupported(Dialog.ModalityType modalityType) {
2250         return (modalityType == null) ||
2251                (modalityType == Dialog.ModalityType.MODELESS) ||
2252                (modalityType == Dialog.ModalityType.DOCUMENT_MODAL) ||
2253                (modalityType == Dialog.ModalityType.APPLICATION_MODAL) ||
2254                (modalityType == Dialog.ModalityType.TOOLKIT_MODAL);
2255     }
2256 
2257     @Override
2258     public boolean isModalExclusionTypeSupported(Dialog.ModalExclusionType exclusionType) {
2259         return (exclusionType == null) ||
2260                (exclusionType == Dialog.ModalExclusionType.NO_EXCLUDE) ||
2261                (exclusionType == Dialog.ModalExclusionType.APPLICATION_EXCLUDE) ||
2262                (exclusionType == Dialog.ModalExclusionType.TOOLKIT_EXCLUDE);
2263     }
2264 
2265     static EventQueue getEventQueue(Object target) {
2266         AppContext appContext = targetToAppContext(target);
2267         if (appContext != null) {
2268             return (EventQueue)appContext.get(AppContext.EVENT_QUEUE_KEY);
2269         }
2270         return null;
2271     }
2272 
2273     static void removeSourceEvents(EventQueue queue,
2274                                    Object source,
2275                                    boolean removeAllEvents) {
2276         AWTAccessor.getEventQueueAccessor()
2277             .removeSourceEvents(queue, source, removeAllEvents);
2278     }
2279 
2280     @Override
2281     public boolean isAlwaysOnTopSupported() {
2282         for (XLayerProtocol proto : XWM.getWM().getProtocols(XLayerProtocol.class)) {
2283             if (proto.supportsLayer(XLayerProtocol.LAYER_ALWAYS_ON_TOP)) {
2284                 return true;
2285             }
2286         }
2287         return false;
2288     }
2289 
2290     @Override
2291     public boolean useBufferPerWindow() {
2292         return XToolkit.getBackingStoreType() == XConstants.NotUseful;
2293     }
2294 
2295     /**
2296      * Returns one of XConstants: NotUseful, WhenMapped or Always.
2297      * If backing store is not available on at least one screen, or
2298      * the string system property &quot;sun.awt.backingStore&quot; is neither &quot;Always&quot;
2299      * nor &quot;WhenMapped&quot;, then the method returns XConstants.NotUseful.
2300      * Otherwise, if the system property &quot;sun.awt.backingStore&quot; is &quot;WhenMapped&quot;,
2301      * then the method returns XConstants.WhenMapped.
2302      * Otherwise (i.e., if the system property &quot;sun.awt.backingStore&quot; is &quot;Always&quot;),
2303      * the method returns XConstants.Always.
2304      */
2305     static int getBackingStoreType() {
2306         return backingStoreType;
2307     }
2308 
2309     private static void setBackingStoreType() {
2310         String prop = AccessController.doPrivileged(
2311                 new sun.security.action.GetPropertyAction(&quot;sun.awt.backingStore&quot;));
2312 
2313         if (prop == null) {
2314             backingStoreType = XConstants.NotUseful;
2315             if (backingStoreLog.isLoggable(PlatformLogger.Level.CONFIG)) {
2316                 backingStoreLog.config(&quot;The system property sun.awt.backingStore is not set&quot; +
2317                                        &quot;, by default backingStore=NotUseful&quot;);
2318             }
2319             return;
2320         }
2321 
2322         if (backingStoreLog.isLoggable(PlatformLogger.Level.CONFIG)) {
2323             backingStoreLog.config(&quot;The system property sun.awt.backingStore is &quot; + prop);
2324         }
2325         prop = prop.toLowerCase();
2326         if (prop.equals(&quot;always&quot;)) {
2327             backingStoreType = XConstants.Always;
2328         } else if (prop.equals(&quot;whenmapped&quot;)) {
2329             backingStoreType = XConstants.WhenMapped;
2330         } else {
2331             backingStoreType = XConstants.NotUseful;
2332         }
2333 
2334         if (backingStoreLog.isLoggable(PlatformLogger.Level.CONFIG)) {
2335             backingStoreLog.config(&quot;backingStore(as provided by the system property)=&quot; +
2336                                    ( backingStoreType == XConstants.NotUseful ? &quot;NotUseful&quot;
2337                                      : backingStoreType == XConstants.WhenMapped ?
2338                                      &quot;WhenMapped&quot; : &quot;Always&quot;) );
2339         }
2340 
2341         awtLock();
2342         try {
2343             int screenCount = XlibWrapper.ScreenCount(getDisplay());
2344             for (int i = 0; i &lt; screenCount; i++) {
2345                 if (XlibWrapper.DoesBackingStore(XlibWrapper.ScreenOfDisplay(getDisplay(), i))
2346                         == XConstants.NotUseful) {
2347                     backingStoreType = XConstants.NotUseful;
2348 
2349                     if (backingStoreLog.isLoggable(PlatformLogger.Level.CONFIG)) {
2350                         backingStoreLog.config(&quot;Backing store is not available on the screen &quot; +
2351                                                i + &quot;, backingStore=NotUseful&quot;);
2352                     }
2353 
2354                     return;
2355                 }
2356             }
2357         } finally {
2358             awtUnlock();
2359         }
2360     }
2361 
2362     /**
2363      * One of XConstants: NotUseful, WhenMapped or Always.
2364      */
2365     private static int backingStoreType;
2366 
2367     static final int XSUN_KP_BEHAVIOR = 1;
2368     static final int XORG_KP_BEHAVIOR = 2;
2369     static final int    IS_SUN_KEYBOARD = 1;
2370     static final int IS_NONSUN_KEYBOARD = 2;
2371     static final int    IS_KANA_KEYBOARD = 1;
2372     static final int IS_NONKANA_KEYBOARD = 2;
2373 
2374 
2375     static int     awt_IsXsunKPBehavior = 0;
2376     static boolean awt_UseXKB         = false;
2377     static boolean awt_UseXKB_Calls   = false;
2378     static int     awt_XKBBaseEventCode = 0;
2379     static int     awt_XKBEffectiveGroup = 0; // so far, I don&#39;t use it leaving all calculations
2380                                               // to XkbTranslateKeyCode
2381     static long    awt_XKBDescPtr     = 0;
2382 
2383     /**
2384      * Check for Xsun convention regarding numpad keys.
2385      * Xsun and some other servers (i.e. derived from Xsun)
2386      * under certain conditions process numpad keys unlike Xorg.
2387      */
2388     static boolean isXsunKPBehavior() {
2389         awtLock();
2390         try {
2391             if( awt_IsXsunKPBehavior == 0 ) {
2392                 if( XlibWrapper.IsXsunKPBehavior(getDisplay()) ) {
2393                     awt_IsXsunKPBehavior = XSUN_KP_BEHAVIOR;
2394                 }else{
2395                     awt_IsXsunKPBehavior = XORG_KP_BEHAVIOR;
2396                 }
2397             }
2398             return awt_IsXsunKPBehavior == XSUN_KP_BEHAVIOR ? true : false;
2399         } finally {
2400             awtUnlock();
2401         }
2402     }
2403 
2404     static int  sunOrNotKeyboard = 0;
2405     static int kanaOrNotKeyboard = 0;
2406     static void resetKeyboardSniffer() {
2407         sunOrNotKeyboard  = 0;
2408         kanaOrNotKeyboard = 0;
2409     }
2410     static boolean isSunKeyboard() {
2411         if( sunOrNotKeyboard == 0 ) {
2412             if( XlibWrapper.IsSunKeyboard( getDisplay() )) {
2413                 sunOrNotKeyboard = IS_SUN_KEYBOARD;
2414             }else{
2415                 sunOrNotKeyboard = IS_NONSUN_KEYBOARD;
2416             }
2417         }
2418         return (sunOrNotKeyboard == IS_SUN_KEYBOARD);
2419     }
2420     static boolean isKanaKeyboard() {
2421         if( kanaOrNotKeyboard == 0 ) {
2422             if( XlibWrapper.IsKanaKeyboard( getDisplay() )) {
2423                 kanaOrNotKeyboard = IS_KANA_KEYBOARD;
2424             }else{
2425                 kanaOrNotKeyboard = IS_NONKANA_KEYBOARD;
2426             }
2427         }
2428         return (kanaOrNotKeyboard == IS_KANA_KEYBOARD);
2429     }
2430     static boolean isXKBenabled() {
2431         awtLock();
2432         try {
2433             return awt_UseXKB;
2434         } finally {
2435             awtUnlock();
2436         }
2437     }
2438 
2439     /**
2440       Query XKEYBOARD extension.
2441       If possible, initialize xkb library.
2442     */
2443     static boolean tryXKB() {
2444         awtLock();
2445         try {
2446             String name = &quot;XKEYBOARD&quot;;
2447             // First, if there is extension at all.
2448             awt_UseXKB = XlibWrapper.XQueryExtension( getDisplay(), name, XlibWrapper.larg1, XlibWrapper.larg2, XlibWrapper.larg3);
2449             if( awt_UseXKB ) {
2450                 // There is a keyboard extension. Check if a client library is compatible.
2451                 // If not, don&#39;t use xkb calls.
2452                 // In this case we still may be Xkb-capable application.
2453                 awt_UseXKB_Calls = XlibWrapper.XkbLibraryVersion( XlibWrapper.larg1, XlibWrapper.larg2);
2454                 if( awt_UseXKB_Calls ) {
2455                     awt_UseXKB_Calls = XlibWrapper.XkbQueryExtension( getDisplay(),  XlibWrapper.larg1, XlibWrapper.larg2,
2456                                      XlibWrapper.larg3, XlibWrapper.larg4, XlibWrapper.larg5);
2457                     if( awt_UseXKB_Calls ) {
2458                         awt_XKBBaseEventCode = Native.getInt(XlibWrapper.larg2);
2459                         XlibWrapper.XkbSelectEvents (getDisplay(),
2460                                          XConstants.XkbUseCoreKbd,
2461                                          XConstants.XkbNewKeyboardNotifyMask |
2462                                                  XConstants.XkbMapNotifyMask ,//|
2463                                                  //XConstants.XkbStateNotifyMask,
2464                                          XConstants.XkbNewKeyboardNotifyMask |
2465                                                  XConstants.XkbMapNotifyMask );//|
2466                                                  //XConstants.XkbStateNotifyMask);
2467 
2468                         XlibWrapper.XkbSelectEventDetails(getDisplay(), XConstants.XkbUseCoreKbd,
2469                                                      XConstants.XkbStateNotify,
2470                                                      XConstants.XkbGroupStateMask,
2471                                                      XConstants.XkbGroupStateMask);
2472                                                      //XXX ? XkbGroupLockMask last, XkbAllStateComponentsMask before last?
2473                         awt_XKBDescPtr = XlibWrapper.XkbGetMap(getDisplay(),
2474                                                      XConstants.XkbKeyTypesMask    |
2475                                                      XConstants.XkbKeySymsMask     |
2476                                                      XConstants.XkbModifierMapMask |
2477                                                      XConstants.XkbVirtualModsMask,
2478                                                      XConstants.XkbUseCoreKbd);
2479 
2480                         XlibWrapper.XkbSetDetectableAutoRepeat(getDisplay(), true);
2481                     }
2482                 }
2483             }
2484             return awt_UseXKB;
2485         } finally {
2486             awtUnlock();
2487         }
2488     }
2489     static boolean canUseXKBCalls() {
2490         awtLock();
2491         try {
2492             return awt_UseXKB_Calls;
2493         } finally {
2494             awtUnlock();
2495         }
2496     }
2497     static int getXKBEffectiveGroup() {
2498         awtLock();
2499         try {
2500             return awt_XKBEffectiveGroup;
2501         } finally {
2502             awtUnlock();
2503         }
2504     }
2505     static int getXKBBaseEventCode() {
2506         awtLock();
2507         try {
2508             return awt_XKBBaseEventCode;
2509         } finally {
2510             awtUnlock();
2511         }
2512     }
2513     static long getXKBKbdDesc() {
2514         awtLock();
2515         try {
2516             return awt_XKBDescPtr;
2517         } finally {
2518             awtUnlock();
2519         }
2520     }
2521     void freeXKB() {
2522         awtLock();
2523         try {
2524             if (awt_UseXKB_Calls &amp;&amp; awt_XKBDescPtr != 0) {
2525                 XlibWrapper.XkbFreeKeyboard(awt_XKBDescPtr, 0xFF, true);
2526                 awt_XKBDescPtr = 0;
2527             }
2528         } finally {
2529             awtUnlock();
2530         }
2531     }
2532     private void processXkbChanges(XEvent ev) {
2533         // mapping change --&gt; refresh kbd map
2534         // state change --&gt; get a new effective group; do I really need it
2535         //  or that should be left for XkbTranslateKeyCode?
2536         XkbEvent xke = new XkbEvent( ev.getPData() );
2537         int xkb_type = xke.get_any().get_xkb_type();
2538         switch( xkb_type ) {
2539             case XConstants.XkbNewKeyboardNotify :
2540                  if( awt_XKBDescPtr != 0 ) {
2541                      freeXKB();
2542                  }
2543                  awt_XKBDescPtr = XlibWrapper.XkbGetMap(getDisplay(),
2544                                               XConstants.XkbKeyTypesMask    |
2545                                               XConstants.XkbKeySymsMask     |
2546                                               XConstants.XkbModifierMapMask |
2547                                               XConstants.XkbVirtualModsMask,
2548                                               XConstants.XkbUseCoreKbd);
2549                  //System.out.println(&quot;XkbNewKeyboard:&quot;+(xke.get_new_kbd()));
2550                  break;
2551             case XConstants.XkbMapNotify :
2552                  if (awt_XKBDescPtr != 0) {
2553                     //TODO: provide a simple unit test.
2554                     XlibWrapper.XkbGetUpdatedMap(getDisplay(),
2555                                                  XConstants.XkbKeyTypesMask    |
2556                                                  XConstants.XkbKeySymsMask     |
2557                                                  XConstants.XkbModifierMapMask |
2558                                                  XConstants.XkbVirtualModsMask,
2559                                                  awt_XKBDescPtr);
2560                  }
2561                 //System.out.println(&quot;XkbMap:&quot;+(xke.get_map()));
2562                  break;
2563             case XConstants.XkbStateNotify :
2564                  // May use it later e.g. to obtain an effective group etc.
2565                  //System.out.println(&quot;XkbState:&quot;+(xke.get_state()));
2566                  break;
2567             default:
2568                  //System.out.println(&quot;XkbEvent of xkb_type &quot;+xkb_type);
2569                  break;
2570         }
2571     }
2572 
2573     private static long eventNumber;
2574     public static long getEventNumber() {
2575         awtLock();
2576         try {
2577             return eventNumber;
2578         } finally {
2579             awtUnlock();
2580         }
2581     }
2582 
2583     private static XEventDispatcher oops_waiter;
2584     private static boolean oops_updated;
2585     private static int oops_position = 0;
2586 
2587     /**
2588      * @inheritDoc
2589      */
2590     @Override
2591     protected boolean syncNativeQueue(final long timeout) {
2592         XBaseWindow win = XBaseWindow.getXAWTRootWindow();
2593 
2594         if (oops_waiter == null) {
2595             oops_waiter = new XEventDispatcher() {
2596                     @Override
2597                     public void dispatchEvent(XEvent e) {
2598                         if (e.get_type() == XConstants.ConfigureNotify) {
2599                             // OOPS ConfigureNotify event catched
2600                             oops_updated = true;
2601                             awtLockNotifyAll();
2602                         }
2603                     }
2604                 };
2605         }
2606 
2607         awtLock();
2608         try {
2609             addEventDispatcher(win.getWindow(), oops_waiter);
2610 
2611             oops_updated = false;
2612             long event_number = getEventNumber();
2613             // Generate OOPS ConfigureNotify event
2614             XlibWrapper.XMoveWindow(getDisplay(), win.getWindow(),
2615                                     win.scaleUp(++oops_position), 0);
2616             // Change win position each time to avoid system optimization
2617             if (oops_position &gt; 50) {
2618                 oops_position = 0;
2619             }
2620 
2621             XSync();
2622 
2623             eventLog.finer(&quot;Generated OOPS ConfigureNotify event&quot;);
2624 
2625             long start = System.currentTimeMillis();
2626             while (!oops_updated) {
2627                 try {
2628                     // Wait for OOPS ConfigureNotify event
2629                     awtLockWait(timeout);
2630                 } catch (InterruptedException e) {
2631                     throw new RuntimeException(e);
2632                 }
2633                 // This &quot;while&quot; is a protection from spurious
2634                 // wake-ups.  However, we shouldn&#39;t wait for too long
2635                 if ((System.currentTimeMillis() - start &gt; timeout) &amp;&amp; timeout &gt;= 0) {
2636                     throw new OperationTimedOut(Long.toString(System.currentTimeMillis() - start));
2637                 }
2638             }
2639             // Don&#39;t take into account OOPS ConfigureNotify event
2640             return getEventNumber() - event_number &gt; 1;
2641         } finally {
2642             removeEventDispatcher(win.getWindow(), oops_waiter);
2643             eventLog.finer(&quot;Exiting syncNativeQueue&quot;);
2644             awtUnlock();
2645         }
2646     }
2647     @Override
2648     public void grab(Window w) {
2649         final Object peer = AWTAccessor.getComponentAccessor().getPeer(w);
2650         if (peer != null) {
2651             ((XWindowPeer) peer).setGrab(true);
2652         }
2653     }
2654 
2655     @Override
2656     public void ungrab(Window w) {
2657         final Object peer = AWTAccessor.getComponentAccessor().getPeer(w);
2658         if (peer != null) {
2659             ((XWindowPeer) peer).setGrab(false);
2660         }
2661     }
2662     /**
2663      * Returns if the java.awt.Desktop class is supported on the current
2664      * desktop.
2665      * &lt;p&gt;
2666      * The methods of java.awt.Desktop class are supported on the Gnome desktop.
2667      * Check if the running desktop is Gnome by checking the window manager.
2668      */
2669     @Override
2670     public boolean isDesktopSupported(){
2671         return XDesktopPeer.isDesktopSupported();
2672     }
2673 
2674     @Override
2675     public DesktopPeer createDesktopPeer(Desktop target){
2676         return new XDesktopPeer();
2677     }
2678 
2679     @Override
2680     public boolean isTaskbarSupported(){
2681         return XTaskbarPeer.isTaskbarSupported();
2682     }
2683 
2684     @Override
2685     public TaskbarPeer createTaskbarPeer(Taskbar target){
2686         return new XTaskbarPeer();
2687     }
2688 
2689     @Override
2690     public boolean areExtraMouseButtonsEnabled() throws HeadlessException {
2691         return areExtraMouseButtonsEnabled;
2692     }
2693 
2694     @Override
2695     public boolean isWindowOpacitySupported() {
2696         XNETProtocol net_protocol = XWM.getWM().getNETProtocol();
2697 
2698         if (net_protocol == null) {
2699             return false;
2700         }
2701 
2702         return net_protocol.doOpacityProtocol();
2703     }
2704 
2705     @Override
2706     public boolean isWindowShapingSupported() {
2707         return XlibUtil.isShapingSupported();
2708     }
2709 
2710     @Override
2711     public boolean isWindowTranslucencySupported() {
2712         //NOTE: it may not be supported. The actual check is being performed
2713         //      at java.awt.GraphicsDevice. In X11 we need to check
2714         //      whether there&#39;s any translucency-capable GC available.
2715         return true;
2716     }
2717 
2718     @Override
2719     public boolean isTranslucencyCapable(GraphicsConfiguration gc) {
2720         if (!(gc instanceof X11GraphicsConfig)) {
2721             return false;
2722         }
2723         return ((X11GraphicsConfig)gc).isTranslucencyCapable();
2724     }
2725 
2726     /**
2727      * Returns the value of &quot;sun.awt.disablegrab&quot; property. Default
2728      * value is {@code false}.
2729      */
2730     public static boolean getSunAwtDisableGrab() {
2731         return AccessController.doPrivileged(new GetBooleanAction(&quot;sun.awt.disablegrab&quot;));
2732     }
2733 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
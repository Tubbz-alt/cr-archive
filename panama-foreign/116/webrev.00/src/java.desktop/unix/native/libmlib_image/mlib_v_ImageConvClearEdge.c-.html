<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libmlib_image/mlib_v_ImageConvClearEdge.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 
  27 
  28 /*
  29  * FUNCTIONS
  30  *      mlib_ImageConvClearEdge  - Set edge of an image to a specific
  31  *                                        color. (VIS version)
  32  *
  33  * SYNOPSIS
  34  *      mlib_status mlib_ImageConvClearEdge(mlib_image     *dst,
  35  *                                          mlib_s32       dx_l,
  36  *                                          mlib_s32       dx_r,
  37  *                                          mlib_s32       dy_t,
  38  *                                          mlib_s32       dy_b,
  39  *                                          const mlib_s32 *color,
  40  *                                          mlib_s32       cmask)
  41  *
  42  * ARGUMENT
  43  *      dst       Pointer to an image.
  44  *      dx_l      Number of columns on the left side of the
  45  *                image to be cleared.
  46  *      dx_r      Number of columns on the right side of the
  47  *                image to be cleared.
  48  *      dy_t      Number of rows on the top edge of the
  49  *                image to be cleared.
  50  *      dy_b      Number of rows on the top edge of the
  51  *                image to be cleared.
  52  *      color     Pointer to the color that the edges are set to.
  53  *      cmask     Channel mask to indicate the channels to be convolved.
  54  *                Each bit of which represents a channel in the image. The
  55  *                channels corresponded to 1 bits are those to be processed.
  56  *
  57  * RESTRICTION
  58  *      dst can have 1, 2, 3 or 4 channels of MLIB_BYTE or MLIB_SHORT or MLIB_INT
  59  *      data type.
  60  *
  61  * DESCRIPTION
  62  *      Set edge of an image to a specific color. (VIS version)
  63  *      The unselected channels are not overwritten.
  64  *      If src and dst have just one channel,
  65  *      cmask is ignored.
  66  */
  67 
  68 #include &quot;mlib_image.h&quot;
  69 #include &quot;vis_proto.h&quot;
  70 #include &quot;mlib_ImageConvEdge.h&quot;
  71 
  72 /***************************************************************/
  73 static void mlib_ImageConvClearEdge_U8_1(mlib_image     *dst,
  74                                          mlib_s32       dx_l,
  75                                          mlib_s32       dx_r,
  76                                          mlib_s32       dy_t,
  77                                          mlib_s32       dy_b,
  78                                          const mlib_s32 *color);
  79 
  80 static void mlib_ImageConvClearEdge_U8_2(mlib_image     *dst,
  81                                          mlib_s32       dx_l,
  82                                          mlib_s32       dx_r,
  83                                          mlib_s32       dy_t,
  84                                          mlib_s32       dy_b,
  85                                          const mlib_s32 *color,
  86                                          mlib_s32       cmask);
  87 
  88 static void mlib_ImageConvClearEdge_U8_3(mlib_image     *dst,
  89                                          mlib_s32       dx_l,
  90                                          mlib_s32       dx_r,
  91                                          mlib_s32       dy_t,
  92                                          mlib_s32       dy_b,
  93                                          const mlib_s32 *color,
  94                                          mlib_s32       cmask);
  95 
  96 static void mlib_ImageConvClearEdge_U8_4(mlib_image     *dst,
  97                                          mlib_s32       dx_l,
  98                                          mlib_s32       dx_r,
  99                                          mlib_s32       dy_t,
 100                                          mlib_s32       dy_b,
 101                                          const mlib_s32 *color,
 102                                          mlib_s32       cmask);
 103 
 104 static void mlib_ImageConvClearEdge_S16_1(mlib_image     *dst,
 105                                           mlib_s32       dx_l,
 106                                           mlib_s32       dx_r,
 107                                           mlib_s32       dy_t,
 108                                           mlib_s32       dy_b,
 109                                           const mlib_s32 *color);
 110 
 111 static void mlib_ImageConvClearEdge_S16_2(mlib_image     *dst,
 112                                           mlib_s32       dx_l,
 113                                           mlib_s32       dx_r,
 114                                           mlib_s32       dy_t,
 115                                           mlib_s32       dy_b,
 116                                           const mlib_s32 *color,
 117                                           mlib_s32       cmask);
 118 
 119 static void mlib_ImageConvClearEdge_S16_3(mlib_image     *dst,
 120                                           mlib_s32       dx_l,
 121                                           mlib_s32       dx_r,
 122                                           mlib_s32       dy_t,
 123                                           mlib_s32       dy_b,
 124                                           const mlib_s32 *color,
 125                                           mlib_s32       cmask);
 126 
 127 static void mlib_ImageConvClearEdge_S16_4(mlib_image     *dst,
 128                                           mlib_s32       dx_l,
 129                                           mlib_s32       dx_r,
 130                                           mlib_s32       dy_t,
 131                                           mlib_s32       dy_b,
 132                                           const mlib_s32 *color,
 133                                           mlib_s32       cmask);
 134 
 135 static void mlib_ImageConvClearEdge_S32_1(mlib_image     *dst,
 136                                           mlib_s32       dx_l,
 137                                           mlib_s32       dx_r,
 138                                           mlib_s32       dy_t,
 139                                           mlib_s32       dy_b,
 140                                           const mlib_s32 *color);
 141 
 142 static void mlib_ImageConvClearEdge_S32_2(mlib_image     *dst,
 143                                           mlib_s32       dx_l,
 144                                           mlib_s32       dx_r,
 145                                           mlib_s32       dy_t,
 146                                           mlib_s32       dy_b,
 147                                           const mlib_s32 *color,
 148                                           mlib_s32       cmask);
 149 
 150 static void mlib_ImageConvClearEdge_S32_3(mlib_image     *dst,
 151                                           mlib_s32       dx_l,
 152                                           mlib_s32       dx_r,
 153                                           mlib_s32       dy_t,
 154                                           mlib_s32       dy_b,
 155                                           const mlib_s32 *color,
 156                                           mlib_s32       cmask);
 157 
 158 static void mlib_ImageConvClearEdge_S32_4(mlib_image     *dst,
 159                                           mlib_s32       dx_l,
 160                                           mlib_s32       dx_r,
 161                                           mlib_s32       dy_t,
 162                                           mlib_s32       dy_b,
 163                                           const mlib_s32 *color,
 164                                           mlib_s32       cmask);
 165 
 166 /***************************************************************/
 167 #define VERT_EDGES(chan, type, mask)                             \
 168   type *pdst = (type *) mlib_ImageGetData(dst);                  \
 169   type *pdst_row, *pdst_row_end;                                 \
 170   type color_i;                                                  \
 171   mlib_s32 dst_height = mlib_ImageGetHeight(dst);                \
 172   mlib_s32 dst_width  = mlib_ImageGetWidth(dst);                 \
 173   mlib_s32 dst_stride = mlib_ImageGetStride(dst) / sizeof(type); \
 174   mlib_s32 i, j, l;                                              \
 175   mlib_s32 emask, testchan;                                      \
 176   mlib_s32 dst_width_t, dst_width_b;                             \
 177   mlib_d64 *dpdst;                                               \
 178                                                                  \
 179   testchan = 1;                                                  \
 180   for (l = chan - 1; l &gt;= 0; l--) {                              \
 181     if ((mask &amp; testchan) == 0) {                                \
 182       testchan &lt;&lt;= 1;                                            \
 183       continue;                                                  \
 184     }                                                            \
 185     testchan &lt;&lt;= 1;                                              \
 186     color_i = (type)color[l];                                    \
 187     for (j = 0; j &lt; dx_l; j++) {                                 \
 188       for (i = dy_t; i &lt; (dst_height - dy_b); i++) {             \
 189         pdst[i*dst_stride + l + j*chan] = color_i;               \
 190       }                                                          \
 191     }                                                            \
 192     for (j = 0; j &lt; dx_r; j++) {                                 \
 193       for (i = dy_t; i &lt; (dst_height - dy_b); i++) {             \
 194         pdst[i*dst_stride + l+(dst_width-1 - j)*chan] = color_i; \
 195       }                                                          \
 196     }                                                            \
 197   }                                                              \
 198                                                                  \
 199   dst_width_t = dst_width;                                       \
 200   dst_width_b = dst_width;                                       \
 201   if ((dst_width * chan) == dst_stride) {                        \
 202     dst_width_t *= dy_t;                                         \
 203     dst_width_b *= dy_b;                                         \
 204     dst_stride *= (dst_height - dy_b);                           \
 205     dst_height = 2;                                              \
 206     dy_t = ((dy_t == 0) ? 0 : 1);                                \
 207     dy_b = ((dy_b == 0) ? 0 : 1);                                \
 208   }
 209 
 210 /***************************************************************/
 211 #define HORIZ_EDGES(chan, type, mask)                            \
 212 {                                                                \
 213   testchan = 1;                                                  \
 214   for (l = chan - 1; l &gt;= 0; l--) {                              \
 215     if ((mask &amp; testchan) == 0) {                                \
 216       testchan &lt;&lt;= 1;                                            \
 217       continue;                                                  \
 218     }                                                            \
 219     testchan &lt;&lt;= 1;                                              \
 220     color_i = (type) color[l];                                   \
 221     for (i = 0; i &lt; dy_t; i++) {                                 \
 222       for (j = 0; j &lt; dst_width_t; j++) {                        \
 223         pdst[i * dst_stride + l + j * chan] = color_i;           \
 224       }                                                          \
 225     }                                                            \
 226     for (i = 0; i &lt; dy_b; i++) {                                 \
 227       for (j = 0; j &lt; dst_width_b; j++) {                        \
 228         pdst[(dst_height - 1 - i) * dst_stride + l + j * chan] = \
 229           color_i;                                               \
 230       }                                                          \
 231     }                                                            \
 232   }                                                              \
 233   return;                                                        \
 234 }
 235 
 236 /***************************************************************/
 237 mlib_status mlib_ImageConvClearEdge(mlib_image     *dst,
 238                                     mlib_s32       dx_l,
 239                                     mlib_s32       dx_r,
 240                                     mlib_s32       dy_t,
 241                                     mlib_s32       dy_b,
 242                                     const mlib_s32 *color,
 243                                     mlib_s32       cmask)
 244 {
 245   mlib_s32 dst_width = mlib_ImageGetWidth(dst);
 246   mlib_s32 dst_height = mlib_ImageGetHeight(dst);
 247 
 248   if (dx_l + dx_r &gt; dst_width) {
 249     dx_l = dst_width;
 250     dx_r = 0;
 251   }
 252 
 253   if (dy_t + dy_b &gt; dst_height) {
 254     dy_t = dst_height;
 255     dy_b = 0;
 256   }
 257 
 258   switch (mlib_ImageGetType(dst)) {
 259     case MLIB_BIT:
 260       return mlib_ImageConvClearEdge_Bit(dst, dx_l, dx_r, dy_t, dy_b, color, cmask);
 261 
 262     case MLIB_BYTE:
 263       switch (mlib_ImageGetChannels(dst)) {
 264 
 265         case 1:
 266           mlib_ImageConvClearEdge_U8_1(dst, dx_l, dx_r, dy_t, dy_b, color);
 267           break;
 268 
 269         case 2:
 270           mlib_ImageConvClearEdge_U8_2(dst, dx_l, dx_r, dy_t, dy_b, color, cmask);
 271           break;
 272 
 273         case 3:
 274           mlib_ImageConvClearEdge_U8_3(dst, dx_l, dx_r, dy_t, dy_b, color, cmask);
 275           break;
 276 
 277         case 4:
 278           mlib_ImageConvClearEdge_U8_4(dst, dx_l, dx_r, dy_t, dy_b, color, cmask);
 279           break;
 280 
 281         default:
 282           return MLIB_FAILURE;
 283       }
 284 
 285       break;
 286 
 287     case MLIB_SHORT:
 288     case MLIB_USHORT:
 289       switch (mlib_ImageGetChannels(dst)) {
 290 
 291         case 1:
 292           mlib_ImageConvClearEdge_S16_1(dst, dx_l, dx_r, dy_t, dy_b, color);
 293           break;
 294 
 295         case 2:
 296           mlib_ImageConvClearEdge_S16_2(dst, dx_l, dx_r, dy_t, dy_b, color, cmask);
 297           break;
 298 
 299         case 3:
 300           mlib_ImageConvClearEdge_S16_3(dst, dx_l, dx_r, dy_t, dy_b, color, cmask);
 301           break;
 302 
 303         case 4:
 304           mlib_ImageConvClearEdge_S16_4(dst, dx_l, dx_r, dy_t, dy_b, color, cmask);
 305           break;
 306 
 307         default:
 308           return MLIB_FAILURE;
 309       }
 310 
 311       break;
 312 
 313     case MLIB_INT:
 314       switch (mlib_ImageGetChannels(dst)) {
 315 
 316         case 1:
 317           mlib_ImageConvClearEdge_S32_1(dst, dx_l, dx_r, dy_t, dy_b, color);
 318           break;
 319 
 320         case 2:
 321           mlib_ImageConvClearEdge_S32_2(dst, dx_l, dx_r, dy_t, dy_b, color, cmask);
 322           break;
 323 
 324         case 3:
 325           mlib_ImageConvClearEdge_S32_3(dst, dx_l, dx_r, dy_t, dy_b, color, cmask);
 326           break;
 327 
 328         case 4:
 329           mlib_ImageConvClearEdge_S32_4(dst, dx_l, dx_r, dy_t, dy_b, color, cmask);
 330           break;
 331 
 332         default:
 333           return MLIB_FAILURE;
 334       }
 335 
 336       break;
 337 
 338     default:
 339       return MLIB_FAILURE;
 340   }
 341 
 342   return MLIB_SUCCESS;
 343 }
 344 
 345 /***************************************************************/
 346 mlib_status mlib_ImageConvZeroEdge(mlib_image *dst,
 347                                    mlib_s32   dx_l,
 348                                    mlib_s32   dx_r,
 349                                    mlib_s32   dy_t,
 350                                    mlib_s32   dy_b,
 351                                    mlib_s32   cmask)
 352 {
 353   mlib_d64 zero[4] = { 0, 0, 0, 0 };
 354   mlib_type type = mlib_ImageGetType(dst);
 355 
 356   if (type == MLIB_FLOAT || type == MLIB_DOUBLE) {
 357     return mlib_ImageConvClearEdge_Fp(dst, dx_l, dx_r, dy_t, dy_b, zero, cmask);
 358   }
 359   else {
 360     return mlib_ImageConvClearEdge(dst, dx_l, dx_r, dy_t, dy_b, (mlib_s32 *) zero, cmask);
 361   }
 362 }
 363 
 364 /***************************************************************/
 365 void mlib_ImageConvClearEdge_U8_1(mlib_image     *dst,
 366                                   mlib_s32       dx_l,
 367                                   mlib_s32       dx_r,
 368                                   mlib_s32       dy_t,
 369                                   mlib_s32       dy_b,
 370                                   const mlib_s32 *color)
 371 {
 372   mlib_u32 color0 = color[0] &amp; 0xFF;
 373   mlib_d64 dcolor;
 374 
 375   VERT_EDGES(1, mlib_u8, 1);
 376 
 377   if (dst_width &lt; 16)
 378     HORIZ_EDGES(1, mlib_u8, 1);
 379 
 380   color0 |= (color0 &lt;&lt; 8);
 381   color0 |= (color0 &lt;&lt; 16);
 382   dcolor = vis_to_double_dup(color0);
 383   for (i = 0; i &lt; dy_t; i++) {
 384     pdst_row = pdst + i * dst_stride;
 385     pdst_row_end = pdst_row + dst_width_t - 1;
 386     dpdst = (mlib_d64 *) vis_alignaddr(pdst_row, 0);
 387     emask = vis_edge8(pdst_row, pdst_row_end);
 388     vis_pst_8(dcolor, dpdst++, emask);
 389     j = (mlib_s32) ((mlib_u8 *) dpdst - pdst_row);
 390     for (; j &lt; (dst_width_t - 8); j += 8)
 391       *dpdst++ = dcolor;
 392     emask = vis_edge8(dpdst, pdst_row_end);
 393     vis_pst_8(dcolor, dpdst, emask);
 394   }
 395 
 396   for (i = 0; i &lt; dy_b; i++) {
 397     pdst_row = pdst + (dst_height - 1 - i) * dst_stride;
 398     pdst_row_end = pdst_row + dst_width_b - 1;
 399     dpdst = (mlib_d64 *) vis_alignaddr(pdst_row, 0);
 400     emask = vis_edge8(pdst_row, pdst_row_end);
 401     vis_pst_8(dcolor, dpdst++, emask);
 402     j = (mlib_s32) ((mlib_u8 *) dpdst - pdst_row);
 403     for (; j &lt; (dst_width_b - 8); j += 8)
 404       *dpdst++ = dcolor;
 405     emask = vis_edge8(dpdst, pdst_row_end);
 406     vis_pst_8(dcolor, dpdst, emask);
 407   }
 408 }
 409 
 410 /***************************************************************/
 411 void mlib_ImageConvClearEdge_U8_2(mlib_image     *dst,
 412                                   mlib_s32       dx_l,
 413                                   mlib_s32       dx_r,
 414                                   mlib_s32       dy_t,
 415                                   mlib_s32       dy_b,
 416                                   const mlib_s32 *color,
 417                                   mlib_s32       cmask)
 418 {
 419   mlib_u32 color0 = color[0] &amp; 0xFF, color1 = color[1] &amp; 0xFF;
 420   mlib_d64 dcolor0;
 421   mlib_s32 tmask = cmask &amp; 3, mask1, offset;
 422   mlib_d64 dcolor;
 423 
 424   VERT_EDGES(2, mlib_u8, cmask);
 425 
 426   if (dst_width &lt; 8)
 427     HORIZ_EDGES(2, mlib_u8, cmask);
 428 
 429   tmask |= (tmask &lt;&lt; 2);
 430   tmask |= (tmask &lt;&lt; 4);
 431   tmask |= (tmask &lt;&lt; 8);
 432   color0 = (color0 &lt;&lt; 8) | color1;
 433   color0 |= (color0 &lt;&lt; 16);
 434   dcolor0 = vis_to_double_dup(color0);
 435   for (i = 0; i &lt; dy_t; i++) {
 436     pdst_row = pdst + i * dst_stride;
 437     pdst_row_end = pdst_row + dst_width_t * 2 - 1;
 438     dpdst = (mlib_d64 *) vis_alignaddr(pdst_row, 0);
 439     offset = pdst_row - (mlib_u8 *) dpdst;
 440     mask1 = (tmask &gt;&gt; offset);
 441     emask = vis_edge8(pdst_row, pdst_row_end) &amp; mask1;
 442     dcolor = vis_faligndata(dcolor0, dcolor0);
 443     vis_pst_8(dcolor, dpdst++, emask);
 444     j = (mlib_s32) ((mlib_u8 *) dpdst - pdst_row);
 445     for (; j &lt; (dst_width_t * 2 - 8); j += 8)
 446       vis_pst_8(dcolor, dpdst++, mask1);
 447     emask = vis_edge8(dpdst, pdst_row_end) &amp; mask1;
 448     vis_pst_8(dcolor, dpdst, emask);
 449   }
 450 
 451   for (i = 0; i &lt; dy_b; i++) {
 452     pdst_row = pdst + (dst_height - 1 - i) * dst_stride;
 453     pdst_row_end = pdst_row + dst_width_b * 2 - 1;
 454     dpdst = (mlib_d64 *) vis_alignaddr(pdst_row, 0);
 455     offset = pdst_row - (mlib_u8 *) dpdst;
 456     mask1 = (tmask &gt;&gt; offset);
 457     emask = vis_edge8(pdst_row, pdst_row_end) &amp; mask1;
 458     dcolor = vis_faligndata(dcolor0, dcolor0);
 459     vis_pst_8(dcolor, dpdst++, emask);
 460     j = (mlib_s32) ((mlib_u8 *) dpdst - pdst_row);
 461     for (; j &lt; (dst_width_b * 2 - 8); j += 8)
 462       vis_pst_8(dcolor, dpdst++, mask1);
 463     emask = vis_edge8(dpdst, pdst_row_end) &amp; mask1;
 464     vis_pst_8(dcolor, dpdst, emask);
 465   }
 466 }
 467 
 468 /***************************************************************/
 469 void mlib_ImageConvClearEdge_U8_3(mlib_image     *dst,
 470                                   mlib_s32       dx_l,
 471                                   mlib_s32       dx_r,
 472                                   mlib_s32       dy_t,
 473                                   mlib_s32       dy_b,
 474                                   const mlib_s32 *color,
 475                                   mlib_s32       cmask)
 476 {
 477   mlib_u32 color0 = color[0] &amp; 0xFF,
 478     color1 = color[1] &amp; 0xFF, color2 = color[2] &amp; 0xFF, col;
 479   mlib_d64 dcolor1, dcolor2, dcolor00, dcolor11, dcolor22;
 480   mlib_s32 tmask = cmask &amp; 7, mask0, mask1, mask2, offset;
 481   mlib_d64 dcolor;
 482 
 483   VERT_EDGES(3, mlib_u8, cmask);
 484 
 485   if (dst_width &lt; 16)
 486     HORIZ_EDGES(3, mlib_u8, cmask);
 487 
 488   tmask |= (tmask &lt;&lt; 3);
 489   tmask |= (tmask &lt;&lt; 6);
 490   tmask |= (tmask &lt;&lt; 12);
 491   col = (color0 &lt;&lt; 16) | (color1 &lt;&lt; 8) | color2;
 492   color0 = (col &lt;&lt; 8) | color0;
 493   color1 = (color0 &lt;&lt; 8) | color1;
 494   color2 = (color1 &lt;&lt; 8) | color2;
 495   dcolor = vis_to_double(color0, color1);
 496   dcolor1 = vis_to_double(color2, color0);
 497   dcolor2 = vis_to_double(color1, color2);
 498   for (i = 0; i &lt; dy_t; i++) {
 499     pdst_row = pdst + i * dst_stride;
 500     pdst_row_end = pdst_row + dst_width_t * 3 - 1;
 501     dpdst = (mlib_d64 *) ((mlib_addr) pdst_row &amp; ~7);
 502     offset = pdst_row - (mlib_u8 *) dpdst;
 503     mask2 = (tmask &gt;&gt; (9 - ((8 - offset) &amp; 7)));
 504     mask0 = mask2 &gt;&gt; 1;
 505     mask1 = mask0 &gt;&gt; 1;
 506     vis_alignaddr((void *)(-(mlib_addr) pdst_row), 8);
 507     dcolor22 = vis_faligndata(dcolor2, dcolor);
 508     dcolor00 = vis_faligndata(dcolor, dcolor1);
 509     dcolor11 = vis_faligndata(dcolor1, dcolor2);
 510     emask = vis_edge8(pdst_row, pdst_row_end) &amp; mask2;
 511 
 512     if ((mlib_addr) pdst_row &amp; 7)
 513       vis_pst_8(dcolor22, dpdst++, emask);
 514     j = (mlib_s32) ((mlib_u8 *) dpdst - pdst_row);
 515     for (; j &lt; (dst_width_t * 3 - 24); j += 24) {
 516       vis_pst_8(dcolor00, dpdst, mask0);
 517       vis_pst_8(dcolor11, dpdst + 1, mask1);
 518       vis_pst_8(dcolor22, dpdst + 2, mask2);
 519       dpdst += 3;
 520     }
 521 
 522     if (j &lt; (dst_width_t * 3 - 8)) {
 523       vis_pst_8(dcolor00, dpdst++, mask0);
 524 
 525       if (j &lt; (dst_width_t * 3 - 16)) {
 526         vis_pst_8(dcolor11, dpdst++, mask1);
 527         dcolor00 = dcolor22;
 528         mask0 = mask2;
 529       }
 530       else {
 531         dcolor00 = dcolor11;
 532         mask0 = mask1;
 533       }
 534     }
 535 
 536     emask = vis_edge8(dpdst, pdst_row_end) &amp; mask0;
 537     vis_pst_8(dcolor00, dpdst, emask);
 538   }
 539 
 540   for (i = 0; i &lt; dy_b; i++) {
 541     pdst_row = pdst + (dst_height - 1 - i) * dst_stride;
 542     pdst_row_end = pdst_row + dst_width_b * 3 - 1;
 543     dpdst = (mlib_d64 *) ((mlib_addr) pdst_row &amp; ~7);
 544     offset = pdst_row - (mlib_u8 *) dpdst;
 545     mask2 = (tmask &gt;&gt; (9 - ((8 - offset) &amp; 7)));
 546     mask0 = mask2 &gt;&gt; 1;
 547     mask1 = mask0 &gt;&gt; 1;
 548     vis_alignaddr((void *)(-(mlib_addr) pdst_row), 8);
 549     dcolor22 = vis_faligndata(dcolor2, dcolor);
 550     dcolor00 = vis_faligndata(dcolor, dcolor1);
 551     dcolor11 = vis_faligndata(dcolor1, dcolor2);
 552     emask = vis_edge8(pdst_row, pdst_row_end) &amp; mask2;
 553 
 554     if ((mlib_addr) pdst_row &amp; 7)
 555       vis_pst_8(dcolor22, dpdst++, emask);
 556     j = (mlib_s32) ((mlib_u8 *) dpdst - pdst_row);
 557     for (; j &lt; (dst_width_b * 3 - 24); j += 24) {
 558       vis_pst_8(dcolor00, dpdst, mask0);
 559       vis_pst_8(dcolor11, dpdst + 1, mask1);
 560       vis_pst_8(dcolor22, dpdst + 2, mask2);
 561       dpdst += 3;
 562     }
 563 
 564     if (j &lt; (dst_width_b * 3 - 8)) {
 565       vis_pst_8(dcolor00, dpdst++, mask0);
 566 
 567       if (j &lt; (dst_width_b * 3 - 16)) {
 568         vis_pst_8(dcolor11, dpdst++, mask1);
 569         dcolor00 = dcolor22;
 570         mask0 = mask2;
 571       }
 572       else {
 573         dcolor00 = dcolor11;
 574         mask0 = mask1;
 575       }
 576     }
 577 
 578     emask = vis_edge8(dpdst, pdst_row_end) &amp; mask0;
 579     vis_pst_8(dcolor00, dpdst, emask);
 580   }
 581 }
 582 
 583 /***************************************************************/
 584 void mlib_ImageConvClearEdge_U8_4(mlib_image     *dst,
 585                                   mlib_s32       dx_l,
 586                                   mlib_s32       dx_r,
 587                                   mlib_s32       dy_t,
 588                                   mlib_s32       dy_b,
 589                                   const mlib_s32 *color,
 590                                   mlib_s32       cmask)
 591 {
 592   mlib_u32 color0 = color[0] &amp; 0xFF,
 593     color1 = color[1] &amp; 0xFF, color2 = color[2] &amp; 0xFF, color3 = color[3] &amp; 0xFF;
 594   mlib_d64 dcolor0;
 595   mlib_s32 tmask = cmask &amp; 0xF, mask1, offset;
 596   mlib_d64 dcolor;
 597 
 598   VERT_EDGES(4, mlib_u8, cmask);
 599 
 600   if (dst_width &lt; 4)
 601     HORIZ_EDGES(4, mlib_u8, cmask);
 602 
 603   tmask |= (tmask &lt;&lt; 4);
 604   tmask |= (tmask &lt;&lt; 8);
 605   color0 = (color0 &lt;&lt; 24) | (color1 &lt;&lt; 16) | (color2 &lt;&lt; 8) | color3;
 606   dcolor0 = vis_to_double_dup(color0);
 607   for (i = 0; i &lt; dy_t; i++) {
 608     pdst_row = pdst + i * dst_stride;
 609     pdst_row_end = pdst_row + dst_width_t * 4 - 1;
 610     dpdst = (mlib_d64 *) ((mlib_addr) pdst_row &amp; ~7);
 611     offset = pdst_row - (mlib_u8 *) dpdst;
 612     mask1 = (tmask &gt;&gt; offset);
 613     vis_alignaddr((void *)(-(mlib_addr) pdst_row), 8);
 614     emask = vis_edge8(pdst_row, pdst_row_end) &amp; mask1;
 615     dcolor = vis_faligndata(dcolor0, dcolor0);
 616     vis_pst_8(dcolor, dpdst++, emask);
 617     j = (mlib_s32) ((mlib_u8 *) dpdst - pdst_row);
 618     for (; j &lt; (dst_width_t * 4 - 8); j += 8)
 619       vis_pst_8(dcolor, dpdst++, mask1);
 620     emask = vis_edge8(dpdst, pdst_row_end) &amp; mask1;
 621     vis_pst_8(dcolor, dpdst, emask);
 622   }
 623 
 624   for (i = 0; i &lt; dy_b; i++) {
 625     pdst_row = pdst + (dst_height - 1 - i) * dst_stride;
 626     pdst_row_end = pdst_row + dst_width_b * 4 - 1;
 627     dpdst = (mlib_d64 *) ((mlib_addr) pdst_row &amp; ~7);
 628     offset = pdst_row - (mlib_u8 *) dpdst;
 629     mask1 = (tmask &gt;&gt; offset);
 630     vis_alignaddr((void *)(-(mlib_addr) pdst_row), 8);
 631     emask = vis_edge8(pdst_row, pdst_row_end) &amp; mask1;
 632     dcolor = vis_faligndata(dcolor0, dcolor0);
 633     vis_pst_8(dcolor, dpdst++, emask);
 634     j = (mlib_s32) ((mlib_u8 *) dpdst - pdst_row);
 635     for (; j &lt; (dst_width_b * 4 - 8); j += 8)
 636       vis_pst_8(dcolor, dpdst++, mask1);
 637     emask = vis_edge8(dpdst, pdst_row_end) &amp; mask1;
 638     vis_pst_8(dcolor, dpdst, emask);
 639   }
 640 }
 641 
 642 /***************************************************************/
 643 void mlib_ImageConvClearEdge_S16_1(mlib_image     *dst,
 644                                    mlib_s32       dx_l,
 645                                    mlib_s32       dx_r,
 646                                    mlib_s32       dy_t,
 647                                    mlib_s32       dy_b,
 648                                    const mlib_s32 *color)
 649 {
 650   mlib_u32 color0 = color[0] &amp; 0xFFFF;
 651   mlib_d64 dcolor;
 652 
 653   VERT_EDGES(1, mlib_s16, 1);
 654 
 655   if (dst_width &lt; 8)
 656     HORIZ_EDGES(1, mlib_s16, 1);
 657 
 658   color0 |= (color0 &lt;&lt; 16);
 659   dcolor = vis_to_double_dup(color0);
 660   for (i = 0; i &lt; dy_t; i++) {
 661     pdst_row = pdst + i * dst_stride;
 662     pdst_row_end = pdst_row + dst_width_t - 1;
 663     dpdst = (mlib_d64 *) vis_alignaddr(pdst_row, 0);
 664     emask = vis_edge16(pdst_row, pdst_row_end);
 665     vis_pst_16(dcolor, dpdst++, emask);
 666     j = (mlib_s32) ((mlib_s16 *) dpdst - pdst_row);
 667     for (; j &lt; (dst_width_t - 4); j += 4)
 668       *dpdst++ = dcolor;
 669     emask = vis_edge16(dpdst, pdst_row_end);
 670     vis_pst_16(dcolor, dpdst, emask);
 671   }
 672 
 673   for (i = 0; i &lt; dy_b; i++) {
 674     pdst_row = pdst + (dst_height - 1 - i) * dst_stride;
 675     pdst_row_end = pdst_row + dst_width_b - 1;
 676     dpdst = (mlib_d64 *) vis_alignaddr(pdst_row, 0);
 677     emask = vis_edge16(pdst_row, pdst_row_end);
 678     vis_pst_16(dcolor, dpdst++, emask);
 679     j = (mlib_s32) ((mlib_s16 *) dpdst - pdst_row);
 680     for (; j &lt; (dst_width_b - 4); j += 4)
 681       *dpdst++ = dcolor;
 682     emask = vis_edge16(dpdst, pdst_row_end);
 683     vis_pst_16(dcolor, dpdst, emask);
 684   }
 685 }
 686 
 687 /***************************************************************/
 688 void mlib_ImageConvClearEdge_S16_2(mlib_image     *dst,
 689                                    mlib_s32       dx_l,
 690                                    mlib_s32       dx_r,
 691                                    mlib_s32       dy_t,
 692                                    mlib_s32       dy_b,
 693                                    const mlib_s32 *color,
 694                                    mlib_s32       cmask)
 695 {
 696   mlib_u32 color0 = color[0] &amp; 0xFFFF, color1 = color[1] &amp; 0xFFFF;
 697   mlib_d64 dcolor0;
 698   mlib_s32 tmask = cmask &amp; 3, mask1, offset;
 699   mlib_d64 dcolor;
 700 
 701   VERT_EDGES(2, mlib_s16, cmask);
 702 
 703   if (dst_width &lt; 4)
 704     HORIZ_EDGES(2, mlib_s16, cmask);
 705 
 706   tmask |= (tmask &lt;&lt; 2);
 707   tmask |= (tmask &lt;&lt; 4);
 708   color0 = (color0 &lt;&lt; 16) | color1;
 709   dcolor0 = vis_to_double_dup(color0);
 710   for (i = 0; i &lt; dy_t; i++) {
 711     pdst_row = pdst + i * dst_stride;
 712     pdst_row_end = pdst_row + dst_width_t * 2 - 1;
 713     dpdst = (mlib_d64 *) vis_alignaddr(pdst_row, 0);
 714     offset = pdst_row - (mlib_s16 *) dpdst;
 715     mask1 = (tmask &gt;&gt; offset);
 716     emask = vis_edge16(pdst_row, pdst_row_end) &amp; mask1;
 717     dcolor = vis_faligndata(dcolor0, dcolor0);
 718     vis_pst_16(dcolor, dpdst++, emask);
 719     j = (mlib_s32) ((mlib_s16 *) dpdst - pdst_row);
 720     for (; j &lt; (dst_width_t * 2 - 4); j += 4)
 721       vis_pst_16(dcolor, dpdst++, mask1);
 722     emask = vis_edge16(dpdst, pdst_row_end) &amp; mask1;
 723     vis_pst_16(dcolor, dpdst, emask);
 724   }
 725 
 726   for (i = 0; i &lt; dy_b; i++) {
 727     pdst_row = pdst + (dst_height - 1 - i) * dst_stride;
 728     pdst_row_end = pdst_row + dst_width_b * 2 - 1;
 729     dpdst = (mlib_d64 *) vis_alignaddr(pdst_row, 0);
 730     offset = pdst_row - (mlib_s16 *) dpdst;
 731     mask1 = (tmask &gt;&gt; offset);
 732     emask = vis_edge16(pdst_row, pdst_row_end) &amp; mask1;
 733     dcolor = vis_faligndata(dcolor0, dcolor0);
 734     vis_pst_16(dcolor, dpdst++, emask);
 735     j = (mlib_s32) ((mlib_s16 *) dpdst - pdst_row);
 736     for (; j &lt; (dst_width_b * 2 - 4); j += 4)
 737       vis_pst_16(dcolor, dpdst++, mask1);
 738     emask = vis_edge16(dpdst, pdst_row_end) &amp; mask1;
 739     vis_pst_16(dcolor, dpdst, emask);
 740   }
 741 }
 742 
 743 /***************************************************************/
 744 void mlib_ImageConvClearEdge_S16_3(mlib_image     *dst,
 745                                    mlib_s32       dx_l,
 746                                    mlib_s32       dx_r,
 747                                    mlib_s32       dy_t,
 748                                    mlib_s32       dy_b,
 749                                    const mlib_s32 *color,
 750                                    mlib_s32       cmask)
 751 {
 752   mlib_u32 color0 = color[0] &amp; 0xFFFF,
 753     color1 = color[1] &amp; 0xFFFF, color2 = color[2] &amp; 0xFFFF, col0, col1, col2;
 754   mlib_d64 dcolor1, dcolor2, dcolor00, dcolor11, dcolor22;
 755   mlib_s32 tmask = cmask &amp; 7, mask0, mask1, mask2, offset;
 756   mlib_d64 dcolor;
 757 
 758   VERT_EDGES(3, mlib_s16, cmask);
 759 
 760   if (dst_width &lt; 8)
 761     HORIZ_EDGES(3, mlib_s16, cmask);
 762 
 763   tmask |= (tmask &lt;&lt; 3);
 764   tmask |= (tmask &lt;&lt; 6);
 765   tmask |= (tmask &lt;&lt; 12);
 766   col0 = (color0 &lt;&lt; 16) | color1;
 767   col1 = (color2 &lt;&lt; 16) | color0;
 768   col2 = (color1 &lt;&lt; 16) | color2;
 769   dcolor = vis_to_double(col0, col1);
 770   dcolor1 = vis_to_double(col2, col0);
 771   dcolor2 = vis_to_double(col1, col2);
 772   for (i = 0; i &lt; dy_t; i++) {
 773     pdst_row = pdst + i * dst_stride;
 774     pdst_row_end = pdst_row + dst_width_t * 3 - 1;
 775     dpdst = (mlib_d64 *) ((mlib_addr) pdst_row &amp; ~7);
 776     offset = pdst_row - (mlib_s16 *) dpdst;
 777     mask2 = (tmask &gt;&gt; (6 - ((4 - offset) &amp; 3)));
 778     mask0 = mask2 &gt;&gt; 2;
 779     mask1 = mask0 &gt;&gt; 2;
 780     vis_alignaddr((void *)(-(mlib_addr) pdst_row), 8);
 781     dcolor22 = vis_faligndata(dcolor2, dcolor);
 782     dcolor00 = vis_faligndata(dcolor, dcolor1);
 783     dcolor11 = vis_faligndata(dcolor1, dcolor2);
 784     emask = vis_edge16(pdst_row, pdst_row_end) &amp; mask2;
 785 
 786     if ((mlib_addr) pdst_row &amp; 7)
 787       vis_pst_16(dcolor22, dpdst++, emask);
 788     j = (mlib_s32) ((mlib_s16 *) dpdst - pdst_row);
 789     for (; j &lt; (dst_width_t * 3 - 12); j += 12) {
 790       vis_pst_16(dcolor00, dpdst, mask0);
 791       vis_pst_16(dcolor11, dpdst + 1, mask1);
 792       vis_pst_16(dcolor22, dpdst + 2, mask2);
 793       dpdst += 3;
 794     }
 795 
 796     if (j &lt; (dst_width_t * 3 - 4)) {
 797       vis_pst_16(dcolor00, dpdst++, mask0);
 798 
 799       if (j &lt; (dst_width_t * 3 - 8)) {
 800         vis_pst_16(dcolor11, dpdst++, mask1);
 801         dcolor00 = dcolor22;
 802         mask0 = mask2;
 803       }
 804       else {
 805         dcolor00 = dcolor11;
 806         mask0 = mask1;
 807       }
 808     }
 809 
 810     emask = vis_edge16(dpdst, pdst_row_end) &amp; mask0;
 811     vis_pst_16(dcolor00, dpdst, emask);
 812   }
 813 
 814   for (i = 0; i &lt; dy_b; i++) {
 815     pdst_row = pdst + (dst_height - 1 - i) * dst_stride;
 816     pdst_row_end = pdst_row + dst_width_b * 3 - 1;
 817     dpdst = (mlib_d64 *) ((mlib_addr) pdst_row &amp; ~7);
 818     offset = pdst_row - (mlib_s16 *) dpdst;
 819     mask2 = (tmask &gt;&gt; (6 - ((4 - offset) &amp; 3)));
 820     mask0 = mask2 &gt;&gt; 2;
 821     mask1 = mask0 &gt;&gt; 2;
 822     vis_alignaddr((void *)(-(mlib_addr) pdst_row), 8);
 823     dcolor22 = vis_faligndata(dcolor2, dcolor);
 824     dcolor00 = vis_faligndata(dcolor, dcolor1);
 825     dcolor11 = vis_faligndata(dcolor1, dcolor2);
 826     emask = vis_edge16(pdst_row, pdst_row_end) &amp; mask2;
 827 
 828     if ((mlib_addr) pdst_row &amp; 7)
 829       vis_pst_16(dcolor22, dpdst++, emask);
 830     j = (mlib_s32) ((mlib_s16 *) dpdst - pdst_row);
 831     for (; j &lt; (dst_width_b * 3 - 12); j += 12) {
 832       vis_pst_16(dcolor00, dpdst, mask0);
 833       vis_pst_16(dcolor11, dpdst + 1, mask1);
 834       vis_pst_16(dcolor22, dpdst + 2, mask2);
 835       dpdst += 3;
 836     }
 837 
 838     if (j &lt; (dst_width_b * 3 - 4)) {
 839       vis_pst_16(dcolor00, dpdst++, mask0);
 840 
 841       if (j &lt; (dst_width_b * 3 - 8)) {
 842         vis_pst_16(dcolor11, dpdst++, mask1);
 843         dcolor00 = dcolor22;
 844         mask0 = mask2;
 845       }
 846       else {
 847         dcolor00 = dcolor11;
 848         mask0 = mask1;
 849       }
 850     }
 851 
 852     emask = vis_edge16(dpdst, pdst_row_end) &amp; mask0;
 853     vis_pst_16(dcolor00, dpdst, emask);
 854   }
 855 }
 856 
 857 /***************************************************************/
 858 void mlib_ImageConvClearEdge_S16_4(mlib_image     *dst,
 859                                    mlib_s32       dx_l,
 860                                    mlib_s32       dx_r,
 861                                    mlib_s32       dy_t,
 862                                    mlib_s32       dy_b,
 863                                    const mlib_s32 *color,
 864                                    mlib_s32       cmask)
 865 {
 866   mlib_u32 color0 = color[0] &amp; 0xFFFF,
 867     color1 = color[1] &amp; 0xFFFF, color2 = color[2] &amp; 0xFFFF, color3 = color[3] &amp; 0xFFFF;
 868   mlib_d64 dcolor0;
 869   mlib_s32 tmask = cmask &amp; 0xF, mask1, offset;
 870   mlib_d64 dcolor;
 871 
 872   VERT_EDGES(4, mlib_s16, cmask);
 873 
 874   if (dst_width &lt; 4)
 875     HORIZ_EDGES(4, mlib_s16, cmask);
 876 
 877   tmask |= (tmask &lt;&lt; 4);
 878   color0 = (color0 &lt;&lt; 16) | color1;
 879   color1 = (color2 &lt;&lt; 16) | color3;
 880   dcolor0 = vis_to_double(color0, color1);
 881   for (i = 0; i &lt; dy_t; i++) {
 882     pdst_row = pdst + i * dst_stride;
 883     pdst_row_end = pdst_row + dst_width_t * 4 - 1;
 884     dpdst = (mlib_d64 *) ((mlib_addr) pdst_row &amp; ~7);
 885     offset = pdst_row - (mlib_s16 *) dpdst;
 886     mask1 = (tmask &gt;&gt; offset);
 887     vis_alignaddr((void *)(-(mlib_addr) pdst_row), 8);
 888     emask = vis_edge16(pdst_row, pdst_row_end) &amp; mask1;
 889     dcolor = vis_faligndata(dcolor0, dcolor0);
 890     vis_pst_16(dcolor, dpdst++, emask);
 891     j = (mlib_s32) ((mlib_s16 *) dpdst - pdst_row);
 892     for (; j &lt; (dst_width_t * 4 - 4); j += 4)
 893       vis_pst_16(dcolor, dpdst++, mask1);
 894     emask = vis_edge16(dpdst, pdst_row_end) &amp; mask1;
 895     vis_pst_16(dcolor, dpdst, emask);
 896   }
 897 
 898   for (i = 0; i &lt; dy_b; i++) {
 899     pdst_row = pdst + (dst_height - 1 - i) * dst_stride;
 900     pdst_row_end = pdst_row + dst_width_b * 4 - 1;
 901     dpdst = (mlib_d64 *) ((mlib_addr) pdst_row &amp; ~7);
 902     offset = pdst_row - (mlib_s16 *) dpdst;
 903     mask1 = (tmask &gt;&gt; offset);
 904     vis_alignaddr((void *)(-(mlib_addr) pdst_row), 8);
 905     emask = vis_edge16(pdst_row, pdst_row_end) &amp; mask1;
 906     dcolor = vis_faligndata(dcolor0, dcolor0);
 907     vis_pst_16(dcolor, dpdst++, emask);
 908     j = (mlib_s32) ((mlib_s16 *) dpdst - pdst_row);
 909     for (; j &lt; (dst_width_b * 4 - 4); j += 4)
 910       vis_pst_16(dcolor, dpdst++, mask1);
 911     emask = vis_edge16(dpdst, pdst_row_end) &amp; mask1;
 912     vis_pst_16(dcolor, dpdst, emask);
 913   }
 914 }
 915 
 916 /***************************************************************/
 917 void mlib_ImageConvClearEdge_S32_1(mlib_image     *dst,
 918                                    mlib_s32       dx_l,
 919                                    mlib_s32       dx_r,
 920                                    mlib_s32       dy_t,
 921                                    mlib_s32       dy_b,
 922                                    const mlib_s32 *color)
 923 {
 924   mlib_s32 color0 = color[0];
 925   mlib_d64 dcolor;
 926 
 927   VERT_EDGES(1, mlib_s32, 1);
 928 
 929   if (dst_width &lt; 8)
 930     HORIZ_EDGES(1, mlib_s32, 1);
 931 
 932   dcolor = vis_to_double_dup(color0);
 933   for (i = 0; i &lt; dy_t; i++) {
 934     pdst_row = pdst + i * dst_stride;
 935     pdst_row_end = pdst_row + dst_width_t - 1;
 936     dpdst = (mlib_d64 *) vis_alignaddr(pdst_row, 0);
 937     emask = vis_edge32(pdst_row, pdst_row_end);
 938     vis_pst_32(dcolor, dpdst++, emask);
 939     j = (mlib_s32) ((mlib_s32 *) dpdst - pdst_row);
 940     for (; j &lt; (dst_width_t - 2); j += 2)
 941       *dpdst++ = dcolor;
 942     emask = vis_edge32(dpdst, pdst_row_end);
 943     vis_pst_32(dcolor, dpdst, emask);
 944   }
 945 
 946   for (i = 0; i &lt; dy_b; i++) {
 947     pdst_row = pdst + (dst_height - 1 - i) * dst_stride;
 948     pdst_row_end = pdst_row + dst_width_b - 1;
 949     dpdst = (mlib_d64 *) vis_alignaddr(pdst_row, 0);
 950     emask = vis_edge32(pdst_row, pdst_row_end);
 951     vis_pst_32(dcolor, dpdst++, emask);
 952     j = (mlib_s32) ((mlib_s32 *) dpdst - pdst_row);
 953     for (; j &lt; (dst_width_b - 2); j += 2)
 954       *dpdst++ = dcolor;
 955     emask = vis_edge32(dpdst, pdst_row_end);
 956     vis_pst_32(dcolor, dpdst, emask);
 957   }
 958 }
 959 
 960 /***************************************************************/
 961 void mlib_ImageConvClearEdge_S32_2(mlib_image     *dst,
 962                                    mlib_s32       dx_l,
 963                                    mlib_s32       dx_r,
 964                                    mlib_s32       dy_t,
 965                                    mlib_s32       dy_b,
 966                                    const mlib_s32 *color,
 967                                    mlib_s32       cmask)
 968 {
 969   mlib_s32 color0 = color[0], color1 = color[1];
 970   mlib_d64 dcolor0;
 971   mlib_s32 tmask = cmask &amp; 3, mask1, offset;
 972   mlib_d64 dcolor;
 973 
 974   VERT_EDGES(2, mlib_s32, cmask);
 975 
 976   if (dst_width &lt; 4)
 977     HORIZ_EDGES(2, mlib_s32, cmask);
 978 
 979   tmask |= (tmask &lt;&lt; 2);
 980   dcolor0 = vis_to_double(color0, color1);
 981   for (i = 0; i &lt; dy_t; i++) {
 982     pdst_row = pdst + i * dst_stride;
 983     pdst_row_end = pdst_row + dst_width_t * 2 - 1;
 984     dpdst = (mlib_d64 *) vis_alignaddr(pdst_row, 0);
 985     offset = pdst_row - (mlib_s32 *) dpdst;
 986     mask1 = (tmask &gt;&gt; offset);
 987     emask = vis_edge32(pdst_row, pdst_row_end) &amp; mask1;
 988     dcolor = vis_faligndata(dcolor0, dcolor0);
 989     vis_pst_32(dcolor, dpdst++, emask);
 990     j = (mlib_s32) ((mlib_s32 *) dpdst - pdst_row);
 991     for (; j &lt; (dst_width_t * 2 - 2); j += 2)
 992       vis_pst_32(dcolor, dpdst++, mask1);
 993     emask = vis_edge32(dpdst, pdst_row_end) &amp; mask1;
 994     vis_pst_32(dcolor, dpdst, emask);
 995   }
 996 
 997   for (i = 0; i &lt; dy_b; i++) {
 998     pdst_row = pdst + (dst_height - 1 - i) * dst_stride;
 999     pdst_row_end = pdst_row + dst_width_b * 2 - 1;
1000     dpdst = (mlib_d64 *) vis_alignaddr(pdst_row, 0);
1001     offset = pdst_row - (mlib_s32 *) dpdst;
1002     mask1 = (tmask &gt;&gt; offset);
1003     emask = vis_edge32(pdst_row, pdst_row_end) &amp; mask1;
1004     dcolor = vis_faligndata(dcolor0, dcolor0);
1005     vis_pst_32(dcolor, dpdst++, emask);
1006     j = (mlib_s32) ((mlib_s32 *) dpdst - pdst_row);
1007     for (; j &lt; (dst_width_b * 2 - 2); j += 2)
1008       vis_pst_32(dcolor, dpdst++, mask1);
1009     emask = vis_edge32(dpdst, pdst_row_end) &amp; mask1;
1010     vis_pst_32(dcolor, dpdst, emask);
1011   }
1012 }
1013 
1014 /***************************************************************/
1015 void mlib_ImageConvClearEdge_S32_3(mlib_image     *dst,
1016                                    mlib_s32       dx_l,
1017                                    mlib_s32       dx_r,
1018                                    mlib_s32       dy_t,
1019                                    mlib_s32       dy_b,
1020                                    const mlib_s32 *color,
1021                                    mlib_s32       cmask)
1022 {
1023   mlib_s32 color0 = color[0], color1 = color[1], color2 = color[2];
1024   mlib_d64 dcolor1, dcolor2, dcolor00, dcolor11, dcolor22;
1025   mlib_s32 tmask = cmask &amp; 7, mask0, mask1, mask2, offset;
1026   mlib_d64 dcolor;
1027 
1028   VERT_EDGES(3, mlib_s32, cmask);
1029 
1030   if (dst_width &lt; 8)
1031     HORIZ_EDGES(3, mlib_s32, cmask);
1032 
1033   tmask |= (tmask &lt;&lt; 3);
1034   tmask |= (tmask &lt;&lt; 6);
1035   dcolor = vis_to_double(color0, color1);
1036   dcolor1 = vis_to_double(color2, color0);
1037   dcolor2 = vis_to_double(color1, color2);
1038   for (i = 0; i &lt; dy_t; i++) {
1039     pdst_row = pdst + i * dst_stride;
1040     pdst_row_end = pdst_row + dst_width_t * 3 - 1;
1041     dpdst = (mlib_d64 *) ((mlib_addr) pdst_row &amp; ~7);
1042     offset = pdst_row - (mlib_s32 *) dpdst;
1043     mask2 = (tmask &gt;&gt; (3 - ((2 - offset) &amp; 1)));
1044     mask0 = mask2 &gt;&gt; 1;
1045     mask1 = mask0 &gt;&gt; 1;
1046     vis_alignaddr((void *)(-(mlib_addr) pdst_row), 8);
1047     dcolor22 = vis_faligndata(dcolor2, dcolor);
1048     dcolor00 = vis_faligndata(dcolor, dcolor1);
1049     dcolor11 = vis_faligndata(dcolor1, dcolor2);
1050     emask = vis_edge32(pdst_row, pdst_row_end) &amp; mask2;
1051 
1052     if ((mlib_addr) pdst_row &amp; 7)
1053       vis_pst_32(dcolor22, dpdst++, emask);
1054     j = (mlib_s32) ((mlib_s32 *) dpdst - pdst_row);
1055     for (; j &lt; (dst_width_t * 3 - 6); j += 6) {
1056       vis_pst_32(dcolor00, dpdst, mask0);
1057       vis_pst_32(dcolor11, dpdst + 1, mask1);
1058       vis_pst_32(dcolor22, dpdst + 2, mask2);
1059       dpdst += 3;
1060     }
1061 
1062     if (j &lt; (dst_width_t * 3 - 2)) {
1063       vis_pst_32(dcolor00, dpdst++, mask0);
1064 
1065       if (j &lt; (dst_width_t * 3 - 4)) {
1066         vis_pst_32(dcolor11, dpdst++, mask1);
1067         dcolor00 = dcolor22;
1068         mask0 = mask2;
1069       }
1070       else {
1071         dcolor00 = dcolor11;
1072         mask0 = mask1;
1073       }
1074     }
1075 
1076     emask = vis_edge32(dpdst, pdst_row_end) &amp; mask0;
1077     vis_pst_32(dcolor00, dpdst, emask);
1078   }
1079 
1080   for (i = 0; i &lt; dy_b; i++) {
1081     pdst_row = pdst + (dst_height - 1 - i) * dst_stride;
1082     pdst_row_end = pdst_row + dst_width_b * 3 - 1;
1083     dpdst = (mlib_d64 *) ((mlib_addr) pdst_row &amp; ~7);
1084     offset = pdst_row - (mlib_s32 *) dpdst;
1085     mask2 = (tmask &gt;&gt; (3 - ((2 - offset) &amp; 1)));
1086     mask0 = mask2 &gt;&gt; 1;
1087     mask1 = mask0 &gt;&gt; 1;
1088     vis_alignaddr((void *)(-(mlib_addr) pdst_row), 8);
1089     dcolor22 = vis_faligndata(dcolor2, dcolor);
1090     dcolor00 = vis_faligndata(dcolor, dcolor1);
1091     dcolor11 = vis_faligndata(dcolor1, dcolor2);
1092     emask = vis_edge32(pdst_row, pdst_row_end) &amp; mask2;
1093 
1094     if ((mlib_addr) pdst_row &amp; 7)
1095       vis_pst_32(dcolor22, dpdst++, emask);
1096     j = (mlib_s32) ((mlib_s32 *) dpdst - pdst_row);
1097     for (; j &lt; (dst_width_b * 3 - 6); j += 6) {
1098       vis_pst_32(dcolor00, dpdst, mask0);
1099       vis_pst_32(dcolor11, dpdst + 1, mask1);
1100       vis_pst_32(dcolor22, dpdst + 2, mask2);
1101       dpdst += 3;
1102     }
1103 
1104     if (j &lt; (dst_width_b * 3 - 2)) {
1105       vis_pst_32(dcolor00, dpdst++, mask0);
1106 
1107       if (j &lt; (dst_width_b * 3 - 4)) {
1108         vis_pst_32(dcolor11, dpdst++, mask1);
1109         dcolor00 = dcolor22;
1110         mask0 = mask2;
1111       }
1112       else {
1113         dcolor00 = dcolor11;
1114         mask0 = mask1;
1115       }
1116     }
1117 
1118     emask = vis_edge32(dpdst, pdst_row_end) &amp; mask0;
1119     vis_pst_32(dcolor00, dpdst, emask);
1120   }
1121 }
1122 
1123 /***************************************************************/
1124 void mlib_ImageConvClearEdge_S32_4(mlib_image     *dst,
1125                                    mlib_s32       dx_l,
1126                                    mlib_s32       dx_r,
1127                                    mlib_s32       dy_t,
1128                                    mlib_s32       dy_b,
1129                                    const mlib_s32 *color,
1130                                    mlib_s32       cmask)
1131 {
1132   mlib_u32 color0 = color[0], color1 = color[1], color2 = color[2], color3 = color[3];
1133   mlib_d64 dcolor0, dcolor1, dcolor00, dcolor11;
1134   mlib_s32 tmask = cmask &amp; 0xF, mask0, mask1, offset;
1135 
1136   VERT_EDGES(4, mlib_s32, cmask);
1137 
1138   if (dst_width &lt; 4)
1139     HORIZ_EDGES(4, mlib_s32, cmask);
1140 
1141   tmask |= (tmask &lt;&lt; 4);
1142   dcolor0 = vis_to_double(color0, color1);
1143   dcolor1 = vis_to_double(color2, color3);
1144   for (i = 0; i &lt; dy_t; i++) {
1145     pdst_row = pdst + i * dst_stride;
1146     pdst_row_end = pdst_row + dst_width_t * 4 - 1;
1147     dpdst = (mlib_d64 *) ((mlib_addr) pdst_row &amp; ~7);
1148     offset = pdst_row - (mlib_s32 *) dpdst;
1149     mask1 = (tmask &gt;&gt; (4 - ((2 - offset) &amp; 1)));
1150     mask0 = mask1 &gt;&gt; 2;
1151     vis_alignaddr((void *)(-(mlib_addr) pdst_row), 8);
1152     emask = vis_edge32(pdst_row, pdst_row_end) &amp; mask1;
1153     dcolor00 = vis_faligndata(dcolor0, dcolor1);
1154     dcolor11 = vis_faligndata(dcolor1, dcolor0);
1155 
1156     if ((mlib_addr) pdst_row &amp; 7)
1157       vis_pst_32(dcolor11, dpdst++, emask);
1158     j = (mlib_s32) ((mlib_s32 *) dpdst - pdst_row);
1159     for (; j &lt; (dst_width_t * 4 - 4); j += 4) {
1160       vis_pst_32(dcolor00, dpdst, mask0);
1161       vis_pst_32(dcolor11, dpdst + 1, mask1);
1162       dpdst += 2;
1163     }
1164 
1165     if (j &lt; (dst_width_t * 4 - 2)) {
1166       vis_pst_32(dcolor00, dpdst++, mask0);
1167       dcolor00 = dcolor11;
1168       mask0 = mask1;
1169     }
1170 
1171     emask = vis_edge32(dpdst, pdst_row_end) &amp; mask0;
1172     vis_pst_32(dcolor00, dpdst, emask);
1173   }
1174 
1175   for (i = 0; i &lt; dy_b; i++) {
1176     pdst_row = pdst + (dst_height - 1 - i) * dst_stride;
1177     pdst_row_end = pdst_row + dst_width_b * 4 - 1;
1178     dpdst = (mlib_d64 *) ((mlib_addr) pdst_row &amp; ~7);
1179     offset = pdst_row - (mlib_s32 *) dpdst;
1180     mask1 = (tmask &gt;&gt; (4 - ((2 - offset) &amp; 1)));
1181     mask0 = mask1 &gt;&gt; 2;
1182     vis_alignaddr((void *)(-(mlib_addr) pdst_row), 8);
1183     emask = vis_edge32(pdst_row, pdst_row_end) &amp; mask1;
1184     dcolor00 = vis_faligndata(dcolor0, dcolor1);
1185     dcolor11 = vis_faligndata(dcolor1, dcolor0);
1186 
1187     if ((mlib_addr) pdst_row &amp; 7)
1188       vis_pst_32(dcolor11, dpdst++, emask);
1189     j = (mlib_s32) ((mlib_s32 *) dpdst - pdst_row);
1190     for (; j &lt; (dst_width_b * 4 - 4); j += 4) {
1191       vis_pst_32(dcolor00, dpdst, mask0);
1192       vis_pst_32(dcolor11, dpdst + 1, mask1);
1193       dpdst += 2;
1194     }
1195 
1196     if (j &lt; (dst_width_b * 4 - 2)) {
1197       vis_pst_32(dcolor00, dpdst++, mask0);
1198       dcolor00 = dcolor11;
1199       mask0 = mask1;
1200     }
1201 
1202     emask = vis_edge32(dpdst, pdst_row_end) &amp; mask0;
1203     vis_pst_32(dcolor00, dpdst, emask);
1204   }
1205 }
1206 
1207 /***************************************************************/
    </pre>
  </body>
</html>
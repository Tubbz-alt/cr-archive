<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libmlib_image/mlib_v_ImageLookUpSIU8U16Func.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 
  27 
  28 #include &quot;vis_proto.h&quot;
  29 #include &quot;mlib_image.h&quot;
  30 #include &quot;mlib_v_ImageLookUpFunc.h&quot;
  31 
  32 /***************************************************************/
  33 static void mlib_v_ImageLookUpSI_U8_U16_2_SrcOff0_D1(const mlib_u8  *src,
  34                                                      mlib_u16       *dst,
  35                                                      mlib_s32       xsize,
  36                                                      const mlib_f32 *table);
  37 
  38 static void mlib_v_ImageLookUpSI_U8_U16_2_DstNonAl_D1(const mlib_u8  *src,
  39                                                       mlib_u16       *dst,
  40                                                       mlib_s32       xsize,
  41                                                       const mlib_f32 *table);
  42 
  43 static void mlib_v_ImageLookUpSI_U8_U16_2_DstA8D1_SMALL(const mlib_u8  *src,
  44                                                         mlib_u16       *dst,
  45                                                         mlib_s32       xsize,
  46                                                         const mlib_u16 **table);
  47 
  48 static void mlib_v_ImageLookUpSI_U8_U16_2_D1_SMALL(const mlib_u8  *src,
  49                                                    mlib_u16       *dst,
  50                                                    mlib_s32       xsize,
  51                                                    const mlib_u16 **table);
  52 
  53 static void mlib_v_ImageLookUpSI_U8_U16_3_SrcOff0_D1(const mlib_u8  *src,
  54                                                      mlib_u16       *dst,
  55                                                      mlib_s32       xsize,
  56                                                      const mlib_d64 *table);
  57 
  58 static void mlib_v_ImageLookUpSI_U8_U16_3_SrcOff1_D1(const mlib_u8  *src,
  59                                                      mlib_u16       *dst,
  60                                                      mlib_s32       xsize,
  61                                                      const mlib_d64 *table);
  62 
  63 static void mlib_v_ImageLookUpSI_U8_U16_3_SrcOff2_D1(const mlib_u8  *src,
  64                                                      mlib_u16       *dst,
  65                                                      mlib_s32       xsize,
  66                                                      const mlib_d64 *table);
  67 
  68 static void mlib_v_ImageLookUpSI_U8_U16_3_SrcOff3_D1(const mlib_u8  *src,
  69                                                      mlib_u16       *dst,
  70                                                      mlib_s32       xsize,
  71                                                      const mlib_d64 *table);
  72 
  73 static void mlib_v_ImageLookUpSI_U8_U16_3_D1_SMALL(const mlib_u8  *src,
  74                                                    mlib_u16       *dst,
  75                                                    mlib_s32       xsize,
  76                                                    const mlib_u16 **table);
  77 
  78 static void mlib_v_ImageLookUpSI_U8_U16_4_DstA8D1_D1(const mlib_u8  *src,
  79                                                      mlib_u16       *dst,
  80                                                      mlib_s32       xsize,
  81                                                      const mlib_d64 *table);
  82 
  83 static void mlib_v_ImageLookUpSI_U8_U16_4_DstNonAl_D1(const mlib_u8  *src,
  84                                                       mlib_u16       *dst,
  85                                                       mlib_s32       xsize,
  86                                                       const mlib_d64 *table);
  87 
  88 static void mlib_v_ImageLookUpSI_U8_U16_4_DstOff0_D1_SMALL(const mlib_u8  *src,
  89                                                            mlib_u16       *dst,
  90                                                            mlib_s32       xsize,
  91                                                            const mlib_u16 **table);
  92 
  93 static void mlib_v_ImageLookUpSI_U8_U16_4_DstOff1_D1_SMALL(const mlib_u8  *src,
  94                                                            mlib_u16       *dst,
  95                                                            mlib_s32       xsize,
  96                                                            const mlib_u16 **table);
  97 
  98 static void mlib_v_ImageLookUpSI_U8_U16_4_DstOff2_D1_SMALL(const mlib_u8  *src,
  99                                                            mlib_u16       *dst,
 100                                                            mlib_s32       xsize,
 101                                                            const mlib_u16 **table);
 102 
 103 static void mlib_v_ImageLookUpSI_U8_U16_4_DstOff3_D1_SMALL(const mlib_u8  *src,
 104                                                            mlib_u16       *dst,
 105                                                            mlib_s32       xsize,
 106                                                            const mlib_u16 **table);
 107 
 108 /***************************************************************/
 109 #define VIS_LD_U16_I(X, Y)      vis_ld_u16_i((void *)(X), (Y))
 110 
 111 /***************************************************************/
 112 void mlib_v_ImageLookUpSI_U8_U16_2_SrcOff0_D1(const mlib_u8  *src,
 113                                               mlib_u16       *dst,
 114                                               mlib_s32       xsize,
 115                                               const mlib_f32 *table)
 116 {
 117   mlib_u32 *sa;          /* aligned pointer to source data */
 118   mlib_u8  *sp;          /* pointer to source data */
 119   mlib_u32 s0;           /* source data */
 120   mlib_f32 *dp;          /* aligned pointer to destination */
 121   mlib_f32 acc0, acc1;   /* destination data */
 122   mlib_f32 acc2, acc3;   /* destination data */
 123   mlib_s32 i;            /* loop variable */
 124   mlib_u32 s00, s01, s02, s03;
 125 
 126   sa   = (mlib_u32*)src;
 127   dp   = (mlib_f32 *) dst;
 128 
 129   i = 0;
 130 
 131   if (xsize &gt;= 4) {
 132 
 133     s0 = *sa++;
 134     s00 = (s0 &gt;&gt; 22) &amp; 0x3FC;
 135     s01 = (s0 &gt;&gt; 14) &amp; 0x3FC;
 136 
 137 #pragma pipeloop(0)
 138     for(i = 0; i &lt;= xsize - 8; i+=4, dp += 4) {
 139       s02 = (s0 &gt;&gt; 6) &amp; 0x3FC;
 140       s03 = (s0 &lt;&lt; 2) &amp; 0x3FC;
 141       acc0 = *(mlib_f32*)((mlib_u8*)table + s00);
 142       acc1 = *(mlib_f32*)((mlib_u8*)table + s01);
 143       acc2 = *(mlib_f32*)((mlib_u8*)table + s02);
 144       acc3 = *(mlib_f32*)((mlib_u8*)table + s03);
 145       s0 = *sa++;
 146       s00 = (s0 &gt;&gt; 22) &amp; 0x3FC;
 147       s01 = (s0 &gt;&gt; 14) &amp; 0x3FC;
 148       dp[0] = acc0;
 149       dp[1] = acc1;
 150       dp[2] = acc2;
 151       dp[3] = acc3;
 152     }
 153 
 154     s02 = (s0 &gt;&gt; 6) &amp; 0x3FC;
 155     s03 = (s0 &lt;&lt; 2) &amp; 0x3FC;
 156     acc0 = *(mlib_f32*)((mlib_u8*)table + s00);
 157     acc1 = *(mlib_f32*)((mlib_u8*)table + s01);
 158     acc2 = *(mlib_f32*)((mlib_u8*)table + s02);
 159     acc3 = *(mlib_f32*)((mlib_u8*)table + s03);
 160     dp[0] = acc0;
 161     dp[1] = acc1;
 162     dp[2] = acc2;
 163     dp[3] = acc3;
 164     dp += 4;
 165     i += 4;
 166   }
 167 
 168   sp = (mlib_u8*)sa;
 169 
 170   if ( i &lt;= xsize - 2) {
 171     *dp++ = table[sp[0]];
 172     *dp++ = table[sp[1]];
 173     i+=2; sp += 2;
 174   }
 175 
 176   if ( i &lt; xsize) *dp = table[sp[0]];
 177 }
 178 
 179 /***************************************************************/
 180 void mlib_v_ImageLookUpSI_U8_U16_2_DstNonAl_D1(const mlib_u8  *src,
 181                                                mlib_u16       *dst,
 182                                                mlib_s32       xsize,
 183                                                const mlib_f32 *table)
 184 {
 185   mlib_u32 *sa;              /* aligned pointer to source data */
 186   mlib_u8  *sp;              /* pointer to source data */
 187   mlib_u32 s0;               /* source data */
 188   mlib_u16 *dl;              /* pointer to start of destination */
 189   mlib_d64 *dp;              /* aligned pointer to destination */
 190   mlib_d64 acc0, acc1, acc2; /* destination data */
 191   mlib_s32 i;                /* loop variable */
 192   mlib_u16 *dend;            /* pointer to end of destination */
 193   mlib_s32 emask;            /* edge mask */
 194   mlib_s32 off;
 195   mlib_u32 s00, s01, s02, s03;
 196 
 197   sa   = (mlib_u32*)src;
 198   sp = (void *)src;
 199   dl = dst;
 200   dend = dl + (xsize &lt;&lt; 1) - 1;
 201   dp   = (mlib_d64 *) ((mlib_addr) dl &amp; (~7));
 202   off  = (mlib_addr) dp - (mlib_addr) dl;
 203   vis_alignaddr(dp, off);
 204 
 205   emask = vis_edge16(dl, dend);
 206   acc0 = vis_freg_pair(table[sp[0]], table[sp[1]]);
 207   vis_pst_16(vis_faligndata(acc0, acc0), dp++, emask);
 208   sp += 2;
 209 
 210   xsize -= 2;
 211 
 212   if (xsize &gt;= 2) {
 213     acc1 = vis_freg_pair(table[sp[0]], table[sp[1]]);
 214     *dp++ = vis_faligndata(acc0, acc1);
 215     acc0 = acc1;
 216     sp += 2; xsize -= 2;
 217   }
 218 
 219   sa++;
 220 
 221   i = 0;
 222 
 223   if (xsize &gt;= 4) {
 224 
 225     s0 = *sa++;
 226     s00 = (s0 &gt;&gt; 22) &amp; 0x3FC;
 227     s01 = (s0 &gt;&gt; 14) &amp; 0x3FC;
 228 
 229 #pragma pipeloop(0)
 230     for(i = 0; i &lt;= xsize - 8; i+=4, dp += 2) {
 231       s02 = (s0 &gt;&gt; 6) &amp; 0x3FC;
 232       s03 = (s0 &lt;&lt; 2) &amp; 0x3FC;
 233       acc1 = vis_freg_pair(*(mlib_f32*)((mlib_u8*)table + s00),
 234                            *(mlib_f32*)((mlib_u8*)table + s01));
 235       acc2 = vis_freg_pair(*(mlib_f32*)((mlib_u8*)table + s02),
 236                            *(mlib_f32*)((mlib_u8*)table + s03));
 237       s0 = *sa++;
 238       s00 = (s0 &gt;&gt; 22) &amp; 0x3FC;
 239       s01 = (s0 &gt;&gt; 14) &amp; 0x3FC;
 240       dp[0] = vis_faligndata(acc0, acc1);
 241       dp[1] = vis_faligndata(acc1, acc2);
 242       acc0 = acc2;
 243     }
 244 
 245     s02 = (s0 &gt;&gt; 6) &amp; 0x3FC;
 246     s03 = (s0 &lt;&lt; 2) &amp; 0x3FC;
 247     acc1 = vis_freg_pair(*(mlib_f32*)((mlib_u8*)table + s00),
 248                          *(mlib_f32*)((mlib_u8*)table + s01));
 249     acc2 = vis_freg_pair(*(mlib_f32*)((mlib_u8*)table + s02),
 250                          *(mlib_f32*)((mlib_u8*)table + s03));
 251     dp[0] = vis_faligndata(acc0, acc1);
 252     dp[1] = vis_faligndata(acc1, acc2);
 253     acc0 = acc2;
 254     sp = (mlib_u8*)sa;
 255     dp += 2;
 256     i += 4;
 257   }
 258 
 259   if ( i &lt;= xsize - 2) {
 260     acc1 = vis_freg_pair(table[sp[0]], table[sp[1]]);
 261     *dp++ = vis_faligndata(acc0, acc1);
 262     acc0 = acc1;
 263     i+=2; sp += 2;
 264   }
 265 
 266   if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 267     emask = vis_edge16(dp, dend);
 268     acc1 = vis_freg_pair(table[sp[0]], table[sp[1]]);
 269     vis_pst_16(vis_faligndata(acc0, acc1), dp++, emask);
 270   }
 271 
 272   if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 273     emask = vis_edge16(dp, dend);
 274     vis_pst_16(vis_faligndata(acc1, acc1), dp++, emask);
 275   }
 276 }
 277 
 278 /***************************************************************/
 279 void mlib_v_ImageLookUpSI_U8_U16_2_DstA8D1_SMALL(const mlib_u8  *src,
 280                                                  mlib_u16       *dst,
 281                                                  mlib_s32       xsize,
 282                                                  const mlib_u16 **table)
 283 {
 284   mlib_u8  *sp;              /* pointer to source data */
 285   mlib_u32 s0, s1;           /* source data */
 286   mlib_u16 *dl;              /* pointer to start of destination */
 287   mlib_d64 *dp;              /* aligned pointer to destination */
 288   mlib_d64 t0, t1, t2;       /* destination data */
 289   mlib_d64 t3, acc;          /* destination data */
 290   mlib_s32 i;                /* loop variable */
 291   const mlib_u16 *tab0 = table[0];
 292   const mlib_u16 *tab1 = table[1];
 293 
 294   sp   = (void *)src;
 295   dl   = dst;
 296   dp   = (mlib_d64 *) dl;
 297 
 298   vis_alignaddr((void *) 0, 6);
 299 
 300   if (xsize &gt;= 2) {
 301 
 302     s0 = (sp[0] &lt;&lt; 1);
 303     s1 = (sp[1] &lt;&lt; 1);
 304     sp += 2;
 305 
 306 #pragma pipeloop(0)
 307     for(i = 0; i &lt;= xsize - 4; i+=2, sp+=2) {
 308       t3 = VIS_LD_U16_I(tab1, s1);
 309       t2 = VIS_LD_U16_I(tab0, s1);
 310       t1 = VIS_LD_U16_I(tab1, s0);
 311       t0 = VIS_LD_U16_I(tab0, s0);
 312       acc = vis_faligndata(t3, acc);
 313       acc = vis_faligndata(t2, acc);
 314       acc = vis_faligndata(t1, acc);
 315       acc = vis_faligndata(t0, acc);
 316       s0 = (sp[0] &lt;&lt; 1);
 317       s1 = (sp[1] &lt;&lt; 1);
 318       *dp++ = acc;
 319     }
 320 
 321     t3 = VIS_LD_U16_I(tab1, s1);
 322     t2 = VIS_LD_U16_I(tab0, s1);
 323     t1 = VIS_LD_U16_I(tab1, s0);
 324     t0 = VIS_LD_U16_I(tab0, s0);
 325     acc = vis_faligndata(t3, acc);
 326     acc = vis_faligndata(t2, acc);
 327     acc = vis_faligndata(t1, acc);
 328     acc = vis_faligndata(t0, acc);
 329     *dp++ = acc;
 330   }
 331 
 332   if ((xsize &amp; 1) != 0) {
 333     s0 = (sp[0] &lt;&lt; 1);
 334     t1 = VIS_LD_U16_I(tab1, s0);
 335     t0 = VIS_LD_U16_I(tab0, s0);
 336     acc = vis_faligndata(t1, acc);
 337     acc = vis_faligndata(t0, acc);
 338     *(mlib_f32*)dp = vis_read_hi(acc);
 339   }
 340 }
 341 
 342 /***************************************************************/
 343 void mlib_v_ImageLookUpSI_U8_U16_2_D1_SMALL(const mlib_u8  *src,
 344                                             mlib_u16       *dst,
 345                                             mlib_s32       xsize,
 346                                             const mlib_u16 **table)
 347 {
 348   mlib_u8  *sp;                /* pointer to source data */
 349   mlib_u32 s0, s1, s2;         /* source data */
 350   mlib_u16 *dl;                /* pointer to start of destination */
 351   mlib_d64 *dp;                /* aligned pointer to destination */
 352   mlib_d64 t0, t1, t2;         /* destination data */
 353   mlib_d64 t3, acc;            /* destination data */
 354   mlib_s32 i;                  /* loop variable */
 355   const mlib_u16 *tab0 = table[0];
 356   const mlib_u16 *tab1 = table[1];
 357 
 358   sp   = (void *)src;
 359   dl   = dst;
 360 
 361   vis_alignaddr((void *) 0, 6);
 362 
 363   s0 = *sp++;
 364   *dl++ = tab0[s0];
 365   dp   = (mlib_d64 *) dl;
 366   xsize--; s0 &lt;&lt;= 1;
 367 
 368   if (xsize &gt;= 2) {
 369 
 370     s1 = (sp[0] &lt;&lt; 1);
 371     s2 = (sp[1] &lt;&lt; 1);
 372     sp += 2;
 373 
 374 #pragma pipeloop(0)
 375     for(i = 0; i &lt;= xsize - 4; i+=2, sp+=2) {
 376       t3 = VIS_LD_U16_I(tab0, s2);
 377       t2 = VIS_LD_U16_I(tab1, s1);
 378       t1 = VIS_LD_U16_I(tab0, s1);
 379       t0 = VIS_LD_U16_I(tab1, s0);
 380       acc = vis_faligndata(t3, acc);
 381       acc = vis_faligndata(t2, acc);
 382       acc = vis_faligndata(t1, acc);
 383       acc = vis_faligndata(t0, acc);
 384       s0 = s2;
 385       s1 = (sp[0] &lt;&lt; 1);
 386       s2 = (sp[1] &lt;&lt; 1);
 387       *dp++ = acc;
 388     }
 389 
 390     t3 = VIS_LD_U16_I(tab0, s2);
 391     t2 = VIS_LD_U16_I(tab1, s1);
 392     t1 = VIS_LD_U16_I(tab0, s1);
 393     t0 = VIS_LD_U16_I(tab1, s0);
 394     acc = vis_faligndata(t3, acc);
 395     acc = vis_faligndata(t2, acc);
 396     acc = vis_faligndata(t1, acc);
 397     acc = vis_faligndata(t0, acc);
 398     s0 = s2;
 399     *dp++ = acc;
 400   }
 401 
 402   dl = (mlib_u16*)dp;
 403 
 404   if ((xsize &amp; 1) != 0) {
 405     s1 = (sp[0] &lt;&lt; 1);
 406     t1 = VIS_LD_U16_I(tab0, s1);
 407     t0 = VIS_LD_U16_I(tab1, s0);
 408     acc = vis_faligndata(t1, acc);
 409     acc = vis_faligndata(t0, acc);
 410     *(mlib_f32*)dp = vis_read_hi(acc);
 411     s0 = s1; dl += 2;
 412   }
 413 
 414   s0 &gt;&gt;= 1;
 415   *dl = tab1[s0];
 416 }
 417 
 418 /***************************************************************/
 419 void mlib_v_ImageLookUpSI_U8_U16_2(const mlib_u8  *src,
 420                                    mlib_s32       slb,
 421                                    mlib_u16       *dst,
 422                                    mlib_s32       dlb,
 423                                    mlib_s32       xsize,
 424                                    mlib_s32       ysize,
 425                                    const mlib_u16 **table)
 426 {
 427   if ((xsize * ysize) &lt; 550) {
 428     mlib_u8  *sl;
 429     mlib_u16 *dl;
 430     mlib_s32 j;
 431     const mlib_u16 *tab0 = table[0];
 432     const mlib_u16 *tab1 = table[1];
 433 
 434     sl = (void *)src;
 435     dl = dst;
 436 
 437     /* row loop */
 438     for (j = 0; j &lt; ysize; j ++) {
 439       mlib_u8  *sp = sl;
 440       mlib_u16 *dp = dl;
 441       mlib_s32 off, s0, size = xsize;
 442 
 443       off = ((8 - ((mlib_addr)dp &amp; 7)) &amp; 7);
 444 
 445       if ((off &gt;= 4) &amp;&amp; (size &gt; 0)) {
 446         s0 = *sp++;
 447         *dp++ = tab0[s0];
 448         *dp++ = tab1[s0];
 449         size--;
 450       }
 451 
 452       if (size &gt; 0) {
 453 
 454         if (((mlib_addr)dp &amp; 7) == 0) {
 455           mlib_v_ImageLookUpSI_U8_U16_2_DstA8D1_SMALL(sp, dp, size, table);
 456         } else {
 457           mlib_v_ImageLookUpSI_U8_U16_2_D1_SMALL(sp, dp, size, table);
 458         }
 459       }
 460 
 461       sl = (mlib_u8 *) ((mlib_u8 *) sl + slb);
 462       dl = (mlib_u16 *) ((mlib_u8 *) dl + dlb);
 463     }
 464 
 465   } else {
 466     mlib_u8  *sl;
 467     mlib_u16 *dl;
 468     mlib_u32 tab[256];
 469     mlib_u16 *tab0 = (mlib_u16*)table[0];
 470     mlib_u16 *tab1 = (mlib_u16*)table[1];
 471     mlib_s32 i, j;
 472     mlib_u32 s0, s1, s2;
 473 
 474     s0 = tab0[0];
 475     s1 = tab1[0];
 476     for (i = 1; i &lt; 256; i++) {
 477       s2 = (s0 &lt;&lt; 16) + s1;
 478       s0 = tab0[i];
 479       s1 = tab1[i];
 480       tab[i-1] = s2;
 481     }
 482 
 483     s2 = (s0 &lt;&lt; 16) + s1;
 484     tab[255] = s2;
 485 
 486     sl = (void *)src;
 487     dl = dst;
 488 
 489     /* row loop */
 490     for (j = 0; j &lt; ysize; j ++) {
 491       mlib_u8  *sp = sl;
 492       mlib_u16 *dp = dl;
 493       mlib_s32 off, s0, size = xsize;
 494 
 495       if (((mlib_addr)dp &amp; 3) == 0) {
 496 
 497         off = (4 - (mlib_addr)sp &amp; 3) &amp; 3;
 498 
 499         off = (off &lt; size) ? off : size;
 500 
 501 #pragma pipeloop(0)
 502         for (i = 0; i &lt; off; i++, sp++) {
 503           *(mlib_u32*)dp = tab[(*sp)];
 504           dp += 2;
 505         }
 506 
 507         size -= off;
 508 
 509         if (size &gt; 0) {
 510           mlib_v_ImageLookUpSI_U8_U16_2_SrcOff0_D1(sp, dp, size, (mlib_f32*)tab);
 511         }
 512 
 513       } else {
 514 
 515         off = ((4 - ((mlib_addr)sp &amp; 3)) &amp; 3);
 516         off = (off &lt; size) ? off : size;
 517 
 518         for (i = 0; i &lt; off; i++) {
 519           s0 = tab[(*sp)];
 520           *dp++ = (s0 &gt;&gt; 16);
 521           *dp++ = (s0 &amp; 0xFFFF);
 522           size--; sp++;
 523         }
 524 
 525         if (size &gt; 0) {
 526           mlib_v_ImageLookUpSI_U8_U16_2_DstNonAl_D1(sp, dp, size, (mlib_f32*)tab);
 527         }
 528       }
 529 
 530       sl = (mlib_u8 *) ((mlib_u8 *) sl + slb);
 531       dl = (mlib_u16 *) ((mlib_u8 *) dl + dlb);
 532     }
 533   }
 534 }
 535 
 536 /***************************************************************/
 537 void mlib_v_ImageLookUpSI_U8_U16_3_SrcOff0_D1(const mlib_u8  *src,
 538                                               mlib_u16       *dst,
 539                                               mlib_s32       xsize,
 540                                               const mlib_d64 *table)
 541 {
 542   mlib_u8  *sp;              /* pointer to source data */
 543   mlib_u32 *sa;              /* aligned pointer to source data */
 544   mlib_u32 s0;               /* source data */
 545   mlib_u16 *dl;              /* pointer to start of destination */
 546   mlib_d64 *dp;              /* aligned pointer to destination */
 547   mlib_d64 t0, t1, t2, t3;   /* destination data */
 548   mlib_d64 acc0, acc1, acc2; /* destination data */
 549   mlib_s32 i;                /* loop variable */
 550   mlib_u16 *ptr;
 551 
 552   dl  = dst;
 553   sp  = (void *)src;
 554   dp  = (mlib_d64 *) dl;
 555   sa  = (mlib_u32*)sp;
 556 
 557   vis_alignaddr((void *) 0, 6);
 558 
 559   i = 0;
 560 
 561   if (xsize &gt;= 4) {
 562 
 563     s0 = *sa++;
 564 
 565 #pragma pipeloop(0)
 566     for(i = 0; i &lt;= xsize - 8; i+=4, dp+=3) {
 567       t0 = *(mlib_d64*)((mlib_u8*)table + ((s0 &gt;&gt; 21) &amp; 0x7F8 ));
 568       t1 = *(mlib_d64*)((mlib_u8*)table + ((s0 &gt;&gt; 13) &amp; 0x7F8 ));
 569       t2 = *(mlib_d64*)((mlib_u8*)table + ((s0 &gt;&gt; 5) &amp; 0x7F8 ));
 570       t3 = *(mlib_d64*)((mlib_u8*)table + ((s0 &lt;&lt; 3) &amp; 0x7F8 ));
 571       acc0 = vis_faligndata(t0, t0);
 572       acc1 = vis_faligndata(acc0, acc0);
 573       acc2 = vis_faligndata(acc0, t1);
 574       acc0 = vis_faligndata(acc1, acc1);
 575       acc1 = vis_faligndata(acc1, acc2);
 576       acc2 = vis_faligndata(acc2, t2);
 577       acc0 = vis_faligndata(acc0, acc1);
 578       acc1 = vis_faligndata(acc1, acc2);
 579       acc2 = vis_faligndata(acc2, t3);
 580       s0 = *sa++;
 581       dp[0] = acc0;
 582       dp[1] = acc1;
 583       dp[2] = acc2;
 584     }
 585 
 586     t0 = *(mlib_d64*)((mlib_u8*)table + ((s0 &gt;&gt; 21) &amp; 0x7F8 ));
 587     t1 = *(mlib_d64*)((mlib_u8*)table + ((s0 &gt;&gt; 13) &amp; 0x7F8 ));
 588     t2 = *(mlib_d64*)((mlib_u8*)table + ((s0 &gt;&gt; 5) &amp; 0x7F8 ));
 589     t3 = *(mlib_d64*)((mlib_u8*)table + ((s0 &lt;&lt; 3) &amp; 0x7F8 ));
 590     acc0 = vis_faligndata(t0, t0);
 591     acc1 = vis_faligndata(acc0, acc0);
 592     acc2 = vis_faligndata(acc0, t1);
 593     acc0 = vis_faligndata(acc1, acc1);
 594     acc1 = vis_faligndata(acc1, acc2);
 595     acc2 = vis_faligndata(acc2, t2);
 596     acc0 = vis_faligndata(acc0, acc1);
 597     acc1 = vis_faligndata(acc1, acc2);
 598     acc2 = vis_faligndata(acc2, t3);
 599     dp[0] = acc0;
 600     dp[1] = acc1;
 601     dp[2] = acc2;
 602     i += 4; dp += 3;
 603   }
 604 
 605   dl = (mlib_u16*)dp;
 606 
 607 #pragma pipeloop(0)
 608   for (; i &lt; xsize; i++) {
 609     ptr = (mlib_u16*)(table + src[i]);
 610     dl[0] = ptr[0];
 611     dl[1] = ptr[1];
 612     dl[2] = ptr[2];
 613     dl += 3;
 614   }
 615 }
 616 
 617 /***************************************************************/
 618 void mlib_v_ImageLookUpSI_U8_U16_3_SrcOff1_D1(const mlib_u8  *src,
 619                                               mlib_u16       *dst,
 620                                               mlib_s32       xsize,
 621                                               const mlib_d64 *table)
 622 {
 623   mlib_u8  *sp;               /* pointer to source data */
 624   mlib_u32 *sa;               /* aligned pointer to source data */
 625   mlib_u32 s0, s1;            /* source data */
 626   mlib_u16 *dl;               /* pointer to start of destination */
 627   mlib_d64 *dp;               /* aligned pointer to destination */
 628   mlib_d64 t0, t1, t2, t3;    /* destination data */
 629   mlib_d64 acc0, acc1, acc2;  /* destination data */
 630   mlib_s32 i;                 /* loop variable */
 631   mlib_u16 *ptr;
 632 
 633   dl  = dst;
 634   sp  = (void *)src;
 635   dp  = (mlib_d64 *) dl;
 636   sa  = (mlib_u32*)(sp - 1);
 637 
 638   i = 0;
 639   s0 = *sa++;
 640 
 641   vis_alignaddr((void *) 0, 6);
 642 
 643   if (xsize &gt;= 4) {
 644 
 645     s1 = *sa++;
 646 
 647 #pragma pipeloop(0)
 648     for(i = 0; i &lt;= xsize - 8; i+=4, dp+=3) {
 649       t0 = *(mlib_d64*)((mlib_u8*)table + ((s0 &gt;&gt; 13) &amp; 0x7F8 ));
 650       t1 = *(mlib_d64*)((mlib_u8*)table + ((s0 &gt;&gt; 5) &amp; 0x7F8 ));
 651       t2 = *(mlib_d64*)((mlib_u8*)table + ((s0 &lt;&lt; 3) &amp; 0x7F8 ));
 652       t3 = *(mlib_d64*)((mlib_u8*)table + ((s1 &gt;&gt; 21) &amp; 0x7F8 ));
 653       acc0 = vis_faligndata(t0, t0);
 654       acc1 = vis_faligndata(acc0, acc0);
 655       acc2 = vis_faligndata(acc0, t1);
 656       acc0 = vis_faligndata(acc1, acc1);
 657       acc1 = vis_faligndata(acc1, acc2);
 658       acc2 = vis_faligndata(acc2, t2);
 659       acc0 = vis_faligndata(acc0, acc1);
 660       acc1 = vis_faligndata(acc1, acc2);
 661       acc2 = vis_faligndata(acc2, t3);
 662       s0 = s1;
 663       s1 = *sa++;
 664       dp[0] = acc0;
 665       dp[1] = acc1;
 666       dp[2] = acc2;
 667     }
 668 
 669     t0 = *(mlib_d64*)((mlib_u8*)table + ((s0 &gt;&gt; 13) &amp; 0x7F8 ));
 670     t1 = *(mlib_d64*)((mlib_u8*)table + ((s0 &gt;&gt; 5) &amp; 0x7F8 ));
 671     t2 = *(mlib_d64*)((mlib_u8*)table + ((s0 &lt;&lt; 3) &amp; 0x7F8 ));
 672     t3 = *(mlib_d64*)((mlib_u8*)table + ((s1 &gt;&gt; 21) &amp; 0x7F8 ));
 673     acc0 = vis_faligndata(t0, t0);
 674     acc1 = vis_faligndata(acc0, acc0);
 675     acc2 = vis_faligndata(acc0, t1);
 676     acc0 = vis_faligndata(acc1, acc1);
 677     acc1 = vis_faligndata(acc1, acc2);
 678     acc2 = vis_faligndata(acc2, t2);
 679     acc0 = vis_faligndata(acc0, acc1);
 680     acc1 = vis_faligndata(acc1, acc2);
 681     acc2 = vis_faligndata(acc2, t3);
 682     dp[0] = acc0;
 683     dp[1] = acc1;
 684     dp[2] = acc2;
 685     i += 4; dp += 3;
 686   }
 687 
 688   dl = (mlib_u16*)dp;
 689 
 690 #pragma pipeloop(0)
 691   for (; i &lt; xsize; i++) {
 692     ptr = (mlib_u16*)(table + src[i]);
 693     dl[0] = ptr[0];
 694     dl[1] = ptr[1];
 695     dl[2] = ptr[2];
 696     dl += 3;
 697   }
 698 }
 699 
 700 /***************************************************************/
 701 void mlib_v_ImageLookUpSI_U8_U16_3_SrcOff2_D1(const mlib_u8  *src,
 702                                               mlib_u16       *dst,
 703                                               mlib_s32       xsize,
 704                                               const mlib_d64 *table)
 705 {
 706   mlib_u8  *sp;               /* pointer to source data */
 707   mlib_u32 *sa;               /* aligned pointer to source data */
 708   mlib_u32 s0, s1;            /* source data */
 709   mlib_u16 *dl;               /* pointer to start of destination */
 710   mlib_d64 *dp;               /* aligned pointer to destination */
 711   mlib_d64 t0, t1, t2, t3;    /* destination data */
 712   mlib_d64 acc0, acc1, acc2;  /* destination data */
 713   mlib_s32 i;                 /* loop variable */
 714   mlib_u16 *ptr;
 715 
 716   dl  = dst;
 717   sp  = (void *)src;
 718   dp  = (mlib_d64 *) dl;
 719   sa  = (mlib_u32*)(sp - 2);
 720 
 721   i = 0;
 722   s0 = *sa++;
 723 
 724   vis_alignaddr((void *) 0, 6);
 725 
 726   if (xsize &gt;= 4) {
 727 
 728     s1 = *sa++;
 729 
 730 #pragma pipeloop(0)
 731     for(i = 0; i &lt;= xsize - 8; i+=4, dp+=3) {
 732       t0 = *(mlib_d64*)((mlib_u8*)table + ((s0 &gt;&gt; 5) &amp; 0x7F8 ));
 733       t1 = *(mlib_d64*)((mlib_u8*)table + ((s0 &lt;&lt; 3) &amp; 0x7F8 ));
 734       t2 = *(mlib_d64*)((mlib_u8*)table + ((s1 &gt;&gt; 21) &amp; 0x7F8 ));
 735       t3 = *(mlib_d64*)((mlib_u8*)table + ((s1 &gt;&gt; 13) &amp; 0x7F8 ));
 736       acc0 = vis_faligndata(t0, t0);
 737       acc1 = vis_faligndata(acc0, acc0);
 738       acc2 = vis_faligndata(acc0, t1);
 739       acc0 = vis_faligndata(acc1, acc1);
 740       acc1 = vis_faligndata(acc1, acc2);
 741       acc2 = vis_faligndata(acc2, t2);
 742       acc0 = vis_faligndata(acc0, acc1);
 743       acc1 = vis_faligndata(acc1, acc2);
 744       acc2 = vis_faligndata(acc2, t3);
 745       s0 = s1;
 746       s1 = *sa++;
 747       dp[0] = acc0;
 748       dp[1] = acc1;
 749       dp[2] = acc2;
 750     }
 751 
 752     t0 = *(mlib_d64*)((mlib_u8*)table + ((s0 &gt;&gt; 5) &amp; 0x7F8 ));
 753     t1 = *(mlib_d64*)((mlib_u8*)table + ((s0 &lt;&lt; 3) &amp; 0x7F8 ));
 754     t2 = *(mlib_d64*)((mlib_u8*)table + ((s1 &gt;&gt; 21) &amp; 0x7F8 ));
 755     t3 = *(mlib_d64*)((mlib_u8*)table + ((s1 &gt;&gt; 13) &amp; 0x7F8 ));
 756     acc0 = vis_faligndata(t0, t0);
 757     acc1 = vis_faligndata(acc0, acc0);
 758     acc2 = vis_faligndata(acc0, t1);
 759     acc0 = vis_faligndata(acc1, acc1);
 760     acc1 = vis_faligndata(acc1, acc2);
 761     acc2 = vis_faligndata(acc2, t2);
 762     acc0 = vis_faligndata(acc0, acc1);
 763     acc1 = vis_faligndata(acc1, acc2);
 764     acc2 = vis_faligndata(acc2, t3);
 765     dp[0] = acc0;
 766     dp[1] = acc1;
 767     dp[2] = acc2;
 768     i += 4; dp += 3;
 769   }
 770 
 771   dl = (mlib_u16*)dp;
 772 
 773 #pragma pipeloop(0)
 774   for (; i &lt; xsize; i++) {
 775     ptr = (mlib_u16*)(table + src[i]);
 776     dl[0] = ptr[0];
 777     dl[1] = ptr[1];
 778     dl[2] = ptr[2];
 779     dl += 3;
 780   }
 781 }
 782 
 783 /***************************************************************/
 784 void mlib_v_ImageLookUpSI_U8_U16_3_SrcOff3_D1(const mlib_u8  *src,
 785                                               mlib_u16       *dst,
 786                                               mlib_s32       xsize,
 787                                               const mlib_d64 *table)
 788 {
 789   mlib_u8  *sp;               /* pointer to source data */
 790   mlib_u32 *sa;               /* aligned pointer to source data */
 791   mlib_u32 s0, s1;            /* source data */
 792   mlib_u16 *dl;               /* pointer to start of destination */
 793   mlib_d64 *dp;               /* aligned pointer to destination */
 794   mlib_d64 t0, t1, t2, t3;    /* destination data */
 795   mlib_d64 acc0, acc1, acc2;  /* destination data */
 796   mlib_s32 i;                 /* loop variable */
 797   mlib_u16 *ptr;
 798 
 799   dl  = dst;
 800   sp  = (void *)src;
 801   dp  = (mlib_d64 *) dl;
 802   sa  = (mlib_u32*)(sp - 3);
 803 
 804   i = 0;
 805   s0 = *sa++;
 806 
 807   vis_alignaddr((void *) 0, 6);
 808 
 809   if (xsize &gt;= 4) {
 810 
 811     s1 = *sa++;
 812 
 813 #pragma pipeloop(0)
 814     for(i = 0; i &lt;= xsize - 8; i+=4, dp+=3) {
 815       t0 = *(mlib_d64*)((mlib_u8*)table + ((s0 &lt;&lt; 3) &amp; 0x7F8 ));
 816       t1 = *(mlib_d64*)((mlib_u8*)table + ((s1 &gt;&gt; 21) &amp; 0x7F8 ));
 817       t2 = *(mlib_d64*)((mlib_u8*)table + ((s1 &gt;&gt; 13) &amp; 0x7F8 ));
 818       t3 = *(mlib_d64*)((mlib_u8*)table + ((s1 &gt;&gt; 5) &amp; 0x7F8 ));
 819       acc0 = vis_faligndata(t0, t0);
 820       acc1 = vis_faligndata(acc0, acc0);
 821       acc2 = vis_faligndata(acc0, t1);
 822       acc0 = vis_faligndata(acc1, acc1);
 823       acc1 = vis_faligndata(acc1, acc2);
 824       acc2 = vis_faligndata(acc2, t2);
 825       acc0 = vis_faligndata(acc0, acc1);
 826       acc1 = vis_faligndata(acc1, acc2);
 827       acc2 = vis_faligndata(acc2, t3);
 828       s0 = s1;
 829       s1 = *sa++;
 830       dp[0] = acc0;
 831       dp[1] = acc1;
 832       dp[2] = acc2;
 833     }
 834 
 835     t0 = *(mlib_d64*)((mlib_u8*)table + ((s0 &lt;&lt; 3) &amp; 0x7F8 ));
 836     t1 = *(mlib_d64*)((mlib_u8*)table + ((s1 &gt;&gt; 21) &amp; 0x7F8 ));
 837     t2 = *(mlib_d64*)((mlib_u8*)table + ((s1 &gt;&gt; 13) &amp; 0x7F8 ));
 838     t3 = *(mlib_d64*)((mlib_u8*)table + ((s1 &gt;&gt; 5) &amp; 0x7F8 ));
 839     acc0 = vis_faligndata(t0, t0);
 840     acc1 = vis_faligndata(acc0, acc0);
 841     acc2 = vis_faligndata(acc0, t1);
 842     acc0 = vis_faligndata(acc1, acc1);
 843     acc1 = vis_faligndata(acc1, acc2);
 844     acc2 = vis_faligndata(acc2, t2);
 845     acc0 = vis_faligndata(acc0, acc1);
 846     acc1 = vis_faligndata(acc1, acc2);
 847     acc2 = vis_faligndata(acc2, t3);
 848     dp[0] = acc0;
 849     dp[1] = acc1;
 850     dp[2] = acc2;
 851     i += 4; dp += 3;
 852   }
 853 
 854   dl = (mlib_u16*)dp;
 855 
 856 #pragma pipeloop(0)
 857   for (; i &lt; xsize; i++) {
 858     ptr = (mlib_u16*)(table + src[i]);
 859     dl[0] = ptr[0];
 860     dl[1] = ptr[1];
 861     dl[2] = ptr[2];
 862     dl += 3;
 863   }
 864 }
 865 
 866 /***************************************************************/
 867 void mlib_v_ImageLookUpSI_U8_U16_3_D1_SMALL(const mlib_u8  *src,
 868                                             mlib_u16       *dst,
 869                                             mlib_s32       xsize,
 870                                             const mlib_u16 **table)
 871 {
 872   mlib_u8  *sp;              /* pointer to source data */
 873   mlib_u16 *dl;              /* pointer to start of destination */
 874   mlib_d64 *dp;              /* aligned pointer to destination */
 875   mlib_d64 t0, t1, t2, t3;   /* destination data */
 876   mlib_d64 acc0, acc1, acc2; /* destination data */
 877   mlib_s32 i;                /* loop variable */
 878   const mlib_u16 *tab0 = table[0];
 879   const mlib_u16 *tab1 = table[1];
 880   const mlib_u16 *tab2 = table[2];
 881   mlib_u32 s00, s01, s02, s03;
 882 
 883   sp   = (void *)src;
 884   dl   = dst;
 885   dp   = (mlib_d64 *) dl;
 886 
 887   vis_alignaddr((void *) 0, 6);
 888 
 889   i = 0;
 890 
 891   if (xsize &gt;= 4) {
 892 
 893     s00 = (sp[0] &lt;&lt; 1);
 894     s01 = (sp[1] &lt;&lt; 1);
 895     s02 = (sp[2] &lt;&lt; 1);
 896     s03 = (sp[3] &lt;&lt; 1);
 897     sp += 4;
 898 
 899 #pragma pipeloop(0)
 900     for(i = 0; i &lt;= xsize - 8; i+=4, sp+=4) {
 901       t3 = VIS_LD_U16_I(tab0, s01);
 902       t2 = VIS_LD_U16_I(tab2, s00);
 903       t1 = VIS_LD_U16_I(tab1, s00);
 904       t0 = VIS_LD_U16_I(tab0, s00);
 905       acc0 = vis_faligndata(t3, acc0);
 906       acc0 = vis_faligndata(t2, acc0);
 907       acc0 = vis_faligndata(t1, acc0);
 908       acc0 = vis_faligndata(t0, acc0);
 909       t3 = VIS_LD_U16_I(tab1, s02);
 910       t2 = VIS_LD_U16_I(tab0, s02);
 911       t1 = VIS_LD_U16_I(tab2, s01);
 912       t0 = VIS_LD_U16_I(tab1, s01);
 913       acc1 = vis_faligndata(t3, acc1);
 914       acc1 = vis_faligndata(t2, acc1);
 915       acc1 = vis_faligndata(t1, acc1);
 916       acc1 = vis_faligndata(t0, acc1);
 917       t3 = VIS_LD_U16_I(tab2, s03);
 918       t2 = VIS_LD_U16_I(tab1, s03);
 919       t1 = VIS_LD_U16_I(tab0, s03);
 920       t0 = VIS_LD_U16_I(tab2, s02);
 921       acc2 = vis_faligndata(t3, acc2);
 922       acc2 = vis_faligndata(t2, acc2);
 923       acc2 = vis_faligndata(t1, acc2);
 924       acc2 = vis_faligndata(t0, acc2);
 925       s00 = (sp[0] &lt;&lt; 1);
 926       s01 = (sp[1] &lt;&lt; 1);
 927       s02 = (sp[2] &lt;&lt; 1);
 928       s03 = (sp[3] &lt;&lt; 1);
 929       *dp++ = acc0;
 930       *dp++ = acc1;
 931       *dp++ = acc2;
 932     }
 933 
 934     t3 = VIS_LD_U16_I(tab0, s01);
 935     t2 = VIS_LD_U16_I(tab2, s00);
 936     t1 = VIS_LD_U16_I(tab1, s00);
 937     t0 = VIS_LD_U16_I(tab0, s00);
 938     acc0 = vis_faligndata(t3, acc0);
 939     acc0 = vis_faligndata(t2, acc0);
 940     acc0 = vis_faligndata(t1, acc0);
 941     acc0 = vis_faligndata(t0, acc0);
 942     t3 = VIS_LD_U16_I(tab1, s02);
 943     t2 = VIS_LD_U16_I(tab0, s02);
 944     t1 = VIS_LD_U16_I(tab2, s01);
 945     t0 = VIS_LD_U16_I(tab1, s01);
 946     acc1 = vis_faligndata(t3, acc1);
 947     acc1 = vis_faligndata(t2, acc1);
 948     acc1 = vis_faligndata(t1, acc1);
 949     acc1 = vis_faligndata(t0, acc1);
 950     t3 = VIS_LD_U16_I(tab2, s03);
 951     t2 = VIS_LD_U16_I(tab1, s03);
 952     t1 = VIS_LD_U16_I(tab0, s03);
 953     t0 = VIS_LD_U16_I(tab2, s02);
 954     acc2 = vis_faligndata(t3, acc2);
 955     acc2 = vis_faligndata(t2, acc2);
 956     acc2 = vis_faligndata(t1, acc2);
 957     acc2 = vis_faligndata(t0, acc2);
 958     *dp++ = acc0;
 959     *dp++ = acc1;
 960     *dp++ = acc2;
 961     i += 4;
 962   }
 963 
 964   dl = (mlib_u16*)dp;
 965 
 966 #pragma pipeloop(0)
 967   for (; i &lt; xsize; i++) {
 968     s00 = sp[0];
 969     dl[0] = tab0[s00];
 970     dl[1] = tab1[s00];
 971     dl[2] = tab2[s00];
 972     dl += 3; sp ++;
 973   }
 974 }
 975 
 976 /***************************************************************/
 977 void mlib_v_ImageLookUpSI_U8_U16_3(const mlib_u8  *src,
 978                                    mlib_s32       slb,
 979                                    mlib_u16       *dst,
 980                                    mlib_s32       dlb,
 981                                    mlib_s32       xsize,
 982                                    mlib_s32       ysize,
 983                                    const mlib_u16 **table)
 984 {
 985   if ((xsize * ysize) &lt; 550) {
 986     mlib_u8  *sl;
 987     mlib_u16 *dl;
 988     mlib_s32 i, j;
 989     const mlib_u16 *tab0 = table[0];
 990     const mlib_u16 *tab1 = table[1];
 991     const mlib_u16 *tab2 = table[2];
 992 
 993     sl = (void *)src;
 994     dl = dst;
 995 
 996     /* row loop */
 997     for (j = 0; j &lt; ysize; j ++) {
 998       mlib_u8 *sp = sl;
 999       mlib_u16*dp = dl;
1000       mlib_s32 off, s0, size = xsize;
1001 
1002       off = ((mlib_addr)dp &amp; 7) &gt;&gt; 1;
1003       off = (off &lt; size) ? off : size;
1004 
1005       for (i = 0; i &lt; off; i++) {
1006         s0 = *sp++;
1007         *dp++ = tab0[s0];
1008         *dp++ = tab1[s0];
1009         *dp++ = tab2[s0];
1010         size--;
1011       }
1012 
1013       if (size &gt; 0) {
1014         mlib_v_ImageLookUpSI_U8_U16_3_D1_SMALL(sp, dp, size, table);
1015       }
1016 
1017       sl = (mlib_u8 *) ((mlib_u8 *) sl + slb);
1018       dl = (mlib_u16 *) ((mlib_u8 *) dl + dlb);
1019     }
1020 
1021   } else {
1022     mlib_u8  *sl;
1023     mlib_u16 *dl;
1024     mlib_u32 tab[512];
1025     mlib_u16 *tab0 = (mlib_u16*)table[0];
1026     mlib_u16 *tab1 = (mlib_u16*)table[1];
1027     mlib_u16 *tab2 = (mlib_u16*)table[2];
1028     mlib_s32 i, j;
1029     mlib_u32 s0, s1, s2, s3;
1030 
1031     s0 = tab0[0];
1032     s1 = tab1[0];
1033     s2 = tab2[0];
1034     for (i = 1; i &lt; 256; i++) {
1035       s3 = (s0 &lt;&lt; 16) + s1;
1036       s0 = tab0[i];
1037       s1 = tab1[i];
1038       tab[2*i-2] = s3;
1039       tab[2*i-1] = (s2 &lt;&lt; 16);
1040       s2 = tab2[i];
1041     }
1042 
1043     s3 = (s0 &lt;&lt; 16) + s1;
1044     tab[510] = s3;
1045     tab[511] = (s2 &lt;&lt; 16);
1046 
1047     sl = (void *)src;
1048     dl = dst;
1049 
1050     /* row loop */
1051     for (j = 0; j &lt; ysize; j ++) {
1052       mlib_u8  *sp = sl;
1053       mlib_u16 *dp = dl;
1054       mlib_s32 off, size = xsize;
1055       mlib_u16 *ptr;
1056 
1057       off = ((mlib_addr)dp &amp; 7) &gt;&gt; 1;
1058       off = (off &lt; size) ? off : size;
1059 
1060 #pragma pipeloop(0)
1061       for (i = 0; i &lt; off; i++) {
1062         ptr = (mlib_u16*)(tab + 2*sp[i]);
1063         dp[0] = ptr[0];
1064         dp[1] = ptr[1];
1065         dp[2] = ptr[2];
1066         dp += 3;
1067       }
1068 
1069       size -= off;
1070       sp += off;
1071 
1072       if (size &gt; 0) {
1073         off = (mlib_addr)sp &amp; 3;
1074 
1075         if (off == 0) {
1076           mlib_v_ImageLookUpSI_U8_U16_3_SrcOff0_D1(sp, dp, size, (mlib_d64*)tab);
1077         } else if (off == 1) {
1078           mlib_v_ImageLookUpSI_U8_U16_3_SrcOff1_D1(sp, dp, size, (mlib_d64*)tab);
1079         } else if (off == 2) {
1080           mlib_v_ImageLookUpSI_U8_U16_3_SrcOff2_D1(sp, dp, size, (mlib_d64*)tab);
1081         } else if (off == 3) {
1082           mlib_v_ImageLookUpSI_U8_U16_3_SrcOff3_D1(sp, dp, size, (mlib_d64*)tab);
1083         }
1084       }
1085 
1086       sl = (mlib_u8 *) ((mlib_u8 *) sl + slb);
1087       dl = (mlib_u16 *) ((mlib_u8 *) dl + dlb);
1088     }
1089   }
1090 }
1091 
1092 /***************************************************************/
1093 void mlib_v_ImageLookUpSI_U8_U16_4_DstA8D1_D1(const mlib_u8  *src,
1094                                               mlib_u16       *dst,
1095                                               mlib_s32       xsize,
1096                                               const mlib_d64 *table)
1097 {
1098   mlib_u32 *sa;          /* aligned pointer to source data */
1099   mlib_u8  *sp;          /* pointer to source data */
1100   mlib_u32 s0;           /* source data */
1101   mlib_d64 *dp;          /* aligned pointer to destination */
1102   mlib_d64 acc0, acc1;   /* destination data */
1103   mlib_d64 acc2, acc3;   /* destination data */
1104   mlib_s32 i;            /* loop variable */
1105   mlib_u32 s00, s01, s02, s03;
1106 
1107   sa   = (mlib_u32*)src;
1108   dp   = (mlib_d64 *) dst;
1109 
1110   i = 0;
1111 
1112   if (xsize &gt;= 4) {
1113 
1114     s0 = *sa++;
1115     s00 = (s0 &gt;&gt; 21) &amp; 0x7F8;
1116     s01 = (s0 &gt;&gt; 13) &amp; 0x7F8;
1117 
1118 #pragma pipeloop(0)
1119     for(i = 0; i &lt;= xsize - 8; i+=4, dp += 4) {
1120       s02 = (s0 &gt;&gt; 5) &amp; 0x7F8;
1121       s03 = (s0 &lt;&lt; 3) &amp; 0x7F8;
1122       acc0 = *(mlib_d64*)((mlib_u8*)table + s00);
1123       acc1 = *(mlib_d64*)((mlib_u8*)table + s01);
1124       acc2 = *(mlib_d64*)((mlib_u8*)table + s02);
1125       acc3 = *(mlib_d64*)((mlib_u8*)table + s03);
1126       s0 = *sa++;
1127       s00 = (s0 &gt;&gt; 21) &amp; 0x7F8;
1128       s01 = (s0 &gt;&gt; 13) &amp; 0x7F8;
1129       dp[0] = acc0;
1130       dp[1] = acc1;
1131       dp[2] = acc2;
1132       dp[3] = acc3;
1133     }
1134 
1135     s02 = (s0 &gt;&gt; 5) &amp; 0x7F8;
1136     s03 = (s0 &lt;&lt; 3) &amp; 0x7F8;
1137     acc0 = *(mlib_d64*)((mlib_u8*)table + s00);
1138     acc1 = *(mlib_d64*)((mlib_u8*)table + s01);
1139     acc2 = *(mlib_d64*)((mlib_u8*)table + s02);
1140     acc3 = *(mlib_d64*)((mlib_u8*)table + s03);
1141     dp[0] = acc0;
1142     dp[1] = acc1;
1143     dp[2] = acc2;
1144     dp[3] = acc3;
1145     dp += 4;
1146     i += 4;
1147   }
1148 
1149   sp = (mlib_u8*)sa;
1150 
1151   if ( i &lt;= xsize - 2) {
1152     *dp++ = table[sp[0]];
1153     *dp++ = table[sp[1]];
1154     i+=2; sp += 2;
1155   }
1156 
1157   if ( i &lt; xsize) *dp++ = table[sp[0]];
1158 }
1159 
1160 /***************************************************************/
1161 void mlib_v_ImageLookUpSI_U8_U16_4_DstNonAl_D1(const mlib_u8  *src,
1162                                                mlib_u16       *dst,
1163                                                mlib_s32       xsize,
1164                                                const mlib_d64 *table)
1165 {
1166   mlib_u32 *sa;              /* aligned pointer to source data */
1167   mlib_u8  *sp;              /* pointer to source data */
1168   mlib_u32 s0;               /* source data */
1169   mlib_u16 *dl;              /* pointer to start of destination */
1170   mlib_d64 *dp;              /* aligned pointer to destination */
1171   mlib_d64 acc0, acc1;       /* destination data */
1172   mlib_d64 acc2, acc3, acc4; /* destination data */
1173   mlib_s32 i;                /* loop variable */
1174   mlib_u16 *dend;            /* pointer to end of destination */
1175   mlib_s32 emask;            /* edge mask */
1176   mlib_s32 off;
1177   mlib_u32 s00, s01, s02, s03;
1178 
1179   sp = (void *)src;
1180   dl = dst;
1181   dend = dl + (xsize &lt;&lt; 2) - 1;
1182   dp   = (mlib_d64 *) ((mlib_addr) dl &amp; (~7));
1183   off  = (mlib_addr) dp - (mlib_addr) dl;
1184   vis_alignaddr(dp, off);
1185 
1186   emask = vis_edge16(dl, dend);
1187   acc0 = table[sp[0]];
1188   vis_pst_16(vis_faligndata(acc0, acc0), dp++, emask);
1189   sp++;
1190 
1191   sa = (mlib_u32*)sp;
1192 
1193   xsize--;
1194 
1195   i = 0;
1196 
1197   if (xsize &gt;= 4) {
1198 
1199     s0 = *sa++;
1200     s00 = (s0 &gt;&gt; 21) &amp; 0x7F8;
1201     s01 = (s0 &gt;&gt; 13) &amp; 0x7F8;
1202 
1203 #pragma pipeloop(0)
1204     for(i = 0; i &lt;= xsize - 8; i+=4, dp += 4) {
1205       s02 = (s0 &gt;&gt; 5) &amp; 0x7F8;
1206       s03 = (s0 &lt;&lt; 3) &amp; 0x7F8;
1207       acc1 = *(mlib_d64*)((mlib_u8*)table + s00);
1208       acc2 = *(mlib_d64*)((mlib_u8*)table + s01);
1209       acc3 = *(mlib_d64*)((mlib_u8*)table + s02);
1210       acc4 = *(mlib_d64*)((mlib_u8*)table + s03);
1211       s0 = *sa++;
1212       s00 = (s0 &gt;&gt; 21) &amp; 0x7F8;
1213       s01 = (s0 &gt;&gt; 13) &amp; 0x7F8;
1214       dp[0] = vis_faligndata(acc0, acc1);
1215       dp[1] = vis_faligndata(acc1, acc2);
1216       dp[2] = vis_faligndata(acc2, acc3);
1217       dp[3] = vis_faligndata(acc3, acc4);
1218       acc0 = acc4;
1219     }
1220 
1221     s02 = (s0 &gt;&gt; 5) &amp; 0x7F8;
1222     s03 = (s0 &lt;&lt; 3) &amp; 0x7F8;
1223     acc1 = *(mlib_d64*)((mlib_u8*)table + s00);
1224     acc2 = *(mlib_d64*)((mlib_u8*)table + s01);
1225     acc3 = *(mlib_d64*)((mlib_u8*)table + s02);
1226     acc4 = *(mlib_d64*)((mlib_u8*)table + s03);
1227     dp[0] = vis_faligndata(acc0, acc1);
1228     dp[1] = vis_faligndata(acc1, acc2);
1229     dp[2] = vis_faligndata(acc2, acc3);
1230     dp[3] = vis_faligndata(acc3, acc4);
1231     acc0 = acc4;
1232     dp += 4;
1233     i += 4;
1234   }
1235 
1236   sp = (mlib_u8*)sa;
1237 
1238   if ( i &lt;= xsize - 2) {
1239     acc1 = table[sp[0]];
1240     acc2 = table[sp[1]];
1241     *dp++ = vis_faligndata(acc0, acc1);
1242     *dp++ = vis_faligndata(acc1, acc2);
1243     i+=2; sp += 2;
1244     acc0 = acc2;
1245   }
1246 
1247   if ( i &lt; xsize) {
1248     acc1 = table[sp[0]];
1249     *dp++ = vis_faligndata(acc0, acc1);
1250     acc0 = acc1;
1251   }
1252 
1253   emask = vis_edge16(dp, dend);
1254   vis_pst_16(vis_faligndata(acc0, acc0), dp++, emask);
1255 }
1256 
1257 /***************************************************************/
1258 void mlib_v_ImageLookUpSI_U8_U16_4_DstOff0_D1_SMALL(const mlib_u8  *src,
1259                                                     mlib_u16       *dst,
1260                                                     mlib_s32       xsize,
1261                                                     const mlib_u16 **table)
1262 {
1263   mlib_u8  *sp;              /* pointer to source data */
1264   mlib_u32 s0;               /* source data */
1265   mlib_u16 *dl;              /* pointer to start of destination */
1266   mlib_d64 *dp;              /* aligned pointer to destination */
1267   mlib_d64 t0, t1, t2, t3;   /* destination data */
1268   mlib_d64 acc;              /* destination data */
1269   mlib_s32 i;                /* loop variable */
1270   const mlib_u16 *tab0 = table[0];
1271   const mlib_u16 *tab1 = table[1];
1272   const mlib_u16 *tab2 = table[2];
1273   const mlib_u16 *tab3 = table[3];
1274 
1275   sp   = (void *)src;
1276   dl   = dst;
1277   dp   = (mlib_d64 *) dl;
1278 
1279   vis_alignaddr((void *) 0, 6);
1280 
1281   if (xsize &gt;= 1) {
1282 
1283     s0 = (*sp++) &lt;&lt; 1;
1284 
1285 #pragma pipeloop(0)
1286     for(i = 0; i &lt;= xsize - 2; i++) {
1287       t3 = VIS_LD_U16_I(tab3, s0);
1288       t2 = VIS_LD_U16_I(tab2, s0);
1289       t1 = VIS_LD_U16_I(tab1, s0);
1290       t0 = VIS_LD_U16_I(tab0, s0);
1291       acc = vis_faligndata(t3, acc);
1292       acc = vis_faligndata(t2, acc);
1293       acc = vis_faligndata(t1, acc);
1294       acc = vis_faligndata(t0, acc);
1295       s0 = (*sp++) &lt;&lt; 1;
1296       *dp++ = acc;
1297     }
1298 
1299     t3 = VIS_LD_U16_I(tab3, s0);
1300     t2 = VIS_LD_U16_I(tab2, s0);
1301     t1 = VIS_LD_U16_I(tab1, s0);
1302     t0 = VIS_LD_U16_I(tab0, s0);
1303     acc = vis_faligndata(t3, acc);
1304     acc = vis_faligndata(t2, acc);
1305     acc = vis_faligndata(t1, acc);
1306     acc = vis_faligndata(t0, acc);
1307     *dp++ = acc;
1308   }
1309 }
1310 
1311 /***************************************************************/
1312 void mlib_v_ImageLookUpSI_U8_U16_4_DstOff1_D1_SMALL(const mlib_u8  *src,
1313                                                     mlib_u16       *dst,
1314                                                     mlib_s32       xsize,
1315                                                     const mlib_u16 **table)
1316 {
1317   mlib_u8  *sp;              /* pointer to source data */
1318   mlib_u32 s0, s1;           /* source data */
1319   mlib_u16 *dl;              /* pointer to start of destination */
1320   mlib_d64 *dp;              /* aligned pointer to destination */
1321   mlib_d64 t0, t1, t2, t3;   /* destination data */
1322   mlib_d64 acc;              /* destination data */
1323   mlib_s32 i;                /* loop variable */
1324   const mlib_u16 *tab0 = table[0];
1325   const mlib_u16 *tab1 = table[1];
1326   const mlib_u16 *tab2 = table[2];
1327   const mlib_u16 *tab3 = table[3];
1328 
1329   sp   = (void *)src;
1330   dl   = dst;
1331   dp   = (mlib_d64 *) dl;
1332 
1333   vis_alignaddr((void *) 0, 6);
1334 
1335   s0 = (*sp++) &lt;&lt; 1;
1336 
1337   if (xsize &gt;= 1) {
1338 
1339     s1 = (*sp++) &lt;&lt; 1;
1340 
1341 #pragma pipeloop(0)
1342     for(i = 0; i &lt;= xsize - 2; i++) {
1343       t3 = VIS_LD_U16_I(tab0, s1);
1344       t2 = VIS_LD_U16_I(tab3, s0);
1345       t1 = VIS_LD_U16_I(tab2, s0);
1346       t0 = VIS_LD_U16_I(tab1, s0);
1347       acc = vis_faligndata(t3, acc);
1348       acc = vis_faligndata(t2, acc);
1349       acc = vis_faligndata(t1, acc);
1350       acc = vis_faligndata(t0, acc);
1351       s0 = s1;
1352       s1 = (*sp++) &lt;&lt; 1;
1353       *dp++ = acc;
1354     }
1355 
1356     t3 = VIS_LD_U16_I(tab0, s1);
1357     t2 = VIS_LD_U16_I(tab3, s0);
1358     t1 = VIS_LD_U16_I(tab2, s0);
1359     t0 = VIS_LD_U16_I(tab1, s0);
1360     acc = vis_faligndata(t3, acc);
1361     acc = vis_faligndata(t2, acc);
1362     acc = vis_faligndata(t1, acc);
1363     acc = vis_faligndata(t0, acc);
1364     s0 = s1;
1365     *dp++ = acc;
1366   }
1367 
1368   dl = (mlib_u16*)dp;
1369   s0 &gt;&gt;= 1;
1370 
1371   dl[0] = tab1[s0];
1372   dl[1] = tab2[s0];
1373   dl[2] = tab3[s0];
1374 }
1375 
1376 /***************************************************************/
1377 void mlib_v_ImageLookUpSI_U8_U16_4_DstOff2_D1_SMALL(const mlib_u8  *src,
1378                                                     mlib_u16       *dst,
1379                                                     mlib_s32       xsize,
1380                                                     const mlib_u16 **table)
1381 {
1382   mlib_u8  *sp;              /* pointer to source data */
1383   mlib_u32 s0, s1;           /* source data */
1384   mlib_u16 *dl;              /* pointer to start of destination */
1385   mlib_d64 *dp;              /* aligned pointer to destination */
1386   mlib_d64 t0, t1, t2, t3;   /* destination data */
1387   mlib_d64 acc;              /* destination data */
1388   mlib_s32 i;                /* loop variable */
1389   const mlib_u16 *tab0 = table[0];
1390   const mlib_u16 *tab1 = table[1];
1391   const mlib_u16 *tab2 = table[2];
1392   const mlib_u16 *tab3 = table[3];
1393 
1394   sp   = (void *)src;
1395   dl   = dst;
1396   dp   = (mlib_d64 *) dl;
1397 
1398   vis_alignaddr((void *) 0, 6);
1399 
1400   s0 = (*sp++) &lt;&lt; 1;
1401 
1402   if (xsize &gt;= 1) {
1403 
1404     s1 = (*sp++) &lt;&lt; 1;
1405 
1406 #pragma pipeloop(0)
1407     for(i = 0; i &lt;= xsize - 2; i++) {
1408       t3 = VIS_LD_U16_I(tab1, s1);
1409       t2 = VIS_LD_U16_I(tab0, s1);
1410       t1 = VIS_LD_U16_I(tab3, s0);
1411       t0 = VIS_LD_U16_I(tab2, s0);
1412       acc = vis_faligndata(t3, acc);
1413       acc = vis_faligndata(t2, acc);
1414       acc = vis_faligndata(t1, acc);
1415       acc = vis_faligndata(t0, acc);
1416       s0 = s1;
1417       s1 = (*sp++) &lt;&lt; 1;
1418       *dp++ = acc;
1419     }
1420 
1421     t3 = VIS_LD_U16_I(tab1, s1);
1422     t2 = VIS_LD_U16_I(tab0, s1);
1423     t1 = VIS_LD_U16_I(tab3, s0);
1424     t0 = VIS_LD_U16_I(tab2, s0);
1425     acc = vis_faligndata(t3, acc);
1426     acc = vis_faligndata(t2, acc);
1427     acc = vis_faligndata(t1, acc);
1428     acc = vis_faligndata(t0, acc);
1429     s0 = s1;
1430     *dp++ = acc;
1431   }
1432 
1433   dl = (mlib_u16*)dp;
1434   s0 &gt;&gt;= 1;
1435 
1436   dl[0] = tab2[s0];
1437   dl[1] = tab3[s0];
1438 }
1439 
1440 /***************************************************************/
1441 void mlib_v_ImageLookUpSI_U8_U16_4_DstOff3_D1_SMALL(const mlib_u8  *src,
1442                                                     mlib_u16       *dst,
1443                                                     mlib_s32       xsize,
1444                                                     const mlib_u16 **table)
1445 {
1446   mlib_u8  *sp;              /* pointer to source data */
1447   mlib_u32 s0, s1;           /* source data */
1448   mlib_u16 *dl;              /* pointer to start of destination */
1449   mlib_d64 *dp;              /* aligned pointer to destination */
1450   mlib_d64 t0, t1, t2, t3;   /* destination data */
1451   mlib_d64 acc;              /* destination data */
1452   mlib_s32 i;                /* loop variable */
1453   const mlib_u16 *tab0 = table[0];
1454   const mlib_u16 *tab1 = table[1];
1455   const mlib_u16 *tab2 = table[2];
1456   const mlib_u16 *tab3 = table[3];
1457 
1458   sp   = (void *)src;
1459   dl   = dst;
1460   dp   = (mlib_d64 *) dl;
1461 
1462   vis_alignaddr((void *) 0, 6);
1463 
1464   s0 = (*sp++) &lt;&lt; 1;
1465 
1466   if (xsize &gt;= 1) {
1467 
1468     s1 = (*sp++) &lt;&lt; 1;
1469 
1470 #pragma pipeloop(0)
1471     for(i = 0; i &lt;= xsize - 2; i++) {
1472       t3 = VIS_LD_U16_I(tab2, s1);
1473       t2 = VIS_LD_U16_I(tab1, s1);
1474       t1 = VIS_LD_U16_I(tab0, s1);
1475       t0 = VIS_LD_U16_I(tab3, s0);
1476       acc = vis_faligndata(t3, acc);
1477       acc = vis_faligndata(t2, acc);
1478       acc = vis_faligndata(t1, acc);
1479       acc = vis_faligndata(t0, acc);
1480       s0 = s1;
1481       s1 = (*sp++) &lt;&lt; 1;
1482       *dp++ = acc;
1483     }
1484 
1485     t3 = VIS_LD_U16_I(tab2, s1);
1486     t2 = VIS_LD_U16_I(tab1, s1);
1487     t1 = VIS_LD_U16_I(tab0, s1);
1488     t0 = VIS_LD_U16_I(tab3, s0);
1489     acc = vis_faligndata(t3, acc);
1490     acc = vis_faligndata(t2, acc);
1491     acc = vis_faligndata(t1, acc);
1492     acc = vis_faligndata(t0, acc);
1493     s0 = s1;
1494     *dp++ = acc;
1495   }
1496 
1497   dl = (mlib_u16*)dp;
1498   s0 &gt;&gt;= 1;
1499 
1500   dl[0] = tab3[s0];
1501 }
1502 
1503 /***************************************************************/
1504 void mlib_v_ImageLookUpSI_U8_U16_4(const mlib_u8  *src,
1505                                    mlib_s32       slb,
1506                                    mlib_u16       *dst,
1507                                    mlib_s32       dlb,
1508                                    mlib_s32       xsize,
1509                                    mlib_s32       ysize,
1510                                    const mlib_u16 **table)
1511 {
1512   if ((xsize * ysize) &lt; 550) {
1513     mlib_u8  *sl;
1514     mlib_u16 *dl;
1515     mlib_s32 j;
1516     const mlib_u16 *tab0 = table[0];
1517     const mlib_u16 *tab1 = table[1];
1518     const mlib_u16 *tab2 = table[2];
1519 
1520     sl = (void *)src;
1521     dl = dst;
1522 
1523     /* row loop */
1524     for (j = 0; j &lt; ysize; j ++) {
1525       mlib_u8  *sp = sl;
1526       mlib_u16 *dp = dl;
1527       mlib_s32 off, s0, size = xsize;
1528 
1529       if (size &gt; 0) {
1530         off =  ((8 - ((mlib_addr)dp &amp; 7)) &amp; 7) &gt;&gt; 1;
1531 
1532         if (off == 0) {
1533           mlib_v_ImageLookUpSI_U8_U16_4_DstOff0_D1_SMALL(sp, dp, size, table);
1534         } else if (off == 1) {
1535           s0 = *sp;
1536           *dp++ = tab0[s0];
1537           size--;
1538           mlib_v_ImageLookUpSI_U8_U16_4_DstOff1_D1_SMALL(sp, dp, size, table);
1539         } else if (off == 2) {
1540           s0 = *sp;
1541           *dp++ = tab0[s0];
1542           *dp++ = tab1[s0];
1543           size--;
1544           mlib_v_ImageLookUpSI_U8_U16_4_DstOff2_D1_SMALL(sp, dp, size, table);
1545         } else if (off == 3) {
1546           s0 = *sp;
1547           *dp++ = tab0[s0];
1548           *dp++ = tab1[s0];
1549           *dp++ = tab2[s0];
1550           size--;
1551           mlib_v_ImageLookUpSI_U8_U16_4_DstOff3_D1_SMALL(sp, dp, size, table);
1552         }
1553       }
1554 
1555       sl = (mlib_u8 *) ((mlib_u8 *) sl + slb);
1556       dl = (mlib_u16 *) ((mlib_u8 *) dl + dlb);
1557     }
1558 
1559   } else {
1560     mlib_u8  *sl;
1561     mlib_u16 *dl;
1562     mlib_u32 tab[512];
1563     mlib_u16 *tab0 = (mlib_u16*)table[0];
1564     mlib_u16 *tab1 = (mlib_u16*)table[1];
1565     mlib_u16 *tab2 = (mlib_u16*)table[2];
1566     mlib_u16 *tab3 = (mlib_u16*)table[3];
1567     mlib_s32 i, j;
1568     mlib_u32 s0, s1, s2, s3, s4, s5;
1569 
1570     s0 = tab0[0];
1571     s1 = tab1[0];
1572     s2 = tab2[0];
1573     s3 = tab3[0];
1574     for (i = 1; i &lt; 256; i++) {
1575       s4 = (s0 &lt;&lt; 16) + s1;
1576       s5 = (s2 &lt;&lt; 16) + s3;
1577       s0 = tab0[i];
1578       s1 = tab1[i];
1579       s2 = tab2[i];
1580       s3 = tab3[i];
1581       tab[2*i-2] = s4;
1582       tab[2*i-1] = s5;
1583     }
1584 
1585     s4 = (s0 &lt;&lt; 16) + s1;
1586     s5 = (s2 &lt;&lt; 16) + s3;
1587     tab[510] = s4;
1588     tab[511] = s5;
1589 
1590     sl = (void *)src;
1591     dl = dst;
1592 
1593     /* row loop */
1594     for (j = 0; j &lt; ysize; j ++) {
1595       mlib_u8  *sp = sl;
1596       mlib_u16 *dp = dl;
1597       mlib_s32 off, s0, size = xsize;
1598       mlib_u16 *ptr;
1599 
1600       if (((mlib_addr)dp &amp; 7) == 0) {
1601 
1602         off = ((4 - (mlib_addr)sp &amp; 3) &amp; 3);
1603         off = (off &lt; size) ? off : size;
1604 
1605 #pragma pipeloop(0)
1606         for (i = 0; i &lt; off; i++) {
1607           s0 = (*sp++);
1608           *(mlib_u32*)dp = tab[2*s0];
1609           *(mlib_u32*)(dp + 2) = tab[2*s0 + 1];
1610           dp += 4;
1611         }
1612 
1613         size -= off;
1614 
1615         if (size &gt; 0) {
1616           mlib_v_ImageLookUpSI_U8_U16_4_DstA8D1_D1(sp, dp, size, (mlib_d64*)tab);
1617         }
1618 
1619       } else {
1620 
1621         off = (3 - ((mlib_addr)sp &amp; 3));
1622         off = (off &lt; size) ? off : size;
1623 
1624         for (i = 0; i &lt; off; i++) {
1625           ptr = (mlib_u16*)(tab + 2*sp[i]);
1626           dp[0] = ptr[0];
1627           dp[1] = ptr[1];
1628           dp[2] = ptr[2];
1629           dp[3] = ptr[3];
1630           dp += 4;
1631         }
1632 
1633         sp += off;
1634         size -= off;
1635 
1636         if (size &gt; 0) {
1637           mlib_v_ImageLookUpSI_U8_U16_4_DstNonAl_D1(sp, dp, size, (mlib_d64*)tab);
1638         }
1639       }
1640 
1641       sl = (mlib_u8 *) ((mlib_u8 *) sl + slb);
1642       dl = (mlib_u16 *) ((mlib_u8 *) dl + dlb);
1643     }
1644   }
1645 }
1646 
1647 /***************************************************************/
    </pre>
  </body>
</html>
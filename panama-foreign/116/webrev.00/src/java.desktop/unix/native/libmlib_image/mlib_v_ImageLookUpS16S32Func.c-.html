<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libmlib_image/mlib_v_ImageLookUpS16S32Func.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 
 28 #include &quot;vis_proto.h&quot;
 29 #include &quot;mlib_image.h&quot;
 30 #include &quot;mlib_v_ImageLookUpFunc.h&quot;
 31 
 32 /***************************************************************/
 33 static void mlib_v_ImageLookUp_S16_S32_124_D1(const mlib_s16 *src,
 34                                               mlib_f32       *dst,
 35                                               mlib_s32       xsize,
 36                                               const mlib_f32 *table0,
 37                                               const mlib_f32 *table1,
 38                                               const mlib_f32 *table2,
 39                                               const mlib_f32 *table3);
 40 
 41 static void mlib_v_ImageLookUp_S16_S32_3_D1(const mlib_s16 *src,
 42                                             mlib_f32       *dst,
 43                                             mlib_s32       xsize,
 44                                             const mlib_f32 *table0,
 45                                             const mlib_f32 *table1,
 46                                             const mlib_f32 *table2);
 47 
 48 /***************************************************************/
 49 void mlib_v_ImageLookUp_S16_S32_124_D1(const mlib_s16 *src,
 50                                        mlib_f32       *dst,
 51                                        mlib_s32       xsize,
 52                                        const mlib_f32 *table0,
 53                                        const mlib_f32 *table1,
 54                                        const mlib_f32 *table2,
 55                                        const mlib_f32 *table3)
 56 {
 57   mlib_s32 *sa;          /* aligned pointer to source data */
 58   mlib_s16 *sp;          /* pointer to source data */
 59   mlib_s32 s0, s1;       /* source data */
 60   mlib_f32 *dp;          /* aligned pointer to destination */
 61   mlib_f32 acc0, acc1;   /* destination data */
 62   mlib_f32 acc2, acc3;   /* destination data */
 63   mlib_s32 i;            /* loop variable */
 64   mlib_s32 s00, s01, s02, s03;
 65 
 66   sa   = (mlib_s32*)src;
 67   dp   = dst;
 68 
 69   i = 0;
 70 
 71   if (xsize &gt;= 4) {
 72 
 73     s0 = *sa++;
 74     s1 = *sa++;
 75     s00 = (s0 &gt;&gt; 14) &amp; (~3);
 76     s01 = ((s0 &lt;&lt; 16) &gt;&gt; 14);
 77 
 78 #pragma pipeloop(0)
 79     for(i = 0; i &lt;= xsize - 8; i+=4, dp += 4) {
 80       s02 = (s1 &gt;&gt; 14) &amp; (~3);
 81       s03 = ((s1 &lt;&lt; 16) &gt;&gt; 14);
 82       acc0 = *(mlib_f32*)((mlib_u8*)table0 + s00);
 83       acc1 = *(mlib_f32*)((mlib_u8*)table1 + s01);
 84       acc2 = *(mlib_f32*)((mlib_u8*)table2 + s02);
 85       acc3 = *(mlib_f32*)((mlib_u8*)table3 + s03);
 86       s0 = *sa++;
 87       s1 = *sa++;
 88       s00 = (s0 &gt;&gt; 14) &amp; (~3);
 89       s01 = ((s0 &lt;&lt; 16) &gt;&gt; 14);
 90       dp[0] = acc0;
 91       dp[1] = acc1;
 92       dp[2] = acc2;
 93       dp[3] = acc3;
 94     }
 95 
 96     s02 = (s1 &gt;&gt; 14) &amp; (~3);
 97     s03 = ((s1 &lt;&lt; 16) &gt;&gt; 14);
 98     acc0 = *(mlib_f32*)((mlib_u8*)table0 + s00);
 99     acc1 = *(mlib_f32*)((mlib_u8*)table1 + s01);
100     acc2 = *(mlib_f32*)((mlib_u8*)table2 + s02);
101     acc3 = *(mlib_f32*)((mlib_u8*)table3 + s03);
102     dp[0] = acc0;
103     dp[1] = acc1;
104     dp[2] = acc2;
105     dp[3] = acc3;
106     dp += 4;
107     i += 4;
108   }
109 
110   sp = (mlib_s16*)sa;
111 
112   if ( i &lt; xsize ) {
113     *dp++ = table0[sp[0]];
114     i++; sp++;
115   }
116 
117   if ( i &lt; xsize ) {
118     *dp++ = table1[sp[0]];
119     i++; sp++;
120   }
121 
122   if ( i &lt; xsize ) {
123     *dp++ = table2[sp[0]];
124   }
125 }
126 
127 /***************************************************************/
128 void mlib_v_ImageLookUp_S16_S32_1(const mlib_s16 *src,
129                                   mlib_s32       slb,
130                                   mlib_s32       *dst,
131                                   mlib_s32       dlb,
132                                   mlib_s32       xsize,
133                                   mlib_s32       ysize,
134                                   const mlib_s32 **table)
135 {
136   mlib_s16 *sl;
137   mlib_s32 *dl;
138   mlib_f32 *tab = (mlib_f32*)(&amp;table[0][32768]);
139   mlib_s32 j;
140 
141   sl = (void *)src;
142   dl = dst;
143 
144   /* row loop */
145   for (j = 0; j &lt; ysize; j ++) {
146     mlib_s16 *sp = sl;
147     mlib_f32 *dp = (mlib_f32*)dl;
148     mlib_s32 off, size = xsize;
149 
150     off = (mlib_s32)(((4 - ((mlib_addr)sp &amp; 3)) &amp; 3) &gt;&gt; 1);
151 
152     off = (off &lt; size) ? off : size;
153 
154     if (off == 1) {
155       *dp++ = tab[(*sp++)];
156       size--;
157     }
158 
159     if (size &gt; 0) {
160       mlib_v_ImageLookUp_S16_S32_124_D1(sp, dp, size, tab, tab, tab, tab);
161     }
162 
163     sl = (mlib_s16 *) ((mlib_u8 *) sl + slb);
164     dl = (mlib_s32 *) ((mlib_u8 *) dl + dlb);
165   }
166 }
167 
168 /***************************************************************/
169 void mlib_v_ImageLookUp_S16_S32_2(const mlib_s16 *src,
170                                   mlib_s32       slb,
171                                   mlib_s32       *dst,
172                                   mlib_s32       dlb,
173                                   mlib_s32       xsize,
174                                   mlib_s32       ysize,
175                                   const mlib_s32 **table)
176 {
177   mlib_s16  *sl;
178   mlib_s32  *dl;
179   mlib_f32  *tab;
180   mlib_s32  j;
181 
182   sl = (void *)src;
183   dl = dst;
184 
185   /* row loop */
186   for (j = 0; j &lt; ysize; j ++) {
187     mlib_s16  *sp = sl;
188     mlib_f32  *dp = (mlib_f32*)dl;
189     mlib_s32  off, size = xsize * 2;
190     mlib_f32  *tab0 = (mlib_f32*)(&amp;table[0][32768]);
191     mlib_f32  *tab1 = (mlib_f32*)(&amp;table[1][32768]);
192 
193     off = (mlib_s32)(((4 - ((mlib_addr)sp &amp; 3)) &amp; 3) &gt;&gt; 1);
194 
195     off = (off &lt; size) ? off : size;
196 
197     if ((off &amp; 1) != 0) {
198       *dp++ = tab0[(*sp++)];
199       size--;
200       tab = tab0; tab0 = tab1; tab1 = tab;
201     }
202 
203     if (size &gt; 0) {
204       mlib_v_ImageLookUp_S16_S32_124_D1(sp, dp, size, tab0, tab1, tab0, tab1);
205     }
206 
207     sl = (mlib_s16 *) ((mlib_u8 *) sl + slb);
208     dl = (mlib_s32 *) ((mlib_u8 *) dl + dlb);
209   }
210 }
211 
212 /***************************************************************/
213 void mlib_v_ImageLookUp_S16_S32_4(const mlib_s16 *src,
214                                   mlib_s32       slb,
215                                   mlib_s32       *dst,
216                                   mlib_s32       dlb,
217                                   mlib_s32       xsize,
218                                   mlib_s32       ysize,
219                                   const mlib_s32 **table)
220 {
221   mlib_s16  *sl;
222   mlib_s32  *dl;
223   mlib_f32  *tab;
224   mlib_s32  j;
225 
226   sl = (void *)src;
227   dl = dst;
228 
229   /* row loop */
230   for (j = 0; j &lt; ysize; j ++) {
231     mlib_s16  *sp = sl;
232     mlib_f32  *dp = (mlib_f32*)dl;
233     mlib_f32  *tab0 = (mlib_f32*)(&amp;table[0][32768]);
234     mlib_f32  *tab1 = (mlib_f32*)(&amp;table[1][32768]);
235     mlib_f32  *tab2 = (mlib_f32*)(&amp;table[2][32768]);
236     mlib_f32  *tab3 = (mlib_f32*)(&amp;table[3][32768]);
237     mlib_s32  off, size = xsize * 4;
238 
239     off = (mlib_s32)(((4 - ((mlib_addr)sp &amp; 3)) &amp; 3) &gt;&gt; 1);
240 
241     off = (off &lt; size) ? off : size;
242 
243     if (off == 1) {
244       *dp++ = tab0[(*sp++)];
245       tab = tab0; tab0 = tab1;
246       tab1 = tab2; tab2 = tab3; tab3 = tab;
247       size--;
248     }
249 
250     if (size &gt; 0) {
251       mlib_v_ImageLookUp_S16_S32_124_D1(sp, dp, size, tab0, tab1, tab2, tab3);
252     }
253 
254     sl = (mlib_s16 *) ((mlib_u8 *) sl + slb);
255     dl = (mlib_s32 *) ((mlib_u8 *) dl + dlb);
256   }
257 }
258 
259 /***************************************************************/
260 void mlib_v_ImageLookUp_S16_S32_3_D1(const mlib_s16 *src,
261                                      mlib_f32       *dst,
262                                      mlib_s32       xsize,
263                                      const mlib_f32 *table0,
264                                      const mlib_f32 *table1,
265                                      const mlib_f32 *table2)
266 {
267   mlib_s32 *sa;          /* aligned pointer to source data */
268   mlib_s16 *sp;          /* pointer to source data */
269   mlib_s32 s0, s1;       /* source data */
270   mlib_f32 *dp;          /* aligned pointer to destination */
271   mlib_f32 acc0, acc1;   /* destination data */
272   mlib_f32 acc2, acc3;   /* destination data */
273   mlib_s32 i;            /* loop variable */
274   const mlib_f32 *table;
275   mlib_s32 s00, s01, s02, s03;
276 
277   sa   = (mlib_s32*)src;
278   dp   = dst;
279 
280   i = 0;
281 
282   if (xsize &gt;= 4) {
283 
284     s0 = *sa++;
285     s1 = *sa++;
286     s00 = (s0 &gt;&gt; 14) &amp; (~3);
287     s01 = ((s0 &lt;&lt; 16) &gt;&gt; 14);
288 
289 #pragma pipeloop(0)
290     for(i = 0; i &lt;= xsize - 8; i+=4, dp += 4) {
291       s02 = (s1 &gt;&gt; 14) &amp; (~3);
292       s03 = ((s1 &lt;&lt; 16) &gt;&gt; 14);
293       acc0 = *(mlib_f32*)((mlib_u8*)table0 + s00);
294       acc1 = *(mlib_f32*)((mlib_u8*)table1 + s01);
295       acc2 = *(mlib_f32*)((mlib_u8*)table2 + s02);
296       acc3 = *(mlib_f32*)((mlib_u8*)table0 + s03);
297       s0 = *sa++;
298       s1 = *sa++;
299       s00 = (s0 &gt;&gt; 14) &amp; (~3);
300       s01 = ((s0 &lt;&lt; 16) &gt;&gt; 14);
301       table = table0; table0 = table1;
302       table1 = table2; table2 = table;
303       dp[0] = acc0;
304       dp[1] = acc1;
305       dp[2] = acc2;
306       dp[3] = acc3;
307     }
308 
309     s02 = (s1 &gt;&gt; 14) &amp; (~3);
310     s03 = ((s1 &lt;&lt; 16) &gt;&gt; 14);
311     acc0 = *(mlib_f32*)((mlib_u8*)table0 + s00);
312     acc1 = *(mlib_f32*)((mlib_u8*)table1 + s01);
313     acc2 = *(mlib_f32*)((mlib_u8*)table2 + s02);
314     acc3 = *(mlib_f32*)((mlib_u8*)table0 + s03);
315     dp[0] = acc0;
316     dp[1] = acc1;
317     dp[2] = acc2;
318     dp[3] = acc3;
319     table = table0; table0 = table1;
320     table1 = table2; table2 = table;
321     dp += 4;
322     i += 4;
323   }
324 
325   sp = (mlib_s16*)sa;
326 
327   if ( i &lt; xsize ) {
328     *dp++ = table0[sp[0]];
329     i++; sp++;
330   }
331 
332   if ( i &lt; xsize ) {
333     *dp++ = table1[sp[0]];
334     i++; sp++;
335   }
336 
337   if ( i &lt; xsize ) {
338     *dp++ = table2[sp[0]];
339   }
340 }
341 
342 /***************************************************************/
343 void mlib_v_ImageLookUp_S16_S32_3(const mlib_s16 *src,
344                                   mlib_s32       slb,
345                                   mlib_s32       *dst,
346                                   mlib_s32       dlb,
347                                   mlib_s32       xsize,
348                                   mlib_s32       ysize,
349                                   const mlib_s32 **table)
350 {
351   mlib_s16  *sl;
352   mlib_s32  *dl;
353   mlib_f32  *tab;
354   mlib_s32  j;
355 
356   sl = (void *)src;
357   dl = dst;
358 
359   /* row loop */
360   for (j = 0; j &lt; ysize; j ++) {
361     mlib_s16  *sp = sl;
362     mlib_f32  *dp = (mlib_f32*)dl;
363     mlib_f32  *tab0 = (mlib_f32*)(&amp;table[0][32768]);
364     mlib_f32  *tab1 = (mlib_f32*)(&amp;table[1][32768]);
365     mlib_f32  *tab2 = (mlib_f32*)(&amp;table[2][32768]);
366     mlib_s32  off, size = xsize * 3;
367 
368     off = (mlib_s32)(((4 - ((mlib_addr)sp &amp; 3)) &amp; 3) &gt;&gt; 1);
369 
370     off = (off &lt; size) ? off : size;
371 
372     if (off == 1) {
373       *dp++ = tab0[(*sp++)];
374       tab = tab0; tab0 = tab1;
375       tab1 = tab2; tab2 = tab;
376       size--;
377     }
378 
379     if (size &gt; 0) {
380       mlib_v_ImageLookUp_S16_S32_3_D1(sp, dp, size, tab0, tab1, tab2);
381     }
382 
383     sl = (mlib_s16 *) ((mlib_u8 *) sl + slb);
384     dl = (mlib_s32 *) ((mlib_u8 *) dl + dlb);
385   }
386 }
387 
388 /***************************************************************/
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libmlib_image/mlib_v_ImageLookUpU16U16Func.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 
 28 #include &quot;vis_proto.h&quot;
 29 #include &quot;mlib_image.h&quot;
 30 #include &quot;mlib_v_ImageLookUpFunc.h&quot;
 31 
 32 /***************************************************************/
 33 static void mlib_v_ImageLookUp_U16_U16_124_D1(const mlib_u16 *src,
 34                                               mlib_u16       *dst,
 35                                               mlib_s32       xsize,
 36                                               const mlib_u16 *table0,
 37                                               const mlib_u16 *table1,
 38                                               const mlib_u16 *table2,
 39                                               const mlib_u16 *table3);
 40 
 41 static void mlib_v_ImageLookUp_U16_U16_3_D1(const mlib_u16 *src,
 42                                             mlib_u16       *dst,
 43                                             mlib_s32       xsize,
 44                                             const mlib_u16 *table0,
 45                                             const mlib_u16 *table1,
 46                                             const mlib_u16 *table2);
 47 
 48 /***************************************************************/
 49 #define VIS_LD_U16_I(X, Y)      vis_ld_u16_i((void *)(X), (Y))
 50 
 51 /***************************************************************/
 52 void mlib_v_ImageLookUp_U16_U16_124_D1(const mlib_u16 *src,
 53                                        mlib_u16       *dst,
 54                                        mlib_s32       xsize,
 55                                        const mlib_u16 *table0,
 56                                        const mlib_u16 *table1,
 57                                        const mlib_u16 *table2,
 58                                        const mlib_u16 *table3)
 59 {
 60   mlib_u16 *sp;            /* pointer to source data */
 61   mlib_s32 s0, s1, s2, s3; /* source data */
 62   mlib_u16 *dl;            /* pointer to start of destination */
 63   mlib_u16 *dend;          /* pointer to end of destination */
 64   mlib_d64 *dp;            /* aligned pointer to destination */
 65   mlib_d64 t0, t1, t2;     /* destination data */
 66   mlib_d64 t3, acc0;       /* destination data */
 67   mlib_s32 emask;          /* edge mask */
 68   mlib_s32 i, num;         /* loop variable */
 69 
 70   dl   = dst;
 71   sp   = (void *)src;
 72   dp   = (mlib_d64 *) dl;
 73   dend = dl + xsize - 1;
 74 
 75   vis_alignaddr((void *) 0, 6);
 76 
 77   i = 0;
 78 
 79   if (xsize &gt;= 4) {
 80 
 81     s0 = sp[0];
 82     s1 = sp[1];
 83     s2 = sp[2];
 84     s3 = sp[3];
 85     sp += 4;
 86 
 87 #pragma pipeloop(0)
 88     for(i = 0; i &lt;= xsize - 8; i+=4, sp += 4) {
 89       t3 = VIS_LD_U16_I(table3, 2*s3);
 90       t2 = VIS_LD_U16_I(table2, 2*s2);
 91       t1 = VIS_LD_U16_I(table1, 2*s1);
 92       t0 = VIS_LD_U16_I(table0, 2*s0);
 93       acc0 = vis_faligndata(t3, acc0);
 94       acc0 = vis_faligndata(t2, acc0);
 95       acc0 = vis_faligndata(t1, acc0);
 96       acc0 = vis_faligndata(t0, acc0);
 97       s0 = sp[0];
 98       s1 = sp[1];
 99       s2 = sp[2];
100       s3 = sp[3];
101       *dp++ = acc0;
102     }
103 
104     t3 = VIS_LD_U16_I(table3, 2*s3);
105     t2 = VIS_LD_U16_I(table2, 2*s2);
106     t1 = VIS_LD_U16_I(table1, 2*s1);
107     t0 = VIS_LD_U16_I(table0, 2*s0);
108     acc0 = vis_faligndata(t3, acc0);
109     acc0 = vis_faligndata(t2, acc0);
110     acc0 = vis_faligndata(t1, acc0);
111     acc0 = vis_faligndata(t0, acc0);
112     *dp++ = acc0;
113   }
114 
115   if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
116 
117     num = (mlib_u16*) dend - (mlib_u16*) dp;
118     sp  += num;
119     num ++;
120 
121     if (num == 1) {
122       s0 = (mlib_s32) *sp;
123       sp --;
124 
125       t0  = VIS_LD_U16_I(table0, 2*s0);
126       acc0 = vis_faligndata(t0, acc0);
127     } else if (num  == 2) {
128       s0 = (mlib_s32) *sp;
129       sp --;
130 
131       t0  = VIS_LD_U16_I(table1, 2*s0);
132       acc0 = vis_faligndata(t0, acc0);
133 
134       s0 = (mlib_s32) *sp;
135       sp --;
136 
137       t0  = VIS_LD_U16_I(table0, 2*s0);
138       acc0 = vis_faligndata(t0, acc0);
139     } else if (num == 3) {
140       s0 = (mlib_s32) *sp;
141       sp --;
142 
143       t0  = VIS_LD_U16_I(table2, 2*s0);
144       acc0 = vis_faligndata(t0, acc0);
145 
146       s0 = (mlib_s32) *sp;
147       sp --;
148 
149       t0  = VIS_LD_U16_I(table1, 2*s0);
150       acc0 = vis_faligndata(t0, acc0);
151 
152       s0 = (mlib_s32) *sp;
153       sp --;
154 
155       t0  = VIS_LD_U16_I(table0, 2*s0);
156       acc0 = vis_faligndata(t0, acc0);
157     }
158 
159     emask = vis_edge16(dp, dend);
160     vis_pst_16(acc0, dp, emask);
161   }
162 }
163 
164 /***************************************************************/
165 void mlib_v_ImageLookUp_U16_U16_1(const mlib_u16 *src,
166                                   mlib_s32       slb,
167                                   mlib_u16       *dst,
168                                   mlib_s32       dlb,
169                                   mlib_s32       xsize,
170                                   mlib_s32       ysize,
171                                   const mlib_u16 **table)
172 {
173   mlib_u16 *sl;
174   mlib_u16 *dl;
175   const mlib_u16 *tab = &amp;table[0][0];
176   mlib_s32 j, i;
177 
178   sl = (void *)src;
179   dl = dst;
180 
181   /* row loop */
182   for (j = 0; j &lt; ysize; j ++) {
183     mlib_u16 *sp = sl;
184     mlib_u16 *dp = dl;
185     mlib_s32 off, size = xsize;
186 
187     off = ((8 - ((mlib_addr)dp &amp; 7)) &amp; 7) &gt;&gt; 1;
188 
189     off = (off &lt; size) ? off : size;
190 
191     for (i = 0; i &lt; off; i++, sp++) {
192       *dp++ = tab[sp[0]];
193       size--;
194     }
195 
196     if (size &gt; 0) {
197       mlib_v_ImageLookUp_U16_U16_124_D1(sp, dp, size, tab, tab, tab, tab);
198     }
199 
200     sl = (mlib_u16 *) ((mlib_u8 *) sl + slb);
201     dl = (mlib_u16 *) ((mlib_u8 *) dl + dlb);
202   }
203 }
204 
205 /***************************************************************/
206 void mlib_v_ImageLookUp_U16_U16_2(const mlib_u16 *src,
207                                   mlib_s32       slb,
208                                   mlib_u16       *dst,
209                                   mlib_s32       dlb,
210                                   mlib_s32       xsize,
211                                   mlib_s32       ysize,
212                                   const mlib_u16 **table)
213 {
214   mlib_u16  *sl;
215   mlib_u16  *dl;
216   const mlib_u16  *tab;
217   mlib_s32  j, i;
218 
219   sl = (void *)src;
220   dl = dst;
221 
222   /* row loop */
223   for (j = 0; j &lt; ysize; j ++) {
224     mlib_u16  *sp = sl;
225     mlib_u16  *dp = dl;
226     mlib_s32  off, size = xsize * 2;
227     const mlib_u16 *tab0 = &amp;table[0][0];
228     const mlib_u16 *tab1 = &amp;table[1][0];
229 
230     off = ((8 - ((mlib_addr)dp &amp; 7)) &amp; 7) &gt;&gt; 1;
231 
232     off = (off &lt; size) ? off : size;
233 
234     for (i = 0; i &lt; off - 1; i+=2, sp += 2) {
235       *dp++ = tab0[sp[0]];
236       *dp++ = tab1[sp[1]];
237       size-=2;
238     }
239 
240     if ((off &amp; 1) != 0) {
241       *dp++ = tab0[sp[0]];
242       size--; sp++;
243       tab = tab0; tab0 = tab1; tab1 = tab;
244     }
245 
246     if (size &gt; 0) {
247       mlib_v_ImageLookUp_U16_U16_124_D1(sp, dp, size, tab0, tab1, tab0, tab1);
248     }
249 
250     sl = (mlib_u16 *) ((mlib_u8 *) sl + slb);
251     dl = (mlib_u16 *) ((mlib_u8 *) dl + dlb);
252   }
253 }
254 
255 /***************************************************************/
256 void mlib_v_ImageLookUp_U16_U16_4(const mlib_u16 *src,
257                                   mlib_s32       slb,
258                                   mlib_u16       *dst,
259                                   mlib_s32       dlb,
260                                   mlib_s32       xsize,
261                                   mlib_s32       ysize,
262                                   const mlib_u16 **table)
263 {
264   mlib_u16  *sl;
265   mlib_u16  *dl;
266   const mlib_u16  *tab;
267   mlib_s32  j;
268 
269   sl = (void *)src;
270   dl = dst;
271 
272   /* row loop */
273   for (j = 0; j &lt; ysize; j ++) {
274     mlib_u16  *sp = sl;
275     mlib_u16  *dp = dl;
276     const mlib_u16 *tab0 = &amp;table[0][0];
277     const mlib_u16 *tab1 = &amp;table[1][0];
278     const mlib_u16 *tab2 = &amp;table[2][0];
279     const mlib_u16 *tab3 = &amp;table[3][0];
280     mlib_s32  off, size = xsize * 4;
281 
282     off = ((8 - ((mlib_addr)dp &amp; 7)) &amp; 7) &gt;&gt; 1;
283 
284     off = (off &lt; size) ? off : size;
285 
286     if (off == 1) {
287       *dp++ = tab0[sp[0]];
288       tab = tab0; tab0 = tab1;
289       tab1 = tab2; tab2 = tab3; tab3 = tab;
290       size--; sp++;
291     } else if (off == 2) {
292       *dp++ = tab0[sp[0]];
293       *dp++ = tab1[sp[1]];
294       tab = tab0; tab0 = tab2; tab2 = tab;
295       tab = tab1; tab1 = tab3; tab3 = tab;
296       size-=2; sp += 2;
297     } else if (off == 3) {
298       *dp++ = tab0[sp[0]];
299       *dp++ = tab1[sp[1]];
300       *dp++ = tab2[sp[2]];
301       tab = tab3; tab3 = tab2;
302       tab2 = tab1; tab1 = tab0; tab0 = tab;
303       size-=3; sp += 3;
304     }
305 
306     if (size &gt; 0) {
307       mlib_v_ImageLookUp_U16_U16_124_D1(sp, dp, size, tab0, tab1, tab2, tab3);
308     }
309 
310     sl = (mlib_u16 *) ((mlib_u8 *) sl + slb);
311     dl = (mlib_u16 *) ((mlib_u8 *) dl + dlb);
312   }
313 }
314 
315 /***************************************************************/
316 void mlib_v_ImageLookUp_U16_U16_3_D1(const mlib_u16 *src,
317                                      mlib_u16       *dst,
318                                      mlib_s32       xsize,
319                                      const mlib_u16 *table0,
320                                      const mlib_u16 *table1,
321                                      const mlib_u16 *table2)
322 {
323   mlib_u16 *sp;              /* pointer to source data */
324   mlib_s32 s0, s1, s2, s3;   /* source data */
325   mlib_u16 *dl;              /* pointer to start of destination */
326   mlib_u16 *dend;            /* pointer to end of destination */
327   mlib_d64 *dp;              /* aligned pointer to destination */
328   mlib_d64 t0, t1, t2, t3;   /* destination data */
329   mlib_d64 acc0;             /* destination data */
330   mlib_s32 emask;            /* edge mask */
331   mlib_s32 i, num;           /* loop variable */
332   const mlib_u16 *table;
333 
334   dl   = dst;
335   sp   = (void *)src;
336   dp   = (mlib_d64 *) dl;
337   dend = dl + xsize - 1;
338 
339   vis_alignaddr((void *) 0, 6);
340 
341   i = 0;
342 
343   if (xsize &gt;= 4) {
344 
345     s0 = sp[0];
346     s1 = sp[1];
347     s2 = sp[2];
348     s3 = sp[3];
349     sp += 4;
350 
351 #pragma pipeloop(0)
352     for(i = 0; i &lt;= xsize - 8; i+=4, sp += 4) {
353       t3 = VIS_LD_U16_I(table0, 2*s3);
354       t2 = VIS_LD_U16_I(table2, 2*s2);
355       t1 = VIS_LD_U16_I(table1, 2*s1);
356       t0 = VIS_LD_U16_I(table0, 2*s0);
357       acc0 = vis_faligndata(t3, acc0);
358       acc0 = vis_faligndata(t2, acc0);
359       acc0 = vis_faligndata(t1, acc0);
360       acc0 = vis_faligndata(t0, acc0);
361       s0 = sp[0];
362       s1 = sp[1];
363       s2 = sp[2];
364       s3 = sp[3];
365       *dp++ = acc0;
366       table = table0; table0 = table1;
367       table1 = table2; table2 = table;
368     }
369 
370     t3 = VIS_LD_U16_I(table0, 2*s3);
371     t2 = VIS_LD_U16_I(table2, 2*s2);
372     t1 = VIS_LD_U16_I(table1, 2*s1);
373     t0 = VIS_LD_U16_I(table0, 2*s0);
374     acc0 = vis_faligndata(t3, acc0);
375     acc0 = vis_faligndata(t2, acc0);
376     acc0 = vis_faligndata(t1, acc0);
377     acc0 = vis_faligndata(t0, acc0);
378     *dp++ = acc0;
379     table = table0; table0 = table1;
380     table1 = table2; table2 = table;
381     i += 4;
382   }
383 
384   if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
385 
386     num = (mlib_u16*) dend - (mlib_u16*) dp;
387     sp  += num;
388     num ++;
389 
390     if (num == 1) {
391       s0 = (mlib_s32) *sp;
392       sp --;
393 
394       t0  = VIS_LD_U16_I(table0, 2*s0);
395       acc0 = vis_faligndata(t0, acc0);
396     } else if (num  == 2) {
397       s0 = (mlib_s32) *sp;
398       sp --;
399 
400       t0  = VIS_LD_U16_I(table1, 2*s0);
401       acc0 = vis_faligndata(t0, acc0);
402 
403       s0 = (mlib_s32) *sp;
404       sp --;
405 
406       t0  = VIS_LD_U16_I(table0, 2*s0);
407       acc0 = vis_faligndata(t0, acc0);
408     } else if (num == 3) {
409       s0 = (mlib_s32) *sp;
410       sp --;
411 
412       t0  = VIS_LD_U16_I(table2, 2*s0);
413       acc0 = vis_faligndata(t0, acc0);
414 
415       s0 = (mlib_s32) *sp;
416       sp --;
417 
418       t0  = VIS_LD_U16_I(table1, 2*s0);
419       acc0 = vis_faligndata(t0, acc0);
420 
421       s0 = (mlib_s32) *sp;
422       sp --;
423 
424       t0  = VIS_LD_U16_I(table0, 2*s0);
425       acc0 = vis_faligndata(t0, acc0);
426     }
427 
428     emask = vis_edge16(dp, dend);
429     vis_pst_16(acc0, dp, emask);
430   }
431 }
432 
433 /***************************************************************/
434 void mlib_v_ImageLookUp_U16_U16_3(const mlib_u16 *src,
435                                   mlib_s32       slb,
436                                   mlib_u16       *dst,
437                                   mlib_s32       dlb,
438                                   mlib_s32       xsize,
439                                   mlib_s32       ysize,
440                                   const mlib_u16 **table)
441 {
442   mlib_u16 *sl;
443   mlib_u16 *dl;
444   const mlib_u16 *tab;
445   mlib_s32 j, i;
446 
447   sl = (void *)src;
448   dl = dst;
449 
450   /* row loop */
451   for (j = 0; j &lt; ysize; j ++) {
452     mlib_u16  *sp = sl;
453     mlib_u16  *dp = dl;
454     const mlib_u16 *tab0 = &amp;table[0][0];
455     const mlib_u16 *tab1 = &amp;table[1][0];
456     const mlib_u16 *tab2 = &amp;table[2][0];
457     mlib_s32  off, size = xsize * 3;
458 
459     off = ((8 - ((mlib_addr)dp &amp; 7)) &amp; 7) &gt;&gt; 1;
460 
461     off = (off &lt; size) ? off : size;
462 
463     for (i = 0; i &lt; off - 2; i += 3, sp += 3) {
464       *dp++ = tab0[sp[0]];
465       *dp++ = tab1[sp[1]];
466       *dp++ = tab2[sp[2]];
467       size-=3;
468     }
469 
470     off -= i;
471 
472     if (off == 1) {
473       *dp++ = tab0[sp[0]];
474       tab = tab0; tab0 = tab1;
475       tab1 = tab2; tab2 = tab;
476       size--; sp++;
477     } else if (off == 2) {
478       *dp++ = tab0[sp[0]];
479       *dp++ = tab1[sp[1]];
480       tab = tab2; tab2 = tab1;
481       tab1 = tab0; tab0 = tab;
482       size-=2; sp += 2;
483     }
484 
485     if (size &gt; 0) {
486       mlib_v_ImageLookUp_U16_U16_3_D1(sp, dp, size, tab0, tab1, tab2);
487     }
488 
489     sl = (mlib_u16 *) ((mlib_u8 *) sl + slb);
490     dl = (mlib_u16 *) ((mlib_u8 *) dl + dlb);
491   }
492 }
493 
494 /***************************************************************/
    </pre>
  </body>
</html>
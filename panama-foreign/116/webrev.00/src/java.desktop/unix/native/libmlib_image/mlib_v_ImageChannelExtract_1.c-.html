<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libmlib_image/mlib_v_ImageChannelExtract_1.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 
  27 
  28 /*
  29  * FILENAME: mlib_ImageChannelExtract_1.c
  30  *
  31  * FUNCTIONS
  32  *      mlib_v_ImageChannelExtract_U8_21_D1
  33  *      mlib_v_ImageChannelExtract_U8_31_D1
  34  *      mlib_v_ImageChannelExtract_U8_41_D1
  35  *
  36  * ARGUMENT
  37  *      src    pointer to source image data
  38  *      dst    pointer to destination image data
  39  *      slb    source image line stride in bytes
  40  *      dlb   destination image line stride in bytes
  41  *      dsize  image data size in pixels
  42  *      xsize  image width in pixels
  43  *      ysize  image height in lines
  44  *      cmask channel mask
  45  *
  46  * DESCRIPTION
  47  *      Extract the one selected channel of the source image into the
  48  *      1-channel destination image.
  49  *
  50  * NOTE
  51  *      These functions are separated from mlib_ImageChannelExtract.c
  52  *      for loop unrolling and structure clarity.
  53  */
  54 
  55 #include &quot;vis_proto.h&quot;
  56 #include &quot;mlib_image.h&quot;
  57 #include &quot;mlib_v_ImageChannelExtract.h&quot;
  58 
  59 /***************************************************************/
  60 #define CHANNELEXTRACT_U8_21L(sd0, sd1, dd)                     \
  61   sda = vis_fpmerge(vis_read_hi(sd0), vis_read_hi(sd1));        \
  62   sdb = vis_fpmerge(vis_read_lo(sd0), vis_read_lo(sd1));        \
  63   sdc = vis_fpmerge(vis_read_hi(sda), vis_read_hi(sdb));        \
  64   sdd = vis_fpmerge(vis_read_lo(sda), vis_read_lo(sdb));        \
  65   dd  = vis_fpmerge(vis_read_hi(sdc), vis_read_hi(sdd))
  66 
  67 /***************************************************************/
  68 #define CHANNELEXTRACT_U8_21R(sd0, sd1, dd)                     \
  69   sda = vis_fpmerge(vis_read_hi(sd0), vis_read_hi(sd1));        \
  70   sdb = vis_fpmerge(vis_read_lo(sd0), vis_read_lo(sd1));        \
  71   sdc = vis_fpmerge(vis_read_hi(sda), vis_read_hi(sdb));        \
  72   sdd = vis_fpmerge(vis_read_lo(sda), vis_read_lo(sdb));        \
  73   dd  = vis_fpmerge(vis_read_lo(sdc), vis_read_lo(sdd))
  74 
  75 /***************************************************************/
  76 /* extract one channel from a 2-channel image.
  77  */
  78 
  79 void mlib_v_ImageChannelExtract_U8_21_D1(const mlib_u8 *src,
  80                                          mlib_u8       *dst,
  81                                          mlib_s32      dsize,
  82                                          mlib_s32      cmask)
  83 {
  84   mlib_u8 *sa, *da;
  85   mlib_u8 *dend, *dend2;                              /* end points in dst */
  86   mlib_d64 *dp;                                       /* 8-byte aligned start points in dst */
  87   mlib_d64 *sp;                                       /* 8-byte aligned start point in src */
  88   mlib_d64 sd0, sd1, sd2, sd3;                        /* 8-byte source data */
  89   mlib_d64 sda, sdb, sdc, sdd;
  90   mlib_d64 dd0, dd1;
  91   mlib_s32 soff;                                      /* offset of address in src */
  92   mlib_s32 doff;                                      /* offset of address in dst */
  93   mlib_s32 off;                                       /* offset of src over dst */
  94   mlib_s32 emask;                                     /* edge mask */
  95   mlib_s32 i, n;
  96 
  97   sa = (void *)src;
  98   da = dst;
  99 
 100   /* prepare the source address */
 101   sp = (mlib_d64 *) ((mlib_addr) sa &amp; (~7));
 102   soff = ((mlib_addr) sa &amp; 7);
 103 
 104   /* prepare the destination addresses */
 105   dp = (mlib_d64 *) ((mlib_addr) da &amp; (~7));
 106   doff = ((mlib_addr) da &amp; 7);
 107   dend = da + dsize - 1;
 108   dend2 = dend - 7;
 109 
 110   /* calculate the src&#39;s offset over dst */
 111   if (cmask == 2) {
 112     off = soff / 2 - doff;
 113   }
 114   else {
 115     off = (soff + 1) / 2 - doff;
 116   }
 117 
 118   if (((cmask == 2) &amp;&amp; (soff % 2 == 0)) || ((cmask == 1) &amp;&amp; (soff % 2 != 0))) { /* extract even bytes */
 119 
 120     if (off == 0) {                         /* src and dst have same alignment */
 121 
 122       /* generate edge mask for the start point */
 123       emask = vis_edge8(da, dend);
 124 
 125       /* load 16 bytes */
 126       sd0 = *sp++;
 127       sd1 = *sp++;
 128 
 129       /* extract, including some garbage at the start point */
 130       CHANNELEXTRACT_U8_21L(sd0, sd1, dd0);
 131 
 132       /* store 8 bytes result */
 133       vis_pst_8(dd0, dp++, emask);
 134 
 135       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
 136         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
 137 
 138         /* 8-pixel column loop, emask not needed */
 139 #pragma pipeloop(0)
 140         for (i = 0; i &lt; n; i++) {
 141           sd0 = *sp++;
 142           sd1 = *sp++;
 143           CHANNELEXTRACT_U8_21L(sd0, sd1, dd0);
 144           *dp++ = dd0;
 145         }
 146       }
 147 
 148       /* end point handling */
 149       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 150         emask = vis_edge8(dp, dend);
 151         sd0 = *sp++;
 152         sd1 = *sp++;
 153         CHANNELEXTRACT_U8_21L(sd0, sd1, dd0);
 154         vis_pst_8(dd0, dp++, emask);
 155       }
 156     }
 157     else {
 158       vis_alignaddr((void *)0, off);
 159 
 160       /* generate edge mask for the start point */
 161       emask = vis_edge8(da, dend);
 162 
 163       if (off &lt; 0) {
 164         /* load 16 bytes */
 165         sd2 = *sp++;
 166         sd3 = *sp++;
 167 
 168         /* extract and store 8 bytes */
 169         CHANNELEXTRACT_U8_21L(sd2, sd3, dd1);
 170         vis_pst_8(vis_faligndata(dd1, dd1), dp++, emask);
 171       }
 172       else {
 173         /* load 32 bytes */
 174         sd0 = *sp++;
 175         sd1 = *sp++;
 176         sd2 = *sp++;
 177         sd3 = *sp++;
 178 
 179         /* extract and store 8 bytes */
 180         CHANNELEXTRACT_U8_21L(sd0, sd1, dd0);
 181         CHANNELEXTRACT_U8_21L(sd2, sd3, dd1);
 182         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
 183       }
 184 
 185       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
 186         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
 187 
 188         /* 8-pixel column loop, emask not needed */
 189 #pragma pipeloop(0)
 190         for (i = 0; i &lt; n; i++) {
 191           dd0 = dd1;
 192           sd2 = *sp++;
 193           sd3 = *sp++;
 194           CHANNELEXTRACT_U8_21L(sd2, sd3, dd1);
 195           *dp++ = vis_faligndata(dd0, dd1);
 196         }
 197       }
 198 
 199       /* end point handling */
 200       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 201         emask = vis_edge8(dp, dend);
 202         dd0 = dd1;
 203         sd2 = *sp++;
 204         sd3 = *sp++;
 205         CHANNELEXTRACT_U8_21L(sd2, sd3, dd1);
 206         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
 207       }
 208     }
 209   }
 210   else {                                    /* extract odd bytes */
 211 
 212     if (off == 0) {                         /* src and dst have same alignment */
 213 
 214       /* generate edge mask for the start point */
 215       emask = vis_edge8(da, dend);
 216 
 217       /* load 16 bytes, don&#39;t care the garbage at the start point */
 218       sd0 = *sp++;
 219       sd1 = *sp++;
 220 
 221       /* extract and store 8 bytes */
 222       CHANNELEXTRACT_U8_21R(sd0, sd1, dd0);
 223       vis_pst_8(dd0, dp++, emask);
 224 
 225       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
 226         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
 227 
 228         /* 8-pixel column loop, emask not needed */
 229 #pragma pipeloop(0)
 230         for (i = 0; i &lt; n; i++) {
 231           sd0 = *sp++;
 232           sd1 = *sp++;
 233           CHANNELEXTRACT_U8_21R(sd0, sd1, dd0);
 234           *dp++ = dd0;
 235         }
 236       }
 237 
 238       /* end point handling */
 239       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 240         emask = vis_edge8(dp, dend);
 241         sd0 = *sp++;
 242         sd1 = *sp++;
 243         CHANNELEXTRACT_U8_21R(sd0, sd1, dd0);
 244         vis_pst_8(dd0, dp++, emask);
 245       }
 246     }
 247     else {
 248       vis_alignaddr((void *)0, off);
 249 
 250       /* generate edge mask for the start point */
 251       emask = vis_edge8(da, dend);
 252 
 253       if (off &lt; 0) {
 254         /* load 16 bytes */
 255         sd2 = *sp++;
 256         sd3 = *sp++;
 257 
 258         /* extract and store 8 bytes */
 259         CHANNELEXTRACT_U8_21R(sd2, sd3, dd1);
 260         vis_pst_8(vis_faligndata(dd1, dd1), dp++, emask);
 261       }
 262       else {
 263         /* load 32 bytes */
 264         sd0 = *sp++;
 265         sd1 = *sp++;
 266         sd2 = *sp++;
 267         sd3 = *sp++;
 268 
 269         /* extract and store 8 bytes */
 270         CHANNELEXTRACT_U8_21R(sd0, sd1, dd0);
 271         CHANNELEXTRACT_U8_21R(sd2, sd3, dd1);
 272         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
 273       }
 274 
 275       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
 276         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
 277 
 278         /* 8-pixel column loop, emask not needed */
 279 #pragma pipeloop(0)
 280         for (i = 0; i &lt; n; i++) {
 281           dd0 = dd1;
 282           sd2 = *sp++;
 283           sd3 = *sp++;
 284           CHANNELEXTRACT_U8_21R(sd2, sd3, dd1);
 285           *dp++ = vis_faligndata(dd0, dd1);
 286         }
 287       }
 288 
 289       /* end point handling */
 290       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 291         emask = vis_edge8(dp, dend);
 292         dd0 = dd1;
 293         sd2 = *sp++;
 294         sd3 = *sp++;
 295         CHANNELEXTRACT_U8_21R(sd2, sd3, dd1);
 296         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
 297       }
 298     }
 299   }
 300 }
 301 
 302 /***************************************************************/
 303 #define CHANNELEXTRACT_U8_31L(sd0, sd1, sd2, dd)                \
 304   sda = vis_fpmerge(vis_read_hi(sd0), vis_read_lo(sd1));        \
 305   sdb = vis_fpmerge(vis_read_lo(sd0), vis_read_hi(sd2));        \
 306   sdc = vis_fpmerge(vis_read_hi(sd1), vis_read_lo(sd2));        \
 307   sdd = vis_fpmerge(vis_read_hi(sda), vis_read_lo(sdb));        \
 308   sde = vis_fpmerge(vis_read_lo(sda), vis_read_hi(sdc));        \
 309   dd  = vis_fpmerge(vis_read_hi(sdd), vis_read_lo(sde))
 310 
 311 /***************************************************************/
 312 #define CHANNELEXTRACT_U8_31M(sd0, sd1, sd2, dd)                \
 313   sda = vis_fpmerge(vis_read_hi(sd0), vis_read_lo(sd1));        \
 314   sdb = vis_fpmerge(vis_read_lo(sd0), vis_read_hi(sd2));        \
 315   sdc = vis_fpmerge(vis_read_hi(sd1), vis_read_lo(sd2));        \
 316   sdd = vis_fpmerge(vis_read_hi(sda), vis_read_lo(sdb));        \
 317   sde = vis_fpmerge(vis_read_hi(sdb), vis_read_lo(sdc));        \
 318   dd  = vis_fpmerge(vis_read_lo(sdd), vis_read_hi(sde))
 319 
 320 /***************************************************************/
 321 #define CHANNELEXTRACT_U8_31R(sd0, sd1, sd2, dd)                \
 322   sda = vis_fpmerge(vis_read_hi(sd0), vis_read_lo(sd1));        \
 323   sdb = vis_fpmerge(vis_read_lo(sd0), vis_read_hi(sd2));        \
 324   sdc = vis_fpmerge(vis_read_hi(sd1), vis_read_lo(sd2));        \
 325   sdd = vis_fpmerge(vis_read_lo(sda), vis_read_hi(sdc));        \
 326   sde = vis_fpmerge(vis_read_hi(sdb), vis_read_lo(sdc));        \
 327   dd  = vis_fpmerge(vis_read_hi(sdd), vis_read_lo(sde))
 328 
 329 /***************************************************************/
 330 void mlib_v_ImageChannelExtract_U8_31_D1(const mlib_u8 *src,
 331                                          mlib_u8       *dst,
 332                                          mlib_s32      dsize,
 333                                          mlib_s32      cmask)
 334 {
 335   mlib_u8 *sa, *da;
 336   mlib_u8 *dend, *dend2;                              /* end points in dst */
 337   mlib_d64 *dp;                                       /* 8-byte aligned start points in dst */
 338   mlib_d64 *sp;                                       /* 8-byte aligned start point in src */
 339   mlib_d64 sd0, sd1, sd2;                             /* 8-byte source data */
 340   mlib_d64 sd3, sd4, sd5;
 341   mlib_d64 sda, sdb, sdc, sdd, sde;
 342   mlib_d64 dd0, dd1;
 343   mlib_s32 soff;                                      /* offset of address in src */
 344   mlib_s32 doff;                                      /* offset of address in dst */
 345   mlib_s32 off;                                       /* offset of src over dst */
 346   mlib_s32 emask;                                     /* edge mask */
 347   mlib_s32 i, n;
 348 
 349   sa = (void *)src;
 350   da = dst;
 351 
 352   /* prepare the source address */
 353   sp = (mlib_d64 *) ((mlib_addr) sa &amp; (~7));
 354   soff = ((mlib_addr) sa &amp; 7);
 355 
 356   /* prepare the destination addresses */
 357   dp = (mlib_d64 *) ((mlib_addr) da &amp; (~7));
 358   doff = ((mlib_addr) da &amp; 7);
 359   dend = da + dsize - 1;
 360   dend2 = dend - 7;
 361 
 362   /* calculate the src&#39;s offset over dst */
 363   if (cmask == 4) {
 364     off = soff / 3 - doff;
 365   }
 366   else if (cmask == 2) {
 367     off = (soff + 1) / 3 - doff;
 368   }
 369   else {
 370     off = (soff + 2) / 3 - doff;
 371   }
 372 
 373   if (((cmask == 4) &amp;&amp; (soff % 3 == 0)) ||
 374       ((cmask == 2) &amp;&amp; (soff % 3 == 2)) ||
 375       ((cmask == 1) &amp;&amp; (soff % 3 == 1))) { /* extract left channel */
 376 
 377     if (off == 0) {                         /* src and dst have same alignment */
 378 
 379       /* generate edge mask for the start point */
 380       emask = vis_edge8(da, dend);
 381 
 382       /* load 16 bytes */
 383       sd0 = *sp++;
 384       sd1 = *sp++;
 385       sd2 = *sp++;
 386 
 387       /* extract, including some garbage at the start point */
 388       CHANNELEXTRACT_U8_31L(sd0, sd1, sd2, dd0);
 389 
 390       /* store 8 bytes result */
 391       vis_pst_8(dd0, dp++, emask);
 392 
 393       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
 394         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
 395 
 396         /* 8-pixel column loop, emask not needed */
 397 #pragma pipeloop(0)
 398         for (i = 0; i &lt; n; i++) {
 399           sd0 = *sp++;
 400           sd1 = *sp++;
 401           sd2 = *sp++;
 402           CHANNELEXTRACT_U8_31L(sd0, sd1, sd2, dd0);
 403           *dp++ = dd0;
 404         }
 405       }
 406 
 407       /* end point handling */
 408       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 409         emask = vis_edge8(dp, dend);
 410         sd0 = *sp++;
 411         sd1 = *sp++;
 412         sd2 = *sp++;
 413         CHANNELEXTRACT_U8_31L(sd0, sd1, sd2, dd0);
 414         vis_pst_8(dd0, dp++, emask);
 415       }
 416     }
 417     else {
 418       vis_alignaddr((void *)0, off);
 419 
 420       /* generate edge mask for the start point */
 421       emask = vis_edge8(da, dend);
 422 
 423       if (off &lt; 0) {
 424         /* load 24 bytes */
 425         sd3 = *sp++;
 426         sd4 = *sp++;
 427         sd5 = *sp++;
 428 
 429         /* extract and store 8 bytes */
 430         CHANNELEXTRACT_U8_31L(sd3, sd4, sd5, dd1);
 431         vis_pst_8(vis_faligndata(dd1, dd1), dp++, emask);
 432       }
 433       else {
 434         /* load 48 bytes */
 435         sd0 = *sp++;
 436         sd1 = *sp++;
 437         sd2 = *sp++;
 438         sd3 = *sp++;
 439         sd4 = *sp++;
 440         sd5 = *sp++;
 441 
 442         /* extract and store 8 bytes */
 443         CHANNELEXTRACT_U8_31L(sd0, sd1, sd2, dd0);
 444         CHANNELEXTRACT_U8_31L(sd3, sd4, sd5, dd1);
 445         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
 446       }
 447 
 448       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
 449         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
 450 
 451         /* 8-pixel column loop, emask not needed */
 452 #pragma pipeloop(0)
 453         for (i = 0; i &lt; n; i++) {
 454           dd0 = dd1;
 455           sd3 = *sp++;
 456           sd4 = *sp++;
 457           sd5 = *sp++;
 458           CHANNELEXTRACT_U8_31L(sd3, sd4, sd5, dd1);
 459           *dp++ = vis_faligndata(dd0, dd1);
 460         }
 461       }
 462 
 463       /* end point handling */
 464       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 465         emask = vis_edge8(dp, dend);
 466         dd0 = dd1;
 467         sd3 = *sp++;
 468         sd4 = *sp++;
 469         sd5 = *sp++;
 470         CHANNELEXTRACT_U8_31L(sd3, sd4, sd5, dd1);
 471         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
 472       }
 473     }
 474   }
 475   else if (((cmask == 4) &amp;&amp; (soff % 3 == 1)) ||
 476            ((cmask == 2) &amp;&amp; (soff % 3 == 0)) ||
 477            ((cmask == 1) &amp;&amp; (soff % 3 == 2))) {
 478     /* extract middle channel */
 479 
 480     if (off == 0) {                         /* src and dst have same alignment */
 481 
 482       /* generate edge mask for the start point */
 483       emask = vis_edge8(da, dend);
 484 
 485       /* load 16 bytes */
 486       sd0 = *sp++;
 487       sd1 = *sp++;
 488       sd2 = *sp++;
 489 
 490       /* extract, including some garbage at the start point */
 491       CHANNELEXTRACT_U8_31M(sd0, sd1, sd2, dd0);
 492 
 493       /* store 8 bytes result */
 494       vis_pst_8(dd0, dp++, emask);
 495 
 496       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
 497         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
 498 
 499         /* 8-pixel column loop, emask not needed */
 500 #pragma pipeloop(0)
 501         for (i = 0; i &lt; n; i++) {
 502           sd0 = *sp++;
 503           sd1 = *sp++;
 504           sd2 = *sp++;
 505           CHANNELEXTRACT_U8_31M(sd0, sd1, sd2, dd0);
 506           *dp++ = dd0;
 507         }
 508       }
 509 
 510       /* end point handling */
 511       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 512         emask = vis_edge8(dp, dend);
 513         sd0 = *sp++;
 514         sd1 = *sp++;
 515         sd2 = *sp++;
 516         CHANNELEXTRACT_U8_31M(sd0, sd1, sd2, dd0);
 517         vis_pst_8(dd0, dp++, emask);
 518       }
 519     }
 520     else {
 521       vis_alignaddr((void *)0, off);
 522 
 523       /* generate edge mask for the start point */
 524       emask = vis_edge8(da, dend);
 525 
 526       if (off &lt; 0) {
 527         /* load 24 bytes */
 528         sd3 = *sp++;
 529         sd4 = *sp++;
 530         sd5 = *sp++;
 531 
 532         /* extract and store 8 bytes */
 533         CHANNELEXTRACT_U8_31M(sd3, sd4, sd5, dd1);
 534         vis_pst_8(vis_faligndata(dd1, dd1), dp++, emask);
 535       }
 536       else {
 537         /* load 48 bytes */
 538         sd0 = *sp++;
 539         sd1 = *sp++;
 540         sd2 = *sp++;
 541         sd3 = *sp++;
 542         sd4 = *sp++;
 543         sd5 = *sp++;
 544 
 545         /* extract and store 8 bytes */
 546         CHANNELEXTRACT_U8_31M(sd0, sd1, sd2, dd0);
 547         CHANNELEXTRACT_U8_31M(sd3, sd4, sd5, dd1);
 548         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
 549       }
 550 
 551       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
 552         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
 553 
 554         /* 8-pixel column loop, emask not needed */
 555 #pragma pipeloop(0)
 556         for (i = 0; i &lt; n; i++) {
 557           dd0 = dd1;
 558           sd3 = *sp++;
 559           sd4 = *sp++;
 560           sd5 = *sp++;
 561           CHANNELEXTRACT_U8_31M(sd3, sd4, sd5, dd1);
 562           *dp++ = vis_faligndata(dd0, dd1);
 563         }
 564       }
 565 
 566       /* end point handling */
 567       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 568         emask = vis_edge8(dp, dend);
 569         dd0 = dd1;
 570         sd3 = *sp++;
 571         sd4 = *sp++;
 572         sd5 = *sp++;
 573         CHANNELEXTRACT_U8_31M(sd3, sd4, sd5, dd1);
 574         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
 575       }
 576     }
 577   }
 578   else {                                    /* extract right channel */
 579 
 580     if (off == 0) {                         /* src and dst have same alignment */
 581 
 582       /* generate edge mask for the start point */
 583       emask = vis_edge8(da, dend);
 584 
 585       /* load 16 bytes */
 586       sd0 = *sp++;
 587       sd1 = *sp++;
 588       sd2 = *sp++;
 589 
 590       /* extract, including some garbage at the start point */
 591       CHANNELEXTRACT_U8_31R(sd0, sd1, sd2, dd0);
 592 
 593       /* store 8 bytes result */
 594       vis_pst_8(dd0, dp++, emask);
 595 
 596       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
 597         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
 598 
 599         /* 8-pixel column loop, emask not needed */
 600 #pragma pipeloop(0)
 601         for (i = 0; i &lt; n; i++) {
 602           sd0 = *sp++;
 603           sd1 = *sp++;
 604           sd2 = *sp++;
 605           CHANNELEXTRACT_U8_31R(sd0, sd1, sd2, dd0);
 606           *dp++ = dd0;
 607         }
 608       }
 609 
 610       /* end point handling */
 611       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 612         emask = vis_edge8(dp, dend);
 613         sd0 = *sp++;
 614         sd1 = *sp++;
 615         sd2 = *sp++;
 616         CHANNELEXTRACT_U8_31R(sd0, sd1, sd2, dd0);
 617         vis_pst_8(dd0, dp++, emask);
 618       }
 619     }
 620     else {
 621       vis_alignaddr((void *)0, off);
 622 
 623       /* generate edge mask for the start point */
 624       emask = vis_edge8(da, dend);
 625 
 626       if (off &lt; 0) {
 627         /* load 24 bytes */
 628         sd3 = *sp++;
 629         sd4 = *sp++;
 630         sd5 = *sp++;
 631 
 632         /* extract and store 8 bytes */
 633         CHANNELEXTRACT_U8_31R(sd3, sd4, sd5, dd1);
 634         vis_pst_8(vis_faligndata(dd1, dd1), dp++, emask);
 635       }
 636       else {
 637         /* load 48 bytes */
 638         sd0 = *sp++;
 639         sd1 = *sp++;
 640         sd2 = *sp++;
 641         sd3 = *sp++;
 642         sd4 = *sp++;
 643         sd5 = *sp++;
 644 
 645         /* extract and store 8 bytes */
 646         CHANNELEXTRACT_U8_31R(sd0, sd1, sd2, dd0);
 647         CHANNELEXTRACT_U8_31R(sd3, sd4, sd5, dd1);
 648         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
 649       }
 650 
 651       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
 652         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
 653 
 654         /* 8-pixel column loop, emask not needed */
 655 #pragma pipeloop(0)
 656         for (i = 0; i &lt; n; i++) {
 657           dd0 = dd1;
 658           sd3 = *sp++;
 659           sd4 = *sp++;
 660           sd5 = *sp++;
 661           CHANNELEXTRACT_U8_31R(sd3, sd4, sd5, dd1);
 662           *dp++ = vis_faligndata(dd0, dd1);
 663         }
 664       }
 665 
 666       /* end point handling */
 667       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 668         emask = vis_edge8(dp, dend);
 669         dd0 = dd1;
 670         sd3 = *sp++;
 671         sd4 = *sp++;
 672         sd5 = *sp++;
 673         CHANNELEXTRACT_U8_31R(sd3, sd4, sd5, dd1);
 674         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
 675       }
 676     }
 677   }
 678 }
 679 
 680 /***************************************************************/
 681 #define CHANNELEXTRACT_U8_41L(sd0, sd1, sd2, sd3, dd)           \
 682   sda = vis_fpmerge(vis_read_hi(sd0), vis_read_hi(sd2));        \
 683   sdb = vis_fpmerge(vis_read_lo(sd0), vis_read_lo(sd2));        \
 684   sdc = vis_fpmerge(vis_read_hi(sd1), vis_read_hi(sd3));        \
 685   sdd = vis_fpmerge(vis_read_lo(sd1), vis_read_lo(sd3));        \
 686   sde = vis_fpmerge(vis_read_hi(sda), vis_read_hi(sdc));        \
 687   sdf = vis_fpmerge(vis_read_hi(sdb), vis_read_hi(sdd));        \
 688   dd  = vis_fpmerge(vis_read_hi(sde), vis_read_hi(sdf))
 689 
 690 /***************************************************************/
 691 #define CHANNELEXTRACT_U8_41ML(sd0, sd1, sd2, sd3, dd)          \
 692   sda = vis_fpmerge(vis_read_hi(sd0), vis_read_hi(sd2));        \
 693   sdb = vis_fpmerge(vis_read_lo(sd0), vis_read_lo(sd2));        \
 694   sdc = vis_fpmerge(vis_read_hi(sd1), vis_read_hi(sd3));        \
 695   sdd = vis_fpmerge(vis_read_lo(sd1), vis_read_lo(sd3));        \
 696   sde = vis_fpmerge(vis_read_hi(sda), vis_read_hi(sdc));        \
 697   sdf = vis_fpmerge(vis_read_hi(sdb), vis_read_hi(sdd));        \
 698   dd  = vis_fpmerge(vis_read_lo(sde), vis_read_lo(sdf))
 699 
 700 /***************************************************************/
 701 #define CHANNELEXTRACT_U8_41MR(sd0, sd1, sd2, sd3, dd)          \
 702   sda = vis_fpmerge(vis_read_hi(sd0), vis_read_hi(sd2));        \
 703   sdb = vis_fpmerge(vis_read_lo(sd0), vis_read_lo(sd2));        \
 704   sdc = vis_fpmerge(vis_read_hi(sd1), vis_read_hi(sd3));        \
 705   sdd = vis_fpmerge(vis_read_lo(sd1), vis_read_lo(sd3));        \
 706   sde = vis_fpmerge(vis_read_lo(sda), vis_read_lo(sdc));        \
 707   sdf = vis_fpmerge(vis_read_lo(sdb), vis_read_lo(sdd));        \
 708   dd  = vis_fpmerge(vis_read_hi(sde), vis_read_hi(sdf))
 709 
 710 /***************************************************************/
 711 #define CHANNELEXTRACT_U8_41R(sd0, sd1, sd2, sd3, dd)           \
 712   sda = vis_fpmerge(vis_read_hi(sd0), vis_read_hi(sd2));        \
 713   sdb = vis_fpmerge(vis_read_lo(sd0), vis_read_lo(sd2));        \
 714   sdc = vis_fpmerge(vis_read_hi(sd1), vis_read_hi(sd3));        \
 715   sdd = vis_fpmerge(vis_read_lo(sd1), vis_read_lo(sd3));        \
 716   sde = vis_fpmerge(vis_read_lo(sda), vis_read_lo(sdc));        \
 717   sdf = vis_fpmerge(vis_read_lo(sdb), vis_read_lo(sdd));        \
 718   dd  = vis_fpmerge(vis_read_lo(sde), vis_read_lo(sdf))
 719 
 720 /***************************************************************/
 721 void mlib_v_ImageChannelExtract_U8_41_D1(const mlib_u8 *src,
 722                                          mlib_u8       *dst,
 723                                          mlib_s32      dsize,
 724                                          mlib_s32      cmask)
 725 {
 726   mlib_u8 *sa, *da;
 727   mlib_u8 *dend, *dend2;                              /* end points in dst */
 728   mlib_d64 *dp;                                       /* 8-byte aligned start points in dst */
 729   mlib_d64 *sp;                                       /* 8-byte aligned start point in src */
 730   mlib_d64 sd0, sd1, sd2, sd3;                        /* 8-byte source data */
 731   mlib_d64 sd4, sd5, sd6, sd7;
 732   mlib_d64 sda, sdb, sdc, sdd;
 733   mlib_d64 sde, sdf;
 734   mlib_d64 dd0, dd1;
 735   mlib_s32 soff;                                      /* offset of address in src */
 736   mlib_s32 doff;                                      /* offset of address in dst */
 737   mlib_s32 off;                                       /* offset of src over dst */
 738   mlib_s32 emask;                                     /* edge mask */
 739   mlib_s32 i, n;
 740 
 741   sa = (void *)src;
 742   da = dst;
 743 
 744   /* prepare the source address */
 745   sp = (mlib_d64 *) ((mlib_addr) sa &amp; (~7));
 746   soff = ((mlib_addr) sa &amp; 7);
 747 
 748   /* prepare the destination addresses */
 749   dp = (mlib_d64 *) ((mlib_addr) da &amp; (~7));
 750   doff = ((mlib_addr) da &amp; 7);
 751   dend = da + dsize - 1;
 752   dend2 = dend - 7;
 753 
 754   /* calculate the src&#39;s offset over dst */
 755   if (cmask == 8) {
 756     off = soff / 4 - doff;
 757   }
 758   else if (cmask == 4) {
 759     off = (soff + 1) / 4 - doff;
 760   }
 761   else if (cmask == 2) {
 762     off = (soff + 2) / 4 - doff;
 763   }
 764   else {
 765     off = (soff + 3) / 4 - doff;
 766   }
 767 
 768   if (((cmask == 8) &amp;&amp; (soff % 4 == 0)) ||
 769       ((cmask == 4) &amp;&amp; (soff % 4 == 3)) ||
 770       ((cmask == 2) &amp;&amp; (soff % 4 == 2)) ||
 771       ((cmask == 1) &amp;&amp; (soff % 4 == 1))) { /* extract left channel */
 772 
 773     if (off == 0) {                         /* src and dst have same alignment */
 774 
 775       /* generate edge mask for the start point */
 776       emask = vis_edge8(da, dend);
 777 
 778       /* load 16 bytes */
 779       sd0 = *sp++;
 780       sd1 = *sp++;
 781       sd2 = *sp++;
 782       sd3 = *sp++;
 783 
 784       /* extract, including some garbage at the start point */
 785       CHANNELEXTRACT_U8_41L(sd0, sd1, sd2, sd3, dd0);
 786 
 787       /* store 8 bytes result */
 788       vis_pst_8(dd0, dp++, emask);
 789 
 790       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
 791         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
 792 
 793         /* 8-pixel column loop, emask not needed */
 794 #pragma pipeloop(0)
 795         for (i = 0; i &lt; n; i++) {
 796           sd0 = *sp++;
 797           sd1 = *sp++;
 798           sd2 = *sp++;
 799           sd3 = *sp++;
 800           CHANNELEXTRACT_U8_41L(sd0, sd1, sd2, sd3, dd0);
 801           *dp++ = dd0;
 802         }
 803       }
 804 
 805       /* end point handling */
 806       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 807         emask = vis_edge8(dp, dend);
 808         sd0 = *sp++;
 809         sd1 = *sp++;
 810         sd2 = *sp++;
 811         sd3 = *sp++;
 812         CHANNELEXTRACT_U8_41L(sd0, sd1, sd2, sd3, dd0);
 813         vis_pst_8(dd0, dp++, emask);
 814       }
 815     }
 816     else {
 817       vis_alignaddr((void *)0, off);
 818 
 819       /* generate edge mask for the start point */
 820       emask = vis_edge8(da, dend);
 821 
 822       if (off &lt; 0) {
 823         /* load 24 bytes */
 824         sd4 = *sp++;
 825         sd5 = *sp++;
 826         sd6 = *sp++;
 827         sd7 = *sp++;
 828 
 829         /* extract and store 8 bytes */
 830         CHANNELEXTRACT_U8_41L(sd4, sd5, sd6, sd7, dd1);
 831         vis_pst_8(vis_faligndata(dd1, dd1), dp++, emask);
 832       }
 833       else {
 834         /* load 48 bytes */
 835         sd0 = *sp++;
 836         sd1 = *sp++;
 837         sd2 = *sp++;
 838         sd3 = *sp++;
 839         sd4 = *sp++;
 840         sd5 = *sp++;
 841         sd6 = *sp++;
 842         sd7 = *sp++;
 843 
 844         /* extract and store 8 bytes */
 845         CHANNELEXTRACT_U8_41L(sd0, sd1, sd2, sd3, dd0);
 846         CHANNELEXTRACT_U8_41L(sd4, sd5, sd6, sd7, dd1);
 847         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
 848       }
 849 
 850       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
 851         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
 852 
 853         /* 8-pixel column loop, emask not needed */
 854 #pragma pipeloop(0)
 855         for (i = 0; i &lt; n; i++) {
 856           dd0 = dd1;
 857           sd4 = *sp++;
 858           sd5 = *sp++;
 859           sd6 = *sp++;
 860           sd7 = *sp++;
 861           CHANNELEXTRACT_U8_41L(sd4, sd5, sd6, sd7, dd1);
 862           *dp++ = vis_faligndata(dd0, dd1);
 863         }
 864       }
 865 
 866       /* end point handling */
 867       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 868         emask = vis_edge8(dp, dend);
 869         dd0 = dd1;
 870         sd4 = *sp++;
 871         sd5 = *sp++;
 872         sd6 = *sp++;
 873         sd7 = *sp++;
 874         CHANNELEXTRACT_U8_41L(sd4, sd5, sd6, sd7, dd1);
 875         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
 876       }
 877     }
 878   }
 879   else if (((cmask == 8) &amp;&amp; (soff % 4 == 1)) ||
 880            ((cmask == 4) &amp;&amp; (soff % 4 == 0)) ||
 881            ((cmask == 2) &amp;&amp; (soff % 4 == 3)) ||
 882            ((cmask == 1) &amp;&amp; (soff % 4 == 2))) {
 883     /* extract middle left channel */
 884 
 885     if (off == 0) {                         /* src and dst have same alignment */
 886 
 887       /* generate edge mask for the start point */
 888       emask = vis_edge8(da, dend);
 889 
 890       /* load 16 bytes */
 891       sd0 = *sp++;
 892       sd1 = *sp++;
 893       sd2 = *sp++;
 894       sd3 = *sp++;
 895 
 896       /* extract, including some garbage at the start point */
 897       CHANNELEXTRACT_U8_41ML(sd0, sd1, sd2, sd3, dd0);
 898 
 899       /* store 8 bytes result */
 900       vis_pst_8(dd0, dp++, emask);
 901 
 902       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
 903         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
 904 
 905         /* 8-pixel column loop, emask not needed */
 906 #pragma pipeloop(0)
 907         for (i = 0; i &lt; n; i++) {
 908           sd0 = *sp++;
 909           sd1 = *sp++;
 910           sd2 = *sp++;
 911           sd3 = *sp++;
 912           CHANNELEXTRACT_U8_41ML(sd0, sd1, sd2, sd3, dd0);
 913           *dp++ = dd0;
 914         }
 915       }
 916 
 917       /* end point handling */
 918       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 919         emask = vis_edge8(dp, dend);
 920         sd0 = *sp++;
 921         sd1 = *sp++;
 922         sd2 = *sp++;
 923         sd3 = *sp++;
 924         CHANNELEXTRACT_U8_41ML(sd0, sd1, sd2, sd3, dd0);
 925         vis_pst_8(dd0, dp++, emask);
 926       }
 927     }
 928     else {
 929       vis_alignaddr((void *)0, off);
 930 
 931       /* generate edge mask for the start point */
 932       emask = vis_edge8(da, dend);
 933 
 934       if (off &lt; 0) {
 935         /* load 24 bytes */
 936         sd4 = *sp++;
 937         sd5 = *sp++;
 938         sd6 = *sp++;
 939         sd7 = *sp++;
 940 
 941         /* extract and store 8 bytes */
 942         CHANNELEXTRACT_U8_41ML(sd4, sd5, sd6, sd7, dd1);
 943         vis_pst_8(vis_faligndata(dd1, dd1), dp++, emask);
 944       }
 945       else {
 946         /* load 48 bytes */
 947         sd0 = *sp++;
 948         sd1 = *sp++;
 949         sd2 = *sp++;
 950         sd3 = *sp++;
 951         sd4 = *sp++;
 952         sd5 = *sp++;
 953         sd6 = *sp++;
 954         sd7 = *sp++;
 955 
 956         /* extract and store 8 bytes */
 957         CHANNELEXTRACT_U8_41ML(sd0, sd1, sd2, sd3, dd0);
 958         CHANNELEXTRACT_U8_41ML(sd4, sd5, sd6, sd7, dd1);
 959         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
 960       }
 961 
 962       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
 963         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
 964 
 965         /* 8-pixel column loop, emask not needed */
 966 #pragma pipeloop(0)
 967         for (i = 0; i &lt; n; i++) {
 968           dd0 = dd1;
 969           sd4 = *sp++;
 970           sd5 = *sp++;
 971           sd6 = *sp++;
 972           sd7 = *sp++;
 973           CHANNELEXTRACT_U8_41ML(sd4, sd5, sd6, sd7, dd1);
 974           *dp++ = vis_faligndata(dd0, dd1);
 975         }
 976       }
 977 
 978       /* end point handling */
 979       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
 980         emask = vis_edge8(dp, dend);
 981         dd0 = dd1;
 982         sd4 = *sp++;
 983         sd5 = *sp++;
 984         sd6 = *sp++;
 985         sd7 = *sp++;
 986         CHANNELEXTRACT_U8_41ML(sd4, sd5, sd6, sd7, dd1);
 987         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
 988       }
 989     }
 990   }
 991   else if (((cmask == 8) &amp;&amp; (soff % 4 == 2)) ||
 992            ((cmask == 4) &amp;&amp; (soff % 4 == 1)) ||
 993            ((cmask == 2) &amp;&amp; (soff % 4 == 0)) ||
 994            ((cmask == 1) &amp;&amp; (soff % 4 == 3))) { /* extract middle right channel */
 995 
 996     if (off == 0) {                         /* src and dst have same alignment */
 997 
 998       /* generate edge mask for the start point */
 999       emask = vis_edge8(da, dend);
1000 
1001       /* load 16 bytes */
1002       sd0 = *sp++;
1003       sd1 = *sp++;
1004       sd2 = *sp++;
1005       sd3 = *sp++;
1006 
1007       /* extract, including some garbage at the start point */
1008       CHANNELEXTRACT_U8_41MR(sd0, sd1, sd2, sd3, dd0);
1009 
1010       /* store 8 bytes result */
1011       vis_pst_8(dd0, dp++, emask);
1012 
1013       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
1014         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
1015 
1016         /* 8-pixel column loop, emask not needed */
1017 #pragma pipeloop(0)
1018         for (i = 0; i &lt; n; i++) {
1019           sd0 = *sp++;
1020           sd1 = *sp++;
1021           sd2 = *sp++;
1022           sd3 = *sp++;
1023           CHANNELEXTRACT_U8_41MR(sd0, sd1, sd2, sd3, dd0);
1024           *dp++ = dd0;
1025         }
1026       }
1027 
1028       /* end point handling */
1029       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
1030         emask = vis_edge8(dp, dend);
1031         sd0 = *sp++;
1032         sd1 = *sp++;
1033         sd2 = *sp++;
1034         sd3 = *sp++;
1035         CHANNELEXTRACT_U8_41MR(sd0, sd1, sd2, sd3, dd0);
1036         vis_pst_8(dd0, dp++, emask);
1037       }
1038     }
1039     else {
1040       vis_alignaddr((void *)0, off);
1041 
1042       /* generate edge mask for the start point */
1043       emask = vis_edge8(da, dend);
1044 
1045       if (off &lt; 0) {
1046         /* load 24 bytes */
1047         sd4 = *sp++;
1048         sd5 = *sp++;
1049         sd6 = *sp++;
1050         sd7 = *sp++;
1051 
1052         /* extract and store 8 bytes */
1053         CHANNELEXTRACT_U8_41MR(sd4, sd5, sd6, sd7, dd1);
1054         vis_pst_8(vis_faligndata(dd1, dd1), dp++, emask);
1055       }
1056       else {
1057         /* load 48 bytes */
1058         sd0 = *sp++;
1059         sd1 = *sp++;
1060         sd2 = *sp++;
1061         sd3 = *sp++;
1062         sd4 = *sp++;
1063         sd5 = *sp++;
1064         sd6 = *sp++;
1065         sd7 = *sp++;
1066 
1067         /* extract and store 8 bytes */
1068         CHANNELEXTRACT_U8_41MR(sd0, sd1, sd2, sd3, dd0);
1069         CHANNELEXTRACT_U8_41MR(sd4, sd5, sd6, sd7, dd1);
1070         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
1071       }
1072 
1073       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
1074         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
1075 
1076         /* 8-pixel column loop, emask not needed */
1077 #pragma pipeloop(0)
1078         for (i = 0; i &lt; n; i++) {
1079           dd0 = dd1;
1080           sd4 = *sp++;
1081           sd5 = *sp++;
1082           sd6 = *sp++;
1083           sd7 = *sp++;
1084           CHANNELEXTRACT_U8_41MR(sd4, sd5, sd6, sd7, dd1);
1085           *dp++ = vis_faligndata(dd0, dd1);
1086         }
1087       }
1088 
1089       /* end point handling */
1090       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
1091         emask = vis_edge8(dp, dend);
1092         dd0 = dd1;
1093         sd4 = *sp++;
1094         sd5 = *sp++;
1095         sd6 = *sp++;
1096         sd7 = *sp++;
1097         CHANNELEXTRACT_U8_41MR(sd4, sd5, sd6, sd7, dd1);
1098         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
1099       }
1100     }
1101   }
1102   else {                                    /* extract right channel */
1103     if (off == 0) {                         /* src and dst have same alignment */
1104 
1105       /* generate edge mask for the start point */
1106       emask = vis_edge8(da, dend);
1107 
1108       /* load 16 bytes */
1109       sd0 = *sp++;
1110       sd1 = *sp++;
1111       sd2 = *sp++;
1112       sd3 = *sp++;
1113 
1114       /* extract, including some garbage at the start point */
1115       CHANNELEXTRACT_U8_41R(sd0, sd1, sd2, sd3, dd0);
1116 
1117       /* store 8 bytes result */
1118       vis_pst_8(dd0, dp++, emask);
1119 
1120       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
1121         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
1122 
1123         /* 8-pixel column loop, emask not needed */
1124 #pragma pipeloop(0)
1125         for (i = 0; i &lt; n; i++) {
1126           sd0 = *sp++;
1127           sd1 = *sp++;
1128           sd2 = *sp++;
1129           sd3 = *sp++;
1130           CHANNELEXTRACT_U8_41R(sd0, sd1, sd2, sd3, dd0);
1131           *dp++ = dd0;
1132         }
1133       }
1134 
1135       /* end point handling */
1136       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
1137         emask = vis_edge8(dp, dend);
1138         sd0 = *sp++;
1139         sd1 = *sp++;
1140         sd2 = *sp++;
1141         sd3 = *sp++;
1142         CHANNELEXTRACT_U8_41R(sd0, sd1, sd2, sd3, dd0);
1143         vis_pst_8(dd0, dp++, emask);
1144       }
1145     }
1146     else {
1147       vis_alignaddr((void *)0, off);
1148 
1149       /* generate edge mask for the start point */
1150       emask = vis_edge8(da, dend);
1151 
1152       if (off &lt; 0) {
1153         /* load 24 bytes */
1154         sd4 = *sp++;
1155         sd5 = *sp++;
1156         sd6 = *sp++;
1157         sd7 = *sp++;
1158 
1159         /* extract and store 8 bytes */
1160         CHANNELEXTRACT_U8_41R(sd4, sd5, sd6, sd7, dd1);
1161         vis_pst_8(vis_faligndata(dd1, dd1), dp++, emask);
1162       }
1163       else {
1164         /* load 48 bytes */
1165         sd0 = *sp++;
1166         sd1 = *sp++;
1167         sd2 = *sp++;
1168         sd3 = *sp++;
1169         sd4 = *sp++;
1170         sd5 = *sp++;
1171         sd6 = *sp++;
1172         sd7 = *sp++;
1173 
1174         /* extract and store 8 bytes */
1175         CHANNELEXTRACT_U8_41R(sd0, sd1, sd2, sd3, dd0);
1176         CHANNELEXTRACT_U8_41R(sd4, sd5, sd6, sd7, dd1);
1177         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
1178       }
1179 
1180       if ((mlib_addr) dp &lt;= (mlib_addr) dend2) {
1181         n = ((mlib_u8 *) dend2 - (mlib_u8 *) dp) / 8 + 1;
1182 
1183         /* 8-pixel column loop, emask not needed */
1184 #pragma pipeloop(0)
1185         for (i = 0; i &lt; n; i++) {
1186           dd0 = dd1;
1187           sd4 = *sp++;
1188           sd5 = *sp++;
1189           sd6 = *sp++;
1190           sd7 = *sp++;
1191           CHANNELEXTRACT_U8_41R(sd4, sd5, sd6, sd7, dd1);
1192           *dp++ = vis_faligndata(dd0, dd1);
1193         }
1194       }
1195 
1196       /* end point handling */
1197       if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
1198         emask = vis_edge8(dp, dend);
1199         dd0 = dd1;
1200         sd4 = *sp++;
1201         sd5 = *sp++;
1202         sd6 = *sp++;
1203         sd7 = *sp++;
1204         CHANNELEXTRACT_U8_41R(sd4, sd5, sd6, sd7, dd1);
1205         vis_pst_8(vis_faligndata(dd0, dd1), dp++, emask);
1206       }
1207     }
1208   }
1209 }
1210 
1211 /***************************************************************/
    </pre>
  </body>
</html>
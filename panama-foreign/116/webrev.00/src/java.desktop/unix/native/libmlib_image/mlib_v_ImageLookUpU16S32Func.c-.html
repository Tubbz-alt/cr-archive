<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libmlib_image/mlib_v_ImageLookUpU16S32Func.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 
 28 #include &quot;vis_proto.h&quot;
 29 #include &quot;mlib_image.h&quot;
 30 #include &quot;mlib_v_ImageLookUpFunc.h&quot;
 31 
 32 /***************************************************************/
 33 static void mlib_v_ImageLookUp_U16_S32_124_D1(const mlib_u16 *src,
 34                                               mlib_f32       *dst,
 35                                               mlib_s32       xsize,
 36                                               const mlib_f32 *table0,
 37                                               const mlib_f32 *table1,
 38                                               const mlib_f32 *table2,
 39                                               const mlib_f32 *table3);
 40 
 41 static void mlib_v_ImageLookUp_U16_S32_3_D1(const mlib_u16 *src,
 42                                             mlib_f32       *dst,
 43                                             mlib_s32       xsize,
 44                                             const mlib_f32 *table0,
 45                                             const mlib_f32 *table1,
 46                                             const mlib_f32 *table2);
 47 
 48 /***************************************************************/
 49 void mlib_v_ImageLookUp_U16_S32_124_D1(const mlib_u16 *src,
 50                                        mlib_f32       *dst,
 51                                        mlib_s32       xsize,
 52                                        const mlib_f32 *table0,
 53                                        const mlib_f32 *table1,
 54                                        const mlib_f32 *table2,
 55                                        const mlib_f32 *table3)
 56 {
 57   mlib_u32 *sa;                        /* aligned pointer to source data */
 58   mlib_u16 *sp;                        /* pointer to source data */
 59   mlib_u32 s0, s1;                     /* source data */
 60   mlib_f32 *dp;                        /* aligned pointer to destination */
 61   mlib_f32 acc0, acc1;                 /* destination data */
 62   mlib_f32 acc2, acc3;                 /* destination data */
 63   mlib_s32 i;                          /* loop variable */
 64   mlib_u32 s00, s01, s02, s03;
 65 
 66   sa = (mlib_u32 *) src;
 67   dp = dst;
 68 
 69   i = 0;
 70 
 71   if (xsize &gt;= 4) {
 72 
 73     s0 = *sa++;
 74     s1 = *sa++;
 75     s00 = (s0 &gt;&gt; 14) &amp; (~3);
 76     s01 = ((s0 &lt;&lt; 16) &gt;&gt; 14);
 77 
 78 #pragma pipeloop(0)
 79     for (i = 0; i &lt;= xsize - 8; i += 4, dp += 4) {
 80       s02 = (s1 &gt;&gt; 14) &amp; (~3);
 81       s03 = ((s1 &lt;&lt; 16) &gt;&gt; 14);
 82       acc0 = *(mlib_f32 *) ((mlib_u8 *) table0 + s00);
 83       acc1 = *(mlib_f32 *) ((mlib_u8 *) table1 + s01);
 84       acc2 = *(mlib_f32 *) ((mlib_u8 *) table2 + s02);
 85       acc3 = *(mlib_f32 *) ((mlib_u8 *) table3 + s03);
 86       s0 = *sa++;
 87       s1 = *sa++;
 88       s00 = (s0 &gt;&gt; 14) &amp; (~3);
 89       s01 = ((s0 &lt;&lt; 16) &gt;&gt; 14);
 90       dp[0] = acc0;
 91       dp[1] = acc1;
 92       dp[2] = acc2;
 93       dp[3] = acc3;
 94     }
 95 
 96     s02 = (s1 &gt;&gt; 14) &amp; (~3);
 97     s03 = ((s1 &lt;&lt; 16) &gt;&gt; 14);
 98     acc0 = *(mlib_f32 *) ((mlib_u8 *) table0 + s00);
 99     acc1 = *(mlib_f32 *) ((mlib_u8 *) table1 + s01);
100     acc2 = *(mlib_f32 *) ((mlib_u8 *) table2 + s02);
101     acc3 = *(mlib_f32 *) ((mlib_u8 *) table3 + s03);
102     dp[0] = acc0;
103     dp[1] = acc1;
104     dp[2] = acc2;
105     dp[3] = acc3;
106     dp += 4;
107     i += 4;
108   }
109 
110   sp = (mlib_u16 *) sa;
111 
112   if (i &lt; xsize) {
113     *dp++ = table0[sp[0]];
114     i++;
115     sp++;
116   }
117 
118   if (i &lt; xsize) {
119     *dp++ = table1[sp[0]];
120     i++;
121     sp++;
122   }
123 
124   if (i &lt; xsize) {
125     *dp++ = table2[sp[0]];
126   }
127 }
128 
129 /***************************************************************/
130 void mlib_v_ImageLookUp_U16_S32_1(const mlib_u16 *src,
131                                   mlib_s32       slb,
132                                   mlib_s32       *dst,
133                                   mlib_s32       dlb,
134                                   mlib_s32       xsize,
135                                   mlib_s32       ysize,
136                                   const mlib_s32 **table)
137 {
138   mlib_u16 *sl;
139   mlib_s32 *dl;
140   mlib_f32 *tab = (mlib_f32 *) (&amp;table[0][0]);
141   mlib_s32 j;
142 
143   sl = (void *)src;
144   dl = dst;
145 
146   /* row loop */
147   for (j = 0; j &lt; ysize; j++) {
148     mlib_u16 *sp = sl;
149     mlib_f32 *dp = (mlib_f32 *) dl;
150     mlib_s32 off, size = xsize;
151 
152     off = (mlib_s32) (((4 - ((mlib_addr) sp &amp; 3)) &amp; 3) &gt;&gt; 1);
153 
154     off = (off &lt; size) ? off : size;
155 
156     if (off == 1) {
157       *dp++ = tab[(*sp++)];
158       size--;
159     }
160 
161     if (size &gt; 0) {
162       mlib_v_ImageLookUp_U16_S32_124_D1(sp, dp, size, tab, tab, tab, tab);
163     }
164 
165     sl = (mlib_u16 *) ((mlib_u8 *) sl + slb);
166     dl = (mlib_s32 *) ((mlib_u8 *) dl + dlb);
167   }
168 }
169 
170 /***************************************************************/
171 void mlib_v_ImageLookUp_U16_S32_2(const mlib_u16 *src,
172                                   mlib_s32       slb,
173                                   mlib_s32       *dst,
174                                   mlib_s32       dlb,
175                                   mlib_s32       xsize,
176                                   mlib_s32       ysize,
177                                   const mlib_s32 **table)
178 {
179   mlib_u16 *sl;
180   mlib_s32 *dl;
181   mlib_f32 *tab;
182   mlib_s32 j;
183 
184   sl = (void *)src;
185   dl = dst;
186 
187   /* row loop */
188   for (j = 0; j &lt; ysize; j++) {
189     mlib_u16 *sp = sl;
190     mlib_f32 *dp = (mlib_f32 *) dl;
191     mlib_s32 off, size = xsize * 2;
192     mlib_f32 *tab0 = (mlib_f32 *) (&amp;table[0][0]);
193     mlib_f32 *tab1 = (mlib_f32 *) (&amp;table[1][0]);
194 
195     off = (mlib_s32) (((4 - ((mlib_addr) sp &amp; 3)) &amp; 3) &gt;&gt; 1);
196 
197     off = (off &lt; size) ? off : size;
198 
199     if ((off &amp; 1) != 0) {
200       *dp++ = tab0[(*sp++)];
201       size--;
202       tab = tab0;
203       tab0 = tab1;
204       tab1 = tab;
205     }
206 
207     if (size &gt; 0) {
208       mlib_v_ImageLookUp_U16_S32_124_D1(sp, dp, size, tab0, tab1, tab0, tab1);
209     }
210 
211     sl = (mlib_u16 *) ((mlib_u8 *) sl + slb);
212     dl = (mlib_s32 *) ((mlib_u8 *) dl + dlb);
213   }
214 }
215 
216 /***************************************************************/
217 void mlib_v_ImageLookUp_U16_S32_4(const mlib_u16 *src,
218                                   mlib_s32       slb,
219                                   mlib_s32       *dst,
220                                   mlib_s32       dlb,
221                                   mlib_s32       xsize,
222                                   mlib_s32       ysize,
223                                   const mlib_s32 **table)
224 {
225   mlib_u16 *sl;
226   mlib_s32 *dl;
227   mlib_f32 *tab;
228   mlib_s32 j;
229 
230   sl = (void *)src;
231   dl = dst;
232 
233   /* row loop */
234   for (j = 0; j &lt; ysize; j++) {
235     mlib_u16 *sp = sl;
236     mlib_f32 *dp = (mlib_f32 *) dl;
237     mlib_f32 *tab0 = (mlib_f32 *) (&amp;table[0][0]);
238     mlib_f32 *tab1 = (mlib_f32 *) (&amp;table[1][0]);
239     mlib_f32 *tab2 = (mlib_f32 *) (&amp;table[2][0]);
240     mlib_f32 *tab3 = (mlib_f32 *) (&amp;table[3][0]);
241     mlib_s32 off, size = xsize * 4;
242 
243     off = (mlib_s32) (((4 - ((mlib_addr) sp &amp; 3)) &amp; 3) &gt;&gt; 1);
244 
245     off = (off &lt; size) ? off : size;
246 
247     if (off == 1) {
248       *dp++ = tab0[(*sp++)];
249       tab = tab0;
250       tab0 = tab1;
251       tab1 = tab2;
252       tab2 = tab3;
253       tab3 = tab;
254       size--;
255     }
256 
257     if (size &gt; 0) {
258       mlib_v_ImageLookUp_U16_S32_124_D1(sp, dp, size, tab0, tab1, tab2, tab3);
259     }
260 
261     sl = (mlib_u16 *) ((mlib_u8 *) sl + slb);
262     dl = (mlib_s32 *) ((mlib_u8 *) dl + dlb);
263   }
264 }
265 
266 /***************************************************************/
267 void mlib_v_ImageLookUp_U16_S32_3_D1(const mlib_u16 *src,
268                                      mlib_f32       *dst,
269                                      mlib_s32       xsize,
270                                      const mlib_f32 *table0,
271                                      const mlib_f32 *table1,
272                                      const mlib_f32 *table2)
273 {
274   mlib_u32 *sa;                        /* aligned pointer to source data */
275   mlib_u16 *sp;                        /* pointer to source data */
276   mlib_u32 s0, s1;                     /* source data */
277   mlib_f32 *dp;                        /* aligned pointer to destination */
278   mlib_f32 acc0, acc1;                 /* destination data */
279   mlib_f32 acc2, acc3;                 /* destination data */
280   mlib_s32 i;                          /* loop variable */
281   const mlib_f32 *table;
282   mlib_u32 s00, s01, s02, s03;
283 
284   sa = (mlib_u32 *) src;
285   dp = dst;
286 
287   i = 0;
288 
289   if (xsize &gt;= 4) {
290 
291     s0 = *sa++;
292     s1 = *sa++;
293     s00 = (s0 &gt;&gt; 14) &amp; (~3);
294     s01 = ((s0 &lt;&lt; 16) &gt;&gt; 14);
295 
296 #pragma pipeloop(0)
297     for (i = 0; i &lt;= xsize - 8; i += 4, dp += 4) {
298       s02 = (s1 &gt;&gt; 14) &amp; (~3);
299       s03 = ((s1 &lt;&lt; 16) &gt;&gt; 14);
300       acc0 = *(mlib_f32 *) ((mlib_u8 *) table0 + s00);
301       acc1 = *(mlib_f32 *) ((mlib_u8 *) table1 + s01);
302       acc2 = *(mlib_f32 *) ((mlib_u8 *) table2 + s02);
303       acc3 = *(mlib_f32 *) ((mlib_u8 *) table0 + s03);
304       s0 = *sa++;
305       s1 = *sa++;
306       s00 = (s0 &gt;&gt; 14) &amp; (~3);
307       s01 = ((s0 &lt;&lt; 16) &gt;&gt; 14);
308       table = table0;
309       table0 = table1;
310       table1 = table2;
311       table2 = table;
312       dp[0] = acc0;
313       dp[1] = acc1;
314       dp[2] = acc2;
315       dp[3] = acc3;
316     }
317 
318     s02 = (s1 &gt;&gt; 14) &amp; (~3);
319     s03 = ((s1 &lt;&lt; 16) &gt;&gt; 14);
320     acc0 = *(mlib_f32 *) ((mlib_u8 *) table0 + s00);
321     acc1 = *(mlib_f32 *) ((mlib_u8 *) table1 + s01);
322     acc2 = *(mlib_f32 *) ((mlib_u8 *) table2 + s02);
323     acc3 = *(mlib_f32 *) ((mlib_u8 *) table0 + s03);
324     dp[0] = acc0;
325     dp[1] = acc1;
326     dp[2] = acc2;
327     dp[3] = acc3;
328     table = table0;
329     table0 = table1;
330     table1 = table2;
331     table2 = table;
332     dp += 4;
333     i += 4;
334   }
335 
336   sp = (mlib_u16 *) sa;
337 
338   if (i &lt; xsize) {
339     *dp++ = table0[sp[0]];
340     i++;
341     sp++;
342   }
343 
344   if (i &lt; xsize) {
345     *dp++ = table1[sp[0]];
346     i++;
347     sp++;
348   }
349 
350   if (i &lt; xsize) {
351     *dp++ = table2[sp[0]];
352   }
353 }
354 
355 /***************************************************************/
356 void mlib_v_ImageLookUp_U16_S32_3(const mlib_u16 *src,
357                                   mlib_s32       slb,
358                                   mlib_s32       *dst,
359                                   mlib_s32       dlb,
360                                   mlib_s32       xsize,
361                                   mlib_s32       ysize,
362                                   const mlib_s32 **table)
363 {
364   mlib_u16 *sl;
365   mlib_s32 *dl;
366   mlib_f32 *tab;
367   mlib_s32 j;
368 
369   sl = (void *)src;
370   dl = dst;
371 
372   /* row loop */
373   for (j = 0; j &lt; ysize; j++) {
374     mlib_u16 *sp = sl;
375     mlib_f32 *dp = (mlib_f32 *) dl;
376     mlib_f32 *tab0 = (mlib_f32 *) (&amp;table[0][0]);
377     mlib_f32 *tab1 = (mlib_f32 *) (&amp;table[1][0]);
378     mlib_f32 *tab2 = (mlib_f32 *) (&amp;table[2][0]);
379     mlib_s32 off, size = xsize * 3;
380 
381     off = (mlib_s32) (((4 - ((mlib_addr) sp &amp; 3)) &amp; 3) &gt;&gt; 1);
382 
383     off = (off &lt; size) ? off : size;
384 
385     if (off == 1) {
386       *dp++ = tab0[(*sp++)];
387       tab = tab0;
388       tab0 = tab1;
389       tab1 = tab2;
390       tab2 = tab;
391       size--;
392     }
393 
394     if (size &gt; 0) {
395       mlib_v_ImageLookUp_U16_S32_3_D1(sp, dp, size, tab0, tab1, tab2);
396     }
397 
398     sl = (mlib_u16 *) ((mlib_u8 *) sl + slb);
399     dl = (mlib_s32 *) ((mlib_u8 *) dl + dlb);
400   }
401 }
402 
403 /***************************************************************/
    </pre>
  </body>
</html>
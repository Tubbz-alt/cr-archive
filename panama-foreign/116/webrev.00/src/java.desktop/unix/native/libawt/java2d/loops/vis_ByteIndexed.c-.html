<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libawt/java2d/loops/vis_ByteIndexed.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #if !defined(JAVA2D_NO_MLIB) || defined(MLIB_ADD_SUFF)
 27 
 28 #include &lt;vis_proto.h&gt;
 29 #include &quot;java2d_Mlib.h&quot;
 30 #include &quot;vis_AlphaMacros.h&quot;
 31 
 32 /***************************************************************/
 33 
 34 const mlib_u8 vis_sat_sh3_tbl[128 + 256 + 128] = {
 35    0,  0,  0,  0,  0,  0,  0,  0,
 36    0,  0,  0,  0,  0,  0,  0,  0,
 37    0,  0,  0,  0,  0,  0,  0,  0,
 38    0,  0,  0,  0,  0,  0,  0,  0,
 39    0,  0,  0,  0,  0,  0,  0,  0,
 40    0,  0,  0,  0,  0,  0,  0,  0,
 41    0,  0,  0,  0,  0,  0,  0,  0,
 42    0,  0,  0,  0,  0,  0,  0,  0,
 43    0,  0,  0,  0,  0,  0,  0,  0,
 44    0,  0,  0,  0,  0,  0,  0,  0,
 45    0,  0,  0,  0,  0,  0,  0,  0,
 46    0,  0,  0,  0,  0,  0,  0,  0,
 47    0,  0,  0,  0,  0,  0,  0,  0,
 48    0,  0,  0,  0,  0,  0,  0,  0,
 49    0,  0,  0,  0,  0,  0,  0,  0,
 50    0,  0,  0,  0,  0,  0,  0,  0,
 51    0,  0,  0,  0,  0,  0,  0,  0,
 52    1,  1,  1,  1,  1,  1,  1,  1,
 53    2,  2,  2,  2,  2,  2,  2,  2,
 54    3,  3,  3,  3,  3,  3,  3,  3,
 55    4,  4,  4,  4,  4,  4,  4,  4,
 56    5,  5,  5,  5,  5,  5,  5,  5,
 57    6,  6,  6,  6,  6,  6,  6,  6,
 58    7,  7,  7,  7,  7,  7,  7,  7,
 59    8,  8,  8,  8,  8,  8,  8,  8,
 60    9,  9,  9,  9,  9,  9,  9,  9,
 61     10, 10, 10, 10, 10, 10, 10, 10,
 62     11, 11, 11, 11, 11, 11, 11, 11,
 63     12, 12, 12, 12, 12, 12, 12, 12,
 64     13, 13, 13, 13, 13, 13, 13, 13,
 65     14, 14, 14, 14, 14, 14, 14, 14,
 66     15, 15, 15, 15, 15, 15, 15, 15,
 67     16, 16, 16, 16, 16, 16, 16, 16,
 68     17, 17, 17, 17, 17, 17, 17, 17,
 69     18, 18, 18, 18, 18, 18, 18, 18,
 70     19, 19, 19, 19, 19, 19, 19, 19,
 71     20, 20, 20, 20, 20, 20, 20, 20,
 72     21, 21, 21, 21, 21, 21, 21, 21,
 73     22, 22, 22, 22, 22, 22, 22, 22,
 74     23, 23, 23, 23, 23, 23, 23, 23,
 75     24, 24, 24, 24, 24, 24, 24, 24,
 76     25, 25, 25, 25, 25, 25, 25, 25,
 77     26, 26, 26, 26, 26, 26, 26, 26,
 78     27, 27, 27, 27, 27, 27, 27, 27,
 79     28, 28, 28, 28, 28, 28, 28, 28,
 80     29, 29, 29, 29, 29, 29, 29, 29,
 81     30, 30, 30, 30, 30, 30, 30, 30,
 82     31, 31, 31, 31, 31, 31, 31, 31,
 83     31, 31, 31, 31, 31, 31, 31, 31,
 84     31, 31, 31, 31, 31, 31, 31, 31,
 85     31, 31, 31, 31, 31, 31, 31, 31,
 86     31, 31, 31, 31, 31, 31, 31, 31,
 87     31, 31, 31, 31, 31, 31, 31, 31,
 88     31, 31, 31, 31, 31, 31, 31, 31,
 89     31, 31, 31, 31, 31, 31, 31, 31,
 90     31, 31, 31, 31, 31, 31, 31, 31,
 91     31, 31, 31, 31, 31, 31, 31, 31,
 92     31, 31, 31, 31, 31, 31, 31, 31,
 93     31, 31, 31, 31, 31, 31, 31, 31,
 94     31, 31, 31, 31, 31, 31, 31, 31,
 95     31, 31, 31, 31, 31, 31, 31, 31,
 96     31, 31, 31, 31, 31, 31, 31, 31,
 97     31, 31, 31, 31, 31, 31, 31, 31,
 98     31, 31, 31, 31, 31, 31, 31, 31,
 99 };
100 
101 /***************************************************************/
102 
103 #define CHECK_LUT
104 
105 /***************************************************************/
106 
107 #define FUNC_CONVERT(FUNC, SRC_T)                                      \
108 void ADD_SUFF(SRC_T##ToByteIndexed##FUNC)(BLIT_PARAMS)                 \
109 {                                                                      \
110     const mlib_u8 *p_tbl = vis_sat_sh3_tbl + 128;                      \
111     mlib_s32 DstWriteXDither, DstWriteYDither;                         \
112     mlib_s8 *DstWritererr, *DstWritegerr, *DstWriteberr;               \
113     mlib_u8 *DstWriteInvLut;                                           \
114     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;                           \
115     mlib_s32 dstScan = pDstInfo-&gt;scanStride;                           \
116     mlib_s32 r, g, b;                                                  \
117     mlib_s32 i, j;                                                     \
118     CHECK_LUT                                                          \
119                                                                        \
120     DstWriteYDither = (pDstInfo-&gt;bounds.y1 &amp; 7) &lt;&lt; 3;                  \
121     DstWriteInvLut = pDstInfo-&gt;invColorTable;                          \
122                                                                        \
123     for (j = 0; j &lt; height; j++) {                                     \
124         mlib_u8 *pSrc = srcBase;                                       \
125         mlib_u8 *pDst = dstBase;                                       \
126                                                                        \
127         DstWritererr = pDstInfo-&gt;redErrTable + DstWriteYDither;        \
128         DstWritegerr = pDstInfo-&gt;grnErrTable + DstWriteYDither;        \
129         DstWriteberr = pDstInfo-&gt;bluErrTable + DstWriteYDither;        \
130                                                                        \
131         DstWriteXDither = pDstInfo-&gt;bounds.x1 &amp; 7;                     \
132                                                                        \
133         for (i = 0; i &lt; width; i++) {                                  \
134             GET_RGB_##SRC_T(i)                                         \
135             {                                                          \
136                 r = p_tbl[r + DstWritererr[DstWriteXDither]];          \
137                 g = p_tbl[g + DstWritegerr[DstWriteXDither]];          \
138                 b = p_tbl[b + DstWriteberr[DstWriteXDither]];          \
139                                                                        \
140                 pDst[i] = DstWriteInvLut[(r &lt;&lt; 10) + (g &lt;&lt; 5) + b];    \
141             }                                                          \
142                                                                        \
143             DstWriteXDither = (DstWriteXDither + 1) &amp; 7;               \
144         }                                                              \
145                                                                        \
146         PTR_ADD(dstBase, dstScan);                                     \
147         PTR_ADD(srcBase, srcScan);                                     \
148                                                                        \
149         DstWriteYDither = (DstWriteYDither + (1 &lt;&lt; 3)) &amp; (7 &lt;&lt; 3);     \
150     }                                                                  \
151 }
152 
153 /***************************************************************/
154 
155 #define FUNC_SCALE_CONVERT(FUNC, SRC_T)                                \
156 void ADD_SUFF(SRC_T##ToByteIndexed##FUNC)(SCALE_PARAMS)                \
157 {                                                                      \
158     const mlib_u8 *p_tbl = vis_sat_sh3_tbl + 128;                      \
159     mlib_s32 DstWriteXDither, DstWriteYDither;                         \
160     mlib_s8 *DstWritererr, *DstWritegerr, *DstWriteberr;               \
161     mlib_u8 *DstWriteInvLut;                                           \
162     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;                           \
163     mlib_s32 dstScan = pDstInfo-&gt;scanStride;                           \
164     mlib_s32 r, g, b;                                                  \
165     mlib_s32 i, j;                                                     \
166     CHECK_LUT                                                          \
167                                                                        \
168     DstWriteYDither = (pDstInfo-&gt;bounds.y1 &amp; 7) &lt;&lt; 3;                  \
169     DstWriteInvLut = pDstInfo-&gt;invColorTable;                          \
170                                                                        \
171     for (j = 0; j &lt; height; j++) {                                     \
172         mlib_u8 *pSrc = srcBase;                                       \
173         mlib_u8 *pDst = dstBase;                                       \
174         mlib_s32 tmpsxloc = sxloc;                                     \
175                                                                        \
176         PTR_ADD(pSrc, (syloc &gt;&gt; shift) * srcScan);                     \
177                                                                        \
178         DstWritererr = pDstInfo-&gt;redErrTable + DstWriteYDither;        \
179         DstWritegerr = pDstInfo-&gt;grnErrTable + DstWriteYDither;        \
180         DstWriteberr = pDstInfo-&gt;bluErrTable + DstWriteYDither;        \
181                                                                        \
182         DstWriteXDither = pDstInfo-&gt;bounds.x1 &amp; 7;                     \
183                                                                        \
184         for (i = 0; i &lt; width; i++) {                                  \
185             mlib_s32 ii = tmpsxloc &gt;&gt; shift;                           \
186             GET_RGB_##SRC_T(ii)                                        \
187             {                                                          \
188                 r = p_tbl[r + DstWritererr[DstWriteXDither]];          \
189                 g = p_tbl[g + DstWritegerr[DstWriteXDither]];          \
190                 b = p_tbl[b + DstWriteberr[DstWriteXDither]];          \
191                                                                        \
192                 pDst[i] = DstWriteInvLut[(r &lt;&lt; 10) + (g &lt;&lt; 5) + b];    \
193             }                                                          \
194                                                                        \
195             DstWriteXDither = (DstWriteXDither + 1) &amp; 7;               \
196             tmpsxloc += sxinc;                                         \
197         }                                                              \
198                                                                        \
199         PTR_ADD(dstBase, dstScan);                                     \
200         syloc += syinc;                                                \
201                                                                        \
202         DstWriteYDither = (DstWriteYDither + (1 &lt;&lt; 3)) &amp; (7 &lt;&lt; 3);     \
203     }                                                                  \
204 }
205 
206 /***************************************************************/
207 
208 #define GET_PIX_IntArgbBm(i)                           \
209     mlib_s32 pixel = *(mlib_s32*)(pSrc + 4*i);         \
210     if (pixel &gt;&gt; 24)
211 
212 #define GET_PIX_ByteIndexedBm(i)               \
213     mlib_s32 pixel = SrcReadLut[pSrc[i]];      \
214     if (pixel &lt; 0)
215 
216 #define FUNC_BGCOPY(SRC_T)                                             \
217 void ADD_SUFF(SRC_T##ToByteIndexedXparBgCopy)(BCOPY_PARAMS)            \
218 {                                                                      \
219     const mlib_u8 *p_tbl = vis_sat_sh3_tbl + 128;                      \
220     mlib_s32 DstWriteXDither, DstWriteYDither;                         \
221     mlib_s8 *DstWritererr, *DstWritegerr, *DstWriteberr;               \
222     mlib_u8 *DstWriteInvLut;                                           \
223     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;                           \
224     mlib_s32 dstScan = pDstInfo-&gt;scanStride;                           \
225     mlib_s32 r, g, b;                                                  \
226     mlib_s32 i, j;                                                     \
227     jint *SrcReadLut = pSrcInfo-&gt;lutBase;                              \
228                                                                        \
229     DstWriteYDither = (pDstInfo-&gt;bounds.y1 &amp; 7) &lt;&lt; 3;                  \
230     DstWriteInvLut = pDstInfo-&gt;invColorTable;                          \
231                                                                        \
232     for (j = 0; j &lt; height; j++) {                                     \
233         mlib_u8 *pSrc = srcBase;                                       \
234         mlib_u8 *pDst = dstBase;                                       \
235                                                                        \
236         DstWritererr = pDstInfo-&gt;redErrTable + DstWriteYDither;        \
237         DstWritegerr = pDstInfo-&gt;grnErrTable + DstWriteYDither;        \
238         DstWriteberr = pDstInfo-&gt;bluErrTable + DstWriteYDither;        \
239                                                                        \
240         DstWriteXDither = pDstInfo-&gt;bounds.x1 &amp; 7;                     \
241                                                                        \
242         for (i = 0; i &lt; width; i++) {                                  \
243             GET_PIX_##SRC_T(i)                                         \
244             {                                                          \
245                 b = (pixel) &amp; 0xff;                                    \
246                 g = (pixel &gt;&gt; 8) &amp; 0xff;                               \
247                 r = (pixel &gt;&gt; 16) &amp; 0xff;                              \
248                                                                        \
249                 r = p_tbl[r + DstWritererr[DstWriteXDither]];          \
250                 g = p_tbl[g + DstWritegerr[DstWriteXDither]];          \
251                 b = p_tbl[b + DstWriteberr[DstWriteXDither]];          \
252                                                                        \
253                 pDst[i] = DstWriteInvLut[(r &lt;&lt; 10) + (g &lt;&lt; 5) + b];    \
254             } else {                                                   \
255                 pDst[i] = bgpixel;                                     \
256             }                                                          \
257                                                                        \
258             DstWriteXDither = (DstWriteXDither + 1) &amp; 7;               \
259         }                                                              \
260                                                                        \
261         PTR_ADD(dstBase, dstScan);                                     \
262         PTR_ADD(srcBase, srcScan);                                     \
263                                                                        \
264         DstWriteYDither = (DstWriteYDither + (1 &lt;&lt; 3)) &amp; (7 &lt;&lt; 3);     \
265     }                                                                  \
266 }
267 
268 FUNC_BGCOPY(ByteIndexedBm)
269 FUNC_BGCOPY(IntArgbBm)
270 
271 /***************************************************************/
272 
273 #define GET_RGB_IntArgb(i)                             \
274     mlib_u32 pixel = *(mlib_u32*)(pSrc + 4*i);         \
275     b = (pixel) &amp; 0xff;                                \
276     g = (pixel &gt;&gt; 8) &amp; 0xff;                           \
277     r = (pixel &gt;&gt; 16) &amp; 0xff;
278 
279 #define GET_RGB_ThreeByteBgr(i)        \
280     b = pSrc[3*i];                     \
281     g = pSrc[3*i + 1];                 \
282     r = pSrc[3*i + 2];
283 
284 #define GET_RGB_ByteGray(i)    \
285     r = g = b = pSrc[i];
286 
287 #define GET_RGB_Index12Gray(i)                         \
288     r = SrcReadLut[((mlib_u16*)pSrc)[i] &amp; 0xfff];      \
289     r &amp;= 0xff;                                         \
290     g = b = r;
291 
292 #define GET_RGB_ByteIndexed(i)                 \
293     mlib_u32 pixel = SrcReadLut[pSrc[i]];      \
294     b = (pixel) &amp; 0xff;                        \
295     g = (pixel &gt;&gt; 8) &amp; 0xff;                   \
296     r = (pixel &gt;&gt; 16) &amp; 0xff;
297 
298 #define GET_RGB_IntArgbBm(i)                           \
299     mlib_s32 pixel = *(mlib_s32*)(pSrc + 4*i);         \
300     b = (pixel) &amp; 0xff;                                \
301     g = (pixel &gt;&gt; 8) &amp; 0xff;                           \
302     r = (pixel &gt;&gt; 16) &amp; 0xff;                          \
303     if (pixel &gt;&gt; 24)
304 
305 #define GET_RGB_ByteIndexedBm(i)               \
306     mlib_s32 pixel = SrcReadLut[pSrc[i]];      \
307     b = (pixel) &amp; 0xff;                        \
308     g = (pixel &gt;&gt; 8) &amp; 0xff;                   \
309     r = (pixel &gt;&gt; 16) &amp; 0xff;                  \
310     if (pixel &lt; 0)
311 
312 /***************************************************************/
313 
314 FUNC_CONVERT(Convert, IntArgb)
315 FUNC_CONVERT(Convert, ThreeByteBgr)
316 FUNC_CONVERT(Convert, ByteGray)
317 FUNC_CONVERT(XparOver, IntArgbBm)
318 FUNC_SCALE_CONVERT(ScaleConvert, IntArgb)
319 FUNC_SCALE_CONVERT(ScaleConvert, ThreeByteBgr)
320 FUNC_SCALE_CONVERT(ScaleConvert, ByteGray)
321 FUNC_SCALE_CONVERT(ScaleXparOver, IntArgbBm)
322 
323 /***************************************************************/
324 
325 #undef  CHECK_LUT
326 #define CHECK_LUT      \
327     jint *SrcReadLut = pSrcInfo-&gt;lutBase;
328 
329 FUNC_CONVERT(Convert, Index12Gray)
330 FUNC_SCALE_CONVERT(ScaleConvert, Index12Gray)
331 
332 FUNC_CONVERT(XparOver, ByteIndexedBm)
333 FUNC_SCALE_CONVERT(ScaleXparOver, ByteIndexedBm)
334 
335 /***************************************************************/
336 
337 #undef  CHECK_LUT
338 #define CHECK_LUT                                                      \
339     jint *SrcReadLut = pSrcInfo-&gt;lutBase;                              \
340     jint *DstReadLut = pDstInfo-&gt;lutBase;                              \
341     if (checkSameLut(SrcReadLut, DstReadLut, pSrcInfo, pDstInfo)) {    \
342         ADD_SUFF(AnyByteIsomorphicCopy)(BLIT_CALL_PARAMS);             \
343         return;                                                        \
344     }
345 
346 FUNC_CONVERT(Convert, ByteIndexed)
347 
348 #undef  CHECK_LUT
349 #define CHECK_LUT                                                      \
350     jint *SrcReadLut = pSrcInfo-&gt;lutBase;                              \
351     jint *DstReadLut = pDstInfo-&gt;lutBase;                              \
352     if (checkSameLut(SrcReadLut, DstReadLut, pSrcInfo, pDstInfo)) {    \
353         ADD_SUFF(AnyByteIsomorphicScaleCopy)(SCALE_CALL_PARAMS);       \
354         return;                                                        \
355     }
356 
357 FUNC_SCALE_CONVERT(ScaleConvert, ByteIndexed)
358 
359 /***************************************************************/
360 
361 void ADD_SUFF(IntArgbToByteIndexedXorBlit)(BLIT_PARAMS)
362 {
363     mlib_u8  *DstWriteInvLut;
364     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
365     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
366     mlib_s32 xorpixel = pCompInfo-&gt;details.xorPixel;
367     mlib_s32 alphamask = pCompInfo-&gt;alphaMask;
368     mlib_s32 i, j;
369 
370     DstWriteInvLut = pDstInfo-&gt;invColorTable;
371 
372     for (j = 0; j &lt; height; j++) {
373         mlib_s32 *pSrc = srcBase;
374         mlib_u8  *pDst = dstBase;
375 
376         for (i = 0; i &lt; width; i++) {
377             mlib_s32 spix = pSrc[i];
378             mlib_s32 dpix;
379             if (spix &lt; 0) {
380                 dpix = DstWriteInvLut[((spix &gt;&gt; 9) &amp; 0x7C00) +
381                                       ((spix &gt;&gt; 6) &amp; 0x03E0) +
382                                       ((spix &gt;&gt; 3) &amp; 0x001F)];
383                 pDst[i] ^= (dpix ^ xorpixel) &amp;~ alphamask;
384             }
385         }
386 
387         PTR_ADD(dstBase, dstScan);
388         PTR_ADD(srcBase, srcScan);
389     }
390 }
391 
392 /***************************************************************/
393 
394 #define MASK_FILL(rr, pathA, dstA, dstARGB)                    \
395 {                                                              \
396     mlib_d64 t0, t1;                                           \
397     mlib_s32 srcF, dstF, srcA;                                 \
398                                                                \
399     srcF = ((dstA &amp; SrcOpAnd) ^ SrcOpXor) + SrcOpAdd;          \
400                                                                \
401     srcF = MUL8_INT(srcF, pathA);                              \
402     dstF = MUL8_INT(dstFbase, pathA) + (0xff - pathA);         \
403                                                                \
404     srcA = MUL8_INT(cnstA, srcF);                              \
405     dstA = MUL8_INT(dstF, dstA);                               \
406                                                                \
407     t0 = MUL8_VIS(cnstARGB0, srcF);                            \
408     t1 = MUL8_VIS(dstARGB, dstA);                              \
409     rr = vis_fpadd16(t0, t1);                                  \
410                                                                \
411     dstA += srcA;                                              \
412     DIV_ALPHA(rr, dstA);                                       \
413 }
414 
415 /***************************************************************/
416 
417 void ADD_SUFF(ByteIndexedAlphaMaskFill)(void *dstBase,
418                                         jubyte *pMask,
419                                         jint maskOff,
420                                         jint maskScan,
421                                         jint width,
422                                         jint height,
423                                         jint fgColor,
424                                         SurfaceDataRasInfo *pDstInfo,
425                                         NativePrimitive *pPrim,
426                                         CompositeInfo *pCompInfo)
427 {
428     const mlib_u8 *mul8_tbl = (void*)mul8table;
429     const mlib_u8 *p_tbl = vis_sat_sh3_tbl + 128;
430     mlib_s32 DstWriteXDither, DstWriteYDither;
431     mlib_s8 *DstWritererr, *DstWritegerr, *DstWriteberr;
432     mlib_u8 *DstWriteInvLut;
433     mlib_s32 r, g, b;
434     mlib_f32 *DstReadLut = (void*)(pDstInfo-&gt;lutBase);
435     mlib_s32 cnstA, cnstR, cnstG, cnstB;
436     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
437     mlib_f32 cnstARGB0;
438     mlib_s32 SrcOpAnd, SrcOpXor, SrcOpAdd;
439     mlib_s32 DstOpAnd, DstOpXor, DstOpAdd;
440     mlib_s32 dstFbase;
441     mlib_s32 j;
442 
443     cnstA = (fgColor &gt;&gt; 24) &amp; 0xff;
444     cnstR = (fgColor &gt;&gt; 16) &amp; 0xff;
445     cnstG = (fgColor &gt;&gt;  8) &amp; 0xff;
446     cnstB = (fgColor      ) &amp; 0xff;
447 
448     if (cnstA != 0xff) {
449         cnstR = mul8table[cnstA][cnstR];
450         cnstG = mul8table[cnstA][cnstG];
451         cnstB = mul8table[cnstA][cnstB];
452     }
453 
454     cnstARGB0 = F32_FROM_U8x4(cnstA, cnstR, cnstG, cnstB);
455 
456     SrcOpAnd = (AlphaRules[pCompInfo-&gt;rule].srcOps).andval;
457     SrcOpXor = (AlphaRules[pCompInfo-&gt;rule].srcOps).xorval;
458     SrcOpAdd = (AlphaRules[pCompInfo-&gt;rule].srcOps).addval;
459     SrcOpAdd -= SrcOpXor;
460 
461     DstOpAnd = (AlphaRules[pCompInfo-&gt;rule].dstOps).andval;
462     DstOpXor = (AlphaRules[pCompInfo-&gt;rule].dstOps).xorval;
463     DstOpAdd = (AlphaRules[pCompInfo-&gt;rule].dstOps).addval;
464     DstOpAdd -= DstOpXor;
465 
466     dstFbase = (((cnstA) &amp; DstOpAnd) ^ DstOpXor) + DstOpAdd;
467 
468     vis_write_gsr(7 &lt;&lt; 3);
469 
470     if (pMask != NULL) {
471         DstWriteYDither = (pDstInfo-&gt;bounds.y1 &amp; 7) &lt;&lt; 3;
472         DstWriteInvLut = pDstInfo-&gt;invColorTable;
473 
474         pMask += maskOff;
475 
476         if (dstScan == width &amp;&amp; maskScan == width) {
477             width *= height;
478             height = 1;
479         }
480 
481         for (j = 0; j &lt; height; j++) {
482             mlib_u8  *pDst = dstBase;
483             mlib_s32 i;
484             mlib_s32 pathA0, dstA0, dst_val, pixel;
485             mlib_d64 res0;
486             mlib_f32 dstARGB0;
487 
488             DstWritererr = pDstInfo-&gt;redErrTable + DstWriteYDither;
489             DstWritegerr = pDstInfo-&gt;grnErrTable + DstWriteYDither;
490             DstWriteberr = pDstInfo-&gt;bluErrTable + DstWriteYDither;
491 
492             DstWriteXDither = pDstInfo-&gt;bounds.x1 &amp; 7;
493 
494 #pragma pipeloop(0)
495             for (i = 0; i &lt; width; i++) {
496                 dst_val = pDst[i];
497                 pathA0 = pMask[i];
498                 dstA0 = *(mlib_u8*)(DstReadLut + dst_val);
499                 dstARGB0 = DstReadLut[dst_val];
500                 MASK_FILL(res0, pathA0, dstA0, dstARGB0);
501                 dstARGB0 = vis_fpack16(res0);
502 
503                 pixel = *(mlib_s32*)&amp;dstARGB0;
504                 b = (pixel) &amp; 0xff;
505                 g = (pixel &gt;&gt; 8) &amp; 0xff;
506                 r = (pixel &gt;&gt; 16) &amp; 0xff;
507                 r = p_tbl[r + DstWritererr[DstWriteXDither]];
508                 g = p_tbl[g + DstWritegerr[DstWriteXDither]];
509                 b = p_tbl[b + DstWriteberr[DstWriteXDither]];
510                 pDst[i] = DstWriteInvLut[(r &lt;&lt; 10) + (g &lt;&lt; 5) + b];
511 
512                 DstWriteXDither = (DstWriteXDither + 1) &amp; 7;
513             }
514 
515             PTR_ADD(dstBase, dstScan);
516             PTR_ADD(pMask, maskScan);
517             DstWriteYDither = (DstWriteYDither + (1 &lt;&lt; 3)) &amp; (7 &lt;&lt; 3);
518         }
519     }/* else {
520         if (dstScan == 4*width) {
521             width *= height;
522             height = 1;
523         }
524 
525         for (j = 0; j &lt; height; j++) {
526             IntArgbAlphaMaskFill_A1_line(dstBase, pMask, width,
527                                          cnstARGB0,
528                                          log_val, mul8_cnstA, mul8_dstF,
529                                          (void*)mul8table);
530 
531             PTR_ADD(dstBase, dstScan);
532         }
533     }*/
534 }
535 
536 /***************************************************************/
537 
538 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libawt/java2d/loops/vis_ThreeByteBgr.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #if !defined(JAVA2D_NO_MLIB) || defined(MLIB_ADD_SUFF)
 27 
 28 #include &quot;vis_AlphaMacros.h&quot;
 29 
 30 /***************************************************************/
 31 
 32 #define GBR_PIXEL(i)   \
 33     0xFF000000 | (src[3*i + 2] &lt;&lt; 16) | (src[3*i + 1] &lt;&lt; 8) | src[3*i]
 34 
 35 /***************************************************************/
 36 
 37 #define BGR_TO_ARGB {                                          \
 38     mlib_d64 sda, sdb, sdc, sdd, sde, sdf;                     \
 39     mlib_d64 s_1, s_2, s_3, a13, b13, a02, b02;                \
 40                                                                \
 41     sda = vis_fpmerge(vis_read_hi(sd0), vis_read_lo(sd1));     \
 42     sdb = vis_fpmerge(vis_read_lo(sd0), vis_read_hi(sd2));     \
 43     sdc = vis_fpmerge(vis_read_hi(sd1), vis_read_lo(sd2));     \
 44                                                                \
 45     sdd = vis_fpmerge(vis_read_hi(sda), vis_read_lo(sdb));     \
 46     sde = vis_fpmerge(vis_read_lo(sda), vis_read_hi(sdc));     \
 47     sdf = vis_fpmerge(vis_read_hi(sdb), vis_read_lo(sdc));     \
 48                                                                \
 49     s_3 = vis_fpmerge(vis_read_hi(sdd), vis_read_lo(sde));     \
 50     s_2 = vis_fpmerge(vis_read_lo(sdd), vis_read_hi(sdf));     \
 51     s_1 = vis_fpmerge(vis_read_hi(sde), vis_read_lo(sdf));     \
 52                                                                \
 53     a13 = vis_fpmerge(vis_read_hi(s_1), vis_read_hi(s_3));     \
 54     b13 = vis_fpmerge(vis_read_lo(s_1), vis_read_lo(s_3));     \
 55     a02 = vis_fpmerge(vis_read_hi(s_0), vis_read_hi(s_2));     \
 56     b02 = vis_fpmerge(vis_read_lo(s_0), vis_read_lo(s_2));     \
 57                                                                \
 58     dd0 = vis_fpmerge(vis_read_hi(a02), vis_read_hi(a13));     \
 59     dd1 = vis_fpmerge(vis_read_lo(a02), vis_read_lo(a13));     \
 60     dd2 = vis_fpmerge(vis_read_hi(b02), vis_read_hi(b13));     \
 61     dd3 = vis_fpmerge(vis_read_lo(b02), vis_read_lo(b13));     \
 62 }
 63 
 64 /***************************************************************/
 65 
 66 void ADD_SUFF(ThreeByteBgrToIntArgbConvert)(BLIT_PARAMS)
 67 {
 68     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
 69     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
 70     mlib_d64 *sp;
 71     mlib_d64 s_0;
 72     mlib_d64 s0, s1, s2, s3, sd0, sd1, sd2, dd0, dd1, dd2, dd3;
 73     mlib_s32 i, i0, j;
 74 
 75     if (width &lt; 16) {
 76         for (j = 0; j &lt; height; j++) {
 77             mlib_u8  *src = srcBase;
 78             mlib_s32 *dst = dstBase;
 79 
 80             for (i = 0; i &lt; width; i++) {
 81                 dst[i] = GBR_PIXEL(i);
 82             }
 83 
 84             PTR_ADD(dstBase, dstScan);
 85             PTR_ADD(srcBase, srcScan);
 86         }
 87         return;
 88     }
 89 
 90     if (srcScan == 3*width &amp;&amp; dstScan == 4*width) {
 91         width *= height;
 92         height = 1;
 93     }
 94 
 95     s_0 = vis_fone();
 96 
 97     for (j = 0; j &lt; height; j++) {
 98         mlib_u8  *src = srcBase;
 99         mlib_f32 *dst = dstBase;
100 
101         i = i0 = 0;
102 
103         if ((mlib_s32)dst &amp; 7) {
104             ((mlib_s32*)dst)[i] = GBR_PIXEL(i);
105             i0 = 1;
106         }
107 
108         sp = vis_alignaddr(src, 3*i0);
109         s3 = *sp++;
110 
111 #pragma pipeloop(0)
112         for (i = i0; i &lt;= (mlib_s32)width - 8; i += 8) {
113             s0 = s3;
114             s1 = *sp++;
115             s2 = *sp++;
116             s3 = *sp++;
117             sd0 = vis_faligndata(s0, s1);
118             sd1 = vis_faligndata(s1, s2);
119             sd2 = vis_faligndata(s2, s3);
120 
121             BGR_TO_ARGB
122 
123             *(mlib_d64*)(dst + i    ) = dd0;
124             *(mlib_d64*)(dst + i + 2) = dd1;
125             *(mlib_d64*)(dst + i + 4) = dd2;
126             *(mlib_d64*)(dst + i + 6) = dd3;
127         }
128 
129         for (; i &lt; width; i++) {
130             ((mlib_s32*)dst)[i] = GBR_PIXEL(i);
131         }
132 
133         PTR_ADD(dstBase, dstScan);
134         PTR_ADD(srcBase, srcScan);
135     }
136 }
137 
138 /***************************************************************/
139 
140 void ADD_SUFF(ThreeByteBgrToIntArgbScaleConvert)(SCALE_PARAMS)
141 {
142     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
143     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
144     mlib_d64 dd, maskFF;
145     mlib_s32 i, i0, i1, j;
146 
147     if (width &lt; 16) {
148         for (j = 0; j &lt; height; j++) {
149             mlib_u8  *src = srcBase;
150             mlib_s32 *dst = dstBase;
151             mlib_s32 *dst_end = dst + width;
152             mlib_s32 tmpsxloc = sxloc;
153 
154             PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
155 
156             for (; dst &lt; dst_end; dst++) {
157                 i = tmpsxloc &gt;&gt; shift;
158                 tmpsxloc += sxinc;
159                 *(mlib_s32*)dst = GBR_PIXEL(i);
160             }
161 
162             PTR_ADD(dstBase, dstScan);
163             syloc += syinc;
164         }
165         return;
166     }
167 
168     maskFF = vis_fone();
169 
170     vis_alignaddr(NULL, 7);
171 
172     for (j = 0; j &lt; height; j++) {
173         mlib_u8  *src = srcBase;
174         mlib_f32 *dst = dstBase;
175         mlib_f32 *dst_end = dst + width;
176         mlib_s32 tmpsxloc = sxloc;
177 
178         PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
179 
180         if ((mlib_s32)dst &amp; 7) {
181             i = tmpsxloc &gt;&gt; shift;
182             tmpsxloc += sxinc;
183             *(mlib_s32*)dst = GBR_PIXEL(i);
184             dst++;
185         }
186 
187 #pragma pipeloop(0)
188         for (; dst &lt;= dst_end - 2; dst += 2) {
189             i0 = tmpsxloc &gt;&gt; shift;
190             i1 = (tmpsxloc + sxinc) &gt;&gt; shift;
191             tmpsxloc += 2*sxinc;
192 
193             dd = vis_faligndata(vis_ld_u8(src + 3*i1    ), dd);
194             dd = vis_faligndata(vis_ld_u8(src + 3*i1 + 1), dd);
195             dd = vis_faligndata(vis_ld_u8(src + 3*i1 + 2), dd);
196             dd = vis_faligndata(maskFF, dd);
197             dd = vis_faligndata(vis_ld_u8(src + 3*i0    ), dd);
198             dd = vis_faligndata(vis_ld_u8(src + 3*i0 + 1), dd);
199             dd = vis_faligndata(vis_ld_u8(src + 3*i0 + 2), dd);
200             dd = vis_faligndata(maskFF, dd);
201 
202             *(mlib_d64*)dst = dd;
203         }
204 
205         for (; dst &lt; dst_end; dst++) {
206             i = tmpsxloc &gt;&gt; shift;
207             tmpsxloc += sxinc;
208             *(mlib_s32*)dst = GBR_PIXEL(i);
209         }
210 
211         PTR_ADD(dstBase, dstScan);
212         syloc += syinc;
213     }
214 }
215 
216 /***************************************************************/
217 
218 #endif
    </pre>
  </body>
</html>
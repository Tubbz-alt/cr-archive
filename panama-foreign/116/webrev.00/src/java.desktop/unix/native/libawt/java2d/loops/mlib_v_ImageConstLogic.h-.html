<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libawt/java2d/loops/mlib_v_ImageConstLogic.h</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef __MLIB_V_IMAGECONSTLOGIC_H
 27 #define __MLIB_V_IMAGECONSTLOGIC_H
 28 
 29 
 30 #if defined ( VIS )
 31 #if VIS &gt;= 0x200
 32 #error This include file can be used with VIS 1.0 only
 33 #endif /* VIS &gt;= 0x200 */
 34 #endif /* defined ( VIS ) */
 35 
 36 #include &lt;mlib_image.h&gt;
 37 #include &lt;vis_proto.h&gt;
 38 #include &lt;mlib_ImageCheck.h&gt;
 39 #include &lt;mlib_ImageLogic_proto.h&gt;
 40 #include &lt;mlib_v_ImageLogic_proto.h&gt;
 41 
 42 #ifdef __cplusplus
 43 extern &quot;C&quot; {
 44 #endif /* __cplusplus */
 45 
 46 /*
 47  * Macro definitions for VIS version image logical functions.
 48  */
 49 
 50 /***************************************************************/
 51 
 52 #define VALIDATE()                                               \
 53   mlib_u8  *sp, *sl; /* pointers for pixel and line of source */ \
 54   mlib_u8  *dp,  *dl;/* pointers for pixel and line of dst */    \
 55   mlib_s32 width, height, type, nchannels;                       \
 56   mlib_s32 stride;   /* for src */                               \
 57   mlib_s32 strided;  /* for dst */                               \
 58   mlib_u32 c01, c02, c03, c04;                                   \
 59   mlib_d64 dc01, dc02, dc03;                                     \
 60                                                                  \
 61   MLIB_IMAGE_SIZE_EQUAL(dst,src);                                \
 62   MLIB_IMAGE_TYPE_EQUAL(dst,src);                                \
 63   MLIB_IMAGE_CHAN_EQUAL(dst,src);                                \
 64                                                                  \
 65   dp  = (mlib_u8 *) mlib_ImageGetData(dst);                      \
 66   sp  = (mlib_u8 *) mlib_ImageGetData(src);                      \
 67   height = mlib_ImageGetHeight(dst);                             \
 68   width  = mlib_ImageGetWidth(dst);                              \
 69   stride = mlib_ImageGetStride(src);                             \
 70   strided  = mlib_ImageGetStride(dst);                           \
 71   nchannels = mlib_ImageGetChannels(dst);                        \
 72   type = mlib_ImageGetType(dst);                                 \
 73                                                                  \
 74   if (type == MLIB_SHORT) {                                      \
 75     width *= (2 * nchannels);                                    \
 76     if (nchannels == 1) {                                        \
 77       c01 = c[0] &amp; 0xFFFF; c01 |= (c01 &lt;&lt; 16);                   \
 78       dc01 = vis_to_double_dup(c01);                             \
 79     } else if (nchannels == 2) {                                 \
 80       c01 = ((c[0] &amp; 0xFFFF) &lt;&lt; 16) | (c[1] &amp; 0xFFFF);           \
 81       dc01 = vis_to_double_dup(c01);                             \
 82     } else if (nchannels == 3) {                                 \
 83       c01 = ((c[0] &amp; 0xFFFF) &lt;&lt; 16) | (c[1] &amp; 0xFFFF);           \
 84       c02 = ((c[2] &amp; 0xFFFF) &lt;&lt; 16) | (c01 &gt;&gt; 16);               \
 85       c03 = (c01 &lt;&lt; 16) | (c02 &gt;&gt; 16);                           \
 86       dc01= vis_to_double(c01, c02);                             \
 87       dc02= vis_to_double(c03, c01);                             \
 88       dc03= vis_to_double(c02, c03);                             \
 89     } else {                                                     \
 90       c01 = ((c[0] &amp; 0xFFFF) &lt;&lt; 16) | (c[1] &amp; 0xFFFF);           \
 91       c02 = ((c[2] &amp; 0xFFFF) &lt;&lt; 16) | (c[3] &amp; 0xFFFF);           \
 92       dc01= vis_to_double(c01, c02);                             \
 93     }                                                            \
 94                                                                  \
 95   } else if (type == MLIB_BYTE) {                                \
 96     width *= nchannels;                                          \
 97     if (nchannels == 1) {                                        \
 98       c01 = c[0] &amp; 0xFF; c01 |= (c01 &lt;&lt; 8);                      \
 99       c01 |= (c01 &lt;&lt; 16);                                        \
100       dc01 = vis_to_double_dup(c01);                             \
101     } else if (nchannels == 2) {                                 \
102       c01 = ((c[0] &amp; 0xFF) &lt;&lt; 8) | (c[1] &amp; 0xFF);                \
103       c01 |= (c01 &lt;&lt; 16);                                        \
104       dc01 = vis_to_double_dup(c01);                             \
105     } else if (nchannels == 3) {                                 \
106       c01 = ((c[0] &amp; 0xFF) &lt;&lt; 16) | ((c[1] &amp; 0xFF) &lt;&lt; 8) |       \
107              (c[2] &amp; 0xFF);                                      \
108       c02 = (c01 &lt;&lt; 16) | (c01 &gt;&gt; 8);                            \
109       c03 = (c01 &lt;&lt; 24) | c01;                                   \
110       c01 = (c01 &lt;&lt; 8) | (c01 &gt;&gt; 16);                            \
111       dc01= vis_to_double(c01, c02);                             \
112       dc02= vis_to_double(c03, c01);                             \
113       dc03= vis_to_double(c02, c03);                             \
114     } else {                                                     \
115       c01 = ((c[0] &amp; 0xFF) &lt;&lt; 24) | ((c[1] &amp; 0xFF) &lt;&lt; 16) |      \
116             ((c[2] &amp; 0xFF) &lt;&lt; 8) | (c[3] &amp; 0xFF);                \
117       dc01 = vis_to_double_dup(c01);                             \
118     }                                                            \
119   } else {                                                       \
120     width *= (4 * nchannels);                                    \
121     if (nchannels == 1) {                                        \
122       c01 = c[0] &amp; 0xFFFFFFFF;                                   \
123       dc01 = vis_to_double_dup(c01);                             \
124     } else if (nchannels == 2) {                                 \
125       c01 = c[0] &amp; 0xFFFFFFFF; c02 = c[1] &amp; 0xFFFFFFFF;          \
126       dc01 = vis_to_double(c01, c02);                            \
127     } else if (nchannels == 3) {                                 \
128       c01 = c[0] &amp; 0xFFFFFFFF; c02 = c[1] &amp; 0xFFFFFFFF;          \
129       c03 = c[2] &amp; 0xFFFFFFFF;                                   \
130       dc01= vis_to_double(c01, c02);                             \
131       dc02= vis_to_double(c03, c01);                             \
132       dc03= vis_to_double(c02, c03);                             \
133     } else {                                                     \
134       c01 = c[0] &amp; 0xFFFFFFFF; c02 = c[1] &amp; 0xFFFFFFFF;          \
135       c03 = c[2] &amp; 0xFFFFFFFF; c04 = c[3] &amp; 0xFFFFFFFF;          \
136       dc01= vis_to_double(c01, c02);                             \
137       dc02= vis_to_double(c03, c04);                             \
138     }                                                            \
139   }                                                              \
140                                                                  \
141   if ((width &gt; stride) || (width &gt; strided))                     \
142     return MLIB_FAILURE
143 
144 /***************************************************************/
145 
146 static mlib_status mlib_v_ImageConstLogic(mlib_image *dst,
147                                           mlib_image *src,
148                                           mlib_s32   *c)
149 {
150   mlib_s32 i, j;
151   mlib_s32 offdst, offsrc, emask;
152   mlib_d64 *dpp, *spp;
153   mlib_d64 sa1, sa2, da, sa;
154   mlib_d64 ssa, ssa1, ssa2, sa3, sa4;
155   mlib_s32 amount;
156   mlib_u8 *dend;
157   mlib_d64 c1, c2, c3;
158 
159   VALIDATE();
160 
161   if (nchannels == 3) {
162     if ((width == stride) &amp;&amp; (width == strided) &amp;&amp; ((width - (width / 3) * 3) == 0)) {
163 
164       amount = height * width;
165       dend = dp + amount - 1;
166       offdst = ((mlib_addr) dp) &amp; 7;
167       offsrc = ((mlib_addr) sp) &amp; 7;
168 
169       if (offsrc == offdst) {
170 
171         /* prepare the destination addresses */
172         dpp = (mlib_d64 *) vis_alignaddr(dp, 0);
173         i = (mlib_u8 *) dpp - dp;
174 
175         if (i != 0) {
176           vis_alignaddr((void *)(8 - offdst), 0);
177           c3 = vis_faligndata(dc03, dc01);
178           c1 = vis_faligndata(dc01, dc02);
179           c2 = vis_faligndata(dc02, dc03);
180         }
181         else {
182           c1 = dc01;
183           c2 = dc02;
184           c3 = dc03;
185         }
186 
187         /* prepare the destination addresses */
188         spp = (mlib_d64 *) vis_alignaddr(sp, 0);
189 
190         if (i != 0) {
191           /* generate edge mask for the start point */
192           emask = vis_edge8(dp, dend);
193           sa1 = *spp++;
194           da = VIS_CONSTLOGIC(c3, sa1);
195           vis_pst_8(da, dpp++, emask);
196           i += 8;
197         }
198 
199 #pragma pipeloop(0)
200         for (; i &lt; amount - 24; i += 24) {
201           dpp[0] = VIS_CONSTLOGIC(c1, spp[0]);
202           dpp[1] = VIS_CONSTLOGIC(c2, spp[1]);
203           dpp[2] = VIS_CONSTLOGIC(c3, spp[2]);
204           dpp += 3;
205           spp += 3;
206         }
207 
208         if (i &lt; amount) {
209           emask = vis_edge8(dpp, dend);
210           sa1 = *spp++;
211           da = VIS_CONSTLOGIC(c1, sa1);
212           vis_pst_8(da, dpp++, emask);
213           i += 8;
214         }
215 
216         if (i &lt; amount) {
217           emask = vis_edge8(dpp, dend);
218           sa1 = *spp++;
219           da = VIS_CONSTLOGIC(c2, sa1);
220           vis_pst_8(da, dpp++, emask);
221           i += 8;
222         }
223 
224         if (i &lt; amount) {
225           emask = vis_edge8(dpp, dend);
226           sa1 = *spp++;
227           da = VIS_CONSTLOGIC(c3, sa1);
228           vis_pst_8(da, dpp, emask);
229         }
230       }
231       else {
232         /* prepare the destination addresses */
233         dpp = (mlib_d64 *) vis_alignaddr(dp, 0);
234         i = (mlib_u8 *) dpp - dp;
235 
236         if (i != 0) {
237           vis_alignaddr((void *)(8 - offdst), 0);
238           c3 = vis_faligndata(dc03, dc01);
239           c1 = vis_faligndata(dc01, dc02);
240           c2 = vis_faligndata(dc02, dc03);
241         }
242         else {
243           c1 = dc01;
244           c2 = dc02;
245           c3 = dc03;
246         }
247 
248         /* prepare the destination addresses */
249         spp = (mlib_d64 *) vis_alignaddr(sp, i);
250 
251         sa1 = spp[0];
252 
253         if (i != 0) {
254           /* generate edge mask for the start point */
255           emask = vis_edge8(dp, dend);
256           sa2 = spp[1];
257           sa = vis_faligndata(sa1, sa2);
258           da = VIS_CONSTLOGIC(c3, sa);
259           vis_pst_8(da, dpp++, emask);
260           sa1 = sa2;
261           i += 8;
262           spp++;
263         }
264 
265 #pragma pipeloop(0)
266         for (; i &lt; amount - 24; i += 24) {
267           sa2 = spp[1];
268           ssa = vis_faligndata(sa1, sa2);
269           dpp[0] = VIS_CONSTLOGIC(c1, ssa);
270           sa3 = spp[2];
271           ssa1 = vis_faligndata(sa2, sa3);
272           dpp[1] = VIS_CONSTLOGIC(c2, ssa1);
273           sa4 = spp[3];
274           ssa2 = vis_faligndata(sa3, sa4);
275           dpp[2] = VIS_CONSTLOGIC(c3, ssa2);
276           sa1 = sa4;
277           dpp += 3;
278           spp += 3;
279         }
280 
281         if (i &lt; amount) {
282           emask = vis_edge8(dpp, dend);
283           sa2 = spp[1];
284           sa = vis_faligndata(sa1, sa2);
285           da = VIS_CONSTLOGIC(c1, sa);
286           vis_pst_8(da, dpp++, emask);
287           sa1 = sa2;
288           i += 8;
289           spp++;
290         }
291 
292         if (i &lt; amount) {
293           emask = vis_edge8(dpp, dend);
294           sa2 = spp[1];
295           sa = vis_faligndata(sa1, sa2);
296           da = VIS_CONSTLOGIC(c2, sa);
297           vis_pst_8(da, dpp++, emask);
298           sa1 = sa2;
299           i += 8;
300           spp++;
301         }
302 
303         if (i &lt; amount) {
304           emask = vis_edge8(dpp, dend);
305           sa2 = spp[1];
306           sa = vis_faligndata(sa1, sa2);
307           da = VIS_CONSTLOGIC(c3, sa);
308           vis_pst_8(da, dpp++, emask);
309         }
310       }
311     }
312     else {
313 
314       sl = sp;
315       dl = dp;
316 
317       amount = width;
318 
319       for (j = 0; j &lt; height; j++) {
320 
321         dend = dp + amount - 1;
322         offdst = ((mlib_addr) dp) &amp; 7;
323         offsrc = ((mlib_addr) sp) &amp; 7;
324 
325         if (offsrc == offdst) {
326 
327           /* prepare the destination addresses */
328           dpp = (mlib_d64 *) vis_alignaddr(dp, 0);
329           i = (mlib_u8 *) dpp - dp;
330 
331           if (i != 0) {
332             vis_alignaddr((void *)(8 - offdst), 0);
333             c3 = vis_faligndata(dc03, dc01);
334             c1 = vis_faligndata(dc01, dc02);
335             c2 = vis_faligndata(dc02, dc03);
336           }
337           else {
338             c1 = dc01;
339             c2 = dc02;
340             c3 = dc03;
341           }
342 
343           /* prepare the destination addresses */
344           spp = (mlib_d64 *) vis_alignaddr(sp, 0);
345 
346           if (i != 0) {
347             /* generate edge mask for the start point */
348             emask = vis_edge8(dp, dend);
349             sa1 = *spp++;
350             da = VIS_CONSTLOGIC(c3, sa1);
351             vis_pst_8(da, dpp++, emask);
352             i += 8;
353           }
354 
355 #pragma pipeloop(0)
356           for (; i &lt; amount - 24; i += 24) {
357             dpp[0] = VIS_CONSTLOGIC(c1, spp[0]);
358             dpp[1] = VIS_CONSTLOGIC(c2, spp[1]);
359             dpp[2] = VIS_CONSTLOGIC(c3, spp[2]);
360             dpp += 3;
361             spp += 3;
362           }
363 
364           if (i &lt; amount) {
365             emask = vis_edge8(dpp, dend);
366             sa1 = *spp++;
367             da = VIS_CONSTLOGIC(c1, sa1);
368             vis_pst_8(da, dpp++, emask);
369             i += 8;
370           }
371 
372           if (i &lt; amount) {
373             emask = vis_edge8(dpp, dend);
374             sa1 = *spp++;
375             da = VIS_CONSTLOGIC(c2, sa1);
376             vis_pst_8(da, dpp++, emask);
377             i += 8;
378           }
379 
380           if (i &lt; amount) {
381             emask = vis_edge8(dpp, dend);
382             sa1 = *spp++;
383             da = VIS_CONSTLOGIC(c3, sa1);
384             vis_pst_8(da, dpp, emask);
385           }
386         }
387         else {
388           /* prepare the destination addresses */
389           dpp = (mlib_d64 *) vis_alignaddr(dp, 0);
390           i = (mlib_u8 *) dpp - dp;
391 
392           if (i != 0) {
393             vis_alignaddr((void *)(8 - offdst), 0);
394             c3 = vis_faligndata(dc03, dc01);
395             c1 = vis_faligndata(dc01, dc02);
396             c2 = vis_faligndata(dc02, dc03);
397           }
398           else {
399             c1 = dc01;
400             c2 = dc02;
401             c3 = dc03;
402           }
403 
404           /* prepare the destination addresses */
405           spp = (mlib_d64 *) vis_alignaddr(sp, i);
406 
407           sa1 = spp[0];
408 
409           if (i != 0) {
410             /* generate edge mask for the start point */
411             emask = vis_edge8(dp, dend);
412             sa2 = spp[1];
413             sa = vis_faligndata(sa1, sa2);
414             da = VIS_CONSTLOGIC(c3, sa);
415             vis_pst_8(da, dpp++, emask);
416             sa1 = sa2;
417             i += 8;
418             spp++;
419           }
420 
421 #pragma pipeloop(0)
422           for (; i &lt; amount - 24; i += 24) {
423             sa2 = spp[1];
424             sa = vis_faligndata(sa1, sa2);
425             dpp[0] = VIS_CONSTLOGIC(c1, sa);
426             sa1 = spp[2];
427             sa = vis_faligndata(sa2, sa1);
428             dpp[1] = VIS_CONSTLOGIC(c2, sa);
429             sa2 = spp[3];
430             sa = vis_faligndata(sa1, sa2);
431             dpp[2] = VIS_CONSTLOGIC(c3, sa);
432             sa1 = sa2;
433             dpp += 3;
434             spp += 3;
435           }
436 
437           if (i &lt; amount) {
438             emask = vis_edge8(dpp, dend);
439             sa2 = spp[1];
440             sa = vis_faligndata(sa1, sa2);
441             da = VIS_CONSTLOGIC(c1, sa);
442             vis_pst_8(da, dpp++, emask);
443             sa1 = sa2;
444             i += 8;
445             spp++;
446           }
447 
448           if (i &lt; amount) {
449             emask = vis_edge8(dpp, dend);
450             sa2 = spp[1];
451             sa = vis_faligndata(sa1, sa2);
452             da = VIS_CONSTLOGIC(c2, sa);
453             vis_pst_8(da, dpp++, emask);
454             sa1 = sa2;
455             i += 8;
456             spp++;
457           }
458 
459           if (i &lt; amount) {
460             emask = vis_edge8(dpp, dend);
461             sa2 = spp[1];
462             sa = vis_faligndata(sa1, sa2);
463             da = VIS_CONSTLOGIC(c3, sa);
464             vis_pst_8(da, dpp++, emask);
465           }
466         }
467 
468         sp = sl += stride;
469         dp = dl += strided;
470       }
471     }
472 
473   }
474   else if ((type != MLIB_INT) || (nchannels != 4)) {
475 
476     if ((width == stride) &amp;&amp; (width == strided)) {
477 
478       amount = height * width;
479       dend = dp + amount - 1;
480       offdst = ((mlib_addr) dp) &amp; 7;
481       offsrc = ((mlib_addr) sp) &amp; 7;
482 
483       if (offsrc == offdst) {
484 
485         /* prepare the destination addresses */
486         dpp = (mlib_d64 *) vis_alignaddr(dp, 0);
487         i = (mlib_u8 *) dpp - dp;
488 
489         if (i != 0) {
490           vis_alignaddr((void *)(8 - offdst), 0);
491           c1 = vis_faligndata(dc01, dc01);
492         }
493         else {
494           c1 = dc01;
495         }
496 
497         /* prepare the destination addresses */
498         spp = (mlib_d64 *) vis_alignaddr(sp, 0);
499 
500         if (i != 0) {
501           /* generate edge mask for the start point */
502           emask = vis_edge8(dp, dend);
503           sa1 = *spp++;
504           da = VIS_CONSTLOGIC(c1, sa1);
505           vis_pst_8(da, dpp++, emask);
506           i += 8;
507         }
508 
509 #pragma pipeloop(0)
510         for (; i &lt; amount - 8; i += 8) {
511           *dpp++ = VIS_CONSTLOGIC(c1, *spp);
512           spp++;
513         }
514 
515         if (i &lt; amount) {
516           emask = vis_edge8(dpp, dend);
517           sa1 = *spp;
518           da = VIS_CONSTLOGIC(c1, sa1);
519           vis_pst_8(da, dpp, emask);
520         }
521       }
522       else {
523         /* prepare the destination addresses */
524         dpp = (mlib_d64 *) vis_alignaddr(dp, 0);
525         i = (mlib_u8 *) dpp - dp;
526 
527         if (i != 0) {
528           vis_alignaddr((void *)(8 - offdst), 0);
529           c1 = vis_faligndata(dc01, dc01);
530         }
531         else {
532           c1 = dc01;
533         }
534 
535         /* prepare the destination addresses */
536         spp = (mlib_d64 *) vis_alignaddr(sp, i);
537 
538         sa1 = spp[0];
539 
540         if (i != 0) {
541           /* generate edge mask for the start point */
542           emask = vis_edge8(dp, dend);
543           sa2 = spp[1];
544           sa = vis_faligndata(sa1, sa2);
545           da = VIS_CONSTLOGIC(c1, sa);
546           vis_pst_8(da, dpp++, emask);
547           sa1 = sa2;
548           i += 8;
549           spp++;
550         }
551 
552 #pragma pipeloop(0)
553         for (; i &lt; amount - 8; i += 8) {
554           sa2 = spp[1];
555           sa = vis_faligndata(sa1, sa2);
556           *dpp++ = VIS_CONSTLOGIC(c1, sa);
557           sa1 = sa2;
558           spp++;
559         }
560 
561         if (i &lt; amount) {
562           emask = vis_edge8(dpp, dend);
563           sa2 = spp[1];
564           sa = vis_faligndata(sa1, sa2);
565           da = VIS_CONSTLOGIC(c1, sa);
566           vis_pst_8(da, dpp, emask);
567         }
568       }
569     }
570     else {
571 
572       sl = sp;
573       dl = dp;
574 
575       amount = width;
576 
577       for (j = 0; j &lt; height; j++) {
578 
579         dend = dp + amount - 1;
580         offdst = ((mlib_addr) dp) &amp; 7;
581         offsrc = ((mlib_addr) sp) &amp; 7;
582 
583         if (offsrc == offdst) {
584 
585           /* prepare the destination addresses */
586           dpp = (mlib_d64 *) vis_alignaddr(dp, 0);
587           i = (mlib_u8 *) dpp - dp;
588 
589           if (i != 0) {
590             vis_alignaddr((void *)(8 - offdst), 0);
591             c1 = vis_faligndata(dc01, dc01);
592           }
593           else {
594             c1 = dc01;
595           }
596 
597           /* prepare the destination addresses */
598           spp = (mlib_d64 *) vis_alignaddr(sp, 0);
599 
600           if (i != 0) {
601             /* generate edge mask for the start point */
602             emask = vis_edge8(dp, dend);
603             sa1 = *spp++;
604             da = VIS_CONSTLOGIC(c1, sa1);
605             vis_pst_8(da, dpp++, emask);
606             i += 8;
607           }
608 
609 #pragma pipeloop(0)
610           for (; i &lt; amount - 8; i += 8) {
611             *dpp++ = VIS_CONSTLOGIC(c1, *spp);
612             spp++;
613           }
614 
615           if (i &lt; amount) {
616             emask = vis_edge8(dpp, dend);
617             sa1 = *spp;
618             da = VIS_CONSTLOGIC(c1, sa1);
619             vis_pst_8(da, dpp, emask);
620           }
621         }
622         else {
623           /* prepare the destination addresses */
624           dpp = (mlib_d64 *) vis_alignaddr(dp, 0);
625           i = (mlib_u8 *) dpp - dp;
626 
627           if (i != 0) {
628             vis_alignaddr((void *)(8 - offdst), 0);
629             c1 = vis_faligndata(dc01, dc01);
630           }
631           else {
632             c1 = dc01;
633           }
634 
635           /* prepare the destination addresses */
636           spp = (mlib_d64 *) vis_alignaddr(sp, i);
637 
638           sa1 = spp[0];
639 
640           if (i != 0) {
641             /* generate edge mask for the start point */
642             emask = vis_edge8(dp, dend);
643             sa2 = spp[1];
644             sa = vis_faligndata(sa1, sa2);
645             da = VIS_CONSTLOGIC(c1, sa);
646             vis_pst_8(da, dpp++, emask);
647             sa1 = sa2;
648             i += 8;
649             spp++;
650           }
651 
652 #pragma pipeloop(0)
653           for (; i &lt; amount - 8; i += 8) {
654             sa2 = spp[1];
655             sa = vis_faligndata(sa1, sa2);
656             *dpp++ = VIS_CONSTLOGIC(c1, sa);
657             sa1 = sa2;
658             spp++;
659           }
660 
661           if (i &lt; amount) {
662             emask = vis_edge8(dpp, dend);
663             sa2 = spp[1];
664             sa = vis_faligndata(sa1, sa2);
665             da = VIS_CONSTLOGIC(c1, sa);
666             vis_pst_8(da, dpp, emask);
667           }
668         }
669 
670         sp = sl += stride;
671         dp = dl += strided;
672       }
673     }
674 
675   }
676   else {
677 
678     if ((width == stride) &amp;&amp; (width == strided)) {
679 
680       amount = height * width;
681       dend = dp + amount - 1;
682       offdst = ((mlib_addr) dp) &amp; 7;
683       offsrc = ((mlib_addr) sp) &amp; 7;
684 
685       if (offsrc == offdst) {
686 
687         /* prepare the destination addresses */
688         dpp = (mlib_d64 *) vis_alignaddr(dp, 0);
689         i = (mlib_u8 *) dpp - dp;
690 
691         if (i != 0) {
692           vis_alignaddr((void *)(8 - offdst), 0);
693           c2 = vis_faligndata(dc02, dc01);
694           c1 = vis_faligndata(dc01, dc02);
695         }
696         else {
697           c1 = dc01;
698           c2 = dc02;
699         }
700 
701         /* prepare the destination addresses */
702         spp = (mlib_d64 *) vis_alignaddr(sp, 0);
703 
704         if (i != 0) {
705           /* generate edge mask for the start point */
706           emask = vis_edge8(dp, dend);
707           sa1 = *spp++;
708           da = VIS_CONSTLOGIC(c2, sa1);
709           vis_pst_8(da, dpp++, emask);
710           i += 8;
711         }
712 
713 #pragma pipeloop(0)
714         for (; i &lt; amount - 16; i += 16) {
715           dpp[0] = VIS_CONSTLOGIC(c1, spp[0]);
716           dpp[1] = VIS_CONSTLOGIC(c2, spp[1]);
717           dpp += 2;
718           spp += 2;
719         }
720 
721         if (i &lt; amount) {
722           emask = vis_edge8(dpp, dend);
723           sa1 = *spp++;
724           da = VIS_CONSTLOGIC(c1, sa1);
725           vis_pst_8(da, dpp++, emask);
726           i += 8;
727         }
728 
729         if (i &lt; amount) {
730           emask = vis_edge8(dpp, dend);
731           sa1 = *spp;
732           da = VIS_CONSTLOGIC(c2, sa1);
733           vis_pst_8(da, dpp++, emask);
734         }
735       }
736       else {
737         /* prepare the destination addresses */
738         dpp = (mlib_d64 *) vis_alignaddr(dp, 0);
739         i = (mlib_u8 *) dpp - dp;
740 
741         if (i != 0) {
742           vis_alignaddr((void *)(8 - offdst), 0);
743           c2 = vis_faligndata(dc02, dc01);
744           c1 = vis_faligndata(dc01, dc02);
745         }
746         else {
747           c1 = dc01;
748           c2 = dc02;
749         }
750 
751         /* prepare the destination addresses */
752         spp = (mlib_d64 *) vis_alignaddr(sp, i);
753 
754         sa1 = spp[0];
755 
756         if (i != 0) {
757           /* generate edge mask for the start point */
758           emask = vis_edge8(dp, dend);
759           sa2 = spp[1];
760           sa = vis_faligndata(sa1, sa2);
761           da = VIS_CONSTLOGIC(c2, sa);
762           vis_pst_8(da, dpp++, emask);
763           sa1 = sa2;
764           i += 8;
765           spp++;
766         }
767 
768 #pragma pipeloop(0)
769         for (; i &lt; amount - 16; i += 16) {
770           sa2 = spp[1];
771           ssa = vis_faligndata(sa1, sa2);
772           dpp[0] = VIS_CONSTLOGIC(c1, ssa);
773           sa3 = spp[2];
774           ssa1 = vis_faligndata(sa2, sa3);
775           dpp[1] = VIS_CONSTLOGIC(c2, ssa1);
776           sa1 = sa3;
777           dpp += 2;
778           spp += 2;
779         }
780 
781         if (i &lt; amount) {
782           emask = vis_edge8(dpp, dend);
783           sa2 = spp[1];
784           sa = vis_faligndata(sa1, sa2);
785           da = VIS_CONSTLOGIC(c1, sa);
786           vis_pst_8(da, dpp++, emask);
787           sa1 = sa2;
788           i += 8;
789           spp++;
790         }
791 
792         if (i &lt; amount) {
793           emask = vis_edge8(dpp, dend);
794           sa2 = spp[1];
795           sa = vis_faligndata(sa1, sa2);
796           da = VIS_CONSTLOGIC(c2, sa);
797           vis_pst_8(da, dpp++, emask);
798         }
799       }
800     }
801     else {
802 
803       sl = sp;
804       dl = dp;
805 
806       amount = width;
807 
808       for (j = 0; j &lt; height; j++) {
809 
810         dend = dp + amount - 1;
811         offdst = ((mlib_addr) dp) &amp; 7;
812         offsrc = ((mlib_addr) sp) &amp; 7;
813 
814         if (offsrc == offdst) {
815 
816           /* prepare the destination addresses */
817           dpp = (mlib_d64 *) vis_alignaddr(dp, 0);
818           i = (mlib_u8 *) dpp - dp;
819 
820           if (i != 0) {
821             vis_alignaddr((void *)(8 - offdst), 0);
822             c2 = vis_faligndata(dc02, dc01);
823             c1 = vis_faligndata(dc01, dc02);
824           }
825           else {
826             c1 = dc01;
827             c2 = dc02;
828           }
829 
830           /* prepare the destination addresses */
831           spp = (mlib_d64 *) vis_alignaddr(sp, 0);
832 
833           if (i != 0) {
834             /* generate edge mask for the start point */
835             emask = vis_edge8(dp, dend);
836             sa1 = *spp++;
837             da = VIS_CONSTLOGIC(c2, sa1);
838             vis_pst_8(da, dpp++, emask);
839             i += 8;
840           }
841 
842 #pragma pipeloop(0)
843           for (; i &lt; amount - 16; i += 16) {
844             dpp[0] = VIS_CONSTLOGIC(c1, spp[0]);
845             dpp[1] = VIS_CONSTLOGIC(c2, spp[1]);
846             dpp += 2;
847             spp += 2;
848           }
849 
850           if (i &lt; amount) {
851             emask = vis_edge8(dpp, dend);
852             sa1 = *spp++;
853             da = VIS_CONSTLOGIC(c1, sa1);
854             vis_pst_8(da, dpp++, emask);
855             i += 8;
856           }
857 
858           if (i &lt; amount) {
859             emask = vis_edge8(dpp, dend);
860             sa1 = *spp;
861             da = VIS_CONSTLOGIC(c2, sa1);
862             vis_pst_8(da, dpp++, emask);
863           }
864         }
865         else {
866           /* prepare the destination addresses */
867           dpp = (mlib_d64 *) vis_alignaddr(dp, 0);
868           i = (mlib_u8 *) dpp - dp;
869 
870           if (i != 0) {
871             vis_alignaddr((void *)(8 - offdst), 0);
872             c2 = vis_faligndata(dc02, dc01);
873             c1 = vis_faligndata(dc01, dc02);
874           }
875           else {
876             c1 = dc01;
877             c2 = dc02;
878           }
879 
880           /* prepare the destination addresses */
881           spp = (mlib_d64 *) vis_alignaddr(sp, i);
882 
883           sa1 = spp[0];
884 
885           if (i != 0) {
886             /* generate edge mask for the start point */
887             emask = vis_edge8(dp, dend);
888             sa2 = spp[1];
889             sa = vis_faligndata(sa1, sa2);
890             da = VIS_CONSTLOGIC(c2, sa);
891             vis_pst_8(da, dpp++, emask);
892             sa1 = sa2;
893             i += 8;
894             spp++;
895           }
896 
897 #pragma pipeloop(0)
898           for (; i &lt; amount - 16; i += 16) {
899             sa2 = spp[1];
900             ssa = vis_faligndata(sa1, sa2);
901             dpp[0] = VIS_CONSTLOGIC(c1, ssa);
902             sa3 = spp[2];
903             ssa1 = vis_faligndata(sa2, sa3);
904             dpp[1] = VIS_CONSTLOGIC(c2, ssa1);
905             sa1 = sa3;
906             dpp += 2;
907             spp += 2;
908           }
909 
910           if (i &lt; amount) {
911             emask = vis_edge8(dpp, dend);
912             sa2 = spp[1];
913             sa = vis_faligndata(sa1, sa2);
914             da = VIS_CONSTLOGIC(c1, sa);
915             vis_pst_8(da, dpp++, emask);
916             sa1 = sa2;
917             i += 8;
918             spp++;
919           }
920 
921           if (i &lt; amount) {
922             emask = vis_edge8(dpp, dend);
923             sa2 = spp[1];
924             sa = vis_faligndata(sa1, sa2);
925             da = VIS_CONSTLOGIC(c2, sa);
926             vis_pst_8(da, dpp++, emask);
927           }
928         }
929 
930         sp = sl += stride;
931         dp = dl += strided;
932       }
933     }
934   }
935 
936   return MLIB_SUCCESS;
937 }
938 
939 /***************************************************************/
940 
941 #ifdef __cplusplus
942 }
943 #endif /* __cplusplus */
944 #endif /* __MLIB_V_IMAGECONSTLOGIC_H */
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libawt/java2d/loops/mlib_v_ImageClear_f.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 /*
 28  *
 29  * DESCRIPTION
 30  *      Clear of an image to a specific color.
 31  *      -- VIS version low level functions.
 32  *
 33  * NOTE
 34  *      These functions are separated from mlib_v_ImageClear.c
 35  *      for structure clarity.
 36  */
 37 
 38 #include &lt;vis_proto.h&gt;
 39 #include &lt;mlib_image.h&gt;
 40 #include &lt;mlib_v_ImageClear_f.h&gt;
 41 
 42 /***************************************************************/
 43 
 44 #define PREPAREVARS(type, chan)                                  \
 45   type *pimg = (type *) mlib_ImageGetData(img);                  \
 46   mlib_s32 img_height = mlib_ImageGetHeight(img);                \
 47   mlib_s32 img_width  = mlib_ImageGetWidth(img);                 \
 48   mlib_s32 img_stride = mlib_ImageGetStride(img) / sizeof(type); \
 49   mlib_s32       i, l, j;                                        \
 50   mlib_s32 emask;                                                \
 51   mlib_d64 dcolor, *dpimg;                                       \
 52                                                                  \
 53   if ((img_width * chan) == img_stride) {                        \
 54     img_width *= img_height;                                     \
 55     img_height = 1;                                              \
 56   }
 57 
 58 /***************************************************************/
 59 
 60 #define STRIP(pd, color, w, h, chan, data_type)                    \
 61   for (l = 0; l &lt; chan; l++) {                                     \
 62     data_type color_i = color[l];                                  \
 63     for (i = 0; i &lt; h; i++) {                                      \
 64       for (j = 0; j &lt; w; j++) pd[i*img_stride+l+j*chan] = color_i; \
 65     }                                                              \
 66   }
 67 
 68 /***************************************************************/
 69 
 70 void mlib_v_ImageClear_BIT_1(mlib_image     *img,
 71                              const mlib_s32 *color)
 72 {
 73   mlib_u8 *pimg = (mlib_u8 *) mlib_ImageGetData(img);
 74   mlib_s32 img_height = mlib_ImageGetHeight(img);
 75   mlib_s32 img_width = mlib_ImageGetWidth(img);
 76   mlib_s32 img_stride = mlib_ImageGetStride(img);
 77   mlib_s32 img_bitoff = mlib_ImageGetBitOffset(img);
 78   mlib_s32 i, j, b_j, k;
 79   mlib_u8 bcolor0, bmask, emask, src;
 80   mlib_d64 dcolor, *dpimg;
 81   mlib_u32 color0;
 82 
 83   if (img_width == img_stride * 8) {
 84     img_width *= img_height;
 85     img_height = 1;
 86   }
 87 
 88   color0 = ((color[0] &amp; 1) &lt;&lt; 31) &gt;&gt; 31;
 89   bcolor0 = color0 &amp; 0xFF;
 90 
 91   dcolor = vis_to_double_dup(color0);
 92   for (i = 0, j = 0; i &lt; img_height; i++) {
 93     mlib_u8 *pimg_row = pimg + i * img_stride, *pimg_row_end;
 94 
 95     if (img_bitoff + img_width &lt;= 8) {
 96       bmask = (0xFF &gt;&gt; (8 - img_width)) &lt;&lt; (8 - img_bitoff - img_width);
 97       src = pimg_row[0];
 98       pimg_row[0] = (src &amp; ~bmask) | (color0 &amp; bmask);
 99       continue;
100     }
101     else {
102       bmask = 0xFF &gt;&gt; img_bitoff;
103       src = pimg_row[0];
104       pimg_row[0] = (src &amp; ~bmask) | (color0 &amp; bmask);
105       pimg_row++;
106       j = 8 - img_bitoff;
107       b_j = (img_width - j) / 8;
108     }
109 
110     if (b_j &lt; 16) {
111       mlib_s32 ii;
112 
113       for (ii = 0; ii &lt; b_j; ii++)
114         pimg_row[ii] = bcolor0;
115 
116       pimg_row += ii;
117       j += ii &lt;&lt; 3;
118 
119       if (j &lt; img_width) {
120         bmask = (0xFF &lt;&lt; (8 - (img_width - j))) &amp; 0xFF;
121         src = pimg_row[0];
122         pimg_row[0] = (src &amp; ~bmask) | (color0 &amp; bmask);
123       }
124 
125       continue;
126     }
127 
128     pimg_row_end = pimg_row + b_j - 1;
129     dpimg = (mlib_d64 *) vis_alignaddr(pimg_row, 0);
130 
131     emask = vis_edge8(pimg_row, pimg_row_end);
132     vis_pst_8(dcolor, dpimg++, emask);
133     k = (mlib_addr) dpimg - (mlib_addr) pimg_row;
134     for (; k &lt; (b_j - 8); k += 8)
135       *dpimg++ = dcolor;
136     emask = vis_edge8(dpimg, pimg_row_end);
137     vis_pst_8(dcolor, dpimg, emask);
138     j += b_j &lt;&lt; 3;
139 
140     if (j &lt; img_width) {
141       pimg_row = (mlib_u8 *) (pimg_row_end + 1);
142       bmask = (0xFF &lt;&lt; (8 - (img_width - j))) &amp; 0xFF;
143       src = pimg_row[0];
144       pimg_row[0] = (src &amp; ~bmask) | (color0 &amp; bmask);
145     }
146   }
147 }
148 
149 /***************************************************************/
150 
151 void mlib_v_ImageClear_BIT_2(mlib_image     *img,
152                              const mlib_s32 *color)
153 {
154   mlib_u8 *pimg = (mlib_u8 *) mlib_ImageGetData(img); /* pointer to the data of img-image */
155   mlib_s32 img_height = mlib_ImageGetHeight(img);     /* height of source image */
156   mlib_s32 img_width = mlib_ImageGetWidth(img) &lt;&lt; 1;  /* width of source image */
157   mlib_s32 img_stride = mlib_ImageGetStride(img);     /* elements to next row */
158   mlib_s32 img_bitoff = mlib_ImageGetBitOffset(img);  /* bits to first byte */
159   mlib_s32 i, j, b_j, k;                              /* indicies */
160   mlib_u8 bcolor0, bmask, emask, src;
161   mlib_d64 dcolor, *dpimg;
162   mlib_u32 color0 = color[0] &amp; 1, color1 = color[1] &amp; 1;
163 
164   if (img_width == img_stride * 8) {
165     img_width *= img_height;
166     img_height = 1;
167   }
168 
169   color1 = (color0 &lt;&lt; 1) | color1;
170   color1 = (color1 &lt;&lt; 2) | color1;
171   color1 = (color1 &lt;&lt; 4) | color1;
172   color0 = ((color1 &lt;&lt; 1) &amp; 0xFE) | color0;
173   bcolor0 = ((img_bitoff &amp; 1) == 0) ? color1 : color0;
174   color0 = (bcolor0 &lt;&lt; 8) | bcolor0;
175   color0 = (color0 &lt;&lt; 16) | color0;
176 
177   dcolor = vis_to_double_dup(color0);
178   for (i = 0, j = 0; i &lt; img_height; i++) {
179     mlib_u8 *pimg_row = pimg + i * img_stride, *pimg_row_end;
180 
181     if (img_bitoff + img_width &lt;= 8) {
182       bmask = (0xFF &gt;&gt; (8 - img_width)) &lt;&lt; (8 - img_bitoff - img_width);
183       src = pimg_row[0];
184       pimg_row[0] = (src &amp; ~bmask) | (color0 &amp; bmask);
185       continue;
186     }
187     else {
188       bmask = 0xFF &gt;&gt; img_bitoff;
189       src = pimg_row[0];
190       pimg_row[0] = (src &amp; ~bmask) | (color0 &amp; bmask);
191       pimg_row++;
192       j = 8 - img_bitoff;
193       b_j = (img_width - j) / 8;
194     }
195 
196     if (b_j &lt; 16) {
197       mlib_s32 ii;
198 
199       for (ii = 0; ii &lt; b_j; ii++)
200         pimg_row[ii] = bcolor0;
201 
202       pimg_row += ii;
203       j += ii &lt;&lt; 3;
204 
205       if (j &lt; img_width) {
206         bmask = (0xFF &lt;&lt; (8 - (img_width - j))) &amp; 0xFF;
207         src = pimg_row[0];
208         pimg_row[0] = (src &amp; ~bmask) | (color0 &amp; bmask);
209       }
210 
211       continue;
212     }
213 
214     pimg_row_end = pimg_row + b_j - 1;
215     dpimg = (mlib_d64 *) vis_alignaddr(pimg_row, 0);
216 
217     emask = vis_edge8(pimg_row, pimg_row_end);
218     vis_pst_8(dcolor, dpimg++, emask);
219     k = (mlib_addr) dpimg - (mlib_addr) pimg_row;
220     for (; k &lt; (b_j - 8); k += 8)
221       *dpimg++ = dcolor;
222     emask = vis_edge8(dpimg, pimg_row_end);
223     vis_pst_8(dcolor, dpimg, emask);
224     j += b_j &lt;&lt; 3;
225 
226     if (j &lt; img_width) {
227       pimg_row = (mlib_u8 *) (pimg_row_end + 1);
228       bmask = (0xFF &lt;&lt; (8 - (img_width - j))) &amp; 0xFF;
229       src = pimg_row[0];
230       pimg_row[0] = (src &amp; ~bmask) | (color0 &amp; bmask);
231     }
232   }
233 }
234 
235 /***************************************************************/
236 
237 void mlib_v_ImageClear_BIT_3(mlib_image     *img,
238                              const mlib_s32 *color)
239 {
240   mlib_u8 *pimg = (mlib_u8 *) mlib_ImageGetData(img); /* pointer to the data of img-image */
241   mlib_s32 img_height = mlib_ImageGetHeight(img);     /* height of source image */
242   mlib_s32 img_width = mlib_ImageGetWidth(img) * 3;   /* width of source image */
243   mlib_s32 img_stride = mlib_ImageGetStride(img);     /* elements to next row */
244   mlib_s32 img_bitoff = mlib_ImageGetBitOffset(img);  /* bits to first byte */
245   mlib_s32 i, j, b_j, k, bit_shift;                   /* indicies */
246   mlib_u8 bcolor, bmask, emask, src;
247   mlib_d64 dcolor0, dcolor1, dcolor2, *dpimg;
248   mlib_d64 dcolor00, dcolor11, dcolor22;
249   mlib_u32 color0 = color[0] &amp; 1, color1 = color[1] &amp; 1, color2 = color[2] &amp; 1;
250   mlib_u32 col0, col1, col2;
251 
252   if (img_width == img_stride * 8) {
253     img_width *= img_height;
254     img_height = 1;
255   }
256 
257   col0 = (color0 &lt;&lt; 3) | (color1 &lt;&lt; 2) | (color2 &lt;&lt; 1) | color0;
258   col1 = (col0 &gt;&gt; 1) | (color2 &lt;&lt; 3);
259   col2 = (col1 &gt;&gt; 1) | (color1 &lt;&lt; 3);
260   color0 = (col0 &lt;&lt; 4) | col2;
261   color1 = (col1 &lt;&lt; 4) | col0;
262   color2 = (col2 &lt;&lt; 4) | col1;
263 
264   color0 = (color0 &lt;&lt; 24) | (color1 &lt;&lt; 16) | (color2 &lt;&lt; 8) | color0;
265   color1 = (color0 &lt;&lt; 8) | color1;
266   color2 = (color1 &lt;&lt; 8) | color2;
267 
268   dcolor0 = vis_to_double(color0, color1);
269   dcolor1 = vis_to_double(color2, color0);
270   dcolor2 = vis_to_double(color1, color2);
271 
272   for (i = 0; i &lt; img_height; i++) {
273     mlib_u8 *pimg_row = pimg + i * img_stride, *pimg_row_end;
274 
275     if (img_bitoff + img_width &lt;= 8) {
276       bmask = (0xFF &gt;&gt; (8 - img_width)) &lt;&lt; (8 - img_bitoff - img_width);
277       src = pimg_row[0];
278       bcolor = (color0 &gt;&gt; img_bitoff) &amp; 0xFF;
279       pimg_row[0] = (src &amp; ~bmask) | (bcolor &amp; bmask);
280       continue;
281     }
282     else {
283       bmask = 0xFF &gt;&gt; img_bitoff;
284       src = pimg_row[0];
285       bcolor = (color0 &gt;&gt; img_bitoff) &amp; 0xFF;
286       bit_shift = (((mlib_addr) pimg_row &amp; 7) &lt;&lt; 3) + img_bitoff;
287       pimg_row[0] = (src &amp; ~bmask) | (bcolor &amp; bmask);
288       pimg_row++;
289       j = 8 - img_bitoff;
290       b_j = (img_width - j) / 8;
291     }
292 
293     pimg_row_end = pimg_row + b_j - 1;
294 
295     dpimg = (mlib_d64 *) ((mlib_addr) pimg_row &amp; ~7);
296     vis_alignaddr((void *)(bit_shift % 3), 0);
297     dcolor22 = vis_faligndata(dcolor0, dcolor1);
298     dcolor00 = vis_faligndata(dcolor1, dcolor2);
299     dcolor11 = vis_faligndata(dcolor2, dcolor0);
300     emask = vis_edge8(pimg_row, pimg_row_end);
301 
302     if ((mlib_addr) pimg_row &amp; 7)
303       vis_pst_8(dcolor22, dpimg++, emask);
304     k = (mlib_addr) dpimg - (mlib_addr) pimg_row;
305     for (; k &lt;= (b_j - 24); k += 24) {
306       dpimg[0] = dcolor00;
307       dpimg[1] = dcolor11;
308       dpimg[2] = dcolor22;
309       dpimg += 3;
310     }
311 
312     if (k &lt; b_j) {
313       if (k &lt; (b_j - 8)) {
314         *dpimg++ = dcolor00;
315 
316         if (k &lt; (b_j - 16)) {
317           *dpimg++ = dcolor11;
318           dcolor00 = dcolor22;
319         }
320         else
321           dcolor00 = dcolor11;
322       }
323 
324       emask = vis_edge8(dpimg, pimg_row_end);
325       vis_pst_8(dcolor00, dpimg, emask);
326     }
327 
328     j = img_width - j - (b_j &lt;&lt; 3);
329 
330     if (j &gt; 0) {
331       pimg_row = (mlib_u8 *) (pimg_row_end + 1);
332       bmask = (0xFF &lt;&lt; (8 - j)) &amp; 0xFF;
333       bcolor = (color0 &gt;&gt; j) &amp; 0xFF;
334       src = pimg_row[0];
335       pimg_row[0] = (src &amp; ~bmask) | (bcolor &amp; bmask);
336     }
337   }
338 }
339 
340 /***************************************************************/
341 
342 void mlib_v_ImageClear_BIT_4(mlib_image     *img,
343                              const mlib_s32 *color)
344 {
345   mlib_u8 *pimg = (mlib_u8 *) mlib_ImageGetData(img); /* pointer to the data of img-image */
346   mlib_s32 img_height = mlib_ImageGetHeight(img);     /* height of source image */
347   mlib_s32 img_width = mlib_ImageGetWidth(img) &lt;&lt; 2;  /* width of source image */
348   mlib_s32 img_stride = mlib_ImageGetStride(img);     /* elements to next row */
349   mlib_s32 img_bitoff = mlib_ImageGetBitOffset(img);  /* bits to first byte */
350   mlib_s32 i, j, b_j, k;                              /* indicies */
351   mlib_u8 bcolor0, bmask, emask, src;
352   mlib_d64 dcolor, *dpimg;
353   mlib_u32 color0 = color[0] &amp; 1, color1 = color[1] &amp; 1, color2 = color[2] &amp; 1, color3 = color[3] &amp; 1;
354 
355   if (img_width == img_stride * 8) {
356     img_width *= img_height;
357     img_height = 1;
358   }
359 
360   color0 = (color0 &lt;&lt; 3) | (color1 &lt;&lt; 2) | (color2 &lt;&lt; 1) | color3;
361   color0 = (color0 &lt;&lt; 4) | color0;
362   color3 = (color0 &lt;&lt; 1) | (color0 &gt;&gt; 7);
363   color2 = (color0 &lt;&lt; 2) | (color0 &gt;&gt; 6);
364   color1 = (color0 &lt;&lt; 3) | (color0 &gt;&gt; 5);
365 
366   bcolor0 = (img_bitoff &amp; 2) ? ((img_bitoff &amp; 1) ? color3 : color2) : ((img_bitoff &amp; 1) ? color1 : color0);
367   color0 = (bcolor0 &lt;&lt; 24) | (bcolor0 &lt;&lt; 16) | (bcolor0 &lt;&lt; 8) | bcolor0;
368 
369   dcolor = vis_to_double_dup(color0);
370   for (i = 0, j = 0; i &lt; img_height; i++) {
371     mlib_u8 *pimg_row = pimg + i * img_stride, *pimg_row_end;
372 
373     if (img_bitoff + img_width &lt;= 8) {
374       bmask = (0xFF &gt;&gt; (8 - img_width)) &lt;&lt; (8 - img_bitoff - img_width);
375       src = pimg_row[0];
376       pimg_row[0] = (src &amp; ~bmask) | (color0 &amp; bmask);
377       continue;
378     }
379     else {
380       bmask = 0xFF &gt;&gt; img_bitoff;
381       src = pimg_row[0];
382       pimg_row[0] = (src &amp; ~bmask) | (color0 &amp; bmask);
383       pimg_row++;
384       j = 8 - img_bitoff;
385       b_j = (img_width - j) / 8;
386     }
387 
388     if (b_j &lt; 16) {
389       mlib_s32 ii;
390 
391       for (ii = 0; ii &lt; b_j; ii++)
392         pimg_row[ii] = bcolor0;
393 
394       pimg_row += ii;
395       j += ii &lt;&lt; 3;
396 
397       if (j &lt; img_width) {
398         bmask = (0xFF &lt;&lt; (8 - (img_width - j))) &amp; 0xFF;
399         src = pimg_row[0];
400         pimg_row[0] = (src &amp; ~bmask) | (color0 &amp; bmask);
401       }
402 
403       continue;
404     }
405 
406     pimg_row_end = pimg_row + b_j - 1;
407     dpimg = (mlib_d64 *) vis_alignaddr(pimg_row, 0);
408 
409     emask = vis_edge8(pimg_row, pimg_row_end);
410     vis_pst_8(dcolor, dpimg++, emask);
411     k = (mlib_addr) dpimg - (mlib_addr) pimg_row;
412     for (; k &lt; (b_j - 8); k += 8)
413       *dpimg++ = dcolor;
414     emask = vis_edge8(dpimg, pimg_row_end);
415     vis_pst_8(dcolor, dpimg, emask);
416     j += b_j &lt;&lt; 3;
417 
418     if (j &lt; img_width) {
419       pimg_row = (mlib_u8 *) (pimg_row_end + 1);
420       bmask = (0xFF &lt;&lt; (8 - (img_width - j))) &amp; 0xFF;
421       src = pimg_row[0];
422       pimg_row[0] = (src &amp; ~bmask) | (color0 &amp; bmask);
423     }
424   }
425 }
426 
427 /***************************************************************/
428 
429 void mlib_v_ImageClear_U8_1(mlib_image     *img,
430                             const mlib_s32 *color)
431 {
432   mlib_u32 color0 = color[0] &amp; 0xFF;
433 
434   PREPAREVARS(mlib_u8, 1);
435 
436   if (img_width &lt; 16) {
437     STRIP(pimg, color, img_width, img_height, 1, mlib_u8);
438     return;
439   }
440 
441   color0 |= (color0 &lt;&lt; 8);
442   color0 |= (color0 &lt;&lt; 16);
443   dcolor = vis_to_double_dup(color0);
444   for (i = 0; i &lt; img_height; i++) {
445     mlib_u8 *pimg_row = pimg + i * img_stride, *pimg_row_end = pimg_row + img_width - 1;
446 
447     dpimg = (mlib_d64 *) vis_alignaddr(pimg_row, 0);
448     emask = vis_edge8(pimg_row, pimg_row_end);
449     vis_pst_8(dcolor, dpimg++, emask);
450     j = (mlib_addr) dpimg - (mlib_addr) pimg_row;
451     for (; j &lt; (img_width - 8); j += 8)
452       *dpimg++ = dcolor;
453     emask = vis_edge8(dpimg, pimg_row_end);
454     vis_pst_8(dcolor, dpimg, emask);
455   }
456 }
457 
458 /***************************************************************/
459 
460 void mlib_v_ImageClear_U8_2(mlib_image     *img,
461                             const mlib_s32 *color)
462 {
463   mlib_u32 color0 = color[0] &amp; 0xFF, color1 = color[1] &amp; 0xFF;
464   mlib_d64 dcolor0;
465 
466   PREPAREVARS(mlib_u8, 2);
467 
468   if (img_width &lt; 8) {
469     STRIP(pimg, color, img_width, img_height, 2, mlib_u8);
470     return;
471   }
472 
473   color0 = (color0 &lt;&lt; 8) | color1;
474   color0 |= (color0 &lt;&lt; 16);
475   dcolor0 = vis_to_double_dup(color0);
476   for (i = 0; i &lt; img_height; i++) {
477     mlib_u8 *pimg_row = pimg + i * img_stride, *pimg_row_end = pimg_row + img_width * 2 - 1;
478 
479     dpimg = (mlib_d64 *) vis_alignaddr(pimg_row, 0);
480     emask = vis_edge8(pimg_row, pimg_row_end);
481     dcolor = vis_faligndata(dcolor0, dcolor0);
482     vis_pst_8(dcolor, dpimg++, emask);
483     j = (mlib_addr) dpimg - (mlib_addr) pimg_row;
484     for (; j &lt; (img_width * 2 - 8); j += 8)
485       *dpimg++ = dcolor;
486     emask = vis_edge8(dpimg, pimg_row_end);
487     vis_pst_8(dcolor, dpimg, emask);
488   }
489 }
490 
491 /***************************************************************/
492 
493 void mlib_v_ImageClear_U8_3(mlib_image     *img,
494                             const mlib_s32 *color)
495 {
496   mlib_u32 color0 = color[0] &amp; 0xFF, color1 = color[1] &amp; 0xFF, color2 = color[2] &amp; 0xFF, col;
497   mlib_d64 dcolor1, dcolor2, dcolor00, dcolor11, dcolor22;
498 
499   PREPAREVARS(mlib_u8, 3);
500 
501   if (img_width &lt; 16) {
502     STRIP(pimg, color, img_width, img_height, 3, mlib_u8);
503     return;
504   }
505 
506   col = (color0 &lt;&lt; 16) | (color1 &lt;&lt; 8) | color2;
507   color0 = (col &lt;&lt; 8) | color0;
508   color1 = (color0 &lt;&lt; 8) | color1;
509   color2 = (color1 &lt;&lt; 8) | color2;
510   dcolor = vis_to_double(color0, color1);
511   dcolor1 = vis_to_double(color2, color0);
512   dcolor2 = vis_to_double(color1, color2);
513   for (i = 0; i &lt; img_height; i++) {
514     mlib_u8 *pimg_row = pimg + i * img_stride, *pimg_row_end = pimg_row + img_width * 3 - 1;
515 
516     dpimg = (mlib_d64 *) ((mlib_addr) pimg_row &amp; ~7);
517     vis_alignaddr((void *)(-(mlib_addr) pimg_row), 8);
518     dcolor22 = vis_faligndata(dcolor2, dcolor);
519     dcolor00 = vis_faligndata(dcolor, dcolor1);
520     dcolor11 = vis_faligndata(dcolor1, dcolor2);
521     emask = vis_edge8(pimg_row, pimg_row_end);
522 
523     if ((mlib_addr) pimg_row &amp; 7)
524       vis_pst_8(dcolor22, dpimg++, emask);
525     j = (mlib_addr) dpimg - (mlib_addr) pimg_row;
526     for (; j &lt; (img_width * 3 - 24); j += 24) {
527       dpimg[0] = dcolor00;
528       dpimg[1] = dcolor11;
529       dpimg[2] = dcolor22;
530       dpimg += 3;
531     }
532 
533     if (j &lt; (img_width * 3 - 8)) {
534       *dpimg++ = dcolor00;
535 
536       if (j &lt; (img_width * 3 - 16)) {
537         *dpimg++ = dcolor11;
538         dcolor00 = dcolor22;
539       }
540       else
541         dcolor00 = dcolor11;
542     }
543 
544     emask = vis_edge8(dpimg, pimg_row_end);
545     vis_pst_8(dcolor00, dpimg, emask);
546   }
547 }
548 
549 /***************************************************************/
550 
551 void mlib_v_ImageClear_U8_4(mlib_image     *img,
552                             const mlib_s32 *color)
553 {
554   mlib_u32 color0 = color[0] &amp; 0xFF, color1 = color[1] &amp; 0xFF, color2 = color[2] &amp; 0xFF, color3 = color[3] &amp; 0xFF;
555   mlib_d64 dcolor0;
556 
557   PREPAREVARS(mlib_u8, 4);
558 
559   if (img_width &lt; 4) {
560     STRIP(pimg, color, img_width, img_height, 4, mlib_u8);
561     return;
562   }
563 
564   color0 = (color0 &lt;&lt; 24) | (color1 &lt;&lt; 16) | (color2 &lt;&lt; 8) | color3;
565   dcolor0 = vis_to_double_dup(color0);
566   for (i = 0; i &lt; img_height; i++) {
567     mlib_u8 *pimg_row = pimg + i * img_stride, *pimg_row_end = pimg_row + img_width * 4 - 1;
568 
569     dpimg = (mlib_d64 *) ((mlib_addr) pimg_row &amp; ~7);
570     vis_alignaddr((void *)(-(mlib_addr) pimg_row), 8);
571     emask = vis_edge8(pimg_row, pimg_row_end);
572     dcolor = vis_faligndata(dcolor0, dcolor0);
573     vis_pst_8(dcolor, dpimg++, emask);
574     j = (mlib_addr) dpimg - (mlib_addr) pimg_row;
575     for (; j &lt; (img_width * 4 - 8); j += 8)
576       *dpimg++ = dcolor;
577     emask = vis_edge8(dpimg, pimg_row_end);
578     vis_pst_8(dcolor, dpimg, emask);
579   }
580 }
581 
582 /***************************************************************/
583 
584 void mlib_v_ImageClear_S16_1(mlib_image     *img,
585                              const mlib_s32 *color)
586 {
587   mlib_u32 color0 = color[0] &amp; 0xFFFF;
588 
589   PREPAREVARS(mlib_s16, 1);
590 
591   if (img_width &lt; 8) {
592     STRIP(pimg, color, img_width, img_height, 1, mlib_s16);
593     return;
594   }
595 
596   color0 |= (color0 &lt;&lt; 16);
597   dcolor = vis_to_double_dup(color0);
598   for (i = 0; i &lt; img_height; i++) {
599     mlib_s16 *pimg_row = pimg + i * img_stride, *pimg_row_end = pimg_row + img_width - 1;
600 
601     dpimg = (mlib_d64 *) vis_alignaddr(pimg_row, 0);
602     emask = vis_edge16(pimg_row, pimg_row_end);
603     vis_pst_16(dcolor, dpimg++, emask);
604     j = (mlib_s16 *) dpimg - pimg_row;
605     for (; j &lt; (img_width - 4); j += 4)
606       *dpimg++ = dcolor;
607     emask = vis_edge16(dpimg, pimg_row_end);
608     vis_pst_16(dcolor, dpimg, emask);
609   }
610 }
611 
612 /***************************************************************/
613 
614 void mlib_v_ImageClear_S16_2(mlib_image     *img,
615                              const mlib_s32 *color)
616 {
617   mlib_u32 color0 = color[0] &amp; 0xFFFF, color1 = color[1] &amp; 0xFFFF;
618   mlib_d64 dcolor0;
619 
620   PREPAREVARS(mlib_s16, 2);
621 
622   if (img_width &lt; 4) {
623     STRIP(pimg, color, img_width, img_height, 2, mlib_s16);
624     return;
625   }
626 
627   color0 = (color0 &lt;&lt; 16) | color1;
628   dcolor0 = vis_to_double_dup(color0);
629   for (i = 0; i &lt; img_height; i++) {
630     mlib_s16 *pimg_row = pimg + i * img_stride, *pimg_row_end = pimg_row + img_width * 2 - 1;
631 
632     dpimg = (mlib_d64 *) vis_alignaddr(pimg_row, 0);
633     emask = vis_edge16(pimg_row, pimg_row_end);
634     dcolor = vis_faligndata(dcolor0, dcolor0);
635     vis_pst_16(dcolor, dpimg++, emask);
636     j = (mlib_s16 *) dpimg - pimg_row;
637     for (; j &lt; (img_width * 2 - 4); j += 4)
638       *dpimg++ = dcolor;
639     emask = vis_edge16(dpimg, pimg_row_end);
640     vis_pst_16(dcolor, dpimg, emask);
641   }
642 }
643 
644 /***************************************************************/
645 
646 void mlib_v_ImageClear_S16_3(mlib_image     *img,
647                              const mlib_s32 *color)
648 {
649   mlib_u32 color0 = color[0] &amp; 0xFFFF, color1 = color[1] &amp; 0xFFFF, color2 = color[2] &amp; 0xFFFF, col0, col1, col2;
650   mlib_d64 dcolor1, dcolor2, dcolor00, dcolor11, dcolor22;
651 
652   PREPAREVARS(mlib_s16, 3);
653 
654   if (img_width &lt; 8) {
655     STRIP(pimg, color, img_width, img_height, 3, mlib_s16);
656     return;
657   }
658 
659   col0 = (color0 &lt;&lt; 16) | color1;
660   col1 = (color2 &lt;&lt; 16) | color0;
661   col2 = (color1 &lt;&lt; 16) | color2;
662   dcolor = vis_to_double(col0, col1);
663   dcolor1 = vis_to_double(col2, col0);
664   dcolor2 = vis_to_double(col1, col2);
665   for (i = 0; i &lt; img_height; i++) {
666     mlib_s16 *pimg_row = pimg + i * img_stride, *pimg_row_end = pimg_row + img_width * 3 - 1;
667 
668     dpimg = (mlib_d64 *) ((mlib_addr) pimg_row &amp; ~7);
669     vis_alignaddr((void *)(-(mlib_addr) pimg_row), 8);
670     dcolor22 = vis_faligndata(dcolor2, dcolor);
671     dcolor00 = vis_faligndata(dcolor, dcolor1);
672     dcolor11 = vis_faligndata(dcolor1, dcolor2);
673     emask = vis_edge16(pimg_row, pimg_row_end);
674 
675     if ((mlib_addr) pimg_row &amp; 7)
676       vis_pst_16(dcolor22, dpimg++, emask);
677     j = (mlib_s16 *) dpimg - pimg_row;
678     for (; j &lt; (img_width * 3 - 12); j += 12) {
679       dpimg[0] = dcolor00;
680       dpimg[1] = dcolor11;
681       dpimg[2] = dcolor22;
682       dpimg += 3;
683     }
684 
685     if (j &lt; (img_width * 3 - 4)) {
686       *dpimg++ = dcolor00;
687 
688       if (j &lt; (img_width * 3 - 8)) {
689         *dpimg++ = dcolor11;
690         dcolor00 = dcolor22;
691       }
692       else
693         dcolor00 = dcolor11;
694     }
695 
696     emask = vis_edge16(dpimg, pimg_row_end);
697     vis_pst_16(dcolor00, dpimg, emask);
698   }
699 }
700 
701 /***************************************************************/
702 
703 void mlib_v_ImageClear_S16_4(mlib_image     *img,
704                              const mlib_s32 *color)
705 {
706   mlib_u32 color0 = color[0] &amp; 0xFFFF, color1 = color[1] &amp; 0xFFFF, color2 = color[2] &amp; 0xFFFF, color3 = color[3] &amp; 0xFFFF;
707   mlib_d64 dcolor0;
708 
709   PREPAREVARS(mlib_s16, 4);
710 
711   if (img_width &lt; 2) {
712     STRIP(pimg, color, img_width, img_height, 4, mlib_s16);
713     return;
714   }
715 
716   color0 = (color0 &lt;&lt; 16) | color1;
717   color1 = (color2 &lt;&lt; 16) | color3;
718   dcolor0 = vis_to_double(color0, color1);
719   for (i = 0; i &lt; img_height; i++) {
720     mlib_s16 *pimg_row = pimg + i * img_stride, *pimg_row_end = pimg_row + img_width * 4 - 1;
721 
722     dpimg = (mlib_d64 *) ((mlib_addr) pimg_row &amp; ~7);
723     vis_alignaddr((void *)(-(mlib_addr) pimg_row), 8);
724     emask = vis_edge16(pimg_row, pimg_row_end);
725     dcolor = vis_faligndata(dcolor0, dcolor0);
726     vis_pst_16(dcolor, dpimg++, emask);
727     j = (mlib_s16 *) dpimg - pimg_row;
728     for (; j &lt; (img_width * 4 - 4); j += 4)
729       *dpimg++ = dcolor;
730     emask = vis_edge16(dpimg, pimg_row_end);
731     vis_pst_16(dcolor, dpimg, emask);
732   }
733 }
734 
735 /***************************************************************/
736 
737 void mlib_v_ImageClear_S32_1(mlib_image     *img,
738                              const mlib_s32 *color)
739 {
740   mlib_u32 color0 = color[0];
741 
742   PREPAREVARS(mlib_s32, 1);
743 
744   if (img_width &lt; 4) {
745     STRIP(pimg, color, img_width, img_height, 1, mlib_s32);
746     return;
747   }
748 
749   dcolor = vis_to_double_dup(color0);
750   for (i = 0; i &lt; img_height; i++) {
751     mlib_s32 *pimg_row = pimg + i * img_stride, *pimg_row_end = pimg_row + img_width - 1;
752 
753     dpimg = (mlib_d64 *) vis_alignaddr(pimg_row, 0);
754     emask = vis_edge32(pimg_row, pimg_row_end);
755     vis_pst_32(dcolor, dpimg++, emask);
756     j = (mlib_s32 *) dpimg - pimg_row;
757     for (; j &lt;= (img_width - 2); j += 2)
758       *dpimg++ = dcolor;
759 
760     if (j &lt; img_width) {
761       emask = vis_edge32(dpimg, pimg_row_end);
762       vis_pst_32(dcolor, dpimg, emask);
763     }
764   }
765 }
766 
767 /***************************************************************/
768 
769 void mlib_v_ImageClear_S32_2(mlib_image     *img,
770                              const mlib_s32 *color)
771 {
772   mlib_u32 color0 = color[0], color1 = color[1];
773   mlib_d64 dcolor0;
774 
775   PREPAREVARS(mlib_s32, 2);
776 
777   if (img_width &lt; 2) {
778     STRIP(pimg, color, img_width, img_height, 2, mlib_s32);
779     return;
780   }
781 
782   dcolor0 = vis_to_double(color0, color1);
783   for (i = 0; i &lt; img_height; i++) {
784     mlib_s32 *pimg_row = pimg + i * img_stride, *pimg_row_end = pimg_row + img_width * 2 - 1;
785 
786     dpimg = (mlib_d64 *) vis_alignaddr(pimg_row, 0);
787     emask = vis_edge32(pimg_row, pimg_row_end);
788     dcolor = vis_faligndata(dcolor0, dcolor0);
789     vis_pst_32(dcolor, dpimg++, emask);
790     j = (mlib_s32 *) dpimg - pimg_row;
791     for (; j &lt; (img_width * 2 - 2); j += 2)
792       *dpimg++ = dcolor;
793     emask = vis_edge32(dpimg, pimg_row_end);
794     vis_pst_32(dcolor, dpimg, emask);
795   }
796 }
797 
798 /***************************************************************/
799 
800 void mlib_v_ImageClear_S32_3(mlib_image     *img,
801                              const mlib_s32 *color)
802 {
803   mlib_u32 color0 = color[0], color1 = color[1], color2 = color[2];
804   mlib_d64 dcolor1, dcolor2, dcolor00, dcolor11, dcolor22;
805 
806   PREPAREVARS(mlib_s32, 3);
807 
808   if (img_width &lt; 2) {
809     STRIP(pimg, color, img_width, img_height, 3, mlib_s32);
810     return;
811   }
812 
813   dcolor = vis_to_double(color0, color1);
814   dcolor1 = vis_to_double(color2, color0);
815   dcolor2 = vis_to_double(color1, color2);
816   for (i = 0; i &lt; img_height; i++) {
817     mlib_s32 *pimg_row = pimg + i * img_stride, *pimg_row_end = pimg_row + img_width * 3 - 1;
818 
819     dpimg = (mlib_d64 *) ((mlib_addr) pimg_row &amp; ~7);
820     vis_alignaddr((void *)(-(mlib_addr) pimg_row), 8);
821     dcolor22 = vis_faligndata(dcolor2, dcolor);
822     dcolor00 = vis_faligndata(dcolor, dcolor1);
823     dcolor11 = vis_faligndata(dcolor1, dcolor2);
824     emask = vis_edge32(pimg_row, pimg_row_end);
825 
826     if ((mlib_addr) pimg_row &amp; 7)
827       vis_pst_32(dcolor22, dpimg++, emask);
828     j = (mlib_s32 *) dpimg - pimg_row;
829     for (; j &lt; (img_width * 3 - 6); j += 6) {
830       dpimg[0] = dcolor00;
831       dpimg[1] = dcolor11;
832       dpimg[2] = dcolor22;
833       dpimg += 3;
834     }
835 
836     if (j &lt; (img_width * 3 - 2)) {
837       *dpimg++ = dcolor00;
838 
839       if (j &lt; (img_width * 3 - 4)) {
840         *dpimg++ = dcolor11;
841         dcolor00 = dcolor22;
842       }
843       else
844         dcolor00 = dcolor11;
845     }
846 
847     emask = vis_edge32(dpimg, pimg_row_end);
848     vis_pst_32(dcolor00, dpimg, emask);
849   }
850 }
851 
852 /***************************************************************/
853 
854 void mlib_v_ImageClear_S32_4(mlib_image     *img,
855                              const mlib_s32 *color)
856 {
857   mlib_u32 color0 = color[0], color1 = color[1], color2 = color[2], color3 = color[3];
858   mlib_d64 dcolor0, dcolor00, dcolor0_, dcolor00_, dcolor1;
859 
860   PREPAREVARS(mlib_s32, 4);
861 
862   if (img_width &lt; 2) {
863     STRIP(pimg, color, img_width, img_height, 4, mlib_s32);
864     return;
865   }
866 
867   dcolor0 = vis_to_double(color2, color3);
868   dcolor00 = vis_to_double(color0, color1);
869   vis_alignaddr((void *)0, 4);
870   dcolor0_ = vis_faligndata(dcolor0, dcolor00);
871   dcolor00_ = vis_faligndata(dcolor00, dcolor0);
872   for (i = 0; i &lt; img_height; i++) {
873     mlib_s32 *pimg_row = pimg + i * img_stride, *pimg_row_end = pimg_row + img_width * 4 - 1;
874 
875     dpimg = (mlib_d64 *) ((mlib_addr) pimg_row &amp; ~7);
876     vis_alignaddr((void *)(-(mlib_addr) pimg_row), 4);
877     emask = vis_edge32(pimg_row, pimg_row_end);
878     dcolor = vis_faligndata(dcolor0_, dcolor00_);
879     dcolor1 = vis_faligndata(dcolor00_, dcolor0_);
880     vis_pst_32(dcolor, dpimg++, emask);
881     *dpimg++ = dcolor1;
882     j = (mlib_s32 *) dpimg - pimg_row;
883     for (; j &lt;= (img_width * 4 - 4); j += 4) {
884       dpimg[0] = dcolor;
885       dpimg[1] = dcolor1;
886       dpimg += 2;
887     }
888 
889     if (j &lt; (img_width * 4)) {
890       emask = vis_edge32(dpimg, pimg_row_end);
891       vis_pst_32(dcolor, dpimg, emask);
892     }
893   }
894 }
895 
896 /***************************************************************/
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libawt/java2d/loops/vis_FourByteAbgrPre.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #if !defined(JAVA2D_NO_MLIB) || defined(MLIB_ADD_SUFF)
 27 
 28 #include &quot;vis_AlphaMacros.h&quot;
 29 
 30 /***************************************************************/
 31 
 32 #define FUNC_CONVERT(TYPE, OPER)                                             \
 33 void ADD_SUFF(TYPE##ToFourByteAbgrPre##OPER)(BLIT_PARAMS)                    \
 34 {                                                                            \
 35     mlib_d64 buff[BUFF_SIZE/2];                                              \
 36     void     *pbuff = buff;                                                  \
 37     mlib_s32 dstScan = pDstInfo-&gt;scanStride;                                 \
 38     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;                                 \
 39     mlib_s32 j;                                                              \
 40                                                                              \
 41     if (width &gt; BUFF_SIZE) pbuff = mlib_malloc(width*sizeof(mlib_s32));      \
 42                                                                              \
 43     for (j = 0; j &lt; height; j++) {                                           \
 44         ADD_SUFF(TYPE##ToIntArgbPre##OPER)(srcBase, pbuff, width, 1,         \
 45                                            pSrcInfo, pDstInfo,               \
 46                                            pPrim, pCompInfo);                \
 47                                                                              \
 48         ADD_SUFF(IntArgbToFourByteAbgrConvert)(pbuff, dstBase, width, 1,     \
 49                                                pSrcInfo, pDstInfo,           \
 50                                                pPrim, pCompInfo);            \
 51                                                                              \
 52         PTR_ADD(dstBase, dstScan);                                           \
 53         PTR_ADD(srcBase, srcScan);                                           \
 54     }                                                                        \
 55                                                                              \
 56     if (pbuff != buff) {                                                     \
 57         mlib_free(pbuff);                                                    \
 58     }                                                                        \
 59 }
 60 
 61 /***************************************************************/
 62 
 63 #define FUNC_SCALE_1(TYPE, OPER)                                             \
 64 void ADD_SUFF(TYPE##ToFourByteAbgrPre##OPER)(SCALE_PARAMS)                   \
 65 {                                                                            \
 66     mlib_d64 buff[BUFF_SIZE/2];                                              \
 67     void     *pbuff = buff;                                                  \
 68     mlib_s32 dstScan = pDstInfo-&gt;scanStride;                                 \
 69     mlib_s32 j;                                                              \
 70                                                                              \
 71     if (width &gt; BUFF_SIZE) pbuff = mlib_malloc(width*sizeof(mlib_s32));      \
 72                                                                              \
 73     for (j = 0; j &lt; height; j++) {                                           \
 74         ADD_SUFF(TYPE##ToIntArgbPre##OPER)(srcBase, pbuff, width, 1,         \
 75                                            sxloc, syloc,                     \
 76                                            sxinc, syinc, shift,              \
 77                                            pSrcInfo, pDstInfo,               \
 78                                            pPrim, pCompInfo);                \
 79                                                                              \
 80         ADD_SUFF(IntArgbToFourByteAbgrConvert)(pbuff, dstBase, width, 1,     \
 81                                                pSrcInfo, pDstInfo,           \
 82                                                pPrim, pCompInfo);            \
 83                                                                              \
 84         PTR_ADD(dstBase, dstScan);                                           \
 85         syloc += syinc;                                                      \
 86     }                                                                        \
 87                                                                              \
 88     if (pbuff != buff) {                                                     \
 89         mlib_free(pbuff);                                                    \
 90     }                                                                        \
 91 }
 92 
 93 /***************************************************************/
 94 
 95 #define FUNC_INDEXED(TYPE, OPER, PARAMS, CALL_PARAMS)                  \
 96 void ADD_SUFF(TYPE##ToFourByteAbgrPre##OPER)(PARAMS)                   \
 97 {                                                                      \
 98     SurfaceDataRasInfo new_src[1];                                     \
 99     jint *pixLut = pSrcInfo-&gt;lutBase;                                  \
100     mlib_s32 buff[256];                                                \
101                                                                        \
102     ADD_SUFF(IntArgbToIntArgbPreConvert)(pixLut, buff, 256, 1,         \
103                                          pSrcInfo, pDstInfo,           \
104                                          pPrim, pCompInfo);            \
105                                                                        \
106     new_src-&gt;lutBase = buff;                                           \
107     new_src-&gt;scanStride = pSrcInfo-&gt;scanStride;                        \
108     pSrcInfo = new_src;                                                \
109                                                                        \
110     ADD_SUFF(TYPE##ToFourByteAbgr##OPER)(CALL_PARAMS);                 \
111 }
112 
113 /***************************************************************/
114 
115 void ADD_SUFF(FourByteAbgrPreToIntArgbConvert)(BLIT_PARAMS)
116 {
117     ADD_SUFF(FourByteAbgrToIntArgbConvert)(BLIT_CALL_PARAMS);
118     pSrcInfo = pDstInfo;
119     srcBase = dstBase;
120     ADD_SUFF(IntArgbPreToIntArgbConvert)(BLIT_CALL_PARAMS);
121 }
122 
123 /***************************************************************/
124 
125 void ADD_SUFF(FourByteAbgrPreToIntArgbScaleConvert)(SCALE_PARAMS)
126 {
127     ADD_SUFF(FourByteAbgrToIntArgbScaleConvert)(SCALE_CALL_PARAMS);
128     pSrcInfo = pDstInfo;
129     srcBase = dstBase;
130     ADD_SUFF(IntArgbPreToIntArgbConvert)(BLIT_CALL_PARAMS);
131 }
132 
133 /***************************************************************/
134 
135 FUNC_CONVERT(ByteGray, Convert)
136 FUNC_CONVERT(IntArgb,  Convert)
137 FUNC_CONVERT(IntRgb,   Convert)
138 FUNC_CONVERT(ThreeByteBgr, Convert)
139 
140 FUNC_SCALE_1(ByteGray, ScaleConvert)
141 FUNC_SCALE_1(IntArgb,  ScaleConvert)
142 FUNC_SCALE_1(IntRgb,   ScaleConvert)
143 FUNC_SCALE_1(ThreeByteBgr, ScaleConvert)
144 
145 FUNC_INDEXED(ByteIndexed,   Convert,       BLIT_PARAMS,  BLIT_CALL_PARAMS)
146 FUNC_INDEXED(ByteIndexedBm, XparOver,      BLIT_PARAMS,  BLIT_CALL_PARAMS)
147 FUNC_INDEXED(ByteIndexedBm, XparBgCopy,    BCOPY_PARAMS, BCOPY_CALL_PARAMS)
148 FUNC_INDEXED(ByteIndexedBm, ScaleXparOver, SCALE_PARAMS, SCALE_CALL_PARAMS)
149 FUNC_INDEXED(ByteIndexed,   ScaleConvert,  SCALE_PARAMS, SCALE_CALL_PARAMS)
150 
151 /***************************************************************/
152 
153 void ADD_SUFF(FourByteAbgrPreDrawGlyphListAA)(SurfaceDataRasInfo * pRasInfo,
154                                               ImageRef *glyphs,
155                                               jint totalGlyphs,
156                                               jint fgpixel, jint argbcolor,
157                                               jint clipLeft, jint clipTop,
158                                               jint clipRight, jint clipBottom,
159                                               NativePrimitive * pPrim,
160                                               CompositeInfo * pCompInfo)
161 {
162     mlib_d64 buff[BUFF_SIZE/2];
163     void     *pbuff = buff;
164     mlib_s32 glyphCounter;
165     mlib_s32 scan = pRasInfo-&gt;scanStride;
166     mlib_u8  *dstBase;
167     mlib_s32 solidpix0, solidpix1, solidpix2, solidpix3;
168     mlib_s32 i, j;
169     mlib_d64 dmix0, dmix1, dd, d0, d1, e0, e1;
170     mlib_d64 done, d_half;
171     mlib_s32 pix;
172     mlib_f32 srcG_f;
173     mlib_s32 max_width = BUFF_SIZE;
174 
175     solidpix0 = fgpixel;
176     solidpix1 = fgpixel &gt;&gt; 8;
177     solidpix2 = fgpixel &gt;&gt; 16;
178     solidpix3 = fgpixel &gt;&gt; 24;
179 
180     done = vis_to_double_dup(0x7fff7fff);
181     d_half = vis_to_double_dup((1 &lt;&lt; (16 + 6)) | (1 &lt;&lt; 6));
182 
183     srcG_f = vis_to_float(argbcolor);
184     ARGB2ABGR_FL(srcG_f);
185 
186     for (glyphCounter = 0; glyphCounter &lt; totalGlyphs; glyphCounter++) {
187         const jubyte *pixels;
188         unsigned int rowBytes;
189         int left, top;
190         int width, height;
191         int right, bottom;
192 
193         pixels = (const jubyte *) glyphs[glyphCounter].pixels;
194 
195         if (!pixels) continue;
196 
197         left = glyphs[glyphCounter].x;
198         top = glyphs[glyphCounter].y;
199         width = glyphs[glyphCounter].width;
200         height = glyphs[glyphCounter].height;
201         rowBytes = width;
202         right = left + width;
203         bottom = top + height;
204         if (left &lt; clipLeft) {
205             pixels += clipLeft - left;
206             left = clipLeft;
207         }
208         if (top &lt; clipTop) {
209             pixels += (clipTop - top) * rowBytes;
210             top = clipTop;
211         }
212         if (right &gt; clipRight) {
213             right = clipRight;
214         }
215         if (bottom &gt; clipBottom) {
216             bottom = clipBottom;
217         }
218         if (right &lt;= left || bottom &lt;= top) {
219             continue;
220         }
221         width = right - left;
222         height = bottom - top;
223 
224         dstBase = pRasInfo-&gt;rasBase;
225         PTR_ADD(dstBase, top*scan + 4*left);
226 
227         if (((mlib_s32)dstBase | scan) &amp; 3) {
228             if (width &gt; max_width) {
229                 if (pbuff != buff) {
230                     mlib_free(pbuff);
231                 }
232                 pbuff = mlib_malloc(width*sizeof(mlib_s32));
233                 if (pbuff == NULL) return;
234                 max_width = width;
235             }
236         }
237 
238         for (j = 0; j &lt; height; j++) {
239             mlib_u8  *src = (void*)pixels;
240             mlib_s32 *dst, *dst_end;
241             mlib_u8  *dst8;
242             mlib_u8* dst_start = dstBase;
243 
244             /*
245              * Typically the inner loop here works on Argb input data, an
246              * Argb color, and produces ArgbPre output data.  To use that
247              * standard approach we would need a FourByteAbgrPre to IntArgb
248              * converter for the front end and an IntArgbPre to FourByteAbgrPre
249              * converter for the back end.  The converter exists for the
250              * front end, but it is a workaround implementation that uses a 2
251              * stage conversion and an intermediate buffer that is allocated
252              * on every call.  The converter for the back end doesn&#39;t really
253              * exist, but we could reuse the IntArgb to FourByteAbgr converter
254              * to do the same work - at the cost of swapping the components as
255              * we copy the data back.  All of this is more work than we really
256              * need so we use an alternate procedure:
257              * - Copy the data into an int-aligned temporary buffer (if needed)
258              * - Convert the data from FourByteAbgrPre to IntAbgr by using the
259              * IntArgbPre to IntArgb converter in the int-aligned buffer.
260              * - Swap the color data to Abgr so that the inner loop goes from
261              * IntAbgr data to IntAbgrPre data
262              * - Simply copy the IntAbgrPre data back into place.
263              */
264             if (((mlib_s32)dstBase) &amp; 3) {
265                 COPY_NA(dstBase, pbuff, width*sizeof(mlib_s32));
266                 dst_start = pbuff;
267             }
268             ADD_SUFF(IntArgbPreToIntArgbConvert)(dst_start, pbuff, width, 1,
269                                                       pRasInfo, pRasInfo,
270                                                       pPrim, pCompInfo);
271 
272             vis_write_gsr(0 &lt;&lt; 3);
273 
274             dst = pbuff;
275             dst_end = dst + width;
276 
277             if ((mlib_s32)dst &amp; 7) {
278                 pix = *src++;
279                 dd = vis_fpadd16(MUL8_VIS(srcG_f, pix), d_half);
280                 dd = vis_fpadd16(MUL8_VIS(*(mlib_f32*)dst, 255 - pix), dd);
281                 *(mlib_f32*)dst = vis_fpack16(dd);
282                 dst++;
283             }
284 
285 #pragma pipeloop(0)
286             for (; dst &lt;= (dst_end - 2); dst += 2) {
287                 dmix0 = vis_freg_pair(((mlib_f32 *)vis_mul8s_tbl)[src[0]],
288                                       ((mlib_f32 *)vis_mul8s_tbl)[src[1]]);
289                 dmix1 = vis_fpsub16(done, dmix0);
290                 src += 2;
291 
292                 dd = *(mlib_d64*)dst;
293                 d0 = vis_fmul8x16al(srcG_f, vis_read_hi(dmix0));
294                 d1 = vis_fmul8x16al(srcG_f, vis_read_lo(dmix0));
295                 e0 = vis_fmul8x16al(vis_read_hi(dd), vis_read_hi(dmix1));
296                 e1 = vis_fmul8x16al(vis_read_lo(dd), vis_read_lo(dmix1));
297                 d0 = vis_fpadd16(vis_fpadd16(d0, d_half), e0);
298                 d1 = vis_fpadd16(vis_fpadd16(d1, d_half), e1);
299                 dd = vis_fpack16_pair(d0, d1);
300 
301                 *(mlib_d64*)dst = dd;
302             }
303 
304             while (dst &lt; dst_end) {
305                 pix = *src++;
306                 dd = vis_fpadd16(MUL8_VIS(srcG_f, pix), d_half);
307                 dd = vis_fpadd16(MUL8_VIS(*(mlib_f32*)dst, 255 - pix), dd);
308                 *(mlib_f32*)dst = vis_fpack16(dd);
309                 dst++;
310             }
311 
312             COPY_NA(pbuff, dstBase, width*sizeof(mlib_s32));
313 
314             src = (void*)pixels;
315             dst8 = (void*)dstBase;
316 
317 #pragma pipeloop(0)
318             for (i = 0; i &lt; width; i++) {
319                 if (src[i] == 255) {
320                     dst8[4*i    ] = solidpix0;
321                     dst8[4*i + 1] = solidpix1;
322                     dst8[4*i + 2] = solidpix2;
323                     dst8[4*i + 3] = solidpix3;
324                 }
325             }
326 
327             PTR_ADD(dstBase, scan);
328             pixels += rowBytes;
329         }
330     }
331 
332     if (pbuff != buff) {
333         mlib_free(pbuff);
334     }
335 }
336 
337 /***************************************************************/
338 
339 #endif /* JAVA2D_NO_MLIB */
    </pre>
  </body>
</html>
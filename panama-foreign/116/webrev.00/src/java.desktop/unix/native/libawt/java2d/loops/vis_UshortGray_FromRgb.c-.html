<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libawt/java2d/loops/vis_UshortGray_FromRgb.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #if !defined(JAVA2D_NO_MLIB) || defined(MLIB_ADD_SUFF)
  27 
  28 #include &lt;vis_proto.h&gt;
  29 #include &quot;java2d_Mlib.h&quot;
  30 #include &quot;vis_AlphaMacros.h&quot;
  31 
  32 /***************************************************************/
  33 
  34 extern mlib_d64 vis_d64_div_tbl[256];
  35 
  36 /***************************************************************/
  37 
  38 #define RGB2GRAY(r, g, b)      \
  39     (((19672 * (r)) + (38621 * (g)) + (7500 * (b))) &gt;&gt; 8)
  40 
  41 /***************************************************************/
  42 
  43 static const mlib_s32 RGB_weight[] = {
  44     (19672/2) | ((19672/2) &lt;&lt; 16),
  45     (38621/2) | ((38621/2) &lt;&lt; 16),
  46     ( 7500/2) | (( 7500/2) &lt;&lt; 16),
  47     /*(1 &lt;&lt; 6)*/ - (1 &lt;&lt; 22)
  48 };
  49 
  50 /***************************************************************/
  51 
  52 #define RGB_VARS                                               \
  53     mlib_d64 r, g, b, ar, gb, s02, s13;                        \
  54     mlib_f32 ff;                                               \
  55     mlib_f32 alpha = ((mlib_f32*)RGB_weight)[0];               \
  56     mlib_f32 beta  = ((mlib_f32*)RGB_weight)[1];               \
  57     mlib_f32 gamma = ((mlib_f32*)RGB_weight)[2];               \
  58     mlib_f32 fzeros = vis_fzeros();                            \
  59     mlib_d64 d_half = vis_to_double_dup(RGB_weight[3]);        \
  60     mlib_f32 mask8000 = vis_to_float(0x80008000);              \
  61                                                                \
  62     vis_write_gsr(((16 - 7) &lt;&lt; 3) | 6)
  63 
  64 /***************************************************************/
  65 
  66 #define GRAY_U16(ff, r, g, b)          \
  67 {                                      \
  68     mlib_d64 dr, dg, db;               \
  69     dr = vis_fmuld8ulx16(r, alpha);    \
  70     dg = vis_fmuld8ulx16(g, beta);     \
  71     db = vis_fmuld8ulx16(b, gamma);    \
  72     dr = vis_fpadd32(dr, dg);          \
  73     db = vis_fpadd32(db, d_half);      \
  74     dr = vis_fpadd32(dr, db);          \
  75     ff = vis_fpackfix(dr);             \
  76     ff = vis_fxors(ff, mask8000);      \
  77 }
  78 
  79 /***************************************************************/
  80 
  81 #define LOAD_BGR(ind)                                          \
  82     b = vis_faligndata(vis_ld_u8(src + (ind    )), b);         \
  83     g = vis_faligndata(vis_ld_u8(src + (ind + 1)), g);         \
  84     r = vis_faligndata(vis_ld_u8(src + (ind + 2)), r)
  85 
  86 /***************************************************************/
  87 
  88 void ADD_SUFF(IntArgbToUshortGrayConvert)(BLIT_PARAMS)
  89 {
  90     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
  91     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
  92     mlib_s32 j;
  93     RGB_VARS;
  94 
  95     if (srcScan == 4*width &amp;&amp; dstScan == 2*width) {
  96         width *= height;
  97         height = 1;
  98     }
  99 
 100     for (j = 0; j &lt; height; j++) {
 101         mlib_f32 *src = srcBase;
 102         mlib_u16 *dst = dstBase;
 103         mlib_u16 *dst_end;
 104 
 105         dst_end = dst + width;
 106 
 107         while (((mlib_s32)dst &amp; 3) &amp;&amp; dst &lt; dst_end) {
 108             r = vis_ld_u8((mlib_u8*)src + 1);
 109             g = vis_ld_u8((mlib_u8*)src + 2);
 110             b = vis_ld_u8((mlib_u8*)src + 3);
 111             GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 112             vis_st_u16(D64_FROM_F32x2(ff), dst);
 113             dst++;
 114             src++;
 115         }
 116 
 117 #pragma pipeloop(0)
 118         for (; dst &lt;= (dst_end - 2); dst += 2) {
 119             s02 = vis_fpmerge(src[0], src[1]);
 120             ar = vis_fpmerge(fzeros, vis_read_hi(s02));
 121             gb = vis_fpmerge(fzeros, vis_read_lo(s02));
 122             GRAY_U16(ff, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
 123             *(mlib_f32*)dst = ff;
 124             src += 2;
 125         }
 126 
 127         while (dst &lt; dst_end) {
 128             r = vis_ld_u8((mlib_u8*)src + 1);
 129             g = vis_ld_u8((mlib_u8*)src + 2);
 130             b = vis_ld_u8((mlib_u8*)src + 3);
 131             GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 132             vis_st_u16(D64_FROM_F32x2(ff), dst);
 133             dst++;
 134             src++;
 135         }
 136 
 137         PTR_ADD(dstBase, dstScan);
 138         PTR_ADD(srcBase, srcScan);
 139     }
 140 }
 141 
 142 /***************************************************************/
 143 
 144 void ADD_SUFF(ThreeByteBgrToUshortGrayConvert)(BLIT_PARAMS)
 145 {
 146     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
 147     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
 148     mlib_u16 *dst_end;
 149     mlib_s32 j;
 150     RGB_VARS;
 151 
 152     if (srcScan == 3*width &amp;&amp; dstScan == 2*width) {
 153         width *= height;
 154         height = 1;
 155     }
 156 
 157     for (j = 0; j &lt; height; j++) {
 158         mlib_u8  *src = srcBase;
 159         mlib_u16 *dst = dstBase;
 160 
 161         dst_end = dst + width;
 162 
 163         while (((mlib_s32)dst &amp; 3) &amp;&amp; dst &lt; dst_end) {
 164             b = vis_ld_u8(src);
 165             g = vis_ld_u8(src + 1);
 166             r = vis_ld_u8(src + 2);
 167             GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 168             vis_st_u16(D64_FROM_F32x2(ff), dst);
 169             dst++;
 170             src += 3;
 171         }
 172 
 173 #pragma pipeloop(0)
 174         for (; dst &lt;= (dst_end - 2); dst += 2) {
 175             LOAD_BGR(3);
 176             LOAD_BGR(0);
 177             GRAY_U16(ff, vis_read_hi(r), vis_read_hi(g), vis_read_hi(b));
 178             *(mlib_f32*)dst = ff;
 179             src += 3*2;
 180         }
 181 
 182         while (dst &lt; dst_end) {
 183             b = vis_ld_u8(src);
 184             g = vis_ld_u8(src + 1);
 185             r = vis_ld_u8(src + 2);
 186             GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 187             vis_st_u16(D64_FROM_F32x2(ff), dst);
 188             dst++;
 189             src += 3;
 190         }
 191 
 192         PTR_ADD(dstBase, dstScan);
 193         PTR_ADD(srcBase, srcScan);
 194     }
 195 }
 196 
 197 /***************************************************************/
 198 
 199 void ADD_SUFF(IntArgbToUshortGrayScaleConvert)(SCALE_PARAMS)
 200 {
 201     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
 202     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
 203     mlib_u16 *dst_end;
 204     mlib_s32 i, j;
 205     RGB_VARS;
 206 
 207     for (j = 0; j &lt; height; j++) {
 208         mlib_f32 *src = srcBase;
 209         mlib_u16 *dst = dstBase;
 210         mlib_s32 tmpsxloc = sxloc;
 211 
 212         PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
 213 
 214         dst_end = dst + width;
 215 
 216         while (((mlib_s32)dst &amp; 3) &amp;&amp; dst &lt; dst_end) {
 217             i = tmpsxloc &gt;&gt; shift;
 218             tmpsxloc += sxinc;
 219             r = vis_ld_u8((mlib_u8*)(src + i) + 1);
 220             g = vis_ld_u8((mlib_u8*)(src + i) + 2);
 221             b = vis_ld_u8((mlib_u8*)(src + i) + 3);
 222             GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 223             vis_st_u16(D64_FROM_F32x2(ff), dst);
 224             dst++;
 225         }
 226 
 227 #pragma pipeloop(0)
 228         for (; dst &lt;= (dst_end - 2); dst += 2) {
 229             s02 = vis_fpmerge(src[(tmpsxloc        ) &gt;&gt; shift],
 230                               src[(tmpsxloc + sxinc) &gt;&gt; shift]);
 231             tmpsxloc += 2*sxinc;
 232             ar = vis_fpmerge(fzeros, vis_read_hi(s02));
 233             gb = vis_fpmerge(fzeros, vis_read_lo(s02));
 234             GRAY_U16(ff, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
 235             *(mlib_f32*)dst = ff;
 236         }
 237 
 238         while (dst &lt; dst_end) {
 239             i = tmpsxloc &gt;&gt; shift;
 240             tmpsxloc += sxinc;
 241             r = vis_ld_u8((mlib_u8*)(src + i) + 1);
 242             g = vis_ld_u8((mlib_u8*)(src + i) + 2);
 243             b = vis_ld_u8((mlib_u8*)(src + i) + 3);
 244             GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 245             vis_st_u16(D64_FROM_F32x2(ff), dst);
 246             dst++;
 247         }
 248 
 249         PTR_ADD(dstBase, dstScan);
 250         syloc += syinc;
 251     }
 252 }
 253 
 254 /***************************************************************/
 255 
 256 void ADD_SUFF(ThreeByteBgrToUshortGrayScaleConvert)(SCALE_PARAMS)
 257 {
 258     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
 259     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
 260     mlib_u16 *dst_end;
 261     mlib_s32 j, i0, i1;
 262     RGB_VARS;
 263 
 264     for (j = 0; j &lt; height; j++) {
 265         mlib_u8  *src = srcBase;
 266         mlib_u16 *dst = dstBase;
 267         mlib_s32 tmpsxloc = sxloc;
 268 
 269         PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
 270 
 271         dst_end = dst + width;
 272 
 273         while (((mlib_s32)dst &amp; 3) &amp;&amp; dst &lt; dst_end) {
 274             i0 = 3*(tmpsxloc &gt;&gt; shift);
 275             tmpsxloc += sxinc;
 276             b = vis_ld_u8(src + i0);
 277             g = vis_ld_u8(src + i0 + 1);
 278             r = vis_ld_u8(src + i0 + 2);
 279             GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 280             vis_st_u16(D64_FROM_F32x2(ff), dst);
 281             dst++;
 282         }
 283 
 284 #pragma pipeloop(0)
 285         for (; dst &lt;= (dst_end - 2); dst += 2) {
 286             i0 = 3*(tmpsxloc &gt;&gt; shift);
 287             tmpsxloc += sxinc;
 288             i1 = 3*(tmpsxloc &gt;&gt; shift);
 289             tmpsxloc += sxinc;
 290             LOAD_BGR(i1);
 291             LOAD_BGR(i0);
 292             GRAY_U16(ff, vis_read_hi(r), vis_read_hi(g), vis_read_hi(b));
 293             *(mlib_f32*)dst = ff;
 294         }
 295 
 296         while (dst &lt; dst_end) {
 297             i0 = 3*(tmpsxloc &gt;&gt; shift);
 298             tmpsxloc += sxinc;
 299             b = vis_ld_u8(src + i0);
 300             g = vis_ld_u8(src + i0 + 1);
 301             r = vis_ld_u8(src + i0 + 2);
 302             GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 303             vis_st_u16(D64_FROM_F32x2(ff), dst);
 304             dst++;
 305         }
 306 
 307         PTR_ADD(dstBase, dstScan);
 308         syloc += syinc;
 309     }
 310 }
 311 
 312 /***************************************************************/
 313 
 314 #if 0
 315 
 316 void ADD_SUFF(IntArgbBmToUshortGrayXparOver)(BLIT_PARAMS)
 317 {
 318     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
 319     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
 320     mlib_d64 dzero = vis_fzero();
 321     mlib_f32 f0, f1;
 322     mlib_s32 i, j, mask0, mask1;
 323     RGB_VARS;
 324 
 325     if (width &lt; 8) {
 326         for (j = 0; j &lt; height; j++) {
 327             mlib_u8  *src = srcBase;
 328             mlib_u16 *dst = dstBase;
 329 
 330             for (i = 0; i &lt; width; i++) {
 331                 if (src[4*i]) {
 332                     dst[i] = RGB2GRAY(src[4*i + 1], src[4*i + 2], src[4*i + 3]);
 333                 }
 334             }
 335 
 336             PTR_ADD(dstBase, dstScan);
 337             PTR_ADD(srcBase, srcScan);
 338         }
 339         return;
 340     }
 341 
 342     for (j = 0; j &lt; height; j++) {
 343         mlib_f32 *src = srcBase;
 344         mlib_u16 *dst = dstBase;
 345         mlib_u16 *dst_end;
 346 
 347         dst_end = dst + width;
 348 
 349         while (((mlib_s32)dst &amp; 7) &amp;&amp; dst &lt; dst_end) {
 350             if (*(mlib_u8*)src) {
 351                 r = vis_ld_u8((mlib_u8*)src + 1);
 352                 g = vis_ld_u8((mlib_u8*)src + 2);
 353                 b = vis_ld_u8((mlib_u8*)src + 3);
 354                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 355                 vis_st_u16(D64_FROM_F32x2(ff), dst);
 356             }
 357             dst++;
 358             src++;
 359         }
 360 
 361 #pragma pipeloop(0)
 362         for (; dst &lt;= (dst_end - 4); dst += 4) {
 363             s02 = vis_fpmerge(src[0], src[1]);
 364             src += 2;
 365             ar = vis_fpmerge(fzeros, vis_read_hi(s02));
 366             gb = vis_fpmerge(fzeros, vis_read_lo(s02));
 367             mask0 = vis_fcmpne16(ar, dzero) &amp; 0xC;
 368             GRAY_U16(f0, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
 369 
 370             s02 = vis_fpmerge(src[0], src[1]);
 371             src += 2;
 372             ar = vis_fpmerge(fzeros, vis_read_hi(s02));
 373             gb = vis_fpmerge(fzeros, vis_read_lo(s02));
 374             mask1 = vis_fcmpne16(ar, dzero) &gt;&gt; 2;
 375             GRAY_U16(f1, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
 376 
 377             vis_pst_16(vis_freg_pair(f0, f1), dst, mask0 | mask1);
 378         }
 379 
 380         while (dst &lt; dst_end) {
 381             if (*(mlib_u8*)src) {
 382                 r = vis_ld_u8((mlib_u8*)src + 1);
 383                 g = vis_ld_u8((mlib_u8*)src + 2);
 384                 b = vis_ld_u8((mlib_u8*)src + 3);
 385                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 386                 vis_st_u16(D64_FROM_F32x2(ff), dst);
 387             }
 388             dst++;
 389             src++;
 390         }
 391 
 392         PTR_ADD(dstBase, dstScan);
 393         PTR_ADD(srcBase, srcScan);
 394     }
 395 }
 396 
 397 /***************************************************************/
 398 
 399 void ADD_SUFF(IntArgbBmToUshortGrayXparBgCopy)(BCOPY_PARAMS)
 400 {
 401     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
 402     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
 403     mlib_d64 dzero = vis_fzero(), d_bgpixel;
 404     mlib_f32 f0, f1;
 405     mlib_s32 i, j, mask0, mask1;
 406     RGB_VARS;
 407 
 408     if (width &lt; 8) {
 409         for (j = 0; j &lt; height; j++) {
 410             mlib_u8  *src = srcBase;
 411             mlib_u16 *dst = dstBase;
 412             mlib_s32 srcpixel, r, g, b;
 413 
 414             for (i = 0; i &lt; width; i++) {
 415                 if (src[4*i]) {
 416                     dst[i] = RGB2GRAY(src[4*i + 1], src[4*i + 2], src[4*i + 3]);
 417                 } else {
 418                     dst[i] = bgpixel;
 419                 }
 420             }
 421 
 422             PTR_ADD(dstBase, dstScan);
 423             PTR_ADD(srcBase, srcScan);
 424         }
 425         return;
 426     }
 427 
 428     D64_FROM_U16x4(d_bgpixel, bgpixel);
 429 
 430     for (j = 0; j &lt; height; j++) {
 431         mlib_f32 *src = srcBase;
 432         mlib_u16 *dst = dstBase;
 433         mlib_u16 *dst_end;
 434 
 435         dst_end = dst + width;
 436 
 437         while (((mlib_s32)dst &amp; 7) &amp;&amp; dst &lt; dst_end) {
 438             if (*(mlib_u8*)src) {
 439                 r = vis_ld_u8((mlib_u8*)src + 1);
 440                 g = vis_ld_u8((mlib_u8*)src + 2);
 441                 b = vis_ld_u8((mlib_u8*)src + 3);
 442                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 443                 vis_st_u16(D64_FROM_F32x2(ff), dst);
 444             } else {
 445                 *dst = bgpixel;
 446             }
 447             dst++;
 448             src++;
 449         }
 450 
 451 #pragma pipeloop(0)
 452         for (; dst &lt;= (dst_end - 4); dst += 4) {
 453             s02 = vis_fpmerge(src[0], src[1]);
 454             src += 2;
 455             ar = vis_fpmerge(fzeros, vis_read_hi(s02));
 456             gb = vis_fpmerge(fzeros, vis_read_lo(s02));
 457             mask0 = vis_fcmpne16(ar, dzero) &amp; 0xC;
 458             GRAY_U16(f0, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
 459 
 460             s02 = vis_fpmerge(src[0], src[1]);
 461             src += 2;
 462             ar = vis_fpmerge(fzeros, vis_read_hi(s02));
 463             gb = vis_fpmerge(fzeros, vis_read_lo(s02));
 464             mask1 = vis_fcmpne16(ar, dzero) &gt;&gt; 2;
 465             GRAY_U16(f1, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
 466 
 467             *(mlib_d64*)dst = d_bgpixel;
 468             vis_pst_16(vis_freg_pair(f0, f1), dst, mask0 | mask1);
 469         }
 470 
 471         while (dst &lt; dst_end) {
 472             if (*(mlib_u8*)src) {
 473                 r = vis_ld_u8((mlib_u8*)src + 1);
 474                 g = vis_ld_u8((mlib_u8*)src + 2);
 475                 b = vis_ld_u8((mlib_u8*)src + 3);
 476                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 477                 vis_st_u16(D64_FROM_F32x2(ff), dst);
 478             } else {
 479                 *dst = bgpixel;
 480             }
 481             dst++;
 482             src++;
 483         }
 484 
 485         PTR_ADD(dstBase, dstScan);
 486         PTR_ADD(srcBase, srcScan);
 487     }
 488 }
 489 
 490 #endif
 491 
 492 /***************************************************************/
 493 
 494 void ADD_SUFF(IntArgbToUshortGrayXorBlit)(BLIT_PARAMS)
 495 {
 496     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
 497     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
 498     mlib_d64 dd, d_xorpixel, d_alphamask, dzero = vis_fzero();
 499     mlib_f32 f0, f1;
 500     mlib_s32 i, j, mask0, mask1;
 501     jint  xorpixel = pCompInfo-&gt;details.xorPixel;
 502     juint alphamask = pCompInfo-&gt;alphaMask;
 503     RGB_VARS;
 504 
 505     if (width &lt; 8) {
 506         for (j = 0; j &lt; height; j++) {
 507             mlib_s32 *src = srcBase;
 508             mlib_u16 *dst = dstBase;
 509             mlib_s32 srcpixel, r, g, b;
 510 
 511             for (i = 0; i &lt; width; i++) {
 512                 srcpixel = src[i];
 513                 if (srcpixel &gt;= 0) continue;
 514                 b = (srcpixel) &amp; 0xff;
 515                 g = (srcpixel &gt;&gt; 8) &amp; 0xff;
 516                 r = (srcpixel &gt;&gt; 16) &amp; 0xff;
 517                 srcpixel = (77*r + 150*g + 29*b + 128) / 256;
 518                 dst[i]  ^= (((srcpixel) ^ (xorpixel)) &amp; ~(alphamask));
 519             }
 520 
 521             PTR_ADD(dstBase, dstScan);
 522             PTR_ADD(srcBase, srcScan);
 523         }
 524         return;
 525     }
 526 
 527     D64_FROM_U16x4(d_xorpixel,  xorpixel);
 528     D64_FROM_U16x4(d_alphamask, alphamask);
 529 
 530     for (j = 0; j &lt; height; j++) {
 531         mlib_f32 *src = srcBase;
 532         mlib_u16 *dst = dstBase;
 533         mlib_u16 *dst_end;
 534 
 535         dst_end = dst + width;
 536 
 537         while (((mlib_s32)dst &amp; 7) &amp;&amp; dst &lt; dst_end) {
 538             if ((*(mlib_u8*)src) &amp; 0x80) {
 539                 r = vis_ld_u8((mlib_u8*)src + 1);
 540                 g = vis_ld_u8((mlib_u8*)src + 2);
 541                 b = vis_ld_u8((mlib_u8*)src + 3);
 542                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 543                 dd = vis_fxor(D64_FROM_F32x2(ff), d_xorpixel);
 544                 dd = vis_fandnot(d_alphamask, dd);
 545                 vis_st_u16(vis_fxor(vis_ld_u8(dst), dd), dst);
 546             }
 547             dst++;
 548             src++;
 549         }
 550 
 551 #pragma pipeloop(0)
 552         for (; dst &lt;= (dst_end - 8); dst += 8) {
 553             s02 = vis_fpmerge(src[0], src[1]);
 554             src += 2;
 555             ar = vis_fpmerge(fzeros, vis_read_hi(s02));
 556             gb = vis_fpmerge(fzeros, vis_read_lo(s02));
 557             mask0 = vis_fcmplt16(ar, dzero) &amp; 0xC;
 558             GRAY_U16(f0, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
 559 
 560             s02 = vis_fpmerge(src[0], src[1]);
 561             src += 2;
 562             ar = vis_fpmerge(fzeros, vis_read_hi(s02));
 563             gb = vis_fpmerge(fzeros, vis_read_lo(s02));
 564             mask1 = vis_fcmplt16(ar, dzero) &gt;&gt; 2;
 565             GRAY_U16(f1, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
 566 
 567             dd = vis_freg_pair(f0, f1);
 568             dd = vis_fandnot(d_alphamask, vis_fxor(dd, d_xorpixel));
 569             vis_pst_16(vis_fxor(*(mlib_d64*)dst, dd), dst, mask0 | mask1);
 570         }
 571 
 572         while (dst &lt; dst_end) {
 573             if ((*(mlib_u8*)src) &amp; 0x80) {
 574                 r = vis_ld_u8((mlib_u8*)src + 1);
 575                 g = vis_ld_u8((mlib_u8*)src + 2);
 576                 b = vis_ld_u8((mlib_u8*)src + 3);
 577                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 578                 dd = vis_fxor(D64_FROM_F32x2(ff), d_xorpixel);
 579                 dd = vis_fandnot(d_alphamask, dd);
 580                 vis_st_u16(vis_fxor(vis_ld_u8(dst), dd), dst);
 581             }
 582             dst++;
 583             src++;
 584         }
 585 
 586         PTR_ADD(dstBase, dstScan);
 587         PTR_ADD(srcBase, srcScan);
 588     }
 589 }
 590 
 591 /***************************************************************/
 592 
 593 void ADD_SUFF(IntArgbBmToUshortGrayScaleXparOver)(SCALE_PARAMS)
 594 {
 595     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
 596     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
 597     mlib_d64 dzero = vis_fzero();
 598     mlib_f32 f0, f1;
 599     mlib_s32 i, j, mask0, mask1;
 600     RGB_VARS;
 601 
 602     for (j = 0; j &lt; height; j++) {
 603         mlib_f32 *src = srcBase;
 604         mlib_u16 *dst = dstBase;
 605         mlib_u16 *dst_end;
 606         mlib_s32 tmpsxloc = sxloc;
 607 
 608         PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
 609 
 610         dst_end = dst + width;
 611 
 612         while (((mlib_s32)dst &amp; 7) &amp;&amp; dst &lt; dst_end) {
 613             i = tmpsxloc &gt;&gt; shift;
 614             tmpsxloc += sxinc;
 615             if (*(mlib_u8*)(src + i)) {
 616                 r = vis_ld_u8((mlib_u8*)(src + i) + 1);
 617                 g = vis_ld_u8((mlib_u8*)(src + i) + 2);
 618                 b = vis_ld_u8((mlib_u8*)(src + i) + 3);
 619                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 620                 vis_st_u16(D64_FROM_F32x2(ff), dst);
 621             }
 622             dst++;
 623         }
 624 
 625 #pragma pipeloop(0)
 626         for (; dst &lt;= (dst_end - 4); dst += 4) {
 627             s02 = vis_fpmerge(src[(tmpsxloc        ) &gt;&gt; shift],
 628                               src[(tmpsxloc + sxinc) &gt;&gt; shift]);
 629             tmpsxloc += 2*sxinc;
 630             ar = vis_fpmerge(fzeros, vis_read_hi(s02));
 631             gb = vis_fpmerge(fzeros, vis_read_lo(s02));
 632             mask0 = vis_fcmpne16(ar, dzero) &amp; 0xC;
 633             GRAY_U16(f0, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
 634 
 635             s02 = vis_fpmerge(src[(tmpsxloc        ) &gt;&gt; shift],
 636                               src[(tmpsxloc + sxinc) &gt;&gt; shift]);
 637             tmpsxloc += 2*sxinc;
 638             ar = vis_fpmerge(fzeros, vis_read_hi(s02));
 639             gb = vis_fpmerge(fzeros, vis_read_lo(s02));
 640             mask1 = vis_fcmpne16(ar, dzero) &gt;&gt; 2;
 641             GRAY_U16(f1, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
 642 
 643             vis_pst_16(vis_freg_pair(f0, f1), dst, mask0 | mask1);
 644         }
 645 
 646         while (dst &lt; dst_end) {
 647             i = tmpsxloc &gt;&gt; shift;
 648             tmpsxloc += sxinc;
 649             if (*(mlib_u8*)(src + i)) {
 650                 r = vis_ld_u8((mlib_u8*)(src + i) + 1);
 651                 g = vis_ld_u8((mlib_u8*)(src + i) + 2);
 652                 b = vis_ld_u8((mlib_u8*)(src + i) + 3);
 653                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 654                 vis_st_u16(D64_FROM_F32x2(ff), dst);
 655             }
 656             dst++;
 657         }
 658 
 659         PTR_ADD(dstBase, dstScan);
 660         syloc += syinc;
 661     }
 662 }
 663 
 664 /***************************************************************/
 665 
 666 #define TBL_MUL ((mlib_s16*)vis_mul8s_tbl + 1)
 667 #define TBL_DIV ((mlib_u8*)vis_div8_tbl + 2)
 668 
 669 void ADD_SUFF(IntArgbToUshortGraySrcOverMaskBlit)(MASKBLIT_PARAMS)
 670 {
 671     mlib_s32 extraA;
 672     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
 673     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
 674     mlib_u8  *mul8_extra;
 675     mlib_u16 *dst_end;
 676     mlib_d64 srcAx4, dd, d0, d1;
 677     mlib_d64 done = vis_to_double_dup(0x7fff7fff);
 678     mlib_s32 j, srcA0, srcA1, srcA2, srcA3;
 679     RGB_VARS;
 680 
 681     extraA = (mlib_s32)(pCompInfo-&gt;details.extraAlpha * 255.0 + 0.5);
 682     mul8_extra = mul8table[extraA];
 683 
 684     if (pMask != NULL) {
 685         pMask += maskOff;
 686 
 687         if (srcScan == 4*width &amp;&amp; dstScan == 2*width &amp;&amp; maskScan == width) {
 688             width *= height;
 689             height = 1;
 690         }
 691 
 692         maskScan -= width;
 693 
 694         for (j = 0; j &lt; height; j++) {
 695             mlib_f32 *src = srcBase;
 696             mlib_u16 *dst = dstBase;
 697 
 698             dst_end = dst + width;
 699 
 700             while (((mlib_s32)dst &amp; 3) &amp;&amp; dst &lt; dst_end) {
 701                 srcA0 = mul8table[mul8_extra[*pMask++]][*(mlib_u8*)src];
 702                 r = vis_ld_u8((mlib_u8*)src + 1);
 703                 g = vis_ld_u8((mlib_u8*)src + 2);
 704                 b = vis_ld_u8((mlib_u8*)src + 3);
 705                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 706                 d0 = vis_fpadd16(MUL8_VIS(ff, srcA0), d_half);
 707                 d1 = MUL8_VIS(vis_read_lo(vis_ld_u8(dst)), 255 - srcA0);
 708                 dd = vis_fpadd16(d0, d1);
 709                 vis_st_u16(D64_FROM_F32x2(vis_fpack16(dd)), dst);
 710                 dst++;
 711                 src++;
 712             }
 713 
 714 #pragma pipeloop(0)
 715             for (; dst &lt;= (dst_end - 4); dst += 4) {
 716                 srcA0 = mul8table[mul8_extra[*pMask++]][*(mlib_u8*)src];
 717                 srcA1 = mul8table[mul8_extra[*pMask++]][*(mlib_u8*)(src + 1)];
 718                 srcA2 = mul8table[mul8_extra[*pMask++]][*(mlib_u8*)(src + 2)];
 719                 srcA3 = mul8table[mul8_extra[*pMask++]][*(mlib_u8*)(src + 3)];
 720                 srcAx4 = vis_faligndata(vis_ld_u16(TBL_MUL + 2*srcA3), srcAx4);
 721                 srcAx4 = vis_faligndata(vis_ld_u16(TBL_MUL + 2*srcA2), srcAx4);
 722                 srcAx4 = vis_faligndata(vis_ld_u16(TBL_MUL + 2*srcA1), srcAx4);
 723                 srcAx4 = vis_faligndata(vis_ld_u16(TBL_MUL + 2*srcA0), srcAx4);
 724 
 725                 s02 = vis_fpmerge(src[0], src[1]);
 726                 ar = vis_fpmerge(fzeros, vis_read_hi(s02));
 727                 gb = vis_fpmerge(fzeros, vis_read_lo(s02));
 728                 GRAY_U16(ff, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
 729                 d0 = vis_fpadd16(vis_fmul8x16(ff, srcAx4), d_half);
 730                 d1 = vis_fmul8x16(*(mlib_f32*)dst, vis_fpsub16(done, srcAx4));
 731                 dd = vis_fpadd16(d0, d1);
 732                 *(mlib_f32*)dst = vis_fpack16(dd);
 733                 src += 4;
 734             }
 735 
 736             while (dst &lt; dst_end) {
 737                 srcA0 = mul8table[mul8_extra[*pMask++]][*(mlib_u8*)src];
 738                 r = vis_ld_u8((mlib_u8*)src + 1);
 739                 g = vis_ld_u8((mlib_u8*)src + 2);
 740                 b = vis_ld_u8((mlib_u8*)src + 3);
 741                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 742                 d0 = vis_fpadd16(MUL8_VIS(ff, srcA0), d_half);
 743                 d1 = MUL8_VIS(vis_read_lo(vis_ld_u8(dst)), 255 - srcA0);
 744                 dd = vis_fpadd16(d0, d1);
 745                 vis_st_u16(D64_FROM_F32x2(vis_fpack16(dd)), dst);
 746                 dst++;
 747                 src++;
 748             }
 749 
 750             PTR_ADD(dstBase, dstScan);
 751             PTR_ADD(srcBase, srcScan);
 752             PTR_ADD(pMask,  maskScan);
 753         }
 754     } else {
 755 
 756         if (dstScan == width &amp;&amp; srcScan == 4*width) {
 757             width *= height;
 758             height = 1;
 759         }
 760 
 761         for (j = 0; j &lt; height; j++) {
 762             mlib_f32 *src = srcBase;
 763             mlib_u16 *dst = dstBase;
 764 
 765             dst_end = dst + width;
 766 
 767             while (((mlib_s32)dst &amp; 3) &amp;&amp; dst &lt; dst_end) {
 768                 srcA0 = mul8_extra[*(mlib_u8*)src];
 769                 r = vis_ld_u8((mlib_u8*)src + 1);
 770                 g = vis_ld_u8((mlib_u8*)src + 2);
 771                 b = vis_ld_u8((mlib_u8*)src + 3);
 772                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 773                 d0 = vis_fpadd16(MUL8_VIS(ff, srcA0), d_half);
 774                 d1 = MUL8_VIS(vis_read_lo(vis_ld_u8(dst)), 255 - srcA0);
 775                 dd = vis_fpadd16(d0, d1);
 776                 vis_st_u16(D64_FROM_F32x2(vis_fpack16(dd)), dst);
 777                 dst++;
 778                 src++;
 779             }
 780 
 781 #pragma pipeloop(0)
 782             for (; dst &lt;= (dst_end - 4); dst += 4) {
 783                 srcA0 = mul8_extra[*(mlib_u8*)src];
 784                 srcA1 = mul8_extra[*(mlib_u8*)(src + 1)];
 785                 srcA2 = mul8_extra[*(mlib_u8*)(src + 2)];
 786                 srcA3 = mul8_extra[*(mlib_u8*)(src + 3)];
 787                 srcAx4 = vis_faligndata(vis_ld_u16(TBL_MUL + 2*srcA3), srcAx4);
 788                 srcAx4 = vis_faligndata(vis_ld_u16(TBL_MUL + 2*srcA2), srcAx4);
 789                 srcAx4 = vis_faligndata(vis_ld_u16(TBL_MUL + 2*srcA1), srcAx4);
 790                 srcAx4 = vis_faligndata(vis_ld_u16(TBL_MUL + 2*srcA0), srcAx4);
 791 
 792                 s02 = vis_fpmerge(src[0], src[2]);
 793                 s13 = vis_fpmerge(src[1], src[3]);
 794                 ar = vis_fpmerge(vis_read_hi(s02), vis_read_hi(s13));
 795                 gb = vis_fpmerge(vis_read_lo(s02), vis_read_lo(s13));
 796                 GRAY_U16(ff, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
 797                 d0 = vis_fpadd16(vis_fmul8x16(ff, srcAx4), d_half);
 798                 d1 = vis_fmul8x16(*(mlib_f32*)dst, vis_fpsub16(done, srcAx4));
 799                 dd = vis_fpadd16(d0, d1);
 800                 *(mlib_f32*)dst = vis_fpack16(dd);
 801                 src += 4;
 802             }
 803 
 804             while (dst &lt; dst_end) {
 805                 srcA0 = mul8_extra[*(mlib_u8*)src];
 806                 r = vis_ld_u8((mlib_u8*)src + 1);
 807                 g = vis_ld_u8((mlib_u8*)src + 2);
 808                 b = vis_ld_u8((mlib_u8*)src + 3);
 809                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 810                 d0 = vis_fpadd16(MUL8_VIS(ff, srcA0), d_half);
 811                 d1 = MUL8_VIS(vis_read_lo(vis_ld_u8(dst)), 255 - srcA0);
 812                 dd = vis_fpadd16(d0, d1);
 813                 vis_st_u16(D64_FROM_F32x2(vis_fpack16(dd)), dst);
 814                 dst++;
 815                 src++;
 816             }
 817 
 818             PTR_ADD(dstBase, dstScan);
 819             PTR_ADD(srcBase, srcScan);
 820         }
 821     }
 822 }
 823 
 824 /***************************************************************/
 825 
 826 #define GET_COEF(i)                                                    \
 827     pathA = pMask[i];                                                  \
 828     srcA = *(mlib_u8*)(src + i);                                       \
 829     srcA = mul8table[extraA][srcA];                                    \
 830     dstF = ((((srcA) &amp; DstOpAnd) ^ DstOpXor) + DstOpAdd);              \
 831     srcF = mul8table[pathA][srcFbase];                                 \
 832     dstA = 0xff - pathA + mul8table[pathA][dstF];                      \
 833     srcA = mul8table[srcF][srcA];                                      \
 834     resA = srcA + dstA;                                                \
 835     srcAx4 = vis_faligndata(vis_ld_u16(TBL_MUL + 2*srcA), srcAx4);     \
 836     divAx4 = vis_faligndata(vis_ld_u16(TBL_DIV + 8*resA), divAx4)
 837 
 838 /***************************************************************/
 839 
 840 void ADD_SUFF(IntArgbToUshortGrayAlphaMaskBlit)(MASKBLIT_PARAMS)
 841 {
 842     mlib_s32 extraA;
 843     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
 844     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
 845     mlib_u16 *dst_end;
 846     mlib_d64 srcAx4, dstAx4, divAx4, dd, ds;
 847     mlib_d64 done = vis_to_double_dup(0x01000100);
 848     mlib_f32 fscale = vis_to_float(0x02020202);
 849     mlib_s32 j;
 850     mlib_s32 SrcOpAnd, SrcOpXor, SrcOpAdd;
 851     mlib_s32 DstOpAnd, DstOpXor, DstOpAdd;
 852     mlib_s32 pathA, srcFbase, resA, resG, srcF, dstF, srcA, dstA;
 853 
 854     RGB_VARS;
 855 
 856     SrcOpAnd = (AlphaRules[pCompInfo-&gt;rule].srcOps).andval;
 857     SrcOpXor = (AlphaRules[pCompInfo-&gt;rule].srcOps).xorval;
 858     SrcOpAdd =
 859         (jint) (AlphaRules[pCompInfo-&gt;rule].srcOps).addval - SrcOpXor;
 860 
 861     DstOpAnd = (AlphaRules[pCompInfo-&gt;rule].dstOps).andval;
 862     DstOpXor = (AlphaRules[pCompInfo-&gt;rule].dstOps).xorval;
 863     DstOpAdd =
 864         (jint) (AlphaRules[pCompInfo-&gt;rule].dstOps).addval - DstOpXor;
 865 
 866     extraA = (mlib_s32)(pCompInfo-&gt;details.extraAlpha * 255.0 + 0.5);
 867 
 868     srcFbase = ((((0xff) &amp; SrcOpAnd) ^ SrcOpXor) + SrcOpAdd);
 869 
 870     vis_write_gsr((7 &lt;&lt; 3) | 6);
 871 
 872     if (pMask != NULL) {
 873         pMask += maskOff;
 874 
 875         if (dstScan == width &amp;&amp; srcScan == 4*width &amp;&amp; maskScan == width) {
 876             width *= height;
 877             height = 1;
 878         }
 879 
 880         maskScan -= width;
 881 
 882         for (j = 0; j &lt; height; j++) {
 883             mlib_f32 *src = srcBase;
 884             mlib_u16 *dst = dstBase;
 885 
 886             dst_end = dst + width;
 887 
 888             while (((mlib_s32)dst &amp; 3) &amp;&amp; dst &lt; dst_end) {
 889                 pathA = *pMask++;
 890                 srcA = *(mlib_u8*)src;
 891                 srcA = mul8table[extraA][srcA];
 892                 dstF = ((((srcA) &amp; DstOpAnd) ^ DstOpXor) + DstOpAdd);
 893                 srcF = mul8table[pathA][srcFbase];
 894                 dstA = 0xff - pathA + mul8table[pathA][dstF];
 895                 srcA = mul8table[srcF][srcA];
 896                 resA = srcA + dstA;
 897 
 898                 r = vis_ld_u8((mlib_u8*)src + 1);
 899                 g = vis_ld_u8((mlib_u8*)src + 2);
 900                 b = vis_ld_u8((mlib_u8*)src + 3);
 901                 GRAY_U16(dd, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 902                 dd = vis_fmul8x16(fscale, dd);
 903                 ff = vis_fpack16(dd);
 904 
 905                 dd = vis_freg_pair(vis_fzeros(),
 906                                    ((mlib_f32*)vis_mul8s_tbl)[dstA]);
 907                 DIV_ALPHA(dd, resA);
 908                 ds = vis_fpsub16(done, dd);
 909                 dd = vis_fmul8x16(vis_read_lo(vis_ld_u8(dst)), dd);
 910                 ds = vis_fmul8x16(ff, ds);
 911                 dd = vis_fpadd16(dd, ds);
 912                 ff = vis_fpack16(dd);
 913                 vis_st_u16(D64_FROM_F32x2(ff), dst);
 914 
 915                 dst++;
 916                 src++;
 917             }
 918 
 919 #pragma pipeloop(0)
 920             for (; dst &lt;= (dst_end - 4); dst += 4) {
 921                 GET_COEF(3);
 922                 GET_COEF(2);
 923                 GET_COEF(1);
 924                 GET_COEF(0);
 925                 pMask += 4;
 926                 srcAx4 = FMUL_16x16(srcAx4, divAx4);
 927                 dstAx4 = vis_fpsub16(done, srcAx4);
 928 
 929                 s02 = vis_fpmerge(src[0], src[2]);
 930                 s13 = vis_fpmerge(src[1], src[3]);
 931                 ar = vis_fpmerge(vis_read_hi(s02), vis_read_hi(s13));
 932                 gb = vis_fpmerge(vis_read_lo(s02), vis_read_lo(s13));
 933                 GRAY_U16(dd, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
 934                 dd = vis_fmul8x16(fscale, dd);
 935                 ff = vis_fpack16(dd);
 936 
 937                 dd = vis_fmul8x16(*(mlib_f32*)dst, dstAx4);
 938                 ds = vis_fmul8x16(ff, srcAx4);
 939                 dd = vis_fpadd16(dd, ds);
 940                 *(mlib_f32*)dst = vis_fpack16(dd);
 941 
 942                 src += 4;
 943             }
 944 
 945             while (dst &lt; dst_end) {
 946                 pathA = *pMask++;
 947                 srcA = *(mlib_u8*)src;
 948                 srcA = mul8table[extraA][srcA];
 949                 dstF = ((((srcA) &amp; DstOpAnd) ^ DstOpXor) + DstOpAdd);
 950                 srcF = mul8table[pathA][srcFbase];
 951                 dstA = 0xff - pathA + mul8table[pathA][dstF];
 952                 srcA = mul8table[srcF][srcA];
 953                 resA = srcA + dstA;
 954 
 955                 r = vis_ld_u8((mlib_u8*)src + 1);
 956                 g = vis_ld_u8((mlib_u8*)src + 2);
 957                 b = vis_ld_u8((mlib_u8*)src + 3);
 958                 GRAY_U16(dd, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
 959                 dd = vis_fmul8x16(fscale, dd);
 960                 ff = vis_fpack16(dd);
 961 
 962                 dd = vis_freg_pair(vis_fzeros(),
 963                                    ((mlib_f32*)vis_mul8s_tbl)[dstA]);
 964                 DIV_ALPHA(dd, resA);
 965                 ds = vis_fpsub16(done, dd);
 966                 dd = vis_fmul8x16(vis_read_lo(vis_ld_u8(dst)), dd);
 967                 ds = vis_fmul8x16(ff, ds);
 968                 dd = vis_fpadd16(dd, ds);
 969                 ff = vis_fpack16(dd);
 970                 vis_st_u16(D64_FROM_F32x2(ff), dst);
 971 
 972                 dst++;
 973                 src++;
 974             }
 975 
 976             PTR_ADD(dstBase, dstScan);
 977             PTR_ADD(srcBase, srcScan);
 978             PTR_ADD(pMask,  maskScan);
 979         }
 980     } else {
 981 
 982         if (dstScan == width &amp;&amp; srcScan == 4*width) {
 983             width *= height;
 984             height = 1;
 985         }
 986 
 987         for (j = 0; j &lt; height; j++) {
 988             mlib_f32 *src = srcBase;
 989             mlib_u16 *dst = dstBase;
 990 
 991             dst_end = dst + width;
 992 
 993             while (dst &lt; dst_end) {
 994                 srcA = *(mlib_u8*)src;
 995                 srcA = mul8table[extraA][srcA];
 996                 dstA = ((((srcA) &amp; DstOpAnd) ^ DstOpXor) + DstOpAdd);
 997                 srcA = mul8table[srcFbase][srcA];
 998                 resA = srcA + dstA;
 999 
1000                 r = vis_ld_u8((mlib_u8*)src + 1);
1001                 g = vis_ld_u8((mlib_u8*)src + 2);
1002                 b = vis_ld_u8((mlib_u8*)src + 3);
1003                 GRAY_U16(dd, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
1004                 dd = vis_fmul8x16(fscale, dd);
1005                 ff = vis_fpack16(dd);
1006 
1007                 resG = mul8table[dstA][*dst] +
1008                        mul8table[srcA][((mlib_u8*)&amp;ff)[3]];
1009                 *dst = div8table[resA][resG];
1010 
1011                 dst++;
1012                 src++;
1013             }
1014 
1015             PTR_ADD(dstBase, dstScan);
1016             PTR_ADD(srcBase, srcScan);
1017         }
1018     }
1019 }
1020 
1021 /***************************************************************/
1022 
1023 void ADD_SUFF(IntRgbToUshortGrayAlphaMaskBlit)(MASKBLIT_PARAMS)
1024 {
1025     mlib_s32 extraA;
1026     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
1027     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
1028     mlib_u16 *dst_end;
1029     mlib_d64 srcA_d, dstA_d, dd, d0, d1;
1030     mlib_s32 i, j, srcG;
1031     mlib_s32 SrcOpAnd, SrcOpXor, SrcOpAdd;
1032     mlib_s32 DstOpAnd, DstOpXor, DstOpAdd;
1033     mlib_s32 pathA, srcFbase, dstFbase, resA, resG, srcA, dstA;
1034 
1035     RGB_VARS;
1036 
1037     SrcOpAnd = (AlphaRules[pCompInfo-&gt;rule].srcOps).andval;
1038     SrcOpXor = (AlphaRules[pCompInfo-&gt;rule].srcOps).xorval;
1039     SrcOpAdd =
1040         (jint) (AlphaRules[pCompInfo-&gt;rule].srcOps).addval - SrcOpXor;
1041 
1042     DstOpAnd = (AlphaRules[pCompInfo-&gt;rule].dstOps).andval;
1043     DstOpXor = (AlphaRules[pCompInfo-&gt;rule].dstOps).xorval;
1044     DstOpAdd =
1045         (jint) (AlphaRules[pCompInfo-&gt;rule].dstOps).addval - DstOpXor;
1046 
1047     extraA = (mlib_s32)(pCompInfo-&gt;details.extraAlpha * 255.0 + 0.5);
1048 
1049     srcFbase = ((((0xff) &amp; SrcOpAnd) ^ SrcOpXor) + SrcOpAdd);
1050     dstFbase = (((extraA &amp; DstOpAnd) ^ DstOpXor) + DstOpAdd);
1051 
1052     srcFbase = mul8table[srcFbase][extraA];
1053 
1054     if (width &lt; 16) {
1055         if (pMask != NULL) {
1056             pMask += maskOff;
1057 
1058             for (j = 0; j &lt; height; j++) {
1059                 mlib_u16 *dst = dstBase;
1060                 mlib_u8  *src = srcBase;
1061 
1062                 for (i = 0; i &lt; width; i++) {
1063                     pathA = pMask[i];
1064                     dstA = 0xff - pathA + mul8table[dstFbase][pathA];
1065                     srcA = mul8table[srcFbase][pathA];
1066                     resA = srcA + dstA;
1067 
1068                     srcG = RGB2GRAY(src[4*i + 1], src[4*i + 2], src[4*i + 3]);
1069                     resG = mul8table[dstA][dst[i]] + mul8table[srcA][srcG];
1070                     resG = div8table[resA][resG];
1071                     dst[i] = resG;
1072                 }
1073 
1074                 PTR_ADD(dstBase, dstScan);
1075                 PTR_ADD(srcBase, srcScan);
1076                 PTR_ADD(pMask,  maskScan);
1077             }
1078         } else {
1079             dstA = dstFbase;
1080             srcA = srcFbase;
1081             resA = srcA + dstA;
1082 
1083             for (j = 0; j &lt; height; j++) {
1084                 mlib_u16 *dst = dstBase;
1085                 mlib_u8  *src = srcBase;
1086 
1087                 for (i = 0; i &lt; width; i++) {
1088                     srcG = RGB2GRAY(src[4*i + 1], src[4*i + 2], src[4*i + 3]);
1089                     resG = mul8table[dstA][dst[i]] + mul8table[srcA][srcG];
1090                     resG = div8table[resA][resG];
1091                     dst[i] = resG;
1092                 }
1093 
1094                 PTR_ADD(dstBase, dstScan);
1095                 PTR_ADD(srcBase, srcScan);
1096             }
1097         }
1098         return;
1099     }
1100 
1101     if (pMask != NULL) {
1102         mlib_s32 srcA_buff[256];
1103         mlib_d64 dscale = (mlib_d64)(1 &lt;&lt; 15)*(1 &lt;&lt; 16), ddiv;
1104         mlib_d64 d_one = vis_to_double_dup(0x7FFF7FFF);
1105 
1106         srcA_buff[0] = 0;
1107 #pragma pipeloop(0)
1108         for (pathA = 1; pathA &lt; 256; pathA++) {
1109             dstA = 0xff - pathA + mul8table[dstFbase][pathA];
1110             srcA = mul8table[srcFbase][pathA];
1111             resA = dstA + srcA;
1112             ddiv = dscale*vis_d64_div_tbl[resA];
1113             srcA_buff[pathA] = srcA*ddiv + (1 &lt;&lt; 15);
1114         }
1115 
1116         pMask += maskOff;
1117         maskScan -= width;
1118 
1119         if (dstScan == width &amp;&amp; srcScan == 4*width &amp;&amp; maskScan == width) {
1120             width *= height;
1121             height = 1;
1122         }
1123 
1124         for (j = 0; j &lt; height; j++) {
1125             mlib_f32 *src = srcBase;
1126             mlib_u16 *dst = dstBase;
1127 
1128             dst_end = dst + width;
1129 
1130             while (((mlib_s32)dst &amp; 3) &amp;&amp; dst &lt; dst_end) {
1131                 pathA = *pMask++;
1132                 srcA_d = vis_ld_u16(srcA_buff + pathA);
1133                 dstA_d = vis_fpsub16(d_one, srcA_d);
1134                 r = vis_ld_u8((mlib_u8*)src + 1);
1135                 g = vis_ld_u8((mlib_u8*)src + 2);
1136                 b = vis_ld_u8((mlib_u8*)src + 3);
1137                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
1138                 d0 = vis_fpadd16(vis_fmul8x16(ff, srcA_d), d_half);
1139                 d1 = vis_fmul8x16(vis_read_lo(vis_ld_u8(dst)), dstA_d);
1140                 dd = vis_fpadd16(d0, d1);
1141                 vis_st_u16(D64_FROM_F32x2(vis_fpack16(dd)), dst);
1142                 dst++;
1143                 src++;
1144             }
1145 
1146 #pragma pipeloop(0)
1147             for (; dst &lt;= (dst_end - 4); dst += 4) {
1148                 LOAD_NEXT_U16(srcA_d, srcA_buff + pMask[3]);
1149                 LOAD_NEXT_U16(srcA_d, srcA_buff + pMask[2]);
1150                 LOAD_NEXT_U16(srcA_d, srcA_buff + pMask[1]);
1151                 LOAD_NEXT_U16(srcA_d, srcA_buff + pMask[0]);
1152                 dstA_d = vis_fpsub16(d_one, srcA_d);
1153                 pMask += 4;
1154 
1155                 s02 = vis_fpmerge(src[0], src[2]);
1156                 s13 = vis_fpmerge(src[1], src[3]);
1157                 ar = vis_fpmerge(vis_read_hi(s02), vis_read_hi(s13));
1158                 gb = vis_fpmerge(vis_read_lo(s02), vis_read_lo(s13));
1159                 GRAY_U16(ff, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
1160                 dd = vis_fpadd16(vis_fmul8x16(ff, srcA_d), d_half);
1161                 dd = vis_fpadd16(vis_fmul8x16(*(mlib_f32*)dst, dstA_d), dd);
1162                 *(mlib_f32*)dst = vis_fpack16(dd);
1163                 src += 4;
1164             }
1165 
1166             while (dst &lt; dst_end) {
1167                 pathA = *pMask++;
1168                 srcA_d = vis_ld_u16(srcA_buff + pathA);
1169                 dstA_d = vis_fpsub16(d_one, srcA_d);
1170                 r = vis_ld_u8((mlib_u8*)src + 1);
1171                 g = vis_ld_u8((mlib_u8*)src + 2);
1172                 b = vis_ld_u8((mlib_u8*)src + 3);
1173                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
1174                 d0 = vis_fpadd16(vis_fmul8x16(ff, srcA_d), d_half);
1175                 d1 = vis_fmul8x16(vis_read_lo(vis_ld_u8(dst)), dstA_d);
1176                 dd = vis_fpadd16(d0, d1);
1177                 ff = vis_fpack16(dd);
1178                 vis_st_u16(D64_FROM_F32x2(ff), dst);
1179                 dst++;
1180                 src++;
1181             }
1182 
1183             PTR_ADD(dstBase, dstScan);
1184             PTR_ADD(srcBase, srcScan);
1185             PTR_ADD(pMask,  maskScan);
1186         }
1187     } else {
1188         mlib_d64 dscale = (mlib_d64)(1 &lt;&lt; 15)*(1 &lt;&lt; 16), ddiv;
1189         mlib_d64 d_one = vis_to_double_dup(0x7FFF7FFF);
1190 
1191         dstA = dstFbase;
1192         srcA = srcFbase;
1193         resA = dstA + srcA;
1194         ddiv = dscale*vis_d64_div_tbl[resA];
1195         srcA = (mlib_s32)(srcA*ddiv + (1 &lt;&lt; 15)) &gt;&gt; 16;
1196         srcA_d = vis_to_double_dup((srcA &lt;&lt; 16) | srcA);
1197         dstA_d = vis_fpsub16(d_one, srcA_d);
1198 
1199         if (dstScan == width &amp;&amp; srcScan == 4*width) {
1200             width *= height;
1201             height = 1;
1202         }
1203 
1204         for (j = 0; j &lt; height; j++) {
1205             mlib_f32 *src = srcBase;
1206             mlib_u16 *dst = dstBase;
1207 
1208             dst_end = dst + width;
1209 
1210             while (((mlib_s32)dst &amp; 3) &amp;&amp; dst &lt; dst_end) {
1211                 r = vis_ld_u8((mlib_u8*)src + 1);
1212                 g = vis_ld_u8((mlib_u8*)src + 2);
1213                 b = vis_ld_u8((mlib_u8*)src + 3);
1214                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
1215                 d0 = vis_fpadd16(vis_fmul8x16(ff, srcA_d), d_half);
1216                 d1 = vis_fmul8x16(vis_read_lo(vis_ld_u8(dst)), dstA_d);
1217                 dd = vis_fpadd16(d0, d1);
1218                 vis_st_u16(D64_FROM_F32x2(vis_fpack16(dd)), dst);
1219                 dst++;
1220                 src++;
1221             }
1222 
1223 #pragma pipeloop(0)
1224             for (; dst &lt;= (dst_end - 4); dst += 4) {
1225                 s02 = vis_fpmerge(src[0], src[2]);
1226                 s13 = vis_fpmerge(src[1], src[3]);
1227                 ar = vis_fpmerge(vis_read_hi(s02), vis_read_hi(s13));
1228                 gb = vis_fpmerge(vis_read_lo(s02), vis_read_lo(s13));
1229                 GRAY_U16(ff, vis_read_lo(ar), vis_read_hi(gb), vis_read_lo(gb));
1230                 dd = vis_fpadd16(vis_fmul8x16(ff, srcA_d), d_half);
1231                 dd = vis_fpadd16(vis_fmul8x16(*(mlib_f32*)dst, dstA_d), dd);
1232                 *(mlib_f32*)dst = vis_fpack16(dd);
1233                 src += 4;
1234             }
1235 
1236             while (dst &lt; dst_end) {
1237                 r = vis_ld_u8((mlib_u8*)src + 1);
1238                 g = vis_ld_u8((mlib_u8*)src + 2);
1239                 b = vis_ld_u8((mlib_u8*)src + 3);
1240                 GRAY_U16(ff, vis_read_lo(r), vis_read_lo(g), vis_read_lo(b));
1241                 d0 = vis_fpadd16(vis_fmul8x16(ff, srcA_d), d_half);
1242                 d1 = vis_fmul8x16(vis_read_lo(vis_ld_u8(dst)), dstA_d);
1243                 dd = vis_fpadd16(d0, d1);
1244                 ff = vis_fpack16(dd);
1245                 vis_st_u16(D64_FROM_F32x2(ff), dst);
1246                 dst++;
1247                 src++;
1248             }
1249 
1250             PTR_ADD(dstBase, dstScan);
1251             PTR_ADD(srcBase, srcScan);
1252         }
1253     }
1254 }
1255 
1256 /***************************************************************/
1257 
1258 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/common/awt/medialib/mlib_v_ImageCopy_f.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 
 28 /*
 29  * FUNCTIONS
 30  *      mlib_v_ImageCopy_a1         - 1-D, Aligned8, size 8x
 31  *      mlib_v_ImageCopy_a2         - 2-D, Aligned8, width 8x
 32  *      mlib_ImageCopy_na           - BYTE, non-aligned
 33  *      mlib_ImageCopy_bit_al       - BIT, aligned
 34  *
 35  * SYNOPSIS
 36  *
 37  * ARGUMENT
 38  *      sp       pointer to source image data
 39  *      dp       pointer to destination image data
 40  *      size     size in 8-bytes, bytes, or SHORTs
 41  *      width    image width in 8-bytes
 42  *      height   image height in lines
 43  *      stride   source image line stride in 8-bytes
 44  *      dstride  destination image line stride in 8-bytes
 45  *      s_offset source image line bit offset
 46  *      d_offset destination image line bit offset
 47  *
 48  * DESCRIPTION
 49  *      Direct copy from one image to another -- VIS version low level
 50  *      functions.
 51  *
 52  * NOTE
 53  *      These functions are separated from mlib_v_ImageCopy.c for loop
 54  *      unrolling and structure clarity.
 55  */
 56 
 57 #include &quot;vis_proto.h&quot;
 58 #include &quot;mlib_image.h&quot;
 59 #include &quot;mlib_ImageCopy.h&quot;
 60 #include &quot;mlib_v_ImageCopy_f.h&quot;
 61 
 62 #define VIS_ALIGNADDR(X, Y)  vis_alignaddr((void *)(X), Y)
 63 
 64 /***************************************************************/
 65 /*
 66  * Both source and destination image data are 1-d vectors and
 67  * 8-byte aligned. And size is in 8-bytes.
 68  */
 69 
 70 void mlib_v_ImageCopy_a1(mlib_d64 *sp,
 71                          mlib_d64 *dp,
 72                          mlib_s32 size)
 73 {
 74   mlib_s32 i;
 75 
 76 #pragma pipeloop(0)
 77   for (i = 0; i &lt; size; i++) {
 78     *dp++ = *sp++;
 79   }
 80 }
 81 
 82 /***************************************************************/
 83 /*
 84  * Either source or destination image data are not 1-d vectors, but
 85  * they are 8-byte aligned. And stride and width are in 8-bytes.
 86  */
 87 
 88 void mlib_v_ImageCopy_a2(mlib_d64 *sp,
 89                          mlib_d64 *dp,
 90                          mlib_s32 width,
 91                          mlib_s32 height,
 92                          mlib_s32 stride,
 93                          mlib_s32 dstride)
 94 {
 95   mlib_d64 *spl;                                      /* 8-byte aligned pointer for line */
 96   mlib_d64 *dpl;                                      /* 8-byte aligned pointer for line */
 97   mlib_s32 i, j;                                      /* indices for x, y */
 98 
 99   spl = sp;
100   dpl = dp;
101 
102   /* row loop */
103   for (j = 0; j &lt; height; j++) {
104     /* 8-byte column loop */
105 #pragma pipeloop(0)
106     for (i = 0; i &lt; width; i++) {
107       *dp++ = *sp++;
108     }
109 
110     sp = spl += stride;
111     dp = dpl += dstride;
112   }
113 }
114 
115 /***************************************************************/
116 /*
117  * Both bit offsets of source and distination are the same
118  */
119 
120 void mlib_ImageCopy_bit_al(const mlib_u8 *sa,
121                            mlib_u8       *da,
122                            mlib_s32      size,
123                            mlib_s32      offset)
124 {
125   mlib_u8 *dend;                                      /* end points in dst */
126   mlib_d64 *dp;                                       /* 8-byte aligned start points in dst */
127   mlib_d64 *sp;                                       /* 8-byte aligned start point in src */
128   mlib_d64 s0, s1;                                    /* 8-byte source data */
129   mlib_s32 j;                                         /* offset of address in dst */
130   mlib_s32 emask;                                     /* edge mask */
131   mlib_s32 b_size;                                    /* size in bytes */
132   mlib_u8 mask0 = 0xFF;
133   mlib_u8 src, mask;
134 
135   if (size &lt;- 0) return;
136 
137   if (size &lt; (8 - offset)) {
138     mask = mask0 &lt;&lt; (8 - size);
139     mask &gt;&gt;= offset;
140     src = da[0];
141     da[0] = (src &amp; (~mask)) | (sa[0] &amp; mask);
142     return;
143   }
144 
145   mask = mask0 &gt;&gt; offset;
146   src = da[0];
147   da[0] = (src &amp; (~mask)) | (sa[0] &amp; mask);
148   da++;
149   sa++;
150   size = size - 8 + offset;
151   b_size = size &gt;&gt; 3;                       /* size in bytes */
152 
153   /* prepare the destination addresses */
154   dp = (mlib_d64 *) ((mlib_addr) da &amp; (~7));
155   j = (mlib_addr) dp - (mlib_addr) da;
156   dend = da + b_size - 1;
157 
158   /* prepare the source address */
159   sp = (mlib_d64 *) VIS_ALIGNADDR(sa, j);
160   /* generate edge mask for the start point */
161   emask = vis_edge8(da, dend);
162 
163   s1 = vis_ld_d64_nf(sp);
164   if (emask != 0xff) {
165     s0 = s1;
166     s1 = vis_ld_d64_nf(sp+1);
167     s0 = vis_faligndata(s0, s1);
168     vis_pst_8(s0, dp++, emask);
169     sp++;
170     j += 8;
171   }
172 
173 #pragma pipeloop(0)
174   for (; j &lt;= (b_size - 8); j += 8) {
175     s0 = s1;
176     s1 = vis_ld_d64_nf(sp+1);
177     *dp++ = vis_faligndata(s0, s1);
178     sp++;
179   }
180 
181   if (j &lt; b_size) {
182     s0 = vis_faligndata(s1, vis_ld_d64_nf(sp+1));
183     emask = vis_edge8(dp, dend);
184     vis_pst_8(s0, dp, emask);
185   }
186 
187   j = size &amp; 7;
188 
189   if (j &gt; 0) {
190     mask = mask0 &lt;&lt; (8 - j);
191     src = dend[1];
192     dend[1] = (src &amp; (~mask)) | (sa[b_size] &amp; mask);
193   }
194 }
195 
196 /***************************************************************/
197 /*
198  * Either source or destination data are not 8-byte aligned.
199  * And size is in bytes.
200  */
201 
202 void mlib_ImageCopy_na(const mlib_u8 *sa,
203                        mlib_u8       *da,
204                        mlib_s32      size)
205 {
206   mlib_u8 *dend;                                      /* end points in dst */
207   mlib_d64 *dp;                                       /* 8-byte aligned start points in dst */
208   mlib_d64 *sp;                                       /* 8-byte aligned start point in src */
209   mlib_d64 s0, s1;                                    /* 8-byte source data */
210   mlib_s32 j;                                         /* offset of address in dst */
211   mlib_s32 emask;                                     /* edge mask */
212 
213   /* prepare the destination addresses */
214   dp = (mlib_d64 *) ((mlib_addr) da &amp; (~7));
215   j = (mlib_addr) dp - (mlib_addr) da;
216   dend = da + size - 1;
217 
218   /* prepare the source address */
219   sp = (mlib_d64 *) VIS_ALIGNADDR(sa, j);
220   /* generate edge mask for the start point */
221   emask = vis_edge8(da, dend);
222 
223   s1 = vis_ld_d64_nf(sp);
224   if (emask != 0xff) {
225     s0 = s1;
226     s1 = vis_ld_d64_nf(sp+1);
227     s0 = vis_faligndata(s0, s1);
228     vis_pst_8(s0, dp++, emask);
229     sp++;
230     j += 8;
231   }
232 
233   if (((mlib_addr) sa ^ (mlib_addr) da) &amp; 7) {
234 #pragma pipeloop(0)
235     for (; j &lt;= (size - 8); j += 8) {
236       s0 = s1;
237       s1 = vis_ld_d64_nf(sp+1);
238       *dp++ = vis_faligndata(s0, s1);
239       sp++;
240     }
241 
242     if (j &lt; size) {
243       s0 = vis_faligndata(s1, vis_ld_d64_nf(sp+1));
244       emask = vis_edge8(dp, dend);
245       vis_pst_8(s0, dp, emask);
246     }
247   }
248   else {
249 #pragma pipeloop(0)
250     for (; j &lt;= (size - 8); j += 8) {
251       *dp++ = *sp++;
252     }
253 
254     if (j &lt; size) {
255       emask = vis_edge8(dp, dend);
256       vis_pst_8(vis_ld_d64_nf(sp), dp, emask);
257     }
258   }
259 }
260 
261 /***************************************************************/
    </pre>
  </body>
</html>
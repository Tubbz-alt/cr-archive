<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/sun/font/FontScaler.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2007, 2014, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.font;
 27 
 28 import java.awt.geom.GeneralPath;
 29 import java.awt.geom.Point2D;
 30 import java.awt.geom.Rectangle2D;
 31 import java.lang.ref.WeakReference;
 32 
 33 import sun.java2d.Disposer;
 34 import sun.java2d.DisposerRecord;
 35 
 36 /* FontScaler is &quot;internal interface&quot; to font rasterizer library.
 37  *
 38  * Access to native rasterizers without going through this interface is
 39  * strongly discouraged. In particular, this is important because native
 40  * data could be disposed due to runtime font processing error at any time.
 41  *
 42  * FontScaler represents combination of particular rasterizer implementation
 43  * and particular font. It does not include rasterization attributes such as
 44  * transform. These attributes are part of native scalerContext object.
 45  * This approach allows to share same scaler for different requests related
 46  * to the same font file.
 47  *
 48  * Note that scaler may throw FontScalerException on any operation.
 49  * Generally this means that runtime error had happened and scaler is not
 50  * usable.  Subsequent calls to this scaler should not cause crash but will
 51  * likely cause exceptions to be thrown again.
 52  *
 53  * It is recommended that callee should replace its reference to the scaler
 54  * with something else. For instance it could be FontManager.getNullScaler().
 55  * Note that NullScaler is trivial and will not actually rasterize anything.
 56  *
 57  * Alternatively, callee can use more sophisticated error recovery strategies
 58  * and for instance try to substitute failed scaler with new scaler instance
 59  * using another font.
 60  *
 61  * Note that in case of error there is no need to call dispose(). Moreover,
 62  * dispose() generally is called by Disposer thread and explicit calls to
 63  * dispose might have unexpected sideeffects because scaler can be shared.
 64  *
 65  * Current disposing logic is the following:
 66  *   - scaler is registered in the Disposer by the FontManager (on creation)
 67  *   - scalers are disposed when associated Font2D object (e.g. TruetypeFont)
 68  *     is garbage collected. That&#39;s why this object implements DisposerRecord
 69  *     interface directly (as it is not used as indicator when it is safe
 70  *     to release native state) and that&#39;s why we have to use WeakReference
 71  *     to Font internally.
 72  *   - Majority of Font2D objects are linked from various mapping arrays
 73  *     (e.g. FontManager.localeFullNamesToFont). So, they are not collected.
 74  *     This logic only works for fonts created with Font.createFont()
 75  *
 76  *  Notes:
 77  *   - Eventually we may consider releasing some of the scaler resources if
 78  *     it was not used for a while but we do not want to be too aggressive on
 79  *     this (and this is probably more important for Type1 fonts).
 80  */
 81 public abstract class FontScaler implements DisposerRecord {
 82 
 83     private static FontScaler nullScaler = null;
 84 
 85     //Find preferred font scaler
 86     //
 87     //NB: we can allow property based preferences
 88     //   (theoretically logic can be font type specific)
 89 
 90     /* This is the only place to instantiate new FontScaler.
 91      * Therefore this is very convinient place to register
 92      * scaler with Disposer as well as trigger deregistering a bad font
 93      * when the scaler reports this.
 94      */
 95     public static FontScaler getScaler(Font2D font,
 96                                 int indexInCollection,
 97                                 boolean supportsCJK,
 98                                 int filesize) {
 99         FontScaler scaler = null;
100 
101         try {
102             scaler = new FreetypeFontScaler(font, indexInCollection,
103                                             supportsCJK, filesize);
104             Disposer.addObjectRecord(font, scaler);
105         } catch (Throwable e) {
106             scaler = getNullScaler();
107 
108             //if we can not instantiate scaler assume a bad font
109             //NB: technically it could be also because of internal scaler
110             //    error but here we are assuming scaler is ok.
111             FontManager fm = FontManagerFactory.getInstance();
112             fm.deRegisterBadFont(font);
113         }
114         return scaler;
115     }
116 
117     /*
118      * At the moment it is harmless to create 2 null scalers so, technically,
119      * syncronized keyword is not needed.
120      *
121      * But it is safer to keep it to avoid subtle problems if we will be adding
122      * checks like whether scaler is null scaler.
123      */
124     public static synchronized FontScaler getNullScaler() {
125         if (nullScaler == null) {
126             nullScaler = new NullFontScaler();
127         }
128         return nullScaler;
129     }
130 
131     protected WeakReference&lt;Font2D&gt; font = null;
132     protected long nativeScaler = 0; //used by decendants
133                                      //that have native state
134     protected boolean disposed = false;
135 
136     abstract StrikeMetrics getFontMetrics(long pScalerContext)
137                 throws FontScalerException;
138 
139     abstract float getGlyphAdvance(long pScalerContext, int glyphCode)
140                 throws FontScalerException;
141 
142     abstract void getGlyphMetrics(long pScalerContext, int glyphCode,
143                                   Point2D.Float metrics)
144                 throws FontScalerException;
145 
146     /*
147      *  Returns pointer to native GlyphInfo object.
148      *  Callee is responsible for freeing this memory.
149      *
150      *  Note:
151      *   currently this method has to return not 0L but pointer to valid
152      *   GlyphInfo object. Because Strike and drawing releated logic does
153      *   expect that.
154      *   In the future we may want to rework this to allow 0L here.
155      */
156     abstract long getGlyphImage(long pScalerContext, int glyphCode)
157                 throws FontScalerException;
158 
159     abstract Rectangle2D.Float getGlyphOutlineBounds(long pContext,
160                                                      int glyphCode)
161                 throws FontScalerException;
162 
163     abstract GeneralPath getGlyphOutline(long pScalerContext, int glyphCode,
164                                          float x, float y)
165                 throws FontScalerException;
166 
167     abstract GeneralPath getGlyphVectorOutline(long pScalerContext, int[] glyphs,
168                                                int numGlyphs, float x, float y)
169                 throws FontScalerException;
170 
171     /* Used by Java2D disposer to ensure native resources are released.
172        Note: this method does not release any of created
173              scaler context objects! */
174     public void dispose() {}
175 
176     /**
177      * Used when the native resources held by the scaler need
178      * to be released before the 2D disposer runs.
179      */
180     public void disposeScaler() {}
181 
182     /* At the moment these 3 methods are needed for Type1 fonts only.
183      * For Truetype fonts we extract required info outside of scaler
184      * on java layer.
185      */
186     abstract int getNumGlyphs() throws FontScalerException;
187     abstract int getMissingGlyphCode() throws FontScalerException;
188     abstract int getGlyphCode(char charCode) throws FontScalerException;
189 
190     /* Used by the OpenType engine for mark positioning. */
191     abstract Point2D.Float getGlyphPoint(long pScalerContext,
192                                 int glyphCode, int ptNumber)
193         throws FontScalerException;
194 
195     abstract long getUnitsPerEm();
196 
197     /* Returns pointer to native structure describing rasterization attributes.
198        Format of this structure is scaler-specific.
199 
200        Callee is responsible for freeing scaler context (using free()).
201 
202        Note:
203          Context is tightly associated with strike and it is actually
204         freed when corresponding strike is being released.
205      */
206     abstract long createScalerContext(double[] matrix,
207                                       int aa, int fm,
<a name="1" id="anc1"></a><span class="line-modified">208                                       float boldness, float italic);</span>

209 
210     /* Marks context as invalid because native scaler is invalid.
211        Notes:
212          - pointer itself is still valid and has to be released
213          - if pointer to native scaler was cached it
214            should not be neither disposed nor used.
215            it is very likely it is already disposed by this moment. */
216     abstract void invalidateScalerContext(long ppScalerContext);
217 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
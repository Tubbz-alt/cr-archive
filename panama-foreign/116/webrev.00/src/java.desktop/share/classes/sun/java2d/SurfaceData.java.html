<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/classes/sun/java2d/SurfaceData.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d;
  27 
  28 import java.awt.Color;
  29 import java.awt.Rectangle;
  30 import java.awt.Transparency;
  31 import java.awt.GraphicsConfiguration;
  32 import java.awt.Image;
  33 import java.awt.image.ColorModel;
  34 import java.awt.image.IndexColorModel;
  35 import java.awt.image.Raster;
  36 
  37 import sun.font.FontUtilities;
  38 import sun.java2d.loops.RenderCache;
  39 import sun.java2d.loops.RenderLoops;
  40 import sun.java2d.loops.CompositeType;
  41 import sun.java2d.loops.SurfaceType;
  42 import sun.java2d.loops.MaskFill;
  43 import sun.java2d.loops.DrawLine;
  44 import sun.java2d.loops.FillRect;
  45 import sun.java2d.loops.DrawRect;
  46 import sun.java2d.loops.DrawPolygons;
  47 import sun.java2d.loops.DrawPath;
  48 import sun.java2d.loops.FillPath;
  49 import sun.java2d.loops.FillSpans;
  50 import sun.java2d.loops.FillParallelogram;
  51 import sun.java2d.loops.DrawParallelogram;
  52 import sun.java2d.loops.FontInfo;
  53 import sun.java2d.loops.DrawGlyphList;
  54 import sun.java2d.loops.DrawGlyphListAA;
  55 import sun.java2d.loops.DrawGlyphListLCD;
  56 import sun.java2d.pipe.LoopPipe;
  57 import sun.java2d.pipe.ShapeDrawPipe;
  58 import sun.java2d.pipe.ParallelogramPipe;
  59 import sun.java2d.pipe.CompositePipe;
  60 import sun.java2d.pipe.GeneralCompositePipe;
  61 import sun.java2d.pipe.SpanClipRenderer;
  62 import sun.java2d.pipe.SpanShapeRenderer;
  63 import sun.java2d.pipe.AAShapePipe;
  64 import sun.java2d.pipe.AlphaPaintPipe;
  65 import sun.java2d.pipe.AlphaColorPipe;
  66 import sun.java2d.pipe.PixelToShapeConverter;
  67 import sun.java2d.pipe.PixelToParallelogramConverter;
  68 import sun.java2d.pipe.TextPipe;
  69 import sun.java2d.pipe.TextRenderer;
  70 import sun.java2d.pipe.AATextRenderer;
  71 import sun.java2d.pipe.LCDTextRenderer;
  72 import sun.java2d.pipe.SolidTextRenderer;
  73 import sun.java2d.pipe.OutlineTextRenderer;
  74 import sun.java2d.pipe.DrawImagePipe;
  75 import sun.java2d.pipe.DrawImage;
  76 import sun.awt.SunHints;
  77 import sun.awt.image.SurfaceManager;
  78 import sun.java2d.pipe.LoopBasedPipe;
  79 
  80 /**
  81  * This class provides various pieces of information relevant to a
  82  * particular drawing surface.  The information obtained from this
  83  * object describes the pixels of a particular instance of a drawing
  84  * surface and can only be shared among the various graphics objects
  85  * that target the same BufferedImage or the same screen Component.
  86  * &lt;p&gt;
  87  * Each SurfaceData object holds a StateTrackableDelegate object
  88  * which tracks both changes to the content of the pixels of this
  89  * surface and changes to the overall state of the pixels - such
  90  * as becoming invalid or losing the surface.  The delegate is
  91  * marked &quot;dirty&quot; whenever the setSurfaceLost() or invalidate()
  92  * methods are called and should also be marked &quot;dirty&quot; by the
  93  * rendering pipelines whenever they modify the pixels of this
  94  * SurfaceData.
  95  * &lt;p&gt;
  96  * If you get a StateTracker from a SurfaceData and it reports
  97  * that it is still &quot;current&quot;, then you can trust that the pixels
  98  * have not changed and that the SurfaceData is still valid and
  99  * has not lost its underlying storage (surfaceLost) since you
 100  * retrieved the tracker.
 101  */
 102 public abstract class SurfaceData
 103     implements Transparency, DisposerTarget, StateTrackable, Surface
 104 {
 105     private long pData;
 106     private boolean valid;
 107     private boolean surfaceLost; // = false;
 108     private SurfaceType surfaceType;
 109     private ColorModel colorModel;
 110 
 111     private Object disposerReferent = new Object();
 112 
 113     private static native void initIDs();
 114 
 115     private Object blitProxyKey;
 116     private StateTrackableDelegate stateDelegate;
 117 
 118     static {
 119         initIDs();
 120     }
 121 
 122     protected SurfaceData(SurfaceType surfaceType, ColorModel cm) {
 123         this(State.STABLE, surfaceType, cm);
 124     }
 125 
 126     protected SurfaceData(State state, SurfaceType surfaceType, ColorModel cm) {
 127         this(StateTrackableDelegate.createInstance(state), surfaceType, cm);
 128     }
 129 
 130     protected SurfaceData(StateTrackableDelegate trackable,
 131                           SurfaceType surfaceType, ColorModel cm)
 132     {
 133         this.stateDelegate = trackable;
 134         this.colorModel = cm;
 135         this.surfaceType = surfaceType;
 136         valid = true;
 137     }
 138 
 139     protected SurfaceData(State state) {
 140         this.stateDelegate = StateTrackableDelegate.createInstance(state);
 141         valid = true;
 142     }
 143 
 144     /**
 145      * Subclasses can set a &quot;blit proxy key&quot; which will be used
 146      * along with the SurfaceManager.getCacheData() mechanism to
 147      * store acceleration-compatible cached copies of source images.
 148      * This key is a &quot;tag&quot; used to identify which cached copies
 149      * are compatible with this destination SurfaceData.
 150      * The getSourceSurfaceData() method uses this key to manage
 151      * cached copies of a source image as described below.
 152      * &lt;p&gt;
 153      * The Object used as this key should be as unique as it needs
 154      * to be to ensure that multiple acceleratible destinations can
 155      * each store their cached copies separately under different keys
 156      * without interfering with each other or getting back the wrong
 157      * cached copy.
 158      * &lt;p&gt;
 159      * Many acceleratable SurfaceData objects can use their own
 160      * GraphicsConfiguration as their proxy key as the GC object will
 161      * typically be unique to a given screen and pixel format, but
 162      * other rendering destinations may have more or less stringent
 163      * sharing requirements.  For instance, X11 pixmaps can be
 164      * shared on a given screen by any GraphicsConfiguration that
 165      * has the same depth and SurfaceType.  Multiple such GCs with
 166      * the same depth and SurfaceType can exist per screen so storing
 167      * a different cached proxy for each would be a waste.  One can
 168      * imagine platforms where a single cached copy can be created
 169      * and shared across all screens and pixel formats - such
 170      * implementations could use a single heavily shared key Object.
 171      */
 172     protected void setBlitProxyKey(Object key) {
 173         // Caching is effectively disabled if we never have a proxy key
 174         // since the getSourceSurfaceData() method only does caching
 175         // if the key is not null.
 176         if (SurfaceDataProxy.isCachingAllowed()) {
 177             this.blitProxyKey = key;
 178         }
 179     }
 180 
 181     /**
 182      * This method is called on a destination SurfaceData to choose
 183      * the best SurfaceData from a source Image for an imaging
 184      * operation, with help from its SurfaceManager.
 185      * The method may determine that the default SurfaceData was
 186      * really the best choice in the first place, or it may decide
 187      * to use a cached surface.  Some general decisions about whether
 188      * acceleration is enabled are made by this method, but any
 189      * decision based on the type of the source image is made in
 190      * the makeProxyFor method below when it comes up with the
 191      * appropriate SurfaceDataProxy instance.
 192      * The parameters describe the type of imaging operation being performed.
 193      * &lt;p&gt;
 194      * If a blitProxyKey was supplied by the subclass then it is
 195      * used to potentially override the choice of source SurfaceData.
 196      * The outline of this process is:
 197      * &lt;ol&gt;
 198      * &lt;li&gt; Image pipeline asks destSD to find an appropriate
 199      *      srcSD for a given source Image object.
 200      * &lt;li&gt; destSD gets the SurfaceManager of the source Image
 201      *      and first retrieves the default SD from it using
 202      *      getPrimarySurfaceData()
 203      * &lt;li&gt; destSD uses its &quot;blit proxy key&quot; (if set) to look for
 204      *      some cached data stored in the source SurfaceManager
 205      * &lt;li&gt; If the cached data is null then makeProxyFor() is used
 206      *      to create some cached data which is stored back in the
 207      *      source SurfaceManager under the same key for future uses.
 208      * &lt;li&gt; The cached data will be a SurfaceDataProxy object.
 209      * &lt;li&gt; The SurfaceDataProxy object is then consulted to
 210      *      return a replacement SurfaceData object (typically
 211      *      a cached copy if appropriate, or the original if not).
 212      * &lt;/ol&gt;
 213      */
 214     public SurfaceData getSourceSurfaceData(Image img,
 215                                             int txtype,
 216                                             CompositeType comp,
 217                                             Color bgColor)
 218     {
 219         SurfaceManager srcMgr = SurfaceManager.getManager(img);
 220         SurfaceData srcData = srcMgr.getPrimarySurfaceData();
 221         if (img.getAccelerationPriority() &gt; 0.0f &amp;&amp;
 222             blitProxyKey != null)
 223         {
 224             SurfaceDataProxy sdp =
 225                 (SurfaceDataProxy) srcMgr.getCacheData(blitProxyKey);
 226             if (sdp == null || !sdp.isValid()) {
 227                 if (srcData.getState() == State.UNTRACKABLE) {
 228                     sdp = SurfaceDataProxy.UNCACHED;
 229                 } else {
 230                     sdp = makeProxyFor(srcData);
 231                 }
 232                 srcMgr.setCacheData(blitProxyKey, sdp);
 233             }
 234             srcData = sdp.replaceData(srcData, txtype, comp, bgColor);
 235         }
 236         return srcData;
 237     }
 238 
 239     /**
 240      * This method is called on a destination SurfaceData to choose
 241      * a proper SurfaceDataProxy subclass for a source SurfaceData
 242      * to use to control when and with what surface to override a
 243      * given image operation.  The argument is the default SurfaceData
 244      * for the source Image.
 245      * &lt;p&gt;
 246      * The type of the return object is chosen based on the
 247      * acceleration capabilities of this SurfaceData and the
 248      * type of the given source SurfaceData object.
 249      * &lt;p&gt;
 250      * In some cases the original SurfaceData will always be the
 251      * best choice to use to blit to this SurfaceData.  This can
 252      * happen if the source image is a hardware surface of the
 253      * same type as this one and so acceleration will happen without
 254      * any caching.  It may also be the case that the source image
 255      * can never be accelerated on this SurfaceData - for example
 256      * because it is translucent and there are no accelerated
 257      * translucent image ops for this surface.
 258      * &lt;p&gt;
 259      * In those cases there is a special SurfaceDataProxy.UNCACHED
 260      * instance that represents a NOP for caching purposes - it
 261      * always returns the original sourceSD object as the replacement
 262      * copy so no caching is ever performed.
 263      */
 264     public SurfaceDataProxy makeProxyFor(SurfaceData srcData) {
 265         return SurfaceDataProxy.UNCACHED;
 266     }
 267 
 268     /**
 269      * Extracts the SurfaceManager from the given Image, and then
 270      * returns the SurfaceData object that would best be suited as the
 271      * destination surface in some rendering operation.
 272      */
 273     public static SurfaceData getPrimarySurfaceData(Image img) {
 274         SurfaceManager sMgr = SurfaceManager.getManager(img);
 275         return sMgr.getPrimarySurfaceData();
 276     }
 277 
 278     /**
 279      * Restores the contents of the given Image and then returns the new
 280      * SurfaceData object in use by the Image&#39;s SurfaceManager.
 281      */
 282     public static SurfaceData restoreContents(Image img) {
 283         SurfaceManager sMgr = SurfaceManager.getManager(img);
 284         return sMgr.restoreContents();
 285     }
 286 
 287     public State getState() {
 288         return stateDelegate.getState();
 289     }
 290 
 291     public StateTracker getStateTracker() {
 292         return stateDelegate.getStateTracker();
 293     }
 294 
 295     /**
 296      * Marks this surface as dirty.
 297      */
 298     public final void markDirty() {
 299         stateDelegate.markDirty();
 300     }
 301 
 302     /**
 303      * Sets the value of the surfaceLost variable, which indicates whether
 304      * something has happened to the rendering surface such that it needs
 305      * to be restored and re-rendered.
 306      */
 307     public void setSurfaceLost(boolean lost) {
 308         surfaceLost = lost;
 309         stateDelegate.markDirty();
 310     }
 311 
 312     public boolean isSurfaceLost() {
 313         return surfaceLost;
 314     }
 315 
 316     /**
 317      * Returns a boolean indicating whether or not this SurfaceData is valid.
 318      */
 319     public final boolean isValid() {
 320         return valid;
 321     }
 322 
 323     public Object getDisposerReferent() {
 324         return disposerReferent;
 325     }
 326 
 327     public long getNativeOps() {
 328         return pData;
 329     }
 330 
 331     /**
 332      * Sets this SurfaceData object to the invalid state.  All Graphics
 333      * objects must get a new SurfaceData object via the refresh method
 334      * and revalidate their pipelines before continuing.
 335      */
 336     public void invalidate() {
 337         valid = false;
 338         stateDelegate.markDirty();
 339     }
 340 
 341     /**
 342      * Certain changes in the configuration of a surface require the
 343      * invalidation of existing associated SurfaceData objects and
 344      * the creation of brand new ones.  These changes include size,
 345      * ColorModel, or SurfaceType.  Existing Graphics objects
 346      * which are directed at such surfaces, however, must continue
 347      * to render to them even after the change occurs underneath
 348      * the covers.  The getReplacement() method is called from
 349      * SunGraphics2D.revalidateAll() when the associated SurfaceData
 350      * is found to be invalid so that a Graphics object can continue
 351      * to render to the surface in its new configuration.
 352      *
 353      * Such changes only tend to happen to window based surfaces since
 354      * most image based surfaces never change size or pixel format.
 355      * Even VolatileImage objects never change size and they only
 356      * change their pixel format when manually validated against a
 357      * new GraphicsConfiguration, at which point old Graphics objects
 358      * are no longer expected to render to them after the validation
 359      * step.  Thus, only window based surfaces really need to deal
 360      * with this form of replacement.
 361      */
 362     public abstract SurfaceData getReplacement();
 363 
 364     protected static final LoopPipe colorPrimitives;
 365 
 366     public static final TextPipe outlineTextRenderer;
 367     public static final TextPipe solidTextRenderer;
 368     public static final TextPipe aaTextRenderer;
 369     public static final TextPipe lcdTextRenderer;
 370 
 371     protected static final AlphaColorPipe colorPipe;
 372     protected static final PixelToShapeConverter colorViaShape;
 373     protected static final PixelToParallelogramConverter colorViaPgram;
 374     protected static final TextPipe colorText;
 375     protected static final CompositePipe clipColorPipe;
 376     protected static final TextPipe clipColorText;
 377     protected static final AAShapePipe AAColorShape;
 378     protected static final PixelToParallelogramConverter AAColorViaShape;
 379     protected static final PixelToParallelogramConverter AAColorViaPgram;
 380     protected static final AAShapePipe AAClipColorShape;
 381     protected static final PixelToParallelogramConverter AAClipColorViaShape;
 382 
 383     protected static final CompositePipe paintPipe;
 384     protected static final SpanShapeRenderer paintShape;
 385     protected static final PixelToShapeConverter paintViaShape;
 386     protected static final TextPipe paintText;
 387     protected static final CompositePipe clipPaintPipe;
 388     protected static final TextPipe clipPaintText;
 389     protected static final AAShapePipe AAPaintShape;
 390     protected static final PixelToParallelogramConverter AAPaintViaShape;
 391     protected static final AAShapePipe AAClipPaintShape;
 392     protected static final PixelToParallelogramConverter AAClipPaintViaShape;
 393 
 394     protected static final CompositePipe compPipe;
 395     protected static final SpanShapeRenderer compShape;
 396     protected static final PixelToShapeConverter compViaShape;
 397     protected static final TextPipe compText;
 398     protected static final CompositePipe clipCompPipe;
 399     protected static final TextPipe clipCompText;
 400     protected static final AAShapePipe AACompShape;
 401     protected static final PixelToParallelogramConverter AACompViaShape;
 402     protected static final AAShapePipe AAClipCompShape;
 403     protected static final PixelToParallelogramConverter AAClipCompViaShape;
 404 
 405     protected static final DrawImagePipe imagepipe;
 406 
 407     // Utility subclass to add the LoopBasedPipe tagging interface
 408     static class PixelToShapeLoopConverter
 409         extends PixelToShapeConverter
 410         implements LoopBasedPipe
 411     {
 412         public PixelToShapeLoopConverter(ShapeDrawPipe pipe) {
 413             super(pipe);
 414         }
 415     }
 416 
 417     // Utility subclass to add the LoopBasedPipe tagging interface
 418     static class PixelToPgramLoopConverter
 419         extends PixelToParallelogramConverter
 420         implements LoopBasedPipe
 421     {
 422         public PixelToPgramLoopConverter(ShapeDrawPipe shapepipe,
 423                                          ParallelogramPipe pgrampipe,
 424                                          double minPenSize,
 425                                          double normPosition,
 426                                          boolean adjustfill)
 427         {
 428             super(shapepipe, pgrampipe, minPenSize, normPosition, adjustfill);
 429         }
 430     }
 431 
 432     private static PixelToParallelogramConverter
 433         makeConverter(AAShapePipe renderer,
 434                       ParallelogramPipe pgrampipe)
 435     {
 436         return new PixelToParallelogramConverter(renderer,
 437                                                  pgrampipe,
 438                                                  1.0/8.0, 0.499,
 439                                                  false);
 440     }
 441 
 442     private static PixelToParallelogramConverter
 443         makeConverter(AAShapePipe renderer)
 444     {
 445         return makeConverter(renderer, renderer);
 446     }
 447 
 448     static {
 449         colorPrimitives = new LoopPipe();
 450 
 451         outlineTextRenderer = new OutlineTextRenderer();
 452         aaTextRenderer = new AATextRenderer();
 453         if (FontUtilities.isMacOSX14) {
 454             solidTextRenderer = aaTextRenderer;
 455         } else {
 456             solidTextRenderer = new SolidTextRenderer();
 457         }
 458         lcdTextRenderer = new LCDTextRenderer();
 459 
 460         colorPipe = new AlphaColorPipe();
 461         // colorShape = colorPrimitives;
 462         colorViaShape = new PixelToShapeLoopConverter(colorPrimitives);
 463         colorViaPgram = new PixelToPgramLoopConverter(colorPrimitives,
 464                                                       colorPrimitives,
 465                                                       1.0, 0.25, true);
 466         colorText = new TextRenderer(colorPipe);
 467         clipColorPipe = new SpanClipRenderer(colorPipe);
 468         clipColorText = new TextRenderer(clipColorPipe);
 469         AAColorShape = new AAShapePipe(colorPipe);
 470         AAColorViaShape = makeConverter(AAColorShape);
 471         AAColorViaPgram = makeConverter(AAColorShape, colorPipe);
 472         AAClipColorShape = new AAShapePipe(clipColorPipe);
 473         AAClipColorViaShape = makeConverter(AAClipColorShape);
 474 
 475         paintPipe = new AlphaPaintPipe();
 476         paintShape = new SpanShapeRenderer.Composite(paintPipe);
 477         paintViaShape = new PixelToShapeConverter(paintShape);
 478         paintText = new TextRenderer(paintPipe);
 479         clipPaintPipe = new SpanClipRenderer(paintPipe);
 480         clipPaintText = new TextRenderer(clipPaintPipe);
 481         AAPaintShape = new AAShapePipe(paintPipe);
 482         AAPaintViaShape = makeConverter(AAPaintShape);
 483         AAClipPaintShape = new AAShapePipe(clipPaintPipe);
 484         AAClipPaintViaShape = makeConverter(AAClipPaintShape);
 485 
 486         compPipe = new GeneralCompositePipe();
 487         compShape = new SpanShapeRenderer.Composite(compPipe);
 488         compViaShape = new PixelToShapeConverter(compShape);
 489         compText = new TextRenderer(compPipe);
 490         clipCompPipe = new SpanClipRenderer(compPipe);
 491         clipCompText = new TextRenderer(clipCompPipe);
 492         AACompShape = new AAShapePipe(compPipe);
 493         AACompViaShape = makeConverter(AACompShape);
 494         AAClipCompShape = new AAShapePipe(clipCompPipe);
 495         AAClipCompViaShape = makeConverter(AAClipCompShape);
 496 
 497         imagepipe = new DrawImage();
 498     }
 499 
 500     /* Not all surfaces and rendering mode combinations support LCD text. */
 501     static final int LOOP_UNKNOWN = 0;
 502     static final int LOOP_FOUND = 1;
 503     static final int LOOP_NOTFOUND = 2;
 504     int haveLCDLoop;
 505     int havePgramXORLoop;
 506     int havePgramSolidLoop;
 507 
 508     public boolean canRenderLCDText(SunGraphics2D sg2d) {
 509         // For now the answer can only be true in the following cases:
 510         if (sg2d.compositeState &lt;= SunGraphics2D.COMP_ISCOPY &amp;&amp;
 511             sg2d.paintState &lt;= SunGraphics2D.PAINT_ALPHACOLOR &amp;&amp;
 512             sg2d.clipState &lt;= SunGraphics2D.CLIP_RECTANGULAR &amp;&amp;
 513             sg2d.surfaceData.getTransparency() == Transparency.OPAQUE)
 514         {
 515             if (haveLCDLoop == LOOP_UNKNOWN) {
 516                 DrawGlyphListLCD loop =
 517                     DrawGlyphListLCD.locate(SurfaceType.AnyColor,
 518                                             CompositeType.SrcNoEa,
 519                                             getSurfaceType());
 520                 haveLCDLoop = (loop != null) ? LOOP_FOUND : LOOP_NOTFOUND;
 521             }
 522             return haveLCDLoop == LOOP_FOUND;
 523         }
 524         return false; /* for now - in the future we may want to search */
 525     }
 526 
 527     public boolean canRenderParallelograms(SunGraphics2D sg2d) {
 528         if (sg2d.paintState &lt;= SunGraphics2D.PAINT_ALPHACOLOR) {
 529             if (sg2d.compositeState == SunGraphics2D.COMP_XOR) {
 530                 if (havePgramXORLoop == LOOP_UNKNOWN) {
 531                     FillParallelogram loop =
 532                         FillParallelogram.locate(SurfaceType.AnyColor,
 533                                                  CompositeType.Xor,
 534                                                  getSurfaceType());
 535                     havePgramXORLoop =
 536                         (loop != null) ? LOOP_FOUND : LOOP_NOTFOUND;
 537                 }
 538                 return havePgramXORLoop == LOOP_FOUND;
 539             } else if (sg2d.compositeState &lt;= SunGraphics2D.COMP_ISCOPY &amp;&amp;
 540                        sg2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_ON &amp;&amp;
 541                        sg2d.clipState != SunGraphics2D.CLIP_SHAPE)
 542             {
 543                 if (havePgramSolidLoop == LOOP_UNKNOWN) {
 544                     FillParallelogram loop =
 545                         FillParallelogram.locate(SurfaceType.AnyColor,
 546                                                  CompositeType.SrcNoEa,
 547                                                  getSurfaceType());
 548                     havePgramSolidLoop =
 549                         (loop != null) ? LOOP_FOUND : LOOP_NOTFOUND;
 550                 }
 551                 return havePgramSolidLoop == LOOP_FOUND;
 552             }
 553         }
 554         return false;
 555     }
 556 
 557     public void validatePipe(SunGraphics2D sg2d) {
 558         sg2d.imagepipe = imagepipe;
 559         if (sg2d.compositeState == SunGraphics2D.COMP_XOR) {
 560             if (sg2d.paintState &gt; SunGraphics2D.PAINT_ALPHACOLOR) {
 561                 sg2d.drawpipe = paintViaShape;
 562                 sg2d.fillpipe = paintViaShape;
 563                 sg2d.shapepipe = paintShape;
 564                 // REMIND: Ideally custom paint mode would use glyph
 565                 // rendering as opposed to outline rendering but the
 566                 // glyph paint rendering pipeline uses MaskBlit which
 567                 // is not defined for XOR.  This means that text drawn
 568                 // in XOR mode with a Color object is different than
 569                 // text drawn in XOR mode with a Paint object.
 570                 sg2d.textpipe = outlineTextRenderer;
 571             } else {
 572                 PixelToShapeConverter converter;
 573                 if (canRenderParallelograms(sg2d)) {
 574                     converter = colorViaPgram;
 575                     // Note that we use the transforming pipe here because it
 576                     // will examine the shape and possibly perform an optimized
 577                     // operation if it can be simplified.  The simplifications
 578                     // will be valid for all STROKE and TRANSFORM types.
 579                     sg2d.shapepipe = colorViaPgram;
 580                 } else {
 581                     converter = colorViaShape;
 582                     sg2d.shapepipe = colorPrimitives;
 583                 }
 584                 if (sg2d.clipState == SunGraphics2D.CLIP_SHAPE) {
 585                     sg2d.drawpipe = converter;
 586                     sg2d.fillpipe = converter;
 587                     // REMIND: We should not be changing text strategies
 588                     // between outline and glyph rendering based upon the
 589                     // presence of a complex clip as that could cause a
 590                     // mismatch when drawing the same text both clipped
 591                     // and unclipped on two separate rendering passes.
 592                     // Unfortunately, all of the clipped glyph rendering
 593                     // pipelines rely on the use of the MaskBlit operation
 594                     // which is not defined for XOR.
 595                     sg2d.textpipe = outlineTextRenderer;
 596                 } else {
 597                     if (sg2d.transformState &gt;= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {
 598                         sg2d.drawpipe = converter;
 599                         sg2d.fillpipe = converter;
 600                     } else {
 601                         if (sg2d.strokeState != SunGraphics2D.STROKE_THIN) {
 602                             sg2d.drawpipe = converter;
 603                         } else {
 604                             sg2d.drawpipe = colorPrimitives;
 605                         }
 606                         sg2d.fillpipe = colorPrimitives;
 607                     }
 608                     sg2d.textpipe = solidTextRenderer;
 609                 }
 610                 // assert(sg2d.surfaceData == this);
 611             }
 612         } else if (sg2d.compositeState == SunGraphics2D.COMP_CUSTOM) {
 613             if (sg2d.antialiasHint == SunHints.INTVAL_ANTIALIAS_ON) {
 614                 if (sg2d.clipState == SunGraphics2D.CLIP_SHAPE) {
 615                     sg2d.drawpipe = AAClipCompViaShape;
 616                     sg2d.fillpipe = AAClipCompViaShape;
 617                     sg2d.shapepipe = AAClipCompViaShape;
 618                     sg2d.textpipe = clipCompText;
 619                 } else {
 620                     sg2d.drawpipe = AACompViaShape;
 621                     sg2d.fillpipe = AACompViaShape;
 622                     sg2d.shapepipe = AACompViaShape;
 623                     sg2d.textpipe = compText;
 624                 }
 625             } else {
 626                 sg2d.drawpipe = compViaShape;
 627                 sg2d.fillpipe = compViaShape;
 628                 sg2d.shapepipe = compShape;
 629                 if (sg2d.clipState == SunGraphics2D.CLIP_SHAPE) {
 630                     sg2d.textpipe = clipCompText;
 631                 } else {
 632                     sg2d.textpipe = compText;
 633                 }
 634             }
 635         } else if (sg2d.antialiasHint == SunHints.INTVAL_ANTIALIAS_ON) {
 636             sg2d.alphafill = getMaskFill(sg2d);
 637             // assert(sg2d.surfaceData == this);
 638             if (sg2d.alphafill != null) {
 639                 if (sg2d.clipState == SunGraphics2D.CLIP_SHAPE) {
 640                     sg2d.drawpipe = AAClipColorViaShape;
 641                     sg2d.fillpipe = AAClipColorViaShape;
 642                     sg2d.shapepipe = AAClipColorViaShape;
 643                     sg2d.textpipe = clipColorText;
 644                 } else {
 645                     PixelToParallelogramConverter converter =
 646                         (sg2d.alphafill.canDoParallelograms()
 647                          ? AAColorViaPgram
 648                          : AAColorViaShape);
 649                     sg2d.drawpipe = converter;
 650                     sg2d.fillpipe = converter;
 651                     sg2d.shapepipe = converter;
 652                     if (sg2d.paintState &gt; SunGraphics2D.PAINT_ALPHACOLOR ||
 653                         sg2d.compositeState &gt; SunGraphics2D.COMP_ISCOPY)
 654                     {
 655                         sg2d.textpipe = colorText;
 656                     } else {
 657                         sg2d.textpipe = getTextPipe(sg2d, true /* AA==ON */);
 658                     }
 659                 }
 660             } else {
 661                 if (sg2d.clipState == SunGraphics2D.CLIP_SHAPE) {
 662                     sg2d.drawpipe = AAClipPaintViaShape;
 663                     sg2d.fillpipe = AAClipPaintViaShape;
 664                     sg2d.shapepipe = AAClipPaintViaShape;
 665                     sg2d.textpipe = clipPaintText;
 666                 } else {
 667                     sg2d.drawpipe = AAPaintViaShape;
 668                     sg2d.fillpipe = AAPaintViaShape;
 669                     sg2d.shapepipe = AAPaintViaShape;
 670                     sg2d.textpipe = paintText;
 671                 }
 672             }
 673         } else if (sg2d.paintState &gt; SunGraphics2D.PAINT_ALPHACOLOR ||
 674                    sg2d.compositeState &gt; SunGraphics2D.COMP_ISCOPY ||
 675                    sg2d.clipState == SunGraphics2D.CLIP_SHAPE)
 676         {
 677             sg2d.drawpipe = paintViaShape;
 678             sg2d.fillpipe = paintViaShape;
 679             sg2d.shapepipe = paintShape;
 680             sg2d.alphafill = getMaskFill(sg2d);
 681             // assert(sg2d.surfaceData == this);
 682             if (sg2d.alphafill != null) {
 683                 if (sg2d.clipState == SunGraphics2D.CLIP_SHAPE) {
 684                     sg2d.textpipe = clipColorText;
 685                 } else {
 686                     sg2d.textpipe = colorText;
 687                 }
 688             } else {
 689                 if (sg2d.clipState == SunGraphics2D.CLIP_SHAPE) {
 690                     sg2d.textpipe = clipPaintText;
 691                 } else {
 692                     sg2d.textpipe = paintText;
 693                 }
 694             }
 695         } else {
 696             PixelToShapeConverter converter;
 697             if (canRenderParallelograms(sg2d)) {
 698                 converter = colorViaPgram;
 699                 // Note that we use the transforming pipe here because it
 700                 // will examine the shape and possibly perform an optimized
 701                 // operation if it can be simplified.  The simplifications
 702                 // will be valid for all STROKE and TRANSFORM types.
 703                 sg2d.shapepipe = colorViaPgram;
 704             } else {
 705                 converter = colorViaShape;
 706                 sg2d.shapepipe = colorPrimitives;
 707             }
 708             if (sg2d.transformState &gt;= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {
 709                 sg2d.drawpipe = converter;
 710                 sg2d.fillpipe = converter;
 711             } else {
 712                 if (sg2d.strokeState != SunGraphics2D.STROKE_THIN) {
 713                     sg2d.drawpipe = converter;
 714                 } else {
 715                     sg2d.drawpipe = colorPrimitives;
 716                 }
 717                 sg2d.fillpipe = colorPrimitives;
 718             }
 719 
 720             sg2d.textpipe = getTextPipe(sg2d, false /* AA==OFF */);
 721             // assert(sg2d.surfaceData == this);
 722         }
 723 
 724         // check for loops
 725         if (sg2d.textpipe  instanceof LoopBasedPipe ||
 726             sg2d.shapepipe instanceof LoopBasedPipe ||
 727             sg2d.fillpipe  instanceof LoopBasedPipe ||
 728             sg2d.drawpipe  instanceof LoopBasedPipe ||
 729             sg2d.imagepipe instanceof LoopBasedPipe)
 730         {
 731             sg2d.loops = getRenderLoops(sg2d);
 732         }
 733     }
 734 
 735     /* Return the text pipe to be used based on the graphics AA hint setting,
 736      * and the rest of the graphics state is compatible with these loops.
 737      * If the text AA hint is &quot;DEFAULT&quot;, then the AA graphics hint requests
 738      * the AA text renderer, else it requests the B&amp;W text renderer.
 739      */
 740     private TextPipe getTextPipe(SunGraphics2D sg2d, boolean aaHintIsOn) {
 741 
 742         /* Try to avoid calling getFontInfo() unless its needed to
 743          * resolve one of the new AA types.
 744          */
 745         switch (sg2d.textAntialiasHint) {
 746         case SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT:
 747             if (aaHintIsOn) {
 748                 return aaTextRenderer;
 749             } else {
 750                 return solidTextRenderer;
 751             }
 752         case SunHints.INTVAL_TEXT_ANTIALIAS_OFF:
 753             return solidTextRenderer;
 754 
 755         case SunHints.INTVAL_TEXT_ANTIALIAS_ON:
 756             return aaTextRenderer;
 757 
 758         default:
 759             switch (sg2d.getFontInfo().aaHint) {
 760 
 761             case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB:
 762             case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_VRGB:
 763                 return lcdTextRenderer;
 764 
 765             case SunHints.INTVAL_TEXT_ANTIALIAS_ON:
 766                 return aaTextRenderer;
 767 
 768             case SunHints.INTVAL_TEXT_ANTIALIAS_OFF:
 769                 return solidTextRenderer;
 770 
 771                  /* This should not be reached as the FontInfo will
 772                  * always explicitly set its hint value. So whilst
 773                  * this could be collapsed to returning say just
 774                  * solidTextRenderer, or even removed, its left
 775                  * here in case DEFAULT is ever passed in.
 776                  */
 777             default:
 778                 if (aaHintIsOn) {
 779                     return aaTextRenderer;
 780                 } else {
 781                     return solidTextRenderer;
 782                 }
 783             }
 784         }
 785     }
 786 
 787     private static SurfaceType getPaintSurfaceType(SunGraphics2D sg2d) {
 788         switch (sg2d.paintState) {
 789         case SunGraphics2D.PAINT_OPAQUECOLOR:
 790             return SurfaceType.OpaqueColor;
 791         case SunGraphics2D.PAINT_ALPHACOLOR:
 792             return SurfaceType.AnyColor;
 793         case SunGraphics2D.PAINT_GRADIENT:
 794             if (sg2d.paint.getTransparency() == OPAQUE) {
 795                 return SurfaceType.OpaqueGradientPaint;
 796             } else {
 797                 return SurfaceType.GradientPaint;
 798             }
 799         case SunGraphics2D.PAINT_LIN_GRADIENT:
 800             if (sg2d.paint.getTransparency() == OPAQUE) {
 801                 return SurfaceType.OpaqueLinearGradientPaint;
 802             } else {
 803                 return SurfaceType.LinearGradientPaint;
 804             }
 805         case SunGraphics2D.PAINT_RAD_GRADIENT:
 806             if (sg2d.paint.getTransparency() == OPAQUE) {
 807                 return SurfaceType.OpaqueRadialGradientPaint;
 808             } else {
 809                 return SurfaceType.RadialGradientPaint;
 810             }
 811         case SunGraphics2D.PAINT_TEXTURE:
 812             if (sg2d.paint.getTransparency() == OPAQUE) {
 813                 return SurfaceType.OpaqueTexturePaint;
 814             } else {
 815                 return SurfaceType.TexturePaint;
 816             }
 817         default:
 818         case SunGraphics2D.PAINT_CUSTOM:
 819             return SurfaceType.AnyPaint;
 820         }
 821     }
 822 
 823     private static CompositeType getFillCompositeType(SunGraphics2D sg2d) {
 824         CompositeType compType = sg2d.imageComp;
 825         if (sg2d.compositeState == SunGraphics2D.COMP_ISCOPY) {
 826             if (compType == CompositeType.SrcOverNoEa) {
 827                 compType = CompositeType.OpaqueSrcOverNoEa;
 828             } else {
 829                 compType = CompositeType.SrcNoEa;
 830             }
 831         }
 832         return compType;
 833     }
 834 
 835     /**
 836      * Returns a MaskFill object that can be used on this destination
 837      * with the source (paint) and composite types determined by the given
 838      * SunGraphics2D, or null if no such MaskFill object can be located.
 839      * Subclasses can override this method if they wish to filter other
 840      * attributes (such as the hardware capabilities of the destination
 841      * surface) before returning a specific MaskFill object.
 842      */
 843     protected MaskFill getMaskFill(SunGraphics2D sg2d) {
 844         SurfaceType src = getPaintSurfaceType(sg2d);
 845         CompositeType comp = getFillCompositeType(sg2d);
 846         SurfaceType dst = getSurfaceType();
 847         return MaskFill.getFromCache(src, comp, dst);
 848     }
 849 
 850     private static RenderCache loopcache = new RenderCache(30);
 851 
 852     /**
 853      * Return a RenderLoops object containing all of the basic
 854      * GraphicsPrimitive objects for rendering to the destination
 855      * surface with the current attributes of the given SunGraphics2D.
 856      */
 857     public RenderLoops getRenderLoops(SunGraphics2D sg2d) {
 858         SurfaceType src = getPaintSurfaceType(sg2d);
 859         CompositeType comp = getFillCompositeType(sg2d);
 860         SurfaceType dst = sg2d.getSurfaceData().getSurfaceType();
 861 
 862         Object o = loopcache.get(src, comp, dst);
 863         if (o != null) {
 864             return (RenderLoops) o;
 865         }
 866 
 867         RenderLoops loops = makeRenderLoops(src, comp, dst);
 868         loopcache.put(src, comp, dst, loops);
 869         return loops;
 870     }
 871 
 872     /**
 873      * Construct and return a RenderLoops object containing all of
 874      * the basic GraphicsPrimitive objects for rendering to the
 875      * destination surface with the given source, destination, and
 876      * composite types.
 877      */
 878     public static RenderLoops makeRenderLoops(SurfaceType src,
 879                                               CompositeType comp,
 880                                               SurfaceType dst)
 881     {
 882         RenderLoops loops = new RenderLoops();
 883         loops.drawLineLoop = DrawLine.locate(src, comp, dst);
 884         loops.fillRectLoop = FillRect.locate(src, comp, dst);
 885         loops.drawRectLoop = DrawRect.locate(src, comp, dst);
 886         loops.drawPolygonsLoop = DrawPolygons.locate(src, comp, dst);
 887         loops.drawPathLoop = DrawPath.locate(src, comp, dst);
 888         loops.fillPathLoop = FillPath.locate(src, comp, dst);
 889         loops.fillSpansLoop = FillSpans.locate(src, comp, dst);
 890         loops.fillParallelogramLoop = FillParallelogram.locate(src, comp, dst);
 891         loops.drawParallelogramLoop = DrawParallelogram.locate(src, comp, dst);
 892         loops.drawGlyphListLoop = DrawGlyphList.locate(src, comp, dst);
 893         loops.drawGlyphListAALoop = DrawGlyphListAA.locate(src, comp, dst);
 894         loops.drawGlyphListLCDLoop = DrawGlyphListLCD.locate(src, comp, dst);
 895         /*
 896         System.out.println(&quot;drawLine: &quot;+loops.drawLineLoop);
 897         System.out.println(&quot;fillRect: &quot;+loops.fillRectLoop);
 898         System.out.println(&quot;drawRect: &quot;+loops.drawRectLoop);
 899         System.out.println(&quot;drawPolygons: &quot;+loops.drawPolygonsLoop);
 900         System.out.println(&quot;fillSpans: &quot;+loops.fillSpansLoop);
 901         System.out.println(&quot;drawGlyphList: &quot;+loops.drawGlyphListLoop);
 902         System.out.println(&quot;drawGlyphListAA: &quot;+loops.drawGlyphListAALoop);
 903         System.out.println(&quot;drawGlyphListLCD: &quot;+loops.drawGlyphListLCDLoop);
 904         */
 905         return loops;
 906     }
 907 
 908     /**
 909      * Return the GraphicsConfiguration object that describes this
 910      * destination surface.
 911      */
 912     public abstract GraphicsConfiguration getDeviceConfiguration();
 913 
 914     /**
 915      * Return the SurfaceType object that describes the destination
 916      * surface.
 917      */
 918     public final SurfaceType getSurfaceType() {
 919         return surfaceType;
 920     }
 921 
 922     /**
 923      * Return the ColorModel for the destination surface.
 924      */
 925     public final ColorModel getColorModel() {
 926         return colorModel;
 927     }
 928 
 929     /**
 930      * Returns the type of this {@code Transparency}.
 931      * @return the field type of this {@code Transparency}, which is
 932      *          either OPAQUE, BITMASK or TRANSLUCENT.
 933      */
 934     public int getTransparency() {
 935         return getColorModel().getTransparency();
 936     }
 937 
 938     /**
 939      * Return a readable Raster which contains the pixels for the
 940      * specified rectangular region of the destination surface.
 941      * The coordinate origin of the returned Raster is the same as
 942      * the device space origin of the destination surface.
 943      * In some cases the returned Raster might also be writeable.
 944      * In most cases, the returned Raster might contain more pixels
 945      * than requested.
 946      *
 947      * @see #useTightBBoxes
 948      */
 949     public abstract Raster getRaster(int x, int y, int w, int h);
 950 
 951     /**
 952      * Does the pixel accessibility of the destination surface
 953      * suggest that rendering algorithms might want to take
 954      * extra time to calculate a more accurate bounding box for
 955      * the operation being performed?
 956      * The typical case when this will be true is when a copy of
 957      * the pixels has to be made when doing a getRaster.  The
 958      * fewer pixels copied, the faster the operation will go.
 959      *
 960      * @see #getRaster
 961      */
 962     public boolean useTightBBoxes() {
 963         // Note: The native equivalent would trigger on VISIBLE_TO_NATIVE
 964         // REMIND: This is not used - should be obsoleted maybe
 965         return true;
 966     }
 967 
 968     /**
 969      * Returns the pixel data for the specified Argb value packed
 970      * into an integer for easy storage and conveyance.
 971      */
 972     public int pixelFor(int rgb) {
 973         return surfaceType.pixelFor(rgb, colorModel);
 974     }
 975 
 976     /**
 977      * Returns the pixel data for the specified color packed into an
 978      * integer for easy storage and conveyance.
 979      *
 980      * This method will use the getRGB() method of the Color object
 981      * and defer to the pixelFor(int rgb) method if not overridden.
 982      *
 983      * For now this is a convenience function, but for cases where
 984      * the highest quality color conversion is requested, this method
 985      * should be overridden in those cases so that a more direct
 986      * conversion of the color to the destination color space
 987      * can be done using the additional information in the Color
 988      * object.
 989      */
 990     public int pixelFor(Color c) {
 991         return pixelFor(c.getRGB());
 992     }
 993 
 994     /**
 995      * Returns the Argb representation for the specified integer value
 996      * which is packed in the format of the associated ColorModel.
 997      */
 998     public int rgbFor(int pixel) {
 999         return surfaceType.rgbFor(pixel, colorModel);
1000     }
1001 
1002     /**
1003      * Returns the bounds of the destination surface.
1004      */
1005     public abstract Rectangle getBounds();
1006 
1007     static java.security.Permission compPermission;
1008 
1009     /**
1010      * Performs Security Permissions checks to see if a Custom
1011      * Composite object should be allowed access to the pixels
1012      * of this surface.
1013      */
1014     protected void checkCustomComposite() {
1015         SecurityManager sm = System.getSecurityManager();
1016         if (sm != null) {
1017             if (compPermission == null) {
1018                 compPermission =
1019                     new java.awt.AWTPermission(&quot;readDisplayPixels&quot;);
1020             }
1021             sm.checkPermission(compPermission);
1022         }
1023     }
1024 
1025     /**
1026      * Fetches private field IndexColorModel.allgrayopaque
1027      * which is true when all palette entries in the color
1028      * model are gray and opaque.
1029      */
1030     protected static native boolean isOpaqueGray(IndexColorModel icm);
1031 
1032     /**
1033      * For our purposes null and NullSurfaceData are the same as
1034      * they represent a disposed surface.
1035      */
1036     public static boolean isNull(SurfaceData sd) {
1037         if (sd == null || sd == NullSurfaceData.theInstance) {
1038             return true;
1039         }
1040         return false;
1041     }
1042 
1043     /**
1044      * Performs a copyarea within this surface.  Returns
1045      * false if there is no algorithm to perform the copyarea
1046      * given the current settings of the SunGraphics2D.
1047      *
1048      * @param x the x coordinate of the area in device space
1049      * @param y the y coordinate of the area in device space
1050      * @param w the width of the area in device space
1051      * @param h the height of the area in device space
1052      */
1053     public boolean copyArea(SunGraphics2D sg2d,
1054                             int x, int y, int w, int h, int dx, int dy)
1055     {
1056         return false;
1057     }
1058 
1059     /**
1060      * Synchronously releases resources associated with this surface.
1061      */
1062     public void flush() {}
1063 
1064     /**
1065      * Returns destination associated with this SurfaceData.  This could be
1066      * either an Image or a Component; subclasses of SurfaceData are
1067      * responsible for returning the appropriate object.
1068      */
1069     public abstract Object getDestination();
1070 
1071     /**
1072      * Returns default horizontal scale factor of the destination surface. Scale
1073      * factor describes the mapping between virtual and physical coordinates of the
1074      * SurfaceData. If the scale is 2 then virtual pixel coordinates need to be
1075      * doubled for physical pixels.
1076      */
1077     public double getDefaultScaleX() {
1078         return 1;
1079     }
1080 
1081     /**
1082      * Returns default vertical scale factor of the destination surface. Scale
1083      * factor describes the mapping between virtual and physical coordinates of the
1084      * SurfaceData. If the scale is 2 then virtual pixel coordinates need to be
1085      * doubled for physical pixels.
1086      */
1087     public double getDefaultScaleY() {
1088         return 1;
1089     }
1090 }
    </pre>
  </body>
</html>
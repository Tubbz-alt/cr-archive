<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/common/awt/debug/debug_mem.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="debug_assert.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="debug_trace.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/common/awt/debug/debug_mem.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #if defined(DEBUG)
 27 
 28 #include &quot;debug_util.h&quot;
 29 
<span class="line-removed"> 30 /* Use THIS_FILE when it is available. */</span>
<span class="line-removed"> 31 #ifndef THIS_FILE</span>
<span class="line-removed"> 32     #define THIS_FILE __FILE__</span>
<span class="line-removed"> 33 #endif</span>
<span class="line-removed"> 34 </span>
 35 #define DMEM_MIN(a,b)   (a) &lt; (b) ? (a) : (b)
 36 #define DMEM_MAX(a,b)   (a) &gt; (b) ? (a) : (b)
 37 
 38 typedef char byte_t;
 39 
 40 static const byte_t ByteInited = &#39;\xCD&#39;;
 41 static const byte_t ByteFreed = &#39;\xDD&#39;;
 42 static const byte_t ByteGuard = &#39;\xFD&#39;;
 43 
 44 enum {
 45     MAX_LINENUM = 50000,        /* I certainly hope we don&#39;t have source files bigger than this */
 46     MAX_CHECK_BYTES = 27,       /* max bytes to check at start of block */
 47     MAX_GUARD_BYTES = 8,        /* size of guard areas on either side of a block */
 48     MAX_DECIMAL_DIGITS = 15
 49 };
 50 
 51 /* Debug Info Header to precede allocated block */
 52 typedef struct MemoryBlockHeader {
 53     char                        filename[FILENAME_MAX+1]; /* filename where alloc occurred */
 54     int                         linenumber;             /* line where alloc occurred */
</pre>
<hr />
<pre>
279     static const char * reportFormat =
280         &quot;file:  %s, line %d\n&quot;
281         &quot;size:  %d bytes\n&quot;
282         &quot;order: %d\n&quot;
283         &quot;-------&quot;;
284 
285     DMem_VerifyHeader(header);
286     sprintf(report, reportFormat, header-&gt;filename, header-&gt;linenumber, header-&gt;size, header-&gt;order);
287     DTRACE_PRINTLN(report);
288 }
289 
290 /*
291  * Call this function at shutdown time to report any leaked blocks
292  */
293 void DMem_ReportLeaks() {
294     MemoryListLink *    link;
295 
296     DMutex_Enter(DMemMutex);
297 
298     /* Force memory leaks to be output regardless of trace settings */
<span class="line-modified">299     DTrace_EnableFile(THIS_FILE, TRUE);</span>
300     DTRACE_PRINTLN(&quot;--------------------------&quot;);
301     DTRACE_PRINTLN(&quot;Debug Memory Manager Leaks&quot;);
302     DTRACE_PRINTLN(&quot;--------------------------&quot;);
303 
304     /* walk through allocated list and dump any blocks not marked as freed */
305     link = MemoryList.next;
306     while (link != NULL) {
307         if ( !link-&gt;freed ) {
308             DMem_DumpHeader(link-&gt;header);
309         }
310         link = link-&gt;next;
311     }
312 
313     DMutex_Exit(DMemMutex);
314 }
315 
316 void DMem_SetAllocCallback( DMEM_ALLOCFN pfn ) {
317     DMutex_Enter(DMemMutex);
318     DMemGlobalState.pfnAlloc = pfn;
319     DMutex_Exit(DMemMutex);
</pre>
</td>
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #if defined(DEBUG)
 27 
 28 #include &quot;debug_util.h&quot;
 29 





 30 #define DMEM_MIN(a,b)   (a) &lt; (b) ? (a) : (b)
 31 #define DMEM_MAX(a,b)   (a) &gt; (b) ? (a) : (b)
 32 
 33 typedef char byte_t;
 34 
 35 static const byte_t ByteInited = &#39;\xCD&#39;;
 36 static const byte_t ByteFreed = &#39;\xDD&#39;;
 37 static const byte_t ByteGuard = &#39;\xFD&#39;;
 38 
 39 enum {
 40     MAX_LINENUM = 50000,        /* I certainly hope we don&#39;t have source files bigger than this */
 41     MAX_CHECK_BYTES = 27,       /* max bytes to check at start of block */
 42     MAX_GUARD_BYTES = 8,        /* size of guard areas on either side of a block */
 43     MAX_DECIMAL_DIGITS = 15
 44 };
 45 
 46 /* Debug Info Header to precede allocated block */
 47 typedef struct MemoryBlockHeader {
 48     char                        filename[FILENAME_MAX+1]; /* filename where alloc occurred */
 49     int                         linenumber;             /* line where alloc occurred */
</pre>
<hr />
<pre>
274     static const char * reportFormat =
275         &quot;file:  %s, line %d\n&quot;
276         &quot;size:  %d bytes\n&quot;
277         &quot;order: %d\n&quot;
278         &quot;-------&quot;;
279 
280     DMem_VerifyHeader(header);
281     sprintf(report, reportFormat, header-&gt;filename, header-&gt;linenumber, header-&gt;size, header-&gt;order);
282     DTRACE_PRINTLN(report);
283 }
284 
285 /*
286  * Call this function at shutdown time to report any leaked blocks
287  */
288 void DMem_ReportLeaks() {
289     MemoryListLink *    link;
290 
291     DMutex_Enter(DMemMutex);
292 
293     /* Force memory leaks to be output regardless of trace settings */
<span class="line-modified">294     DTrace_EnableFile(__FILE__, TRUE);</span>
295     DTRACE_PRINTLN(&quot;--------------------------&quot;);
296     DTRACE_PRINTLN(&quot;Debug Memory Manager Leaks&quot;);
297     DTRACE_PRINTLN(&quot;--------------------------&quot;);
298 
299     /* walk through allocated list and dump any blocks not marked as freed */
300     link = MemoryList.next;
301     while (link != NULL) {
302         if ( !link-&gt;freed ) {
303             DMem_DumpHeader(link-&gt;header);
304         }
305         link = link-&gt;next;
306     }
307 
308     DMutex_Exit(DMemMutex);
309 }
310 
311 void DMem_SetAllocCallback( DMEM_ALLOCFN pfn ) {
312     DMutex_Enter(DMemMutex);
313     DMemGlobalState.pfnAlloc = pfn;
314     DMutex_Exit(DMemMutex);
</pre>
</td>
</tr>
</table>
<center><a href="debug_assert.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="debug_trace.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/windows/native/libjsound/PLATFORM_API_WinOS_MidiOut.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #define USE_ERROR
 27 #define USE_TRACE
 28 
 29 #include &quot;PLATFORM_API_WinOS_Util.h&quot;
 30 
 31 /* include to prevent charset problem */
 32 #include &quot;PLATFORM_API_WinOS_Charset_Util.h&quot;
 33 
 34 #if USE_PLATFORM_MIDI_OUT == TRUE
 35 
 36 
 37 #ifdef USE_ERROR
 38 #include &lt;stdio.h&gt;
 39 
<a name="1" id="anc1"></a><span class="line-removed"> 40 /* Use THIS_FILE when it is available. */</span>
<span class="line-removed"> 41 #ifndef THIS_FILE</span>
<span class="line-removed"> 42     #define THIS_FILE __FILE__</span>
<span class="line-removed"> 43 #endif</span>
<span class="line-removed"> 44 </span>
 45 #define MIDIOUT_CHECK_ERROR  { \
 46         if (err != MMSYSERR_NOERROR) \
<a name="2" id="anc2"></a><span class="line-modified"> 47             ERROR3(&quot;MIDI OUT Error in %s:%d : %s\n&quot;, THIS_FILE, __LINE__, MIDI_OUT_GetErrorStr((INT32) err)); \</span>
 48         }
 49 #else
 50 #define MIDIOUT_CHECK_ERROR
 51 #endif
 52 
 53 /* *************************** MidiOutDeviceProvider implementation *********************************** */
 54 
 55 /* not thread safe */
 56 static char winMidiOutErrMsg[WIN_MAX_ERROR_LEN];
 57 
 58 char* MIDI_OUT_GetErrorStr(INT32 err) {
 59     winMidiOutErrMsg[0] = 0;
 60     midiOutGetErrorText((MMRESULT) err, winMidiOutErrMsg, WIN_MAX_ERROR_LEN);
 61     return winMidiOutErrMsg;
 62 }
 63 
 64 INT32 MIDI_OUT_GetNumDevices() {
 65     // add one for the MIDI_MAPPER
 66     // we want to return it first so it&#39;ll be the default, so we
 67     // decrement each deviceID for these methods....
 68     return (INT32) (midiOutGetNumDevs() + 1);
 69 }
 70 
 71 
 72 INT32 getMidiOutCaps(INT32 deviceID, MIDIOUTCAPSW* caps, INT32* err) {
 73     UINT_PTR id;
 74     if (deviceID == 0) {
 75         id = MIDI_MAPPER;
 76     } else {
 77         id = (UINT_PTR)(deviceID-1);
 78     }
 79     (*err) = (INT32) midiOutGetDevCapsW(id, caps, sizeof(MIDIOUTCAPSW));
 80     return ((*err) == MMSYSERR_NOERROR);
 81 }
 82 
 83 
 84 INT32 MIDI_OUT_GetDeviceName(INT32 deviceID, char *name, UINT32 nameLength) {
 85     MIDIOUTCAPSW midiOutCaps;
 86     INT32 err;
 87 
 88     memset(&amp;midiOutCaps, 0, sizeof(midiOutCaps));
 89     if (getMidiOutCaps(deviceID, &amp;midiOutCaps, &amp;err)) {
 90         UnicodeToUTF8AndCopy(name, midiOutCaps.szPname, nameLength);
 91         return MIDI_SUCCESS;
 92     }
 93     MIDIOUT_CHECK_ERROR;
 94     return err;
 95 }
 96 
 97 
 98 INT32 MIDI_OUT_GetDeviceVendor(INT32 deviceID, char *name, UINT32 nameLength) {
 99     return MIDI_NOT_SUPPORTED;
100 }
101 
102 
103 INT32 MIDI_OUT_GetDeviceDescription(INT32 deviceID, char *name, UINT32 nameLength) {
104     MIDIOUTCAPSW midiOutCaps;
105     char *desc;
106     INT32 err;
107 
108     memset(&amp;midiOutCaps, 0, sizeof(midiOutCaps));
109     if (getMidiOutCaps(deviceID, &amp;midiOutCaps, &amp;err)) {
110         int tech = (int)midiOutCaps.wTechnology;
111         switch(tech) {
112         case MOD_MIDIPORT:
113             desc = &quot;External MIDI Port&quot;;
114             break;
115         case MOD_SQSYNTH:
116             desc = &quot;Internal square wave synthesizer&quot;;
117             break;
118         case MOD_FMSYNTH:
119             desc = &quot;Internal FM synthesizer&quot;;
120             break;
121         case MOD_SYNTH:
122             desc = &quot;Internal synthesizer (generic)&quot;;
123             break;
124         case MOD_MAPPER:
125             desc = &quot;Windows MIDI_MAPPER&quot;;
126             break;
127         case 7 /* MOD_SWSYNTH*/:
128             desc = &quot;Internal software synthesizer&quot;;
129             break;
130         default:
131             return MIDI_NOT_SUPPORTED;
132         }
133         strncpy(name, desc, nameLength-1);
134         name[nameLength-1] = 0;
135         return MIDI_SUCCESS;
136     }
137     return err;
138 }
139 
140 
141 INT32 MIDI_OUT_GetDeviceVersion(INT32 deviceID, char *name, UINT32 nameLength) {
142     MIDIOUTCAPSW midiOutCaps;
143     INT32 err;
144 
145     memset(&amp;midiOutCaps, 0, sizeof(midiOutCaps));
146     if (getMidiOutCaps(deviceID, &amp;midiOutCaps, &amp;err) &amp;&amp; nameLength&gt;7) {
147         sprintf(name, &quot;%d.%d&quot;, (midiOutCaps.vDriverVersion &amp; 0xFF00) &gt;&gt; 8, midiOutCaps.vDriverVersion &amp; 0xFF);
148         return MIDI_SUCCESS;
149     }
150     MIDIOUT_CHECK_ERROR;
151     return err;
152 }
153 
154 
155 /* *************************** MidiOutDevice implementation ***************************************** */
156 
157 
158 INT32 unprepareLongBuffers(MidiDeviceHandle* handle) {
159     SysExQueue* sysex;
160     MMRESULT err = MMSYSERR_NOERROR;
161     int i;
162 
163     if (!handle || !handle-&gt;deviceHandle || !handle-&gt;longBuffers) {
164         ERROR0(&quot;MIDI_OUT_unprepareLongBuffers: handle, deviceHandle, or longBuffers == NULL\n&quot;);
165         return MIDI_INVALID_HANDLE;
166     }
167     sysex = (SysExQueue*) handle-&gt;longBuffers;
168     for (i = 0; i&lt;sysex-&gt;count; i++) {
169         MIDIHDR* hdr = &amp;(sysex-&gt;header[i]);
170         if (hdr-&gt;dwFlags) {
171             err = midiOutUnprepareHeader((HMIDIOUT) handle-&gt;deviceHandle, hdr, sizeof(MIDIHDR));
172         }
173     }
174     MIDIOUT_CHECK_ERROR;
175     return (INT32) err;
176 }
177 
178 INT32 freeLongBuffer(MIDIHDR* hdr, HMIDIOUT deviceHandle, INT32 minToLeaveData) {
179     MMRESULT err = MMSYSERR_NOERROR;
180 
181     if (!hdr) {
182         ERROR0(&quot;MIDI_OUT_freeLongBuffer: hdr == NULL\n&quot;);
183         return MIDI_INVALID_HANDLE;
184     }
185     if (hdr-&gt;dwFlags &amp;&amp; deviceHandle) {
186         err = midiOutUnprepareHeader(deviceHandle, hdr, sizeof(MIDIHDR));
187     }
188     if (hdr-&gt;lpData &amp;&amp; (((INT32) hdr-&gt;dwBufferLength) &lt; minToLeaveData || minToLeaveData &lt; 0)) {
189         free(hdr-&gt;lpData);
190         hdr-&gt;lpData=NULL;
191         hdr-&gt;dwBufferLength=0;
192     }
193     hdr-&gt;dwBytesRecorded=0;
194     hdr-&gt;dwFlags=0;
195     return (INT32) err;
196 }
197 
198 INT32 freeLongBuffers(MidiDeviceHandle* handle) {
199     SysExQueue* sysex;
200     MMRESULT err = MMSYSERR_NOERROR;
201     int i;
202 
203     if (!handle || !handle-&gt;longBuffers) {
204         ERROR0(&quot;MIDI_OUT_freeLongBuffers: handle or longBuffers == NULL\n&quot;);
205         return MIDI_INVALID_HANDLE;
206     }
207     sysex = (SysExQueue*) handle-&gt;longBuffers;
208     for (i = 0; i&lt;sysex-&gt;count; i++) {
209         err = freeLongBuffer(&amp;(sysex-&gt;header[i]), (HMIDIOUT) handle-&gt;deviceHandle, -1);
210     }
211     MIDIOUT_CHECK_ERROR;
212     return (INT32) err;
213 }
214 
215 INT32 MIDI_OUT_OpenDevice(INT32 deviceID, MidiDeviceHandle** handle) {
216     MMRESULT err;
217 
218     TRACE1(&quot;&gt;&gt; MIDI_OUT_OpenDevice: deviceID: %d\n&quot;, deviceID);
219 
220     if (deviceID == 0) {
221         deviceID = MIDI_MAPPER;
222     } else {
223         deviceID--;
224     }
225 #ifdef USE_ERROR
226     setvbuf(stdout, NULL, (int)_IONBF, 0);
227     setvbuf(stderr, NULL, (int)_IONBF, 0);
228 #endif
229 
230     (*handle) = (MidiDeviceHandle*) malloc(sizeof(MidiDeviceHandle));
231     if (!(*handle)) {
232         ERROR0(&quot;ERROR: MIDI_OUT_OpenDevice: out of memory\n&quot;);
233         return MIDI_OUT_OF_MEMORY;
234     }
235     memset(*handle, 0, sizeof(MidiDeviceHandle));
236 
237     // create long buffer queue
238     if (!MIDI_WinCreateEmptyLongBufferQueue(*handle, MIDI_OUT_LONG_QUEUE_SIZE)) {
239         ERROR0(&quot;ERROR: MIDI_OUT_OpenDevice: could not create long Buffers\n&quot;);
240         free(*handle);
241         (*handle) = NULL;
242         return MIDI_OUT_OF_MEMORY;
243     }
244 
245     // create notification event
246     (*handle)-&gt;platformData = (void*) CreateEvent(NULL, FALSE /*manual reset*/, FALSE /*signaled*/, NULL);
247     if (!(*handle)-&gt;platformData) {
248         ERROR0(&quot;ERROR: MIDI_OUT_StartDevice: could not create event\n&quot;);
249         MIDI_WinDestroyLongBufferQueue(*handle);
250         free(*handle);
251         (*handle) = NULL;
252         return MIDI_OUT_OF_MEMORY;
253     }
254 
255     // finally open the device
256     err = midiOutOpen((HMIDIOUT*) &amp;((*handle)-&gt;deviceHandle), deviceID,
257                       (UINT_PTR) (*handle)-&gt;platformData, (UINT_PTR) (*handle), CALLBACK_EVENT);
258 
259     if ((err != MMSYSERR_NOERROR) || (!(*handle)-&gt;deviceHandle)) {
260         /* some devices return non zero, but no error! */
261         if (midiOutShortMsg((HMIDIOUT) ((*handle)-&gt;deviceHandle),0) == MMSYSERR_INVALHANDLE) {
262             MIDIOUT_CHECK_ERROR;
263             CloseHandle((HANDLE) (*handle)-&gt;platformData);
264             MIDI_WinDestroyLongBufferQueue(*handle);
265             free(*handle);
266             (*handle) = NULL;
267             return (INT32) err;
268         }
269     }
270     //$$fb enable high resolution time
271     timeBeginPeriod(1);
272     MIDI_SetStartTime(*handle);
273     TRACE0(&quot;&lt;&lt; MIDI_OUT_OpenDevice: succeeded\n&quot;);
274     return MIDI_SUCCESS;
275 }
276 
277 INT32 MIDI_OUT_CloseDevice(MidiDeviceHandle* handle) {
278     MMRESULT err = MMSYSERR_NOERROR;
279     HANDLE event;
280 
281     TRACE0(&quot;&gt; MIDI_OUT_CloseDevice\n&quot;);
282     if (!handle) {
283         ERROR0(&quot;ERROR: MIDI_OUT_StopDevice: handle is NULL\n&quot;);
284         return MIDI_INVALID_HANDLE; // failure
285     }
286     // encourage MIDI_OUT_SendLongMessage to return soon
287     event = handle-&gt;platformData;
288     handle-&gt;platformData = NULL;
289     if (event) {
290         SetEvent(event);
291     } else {
292         ERROR0(&quot;ERROR: MIDI_OUT_StopDevice: event is NULL\n&quot;);
293     }
294 
295     if (handle-&gt;deviceHandle) {
296         //$$fb disable high resolution time
297         timeEndPeriod(1);
298         err = midiOutReset((HMIDIOUT) handle-&gt;deviceHandle);
299     } else {
300         ERROR0(&quot;ERROR: MIDI_OUT_CloseDevice: deviceHandle is NULL\n&quot;);
301     }
302 
303     // issue a &quot;SUSTAIN OFF&quot; message to each MIDI channel, 0 to 15.
304     // &quot;CONTROL CHANGE&quot; is 176, &quot;SUSTAIN CONTROLLER&quot; is 64, and the value is 0.
305     // $$fb 2002-04-04: It is responsability of the application developer to
306     // leave the device in a consistent state. So I put this in comments
307     /*
308       for (channel = 0; channel &lt; 16; channel++)
309       MIDI_OUT_SendShortMessage(deviceHandle, (unsigned char)(176 + channel), (unsigned char)64, (unsigned char)0, (UINT32)-1);
310     */
311 
312     if (event) {
313         // wait until MIDI_OUT_SendLongMessage has finished
314         while (handle-&gt;isWaiting) Sleep(0);
315     }
316 
317     unprepareLongBuffers(handle);
318 
319     if (handle-&gt;deviceHandle) {
320         err = midiOutClose((HMIDIOUT) handle-&gt;deviceHandle);
321         MIDIOUT_CHECK_ERROR;
322         handle-&gt;deviceHandle = NULL;
323     }
324     freeLongBuffers(handle);
325 
326     if (event) {
327         CloseHandle(event);
328     }
329     MIDI_WinDestroyLongBufferQueue(handle);
330     free(handle);
331 
332     TRACE0(&quot;&lt; MIDI_OUT_CloseDevice\n&quot;);
333     return (INT32) err;
334 }
335 
336 
337 /* return time stamp in microseconds */
338 INT64 MIDI_OUT_GetTimeStamp(MidiDeviceHandle* handle) {
339     return MIDI_GetTimeStamp(handle);
340 }
341 
342 
343 INT32 MIDI_OUT_SendShortMessage(MidiDeviceHandle* handle, UINT32 packedMsg, UINT32 timestamp) {
344     MMRESULT err = MMSYSERR_NOERROR;
345 
346     TRACE2(&quot;&gt; MIDI_OUT_SendShortMessage %x, time: %d\n&quot;, packedMsg, timestamp);
347     if (!handle) {
348         ERROR0(&quot;ERROR: MIDI_OUT_SendShortMessage: handle is NULL\n&quot;);
349         return MIDI_INVALID_HANDLE; // failure
350     }
351     err = midiOutShortMsg((HMIDIOUT) handle-&gt;deviceHandle, packedMsg);
352     MIDIOUT_CHECK_ERROR;
353     TRACE0(&quot;&lt; MIDI_OUT_SendShortMessage\n&quot;);
354     return (INT32) err;
355 }
356 
357 INT32 MIDI_OUT_SendLongMessage(MidiDeviceHandle* handle, UBYTE* data, UINT32 size, UINT32 timestamp) {
358     MMRESULT err;
359     SysExQueue* sysex;
360     MIDIHDR* hdr = NULL;
361     INT32 remainingSize;
362     int i;
363 
364     TRACE2(&quot;&gt; MIDI_OUT_SendLongMessage size %d, time: %d\n&quot;, size, timestamp);
365     if (!handle || !data || !handle-&gt;longBuffers) {
366         ERROR0(&quot;&lt; ERROR: MIDI_OUT_SendLongMessage: handle, data, or longBuffers is NULL\n&quot;);
367         return MIDI_INVALID_HANDLE; // failure
368     }
369     if (size == 0) {
370         return MIDI_SUCCESS;
371     }
372 
373     sysex = (SysExQueue*) handle-&gt;longBuffers;
374     remainingSize = size;
375 
376     // send in chunks of 512 bytes
377     size = 512;
378     while (remainingSize &gt; 0) {
379         if (remainingSize &lt; (INT32) size) {
380             size = (UINT32) remainingSize;
381         }
382 
383         while (!hdr &amp;&amp; handle-&gt;platformData) {
384             /* find a non-queued header */
385             for (i = 0; i &lt; sysex-&gt;count; i++) {
386                 hdr = &amp;(sysex-&gt;header[i]);
387                 if ((hdr-&gt;dwFlags &amp; MHDR_DONE) || (hdr-&gt;dwFlags == 0)) {
388                     break;
389                 }
390                 hdr = NULL;
391             }
392             /* wait for a buffer to free up */
393             if (!hdr &amp;&amp; handle-&gt;platformData) {
394                 DWORD res;
395                 TRACE0(&quot; Need to wait for free buffer\n&quot;);
396                 handle-&gt;isWaiting = TRUE;
397                 res = WaitForSingleObject((HANDLE) handle-&gt;platformData, 700);
398                 handle-&gt;isWaiting = FALSE;
399                 if (res == WAIT_TIMEOUT) {
400                     // break out back to Java if no buffer freed up after 700 milliseconds
401                     TRACE0(&quot;-&gt; TIMEOUT. Need to go back to Java\n&quot;);
402                     break;
403                 }
404             }
405         }
406         if (!hdr) {
407             // no free buffer
408             return MIDI_NOT_SUPPORTED;
409         }
410 
411         TRACE2(&quot;-&gt; sending %d bytes with buffer index=%d\n&quot;, (int) size, (int) hdr-&gt;dwUser);
412         freeLongBuffer(hdr, handle-&gt;deviceHandle, (INT32) size);
413         if (hdr-&gt;lpData == NULL) {
414             hdr-&gt;lpData = malloc(size);
415             hdr-&gt;dwBufferLength = size;
416         }
417         hdr-&gt;dwBytesRecorded = size;
418         memcpy(hdr-&gt;lpData, data, size);
419         err = midiOutPrepareHeader((HMIDIOUT) handle-&gt;deviceHandle, hdr, sizeof(MIDIHDR));
420         if (err != MMSYSERR_NOERROR) {
421             freeLongBuffer(hdr, handle-&gt;deviceHandle, -1);
422             MIDIOUT_CHECK_ERROR;
423             return (INT32) err;
424         }
425         err = midiOutLongMsg((HMIDIOUT) handle-&gt;deviceHandle, hdr, sizeof(MIDIHDR));
426         if (err != MMSYSERR_NOERROR) {
427             freeLongBuffer(hdr, handle-&gt;deviceHandle, -1);
428             ERROR0(&quot;ERROR: MIDI_OUT_SendLongMessage: midiOutLongMsg returned error:\n&quot;);
429             MIDIOUT_CHECK_ERROR;
430             return (INT32) err;
431         }
432         remainingSize -= size;
433         data += size;
434     }
435     TRACE0(&quot;&lt; MIDI_OUT_SendLongMessage success\n&quot;);
436     return MIDI_SUCCESS;
437 }
438 
439 #endif // USE_PLATFORM_MIDI_OUT
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
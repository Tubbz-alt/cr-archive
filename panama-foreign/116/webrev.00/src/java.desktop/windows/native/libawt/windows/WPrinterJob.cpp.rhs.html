<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/windows/native/libawt/windows/WPrinterJob.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &quot;awt.h&quot;
  27 
  28 #include &quot;stdhdrs.h&quot;
  29 #include &lt;commdlg.h&gt;
  30 #include &lt;winspool.h&gt;
  31 #include &lt;limits.h&gt;
  32 #include &lt;float.h&gt;
  33 
  34 #include &quot;awt_Toolkit.h&quot;
  35 #include &quot;awt_PrintControl.h&quot;
  36 
  37 /* values for parameter &quot;type&quot; of XXX_getJobStatus() */
  38 #define GETJOBCOUNT  1
  39 #define ACCEPTJOB    2
  40 
  41 static const char *HPRINTER_STR = &quot;hPrintJob&quot;;
  42 
  43 /* constants for DeviceCapability buffer lengths */
  44 #define PAPERNAME_LENGTH 64
  45 #define TRAYNAME_LENGTH 24
  46 
  47 
  48 static BOOL IsSupportedLevel(HANDLE hPrinter, DWORD dwLevel) {
  49     BOOL isSupported = FALSE;
  50     DWORD cbBuf = 0;
  51     LPBYTE pPrinter = NULL;
  52 
  53     DASSERT(hPrinter != NULL);
  54 
  55     VERIFY(::GetPrinter(hPrinter, dwLevel, NULL, 0, &amp;cbBuf) == 0);
  56     if (::GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
  57         pPrinter = new BYTE[cbBuf];
  58         if (::GetPrinter(hPrinter, dwLevel, pPrinter, cbBuf, &amp;cbBuf)) {
  59             isSupported = TRUE;
  60         }
  61         delete[] pPrinter;
  62     }
  63 
  64     return isSupported;
  65 }
  66 
  67 
  68 extern &quot;C&quot; {
  69 
  70 JNIEXPORT jstring JNICALL
  71 Java_sun_print_PrintServiceLookupProvider_getDefaultPrinterName(JNIEnv *env,
  72                                                              jobject peer)
  73 {
  74     TRY;
  75 
  76     TCHAR cBuffer[250];
  77     OSVERSIONINFO osv;
  78     PRINTER_INFO_2 *ppi2 = NULL;
  79     DWORD dwNeeded = 0;
  80     DWORD dwReturned = 0;
  81     LPTSTR pPrinterName = NULL;
  82     jstring jPrinterName;
  83 
  84     // What version of Windows are you running?
  85     osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
  86     GetVersionEx(&amp;osv);
  87 
  88     // If Windows 2000, XP, Vista
  89     if (osv.dwPlatformId == VER_PLATFORM_WIN32_NT) {
  90 
  91        // Retrieve the default string from Win.ini (the registry).
  92        // String will be in form &quot;printername,drivername,portname&quot;.
  93 
  94        if (GetProfileString(TEXT(&quot;windows&quot;), TEXT(&quot;device&quot;), TEXT(&quot;,,,&quot;),
  95                             cBuffer, 250) &lt;= 0) {
  96            return NULL;
  97        }
  98        // Copy printer name into passed-in buffer...
  99        int index = 0;
 100        int len = lstrlen(cBuffer);
 101        while ((index &lt; len) &amp;&amp; cBuffer[index] != _T(&#39;,&#39;)) {
 102               index++;
 103        }
 104        if (index==0) {
 105          return NULL;
 106        }
 107 
 108        pPrinterName = (LPTSTR)GlobalAlloc(GPTR, (index+1)*sizeof(TCHAR));
 109        lstrcpyn(pPrinterName, cBuffer, index+1);
 110        jPrinterName = JNU_NewStringPlatform(env, pPrinterName);
 111        GlobalFree(pPrinterName);
 112        return jPrinterName;
 113     } else {
 114         return NULL;
 115     }
 116 
 117     CATCH_BAD_ALLOC_RET(NULL);
 118 }
 119 
 120 
 121 static jobjectArray getPrinterNames(JNIEnv *env, DWORD flags) {
 122     TRY;
 123 
 124     DWORD cbNeeded = 0;
 125     DWORD cReturned = 0;
 126     LPBYTE pPrinterEnum = NULL;
 127 
 128     jstring utf_str;
 129     jclass clazz = env-&gt;FindClass(&quot;java/lang/String&quot;);
 130     if (clazz == NULL) {
 131         return NULL;
 132     }
 133     jobjectArray nameArray;
 134 
 135     try {
 136         ::EnumPrinters(flags,
 137                        NULL, 4, NULL, 0, &amp;cbNeeded, &amp;cReturned);
 138         pPrinterEnum = new BYTE[cbNeeded];
 139         ::EnumPrinters(flags,
 140                        NULL, 4, pPrinterEnum, cbNeeded, &amp;cbNeeded,
 141                        &amp;cReturned);
 142 
 143         if (cReturned &gt; 0) {
 144             nameArray = env-&gt;NewObjectArray(cReturned, clazz, NULL);
 145             if (nameArray == NULL) {
 146                 throw std::bad_alloc();
 147             }
 148         } else {
 149             nameArray = NULL;
 150         }
 151 
 152 
 153         for (DWORD i = 0; i &lt; cReturned; i++) {
 154             PRINTER_INFO_4 *info4 = (PRINTER_INFO_4 *)
 155                 (pPrinterEnum + i * sizeof(PRINTER_INFO_4));
 156             utf_str = JNU_NewStringPlatform(env, info4-&gt;pPrinterName);
 157             if (utf_str == NULL) {
 158                 throw std::bad_alloc();
 159             }
 160             env-&gt;SetObjectArrayElement(nameArray, i, utf_str);
 161             env-&gt;DeleteLocalRef(utf_str);
 162         }
 163     } catch (std::bad_alloc&amp;) {
 164         delete [] pPrinterEnum;
 165         throw;
 166     }
 167 
 168     delete [] pPrinterEnum;
 169     return nameArray;
 170 
 171     CATCH_BAD_ALLOC_RET(NULL);
 172 }
 173 
 174 JNIEXPORT jobjectArray JNICALL
 175 Java_sun_print_PrintServiceLookupProvider_getAllPrinterNames(JNIEnv *env,
 176                                                              jobject peer)
 177 {
 178     return getPrinterNames(env, PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS);
 179 }
 180 
 181 JNIEXPORT jobjectArray JNICALL
 182 Java_sun_print_PrintServiceLookupProvider_getRemotePrintersNames(JNIEnv *env,
 183                                                                  jobject peer)
 184 {
 185     return getPrinterNames(env, PRINTER_ENUM_CONNECTIONS);
 186 }
 187 
<a name="1" id="anc1"></a><span class="line-added"> 188 JNIEXPORT void JNICALL</span>
<span class="line-added"> 189 Java_sun_print_PrintServiceLookupProvider_notifyLocalPrinterChange(JNIEnv *env,</span>
<span class="line-added"> 190                                                                    jobject peer)</span>
<span class="line-added"> 191 {</span>
<span class="line-added"> 192     jclass cls = env-&gt;GetObjectClass(peer);</span>
<span class="line-added"> 193     CHECK_NULL(cls);</span>
<span class="line-added"> 194     jmethodID refresh = env-&gt;GetMethodID(cls, &quot;refreshServices&quot;, &quot;()V&quot;);</span>
<span class="line-added"> 195     CHECK_NULL(refresh);</span>
 196 
<a name="2" id="anc2"></a>



 197     HANDLE hPrinter;
<a name="3" id="anc3"></a><span class="line-modified"> 198     LPTSTR printerName = NULL; // NULL indicates the local printer server</span>
<span class="line-modified"> 199     if (!::OpenPrinter(printerName, &amp;hPrinter, NULL)) {</span>
<span class="line-modified"> 200         return;</span>











 201     }
<a name="4" id="anc4"></a>
 202     // PRINTER_CHANGE_PRINTER = PRINTER_CHANGE_ADD_PRINTER |
 203     //                          PRINTER_CHANGE_SET_PRINTER |
 204     //                          PRINTER_CHANGE_DELETE_PRINTER |
 205     //                          PRINTER_CHANGE_FAILED_CONNECTION_PRINTER
 206     HANDLE chgObj = FindFirstPrinterChangeNotification(hPrinter,
 207                                                        PRINTER_CHANGE_PRINTER,
 208                                                        0,
 209                                                        NULL);
<a name="5" id="anc5"></a><span class="line-modified"> 210     if (chgObj != INVALID_HANDLE_VALUE) {</span>
<span class="line-modified"> 211         BOOL keepMonitoring;</span>
<span class="line-modified"> 212         do {</span>
<span class="line-modified"> 213             keepMonitoring = FALSE;</span>
<span class="line-modified"> 214             if (WaitForSingleObject(chgObj, INFINITE) == WAIT_OBJECT_0) {</span>
<span class="line-modified"> 215                 DWORD dwChange;</span>
<span class="line-modified"> 216                 keepMonitoring = FindNextPrinterChangeNotification(</span>
<span class="line-modified"> 217                                                  chgObj, &amp;dwChange, NULL, NULL);</span>
<span class="line-modified"> 218             }</span>
<span class="line-modified"> 219             if (keepMonitoring) {</span>
<span class="line-modified"> 220                 env-&gt;CallVoidMethod(peer, refresh);</span>
<span class="line-modified"> 221             }</span>
<span class="line-modified"> 222         } while (keepMonitoring &amp;&amp; !env-&gt;ExceptionCheck());</span>





 223 
<a name="6" id="anc6"></a><span class="line-modified"> 224         FindClosePrinterChangeNotification(chgObj);</span>





 225     }
<a name="7" id="anc7"></a><span class="line-added"> 226     ::ClosePrinter(hPrinter);</span>
 227 }
 228 
 229 
 230 JNIEXPORT jfloatArray JNICALL
 231 Java_sun_print_Win32PrintService_getMediaPrintableArea(JNIEnv *env,
 232                                                   jobject peer,
 233                                                   jstring printer,
 234                                                   jint  papersize)
 235 {
 236     TRY;
 237 
 238     LPTSTR printerName = (LPTSTR)JNU_GetStringPlatformChars(env,
 239                                                             printer, NULL);
 240     if (printerName == NULL) {
 241         return NULL;
 242     }
 243 
 244     jfloatArray printableArray = NULL;
 245 
 246     SAVE_CONTROLWORD
 247     HDC pdc = CreateDC(TEXT(&quot;WINSPOOL&quot;), printerName, NULL, NULL);
 248     RESTORE_CONTROLWORD
 249     if (pdc) {
 250         HANDLE hPrinter;
 251         /* Start by opening the printer */
 252         if (!::OpenPrinter(printerName, &amp;hPrinter, NULL)) {
 253             JNU_ReleaseStringPlatformChars(env, printer, printerName);
 254             return printableArray;
 255         }
 256 
 257         PDEVMODE pDevMode;
 258 
 259         if (!AwtPrintControl::getDevmode(hPrinter, printerName, &amp;pDevMode)) {
 260             /* if failure, cleanup and return failure */
 261 
 262             if (pDevMode != NULL) {
 263                 ::GlobalFree(pDevMode);
 264             }
 265             DeleteDC(pdc);
 266             ::ClosePrinter(hPrinter);
 267             JNU_ReleaseStringPlatformChars(env, printer, printerName);
 268             return printableArray;
 269         }
 270 
 271         pDevMode-&gt;dmFields |= (DM_PAPERSIZE | DM_ORIENTATION);
 272         pDevMode-&gt;dmPaperSize = (short)papersize;
 273         pDevMode-&gt;dmOrientation = DMORIENT_PORTRAIT;
 274         ::ResetDC(pdc, pDevMode);
 275         RESTORE_CONTROLWORD
 276 
 277         int left = GetDeviceCaps(pdc, PHYSICALOFFSETX);
 278         int top = GetDeviceCaps(pdc, PHYSICALOFFSETY);
 279         int width = GetDeviceCaps(pdc, HORZRES);
 280         int height = GetDeviceCaps(pdc, VERTRES);
 281 
 282         int resx = GetDeviceCaps(pdc, LOGPIXELSX);
 283         int resy = GetDeviceCaps(pdc, LOGPIXELSY);
 284 
 285         printableArray=env-&gt;NewFloatArray(4);
 286         if (printableArray != NULL) {
 287             jfloat *iPrintables =
 288                 env-&gt;GetFloatArrayElements(printableArray, NULL);
 289             if (iPrintables != NULL) {
 290                 iPrintables[0] = (float)left/resx;
 291                 iPrintables[1] = (float)top/resy;
 292                 iPrintables[2] = (float)width/resx;
 293                 iPrintables[3] = (float)height/resy;
 294                 env-&gt;ReleaseFloatArrayElements(printableArray, iPrintables, 0);
 295             }
 296         }
 297         GlobalFree(pDevMode);
 298         DeleteDC(pdc);
 299     }
 300 
 301     JNU_ReleaseStringPlatformChars(env, printer, printerName);
 302 
 303     return printableArray;
 304 
 305     CATCH_BAD_ALLOC_RET(NULL);
 306 }
 307 
 308 jintArray getIDs(JNIEnv *env, jstring printer, jstring port, int dm_id)
 309 {
 310 
 311   LPTSTR printerName = (LPTSTR)JNU_GetStringPlatformChars(env, printer, NULL);
 312   LPTSTR printerPort = (LPTSTR)JNU_GetStringPlatformChars(env, port, NULL);
 313 
 314   if (printerName == NULL || printerPort == NULL) {
 315       if (printerName != NULL) {
 316           JNU_ReleaseStringPlatformChars(env, printer, printerName);
 317       }
 318       if (printerPort != NULL) {
 319           JNU_ReleaseStringPlatformChars(env, port, printerPort);
 320       }
 321       return NULL;
 322   }
 323 
 324   SAVE_CONTROLWORD
 325   int numIDs = ::DeviceCapabilities(printerName, printerPort, dm_id,
 326                                     NULL, NULL);
 327   RESTORE_CONTROLWORD
 328 
 329   jintArray idArray = NULL;
 330   if (numIDs &gt; 0) {
 331       idArray = env-&gt;NewIntArray(numIDs);
 332       if (idArray != NULL) {
 333           jint *jpcIndices = env-&gt;GetIntArrayElements(idArray, NULL);
 334           if (jpcIndices != NULL) {
 335               jint *saveFormats = jpcIndices;
 336               LPTSTR buf = NULL;
 337               try {
 338                   buf = (LPTSTR)new char[numIDs * sizeof(WORD)];
 339               } catch (std::bad_alloc&amp;) {
 340                   buf = NULL;
 341               }
 342               if (buf != NULL) {
 343                   if (::DeviceCapabilities(printerName, printerPort,
 344                                            dm_id, buf, NULL) != -1) {
 345                       WORD *id = (WORD *)buf;
 346                       for (int i = 0; i &lt; numIDs; i++, id++) {
 347                           jpcIndices[i] = *id;
 348                       }
 349                   }
 350                   RESTORE_CONTROLWORD
 351                   delete[] buf;
 352               }
 353               env-&gt;ReleaseIntArrayElements(idArray, saveFormats, 0);
 354           }
 355       }
 356   }
 357 
 358   JNU_ReleaseStringPlatformChars(env, printer, printerName);
 359   JNU_ReleaseStringPlatformChars(env, port, printerPort);
 360   return idArray;
 361 }
 362 
 363 JNIEXPORT jintArray JNICALL
 364 Java_sun_print_Win32PrintService_getAllMediaIDs(JNIEnv *env,
 365                                                 jobject peer,
 366                                                 jstring printer,
 367                                                 jstring port)
 368 {
 369     return getIDs(env, printer, port, DC_PAPERS);
 370 }
 371 
 372 
 373 JNIEXPORT jintArray JNICALL
 374 Java_sun_print_Win32PrintService_getAllMediaTrays(JNIEnv *env,
 375                                                   jobject peer,
 376                                                   jstring printer,
 377                                                   jstring port)
 378 {
 379     return getIDs(env, printer, port, DC_BINS);
 380 }
 381 
 382 
 383 JNIEXPORT jintArray JNICALL
 384 Java_sun_print_Win32PrintService_getAllMediaSizes(JNIEnv *env,
 385                                                   jobject peer,
 386                                                   jstring printer,
 387                                                   jstring port)
 388 {
 389   LPTSTR printerName = (LPTSTR)JNU_GetStringPlatformChars(env, printer, NULL);
 390   LPTSTR printerPort = (LPTSTR)JNU_GetStringPlatformChars(env, port, NULL);
 391 
 392   if (printerName == NULL || printerPort == NULL) {
 393       if (printerName != NULL) {
 394           JNU_ReleaseStringPlatformChars(env, printer, printerName);
 395       }
 396       if (printerPort != NULL) {
 397           JNU_ReleaseStringPlatformChars(env, port, printerPort);
 398       }
 399       return NULL;
 400   }
 401 
 402   SAVE_CONTROLWORD
 403   int nPapers = ::DeviceCapabilities(printerName, printerPort, DC_PAPERSIZE,
 404                                      NULL, NULL) ;
 405   RESTORE_CONTROLWORD
 406 
 407   jintArray mediaArray = NULL;
 408   jint *saveFormats = NULL;
 409 
 410   if (nPapers &gt; 0) {
 411       mediaArray = env-&gt;NewIntArray(nPapers*2);
 412       if (mediaArray != NULL) {
 413           jint *jpcIndices = env-&gt;GetIntArrayElements(mediaArray, NULL);
 414           if (jpcIndices != NULL) {
 415               saveFormats = jpcIndices;
 416               LPTSTR buf = NULL;
 417               try {
 418                   buf = (LPTSTR)new char[nPapers * sizeof(POINT)];
 419               } catch (std::bad_alloc&amp;) {
 420                   buf = NULL;
 421               }
 422               if (buf != NULL) {
 423                   if (::DeviceCapabilities(printerName, printerPort,
 424                                            DC_PAPERSIZE, buf, NULL) != -1) {
 425                       POINT *pDim = (POINT *)buf;
 426                       for (int i = 0; i &lt; nPapers; i++) {
 427                           jpcIndices[i*2] = (pDim+i)-&gt;x;
 428                           jpcIndices[i*2+1] = (pDim+i)-&gt;y;
 429                       }
 430                   }
 431                   RESTORE_CONTROLWORD
 432                   delete[] buf;
 433               }
 434               env-&gt;ReleaseIntArrayElements(mediaArray, saveFormats, 0);
 435               saveFormats = NULL;
 436           }
 437       }
 438   }
 439 
 440   JNU_ReleaseStringPlatformChars(env, printer, printerName);
 441   JNU_ReleaseStringPlatformChars(env, port, printerPort);
 442   if (mediaArray != NULL &amp;&amp; saveFormats != NULL) {
 443       env-&gt;ReleaseIntArrayElements(mediaArray, saveFormats, 0);
 444   }
 445   return mediaArray;
 446 
 447 }
 448 
 449 
 450 jobjectArray getAllDCNames(JNIEnv *env, jobject peer, jstring printer,
 451                  jstring port, unsigned int dc_id, unsigned int buf_len)
 452 {
 453 
 454   LPTSTR printerName = (LPTSTR)JNU_GetStringPlatformChars(env, printer, NULL);
 455   LPTSTR printerPort = (LPTSTR)JNU_GetStringPlatformChars(env, port, NULL);
 456 
 457   if (printerName == NULL || printerPort == NULL) {
 458       if (printerName != NULL) {
 459           JNU_ReleaseStringPlatformChars(env, printer, printerName);
 460       }
 461       if (printerPort != NULL) {
 462           JNU_ReleaseStringPlatformChars(env, port, printerPort);
 463       }
 464       return NULL;
 465   }
 466 
 467   jstring utf_str;
 468   jobjectArray names = NULL;
 469   LPTSTR buf = NULL;
 470   SAVE_CONTROLWORD
 471   int cReturned = ::DeviceCapabilities(printerName, printerPort,
 472                                          dc_id, NULL, NULL);
 473   RESTORE_CONTROLWORD
 474   if (cReturned &lt;= 0) {
 475       JNU_ReleaseStringPlatformChars(env, printer, printerName);
 476       JNU_ReleaseStringPlatformChars(env, port, printerPort);
 477       return NULL;
 478   }
 479 
 480   try {
 481       buf = (LPTSTR)new char[cReturned * buf_len * sizeof(TCHAR)];
 482   } catch (std::bad_alloc&amp;) {
 483       buf = NULL;
 484   }
 485   if (buf == NULL) {
 486       JNU_ReleaseStringPlatformChars(env, printer, printerName);
 487       JNU_ReleaseStringPlatformChars(env, port, printerPort);
 488       JNU_ThrowOutOfMemoryError(env, &quot;OutOfMemoryError&quot;);
 489      return NULL;
 490   }
 491 
 492   cReturned = ::DeviceCapabilities(printerName, printerPort,
 493                                    dc_id, buf, NULL);
 494   RESTORE_CONTROLWORD
 495 
 496   JNU_ReleaseStringPlatformChars(env, printer, printerName);
 497   JNU_ReleaseStringPlatformChars(env, port, printerPort);
 498 
 499   if (cReturned &gt; 0) {
 500       jclass cls = env-&gt;FindClass(&quot;java/lang/String&quot;);
 501       if (cls != NULL) {
 502           names = env-&gt;NewObjectArray(cReturned, cls, NULL);
 503       }
 504       if (names == NULL || cls == NULL) {
 505           delete[] buf;
 506           return names;
 507       }
 508 
 509       for (int i = 0; i &lt; cReturned; i++) {
 510           utf_str = JNU_NewStringPlatform(env, buf+(buf_len*i));
 511             if (utf_str == NULL) {
 512                 delete[] buf;
 513                 return names;
 514             }
 515             env-&gt;SetObjectArrayElement(names, i, utf_str);
 516             env-&gt;DeleteLocalRef(utf_str);
 517         }
 518     }
 519     delete[] buf;
 520     return names;
 521 
 522 }
 523 
 524 
 525 JNIEXPORT jobjectArray JNICALL
 526 Java_sun_print_Win32PrintService_getAllMediaNames(JNIEnv *env,
 527                                                   jobject peer,
 528                                                   jstring printer,
 529                                                   jstring port)
 530 {
 531   return getAllDCNames(env, peer, printer, port, DC_PAPERNAMES, PAPERNAME_LENGTH);
 532 }
 533 
 534 
 535 JNIEXPORT jobjectArray JNICALL
 536 Java_sun_print_Win32PrintService_getAllMediaTrayNames(JNIEnv *env,
 537                                                   jobject peer,
 538                                                   jstring printer,
 539                                                   jstring port)
 540 {
 541   return getAllDCNames(env, peer, printer, port, DC_BINNAMES, TRAYNAME_LENGTH);
 542 }
 543 
 544 
 545 JNIEXPORT jint JNICALL
 546 Java_sun_print_Win32PrintService_getCopiesSupported(JNIEnv *env,
 547                                                     jobject peer,
 548                                                     jstring printer,
 549                                                     jstring port)
 550 {
 551   LPTSTR printerName = (LPTSTR)JNU_GetStringPlatformChars(env, printer, NULL);
 552   LPTSTR printerPort = (LPTSTR)JNU_GetStringPlatformChars(env, port, NULL);
 553 
 554   if (printerName == NULL || printerPort == NULL) {
 555       if (printerName != NULL) {
 556           JNU_ReleaseStringPlatformChars(env, printer, printerName);
 557       }
 558       if (printerPort != NULL) {
 559           JNU_ReleaseStringPlatformChars(env, port, printerPort);
 560       }
 561       return 1;
 562   }
 563 
 564   SAVE_CONTROLWORD
 565   int numCopies = ::DeviceCapabilities(printerName, printerPort,
 566                                        DC_COPIES,   NULL, NULL);
 567   RESTORE_CONTROLWORD
 568 
 569   if (numCopies == -1)
 570     return 1; // default
 571 
 572   JNU_ReleaseStringPlatformChars(env, printer, printerName);
 573   JNU_ReleaseStringPlatformChars(env, port, printerPort);
 574 
 575   return numCopies;
 576 }
 577 
 578 
 579 /*
 580 PostScript Drivers return wrong support info for the following code:
 581 
 582  DWORD dmFields = (::DeviceCapabilities(printerName,
 583                                          NULL, DC_FIELDS,   NULL, NULL)) ;
 584 
 585   if ((dmFields &amp; DM_YRESOLUTION) )
 586     isSupported = true;
 587 
 588 Returns not supported even if it supports resolution. Therefore, we use the
 589 function _getAllResolutions.
 590 */
 591 JNIEXPORT jintArray JNICALL
 592 Java_sun_print_Win32PrintService_getAllResolutions(JNIEnv *env,
 593                                                    jobject peer,
 594                                                    jstring printer,
 595                                                    jstring port)
 596 {
 597   LPTSTR printerName = (LPTSTR)JNU_GetStringPlatformChars(env, printer, NULL);
 598   LPTSTR printerPort = (LPTSTR)JNU_GetStringPlatformChars(env, port, NULL);
 599 
 600  if (printerName == NULL || printerPort == NULL) {
 601       if (printerName != NULL) {
 602           JNU_ReleaseStringPlatformChars(env, printer, printerName);
 603       }
 604       if (printerPort != NULL) {
 605           JNU_ReleaseStringPlatformChars(env, port, printerPort);
 606       }
 607       return NULL;
 608   }
 609 
 610   SAVE_CONTROLWORD
 611   int nResolutions = ::DeviceCapabilities(printerName, printerPort,
 612                                           DC_ENUMRESOLUTIONS, NULL, NULL);
 613   RESTORE_CONTROLWORD
 614 
 615   jintArray resolutionArray = NULL;
 616   if (nResolutions &gt; 0) {
 617     resolutionArray = env-&gt;NewIntArray(nResolutions*2);
 618     if (resolutionArray != NULL) {
 619         jint *jpcIndices = env-&gt;GetIntArrayElements(resolutionArray, NULL);
 620         if (jpcIndices != NULL) {
 621             jint *saveFormats = jpcIndices;
 622             LPTSTR resBuf = NULL;
 623             try {
 624                 resBuf = (LPTSTR)new char[nResolutions * sizeof(LONG) * 2];
 625             } catch (std::bad_alloc&amp;) {
 626                 resBuf = NULL;
 627             }
 628             if (resBuf != NULL) {
 629                 if (::DeviceCapabilities(printerName, printerPort,
 630                                          DC_ENUMRESOLUTIONS, resBuf,
 631                                          NULL) != -1) {
 632                     LONG *pResolution = (LONG *)resBuf;
 633                     for (int i = 0; i &lt; nResolutions; i++) {
 634                         jpcIndices[i*2] = *pResolution++;
 635                         jpcIndices[i*2+1] = *pResolution++;
 636                     }
 637                 }
 638                 RESTORE_CONTROLWORD
 639                 delete[] resBuf;
 640             }
 641             env-&gt;ReleaseIntArrayElements(resolutionArray, saveFormats, 0);
 642         }
 643     }
 644   }
 645 
 646   JNU_ReleaseStringPlatformChars(env, printer, printerName);
 647   JNU_ReleaseStringPlatformChars(env, port, printerPort);
 648   return resolutionArray;
 649 }
 650 
 651 
 652 static BOOL IsDCPostscript( HDC hDC )
 653 {
 654     int         nEscapeCode;
 655     CHAR        szTechnology[MAX_PATH] = &quot;&quot;;
 656 
 657     // If it supports POSTSCRIPT_PASSTHROUGH, it must be PS.
 658     nEscapeCode = POSTSCRIPT_PASSTHROUGH;
 659     if( ::ExtEscape( hDC, QUERYESCSUPPORT, sizeof(int),
 660                      (LPCSTR)&amp;nEscapeCode, 0, NULL ) &gt; 0 )
 661         return TRUE;
 662 
 663     // If it doesn&#39;t support GETTECHNOLOGY, we won&#39;t be able to tell.
 664     nEscapeCode = GETTECHNOLOGY;
 665     if( ::ExtEscape( hDC, QUERYESCSUPPORT, sizeof(int),
 666                      (LPCSTR)&amp;nEscapeCode, 0, NULL ) &lt;= 0 )
 667         return FALSE;
 668 
 669     // Get the technology string and check if the word &quot;postscript&quot; is in it.
 670     if( ::ExtEscape( hDC, GETTECHNOLOGY, 0, NULL, MAX_PATH,
 671                      (LPSTR)szTechnology ) &lt;= 0 )
 672         return FALSE;
 673     _strupr_s(szTechnology, MAX_PATH);
 674     if(!strstr( szTechnology, &quot;POSTSCRIPT&quot; ) == NULL )
 675         return TRUE;
 676 
 677     // The word &quot;postscript&quot; was not found and it didn&#39;t support
 678     //   POSTSCRIPT_PASSTHROUGH, so it&#39;s not a PS printer.
 679         return FALSE;
 680 }
 681 
 682 
 683 JNIEXPORT jstring JNICALL
 684 Java_sun_print_Win32PrintService_getPrinterPort(JNIEnv *env,
 685                                                 jobject peer,
 686                                                 jstring printer)
 687 {
 688 
 689   if (printer == NULL) {
 690     return NULL;
 691   }
 692 
 693   jstring jPort;
 694   LPTSTR printerName = NULL, printerPort = TEXT(&quot;LPT1&quot;);
 695   LPBYTE buffer = NULL;
 696   DWORD cbBuf = 0;
 697 
 698   try {
 699     VERIFY(AwtPrintControl::FindPrinter(NULL, NULL, &amp;cbBuf, NULL, NULL));
 700     buffer = new BYTE[cbBuf];
 701     AwtPrintControl::FindPrinter(printer, buffer, &amp;cbBuf,
 702                                       &amp;printerName, &amp;printerPort);
 703   } catch (std::bad_alloc&amp;) {
 704     delete [] buffer;
 705     JNU_ThrowOutOfMemoryError(env, &quot;OutOfMemoryError&quot;);
 706     return NULL;
 707   }
 708 
 709   if (printerPort == NULL) {
 710     printerPort = TEXT(&quot;LPT1&quot;);
 711   }
 712   jPort = JNU_NewStringPlatform(env, printerPort);
 713   delete [] buffer;
 714   return jPort;
 715 
 716 }
 717 
 718 
 719 JNIEXPORT jint JNICALL
 720 Java_sun_print_Win32PrintService_getCapabilities(JNIEnv *env,
 721                                                  jobject peer,
 722                                                  jstring printer,
 723                                                  jstring port)
 724 {
 725   LPTSTR printerName = (LPTSTR)JNU_GetStringPlatformChars(env, printer, NULL);
 726   LPTSTR printerPort = (LPTSTR)JNU_GetStringPlatformChars(env, port, NULL);
 727 
 728   if (printerName == NULL || printerPort == NULL) {
 729       if (printerName != NULL) {
 730           JNU_ReleaseStringPlatformChars(env, printer, printerName);
 731       }
 732       if (printerPort != NULL) {
 733           JNU_ReleaseStringPlatformChars(env, port, printerPort);
 734       }
 735       return NULL;
 736   }
 737 
 738   // 0x1000 is a flag to indicate that getCapabilities has already been called.
 739   // 0x0001 is a flag for color support and supported is the default.
 740   jint ret = 0x1001;
 741   DWORD dmFields;
 742 
 743   // get Duplex
 744   SAVE_CONTROLWORD
 745   DWORD isDuplex = (::DeviceCapabilities(printerName, printerPort,
 746                                          DC_DUPLEX,   NULL, NULL)) ;
 747 
 748   /*
 749     Check if duplexer is installed either physically or manually thru the
 750     printer setting dialog by checking if DM_DUPLEX is set.
 751   */
 752   dmFields = (::DeviceCapabilities(printerName, printerPort,
 753                                    DC_FIELDS,   NULL, NULL)) ;
 754 
 755   if ((dmFields &amp; DM_DUPLEX) &amp;&amp; isDuplex) {
 756       ret |= 0x0002;
 757   }
 758 
 759   // get Collation
 760   if ((dmFields &amp; DM_COLLATE) ) {
 761       ret |= 0x0004;
 762   }
 763 
 764   // get Print Quality
 765   if ((dmFields &amp; DM_PRINTQUALITY) ) {
 766       ret |= 0x0008;
 767   }
 768 
 769   HDC pdc = CreateDC(TEXT(&quot;WINSPOOL&quot;), printerName, NULL, NULL);
 770   if (pdc != NULL) {
 771       // get Color
 772       int bpp = GetDeviceCaps(pdc, BITSPIXEL);
 773       int nColors = GetDeviceCaps(pdc, NUMCOLORS);
 774 
 775       if (!(dmFields &amp; DM_COLOR) || ((bpp == 1)
 776                                      &amp;&amp; ((nColors == 2) || (nColors == 256)))) {
 777           ret &amp;= ~0x0001;
 778       }
 779 
 780       // check support for PostScript
 781       if (IsDCPostscript(pdc)) {
 782             ret |= 0x0010;
 783       }
 784 
 785       DeleteDC(pdc);
 786   }
 787 
 788   RESTORE_CONTROLWORD
 789   JNU_ReleaseStringPlatformChars(env, printer, printerName);
 790   JNU_ReleaseStringPlatformChars(env, port, printerPort);
 791   return ret;
 792 }
 793 
 794 
 795 #define GETDEFAULT_ERROR        -50
 796 #define NDEFAULT 9
 797 
 798 JNIEXPORT jintArray JNICALL
 799 Java_sun_print_Win32PrintService_getDefaultSettings(JNIEnv *env,
 800                                                     jobject peer,
 801                                                     jstring printer,
 802                                                     jstring port)
 803 {
 804   HANDLE      hPrinter;
 805   LPDEVMODE   pDevMode = NULL;
 806 
 807   LPTSTR printerName = (LPTSTR)JNU_GetStringPlatformChars(env, printer, NULL);
 808   LPTSTR printerPort = (LPTSTR)JNU_GetStringPlatformChars(env, port, NULL);
 809 
 810   if (printerName == NULL || printerPort == NULL) {
 811       if (printerName != NULL) {
 812           JNU_ReleaseStringPlatformChars(env, printer, printerName);
 813       }
 814       if (printerPort != NULL) {
 815           JNU_ReleaseStringPlatformChars(env, port, printerPort);
 816       }
 817       return NULL;
 818   }
 819 
 820   jint* defIndices = NULL;
 821   jintArray defaultArray = env-&gt;NewIntArray(NDEFAULT);
 822   if (defaultArray != NULL) {
 823       defIndices = env-&gt;GetIntArrayElements(defaultArray, NULL);
 824   }
 825   if (defIndices == NULL) {
 826       JNU_ReleaseStringPlatformChars(env, printer, printerName);
 827       JNU_ReleaseStringPlatformChars(env, port, printerPort);
 828       return NULL;
 829   }
 830 
 831   jint *saveFormats = defIndices;
 832 
 833   for (int i=0; i &lt; NDEFAULT; i++) {
 834       defIndices[i] = GETDEFAULT_ERROR;
 835   }
 836 
 837   /* Start by opening the printer */
 838   if (!::OpenPrinter(printerName, &amp;hPrinter, NULL)) {
 839       env-&gt;ReleaseIntArrayElements(defaultArray, saveFormats, 0);
 840       JNU_ReleaseStringPlatformChars(env, printer, printerName);
 841       JNU_ReleaseStringPlatformChars(env, port, printerPort);
 842       return defaultArray;
 843   }
 844 
 845   if (!AwtPrintControl::getDevmode(hPrinter, printerName, &amp;pDevMode)) {
 846       /* if failure, cleanup and return failure */
 847       if (pDevMode != NULL) {
 848           ::GlobalFree(pDevMode);
 849       }
 850       ::ClosePrinter(hPrinter);
 851       env-&gt;ReleaseIntArrayElements(defaultArray, saveFormats, 0);
 852       JNU_ReleaseStringPlatformChars(env, printer, printerName);
 853       JNU_ReleaseStringPlatformChars(env, port, printerPort);
 854       return defaultArray;
 855   }
 856 
 857   /* Have seen one driver which reports a default paper id which is not
 858    * one of their supported paper ids. If what is returned is not
 859    * a supported paper, use one of the supported sizes instead.
 860    *
 861    */
 862   if (pDevMode-&gt;dmFields &amp; DM_PAPERSIZE) {
 863       defIndices[0] = pDevMode-&gt;dmPaperSize;
 864 
 865       SAVE_CONTROLWORD
 866 
 867       int numSizes = ::DeviceCapabilities(printerName, printerPort,
 868                                           DC_PAPERS, NULL, NULL);
 869       if (numSizes &gt; 0) {
 870           LPTSTR papers;
 871           try {
 872               papers = (LPTSTR)SAFE_SIZE_ARRAY_ALLOC(safe_Malloc, numSizes, sizeof(WORD));
 873           } catch (const std::bad_alloc&amp;) {
 874               papers = NULL;
 875           }
 876 
 877           if (papers != NULL &amp;&amp;
 878               ::DeviceCapabilities(printerName, printerPort,
 879                                    DC_PAPERS, papers, NULL) != -1) {
 880               int present = 0;
 881               for (int i=0;i&lt;numSizes;i++) {
 882                   if (papers[i] == pDevMode-&gt;dmPaperSize) {
 883                       present = 1;
 884                   }
 885               }
 886               if (!present) {
 887                   defIndices[0] = papers[0];
 888               }
 889           }
 890           // If DeviceCapabilities fails, then also free paper allocation
 891           if (papers != NULL) {
 892               free((char*)papers);
 893           }
 894       }
 895       RESTORE_CONTROLWORD
 896   }
 897 
 898   if (pDevMode-&gt;dmFields &amp; DM_MEDIATYPE) {
 899       defIndices[1] = pDevMode-&gt;dmMediaType;
 900   }
 901 
 902   /*
 903    * For some printer like Brother HL-2240D series
 904    * pDevMode-&gt;dmYResolution is not set in pDevMode-&gt;dmFields
 905    * even though pDevMode-&gt;dmYResolution is populated
 906    * via ::DocumentProperties API, so for this case
 907    * we populate the resolution index in default array
 908    */
 909   if (pDevMode-&gt;dmFields &amp; DM_YRESOLUTION || pDevMode-&gt;dmYResolution &gt; 0) {
 910       defIndices[2]  = pDevMode-&gt;dmYResolution;
 911   }
 912 
 913   /*
 914    * For some printer like Brother HL-2240D series
 915    * pDevMode-&gt;dmPrintQuality is not set in pDevMode-&gt;dmFields
 916    * even though pDevMode-&gt;dmPrintQuality is populated
 917    * via ::DocumentProperties API, so for this case
 918    * we populate the print quality index in default array
 919    */
 920   if (pDevMode-&gt;dmFields &amp; DM_PRINTQUALITY || pDevMode-&gt;dmPrintQuality != 0) {
 921       defIndices[3] = pDevMode-&gt;dmPrintQuality;
 922   }
 923 
 924   if (pDevMode-&gt;dmFields &amp; DM_COPIES) {
 925       defIndices[4] = pDevMode-&gt;dmCopies;
 926   }
 927 
 928   if (pDevMode-&gt;dmFields &amp; DM_ORIENTATION) {
 929       defIndices[5] = pDevMode-&gt;dmOrientation;
 930   }
 931 
 932   if (pDevMode-&gt;dmFields &amp; DM_DUPLEX) {
 933       defIndices[6] = pDevMode-&gt;dmDuplex;
 934   }
 935 
 936   if (pDevMode-&gt;dmFields &amp; DM_COLLATE) {
 937       defIndices[7] = pDevMode-&gt;dmCollate;
 938   }
 939 
 940   if (pDevMode-&gt;dmFields &amp; DM_COLOR) {
 941       defIndices[8] = pDevMode-&gt;dmColor;
 942   }
 943 
 944   GlobalFree(pDevMode);
 945   ::ClosePrinter(hPrinter);
 946 
 947   env-&gt;ReleaseIntArrayElements(defaultArray, saveFormats, 0);
 948 
 949   JNU_ReleaseStringPlatformChars(env, printer, printerName);
 950   JNU_ReleaseStringPlatformChars(env, port, printerPort);
 951 
 952   return defaultArray;
 953 }
 954 
 955 
 956 JNIEXPORT jint JNICALL
 957 Java_sun_print_Win32PrintService_getJobStatus(JNIEnv *env,
 958                                           jobject peer,
 959                                           jstring printer,
 960                                           jint type)
 961 {
 962     HANDLE hPrinter;
 963     DWORD  cByteNeeded;
 964     DWORD  cByteUsed;
 965     PRINTER_INFO_2 *pPrinterInfo = NULL;
 966     int ret=0;
 967 
 968     LPTSTR printerName = (LPTSTR)JNU_GetStringPlatformChars(env, printer, NULL);
 969     if (printerName == NULL) {
 970         return -1;
 971     }
 972 
 973     // Start by opening the printer
 974     if (!::OpenPrinter(printerName, &amp;hPrinter, NULL)) {
 975         JNU_ReleaseStringPlatformChars(env, printer, printerName);
 976         return -1;
 977     }
 978 
 979     if (!::GetPrinter(hPrinter, 2, NULL, 0, &amp;cByteNeeded)) {
 980         if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
 981             ::ClosePrinter(hPrinter);
 982             JNU_ReleaseStringPlatformChars(env, printer, printerName);
 983             return -1;
 984         }
 985     }
 986 
 987     pPrinterInfo = (PRINTER_INFO_2 *)::GlobalAlloc(GPTR, cByteNeeded);
 988     if (!(pPrinterInfo)) {
 989         /* failure to allocate memory */
 990         ::ClosePrinter(hPrinter);
 991         JNU_ReleaseStringPlatformChars(env, printer, printerName);
 992         return -1;
 993     }
 994 
 995     /* get the printer info */
 996     if (!::GetPrinter(hPrinter,
 997                       2,
 998                       (LPBYTE)pPrinterInfo,
 999                       cByteNeeded,
1000                       &amp;cByteUsed))
1001         {
1002             /* failure to access the printer */
1003             ::GlobalFree(pPrinterInfo);
1004             pPrinterInfo = NULL;
1005             ::ClosePrinter(hPrinter);
1006             JNU_ReleaseStringPlatformChars(env, printer, printerName);
1007             return -1;
1008         }
1009 
1010     if (type == GETJOBCOUNT) {
1011         ret = pPrinterInfo-&gt;cJobs;
1012     } else if (type == ACCEPTJOB) {
1013         if (pPrinterInfo-&gt;Status &amp; PRINTER_STATUS_PENDING_DELETION) {
1014             ret = 0;
1015         }
1016         else {
1017             ret = 1;
1018         }
1019     }
1020 
1021     ::GlobalFree(pPrinterInfo);
1022     ::ClosePrinter(hPrinter);
1023     JNU_ReleaseStringPlatformChars(env, printer, printerName);
1024     return ret;
1025 }
1026 
1027 
1028 static jfieldID getIdOfLongField(JNIEnv *env, jobject self,
1029                                  const char *fieldName) {
1030   jclass myClass = env-&gt;GetObjectClass(self);
1031   jfieldID fieldId = env-&gt;GetFieldID(myClass, fieldName, &quot;J&quot;);
1032   DASSERT(fieldId != 0);
1033   return fieldId;
1034 }
1035 
1036 
1037 static inline HANDLE getHPrinter(JNIEnv *env, jobject self) {
1038   jfieldID fieldId = getIdOfLongField(env, self, HPRINTER_STR);
1039   if (fieldId == (jfieldID)0) {
1040       return (HANDLE)NULL;
1041   }
1042   return (HANDLE)(env-&gt;GetLongField(self, fieldId));
1043 }
1044 
1045 
1046 JNIEXPORT jboolean JNICALL
1047 Java_sun_print_Win32PrintJob_startPrintRawData(JNIEnv *env,
1048                                                jobject peer,
1049                                                jstring printer,
1050                                                jstring jobname)
1051 {
1052   HANDLE      hPrinter;
1053   DOC_INFO_1  DocInfo;
1054   LPTSTR printerName = (LPTSTR)JNU_GetStringPlatformChars(env, printer, NULL);
1055   if (printerName == NULL) {
1056       return false;
1057   }
1058   DASSERT(jobname != NULL);
1059   LPTSTR lpJobName = (LPTSTR)JNU_GetStringPlatformChars(env, jobname, NULL);
1060   LPTSTR jname = _tcsdup(lpJobName);
1061   JNU_ReleaseStringPlatformChars(env, jobname, lpJobName);
1062 
1063   // Start by opening the printer
1064   if (!::OpenPrinter(printerName, &amp;hPrinter, NULL)) {
1065     JNU_ReleaseStringPlatformChars(env, printer, printerName);
1066     free((LPTSTR)jname);
1067     return false;
1068   }
1069 
1070   JNU_ReleaseStringPlatformChars(env, printer, printerName);
1071 
1072   // Fill in the structure with info about this &quot;document.&quot;
1073   DocInfo.pDocName = jname;
1074   DocInfo.pOutputFile = NULL;
1075   DocInfo.pDatatype = TEXT(&quot;RAW&quot;);
1076 
1077   // Inform the spooler the document is beginning.
1078   if( (::StartDocPrinter(hPrinter, 1, (LPBYTE)&amp;DocInfo)) == 0 ) {
1079     ::ClosePrinter( hPrinter );
1080     free((LPTSTR)jname);
1081     return false;
1082   }
1083 
1084   free((LPTSTR)jname);
1085 
1086   // Start a page.
1087   if( ! ::StartPagePrinter( hPrinter ) ) {
1088     ::EndDocPrinter( hPrinter );
1089     ::ClosePrinter( hPrinter );
1090     return false;
1091   }
1092 
1093   // store handle
1094   jfieldID fieldId = getIdOfLongField(env, peer, HPRINTER_STR);
1095   if (fieldId == (jfieldID)0) {
1096       return false;
1097   } else {
1098       env-&gt;SetLongField(peer, fieldId, reinterpret_cast&lt;jlong&gt;(hPrinter));
1099       return true;
1100   }
1101 }
1102 
1103 
1104 JNIEXPORT jboolean JNICALL
1105 Java_sun_print_Win32PrintJob_printRawData(JNIEnv *env,
1106                                           jobject peer,
1107                                           jbyteArray dataArray,
1108                                           jint count)
1109 {
1110   jboolean  ret=true;
1111   jint      dwBytesWritten;
1112   jbyte*    data = NULL;
1113 
1114   // retrieve handle
1115   HANDLE    hPrinter = getHPrinter(env, peer);
1116   if (hPrinter == NULL) {
1117     return false;
1118   }
1119 
1120   try {
1121     data=(jbyte *)env-&gt;GetPrimitiveArrayCritical(dataArray, 0);
1122     if (data == NULL) {
1123         return false;
1124     }
1125 
1126     // Send the data to the printer.
1127     if( ! ::WritePrinter(hPrinter, data, count,(LPDWORD)&amp;dwBytesWritten)) {
1128       env-&gt;ReleasePrimitiveArrayCritical(dataArray, data, 0);
1129       return false;
1130     }
1131 
1132     // Check to see if correct number of bytes were written.
1133     if( dwBytesWritten != count ) {
1134       ret = false;
1135     }
1136 
1137   } catch (...) {
1138     if (data != NULL) {
1139       env-&gt;ReleasePrimitiveArrayCritical(dataArray, data, 0);
1140     }
1141     JNU_ThrowInternalError(env, &quot;Problem in Win32PrintJob_printRawData&quot;);
1142     return false;
1143   }
1144 
1145   env-&gt;ReleasePrimitiveArrayCritical(dataArray, data, 0);
1146   return ret;
1147 }
1148 
1149 
1150 JNIEXPORT jboolean JNICALL
1151 Java_sun_print_Win32PrintJob_endPrintRawData(JNIEnv *env,
1152                                           jobject peer)
1153 {
1154   // retrieve handle
1155   HANDLE hPrinter = getHPrinter(env, peer);
1156   if (hPrinter == NULL) {
1157     return false;
1158   }
1159 
1160   if ((::EndPagePrinter(hPrinter) != 0) &amp;&amp;
1161       (::EndDocPrinter(hPrinter) != 0) &amp;&amp;
1162       (::ClosePrinter(hPrinter) != 0)) {
1163     return true;
1164   } else {
1165     return false;
1166   }
1167 }
1168 
1169 } /* extern &quot;C&quot; */
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
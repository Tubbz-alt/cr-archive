<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/windows/native/libawt/windows/awt_Toolkit.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * The Toolkit class has two functions: it instantiates the AWT
 28  * ToolkitPeer&#39;s native methods, and provides the DLL&#39;s core functions.
 29  *
 30  * There are two ways this DLL can be used: either as a dynamically-
 31  * loaded Java native library from the interpreter, or by a Windows-
 32  * specific app.  The first manner requires that the Toolkit provide
 33  * all support needed so the app can function as a first-class Windows
 34  * app, while the second assumes that the app will provide that
 35  * functionality.  Which mode this DLL functions in is determined by
 36  * which initialization paradigm is used. If the Toolkit is constructed
 37  * normally, then the Toolkit will have its own pump. If it is explicitly
 38  * initialized for an embedded environment (via a static method on
 39  * sun.awt.windows.WToolkit), then it will rely on an external message
 40  * pump.
 41  *
 42  * The most basic functionality needed is a Windows message pump (also
 43  * known as a message loop).  When an Java app is started as a console
 44  * app by the interpreter, the Toolkit needs to provide that message
 45  * pump if the AWT is dynamically loaded.
 46  */
 47 
 48 #ifndef AWT_TOOLKIT_H
 49 #define AWT_TOOLKIT_H
 50 
 51 #include &quot;awt.h&quot;
 52 #include &quot;awtmsg.h&quot;
 53 #include &quot;Trace.h&quot;
 54 
 55 #include &quot;sun_awt_windows_WToolkit.h&quot;
 56 
 57 class AwtObject;
 58 class AwtDialog;
 59 class AwtDropTarget;
 60 
 61 typedef VOID (CALLBACK* IDLEPROC)(VOID);
 62 typedef BOOL (CALLBACK* PEEKMESSAGEPROC)(MSG&amp;);
 63 
 64 // Struct for _WInputMethod_enable|disableNativeIME method
 65 struct EnableNativeIMEStruct {
 66     jobject self;
 67     jobject peer;
 68     jint context;
 69     jboolean useNativeCompWindow;
 70 };
 71 
 72 /*
 73  * class JNILocalFrame
 74  * Push/PopLocalFrame helper
 75  */
 76 class JNILocalFrame {
 77   public:
 78     INLINE JNILocalFrame(JNIEnv *env, int size) {
 79         m_env = env;
 80         int result = m_env-&gt;PushLocalFrame(size);
 81         if (result &lt; 0) {
 82             DASSERT(FALSE);
 83             throw std::bad_alloc();
 84         }
 85     }
 86     INLINE ~JNILocalFrame() { m_env-&gt;PopLocalFrame(NULL); }
 87   private:
 88     JNIEnv* m_env;
 89 };
 90 
 91 /*
 92  * class CriticalSection
 93  * ~~~~~ ~~~~~~~~~~~~~~~~
 94  * Lightweight intra-process thread synchronization. Can only be used with
 95  * other critical sections, and only within the same process.
 96  */
 97 class CriticalSection {
 98   public:
 99     INLINE  CriticalSection() { ::InitializeCriticalSection(&amp;rep); }
100     INLINE ~CriticalSection() { ::DeleteCriticalSection(&amp;rep); }
101 
102     class Lock {
103       public:
104         INLINE Lock(const CriticalSection&amp; cs) : critSec(cs) {
105             (const_cast&lt;CriticalSection &amp;&gt;(critSec)).Enter();
106         }
107         INLINE ~Lock() {
108             (const_cast&lt;CriticalSection &amp;&gt;(critSec)).Leave();
109         }
110       private:
111         const CriticalSection&amp; critSec;
112     };
113     friend class Lock;
114 
115   private:
116     CRITICAL_SECTION rep;
117 
118     CriticalSection(const CriticalSection&amp;);
119     const CriticalSection&amp; operator =(const CriticalSection&amp;);
120 
121   public:
122     virtual void Enter() {
123         ::EnterCriticalSection(&amp;rep);
124     }
125     virtual BOOL TryEnter() {
126         return ::TryEnterCriticalSection(&amp;rep);
127     }
128     virtual void Leave() {
129         ::LeaveCriticalSection(&amp;rep);
130     }
131 };
132 
133 // Macros for using CriticalSection objects that help trace
134 // lock/unlock actions
135 
136 /* Use THIS_FILE when it is available. */
137 #ifndef THIS_FILE
138     #define THIS_FILE __FILE__
139 #endif
140 
141 #define CRITICAL_SECTION_ENTER(cs) { \
142     J2dTraceLn4(J2D_TRACE_VERBOSE2, \
143                 &quot;CS.Wait:  tid, cs, file, line = 0x%x, 0x%x, %s, %d&quot;, \
144                 GetCurrentThreadId(), &amp;(cs), THIS_FILE, __LINE__); \
145     (cs).Enter(); \
146     J2dTraceLn4(J2D_TRACE_VERBOSE2, \
147                 &quot;CS.Enter: tid, cs, file, line = 0x%x, 0x%x, %s, %d&quot;, \
148                 GetCurrentThreadId(), &amp;(cs), THIS_FILE, __LINE__); \
149 }
150 
151 #define CRITICAL_SECTION_LEAVE(cs) { \
152     J2dTraceLn4(J2D_TRACE_VERBOSE2, \
153                 &quot;CS.Leave: tid, cs, file, line = 0x%x, 0x%x, %s, %d&quot;, \
154                 GetCurrentThreadId(), &amp;(cs), THIS_FILE, __LINE__); \
155     (cs).Leave(); \
156     J2dTraceLn4(J2D_TRACE_VERBOSE2, \
157                 &quot;CS.Left:  tid, cs, file, line = 0x%x, 0x%x, %s, %d&quot;, \
158                 GetCurrentThreadId(), &amp;(cs), THIS_FILE, __LINE__); \
159 }
160 
161 // Redefine WinAPI values related to touch input, if OS &lt; Windows 7.
162 #if (!defined(WINVER) || ((WINVER) &lt; 0x0601))
163     /*
164      * RegisterTouchWindow flag values
165      */
166     #define TWF_FINETOUCH       (0x00000001)
167     #define TWF_WANTPALM        (0x00000002)
168 
169     #define WM_TOUCH                        0x0240
170 
171     /*
172      * Touch input handle
173      */
174     typedef HANDLE HTOUCHINPUT;
175 
176     typedef struct tagTOUCHINPUT {
177         LONG x;
178         LONG y;
179         HANDLE hSource;
180         DWORD dwID;
181         DWORD dwFlags;
182         DWORD dwMask;
183         DWORD dwTime;
184         ULONG_PTR dwExtraInfo;
185         DWORD cxContact;
186         DWORD cyContact;
187     } TOUCHINPUT, *PTOUCHINPUT;
188     typedef TOUCHINPUT const * PCTOUCHINPUT;
189 
190     /*
191      * Touch input flag values (TOUCHINPUT.dwFlags)
192      */
193     #define TOUCHEVENTF_MOVE            0x0001
194     #define TOUCHEVENTF_DOWN            0x0002
195     #define TOUCHEVENTF_UP              0x0004
196     #define TOUCHEVENTF_INRANGE         0x0008
197     #define TOUCHEVENTF_PRIMARY         0x0010
198     #define TOUCHEVENTF_NOCOALESCE      0x0020
199     #define TOUCHEVENTF_PEN             0x0040
200     #define TOUCHEVENTF_PALM            0x0080
201 #endif
202 
203 /************************************************************************
204  * AwtToolkit class
205  */
206 
207 class AwtToolkit {
208 public:
209     enum {
210         KB_STATE_SIZE = 256
211     };
212 
213     /* java.awt.Toolkit method ids */
214     static jmethodID getDefaultToolkitMID;
215     static jmethodID getFontMetricsMID;
216     static jmethodID insetsMID;
217 
218     /* sun.awt.windows.WToolkit ids */
219     static jmethodID windowsSettingChangeMID;
220     static jmethodID displayChangeMID;
221 
222     static jmethodID userSessionMID;
223     static jmethodID systemSleepMID;
224 
225     BOOL m_isDynamicLayoutSet;
226 
227     AwtToolkit();
228     ~AwtToolkit();
229 
230     BOOL Initialize(BOOL localPump);
231     BOOL Dispose();
232 
233     void SetDynamicLayout(BOOL dynamic);
234     BOOL IsDynamicLayoutSet();
235     BOOL IsDynamicLayoutSupported();
236     BOOL IsDynamicLayoutActive();
237     BOOL areExtraMouseButtonsEnabled();
238     void setExtraMouseButtonsEnabled(BOOL enable);
239     static UINT GetNumberOfButtons();
240 
241     bool IsWin8OrLater();
242     bool IsTouchKeyboardAutoShowEnabled();
243     bool IsAnyKeyboardAttached();
244     bool IsTouchKeyboardAutoShowSystemEnabled();
245     void ShowTouchKeyboard();
246     void HideTouchKeyboard();
247     BOOL TIRegisterTouchWindow(HWND hWnd, ULONG ulFlags);
248     BOOL TIGetTouchInputInfo(HTOUCHINPUT hTouchInput,
249         UINT cInputs, PTOUCHINPUT pInputs, int cbSize);
250     BOOL TICloseTouchInputHandle(HTOUCHINPUT hTouchInput);
251 
252     INLINE BOOL localPump() { return m_localPump; }
253     INLINE BOOL VerifyComponents() { return FALSE; } // TODO: Use new DebugHelper class to set this flag
254     INLINE HWND GetHWnd() { return m_toolkitHWnd; }
255 
256     INLINE HMODULE GetModuleHandle() { return m_dllHandle; }
257     INLINE void SetModuleHandle(HMODULE h) { m_dllHandle = h; }
258 
259     INLINE static DWORD MainThread() { return GetInstance().m_mainThreadId; }
260     INLINE void VerifyActive() throw (awt_toolkit_shutdown) {
261         if (!m_isActive &amp;&amp; m_mainThreadId != ::GetCurrentThreadId()) {
262             throw awt_toolkit_shutdown();
263         }
264     }
265     INLINE BOOL IsDisposed() { return m_isDisposed; }
266     static UINT GetMouseKeyState();
267     static void GetKeyboardState(PBYTE keyboardState);
268 
269     static ATOM RegisterClass();
270     static void UnregisterClass();
271     INLINE LRESULT SendMessage(UINT msg, WPARAM wParam=0, LPARAM lParam=0) {
272         if (!m_isDisposed) {
273             return ::SendMessage(GetHWnd(), msg, wParam, lParam);
274         } else {
275             return NULL;
276         }
277     }
278     static LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam,
279                                     LPARAM lParam);
280     static LRESULT CALLBACK GetMessageFilter(int code, WPARAM wParam,
281                                              LPARAM lParam);
282     static LRESULT CALLBACK ForegroundIdleFilter(int code, WPARAM wParam,
283                                                  LPARAM lParam);
284     static LRESULT CALLBACK MouseLowLevelHook(int code, WPARAM wParam,
285             LPARAM lParam);
286 
287     INLINE static AwtToolkit&amp; GetInstance() { return theInstance; }
288     INLINE void SetPeer(JNIEnv *env, jobject wToolkit) {
289         AwtToolkit &amp;tk = AwtToolkit::GetInstance();
290         if (tk.m_peer != NULL) {
291             env-&gt;DeleteGlobalRef(tk.m_peer);
292         }
293         tk.m_peer = (wToolkit != NULL) ? env-&gt;NewGlobalRef(wToolkit) : NULL;
294     }
295 
296     INLINE jobject GetPeer() {
297         return m_peer;
298     }
299 
300     // is this thread the main thread?
301 
302     INLINE static BOOL IsMainThread() {
303         return GetInstance().m_mainThreadId == ::GetCurrentThreadId();
304     }
305 
306     // post a message to the message pump thread
307 
308     INLINE BOOL PostMessage(UINT msg, WPARAM wp=0, LPARAM lp=0) {
309         return ::PostMessage(GetHWnd(), msg, wp, lp);
310     }
311 
312     // cause the message pump thread to call the function synchronously now!
313 
314     INLINE void * InvokeFunction(void*(*ftn)(void)) {
315         return (void *)SendMessage(WM_AWT_INVOKE_VOID_METHOD, (WPARAM)ftn, 0);
316     }
317     INLINE void InvokeFunction(void (*ftn)(void)) {
318         InvokeFunction((void*(*)(void))ftn);
319     }
320     INLINE void * InvokeFunction(void*(*ftn)(void *), void* param) {
321         return (void *)SendMessage(WM_AWT_INVOKE_METHOD, (WPARAM)ftn,
322                                    (LPARAM)param);
323     }
324     INLINE void InvokeFunction(void (*ftn)(void *), void* param) {
325         InvokeFunction((void*(*)(void*))ftn, param);
326     }
327 
328     INLINE CriticalSection &amp;GetSyncCS() { return m_Sync; }
329 
330     void *SyncCall(void*(*ftn)(void *), void* param);
331     void SyncCall(void (*ftn)(void *), void *param);
332     void *SyncCall(void *(*ftn)(void));
333     void SyncCall(void (*ftn)(void));
334 
335     // cause the message pump thread to call the function later ...
336 
337     INLINE void InvokeFunctionLater(void (*ftn)(void *), void* param) {
338         if (!PostMessage(WM_AWT_INVOKE_METHOD, (WPARAM)ftn, (LPARAM)param)) {
339             JNIEnv* env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
340             JNU_ThrowInternalError(env, &quot;Message not posted, native event queue may be full.&quot;);
341         }
342     }
343 
344    // cause the message pump thread to synchronously synchronize on the handle
345 
346     INLINE void WaitForSingleObject(HANDLE handle) {
347         SendMessage(WM_AWT_WAIT_FOR_SINGLE_OBJECT, 0, (LPARAM)handle);
348     }
349 
350     /*
351      * Create an AwtXxxx C++ component using a given factory
352      */
353     typedef void (*ComponentFactory)(void*, void*);
354     static void CreateComponent(void* hComponent, void* hParent,
355                                 ComponentFactory compFactory, BOOL isParentALocalReference=TRUE);
356 
357     static void DestroyComponentHWND(HWND hwnd);
358 
359     // constants used to PostQuitMessage
360 
361     static const int EXIT_ENCLOSING_LOOP;
362     static const int EXIT_ALL_ENCLOSING_LOOPS;
363 
364     // ...
365 
366     void QuitMessageLoop(int status);
367 
368     UINT MessageLoop(IDLEPROC lpIdleFunc, PEEKMESSAGEPROC lpPeekMessageFunc);
369     BOOL PumpWaitingMessages(PEEKMESSAGEPROC lpPeekMessageFunc);
370     void PumpToDestroy(class AwtComponent* p);
371     void ProcessMsg(MSG&amp; msg);
372     BOOL PreProcessMsg(MSG&amp; msg);
373     BOOL PreProcessMouseMsg(class AwtComponent* p, MSG&amp; msg);
374     BOOL PreProcessKeyMsg(class AwtComponent* p, MSG&amp; msg);
375 
376     /* Checks that an free ID exists. */
377     jboolean isFreeIDAvailable();
378     /* Create an ID which maps to an AwtObject pointer, such as a menu. */
379     UINT CreateCmdID(AwtObject* object);
380 
381     // removes cmd id mapping
382     void RemoveCmdID(UINT id);
383 
384     /* Return the AwtObject associated with its ID. */
385     AwtObject* LookupCmdID(UINT id);
386 
387     /* Return the current application icon. */
388     HICON GetAwtIcon();
389     HICON GetAwtIconSm();
390 
391     // Calculate a wave-like value out of the integer &#39;value&#39; and
392     // the specified period.
393     // The argument &#39;value&#39; is an integer 0, 1, 2, ... *infinity*.
394     //
395     // Examples:
396     //    Period == 3
397     //    Generated sequence: 0 1 2 1 0 .....
398     //
399     //    Period == 4
400     //    Generated sequence: 0 1 2 3 2 1 0 .....
401     static inline UINT CalculateWave(UINT value, const UINT period) {
402         if (period &lt; 2) {
403             return 0;
404         }
405         // -2 is necessary to avoid repeating extreme values (0 and period-1)
406         value %= period * 2 -2;
407         if (value &gt;= period) {
408             value = period * 2 -2 - value;
409         }
410         return value;
411     }
412 
413     HICON GetSecurityWarningIcon(UINT index, UINT w, UINT h);
414 
415     /* Turns on/off dialog modality for the system. */
416     INLINE AwtDialog* SetModal(AwtDialog* frame) {
417         AwtDialog* previousDialog = m_pModalDialog;
418         m_pModalDialog = frame;
419         return previousDialog;
420     };
421     INLINE void ResetModal(AwtDialog* oldFrame) { m_pModalDialog = oldFrame; };
422     INLINE BOOL IsModal() { return (m_pModalDialog != NULL); };
423     INLINE AwtDialog* GetModalDialog(void) { return m_pModalDialog; };
424 
425     /* Stops the current message pump (normally a modal dialog pump) */
426     INLINE void StopMessagePump() { m_breakOnError = TRUE; }
427 
428     /* Debug settings */
429     INLINE void SetVerbose(long flag)   { m_verbose = (flag != 0); }
430     INLINE void SetVerify(long flag)    { m_verifyComponents = (flag != 0); }
431     INLINE void SetBreak(long flag)     { m_breakOnError = (flag != 0); }
432     INLINE void SetHeapCheck(long flag);
433 
434     static void SetBusy(BOOL busy);
435 
436     /* Set and get the default input method Window handler. */
437     INLINE void SetInputMethodWindow(HWND inputMethodHWnd) { m_inputMethodHWnd = inputMethodHWnd; }
438     INLINE HWND GetInputMethodWindow() { return m_inputMethodHWnd; }
439 
440     static VOID CALLBACK PrimaryIdleFunc();
441     static VOID CALLBACK SecondaryIdleFunc();
442     static BOOL CALLBACK CommonPeekMessageFunc(MSG&amp; msg);
443     static BOOL activateKeyboardLayout(HKL hkl);
444 
445     HANDLE m_waitEvent;
446     volatile DWORD eventNumber;
447     volatile BOOL isInDoDragDropLoop;
448 private:
449     HWND CreateToolkitWnd(LPCTSTR name);
450 
451     void InitTouchKeyboardExeFilePath();
452     HWND GetTouchKeyboardWindow();
453 
454     BOOL m_localPump;
455     DWORD m_mainThreadId;
456     HWND m_toolkitHWnd;
457     HWND m_inputMethodHWnd;
458     BOOL m_verbose;
459     BOOL m_isActive; // set to FALSE at beginning of Dispose
460     BOOL m_isDisposed; // set to TRUE at end of Dispose
461     BOOL m_areExtraMouseButtonsEnabled;
462 
463     typedef BOOL (WINAPI *RegisterTouchWindowFunc)(HWND hWnd, ULONG ulFlags);
464     typedef BOOL (WINAPI *GetTouchInputInfoFunc)(HTOUCHINPUT hTouchInput,
465         UINT cInputs, PTOUCHINPUT pInputs, int cbSize);
466     typedef BOOL (WINAPI *CloseTouchInputHandleFunc)(HTOUCHINPUT hTouchInput);
467 
468     BOOL m_isWin8OrLater;
469     BOOL m_touchKbrdAutoShowIsEnabled;
470     TCHAR* m_touchKbrdExeFilePath;
471     RegisterTouchWindowFunc m_pRegisterTouchWindow;
472     GetTouchInputInfoFunc m_pGetTouchInputInfo;
473     CloseTouchInputHandleFunc m_pCloseTouchInputHandle;
474 
475     BOOL m_vmSignalled; // set to TRUE if QUERYENDSESSION has successfully
476                         // raised SIGTERM
477 
478     BOOL m_verifyComponents;
479     BOOL m_breakOnError;
480 
481     BOOL  m_breakMessageLoop;
482     UINT  m_messageLoopResult;
483 
484     class AwtComponent* m_lastMouseOver;
485     BOOL                m_mouseDown;
486 
487     HHOOK m_hGetMessageHook;
488     HHOOK m_hMouseLLHook;
489     UINT_PTR  m_timer;
490 
491     class AwtCmdIDList* m_cmdIDs;
492     BYTE                m_lastKeyboardState[KB_STATE_SIZE];
493     CriticalSection     m_lockKB;
494 
495     static AwtToolkit theInstance;
496 
497     /* The current modal dialog frame (normally NULL). */
498     AwtDialog* m_pModalDialog;
499 
500     /* The WToolkit peer instance */
501     jobject m_peer;
502 
503     HMODULE m_dllHandle;  /* The module handle. */
504 
505     CriticalSection m_Sync;
506 
507 /* track display changes - used by palette-updating code.
508    This is a workaround for a windows bug that prevents
509    WM_PALETTECHANGED event from occurring immediately after
510    a WM_DISPLAYCHANGED event.
511   */
512 private:
513     BOOL m_displayChanged;  /* Tracks displayChanged events */
514     // 0 means we are not embedded.
515     DWORD m_embedderProcessID;
516 
517 public:
518     BOOL HasDisplayChanged() { return m_displayChanged; }
519     void ResetDisplayChanged() { m_displayChanged = FALSE; }
520     void RegisterEmbedderProcessId(HWND);
521     BOOL IsEmbedderProcessId(const DWORD processID) const
522     {
523         return m_embedderProcessID &amp;&amp; (processID == m_embedderProcessID);
524     }
525 
526  private:
527     static JNIEnv *m_env;
528     static DWORD m_threadId;
529  public:
530     static void SetEnv(JNIEnv *env);
531     static JNIEnv* GetEnv();
532 
533     static BOOL GetScreenInsets(int screenNum, RECT * rect);
534 
535     // If the DWM is active, this function uses
536     // DwmGetWindowAttribute()/DWMWA_EXTENDED_FRAME_BOUNDS.
537     // Otherwise, fall back to regular ::GetWindowRect().
538     // See 6711576 for more details.
539     static void GetWindowRect(HWND hWnd, LPRECT lpRect);
540 
541  private:
542     // The window handle of a toplevel window last seen under the mouse cursor.
543     // See MouseLowLevelHook() for details.
544     HWND m_lastWindowUnderMouse;
545  public:
546     HWND GetWindowUnderMouse() { return m_lastWindowUnderMouse; }
547 
548     void InstallMouseLowLevelHook();
549     void UninstallMouseLowLevelHook();
550 
551 
552 /* AWT preloading (early Toolkit thread start)
553  */
554 public:
555     /* Toolkit preload action class.
556      * Preload actions should be registered with
557      * AwtToolkit::getInstance().GetPreloadThread().AddAction().
558      * AwtToolkit thread calls InitImpl method at the beghining
559      * and CleanImpl(false) before exiting for all registered actions.
560      * If an application provides own Toolkit thread
561      * (sun.awt.windows.WToolkit.embeddedInit), the thread calls Clean(true)
562      * for each action.
563      */
564     class PreloadThread;    // forward declaration
565     class PreloadAction {
566         friend class PreloadThread;
567     public:
568         PreloadAction() : initThreadId(0), pNext(NULL) {}
569         virtual ~PreloadAction() {}
570 
571     protected:
572         // called by PreloadThread or as result
573         // of EnsureInited() call (on Toolkit thread!).
574         virtual void InitImpl() = 0;
575 
576         // called by PreloadThread (before exiting).
577         // reInit == false: normal shutdown;
578         // reInit == true: PreloadThread is shutting down due external
579         //   Toolkit thread was provided.
580         virtual void CleanImpl(bool reInit) = 0;
581 
582     public:
583         // Initialized the action on the Toolkit thread if not yet initialized.
584         bool EnsureInited();
585 
586         // returns thread ID which the action was inited on (0 if not inited)
587         DWORD GetInitThreadID();
588 
589         // Allows to deinitialize action earlier.
590         // The method must be called on the Toolkit thread only.
591         // returns true on success,
592         //         false if the action was inited on other thread.
593         bool Clean();
594 
595     private:
596         unsigned initThreadId;
597         // lock for Init/Clean
598         CriticalSection initLock;
599 
600         // Chain support (for PreloadThread)
601         PreloadAction *pNext;   // for action chain used by PreloadThread
602         void SetNext(PreloadAction *pNext) { this-&gt;pNext = pNext; }
603         PreloadAction *GetNext() { return pNext; }
604 
605         // wrapper for AwtToolkit::InvokeFunction
606         static void InitWrapper(void *param);
607 
608         void Init();
609         void Clean(bool reInit);
610 
611     };
612 
613     /** Toolkit preload thread class.
614      */
615     class PreloadThread {
616     public:
617         PreloadThread();
618         ~PreloadThread();
619 
620         // adds action &amp; start the thread if not yet started
621         bool AddAction(PreloadAction *pAction);
622 
623         // sets termination flag; returns true if the thread is running.
624         // wrongThread specifies cause of the termination:
625         //   false means termination on the application shutdown;
626         // wrongThread is used as reInit parameter for action cleanup.
627         bool Terminate(bool wrongThread);
628         bool InvokeAndTerminate(void(_cdecl *fn)(void *), void *param);
629 
630         // waits for the thread completion;
631         // use the method after Terminate() only if Terminate() returned true
632         INLINE void Wait4Finish() {
633             ::WaitForSingleObject(hFinished, INFINITE);
634         }
635 
636         INLINE unsigned GetThreadId() {
637             CriticalSection::Lock lock(threadLock);
638             return threadId;
639         }
640         INLINE bool IsWrongThread() {
641             CriticalSection::Lock lock(threadLock);
642             return wrongThread;
643         }
644         // returns true if the current thread is &quot;preload&quot; thread
645         bool OnPreloadThread();
646 
647     private:
648         // data access lock
649         CriticalSection threadLock;
650 
651         // the thread status
652         enum Status {
653             None = -1,      // initial
654             Preloading = 0, // preloading in progress
655             RunningToolkit, // Running as Toolkit thread
656             Cleaning,       // exited from Toolkit thread proc, cleaning
657             Finished        //
658         } status;
659 
660         // &quot;wrong thread&quot; flag
661         bool wrongThread;
662 
663         // thread proc (calls (this)param-&gt;ThreadProc())
664         static unsigned WINAPI StaticThreadProc(void *param);
665         unsigned ThreadProc();
666 
667         INLINE void AwakeThread() {
668             ::SetEvent(hAwake);
669         }
670 
671         // if threadId != 0 -&gt; we are running
672         unsigned threadId;
673         // ThreadProc sets the event on exit
674         HANDLE hFinished;
675         // ThreadProc waits on the event for NewAction/Terminate/InvokeAndTerminate
676         HANDLE hAwake;
677 
678         // function/param to invoke (InvokeAndTerminate)
679         // if execFunc == NULL =&gt; just terminate
680         void(_cdecl *execFunc)(void *);
681         void *execParam;
682 
683         // action chain
684         PreloadAction *pActionChain;
685         PreloadAction *pLastProcessedAction;
686 
687         // returns next action in the list (NULL if no more actions)
688         PreloadAction* GetNextAction();
689 
690     };
691 
692     INLINE PreloadThread&amp; GetPreloadThread() { return preloadThread; }
693 
694 private:
695     PreloadThread preloadThread;
696 
697 };
698 
699 
700 /*  creates an instance of T and assigns it to the argument, but only if
701     the argument is initially NULL. Supposed to be thread-safe.
702     returns the new value of the argument. I&#39;m not using volatile here
703     as InterlockedCompareExchange ensures volatile semantics
704     and acquire/release.
705     The function is useful when used with static POD NULL-initialized
706     pointers, as they are guaranteed to be NULL before any dynamic
707     initialization takes place. This function turns such a pointer
708     into a thread-safe singleton, working regardless of dynamic
709     initialization order. Destruction problem is not solved,
710     we don&#39;t need it here.
711 */
712 
713 template&lt;typename T&gt; inline T* SafeCreate(T* &amp;pArg) {
714     /*  this implementation has no locks, it just destroys the object if it
715         fails to be the first to init. another way would be using a special
716         flag pointer value to mark the pointer as &quot;being initialized&quot;. */
717     T* pTemp = (T*)InterlockedCompareExchangePointer((void**)&amp;pArg, NULL, NULL);
718     if (pTemp != NULL) return pTemp;
719     T* pNew = new T;
720     pTemp = (T*)InterlockedCompareExchangePointer((void**)&amp;pArg, pNew, NULL);
721     if (pTemp != NULL) {
722         // we failed it - another thread has already initialized pArg
723         delete pNew;
724         return pTemp;
725     } else {
726         return pNew;
727     }
728 }
729 
730 #endif /* AWT_TOOLKIT_H */
    </pre>
  </body>
</html>
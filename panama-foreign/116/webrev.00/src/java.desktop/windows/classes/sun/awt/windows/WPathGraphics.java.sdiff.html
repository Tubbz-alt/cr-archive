<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/windows/classes/sun/awt/windows/WPathGraphics.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../unix/native/libawt_xawt/xawt/XWindow.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../print/PrintServiceLookupProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/windows/classes/sun/awt/windows/WPathGraphics.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1075 
1076             if (boundsWidth &gt; 0 &amp;&amp; boundsHeight &gt; 0) {
1077 
1078                 /* If the image has transparent or semi-transparent
1079                  * pixels then we&#39;ll have the application re-render
1080                  * the portion of the page covered by the image.
1081                  * The BufferedImage will be at the image&#39;s resolution
1082                  * to avoid wasting memory. By re-rendering this portion
1083                  * of a page all compositing is done by Java2D into
1084                  * the BufferedImage and then that image is copied to
1085                  * GDI.
1086                  * However several special cases can be handled otherwise:
1087                  * - bitmask transparency with a solid background colour
1088                  * - images which have transparency color models but no
1089                  * transparent pixels
1090                  * - images with bitmask transparency and an IndexColorModel
1091                  * (the common transparent GIF case) can be handled by
1092                  * rendering just the opaque pixels.
1093                  */
1094                 boolean drawOpaque = true;
<span class="line-modified">1095                 if (!handlingTransparency &amp;&amp; hasTransparentPixels(img)) {</span>


1096                     drawOpaque = false;
1097                     if (isBitmaskTransparency(img)) {
1098                         if (bgcolor == null) {
1099                             if (drawBitmaskImage(img, xform, bgcolor,
1100                                                  srcX, srcY,
1101                                                  srcWidth, srcHeight)) {
1102                                 // image drawn, just return.
1103                                 return true;
1104                             }
1105                         } else if (bgcolor.getTransparency()
1106                                    == Transparency.OPAQUE) {
1107                             drawOpaque = true;
1108                         }
1109                     }
1110                     if (!canDoRedraws()) {
1111                         drawOpaque = true;
1112                     }
1113                 } else {
1114                     // if there&#39;s no transparent pixels there&#39;s no need
1115                     // for a background colour. This can avoid edge artifacts
</pre>
</td>
<td>
<hr />
<pre>
1075 
1076             if (boundsWidth &gt; 0 &amp;&amp; boundsHeight &gt; 0) {
1077 
1078                 /* If the image has transparent or semi-transparent
1079                  * pixels then we&#39;ll have the application re-render
1080                  * the portion of the page covered by the image.
1081                  * The BufferedImage will be at the image&#39;s resolution
1082                  * to avoid wasting memory. By re-rendering this portion
1083                  * of a page all compositing is done by Java2D into
1084                  * the BufferedImage and then that image is copied to
1085                  * GDI.
1086                  * However several special cases can be handled otherwise:
1087                  * - bitmask transparency with a solid background colour
1088                  * - images which have transparency color models but no
1089                  * transparent pixels
1090                  * - images with bitmask transparency and an IndexColorModel
1091                  * (the common transparent GIF case) can be handled by
1092                  * rendering just the opaque pixels.
1093                  */
1094                 boolean drawOpaque = true;
<span class="line-modified">1095                 if (isCompositing(getComposite())) {</span>
<span class="line-added">1096                     drawOpaque = false;</span>
<span class="line-added">1097                 } else if (!handlingTransparency &amp;&amp; hasTransparentPixels(img)) {</span>
1098                     drawOpaque = false;
1099                     if (isBitmaskTransparency(img)) {
1100                         if (bgcolor == null) {
1101                             if (drawBitmaskImage(img, xform, bgcolor,
1102                                                  srcX, srcY,
1103                                                  srcWidth, srcHeight)) {
1104                                 // image drawn, just return.
1105                                 return true;
1106                             }
1107                         } else if (bgcolor.getTransparency()
1108                                    == Transparency.OPAQUE) {
1109                             drawOpaque = true;
1110                         }
1111                     }
1112                     if (!canDoRedraws()) {
1113                         drawOpaque = true;
1114                     }
1115                 } else {
1116                     // if there&#39;s no transparent pixels there&#39;s no need
1117                     // for a background colour. This can avoid edge artifacts
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../unix/native/libawt_xawt/xawt/XWindow.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../print/PrintServiceLookupProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
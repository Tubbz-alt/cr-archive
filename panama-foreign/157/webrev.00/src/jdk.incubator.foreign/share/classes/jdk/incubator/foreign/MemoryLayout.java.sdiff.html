<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/jdk/java/foreign/TestLayoutPaths.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 80  *     &lt;li&gt;for a padding layout &lt;em&gt;L&lt;/em&gt;, the natural alignment is 1, regardless of its size; that is, in the absence
 81  *     of an explicit alignment constraint, a padding layout should not affect the alignment constraint of the group
 82  *     layout it is nested into&lt;/li&gt;
 83  *     &lt;li&gt;for a value layout &lt;em&gt;L&lt;/em&gt; whose size is &lt;em&gt;N&lt;/em&gt;, the natural alignment of &lt;em&gt;L&lt;/em&gt; is &lt;em&gt;N&lt;/em&gt;&lt;/li&gt;
 84  *     &lt;li&gt;for a sequence layout &lt;em&gt;S&lt;/em&gt; whose element layout is &lt;em&gt;E&lt;/em&gt;, the natural alignment of &lt;em&gt;S&lt;/em&gt; is that of &lt;em&gt;E&lt;/em&gt;&lt;/li&gt;
 85  *     &lt;li&gt;for a group layout &lt;em&gt;G&lt;/em&gt; with member layouts &lt;em&gt;M1&lt;/em&gt;, &lt;em&gt;M2&lt;/em&gt;, ... &lt;em&gt;Mn&lt;/em&gt; whose alignments are
 86  *     &lt;em&gt;A1&lt;/em&gt;, &lt;em&gt;A2&lt;/em&gt;, ... &lt;em&gt;An&lt;/em&gt;, respectively, the natural alignment of &lt;em&gt;G&lt;/em&gt; is &lt;em&gt;max(A1, A2 ... An)&lt;/em&gt;&lt;/li&gt;
 87  * &lt;/ul&gt;
 88  * A layout&#39;s natural alignment can be overridden if needed (see {@link MemoryLayout#withBitAlignment(long)}), which can be useful to describe
 89  * hyper-aligned layouts.
 90  * &lt;p&gt;
 91  * All value layouts have an &lt;em&gt;explicit&lt;/em&gt; byte order (see {@link java.nio.ByteOrder}) which is set when the layout is created.
 92  *
 93  * &lt;h2&gt;&lt;a id = &quot;layout-paths&quot;&gt;Layout paths&lt;/a&gt;&lt;/h2&gt;
 94  *
 95  * A &lt;em&gt;layout path&lt;/em&gt; originates from a &lt;em&gt;root&lt;/em&gt; layout (typically a group or a sequence layout) and terminates
 96  * at a layout nested within the root layout - this is the layout &lt;em&gt;selected&lt;/em&gt; by the layout path.
 97  * Layout paths are typically expressed as a sequence of one or more {@link PathElement} instances.
 98  * &lt;p&gt;
 99  * Layout paths are for example useful in order to obtain offsets of arbitrarily nested layouts inside another layout
<span class="line-modified">100  * (see {@link MemoryLayout#offset(PathElement...)}), to quickly obtain a memory access handle corresponding to the selected</span>
101  * layout (see {@link MemoryLayout#varHandle(Class, PathElement...)}), to select an arbitrarily nested layout inside
102  * another layout (see {@link MemoryLayout#select(PathElement...)}, or to transform a nested layout element inside
103  * another layout (see {@link MemoryLayout#map(UnaryOperator, PathElement...)}).
104  * &lt;p&gt;
105  * Such &lt;em&gt;layout paths&lt;/em&gt; can be constructed programmatically using the methods in this class.
106  * For instance, given a layout constructed as follows:
107  * &lt;blockquote&gt;&lt;pre&gt;{@code
108 SequenceLayout seq = MemoryLayout.ofSequence(5,
109     MemoryLayout.ofStruct(
110         MemoryLayout.ofPaddingBits(32),
111         MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName(&quot;value&quot;)
112 ));
113  * }&lt;/pre&gt;&lt;/blockquote&gt;
114  *
<span class="line-modified">115  * We can obtain the offset of the member layout named &lt;code&gt;value&lt;/code&gt; from &lt;code&gt;seq&lt;/code&gt;, as follows:</span>
116  * &lt;blockquote&gt;&lt;pre&gt;{@code
<span class="line-modified">117 long valueOffset = seq.addOffset(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));</span>
118  * }&lt;/pre&gt;&lt;/blockquote&gt;
119  *
120  * Similarly, we can select the member layout named {@code value}, as follows:
121  * &lt;blockquote&gt;&lt;pre&gt;{@code
122 MemoryLayout value = seq.select(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
123  * }&lt;/pre&gt;&lt;/blockquote&gt;
124  *
125  * And, we can also replace the layout named {@code value} with another layout, as follows:
126  * &lt;blockquote&gt;&lt;pre&gt;{@code
127 MemoryLayout newSeq = seq.map(l -&gt; MemoryLayout.ofPadding(32), PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
128  * }&lt;/pre&gt;&lt;/blockquote&gt;
129  *
130  * That is, the above declaration is identical to the following, more verbose one:
131  * &lt;blockquote&gt;&lt;pre&gt;{@code
132 MemoryLayout newSeq = MemoryLayout.ofSequence(5,
133     MemoryLayout.ofStruct(
134         MemoryLayout.ofPaddingBits(32),
135         MemoryLayout.ofPaddingBits(32)
136 ));
137  * }&lt;/pre&gt;&lt;/blockquote&gt;
</pre>
<hr />
<pre>
306      * Returns a stream of the names of the attributes of this layout
307      *
308      * @return the stream of names
309      */
310     Stream&lt;String&gt; attributes();
311 
312     /**
313      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
314      * layout.
315      *
316      * @apiNote if the layout path has one (or more) free dimensions,
317      * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.
318      *
319      * @param elements the layout path elements.
320      * @return The offset, in bits, of the layout selected by the layout path in {@code elements}.
321      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the
322      * layout path contains one or more path elements that select multiple sequence element indices
323      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).
324      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.
325      */
<span class="line-modified">326     default long offset(PathElement... elements) {</span>
327         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset, EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);
328     }
329 




















330     /**
331      * Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path,
332      * where the path is considered rooted in this layout.
333      *
334      * @apiNote the resulting var handle will feature an additional {@code long} access coordinate for every
335      * unspecified sequence access component contained in this layout path. Moreover, the resulting var handle
336      * features certain &lt;a href=&quot;MemoryHandles.html#memaccess-mode&quot;&gt;access mode restrictions&lt;/a&gt;, which are common to all memory access var handles.
337      *
338      * @param carrier the var handle carrier type.
339      * @param elements the layout path elements.
340      * @return a var handle which can be used to dereference memory at the (possibly nested) layout selected by the layout path in {@code elements}.
341      * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraints,
342      * or if one of the layouts traversed by the layout path has unspecified size.
343      * @throws IllegalArgumentException if the carrier does not represent a primitive type, if the carrier is {@code void},
344      * {@code boolean}, or if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}),
345      * or if the selected value layout has a size that that does not match that of the specified carrier type.
346      */
347     default VarHandle varHandle(Class&lt;?&gt; carrier, PathElement... elements) {
348         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), path -&gt; path.dereferenceHandle(carrier),
349                 Set.of(), elements);
</pre>
</td>
<td>
<hr />
<pre>
 80  *     &lt;li&gt;for a padding layout &lt;em&gt;L&lt;/em&gt;, the natural alignment is 1, regardless of its size; that is, in the absence
 81  *     of an explicit alignment constraint, a padding layout should not affect the alignment constraint of the group
 82  *     layout it is nested into&lt;/li&gt;
 83  *     &lt;li&gt;for a value layout &lt;em&gt;L&lt;/em&gt; whose size is &lt;em&gt;N&lt;/em&gt;, the natural alignment of &lt;em&gt;L&lt;/em&gt; is &lt;em&gt;N&lt;/em&gt;&lt;/li&gt;
 84  *     &lt;li&gt;for a sequence layout &lt;em&gt;S&lt;/em&gt; whose element layout is &lt;em&gt;E&lt;/em&gt;, the natural alignment of &lt;em&gt;S&lt;/em&gt; is that of &lt;em&gt;E&lt;/em&gt;&lt;/li&gt;
 85  *     &lt;li&gt;for a group layout &lt;em&gt;G&lt;/em&gt; with member layouts &lt;em&gt;M1&lt;/em&gt;, &lt;em&gt;M2&lt;/em&gt;, ... &lt;em&gt;Mn&lt;/em&gt; whose alignments are
 86  *     &lt;em&gt;A1&lt;/em&gt;, &lt;em&gt;A2&lt;/em&gt;, ... &lt;em&gt;An&lt;/em&gt;, respectively, the natural alignment of &lt;em&gt;G&lt;/em&gt; is &lt;em&gt;max(A1, A2 ... An)&lt;/em&gt;&lt;/li&gt;
 87  * &lt;/ul&gt;
 88  * A layout&#39;s natural alignment can be overridden if needed (see {@link MemoryLayout#withBitAlignment(long)}), which can be useful to describe
 89  * hyper-aligned layouts.
 90  * &lt;p&gt;
 91  * All value layouts have an &lt;em&gt;explicit&lt;/em&gt; byte order (see {@link java.nio.ByteOrder}) which is set when the layout is created.
 92  *
 93  * &lt;h2&gt;&lt;a id = &quot;layout-paths&quot;&gt;Layout paths&lt;/a&gt;&lt;/h2&gt;
 94  *
 95  * A &lt;em&gt;layout path&lt;/em&gt; originates from a &lt;em&gt;root&lt;/em&gt; layout (typically a group or a sequence layout) and terminates
 96  * at a layout nested within the root layout - this is the layout &lt;em&gt;selected&lt;/em&gt; by the layout path.
 97  * Layout paths are typically expressed as a sequence of one or more {@link PathElement} instances.
 98  * &lt;p&gt;
 99  * Layout paths are for example useful in order to obtain offsets of arbitrarily nested layouts inside another layout
<span class="line-modified">100  * (see {@link MemoryLayout#bitOffset(PathElement...)}), to quickly obtain a memory access handle corresponding to the selected</span>
101  * layout (see {@link MemoryLayout#varHandle(Class, PathElement...)}), to select an arbitrarily nested layout inside
102  * another layout (see {@link MemoryLayout#select(PathElement...)}, or to transform a nested layout element inside
103  * another layout (see {@link MemoryLayout#map(UnaryOperator, PathElement...)}).
104  * &lt;p&gt;
105  * Such &lt;em&gt;layout paths&lt;/em&gt; can be constructed programmatically using the methods in this class.
106  * For instance, given a layout constructed as follows:
107  * &lt;blockquote&gt;&lt;pre&gt;{@code
108 SequenceLayout seq = MemoryLayout.ofSequence(5,
109     MemoryLayout.ofStruct(
110         MemoryLayout.ofPaddingBits(32),
111         MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName(&quot;value&quot;)
112 ));
113  * }&lt;/pre&gt;&lt;/blockquote&gt;
114  *
<span class="line-modified">115  * We can obtain the offset, in bits, of the member layout named &lt;code&gt;value&lt;/code&gt; from &lt;code&gt;seq&lt;/code&gt;, as follows:</span>
116  * &lt;blockquote&gt;&lt;pre&gt;{@code
<span class="line-modified">117 long valueOffset = seq.bitOffset(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));</span>
118  * }&lt;/pre&gt;&lt;/blockquote&gt;
119  *
120  * Similarly, we can select the member layout named {@code value}, as follows:
121  * &lt;blockquote&gt;&lt;pre&gt;{@code
122 MemoryLayout value = seq.select(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
123  * }&lt;/pre&gt;&lt;/blockquote&gt;
124  *
125  * And, we can also replace the layout named {@code value} with another layout, as follows:
126  * &lt;blockquote&gt;&lt;pre&gt;{@code
127 MemoryLayout newSeq = seq.map(l -&gt; MemoryLayout.ofPadding(32), PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
128  * }&lt;/pre&gt;&lt;/blockquote&gt;
129  *
130  * That is, the above declaration is identical to the following, more verbose one:
131  * &lt;blockquote&gt;&lt;pre&gt;{@code
132 MemoryLayout newSeq = MemoryLayout.ofSequence(5,
133     MemoryLayout.ofStruct(
134         MemoryLayout.ofPaddingBits(32),
135         MemoryLayout.ofPaddingBits(32)
136 ));
137  * }&lt;/pre&gt;&lt;/blockquote&gt;
</pre>
<hr />
<pre>
306      * Returns a stream of the names of the attributes of this layout
307      *
308      * @return the stream of names
309      */
310     Stream&lt;String&gt; attributes();
311 
312     /**
313      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
314      * layout.
315      *
316      * @apiNote if the layout path has one (or more) free dimensions,
317      * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.
318      *
319      * @param elements the layout path elements.
320      * @return The offset, in bits, of the layout selected by the layout path in {@code elements}.
321      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the
322      * layout path contains one or more path elements that select multiple sequence element indices
323      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).
324      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.
325      */
<span class="line-modified">326     default long bitOffset(PathElement... elements) {</span>
327         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset, EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);
328     }
329 
<span class="line-added">330     /**</span>
<span class="line-added">331      * Computes the offset, in bytes, of the layout selected by a given layout path, where the path is considered rooted in this</span>
<span class="line-added">332      * layout.</span>
<span class="line-added">333      *</span>
<span class="line-added">334      * @apiNote if the layout path has one (or more) free dimensions,</span>
<span class="line-added">335      * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.</span>
<span class="line-added">336      *</span>
<span class="line-added">337      * @param elements the layout path elements.</span>
<span class="line-added">338      * @return The offset, in bytes, of the layout selected by the layout path in {@code elements}.</span>
<span class="line-added">339      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the</span>
<span class="line-added">340      * layout path contains one or more path elements that select multiple sequence element indices</span>
<span class="line-added">341      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).</span>
<span class="line-added">342      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size,</span>
<span class="line-added">343      * or if {@code bitOffset(elements)} is not a multiple of 8.</span>
<span class="line-added">344      */</span>
<span class="line-added">345     default long byteOffset(PathElement... elements) {</span>
<span class="line-added">346         return Utils.bitsToBytesOrThrow(bitOffset(elements),</span>
<span class="line-added">347                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte offset; bit offset is not a multiple of 8&quot;));</span>
<span class="line-added">348     }</span>
<span class="line-added">349 </span>
350     /**
351      * Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path,
352      * where the path is considered rooted in this layout.
353      *
354      * @apiNote the resulting var handle will feature an additional {@code long} access coordinate for every
355      * unspecified sequence access component contained in this layout path. Moreover, the resulting var handle
356      * features certain &lt;a href=&quot;MemoryHandles.html#memaccess-mode&quot;&gt;access mode restrictions&lt;/a&gt;, which are common to all memory access var handles.
357      *
358      * @param carrier the var handle carrier type.
359      * @param elements the layout path elements.
360      * @return a var handle which can be used to dereference memory at the (possibly nested) layout selected by the layout path in {@code elements}.
361      * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraints,
362      * or if one of the layouts traversed by the layout path has unspecified size.
363      * @throws IllegalArgumentException if the carrier does not represent a primitive type, if the carrier is {@code void},
364      * {@code boolean}, or if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}),
365      * or if the selected value layout has a size that that does not match that of the specified carrier type.
366      */
367     default VarHandle varHandle(Class&lt;?&gt; carrier, PathElement... elements) {
368         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), path -&gt; path.dereferenceHandle(carrier),
369                 Set.of(), elements);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/jdk/java/foreign/TestLayoutPaths.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
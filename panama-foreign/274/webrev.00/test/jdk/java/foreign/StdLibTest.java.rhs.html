<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/foreign/StdLibTest.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<a name="1" id="anc1"></a>



 26  * @build NativeTestHelper StdLibTest
 27  * @run testng/othervm -Dforeign.restricted=permit StdLibTest
 28  */
 29 
 30 import java.lang.invoke.MethodHandle;
 31 import java.lang.invoke.MethodHandles;
 32 import java.lang.invoke.MethodType;
 33 import java.time.Instant;
 34 import java.time.LocalDateTime;
 35 import java.time.ZoneOffset;
 36 import java.time.ZonedDateTime;
 37 import java.util.ArrayList;
 38 import java.util.Arrays;
 39 import java.util.Collections;
 40 import java.util.LinkedHashSet;
 41 import java.util.List;
 42 import java.util.Set;
 43 import java.util.function.Consumer;
 44 import java.util.stream.Collectors;
 45 import java.util.stream.Stream;
 46 
 47 import jdk.incubator.foreign.CSupport;
 48 import jdk.incubator.foreign.ForeignLinker;
 49 import jdk.incubator.foreign.FunctionDescriptor;
 50 import jdk.incubator.foreign.LibraryLookup;
 51 import jdk.incubator.foreign.MemoryAddress;
 52 import jdk.incubator.foreign.MemoryLayout;
 53 import jdk.incubator.foreign.MemorySegment;
 54 import jdk.incubator.foreign.NativeScope;
 55 import jdk.incubator.foreign.SequenceLayout;
 56 
 57 import static jdk.incubator.foreign.MemoryAccess.*;
 58 
 59 import org.testng.annotations.*;
 60 
 61 import static jdk.incubator.foreign.CSupport.*;
 62 import static org.testng.Assert.*;
 63 
 64 @Test
 65 public class StdLibTest extends NativeTestHelper {
 66 
 67     final static ForeignLinker abi = CSupport.getSystemLinker();
 68 
 69     private StdLibHelper stdLibHelper = new StdLibHelper();
 70 
 71     @Test(dataProvider = &quot;stringPairs&quot;)
 72     void test_strcat(String s1, String s2) throws Throwable {
 73         assertEquals(stdLibHelper.strcat(s1, s2), s1 + s2);
 74     }
 75 
 76     @Test(dataProvider = &quot;stringPairs&quot;)
 77     void test_strcmp(String s1, String s2) throws Throwable {
 78         assertEquals(Math.signum(stdLibHelper.strcmp(s1, s2)), Math.signum(s1.compareTo(s2)));
 79     }
 80 
 81     @Test(dataProvider = &quot;strings&quot;)
 82     void test_puts(String s) throws Throwable {
 83         assertTrue(stdLibHelper.puts(s) &gt;= 0);
 84     }
 85 
 86     @Test(dataProvider = &quot;strings&quot;)
 87     void test_strlen(String s) throws Throwable {
 88         assertEquals(stdLibHelper.strlen(s), s.length());
 89     }
 90 
 91     @Test(dataProvider = &quot;instants&quot;)
 92     void test_time(Instant instant) throws Throwable {
 93         StdLibHelper.Tm tm = stdLibHelper.gmtime(instant.getEpochSecond());
 94         LocalDateTime localTime = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);
 95         assertEquals(tm.sec(), localTime.getSecond());
 96         assertEquals(tm.min(), localTime.getMinute());
 97         assertEquals(tm.hour(), localTime.getHour());
 98         //day pf year in Java has 1-offset
 99         assertEquals(tm.yday(), localTime.getDayOfYear() - 1);
100         assertEquals(tm.mday(), localTime.getDayOfMonth());
101         //days of week starts from Sunday in C, but on Monday in Java, also account for 1-offset
102         assertEquals((tm.wday() + 6) % 7, localTime.getDayOfWeek().getValue() - 1);
103         //month in Java has 1-offset
104         assertEquals(tm.mon(), localTime.getMonth().getValue() - 1);
105         assertEquals(tm.isdst(), ZoneOffset.UTC.getRules()
106                 .isDaylightSavings(Instant.ofEpochMilli(instant.getEpochSecond() * 1000)));
107     }
108 
109     @Test(dataProvider = &quot;ints&quot;)
110     void test_qsort(List&lt;Integer&gt; ints) throws Throwable {
111         if (ints.size() &gt; 0) {
112             int[] input = ints.stream().mapToInt(i -&gt; i).toArray();
113             int[] sorted = stdLibHelper.qsort(input);
114             Arrays.sort(input);
115             assertEquals(sorted, input);
116         }
117     }
118 
119     @Test
120     void test_rand() throws Throwable {
121         int val = stdLibHelper.rand();
122         for (int i = 0 ; i &lt; 100 ; i++) {
123             int newVal = stdLibHelper.rand();
124             if (newVal != val) {
125                 return; //ok
126             }
127             val = newVal;
128         }
129         fail(&quot;All values are the same! &quot; + val);
130     }
131 
132     @Test(dataProvider = &quot;printfArgs&quot;)
133     void test_printf(List&lt;PrintfArg&gt; args) throws Throwable {
134         String formatArgs = args.stream()
135                 .map(a -&gt; a.format)
136                 .collect(Collectors.joining(&quot;,&quot;));
137 
138         String formatString = &quot;hello(&quot; + formatArgs + &quot;)\n&quot;;
139 
140         String expected = String.format(formatString, args.stream()
141                 .map(a -&gt; a.javaValue).toArray());
142 
143         int found = stdLibHelper.printf(formatString, args);
144         assertEquals(found, expected.length());
145     }
146 
147     @Test(dataProvider = &quot;printfArgs&quot;)
148     void test_vprintf(List&lt;PrintfArg&gt; args) throws Throwable {
149         String formatArgs = args.stream()
150                 .map(a -&gt; a.format)
151                 .collect(Collectors.joining(&quot;,&quot;));
152 
153         String formatString = &quot;hello(&quot; + formatArgs + &quot;)\n&quot;;
154 
155         String expected = String.format(formatString, args.stream()
156                 .map(a -&gt; a.javaValue).toArray());
157 
158         int found = stdLibHelper.vprintf(formatString, args);
159         assertEquals(found, expected.length());
160     }
161 
162     static class StdLibHelper {
163 
164         final static MethodHandle strcat;
165         final static MethodHandle strcmp;
166         final static MethodHandle puts;
167         final static MethodHandle strlen;
168         final static MethodHandle gmtime;
169         final static MethodHandle qsort;
170         final static MethodHandle qsortCompar;
171         final static FunctionDescriptor qsortComparFunction;
172         final static MethodHandle rand;
173         final static MethodHandle vprintf;
174         final static LibraryLookup.Symbol printfAddr;
175         final static FunctionDescriptor printfBase;
176 
177         static {
178             try {
179                 LibraryLookup lookup = LibraryLookup.ofDefault();
180 
181                 strcat = abi.downcallHandle(lookup.lookup(&quot;strcat&quot;),
182                         MethodType.methodType(MemoryAddress.class, MemoryAddress.class, MemoryAddress.class),
183                         FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER));
184 
185                 strcmp = abi.downcallHandle(lookup.lookup(&quot;strcmp&quot;),
186                         MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class),
187                         FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER));
188 
189                 puts = abi.downcallHandle(lookup.lookup(&quot;puts&quot;),
190                         MethodType.methodType(int.class, MemoryAddress.class),
191                         FunctionDescriptor.of(C_INT, C_POINTER));
192 
193                 strlen = abi.downcallHandle(lookup.lookup(&quot;strlen&quot;),
194                         MethodType.methodType(int.class, MemoryAddress.class),
195                         FunctionDescriptor.of(C_INT, C_POINTER));
196 
197                 gmtime = abi.downcallHandle(lookup.lookup(&quot;gmtime&quot;),
198                         MethodType.methodType(MemoryAddress.class, MemoryAddress.class),
199                         FunctionDescriptor.of(C_POINTER, C_POINTER));
200 
201                 qsortComparFunction = FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER);
202 
203                 qsort = abi.downcallHandle(lookup.lookup(&quot;qsort&quot;),
204                         MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),
205                         FunctionDescriptor.ofVoid(C_POINTER, C_LONGLONG, C_LONGLONG, C_POINTER));
206 
207                 //qsort upcall handle
208                 qsortCompar = MethodHandles.lookup().findStatic(StdLibTest.StdLibHelper.class, &quot;qsortCompare&quot;,
209                         MethodType.methodType(int.class, MemorySegment.class, MemoryAddress.class, MemoryAddress.class));
210 
211                 rand = abi.downcallHandle(lookup.lookup(&quot;rand&quot;),
212                         MethodType.methodType(int.class),
213                         FunctionDescriptor.of(C_INT));
214 
215                 vprintf = abi.downcallHandle(lookup.lookup(&quot;vprintf&quot;),
216                         MethodType.methodType(int.class, MemoryAddress.class, VaList.class),
217                         FunctionDescriptor.of(C_INT, C_POINTER, C_VA_LIST));
218 
219                 printfAddr = lookup.lookup(&quot;printf&quot;);
220 
221                 printfBase = FunctionDescriptor.of(C_INT, C_POINTER);
222             } catch (Throwable ex) {
223                 throw new IllegalStateException(ex);
224             }
225         }
226 
227         String strcat(String s1, String s2) throws Throwable {
228             try (MemorySegment buf = MemorySegment.allocateNative(s1.length() + s2.length() + 1) ;
229                  MemorySegment other = toCString(s2)) {
230                 char[] chars = s1.toCharArray();
231                 for (long i = 0 ; i &lt; chars.length ; i++) {
232                     setByteAtOffset(buf, i, (byte)chars[(int)i]);
233                 }
234                 setByteAtOffset(buf, chars.length, (byte)&#39;\0&#39;);
235                 return toJavaStringRestricted(((MemoryAddress)strcat.invokeExact(buf.address(), other.address())));
236             }
237         }
238 
239         int strcmp(String s1, String s2) throws Throwable {
240             try (MemorySegment ns1 = toCString(s1) ;
241                  MemorySegment ns2 = toCString(s2)) {
242                 return (int)strcmp.invokeExact(ns1.address(), ns2.address());
243             }
244         }
245 
246         int puts(String msg) throws Throwable {
247             try (MemorySegment s = toCString(msg)) {
248                 return (int)puts.invokeExact(s.address());
249             }
250         }
251 
252         int strlen(String msg) throws Throwable {
253             try (MemorySegment s = toCString(msg)) {
254                 return (int)strlen.invokeExact(s.address());
255             }
256         }
257 
258         Tm gmtime(long arg) throws Throwable {
259             try (MemorySegment time = MemorySegment.allocateNative(8)) {
260                 setLong(time, arg);
261                 return new Tm((MemoryAddress)gmtime.invokeExact(time.address()));
262             }
263         }
264 
265         static class Tm {
266 
267             //Tm pointer should never be freed directly, as it points to shared memory
268             private final MemorySegment base;
269 
270             static final long SIZE = 56;
271 
272             Tm(MemoryAddress addr) {
273                 this.base = MemorySegment.ofNativeRestricted(addr, SIZE, Thread.currentThread(),
274                         null, null);
275             }
276 
277             int sec() {
278                 return getIntAtOffset(base, 0);
279             }
280             int min() {
281                 return getIntAtOffset(base, 4);
282             }
283             int hour() {
284                 return getIntAtOffset(base, 8);
285             }
286             int mday() {
287                 return getIntAtOffset(base, 12);
288             }
289             int mon() {
290                 return getIntAtOffset(base, 16);
291             }
292             int year() {
293                 return getIntAtOffset(base, 20);
294             }
295             int wday() {
296                 return getIntAtOffset(base, 24);
297             }
298             int yday() {
299                 return getIntAtOffset(base, 28);
300             }
301             boolean isdst() {
302                 byte b = getByteAtOffset(base, 32);
303                 return b != 0;
304             }
305         }
306 
307         int[] qsort(int[] arr) throws Throwable {
308             //init native array
309             try (NativeScope scope = NativeScope.unboundedScope()) {
310 
311                 MemorySegment nativeArr = scope.allocateArray(C_INT, arr);
312 
313                 //call qsort
314                 MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar.bindTo(nativeArr), qsortComparFunction);
315                 qsortUpcallStub = scope.register(qsortUpcallStub);
316 
317                 qsort.invokeExact(nativeArr.address(), (long)arr.length, C_INT.byteSize(), qsortUpcallStub.address());
318 
319                 //convert back to Java array
320                 return nativeArr.toIntArray();
321             }
322         }
323 
324         static int qsortCompare(MemorySegment base, MemoryAddress addr1, MemoryAddress addr2) {
325             return getIntAtOffset(base, addr1.segmentOffset(base)) -
326                    getIntAtOffset(base, addr2.segmentOffset(base));
327         }
328 
329         int rand() throws Throwable {
330             return (int)rand.invokeExact();
331         }
332 
333         int printf(String format, List&lt;PrintfArg&gt; args) throws Throwable {
334             try (MemorySegment formatStr = toCString(format)) {
335                 return (int)specializedPrintf(args).invokeExact(formatStr.address(),
336                         args.stream().map(a -&gt; a.nativeValue).toArray());
337             }
338         }
339 
340         int vprintf(String format, List&lt;PrintfArg&gt; args) throws Throwable {
341             try (MemorySegment formatStr = toCString(format)) {
342                 VaList vaList = VaList.make(b -&gt; args.forEach(a -&gt; a.accept(b)));
343                 int result = (int)vprintf.invokeExact(formatStr.address(), vaList);
344                 try {
345                     vaList.close();
346                 }
347                 catch (UnsupportedOperationException e) {
348                     assertEquals(e.getMessage(), &quot;Empty VaList&quot;);
349                 }
350                 return result;
351             }
352         }
353 
354         private MethodHandle specializedPrintf(List&lt;PrintfArg&gt; args) {
355             //method type
356             MethodType mt = MethodType.methodType(int.class, MemoryAddress.class);
357             FunctionDescriptor fd = printfBase;
358             for (PrintfArg arg : args) {
359                 mt = mt.appendParameterTypes(arg.carrier);
360                 fd = fd.appendArgumentLayouts(arg.layout);
361             }
362             MethodHandle mh = abi.downcallHandle(printfAddr, mt, fd);
363             return mh.asSpreader(1, Object[].class, args.size());
364         }
365     }
366 
367     /*** data providers ***/
368 
369     @DataProvider
370     public static Object[][] ints() {
371         return perms(0, new Integer[] { 0, 1, 2, 3, 4 }).stream()
372                 .map(l -&gt; new Object[] { l })
373                 .toArray(Object[][]::new);
374     }
375 
376     @DataProvider
377     public static Object[][] strings() {
378         return perms(0, new String[] { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }).stream()
379                 .map(l -&gt; new Object[] { String.join(&quot;&quot;, l) })
380                 .toArray(Object[][]::new);
381     }
382 
383     @DataProvider
384     public static Object[][] stringPairs() {
385         Object[][] strings = strings();
386         Object[][] stringPairs = new Object[strings.length * strings.length][];
387         int pos = 0;
388         for (Object[] s1 : strings) {
389             for (Object[] s2 : strings) {
390                 stringPairs[pos++] = new Object[] { s1[0], s2[0] };
391             }
392         }
393         return stringPairs;
394     }
395 
396     @DataProvider
397     public static Object[][] instants() {
398         Instant start = ZonedDateTime.of(LocalDateTime.parse(&quot;2017-01-01T00:00:00&quot;), ZoneOffset.UTC).toInstant();
399         Instant end = ZonedDateTime.of(LocalDateTime.parse(&quot;2017-12-31T00:00:00&quot;), ZoneOffset.UTC).toInstant();
400         Object[][] instants = new Object[100][];
401         for (int i = 0 ; i &lt; instants.length ; i++) {
402             Instant instant = start.plusSeconds((long)(Math.random() * (end.getEpochSecond() - start.getEpochSecond())));
403             instants[i] = new Object[] { instant };
404         }
405         return instants;
406     }
407 
408     @DataProvider
409     public static Object[][] printfArgs() {
410         ArrayList&lt;List&lt;PrintfArg&gt;&gt; res = new ArrayList&lt;&gt;();
411         List&lt;List&lt;PrintfArg&gt;&gt; perms = new ArrayList&lt;&gt;(perms(0, PrintfArg.values()));
412         for (int i = 0 ; i &lt; 100 ; i++) {
413             Collections.shuffle(perms);
414             res.addAll(perms);
415         }
416         return res.stream()
417                 .map(l -&gt; new Object[] { l })
418                 .toArray(Object[][]::new);
419     }
420 
421     enum PrintfArg implements Consumer&lt;VaList.Builder&gt; {
422 
423         INTEGRAL(int.class, asVarArg(C_INT), &quot;%d&quot;, 42, 42, VaList.Builder::vargFromInt),
424         STRING(MemoryAddress.class, asVarArg(C_POINTER), &quot;%s&quot;, toCString(&quot;str&quot;).address(), &quot;str&quot;, VaList.Builder::vargFromAddress),
425         CHAR(byte.class, asVarArg(C_CHAR), &quot;%c&quot;, (byte) &#39;h&#39;, &#39;h&#39;, (builder, layout, value) -&gt; builder.vargFromInt(C_INT, (int)value)),
426         DOUBLE(double.class, asVarArg(C_DOUBLE), &quot;%.4f&quot;, 1.2345d, 1.2345d, VaList.Builder::vargFromDouble);
427 
428         final Class&lt;?&gt; carrier;
429         final MemoryLayout layout;
430         final String format;
431         final Object nativeValue;
432         final Object javaValue;
433         @SuppressWarnings(&quot;rawtypes&quot;)
434         final VaListBuilderCall builderCall;
435 
436         &lt;Z&gt; PrintfArg(Class&lt;?&gt; carrier, MemoryLayout layout, String format, Z nativeValue, Object javaValue, VaListBuilderCall&lt;Z&gt; builderCall) {
437             this.carrier = carrier;
438             this.layout = layout;
439             this.format = format;
440             this.nativeValue = nativeValue;
441             this.javaValue = javaValue;
442             this.builderCall = builderCall;
443         }
444 
445         @Override
446         @SuppressWarnings(&quot;unchecked&quot;)
447         public void accept(VaList.Builder builder) {
448             builderCall.build(builder, layout, nativeValue);
449         }
450 
451         interface VaListBuilderCall&lt;V&gt; {
452             void build(VaList.Builder builder, MemoryLayout layout, V value);
453         }
454     }
455 
456     static &lt;Z&gt; Set&lt;List&lt;Z&gt;&gt; perms(int count, Z[] arr) {
457         if (count == arr.length) {
458             return Set.of(List.of());
459         } else {
460             return Arrays.stream(arr)
461                     .flatMap(num -&gt; {
462                         Set&lt;List&lt;Z&gt;&gt; perms = perms(count + 1, arr);
463                         return Stream.concat(
464                                 //take n
465                                 perms.stream().map(l -&gt; {
466                                     List&lt;Z&gt; li = new ArrayList&lt;&gt;(l);
467                                     li.add(num);
468                                     return li;
469                                 }),
470                                 //drop n
471                                 perms.stream());
472                     }).collect(Collectors.toCollection(LinkedHashSet::new));
473         }
474     }
475 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
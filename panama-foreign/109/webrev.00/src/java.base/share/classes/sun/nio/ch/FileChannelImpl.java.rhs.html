<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.io.UncheckedIOException;
  31 import java.lang.ref.Cleaner.Cleanable;
  32 import java.nio.ByteBuffer;
  33 import java.nio.MappedByteBuffer;
  34 import java.nio.channels.AsynchronousCloseException;
  35 import java.nio.channels.ClosedByInterruptException;
  36 import java.nio.channels.ClosedChannelException;
  37 import java.nio.channels.FileChannel;
  38 import java.nio.channels.FileLock;
  39 import java.nio.channels.FileLockInterruptionException;
  40 import java.nio.channels.NonReadableChannelException;
  41 import java.nio.channels.NonWritableChannelException;
  42 import java.nio.channels.ReadableByteChannel;
  43 import java.nio.channels.SelectableChannel;
  44 import java.nio.channels.WritableByteChannel;
  45 import java.util.Objects;
  46 
  47 import jdk.internal.access.JavaIOFileDescriptorAccess;
  48 import jdk.internal.access.JavaNioAccess;
  49 import jdk.internal.access.SharedSecrets;
  50 import jdk.internal.misc.ExtendedMapMode;
  51 import jdk.internal.misc.Unsafe;
  52 import jdk.internal.misc.VM;
  53 import jdk.internal.ref.Cleaner;
  54 import jdk.internal.ref.CleanerFactory;
  55 
  56 import jdk.internal.access.foreign.UnmapperProxy;
  57 
  58 public class FileChannelImpl
  59     extends FileChannel
  60 {
  61     // Memory allocation size for mapping buffers
  62     private static final long allocationGranularity;
  63 
  64     // Access to FileDescriptor internals
  65     private static final JavaIOFileDescriptorAccess fdAccess =
  66         SharedSecrets.getJavaIOFileDescriptorAccess();
  67 
  68     // Used to make native read and write calls
  69     private final FileDispatcher nd;
  70 
  71     // File descriptor
  72     private final FileDescriptor fd;
  73 
  74     // File access mode (immutable)
  75     private final boolean writable;
  76     private final boolean readable;
  77 
  78     // Required to prevent finalization of creating stream (immutable)
  79     private final Object parent;
  80 
  81     // The path of the referenced file
  82     // (null if the parent stream is created with a file descriptor)
  83     private final String path;
  84 
  85     // Thread-safe set of IDs of native threads, for signalling
  86     private final NativeThreadSet threads = new NativeThreadSet(2);
  87 
  88     // Lock for operations involving position and size
  89     private final Object positionLock = new Object();
  90 
  91     // blocking operations are not interruptible
  92     private volatile boolean uninterruptible;
  93 
  94     // DirectIO flag
  95     private final boolean direct;
  96 
  97     // IO alignment value for DirectIO
  98     private final int alignment;
  99 
 100     // Cleanable with an action which closes this channel&#39;s file descriptor
 101     private final Cleanable closer;
 102 
 103     private static class Closer implements Runnable {
 104         private final FileDescriptor fd;
 105 
 106         Closer(FileDescriptor fd) {
 107             this.fd = fd;
 108         }
 109 
 110         public void run() {
 111             try {
 112                 fdAccess.close(fd);
 113             } catch (IOException ioe) {
 114                 // Rethrow as unchecked so the exception can be propagated as needed
 115                 throw new UncheckedIOException(&quot;close&quot;, ioe);
 116             }
 117         }
 118     }
 119 
 120     private FileChannelImpl(FileDescriptor fd, String path, boolean readable,
 121                             boolean writable, boolean direct, Object parent)
 122     {
 123         this.fd = fd;
 124         this.readable = readable;
 125         this.writable = writable;
 126         this.parent = parent;
 127         this.path = path;
 128         this.direct = direct;
 129         this.nd = new FileDispatcherImpl();
 130         if (direct) {
 131             assert path != null;
 132             this.alignment = nd.setDirectIO(fd, path);
 133         } else {
 134             this.alignment = -1;
 135         }
 136 
 137         // Register a cleaning action if and only if there is no parent
 138         // as the parent will take care of closing the file descriptor.
 139         // FileChannel is used by the LambdaMetaFactory so a lambda cannot
 140         // be used here hence we use a nested class instead.
 141         this.closer = parent != null ? null :
 142             CleanerFactory.cleaner().register(this, new Closer(fd));
 143     }
 144 
 145     // Used by FileInputStream.getChannel(), FileOutputStream.getChannel
 146     // and RandomAccessFile.getChannel()
 147     public static FileChannel open(FileDescriptor fd, String path,
 148                                    boolean readable, boolean writable,
 149                                    boolean direct, Object parent)
 150     {
 151         return new FileChannelImpl(fd, path, readable, writable, direct, parent);
 152     }
 153 
 154     private void ensureOpen() throws IOException {
 155         if (!isOpen())
 156             throw new ClosedChannelException();
 157     }
 158 
 159     public void setUninterruptible() {
 160         uninterruptible = true;
 161     }
 162 
 163     private void beginBlocking() {
 164         if (!uninterruptible) begin();
 165     }
 166 
 167     private void endBlocking(boolean completed) throws AsynchronousCloseException {
 168         if (!uninterruptible) end(completed);
 169     }
 170 
 171     // -- Standard channel operations --
 172 
 173     protected void implCloseChannel() throws IOException {
 174         if (!fd.valid())
 175             return; // nothing to do
 176 
 177         // Release and invalidate any locks that we still hold
 178         if (fileLockTable != null) {
 179             for (FileLock fl: fileLockTable.removeAll()) {
 180                 synchronized (fl) {
 181                     if (fl.isValid()) {
 182                         nd.release(fd, fl.position(), fl.size());
 183                         ((FileLockImpl)fl).invalidate();
 184                     }
 185                 }
 186             }
 187         }
 188 
 189         // signal any threads blocked on this channel
 190         threads.signalAndWait();
 191 
 192         if (parent != null) {
 193 
 194             // Close the fd via the parent stream&#39;s close method.  The parent
 195             // will reinvoke our close method, which is defined in the
 196             // superclass AbstractInterruptibleChannel, but the isOpen logic in
 197             // that method will prevent this method from being reinvoked.
 198             //
 199             ((java.io.Closeable)parent).close();
 200         } else if (closer != null) {
 201             // Perform the cleaning action so it is not redone when
 202             // this channel becomes phantom reachable.
 203             try {
 204                 closer.clean();
 205             } catch (UncheckedIOException uioe) {
 206                 throw uioe.getCause();
 207             }
 208         } else {
 209             fdAccess.close(fd);
 210         }
 211 
 212     }
 213 
 214     public int read(ByteBuffer dst) throws IOException {
 215         ensureOpen();
 216         if (!readable)
 217             throw new NonReadableChannelException();
 218         synchronized (positionLock) {
 219             if (direct)
 220                 Util.checkChannelPositionAligned(position(), alignment);
 221             int n = 0;
 222             int ti = -1;
 223             try {
 224                 beginBlocking();
 225                 ti = threads.add();
 226                 if (!isOpen())
 227                     return 0;
 228                 do {
 229                     n = IOUtil.read(fd, dst, -1, direct, alignment, nd);
 230                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 231                 return IOStatus.normalize(n);
 232             } finally {
 233                 threads.remove(ti);
 234                 endBlocking(n &gt; 0);
 235                 assert IOStatus.check(n);
 236             }
 237         }
 238     }
 239 
 240     public long read(ByteBuffer[] dsts, int offset, int length)
 241         throws IOException
 242     {
 243         if ((offset &lt; 0) || (length &lt; 0) || (offset &gt; dsts.length - length))
 244             throw new IndexOutOfBoundsException();
 245         ensureOpen();
 246         if (!readable)
 247             throw new NonReadableChannelException();
 248         synchronized (positionLock) {
 249             if (direct)
 250                 Util.checkChannelPositionAligned(position(), alignment);
 251             long n = 0;
 252             int ti = -1;
 253             try {
 254                 beginBlocking();
 255                 ti = threads.add();
 256                 if (!isOpen())
 257                     return 0;
 258                 do {
 259                     n = IOUtil.read(fd, dsts, offset, length,
 260                             direct, alignment, nd);
 261                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 262                 return IOStatus.normalize(n);
 263             } finally {
 264                 threads.remove(ti);
 265                 endBlocking(n &gt; 0);
 266                 assert IOStatus.check(n);
 267             }
 268         }
 269     }
 270 
 271     public int write(ByteBuffer src) throws IOException {
 272         ensureOpen();
 273         if (!writable)
 274             throw new NonWritableChannelException();
 275         synchronized (positionLock) {
 276             if (direct)
 277                 Util.checkChannelPositionAligned(position(), alignment);
 278             int n = 0;
 279             int ti = -1;
 280             try {
 281                 beginBlocking();
 282                 ti = threads.add();
 283                 if (!isOpen())
 284                     return 0;
 285                 do {
 286                     n = IOUtil.write(fd, src, -1, direct, alignment, nd);
 287                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 288                 return IOStatus.normalize(n);
 289             } finally {
 290                 threads.remove(ti);
 291                 endBlocking(n &gt; 0);
 292                 assert IOStatus.check(n);
 293             }
 294         }
 295     }
 296 
 297     public long write(ByteBuffer[] srcs, int offset, int length)
 298         throws IOException
 299     {
 300         if ((offset &lt; 0) || (length &lt; 0) || (offset &gt; srcs.length - length))
 301             throw new IndexOutOfBoundsException();
 302         ensureOpen();
 303         if (!writable)
 304             throw new NonWritableChannelException();
 305         synchronized (positionLock) {
 306             if (direct)
 307                 Util.checkChannelPositionAligned(position(), alignment);
 308             long n = 0;
 309             int ti = -1;
 310             try {
 311                 beginBlocking();
 312                 ti = threads.add();
 313                 if (!isOpen())
 314                     return 0;
 315                 do {
 316                     n = IOUtil.write(fd, srcs, offset, length,
 317                             direct, alignment, nd);
 318                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 319                 return IOStatus.normalize(n);
 320             } finally {
 321                 threads.remove(ti);
 322                 endBlocking(n &gt; 0);
 323                 assert IOStatus.check(n);
 324             }
 325         }
 326     }
 327 
 328     // -- Other operations --
 329 
 330     public long position() throws IOException {
 331         ensureOpen();
 332         synchronized (positionLock) {
 333             long p = -1;
 334             int ti = -1;
 335             try {
 336                 beginBlocking();
 337                 ti = threads.add();
 338                 if (!isOpen())
 339                     return 0;
 340                 boolean append = fdAccess.getAppend(fd);
 341                 do {
 342                     // in append-mode then position is advanced to end before writing
 343                     p = (append) ? nd.size(fd) : nd.seek(fd, -1);
 344                 } while ((p == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 345                 return IOStatus.normalize(p);
 346             } finally {
 347                 threads.remove(ti);
 348                 endBlocking(p &gt; -1);
 349                 assert IOStatus.check(p);
 350             }
 351         }
 352     }
 353 
 354     public FileChannel position(long newPosition) throws IOException {
 355         ensureOpen();
 356         if (newPosition &lt; 0)
 357             throw new IllegalArgumentException();
 358         synchronized (positionLock) {
 359             long p = -1;
 360             int ti = -1;
 361             try {
 362                 beginBlocking();
 363                 ti = threads.add();
 364                 if (!isOpen())
 365                     return null;
 366                 do {
 367                     p = nd.seek(fd, newPosition);
 368                 } while ((p == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 369                 return this;
 370             } finally {
 371                 threads.remove(ti);
 372                 endBlocking(p &gt; -1);
 373                 assert IOStatus.check(p);
 374             }
 375         }
 376     }
 377 
 378     public long size() throws IOException {
 379         ensureOpen();
 380         synchronized (positionLock) {
 381             long s = -1;
 382             int ti = -1;
 383             try {
 384                 beginBlocking();
 385                 ti = threads.add();
 386                 if (!isOpen())
 387                     return -1;
 388                 do {
 389                     s = nd.size(fd);
 390                 } while ((s == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 391                 return IOStatus.normalize(s);
 392             } finally {
 393                 threads.remove(ti);
 394                 endBlocking(s &gt; -1);
 395                 assert IOStatus.check(s);
 396             }
 397         }
 398     }
 399 
 400     public FileChannel truncate(long newSize) throws IOException {
 401         ensureOpen();
 402         if (newSize &lt; 0)
 403             throw new IllegalArgumentException(&quot;Negative size&quot;);
 404         if (!writable)
 405             throw new NonWritableChannelException();
 406         synchronized (positionLock) {
 407             int rv = -1;
 408             long p = -1;
 409             int ti = -1;
 410             long rp = -1;
 411             try {
 412                 beginBlocking();
 413                 ti = threads.add();
 414                 if (!isOpen())
 415                     return null;
 416 
 417                 // get current size
 418                 long size;
 419                 do {
 420                     size = nd.size(fd);
 421                 } while ((size == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 422                 if (!isOpen())
 423                     return null;
 424 
 425                 // get current position
 426                 do {
 427                     p = nd.seek(fd, -1);
 428                 } while ((p == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 429                 if (!isOpen())
 430                     return null;
 431                 assert p &gt;= 0;
 432 
 433                 // truncate file if given size is less than the current size
 434                 if (newSize &lt; size) {
 435                     do {
 436                         rv = nd.truncate(fd, newSize);
 437                     } while ((rv == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 438                     if (!isOpen())
 439                         return null;
 440                 }
 441 
 442                 // if position is beyond new size then adjust it
 443                 if (p &gt; newSize)
 444                     p = newSize;
 445                 do {
 446                     rp = nd.seek(fd, p);
 447                 } while ((rp == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 448                 return this;
 449             } finally {
 450                 threads.remove(ti);
 451                 endBlocking(rv &gt; -1);
 452                 assert IOStatus.check(rv);
 453             }
 454         }
 455     }
 456 
 457     public void force(boolean metaData) throws IOException {
 458         ensureOpen();
 459         int rv = -1;
 460         int ti = -1;
 461         try {
 462             beginBlocking();
 463             ti = threads.add();
 464             if (!isOpen())
 465                 return;
 466             do {
 467                 rv = nd.force(fd, metaData);
 468             } while ((rv == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 469         } finally {
 470             threads.remove(ti);
 471             endBlocking(rv &gt; -1);
 472             assert IOStatus.check(rv);
 473         }
 474     }
 475 
 476     // Assume at first that the underlying kernel supports sendfile();
 477     // set this to false if we find out later that it doesn&#39;t
 478     //
 479     private static volatile boolean transferSupported = true;
 480 
 481     // Assume that the underlying kernel sendfile() will work if the target
 482     // fd is a pipe; set this to false if we find out later that it doesn&#39;t
 483     //
 484     private static volatile boolean pipeSupported = true;
 485 
 486     // Assume that the underlying kernel sendfile() will work if the target
 487     // fd is a file; set this to false if we find out later that it doesn&#39;t
 488     //
 489     private static volatile boolean fileSupported = true;
 490 
 491     private long transferToDirectlyInternal(long position, int icount,
 492                                             WritableByteChannel target,
 493                                             FileDescriptor targetFD)
 494         throws IOException
 495     {
 496         assert !nd.transferToDirectlyNeedsPositionLock() ||
 497                Thread.holdsLock(positionLock);
 498 
 499         long n = -1;
 500         int ti = -1;
 501         try {
 502             beginBlocking();
 503             ti = threads.add();
 504             if (!isOpen())
 505                 return -1;
 506             do {
 507                 n = transferTo0(fd, position, icount, targetFD);
 508             } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 509             if (n == IOStatus.UNSUPPORTED_CASE) {
 510                 if (target instanceof SinkChannelImpl)
 511                     pipeSupported = false;
 512                 if (target instanceof FileChannelImpl)
 513                     fileSupported = false;
 514                 return IOStatus.UNSUPPORTED_CASE;
 515             }
 516             if (n == IOStatus.UNSUPPORTED) {
 517                 // Don&#39;t bother trying again
 518                 transferSupported = false;
 519                 return IOStatus.UNSUPPORTED;
 520             }
 521             return IOStatus.normalize(n);
 522         } finally {
 523             threads.remove(ti);
 524             end (n &gt; -1);
 525         }
 526     }
 527 
 528     private long transferToDirectly(long position, int icount,
 529                                     WritableByteChannel target)
 530         throws IOException
 531     {
 532         if (!transferSupported)
 533             return IOStatus.UNSUPPORTED;
 534 
 535         FileDescriptor targetFD = null;
 536         if (target instanceof FileChannelImpl) {
 537             if (!fileSupported)
 538                 return IOStatus.UNSUPPORTED_CASE;
 539             targetFD = ((FileChannelImpl)target).fd;
 540         } else if (target instanceof SelChImpl) {
 541             // Direct transfer to pipe causes EINVAL on some configurations
 542             if ((target instanceof SinkChannelImpl) &amp;&amp; !pipeSupported)
 543                 return IOStatus.UNSUPPORTED_CASE;
 544 
 545             // Platform-specific restrictions. Now there is only one:
 546             // Direct transfer to non-blocking channel could be forbidden
 547             SelectableChannel sc = (SelectableChannel)target;
 548             if (!nd.canTransferToDirectly(sc))
 549                 return IOStatus.UNSUPPORTED_CASE;
 550 
 551             targetFD = ((SelChImpl)target).getFD();
 552         }
 553 
 554         if (targetFD == null)
 555             return IOStatus.UNSUPPORTED;
 556         int thisFDVal = IOUtil.fdVal(fd);
 557         int targetFDVal = IOUtil.fdVal(targetFD);
 558         if (thisFDVal == targetFDVal) // Not supported on some configurations
 559             return IOStatus.UNSUPPORTED;
 560 
 561         if (nd.transferToDirectlyNeedsPositionLock()) {
 562             synchronized (positionLock) {
 563                 long pos = position();
 564                 try {
 565                     return transferToDirectlyInternal(position, icount,
 566                                                       target, targetFD);
 567                 } finally {
 568                     position(pos);
 569                 }
 570             }
 571         } else {
 572             return transferToDirectlyInternal(position, icount, target, targetFD);
 573         }
 574     }
 575 
 576     // Maximum size to map when using a mapped buffer
 577     private static final long MAPPED_TRANSFER_SIZE = 8L*1024L*1024L;
 578 
 579     private long transferToTrustedChannel(long position, long count,
 580                                           WritableByteChannel target)
 581         throws IOException
 582     {
 583         boolean isSelChImpl = (target instanceof SelChImpl);
 584         if (!((target instanceof FileChannelImpl) || isSelChImpl))
 585             return IOStatus.UNSUPPORTED;
 586 
 587         // Trusted target: Use a mapped buffer
 588         long remaining = count;
 589         while (remaining &gt; 0L) {
 590             long size = Math.min(remaining, MAPPED_TRANSFER_SIZE);
 591             try {
 592                 MappedByteBuffer dbb = map(MapMode.READ_ONLY, position, size);
 593                 try {
 594                     // ## Bug: Closing this channel will not terminate the write
 595                     int n = target.write(dbb);
 596                     assert n &gt;= 0;
 597                     remaining -= n;
 598                     if (isSelChImpl) {
 599                         // one attempt to write to selectable channel
 600                         break;
 601                     }
 602                     assert n &gt; 0;
 603                     position += n;
 604                 } finally {
 605                     unmap(dbb);
 606                 }
 607             } catch (ClosedByInterruptException e) {
 608                 // target closed by interrupt as ClosedByInterruptException needs
 609                 // to be thrown after closing this channel.
 610                 assert !target.isOpen();
 611                 try {
 612                     close();
 613                 } catch (Throwable suppressed) {
 614                     e.addSuppressed(suppressed);
 615                 }
 616                 throw e;
 617             } catch (IOException ioe) {
 618                 // Only throw exception if no bytes have been written
 619                 if (remaining == count)
 620                     throw ioe;
 621                 break;
 622             }
 623         }
 624         return count - remaining;
 625     }
 626 
 627     private long transferToArbitraryChannel(long position, int icount,
 628                                             WritableByteChannel target)
 629         throws IOException
 630     {
 631         // Untrusted target: Use a newly-erased buffer
 632         int c = Math.min(icount, TRANSFER_SIZE);
 633         ByteBuffer bb = ByteBuffer.allocate(c);
 634         long tw = 0;                    // Total bytes written
 635         long pos = position;
 636         try {
 637             while (tw &lt; icount) {
 638                 bb.limit(Math.min((int)(icount - tw), TRANSFER_SIZE));
 639                 int nr = read(bb, pos);
 640                 if (nr &lt;= 0)
 641                     break;
 642                 bb.flip();
 643                 // ## Bug: Will block writing target if this channel
 644                 // ##      is asynchronously closed
 645                 int nw = target.write(bb);
 646                 tw += nw;
 647                 if (nw != nr)
 648                     break;
 649                 pos += nw;
 650                 bb.clear();
 651             }
 652             return tw;
 653         } catch (IOException x) {
 654             if (tw &gt; 0)
 655                 return tw;
 656             throw x;
 657         }
 658     }
 659 
 660     public long transferTo(long position, long count,
 661                            WritableByteChannel target)
 662         throws IOException
 663     {
 664         ensureOpen();
 665         if (!target.isOpen())
 666             throw new ClosedChannelException();
 667         if (!readable)
 668             throw new NonReadableChannelException();
 669         if (target instanceof FileChannelImpl &amp;&amp;
 670             !((FileChannelImpl)target).writable)
 671             throw new NonWritableChannelException();
 672         if ((position &lt; 0) || (count &lt; 0))
 673             throw new IllegalArgumentException();
 674         long sz = size();
 675         if (position &gt; sz)
 676             return 0;
 677         int icount = (int)Math.min(count, Integer.MAX_VALUE);
 678         if ((sz - position) &lt; icount)
 679             icount = (int)(sz - position);
 680 
 681         long n;
 682 
 683         // Attempt a direct transfer, if the kernel supports it
 684         if ((n = transferToDirectly(position, icount, target)) &gt;= 0)
 685             return n;
 686 
 687         // Attempt a mapped transfer, but only to trusted channel types
 688         if ((n = transferToTrustedChannel(position, icount, target)) &gt;= 0)
 689             return n;
 690 
 691         // Slow path for untrusted targets
 692         return transferToArbitraryChannel(position, icount, target);
 693     }
 694 
 695     private long transferFromFileChannel(FileChannelImpl src,
 696                                          long position, long count)
 697         throws IOException
 698     {
 699         if (!src.readable)
 700             throw new NonReadableChannelException();
 701         synchronized (src.positionLock) {
 702             long pos = src.position();
 703             long max = Math.min(count, src.size() - pos);
 704 
 705             long remaining = max;
 706             long p = pos;
 707             while (remaining &gt; 0L) {
 708                 long size = Math.min(remaining, MAPPED_TRANSFER_SIZE);
 709                 // ## Bug: Closing this channel will not terminate the write
 710                 MappedByteBuffer bb = src.map(MapMode.READ_ONLY, p, size);
 711                 try {
 712                     long n = write(bb, position);
 713                     assert n &gt; 0;
 714                     p += n;
 715                     position += n;
 716                     remaining -= n;
 717                 } catch (IOException ioe) {
 718                     // Only throw exception if no bytes have been written
 719                     if (remaining == max)
 720                         throw ioe;
 721                     break;
 722                 } finally {
 723                     unmap(bb);
 724                 }
 725             }
 726             long nwritten = max - remaining;
 727             src.position(pos + nwritten);
 728             return nwritten;
 729         }
 730     }
 731 
 732     private static final int TRANSFER_SIZE = 8192;
 733 
 734     private long transferFromArbitraryChannel(ReadableByteChannel src,
 735                                               long position, long count)
 736         throws IOException
 737     {
 738         // Untrusted target: Use a newly-erased buffer
 739         int c = (int)Math.min(count, TRANSFER_SIZE);
 740         ByteBuffer bb = ByteBuffer.allocate(c);
 741         long tw = 0;                    // Total bytes written
 742         long pos = position;
 743         try {
 744             while (tw &lt; count) {
 745                 bb.limit((int)Math.min((count - tw), (long)TRANSFER_SIZE));
 746                 // ## Bug: Will block reading src if this channel
 747                 // ##      is asynchronously closed
 748                 int nr = src.read(bb);
 749                 if (nr &lt;= 0)
 750                     break;
 751                 bb.flip();
 752                 int nw = write(bb, pos);
 753                 tw += nw;
 754                 if (nw != nr)
 755                     break;
 756                 pos += nw;
 757                 bb.clear();
 758             }
 759             return tw;
 760         } catch (IOException x) {
 761             if (tw &gt; 0)
 762                 return tw;
 763             throw x;
 764         }
 765     }
 766 
 767     public long transferFrom(ReadableByteChannel src,
 768                              long position, long count)
 769         throws IOException
 770     {
 771         ensureOpen();
 772         if (!src.isOpen())
 773             throw new ClosedChannelException();
 774         if (!writable)
 775             throw new NonWritableChannelException();
 776         if ((position &lt; 0) || (count &lt; 0))
 777             throw new IllegalArgumentException();
 778         if (position &gt; size())
 779             return 0;
 780         if (src instanceof FileChannelImpl)
 781            return transferFromFileChannel((FileChannelImpl)src,
 782                                           position, count);
 783 
 784         return transferFromArbitraryChannel(src, position, count);
 785     }
 786 
 787     public int read(ByteBuffer dst, long position) throws IOException {
 788         if (dst == null)
 789             throw new NullPointerException();
 790         if (position &lt; 0)
 791             throw new IllegalArgumentException(&quot;Negative position&quot;);
 792         if (!readable)
 793             throw new NonReadableChannelException();
 794         if (direct)
 795             Util.checkChannelPositionAligned(position, alignment);
 796         ensureOpen();
 797         if (nd.needsPositionLock()) {
 798             synchronized (positionLock) {
 799                 return readInternal(dst, position);
 800             }
 801         } else {
 802             return readInternal(dst, position);
 803         }
 804     }
 805 
 806     private int readInternal(ByteBuffer dst, long position) throws IOException {
 807         assert !nd.needsPositionLock() || Thread.holdsLock(positionLock);
 808         int n = 0;
 809         int ti = -1;
 810 
 811         try {
 812             beginBlocking();
 813             ti = threads.add();
 814             if (!isOpen())
 815                 return -1;
 816             do {
 817                 n = IOUtil.read(fd, dst, position, direct, alignment, nd);
 818             } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 819             return IOStatus.normalize(n);
 820         } finally {
 821             threads.remove(ti);
 822             endBlocking(n &gt; 0);
 823             assert IOStatus.check(n);
 824         }
 825     }
 826 
 827     public int write(ByteBuffer src, long position) throws IOException {
 828         if (src == null)
 829             throw new NullPointerException();
 830         if (position &lt; 0)
 831             throw new IllegalArgumentException(&quot;Negative position&quot;);
 832         if (!writable)
 833             throw new NonWritableChannelException();
 834         if (direct)
 835             Util.checkChannelPositionAligned(position, alignment);
 836         ensureOpen();
 837         if (nd.needsPositionLock()) {
 838             synchronized (positionLock) {
 839                 return writeInternal(src, position);
 840             }
 841         } else {
 842             return writeInternal(src, position);
 843         }
 844     }
 845 
 846     private int writeInternal(ByteBuffer src, long position) throws IOException {
 847         assert !nd.needsPositionLock() || Thread.holdsLock(positionLock);
 848         int n = 0;
 849         int ti = -1;
 850         try {
 851             beginBlocking();
 852             ti = threads.add();
 853             if (!isOpen())
 854                 return -1;
 855             do {
 856                 n = IOUtil.write(fd, src, position, direct, alignment, nd);
 857             } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 858             return IOStatus.normalize(n);
 859         } finally {
 860             threads.remove(ti);
 861             endBlocking(n &gt; 0);
 862             assert IOStatus.check(n);
 863         }
 864     }
 865 
 866 
 867     // -- Memory-mapped buffers --
 868 
 869     private static abstract class Unmapper
 870         implements Runnable, UnmapperProxy
 871     {
 872         // may be required to close file
 873         private static final NativeDispatcher nd = new FileDispatcherImpl();
 874 
 875         private volatile long address;
 876         protected final long size;
 877         protected final long cap;
 878         private final FileDescriptor fd;
 879         private final int pagePosition;
 880 
 881         private Unmapper(long address, long size, long cap,
 882                          FileDescriptor fd, int pagePosition)
 883         {
 884             assert (address != 0);
 885             this.address = address;
 886             this.size = size;
 887             this.cap = cap;
 888             this.fd = fd;
 889             this.pagePosition = pagePosition;
 890         }
 891 
 892         @Override
 893         public long address() {
 894             return address;
 895         }
 896 
<a name="1" id="anc1"></a><span class="line-added"> 897         @Override</span>
<span class="line-added"> 898         public FileDescriptor fileDescriptor() {</span>
<span class="line-added"> 899             return fd;</span>
<span class="line-added"> 900         }</span>
<span class="line-added"> 901 </span>
 902         @Override
 903         public void run() {
 904             unmap();
 905         }
 906 
 907         public void unmap() {
 908             if (address == 0)
 909                 return;
 910             unmap0(address, size);
 911             address = 0;
 912 
 913             // if this mapping has a valid file descriptor then we close it
 914             if (fd.valid()) {
 915                 try {
 916                     nd.close(fd);
 917                 } catch (IOException ignore) {
 918                     // nothing we can do
 919                 }
 920             }
 921 
 922             decrementStats();
 923         }
 924         protected abstract void incrementStats();
 925         protected abstract void decrementStats();
 926     }
 927 
 928     private static class DefaultUnmapper extends Unmapper {
 929 
 930         // keep track of non-sync mapped buffer usage
 931         static volatile int count;
 932         static volatile long totalSize;
 933         static volatile long totalCapacity;
 934 
 935         public DefaultUnmapper(long address, long size, long cap,
 936                                FileDescriptor fd, int pagePosition) {
 937             super(address, size, cap, fd, pagePosition);
 938             incrementStats();
 939         }
 940 
 941         protected void incrementStats() {
 942             synchronized (DefaultUnmapper.class) {
 943                 count++;
 944                 totalSize += size;
 945                 totalCapacity += cap;
 946             }
 947         }
 948         protected void decrementStats() {
 949             synchronized (DefaultUnmapper.class) {
 950                 count--;
 951                 totalSize -= size;
 952                 totalCapacity -= cap;
 953             }
 954         }
<a name="2" id="anc2"></a><span class="line-added"> 955 </span>
<span class="line-added"> 956         public boolean isSync() {</span>
<span class="line-added"> 957             return false;</span>
<span class="line-added"> 958         }</span>
 959     }
 960 
 961     private static class SyncUnmapper extends Unmapper {
 962 
 963         // keep track of mapped buffer usage
 964         static volatile int count;
 965         static volatile long totalSize;
 966         static volatile long totalCapacity;
 967 
 968         public SyncUnmapper(long address, long size, long cap,
 969                             FileDescriptor fd, int pagePosition) {
 970             super(address, size, cap, fd, pagePosition);
 971             incrementStats();
 972         }
 973 
 974         protected void incrementStats() {
 975             synchronized (SyncUnmapper.class) {
 976                 count++;
 977                 totalSize += size;
 978                 totalCapacity += cap;
 979             }
 980         }
 981         protected void decrementStats() {
 982             synchronized (SyncUnmapper.class) {
 983                 count--;
 984                 totalSize -= size;
 985                 totalCapacity -= cap;
 986             }
 987         }
<a name="3" id="anc3"></a><span class="line-added"> 988 </span>
<span class="line-added"> 989         public boolean isSync() {</span>
<span class="line-added"> 990             return true;</span>
<span class="line-added"> 991         }</span>
 992     }
 993 
 994     private static void unmap(MappedByteBuffer bb) {
 995         Cleaner cl = ((DirectBuffer)bb).cleaner();
 996         if (cl != null)
 997             cl.clean();
 998     }
 999 
1000     private static final int MAP_INVALID = -1;
1001     private static final int MAP_RO = 0;
1002     private static final int MAP_RW = 1;
1003     private static final int MAP_PV = 2;
1004 
1005     public MappedByteBuffer map(MapMode mode, long position, long size) throws IOException {
1006         if (size &gt; Integer.MAX_VALUE)
1007             throw new IllegalArgumentException(&quot;Size exceeds Integer.MAX_VALUE&quot;);
1008         boolean isSync = isSync(Objects.requireNonNull(mode, &quot;Mode is null&quot;));
1009         int prot = toProt(mode);
1010         Unmapper unmapper = mapInternal(mode, position, size, prot, isSync);
1011         if (unmapper == null) {
1012             // a valid file descriptor is not required
1013             FileDescriptor dummy = new FileDescriptor();
1014             if ((!writable) || (prot == MAP_RO))
1015                 return Util.newMappedByteBufferR(0, 0, dummy, null, isSync);
1016             else
1017                 return Util.newMappedByteBuffer(0, 0, dummy, null, isSync);
1018         } else if ((!writable) || (prot == MAP_RO)) {
1019             return Util.newMappedByteBufferR((int)unmapper.cap,
1020                     unmapper.address + unmapper.pagePosition,
1021                     unmapper.fd,
1022                     unmapper, isSync);
1023         } else {
1024             return Util.newMappedByteBuffer((int)unmapper.cap,
1025                     unmapper.address + unmapper.pagePosition,
1026                     unmapper.fd,
1027                     unmapper, isSync);
1028         }
1029     }
1030 
1031     public Unmapper mapInternal(MapMode mode, long position, long size) throws IOException {
1032         boolean isSync = isSync(Objects.requireNonNull(mode, &quot;Mode is null&quot;));
1033         int prot = toProt(mode);
1034         return mapInternal(mode, position, size, prot, isSync);
1035     }
1036 
1037     private Unmapper mapInternal(MapMode mode, long position, long size, int prot, boolean isSync)
1038         throws IOException
1039     {
1040         ensureOpen();
1041         if (mode == null)
1042             throw new NullPointerException(&quot;Mode is null&quot;);
1043         if (position &lt; 0L)
1044             throw new IllegalArgumentException(&quot;Negative position&quot;);
1045         if (size &lt; 0L)
1046             throw new IllegalArgumentException(&quot;Negative size&quot;);
1047         if (position + size &lt; 0)
1048             throw new IllegalArgumentException(&quot;Position + size overflow&quot;);
1049 
1050         checkMode(mode, prot, isSync);
1051         long addr = -1;
1052         int ti = -1;
1053         try {
1054             beginBlocking();
1055             ti = threads.add();
1056             if (!isOpen())
1057                 return null;
1058 
1059             long mapSize;
1060             int pagePosition;
1061             synchronized (positionLock) {
1062                 long filesize;
1063                 do {
1064                     filesize = nd.size(fd);
1065                 } while ((filesize == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
1066                 if (!isOpen())
1067                     return null;
1068 
1069                 if (filesize &lt; position + size) { // Extend file size
1070                     if (!writable) {
1071                         throw new IOException(&quot;Channel not open for writing &quot; +
1072                             &quot;- cannot extend file to required size&quot;);
1073                     }
1074                     int rv;
1075                     do {
1076                         rv = nd.truncate(fd, position + size);
1077                     } while ((rv == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
1078                     if (!isOpen())
1079                         return null;
1080                 }
1081 
1082                 if (size == 0) {
1083                     return null;
1084                 }
1085 
1086                 pagePosition = (int)(position % allocationGranularity);
1087                 long mapPosition = position - pagePosition;
1088                 mapSize = size + pagePosition;
1089                 try {
1090                     // If map0 did not throw an exception, the address is valid
1091                     addr = map0(prot, mapPosition, mapSize, isSync);
1092                 } catch (OutOfMemoryError x) {
1093                     // An OutOfMemoryError may indicate that we&#39;ve exhausted
1094                     // memory so force gc and re-attempt map
1095                     System.gc();
1096                     try {
1097                         Thread.sleep(100);
1098                     } catch (InterruptedException y) {
1099                         Thread.currentThread().interrupt();
1100                     }
1101                     try {
1102                         addr = map0(prot, mapPosition, mapSize, isSync);
1103                     } catch (OutOfMemoryError y) {
1104                         // After a second OOME, fail
1105                         throw new IOException(&quot;Map failed&quot;, y);
1106                     }
1107                 }
1108             } // synchronized
1109 
1110             // On Windows, and potentially other platforms, we need an open
1111             // file descriptor for some mapping operations.
1112             FileDescriptor mfd;
1113             try {
1114                 mfd = nd.duplicateForMapping(fd);
1115             } catch (IOException ioe) {
1116                 unmap0(addr, mapSize);
1117                 throw ioe;
1118             }
1119 
1120             assert (IOStatus.checkAll(addr));
1121             assert (addr % allocationGranularity == 0);
1122             Unmapper um = (isSync
1123                            ? new SyncUnmapper(addr, mapSize, size, mfd, pagePosition)
1124                            : new DefaultUnmapper(addr, mapSize, size, mfd, pagePosition));
1125             return um;
1126         } finally {
1127             threads.remove(ti);
1128             endBlocking(IOStatus.checkAll(addr));
1129         }
1130     }
1131 
1132     private boolean isSync(MapMode mode) {
1133         // Do not want to initialize ExtendedMapMode until
1134         // after the module system has been initialized
1135         return !VM.isModuleSystemInited() ? false :
1136             (mode == ExtendedMapMode.READ_ONLY_SYNC ||
1137                 mode == ExtendedMapMode.READ_WRITE_SYNC);
1138     }
1139 
1140     private int toProt(MapMode mode) {
1141         int prot;
1142         if (mode == MapMode.READ_ONLY) {
1143             prot = MAP_RO;
1144         } else if (mode == MapMode.READ_WRITE) {
1145             prot = MAP_RW;
1146         } else if (mode == MapMode.PRIVATE) {
1147             prot = MAP_PV;
1148         } else if (mode == ExtendedMapMode.READ_ONLY_SYNC) {
1149             prot = MAP_RO;
1150         } else if (mode == ExtendedMapMode.READ_WRITE_SYNC) {
1151             prot = MAP_RW;
1152         } else {
1153             prot = MAP_INVALID;
1154         }
1155         return prot;
1156     }
1157 
1158     private void checkMode(MapMode mode, int prot, boolean isSync) {
1159         if (prot == MAP_INVALID) {
1160             throw new UnsupportedOperationException();
1161         }
1162         if ((mode != MapMode.READ_ONLY) &amp;&amp; mode != ExtendedMapMode.READ_ONLY_SYNC &amp;&amp; !writable)
1163             throw new NonWritableChannelException();
1164         if (!readable)
1165             throw new NonReadableChannelException();
1166         // reject SYNC request if writeback is not enabled for this platform
1167         if (isSync &amp;&amp; !Unsafe.isWritebackEnabled()) {
1168             throw new UnsupportedOperationException();
1169         }
1170     }
1171 
1172     /**
1173      * Invoked by sun.management.ManagementFactoryHelper to create the management
1174      * interface for mapped buffers.
1175      */
1176     public static JavaNioAccess.BufferPool getMappedBufferPool() {
1177         return new JavaNioAccess.BufferPool() {
1178             @Override
1179             public String getName() {
1180                 return &quot;mapped&quot;;
1181             }
1182             @Override
1183             public long getCount() {
1184                 return DefaultUnmapper.count;
1185             }
1186             @Override
1187             public long getTotalCapacity() {
1188                 return DefaultUnmapper.totalCapacity;
1189             }
1190             @Override
1191             public long getMemoryUsed() {
1192                 return DefaultUnmapper.totalSize;
1193             }
1194         };
1195     }
1196 
1197     /**
1198      * Invoked by sun.management.ManagementFactoryHelper to create the management
1199      * interface for sync mapped buffers.
1200      */
1201     public static JavaNioAccess.BufferPool getSyncMappedBufferPool() {
1202         return new JavaNioAccess.BufferPool() {
1203             @Override
1204             public String getName() {
1205                 return &quot;mapped - &#39;non-volatile memory&#39;&quot;;
1206             }
1207             @Override
1208             public long getCount() {
1209                 return SyncUnmapper.count;
1210             }
1211             @Override
1212             public long getTotalCapacity() {
1213                 return SyncUnmapper.totalCapacity;
1214             }
1215             @Override
1216             public long getMemoryUsed() {
1217                 return SyncUnmapper.totalSize;
1218             }
1219         };
1220     }
1221 
1222     // -- Locks --
1223 
1224     // keeps track of locks on this file
1225     private volatile FileLockTable fileLockTable;
1226 
1227     private FileLockTable fileLockTable() throws IOException {
1228         if (fileLockTable == null) {
1229             synchronized (this) {
1230                 if (fileLockTable == null) {
1231                     int ti = threads.add();
1232                     try {
1233                         ensureOpen();
1234                         fileLockTable = new FileLockTable(this, fd);
1235                     } finally {
1236                         threads.remove(ti);
1237                     }
1238                 }
1239             }
1240         }
1241         return fileLockTable;
1242     }
1243 
1244     public FileLock lock(long position, long size, boolean shared)
1245         throws IOException
1246     {
1247         ensureOpen();
1248         if (shared &amp;&amp; !readable)
1249             throw new NonReadableChannelException();
1250         if (!shared &amp;&amp; !writable)
1251             throw new NonWritableChannelException();
1252         FileLockImpl fli = new FileLockImpl(this, position, size, shared);
1253         FileLockTable flt = fileLockTable();
1254         flt.add(fli);
1255         boolean completed = false;
1256         int ti = -1;
1257         try {
1258             beginBlocking();
1259             ti = threads.add();
1260             if (!isOpen())
1261                 return null;
1262             int n;
1263             do {
1264                 n = nd.lock(fd, true, position, size, shared);
1265             } while ((n == FileDispatcher.INTERRUPTED) &amp;&amp; isOpen());
1266             if (isOpen()) {
1267                 if (n == FileDispatcher.RET_EX_LOCK) {
1268                     assert shared;
1269                     FileLockImpl fli2 = new FileLockImpl(this, position, size,
1270                                                          false);
1271                     flt.replace(fli, fli2);
1272                     fli = fli2;
1273                 }
1274                 completed = true;
1275             }
1276         } finally {
1277             if (!completed)
1278                 flt.remove(fli);
1279             threads.remove(ti);
1280             try {
1281                 endBlocking(completed);
1282             } catch (ClosedByInterruptException e) {
1283                 throw new FileLockInterruptionException();
1284             }
1285         }
1286         return fli;
1287     }
1288 
1289     public FileLock tryLock(long position, long size, boolean shared)
1290         throws IOException
1291     {
1292         ensureOpen();
1293         if (shared &amp;&amp; !readable)
1294             throw new NonReadableChannelException();
1295         if (!shared &amp;&amp; !writable)
1296             throw new NonWritableChannelException();
1297         FileLockImpl fli = new FileLockImpl(this, position, size, shared);
1298         FileLockTable flt = fileLockTable();
1299         flt.add(fli);
1300         int result;
1301 
1302         int ti = threads.add();
1303         try {
1304             try {
1305                 ensureOpen();
1306                 result = nd.lock(fd, false, position, size, shared);
1307             } catch (IOException e) {
1308                 flt.remove(fli);
1309                 throw e;
1310             }
1311             if (result == FileDispatcher.NO_LOCK) {
1312                 flt.remove(fli);
1313                 return null;
1314             }
1315             if (result == FileDispatcher.RET_EX_LOCK) {
1316                 assert shared;
1317                 FileLockImpl fli2 = new FileLockImpl(this, position, size,
1318                                                      false);
1319                 flt.replace(fli, fli2);
1320                 return fli2;
1321             }
1322             return fli;
1323         } finally {
1324             threads.remove(ti);
1325         }
1326     }
1327 
1328     void release(FileLockImpl fli) throws IOException {
1329         int ti = threads.add();
1330         try {
1331             ensureOpen();
1332             nd.release(fd, fli.position(), fli.size());
1333         } finally {
1334             threads.remove(ti);
1335         }
1336         assert fileLockTable != null;
1337         fileLockTable.remove(fli);
1338     }
1339 
1340     // -- Native methods --
1341 
1342     // Creates a new mapping
1343     private native long map0(int prot, long position, long length, boolean isSync)
1344         throws IOException;
1345 
1346     // Removes an existing mapping
1347     private static native int unmap0(long address, long length);
1348 
1349     // Transfers from src to dst, or returns -2 if kernel can&#39;t do that
1350     private native long transferTo0(FileDescriptor src, long position,
1351                                     long count, FileDescriptor dst);
1352 
1353     // Caches fieldIDs
1354     private static native long initIDs();
1355 
1356     static {
1357         IOUtil.load();
1358         allocationGranularity = initIDs();
1359     }
1360 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
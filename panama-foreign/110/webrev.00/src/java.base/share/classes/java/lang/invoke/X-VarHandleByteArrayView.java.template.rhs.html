<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package java.lang.invoke;
  26 
  27 import jdk.internal.access.JavaNioAccess;
  28 import jdk.internal.access.SharedSecrets;
<a name="1" id="anc1"></a><span class="line-added">  29 import jdk.internal.access.foreign.MemorySegmentProxy;</span>
  30 import jdk.internal.misc.Unsafe;
  31 import jdk.internal.util.Preconditions;
  32 import jdk.internal.vm.annotation.ForceInline;
  33 
  34 import java.nio.ByteBuffer;
  35 import java.nio.ReadOnlyBufferException;
  36 import java.util.Objects;
  37 
  38 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  39 
  40 #warn
  41 
  42 final class VarHandleByteArrayAs$Type$s extends VarHandleByteArrayBase {
  43 
  44     static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
  45 
  46     static final int ALIGN = $BoxType$.BYTES - 1;
  47 
  48 #if[floatingPoint]
  49     @ForceInline
  50     static $rawType$ convEndian(boolean big, $type$ v) {
  51         $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
  52         return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
  53     }
  54 
  55     @ForceInline
  56     static $type$ convEndian(boolean big, $rawType$ rv) {
  57         rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);
  58         return $Type$.$rawType$BitsTo$Type$(rv);
  59     }
  60 #else[floatingPoint]
  61     @ForceInline
  62     static $type$ convEndian(boolean big, $type$ n) {
  63         return big == BE ? n : $BoxType$.reverseBytes(n);
  64     }
  65 #end[floatingPoint]
  66 
  67 
  68     private static abstract class ByteArrayViewVarHandle extends VarHandle {
  69         final boolean be;
  70 
  71         ByteArrayViewVarHandle(VarForm form, boolean be) {
  72             super(form);
  73             this.be = be;
  74         }
  75     }
  76 
  77     static final class ArrayHandle extends ByteArrayViewVarHandle {
  78 
  79         ArrayHandle(boolean be) {
  80             super(ArrayHandle.FORM, be);
  81         }
  82 
  83         @Override
  84         final MethodType accessModeTypeUncached(AccessMode accessMode) {
  85             return accessMode.at.accessModeType(byte[].class, $type$.class, int.class);
  86         }
  87 
  88         @ForceInline
  89         static int index(byte[] ba, int index) {
  90             return Preconditions.checkIndex(index, ba.length - ALIGN, null);
  91         }
  92 
  93         @ForceInline
  94         static long address(byte[] ba, int index) {
  95             long address = ((long) index) + Unsafe.ARRAY_BYTE_BASE_OFFSET;
  96             if ((address &amp; ALIGN) != 0)
  97                 throw newIllegalStateExceptionForMisalignedAccess(index);
  98             return address;
  99         }
 100 
 101         @ForceInline
 102         static $type$ get(VarHandle ob, Object oba, int index) {
 103             ArrayHandle handle = (ArrayHandle)ob;
 104             byte[] ba = (byte[]) oba;
 105 #if[floatingPoint]
 106             $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
 107                     ba,
 108                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
 109                     handle.be);
 110             return $Type$.$rawType$BitsTo$Type$(rawValue);
 111 #else[floatingPoint]
 112             return UNSAFE.get$Type$Unaligned(
 113                     ba,
 114                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
 115                     handle.be);
 116 #end[floatingPoint]
 117         }
 118 
 119         @ForceInline
 120         static void set(VarHandle ob, Object oba, int index, $type$ value) {
 121             ArrayHandle handle = (ArrayHandle)ob;
 122             byte[] ba = (byte[]) oba;
 123 #if[floatingPoint]
 124             UNSAFE.put$RawType$Unaligned(
 125                     ba,
 126                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
 127                     $Type$.$type$ToRaw$RawType$Bits(value),
 128                     handle.be);
 129 #else[floatingPoint]
 130             UNSAFE.put$RawType$Unaligned(
 131                     ba,
 132                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
 133                     value,
 134                     handle.be);
 135 #end[floatingPoint]
 136         }
 137 
 138         @ForceInline
 139         static $type$ getVolatile(VarHandle ob, Object oba, int index) {
 140             ArrayHandle handle = (ArrayHandle)ob;
 141             byte[] ba = (byte[]) oba;
 142             return convEndian(handle.be,
 143                               UNSAFE.get$RawType$Volatile(
 144                                       ba,
 145                                       address(ba, index(ba, index))));
 146         }
 147 
 148         @ForceInline
 149         static void setVolatile(VarHandle ob, Object oba, int index, $type$ value) {
 150             ArrayHandle handle = (ArrayHandle)ob;
 151             byte[] ba = (byte[]) oba;
 152             UNSAFE.put$RawType$Volatile(
 153                     ba,
 154                     address(ba, index(ba, index)),
 155                     convEndian(handle.be, value));
 156         }
 157 
 158         @ForceInline
 159         static $type$ getAcquire(VarHandle ob, Object oba, int index) {
 160             ArrayHandle handle = (ArrayHandle)ob;
 161             byte[] ba = (byte[]) oba;
 162             return convEndian(handle.be,
 163                               UNSAFE.get$RawType$Acquire(
 164                                       ba,
 165                                       address(ba, index(ba, index))));
 166         }
 167 
 168         @ForceInline
 169         static void setRelease(VarHandle ob, Object oba, int index, $type$ value) {
 170             ArrayHandle handle = (ArrayHandle)ob;
 171             byte[] ba = (byte[]) oba;
 172             UNSAFE.put$RawType$Release(
 173                     ba,
 174                     address(ba, index(ba, index)),
 175                     convEndian(handle.be, value));
 176         }
 177 
 178         @ForceInline
 179         static $type$ getOpaque(VarHandle ob, Object oba, int index) {
 180             ArrayHandle handle = (ArrayHandle)ob;
 181             byte[] ba = (byte[]) oba;
 182             return convEndian(handle.be,
 183                               UNSAFE.get$RawType$Opaque(
 184                                       ba,
 185                                       address(ba, index(ba, index))));
 186         }
 187 
 188         @ForceInline
 189         static void setOpaque(VarHandle ob, Object oba, int index, $type$ value) {
 190             ArrayHandle handle = (ArrayHandle)ob;
 191             byte[] ba = (byte[]) oba;
 192             UNSAFE.put$RawType$Opaque(
 193                     ba,
 194                     address(ba, index(ba, index)),
 195                     convEndian(handle.be, value));
 196         }
 197 #if[CAS]
 198 
 199         @ForceInline
 200         static boolean compareAndSet(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {
 201             ArrayHandle handle = (ArrayHandle)ob;
 202             byte[] ba = (byte[]) oba;
 203 #if[Object]
 204             return UNSAFE.compareAndSetReference(
 205                     ba,
 206                     address(ba, index(ba, index)),
 207                     convEndian(handle.be, expected), convEndian(handle.be, value));
 208 #else[Object]
 209             return UNSAFE.compareAndSet$RawType$(
 210                     ba,
 211                     address(ba, index(ba, index)),
 212                     convEndian(handle.be, expected), convEndian(handle.be, value));
 213 #end[Object]
 214         }
 215 
 216         @ForceInline
 217         static $type$ compareAndExchange(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {
 218             ArrayHandle handle = (ArrayHandle)ob;
 219             byte[] ba = (byte[]) oba;
 220             return convEndian(handle.be,
 221                               UNSAFE.compareAndExchange$RawType$(
 222                                       ba,
 223                                       address(ba, index(ba, index)),
 224                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 225         }
 226 
 227         @ForceInline
 228         static $type$ compareAndExchangeAcquire(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {
 229             ArrayHandle handle = (ArrayHandle)ob;
 230             byte[] ba = (byte[]) oba;
 231             return convEndian(handle.be,
 232                               UNSAFE.compareAndExchange$RawType$Acquire(
 233                                       ba,
 234                                       address(ba, index(ba, index)),
 235                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 236         }
 237 
 238         @ForceInline
 239         static $type$ compareAndExchangeRelease(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {
 240             ArrayHandle handle = (ArrayHandle)ob;
 241             byte[] ba = (byte[]) oba;
 242             return convEndian(handle.be,
 243                               UNSAFE.compareAndExchange$RawType$Release(
 244                                       ba,
 245                                       address(ba, index(ba, index)),
 246                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 247         }
 248 
 249         @ForceInline
 250         static boolean weakCompareAndSetPlain(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {
 251             ArrayHandle handle = (ArrayHandle)ob;
 252             byte[] ba = (byte[]) oba;
 253             return UNSAFE.weakCompareAndSet$RawType$Plain(
 254                     ba,
 255                     address(ba, index(ba, index)),
 256                     convEndian(handle.be, expected), convEndian(handle.be, value));
 257         }
 258 
 259         @ForceInline
 260         static boolean weakCompareAndSet(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {
 261             ArrayHandle handle = (ArrayHandle)ob;
 262             byte[] ba = (byte[]) oba;
 263             return UNSAFE.weakCompareAndSet$RawType$(
 264                     ba,
 265                     address(ba, index(ba, index)),
 266                     convEndian(handle.be, expected), convEndian(handle.be, value));
 267         }
 268 
 269         @ForceInline
 270         static boolean weakCompareAndSetAcquire(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {
 271             ArrayHandle handle = (ArrayHandle)ob;
 272             byte[] ba = (byte[]) oba;
 273             return UNSAFE.weakCompareAndSet$RawType$Acquire(
 274                     ba,
 275                     address(ba, index(ba, index)),
 276                     convEndian(handle.be, expected), convEndian(handle.be, value));
 277         }
 278 
 279         @ForceInline
 280         static boolean weakCompareAndSetRelease(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {
 281             ArrayHandle handle = (ArrayHandle)ob;
 282             byte[] ba = (byte[]) oba;
 283             return UNSAFE.weakCompareAndSet$RawType$Release(
 284                     ba,
 285                     address(ba, index(ba, index)),
 286                     convEndian(handle.be, expected), convEndian(handle.be, value));
 287         }
 288 
 289         @ForceInline
 290         static $type$ getAndSet(VarHandle ob, Object oba, int index, $type$ value) {
 291             ArrayHandle handle = (ArrayHandle)ob;
 292             byte[] ba = (byte[]) oba;
 293 #if[Object]
 294             return convEndian(handle.be,
 295                               UNSAFE.getAndSetReference(
 296                                       ba,
 297                                       address(ba, index(ba, index)),
 298                                       convEndian(handle.be, value)));
 299 #else[Object]
 300             return convEndian(handle.be,
 301                               UNSAFE.getAndSet$RawType$(
 302                                       ba,
 303                                       address(ba, index(ba, index)),
 304                                       convEndian(handle.be, value)));
 305 #end[Object]
 306         }
 307 
 308         @ForceInline
 309         static $type$ getAndSetAcquire(VarHandle ob, Object oba, int index, $type$ value) {
 310             ArrayHandle handle = (ArrayHandle)ob;
 311             byte[] ba = (byte[]) oba;
 312             return convEndian(handle.be,
 313                               UNSAFE.getAndSet$RawType$Acquire(
 314                                       ba,
 315                                       address(ba, index(ba, index)),
 316                                       convEndian(handle.be, value)));
 317         }
 318 
 319         @ForceInline
 320         static $type$ getAndSetRelease(VarHandle ob, Object oba, int index, $type$ value) {
 321             ArrayHandle handle = (ArrayHandle)ob;
 322             byte[] ba = (byte[]) oba;
 323             return convEndian(handle.be,
 324                               UNSAFE.getAndSet$RawType$Release(
 325                                       ba,
 326                                       address(ba, index(ba, index)),
 327                                       convEndian(handle.be, value)));
 328         }
 329 #end[CAS]
 330 #if[AtomicAdd]
 331 
 332         @ForceInline
 333         static $type$ getAndAdd(VarHandle ob, Object oba, int index, $type$ delta) {
 334             ArrayHandle handle = (ArrayHandle)ob;
 335             byte[] ba = (byte[]) oba;
 336             if (handle.be == BE) {
 337                 return UNSAFE.getAndAdd$RawType$(
 338                         ba,
 339                         address(ba, index(ba, index)),
 340                         delta);
 341             } else {
 342                 return getAndAddConvEndianWithCAS(ba, index, delta);
 343             }
 344         }
 345 
 346         @ForceInline
 347         static $type$ getAndAddAcquire(VarHandle ob, Object oba, int index, $type$ delta) {
 348             ArrayHandle handle = (ArrayHandle)ob;
 349             byte[] ba = (byte[]) oba;
 350             if (handle.be == BE) {
 351                 return UNSAFE.getAndAdd$RawType$Acquire(
 352                         ba,
 353                         address(ba, index(ba, index)),
 354                         delta);
 355             } else {
 356                 return getAndAddConvEndianWithCAS(ba, index, delta);
 357             }
 358         }
 359 
 360         @ForceInline
 361         static $type$ getAndAddRelease(VarHandle ob, Object oba, int index, $type$ delta) {
 362             ArrayHandle handle = (ArrayHandle)ob;
 363             byte[] ba = (byte[]) oba;
 364             if (handle.be == BE) {
 365                 return UNSAFE.getAndAdd$RawType$Release(
 366                         ba,
 367                         address(ba, index(ba, index)),
 368                         delta);
 369             } else {
 370                 return getAndAddConvEndianWithCAS(ba, index, delta);
 371             }
 372         }
 373 
 374         @ForceInline
 375         static $type$ getAndAddConvEndianWithCAS(byte[] ba, int index, $type$ delta) {
 376             $type$ nativeExpectedValue, expectedValue;
 377             long offset = address(ba, index(ba, index));
 378             do {
 379                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
 380                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 381             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
 382                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
 383             return expectedValue;
 384         }
 385 #end[AtomicAdd]
 386 #if[Bitwise]
 387 
 388         @ForceInline
 389         static $type$ getAndBitwiseOr(VarHandle ob, Object oba, int index, $type$ value) {
 390             ArrayHandle handle = (ArrayHandle)ob;
 391             byte[] ba = (byte[]) oba;
 392             if (handle.be == BE) {
 393                 return UNSAFE.getAndBitwiseOr$RawType$(
 394                         ba,
 395                         address(ba, index(ba, index)),
 396                         value);
 397             } else {
 398                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
 399             }
 400         }
 401 
 402         @ForceInline
 403         static $type$ getAndBitwiseOrRelease(VarHandle ob, Object oba, int index, $type$ value) {
 404             ArrayHandle handle = (ArrayHandle)ob;
 405             byte[] ba = (byte[]) oba;
 406             if (handle.be == BE) {
 407                 return UNSAFE.getAndBitwiseOr$RawType$Release(
 408                         ba,
 409                         address(ba, index(ba, index)),
 410                         value);
 411             } else {
 412                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
 413             }
 414         }
 415 
 416         @ForceInline
 417         static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object oba, int index, $type$ value) {
 418             ArrayHandle handle = (ArrayHandle)ob;
 419             byte[] ba = (byte[]) oba;
 420             if (handle.be == BE) {
 421                 return UNSAFE.getAndBitwiseOr$RawType$Acquire(
 422                         ba,
 423                         address(ba, index(ba, index)),
 424                         value);
 425             } else {
 426                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
 427             }
 428         }
 429 
 430         @ForceInline
 431         static $type$ getAndBitwiseOrConvEndianWithCAS(byte[] ba, int index, $type$ value) {
 432             $type$ nativeExpectedValue, expectedValue;
 433             long offset = address(ba, index(ba, index));
 434             do {
 435                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
 436                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 437             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
 438                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
 439             return expectedValue;
 440         }
 441 
 442         @ForceInline
 443         static $type$ getAndBitwiseAnd(VarHandle ob, Object oba, int index, $type$ value) {
 444             ArrayHandle handle = (ArrayHandle)ob;
 445             byte[] ba = (byte[]) oba;
 446             if (handle.be == BE) {
 447                 return UNSAFE.getAndBitwiseAnd$RawType$(
 448                         ba,
 449                         address(ba, index(ba, index)),
 450                         value);
 451             } else {
 452                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
 453             }
 454         }
 455 
 456         @ForceInline
 457         static $type$ getAndBitwiseAndRelease(VarHandle ob, Object oba, int index, $type$ value) {
 458             ArrayHandle handle = (ArrayHandle)ob;
 459             byte[] ba = (byte[]) oba;
 460             if (handle.be == BE) {
 461                 return UNSAFE.getAndBitwiseAnd$RawType$Release(
 462                         ba,
 463                         address(ba, index(ba, index)),
 464                         value);
 465             } else {
 466                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
 467             }
 468         }
 469 
 470         @ForceInline
 471         static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object oba, int index, $type$ value) {
 472             ArrayHandle handle = (ArrayHandle)ob;
 473             byte[] ba = (byte[]) oba;
 474             if (handle.be == BE) {
 475                 return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
 476                         ba,
 477                         address(ba, index(ba, index)),
 478                         value);
 479             } else {
 480                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
 481             }
 482         }
 483 
 484         @ForceInline
 485         static $type$ getAndBitwiseAndConvEndianWithCAS(byte[] ba, int index, $type$ value) {
 486             $type$ nativeExpectedValue, expectedValue;
 487             long offset = address(ba, index(ba, index));
 488             do {
 489                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
 490                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 491             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
 492                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
 493             return expectedValue;
 494         }
 495 
 496         @ForceInline
 497         static $type$ getAndBitwiseXor(VarHandle ob, Object oba, int index, $type$ value) {
 498             ArrayHandle handle = (ArrayHandle)ob;
 499             byte[] ba = (byte[]) oba;
 500             if (handle.be == BE) {
 501                 return UNSAFE.getAndBitwiseXor$RawType$(
 502                         ba,
 503                         address(ba, index(ba, index)),
 504                         value);
 505             } else {
 506                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
 507             }
 508         }
 509 
 510         @ForceInline
 511         static $type$ getAndBitwiseXorRelease(VarHandle ob, Object oba, int index, $type$ value) {
 512             ArrayHandle handle = (ArrayHandle)ob;
 513             byte[] ba = (byte[]) oba;
 514             if (handle.be == BE) {
 515                 return UNSAFE.getAndBitwiseXor$RawType$Release(
 516                         ba,
 517                         address(ba, index(ba, index)),
 518                         value);
 519             } else {
 520                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
 521             }
 522         }
 523 
 524         @ForceInline
 525         static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object oba, int index, $type$ value) {
 526             ArrayHandle handle = (ArrayHandle)ob;
 527             byte[] ba = (byte[]) oba;
 528             if (handle.be == BE) {
 529                 return UNSAFE.getAndBitwiseXor$RawType$Acquire(
 530                         ba,
 531                         address(ba, index(ba, index)),
 532                         value);
 533             } else {
 534                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
 535             }
 536         }
 537 
 538         @ForceInline
 539         static $type$ getAndBitwiseXorConvEndianWithCAS(byte[] ba, int index, $type$ value) {
 540             $type$ nativeExpectedValue, expectedValue;
 541             long offset = address(ba, index(ba, index));
 542             do {
 543                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
 544                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 545             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
 546                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
 547             return expectedValue;
 548         }
 549 #end[Bitwise]
 550 
 551         static final VarForm FORM = new VarForm(ArrayHandle.class, byte[].class, $type$.class, int.class);
 552     }
 553 
 554 
 555     static final class ByteBufferHandle extends ByteArrayViewVarHandle {
 556 
 557         ByteBufferHandle(boolean be) {
 558             super(ByteBufferHandle.FORM, be);
 559         }
 560 
 561         @Override
 562         final MethodType accessModeTypeUncached(AccessMode accessMode) {
 563             return accessMode.at.accessModeType(ByteBuffer.class, $type$.class, int.class);
 564         }
 565 
 566         @ForceInline
 567         static int index(ByteBuffer bb, int index) {
<a name="2" id="anc2"></a><span class="line-modified"> 568             MemorySegmentProxy segmentProxy = nioAccess.bufferSegment(bb);</span>
<span class="line-added"> 569             if (segmentProxy != null) {</span>
<span class="line-added"> 570                 segmentProxy.checkValidState();</span>
<span class="line-added"> 571             }</span>
 572             return Preconditions.checkIndex(index, UNSAFE.getInt(bb, BUFFER_LIMIT) - ALIGN, null);
 573         }
 574 
 575         @ForceInline
 576         static int indexRO(ByteBuffer bb, int index) {
 577             if (UNSAFE.getBoolean(bb, BYTE_BUFFER_IS_READ_ONLY))
 578                 throw new ReadOnlyBufferException();
 579             return index(bb, index);
 580         }
 581 
 582         @ForceInline
 583         static long address(ByteBuffer bb, int index) {
 584             long address = ((long) index) + UNSAFE.getLong(bb, BUFFER_ADDRESS);
 585             if ((address &amp; ALIGN) != 0)
 586                 throw newIllegalStateExceptionForMisalignedAccess(index);
 587             return address;
 588         }
 589 
 590         @ForceInline
 591         static $type$ get(VarHandle ob, Object obb, int index) {
 592             ByteBufferHandle handle = (ByteBufferHandle)ob;
 593             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 594 #if[floatingPoint]
 595             $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
 596                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 597                     ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
 598                     handle.be);
 599             return $Type$.$rawType$BitsTo$Type$(rawValue);
 600 #else[floatingPoint]
 601             return UNSAFE.get$Type$Unaligned(
 602                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 603                     ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
 604                     handle.be);
 605 #end[floatingPoint]
 606         }
 607 
 608         @ForceInline
 609         static void set(VarHandle ob, Object obb, int index, $type$ value) {
 610             ByteBufferHandle handle = (ByteBufferHandle)ob;
 611             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 612 #if[floatingPoint]
 613             UNSAFE.put$RawType$Unaligned(
 614                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 615                     ((long) indexRO(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
 616                     $Type$.$type$ToRaw$RawType$Bits(value),
 617                     handle.be);
 618 #else[floatingPoint]
 619             UNSAFE.put$Type$Unaligned(
 620                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 621                     ((long) indexRO(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
 622                     value,
 623                     handle.be);
 624 #end[floatingPoint]
 625         }
 626 
 627         @ForceInline
 628         static $type$ getVolatile(VarHandle ob, Object obb, int index) {
 629             ByteBufferHandle handle = (ByteBufferHandle)ob;
 630             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 631             return convEndian(handle.be,
 632                               UNSAFE.get$RawType$Volatile(
 633                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 634                                       address(bb, index(bb, index))));
 635         }
 636 
 637         @ForceInline
 638         static void setVolatile(VarHandle ob, Object obb, int index, $type$ value) {
 639             ByteBufferHandle handle = (ByteBufferHandle)ob;
 640             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 641             UNSAFE.put$RawType$Volatile(
 642                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 643                     address(bb, indexRO(bb, index)),
 644                     convEndian(handle.be, value));
 645         }
 646 
 647         @ForceInline
 648         static $type$ getAcquire(VarHandle ob, Object obb, int index) {
 649             ByteBufferHandle handle = (ByteBufferHandle)ob;
 650             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 651             return convEndian(handle.be,
 652                               UNSAFE.get$RawType$Acquire(
 653                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 654                                       address(bb, index(bb, index))));
 655         }
 656 
 657         @ForceInline
 658         static void setRelease(VarHandle ob, Object obb, int index, $type$ value) {
 659             ByteBufferHandle handle = (ByteBufferHandle)ob;
 660             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 661             UNSAFE.put$RawType$Release(
 662                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 663                     address(bb, indexRO(bb, index)),
 664                     convEndian(handle.be, value));
 665         }
 666 
 667         @ForceInline
 668         static $type$ getOpaque(VarHandle ob, Object obb, int index) {
 669             ByteBufferHandle handle = (ByteBufferHandle)ob;
 670             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 671             return convEndian(handle.be,
 672                               UNSAFE.get$RawType$Opaque(
 673                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 674                                       address(bb, index(bb, index))));
 675         }
 676 
 677         @ForceInline
 678         static void setOpaque(VarHandle ob, Object obb, int index, $type$ value) {
 679             ByteBufferHandle handle = (ByteBufferHandle)ob;
 680             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 681             UNSAFE.put$RawType$Opaque(
 682                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 683                     address(bb, indexRO(bb, index)),
 684                     convEndian(handle.be, value));
 685         }
 686 #if[CAS]
 687 
 688         @ForceInline
 689         static boolean compareAndSet(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {
 690             ByteBufferHandle handle = (ByteBufferHandle)ob;
 691             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 692 #if[Object]
 693             return UNSAFE.compareAndSetReference(
 694                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 695                     address(bb, indexRO(bb, index)),
 696                     convEndian(handle.be, expected), convEndian(handle.be, value));
 697 #else[Object]
 698             return UNSAFE.compareAndSet$RawType$(
 699                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 700                     address(bb, indexRO(bb, index)),
 701                     convEndian(handle.be, expected), convEndian(handle.be, value));
 702 #end[Object]
 703         }
 704 
 705         @ForceInline
 706         static $type$ compareAndExchange(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {
 707             ByteBufferHandle handle = (ByteBufferHandle)ob;
 708             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 709             return convEndian(handle.be,
 710                               UNSAFE.compareAndExchange$RawType$(
 711                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 712                                       address(bb, indexRO(bb, index)),
 713                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 714         }
 715 
 716         @ForceInline
 717         static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {
 718             ByteBufferHandle handle = (ByteBufferHandle)ob;
 719             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 720             return convEndian(handle.be,
 721                               UNSAFE.compareAndExchange$RawType$Acquire(
 722                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 723                                       address(bb, indexRO(bb, index)),
 724                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 725         }
 726 
 727         @ForceInline
 728         static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {
 729             ByteBufferHandle handle = (ByteBufferHandle)ob;
 730             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 731             return convEndian(handle.be,
 732                               UNSAFE.compareAndExchange$RawType$Release(
 733                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 734                                       address(bb, indexRO(bb, index)),
 735                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 736         }
 737 
 738         @ForceInline
 739         static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {
 740             ByteBufferHandle handle = (ByteBufferHandle)ob;
 741             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 742             return UNSAFE.weakCompareAndSet$RawType$Plain(
 743                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 744                     address(bb, indexRO(bb, index)),
 745                     convEndian(handle.be, expected), convEndian(handle.be, value));
 746         }
 747 
 748         @ForceInline
 749         static boolean weakCompareAndSet(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {
 750             ByteBufferHandle handle = (ByteBufferHandle)ob;
 751             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 752             return UNSAFE.weakCompareAndSet$RawType$(
 753                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 754                     address(bb, indexRO(bb, index)),
 755                     convEndian(handle.be, expected), convEndian(handle.be, value));
 756         }
 757 
 758         @ForceInline
 759         static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {
 760             ByteBufferHandle handle = (ByteBufferHandle)ob;
 761             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 762             return UNSAFE.weakCompareAndSet$RawType$Acquire(
 763                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 764                     address(bb, indexRO(bb, index)),
 765                     convEndian(handle.be, expected), convEndian(handle.be, value));
 766         }
 767 
 768         @ForceInline
 769         static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {
 770             ByteBufferHandle handle = (ByteBufferHandle)ob;
 771             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 772             return UNSAFE.weakCompareAndSet$RawType$Release(
 773                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 774                     address(bb, indexRO(bb, index)),
 775                     convEndian(handle.be, expected), convEndian(handle.be, value));
 776         }
 777 
 778         @ForceInline
 779         static $type$ getAndSet(VarHandle ob, Object obb, int index, $type$ value) {
 780             ByteBufferHandle handle = (ByteBufferHandle)ob;
 781             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 782 #if[Object]
 783             return convEndian(handle.be,
 784                               UNSAFE.getAndSetReference(
 785                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 786                                       address(bb, indexRO(bb, index)),
 787                                       convEndian(handle.be, value)));
 788 #else[Object]
 789             return convEndian(handle.be,
 790                               UNSAFE.getAndSet$RawType$(
 791                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 792                                       address(bb, indexRO(bb, index)),
 793                                       convEndian(handle.be, value)));
 794 #end[Object]
 795         }
 796 
 797         @ForceInline
 798         static $type$ getAndSetAcquire(VarHandle ob, Object obb, int index, $type$ value) {
 799             ByteBufferHandle handle = (ByteBufferHandle)ob;
 800             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 801             return convEndian(handle.be,
 802                               UNSAFE.getAndSet$RawType$Acquire(
 803                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 804                                       address(bb, indexRO(bb, index)),
 805                                       convEndian(handle.be, value)));
 806         }
 807 
 808         @ForceInline
 809         static $type$ getAndSetRelease(VarHandle ob, Object obb, int index, $type$ value) {
 810             ByteBufferHandle handle = (ByteBufferHandle)ob;
 811             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 812             return convEndian(handle.be,
 813                               UNSAFE.getAndSet$RawType$Release(
 814                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 815                                       address(bb, indexRO(bb, index)),
 816                                       convEndian(handle.be, value)));
 817         }
 818 #end[CAS]
 819 #if[AtomicAdd]
 820 
 821         @ForceInline
 822         static $type$ getAndAdd(VarHandle ob, Object obb, int index, $type$ delta) {
 823             ByteBufferHandle handle = (ByteBufferHandle)ob;
 824             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 825             if (handle.be == BE) {
 826                 return UNSAFE.getAndAdd$RawType$(
 827                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 828                         address(bb, indexRO(bb, index)),
 829                         delta);
 830             } else {
 831                 return getAndAddConvEndianWithCAS(bb, index, delta);
 832             }
 833         }
 834 
 835         @ForceInline
 836         static $type$ getAndAddAcquire(VarHandle ob, Object obb, int index, $type$ delta) {
 837             ByteBufferHandle handle = (ByteBufferHandle)ob;
 838             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 839             if (handle.be == BE) {
 840                 return UNSAFE.getAndAdd$RawType$Acquire(
 841                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 842                         address(bb, indexRO(bb, index)),
 843                         delta);
 844             } else {
 845                 return getAndAddConvEndianWithCAS(bb, index, delta);
 846             }
 847         }
 848 
 849         @ForceInline
 850         static $type$ getAndAddRelease(VarHandle ob, Object obb, int index, $type$ delta) {
 851             ByteBufferHandle handle = (ByteBufferHandle)ob;
 852             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 853             if (handle.be == BE) {
 854                 return UNSAFE.getAndAdd$RawType$Release(
 855                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 856                         address(bb, indexRO(bb, index)),
 857                         delta);
 858             } else {
 859                 return getAndAddConvEndianWithCAS(bb, index, delta);
 860             }
 861         }
 862 
 863         @ForceInline
 864         static $type$ getAndAddConvEndianWithCAS(ByteBuffer bb, int index, $type$ delta) {
 865             $type$ nativeExpectedValue, expectedValue;
 866             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
 867             long offset = address(bb, indexRO(bb, index));
 868             do {
 869                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
 870                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 871             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
 872                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
 873             return expectedValue;
 874         }
 875 #end[AtomicAdd]
 876 #if[Bitwise]
 877 
 878         @ForceInline
 879         static $type$ getAndBitwiseOr(VarHandle ob, Object obb, int index, $type$ value) {
 880             ByteBufferHandle handle = (ByteBufferHandle)ob;
 881             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 882             if (handle.be == BE) {
 883                 return UNSAFE.getAndBitwiseOr$RawType$(
 884                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 885                         address(bb, indexRO(bb, index)),
 886                         value);
 887             } else {
 888                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
 889             }
 890         }
 891 
 892         @ForceInline
 893         static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, int index, $type$ value) {
 894             ByteBufferHandle handle = (ByteBufferHandle)ob;
 895             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 896             if (handle.be == BE) {
 897                 return UNSAFE.getAndBitwiseOr$RawType$Release(
 898                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 899                         address(bb, indexRO(bb, index)),
 900                         value);
 901             } else {
 902                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
 903             }
 904         }
 905 
 906         @ForceInline
 907         static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, int index, $type$ value) {
 908             ByteBufferHandle handle = (ByteBufferHandle)ob;
 909             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 910             if (handle.be == BE) {
 911                 return UNSAFE.getAndBitwiseOr$RawType$Acquire(
 912                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 913                         address(bb, indexRO(bb, index)),
 914                         value);
 915             } else {
 916                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
 917             }
 918         }
 919 
 920         @ForceInline
 921         static $type$ getAndBitwiseOrConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
 922             $type$ nativeExpectedValue, expectedValue;
 923             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
 924             long offset = address(bb, indexRO(bb, index));
 925             do {
 926                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
 927                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 928             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
 929                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
 930             return expectedValue;
 931         }
 932 
 933         @ForceInline
 934         static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, int index, $type$ value) {
 935             ByteBufferHandle handle = (ByteBufferHandle)ob;
 936             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 937             if (handle.be == BE) {
 938                 return UNSAFE.getAndBitwiseAnd$RawType$(
 939                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 940                         address(bb, indexRO(bb, index)),
 941                         value);
 942             } else {
 943                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
 944             }
 945         }
 946 
 947         @ForceInline
 948         static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, int index, $type$ value) {
 949             ByteBufferHandle handle = (ByteBufferHandle)ob;
 950             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 951             if (handle.be == BE) {
 952                 return UNSAFE.getAndBitwiseAnd$RawType$Release(
 953                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 954                         address(bb, indexRO(bb, index)),
 955                         value);
 956             } else {
 957                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
 958             }
 959         }
 960 
 961         @ForceInline
 962         static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, int index, $type$ value) {
 963             ByteBufferHandle handle = (ByteBufferHandle)ob;
 964             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 965             if (handle.be == BE) {
 966                 return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
 967                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 968                         address(bb, indexRO(bb, index)),
 969                         value);
 970             } else {
 971                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
 972             }
 973         }
 974 
 975         @ForceInline
 976         static $type$ getAndBitwiseAndConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
 977             $type$ nativeExpectedValue, expectedValue;
 978             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
 979             long offset = address(bb, indexRO(bb, index));
 980             do {
 981                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
 982                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 983             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
 984                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
 985             return expectedValue;
 986         }
 987 
 988 
 989         @ForceInline
 990         static $type$ getAndBitwiseXor(VarHandle ob, Object obb, int index, $type$ value) {
 991             ByteBufferHandle handle = (ByteBufferHandle)ob;
 992             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 993             if (handle.be == BE) {
 994                 return UNSAFE.getAndBitwiseXor$RawType$(
 995                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 996                         address(bb, indexRO(bb, index)),
 997                         value);
 998             } else {
 999                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
1000             }
1001         }
1002 
1003         @ForceInline
1004         static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, int index, $type$ value) {
1005             ByteBufferHandle handle = (ByteBufferHandle)ob;
1006             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
1007             if (handle.be == BE) {
1008                 return UNSAFE.getAndBitwiseXor$RawType$Release(
1009                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
1010                         address(bb, indexRO(bb, index)),
1011                         value);
1012             } else {
1013                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
1014             }
1015         }
1016 
1017         @ForceInline
1018         static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, int index, $type$ value) {
1019             ByteBufferHandle handle = (ByteBufferHandle)ob;
1020             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
1021             if (handle.be == BE) {
1022                 return UNSAFE.getAndBitwiseXor$RawType$Acquire(
1023                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
1024                         address(bb, indexRO(bb, index)),
1025                         value);
1026             } else {
1027                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
1028             }
1029         }
1030 
1031         @ForceInline
1032         static $type$ getAndBitwiseXorConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
1033             $type$ nativeExpectedValue, expectedValue;
1034             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
1035             long offset = address(bb, indexRO(bb, index));
1036             do {
1037                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
1038                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
1039             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
1040                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
1041             return expectedValue;
1042         }
1043 #end[Bitwise]
1044 
1045         static final VarForm FORM = new VarForm(ByteBufferHandle.class, ByteBuffer.class, $type$.class, int.class);
1046     }
1047 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
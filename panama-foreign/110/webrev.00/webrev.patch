diff a/src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template b/src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template
--- a/src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template
+++ b/src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template
@@ -24,10 +24,11 @@
  */
 package java.lang.invoke;
 
 import jdk.internal.access.JavaNioAccess;
 import jdk.internal.access.SharedSecrets;
+import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.misc.Unsafe;
 import jdk.internal.util.Preconditions;
 import jdk.internal.vm.annotation.ForceInline;
 
 import java.nio.ByteBuffer;
@@ -562,11 +563,14 @@
             return accessMode.at.accessModeType(ByteBuffer.class, $type$.class, int.class);
         }
 
         @ForceInline
         static int index(ByteBuffer bb, int index) {
-            nioAccess.checkSegment(bb);
+            MemorySegmentProxy segmentProxy = nioAccess.bufferSegment(bb);
+            if (segmentProxy != null) {
+                segmentProxy.checkValidState();
+            }
             return Preconditions.checkIndex(index, UNSAFE.getInt(bb, BUFFER_LIMIT) - ALIGN, null);
         }
 
         @ForceInline
         static int indexRO(ByteBuffer bb, int index) {
diff a/src/java.base/share/classes/java/nio/Buffer.java b/src/java.base/share/classes/java/nio/Buffer.java
--- a/src/java.base/share/classes/java/nio/Buffer.java
+++ b/src/java.base/share/classes/java/nio/Buffer.java
@@ -27,10 +27,11 @@
 
 import jdk.internal.HotSpotIntrinsicCandidate;
 import jdk.internal.access.JavaNioAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.access.foreign.MemorySegmentProxy;
+import jdk.internal.access.foreign.UnmapperProxy;
 import jdk.internal.misc.Unsafe;
 import jdk.internal.vm.annotation.ForceInline;
 
 import java.util.Spliterator;
 
@@ -765,10 +766,15 @@
                 @Override
                 public ByteBuffer newDirectByteBuffer(long addr, int cap, Object obj, MemorySegmentProxy segment) {
                     return new DirectByteBuffer(addr, cap, obj, segment);
                 }
 
+                @Override
+                public ByteBuffer newMappedByteBuffer(UnmapperProxy unmapperProxy, long address, int cap, Object obj, MemorySegmentProxy segment) {
+                    return new DirectByteBuffer(address, cap, obj, unmapperProxy.fileDescriptor(), unmapperProxy.isSync(), segment);
+                }
+
                 @Override
                 public ByteBuffer newHeapByteBuffer(byte[] hb, int offset, int capacity, MemorySegmentProxy segment) {
                     return new HeapByteBuffer(hb, offset, capacity, segment);
                 }
 
@@ -781,12 +787,21 @@
                 public long getBufferAddress(ByteBuffer bb) {
                     return bb.address;
                 }
 
                 @Override
-                public void checkSegment(Buffer buffer) {
-                    buffer.checkSegment();
+                public UnmapperProxy unmapper(ByteBuffer bb) {
+                    if (bb instanceof MappedByteBuffer) {
+                        return ((MappedByteBuffer)bb).unmapper();
+                    } else {
+                        return null;
+                    }
+                }
+
+                @Override
+                public MemorySegmentProxy bufferSegment(Buffer buffer) {
+                    return buffer.segment;
                 }
             });
     }
 
 }
diff a/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template b/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template
--- a/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template
+++ b/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template
@@ -151,10 +151,19 @@
         address = addr;
         cleaner = null;
         att = ob;
     }
 
+    // Invoked to construct a direct ByteBuffer referring to the block of
+    // memory. A given arbitrary object may also be attached to the buffer.
+    //
+    Direct$Type$Buffer(long addr, int cap, Object ob, FileDescriptor fd, boolean isSync, MemorySegmentProxy segment) {
+        super(-1, 0, cap, cap, fd, isSync, segment);
+        address = addr;
+        cleaner = null;
+        att = ob;
+    }
 
     // Invoked only by JNI: NewDirectByteBuffer(void*, long)
     //
     private Direct$Type$Buffer(long addr, int cap) {
         super(-1, 0, cap, cap, null);
diff a/src/java.base/share/classes/java/nio/MappedByteBuffer.java b/src/java.base/share/classes/java/nio/MappedByteBuffer.java
--- a/src/java.base/share/classes/java/nio/MappedByteBuffer.java
+++ b/src/java.base/share/classes/java/nio/MappedByteBuffer.java
@@ -28,10 +28,11 @@
 import java.io.FileDescriptor;
 import java.lang.ref.Reference;
 import java.util.Objects;
 
 import jdk.internal.access.foreign.MemorySegmentProxy;
+import jdk.internal.access.foreign.UnmapperProxy;
 import jdk.internal.misc.Unsafe;
 
 
 /**
  * A direct byte buffer whose content is a memory-mapped region of a file.
@@ -107,10 +108,35 @@
         super(mark, pos, lim, cap, segment);
         this.fd = null;
         this.isSync = false;
     }
 
+    UnmapperProxy unmapper() {
+        return fd != null ?
+                new UnmapperProxy() {
+                    @Override
+                    public long address() {
+                        return address;
+                    }
+
+                    @Override
+                    public FileDescriptor fileDescriptor() {
+                        return fd;
+                    }
+
+                    @Override
+                    public boolean isSync() {
+                        return isSync;
+                    }
+
+                    @Override
+                    public void unmap() {
+                        throw new UnsupportedOperationException();
+                    }
+                } : null;
+    }
+
     // Returns the distance (in bytes) of the buffer start from the
     // largest page aligned address of the mapping less than or equal
     // to the start address.
     private long mappingOffset() {
         return mappingOffset(0);
diff a/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java
--- a/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java
@@ -24,10 +24,11 @@
  */
 
 package jdk.internal.access;
 
 import jdk.internal.access.foreign.MemorySegmentProxy;
+import jdk.internal.access.foreign.UnmapperProxy;
 
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
 
 public interface JavaNioAccess {
@@ -49,10 +50,20 @@
      * to the resulting buffer.
      * Used by {@code jdk.internal.foreignMemorySegmentImpl}.
      */
     ByteBuffer newDirectByteBuffer(long addr, int cap, Object obj, MemorySegmentProxy segment);
 
+    /**
+     * Constructs a mapped ByteBuffer referring to the block of memory starting
+     * at the given memory address and extending {@code cap} bytes.
+     * The {@code ob} parameter is an arbitrary object that is attached
+     * to the resulting buffer. The {@code sync} and {@code fd} parameters of the mapped
+     * buffer are derived from the {@code UnmapperProxy}.
+     * Used by {@code jdk.internal.foreignMemorySegmentImpl}.
+     */
+    ByteBuffer newMappedByteBuffer(UnmapperProxy unmapperProxy, long addr, int cap, Object obj, MemorySegmentProxy segment);
+
     /**
      * Constructs an heap ByteBuffer with given backing array, offset, capacity and segment.
      * Used by {@code jdk.internal.foreignMemorySegmentImpl}.
      */
     ByteBuffer newHeapByteBuffer(byte[] hb, int offset, int capacity, MemorySegmentProxy segment);
@@ -66,9 +77,14 @@
      * Used by {@code jdk.internal.foreign.Utils}.
      */
     long getBufferAddress(ByteBuffer bb);
 
     /**
-     * Used by byte buffer var handle views.
+     * Used by {@code jdk.internal.foreign.Utils}.
+     */
+    UnmapperProxy unmapper(ByteBuffer bb);
+
+    /**
+     * Used by {@code jdk.internal.foreign.AbstractMemorySegmentImpl} and byte buffer var handle views.
      */
-    void checkSegment(Buffer buffer);
+    MemorySegmentProxy bufferSegment(Buffer buffer);
 }
diff a/src/java.base/share/classes/jdk/internal/access/foreign/UnmapperProxy.java b/src/java.base/share/classes/jdk/internal/access/foreign/UnmapperProxy.java
--- a/src/java.base/share/classes/jdk/internal/access/foreign/UnmapperProxy.java
+++ b/src/java.base/share/classes/jdk/internal/access/foreign/UnmapperProxy.java
@@ -24,13 +24,17 @@
  *
  */
 
 package jdk.internal.access.foreign;
 
+import java.io.FileDescriptor;
+
 /**
  * This proxy interface is required to allow instances of the {@code FileChannelImpl.Unmapper} interface (which is a non-public class
  * inside the {@code sun.nio.ch} package) to be accessed from the mapped memory segment factory.
  */
 public interface UnmapperProxy {
     long address();
+    FileDescriptor fileDescriptor();
+    boolean isSync();
     void unmap();
 }
diff a/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java b/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java
--- a/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java
+++ b/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java
@@ -892,10 +892,15 @@
         @Override
         public long address() {
             return address;
         }
 
+        @Override
+        public FileDescriptor fileDescriptor() {
+            return fd;
+        }
+
         @Override
         public void run() {
             unmap();
         }
 
@@ -945,10 +950,14 @@
                 count--;
                 totalSize -= size;
                 totalCapacity -= cap;
             }
         }
+
+        public boolean isSync() {
+            return false;
+        }
     }
 
     private static class SyncUnmapper extends Unmapper {
 
         // keep track of mapped buffer usage
@@ -974,10 +983,14 @@
                 count--;
                 totalSize -= size;
                 totalCapacity -= cap;
             }
         }
+
+        public boolean isSync() {
+            return true;
+        }
     }
 
     private static void unmap(MappedByteBuffer bb) {
         Cleaner cl = ((DirectBuffer)bb).cleaner();
         if (cl != null)
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
@@ -25,11 +25,10 @@
  */
 
 package jdk.incubator.foreign;
 
 import jdk.internal.foreign.MemoryAddressImpl;
-import jdk.internal.foreign.MemorySegmentImpl;
 
 /**
  * A memory address models a reference into a memory location. Memory addresses are typically obtained using the
  * {@link MemorySegment#baseAddress()} method; such addresses are said to be <em>checked</em>, and can be expressed
  * as <em>offsets</em> into some underlying memory segment (see {@link #segment()} and {@link #segmentOffset()}).
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -26,11 +26,14 @@
 
 package jdk.incubator.foreign;
 
 import java.nio.ByteBuffer;
 
-import jdk.internal.foreign.Utils;
+import jdk.internal.foreign.AbstractMemorySegmentImpl;
+import jdk.internal.foreign.HeapMemorySegmentImpl;
+import jdk.internal.foreign.MappedMemorySegmentImpl;
+import jdk.internal.foreign.NativeMemorySegmentImpl;
 
 import java.io.IOException;
 import java.nio.channels.FileChannel;
 import java.nio.file.Path;
 import java.util.Spliterator;
@@ -289,11 +292,11 @@
      *
      * @param bb the byte buffer backing the buffer memory segment.
      * @return a new buffer memory segment.
      */
     static MemorySegment ofByteBuffer(ByteBuffer bb) {
-        return Utils.makeBufferSegment(bb);
+        return AbstractMemorySegmentImpl.ofBuffer(bb);
     }
 
     /**
      * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
      * <p>
@@ -302,11 +305,11 @@
      *
      * @param arr the primitive array backing the array memory segment.
      * @return a new array memory segment.
      */
     static MemorySegment ofArray(byte[] arr) {
-        return Utils.makeArraySegment(arr);
+        return HeapMemorySegmentImpl.makeArraySegment(arr);
     }
 
     /**
      * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
      * <p>
@@ -315,11 +318,11 @@
      *
      * @param arr the primitive array backing the array memory segment.
      * @return a new array memory segment.
      */
     static MemorySegment ofArray(char[] arr) {
-        return Utils.makeArraySegment(arr);
+        return HeapMemorySegmentImpl.makeArraySegment(arr);
     }
 
     /**
      * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
      * <p>
@@ -328,11 +331,11 @@
      *
      * @param arr the primitive array backing the array memory segment.
      * @return a new array memory segment.
      */
     static MemorySegment ofArray(short[] arr) {
-        return Utils.makeArraySegment(arr);
+        return HeapMemorySegmentImpl.makeArraySegment(arr);
     }
 
     /**
      * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.
      * <p>
@@ -341,11 +344,11 @@
      *
      * @param arr the primitive array backing the array memory segment.
      * @return a new array memory segment.
      */
     static MemorySegment ofArray(int[] arr) {
-        return Utils.makeArraySegment(arr);
+        return HeapMemorySegmentImpl.makeArraySegment(arr);
     }
 
     /**
      * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
      * <p>
@@ -354,11 +357,11 @@
      *
      * @param arr the primitive array backing the array memory segment.
      * @return a new array memory segment.
      */
     static MemorySegment ofArray(float[] arr) {
-        return Utils.makeArraySegment(arr);
+        return HeapMemorySegmentImpl.makeArraySegment(arr);
     }
 
     /**
      * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
      * <p>
@@ -367,11 +370,11 @@
      *
      * @param arr the primitive array backing the array memory segment.
      * @return a new array memory segment.
      */
     static MemorySegment ofArray(long[] arr) {
-        return Utils.makeArraySegment(arr);
+        return HeapMemorySegmentImpl.makeArraySegment(arr);
     }
 
     /**
      * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
      * <p>
@@ -380,11 +383,11 @@
      *
      * @param arr the primitive array backing the array memory segment.
      * @return a new array memory segment.
      */
     static MemorySegment ofArray(double[] arr) {
-        return Utils.makeArraySegment(arr);
+        return HeapMemorySegmentImpl.makeArraySegment(arr);
     }
 
     /**
      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.
      * <p>
@@ -438,11 +441,11 @@
      * @throws IllegalArgumentException if {@code bytesSize < 0}.
      * @throws UnsupportedOperationException if an unsupported map mode is specified.
      * @throws IOException if the specified path does not point to an existing file, or if some other I/O error occurs.
      */
     static MemorySegment mapFromPath(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
-        return Utils.makeMappedSegment(path, bytesSize, mapMode);
+        return MappedMemorySegmentImpl.makeMappedSegment(path, bytesSize, mapMode);
     }
 
     /**
      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
      * alignment constraint (in bytes).
@@ -465,11 +468,11 @@
         if (alignmentBytes < 0 ||
                 ((alignmentBytes & (alignmentBytes - 1)) != 0L)) {
             throw new IllegalArgumentException("Invalid alignment constraint : " + alignmentBytes);
         }
 
-        return Utils.makeNativeSegment(bytesSize, alignmentBytes);
+        return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
     }
 
     // access mode masks
 
     /**
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -0,0 +1,435 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.foreign;
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SequenceLayout;
+import jdk.internal.access.JavaNioAccess;
+import jdk.internal.access.SharedSecrets;
+import jdk.internal.access.foreign.MemorySegmentProxy;
+import jdk.internal.access.foreign.UnmapperProxy;
+import jdk.internal.vm.annotation.ForceInline;
+import sun.security.action.GetPropertyAction;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.Random;
+import java.util.Spliterator;
+import java.util.function.Consumer;
+
+/**
+ * This abstract class provides an immutable implementation for the {@code MemorySegment} interface. This class contains information
+ * about the segment's spatial and temporal bounds; each memory segment implementation is associated with an owner thread which is set at creation time.
+ * Access to certain sensitive operations on the memory segment will fail with {@code IllegalStateException} if the
+ * segment is either in an invalid state (e.g. it has already been closed) or if access occurs from a thread other
+ * than the owner thread. See {@link MemoryScope} for more details on management of temporal bounds. Subclasses
+ * are defined for each memory segment kind, see {@link NativeMemorySegmentImpl}, {@link HeapMemorySegmentImpl} and
+ * {@link MappedMemorySegmentImpl}.
+ */
+public abstract class AbstractMemorySegmentImpl implements MemorySegment, MemorySegmentProxy {
+
+    private static final boolean enableSmallSegments =
+            Boolean.parseBoolean(GetPropertyAction.privilegedGetProperty("jdk.incubator.foreign.SmallSegments", "true"));
+
+    final static int ACCESS_MASK = READ | WRITE | CLOSE | ACQUIRE;
+    final static int FIRST_RESERVED_FLAG = 1 << 16; // upper 16 bits are reserved
+    final static int SMALL = FIRST_RESERVED_FLAG;
+    final static long NONCE = new Random().nextLong();
+    final static int DEFAULT_MASK = READ | WRITE | CLOSE | ACQUIRE;
+
+    final static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
+
+    final long length;
+    final int mask;
+    final Thread owner;
+    final MemoryScope scope;
+
+    @ForceInline
+    AbstractMemorySegmentImpl(long length, int mask, Thread owner, MemoryScope scope) {
+        this.length = length;
+        this.mask = mask;
+        this.owner = owner;
+        this.scope = scope;
+    }
+
+    abstract long min();
+
+    abstract Object base();
+
+    abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope);
+
+    abstract ByteBuffer makeByteBuffer();
+
+    static int defaultAccessModes(long size) {
+        return (enableSmallSegments && size < Integer.MAX_VALUE) ?
+                DEFAULT_MASK | SMALL :
+                DEFAULT_MASK;
+    }
+
+    @Override
+    public final MemorySegment asSlice(long offset, long newSize) {
+        checkBounds(offset, newSize);
+        return asSliceNoCheck(offset, newSize);
+    }
+
+    private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
+        return dup(offset, newSize, mask, owner, scope);
+    }
+
+    @Override
+    public Spliterator<MemorySegment> spliterator(SequenceLayout sequenceLayout) {
+        checkValidState();
+        if (sequenceLayout.byteSize() != byteSize()) {
+            throw new IllegalArgumentException();
+        }
+        return new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
+                this.withAccessModes(accessModes() & ~CLOSE));
+    }
+
+    @Override
+    @ForceInline
+    public final MemoryAddress baseAddress() {
+        return new MemoryAddressImpl(this, 0);
+    }
+
+    @Override
+    public final ByteBuffer asByteBuffer() {
+        if (!isSet(READ)) {
+            throw unsupportedAccessMode(READ);
+        }
+        checkIntSize("ByteBuffer");
+        ByteBuffer _bb = makeByteBuffer();
+        if (!isSet(WRITE)) {
+            //scope is IMMUTABLE - obtain a RO byte buffer
+            _bb = _bb.asReadOnlyBuffer();
+        }
+        return _bb;
+    }
+
+    @Override
+    public final int accessModes() {
+        return mask & ACCESS_MASK;
+    }
+
+    @Override
+    public final long byteSize() {
+        return length;
+    }
+
+    @Override
+    public final boolean isAlive() {
+        return scope.isAliveThreadSafe();
+    }
+
+    @Override
+    public Thread ownerThread() {
+        return owner;
+    }
+
+    @Override
+    public AbstractMemorySegmentImpl withAccessModes(int accessModes) {
+        checkAccessModes(accessModes);
+        if ((~accessModes() & accessModes) != 0) {
+            throw new UnsupportedOperationException("Cannot acquire more access modes");
+        }
+        return dup(0, length, (mask & ~ACCESS_MASK) | accessModes, owner, scope);
+    }
+
+    @Override
+    public boolean hasAccessModes(int accessModes) {
+        checkAccessModes(accessModes);
+        return (accessModes() & accessModes) == accessModes;
+    }
+
+    private void checkAccessModes(int accessModes) {
+        if ((accessModes & ~ACCESS_MASK) != 0) {
+            throw new IllegalArgumentException("Invalid access modes");
+        }
+    }
+
+    @Override
+    public final void close() {
+        if (!isSet(CLOSE)) {
+            throw unsupportedAccessMode(CLOSE);
+        }
+        checkValidState();
+        closeNoCheck();
+    }
+
+    private final void closeNoCheck() {
+        scope.close();
+    }
+
+    final AbstractMemorySegmentImpl acquire() {
+        if (Thread.currentThread() != ownerThread() && !isSet(ACQUIRE)) {
+            throw unsupportedAccessMode(ACQUIRE);
+        }
+        return dup(0, length, mask, Thread.currentThread(), scope.acquire());
+    }
+
+    @Override
+    public final byte[] toByteArray() {
+        checkIntSize("byte[]");
+        byte[] arr = new byte[(int)length];
+        MemorySegment arrSegment = MemorySegment.ofArray(arr);
+        MemoryAddress.copy(baseAddress(), arrSegment.baseAddress(), length);
+        return arr;
+    }
+
+    boolean isSmall() {
+        return isSet(SMALL);
+    }
+
+    void checkRange(long offset, long length, boolean writeAccess) {
+        checkValidState();
+        if (writeAccess && !isSet(WRITE)) {
+            throw unsupportedAccessMode(WRITE);
+        } else if (!writeAccess && !isSet(READ)) {
+            throw unsupportedAccessMode(READ);
+        }
+        checkBounds(offset, length);
+    }
+
+    @Override
+    public final void checkValidState() {
+        if (owner != null && owner != Thread.currentThread()) {
+            throw new IllegalStateException("Attempt to access segment outside owning thread");
+        }
+        scope.checkAliveConfined();
+    }
+
+    // Helper methods
+
+    AbstractMemorySegmentImpl asUnconfined() {
+        checkValidState();
+        return dup(0, length, mask, null, scope);
+    }
+
+    private boolean isSet(int mask) {
+        return (this.mask & mask) != 0;
+    }
+
+    private void checkIntSize(String typeName) {
+        if (length > (Integer.MAX_VALUE - 8)) { //conservative check
+            throw new UnsupportedOperationException(String.format("Segment is too large to wrap as %s. Size: %d", typeName, length));
+        }
+    }
+
+    private void checkBounds(long offset, long length) {
+        if (isSmall()) {
+            checkBoundsSmall((int)offset, (int)length);
+        } else {
+            if (length < 0 ||
+                    offset < 0 ||
+                    offset > this.length - length) { // careful of overflow
+                throw outOfBoundException(offset, length);
+            }
+        }
+    }
+
+    private void checkBoundsSmall(int offset, int length) {
+        if (length < 0 ||
+                offset < 0 ||
+                offset > (int)this.length - length) { // careful of overflow
+            throw outOfBoundException(offset, length);
+        }
+    }
+
+    UnsupportedOperationException unsupportedAccessMode(int expected) {
+        return new UnsupportedOperationException((String.format("Required access mode %s ; current access modes: %s",
+                modeStrings(expected).get(0), modeStrings(mask))));
+    }
+
+    private List<String> modeStrings(int mode) {
+        List<String> modes = new ArrayList<>();
+        if ((mode & READ) != 0) {
+            modes.add("READ");
+        }
+        if ((mode & WRITE) != 0) {
+            modes.add("WRITE");
+        }
+        if ((mode & CLOSE) != 0) {
+            modes.add("CLOSE");
+        }
+        if ((mode & ACQUIRE) != 0) {
+            modes.add("ACQUIRE");
+        }
+        return modes;
+    }
+
+    private IndexOutOfBoundsException outOfBoundException(long offset, long length) {
+        return new IndexOutOfBoundsException(String.format("Out of bound access on segment %s; new offset = %d; new length = %d",
+                        this, offset, length));
+    }
+
+    protected int id() {
+        //compute a stable and random id for this memory segment
+        return Math.abs(Objects.hash(base(), min(), NONCE));
+    }
+
+    static class SegmentSplitter implements Spliterator<MemorySegment> {
+        AbstractMemorySegmentImpl segment;
+        long elemCount;
+        final long elementSize;
+        long currentIndex;
+
+        SegmentSplitter(long elementSize, long elemCount, AbstractMemorySegmentImpl segment) {
+            this.segment = segment;
+            this.elementSize = elementSize;
+            this.elemCount = elemCount;
+        }
+
+        @Override
+        public SegmentSplitter trySplit() {
+            if (currentIndex == 0 && elemCount > 1) {
+                AbstractMemorySegmentImpl parent = segment;
+                long rem = elemCount % 2;
+                long split = elemCount / 2;
+                long lobound = split * elementSize;
+                long hibound = lobound + (rem * elementSize);
+                elemCount  = split + rem;
+                segment = parent.asSliceNoCheck(lobound, hibound);
+                return new SegmentSplitter(elementSize, split, parent.asSliceNoCheck(0, lobound));
+            } else {
+                return null;
+            }
+        }
+
+        @Override
+        public boolean tryAdvance(Consumer<? super MemorySegment> action) {
+            Objects.requireNonNull(action);
+            if (currentIndex < elemCount) {
+                AbstractMemorySegmentImpl acquired = segment.acquire();
+                try {
+                    action.accept(acquired.asSliceNoCheck(currentIndex * elementSize, elementSize));
+                } finally {
+                    acquired.closeNoCheck();
+                    currentIndex++;
+                    if (currentIndex == elemCount) {
+                        segment = null;
+                    }
+                }
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        @Override
+        public void forEachRemaining(Consumer<? super MemorySegment> action) {
+            Objects.requireNonNull(action);
+            if (currentIndex < elemCount) {
+                AbstractMemorySegmentImpl acquired = segment.acquire();
+                try {
+                    if (acquired.isSmall()) {
+                        int index = (int) currentIndex;
+                        int limit = (int) elemCount;
+                        int elemSize = (int) elementSize;
+                        for (; index < limit; index++) {
+                            action.accept(acquired.asSliceNoCheck(index * elemSize, elemSize));
+                        }
+                    } else {
+                        for (long i = currentIndex ; i < elemCount ; i++) {
+                            action.accept(acquired.asSliceNoCheck(i * elementSize, elementSize));
+                        }
+                    }
+                } finally {
+                    acquired.closeNoCheck();
+                    currentIndex = elemCount;
+                    segment = null;
+                }
+            }
+        }
+
+        @Override
+        public long estimateSize() {
+            return elemCount;
+        }
+
+        @Override
+        public int characteristics() {
+            return NONNULL | SUBSIZED | SIZED | IMMUTABLE | ORDERED;
+        }
+    }
+
+    // Object methods
+
+    @Override
+    public String toString() {
+        return "MemorySegment{ id=0x" + Long.toHexString(id()) + " limit: " + length + " }";
+    }
+
+    public static AbstractMemorySegmentImpl ofBuffer(ByteBuffer bb) {
+        long bbAddress = nioAccess.getBufferAddress(bb);
+        Object base = nioAccess.getBufferBase(bb);
+        UnmapperProxy unmapper = nioAccess.unmapper(bb);
+
+        int pos = bb.position();
+        int limit = bb.limit();
+
+        MemoryScope bufferScope = new MemoryScope(bb, null);
+        int size = limit - pos;
+
+        MemorySegment bufferSegment = (MemorySegment)nioAccess.bufferSegment(bb);
+        int modes = bufferSegment == null ?
+                defaultAccessModes(size) : bufferSegment.accessModes();
+        if (bb.isReadOnly()) {
+            modes &= ~WRITE;
+        }
+        if (base != null) {
+            return new HeapMemorySegmentImpl<>(bbAddress + pos, () -> (byte[])base, size, modes, Thread.currentThread(), bufferScope);
+        } else if (unmapper == null) {
+            return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, Thread.currentThread(), bufferScope);
+        } else {
+            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, Thread.currentThread(), bufferScope);
+        }
+    }
+
+    public static AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(0, 0, null, MemoryScope.GLOBAL) {
+        @Override
+        ByteBuffer makeByteBuffer() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        long min() {
+            return 0;
+        }
+
+        @Override
+        Object base() {
+            return null;
+        }
+
+        @Override
+        AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
+            throw new UnsupportedOperationException();
+        }
+    };
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java
@@ -0,0 +1,127 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.foreign;
+
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.access.JavaNioAccess;
+import jdk.internal.access.SharedSecrets;
+import jdk.internal.misc.Unsafe;
+import jdk.internal.vm.annotation.ForceInline;
+
+import java.nio.ByteBuffer;
+import java.util.Objects;
+import java.util.function.Supplier;
+
+/**
+ * Implementation for heap memory segments. An heap memory segment is composed by an offset and
+ * a base object (typically an array). To enhance performances, the access to the base object needs to feature
+ * sharp type information, as well as sharp null-check information. For this reason, the factories for heap segments
+ * use a lambda to implement the base object accessor, so that the type information will remain sharp (e.g.
+ * the static compiler will generate specialized base accessor for us).
+ */
+public class HeapMemorySegmentImpl<H> extends AbstractMemorySegmentImpl {
+
+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+    private static final int BYTE_ARR_BASE = UNSAFE.arrayBaseOffset(byte[].class);
+
+    final long offset;
+    final Supplier<H> baseProvider;
+
+    @ForceInline
+    HeapMemorySegmentImpl(long offset, Supplier<H> baseProvider, long length, int mask, Thread owner, MemoryScope scope) {
+        super(length, mask, owner, scope);
+        this.offset = offset;
+        this.baseProvider = baseProvider;
+    }
+
+    @Override
+    H base() {
+        return Objects.requireNonNull(baseProvider.get());
+    }
+
+    @Override
+    long min() {
+        return offset;
+    }
+
+    @Override
+    AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
+        return new HeapMemorySegmentImpl<H>(this.offset + offset, baseProvider, size, mask, owner, scope);
+    }
+
+    @Override
+    ByteBuffer makeByteBuffer() {
+        if (!(base() instanceof byte[])) {
+            throw new UnsupportedOperationException("Not an address to an heap-allocated byte array");
+        }
+        JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
+        return nioAccess.newHeapByteBuffer((byte[]) base(), (int)min() - BYTE_ARR_BASE, (int) byteSize(), this);
+    }
+
+    // factories
+
+    public static MemorySegment makeArraySegment(byte[] arr) {
+        return makeHeapSegment(() -> arr, arr.length,
+                Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE);
+    }
+
+    public static MemorySegment makeArraySegment(char[] arr) {
+        return makeHeapSegment(() -> arr, arr.length,
+                Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE);
+    }
+
+    public static MemorySegment makeArraySegment(short[] arr) {
+        return makeHeapSegment(() -> arr, arr.length,
+                Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE);
+    }
+
+    public static MemorySegment makeArraySegment(int[] arr) {
+        return makeHeapSegment(() -> arr, arr.length,
+                Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE);
+    }
+
+    public static MemorySegment makeArraySegment(long[] arr) {
+        return makeHeapSegment(() -> arr, arr.length,
+                Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE);
+    }
+
+    public static MemorySegment makeArraySegment(float[] arr) {
+        return makeHeapSegment(() -> arr, arr.length,
+                Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE);
+    }
+
+    public static MemorySegment makeArraySegment(double[] arr) {
+        return makeHeapSegment(() -> arr, arr.length,
+                Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE);
+    }
+
+    static <Z> HeapMemorySegmentImpl<Z> makeHeapSegment(Supplier<Z> obj, int length, int base, int scale) {
+        int byteSize = length * scale;
+        MemoryScope scope = new MemoryScope(null, null);
+        return new HeapMemorySegmentImpl<>(base, obj, byteSize, defaultAccessModes(byteSize), Thread.currentThread(), scope);
+    }
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
@@ -47,22 +47,30 @@
         return INSTANCE;
     }
 
     @Override
     public MemoryAddress withSize(MemoryAddress base, long byteSize) throws IllegalAccessError {
-        return Utils.makeNativeSegmentUnchecked(base.toRawLongValue(), byteSize, null, false)
+        checkRawNativeAddress(base);
+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(base.toRawLongValue(), byteSize, null, false)
                 .baseAddress();
     }
 
     @Override
     public MemorySegment asMallocSegment(MemoryAddress base, long byteSize) throws IllegalAccessError {
-        return Utils.makeNativeSegmentUnchecked(base.toRawLongValue(), byteSize, Thread.currentThread(), true);
+        checkRawNativeAddress(base);
+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(base.toRawLongValue(), byteSize, Thread.currentThread(), true);
+    }
+
+    private void checkRawNativeAddress(MemoryAddress base) {
+        if (base.segment() != AbstractMemorySegmentImpl.NOTHING) {
+            throw new IllegalArgumentException("Not an unchecked memory address");
+        }
     }
 
     @Override
     public MemorySegment asUnconfined(MemorySegment segment) {
-        return ((MemorySegmentImpl)segment).asUnconfined();
+        return ((NativeMemorySegmentImpl)segment).asUnconfined();
     }
 
     private static void checkRestrictedAccess() {
         switch (foreignAccess) {
             case "deny" -> throwIllegalAccessError(foreignAccess);
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.foreign;
+
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.access.JavaNioAccess;
+import jdk.internal.access.SharedSecrets;
+import jdk.internal.access.foreign.UnmapperProxy;
+import sun.nio.ch.FileChannelImpl;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.file.OpenOption;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
+
+/**
+ * Implementation for a mapped memory segments. A mapped memory segment is a native memory segment, which
+ * additionally features an {@link UnmapperProxy} object. This object provides detailed information about the
+ * memory mapped segment, such as the file descriptor associated with the mapping. This information is crucial
+ * in order to correctly reconstruct a byte buffer object from the segment (see {@link #makeByteBuffer()}).
+ */
+public class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {
+
+    private final UnmapperProxy unmapper;
+
+    MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, Thread owner, MemoryScope scope) {
+        super(min, length, mask, owner, scope);
+        this.unmapper = unmapper;
+    }
+
+    @Override
+    ByteBuffer makeByteBuffer() {
+        JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
+        return nioAccess.newMappedByteBuffer(unmapper, min, (int)length, null, this);
+    }
+
+    @Override
+    AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
+        return new MappedMemorySegmentImpl(min + offset, unmapper, size, mask, owner, scope);
+    }
+
+    // factories
+
+    public static MemorySegment makeMappedSegment(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
+        if (bytesSize <= 0) throw new IllegalArgumentException("Requested bytes size must be > 0.");
+        try (FileChannelImpl channelImpl = (FileChannelImpl)FileChannel.open(path, openOptions(mapMode))) {
+            UnmapperProxy unmapperProxy = channelImpl.mapInternal(mapMode, 0L, bytesSize);
+            MemoryScope scope = new MemoryScope(null, unmapperProxy::unmap);
+            return new MappedMemorySegmentImpl(unmapperProxy.address(), unmapperProxy, bytesSize,
+                    defaultAccessModes(bytesSize), Thread.currentThread(), scope);
+        }
+    }
+
+    private static OpenOption[] openOptions(FileChannel.MapMode mapMode) {
+        if (mapMode == FileChannel.MapMode.READ_ONLY) {
+            return new OpenOption[] { StandardOpenOption.READ };
+        } else if (mapMode == FileChannel.MapMode.READ_WRITE || mapMode == FileChannel.MapMode.PRIVATE) {
+            return new OpenOption[] { StandardOpenOption.READ, StandardOpenOption.WRITE };
+        } else {
+            throw new UnsupportedOperationException("Unsupported map mode: " + mapMode);
+        }
+    }
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
@@ -39,19 +39,19 @@
  */
 public final class MemoryAddressImpl implements MemoryAddress, MemoryAddressProxy {
 
     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
 
-    private final MemorySegmentImpl segment;
+    private final AbstractMemorySegmentImpl segment;
     private final long offset;
 
     public MemoryAddressImpl(long offset) {
-        this.segment = MemorySegmentImpl.NOTHING;
+        this.segment = AbstractMemorySegmentImpl.NOTHING;
         this.offset = offset;
     }
 
-    public MemoryAddressImpl(MemorySegmentImpl segment, long offset) {
+    public MemoryAddressImpl(AbstractMemorySegmentImpl segment, long offset) {
         this.segment = Objects.requireNonNull(segment);
         this.offset = offset;
     }
 
     public static void copy(MemoryAddressImpl src, MemoryAddressImpl dst, long size) {
@@ -83,48 +83,47 @@
         return unsafeGetOffset();
     }
 
     @Override
     public MemorySegment segment() {
-        return segment != MemorySegmentImpl.NOTHING ?
+        return segment != AbstractMemorySegmentImpl.NOTHING ?
                 segment : null;
     }
 
     @Override
     public MemoryAddress addOffset(long bytes) {
         return new MemoryAddressImpl(segment, offset + bytes);
     }
 
     @Override
     public MemoryAddress rebase(MemorySegment segment) {
-        MemorySegmentImpl segmentImpl = (MemorySegmentImpl)segment;
-        if (segmentImpl.base != this.segment.base) {
+        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl) segment;
+        if (segmentImpl.base() != this.segment.base()) {
             throw new IllegalArgumentException("Invalid rebase target: " + segment);
         }
-        return new MemoryAddressImpl((MemorySegmentImpl)segment,
+        return new MemoryAddressImpl((AbstractMemorySegmentImpl) segment,
                 unsafeGetOffset() - ((MemoryAddressImpl)segment.baseAddress()).unsafeGetOffset());
     }
 
     // MemoryAddressProxy methods
 
     public void checkAccess(long offset, long length, boolean readOnly) {
         segment.checkRange(MemoryAddressProxy.addOffsets(this.offset, offset, this), length, !readOnly);
     }
 
     public long unsafeGetOffset() {
-        return segment.min + offset;
+        return segment.min() + offset;
     }
 
     public Object unsafeGetBase() {
         return segment.base();
     }
 
     @Override
     public boolean isSmall() {
         return segment.isSmall();
     }
-
     // Object methods
 
     @Override
     public int hashCode() {
         return Objects.hash(unsafeGetBase(), unsafeGetOffset());
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
@@ -29,11 +29,11 @@
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 
 /**
  * This class manages the temporal bounds associated with a memory segment. A scope has a liveness bit, which is updated
- * when the scope is closed (this operation is triggered by {@link MemorySegmentImpl#close()}). Furthermore, a scope is
+ * when the scope is closed (this operation is triggered by {@link AbstractMemorySegmentImpl#close()}). Furthermore, a scope is
  * associated with an <em>atomic</em> counter which can be incremented (upon calling the {@link #acquire()} method),
  * and is decremented (when a previously acquired segment is later closed).
  */
 public final class MemoryScope {
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
+++ /dev/null
@@ -1,409 +0,0 @@
-/*
- *  Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- *  This code is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 only, as
- *  published by the Free Software Foundation.  Oracle designates this
- *  particular file as subject to the "Classpath" exception as provided
- *  by Oracle in the LICENSE file that accompanied this code.
- *
- *  This code is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  version 2 for more details (a copy is included in the LICENSE file that
- *  accompanied this code).
- *
- *  You should have received a copy of the GNU General Public License version
- *  2 along with this work; if not, write to the Free Software Foundation,
- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- *  or visit www.oracle.com if you need additional information or have any
- *  questions.
- *
- */
-
-package jdk.internal.foreign;
-
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.SequenceLayout;
-import jdk.internal.access.JavaNioAccess;
-import jdk.internal.access.SharedSecrets;
-import jdk.internal.access.foreign.MemorySegmentProxy;
-import jdk.internal.misc.Unsafe;
-import jdk.internal.vm.annotation.ForceInline;
-
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Objects;
-import java.util.Random;
-import java.util.Spliterator;
-import java.util.function.Consumer;
-
-/**
- * This class provides an immutable implementation for the {@code MemorySegment} interface. This class contains information
- * about the segment's spatial and temporal bounds, as well as the addressing coordinates (base + offset) which allows
- * unsafe access; each memory segment implementation is associated with an owner thread which is set at creation time.
- * Access to certain sensitive operations on the memory segment will fail with {@code IllegalStateException} if the
- * segment is either in an invalid state (e.g. it has already been closed) or if access occurs from a thread other
- * than the owner thread. See {@link MemoryScope} for more details on management of temporal bounds.
- */
-public final class MemorySegmentImpl implements MemorySegment, MemorySegmentProxy {
-
-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
-    private static final int BYTE_ARR_BASE = UNSAFE.arrayBaseOffset(byte[].class);
-
-    final long length;
-    final int mask;
-    final long min;
-    final Object base;
-    final Thread owner;
-    final MemoryScope scope;
-
-    final static int ACCESS_MASK = READ | WRITE | CLOSE | ACQUIRE;
-    final static int FIRST_RESERVED_FLAG = 1 << 16; // upper 16 bits are reserved
-    final static int SMALL = FIRST_RESERVED_FLAG;
-
-    final static long NONCE = new Random().nextLong();
-
-    final static int DEFAULT_MASK = READ | WRITE | CLOSE | ACQUIRE;
-    public static final MemorySegmentImpl NOTHING = new MemorySegmentImpl();
-
-    private MemorySegmentImpl() {
-        this.length = 0L;
-        this.mask = 0;
-        this.min = 0L;
-        this.base = null;
-        this.owner = null;
-        this.scope = MemoryScope.GLOBAL;
-    }
-
-    public MemorySegmentImpl(long min, Object base, long length, Thread owner, MemoryScope scope) {
-        this(min, base, length, DEFAULT_MASK, owner, scope);
-    }
-
-    @ForceInline
-    MemorySegmentImpl(long min, Object base, long length, int mask, Thread owner, MemoryScope scope) {
-        this.length = length;
-        this.mask = length > Integer.MAX_VALUE ? mask : (mask | SMALL);
-        this.min = min;
-        this.base = base;
-        this.owner = owner;
-        this.scope = scope;
-    }
-
-    // MemorySegment methods
-
-    @Override
-    public final MemorySegment asSlice(long offset, long newSize) {
-        checkBounds(offset, newSize);
-        return asSliceNoCheck(offset, newSize);
-    }
-
-    @ForceInline
-    private MemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
-        return new MemorySegmentImpl(min + offset, base, newSize, mask, owner, scope);
-    }
-
-    @Override
-    public Spliterator<MemorySegment> spliterator(SequenceLayout sequenceLayout) {
-        checkValidState();
-        if (sequenceLayout.byteSize() != byteSize()) {
-            throw new IllegalArgumentException();
-        }
-        return new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
-                this.withAccessModes(accessModes() & ~CLOSE));
-    }
-
-    @Override
-    @ForceInline
-    public final MemoryAddress baseAddress() {
-        return new MemoryAddressImpl(this, 0);
-    }
-
-    @Override
-    public final long byteSize() {
-        return length;
-    }
-
-    @Override
-    public final boolean isAlive() {
-        return scope.isAliveThreadSafe();
-    }
-
-    @Override
-    public Thread ownerThread() {
-        return owner;
-    }
-
-    @Override
-    public final void close() {
-        if (!isSet(CLOSE)) {
-            throw unsupportedAccessMode(CLOSE);
-        }
-        checkValidState();
-        closeNoCheck();
-    }
-
-    private void closeNoCheck() {
-        scope.close();
-    }
-
-    @Override
-    public ByteBuffer asByteBuffer() {
-        if (!isSet(READ)) {
-            throw unsupportedAccessMode(READ);
-        }
-        checkIntSize("ByteBuffer");
-        JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
-        ByteBuffer _bb;
-        if (base() != null) {
-            if (!(base() instanceof byte[])) {
-                throw new UnsupportedOperationException("Not an address to an heap-allocated byte array");
-            }
-            _bb = nioAccess.newHeapByteBuffer((byte[]) base(), (int)min - BYTE_ARR_BASE, (int) length, this);
-        } else {
-            _bb = nioAccess.newDirectByteBuffer(min, (int) length, null, this);
-        }
-        if (!isSet(WRITE)) {
-            //scope is IMMUTABLE - obtain a RO byte buffer
-            _bb = _bb.asReadOnlyBuffer();
-        }
-        return _bb;
-    }
-
-    @Override
-    public MemorySegmentImpl withAccessModes(int accessModes) {
-        checkAccessModes(accessModes);
-        if ((~accessModes() & accessModes) != 0) {
-            throw new UnsupportedOperationException("Cannot acquire more access modes");
-        }
-        return new MemorySegmentImpl(min, base, length, accessModes, owner, scope);
-    }
-
-    @Override
-    public boolean hasAccessModes(int accessModes) {
-        checkAccessModes(accessModes);
-        return (accessModes() & accessModes) == accessModes;
-    }
-
-    private void checkAccessModes(int accessModes) {
-        if ((accessModes & ~ACCESS_MASK) != 0) {
-            throw new IllegalArgumentException("Invalid access modes");
-        }
-    }
-
-    @Override
-    public int accessModes() {
-        return mask & ACCESS_MASK;
-    }
-
-    @Override
-    public byte[] toByteArray() {
-        checkIntSize("byte[]");
-        byte[] arr = new byte[(int)length];
-        MemorySegment arrSegment = MemorySegment.ofArray(arr);
-        MemoryAddress.copy(this.baseAddress(), arrSegment.baseAddress(), length);
-        return arr;
-    }
-
-    // MemorySegmentProxy methods
-
-    @Override
-    public final void checkValidState() {
-        if (owner != null && owner != Thread.currentThread()) {
-            throw new IllegalStateException("Attempt to access segment outside owning thread");
-        }
-        scope.checkAliveConfined();
-    }
-
-    boolean isSmall() {
-        return isSet(SMALL);
-    }
-
-    // Object methods
-
-    @Override
-    public String toString() {
-        return "MemorySegment{ id=0x" + Long.toHexString(id()) + " limit: " + byteSize() + " }";
-    }
-
-    // Helper methods
-
-    private MemorySegmentImpl acquire() {
-        if (Thread.currentThread() != owner && !isSet(ACQUIRE)) {
-            throw unsupportedAccessMode(ACQUIRE);
-        }
-        return new MemorySegmentImpl(min, base, length, mask, Thread.currentThread(), scope.acquire());
-    }
-
-    public MemorySegment asUnconfined() {
-        checkValidState();
-        return new MemorySegmentImpl(min, base, length, mask, null, scope);
-    }
-
-    void checkRange(long offset, long length, boolean writeAccess) {
-        checkValidState();
-        if (writeAccess && !isSet(WRITE)) {
-            throw unsupportedAccessMode(WRITE);
-        } else if (!writeAccess && !isSet(READ)) {
-            throw unsupportedAccessMode(READ);
-        }
-        checkBounds(offset, length);
-    }
-
-    Object base() {
-        return base;
-    }
-
-    private boolean isSet(int mask) {
-        return (this.mask & mask) != 0;
-    }
-
-    private void checkIntSize(String typeName) {
-        if (length > (Integer.MAX_VALUE - 8)) { //conservative check
-            throw new UnsupportedOperationException(String.format("Segment is too large to wrap as %s. Size: %d", typeName, length));
-        }
-    }
-
-    private void checkBounds(long offset, long length) {
-        if (isSmall()) {
-            checkBoundsSmall((int)offset, (int)length);
-        } else {
-            if (length < 0 ||
-                    offset < 0 ||
-                    offset > this.length - length) { // careful of overflow
-                throw outOfBoundException(offset, length);
-            }
-        }
-    }
-
-    @ForceInline
-    private void checkBoundsSmall(int offset, int length) {
-        if (length < 0 ||
-                offset < 0 ||
-                offset > (int)this.length - length) { // careful of overflow
-            throw outOfBoundException(offset, length);
-        }
-    }
-
-    UnsupportedOperationException unsupportedAccessMode(int expected) {
-        return new UnsupportedOperationException((String.format("Required access mode %s ; current access modes: %s",
-                modeStrings(expected).get(0), modeStrings(mask))));
-    }
-
-    private List<String> modeStrings(int mode) {
-        List<String> modes = new ArrayList<>();
-        if ((mode & READ) != 0) {
-            modes.add("READ");
-        }
-        if ((mode & WRITE) != 0) {
-            modes.add("WRITE");
-        }
-        if ((mode & CLOSE) != 0) {
-            modes.add("CLOSE");
-        }
-        if ((mode & ACQUIRE) != 0) {
-            modes.add("ACQUIRE");
-        }
-        return modes;
-    }
-
-    private IndexOutOfBoundsException outOfBoundException(long offset, long length) {
-        return new IndexOutOfBoundsException(String.format("Out of bound access on segment %s; new offset = %d; new length = %d",
-                        this, offset, length));
-    }
-
-    private int id() {
-        //compute a stable and random id for this memory segment
-        return Math.abs(Objects.hash(base, min, NONCE));
-    }
-
-    static class SegmentSplitter implements Spliterator<MemorySegment> {
-        MemorySegmentImpl segment;
-        long elemCount;
-        final long elementSize;
-        long currentIndex;
-
-        SegmentSplitter(long elementSize, long elemCount, MemorySegmentImpl segment) {
-            this.segment = segment;
-            this.elementSize = elementSize;
-            this.elemCount = elemCount;
-        }
-
-        @Override
-        public SegmentSplitter trySplit() {
-            if (currentIndex == 0 && elemCount > 1) {
-                MemorySegmentImpl parent = segment;
-                long rem = elemCount % 2;
-                long split = elemCount / 2;
-                long lobound = split * elementSize;
-                long hibound = lobound + (rem * elementSize);
-                elemCount  = split + rem;
-                segment = parent.asSliceNoCheck(lobound, hibound);
-                return new SegmentSplitter(elementSize, split, parent.asSliceNoCheck(0, lobound));
-            } else {
-                return null;
-            }
-        }
-
-        @Override
-        public boolean tryAdvance(Consumer<? super MemorySegment> action) {
-            Objects.requireNonNull(action);
-            if (currentIndex < elemCount) {
-                MemorySegmentImpl acquired = segment.acquire();
-                try {
-                    action.accept(acquired.asSliceNoCheck(currentIndex * elementSize, elementSize));
-                } finally {
-                    acquired.closeNoCheck();
-                    currentIndex++;
-                    if (currentIndex == elemCount) {
-                        segment = null;
-                    }
-                }
-                return true;
-            } else {
-                return false;
-            }
-        }
-
-        @Override
-        public void forEachRemaining(Consumer<? super MemorySegment> action) {
-            Objects.requireNonNull(action);
-            if (currentIndex < elemCount) {
-                MemorySegmentImpl acquired = segment.acquire();
-                try {
-                    if (acquired.isSmall()) {
-                        int index = (int) currentIndex;
-                        int limit = (int) elemCount;
-                        int elemSize = (int) elementSize;
-                        for (; index < limit; index++) {
-                            action.accept(acquired.asSliceNoCheck(index * elemSize, elemSize));
-                        }
-                    } else {
-                        for (long i = currentIndex ; i < elemCount ; i++) {
-                            action.accept(acquired.asSliceNoCheck(i * elementSize, elementSize));
-                        }
-                    }
-                } finally {
-                    acquired.closeNoCheck();
-                    currentIndex = elemCount;
-                    segment = null;
-                }
-            }
-        }
-
-        @Override
-        public long estimateSize() {
-            return elemCount;
-        }
-
-        @Override
-        public int characteristics() {
-            return NONNULL | SUBSIZED | SIZED | IMMUTABLE | ORDERED;
-        }
-    }
-}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java
@@ -0,0 +1,113 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.foreign;
+
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.access.JavaNioAccess;
+import jdk.internal.access.SharedSecrets;
+import jdk.internal.misc.Unsafe;
+import jdk.internal.vm.annotation.ForceInline;
+import sun.security.action.GetBooleanAction;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Implementation for native memory segments. A native memory segment is essentially a wrapper around
+ * a native long address.
+ */
+public class NativeMemorySegmentImpl extends AbstractMemorySegmentImpl {
+
+    private static final Unsafe unsafe = Unsafe.getUnsafe();
+
+    // The maximum alignment supported by malloc - typically 16 on
+    // 64-bit platforms and 8 on 32-bit platforms.
+    private final static long MAX_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;
+
+    private static final boolean skipZeroMemory = GetBooleanAction.privilegedGetProperty("jdk.internal.foreign.skipZeroMemory");
+
+    final long min;
+
+    @ForceInline
+    NativeMemorySegmentImpl(long min, long length, int mask, Thread owner, MemoryScope scope) {
+        super(length, mask, owner, scope);
+        this.min = min;
+    }
+
+    @Override
+    AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
+        return new NativeMemorySegmentImpl(min + offset, size, mask, owner, scope);
+    }
+
+    @Override
+    ByteBuffer makeByteBuffer() {
+        JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
+        return nioAccess.newDirectByteBuffer(min(), (int) this.length, null, this);
+    }
+
+    @Override
+    long min() {
+        return min;
+    }
+
+    @Override
+    Object base() {
+        return null;
+    }
+
+    // factories
+
+    public static MemorySegment makeNativeSegment(long bytesSize, long alignmentBytes) {
+        long alignedSize = bytesSize;
+
+        if (alignmentBytes > MAX_ALIGN) {
+            alignedSize = bytesSize + (alignmentBytes - 1);
+        }
+
+        long buf = unsafe.allocateMemory(alignedSize);
+        if (!skipZeroMemory) {
+            unsafe.setMemory(buf, alignedSize, (byte)0);
+        }
+        long alignedBuf = Utils.alignUp(buf, alignmentBytes);
+        MemoryScope scope = new MemoryScope(null, () -> unsafe.freeMemory(buf));
+        MemorySegment segment = new NativeMemorySegmentImpl(buf, alignedSize, defaultAccessModes(alignedSize),
+                Thread.currentThread(), scope);
+        if (alignedBuf != buf) {
+            long delta = alignedBuf - buf;
+            segment = segment.asSlice(delta, bytesSize);
+        }
+        return segment;
+    }
+
+    public static MemorySegment makeNativeSegmentUnchecked(long min, long bytesSize, Thread owner, boolean allowClose) {
+        MemoryScope scope = new MemoryScope(null, allowClose ? () -> unsafe.freeMemory(min) : null);
+        int mask = defaultAccessModes(bytesSize);
+        if (!allowClose) {
+            mask &= ~MemorySegment.CLOSE;
+        }
+        return new NativeMemorySegmentImpl(min, bytesSize, mask, owner, scope);
+    }
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -51,12 +51,10 @@
 /**
  * This class contains misc helper functions to support creation of memory segments.
  */
 public final class Utils {
 
-    private static final Unsafe unsafe = Unsafe.getUnsafe();
-
     private static final MethodHandle ADDRESS_FILTER;
 
     static {
         try {
             ADDRESS_FILTER = MethodHandles.lookup().findStatic(Utils.class, "filterAddress",
@@ -64,18 +62,10 @@
         } catch (Throwable ex) {
             throw new ExceptionInInitializerError(ex);
         }
     }
 
-    // The maximum alignment supported by malloc - typically 16 on
-    // 64-bit platforms and 8 on 32-bit platforms.
-    private final static long MAX_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;
-
-    private static final JavaNioAccess javaNioAccess = SharedSecrets.getJavaNioAccess();
-
-    private static final boolean skipZeroMemory = GetBooleanAction.privilegedGetProperty("jdk.internal.foreign.skipZeroMemory");
-
     public static long alignUp(long n, long alignment) {
         return (n + alignment - 1) & -alignment;
     }
 
     public static long bitsToBytesOrThrow(long bits, Supplier<RuntimeException> exFactory) {
@@ -84,106 +74,10 @@
         } else {
             throw exFactory.get();
         }
     }
 
-    // segment factories
-
-    public static MemorySegment makeNativeSegment(long bytesSize, long alignmentBytes) {
-        long alignedSize = bytesSize;
-
-        if (alignmentBytes > MAX_ALIGN) {
-            alignedSize = bytesSize + (alignmentBytes - 1);
-        }
-
-        long buf = unsafe.allocateMemory(alignedSize);
-        if (!skipZeroMemory) {
-            unsafe.setMemory(buf, alignedSize, (byte)0);
-        }
-        long alignedBuf = Utils.alignUp(buf, alignmentBytes);
-        MemoryScope scope = new MemoryScope(null, () -> unsafe.freeMemory(buf));
-        MemorySegment segment = new MemorySegmentImpl(buf, null, alignedSize, Thread.currentThread(), scope);
-        if (alignedBuf != buf) {
-            long delta = alignedBuf - buf;
-            segment = segment.asSlice(delta, bytesSize);
-        }
-        return segment;
-    }
-
-    public static MemorySegment makeNativeSegmentUnchecked(long min, long bytesSize, Thread owner, boolean allowClose) {
-        MemoryScope scope = new MemoryScope(null, allowClose ? () -> unsafe.freeMemory(min) : null);
-        int mask = MemorySegmentImpl.DEFAULT_MASK;
-        if (!allowClose) {
-            mask &= ~MemorySegment.CLOSE;
-        }
-        return new MemorySegmentImpl(min, null, bytesSize, mask, owner, scope);
-    }
-
-    public static MemorySegment makeArraySegment(byte[] arr) {
-        return makeArraySegment(arr, arr.length, Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE);
-    }
-
-    public static MemorySegment makeArraySegment(char[] arr) {
-        return makeArraySegment(arr, arr.length, Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE);
-    }
-
-    public static MemorySegment makeArraySegment(short[] arr) {
-        return makeArraySegment(arr, arr.length, Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE);
-    }
-
-    public static MemorySegment makeArraySegment(int[] arr) {
-        return makeArraySegment(arr, arr.length, Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE);
-    }
-
-    public static MemorySegment makeArraySegment(float[] arr) {
-        return makeArraySegment(arr, arr.length, Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE);
-    }
-
-    public static MemorySegment makeArraySegment(long[] arr) {
-        return makeArraySegment(arr, arr.length, Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE);
-    }
-
-    public static MemorySegment makeArraySegment(double[] arr) {
-        return makeArraySegment(arr, arr.length, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE);
-    }
-
-    private static MemorySegment makeArraySegment(Object arr, int size, int base, int scale) {
-        MemoryScope scope = new MemoryScope(null, null);
-        return new MemorySegmentImpl(base, arr, size * scale, Thread.currentThread(), scope);
-    }
-
-    public static MemorySegment makeBufferSegment(ByteBuffer bb) {
-        long bbAddress = javaNioAccess.getBufferAddress(bb);
-        Object base = javaNioAccess.getBufferBase(bb);
-
-        int pos = bb.position();
-        int limit = bb.limit();
-
-        MemoryScope bufferScope = new MemoryScope(bb, null);
-        return new MemorySegmentImpl(bbAddress + pos, base, limit - pos, Thread.currentThread(), bufferScope);
-    }
-
-    // create and map a file into a fresh segment
-    public static MemorySegment makeMappedSegment(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
-        if (bytesSize <= 0) throw new IllegalArgumentException("Requested bytes size must be > 0.");
-        try (FileChannelImpl channelImpl = (FileChannelImpl)FileChannel.open(path, openOptions(mapMode))) {
-            UnmapperProxy unmapperProxy = channelImpl.mapInternal(mapMode, 0L, bytesSize);
-            MemoryScope scope = new MemoryScope(null, unmapperProxy::unmap);
-            return new MemorySegmentImpl(unmapperProxy.address(), null, bytesSize, Thread.currentThread(), scope);
-        }
-    }
-
-    private static OpenOption[] openOptions(FileChannel.MapMode mapMode) {
-        if (mapMode == FileChannel.MapMode.READ_ONLY) {
-            return new OpenOption[] { StandardOpenOption.READ };
-        } else if (mapMode == FileChannel.MapMode.READ_WRITE || mapMode == FileChannel.MapMode.PRIVATE) {
-            return new OpenOption[] { StandardOpenOption.READ, StandardOpenOption.WRITE };
-        } else {
-            throw new UnsupportedOperationException("Unsupported map mode: " + mapMode);
-        }
-    }
-
     public static VarHandle fixUpVarHandle(VarHandle handle) {
         // This adaptation is required, otherwise the memory access var handle will have type MemoryAddressProxy,
         // and not MemoryAddress (which the user expects), which causes performance issues with asType() adaptations.
         return MethodHandles.filterCoordinates(handle, 0, ADDRESS_FILTER);
     }
diff a/test/jdk/java/foreign/TestByteBuffer.java b/test/jdk/java/foreign/TestByteBuffer.java
--- a/test/jdk/java/foreign/TestByteBuffer.java
+++ b/test/jdk/java/foreign/TestByteBuffer.java
@@ -37,10 +37,11 @@
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
 import jdk.incubator.foreign.SequenceLayout;
 
 import java.io.File;
+import java.io.IOException;
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.lang.ref.WeakReference;
 import java.lang.reflect.InvocationTargetException;
@@ -51,35 +52,52 @@
 import java.nio.ByteOrder;
 import java.nio.CharBuffer;
 import java.nio.DoubleBuffer;
 import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
-import java.nio.InvalidMarkException;
 import java.nio.LongBuffer;
 import java.nio.MappedByteBuffer;
 import java.nio.ShortBuffer;
 import java.nio.channels.FileChannel;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.Optional;
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import java.util.function.Function;
-import java.util.function.Supplier;
+import java.util.function.Predicate;
 import java.util.stream.Stream;
 
+import jdk.internal.foreign.HeapMemorySegmentImpl;
+import jdk.internal.foreign.MappedMemorySegmentImpl;
 import jdk.internal.foreign.MemoryAddressImpl;
+import jdk.internal.foreign.NativeMemorySegmentImpl;
 import org.testng.SkipException;
 import org.testng.annotations.*;
 import sun.nio.ch.DirectBuffer;
 
 import static org.testng.Assert.*;
 
 public class TestByteBuffer {
 
+    static Path tempPath;
+
+    static {
+        try {
+            File file = File.createTempFile("buffer", "txt");
+            file.deleteOnExit();
+            tempPath = file.toPath();
+            Files.write(file.toPath(), new byte[256], StandardOpenOption.WRITE);
+
+        } catch (IOException ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
+
     static SequenceLayout tuples = MemoryLayout.ofSequence(500,
             MemoryLayout.ofStruct(
                     MemoryLayouts.BITS_32_BE.withName("index"),
                     MemoryLayouts.BITS_32_BE.withName("value")
             ));
@@ -201,11 +219,11 @@
         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -> {
                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
                 MemoryAddress base = segment.baseAddress();
                 initTuples(base);
-                mbb.force();
+                ((MappedByteBuffer)segment.asByteBuffer()).force(); //force via segment
             });
         }
 
         //read from channel
         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
@@ -424,10 +442,27 @@
             MemoryAddress.copy(nativeArray.baseAddress(), heapArray.baseAddress(), bytes);
             checker.accept(heapArray.baseAddress());
         }
     }
 
+    @Test(dataProvider="bufferSources")
+    public void testBufferToSegment(ByteBuffer bb, Predicate<MemorySegment> segmentChecker) {
+        MemorySegment segment = MemorySegment.ofByteBuffer(bb);
+        assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
+        assertTrue(segmentChecker.test(segment));
+        assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
+        assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
+        assertEquals(bb.capacity(), segment.byteSize());
+        //another round trip
+        segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());
+        assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());
+        assertTrue(segmentChecker.test(segment));
+        assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));
+        assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
+        assertEquals(bb.capacity(), segment.byteSize());
+    }
+
     @DataProvider(name = "bufferOps")
     public static Object[][] bufferOps() throws Throwable {
         return new Object[][]{
                 { (Function<ByteBuffer, Buffer>) bb -> bb, bufferMembers(ByteBuffer.class)},
                 { (Function<ByteBuffer, Buffer>) ByteBuffer::asCharBuffer, bufferMembers(CharBuffer.class)},
@@ -567,6 +602,29 @@
             }
         } else {
             return null;
         }
     }
+
+    @DataProvider(name = "bufferSources")
+    public static Object[][] bufferSources() {
+        Predicate<MemorySegment> heapTest = segment -> segment instanceof HeapMemorySegmentImpl;
+        Predicate<MemorySegment> nativeTest = segment -> segment instanceof NativeMemorySegmentImpl;
+        Predicate<MemorySegment> mappedTest = segment -> segment instanceof MappedMemorySegmentImpl;
+        try (FileChannel channel = FileChannel.open(tempPath, StandardOpenOption.READ, StandardOpenOption.WRITE)) {
+            return new Object[][]{
+                    { ByteBuffer.wrap(new byte[256]), heapTest },
+                    { ByteBuffer.allocate(256), heapTest },
+                    { ByteBuffer.allocateDirect(256), nativeTest },
+                    { channel.map(FileChannel.MapMode.READ_WRITE, 0L, 256), mappedTest },
+
+                    { ByteBuffer.wrap(new byte[256]).asReadOnlyBuffer(), heapTest },
+                    { ByteBuffer.allocate(256).asReadOnlyBuffer(), heapTest },
+                    { ByteBuffer.allocateDirect(256).asReadOnlyBuffer(), nativeTest },
+                    { channel.map(FileChannel.MapMode.READ_WRITE, 0L, 256).asReadOnlyBuffer(),
+                            nativeTest /* this seems to be an existing bug in the BB implementation */ }
+            };
+        } catch (IOException ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
 }
diff a/test/jdk/java/foreign/TestNative.java b/test/jdk/java/foreign/TestNative.java
--- a/test/jdk/java/foreign/TestNative.java
+++ b/test/jdk/java/foreign/TestNative.java
@@ -23,20 +23,22 @@
  */
 
 /*
  * @test
  * @modules java.base/jdk.internal.misc
- *          jdk.incubator.foreign
+ *          jdk.incubator.foreign/jdk.internal.foreign
  * @run testng TestNative
  */
 
+import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
+import jdk.internal.foreign.InternalForeign;
 import jdk.internal.misc.Unsafe;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.VarHandle;
@@ -167,10 +169,24 @@
             assertEquals(buf.capacity(), expected);
             assertEquals(getCapacity(buf), expected);
         }
     }
 
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadResize() {
+        try (MemorySegment segment = MemorySegment.allocateNative(4)) {
+            InternalForeign.getInstancePrivileged().withSize(segment.baseAddress(), 12);
+        }
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void testBadMallocSegment() {
+        try (MemorySegment segment = MemorySegment.allocateNative(4)) {
+            InternalForeign.getInstancePrivileged().asMallocSegment(segment.baseAddress(), 12);
+        }
+    }
+
     static {
         System.loadLibrary("NativeAccess");
     }
 
     @DataProvider(name = "nativeAccessOps")
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
@@ -73,11 +73,10 @@
         }
         segment = MemorySegment.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
             VH_int.set(segment.baseAddress(), (long) i, i);
         }
-
         byteBuffer = ByteBuffer.allocateDirect(ALLOC_SIZE).order(ByteOrder.nativeOrder());
         for (int i = 0; i < ELEM_SIZE; i++) {
             byteBuffer.putInt(i * CARRIER_SIZE , i);
         }
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
--- /dev/null
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.bench.jdk.incubator.foreign;
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import org.openjdk.jmh.annotations.Benchmark;
+import org.openjdk.jmh.annotations.BenchmarkMode;
+import org.openjdk.jmh.annotations.Fork;
+import org.openjdk.jmh.annotations.Measurement;
+import org.openjdk.jmh.annotations.Mode;
+import org.openjdk.jmh.annotations.OutputTimeUnit;
+import org.openjdk.jmh.annotations.Setup;
+import org.openjdk.jmh.annotations.State;
+import org.openjdk.jmh.annotations.TearDown;
+import org.openjdk.jmh.annotations.Warmup;
+import sun.misc.Unsafe;
+
+import java.lang.invoke.VarHandle;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.concurrent.TimeUnit;
+
+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;
+import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;
+
+@BenchmarkMode(Mode.AverageTime)
+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)
+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)
+@State(org.openjdk.jmh.annotations.Scope.Thread)
+@OutputTimeUnit(TimeUnit.MILLISECONDS)
+@Fork(3)
+public class LoopOverNonConstantHeap {
+
+    static final Unsafe unsafe = Utils.unsafe;
+
+    static final int ELEM_SIZE = 1_000_000;
+    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();
+    static final int ALLOC_SIZE = ELEM_SIZE * CARRIER_SIZE;
+    static final int UNSAFE_BYTE_BASE = unsafe.arrayBaseOffset(byte[].class);
+
+    static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());
+    MemorySegment segment;
+    byte[] base;
+
+    ByteBuffer byteBuffer;
+
+    @Setup
+    public void setup() {
+        base = new byte[ALLOC_SIZE];
+        for (int i = 0; i < ELEM_SIZE; i++) {
+            unsafe.putInt(base, UNSAFE_BYTE_BASE + (i * CARRIER_SIZE) , i);
+        }
+        segment = MemorySegment.ofArray(base);
+        byteBuffer = ByteBuffer.wrap(base).order(ByteOrder.nativeOrder());
+    }
+
+    @TearDown
+    public void tearDown() {
+        segment.close();
+    }
+
+    @Benchmark
+    @OutputTimeUnit(TimeUnit.NANOSECONDS)
+    public int unsafe_get() {
+        return unsafe.getInt(base, UNSAFE_BYTE_BASE);
+    }
+
+    @Benchmark
+    @OutputTimeUnit(TimeUnit.NANOSECONDS)
+    public int segment_get() {
+        return (int) VH_int.get(segment.baseAddress(), 0L);
+    }
+
+    @Benchmark
+    @OutputTimeUnit(TimeUnit.NANOSECONDS)
+    public int BB_get() {
+        return byteBuffer.getInt(0);
+    }
+
+    @Benchmark
+    public int unsafe_loop() {
+        int res = 0;
+        for (int i = 0; i < ELEM_SIZE; i ++) {
+            res += unsafe.getInt(base, UNSAFE_BYTE_BASE + (i * CARRIER_SIZE));
+        }
+        return res;
+    }
+
+    @Benchmark
+    public int segment_loop() {
+        int sum = 0;
+        MemoryAddress base = segment.baseAddress();
+        for (int i = 0; i < ELEM_SIZE; i++) {
+            sum += (int) VH_int.get(base, (long) i);
+        }
+        return sum;
+    }
+
+    @Benchmark
+    public int segment_loop_slice() {
+        int sum = 0;
+        MemoryAddress base = segment.asSlice(0, segment.byteSize()).baseAddress();
+        for (int i = 0; i < ELEM_SIZE; i++) {
+            sum += (int) VH_int.get(base, (long) i);
+        }
+        return sum;
+    }
+
+    @Benchmark
+    public int segment_loop_readonly() {
+        int sum = 0;
+        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).baseAddress();
+        for (int i = 0; i < ELEM_SIZE; i++) {
+            sum += (int) VH_int.get(base, (long) i);
+        }
+        return sum;
+    }
+
+    @Benchmark
+    public int BB_loop() {
+        int sum = 0;
+        ByteBuffer bb = byteBuffer;
+        for (int i = 0; i < ELEM_SIZE; i++) {
+            sum += bb.getInt(i * CARRIER_SIZE);
+        }
+        return sum;
+    }
+
+}
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
--- /dev/null
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.bench.jdk.incubator.foreign;
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import org.openjdk.jmh.annotations.Benchmark;
+import org.openjdk.jmh.annotations.BenchmarkMode;
+import org.openjdk.jmh.annotations.Fork;
+import org.openjdk.jmh.annotations.Measurement;
+import org.openjdk.jmh.annotations.Mode;
+import org.openjdk.jmh.annotations.OutputTimeUnit;
+import org.openjdk.jmh.annotations.Setup;
+import org.openjdk.jmh.annotations.State;
+import org.openjdk.jmh.annotations.TearDown;
+import org.openjdk.jmh.annotations.Warmup;
+import sun.misc.Unsafe;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.MappedByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
+import java.util.concurrent.TimeUnit;
+
+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;
+import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;
+
+@BenchmarkMode(Mode.AverageTime)
+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)
+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)
+@State(org.openjdk.jmh.annotations.Scope.Thread)
+@OutputTimeUnit(TimeUnit.MILLISECONDS)
+@Fork(3)
+public class LoopOverNonConstantMapped {
+
+    static final Unsafe unsafe = Utils.unsafe;
+
+    static final int ELEM_SIZE = 1_000_000;
+    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();
+    static final int ALLOC_SIZE = ELEM_SIZE * CARRIER_SIZE;
+
+    static final Path tempPath;
+
+    static {
+        try {
+            File file = File.createTempFile("buffer", "txt");
+            file.deleteOnExit();
+            tempPath = file.toPath();
+            Files.write(file.toPath(), new byte[ALLOC_SIZE], StandardOpenOption.WRITE);
+
+        } catch (IOException ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
+
+    static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());
+    MemorySegment segment;
+    long unsafe_addr;
+
+    ByteBuffer byteBuffer;
+
+    @Setup
+    public void setup() throws IOException {
+        try (FileChannel channel = FileChannel.open(tempPath, StandardOpenOption.READ, StandardOpenOption.WRITE)) {
+            byteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, ALLOC_SIZE).order(ByteOrder.nativeOrder());
+            for (int i = 0; i < ELEM_SIZE; i++) {
+                byteBuffer.putInt(i * CARRIER_SIZE, i);
+            }
+            ((MappedByteBuffer)byteBuffer).force();
+        }
+        segment = MemorySegment.mapFromPath(tempPath, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE);
+        unsafe_addr = segment.baseAddress().toRawLongValue();
+    }
+
+    @TearDown
+    public void tearDown() {
+        segment.close();
+        unsafe.invokeCleaner(byteBuffer);
+    }
+
+    @Benchmark
+    @OutputTimeUnit(TimeUnit.NANOSECONDS)
+    public int unsafe_get() {
+        return unsafe.getInt(unsafe_addr);
+    }
+
+    @Benchmark
+    @OutputTimeUnit(TimeUnit.NANOSECONDS)
+    public int segment_get() {
+        return (int) VH_int.get(segment.baseAddress(), 0L);
+    }
+
+    @Benchmark
+    @OutputTimeUnit(TimeUnit.NANOSECONDS)
+    public int BB_get() {
+        return byteBuffer.getInt(0);
+    }
+
+    @Benchmark
+    public int unsafe_loop() {
+        int res = 0;
+        for (int i = 0; i < ELEM_SIZE; i ++) {
+            res += unsafe.getInt(unsafe_addr + (i * CARRIER_SIZE));
+        }
+        return res;
+    }
+
+    @Benchmark
+    public int segment_loop() {
+        int sum = 0;
+        MemoryAddress base = segment.baseAddress();
+        for (int i = 0; i < ELEM_SIZE; i++) {
+            sum += (int) VH_int.get(base, (long) i);
+        }
+        return sum;
+    }
+
+    @Benchmark
+    public int segment_loop_slice() {
+        int sum = 0;
+        MemoryAddress base = segment.asSlice(0, segment.byteSize()).baseAddress();
+        for (int i = 0; i < ELEM_SIZE; i++) {
+            sum += (int) VH_int.get(base, (long) i);
+        }
+        return sum;
+    }
+
+    @Benchmark
+    public int segment_loop_readonly() {
+        int sum = 0;
+        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).baseAddress();
+        for (int i = 0; i < ELEM_SIZE; i++) {
+            sum += (int) VH_int.get(base, (long) i);
+        }
+        return sum;
+    }
+
+    @Benchmark
+    public int BB_loop() {
+        int sum = 0;
+        ByteBuffer bb = byteBuffer;
+        for (int i = 0; i < ELEM_SIZE; i++) {
+            sum += bb.getInt(i * CARRIER_SIZE);
+        }
+        return sum;
+    }
+
+}
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
@@ -48,10 +48,11 @@
 import java.util.List;
 import java.util.Spliterator;
 import java.util.concurrent.CountedCompleter;
 import java.util.concurrent.RecursiveTask;
 import java.util.concurrent.TimeUnit;
+import java.util.function.IntFunction;
 import java.util.function.ToIntFunction;
 import java.util.stream.StreamSupport;
 
 import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;
 import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;
@@ -115,42 +116,41 @@
         return res;
     }
 
     @Benchmark
     public int segment_parallel() {
-        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT), ParallelSum::segmentToInt).invoke();
+        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT), SEGMENT_TO_INT).invoke();
     }
 
     @Benchmark
     public int segment_parallel_bulk() {
-        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT_BULK), ParallelSum::segmentToIntBulk).invoke();
+        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT_BULK), SEGMENT_TO_INT_BULK).invoke();
     }
 
     @Benchmark
     public int segment_stream_parallel() {
         return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)
-                .mapToInt(ParallelSum::segmentToInt).sum();
+                .mapToInt(SEGMENT_TO_INT).sum();
     }
 
     @Benchmark
     public int segment_stream_parallel_bulk() {
         return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), true)
-                .mapToInt(ParallelSum::segmentToIntBulk).sum();
+                .mapToInt(SEGMENT_TO_INT_BULK).sum();
     }
 
-    static int segmentToInt(MemorySegment slice) {
-        return (int) VH_int.get(slice.baseAddress(), 0L);
-    }
+    final static ToIntFunction<MemorySegment> SEGMENT_TO_INT = slice ->
+        (int) VH_int.get(slice.baseAddress(), 0L);
 
-    static int segmentToIntBulk(MemorySegment slice) {
+    final static ToIntFunction<MemorySegment> SEGMENT_TO_INT_BULK = slice -> {
         int res = 0;
         MemoryAddress base = slice.baseAddress();
         for (int i = 0; i < BULK_FACTOR ; i++) {
             res += (int)VH_int.get(base, (long) i);
         }
         return res;
-    }
+    };
 
     @Benchmark
     public int unsafe_parallel() {
         return new SumUnsafe(address, 0, ALLOC_SIZE).invoke();
     }
@@ -184,33 +184,52 @@
                 return res;
             }
         }
     }
 
-    static class SumSegment extends RecursiveTask<Integer> {
+    static class SumSegment extends CountedCompleter<Integer> {
 
         final static int SPLIT_THRESHOLD = 1024 * 8;
 
-        private final Spliterator<MemorySegment> splitter;
+        int localSum = 0;
         private final ToIntFunction<MemorySegment> mapper;
-        int result;
+        List<SumSegment> children = new LinkedList<>();
+
+        private Spliterator<MemorySegment> segmentSplitter;
 
-        SumSegment(Spliterator<MemorySegment> splitter, ToIntFunction<MemorySegment> mapper) {
-            this.splitter = splitter;
+        SumSegment(Spliterator<MemorySegment> segmentSplitter, ToIntFunction<MemorySegment> mapper) {
+            this(null, segmentSplitter, mapper);
+        }
+
+        SumSegment(SumSegment parent, Spliterator<MemorySegment> segmentSplitter, ToIntFunction<MemorySegment> mapper) {
+            super(parent);
+            this.segmentSplitter = segmentSplitter;
             this.mapper = mapper;
         }
 
         @Override
-        protected Integer compute() {
-            if (splitter.estimateSize() > SPLIT_THRESHOLD) {
-                SumSegment sub = new SumSegment(splitter.trySplit(), mapper);
-                sub.fork();
-                return compute() + sub.join();
-            } else {
-                splitter.forEachRemaining(s -> {
-                    result += mapper.applyAsInt(s);
-                });
-                return result;
+        public void compute() {
+            Spliterator<MemorySegment> sub;
+            while (segmentSplitter.estimateSize() > SPLIT_THRESHOLD &&
+                    (sub = segmentSplitter.trySplit()) != null) {
+                addToPendingCount(1);
+                SumSegment child = new SumSegment(this, sub, mapper);
+                children.add(child);
+                child.fork();
+            }
+            segmentSplitter.forEachRemaining(s -> {
+                localSum += mapper.applyAsInt(s);
+            });
+            propagateCompletion();
+        }
+
+        @Override
+        public Integer getRawResult() {
+            int sum = localSum;
+            for (SumSegment c : children) {
+                sum += c.getRawResult();
             }
+            children = null;
+            return sum;
         }
     }
 }

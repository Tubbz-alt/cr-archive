<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old make/jdk/src/classes/build/tools/module/GenModuleInfoSource.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package build.tools.module;
 26 
 27 import java.io.BufferedWriter;
 28 import java.io.IOException;
 29 import java.io.PrintWriter;
 30 import java.nio.file.Files;
 31 import java.nio.file.Path;
 32 import java.nio.file.Paths;
 33 import java.util.ArrayList;
 34 import java.util.Arrays;
 35 import java.util.Collections;
 36 import java.util.HashMap;
 37 import java.util.LinkedHashSet;
 38 import java.util.List;
 39 import java.util.Map;
 40 import java.util.Objects;
 41 import java.util.Set;
 42 import java.util.stream.Collectors;
 43 import java.util.stream.Stream;
 44 import static java.util.stream.Collectors.*;
 45 
 46 /**
 47  * A build tool to extend the module-info.java in the source tree for
 48  * platform-specific exports, opens, uses, and provides and write to
 49  * the specified output file.
 50  *
 51  * GenModuleInfoSource will be invoked for each module that has
 52  * module-info.java.extra in the source directory.
 53  *
 54  * The extra exports, opens, uses, provides can be specified
 55  * in module-info.java.extra.
 56  * Injecting platform-specific requires is not supported.
 57  *
 58  * @see build.tools.module.ModuleInfoExtraTest for basic testing
 59  */
 60 public class GenModuleInfoSource {
 61     private final static String USAGE =
 62         &quot;Usage: GenModuleInfoSource -o &lt;output file&gt; \n&quot; +
 63         &quot;  --source-file &lt;module-info-java&gt;\n&quot; +
 64         &quot;  --modules &lt;module-name&gt;[,&lt;module-name&gt;...]\n&quot; +
 65         &quot;  &lt;module-info.java.extra&gt; ...\n&quot;;
 66 
 67     static boolean verbose = false;
 68     public static void main(String... args) throws Exception {
 69         Path outfile = null;
 70         Path moduleInfoJava = null;
 71         Set&lt;String&gt; modules = Collections.emptySet();
 72         List&lt;Path&gt; extras = new ArrayList&lt;&gt;();
 73         // validate input arguments
 74         for (int i = 0; i &lt; args.length; i++){
 75             String option = args[i];
 76             String arg = i+1 &lt; args.length ? args[i+1] : null;
 77             switch (option) {
 78                 case &quot;-o&quot;:
 79                     outfile = Paths.get(arg);
 80                     i++;
 81                     break;
 82                 case &quot;--source-file&quot;:
 83                     moduleInfoJava = Paths.get(arg);
 84                     if (Files.notExists(moduleInfoJava)) {
 85                         throw new IllegalArgumentException(moduleInfoJava + &quot; not exist&quot;);
 86                     }
 87                     i++;
 88                     break;
 89                 case &quot;--modules&quot;:
 90                     modules = Arrays.stream(arg.split(&quot;,&quot;))
 91                                     .collect(toSet());
 92                     i++;
 93                     break;
 94                 case &quot;-v&quot;:
 95                     verbose = true;
 96                     break;
 97                 default:
 98                     Path file = Paths.get(option);
 99                     if (Files.notExists(file)) {
100                         throw new IllegalArgumentException(file + &quot; not exist&quot;);
101                     }
102                     extras.add(file);
103             }
104         }
105 
106         if (moduleInfoJava == null || outfile == null ||
107                 modules.isEmpty() || extras.isEmpty()) {
108             System.err.println(USAGE);
109             System.exit(-1);
110         }
111 
112         GenModuleInfoSource genModuleInfo =
113             new GenModuleInfoSource(moduleInfoJava, extras, modules);
114 
115         // generate new module-info.java
116         genModuleInfo.generate(outfile);
117     }
118 
119     final Path sourceFile;
120     final List&lt;Path&gt; extraFiles;
121     final ModuleInfo extras;
122     final Set&lt;String&gt; modules;
123     final ModuleInfo moduleInfo;
124     GenModuleInfoSource(Path sourceFile, List&lt;Path&gt; extraFiles, Set&lt;String&gt; modules)
125         throws IOException
126     {
127         this.sourceFile = sourceFile;
128         this.extraFiles = extraFiles;
129         this.modules = modules;
130         this.moduleInfo = new ModuleInfo();
131         this.moduleInfo.parse(sourceFile);
132 
133         // parse module-info.java.extra
134         this.extras = new ModuleInfo();
135         for (Path file : extraFiles) {
136             extras.parseExtra(file);
137         }
138 
139         // merge with module-info.java.extra
140         moduleInfo.augmentModuleInfo(extras, modules);
141     }
142 
143     void generate(Path output) throws IOException {
144         List&lt;String&gt; lines = Files.readAllLines(sourceFile);
145         try (BufferedWriter bw = Files.newBufferedWriter(output);
146              PrintWriter writer = new PrintWriter(bw)) {
147             // write the copyright header and lines up to module declaration
148             for (String l : lines) {
149                 writer.println(l);
150                 if (l.trim().startsWith(&quot;module &quot;)) {
151                     // print URI rather than file path to avoid escape
152                     writer.format(&quot;    // source file: %s%n&quot;, sourceFile.toUri());
153                     for (Path file: extraFiles) {
154                         writer.format(&quot;    //              %s%n&quot;, file.toUri());
155                     }
156                     break;
157                 }
158             }
159 
160             // requires
161             for (String l : lines) {
162                 if (l.trim().startsWith(&quot;requires&quot;))
163                     writer.println(l);
164             }
165 
166             // write exports, opens, uses, and provides
167             moduleInfo.print(writer);
168 
169             // close
170             writer.println(&quot;}&quot;);
171         }
172     }
173 
174 
175     class ModuleInfo {
176         final Map&lt;String, Statement&gt; exports = new HashMap&lt;&gt;();
177         final Map&lt;String, Statement&gt; opens = new HashMap&lt;&gt;();
178         final Map&lt;String, Statement&gt; uses = new HashMap&lt;&gt;();
179         final Map&lt;String, Statement&gt; provides = new HashMap&lt;&gt;();
180 
181         Statement getStatement(String directive, String name) {
182             Objects.requireNonNull(name);
183             switch (directive) {
184                 case &quot;exports&quot;:
185                     if (moduleInfo.exports.containsKey(name) &amp;&amp;
186                         moduleInfo.exports.get(name).isUnqualified()) {
187                         throw new IllegalArgumentException(sourceFile +
188                             &quot; already has &quot; + directive + &quot; &quot; + name);
189                     }
190                     return exports.computeIfAbsent(name,
191                         _n -&gt; new Statement(&quot;exports&quot;, &quot;to&quot;, name));
192 
193                 case &quot;opens&quot;:
194                     if (moduleInfo.opens.containsKey(name) &amp;&amp;
195                         moduleInfo.opens.get(name).isUnqualified()) {
196                         throw new IllegalArgumentException(sourceFile +
197                             &quot; already has &quot; + directive + &quot; &quot; + name);
198                     }
199 
200                     if (moduleInfo.opens.containsKey(name)) {
201                         throw new IllegalArgumentException(sourceFile +
202                             &quot; already has &quot; + directive + &quot; &quot; + name);
203                     }
204                     return opens.computeIfAbsent(name,
205                         _n -&gt; new Statement(&quot;opens&quot;, &quot;to&quot;, name));
206 
207                 case &quot;uses&quot;:
208                     return uses.computeIfAbsent(name,
209                         _n -&gt; new Statement(&quot;uses&quot;, &quot;&quot;, name));
210 
211                 case &quot;provides&quot;:
212                     return provides.computeIfAbsent(name,
213                         _n -&gt; new Statement(&quot;provides&quot;, &quot;with&quot;, name, true));
214 
215                 default:
216                     throw new IllegalArgumentException(directive);
217             }
218 
219         }
220 
221         /*
222          * Augment this ModuleInfo with module-info.java.extra
223          */
224         void augmentModuleInfo(ModuleInfo extraFiles, Set&lt;String&gt; modules) {
225             // API package exported in the original module-info.java
226             extraFiles.exports.entrySet()
227                 .stream()
228                 .filter(e -&gt; exports.containsKey(e.getKey()) &amp;&amp;
229                     e.getValue().filter(modules))
230                 .forEach(e -&gt; mergeExportsOrOpens(exports.get(e.getKey()),
231                     e.getValue(),
232                     modules));
233 
234             // add exports that are not defined in the original module-info.java
235             extraFiles.exports.entrySet()
236                 .stream()
237                 .filter(e -&gt; !exports.containsKey(e.getKey()) &amp;&amp;
238                     e.getValue().filter(modules))
239                 .forEach(e -&gt; addTargets(getStatement(&quot;exports&quot;, e.getKey()),
240                     e.getValue(),
241                     modules));
242 
243             // API package opened in the original module-info.java
244             extraFiles.opens.entrySet()
245                 .stream()
246                 .filter(e -&gt; opens.containsKey(e.getKey()) &amp;&amp;
247                     e.getValue().filter(modules))
248                 .forEach(e -&gt; mergeExportsOrOpens(opens.get(e.getKey()),
249                     e.getValue(),
250                     modules));
251 
252             // add opens that are not defined in the original module-info.java
253             extraFiles.opens.entrySet()
254                 .stream()
255                 .filter(e -&gt; !opens.containsKey(e.getKey()) &amp;&amp;
256                     e.getValue().filter(modules))
257                 .forEach(e -&gt; addTargets(getStatement(&quot;opens&quot;, e.getKey()),
258                     e.getValue(),
259                     modules));
260 
261             // provides
262             extraFiles.provides.keySet()
263                 .stream()
264                 .filter(service -&gt; provides.containsKey(service))
265                 .forEach(service -&gt; mergeProvides(service,
266                     extraFiles.provides.get(service)));
267             extraFiles.provides.keySet()
268                 .stream()
269                 .filter(service -&gt; !provides.containsKey(service))
270                 .forEach(service -&gt; provides.put(service,
271                     extraFiles.provides.get(service)));
272 
273             // uses
274             extraFiles.uses.keySet()
275                 .stream()
276                 .filter(service -&gt; !uses.containsKey(service))
277                 .forEach(service -&gt; uses.put(service, extraFiles.uses.get(service)));
278         }
279 
280         // add qualified exports or opens to known modules only
281         private void addTargets(Statement statement,
282                                 Statement extra,
283                                 Set&lt;String&gt; modules)
284         {
285             extra.targets.stream()
286                 .filter(mn -&gt; modules.contains(mn))
287                 .forEach(mn -&gt; statement.addTarget(mn));
288         }
289 
290         private void mergeExportsOrOpens(Statement statement,
291                                          Statement extra,
292                                          Set&lt;String&gt; modules)
293         {
294             String pn = statement.name;
295             if (statement.isUnqualified() &amp;&amp; extra.isQualified()) {
296                 throw new RuntimeException(&quot;can&#39;t add qualified exports to &quot; +
297                     &quot;unqualified exports &quot; + pn);
298             }
299 
300             Set&lt;String&gt; mods = extra.targets.stream()
301                 .filter(mn -&gt; statement.targets.contains(mn))
302                 .collect(toSet());
303             if (mods.size() &gt; 0) {
304                 throw new RuntimeException(&quot;qualified exports &quot; + pn + &quot; to &quot; +
305                     mods.toString() + &quot; already declared in &quot; + sourceFile);
306             }
307 
308             // add qualified exports or opens to known modules only
309             addTargets(statement, extra, modules);
310         }
311 
312         private void mergeProvides(String service, Statement extra) {
313             Statement statement = provides.get(service);
314 
315             Set&lt;String&gt; mods = extra.targets.stream()
316                 .filter(mn -&gt; statement.targets.contains(mn))
317                 .collect(toSet());
318 
319             if (mods.size() &gt; 0) {
320                 throw new RuntimeException(&quot;qualified exports &quot; + service + &quot; to &quot; +
321                     mods.toString() + &quot; already declared in &quot; + sourceFile);
322             }
323 
324             extra.targets.stream()
325                 .forEach(mn -&gt; statement.addTarget(mn));
326         }
327 
328 
329         void print(PrintWriter writer) {
330             // print unqualified exports
331             exports.entrySet().stream()
332                 .filter(e -&gt; e.getValue().targets.isEmpty())
333                 .sorted(Map.Entry.comparingByKey())
334                 .forEach(e -&gt; writer.println(e.getValue()));
335 
336             // print qualified exports
337             exports.entrySet().stream()
338                 .filter(e -&gt; !e.getValue().targets.isEmpty())
339                 .sorted(Map.Entry.comparingByKey())
340                 .forEach(e -&gt; writer.println(e.getValue()));
341 
342             // print unqualified opens
343             opens.entrySet().stream()
344                 .filter(e -&gt; e.getValue().targets.isEmpty())
345                 .sorted(Map.Entry.comparingByKey())
346                 .forEach(e -&gt; writer.println(e.getValue()));
347 
348             // print qualified opens
349             opens.entrySet().stream()
350                 .filter(e -&gt; !e.getValue().targets.isEmpty())
351                 .sorted(Map.Entry.comparingByKey())
352                 .forEach(e -&gt; writer.println(e.getValue()));
353 
354             // uses and provides
355             writer.println();
356             uses.entrySet().stream()
357                 .sorted(Map.Entry.comparingByKey())
358                 .forEach(e -&gt; writer.println(e.getValue()));
359             provides.entrySet().stream()
360                 .sorted(Map.Entry.comparingByKey())
361                 .forEach(e -&gt; writer.println(e.getValue()));
362         }
363 
364 
365         private void parse(Path file) throws IOException {
366             Parser parser = new Parser(file);
367             parser.run();
368             if (verbose) {
369                 parser.dump();
370             }
371             process(parser, false);
372         }
373 
374         private void parseExtra(Path file) throws IOException {
375             Parser parser = new Parser(file);
376             parser.run();
377             if (verbose) {
378                 parser.dump();
379             }
380             process(parser, true);
381         }
382 
383 
384         private void process(Parser parser, boolean extraFile) throws IOException {
385             // no duplicate statement local in each file
386             Map&lt;String, Statement&gt; exports = new HashMap&lt;&gt;();
387             Map&lt;String, Statement&gt; opens = new HashMap&lt;&gt;();
388             Map&lt;String, Statement&gt; uses = new HashMap&lt;&gt;();
389             Map&lt;String, Statement&gt; provides = new HashMap&lt;&gt;();
390 
391             String token = null;
392             boolean hasCurlyBracket = false;
393             while ((token = parser.nextToken()) != null) {
394                 if (token.equals(&quot;module&quot;)) {
395                     String modulename = nextIdentifier(parser);
396                     if (extraFile) {
397                         throw parser.newError(&quot;cannot declare module in &quot; + parser.sourceFile);
398                     }
399                     skipTokenOrThrow(parser, &quot;{&quot;, &quot;missing {&quot;);
400                     hasCurlyBracket = true;
401                 } else if (token.equals(&quot;requires&quot;)) {
402                     token = nextIdentifier(parser);
403                     if (token.equals(&quot;transitive&quot;)) {
404                         token = nextIdentifier(parser);
405                     }
406                     if (extraFile) {
407                         throw parser.newError(&quot;cannot declare requires in &quot; + parser.sourceFile);
408                     }
409                     skipTokenOrThrow(parser, &quot;;&quot;, &quot;missing semicolon&quot;);
410                 } else if (isExportsOpensProvidesUses(token)) {
411                     // new statement
412                     String keyword = token;
413                     String name = nextIdentifier(parser);
414                     Statement statement = getStatement(keyword, name);
415                     switch (keyword) {
416                         case &quot;exports&quot;:
417                             if (exports.containsKey(name)) {
418                                 throw parser.newError(&quot;multiple &quot; + keyword + &quot; &quot; + name);
419                             }
420                             exports.put(name, statement);
421                             break;
422                         case &quot;opens&quot;:
423                             if (opens.containsKey(name)) {
424                                 throw parser.newError(&quot;multiple &quot; + keyword + &quot; &quot; + name);
425                             }
426                             opens.put(name, statement);
427                             break;
428                         case &quot;uses&quot;:
429                             if (uses.containsKey(name)) {
430                                 throw parser.newError(&quot;multiple &quot; + keyword + &quot; &quot; + name);
431                             }
432                             uses.put(name, statement);
433                             break;
434                         case &quot;provides&quot;:
435                             if (provides.containsKey(name)) {
436                                 throw parser.newError(&quot;multiple &quot; + keyword + &quot; &quot; + name);
437                             }
438                             provides.put(name, statement);
439                             break;
440                     }
441                     String lookAhead = lookAhead(parser);
442                     if (lookAhead.equals(statement.qualifier)) {
443                         parser.nextToken(); // skip qualifier
444                         while ((lookAhead = parser.peekToken()) != null) {
445                             // add target name
446                             name = nextIdentifier(parser);
447                             statement.addTarget(name);
448                             lookAhead = lookAhead(parser);
449                             if (lookAhead.equals(&quot;,&quot;) || lookAhead.equals(&quot;;&quot;)) {
450                                 parser.nextToken();
451                             } else {
452                                 throw parser.newError(&quot;missing semicolon&quot;);
453                             }
454                             if (lookAhead.equals(&quot;;&quot;)) {
455                                 break;
456                             }
457                         }
458                     } else {
459                         skipTokenOrThrow(parser, &quot;;&quot;, &quot;missing semicolon&quot;);
460                     }
461                 } else if (token.equals(&quot;;&quot;)) {
462                     continue;
463                 } else if (hasCurlyBracket &amp;&amp; token.equals(&quot;}&quot;)) {
464                     hasCurlyBracket = false;
465                     if (parser.peekToken() != null) {  // must be EOF
466                         throw parser.newError(&quot;is malformed&quot;);
467                     }
468                 } else {
469                     throw parser.newError(&quot;missing keyword&quot;);
470                 }
471             }
472             if (hasCurlyBracket) {
473                 parser.newError(&quot;missing }&quot;);
474             }
475         }
476 
477         private boolean isExportsOpensProvidesUses(String word) {
478             switch (word) {
479                 case &quot;exports&quot;:
480                 case &quot;opens&quot;:
481                 case &quot;provides&quot;:
482                 case &quot;uses&quot;:
483                     return true;
484                 default:
485                     return false;
486             }
487         }
488 
489         private String lookAhead(Parser parser) {
490             String lookAhead = parser.peekToken();
491             if (lookAhead == null) { // EOF
492                 throw parser.newError(&quot;reach end of file&quot;);
493             }
494             return lookAhead;
495         }
496 
497         private String nextIdentifier(Parser parser) {
498             String lookAhead = parser.peekToken();
499             boolean maybeIdentifier = true;
500             switch (lookAhead) {
501                 case &quot;module&quot;:
502                 case &quot;requires&quot;:
503                 case &quot;exports&quot;:
504                 case &quot;opens&quot;:
505                 case &quot;provides&quot;:
506                 case &quot;uses&quot;:
507                 case &quot;to&quot;:
508                 case &quot;with&quot;:
509                 case &quot;,&quot;:
510                 case &quot;;&quot;:
511                 case &quot;{&quot;:
512                 case &quot;}&quot;:
513                     maybeIdentifier = false;
514             }
515             if (lookAhead == null || !maybeIdentifier) {
516                 throw parser.newError(&quot;&lt;identifier&gt; missing&quot;);
517             }
518 
519             return parser.nextToken();
520         }
521 
522         private String skipTokenOrThrow(Parser parser, String token, String msg) {
523             // look ahead to report the proper line number
524             String lookAhead = parser.peekToken();
525             if (!token.equals(lookAhead)) {
526                 throw parser.newError(msg);
527             }
528             return parser.nextToken();
529         }
530     }
531 
532     static class Statement {
533         final String directive;
534         final String qualifier;
535         final String name;
536         final Set&lt;String&gt; targets = new LinkedHashSet&lt;&gt;();
537         final boolean ordered;
538 
539         Statement(String directive, String qualifier, String name) {
540             this(directive, qualifier, name, false);
541         }
542 
543         Statement(String directive, String qualifier, String name, boolean ordered) {
544             this.directive = directive;
545             this.qualifier = qualifier;
546             this.name = name;
547             this.ordered = ordered;
548         }
549 
550         Statement addTarget(String mn) {
551             if (mn.isEmpty())
552                 throw new IllegalArgumentException(&quot;empty module name&quot;);
553             targets.add(mn);
554             return this;
555         }
556 
557         boolean isQualified() {
558             return targets.size() &gt; 0;
559         }
560 
561         boolean isUnqualified() {
562             return targets.isEmpty();
563         }
564 
565         /**
566          * Returns true if this statement is unqualified or it has
567          * at least one target in the given names.
568          */
569         boolean filter(Set&lt;String&gt; names) {
570             if (isUnqualified()) {
571                 return true;
572             } else {
573                 return targets.stream()
574                     .filter(mn -&gt; names.contains(mn))
575                     .findAny().isPresent();
576             }
577         }
578 
579         @Override
580         public String toString() {
581             StringBuilder sb = new StringBuilder(&quot;    &quot;);
582             sb.append(directive).append(&quot; &quot;).append(name);
583             if (targets.isEmpty()) {
584                 sb.append(&quot;;&quot;);
585             } else if (targets.size() == 1) {
586                 sb.append(&quot; &quot;).append(qualifier)
587                   .append(orderedTargets().collect(joining(&quot;,&quot;, &quot; &quot;, &quot;;&quot;)));
588             } else {
589                 sb.append(&quot; &quot;).append(qualifier)
590                   .append(orderedTargets()
591                       .map(target -&gt; String.format(&quot;        %s&quot;, target))
592                       .collect(joining(&quot;,\n&quot;, &quot;\n&quot;, &quot;;&quot;)));
593             }
594             return sb.toString();
595         }
596 
597         public Stream&lt;String&gt; orderedTargets() {
598             return ordered ? targets.stream()
599                            : targets.stream().sorted();
600         }
601     }
602 
603     static void trace(String fmt, Object... params) {
604         if (verbose) {
605             System.out.format(fmt, params);
606         }
607     }
608 
609     static class Parser {
610         private static final List&lt;String&gt; EMPTY = List.of();
611 
612         private final Path sourceFile;
613         private boolean inCommentBlock = false;
614         private List&lt;List&lt;String&gt;&gt; tokens = new ArrayList&lt;&gt;();
615         private int lineNumber = 1;
616         private int index = 0;
617 
618         Parser(Path file) {
619             this.sourceFile = file;
620         }
621 
622         void run() throws IOException {
623             List&lt;String&gt; lines = Files.readAllLines(sourceFile);
624             for (int lineNumber = 1; lineNumber &lt;= lines.size(); lineNumber++) {
625                 String l = lines.get(lineNumber - 1).trim();
626                 tokenize(l);
627             }
628         }
629 
630         /*
631          * Tokenize the given string.  Comments are skipped.
632          */
633         List&lt;String&gt; tokenize(String l) {
634             while (!l.isEmpty()) {
635                 if (inCommentBlock) {
636                     int comment = l.indexOf(&quot;*/&quot;);
637                     if (comment == -1)
638                         return emptyTokens();
639 
640                     // end comment block
641                     inCommentBlock = false;
642                     if ((comment + 2) &gt;= l.length()) {
643                         return emptyTokens();
644                     }
645                     l = l.substring(comment + 2, l.length()).trim();
646                 }
647 
648                 // skip comment
649                 int comment = l.indexOf(&quot;//&quot;);
650                 if (comment &gt;= 0) {
651                     l = l.substring(0, comment).trim();
652                     if (l.isEmpty()) return emptyTokens();
653                 }
654 
655                 if (l.isEmpty()) {
656                     return emptyTokens();
657                 }
658 
659                 int beginComment = l.indexOf(&quot;/*&quot;);
660                 int endComment = l.indexOf(&quot;*/&quot;);
661                 if (beginComment == -1)
662                     return tokens(l);
663 
664                 String s1 = l.substring(0, beginComment).trim();
665                 if (endComment &gt; 0) {
666                     String s2 = l.substring(endComment + 2, l.length()).trim();
667                     if (s1.isEmpty()) {
668                         l = s2;
669                     } else if (s2.isEmpty()) {
670                         l = s1;
671                     } else {
672                         l = s1 + &quot; &quot; + s2;
673                     }
674                 } else {
675                     inCommentBlock = true;
676                     return tokens(s1);
677                 }
678             }
679             return tokens(l);
680         }
681 
682         private List&lt;String&gt; emptyTokens() {
683             this.tokens.add(EMPTY);
684             return EMPTY;
685         }
686         private List&lt;String&gt; tokens(String l) {
687             List&lt;String&gt; tokens = new ArrayList&lt;&gt;();
688             for (String s : l.split(&quot;\\s+&quot;)) {
689                 int pos=0;
690                 s = s.trim();
691                 if (s.isEmpty())
692                      continue;
693 
694                 int i = s.indexOf(&#39;,&#39;, pos);
695                 int j = s.indexOf(&#39;;&#39;, pos);
696                 while ((i &gt;= 0 &amp;&amp; i &lt; s.length()) || (j &gt;= 0 &amp;&amp; j &lt; s.length())) {
697                     if (j == -1 || (i &gt;= 0 &amp;&amp; i &lt; j)) {
698                         String n = s.substring(pos, i).trim();
699                         if (!n.isEmpty()) {
700                             tokens.add(n);
701                         }
702                         tokens.add(s.substring(i, i + 1));
703                         pos = i + 1;
704                         i = s.indexOf(&#39;,&#39;, pos);
705                     } else {
706                         String n = s.substring(pos, j).trim();
707                         if (!n.isEmpty()) {
708                             tokens.add(n);
709                         }
710                         tokens.add(s.substring(j, j + 1));
711                         pos = j + 1;
712                         j = s.indexOf(&#39;;&#39;, pos);
713                     }
714                 }
715 
716                 String n = s.substring(pos).trim();
717                 if (!n.isEmpty()) {
718                     tokens.add(n);
719                 }
720             }
721             this.tokens.add(tokens);
722             return tokens;
723         }
724 
725         /*
726          * Returns next token.
727          */
728         String nextToken() {
729             while (lineNumber &lt;= tokens.size()) {
730                 List&lt;String&gt; l = tokens.get(lineNumber-1);
731                 if (index &lt; l.size()) {
732                     return l.get(index++);
733                 } else {
734                     lineNumber++;
735                     index = 0;
736                 }
737             }
738             return null;
739         }
740 
741         /*
742          * Peeks next token.
743          */
744         String peekToken() {
745             int ln = lineNumber;
746             int i = index;
747             while (ln &lt;= tokens.size()) {
748                 List&lt;String&gt; l = tokens.get(ln-1);
749                 if (i &lt; l.size()) {
750                     return l.get(i++);
751                 } else {
752                     ln++;
753                     i = 0;
754                 }
755             }
756             return null;
757         }
758 
759         Error newError(String msg) {
760             if (lineNumber &lt;= tokens.size()) {
761                 throw new Error(sourceFile + &quot;, line &quot; +
762                     lineNumber + &quot;, &quot; + msg + &quot; \&quot;&quot; + lineAt(lineNumber) + &quot;\&quot;&quot;);
763             } else {
764                 throw new Error(sourceFile + &quot;, line &quot; + lineNumber + &quot;, &quot; + msg);
765             }
766         }
767 
768         void dump() {
769             for (int i = 1; i &lt;= tokens.size(); i++) {
770                 System.out.format(&quot;%d: %s%n&quot;, i, lineAt(i));
771             }
772         }
773 
774         private String lineAt(int i) {
775             return tokens.get(i-1).stream().collect(Collectors.joining(&quot; &quot;));
776         }
777     }
778 }
779 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/jdk/src/classes/build/tools/generatecharacter/GenerateCharacter.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../hotspot/test/GtestImage.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../module/GenModuleInfoSource.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/jdk/src/classes/build/tools/generatecharacter/GenerateCharacter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 925             return Integer.toString(UnicodeSpec.DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE);
 926         FAIL(&quot;Unknown text substitution marker &quot; + commandMarker + x);
 927         return commandMarker + x;
 928     }
 929 
 930     /**
 931     * The genTables method generates source code for all the lookup tables
 932     * needed to represent the various Unicode character properties.
 933     * It simply calls the method genTable once for each table to be generated
 934     * and then generates a summary comment.
 935     *
 936     * @return   the replacement text for the &quot;Tables&quot; command, as a String
 937     *
 938     * @see GenerateCharacter#genTable
 939     * @see GenerateCharacter#replaceCommand
 940     */
 941     static String genTables() {
 942         int n = sizes.length;
 943         StringBuffer result = new StringBuffer();
 944         // liu : Add a comment showing the source of this table
<span class="line-modified"> 945         result.append(commentStart + &quot; The following tables and code generated using:&quot; +</span>
<span class="line-modified"> 946                   commentEnd + &quot;\n  &quot;);</span>
<span class="line-modified"> 947         result.append(commentStart + &#39; &#39; + commandLineDescription + commentEnd + &quot;\n  &quot;);</span>
<span class="line-modified"> 948 </span>
<span class="line-modified"> 949                 if (plane == 0 &amp;&amp; bLatin1 == false) {</span>

 950             genCaseMapTableDeclaration(result);
 951             genCaseMapTable(initializers, specialCaseMaps);
<span class="line-modified"> 952                 }</span>
 953         int totalBytes = 0;
 954         for (int k = 0; k &lt; n - 1; k++) {
 955             genTable(result, tableNames[k], tables[k], 0, bytes[k]&lt;&lt;3, sizes[k], preshifted[k],
 956                 sizes[k+1], false, false, k==0);
 957             int s = bytes[k];
 958             if (s == 1 &amp;&amp; useCharForByte) {
 959                 s = 2;
 960             }
 961             totalBytes += tables[k].length * s;
 962         }
 963         genTable(result, &quot;A&quot;, tables[n - 1], 0, (identifiers ? 2 : 32),
 964             sizes[n - 1], false, 0, true, !(identifiers), false);
 965 
 966         // If we ever need more than 32 bits to represent the character properties,
 967         // then a table &quot;B&quot; may be needed as well.
 968         genTable(result, &quot;B&quot;, tables[n - 1], 32, 16, sizes[n - 1], false, 0, true, true, false);
 969 
 970         totalBytes += ((((tables[n - 1].length * (identifiers ? 2 : 32)) + 31) &gt;&gt; 5) &lt;&lt; 2);
 971         result.append(commentStart);
 972         result.append(&quot; In all, the character property tables require &quot;);
</pre>
<hr />
<pre>
1595             int adjustment = preshifted[k] ? 0 :
1596                sizes[k+1] - ((k == sizes.length - 2) ? bitoffset : 0);
1597             String adjusted = (preshifted[k] || adjustment == 0) ? zeroextended :
1598                 &quot;(&quot; + zeroextended + &quot;&lt;&lt;&quot; + adjustment + &quot;)&quot;;
1599             String bitshift = (bits == 1) ? &quot;(&quot; + var + &quot;&amp;0x1F)&quot; :
1600                 (bits == 2) ? &quot;((&quot; + var + &quot;&amp;0xF)&lt;&lt;1)&quot; :
1601                 (bits == 4) ? &quot;((&quot; + var + &quot;&amp;7)&lt;&lt;2)&quot; : null;
1602             String extracted = ((k &lt; sizes.length - 1) || (bits &gt;= 8)) ? adjusted :
1603                 &quot;((&quot; + adjusted + &quot;&gt;&gt;&quot; + bitshift + &quot;)&amp;&quot; +
1604                 (bits == 4 ? &quot;0xF&quot; : &quot;&quot; + ((1 &lt;&lt; bits) - 1)) + &quot;)&quot;;
1605             access = extracted;
1606         }
1607         return access;
1608     }
1609 
1610     /* The command line arguments are decoded and used to set the following
1611      global variables.
1612      */
1613 
1614     static boolean verbose = false;

1615     static boolean nobidi = false;
1616     static boolean nomirror = false;
1617     static boolean identifiers = false;
1618     static boolean Csyntax = false;
1619     static String TemplateFileName = null;
1620     static String OutputFileName = null;
1621     static String UnicodeSpecFileName = null; // liu
1622     static String SpecialCasingFileName = null;
1623     static String PropListFileName = null;
1624     static String DerivedPropsFileName = null;
1625     static boolean useCharForByte = false;
1626     static int[] sizes;
1627     static int bins = 0; // liu; if &gt; 0, then perform search
1628     static boolean tableAsString = false;
1629     static boolean bLatin1 = false;
1630 
1631     static String commandLineDescription;
1632 
1633     /* Other global variables, equal in length to the &quot;sizes&quot; array. */
1634 
</pre>
<hr />
<pre>
1675     * In addition, decimal literals may appear as command line arguments;
1676     * each one represents the number of bits of the character to be broken
1677     * off at each lookup step.  If present, they must add up to 16 (the number
1678     * of bits in a char value).  For smaller tables, the last value should
1679     * be 0; values other than the last one may not be zero.  If no such
1680     * numeric values are provided, default values are used.
1681     *
1682     * @param args       the command line arguments, as an array of String
1683     *
1684     * @see GenerateCharacter#main
1685     */
1686 
1687     static void processArgs(String[] args) {
1688         StringBuffer desc = new StringBuffer(&quot;java GenerateCharacter&quot;);
1689         for (int j=0; j&lt;args.length; ++j) {
1690             desc.append(&quot; &quot; + args[j]);
1691         }
1692         for (int j = 0; j &lt; args.length; j++) {
1693             if (args[j].equals(&quot;-verbose&quot;) || args[j].equals(&quot;-v&quot;))
1694                 verbose = true;


1695             else if (args[j].equals(&quot;-nobidi&quot;))
1696                 nobidi = true;
1697             else if (args[j].equals(&quot;-nomirror&quot;))
1698                 nomirror = true;
1699             else if (args[j].equals(&quot;-identifiers&quot;))
1700                 identifiers = true;
1701             else if (args[j].equals(&quot;-c&quot;))
1702                 Csyntax = true;
1703             else if (args[j].equals(&quot;-string&quot;))
1704                 tableAsString = true;
1705             else if (args[j].equals(&quot;-o&quot;)) {
1706                 if (j == args.length - 1) {
1707                     FAIL(&quot;File name missing after -o&quot;);
1708                 }
1709                 else {
1710                     OutputFileName = args[++j];
1711                 }
1712             }
1713             else if (args[j].equals(&quot;-search&quot;)) {
1714                 if (j == args.length - 1)
</pre>
</td>
<td>
<hr />
<pre>
 925             return Integer.toString(UnicodeSpec.DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE);
 926         FAIL(&quot;Unknown text substitution marker &quot; + commandMarker + x);
 927         return commandMarker + x;
 928     }
 929 
 930     /**
 931     * The genTables method generates source code for all the lookup tables
 932     * needed to represent the various Unicode character properties.
 933     * It simply calls the method genTable once for each table to be generated
 934     * and then generates a summary comment.
 935     *
 936     * @return   the replacement text for the &quot;Tables&quot; command, as a String
 937     *
 938     * @see GenerateCharacter#genTable
 939     * @see GenerateCharacter#replaceCommand
 940     */
 941     static String genTables() {
 942         int n = sizes.length;
 943         StringBuffer result = new StringBuffer();
 944         // liu : Add a comment showing the source of this table
<span class="line-modified"> 945         if (debug) {</span>
<span class="line-modified"> 946             result.append(commentStart + &quot; The following tables and code generated using:&quot; +</span>
<span class="line-modified"> 947                     commentEnd + &quot;\n  &quot;);</span>
<span class="line-modified"> 948             result.append(commentStart + &#39; &#39; + commandLineDescription + commentEnd + &quot;\n  &quot;);</span>
<span class="line-modified"> 949         }</span>
<span class="line-added"> 950         if (plane == 0 &amp;&amp; bLatin1 == false) {</span>
 951             genCaseMapTableDeclaration(result);
 952             genCaseMapTable(initializers, specialCaseMaps);
<span class="line-modified"> 953         }</span>
 954         int totalBytes = 0;
 955         for (int k = 0; k &lt; n - 1; k++) {
 956             genTable(result, tableNames[k], tables[k], 0, bytes[k]&lt;&lt;3, sizes[k], preshifted[k],
 957                 sizes[k+1], false, false, k==0);
 958             int s = bytes[k];
 959             if (s == 1 &amp;&amp; useCharForByte) {
 960                 s = 2;
 961             }
 962             totalBytes += tables[k].length * s;
 963         }
 964         genTable(result, &quot;A&quot;, tables[n - 1], 0, (identifiers ? 2 : 32),
 965             sizes[n - 1], false, 0, true, !(identifiers), false);
 966 
 967         // If we ever need more than 32 bits to represent the character properties,
 968         // then a table &quot;B&quot; may be needed as well.
 969         genTable(result, &quot;B&quot;, tables[n - 1], 32, 16, sizes[n - 1], false, 0, true, true, false);
 970 
 971         totalBytes += ((((tables[n - 1].length * (identifiers ? 2 : 32)) + 31) &gt;&gt; 5) &lt;&lt; 2);
 972         result.append(commentStart);
 973         result.append(&quot; In all, the character property tables require &quot;);
</pre>
<hr />
<pre>
1596             int adjustment = preshifted[k] ? 0 :
1597                sizes[k+1] - ((k == sizes.length - 2) ? bitoffset : 0);
1598             String adjusted = (preshifted[k] || adjustment == 0) ? zeroextended :
1599                 &quot;(&quot; + zeroextended + &quot;&lt;&lt;&quot; + adjustment + &quot;)&quot;;
1600             String bitshift = (bits == 1) ? &quot;(&quot; + var + &quot;&amp;0x1F)&quot; :
1601                 (bits == 2) ? &quot;((&quot; + var + &quot;&amp;0xF)&lt;&lt;1)&quot; :
1602                 (bits == 4) ? &quot;((&quot; + var + &quot;&amp;7)&lt;&lt;2)&quot; : null;
1603             String extracted = ((k &lt; sizes.length - 1) || (bits &gt;= 8)) ? adjusted :
1604                 &quot;((&quot; + adjusted + &quot;&gt;&gt;&quot; + bitshift + &quot;)&amp;&quot; +
1605                 (bits == 4 ? &quot;0xF&quot; : &quot;&quot; + ((1 &lt;&lt; bits) - 1)) + &quot;)&quot;;
1606             access = extracted;
1607         }
1608         return access;
1609     }
1610 
1611     /* The command line arguments are decoded and used to set the following
1612      global variables.
1613      */
1614 
1615     static boolean verbose = false;
<span class="line-added">1616     static boolean debug = false;</span>
1617     static boolean nobidi = false;
1618     static boolean nomirror = false;
1619     static boolean identifiers = false;
1620     static boolean Csyntax = false;
1621     static String TemplateFileName = null;
1622     static String OutputFileName = null;
1623     static String UnicodeSpecFileName = null; // liu
1624     static String SpecialCasingFileName = null;
1625     static String PropListFileName = null;
1626     static String DerivedPropsFileName = null;
1627     static boolean useCharForByte = false;
1628     static int[] sizes;
1629     static int bins = 0; // liu; if &gt; 0, then perform search
1630     static boolean tableAsString = false;
1631     static boolean bLatin1 = false;
1632 
1633     static String commandLineDescription;
1634 
1635     /* Other global variables, equal in length to the &quot;sizes&quot; array. */
1636 
</pre>
<hr />
<pre>
1677     * In addition, decimal literals may appear as command line arguments;
1678     * each one represents the number of bits of the character to be broken
1679     * off at each lookup step.  If present, they must add up to 16 (the number
1680     * of bits in a char value).  For smaller tables, the last value should
1681     * be 0; values other than the last one may not be zero.  If no such
1682     * numeric values are provided, default values are used.
1683     *
1684     * @param args       the command line arguments, as an array of String
1685     *
1686     * @see GenerateCharacter#main
1687     */
1688 
1689     static void processArgs(String[] args) {
1690         StringBuffer desc = new StringBuffer(&quot;java GenerateCharacter&quot;);
1691         for (int j=0; j&lt;args.length; ++j) {
1692             desc.append(&quot; &quot; + args[j]);
1693         }
1694         for (int j = 0; j &lt; args.length; j++) {
1695             if (args[j].equals(&quot;-verbose&quot;) || args[j].equals(&quot;-v&quot;))
1696                 verbose = true;
<span class="line-added">1697             else if (args[j].equals(&quot;-d&quot;))</span>
<span class="line-added">1698                 debug = true;</span>
1699             else if (args[j].equals(&quot;-nobidi&quot;))
1700                 nobidi = true;
1701             else if (args[j].equals(&quot;-nomirror&quot;))
1702                 nomirror = true;
1703             else if (args[j].equals(&quot;-identifiers&quot;))
1704                 identifiers = true;
1705             else if (args[j].equals(&quot;-c&quot;))
1706                 Csyntax = true;
1707             else if (args[j].equals(&quot;-string&quot;))
1708                 tableAsString = true;
1709             else if (args[j].equals(&quot;-o&quot;)) {
1710                 if (j == args.length - 1) {
1711                     FAIL(&quot;File name missing after -o&quot;);
1712                 }
1713                 else {
1714                     OutputFileName = args[++j];
1715                 }
1716             }
1717             else if (args[j].equals(&quot;-search&quot;)) {
1718                 if (j == args.length - 1)
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../hotspot/test/GtestImage.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../module/GenModuleInfoSource.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
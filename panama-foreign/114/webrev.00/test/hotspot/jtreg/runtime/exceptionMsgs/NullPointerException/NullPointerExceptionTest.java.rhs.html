<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/runtime/exceptionMsgs/NullPointerException/NullPointerExceptionTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2019 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /**
  26  * @test
<a name="2" id="anc2"></a><span class="line-added">  27  * @key randomness</span>
  28  * @summary Test extended NullPointerException message for
  29  *   classfiles generated with debug information. In this case the name
  30  *   of the variable containing the array is printed.
  31  * @bug 8218628
  32  * @modules java.base/java.lang:open
  33  *          java.base/jdk.internal.org.objectweb.asm
  34  * @library /test/lib
  35  * @compile -g NullPointerExceptionTest.java
  36  * @run main/othervm -XX:MaxJavaStackTraceDepth=1 -XX:+ShowCodeDetailsInExceptionMessages NullPointerExceptionTest hasDebugInfo
  37  */
  38 /**
  39  * @test
<a name="3" id="anc3"></a><span class="line-added">  40  * @key randomness</span>
  41  * @summary Test extended NullPointerException message for class
  42  *   files generated without debugging information. The message lists
  43  *   detailed information about the entity that is null.
  44  * @bug 8218628
  45  * @modules java.base/java.lang:open
  46  *          java.base/jdk.internal.org.objectweb.asm
  47  * @library /test/lib
  48  * @compile NullPointerExceptionTest.java
  49  * @run main/othervm -XX:MaxJavaStackTraceDepth=1 -XX:+ShowCodeDetailsInExceptionMessages NullPointerExceptionTest
  50  */
  51 
  52 import java.io.ByteArrayInputStream;
  53 import java.io.ByteArrayOutputStream;
  54 import java.io.ObjectInputStream;
  55 import java.io.ObjectOutputStream;
  56 import java.lang.invoke.MethodHandles.Lookup;
  57 import java.util.ArrayList;
<a name="4" id="anc4"></a><span class="line-added">  58 import java.util.Random;</span>
  59 
  60 import jdk.internal.org.objectweb.asm.ClassWriter;
  61 import jdk.internal.org.objectweb.asm.Label;
  62 import jdk.internal.org.objectweb.asm.MethodVisitor;
  63 import jdk.test.lib.Asserts;
<a name="5" id="anc5"></a><span class="line-added">  64 import jdk.test.lib.Utils;</span>
  65 
  66 import static java.lang.invoke.MethodHandles.lookup;
  67 import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;
  68 import static jdk.internal.org.objectweb.asm.Opcodes.ACC_SUPER;
  69 import static jdk.internal.org.objectweb.asm.Opcodes.ACONST_NULL;
  70 import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;
  71 import static jdk.internal.org.objectweb.asm.Opcodes.ASTORE;
  72 import static jdk.internal.org.objectweb.asm.Opcodes.GETFIELD;
  73 import static jdk.internal.org.objectweb.asm.Opcodes.GETSTATIC;
  74 import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_1;
  75 import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_2;
  76 import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;
  77 import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
  78 import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;
  79 import static jdk.internal.org.objectweb.asm.Opcodes.IRETURN;
  80 import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;
  81 
  82 /**
  83  * Tests NullPointerExceptions
  84  */
  85 public class NullPointerExceptionTest {
  86 
  87     // Some fields used in the test.
  88     static Object nullStaticField;
  89     NullPointerExceptionTest nullInstanceField;
  90     static int[][][][] staticArray;
  91     static long[][] staticLongArray = new long[1000][];
  92     DoubleArrayGen dag;
  93     ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();
  94     ArrayList&lt;String&gt; curr;
  95     static boolean hasDebugInfo = false;
<a name="6" id="anc6"></a><span class="line-added">  96     static final Random rng = Utils.getRandomInstance();</span>
  97 
  98     static {
  99         staticArray       = new int[1][][][];
 100         staticArray[0]    = new int[1][][];
 101         staticArray[0][0] = new int[1][];
 102     }
 103 
 104     public static void checkMessage(Throwable t, String expression,
 105                                     String obtainedMsg, String expectedMsg) {
 106         System.out.println(&quot;\nSource code:\n  &quot; + expression + &quot;\n\nOutput:&quot;);
 107         t.printStackTrace(System.out);
 108         if (obtainedMsg != expectedMsg &amp;&amp; // E.g. both are null.
 109             !obtainedMsg.equals(expectedMsg)) {
 110             System.out.println(&quot;expected msg: &quot; + expectedMsg);
 111             Asserts.assertEquals(expectedMsg, obtainedMsg);
 112         }
 113         System.out.println(&quot;\n----&quot;);
 114     }
 115 
 116     public static void main(String[] args) throws Exception {
 117         NullPointerExceptionTest t = new NullPointerExceptionTest();
 118         if (args.length &gt; 0) {
 119             hasDebugInfo = true;
 120         }
 121 
 122         System.out.println(&quot;Tests for the first part of the message:&quot;);
 123         System.out.println(&quot;========================================\n&quot;);
 124 
 125         // Test the message printed for the failed action.
 126         t.testFailedAction();
 127 
 128         System.out.println(&quot;Tests for the second part of the message:&quot;);
 129         System.out.println(&quot;=========================================\n&quot;);
 130         // Test the method printed for the null entity.
 131         t.testNullEntity();
 132 
 133         System.out.println(&quot;Further tests:&quot;);
 134         System.out.println(&quot;==============\n&quot;);
 135 
 136         // Test if parameters are used in the code.
 137         // This is relevant if there is no debug information.
 138         t.testParameters();
 139 
 140         // Test that no message is printed for exceptions
 141         // allocated explicitly.
 142         t.testCreation();
 143 
 144         // Test that no message is printed for exceptions
 145         // thrown in native methods.
 146         t.testNative();
 147 
 148         // Test that two calls to getMessage() return the same
 149         // message.
 150         // It is a design decision that it returns two different
 151         // String objects.
 152         t.testSameMessage();
 153 
 154         // Test serialization.
 155         // It is a design decision that after serialization the
 156         // the message is lost.
 157         t.testSerialization();
 158 
 159         // Test that messages are printed for code generated
 160         // on-the-fly.
 161         t.testGeneratedCode();
 162 
 163         // Some more interesting complex messages.
 164         t.testComplexMessages();
 165     }
 166 
 167     // Helper method to cause test case.
 168     private double callWithTypes(String[][] dummy1, int[][][] dummy2, float dummy3, long dummy4, short dummy5,
 169                                  boolean dummy6, byte dummy7, double dummy8, char dummy9) {
 170         return 0.0;
 171     }
 172 
 173     @SuppressWarnings(&quot;null&quot;)
 174     public void testFailedAction() {
 175         int[]     ia1 = null;
 176         float[]   fa1 = null;
 177         Object[]  oa1 = null;
 178         boolean[] za1 = null;
 179         byte[]    ba1 = null;
 180         char[]    ca1 = null;
 181         short[]   sa1 = null;
 182         long[]    la1 = null;
 183         double[]  da1 = null;
 184 
 185         // iaload
 186         try {
 187             int val = ia1[0];
 188             System.out.println(val);
 189             Asserts.fail();
 190         } catch (NullPointerException e) {
 191             checkMessage(e, &quot;int val = ia1[0];&quot;, e.getMessage(),
 192                          &quot;Cannot load from int array because &quot; +
 193                          (hasDebugInfo ? &quot;\&quot;ia1\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
 194         }
 195         // faload
 196         try {
 197             float val = fa1[0];
 198             System.out.println(val);
 199             Asserts.fail();
 200         } catch (NullPointerException e) {
 201             checkMessage(e, &quot;float val = fa1[0];&quot;, e.getMessage(),
 202                          &quot;Cannot load from float array because &quot; +
 203                          (hasDebugInfo ? &quot;\&quot;fa1\&quot;&quot; : &quot;\&quot;&lt;local2&gt;\&quot;&quot;) + &quot; is null&quot;);
 204         }
 205         // aaload
 206         try {
 207             Object val = oa1[0];
 208             System.out.println(val);
 209             Asserts.fail();
 210         } catch (NullPointerException e) {
 211             checkMessage(e, &quot;Object val = oa1[0];&quot;, e.getMessage(),
 212                          &quot;Cannot load from object array because &quot; +
 213                          (hasDebugInfo ? &quot;\&quot;oa1\&quot;&quot; : &quot;\&quot;&lt;local3&gt;\&quot;&quot;) + &quot; is null&quot;);
 214         }
 215         // baload (boolean)
 216         try {
 217             boolean val = za1[0];
 218             System.out.println(val);
 219             Asserts.fail();
 220         } catch (NullPointerException e) {
 221             checkMessage(e, &quot;boolean val = za1[0];&quot;, e.getMessage(),
 222                          &quot;Cannot load from byte/boolean array because &quot; +
 223                          (hasDebugInfo ? &quot;\&quot;za1\&quot;&quot; : &quot;\&quot;&lt;local4&gt;\&quot;&quot;) + &quot; is null&quot;);
 224         }
 225         // baload (byte)
 226         try {
 227             byte val = ba1[0];
 228             System.out.println(val);
 229             Asserts.fail();
 230         } catch (NullPointerException e) {
 231             checkMessage(e, &quot;byte val = ba1[0];&quot;, e.getMessage(),
 232                          &quot;Cannot load from byte/boolean array because &quot; +
 233                          (hasDebugInfo ? &quot;\&quot;ba1\&quot;&quot; : &quot;\&quot;&lt;local5&gt;\&quot;&quot;) + &quot; is null&quot;);
 234         }
 235         // caload
 236         try {
 237             char val = ca1[0];
 238             System.out.println(val);
 239             Asserts.fail();
 240         } catch (NullPointerException e) {
 241             checkMessage(e, &quot;char val = ca1[0];&quot;, e.getMessage(),
 242                          &quot;Cannot load from char array because &quot; +
 243                          (hasDebugInfo ? &quot;\&quot;ca1\&quot;&quot; : &quot;\&quot;&lt;local6&gt;\&quot;&quot;) + &quot; is null&quot;);
 244         }
 245         // saload
 246         try {
 247             short val = sa1[0];
 248             System.out.println(val);
 249             Asserts.fail();
 250         } catch (NullPointerException e) {
 251             checkMessage(e, &quot;short val = sa1[0];&quot;, e.getMessage(),
 252                          &quot;Cannot load from short array because &quot; +
 253                          (hasDebugInfo ? &quot;\&quot;sa1\&quot;&quot; : &quot;\&quot;&lt;local7&gt;\&quot;&quot;) + &quot; is null&quot;);
 254         }
 255         // laload
 256         try {
 257             long val = la1[0];
 258             System.out.println(val);
 259             Asserts.fail();
 260         } catch (NullPointerException e) {
 261             checkMessage(e, &quot;long val = la1[0];&quot;, e.getMessage(),
 262                          &quot;Cannot load from long array because &quot; +
 263                          (hasDebugInfo ? &quot;\&quot;la1\&quot;&quot; : &quot;\&quot;&lt;local8&gt;\&quot;&quot;) + &quot; is null&quot;);
 264         }
 265         // daload
 266         try {
 267             double val = da1[0];
 268             System.out.println(val);
 269             Asserts.fail();
 270         } catch (NullPointerException e) {
 271             checkMessage(e, &quot;double val = da1[0];&quot;, e.getMessage(),
 272                          &quot;Cannot load from double array because &quot; +
 273                          (hasDebugInfo ? &quot;\&quot;da1\&quot;&quot; : &quot;\&quot;&lt;local9&gt;\&quot;&quot;) + &quot; is null&quot;);
 274         }
 275 
 276         // iastore
 277         try {
 278             ia1[0] = 0;
 279             System.out.println(ia1[0]);
 280             Asserts.fail();
 281         } catch (NullPointerException e) {
 282             checkMessage(e, &quot;ia1[0] = 0;&quot;, e.getMessage(),
 283                          &quot;Cannot store to int array because &quot; +
 284                          (hasDebugInfo ? &quot;\&quot;ia1\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
 285         }
 286         // fastore
 287         try {
 288             fa1[0] = 0.7f;
 289             System.out.println(fa1[0]);
 290             Asserts.fail();
 291         } catch (NullPointerException e) {
 292             checkMessage(e, &quot;fa1[0] = 0.7f;&quot;, e.getMessage(),
 293                          &quot;Cannot store to float array because &quot; +
 294                          (hasDebugInfo ? &quot;\&quot;fa1\&quot;&quot; : &quot;\&quot;&lt;local2&gt;\&quot;&quot;) + &quot; is null&quot;);
 295         }
 296         // aastore
 297         try {
 298             oa1[0] = new Object();
 299             System.out.println(oa1[0]);
 300             Asserts.fail();
 301         } catch (NullPointerException e) {
 302             checkMessage(e, &quot;oa1[0] = new Object();&quot;, e.getMessage(),
 303                          &quot;Cannot store to object array because &quot; +
 304                          (hasDebugInfo ? &quot;\&quot;oa1\&quot;&quot; : &quot;\&quot;&lt;local3&gt;\&quot;&quot;) + &quot; is null&quot;);
 305         }
 306         // bastore (boolean)
 307         try {
 308             za1[0] = false;
 309             System.out.println(za1[0]);
 310             Asserts.fail();
 311         } catch (NullPointerException e) {
 312             checkMessage(e, &quot;za1[0] = false;&quot;, e.getMessage(),
 313                          &quot;Cannot store to byte/boolean array because &quot; +
 314                          (hasDebugInfo ? &quot;\&quot;za1\&quot;&quot; : &quot;\&quot;&lt;local4&gt;\&quot;&quot;) + &quot; is null&quot;);
 315         }
 316         // bastore (byte)
 317         try {
 318             ba1[0] = 0;
 319             System.out.println(ba1[0]);
 320             Asserts.fail();
 321         } catch (NullPointerException e) {
 322             checkMessage(e, &quot;ba1[0] = 0;&quot;, e.getMessage(),
 323                          &quot;Cannot store to byte/boolean array because &quot; +
 324                          (hasDebugInfo ? &quot;\&quot;ba1\&quot;&quot; : &quot;\&quot;&lt;local5&gt;\&quot;&quot;) + &quot; is null&quot;);
 325         }
 326         // castore
 327         try {
 328             ca1[0] = 0;
 329             System.out.println(ca1[0]);
 330             Asserts.fail();
 331         } catch (NullPointerException e) {
 332             checkMessage(e, &quot;ca1[0] = 0;&quot;, e.getMessage(),
 333                          &quot;Cannot store to char array because &quot; +
 334                          (hasDebugInfo ? &quot;\&quot;ca1\&quot;&quot; : &quot;\&quot;&lt;local6&gt;\&quot;&quot;) + &quot; is null&quot;);
 335         }
 336         // sastore
 337         try {
 338             sa1[0] = 0;
 339             System.out.println(sa1[0]);
 340             Asserts.fail();
 341         } catch (NullPointerException e) {
 342             checkMessage(e, &quot;sa1[0] = 0;&quot;, e.getMessage(),
 343                          &quot;Cannot store to short array because &quot; +
 344                          (hasDebugInfo ? &quot;\&quot;sa1\&quot;&quot; : &quot;\&quot;&lt;local7&gt;\&quot;&quot;) + &quot; is null&quot;);
 345         }
 346         // lastore
 347         try {
 348             la1[0] = 0;
 349             System.out.println(la1[0]);
 350             Asserts.fail();
 351         } catch (NullPointerException e) {
 352             checkMessage(e, &quot;la1[0] = 0;&quot;, e.getMessage(),
 353                          &quot;Cannot store to long array because &quot; +
 354                          (hasDebugInfo ? &quot;\&quot;la1\&quot;&quot; : &quot;\&quot;&lt;local8&gt;\&quot;&quot;) + &quot; is null&quot;);
 355         }
 356         // dastore
 357         try {
 358             da1[0] = 0;
 359             System.out.println(da1[0]);
 360             Asserts.fail();
 361         } catch (NullPointerException e) {
 362             checkMessage(e, &quot;da1[0] = 0;&quot;, e.getMessage(),
 363                          &quot;Cannot store to double array because &quot; +
 364                          (hasDebugInfo ? &quot;\&quot;da1\&quot;&quot; : &quot;\&quot;&lt;local9&gt;\&quot;&quot;) + &quot; is null&quot;);
 365         }
 366 
 367         // arraylength
 368         try {
 369             int val = za1.length;
 370             System.out.println(val);
 371             Asserts.fail();
 372         } catch (NullPointerException e) {
 373             checkMessage(e, &quot; int val = za1.length;&quot;, e.getMessage(),
 374                          &quot;Cannot read the array length because &quot; +
 375                          (hasDebugInfo ? &quot;\&quot;za1\&quot;&quot; : &quot;\&quot;&lt;local4&gt;\&quot;&quot;) + &quot; is null&quot;);
 376         }
 377         // athrow
 378         try {
 379             RuntimeException exc = null;
 380             throw exc;
 381         } catch (NullPointerException e) {
 382             checkMessage(e, &quot;throw exc;&quot;, e.getMessage(),
 383                          &quot;Cannot throw exception because &quot; +
 384                          (hasDebugInfo ? &quot;\&quot;exc\&quot;&quot; : &quot;\&quot;&lt;local10&gt;\&quot;&quot;) + &quot; is null&quot;);
 385         }
 386         // monitorenter
 387         try {
 388             synchronized (nullInstanceField) {
 389                 // desired
 390             }
 391         } catch (NullPointerException e) {
 392             checkMessage(e, &quot;synchronized (nullInstanceField) { ... }&quot;, e.getMessage(),
 393                          &quot;Cannot enter synchronized block because &quot; +
 394                          &quot;\&quot;this.nullInstanceField\&quot; is null&quot;);
 395         }
 396         // monitorexit
 397         // No test available
 398 
 399         // getfield
 400         try {
 401             Object val = nullInstanceField.nullInstanceField;
 402             System.out.println(val);
 403             Asserts.fail();
 404         } catch (NullPointerException e) {
 405             checkMessage(e, &quot;Object val = nullInstanceField.nullInstanceField;&quot;, e.getMessage(),
 406                          &quot;Cannot read field \&quot;nullInstanceField\&quot; because &quot; +
 407                          &quot;\&quot;this.nullInstanceField\&quot; is null&quot;);
 408         }
 409         // putfield
 410         try {
 411             nullInstanceField.nullInstanceField = new NullPointerExceptionTest();
 412             System.out.println(nullInstanceField.nullInstanceField);
 413             Asserts.fail();
 414         } catch (NullPointerException e) {
 415             checkMessage(e, &quot;nullInstanceField.nullInstanceField = new NullPointerExceptionTest();&quot;, e.getMessage(),
 416                          &quot;Cannot assign field \&quot;nullInstanceField\&quot; because &quot; +
 417                          &quot;\&quot;this.nullInstanceField\&quot; is null&quot;);
 418         }
 419         // invokevirtual
 420         try {
 421             String val = nullInstanceField.toString();
 422             System.out.println(val);
 423             Asserts.fail();
 424         } catch (NullPointerException e) {
 425             checkMessage(e, &quot;String val = nullInstanceField.toString();&quot;, e.getMessage(),
 426                          &quot;Cannot invoke \&quot;Object.toString()\&quot; because &quot; +
 427                          &quot;\&quot;this.nullInstanceField\&quot; is null&quot;);
 428         }
 429         // invokeinterface
 430         try {
 431             NullPointerExceptionTest obj = this;
 432             Object val = obj.dag.getArray();
 433             Asserts.assertNull(val);
 434             Asserts.fail();
 435         } catch (NullPointerException e) {
 436             checkMessage(e, &quot;Object val = obj.dag.getArray();&quot;, e.getMessage(),
 437                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$DoubleArrayGen.getArray()\&quot; because &quot; +
 438                          (hasDebugInfo ? &quot;\&quot;obj&quot; : &quot;\&quot;&lt;local10&gt;&quot;) + &quot;.dag\&quot; is null&quot;);
 439         }
 440         // invokespecial
 441         G g = null;
 442         try {
 443             byte[] classBytes = G.generateSub2GTestClass();
 444             Lookup lookup = lookup();
 445             Class&lt;?&gt; clazz = lookup.defineClass(classBytes);
 446             g = (G) clazz.getDeclaredConstructor().newInstance();
 447         } catch (Exception e) {
 448             e.printStackTrace();
 449             Asserts.fail(&quot;Generating class Sub2G failed.&quot;);
 450         }
 451         try {
 452             g.m2(&quot;Beginning&quot;);
 453         } catch (NullPointerException e) {
 454             checkMessage(e, &quot;return super.m2(x).substring(2); // ... where super is null by bytecode manipulation.&quot;, e.getMessage(),
 455                          &quot;Cannot invoke \&quot;G.m2(String)\&quot; because \&quot;null\&quot; is null&quot;);
 456         }
 457         // Test parameter and return types
 458         try {
 459             boolean val = (nullInstanceField.callWithTypes(null, null, 0.0f, 0L, (short)0, false, (byte)0, 0.0, &#39;x&#39;) == 0.0);
 460             Asserts.assertTrue(val);
 461             Asserts.fail();
 462         } catch (NullPointerException e) {
 463             checkMessage(e, &quot;boolean val = (nullInstanceField.callWithTypes(null, null, 0.0f, 0L, (short)0, false, (byte)0, 0.0, &#39;x&#39;) == 0.0);&quot;, e.getMessage(),
 464                          &quot;Cannot invoke \&quot;NullPointerExceptionTest.callWithTypes(String[][], int[][][], float, long, short, boolean, byte, double, char)\&quot; because &quot; +
 465                          &quot;\&quot;this.nullInstanceField\&quot; is null&quot;);
 466         }
 467     }
 468 
 469     static void test_iload() {
 470         int i0 = 0;
 471         int i1 = 1;
 472         int i2 = 2;
 473         int i3 = 3;
 474         @SuppressWarnings(&quot;unused&quot;)
 475         int i4 = 4;
 476         int i5 = 5;
 477 
 478         int[][] a = new int[6][];
 479 
 480         // iload_0
 481         try {
 482             a[i0][0] = 77;
 483             Asserts.fail();
 484         } catch (NullPointerException e) {
 485             checkMessage(e, &quot;a[i0][0] = 77;&quot;, e.getMessage(),
 486                          &quot;Cannot store to int array because &quot; +
 487                          (hasDebugInfo ? &quot;\&quot;a[i0]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[&lt;local0&gt;]\&quot;&quot;) + &quot; is null&quot;);
 488         }
 489         // iload_1
 490         try {
 491             a[i1][0] = 77;
 492             Asserts.fail();
 493         } catch (NullPointerException e) {
 494             checkMessage(e, &quot;a[i1][0] = 77;&quot;, e.getMessage(),
 495                          &quot;Cannot store to int array because &quot; +
 496                          (hasDebugInfo ? &quot;\&quot;a[i1]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[&lt;local1&gt;]\&quot;&quot;) + &quot; is null&quot;);
 497         }
 498         // iload_2
 499         try {
 500             a[i2][0] = 77;
 501             Asserts.fail();
 502         } catch (NullPointerException e) {
 503             checkMessage(e, &quot;a[i2][0] = 77;&quot;, e.getMessage(),
 504                          &quot;Cannot store to int array because &quot; +
 505                          (hasDebugInfo ? &quot;\&quot;a[i2]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[&lt;local2&gt;]\&quot;&quot;) + &quot; is null&quot;);
 506         }
 507         // iload_3
 508         try {
 509             a[i3][0] = 77;
 510             Asserts.fail();
 511         } catch (NullPointerException e) {
 512             checkMessage(e, &quot;a[i3][0] = 77;&quot;, e.getMessage(),
 513                          &quot;Cannot store to int array because &quot; +
 514                          (hasDebugInfo ? &quot;\&quot;a[i3]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[&lt;local3&gt;]\&quot;&quot;) + &quot; is null&quot;);
 515         }
 516         // iload
 517         try {
 518             a[i5][0] = 77;
 519             Asserts.fail();
 520         } catch (NullPointerException e) {
 521             checkMessage(e, &quot;a[i5][0] = 77;&quot;, e.getMessage(),
 522                          &quot;Cannot store to int array because &quot; +
 523                          (hasDebugInfo ? &quot;\&quot;a[i5]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[&lt;local5&gt;]\&quot;&quot;) + &quot; is null&quot;);
 524         }
 525     }
 526 
 527     // Other datatyes than int are not needed.
 528     // If we implement l2d and similar bytecodes, we can print
 529     // long expressions as array indexes. Then these here could
 530     // be used.
 531     static void test_lload() {
 532         long long0 = 0L;  // l0 looks like 10. Therefore long0.
 533         long long1 = 1L;
 534         long long2 = 2L;
 535         long long3 = 3L;
 536         @SuppressWarnings(&quot;unused&quot;)
 537         long long4 = 4L;
 538         long long5 = 5L;
 539 
 540         int[][] a = new int[6][];
 541 
 542         // lload_0
 543         try {
 544             a[(int)long0][0] = 77;
 545             Asserts.fail();
 546         } catch (NullPointerException e) {
 547             checkMessage(e, &quot;a[(int)long0][0] = 77;&quot;, e.getMessage(),
 548                          &quot;Cannot store to int array because &quot; +
 549                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local12&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 550         }
 551         // lload_1
 552         try {
 553             a[(int)long1][0] = 77;
 554             Asserts.fail();
 555         } catch (NullPointerException e) {
 556             checkMessage(e, &quot;a[(int)long1][0] = 77;&quot;, e.getMessage(),
 557                          &quot;Cannot store to int array because &quot; +
 558                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local12&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 559         }
 560         // lload_2
 561         try {
 562             a[(int)long2][0] = 77;
 563             Asserts.fail();
 564         } catch (NullPointerException e) {
 565             checkMessage(e, &quot;a[(int)long2][0] = 77;&quot;, e.getMessage(),
 566                          &quot;Cannot store to int array because &quot; +
 567                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local12&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 568         }
 569         // lload_3
 570         try {
 571             a[(int)long3][0] = 77;
 572             Asserts.fail();
 573         } catch (NullPointerException e) {
 574             checkMessage(e, &quot;a[(int)long3][0] = 77;&quot;, e.getMessage(),
 575                          &quot;Cannot store to int array because &quot; +
 576                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local12&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 577         }
 578         // lload
 579         try {
 580             a[(int)long5][0] = 77;
 581             Asserts.fail();
 582         } catch (NullPointerException e) {
 583             checkMessage(e, &quot;a[(int)long5][0] = 77;&quot;, e.getMessage(),
 584                          &quot;Cannot store to int array because &quot; +
 585                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local12&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 586         }
 587     }
 588 
 589     static void test_fload() {
 590         float f0 = 0.0f;
 591         float f1 = 1.0f;
 592         float f2 = 2.0f;
 593         float f3 = 3.0f;
 594         @SuppressWarnings(&quot;unused&quot;)
 595         float f4 = 4.0f;
 596         float f5 = 5.0f;
 597 
 598         int[][] a = new int[6][];
 599 
 600         // fload_0
 601         try {
 602             a[(int)f0][0] = 77;
 603             Asserts.fail();
 604         } catch (NullPointerException e) {
 605             checkMessage(e, &quot;a[(int)f0][0] = 77;&quot;, e.getMessage(),
 606                          &quot;Cannot store to int array because &quot; +
 607                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 608         }
 609         // fload_1
 610         try {
 611             a[(int)f1][0] = 77;
 612             Asserts.fail();
 613         } catch (NullPointerException e) {
 614             checkMessage(e, &quot;a[(int)f1][0] = 77;&quot;, e.getMessage(),
 615                          &quot;Cannot store to int array because &quot; +
 616                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 617         }
 618         // fload_2
 619         try {
 620             a[(int)f2][0] = 77;
 621             Asserts.fail();
 622         } catch (NullPointerException e) {
 623             checkMessage(e, &quot;a[(int)f2][0] = 77;&quot;, e.getMessage(),
 624                          &quot;Cannot store to int array because &quot; +
 625                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 626         }
 627         // fload_3
 628         try {
 629             a[(int)f3][0] = 77;
 630             Asserts.fail();
 631         } catch (NullPointerException e) {
 632             checkMessage(e, &quot;a[(int)f3][0] = 77;&quot;, e.getMessage(),
 633                          &quot;Cannot store to int array because &quot; +
 634                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 635         }
 636         // fload
 637         try {
 638             a[(int)f5][0] = 77;
 639             Asserts.fail();
 640         } catch (NullPointerException e) {
 641             checkMessage(e, &quot;a[(int)f5][0] = 77;&quot;, e.getMessage(),
 642                          &quot;Cannot store to int array because &quot; +
 643                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 644         }
 645     }
 646 
 647     @SuppressWarnings(&quot;null&quot;)
 648     static void test_aload() {
 649         F f0 = null;
 650         F f1 = null;
 651         F f2 = null;
 652         F f3 = null;
 653         @SuppressWarnings(&quot;unused&quot;)
 654         F f4 = null;
 655         F f5 = null;
 656 
 657         // aload_0
 658         try {
 659             f0.i = 33;
 660             Asserts.fail();
 661         } catch (NullPointerException e) {
 662             checkMessage(e, &quot;f0.i = 33;&quot;, e.getMessage(),
 663                          &quot;Cannot assign field \&quot;i\&quot; because &quot; +
 664                          (hasDebugInfo ? &quot;\&quot;f0\&quot;&quot; : &quot;\&quot;&lt;local0&gt;\&quot;&quot;) + &quot; is null&quot;);
 665         }
 666         // aload_1
 667         try {
 668             f1.i = 33;
 669             Asserts.fail();
 670         } catch (NullPointerException e) {
 671             checkMessage(e, &quot;f1.i = 33;&quot;, e.getMessage(),
 672                          &quot;Cannot assign field \&quot;i\&quot; because &quot; +
 673                          (hasDebugInfo ? &quot;\&quot;f1\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
 674         }
 675         // aload_2
 676         try {
 677             f2.i = 33;
 678             Asserts.fail();
 679         } catch (NullPointerException e) {
 680             checkMessage(e, &quot;f2.i = 33;&quot;, e.getMessage(),
 681                          &quot;Cannot assign field \&quot;i\&quot; because &quot; +
 682                          (hasDebugInfo ? &quot;\&quot;f2\&quot;&quot; : &quot;\&quot;&lt;local2&gt;\&quot;&quot;) + &quot; is null&quot;);
 683         }
 684         // aload_3
 685         try {
 686             f3.i = 33;
 687             Asserts.fail();
 688         } catch (NullPointerException e) {
 689             checkMessage(e, &quot;f3.i = 33;&quot;, e.getMessage(),
 690                          &quot;Cannot assign field \&quot;i\&quot; because &quot; +
 691                          (hasDebugInfo ? &quot;\&quot;f3\&quot;&quot; : &quot;\&quot;&lt;local3&gt;\&quot;&quot;) + &quot; is null&quot;);
 692         }
 693         // aload
 694         try {
 695             f5.i = 33;
 696             Asserts.fail();
 697         } catch (NullPointerException e) {
 698             checkMessage(e, &quot;f5.i = 33;&quot;, e.getMessage(),
 699                          &quot;Cannot assign field \&quot;i\&quot; because &quot; +
 700                          (hasDebugInfo ? &quot;\&quot;f5\&quot;&quot; : &quot;\&quot;&lt;local5&gt;\&quot;&quot;) + &quot; is null&quot;);
 701         }
 702     }
 703 
 704     // Helper class for test cases.
 705     class A {
 706         public B to_b;
 707         public B getB() { return to_b; }
 708     }
 709 
 710     // Helper class for test cases.
 711     class B {
 712         public C to_c;
 713         public B to_b;
 714         public C getC() { return to_c; }
 715         public B getBfromB() { return to_b; }
 716     }
 717 
 718     // Helper class for test cases.
 719     class C {
 720         public D to_d;
 721         public D getD() { return to_d; }
 722     }
 723 
 724     // Helper class for test cases.
 725     class D {
 726         public int num;
 727         public int[][] ar;
 728     }
 729 
 730 
 731     @SuppressWarnings(&quot;null&quot;)
 732     public void testArrayChasing() {
 733         int[][][][][][] a = null;
 734         try {
 735             a[0][0][0][0][0][0] = 99;
 736             Asserts.fail();
 737         } catch (NullPointerException e) {
 738             checkMessage(e, &quot;a[0][0][0][0][0] = 99; // a is null&quot;, e.getMessage(),
 739                          &quot;Cannot load from object array because &quot; +
 740                          (hasDebugInfo ? &quot;\&quot;a\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
 741         }
 742         a = new int[1][][][][][];
 743         try {
 744             a[0][0][0][0][0][0] = 99;
 745             Asserts.fail();
 746         } catch (NullPointerException e) {
 747             checkMessage(e, &quot;a[0][0][0][0][0] = 99; // a[0] is null&quot;, e.getMessage(),
 748                          &quot;Cannot load from object array because &quot; +
 749                          (hasDebugInfo ? &quot;\&quot;a[0]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[0]\&quot;&quot;) + &quot; is null&quot;);
 750         }
 751         a[0] = new int[1][][][][];
 752         try {
 753             a[0][0][0][0][0][0] = 99;
 754             Asserts.fail();
 755         } catch (NullPointerException e) {
 756             checkMessage(e, &quot;a[0][0][0][0][0] = 99; // a[0][0] is null&quot;, e.getMessage(),
 757                          &quot;Cannot load from object array because &quot; +
 758                          (hasDebugInfo ? &quot;\&quot;a[0][0]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[0][0]\&quot;&quot;) + &quot; is null&quot;);
 759         }
 760         a[0][0] = new int[1][][][];
 761         try {
 762             a[0][0][0][0][0][0] = 99;
 763             Asserts.fail();
 764         } catch (NullPointerException e) {
 765             checkMessage(e, &quot;a[0][0][0][0][0] = 99; // a[0][0][0] is null&quot;, e.getMessage(),
 766                          &quot;Cannot load from object array because &quot; +
 767                          (hasDebugInfo ? &quot;\&quot;a[0][0][0]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[0][0][0]\&quot;&quot;) + &quot; is null&quot;);
 768         }
 769         try {
 770             System.out.println(a[0][0][0].length);
 771             Asserts.fail();
 772         } catch (NullPointerException e) {
 773             checkMessage(e, &quot;a[0][0][0].length; // a[0][0][0] is null&quot;, e.getMessage(),
 774                          &quot;Cannot read the array length because &quot; +
 775                          (hasDebugInfo ? &quot;\&quot;a[0][0][0]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[0][0][0]\&quot;&quot;) + &quot; is null&quot;);
 776         }
 777         a[0][0][0] = new int[1][][];
 778         try {
 779             a[0][0][0][0][0][0] = 99;
 780             Asserts.fail();
 781         } catch (NullPointerException e) {
 782             checkMessage(e, &quot;a[0][0][0][0][0] = 99; // a[0][0][0][0] is null&quot;, e.getMessage(),
 783                          &quot;Cannot load from object array because &quot; +
 784                          (hasDebugInfo ? &quot;\&quot;a[0][0][0][0]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[0][0][0][0]\&quot;&quot;) + &quot; is null&quot;);
 785         }
 786         a[0][0][0][0] = new int[1][];
 787         // Reaching max recursion depth. Prints &lt;array&gt;.
 788         try {
 789             a[0][0][0][0][0][0] = 99;
 790             Asserts.fail();
 791         } catch (NullPointerException e) {
 792             checkMessage(e, &quot;a[0][0][0][0][0] = 99; // a[0][0][0][0][0] is null&quot;, e.getMessage(),
 793                          &quot;Cannot store to int array because &quot; +
 794                          &quot;\&quot;&lt;array&gt;[0][0][0][0][0]\&quot; is null&quot;);
 795         }
 796         a[0][0][0][0][0] = new int[1];
 797         try {
 798             a[0][0][0][0][0][0] = 99;
 799         } catch (NullPointerException e) {
 800             Asserts.fail();
 801         }
 802     }
 803 
 804     @SuppressWarnings(&quot;null&quot;)
 805     public void testPointerChasing() {
 806         A a = null;
 807         try {
 808             a.to_b.to_c.to_d.num = 99;
 809             Asserts.fail();
 810         } catch (NullPointerException e) {
 811             checkMessage(e, &quot;a.to_b.to_c.to_d.num = 99; // a is null&quot;, e.getMessage(),
 812                          &quot;Cannot read field \&quot;to_b\&quot; because &quot; +
 813                          (hasDebugInfo ? &quot;\&quot;a\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
 814         }
 815         a = new A();
 816         try {
 817             a.to_b.to_c.to_d.num = 99;
 818             Asserts.fail();
 819         } catch (NullPointerException e) {
 820             checkMessage(e, &quot;a.to_b.to_c.to_d.num = 99; // a.to_b is null&quot;, e.getMessage(),
 821                          &quot;Cannot read field \&quot;to_c\&quot; because &quot; +
 822                          (hasDebugInfo ? &quot;\&quot;a.to_b\&quot;&quot; : &quot;\&quot;&lt;local1&gt;.to_b\&quot;&quot;) + &quot; is null&quot;);
 823         }
 824         a.to_b = new B();
 825         try {
 826             a.to_b.to_c.to_d.num = 99;
 827             Asserts.fail();
 828         } catch (NullPointerException e) {
 829             checkMessage(e, &quot;a.to_b.to_c.to_d.num = 99; // a.to_b.to_c is null&quot;, e.getMessage(),
 830                          &quot;Cannot read field \&quot;to_d\&quot; because &quot; +
 831                          (hasDebugInfo ? &quot;\&quot;a.to_b.to_c\&quot;&quot; : &quot;\&quot;&lt;local1&gt;.to_b.to_c\&quot;&quot;) + &quot; is null&quot;);
 832         }
 833         a.to_b.to_c = new C();
 834         try {
 835             a.to_b.to_c.to_d.num = 99;
 836             Asserts.fail();
 837         } catch (NullPointerException e) {
 838             checkMessage(e, &quot;a.to_b.to_c.to_d.num = 99; // a.to_b.to_c.to_d is null&quot;, e.getMessage(),
 839                          &quot;Cannot assign field \&quot;num\&quot; because &quot; +
 840                          (hasDebugInfo ? &quot;\&quot;a.to_b.to_c.to_d\&quot;&quot; : &quot;\&quot;&lt;local1&gt;.to_b.to_c.to_d\&quot;&quot;) + &quot; is null&quot;);
 841         }
 842     }
 843 
 844     @SuppressWarnings(&quot;null&quot;)
 845     public void testMethodChasing() {
 846         A a = null;
 847         try {
 848             a.getB().getBfromB().getC().getD().num = 99;
 849             Asserts.fail();
 850         } catch (NullPointerException e) {
 851             checkMessage(e, &quot;a.getB().getBfromB().getC().getD().num = 99; // a is null&quot;, e.getMessage(),
 852                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$A.getB()\&quot; because &quot; +
 853                          (hasDebugInfo ? &quot;\&quot;a&quot; : &quot;\&quot;&lt;local1&gt;&quot;) + &quot;\&quot; is null&quot;);
 854         }
 855         a = new A();
 856         try {
 857             a.getB().getBfromB().getC().getD().num = 99;
 858             Asserts.fail();
 859         } catch (NullPointerException e) {
 860             checkMessage(e, &quot;a.getB().getBfromB().getC().getD().num = 99; // a.getB() is null&quot;, e.getMessage(),
 861                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$B.getBfromB()\&quot; because &quot; +
 862                          &quot;the return value of \&quot;NullPointerExceptionTest$A.getB()\&quot; is null&quot;);
 863         }
 864         a.to_b = new B();
 865         try {
 866             a.getB().getBfromB().getC().getD().num = 99;
 867             Asserts.fail();
 868         } catch (NullPointerException e) {
 869             checkMessage(e, &quot;a.getB().getBfromB().getC().getD().num = 99; // a.getB().getBfromB() is null&quot;, e.getMessage(),
 870                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$B.getC()\&quot; because &quot; +
 871                          &quot;the return value of \&quot;NullPointerExceptionTest$B.getBfromB()\&quot; is null&quot;);
 872         }
 873         a.to_b.to_b = new B();
 874         try {
 875             a.getB().getBfromB().getC().getD().num = 99;
 876             Asserts.fail();
 877         } catch (NullPointerException e) {
 878             checkMessage(e, &quot;a.getB().getBfromB().getC().getD().num = 99; // a.getB().getBfromB().getC() is null&quot;, e.getMessage(),
 879                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$C.getD()\&quot; because &quot; +
 880                          &quot;the return value of \&quot;NullPointerExceptionTest$B.getC()\&quot; is null&quot;);
 881         }
 882         a.to_b.to_b.to_c = new C();
 883         try {
 884             a.getB().getBfromB().getC().getD().num = 99;
 885             Asserts.fail();
 886         } catch (NullPointerException e) {
 887             checkMessage(e, &quot;a.getB().getBfromB().getC().getD().num = 99; // a.getB().getBfromB().getC().getD() is null&quot;, e.getMessage(),
 888                          &quot;Cannot assign field \&quot;num\&quot; because &quot; +
 889                          &quot;the return value of \&quot;NullPointerExceptionTest$C.getD()\&quot; is null&quot;);
 890         }
 891     }
 892 
 893     @SuppressWarnings(&quot;null&quot;)
 894     public void testMixedChasing() {
 895         A a = null;
 896         try {
 897             a.getB().getBfromB().to_c.to_d.ar[0][0] = 99;
 898             Asserts.fail();
 899         } catch (NullPointerException e) {
 900             checkMessage(e, &quot;a.getB().getBfromB().to_c.to_d.ar[0][0] = 99; // a is null&quot;, e.getMessage(),
 901                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$A.getB()\&quot; because &quot; +
 902                          (hasDebugInfo ? &quot;\&quot;a\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
 903         }
 904         a = new A();
 905         try {
 906             a.getB().getBfromB().to_c.to_d.ar[0][0] = 99;
 907             Asserts.fail();
 908         } catch (NullPointerException e) {
 909             checkMessage(e, &quot;a.getB().getBfromB().to_c.to_d.ar[0][0] = 99; // a.getB() is null&quot;, e.getMessage(),
 910                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$B.getBfromB()\&quot; because &quot; +
 911                          &quot;the return value of \&quot;NullPointerExceptionTest$A.getB()\&quot; is null&quot;);
 912         }
 913         a.to_b = new B();
 914         try {
 915             a.getB().getBfromB().to_c.to_d.ar[0][0] = 99;
 916             Asserts.fail();
 917         } catch (NullPointerException e) {
 918             checkMessage(e, &quot;a.getB().getBfromB().to_c.to_d.ar[0][0] = 99; // a.getB().getBfromB() is null&quot;, e.getMessage(),
 919                          &quot;Cannot read field \&quot;to_c\&quot; because &quot; +
 920                          &quot;the return value of \&quot;NullPointerExceptionTest$B.getBfromB()\&quot; is null&quot;);
 921         }
 922         a.to_b.to_b = new B();
 923         try {
 924             a.getB().getBfromB().to_c.to_d.ar[0][0] = 99;
 925             Asserts.fail();
 926         } catch (NullPointerException e) {
 927             checkMessage(e, &quot;a.getB().getBfromB().to_c.to_d.ar[0][0] = 99; // a.getB().getBfromB().to_c is null&quot;, e.getMessage(),
 928                          &quot;Cannot read field \&quot;to_d\&quot; because &quot; +
 929                          &quot;\&quot;NullPointerExceptionTest$B.getBfromB().to_c\&quot; is null&quot;);
 930         }
 931         a.to_b.to_b.to_c = new C();
 932         try {
 933             a.getB().getBfromB().to_c.to_d.ar[0][0] = 99;
 934             Asserts.fail();
 935         } catch (NullPointerException e) {
 936             checkMessage(e, &quot;a.getB().getBfromB().to_c.to_d.ar[0][0] = 99; // a.getB().getBfromB().to_c.to_d is null&quot;, e.getMessage(),
 937                          &quot;Cannot read field \&quot;ar\&quot; because &quot; +
 938                          &quot;\&quot;NullPointerExceptionTest$B.getBfromB().to_c.to_d\&quot; is null&quot;);
 939         }
 940         a.to_b.to_b.to_c.to_d = new D();
 941         try {
 942             a.getB().getBfromB().to_c.to_d.ar[0][0] = 99;
 943             Asserts.fail();
 944         } catch (NullPointerException e) {
 945             checkMessage(e, &quot;a.getB().getBfromB().to_c.to_d.ar[0][0] = 99; // a.getB().getBfromB().to_c.to_d.ar is null&quot;, e.getMessage(),
 946                          &quot;Cannot load from object array because &quot; +
 947                          &quot;\&quot;NullPointerExceptionTest$B.getBfromB().to_c.to_d.ar\&quot; is null&quot;);
 948         }
 949         try {
 950             a.getB().getBfromB().getC().getD().ar[0][0] = 99;
 951             Asserts.fail();
 952         } catch (NullPointerException e) {
 953             checkMessage(e, &quot;a.getB().getBfromB().getC().getD().ar[0][0] = 99; // a.getB().getBfromB().getC().getD().ar is null&quot;, e.getMessage(),
 954                          &quot;Cannot load from object array because &quot; +
 955                          &quot;\&quot;NullPointerExceptionTest$C.getD().ar\&quot; is null&quot;);
 956         }
 957         a.to_b.to_b.to_c.to_d.ar = new int[1][];
 958         try {
 959             a.getB().getBfromB().to_c.to_d.ar[0][0] = 99;
 960             Asserts.fail();
 961         } catch (NullPointerException e) {
 962             checkMessage(e, &quot;a.getB().getBfromB().to_c.to_d.ar[0][0] = 99; // a.getB().getBfromB().to_c.to_d.ar[0] is null&quot;, e.getMessage(),
 963                          &quot;Cannot store to int array because &quot; +
 964                          &quot;\&quot;NullPointerExceptionTest$B.getBfromB().to_c.to_d.ar[0]\&quot; is null&quot;);
 965         }
 966         try {
 967             a.getB().getBfromB().getC().getD().ar[0][0] = 99;
 968             Asserts.fail();
 969         } catch (NullPointerException e) {
 970             checkMessage(e, &quot;a.getB().getBfromB().getC().getD().ar[0][0] = 99; // a.getB().getBfromB().getC().getD().ar[0] is null&quot;, e.getMessage(),
 971                          &quot;Cannot store to int array because &quot; +
 972                          &quot;\&quot;NullPointerExceptionTest$C.getD().ar[0]\&quot; is null&quot;);
 973         }
 974     }
 975 
 976     // Helper method to cause test case.
 977     private Object returnNull(String[][] dummy1, int[][][] dummy2, float dummy3) {
 978         return null;
 979     }
 980 
 981     // Helper method to cause test case.
 982     private NullPointerExceptionTest returnMeAsNull(Throwable dummy1, int dummy2, char dummy3) {
 983         return null;
 984     }
 985 
 986     // Helper interface for test cases.
 987     static interface DoubleArrayGen {
 988         public double[] getArray();
 989     }
 990 
 991     // Helper class for test cases.
 992     static class DoubleArrayGenImpl implements DoubleArrayGen {
 993         @Override
 994         public double[] getArray() {
 995             return null;
 996         }
 997     }
 998 
 999     // Helper class for test cases.
1000     static class NullPointerGenerator {
1001         public static Object nullReturner(boolean dummy1) {
1002             return null;
1003         }
1004 
1005         public Object returnMyNull(double dummy1, long dummy2, short dummy3) {
1006             return null;
1007         }
1008     }
1009 
1010     // Helper method to cause test case.
1011     public void ImplTestLoadedFromMethod(DoubleArrayGen gen) {
1012         try {
1013             (gen.getArray())[0] = 1.0;
1014             Asserts.fail();
1015         } catch (NullPointerException e) {
1016             checkMessage(e, &quot;(gen.getArray())[0] = 1.0;&quot;, e.getMessage(),
1017                          &quot;Cannot store to double array because &quot; +
1018                          &quot;the return value of \&quot;NullPointerExceptionTest$DoubleArrayGen.getArray()\&quot; is null&quot;);
1019         }
1020     }
1021 
1022     public void testNullEntity() {
1023         int[][] a = new int[820][];
1024 
1025         test_iload();
1026         test_lload();
1027         test_fload();
1028         // test_dload();
1029         test_aload();
1030         // aload_0: &#39;this&#39;
1031         try {
1032             this.nullInstanceField.nullInstanceField = new NullPointerExceptionTest();
1033             Asserts.fail();
1034         } catch (NullPointerException e) {
1035             checkMessage(e, &quot;this.nullInstanceField.nullInstanceField = new NullPointerExceptionTest();&quot;, e.getMessage(),
1036                          &quot;Cannot assign field \&quot;nullInstanceField\&quot; because \&quot;this.nullInstanceField\&quot; is null&quot;);
1037         }
1038 
1039         // aconst_null
1040         try {
1041             throw null;
1042         } catch (NullPointerException e) {
1043             checkMessage(e, &quot;throw null;&quot;, e.getMessage(),
1044                          &quot;Cannot throw exception because \&quot;null\&quot; is null&quot;);
1045         }
1046         // iconst_0
1047         try {
1048             a[0][0] = 77;
1049             Asserts.fail();
1050         } catch (NullPointerException e) {
1051             checkMessage(e, &quot;a[0][0] = 77;&quot;, e.getMessage(),
1052                          &quot;Cannot store to int array because &quot; +
1053                          (hasDebugInfo ? &quot;\&quot;a[0]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[0]\&quot;&quot;) + &quot; is null&quot;);
1054         }
1055         // iconst_1
1056         try {
1057             a[1][0] = 77;
1058             Asserts.fail();
1059         } catch (NullPointerException e) {
1060             checkMessage(e, &quot;a[1][0] = 77;&quot;, e.getMessage(),
1061                          &quot;Cannot store to int array because &quot; +
1062                          (hasDebugInfo ? &quot;\&quot;a[1]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[1]\&quot;&quot;) + &quot; is null&quot;);
1063         }
1064         // iconst_2
1065         try {
1066             a[2][0] = 77;
1067             Asserts.fail();
1068         } catch (NullPointerException e) {
1069             checkMessage(e, &quot;a[2][0] = 77;&quot;, e.getMessage(),
1070                          &quot;Cannot store to int array because &quot; +
1071                          (hasDebugInfo ? &quot;\&quot;a[2]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[2]\&quot;&quot;) + &quot; is null&quot;);
1072         }
1073         // iconst_3
1074         try {
1075             a[3][0] = 77;
1076             Asserts.fail();
1077         } catch (NullPointerException e) {
1078             checkMessage(e, &quot;a[3][0] = 77;&quot;, e.getMessage(),
1079                          &quot;Cannot store to int array because &quot; +
1080                          (hasDebugInfo ? &quot;\&quot;a[3]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[3]\&quot;&quot;) + &quot; is null&quot;);
1081         }
1082         // iconst_4
1083         try {
1084             a[4][0] = 77;
1085             Asserts.fail();
1086         } catch (NullPointerException e) {
1087             checkMessage(e, &quot;a[4][0] = 77;&quot;, e.getMessage(),
1088                          &quot;Cannot store to int array because &quot; +
1089                          (hasDebugInfo ? &quot;\&quot;a[4]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[4]\&quot;&quot;) + &quot; is null&quot;);
1090         }
1091         // iconst_5
1092         try {
1093             a[5][0] = 77;
1094             Asserts.fail();
1095         } catch (NullPointerException e) {
1096             checkMessage(e, &quot;a[5][0] = 77;&quot;, e.getMessage(),
1097                          &quot;Cannot store to int array because &quot; +
1098                          (hasDebugInfo ? &quot;\&quot;a[5]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[5]\&quot;&quot;) + &quot; is null&quot;);
1099         }
1100         // long --&gt; iconst
1101         try {
1102             a[(int)0L][0] = 77;
1103             Asserts.fail();
1104         } catch (NullPointerException e) {
1105             checkMessage(e, &quot;a[(int)0L][0] = 77;&quot;, e.getMessage(),
1106                          &quot;Cannot store to int array because &quot; +
1107                          (hasDebugInfo ? &quot;\&quot;a[0]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[0]\&quot;&quot;) + &quot; is null&quot;);
1108         }
1109         // bipush
1110         try {
1111             a[139 /*0x77*/][0] = 77;
1112             Asserts.fail();
1113         } catch (NullPointerException e) {
1114             checkMessage(e, &quot;a[139][0] = 77;&quot;, e.getMessage(),
1115                          &quot;Cannot store to int array because &quot; +
1116                          (hasDebugInfo ? &quot;\&quot;a[139]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[139]\&quot;&quot;) + &quot; is null&quot;);
1117         }
1118         // sipush
1119         try {
1120             a[819 /*0x333*/][0] = 77;
1121             Asserts.fail();
1122         } catch (NullPointerException e) {
1123             checkMessage(e, &quot;a[819][0] = 77;&quot;, e.getMessage(),
1124                          &quot;Cannot store to int array because &quot; +
1125                          (hasDebugInfo ? &quot;\&quot;a[819]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[819]\&quot;&quot;) + &quot; is null&quot;);
1126         }
1127 
1128         // aaload, with recursive descend.
1129         testArrayChasing();
1130 
1131         // getstatic
1132         try {
1133             boolean val = (((float[]) nullStaticField)[0] == 1.0f);
1134             Asserts.assertTrue(val);
1135             Asserts.fail();
1136         } catch (NullPointerException e) {
1137             checkMessage(e, &quot;boolean val = (((float[]) nullStaticField)[0] == 1.0f);&quot;, e.getMessage(),
1138                          &quot;Cannot load from float array because \&quot;NullPointerExceptionTest.nullStaticField\&quot; is null&quot;);
1139         }
1140 
1141         // getfield, with recursive descend.
1142         testPointerChasing();
1143 
1144         // invokestatic
1145         try {
1146             char val = ((char[]) NullPointerGenerator.nullReturner(false))[0];
1147             System.out.println(val);
1148             Asserts.fail();
1149         } catch (NullPointerException e) {
1150             checkMessage(e, &quot;char val = ((char[]) NullPointerGenerator.nullReturner(false))[0];&quot;, e.getMessage(),
1151                          &quot;Cannot load from char array because &quot; +
1152                          &quot;the return value of \&quot;NullPointerExceptionTest$NullPointerGenerator.nullReturner(boolean)\&quot; is null&quot;);
1153         }
1154         // invokevirtual
1155         try {
1156             char val = ((char[]) (new NullPointerGenerator().returnMyNull(1, 1, (short) 1)))[0];
1157             System.out.println(val);
1158             Asserts.fail();
1159         } catch (NullPointerException e) {
1160             checkMessage(e, &quot;char val = ((char[]) (new NullPointerGenerator().returnMyNull(1, 1, (short) 1)))[0];&quot;, e.getMessage(),
1161                          &quot;Cannot load from char array because &quot; +
1162                          &quot;the return value of \&quot;NullPointerExceptionTest$NullPointerGenerator.returnMyNull(double, long, short)\&quot; is null&quot;);
1163         }
1164         // Call with array arguments.
1165         try {
1166             double val = ((double[]) returnNull(null, null, 1f))[0];
1167             System.out.println(val);
1168             Asserts.fail();
1169         } catch (NullPointerException e) {
1170             checkMessage(e, &quot;double val = ((double[]) returnNull(null, null, 1f))[0];&quot;, e.getMessage(),
1171                          &quot;Cannot load from double array because &quot; +
1172                          &quot;the return value of \&quot;NullPointerExceptionTest.returnNull(String[][], int[][][], float)\&quot; is null&quot;);
1173         }
1174         // invokespecial
1175         try {
1176             SubG g = new SubG();
1177             g.m2(&quot;Beginning&quot;);
1178         } catch (NullPointerException e) {
1179             checkMessage(e, &quot;return super.m2(x).substring(2);&quot;, e.getMessage(),
1180                          &quot;Cannot invoke \&quot;String.substring(int)\&quot; because &quot; +
1181                          &quot;the return value of \&quot;G.m2(String)\&quot; is null&quot;);
1182         }
1183         // invokeinterface
1184         ImplTestLoadedFromMethod(new DoubleArrayGenImpl());
1185         try {
1186             returnMeAsNull(null, 1, &#39;A&#39;).dag = new DoubleArrayGenImpl();
1187             Asserts.fail();
1188         } catch (NullPointerException e) {
1189             checkMessage(e, &quot;returnMeAsNull(null, 1, &#39;A&#39;).dag = new DoubleArrayGenImpl();&quot;, e.getMessage(),
1190                          &quot;Cannot assign field \&quot;dag\&quot; because &quot; +
1191                          &quot;the return value of \&quot;NullPointerExceptionTest.returnMeAsNull(java.lang.Throwable, int, char)\&quot; is null&quot;);
1192         }
1193         testMethodChasing();
1194 
1195         // Mixed recursive descend.
1196         testMixedChasing();
1197     }
1198 
1199     // Assure 64 parameters are printed as &#39;parameteri&#39;.
1200     public String manyParameters(
1201         int  i1, int  i2, int  i3, int  i4, int  i5, int  i6, int  i7, int  i8, int  i9, int i10,
1202         int i11, int i12, int i13, int i14, int i15, int i16, int i17, int i18, int i19, int i20,
1203         int i21, int i22, int i23, int i24, int i25, int i26, int i27, int i28, int i29, int i30,
1204         int i31, int i32, int i33, int i34, int i35, int i36, int i37, int i38, int i39, int i40,
1205         int i41, int i42, int i43, int i44, int i45, int i46, int i47, int i48, int i49, int i50,
1206         int i51, int i52, int i53, int i54, int i55, int i56, int i57, int i58, int i59, int i60,
1207         int i61, int i62, int i63, int i64, int i65, int i66, int i67, int i68, int i69, int i70) {
1208         String[][][][] ar5 = new String[1][1][1][1];
1209         int[][][] idx3 = new int[1][1][1];
1210         int[][]   idx2 = new int[1][1];
1211         return ar5[i70]
1212                   [idx2[i65][i64]]
1213                   [idx3[i63][i62][i47]]
1214                   [idx3[idx2[i33][i32]][i31][i17]]
1215                   .substring(2);
1216     }
1217 
1218     // The double placeholder takes two slots on the stack.
1219     public void testParametersTestMethod(A a, double placeholder, B b, Integer i) throws Exception {
1220         try {
1221             a.to_b.to_c.to_d.num = 99;
1222             Asserts.fail();
1223         } catch (NullPointerException e) {
1224             checkMessage(e, &quot;a.to_b.to_c.to_d.num = 99; // to_c is null, a is a parameter.&quot;, e.getMessage(),
1225                          &quot;Cannot read field \&quot;to_d\&quot; because \&quot;&quot; +
1226                          (hasDebugInfo ? &quot;a&quot; : &quot;&lt;parameter1&gt;&quot;) + &quot;.to_b.to_c\&quot; is null&quot;);
1227         }
1228 
1229         try {
1230             b.to_c.to_d.num = 99;
1231             Asserts.fail();
1232         } catch (NullPointerException e) {
1233             checkMessage(e, &quot;b.to_c.to_d.num = 99; // b is null and b is a parameter.&quot;, e.getMessage(),
1234                          &quot;Cannot read field \&quot;to_c\&quot; because &quot; +
1235                          // We expect number &#39;3&#39; for the parameter.
1236                          (hasDebugInfo ? &quot;\&quot;b\&quot;&quot; : &quot;\&quot;&lt;parameter3&gt;\&quot;&quot;) + &quot; is null&quot;);
1237         }
1238 
1239 
1240         try {
1241             @SuppressWarnings(&quot;unused&quot;)
1242             int my_i = i;
1243         }  catch (NullPointerException e) {
1244             checkMessage(e, &quot;int my_i = i; // i is a parameter of type Integer.&quot;,  e.getMessage(),
1245                          &quot;Cannot invoke \&quot;java.lang.Integer.intValue()\&quot; because &quot; +
1246                          (hasDebugInfo ? &quot;\&quot;i\&quot;&quot; : &quot;\&quot;&lt;parameter4&gt;\&quot;&quot;) + &quot; is null&quot;);
1247         }
1248 
1249         // If no debug information is available, only 64 parameters (this and i1 through i63)
1250         // will be reported in the message as &#39;parameteri&#39;. Others will be reported as &#39;locali&#39;.
1251         try {
1252             manyParameters(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1253                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1254                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1255                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1256                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1257                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1258                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
1259             } catch (NullPointerException e) {
1260                 checkMessage(e, &quot;return ar5[i70][idx2[i65][i64]][idx3[i63][i62][i47]][idx3[idx2[i33][i32]][i31][i17]].substring(2);&quot;, e.getMessage(),
1261                              &quot;Cannot invoke \&quot;String.substring(int)\&quot; because &quot; +
1262                              (hasDebugInfo ?
1263                                &quot;\&quot;ar5[i70][idx2[i65][i64]][idx3[i63][i62][i47]][idx3[idx2[i33][i32]][i31][i17]]\&quot;&quot; :
1264                                &quot;\&quot;&lt;local71&gt;[&lt;local70&gt;][&lt;local73&gt;[&lt;local65&gt;][&lt;local64&gt;]][&lt;local72&gt;[&lt;parameter63&gt;][&lt;parameter62&gt;]&quot; +
1265                                   &quot;[&lt;parameter47&gt;]][&lt;local72&gt;[&lt;local73&gt;[&lt;parameter33&gt;][&lt;parameter32&gt;]][&lt;parameter31&gt;][&lt;parameter17&gt;]]\&quot;&quot;) +
1266                              &quot; is null&quot;);
1267             }
1268     }
1269 
1270 
1271     public void testParameters() throws Exception {
1272         A a = new A();
1273         a.to_b = new B();
1274         testParametersTestMethod(a, 0.0, null, null);
1275     }
1276 
1277 
1278     public void testCreation() throws Exception {
1279         // If allocated with new, the message should not be generated.
1280         Asserts.assertNull(new NullPointerException().getMessage());
1281         String msg = new String(&quot;A pointless message&quot;);
1282         Asserts.assertTrue(new NullPointerException(msg).getMessage() == msg);
1283 
1284         // If created via reflection, the message should not be generated.
1285         Exception ex = NullPointerException.class.getDeclaredConstructor().newInstance();
1286         Asserts.assertNull(ex.getMessage());
1287     }
1288 
1289     public void testNative() throws Exception {
1290         // If NPE is thrown in a native method, the message should
1291         // not be generated.
1292         try {
1293             Class.forName(null);
1294             Asserts.fail();
1295         } catch (NullPointerException e) {
1296             Asserts.assertNull(e.getMessage());
1297         }
1298 
1299     }
1300 
1301     // Test we get the same message calling npe.getMessage() twice.
1302     @SuppressWarnings(&quot;null&quot;)
1303     public void testSameMessage() throws Exception {
1304         Object null_o = null;
1305         String expectedMsg =
1306             &quot;Cannot invoke \&quot;Object.hashCode()\&quot; because &quot; +
1307             (hasDebugInfo ? &quot;\&quot;null_o&quot; : &quot;\&quot;&lt;local1&gt;&quot;) + &quot;\&quot; is null&quot;;
1308 
1309         try {
1310             null_o.hashCode();
1311             Asserts.fail();
1312         } catch (NullPointerException e) {
1313             String msg1 = e.getMessage();
1314             checkMessage(e, &quot;null_o.hashCode()&quot;, msg1, expectedMsg);
1315             String msg2 = e.getMessage();
1316             Asserts.assertTrue(msg1.equals(msg2));
1317             // It was decided that getMessage should generate the
1318             // message anew on every call, so this does not hold.
1319             //Asserts.assertTrue(msg1 == msg2);
1320             Asserts.assertFalse(msg1 == msg2);
1321         }
1322     }
1323 
1324     @SuppressWarnings(&quot;null&quot;)
1325     public void testSerialization() throws Exception {
1326         // NPE without message.
1327         Object o1 = new NullPointerException();
1328         ByteArrayOutputStream bos1 = new ByteArrayOutputStream();
1329         ObjectOutputStream oos1 = new ObjectOutputStream(bos1);
1330         oos1.writeObject(o1);
1331         ByteArrayInputStream bis1 = new ByteArrayInputStream(bos1.toByteArray());
1332         ObjectInputStream ois1 = new ObjectInputStream(bis1);
1333         Exception ex1 = (Exception) ois1.readObject();
1334         Asserts.assertNull(ex1.getMessage());
1335 
1336         // NPE with custom message.
1337         String msg2 = &quot;A useless message&quot;;
1338         Object o2 = new NullPointerException(msg2);
1339         ByteArrayOutputStream bos2 = new ByteArrayOutputStream();
1340         ObjectOutputStream oos2 = new ObjectOutputStream(bos2);
1341         oos2.writeObject(o2);
1342         ByteArrayInputStream bis2 = new ByteArrayInputStream(bos2.toByteArray());
1343         ObjectInputStream ois2 = new ObjectInputStream(bis2);
1344         Exception ex2 = (Exception) ois2.readObject();
1345         Asserts.assertEquals(ex2.getMessage(), msg2);
1346 
1347         // NPE with generated message.
1348         Object null_o3 = null;
1349         Object o3 = null;
1350         String msg3 = null;
1351         try {
1352             int hc = null_o3.hashCode();
1353             System.out.println(hc);
1354             Asserts.fail();
1355         } catch (NullPointerException npe3) {
1356             o3 = npe3;
1357             msg3 = npe3.getMessage();
1358             checkMessage(npe3, &quot;int hc = null_o3.hashCode();&quot;, msg3,
1359                          &quot;Cannot invoke \&quot;Object.hashCode()\&quot; because &quot; +
1360                          (hasDebugInfo ? &quot;\&quot;null_o3\&quot;&quot; : &quot;\&quot;&lt;local14&gt;\&quot;&quot;) + &quot; is null&quot;);
1361         }
1362         ByteArrayOutputStream bos3 = new ByteArrayOutputStream();
1363         ObjectOutputStream oos3 = new ObjectOutputStream(bos3);
1364         oos3.writeObject(o3);
1365         ByteArrayInputStream bis3 = new ByteArrayInputStream(bos3.toByteArray());
1366         ObjectInputStream ois3 = new ObjectInputStream(bis3);
1367         Exception ex3 = (Exception) ois3.readObject();
1368         // It was decided that getMessage should not store the
1369         // message in Throwable.detailMessage or implement writeReplace(),
1370         // thus it can not be recovered by serialization.
1371         //Asserts.assertEquals(ex3.getMessage(), msg3);
1372         Asserts.assertEquals(ex3.getMessage(), null);
1373     }
1374 
1375     static int index17 = 17;
1376     int getIndex17() { return 17; };
1377 
1378     @SuppressWarnings({ &quot;unused&quot;, &quot;null&quot; })
1379     public void testComplexMessages() {
1380         try {
1381             staticLongArray[0][0] = 2L;
1382             Asserts.fail();
1383         } catch (NullPointerException e) {
1384             checkMessage(e, &quot;staticLongArray[0][0] = 2L;&quot;, e.getMessage(),
1385                          &quot;Cannot store to long array because &quot; +
1386                          &quot;\&quot;NullPointerExceptionTest.staticLongArray[0]\&quot; is null&quot;);
1387         }
1388 
1389         try {
1390             NullPointerExceptionTest obj = this;
1391             Object val = obj.dag.getArray().clone();
1392             Asserts.assertNull(val);
1393             Asserts.fail();
1394         } catch (NullPointerException e) {
1395             checkMessage(e, &quot;Object val = obj.dag.getArray().clone();&quot;, e.getMessage(),
1396                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$DoubleArrayGen.getArray()\&quot; because &quot; +
1397                          (hasDebugInfo ? &quot;\&quot;obj&quot; : &quot;\&quot;&lt;local1&gt;&quot;) + &quot;.dag\&quot; is null&quot;);
1398         }
1399         try {
1400             int indexes[] = new int[1];
1401             NullPointerExceptionTest[] objs = new NullPointerExceptionTest[] {this};
1402             Object val = objs[indexes[0]].nullInstanceField.returnNull(null, null, 1f);
1403             Asserts.assertNull(val);
1404             Asserts.fail();
1405         } catch (NullPointerException e) {
1406             checkMessage(e, &quot;Object val = objs[indexes[0]].nullInstanceField.returnNull(null, null, 1f);&quot;, e.getMessage(),
1407                          &quot;Cannot invoke \&quot;NullPointerExceptionTest.returnNull(String[][], int[][][], float)\&quot; because &quot; +
1408                          (hasDebugInfo ? &quot;\&quot;objs[indexes&quot; : &quot;\&quot;&lt;local2&gt;[&lt;local1&gt;&quot;) + &quot;[0]].nullInstanceField\&quot; is null&quot;);
1409         }
1410 
1411         try {
1412             int indexes[] = new int[1];
1413             NullPointerExceptionTest[][] objs =
1414                 new NullPointerExceptionTest[][] {new NullPointerExceptionTest[] {this}};
1415             synchronized (objs[indexes[0]][0].nullInstanceField) {
1416                 Asserts.fail();
1417             }
1418         } catch (NullPointerException e) {
1419             checkMessage(e, &quot;synchronized (objs[indexes[0]][0].nullInstanceField) { ... }&quot;, e.getMessage(),
1420                          &quot;Cannot enter synchronized block because &quot; +
1421                          (hasDebugInfo ? &quot;\&quot;objs[indexes&quot; : &quot;\&quot;&lt;local2&gt;[&lt;local1&gt;&quot; ) + &quot;[0]][0].nullInstanceField\&quot; is null&quot;);
1422         }
1423 
1424         try {
1425             // If we can get the value from more than one bci, we cannot know which one
1426             // is null. Make sure we don&#39;t print the wrong value.
1427             String s = null;
1428             @SuppressWarnings(&quot;unused&quot;)
<a name="7" id="anc7"></a><span class="line-modified">1429             byte[] val = (rng.nextDouble() &lt; 0.5 ? s : (new String[1])[0]).getBytes();</span>
1430         } catch (NullPointerException e) {
<a name="8" id="anc8"></a><span class="line-modified">1431             checkMessage(e, &quot;byte[] val = (rng.nextDouble() &lt; 0.5 ? s : (new String[1])[0]).getBytes();&quot;, e.getMessage(),</span>
1432                          &quot;Cannot invoke \&quot;String.getBytes()\&quot;&quot;);
1433         }
1434 
1435         try {
1436             // If we can get the value from more than one bci, we cannot know which one
1437             // is null. Make sure we don&#39;t print the wrong value.  Also make sure if
1438             // we don&#39;t print the failed action we don&#39;t print a string at all.
1439             int[][] a = new int[1][];
1440             int[][] b = new int[2][];
1441             long index = 0;
1442             @SuppressWarnings(&quot;unused&quot;)
<a name="9" id="anc9"></a><span class="line-modified">1443             int val = (rng.nextDouble() &lt; 0.5 ? a[(int)index] : b[(int)index])[13];</span>
1444         } catch (NullPointerException e) {
<a name="10" id="anc10"></a><span class="line-modified">1445             checkMessage(e, &quot;int val = (rng.nextDouble() &lt; 0.5 ? a[(int)index] : b[(int)index])[13]&quot;, e.getMessage(),</span>
1446                          &quot;Cannot load from int array&quot;);
1447         }
1448 
1449         try {
1450             // If we can get the value from more than one bci, we cannot know which one
1451             // is null. Make sure we don&#39;t print the wrong value.  Also make sure if
1452             // we don&#39;t print the failed action we don&#39;t print a string at all.
1453             int[][] a = new int[1][];
1454             int[][] b = new int[2][];
1455             long index = 0;
<a name="11" id="anc11"></a><span class="line-modified">1456             int val = (rng.nextDouble() &lt; 0.5 ? a : b)[(int)index][13];</span>
1457         } catch (NullPointerException e) {
<a name="12" id="anc12"></a><span class="line-modified">1458             checkMessage(e, &quot;int val = (rng.nextDouble() &lt; 0.5 ? a : b)[(int)index][13]&quot;, e.getMessage(),</span>
1459                          &quot;Cannot load from int array because \&quot;&lt;array&gt;[...]\&quot; is null&quot;);
1460         }
1461 
1462         try {
1463             C c1 = new C();
1464             C c2 = new C();
<a name="13" id="anc13"></a><span class="line-modified">1465             (rng.nextDouble() &lt; 0.5 ? c1 : c2).to_d.num = 77;</span>
1466         } catch (NullPointerException e) {
<a name="14" id="anc14"></a><span class="line-modified">1467             checkMessage(e, &quot;(rng.nextDouble() &lt; 0.5 ? c1 : c2).to_d.num = 77;&quot;, e.getMessage(),</span>
1468                          &quot;Cannot assign field \&quot;num\&quot; because \&quot;to_d\&quot; is null&quot;);
1469         }
1470 
1471         // Static variable as array index.
1472         try {
1473             staticLongArray[index17][0] = 2L;
1474         }  catch (NullPointerException e) {
1475             checkMessage(e, &quot;staticLongArray[index17][0] = 2L;&quot;,  e.getMessage(),
1476                          &quot;Cannot store to long array because &quot; +
1477                          &quot;\&quot;NullPointerExceptionTest.staticLongArray[NullPointerExceptionTest.index17]\&quot; is null&quot;);
1478         }
1479 
1480         // Method call as array index.
1481         try {
1482             staticLongArray[getIndex17()][0] = 2L;
1483         }  catch (NullPointerException e) {
1484             checkMessage(e, &quot;staticLongArray[getIndex17()][0] = 2L;&quot;,  e.getMessage(),
1485                          &quot;Cannot store to long array because &quot; +
1486                          &quot;\&quot;NullPointerExceptionTest.staticLongArray[NullPointerExceptionTest.getIndex17()]\&quot; is null&quot;);
1487         }
1488 
1489         // Unboxing.
1490         Integer a = null;
1491         try {
1492             int b = a;
1493         }  catch (NullPointerException e) {
1494             checkMessage(e, &quot;Integer a = null; int b = a;&quot;,  e.getMessage(),
1495                          &quot;Cannot invoke \&quot;java.lang.Integer.intValue()\&quot; because &quot; +
1496                          (hasDebugInfo ? &quot;\&quot;a\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
1497         }
1498 
1499         // Unboxing by hand. Has the same message as above.
1500         try {
1501             int b = a.intValue();
1502         }  catch (NullPointerException e) {
1503             checkMessage(e, &quot;Integer a = null; int b = a.intValue();&quot;,  e.getMessage(),
1504                          &quot;Cannot invoke \&quot;java.lang.Integer.intValue()\&quot; because &quot; +
1505                          (hasDebugInfo ? &quot;\&quot;a\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
1506         }
1507     }
1508 
1509     // Generates:
1510     // class E implements E0 {
1511     //     public int throwNPE(F f) {
1512     //         return f.i;
1513     //     }
1514     //     public void throwNPE_reuseStackSlot1(String s1) {
1515     //         System.out.println(s1.substring(1));
1516     //         String s1_2 = null; // Reuses slot 1.
1517     //         System.out.println(s1_2.substring(1));
1518     //     }
1519     //     public void throwNPE_reuseStackSlot4(String s1, String s2, String s3, String s4) {
1520     //         System.out.println(s4.substring(1));
1521     //         String s4_2 = null;  // Reuses slot 4.
1522     //         System.out.println(s4_2.substring(1));
1523     //     }
1524     // }
1525     //
1526     // This code was adapted from output of
1527     //   java jdk.internal.org.objectweb.asm.util.ASMifier E0.class
1528     static byte[] generateTestClass() {
1529         ClassWriter cw = new ClassWriter(0);
1530         MethodVisitor mv;
1531 
1532         cw.visit(50, ACC_SUPER, &quot;E&quot;, null, &quot;java/lang/Object&quot;, new String[] { &quot;E0&quot; });
1533 
1534         {
1535             mv = cw.visitMethod(0, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
1536             mv.visitCode();
1537             mv.visitVarInsn(ALOAD, 0);
1538             mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);
1539             mv.visitInsn(RETURN);
1540             mv.visitMaxs(1, 1);
1541             mv.visitEnd();
1542         }
1543 
1544         {
1545             mv = cw.visitMethod(ACC_PUBLIC, &quot;throwNPE&quot;, &quot;(LF;)I&quot;, null, null);
1546             mv.visitCode();
1547             Label label0 = new Label();
1548             mv.visitLabel(label0);
1549             mv.visitLineNumber(118, label0);
1550             mv.visitVarInsn(ALOAD, 1);
1551             mv.visitFieldInsn(GETFIELD, &quot;F&quot;, &quot;i&quot;, &quot;I&quot;);
1552             mv.visitInsn(IRETURN);
1553             Label label1 = new Label();
1554             mv.visitLabel(label1);
1555             mv.visitLocalVariable(&quot;this&quot;, &quot;LE;&quot;, null, label0, label1, 0);
1556             mv.visitLocalVariable(&quot;f&quot;, &quot;LE;&quot;, null, label0, label1, 1);
1557             mv.visitMaxs(1, 2);
1558             mv.visitEnd();
1559         }
1560 
1561         {
1562             mv = cw.visitMethod(ACC_PUBLIC, &quot;throwNPE_reuseStackSlot1&quot;, &quot;(Ljava/lang/String;)V&quot;, null, null);
1563             mv.visitCode();
1564             Label label0 = new Label();
1565             mv.visitLabel(label0);
1566             mv.visitLineNumber(7, label0);
1567             mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
1568             mv.visitVarInsn(ALOAD, 1);
1569             mv.visitInsn(ICONST_1);
1570             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;substring&quot;, &quot;(I)Ljava/lang/String;&quot;, false);
1571             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
1572             Label label1 = new Label();
1573             mv.visitLabel(label1);
1574             mv.visitLineNumber(8, label1);
1575             mv.visitInsn(ACONST_NULL);
1576             mv.visitVarInsn(ASTORE, 1);
1577             Label label2 = new Label();
1578             mv.visitLabel(label2);
1579             mv.visitLineNumber(9, label2);
1580             mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
1581             mv.visitVarInsn(ALOAD, 1);
1582             mv.visitInsn(ICONST_1);
1583             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;substring&quot;, &quot;(I)Ljava/lang/String;&quot;, false);
1584             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
1585             Label label3 = new Label();
1586             mv.visitLabel(label3);
1587             mv.visitLineNumber(10, label3);
1588             mv.visitInsn(RETURN);
1589             mv.visitMaxs(3, 3);
1590             mv.visitEnd();
1591         }
1592 
1593         {
1594             mv = cw.visitMethod(ACC_PUBLIC, &quot;throwNPE_reuseStackSlot4&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V&quot;, null, null);
1595             mv.visitCode();
1596             Label label0 = new Label();
1597             mv.visitLabel(label0);
1598             mv.visitLineNumber(12, label0);
1599             mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
1600             mv.visitVarInsn(ALOAD, 4);
1601             mv.visitInsn(ICONST_1);
1602             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;substring&quot;, &quot;(I)Ljava/lang/String;&quot;, false);
1603             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
1604             Label label1 = new Label();
1605             mv.visitLabel(label1);
1606             mv.visitLineNumber(13, label1);
1607             mv.visitInsn(ACONST_NULL);
1608             mv.visitVarInsn(ASTORE, 4);
1609             Label label2 = new Label();
1610             mv.visitLabel(label2);
1611             mv.visitLineNumber(14, label2);
1612             mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
1613             mv.visitVarInsn(ALOAD, 4);
1614             mv.visitInsn(ICONST_1);
1615             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;substring&quot;, &quot;(I)Ljava/lang/String;&quot;, false);
1616             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
1617             Label label3 = new Label();
1618             mv.visitLabel(label3);
1619             mv.visitLineNumber(15, label3);
1620             mv.visitInsn(RETURN);
1621             mv.visitMaxs(3, 6);
1622             mv.visitEnd();
1623         }
1624 
1625         cw.visitEnd();
1626 
1627         return cw.toByteArray();
1628     }
1629 
1630     // Assign to a parameter.
1631     // Without debug information, this will print &quot;parameter1&quot; if a NPE
1632     // is raised in the first line because null was passed to the method.
1633     // It will print &quot;local1&quot; if a NPE is raised in line three.
1634     public void assign_to_parameter(String s1) {
1635         System.out.println(s1.substring(1));
1636         s1 = null;
1637         System.out.println(s1.substring(2));
1638     }
1639 
1640     // Tests that a class generated on the fly is handled properly.
1641     public void testGeneratedCode() throws Exception {
1642         byte[] classBytes = generateTestClass();
1643         Lookup lookup = lookup();
1644         Class&lt;?&gt; clazz = lookup.defineClass(classBytes);
1645         E0 e = (E0) clazz.getDeclaredConstructor().newInstance();
1646         try {
1647             e.throwNPE(null);
1648         } catch (NullPointerException ex) {
1649             checkMessage(ex, &quot;return f.i;&quot;,
1650                          ex.getMessage(),
1651                          &quot;Cannot read field \&quot;i\&quot; because \&quot;f\&quot; is null&quot;);
1652         }
1653 
1654         // Optimized bytecode can reuse local variable slots for several
1655         // local variables.
1656         // If there is no variable name information, we print &#39;parameteri&#39;
1657         // if a parameter maps to a local slot. Once a local slot has been
1658         // written, we don&#39;t know any more whether it was written as the
1659         // corresponding parameter, or whether another local has been
1660         // mapped to the slot. So we don&#39;t want to print &#39;parameteri&#39; any
1661         // more, but &#39;locali&#39;. Similary for &#39;this&#39;.
1662 
1663         // Expect message saying &quot;parameter0&quot;.
1664         try {
1665             e.throwNPE_reuseStackSlot1(null);
1666         } catch (NullPointerException ex) {
1667             checkMessage(ex, &quot;s1.substring(1)&quot;,
1668                          ex.getMessage(),
1669                          &quot;Cannot invoke \&quot;String.substring(int)\&quot; because \&quot;&lt;parameter1&gt;\&quot; is null&quot;);
1670         }
1671         // Expect message saying &quot;local0&quot;.
1672         try {
1673             e.throwNPE_reuseStackSlot1(&quot;aa&quot;);
1674         } catch (NullPointerException ex) {
1675             checkMessage(ex, &quot;s1_2.substring(1)&quot;,
1676                          ex.getMessage(),
1677                          &quot;Cannot invoke \&quot;String.substring(int)\&quot; because \&quot;&lt;local1&gt;\&quot; is null&quot;);
1678         }
1679         // Expect message saying &quot;parameter4&quot;.
1680         try {
1681             e.throwNPE_reuseStackSlot4(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, null);
1682         } catch (NullPointerException ex) {
1683             checkMessage(ex, &quot;s4.substring(1)&quot;,
1684                          ex.getMessage(),
1685                          &quot;Cannot invoke \&quot;String.substring(int)\&quot; because \&quot;&lt;parameter4&gt;\&quot; is null&quot;);
1686         }
1687         // Expect message saying &quot;local4&quot;.
1688         try {
1689             e.throwNPE_reuseStackSlot4(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);
1690         } catch (NullPointerException ex) {
1691             checkMessage(ex, &quot;s4_2.substring(1)&quot;,
1692                          ex.getMessage(),
1693                          &quot;Cannot invoke \&quot;String.substring(int)\&quot; because \&quot;&lt;local4&gt;\&quot; is null&quot;);
1694         }
1695 
1696         // Unfortunately, with the fix for optimized code as described above
1697         // we don&#39;t write &#39;parameteri&#39; any more after the parameter variable
1698         // has been assigned.
1699 
1700         if (!hasDebugInfo) {
1701             // Expect message saying &quot;parameter1&quot;.
1702             try {
1703                 assign_to_parameter(null);
1704             } catch (NullPointerException ex) {
1705                 checkMessage(ex, &quot;s1.substring(1)&quot;,
1706                              ex.getMessage(),
1707                              &quot;Cannot invoke \&quot;String.substring(int)\&quot; because \&quot;&lt;parameter1&gt;\&quot; is null&quot;);
1708             }
1709             // The message says &quot;local1&quot; although &quot;parameter1&quot; would be correct.
1710             try {
1711                 assign_to_parameter(&quot;aaa&quot;);
1712             } catch (NullPointerException ex) {
1713                 checkMessage(ex, &quot;s1.substring(2)&quot;,
1714                              ex.getMessage(),
1715                              &quot;Cannot invoke \&quot;String.substring(int)\&quot; because \&quot;&lt;local1&gt;\&quot; is null&quot;);
1716             }
1717         }
1718     }
1719 }
1720 
1721 // Helper interface for test cases needed for generateTestClass().
1722 interface E0 {
1723     public int  throwNPE(F f);
1724     public void throwNPE_reuseStackSlot1(String s1);
1725     public void throwNPE_reuseStackSlot4(String s1, String s2, String s3, String s4);
1726 }
1727 
1728 // Helper class for test cases needed for generateTestClass().
1729 class F {
1730     int i;
1731 }
1732 
1733 // For invokespecial test cases.
1734 class G {
1735     public String m2(String x) {
1736         return null;
1737     }
1738 
1739     // This generates the following class:
1740     //
1741     // class Sub2G extends G {
1742     //   public String m2(String x) {
1743     //       super = null;  // Possible in raw bytecode.
1744     //       return super.m2(x).substring(2);  // Uses invokespecial.
1745     //   }
1746     // }
1747     //
1748     // This code was adapted from output of
1749     //   java jdk.internal.org.objectweb.asm.util.ASMifier Sub2G.class
1750     static byte[] generateSub2GTestClass() {
1751         ClassWriter cw = new ClassWriter(0);
1752         MethodVisitor mv;
1753 
1754         cw.visit(50, ACC_SUPER, &quot;Sub2G&quot;, null, &quot;G&quot;, null);
1755 
1756         {
1757             mv = cw.visitMethod(0, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
1758             mv.visitCode();
1759             mv.visitVarInsn(ALOAD, 0);
1760             mv.visitMethodInsn(INVOKESPECIAL, &quot;G&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);
1761             mv.visitInsn(RETURN);
1762             mv.visitMaxs(1, 1);
1763             mv.visitEnd();
1764         }
1765         {
1766             mv = cw.visitMethod(ACC_PUBLIC, &quot;m2&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;, null, null);
1767             mv.visitCode();
1768             mv.visitInsn(ACONST_NULL);   // Will cause NPE.
1769             mv.visitVarInsn(ALOAD, 1);
1770             mv.visitMethodInsn(INVOKESPECIAL, &quot;G&quot;, &quot;m2&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;, false);
1771             mv.visitInsn(ICONST_2);
1772             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;substring&quot;, &quot;(I)Ljava/lang/String;&quot;, false);
1773             mv.visitInsn(ARETURN);
1774             mv.visitMaxs(2, 2);
1775             mv.visitEnd();
1776         }
1777 
1778         cw.visitEnd();
1779 
1780         return cw.toByteArray();
1781     }
1782 }
1783 class SubG extends G {
1784     public String m2(String x) {
1785         return super.m2(x).substring(2);
1786     }
1787 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
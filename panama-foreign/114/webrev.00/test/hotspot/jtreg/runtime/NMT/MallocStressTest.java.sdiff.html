<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/runtime/NMT/MallocStressTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="HugeArenaTracking.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="MallocTrackingVerify.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/runtime/NMT/MallocStressTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Stress test for malloc tracking
<span class="line-modified"> 27  * @key nmt jcmd stress</span>
 28  * @library /test/lib
 29  * @modules java.base/jdk.internal.misc
 30  *          java.management
 31  * @build sun.hotspot.WhiteBox
 32  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 33  * @run main/othervm/timeout=1200 -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail MallocStressTest
 34  */
 35 
 36 import java.util.concurrent.atomic.AtomicInteger;
 37 import java.util.ArrayList;
 38 import java.util.List;
 39 import java.util.Random;
 40 import jdk.test.lib.JDKToolFinder;
 41 import jdk.test.lib.Platform;

 42 import jdk.test.lib.process.ProcessTools;
 43 import jdk.test.lib.process.OutputAnalyzer;
 44 import sun.hotspot.WhiteBox;
 45 
 46 public class MallocStressTest {
 47     private static int K = 1024;
 48 
 49     // The stress test runs in three phases:
 50     // 1. alloc: A lot of malloc with fewer free, which simulates a burst memory allocation
 51     //    that is usually seen during startup or class loading.
 52     // 2. pause: Pause the test to check accuracy of native memory tracking
 53     // 3. release: Release all malloc&#39;d memory and check native memory tracking result.
 54     public enum TestPhase {
 55         alloc,
 56         pause,
 57         release
 58     };
 59 
 60     static volatile TestPhase phase = TestPhase.alloc;
 61 
</pre>
<hr />
<pre>
142             Thread.sleep(n);
143         } catch (InterruptedException e) {
144         }
145     }
146 
147 
148     static class MallocMemory {
149         private long  addr;
150         private int   size;
151 
152         MallocMemory(long addr, int size) {
153             this.addr = addr;
154             this.size = size;
155         }
156 
157         long addr()  { return this.addr; }
158         int  size()  { return this.size; }
159     }
160 
161     static class AllocThread extends Thread {

162         AllocThread() {
163             this.setName(&quot;MallocThread&quot;);
164             this.start();
165         }
166 
167         // AllocThread only runs &quot;Alloc&quot; phase
168         public void run() {
<span class="line-removed">169             Random random = new Random();</span>
170             // MallocStressTest.phase == TestPhase.alloc
171             for (int loops = 0; loops &lt; 100; loops++) {
172                 int r = random.nextInt(Integer.MAX_VALUE);
173                 // Only malloc small amount to avoid OOM
174                 int size = r % 32;
175                 if (is_64_bit_system()) {
176                     r = r % 32 * K;
177                 } else {
178                     r = r % 64;
179                 }
180                 if (size == 0) size = 1;
181                 long addr = MallocStressTest.whiteBox.NMTMallocWithPseudoStack(size, r);
182                 if (addr != 0) {
183                     try {
184                         MallocMemory mem = new MallocMemory(addr, size);
185                         synchronized(MallocStressTest.mallocd_memory) {
186                             MallocStressTest.mallocd_memory.add(mem);
187                             MallocStressTest.mallocd_total += size;
188                         }
189                     } catch (OutOfMemoryError e) {
190                         // Don&#39;t include this malloc memory because it didn&#39;t
191                         // get recorded in mallocd_memory list.
192                         MallocStressTest.whiteBox.NMTFree(addr);
193                         break;
194                     }
195                 } else {
196                     break;
197                 }
198             }
199             MallocStressTest.pause_count.incrementAndGet();
200         }
201     }
202 
203     static class ReleaseThread extends Thread {
<span class="line-modified">204         private Random random = new Random();</span>
205         ReleaseThread() {
206             this.setName(&quot;ReleaseThread&quot;);
207             this.start();
208         }
209 
210         public void run() {
211             while(true) {
212                 switch(MallocStressTest.phase) {
213                 case alloc:
214                     slow_release();
215                     break;
216                 case pause:
217                     enter_pause();
218                     break;
219                 case release:
220                     quick_release();
221                     return;
222                 }
223             }
224         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Stress test for malloc tracking
<span class="line-modified"> 27  * @key nmt jcmd stress randomness</span>
 28  * @library /test/lib
 29  * @modules java.base/jdk.internal.misc
 30  *          java.management
 31  * @build sun.hotspot.WhiteBox
 32  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 33  * @run main/othervm/timeout=1200 -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail MallocStressTest
 34  */
 35 
 36 import java.util.concurrent.atomic.AtomicInteger;
 37 import java.util.ArrayList;
 38 import java.util.List;
 39 import java.util.Random;
 40 import jdk.test.lib.JDKToolFinder;
 41 import jdk.test.lib.Platform;
<span class="line-added"> 42 import jdk.test.lib.Utils;</span>
 43 import jdk.test.lib.process.ProcessTools;
 44 import jdk.test.lib.process.OutputAnalyzer;
 45 import sun.hotspot.WhiteBox;
 46 
 47 public class MallocStressTest {
 48     private static int K = 1024;
 49 
 50     // The stress test runs in three phases:
 51     // 1. alloc: A lot of malloc with fewer free, which simulates a burst memory allocation
 52     //    that is usually seen during startup or class loading.
 53     // 2. pause: Pause the test to check accuracy of native memory tracking
 54     // 3. release: Release all malloc&#39;d memory and check native memory tracking result.
 55     public enum TestPhase {
 56         alloc,
 57         pause,
 58         release
 59     };
 60 
 61     static volatile TestPhase phase = TestPhase.alloc;
 62 
</pre>
<hr />
<pre>
143             Thread.sleep(n);
144         } catch (InterruptedException e) {
145         }
146     }
147 
148 
149     static class MallocMemory {
150         private long  addr;
151         private int   size;
152 
153         MallocMemory(long addr, int size) {
154             this.addr = addr;
155             this.size = size;
156         }
157 
158         long addr()  { return this.addr; }
159         int  size()  { return this.size; }
160     }
161 
162     static class AllocThread extends Thread {
<span class="line-added">163         private final Random random = new Random(Utils.getRandomInstance().nextLong());</span>
164         AllocThread() {
165             this.setName(&quot;MallocThread&quot;);
166             this.start();
167         }
168 
169         // AllocThread only runs &quot;Alloc&quot; phase
170         public void run() {

171             // MallocStressTest.phase == TestPhase.alloc
172             for (int loops = 0; loops &lt; 100; loops++) {
173                 int r = random.nextInt(Integer.MAX_VALUE);
174                 // Only malloc small amount to avoid OOM
175                 int size = r % 32;
176                 if (is_64_bit_system()) {
177                     r = r % 32 * K;
178                 } else {
179                     r = r % 64;
180                 }
181                 if (size == 0) size = 1;
182                 long addr = MallocStressTest.whiteBox.NMTMallocWithPseudoStack(size, r);
183                 if (addr != 0) {
184                     try {
185                         MallocMemory mem = new MallocMemory(addr, size);
186                         synchronized(MallocStressTest.mallocd_memory) {
187                             MallocStressTest.mallocd_memory.add(mem);
188                             MallocStressTest.mallocd_total += size;
189                         }
190                     } catch (OutOfMemoryError e) {
191                         // Don&#39;t include this malloc memory because it didn&#39;t
192                         // get recorded in mallocd_memory list.
193                         MallocStressTest.whiteBox.NMTFree(addr);
194                         break;
195                     }
196                 } else {
197                     break;
198                 }
199             }
200             MallocStressTest.pause_count.incrementAndGet();
201         }
202     }
203 
204     static class ReleaseThread extends Thread {
<span class="line-modified">205         private final Random random = new Random(Utils.getRandomInstance().nextLong());</span>
206         ReleaseThread() {
207             this.setName(&quot;ReleaseThread&quot;);
208             this.start();
209         }
210 
211         public void run() {
212             while(true) {
213                 switch(MallocStressTest.phase) {
214                 case alloc:
215                     slow_release();
216                     break;
217                 case pause:
218                     enter_pause();
219                     break;
220                 case release:
221                     quick_release();
222                     return;
223                 }
224             }
225         }
</pre>
</td>
</tr>
</table>
<center><a href="HugeArenaTracking.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="MallocTrackingVerify.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
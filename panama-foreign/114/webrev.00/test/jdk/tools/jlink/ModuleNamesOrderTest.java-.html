<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/tools/jlink/ModuleNamesOrderTest.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.File;
 25 import java.io.FileReader;
 26 import java.io.IOException;
 27 import java.nio.file.Path;
 28 import java.nio.file.Paths;
 29 import java.util.List;
 30 import java.util.Properties;
 31 import java.util.spi.ToolProvider;
 32 import java.util.stream.Collectors;
 33 import java.util.stream.Stream;
 34 
 35 import tests.Helper;
 36 import tests.JImageGenerator;
 37 import tests.JImageGenerator.JLinkTask;
 38 
 39 /*
 40  * @test
 41  * @bug 8168925
 42  * @summary MODULES property should be topologically ordered and space-separated list
 43  * @library ../lib
 44  * @modules java.base/jdk.internal.jimage
 45  *          jdk.jdeps/com.sun.tools.classfile
 46  *          jdk.jlink/jdk.tools.jlink.internal
 47  *          jdk.jlink/jdk.tools.jmod
 48  *          jdk.jlink/jdk.tools.jimage
 49  *          jdk.compiler
 50  *          jdk.scripting.nashorn
 51  *          jdk.scripting.nashorn.shell
 52  *
 53  * @build tests.*
 54  * @run main ModuleNamesOrderTest
 55  */
 56 public class ModuleNamesOrderTest {
 57     static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(&quot;jlink&quot;)
 58         .orElseThrow(() -&gt;
 59             new RuntimeException(&quot;jlink tool not found&quot;)
 60         );
 61 
 62     public static void main(String[] args) throws Exception {
 63         Helper helper = Helper.newHelper();
 64         if (helper == null) {
 65             System.err.println(&quot;Test not run&quot;);
 66             return;
 67         }
 68 
 69         testDependences(helper);
 70         testModulesOrder(helper);
 71     }
 72 
 73     private static List&lt;String&gt; modulesProperty(Path outputDir, String modulePath, String... roots)
 74         throws IOException
 75     {
 76         JLinkTask jlinkTask = JImageGenerator.getJLinkTask()
 77                                              .modulePath(modulePath)
 78                                              .output(outputDir);
 79         Stream.of(roots).forEach(jlinkTask::addMods);
 80         jlinkTask.call().assertSuccess();
 81 
 82         File release = new File(outputDir.toString(), &quot;release&quot;);
 83         if (!release.exists()) {
 84             throw new AssertionError(&quot;release not generated&quot;);
 85         }
 86 
 87         Properties props = new Properties();
 88         try (FileReader reader = new FileReader(release)) {
 89             props.load(reader);
 90         }
 91 
 92         String modules = props.getProperty(&quot;MODULES&quot;);
 93         if (!modules.startsWith(&quot;\&quot;java.base &quot;)) {
 94             throw new AssertionError(&quot;MODULES should start with &#39;java.base&#39;&quot;);
 95         }
 96         if (modules.charAt(0) != &#39;&quot;&#39; || modules.charAt(modules.length()-1) != &#39;&quot;&#39;) {
 97             throw new AssertionError(&quot;MODULES value should be double quoted&quot;);
 98         }
 99 
100         return Stream.of(modules.substring(1, modules.length()-1).split(&quot;\\s+&quot;))
101                      .collect(Collectors.toList());
102     }
103 
104     private static void testDependences(Helper helper) throws IOException {
105         Path outputDir = helper.createNewImageDir(&quot;test&quot;);
106         List&lt;String&gt; modules = modulesProperty(outputDir, helper.defaultModulePath(),
107             &quot;jdk.scripting.nashorn&quot;);
108         String last = modules.get(modules.size()-1);
109         if (!last.equals(&quot;jdk.scripting.nashorn&quot;)) {
110             throw new AssertionError(&quot;Unexpected MODULES value: &quot; + modules);
111         }
112 
113         checkDependency(modules, &quot;java.logging&quot;, &quot;java.base&quot;);
114         checkDependency(modules, &quot;jdk.dynalink&quot;, &quot;java.logging&quot;);
115         checkDependency(modules, &quot;java.scripting&quot;, &quot;java.base&quot;);
116         checkDependency(modules, &quot;jdk.scripting.nashorn&quot;, &quot;java.logging&quot;);
117         checkDependency(modules, &quot;jdk.scripting.nashorn&quot;, &quot;jdk.dynalink&quot;);
118         checkDependency(modules, &quot;jdk.scripting.nashorn&quot;, &quot;java.scripting&quot;);
119     }
120 
121     /*
122      * Verify the MODULES list must be the same for the same module graph
123      */
124     private static void testModulesOrder(Helper helper) throws IOException {
125         Path image1 = helper.createNewImageDir(&quot;test1&quot;);
126         List&lt;String&gt; modules1 = modulesProperty(image1, helper.defaultModulePath(),
127             &quot;jdk.scripting.nashorn&quot;, &quot;jdk.scripting.nashorn.shell&quot;);
128         Path image2 = helper.createNewImageDir(&quot;test2&quot;);
129         List&lt;String&gt; modules2 = modulesProperty(image2, helper.defaultModulePath(),
130             &quot;jdk.scripting.nashorn.shell&quot;, &quot;jdk.scripting.nashorn&quot;);
131         if (!modules1.equals(modules2)) {
132             throw new AssertionError(&quot;MODULES should be a stable order: &quot; +
133                 modules1 + &quot; vs &quot; + modules2);
134         }
135     }
136 
137     private static void checkDependency(List&lt;String&gt; modules, String fromMod, String toMod) {
138         int fromModIdx = modules.indexOf(fromMod);
139         if (fromModIdx == -1) {
140             throw new AssertionError(fromMod + &quot; is missing in MODULES&quot;);
141         }
142         int toModIdx = modules.indexOf(toMod);
143         if (toModIdx == -1) {
144             throw new AssertionError(toMod + &quot; is missing in MODULES&quot;);
145         }
146 
147         if (toModIdx &gt; fromModIdx) {
148             throw new AssertionError(&quot;in MODULES, &quot; + fromMod + &quot; should appear after &quot; + toMod);
149         }
150     }
151 }
    </pre>
  </body>
</html>
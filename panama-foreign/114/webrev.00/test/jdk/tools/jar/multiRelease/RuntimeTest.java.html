<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/tools/jar/multiRelease/RuntimeTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Test Multi-Release jar usage in runtime
 27  * @library /test/lib
 28  * @modules jdk.compiler
 29  * @build jdk.test.lib.compiler.CompilerUtils
 30  *        jdk.test.lib.Utils
 31  *        jdk.test.lib.Asserts
 32  *        jdk.test.lib.JDKToolFinder
 33  *        jdk.test.lib.JDKToolLauncher
 34  *        jdk.test.lib.Platform
 35  *        jdk.test.lib.process.*
 36  * @run testng RuntimeTest
 37  */
 38 
 39 import static org.testng.Assert.*;
 40 
 41 import java.io.BufferedReader;
 42 import java.io.File;
 43 import java.io.IOException;
 44 import java.io.InputStream;
 45 import java.io.InputStreamReader;
 46 import java.io.UncheckedIOException;
 47 import java.lang.reflect.InvocationTargetException;
 48 import java.lang.reflect.Method;
 49 import java.net.URL;
 50 import java.net.URLClassLoader;
 51 import java.nio.file.Files;
 52 import java.nio.file.Path;
 53 import java.nio.file.Paths;
 54 import java.nio.file.StandardCopyOption;
 55 import java.util.ArrayList;
 56 import java.util.Arrays;
 57 import java.util.HashMap;
 58 import java.util.List;
 59 import java.util.Map;
 60 import java.util.stream.Collectors;
 61 import java.util.stream.Stream;
 62 
 63 import org.testng.annotations.BeforeClass;
 64 import org.testng.annotations.DataProvider;
 65 import org.testng.annotations.Test;
 66 
 67 import jdk.test.lib.JDKToolFinder;
 68 import jdk.test.lib.JDKToolLauncher;
 69 import jdk.test.lib.compiler.CompilerUtils;
 70 import jdk.test.lib.process.OutputAnalyzer;
 71 import jdk.test.lib.process.ProcessTools;
 72 
 73 public class RuntimeTest {
 74     public static final int SUCCESS = 0;
 75     private static final String src = System.getProperty(&quot;test.src&quot;, &quot;.&quot;);
 76     private static final String usr = System.getProperty(&quot;user.dir&quot;, &quot;.&quot;);
 77 
 78     private static final Path srcFileRoot = Paths.get(src, &quot;data&quot;, &quot;runtimetest&quot;);
 79     private static final Path genFileRoot = Paths.get(usr, &quot;data&quot;, &quot;runtimetest&quot;);
 80 
 81     private static final int OLD_RELEASE = 8;
 82     private static final int CURRENT_RELEASE = Runtime.version().major();
 83     private static final int FUTURE_RELEASE = CURRENT_RELEASE + 1;
 84     private static final String MRJAR_BOTH_RELEASES = &quot;MV_BOTH.jar&quot;;
 85     private static final String MRJAR_CURRENT_RELEASE = &quot;MV_ONLY_&quot; + CURRENT_RELEASE + &quot;.jar&quot;;
 86     private static final String NON_MRJAR_OLD_RELEASE = &quot;NON_MV.jar&quot;;
 87 
 88     private static final int[] versions = { OLD_RELEASE, CURRENT_RELEASE, FUTURE_RELEASE };
 89 
 90     @DataProvider(name = &quot;jarFiles&quot;)
 91     Object[][] jarFiles() {
 92         return new Object[][]{
 93             { MRJAR_BOTH_RELEASES, CURRENT_RELEASE, CURRENT_RELEASE, CURRENT_RELEASE },
 94             { MRJAR_CURRENT_RELEASE, CURRENT_RELEASE, CURRENT_RELEASE, CURRENT_RELEASE },
 95             { NON_MRJAR_OLD_RELEASE, OLD_RELEASE, OLD_RELEASE, OLD_RELEASE }
 96         };
 97     }
 98 
 99     @BeforeClass
100     protected void setUpTest() throws Throwable {
101         createJarSourceFiles();
102         compile();
103         Path classes = Paths.get(&quot;classes&quot;);
104         jar(&quot;cfm&quot;, MRJAR_BOTH_RELEASES, &quot;manifest.txt&quot;,
105                 &quot;-C&quot;, classes.resolve(&quot;v&quot; + OLD_RELEASE).toString(), &quot;.&quot;,
106                 &quot;--release&quot;, &quot;&quot; + CURRENT_RELEASE, &quot;-C&quot;, classes.resolve(&quot;v&quot; + CURRENT_RELEASE).toString(), &quot;.&quot;,
107                 &quot;--release&quot;, &quot;&quot; + FUTURE_RELEASE, &quot;-C&quot;, classes.resolve(&quot;v&quot; + FUTURE_RELEASE).toString(), &quot;.&quot;)
108                 .shouldHaveExitValue(0);
109 
110         jar(&quot;cfm&quot;, MRJAR_CURRENT_RELEASE, &quot;manifest.txt&quot;,
111                 &quot;-C&quot;, classes.resolve(&quot;v&quot; + OLD_RELEASE).toString(), &quot;.&quot;,
112                 &quot;--release&quot;, &quot;&quot; + CURRENT_RELEASE, &quot;-C&quot;, classes.resolve(&quot;v&quot; + CURRENT_RELEASE).toString(), &quot;.&quot;)
113                 .shouldHaveExitValue(0);
114         jar(&quot;cfm&quot;, NON_MRJAR_OLD_RELEASE, &quot;manifest.txt&quot;,
115                 &quot;-C&quot;, classes.resolve(&quot;v&quot; + OLD_RELEASE).toString(), &quot;.&quot;)
116                 .shouldHaveExitValue(0);
117     }
118 
119     @Test(dataProvider = &quot;jarFiles&quot;)
120     public void testClasspath(String jar, int mainVer, int helperVer,
121             int resVer) throws Throwable {
122         String[] command = { &quot;-cp&quot;, jar, &quot;testpackage.Main&quot; };
123         System.out.println(&quot;Command arguments:&quot; + Arrays.asList(command));
124         System.out.println();
125         java(command).shouldHaveExitValue(SUCCESS)
126                 .shouldContain(&quot;Main version: &quot; + mainVer)
127                 .shouldContain(&quot;Helpers version: &quot; + helperVer)
128                 .shouldContain(&quot;Resource version: &quot; + resVer);
129     }
130 
131     @Test(dataProvider = &quot;jarFiles&quot;)
132     void testMVJarAsLib(String jar, int mainVer, int helperVer, int resVer)
133             throws Throwable {
134         String[] apps = { &quot;UseByImport&quot;, &quot;UseByReflection&quot; };
135         for (String app : apps) {
136             String[] command = {&quot;-cp&quot;,
137                     jar + File.pathSeparatorChar + &quot;classes/test/&quot;, app };
138             System.out.println(&quot;Command arguments:&quot; + Arrays.asList(command));
139             System.out.println();
140             java(command).shouldHaveExitValue(SUCCESS)
141                     .shouldContain(&quot;Main version: &quot; + mainVer)
142                     .shouldContain(&quot;Helpers version: &quot; + helperVer)
143                     .shouldContain(&quot;Resource version: &quot; + resVer);
144         }
145     }
146 
147     @Test(dataProvider = &quot;jarFiles&quot;)
148     void testJavaJar(String jar, int mainVer, int helperVer, int resVer)
149             throws Throwable {
150         String[] command = { &quot;-jar&quot;, jar };
151         System.out.println(&quot;Command arguments:&quot; + Arrays.asList(command));
152         System.out.println();
153         java(command).shouldHaveExitValue(SUCCESS)
154                 .shouldContain(&quot;Main version: &quot; + mainVer)
155                 .shouldContain(&quot;Helpers version: &quot; + helperVer)
156                 .shouldContain(&quot;Resource version: &quot; + resVer);
157     }
158 
159     @Test(dataProvider = &quot;jarFiles&quot;)
160     void testURLClassLoader(String jarName, int mainVer, int helperVer,
161             int resVer) throws ClassNotFoundException, NoSuchMethodException,
162             IllegalAccessException, IllegalArgumentException,
163             InvocationTargetException, IOException {
164         Path pathToJAR = Paths.get(jarName).toAbsolutePath();
165         URL jarURL1 = new URL(&quot;jar:file:&quot; + pathToJAR + &quot;!/&quot;);
166         URL jarURL2 = new URL(&quot;file:///&quot; + pathToJAR);
167         testURLClassLoaderURL(jarURL1, mainVer, helperVer, resVer);
168         testURLClassLoaderURL(jarURL2, mainVer, helperVer, resVer);
169     }
170 
171     private static void testURLClassLoaderURL(URL jarURL,
172             int mainVersionExpected, int helperVersionExpected,
173             int resourceVersionExpected) throws ClassNotFoundException,
174             NoSuchMethodException, IllegalAccessException,
175             IllegalArgumentException, InvocationTargetException, IOException {
176         System.out.println(
177                 &quot;Testing URLClassLoader MV JAR support for URL: &quot; + jarURL);
178         URL[] urls = { jarURL };
179         int mainVersionActual;
180         int helperVersionActual;
181         int resourceVersionActual;
182         try (URLClassLoader cl = URLClassLoader.newInstance(urls)) {
183             Class c = cl.loadClass(&quot;testpackage.Main&quot;);
184             Method getMainVersion = c.getMethod(&quot;getMainVersion&quot;);
185             mainVersionActual = (int) getMainVersion.invoke(null);
186             Method getHelperVersion = c.getMethod(&quot;getHelperVersion&quot;);
187             helperVersionActual = (int) getHelperVersion.invoke(null);
188             try (InputStream ris = cl.getResourceAsStream(&quot;versionResource&quot;);
189                     BufferedReader br = new BufferedReader(
190                             new InputStreamReader(ris))) {
191                 resourceVersionActual = Integer.parseInt(br.readLine());
192             }
193         }
194 
195         assertEquals(mainVersionActual, mainVersionExpected,
196                          &quot;Test failed: Expected Main class version: &quot;
197                          + mainVersionExpected + &quot; Actual version: &quot;
198                          + mainVersionActual);
199         assertEquals(helperVersionActual, helperVersionExpected,
200                          &quot;Test failed: Expected Helper class version: &quot;
201                          + helperVersionExpected + &quot; Actual version: &quot;
202                          + helperVersionActual);
203         assertEquals(resourceVersionActual, resourceVersionExpected,
204                          &quot;Test failed: Expected resource version: &quot;
205                          + resourceVersionExpected + &quot; Actual version: &quot;
206                          + resourceVersionActual);
207     }
208 
209     private static OutputAnalyzer jar(String... args) throws Throwable {
210         JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(&quot;jar&quot;);
211         Stream.of(args).forEach(launcher::addToolArg);
212         return ProcessTools.executeCommand(launcher.getCommand());
213     }
214 
215     private static String platformPath(String p) {
216         return p.replace(&quot;/&quot;, File.separator);
217     }
218 
219     private static void createJarSourceFiles() throws IOException {
220         for (int ver : versions) {
221             Files.find(srcFileRoot, 3, (file, attrs) -&gt; (file.toString().endsWith(&quot;.template&quot;)))
222                  .map(srcFileRoot::relativize)
223                  .map(Path::toString)
224                  .map(p -&gt; p.replace(&quot;.template&quot;, &quot;&quot;))
225                  .forEach(f -&gt; {
226                      try {
227                          Path template = srcFileRoot.resolve(f + &quot;.template&quot;);
228                          Path out = genFileRoot.resolve(platformPath(&quot;v&quot; + ver + &quot;/&quot; + f));
229                          Files.createDirectories(out.getParent());
230                          List&lt;String&gt; lines = Files.lines(template)
231                                  .map(s -&gt; s.replaceAll(&quot;\\$version&quot;, String.valueOf(ver)))
232                                  .collect(Collectors.toList());
233                          Files.write(out, lines);
234                      } catch (IOException x) {
235                          throw new UncheckedIOException(x);
236                      }
237                  });
238         }
239     }
240 
241     private void compile() throws Throwable {
242         for (int ver : versions) {
243             Path classes = Paths.get(usr, &quot;classes&quot;, &quot;v&quot; + ver);
244             Files.createDirectories(classes);
245             Path source = genFileRoot.resolve(&quot;v&quot; + ver);
246             assertTrue(CompilerUtils.compile(source, classes));
247             Files.copy(source.resolve(&quot;versionResource&quot;),
248                     classes.resolve(&quot;versionResource&quot;),
249                     StandardCopyOption.REPLACE_EXISTING);
250         }
251 
252         Path classes = Paths.get(usr, &quot;classes&quot;, &quot;test&quot;);
253         Files.createDirectory(classes);
254         Path source = srcFileRoot.resolve(&quot;test&quot;);
255         assertTrue(
256                 CompilerUtils.compile(source, classes, &quot;-cp&quot;, &quot;classes/v&quot; + OLD_RELEASE));
257         Files.copy(srcFileRoot.resolve(&quot;manifest.txt&quot;),
258                 Paths.get(usr, &quot;manifest.txt&quot;),
259                 StandardCopyOption.REPLACE_EXISTING);
260     }
261 
262     OutputAnalyzer java(String... args) throws Throwable {
263         String java = JDKToolFinder.getJDKTool(&quot;java&quot;);
264 
265         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
266         commands.add(java);
267         Stream.of(args).forEach(x -&gt; commands.add(x));
268         return ProcessTools.executeCommand(new ProcessBuilder(commands));
269     }
270 }
    </pre>
  </body>
</html>
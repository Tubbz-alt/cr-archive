<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/jdk/jshell/CompletenessStressTest.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.File;
 25 import java.io.IOException;
 26 import java.io.StringWriter;
 27 import java.nio.charset.StandardCharsets;
 28 import java.nio.file.Files;
 29 import java.nio.file.Path;
 30 import java.nio.file.Paths;
 31 import java.util.ArrayList;
 32 import java.util.List;
 33 import java.util.Set;
 34 import java.util.stream.Collectors;
 35 
 36 import javax.lang.model.element.Modifier;
 37 import javax.tools.JavaCompiler;
 38 import javax.tools.JavaFileObject;
 39 import javax.tools.StandardJavaFileManager;
 40 import javax.tools.ToolProvider;
 41 
 42 import com.sun.source.tree.BlockTree;
 43 import com.sun.source.tree.BreakTree;
 44 import com.sun.source.tree.CaseTree;
 45 import com.sun.source.tree.ClassTree;
 46 import com.sun.source.tree.CompilationUnitTree;
 47 import com.sun.source.tree.ContinueTree;
 48 import com.sun.source.tree.DoWhileLoopTree;
 49 import com.sun.source.tree.ExpressionStatementTree;
 50 import com.sun.source.tree.ForLoopTree;
 51 import com.sun.source.tree.IfTree;
 52 import com.sun.source.tree.ImportTree;
 53 import com.sun.source.tree.LabeledStatementTree;
 54 import com.sun.source.tree.LineMap;
 55 import com.sun.source.tree.MethodTree;
 56 import com.sun.source.tree.ReturnTree;
 57 import com.sun.source.tree.StatementTree;
 58 import com.sun.source.tree.SwitchTree;
 59 import com.sun.source.tree.Tree;
 60 import com.sun.source.tree.WhileLoopTree;
 61 import com.sun.source.util.SourcePositions;
 62 import com.sun.source.util.Trees;
 63 import com.sun.tools.javac.api.JavacTaskImpl;
 64 
 65 import jdk.jshell.SourceCodeAnalysis;
 66 
 67 import org.testng.annotations.DataProvider;
 68 import org.testng.annotations.Test;
 69 
 70 import static java.lang.Integer.max;
 71 import static java.lang.Integer.min;
 72 import static jdk.jshell.SourceCodeAnalysis.Completeness.*;
 73 
 74 public class CompletenessStressTest extends KullaTesting {
 75     public final static String JDK_ROOT_SRC_PROP = &quot;jdk.root.src&quot;;
 76     public final static String JDK_ROOT_SRC;
 77 
 78     static {
 79         JDK_ROOT_SRC = System.getProperty(JDK_ROOT_SRC_PROP);
 80     }
 81 
 82     public File getSourceFile(String fileName) {
 83         for (File dir : getDirectoriesToTest()) {
 84             File file = new File(dir, fileName);
 85             if (file.exists()) {
 86                 return file;
 87             }
 88         }
 89         throw new AssertionError(&quot;File not found: &quot; + fileName);
 90     }
 91 
 92     public File[] getDirectoriesToTest() {
 93         return new File[]{
<a name="1" id="anc1"></a>
 94                 new File(JDK_ROOT_SRC, &quot;langtools/src&quot;),
 95                 new File(JDK_ROOT_SRC, &quot;jaxp/src&quot;),
 96                 new File(JDK_ROOT_SRC, &quot;jaxws/src&quot;),
 97                 new File(JDK_ROOT_SRC, &quot;jdk/src&quot;),
 98                 new File(JDK_ROOT_SRC, &quot;corba/src&quot;)
 99         };
100     }
101 
102     @DataProvider(name = &quot;crawler&quot;)
103     public Object[][] dataProvider() throws IOException {
104         File[] srcDirs = getDirectoriesToTest();
105         List&lt;String[]&gt; list = new ArrayList&lt;&gt;();
106         for (File srcDir : srcDirs) {
107             String srcDirName = srcDir.getAbsolutePath();
108             // this is just to obtain pretty test names for testng tests
109             List&lt;String[]&gt; a = Files.walk(Paths.get(srcDirName))
110                     .map(Path::toFile)
111                     .map(File::getAbsolutePath)
112                     .filter(n -&gt; n.endsWith(&quot;.java&quot;))
113                     .map(n -&gt; n.replace(srcDirName, &quot;&quot;))
114                     .map(n -&gt; new String[]{n})
115                     .collect(Collectors.toList());
116             if (a.isEmpty()) {
117                 throw new AssertionError(&quot;Java sources have not been found in directory: &quot; + srcDirName);
118             }
119             list.addAll(a);
120         }
121         return list.toArray(new String[list.size()][]);
122     }
123 
124     @Test(dataProvider = &quot;crawler&quot;)
125     public void testFile(String fileName) throws IOException {
126         File file = getSourceFile(fileName);
127         final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
128         final StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);
129         boolean success = true;
130         StringWriter writer = new StringWriter();
131         writer.write(&quot;Testing : &quot; + file.toString() + &quot;\n&quot;);
132         String text = new String(Files.readAllBytes(file.toPath()), StandardCharsets.UTF_8);
133         Iterable&lt;? extends JavaFileObject&gt; compilationUnits = fileManager.getJavaFileObjects(file);
134         JavacTaskImpl task = (JavacTaskImpl) compiler.getTask(null, fileManager, null, null, null, compilationUnits);
135         Iterable&lt;? extends CompilationUnitTree&gt; asts = task.parse();
136         Trees trees = Trees.instance(task);
137         SourcePositions sp = trees.getSourcePositions();
138 
139         for (CompilationUnitTree cut : asts) {
140             for (ImportTree imp : cut.getImports()) {
141                 success &amp;= testStatement(writer, sp, text, cut, imp);
142             }
143             for (Tree decl : cut.getTypeDecls()) {
144                 success &amp;= testStatement(writer, sp, text, cut, decl);
145                 if (decl instanceof ClassTree) {
146                     ClassTree ct = (ClassTree) decl;
147                     for (Tree mem : ct.getMembers()) {
148                         if (mem instanceof MethodTree) {
149                             MethodTree mt = (MethodTree) mem;
150                             BlockTree bt = mt.getBody();
151                             // No abstract methods or constructors
152                             if (bt != null &amp;&amp; mt.getReturnType() != null) {
153                                 // The modifiers synchronized, abstract, and default are not allowed on
154                                 // top-level declarations and are errors.
155                                 Set&lt;Modifier&gt; modifier = mt.getModifiers().getFlags();
156                                 if (!modifier.contains(Modifier.ABSTRACT)
157                                         &amp;&amp; !modifier.contains(Modifier.SYNCHRONIZED)
158                                         &amp;&amp; !modifier.contains(Modifier.DEFAULT)) {
159                                     success &amp;= testStatement(writer, sp, text, cut, mt);
160                                 }
161                                 testBlock(writer, sp, text, cut, bt);
162                             }
163                         }
164                     }
165                 }
166             }
167         }
168         fileManager.close();
169         if (!success) {
170             throw new AssertionError(writer.toString());
171         }
172     }
173 
174     private boolean isLegal(StatementTree st) {
175         return !(st instanceof ReturnTree) &amp;&amp;
176                 !(st instanceof ContinueTree) &amp;&amp; !(st instanceof BreakTree);
177     }
178 
179     private boolean testBranch(StringWriter writer, SourcePositions sp, String text, CompilationUnitTree cut, StatementTree statementTree) {
180         if (statementTree instanceof BlockTree) {
181             return testBlock(writer, sp, text, cut, (BlockTree) statementTree);
182         } else if (isLegal(statementTree)) {
183             return testStatement(writer, sp, text, cut, statementTree);
184         }
185         return true;
186     }
187 
188     private boolean testBlock(StringWriter writer, SourcePositions sp, String text, CompilationUnitTree cut, BlockTree blockTree) {
189         boolean success = true;
190         for (StatementTree st : blockTree.getStatements()) {
191             if (isLegal(st)) {
192                 success &amp;= testStatement(writer, sp, text, cut, st);
193             }
194             if (st instanceof IfTree) {
195                 IfTree ifTree = (IfTree) st;
196                 success &amp;= testBranch(writer, sp, text, cut, ifTree.getThenStatement());
197                 success &amp;= testBranch(writer, sp, text, cut, ifTree.getElseStatement());
198             } else if (st instanceof WhileLoopTree) {
199                 WhileLoopTree whileLoopTree = (WhileLoopTree) st;
200                 success &amp;= testBranch(writer, sp, text, cut, whileLoopTree.getStatement());
201             } else if (st instanceof DoWhileLoopTree) {
202                 DoWhileLoopTree doWhileLoopTree = (DoWhileLoopTree) st;
203                 success &amp;= testBranch(writer, sp, text, cut, doWhileLoopTree.getStatement());
204             } else if (st instanceof ForLoopTree) {
205                 ForLoopTree forLoopTree = (ForLoopTree) st;
206                 success &amp;= testBranch(writer, sp, text, cut, forLoopTree.getStatement());
207             } else if (st instanceof LabeledStatementTree) {
208                 LabeledStatementTree labelTree = (LabeledStatementTree) st;
209                 success &amp;= testBranch(writer, sp, text, cut, labelTree.getStatement());
210             } else if (st instanceof SwitchTree) {
211                 SwitchTree switchTree = (SwitchTree) st;
212                 for (CaseTree caseTree : switchTree.getCases()) {
213                     for (StatementTree statementTree : caseTree.getStatements()) {
214                         success &amp;= testBranch(writer, sp, text, cut, statementTree);
215                     }
216                 }
217             }
218         }
219         return success;
220     }
221 
222     private boolean testStatement(StringWriter writer, SourcePositions sp, String text, CompilationUnitTree cut, Tree statement) {
223         if (statement == null) {
224             return true;
225         }
226         int start = (int) sp.getStartPosition(cut, statement);
227         int end = (int) sp.getEndPosition(cut, statement);
228         char ch = text.charAt(end - 1);
229         SourceCodeAnalysis.Completeness expected = COMPLETE;
230         LineMap lineMap = cut.getLineMap();
231         int row = (int) lineMap.getLineNumber(start);
232         int column = (int) lineMap.getColumnNumber(start);
233         switch (ch) {
234             case &#39;,&#39;:
235             case &#39;;&#39;:
236                 expected = (statement instanceof ExpressionStatementTree)
237                         ? COMPLETE
238                         : COMPLETE_WITH_SEMI;
239                 --end;
240                 break;
241             case &#39;}&#39;:
242                 break;
243             default:
244                 writer.write(String.format(&quot;Unexpected end: row %d, column %d: &#39;%c&#39; -- %s\n&quot;,
245                         row, column, ch, text.substring(start, end)));
246                 return true;
247         }
248         String unit = text.substring(start, end);
249         SourceCodeAnalysis.CompletionInfo ci = getAnalysis().analyzeCompletion(unit);
250         if (ci.completeness() != expected) {
251             if (expected == COMPLETE_WITH_SEMI &amp;&amp; (ci.completeness() == CONSIDERED_INCOMPLETE || ci.completeness() == EMPTY)) {
252                 writer.write(String.format(&quot;Empty statement: row %d, column %d: -- %s\n&quot;,
253                         start, end, unit));
254             } else {
255                 writer.write(String.format(&quot;Expected %s got %s: &#39;%s&#39;  row %d, column %d: -- %s\n&quot;,
256                         expected, ci.completeness(), unit, row, column, unit));
257                 return false;
258             }
259         }
260         return true;
261     }
262 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
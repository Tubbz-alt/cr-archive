<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/nashorn/script/trusted/JDK-8006529.js</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * JDK-8006529 : Methods should not always get callee parameter, and they
 26  * should not be too eager in creation of scopes.
 27  *
 28  * @test
 29  * @run
 30  */
 31 
 32 /*
 33  * This test script depends on nashorn Compiler internals. It uses reflection
 34  * to get access to private field and many public methods of Compiler and
 35  * FunctionNode classes. Note that this is trusted code and access to such
 36  * internal package classes and methods is okay. But, if you modify any
 37  * Compiler or FunctionNode class, you may have to revisit this script.
 38  * We cannot use direct Java class (via dynalink bean linker) to Compiler
 39  * and FunctionNode because of package-access check and so reflective calls.
 40  */
 41 var Reflector           = Java.type(&quot;jdk.nashorn.test.models.Reflector&quot;);
 42 var forName             = java.lang.Class[&quot;forName(String)&quot;];
 43 var Parser              = forName(&quot;jdk.nashorn.internal.parser.Parser&quot;).static
 44 var Compiler            = forName(&quot;jdk.nashorn.internal.codegen.Compiler&quot;).static
 45 var CompilationPhases   = forName(&quot;jdk.nashorn.internal.codegen.Compiler$CompilationPhases&quot;).static;
 46 var Context             = forName(&quot;jdk.nashorn.internal.runtime.Context&quot;).static
 47 var CodeInstaller       = forName(&quot;jdk.nashorn.internal.runtime.CodeInstaller&quot;).static
 48 var ScriptEnvironment   = forName(&quot;jdk.nashorn.internal.runtime.ScriptEnvironment&quot;).static
 49 var Source              = forName(&quot;jdk.nashorn.internal.runtime.Source&quot;).static
 50 var FunctionNode        = forName(&quot;jdk.nashorn.internal.ir.FunctionNode&quot;).static
 51 var Block               = forName(&quot;jdk.nashorn.internal.ir.Block&quot;).static
 52 var VarNode             = forName(&quot;jdk.nashorn.internal.ir.VarNode&quot;).static
 53 var ExpressionStatement = forName(&quot;jdk.nashorn.internal.ir.ExpressionStatement&quot;).static
 54 var UnaryNode           = forName(&quot;jdk.nashorn.internal.ir.UnaryNode&quot;).static
 55 var BinaryNode          = forName(&quot;jdk.nashorn.internal.ir.BinaryNode&quot;).static
 56 var ThrowErrorManager   = forName(&quot;jdk.nashorn.internal.runtime.Context$ThrowErrorManager&quot;).static
 57 var ErrorManager        = forName(&quot;jdk.nashorn.internal.runtime.ErrorManager&quot;).static
 58 var Debug               = forName(&quot;jdk.nashorn.internal.runtime.Debug&quot;).static
 59 var String              = forName(&quot;java.lang.String&quot;).static
 60 var boolean             = Java.type(&quot;boolean&quot;);
 61 
 62 var parseMethod = Parser.class.getMethod(&quot;parse&quot;);
 63 var compileMethod = Compiler.class.getMethod(&quot;compile&quot;, FunctionNode.class, CompilationPhases.class);
 64 var getBodyMethod = FunctionNode.class.getMethod(&quot;getBody&quot;);
 65 var getStatementsMethod = Block.class.getMethod(&quot;getStatements&quot;);
 66 var getInitMethod = VarNode.class.getMethod(&quot;getInit&quot;);
 67 var getExpressionMethod = ExpressionStatement.class.getMethod(&quot;getExpression&quot;)
 68 var rhsMethod = UnaryNode.class.getMethod(&quot;getExpression&quot;)
 69 var lhsMethod = BinaryNode.class.getMethod(&quot;lhs&quot;)
 70 var binaryRhsMethod = BinaryNode.class.getMethod(&quot;rhs&quot;)
 71 var debugIdMethod = Debug.class.getMethod(&quot;id&quot;, java.lang.Object.class)
 72 var compilePhases = Reflector.get(CompilationPhases.class.getField(&quot;COMPILE_UPTO_BYTECODE&quot;), null);
 73 
 74 function invoke(m, obj) {
 75     return Reflector.invoke(m, obj);
 76 }
 77 
 78 // These are method names of methods in FunctionNode class
 79 var allAssertionList = [&#39;isVarArg&#39;, &#39;needsParentScope&#39;, &#39;needsCallee&#39;, &#39;hasScopeBlock&#39;, &#39;usesSelfSymbol&#39;, &#39;isSplit&#39;, &#39;hasEval&#39;, &#39;allVarsInScope&#39;, &#39;isStrict&#39;]
 80 
 81 // corresponding Method objects of FunctionNode class
 82 var functionNodeMethods = {};
 83 // initialize FunctionNode methods
 84 (function() {
 85     for (var f in allAssertionList) {
 86         var method = allAssertionList[f];
 87         functionNodeMethods[method] = FunctionNode.class.getMethod(method);
 88     }
 89 })();
 90 
 91 // returns functionNode.getBody().getStatements().get(0)
 92 function getFirstFunction(functionNode) {
 93     var f = findFunction(invoke(getBodyMethod, functionNode))
 94     if (f == null) {
 95         throw new Error();
 96     }
 97     return f;
 98 }
 99 
100 function findFunction(node) {
101     if(node instanceof Block) {
102         var stmts = invoke(getStatementsMethod, node)
103         for(var i = 0; i &lt; stmts.size(); ++i) {
104             var retval = findFunction(stmts.get(i))
105             if(retval != null) {
106                 return retval;
107             }
108         }
109     } else if(node instanceof VarNode) {
110         return findFunction(invoke(getInitMethod, node))
111     } else if(node instanceof UnaryNode) {
112         return findFunction(invoke(rhsMethod, node))
113     } else if(node instanceof BinaryNode) {
114         return findFunction(invoke(lhsMethod, node)) || findFunction(invoke(binaryRhsMethod, node))
115     } else if(node instanceof ExpressionStatement) {
116         return findFunction(invoke(getExpressionMethod, node))
117     } else if(node instanceof FunctionNode) {
118         return node
119     }
120 }
121 
122 var getContextMethod = Context.class.getMethod(&quot;getContext&quot;)
123 var getEnvMethod = Context.class.getMethod(&quot;getEnv&quot;)
124 
125 var sourceForMethod = Source.class.getMethod(&quot;sourceFor&quot;, java.lang.String.class, java.lang.String.class)
126 var ParserConstructor = Parser.class.getConstructor(ScriptEnvironment.class, Source.class, ErrorManager.class)
127 var CompilerConstructor = Compiler.class.getMethod(&quot;forNoInstallerCompilation&quot;, Context.class, Source.class, boolean.class);
128 
129 // compile(script) -- compiles a script specified as a string with its
130 // source code, returns a jdk.nashorn.internal.ir.FunctionNode object
131 // representing it.
132 function compile(source, phases) {
133     var source = sourceForMethod.invoke(null, &quot;&lt;no name&gt;&quot;, source);
134 
135     var ctxt = getContextMethod.invoke(null);
136     var env = getEnvMethod.invoke(ctxt);
137 
138     var parser   = Reflector.newInstance(ParserConstructor, env, source, ThrowErrorManager.class.newInstance());
139     var func     = invoke(parseMethod, parser);
140 
141     var compiler = Reflector.invoke(CompilerConstructor, null, ctxt, source, false);
142 
143     return Reflector.invoke(compileMethod, compiler, func, phases);
144 };
145 
146 var allAssertions = (function() {
147     var allAssertions = {}
148     for(var assertion in allAssertionList) {
149         allAssertions[allAssertionList[assertion]] = true
150     }
151     return allAssertions;
152 })();
153 
154 
155 // test(f[, assertions...]) tests whether all the specified assertions on the
156 // passed function node are true.
157 function test(f) {
158     var assertions = {}
159     for(var i = 1; i &lt; arguments.length; ++i) {
160         var assertion = arguments[i]
161         if(!allAssertions[assertion]) {
162             throw &quot;Unknown assertion &quot; + assertion + &quot; for &quot; + f;
163         }
164         assertions[assertion] = true
165     }
166     for(var assertion in allAssertions) {
167         var expectedValue = !!assertions[assertion]
168         var actualValue = invoke(functionNodeMethods[assertion], f)
169         if(actualValue !== expectedValue) {
170             throw &quot;Expected &quot; + assertion + &quot; === &quot; + expectedValue + &quot;, got &quot; + actualValue + &quot; for &quot; + f + &quot;:&quot; 
171                 + invoke(debugIdMethod, null, f);
172         }
173     }
174 }
175 
176 // testFirstFn(script[, assertions...] tests whether all the specified
177 // assertions are true in the first function in the given script; &quot;script&quot;
178 // is a string with the source text of the script.
179 function testFirstFn(script) {
180     arguments[0] = getFirstFunction(compile(script, compilePhases));
181     test.apply(null, arguments);
182 }
183 
184 // ---------------------------------- ACTUAL TESTS START HERE --------------
185 
186 // The simplest possible functions have no attributes set
187 testFirstFn(&quot;function f() { }&quot;)
188 testFirstFn(&quot;function f(x) { x }&quot;)
189 
190 // A function referencing a global needs parent scope, and it needs callee
191 // (because parent scope is passed through callee)
192 testFirstFn(&quot;function f() { x }&quot;, &#39;needsCallee&#39;, &#39;needsParentScope&#39;)
193 
194 // A function referencing &quot;arguments&quot; will have to be vararg. It also needs
195 // the callee, as it needs to fill out &quot;arguments.callee&quot;.
196 testFirstFn(&quot;function f() { arguments }&quot;, &#39;needsCallee&#39;, &#39;isVarArg&#39;)
197 
198 // A function referencing &quot;arguments&quot; will have to be vararg. If it is
199 // strict, it will not have to have a callee, though.
200 testFirstFn(&quot;function f() {&#39;use strict&#39;; arguments }&quot;, &#39;isVarArg&#39;, &#39;isStrict&#39;)
201 
202 // A function defining &quot;arguments&quot; as a parameter will not be vararg.
203 testFirstFn(&quot;function f(arguments) { arguments }&quot;)
204 
205 // A function defining &quot;arguments&quot; as a nested function will not be vararg.
206 testFirstFn(&quot;function f() { function arguments() {}; arguments; }&quot;)
207 
208 // A function defining &quot;arguments&quot; as a local variable will be vararg.
209 testFirstFn(&quot;function f() { var arguments; arguments; }&quot;, &#39;isVarArg&#39;, &#39;needsCallee&#39;)
210 
211 // A self-referencing function defined as a statement doesn&#39;t need a self
212 // symbol, as it&#39;ll rather obtain itself from the parent scope.
213 testFirstFn(&quot;function f() { f() }&quot;, &#39;needsCallee&#39;, &#39;needsParentScope&#39;)
214 
215 // A self-referencing function defined as an expression needs a self symbol,
216 // as it can&#39;t obtain itself from the parent scope.
217 testFirstFn(&quot;(function f() { f() })&quot;, &#39;needsCallee&#39;, &#39;usesSelfSymbol&#39;)
218 
219 // A child function accessing parent&#39;s variable triggers the need for scope
220 // in parent
221 testFirstFn(&quot;(function f() { var x; function g() { x } })&quot;, &#39;hasScopeBlock&#39;)
222 
223 // A child function accessing parent&#39;s parameter triggers the need for scope
224 // in parent
225 testFirstFn(&quot;(function f(x) { function g() { x } })&quot;, &#39;hasScopeBlock&#39;)
226 
227 // A child function accessing a global variable triggers the need for parent
228 // scope in parent
229 testFirstFn(&quot;(function f() { function g() { x } })&quot;, &#39;needsParentScope&#39;, &#39;needsCallee&#39;)
230 
231 // A child function redefining a local variable from its parent should not
232 // affect the parent function in any way
233 testFirstFn(&quot;(function f() { var x; function g() { var x; x } })&quot;)
234 
235 // Using &quot;with&quot; on its own doesn&#39;t do much.
236 testFirstFn(&quot;(function f() { var o; with(o) {} })&quot;)
237 
238 // &quot;with&quot; referencing a local variable triggers scoping.
239 testFirstFn(&quot;(function f() { var x; var y; with(x) { y } })&quot;, &#39;hasScopeBlock&#39;)
240 
241 // &quot;with&quot; referencing a non-local variable triggers parent scope.
242 testFirstFn(&quot;(function f() { var x; with(x) { y } })&quot;, &#39;needsCallee&#39;, &#39;needsParentScope&#39;)
243 
244 // Nested function using &quot;with&quot; is pretty much the same as the parent
245 // function needing with.
246 testFirstFn(&quot;(function f() { function g() { var o; with(o) {} } })&quot;)
247 
248 // Nested function using &quot;with&quot; referencing a local variable.
249 testFirstFn(&quot;(function f() { var x; function g() { var o; with(o) { x } } })&quot;, &#39;hasScopeBlock&#39;)
250 
251 // Using &quot;eval&quot; triggers pretty much everything. The function even needs to be
252 // vararg, &#39;cause we don&#39;t know if eval will be using &quot;arguments&quot;.
253 testFirstFn(&quot;(function f() { eval() })&quot;, &#39;usesSelfSymbol&#39;, &#39;needsParentScope&#39;, &#39;needsCallee&#39;, &#39;hasScopeBlock&#39;, &#39;hasEval&#39;, &#39;isVarArg&#39;, &#39;allVarsInScope&#39;)
254 
255 // Nested function using &quot;eval&quot; is almost the same as parent function using
256 // eval, but at least the parent doesn&#39;t have to be vararg.
257 testFirstFn(&quot;(function f() { function g() { eval() } })&quot;, &#39;usesSelfSymbol&#39;, &#39;needsParentScope&#39;, &#39;needsCallee&#39;, &#39;hasScopeBlock&#39;, &#39;allVarsInScope&#39;)
258 
259 // Function with 125 named parameters is ordinary
260 testFirstFn(&quot;function f(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30, p31, p32, p33, p34, p35, p36, p37, p38, p39, p40, p41, p42, p43, p44, p45, p46, p47, p48, p49, p50, p51, p52, p53, p54, p55, p56, p57, p58, p59, p60, p61, p62, p63, p64, p65, p66, p67, p68, p69, p70, p71, p72, p73, p74, p75, p76, p77, p78, p79, p80, p81, p82, p83, p84, p85, p86, p87, p88, p89, p90, p91, p92, p93, p94, p95, p96, p97, p98, p99, p100, p101, p102, p103, p104, p105, p106, p107, p108, p109, p110, p111, p112, p113, p114, p115, p116, p117, p118, p119, p120, p121, p122, p123, p124, p125) { p125 = p124 }&quot;)
261 
262 // Function with 126 named parameters is variable arguments
263 // NOTE: hasScopeBlock should be optimized away. Implementation of JDK-8038942 should take care of it.
264 testFirstFn(&quot;function f(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30, p31, p32, p33, p34, p35, p36, p37, p38, p39, p40, p41, p42, p43, p44, p45, p46, p47, p48, p49, p50, p51, p52, p53, p54, p55, p56, p57, p58, p59, p60, p61, p62, p63, p64, p65, p66, p67, p68, p69, p70, p71, p72, p73, p74, p75, p76, p77, p78, p79, p80, p81, p82, p83, p84, p85, p86, p87, p88, p89, p90, p91, p92, p93, p94, p95, p96, p97, p98, p99, p100, p101, p102, p103, p104, p105, p106, p107, p108, p109, p110, p111, p112, p113, p114, p115, p116, p117, p118, p119, p120, p121, p122, p123, p124, p125, p126) { p125 = p126 }&quot;, &#39;isVarArg&#39;, &#39;hasScopeBlock&#39;)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/nashorn/script/basic/JDK-8035712.js</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * JDK-8035712: Restore some of the RuntimeCallSite specializations
 26  *
 27  * @test
 28  * @run
 29  */
 30 
 31 if ((typeof Assert) == &quot;undefined&quot;) {
 32     Assert = { 
 33         assertTrue: function(x) { if(!x) { throw &quot;expected true&quot; } },
 34         assertFalse: function(x) { if(x) { throw &quot;expected false&quot; } },
 35     };
 36 }
 37 
 38 function nop() {}
 39 
 40 function EQ(x, y) {
 41     // Exercise normal evaluation
 42     Assert.assertTrue (x == y);
 43     Assert.assertTrue (y == x);
 44     Assert.assertFalse(x != y);
 45     Assert.assertFalse(y != x);
 46     // Exercise the branch optimizer
 47     if (x == y) { nop(); } else { Assert.fail(); }
 48     if (y == x) { nop(); } else { Assert.fail(); }
 49     if (x != y) { Assert.fail(); } else { nop(); }
 50     if (y != x) { Assert.fail(); } else { nop(); }
 51 }
 52 
 53 function NE(x, y) {
 54     // Exercise normal evaluation
 55     Assert.assertTrue (x != y);
 56     Assert.assertTrue (y != x);
 57     Assert.assertFalse(x == y);
 58     Assert.assertFalse(y == x);
 59     // Exercise the branch optimizer
 60     if (x != y) { nop(); } else { Assert.fail(); }
 61     if (y != x) { nop(); } else { Assert.fail(); }
 62     if (x == y) { Assert.fail(); } else { nop(); }
 63     if (y == x) { Assert.fail(); } else { nop(); }
 64 }
 65 
 66 function STRICT_EQ(x, y) {
 67     // Exercise normal evaluation
 68     Assert.assertTrue (x === y);
 69     Assert.assertTrue (y === x);
 70     Assert.assertFalse(x !== y);
 71     Assert.assertFalse(y !== x);
 72     // Exercise the branch optimizer
 73     if (x === y) { nop(); } else { Assert.fail(); }
 74     if (y === x) { nop(); } else { Assert.fail(); }
 75     if (x !== y) { Assert.fail(); } else { nop(); }
 76     if (y !== x) { Assert.fail(); } else { nop(); }
 77 }
 78 
 79 function STRICT_NE(x, y) {
 80     // Exercise normal evaluation
 81     Assert.assertTrue (x !== y);
 82     Assert.assertTrue (y !== x);
 83     Assert.assertFalse(x === y);
 84     Assert.assertFalse(y === x);
 85     // Exercise the branch optimizer
 86     if (x !== y) { nop(); } else { Assert.fail(); }
 87     if (y !== x) { nop(); } else { Assert.fail(); }
 88     if (x === y) { Assert.fail(); } else { nop(); }
 89     if (y === x) { Assert.fail(); } else { nop(); }
 90 }
 91 
 92 function cmpToAnyNumber(cmp, value) {
 93     cmp(1, value);
 94     cmp(4294967296, value);
 95     cmp(1.2, value);
 96     cmp(Infinity, value);
 97     cmp(-Infinity, value);
 98     cmp(1/Infinity, value);
 99     cmp(0, value);
100     cmp(-0, value);
101     cmp(true, value);
102     cmp(false, value);
103 }
104 
105 function notEqualToAnyNumber(value) {
106     cmpToAnyNumber(NE, value);
107     cmpToAnyNumber(STRICT_NE, value);
108 }
109 
110 notEqualToAnyNumber(null);
111 notEqualToAnyNumber(void 0);
112 notEqualToAnyNumber(&quot;abc&quot;);
113 notEqualToAnyNumber({});
114 notEqualToAnyNumber([&quot;xyz&quot;]);
115 
116 function objectWithPrimitiveFunctionNotEqualToAnyNumber(fnName) {
117     var obj = {
118         count: 0
119     };
120     obj[fnName] = function() { this.count++; return &quot;foo&quot;; };
121     notEqualToAnyNumber(obj);
122     // Every NE will invoke it 8 times; cmpToAnyNumber has 10 comparisons
123     // STRICT_NE doesn&#39;t invoke toString.
124     Assert.assertTrue(80 === obj.count);
125 }
126 objectWithPrimitiveFunctionNotEqualToAnyNumber(&quot;valueOf&quot;);
127 objectWithPrimitiveFunctionNotEqualToAnyNumber(&quot;toString&quot;);
128 
129 function objectEqualButNotStrictlyEqual(val, obj) {
130     EQ(val, obj);
131     STRICT_NE(val, obj);
132 }
133 
134 function numberEqualButNotStrictlyEqualToObject(num, obj) {
135     objectEqualButNotStrictlyEqual(num, obj);
136     objectEqualButNotStrictlyEqual(num, [obj]);
137     objectEqualButNotStrictlyEqual(num, [[obj]]);
138 }
139 
140 function numberEqualButNotStrictlyEqualToZeroObjects(num) {
141     numberEqualButNotStrictlyEqualToObject(num, [0]);
142     numberEqualButNotStrictlyEqualToObject(num, &quot;&quot;);
143     numberEqualButNotStrictlyEqualToObject(num, []);
144     numberEqualButNotStrictlyEqualToObject(num, &quot;0&quot;);
145 }
146 
147 numberEqualButNotStrictlyEqualToZeroObjects(0);
148 numberEqualButNotStrictlyEqualToZeroObjects(1/Infinity);
149 numberEqualButNotStrictlyEqualToZeroObjects(false);
150 
151 function numberEqualButNotStrictlyEqualToObjectEquivalent(num) {
152     var str = String(num);
153     objectEqualButNotStrictlyEqual(num, str);
154     objectEqualButNotStrictlyEqual(num, { valueOf:  function() { return str }});
155     objectEqualButNotStrictlyEqual(num, { toString: function() { return str }});
156     objectEqualButNotStrictlyEqual(num, { valueOf:  function() { return num }});
157     objectEqualButNotStrictlyEqual(num, { toString: function() { return num }});
158 }
159 
160 numberEqualButNotStrictlyEqualToObjectEquivalent(1);
161 numberEqualButNotStrictlyEqualToObjectEquivalent(4294967296);
162 numberEqualButNotStrictlyEqualToObjectEquivalent(1.2);
163 numberEqualButNotStrictlyEqualToObjectEquivalent(Infinity);
164 numberEqualButNotStrictlyEqualToObjectEquivalent(-Infinity);
165 numberEqualButNotStrictlyEqualToObjectEquivalent(1/Infinity);
166 numberEqualButNotStrictlyEqualToObjectEquivalent(0);
167 numberEqualButNotStrictlyEqualToObjectEquivalent(-0);
168 
169 STRICT_EQ(1, new java.lang.Integer(1));
170 STRICT_EQ(1, new java.lang.Double(1));
171 STRICT_EQ(1.2, new java.lang.Double(1.2));
172 
173 function LE(x, y) {
174     // Exercise normal evaluation
175     Assert.assertTrue(x &lt;= y);
176     Assert.assertTrue(y &gt;= x);
177     Assert.assertFalse(x &gt; y);
178     Assert.assertFalse(x &lt; y);
179     // Exercise the branch optimizer
180     if (x &lt;= y) { nop(); } else { Assert.fail(); }
181     if (y &gt;= x) { nop(); } else { Assert.fail(); }
182     if (x &gt; y) { Assert.fail(); } else { nop(); }
183     if (y &lt; x) { Assert.fail(); } else { nop(); }
184 }
185 
186 function mutuallyLessThanOrEqual(x, y) {
187     LE(x, y);
188     LE(y, x);
189 }
190 
191 mutuallyLessThanOrEqual(0, null);
192 mutuallyLessThanOrEqual(false, null);
193 mutuallyLessThanOrEqual(1/Infinity, null);
194 
195 function mutuallyLessThanEqualToObjectWithValue(num, val) {
196     mutuallyLessThanOrEqual(num, { valueOf: function() { return val } });
197     mutuallyLessThanOrEqual(num, { toString: function() { return val } });
198 }
199 
200 mutuallyLessThanEqualToObjectWithValue(false, 0);
201 mutuallyLessThanEqualToObjectWithValue(false, &quot;&quot;);
202 
203 mutuallyLessThanEqualToObjectWithValue(true, 1);
204 mutuallyLessThanEqualToObjectWithValue(true, &quot;1&quot;);
205 
206 function lessThanEqualToObjectEquivalent(num) {
207     var str = String(num);
208     mutuallyLessThanOrEqual(num, str);
209     mutuallyLessThanEqualToObjectWithValue(num, num);
210     mutuallyLessThanEqualToObjectWithValue(num, str);
211 }
212 
213 lessThanEqualToObjectEquivalent(1);
214 lessThanEqualToObjectEquivalent(4294967296);
215 lessThanEqualToObjectEquivalent(1.2);
216 lessThanEqualToObjectEquivalent(Infinity);
217 lessThanEqualToObjectEquivalent(-Infinity);
218 lessThanEqualToObjectEquivalent(1/Infinity);
219 lessThanEqualToObjectEquivalent(0);
220 lessThanEqualToObjectEquivalent(-0);
221 
222 function INCOMPARABLE(x, y) {
223     // Exercise normal evaluation
224     Assert.assertFalse(x &lt; y);
225     Assert.assertFalse(x &gt; y);
226     Assert.assertFalse(x &lt;= y);
227     Assert.assertFalse(x &gt;= y);
228     Assert.assertFalse(y &lt; x);
229     Assert.assertFalse(y &gt; x);
230     Assert.assertFalse(y &lt;= x);
231     Assert.assertFalse(y &gt;= x);
232     // Exercise the branch optimizer
233     if (x &lt; y) { Assert.fail(); } else { nop(); }
234     if (x &gt; y) { Assert.fail(); } else { nop(); }
235     if (x &lt;= y) { Assert.fail(); } else { nop(); }
236     if (x &gt;= y) { Assert.fail(); } else { nop(); }
237     if (y &lt; x) { Assert.fail(); } else { nop(); }
238     if (y &gt; x) { Assert.fail(); } else { nop(); }
239     if (y &lt;= x) { Assert.fail(); } else { nop(); }
240     if (y &gt;= x) { Assert.fail(); } else { nop(); }
241 }
242 
243 function isIncomparable(value) {
244     cmpToAnyNumber(INCOMPARABLE, value);
245 }
246 
247 isIncomparable(void 0);
248 isIncomparable({ valueOf: function() { return NaN }});
249 isIncomparable({ toString: function() { return NaN }});
250 
251 // Force ScriptRuntime.LT(Object, Object) etc. comparisons
252 function cmpObj(fn, x, y) {
253     fn({valueOf: function() { return x }}, {valueOf: function() { return y }});
254 }
255 
256 function LT(x, y) {
257     Assert.assertTrue(x &lt; y);
258     Assert.assertTrue(y &gt; x);
259     Assert.assertFalse(x &gt;= y);
260     Assert.assertFalse(y &lt;= x);
261 }
262 
263 cmpObj(LT, 1, 2);
264 cmpObj(LT, 1, &quot;2&quot;);
265 cmpObj(LT, &quot;1&quot;, 2);
266 cmpObj(LT, &quot;a&quot;, &quot;b&quot;);
267 cmpObj(LT, -Infinity, 0);
268 cmpObj(LT, 0, Infinity);
269 cmpObj(LT, -Infinity, Infinity);
270 cmpObj(INCOMPARABLE, 1, NaN);
271 cmpObj(INCOMPARABLE, NaN, NaN);
272 cmpObj(INCOMPARABLE, &quot;boo&quot;, NaN);
273 cmpObj(INCOMPARABLE, 1, &quot;boo&quot;); // boo number value will be NaN
274 
275 // Test that a comparison call site can deoptimize from (int, int) to (object, object)
276 (function(){
277     var x = [1,  2,  &quot;a&quot;];
278     var y = [2, &quot;3&quot;, &quot;b&quot;];
279     for(var i = 0; i &lt; 3; ++i) {
280         Assert.assertTrue(x[i] &lt; y[i]);
281     }
282 })();
    </pre>
  </body>
</html>
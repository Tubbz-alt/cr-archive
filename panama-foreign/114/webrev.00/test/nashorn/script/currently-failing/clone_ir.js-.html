<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/nashorn/script/currently-failing/clone_ir.js</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * clone_ir : Check that functionNode.clone copies all nodes and that they
 26  * are not the same references
 27  *
 28  * @test
 29  * @run
 30  */
 31 
 32 var js1 = &quot;var tuple = { func : function f(x) { if (x) { print(&#39;true&#39;); { print(&#39;block_under-true&#39;); } } else { print(&#39;false&#39;); } } }&quot;;
 33 
 34 var Parser            = Java.type(&quot;jdk.nashorn.internal.parser.Parser&quot;);
 35 var ASTWriter         = Java.type(&quot;jdk.nashorn.internal.ir.debug.ASTWriter&quot;);
 36 var Context           = Java.type(&quot;jdk.nashorn.internal.runtime.Context&quot;);
 37 var ScriptEnvironment = Java.type(&quot;jdk.nashorn.internal.runtime.ScriptEnvironment&quot;);
 38 var Source            = Java.type(&quot;jdk.nashorn.internal.runtime.Source&quot;);
 39 var FunctionNode      = Java.type(&quot;jdk.nashorn.internal.ir.FunctionNode&quot;);
 40 var ThrowErrorManager = Java.type(&quot;jdk.nashorn.internal.runtime.Context$ThrowErrorManager&quot;);
 41 var System            = Java.type(&quot;java.lang.System&quot;);
 42 
 43 var toArrayMethod = ASTWriter.class.getMethod(&quot;toArray&quot;);
 44 var parseMethod  = Parser.class.getMethod(&quot;parse&quot;);
 45 
 46 function toString(obj) {
 47     var output = &quot;{ &quot;;
 48     for (property in obj) {
 49     output += property + &#39;: &#39; + obj[property]+&#39;; &#39;;
 50     }
 51     return output + &#39;}&#39;
 52 }
 53 
 54 function flatten(func) {
 55     var writer   = new ASTWriter(func);
 56     var funcList = toArrayMethod.invoke(writer);
 57 
 58     var res = [];
 59     for each (x in funcList) {
 60         res.push({ name: x.getClass().getName(), id: System.identityHashCode(x) });
 61     }
 62     return res;
 63 }
 64 
 65 function check(contents) {
 66     return check_src(new Source(&quot;&lt;no name&gt;&quot;, contents));
 67 }
 68 
 69 function check_src(src) {
 70     var parser  = new Parser(Context.getContext().getEnv(), src, new ThrowErrorManager());
 71 
 72     var func = parseMethod.invoke(parser);
 73     print(func);
 74     var func2 = func.clone();
 75 
 76     var f1 = flatten(func);
 77     var f2 = flatten(func2);
 78 
 79     print(f1.map(toString));
 80     print(f2.map(toString));
 81 
 82     if (f1.length != f2.length) {
 83     print(&quot;length difference between original and clone &quot; + f1.length + &quot; != &quot; + f2.length);
 84     return false;
 85     }
 86 
 87     for (var i = 0; i &lt; f1.length; i++) {
 88     if (f1[i].name !== f2[i].name) {
 89         print(&quot;name conflict at &quot; + i + &quot; &quot; + f1[i].name + &quot; != &quot; + f2[i].name);
 90         return false;
 91     } else if (f1[i].id === f2[i].id) {
 92         print(&quot;id problem at &quot; + i + &quot; &quot; + toString(f1[i]) + &quot; was not deep copied to &quot; + toString(f2[i]) + &quot; became &quot; + f1[i].id + &quot; != &quot; + f2[i].id);
 93         return false;
 94     }
 95     }
 96 
 97     return true;
 98 }
 99 
100 print(check(js1));
    </pre>
  </body>
</html>
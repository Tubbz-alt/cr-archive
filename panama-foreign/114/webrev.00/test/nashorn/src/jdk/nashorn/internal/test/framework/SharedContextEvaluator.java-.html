<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/nashorn/src/jdk/nashorn/internal/test/framework/SharedContextEvaluator.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.test.framework;
 27 
 28 import static jdk.nashorn.internal.runtime.Source.sourceFor;
 29 import static jdk.nashorn.tools.Shell.COMPILATION_ERROR;
 30 import static jdk.nashorn.tools.Shell.RUNTIME_ERROR;
 31 import static jdk.nashorn.tools.Shell.SUCCESS;
 32 
 33 import java.io.File;
 34 import java.io.IOException;
 35 import java.io.OutputStream;
 36 import java.io.PrintWriter;
 37 import jdk.nashorn.api.scripting.NashornException;
 38 import jdk.nashorn.internal.objects.Global;
 39 import jdk.nashorn.internal.runtime.Context;
 40 import jdk.nashorn.internal.runtime.ErrorManager;
 41 import jdk.nashorn.internal.runtime.ScriptFunction;
 42 import jdk.nashorn.internal.runtime.ScriptRuntime;
 43 import jdk.nashorn.internal.runtime.options.Options;
 44 
 45 /**
 46  * A script evaluator that shares a single Nashorn Context instance to run
 47  * scripts many times on it.
 48  */
 49 public final class SharedContextEvaluator implements ScriptEvaluator {
 50     // The shared Nashorn Context
 51     private final Context context;
 52 
 53     // We can&#39;t replace output and error streams after Context is created
 54     // So, we create these delegating streams - so that we can replace underlying
 55     // delegate streams for each script run call
 56     private final DelegatingOutputStream ctxOut;
 57     private final DelegatingOutputStream ctxErr;
 58 
 59     private static class DelegatingOutputStream extends OutputStream {
 60         private OutputStream underlying;
 61 
 62         public DelegatingOutputStream(final OutputStream out) {
 63             this.underlying = out;
 64         }
 65 
 66         @Override
 67         public void close() throws IOException {
 68             underlying.close();
 69         }
 70 
 71         @Override
 72         public void flush() throws IOException {
 73             underlying.flush();
 74         }
 75 
 76         @Override
 77         public void write(final byte[] b) throws IOException {
 78             underlying.write(b);
 79         }
 80 
 81         @Override
 82         public void write(final byte[] b, final int off, final int len) throws IOException {
 83             underlying.write(b, off, len);
 84         }
 85 
 86         @Override
 87         public void write(final int b) throws IOException {
 88             underlying.write(b);
 89         }
 90 
 91         void setDelegatee(final OutputStream stream) {
 92             this.underlying = stream;
 93         }
 94     }
 95 
 96     /**
 97      * SharedContextEvaluator constructor
 98      * @param args initial script arguments to create shared context
 99      */
100     public SharedContextEvaluator(final String[] args) {
101         this.ctxOut = new DelegatingOutputStream(System.out);
102         this.ctxErr = new DelegatingOutputStream(System.err);
103         final PrintWriter wout = new PrintWriter(ctxOut, true);
104         final PrintWriter werr = new PrintWriter(ctxErr, true);
105         final Options options = new Options(&quot;nashorn&quot;, werr);
106         options.process(args);
107         final ErrorManager errors = new ErrorManager(werr);
108         this.context = new Context(options, errors, wout, werr, Thread.currentThread().getContextClassLoader());
109     }
110 
111     @Override
112     public int run(final OutputStream out, final OutputStream err, final String[] args) throws IOException {
113         final Global oldGlobal = Context.getGlobal();
114         try {
115             ctxOut.setDelegatee(out);
116             ctxErr.setDelegatee(err);
117             final ErrorManager errors = context.getErrorManager();
118             final Global global = context.createGlobal();
119             Context.setGlobal(global);
120 
121             // For each file on the command line.
122             for (final String fileName : args) {
123                 if (fileName.startsWith(&quot;-&quot;)) {
124                     // ignore options in shared context mode (which was initialized upfront!)
125                     continue;
126                 }
127                 final File file = new File(fileName);
128                 final ScriptFunction script = context.compileScript(sourceFor(fileName, file.toURI().toURL()), global);
129 
130                 if (script == null || errors.getNumberOfErrors() != 0) {
131                     return COMPILATION_ERROR;
132                 }
133 
134                 try {
135                     ScriptRuntime.apply(script, global);
136                 } catch (final NashornException e) {
137                     errors.error(e.toString());
138                     if (context.getEnv()._dump_on_error) {
139                         e.printStackTrace(context.getErr());
140                     }
141 
142                     return RUNTIME_ERROR;
143                 }
144             }
145         } finally {
146             context.getOut().flush();
147             context.getErr().flush();
148             Context.setGlobal(oldGlobal);
149         }
150 
151         return SUCCESS;
152     }
153 }
    </pre>
  </body>
</html>
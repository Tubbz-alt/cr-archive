<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/windows/native/libjli/java_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;windows.h&gt;
  27 #include &lt;io.h&gt;
  28 #include &lt;process.h&gt;
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;stdio.h&gt;
  31 #include &lt;stdarg.h&gt;
  32 #include &lt;string.h&gt;
  33 #include &lt;sys/types.h&gt;
  34 #include &lt;sys/stat.h&gt;
  35 #include &lt;wtypes.h&gt;
  36 #include &lt;commctrl.h&gt;
  37 #include &lt;assert.h&gt;
  38 
  39 #include &lt;jni.h&gt;
  40 #include &quot;java.h&quot;
  41 
  42 #define JVM_DLL &quot;jvm.dll&quot;
  43 #define JAVA_DLL &quot;java.dll&quot;
  44 
  45 /*
  46  * Prototypes.
  47  */
  48 static jboolean GetJVMPath(const char *jrepath, const char *jvmtype,
  49                            char *jvmpath, jint jvmpathsize);
  50 static jboolean GetJREPath(char *path, jint pathsize);
  51 
  52 #ifdef USE_REGISTRY_LOOKUP
  53 jboolean GetPublicJREHome(char *buf, jint bufsize);
  54 #endif
  55 
  56 /* We supports warmup for UI stack that is performed in parallel
  57  * to VM initialization.
  58  * This helps to improve startup of UI application as warmup phase
  59  * might be long due to initialization of OS or hardware resources.
  60  * It is not CPU bound and therefore it does not interfere with VM init.
  61  * Obviously such warmup only has sense for UI apps and therefore it needs
  62  * to be explicitly requested by passing -Dsun.awt.warmup=true property
  63  * (this is always the case for plugin/javaws).
  64  *
  65  * Implementation launches new thread after VM starts and use it to perform
  66  * warmup code (platform dependent).
  67  * This thread is later reused as AWT toolkit thread as graphics toolkit
  68  * often assume that they are used from the same thread they were launched on.
  69  *
  70  * At the moment we only support warmup for D3D. It only possible on windows
  71  * and only if other flags do not prohibit this (e.g. OpenGL support requested).
  72  */
  73 #undef ENABLE_AWT_PRELOAD
  74 #ifndef JAVA_ARGS /* turn off AWT preloading for javac, jar, etc */
  75     /* CR6999872: fastdebug crashes if awt library is loaded before JVM is
  76      * initialized*/
  77     #if !defined(DEBUG)
  78         #define ENABLE_AWT_PRELOAD
  79     #endif
  80 #endif
  81 
  82 #ifdef ENABLE_AWT_PRELOAD
  83 /* &quot;AWT was preloaded&quot; flag;
  84  * turned on by AWTPreload().
  85  */
  86 int awtPreloaded = 0;
  87 
  88 /* Calls a function with the name specified
  89  * the function must be int(*fn)(void).
  90  */
  91 int AWTPreload(const char *funcName);
  92 /* stops AWT preloading */
  93 void AWTPreloadStop();
  94 
  95 /* D3D preloading */
  96 /* -1: not initialized; 0: OFF, 1: ON */
  97 int awtPreloadD3D = -1;
  98 /* command line parameter to swith D3D preloading on */
  99 #define PARAM_PRELOAD_D3D &quot;-Dsun.awt.warmup&quot;
 100 /* D3D/OpenGL management parameters */
 101 #define PARAM_NODDRAW &quot;-Dsun.java2d.noddraw&quot;
 102 #define PARAM_D3D &quot;-Dsun.java2d.d3d&quot;
 103 #define PARAM_OPENGL &quot;-Dsun.java2d.opengl&quot;
 104 /* funtion in awt.dll (src/windows/native/sun/java2d/d3d/D3DPipelineManager.cpp) */
 105 #define D3D_PRELOAD_FUNC &quot;preloadD3D&quot;
 106 
 107 /* Extracts value of a parameter with the specified name
 108  * from command line argument (returns pointer in the argument).
 109  * Returns NULL if the argument does not contains the parameter.
 110  * e.g.:
 111  * GetParamValue(&quot;theParam&quot;, &quot;theParam=value&quot;) returns pointer to &quot;value&quot;.
 112  */
 113 const char * GetParamValue(const char *paramName, const char *arg) {
 114     size_t nameLen = JLI_StrLen(paramName);
 115     if (JLI_StrNCmp(paramName, arg, nameLen) == 0) {
 116         /* arg[nameLen] is valid (may contain final NULL) */
 117         if (arg[nameLen] == &#39;=&#39;) {
 118             return arg + nameLen + 1;
 119         }
 120     }
 121     return NULL;
 122 }
 123 
 124 /* Checks if commandline argument contains property specified
 125  * and analyze it as boolean property (true/false).
 126  * Returns -1 if the argument does not contain the parameter;
 127  * Returns 1 if the argument contains the parameter and its value is &quot;true&quot;;
 128  * Returns 0 if the argument contains the parameter and its value is &quot;false&quot;.
 129  */
 130 int GetBoolParamValue(const char *paramName, const char *arg) {
 131     const char * paramValue = GetParamValue(paramName, arg);
 132     if (paramValue != NULL) {
 133         if (JLI_StrCaseCmp(paramValue, &quot;true&quot;) == 0) {
 134             return 1;
 135         }
 136         if (JLI_StrCaseCmp(paramValue, &quot;false&quot;) == 0) {
 137             return 0;
 138         }
 139     }
 140     return -1;
 141 }
 142 #endif /* ENABLE_AWT_PRELOAD */
 143 
 144 
 145 static jboolean _isjavaw = JNI_FALSE;
 146 
 147 
 148 jboolean
 149 IsJavaw()
 150 {
 151     return _isjavaw;
 152 }
 153 
 154 /*
 155  *
 156  */
 157 void
 158 CreateExecutionEnvironment(int *pargc, char ***pargv,
 159                            char *jrepath, jint so_jrepath,
 160                            char *jvmpath, jint so_jvmpath,
 161                            char *jvmcfg,  jint so_jvmcfg) {
 162 
 163     char *jvmtype;
 164     int i = 0;
 165     char** argv = *pargv;
 166 
 167     /* Find out where the JRE is that we will be using. */
 168     if (!GetJREPath(jrepath, so_jrepath)) {
 169         JLI_ReportErrorMessage(JRE_ERROR1);
 170         exit(2);
 171     }
 172 
 173     JLI_Snprintf(jvmcfg, so_jvmcfg, &quot;%s%slib%sjvm.cfg&quot;,
 174         jrepath, FILESEP, FILESEP);
 175 
 176     /* Find the specified JVM type */
 177     if (ReadKnownVMs(jvmcfg, JNI_FALSE) &lt; 1) {
 178         JLI_ReportErrorMessage(CFG_ERROR7);
 179         exit(1);
 180     }
 181 
 182     jvmtype = CheckJvmType(pargc, pargv, JNI_FALSE);
 183     if (JLI_StrCmp(jvmtype, &quot;ERROR&quot;) == 0) {
 184         JLI_ReportErrorMessage(CFG_ERROR9);
 185         exit(4);
 186     }
 187 
 188     jvmpath[0] = &#39;\0&#39;;
 189     if (!GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath)) {
 190         JLI_ReportErrorMessage(CFG_ERROR8, jvmtype, jvmpath);
 191         exit(4);
 192     }
 193     /* If we got here, jvmpath has been correctly initialized. */
 194 
 195     /* Check if we need preload AWT */
 196 #ifdef ENABLE_AWT_PRELOAD
 197     argv = *pargv;
 198     for (i = 0; i &lt; *pargc ; i++) {
 199         /* Tests the &quot;turn on&quot; parameter only if not set yet. */
 200         if (awtPreloadD3D &lt; 0) {
 201             if (GetBoolParamValue(PARAM_PRELOAD_D3D, argv[i]) == 1) {
 202                 awtPreloadD3D = 1;
 203             }
 204         }
 205         /* Test parameters which can disable preloading if not already disabled. */
 206         if (awtPreloadD3D != 0) {
 207             if (GetBoolParamValue(PARAM_NODDRAW, argv[i]) == 1
 208                 || GetBoolParamValue(PARAM_D3D, argv[i]) == 0
 209                 || GetBoolParamValue(PARAM_OPENGL, argv[i]) == 1)
 210             {
 211                 awtPreloadD3D = 0;
 212                 /* no need to test the rest of the parameters */
 213                 break;
 214             }
 215         }
 216     }
 217 #endif /* ENABLE_AWT_PRELOAD */
 218 }
 219 
 220 
 221 static jboolean
 222 LoadMSVCRT()
 223 {
 224     // Only do this once
 225     static int loaded = 0;
 226     char crtpath[MAXPATHLEN];
 227 
 228     if (!loaded) {
 229         /*
 230          * The Microsoft C Runtime Library needs to be loaded first.  A copy is
 231          * assumed to be present in the &quot;JRE path&quot; directory.  If it is not found
 232          * there (or &quot;JRE path&quot; fails to resolve), skip the explicit load and let
 233          * nature take its course, which is likely to be a failure to execute.
 234          * The makefiles will provide the correct lib contained in quotes in the
 235          * macro MSVCR_DLL_NAME.
 236          */
 237 #ifdef MSVCR_DLL_NAME
 238         if (GetJREPath(crtpath, MAXPATHLEN)) {
 239             if (JLI_StrLen(crtpath) + JLI_StrLen(&quot;\\bin\\&quot;) +
 240                     JLI_StrLen(MSVCR_DLL_NAME) &gt;= MAXPATHLEN) {
 241                 JLI_ReportErrorMessage(JRE_ERROR11);
 242                 return JNI_FALSE;
 243             }
 244             (void)JLI_StrCat(crtpath, &quot;\\bin\\&quot; MSVCR_DLL_NAME);   /* Add crt dll */
 245             JLI_TraceLauncher(&quot;CRT path is %s\n&quot;, crtpath);
 246             if (_access(crtpath, 0) == 0) {
 247                 if (LoadLibrary(crtpath) == 0) {
 248                     JLI_ReportErrorMessage(DLL_ERROR4, crtpath);
 249                     return JNI_FALSE;
 250                 }
 251             }
 252         }
 253 #endif /* MSVCR_DLL_NAME */
<a name="1" id="anc1"></a><span class="line-added"> 254 #ifdef VCRUNTIME_1_DLL_NAME</span>
<span class="line-added"> 255         if (GetJREPath(crtpath, MAXPATHLEN)) {</span>
<span class="line-added"> 256             if (JLI_StrLen(crtpath) + JLI_StrLen(&quot;\\bin\\&quot;) +</span>
<span class="line-added"> 257                     JLI_StrLen(VCRUNTIME_1_DLL_NAME) &gt;= MAXPATHLEN) {</span>
<span class="line-added"> 258                 JLI_ReportErrorMessage(JRE_ERROR11);</span>
<span class="line-added"> 259                 return JNI_FALSE;</span>
<span class="line-added"> 260             }</span>
<span class="line-added"> 261             (void)JLI_StrCat(crtpath, &quot;\\bin\\&quot; VCRUNTIME_1_DLL_NAME);   /* Add crt dll */</span>
<span class="line-added"> 262             JLI_TraceLauncher(&quot;CRT path is %s\n&quot;, crtpath);</span>
<span class="line-added"> 263             if (_access(crtpath, 0) == 0) {</span>
<span class="line-added"> 264                 if (LoadLibrary(crtpath) == 0) {</span>
<span class="line-added"> 265                     JLI_ReportErrorMessage(DLL_ERROR4, crtpath);</span>
<span class="line-added"> 266                     return JNI_FALSE;</span>
<span class="line-added"> 267                 }</span>
<span class="line-added"> 268             }</span>
<span class="line-added"> 269         }</span>
<span class="line-added"> 270 #endif /* VCRUNTIME_1_DLL_NAME */</span>
 271 #ifdef MSVCP_DLL_NAME
 272         if (GetJREPath(crtpath, MAXPATHLEN)) {
 273             if (JLI_StrLen(crtpath) + JLI_StrLen(&quot;\\bin\\&quot;) +
 274                     JLI_StrLen(MSVCP_DLL_NAME) &gt;= MAXPATHLEN) {
 275                 JLI_ReportErrorMessage(JRE_ERROR11);
 276                 return JNI_FALSE;
 277             }
 278             (void)JLI_StrCat(crtpath, &quot;\\bin\\&quot; MSVCP_DLL_NAME);   /* Add prt dll */
 279             JLI_TraceLauncher(&quot;PRT path is %s\n&quot;, crtpath);
 280             if (_access(crtpath, 0) == 0) {
 281                 if (LoadLibrary(crtpath) == 0) {
 282                     JLI_ReportErrorMessage(DLL_ERROR4, crtpath);
 283                     return JNI_FALSE;
 284                 }
 285             }
 286         }
 287 #endif /* MSVCP_DLL_NAME */
 288         loaded = 1;
 289     }
 290     return JNI_TRUE;
 291 }
 292 
 293 
 294 /*
 295  * Find path to JRE based on .exe&#39;s location or registry settings.
 296  */
 297 jboolean
 298 GetJREPath(char *path, jint pathsize)
 299 {
 300     char javadll[MAXPATHLEN];
 301     struct stat s;
 302 
 303     if (GetApplicationHome(path, pathsize)) {
 304         /* Is JRE co-located with the application? */
 305         JLI_Snprintf(javadll, sizeof(javadll), &quot;%s\\bin\\&quot; JAVA_DLL, path);
 306         if (stat(javadll, &amp;s) == 0) {
 307             JLI_TraceLauncher(&quot;JRE path is %s\n&quot;, path);
 308             return JNI_TRUE;
 309         }
 310         /* ensure storage for path + \jre + NULL */
 311         if ((JLI_StrLen(path) + 4 + 1) &gt; (size_t) pathsize) {
 312             JLI_TraceLauncher(&quot;Insufficient space to store JRE path\n&quot;);
 313             return JNI_FALSE;
 314         }
 315         /* Does this app ship a private JRE in &lt;apphome&gt;\jre directory? */
 316         JLI_Snprintf(javadll, sizeof (javadll), &quot;%s\\jre\\bin\\&quot; JAVA_DLL, path);
 317         if (stat(javadll, &amp;s) == 0) {
 318             JLI_StrCat(path, &quot;\\jre&quot;);
 319             JLI_TraceLauncher(&quot;JRE path is %s\n&quot;, path);
 320             return JNI_TRUE;
 321         }
 322     }
 323 
 324     /* Try getting path to JRE from path to JLI.DLL */
 325     if (GetApplicationHomeFromDll(path, pathsize)) {
 326         JLI_Snprintf(javadll, sizeof(javadll), &quot;%s\\bin\\&quot; JAVA_DLL, path);
 327         if (stat(javadll, &amp;s) == 0) {
 328             JLI_TraceLauncher(&quot;JRE path is %s\n&quot;, path);
 329             return JNI_TRUE;
 330         }
 331     }
 332 
 333 #ifdef USE_REGISTRY_LOOKUP
 334     /* Lookup public JRE using Windows registry. */
 335     if (GetPublicJREHome(path, pathsize)) {
 336         JLI_TraceLauncher(&quot;JRE path is %s\n&quot;, path);
 337         return JNI_TRUE;
 338     }
 339 #endif
 340 
 341     JLI_ReportErrorMessage(JRE_ERROR8 JAVA_DLL);
 342     return JNI_FALSE;
 343 }
 344 
 345 /*
 346  * Given a JRE location and a JVM type, construct what the name the
 347  * JVM shared library will be.  Return true, if such a library
 348  * exists, false otherwise.
 349  */
 350 static jboolean
 351 GetJVMPath(const char *jrepath, const char *jvmtype,
 352            char *jvmpath, jint jvmpathsize)
 353 {
 354     struct stat s;
 355     if (JLI_StrChr(jvmtype, &#39;/&#39;) || JLI_StrChr(jvmtype, &#39;\\&#39;)) {
 356         JLI_Snprintf(jvmpath, jvmpathsize, &quot;%s\\&quot; JVM_DLL, jvmtype);
 357     } else {
 358         JLI_Snprintf(jvmpath, jvmpathsize, &quot;%s\\bin\\%s\\&quot; JVM_DLL,
 359                      jrepath, jvmtype);
 360     }
 361     if (stat(jvmpath, &amp;s) == 0) {
 362         return JNI_TRUE;
 363     } else {
 364         return JNI_FALSE;
 365     }
 366 }
 367 
 368 /*
 369  * Load a jvm from &quot;jvmpath&quot; and initialize the invocation functions.
 370  */
 371 jboolean
 372 LoadJavaVM(const char *jvmpath, InvocationFunctions *ifn)
 373 {
 374     HINSTANCE handle;
 375 
 376     JLI_TraceLauncher(&quot;JVM path is %s\n&quot;, jvmpath);
 377 
 378     /*
 379      * The Microsoft C Runtime Library needs to be loaded first.  A copy is
 380      * assumed to be present in the &quot;JRE path&quot; directory.  If it is not found
 381      * there (or &quot;JRE path&quot; fails to resolve), skip the explicit load and let
 382      * nature take its course, which is likely to be a failure to execute.
 383      *
 384      */
 385     LoadMSVCRT();
 386 
 387     /* Load the Java VM DLL */
 388     if ((handle = LoadLibrary(jvmpath)) == 0) {
 389         JLI_ReportErrorMessage(DLL_ERROR4, (char *)jvmpath);
 390         return JNI_FALSE;
 391     }
 392 
 393     /* Now get the function addresses */
 394     ifn-&gt;CreateJavaVM =
 395         (void *)GetProcAddress(handle, &quot;JNI_CreateJavaVM&quot;);
 396     ifn-&gt;GetDefaultJavaVMInitArgs =
 397         (void *)GetProcAddress(handle, &quot;JNI_GetDefaultJavaVMInitArgs&quot;);
 398     if (ifn-&gt;CreateJavaVM == 0 || ifn-&gt;GetDefaultJavaVMInitArgs == 0) {
 399         JLI_ReportErrorMessage(JNI_ERROR1, (char *)jvmpath);
 400         return JNI_FALSE;
 401     }
 402 
 403     return JNI_TRUE;
 404 }
 405 
 406 /*
 407  * Removes the trailing file name and one sub-folder from a path.
 408  * If buf is &quot;c:\foo\bin\javac&quot;, then put &quot;c:\foo&quot; into buf.
 409  */
 410 jboolean
 411 TruncatePath(char *buf)
 412 {
 413     char *cp;
 414     *JLI_StrRChr(buf, &#39;\\&#39;) = &#39;\0&#39;; /* remove .exe file name */
 415     if ((cp = JLI_StrRChr(buf, &#39;\\&#39;)) == 0) {
 416         /* This happens if the application is in a drive root, and
 417          * there is no bin directory. */
 418         buf[0] = &#39;\0&#39;;
 419         return JNI_FALSE;
 420     }
 421     *cp = &#39;\0&#39;; /* remove the bin\ part */
 422     return JNI_TRUE;
 423 }
 424 
 425 /*
 426  * Retrieves the path to the JRE home by locating the executable file
 427  * of the current process and then truncating the path to the executable
 428  */
 429 jboolean
 430 GetApplicationHome(char *buf, jint bufsize)
 431 {
 432     GetModuleFileName(NULL, buf, bufsize);
 433     return TruncatePath(buf);
 434 }
 435 
 436 /*
 437  * Retrieves the path to the JRE home by locating JLI.DLL and
 438  * then truncating the path to JLI.DLL
 439  */
 440 jboolean
 441 GetApplicationHomeFromDll(char *buf, jint bufsize)
 442 {
 443     HMODULE module;
 444     DWORD flags = GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
 445                   GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT;
 446 
 447     if (GetModuleHandleEx(flags, (LPCSTR)&amp;GetJREPath, &amp;module) != 0) {
 448         if (GetModuleFileName(module, buf, bufsize) != 0) {
 449             return TruncatePath(buf);
 450         }
 451     }
 452     return JNI_FALSE;
 453 }
 454 
 455 /*
 456  * Support for doing cheap, accurate interval timing.
 457  */
 458 static jboolean counterAvailable = JNI_FALSE;
 459 static jboolean counterInitialized = JNI_FALSE;
 460 static LARGE_INTEGER counterFrequency;
 461 
 462 jlong CounterGet()
 463 {
 464     LARGE_INTEGER count;
 465 
 466     if (!counterInitialized) {
 467         counterAvailable = QueryPerformanceFrequency(&amp;counterFrequency);
 468         counterInitialized = JNI_TRUE;
 469     }
 470     if (!counterAvailable) {
 471         return 0;
 472     }
 473     QueryPerformanceCounter(&amp;count);
 474     return (jlong)(count.QuadPart);
 475 }
 476 
 477 jlong Counter2Micros(jlong counts)
 478 {
 479     if (!counterAvailable || !counterInitialized) {
 480         return 0;
 481     }
 482     return (counts * 1000 * 1000)/counterFrequency.QuadPart;
 483 }
 484 /*
 485  * windows snprintf does not guarantee a null terminator in the buffer,
 486  * if the computed size is equal to or greater than the buffer size,
 487  * as well as error conditions. This function guarantees a null terminator
 488  * under all these conditions. An unreasonable buffer or size will return
 489  * an error value. Under all other conditions this function will return the
 490  * size of the bytes actually written minus the null terminator, similar
 491  * to ansi snprintf api. Thus when calling this function the caller must
 492  * ensure storage for the null terminator.
 493  */
 494 int
 495 JLI_Snprintf(char* buffer, size_t size, const char* format, ...) {
 496     int rc;
 497     va_list vl;
 498     if (size == 0 || buffer == NULL)
 499         return -1;
 500     buffer[0] = &#39;\0&#39;;
 501     va_start(vl, format);
 502     rc = vsnprintf(buffer, size, format, vl);
 503     va_end(vl);
 504     /* force a null terminator, if something is amiss */
 505     if (rc &lt; 0) {
 506         /* apply ansi semantics */
 507         buffer[size - 1] = &#39;\0&#39;;
 508         return (int)size;
 509     } else if (rc == size) {
 510         /* force a null terminator */
 511         buffer[size - 1] = &#39;\0&#39;;
 512     }
 513     return rc;
 514 }
 515 
 516 static errno_t convert_to_unicode(const char* path, const wchar_t* prefix, wchar_t** wpath) {
 517     int unicode_path_len;
 518     size_t prefix_len, wpath_len;
 519 
 520     /*
 521      * Get required buffer size to convert to Unicode.
 522      * The return value includes the terminating null character.
 523      */
<a name="2" id="anc2"></a><span class="line-modified"> 524     unicode_path_len = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS,</span>
 525                                            path, -1, NULL, 0);
 526     if (unicode_path_len == 0) {
 527         return EINVAL;
 528     }
 529 
 530     prefix_len = wcslen(prefix);
 531     wpath_len = prefix_len + unicode_path_len;
 532     *wpath = (wchar_t*)JLI_MemAlloc(wpath_len * sizeof(wchar_t));
 533     if (*wpath == NULL) {
 534         return ENOMEM;
 535     }
 536 
 537     wcsncpy(*wpath, prefix, prefix_len);
<a name="3" id="anc3"></a><span class="line-modified"> 538     if (MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS,</span>
 539                             path, -1, &amp;((*wpath)[prefix_len]), (int)wpath_len) == 0) {
 540         JLI_MemFree(*wpath);
 541         *wpath = NULL;
 542         return EINVAL;
 543     }
 544 
 545     return ERROR_SUCCESS;
 546 }
 547 
 548 /* taken from hotspot and slightly adjusted for jli lib;
 549  * creates a UNC/ELP path from input &#39;path&#39;
 550  * the return buffer is allocated in C heap and needs to be freed using
 551  * JLI_MemFree by the caller.
 552  */
 553 static wchar_t* create_unc_path(const char* path, errno_t* err) {
 554     wchar_t* wpath = NULL;
 555     size_t converted_chars = 0;
 556     size_t path_len = strlen(path) + 1; /* includes the terminating NULL */
 557     if (path[0] == &#39;\\&#39; &amp;&amp; path[1] == &#39;\\&#39;) {
 558         if (path[2] == &#39;?&#39; &amp;&amp; path[3] == &#39;\\&#39;) {
 559             /* if it already has a \\?\ don&#39;t do the prefix */
 560             *err = convert_to_unicode(path, L&quot;&quot;, &amp;wpath);
 561         } else {
 562             /* only UNC pathname includes double slashes here */
 563             *err = convert_to_unicode(path, L&quot;\\\\?\\UNC&quot;, &amp;wpath);
 564         }
 565     } else {
 566         *err = convert_to_unicode(path, L&quot;\\\\?\\&quot;, &amp;wpath);
 567     }
 568     return wpath;
 569 }
 570 
 571 int JLI_Open(const char* name, int flags) {
 572     int fd;
 573     if (strlen(name) &lt; MAX_PATH) {
 574         fd = _open(name, flags);
 575     } else {
 576         errno_t err = ERROR_SUCCESS;
 577         wchar_t* wpath = create_unc_path(name, &amp;err);
 578         if (err != ERROR_SUCCESS) {
 579             if (wpath != NULL) JLI_MemFree(wpath);
 580             errno = err;
 581             return -1;
 582         }
 583         fd = _wopen(wpath, flags);
 584         if (fd == -1) {
 585             errno = GetLastError();
 586         }
 587         JLI_MemFree(wpath);
 588     }
 589     return fd;
 590 }
 591 
 592 JNIEXPORT void JNICALL
 593 JLI_ReportErrorMessage(const char* fmt, ...) {
 594     va_list vl;
 595     va_start(vl,fmt);
 596 
 597     if (IsJavaw()) {
 598         char *message;
 599 
 600         /* get the length of the string we need */
 601         int n = _vscprintf(fmt, vl);
 602 
 603         message = (char *)JLI_MemAlloc(n + 1);
 604         _vsnprintf(message, n, fmt, vl);
 605         message[n]=&#39;\0&#39;;
 606         MessageBox(NULL, message, &quot;Java Virtual Machine Launcher&quot;,
 607             (MB_OK|MB_ICONSTOP|MB_APPLMODAL));
 608         JLI_MemFree(message);
 609     } else {
 610         vfprintf(stderr, fmt, vl);
 611         fprintf(stderr, &quot;\n&quot;);
 612     }
 613     va_end(vl);
 614 }
 615 
 616 /*
 617  * Just like JLI_ReportErrorMessage, except that it concatenates the system
 618  * error message if any, its upto the calling routine to correctly
 619  * format the separation of the messages.
 620  */
 621 JNIEXPORT void JNICALL
 622 JLI_ReportErrorMessageSys(const char *fmt, ...)
 623 {
 624     va_list vl;
 625 
 626     int save_errno = errno;
 627     DWORD       errval;
 628     jboolean freeit = JNI_FALSE;
 629     char  *errtext = NULL;
 630 
 631     va_start(vl, fmt);
 632 
 633     if ((errval = GetLastError()) != 0) {               /* Platform SDK / DOS Error */
 634         int n = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|
 635             FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_ALLOCATE_BUFFER,
 636             NULL, errval, 0, (LPTSTR)&amp;errtext, 0, NULL);
 637         if (errtext == NULL || n == 0) {                /* Paranoia check */
 638             errtext = &quot;&quot;;
 639             n = 0;
 640         } else {
 641             freeit = JNI_TRUE;
 642             if (n &gt; 2) {                                /* Drop final CR, LF */
 643                 if (errtext[n - 1] == &#39;\n&#39;) n--;
 644                 if (errtext[n - 1] == &#39;\r&#39;) n--;
 645                 errtext[n] = &#39;\0&#39;;
 646             }
 647         }
 648     } else {   /* C runtime error that has no corresponding DOS error code */
 649         errtext = strerror(save_errno);
 650     }
 651 
 652     if (IsJavaw()) {
 653         char *message;
 654         int mlen;
 655         /* get the length of the string we need */
 656         int len = mlen =  _vscprintf(fmt, vl) + 1;
 657         if (freeit) {
 658            mlen += (int)JLI_StrLen(errtext);
 659         }
 660 
 661         message = (char *)JLI_MemAlloc(mlen);
 662         _vsnprintf(message, len, fmt, vl);
 663         message[len]=&#39;\0&#39;;
 664 
 665         if (freeit) {
 666            JLI_StrCat(message, errtext);
 667         }
 668 
 669         MessageBox(NULL, message, &quot;Java Virtual Machine Launcher&quot;,
 670             (MB_OK|MB_ICONSTOP|MB_APPLMODAL));
 671 
 672         JLI_MemFree(message);
 673     } else {
 674         vfprintf(stderr, fmt, vl);
 675         if (freeit) {
 676            fprintf(stderr, &quot;%s&quot;, errtext);
 677         }
 678     }
 679     if (freeit) {
 680         (void)LocalFree((HLOCAL)errtext);
 681     }
 682     va_end(vl);
 683 }
 684 
 685 JNIEXPORT void JNICALL
 686 JLI_ReportExceptionDescription(JNIEnv * env) {
 687     if (IsJavaw()) {
 688        /*
 689         * This code should be replaced by code which opens a window with
 690         * the exception detail message, for now atleast put a dialog up.
 691         */
 692         MessageBox(NULL, &quot;A Java Exception has occurred.&quot;, &quot;Java Virtual Machine Launcher&quot;,
 693                (MB_OK|MB_ICONSTOP|MB_APPLMODAL));
 694     } else {
 695         (*env)-&gt;ExceptionDescribe(env);
 696     }
 697 }
 698 
 699 /*
 700  * Wrapper for platform dependent unsetenv function.
 701  */
 702 int
 703 UnsetEnv(char *name)
 704 {
 705     int ret;
 706     char *buf = JLI_MemAlloc(JLI_StrLen(name) + 2);
 707     buf = JLI_StrCat(JLI_StrCpy(buf, name), &quot;=&quot;);
 708     ret = _putenv(buf);
 709     JLI_MemFree(buf);
 710     return (ret);
 711 }
 712 
 713 /* --- Splash Screen shared library support --- */
 714 
 715 static const char* SPLASHSCREEN_SO = &quot;\\bin\\splashscreen.dll&quot;;
 716 
 717 static HMODULE hSplashLib = NULL;
 718 
 719 void* SplashProcAddress(const char* name) {
 720     char libraryPath[MAXPATHLEN]; /* some extra space for JLI_StrCat&#39;ing SPLASHSCREEN_SO */
 721 
 722     if (!GetJREPath(libraryPath, MAXPATHLEN)) {
 723         return NULL;
 724     }
 725     if (JLI_StrLen(libraryPath)+JLI_StrLen(SPLASHSCREEN_SO) &gt;= MAXPATHLEN) {
 726         return NULL;
 727     }
 728     JLI_StrCat(libraryPath, SPLASHSCREEN_SO);
 729 
 730     if (!hSplashLib) {
 731         hSplashLib = LoadLibrary(libraryPath);
 732     }
 733     if (hSplashLib) {
 734         return GetProcAddress(hSplashLib, name);
 735     } else {
 736         return NULL;
 737     }
 738 }
 739 
 740 /*
 741  * Signature adapter for _beginthreadex().
 742  */
 743 static unsigned __stdcall ThreadJavaMain(void* args) {
 744     return (unsigned)JavaMain(args);
 745 }
 746 
 747 /*
 748  * Block current thread and continue execution in a new thread.
 749  */
 750 int
 751 CallJavaMainInNewThread(jlong stack_size, void* args) {
 752     int rslt = 0;
 753     unsigned thread_id;
 754 
 755 #ifndef STACK_SIZE_PARAM_IS_A_RESERVATION
 756 #define STACK_SIZE_PARAM_IS_A_RESERVATION  (0x10000)
 757 #endif
 758 
 759     /*
 760      * STACK_SIZE_PARAM_IS_A_RESERVATION is what we want, but it&#39;s not
 761      * supported on older version of Windows. Try first with the flag; and
 762      * if that fails try again without the flag. See MSDN document or HotSpot
 763      * source (os_win32.cpp) for details.
 764      */
 765     HANDLE thread_handle =
 766         (HANDLE)_beginthreadex(NULL,
 767                                (unsigned)stack_size,
 768                                ThreadJavaMain,
 769                                args,
 770                                STACK_SIZE_PARAM_IS_A_RESERVATION,
 771                                &amp;thread_id);
 772     if (thread_handle == NULL) {
 773         thread_handle =
 774         (HANDLE)_beginthreadex(NULL,
 775                                (unsigned)stack_size,
 776                                ThreadJavaMain,
 777                                args,
 778                                0,
 779                                &amp;thread_id);
 780     }
 781 
 782     /* AWT preloading (AFTER main thread start) */
 783 #ifdef ENABLE_AWT_PRELOAD
 784     /* D3D preloading */
 785     if (awtPreloadD3D != 0) {
 786         char *envValue;
 787         /* D3D routines checks env.var J2D_D3D if no appropriate
 788          * command line params was specified
 789          */
 790         envValue = getenv(&quot;J2D_D3D&quot;);
 791         if (envValue != NULL &amp;&amp; JLI_StrCaseCmp(envValue, &quot;false&quot;) == 0) {
 792             awtPreloadD3D = 0;
 793         }
 794         /* Test that AWT preloading isn&#39;t disabled by J2D_D3D_PRELOAD env.var */
 795         envValue = getenv(&quot;J2D_D3D_PRELOAD&quot;);
 796         if (envValue != NULL &amp;&amp; JLI_StrCaseCmp(envValue, &quot;false&quot;) == 0) {
 797             awtPreloadD3D = 0;
 798         }
 799         if (awtPreloadD3D &lt; 0) {
 800             /* If awtPreloadD3D is still undefined (-1), test
 801              * if it is turned on by J2D_D3D_PRELOAD env.var.
 802              * By default it&#39;s turned OFF.
 803              */
 804             awtPreloadD3D = 0;
 805             if (envValue != NULL &amp;&amp; JLI_StrCaseCmp(envValue, &quot;true&quot;) == 0) {
 806                 awtPreloadD3D = 1;
 807             }
 808          }
 809     }
 810     if (awtPreloadD3D) {
 811         AWTPreload(D3D_PRELOAD_FUNC);
 812     }
 813 #endif /* ENABLE_AWT_PRELOAD */
 814 
 815     if (thread_handle) {
 816         WaitForSingleObject(thread_handle, INFINITE);
 817         GetExitCodeThread(thread_handle, &amp;rslt);
 818         CloseHandle(thread_handle);
 819     } else {
 820         rslt = JavaMain(args);
 821     }
 822 
 823 #ifdef ENABLE_AWT_PRELOAD
 824     if (awtPreloaded) {
 825         AWTPreloadStop();
 826     }
 827 #endif /* ENABLE_AWT_PRELOAD */
 828 
 829     return rslt;
 830 }
 831 
 832 /*
 833  * The implementation for finding classes from the bootstrap
 834  * class loader, refer to java.h
 835  */
 836 static FindClassFromBootLoader_t *findBootClass = NULL;
 837 
 838 jclass FindBootStrapClass(JNIEnv *env, const char *classname)
 839 {
 840    HMODULE hJvm;
 841 
 842    if (findBootClass == NULL) {
 843        hJvm = GetModuleHandle(JVM_DLL);
 844        if (hJvm == NULL) return NULL;
 845        /* need to use the demangled entry point */
 846        findBootClass = (FindClassFromBootLoader_t *)GetProcAddress(hJvm,
 847             &quot;JVM_FindClassFromBootLoader&quot;);
 848        if (findBootClass == NULL) {
 849           JLI_ReportErrorMessage(DLL_ERROR4, &quot;JVM_FindClassFromBootLoader&quot;);
 850           return NULL;
 851        }
 852    }
 853    return findBootClass(env, classname);
 854 }
 855 
 856 void
 857 InitLauncher(boolean javaw)
 858 {
 859     INITCOMMONCONTROLSEX icx;
 860 
 861     /*
 862      * Required for javaw mode MessageBox output as well as for
 863      * HotSpot -XX:+ShowMessageBoxOnError in java mode, an empty
 864      * flag field is sufficient to perform the basic UI initialization.
 865      */
 866     memset(&amp;icx, 0, sizeof(INITCOMMONCONTROLSEX));
 867     icx.dwSize = sizeof(INITCOMMONCONTROLSEX);
 868     InitCommonControlsEx(&amp;icx);
 869     _isjavaw = javaw;
 870     JLI_SetTraceLauncher();
 871 }
 872 
 873 
 874 /* ============================== */
 875 /* AWT preloading */
 876 #ifdef ENABLE_AWT_PRELOAD
 877 
 878 typedef int FnPreloadStart(void);
 879 typedef void FnPreloadStop(void);
 880 static FnPreloadStop *fnPreloadStop = NULL;
 881 static HMODULE hPreloadAwt = NULL;
 882 
 883 /*
 884  * Starts AWT preloading
 885  */
 886 int AWTPreload(const char *funcName)
 887 {
 888     int result = -1;
 889     /* load AWT library once (if several preload function should be called) */
 890     if (hPreloadAwt == NULL) {
 891         /* awt.dll is not loaded yet */
 892         char libraryPath[MAXPATHLEN];
 893         size_t jrePathLen = 0;
 894         HMODULE hJava = NULL;
 895         HMODULE hVerify = NULL;
 896 
 897         while (1) {
 898             /* awt.dll depends on jvm.dll &amp; java.dll;
 899              * jvm.dll is already loaded, so we need only java.dll;
 900              * java.dll depends on MSVCRT lib &amp; verify.dll.
 901              */
 902             if (!GetJREPath(libraryPath, MAXPATHLEN)) {
 903                 break;
 904             }
 905 
 906             /* save path length */
 907             jrePathLen = JLI_StrLen(libraryPath);
 908 
 909             if (jrePathLen + JLI_StrLen(&quot;\\bin\\verify.dll&quot;) &gt;= MAXPATHLEN) {
 910               /* jre path is too long, the library path will not fit there;
 911                * report and abort preloading
 912                */
 913               JLI_ReportErrorMessage(JRE_ERROR11);
 914               break;
 915             }
 916 
 917             /* load msvcrt 1st */
 918             LoadMSVCRT();
 919 
 920             /* load verify.dll */
 921             JLI_StrCat(libraryPath, &quot;\\bin\\verify.dll&quot;);
 922             hVerify = LoadLibrary(libraryPath);
 923             if (hVerify == NULL) {
 924                 break;
 925             }
 926 
 927             /* restore jrePath */
 928             libraryPath[jrePathLen] = 0;
 929             /* load java.dll */
 930             JLI_StrCat(libraryPath, &quot;\\bin\\&quot; JAVA_DLL);
 931             hJava = LoadLibrary(libraryPath);
 932             if (hJava == NULL) {
 933                 break;
 934             }
 935 
 936             /* restore jrePath */
 937             libraryPath[jrePathLen] = 0;
 938             /* load awt.dll */
 939             JLI_StrCat(libraryPath, &quot;\\bin\\awt.dll&quot;);
 940             hPreloadAwt = LoadLibrary(libraryPath);
 941             if (hPreloadAwt == NULL) {
 942                 break;
 943             }
 944 
 945             /* get &quot;preloadStop&quot; func ptr */
 946             fnPreloadStop = (FnPreloadStop *)GetProcAddress(hPreloadAwt, &quot;preloadStop&quot;);
 947 
 948             break;
 949         }
 950     }
 951 
 952     if (hPreloadAwt != NULL) {
 953         FnPreloadStart *fnInit = (FnPreloadStart *)GetProcAddress(hPreloadAwt, funcName);
 954         if (fnInit != NULL) {
 955             /* don&#39;t forget to stop preloading */
 956             awtPreloaded = 1;
 957 
 958             result = fnInit();
 959         }
 960     }
 961 
 962     return result;
 963 }
 964 
 965 /*
 966  * Terminates AWT preloading
 967  */
 968 void AWTPreloadStop() {
 969     if (fnPreloadStop != NULL) {
 970         fnPreloadStop();
 971     }
 972 }
 973 
 974 #endif /* ENABLE_AWT_PRELOAD */
 975 
 976 int
 977 JVMInit(InvocationFunctions* ifn, jlong threadStackSize,
 978         int argc, char **argv,
 979         int mode, char *what, int ret)
 980 {
 981     ShowSplashScreen();
 982     return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);
 983 }
 984 
 985 void
 986 PostJVMInit(JNIEnv *env, jclass mainClass, JavaVM *vm)
 987 {
 988     // stubbed out for windows and *nixes.
 989 }
 990 
 991 void
 992 RegisterThread()
 993 {
 994     // stubbed out for windows and *nixes.
 995 }
 996 
 997 /*
 998  * on windows, we return a false to indicate this option is not applicable
 999  */
1000 jboolean
1001 ProcessPlatformOption(const char *arg)
1002 {
1003     return JNI_FALSE;
1004 }
1005 
1006 /*
1007  * At this point we have the arguments to the application, and we need to
1008  * check with original stdargs in order to compare which of these truly
1009  * needs expansion. cmdtoargs will specify this if it finds a bare
1010  * (unquoted) argument containing a glob character(s) ie. * or ?
1011  */
1012 jobjectArray
1013 CreateApplicationArgs(JNIEnv *env, char **strv, int argc)
1014 {
1015     int i, j, idx;
1016     size_t tlen;
1017     jobjectArray outArray, inArray;
1018     char *arg, **nargv;
1019     jboolean needs_expansion = JNI_FALSE;
1020     jmethodID mid;
1021     int stdargc;
1022     StdArg *stdargs;
1023     int *appArgIdx;
1024     int isTool;
1025     jclass cls = GetLauncherHelperClass(env);
1026     NULL_CHECK0(cls);
1027 
1028     if (argc == 0) {
1029         return NewPlatformStringArray(env, strv, argc);
1030     }
1031     // the holy grail we need to compare with.
1032     stdargs = JLI_GetStdArgs();
1033     stdargc = JLI_GetStdArgc();
1034 
1035     // sanity check, this should never happen
1036     if (argc &gt; stdargc) {
1037         JLI_TraceLauncher(&quot;Warning: app args is larger than the original, %d %d\n&quot;, argc, stdargc);
1038         JLI_TraceLauncher(&quot;passing arguments as-is.\n&quot;);
1039         return NewPlatformStringArray(env, strv, argc);
1040     }
1041 
1042     // sanity check, match the args we have, to the holy grail
1043     idx = JLI_GetAppArgIndex();
1044 
1045     // First arg index is NOT_FOUND
1046     if (idx &lt; 0) {
1047         // The only allowed value should be NOT_FOUND (-1) unless another change introduces
1048         // a different negative index
1049         assert (idx == -1);
1050         JLI_TraceLauncher(&quot;Warning: first app arg index not found, %d\n&quot;, idx);
1051         JLI_TraceLauncher(&quot;passing arguments as-is.\n&quot;);
1052         return NewPlatformStringArray(env, strv, argc);
1053     }
1054 
1055     isTool = (idx == 0);
1056     if (isTool) { idx++; } // skip tool name
1057     JLI_TraceLauncher(&quot;AppArgIndex: %d points to %s\n&quot;, idx, stdargs[idx].arg);
1058 
1059     appArgIdx = calloc(argc, sizeof(int));
1060     for (i = idx, j = 0; i &lt; stdargc; i++) {
1061         if (isTool) { // filter -J used by tools to pass JVM options
1062             arg = stdargs[i].arg;
1063             if (arg[0] == &#39;-&#39; &amp;&amp; arg[1] == &#39;J&#39;) {
1064                 continue;
1065             }
1066         }
1067         appArgIdx[j++] = i;
1068     }
1069     // sanity check, ensure same number of arguments for application
1070     if (j != argc) {
1071         JLI_TraceLauncher(&quot;Warning: app args count doesn&#39;t match, %d %d\n&quot;, j, argc);
1072         JLI_TraceLauncher(&quot;passing arguments as-is.\n&quot;);
1073         JLI_MemFree(appArgIdx);
1074         return NewPlatformStringArray(env, strv, argc);
1075     }
1076 
1077     // make a copy of the args which will be expanded in java if required.
1078     nargv = (char **)JLI_MemAlloc(argc * sizeof(char*));
1079     for (i = 0; i &lt; argc; i++) {
1080         jboolean arg_expand;
1081         j = appArgIdx[i];
1082         arg_expand = (JLI_StrCmp(stdargs[j].arg, strv[i]) == 0)
1083             ? stdargs[j].has_wildcard
1084             : JNI_FALSE;
1085         if (needs_expansion == JNI_FALSE)
1086             needs_expansion = arg_expand;
1087 
1088         // indicator char + String + NULL terminator, the java method will strip
1089         // out the first character, the indicator character, so no matter what
1090         // we add the indicator
1091         tlen = 1 + JLI_StrLen(strv[i]) + 1;
1092         nargv[i] = (char *) JLI_MemAlloc(tlen);
1093         if (JLI_Snprintf(nargv[i], tlen, &quot;%c%s&quot;, arg_expand ? &#39;T&#39; : &#39;F&#39;,
1094                          strv[i]) &lt; 0) {
1095             return NULL;
1096         }
1097         JLI_TraceLauncher(&quot;%s\n&quot;, nargv[i]);
1098     }
1099 
1100     if (!needs_expansion) {
1101         // clean up any allocated memory and return back the old arguments
1102         for (i = 0 ; i &lt; argc ; i++) {
1103             JLI_MemFree(nargv[i]);
1104         }
1105         JLI_MemFree(nargv);
1106         JLI_MemFree(appArgIdx);
1107         return NewPlatformStringArray(env, strv, argc);
1108     }
1109     NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls,
1110                                                 &quot;expandArgs&quot;,
1111                                                 &quot;([Ljava/lang/String;)[Ljava/lang/String;&quot;));
1112 
1113     // expand the arguments that require expansion, the java method will strip
1114     // out the indicator character.
1115     NULL_CHECK0(inArray = NewPlatformStringArray(env, nargv, argc));
1116     outArray = (*env)-&gt;CallStaticObjectMethod(env, cls, mid, inArray);
1117     for (i = 0; i &lt; argc; i++) {
1118         JLI_MemFree(nargv[i]);
1119     }
1120     JLI_MemFree(nargv);
1121     JLI_MemFree(appArgIdx);
1122     return outArray;
1123 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
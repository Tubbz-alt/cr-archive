<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/io/ObjectInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.io.ObjectStreamClass.WeakClassKey;
  29 import java.io.ObjectStreamClass.RecordSupport;
  30 import java.lang.System.Logger;
  31 import java.lang.invoke.MethodHandle;
  32 import java.lang.ref.ReferenceQueue;
  33 import java.lang.reflect.Array;
  34 import java.lang.reflect.Modifier;
  35 import java.lang.reflect.Proxy;
  36 import java.security.AccessControlContext;
  37 import java.security.AccessController;
  38 import java.security.PrivilegedAction;
  39 import java.security.PrivilegedActionException;
  40 import java.security.PrivilegedExceptionAction;
  41 import java.util.Arrays;
  42 import java.util.Map;
  43 import java.util.Objects;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 import java.util.concurrent.ConcurrentMap;
  46 
  47 import static java.io.ObjectStreamClass.processQueue;
  48 
  49 import jdk.internal.access.SharedSecrets;
  50 import jdk.internal.misc.Unsafe;
  51 import sun.reflect.misc.ReflectUtil;
  52 
  53 /**
  54  * An ObjectInputStream deserializes primitive data and objects previously
  55  * written using an ObjectOutputStream.
  56  *
  57  * &lt;p&gt;&lt;strong&gt;Warning: Deserialization of untrusted data is inherently dangerous
  58  * and should be avoided. Untrusted data should be carefully validated according to the
  59  * &quot;Serialization and Deserialization&quot; section of the
  60  * {@extLink secure_coding_guidelines_javase Secure Coding Guidelines for Java SE}.
  61  * {@extLink serialization_filter_guide Serialization Filtering} describes best
  62  * practices for defensive use of serial filters.
  63  * &lt;/strong&gt;&lt;/p&gt;
  64  *
  65  * &lt;p&gt;ObjectOutputStream and ObjectInputStream can provide an application with
  66  * persistent storage for graphs of objects when used with a FileOutputStream
  67  * and FileInputStream respectively.  ObjectInputStream is used to recover
  68  * those objects previously serialized. Other uses include passing objects
  69  * between hosts using a socket stream or for marshaling and unmarshaling
  70  * arguments and parameters in a remote communication system.
  71  *
  72  * &lt;p&gt;ObjectInputStream ensures that the types of all objects in the graph
  73  * created from the stream match the classes present in the Java Virtual
  74  * Machine.  Classes are loaded as required using the standard mechanisms.
  75  *
  76  * &lt;p&gt;Only objects that support the java.io.Serializable or
  77  * java.io.Externalizable interface can be read from streams.
  78  *
  79  * &lt;p&gt;The method {@code readObject} is used to read an object from the
  80  * stream.  Java&#39;s safe casting should be used to get the desired type.  In
  81  * Java, strings and arrays are objects and are treated as objects during
  82  * serialization. When read they need to be cast to the expected type.
  83  *
  84  * &lt;p&gt;Primitive data types can be read from the stream using the appropriate
  85  * method on DataInput.
  86  *
  87  * &lt;p&gt;The default deserialization mechanism for objects restores the contents
  88  * of each field to the value and type it had when it was written.  Fields
  89  * declared as transient or static are ignored by the deserialization process.
  90  * References to other objects cause those objects to be read from the stream
  91  * as necessary.  Graphs of objects are restored correctly using a reference
  92  * sharing mechanism.  New objects are always allocated when deserializing,
  93  * which prevents existing objects from being overwritten.
  94  *
  95  * &lt;p&gt;Reading an object is analogous to running the constructors of a new
  96  * object.  Memory is allocated for the object and initialized to zero (NULL).
  97  * No-arg constructors are invoked for the non-serializable classes and then
  98  * the fields of the serializable classes are restored from the stream starting
  99  * with the serializable class closest to java.lang.object and finishing with
 100  * the object&#39;s most specific class.
 101  *
 102  * &lt;p&gt;For example to read from a stream as written by the example in
 103  * ObjectOutputStream:
 104  * &lt;br&gt;
 105  * &lt;pre&gt;
 106  *      FileInputStream fis = new FileInputStream(&quot;t.tmp&quot;);
 107  *      ObjectInputStream ois = new ObjectInputStream(fis);
 108  *
 109  *      int i = ois.readInt();
 110  *      String today = (String) ois.readObject();
 111  *      Date date = (Date) ois.readObject();
 112  *
 113  *      ois.close();
 114  * &lt;/pre&gt;
 115  *
 116  * &lt;p&gt;Classes control how they are serialized by implementing either the
 117  * java.io.Serializable or java.io.Externalizable interfaces.
 118  *
 119  * &lt;p&gt;Implementing the Serializable interface allows object serialization to
 120  * save and restore the entire state of the object and it allows classes to
 121  * evolve between the time the stream is written and the time it is read.  It
 122  * automatically traverses references between objects, saving and restoring
 123  * entire graphs.
 124  *
 125  * &lt;p&gt;Serializable classes that require special handling during the
 126  * serialization and deserialization process should implement the following
 127  * methods:
 128  *
 129  * &lt;pre&gt;
 130  * private void writeObject(java.io.ObjectOutputStream stream)
 131  *     throws IOException;
 132  * private void readObject(java.io.ObjectInputStream stream)
 133  *     throws IOException, ClassNotFoundException;
 134  * private void readObjectNoData()
 135  *     throws ObjectStreamException;
 136  * &lt;/pre&gt;
 137  *
 138  * &lt;p&gt;The readObject method is responsible for reading and restoring the state
 139  * of the object for its particular class using data written to the stream by
 140  * the corresponding writeObject method.  The method does not need to concern
 141  * itself with the state belonging to its superclasses or subclasses.  State is
 142  * restored by reading data from the ObjectInputStream for the individual
 143  * fields and making assignments to the appropriate fields of the object.
 144  * Reading primitive data types is supported by DataInput.
 145  *
 146  * &lt;p&gt;Any attempt to read object data which exceeds the boundaries of the
 147  * custom data written by the corresponding writeObject method will cause an
 148  * OptionalDataException to be thrown with an eof field value of true.
 149  * Non-object reads which exceed the end of the allotted data will reflect the
 150  * end of data in the same way that they would indicate the end of the stream:
 151  * bytewise reads will return -1 as the byte read or number of bytes read, and
 152  * primitive reads will throw EOFExceptions.  If there is no corresponding
 153  * writeObject method, then the end of default serialized data marks the end of
 154  * the allotted data.
 155  *
 156  * &lt;p&gt;Primitive and object read calls issued from within a readExternal method
 157  * behave in the same manner--if the stream is already positioned at the end of
 158  * data written by the corresponding writeExternal method, object reads will
 159  * throw OptionalDataExceptions with eof set to true, bytewise reads will
 160  * return -1, and primitive reads will throw EOFExceptions.  Note that this
 161  * behavior does not hold for streams written with the old
 162  * {@code ObjectStreamConstants.PROTOCOL_VERSION_1} protocol, in which the
 163  * end of data written by writeExternal methods is not demarcated, and hence
 164  * cannot be detected.
 165  *
 166  * &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
 167  * the object for its particular class in the event that the serialization
 168  * stream does not list the given class as a superclass of the object being
 169  * deserialized.  This may occur in cases where the receiving party uses a
 170  * different version of the deserialized instance&#39;s class than the sending
 171  * party, and the receiver&#39;s version extends classes that are not extended by
 172  * the sender&#39;s version.  This may also occur if the serialization stream has
 173  * been tampered; hence, readObjectNoData is useful for initializing
 174  * deserialized objects properly despite a &quot;hostile&quot; or incomplete source
 175  * stream.
 176  *
 177  * &lt;p&gt;Serialization does not read or assign values to the fields of any object
 178  * that does not implement the java.io.Serializable interface.  Subclasses of
 179  * Objects that are not serializable can be serializable. In this case the
 180  * non-serializable class must have a no-arg constructor to allow its fields to
 181  * be initialized.  In this case it is the responsibility of the subclass to
 182  * save and restore the state of the non-serializable class. It is frequently
 183  * the case that the fields of that class are accessible (public, package, or
 184  * protected) or that there are get and set methods that can be used to restore
 185  * the state.
 186  *
 187  * &lt;p&gt;The contents of the stream can be filtered during deserialization.
 188  * If a {@linkplain #setObjectInputFilter(ObjectInputFilter) filter is set}
 189  * on an ObjectInputStream, the {@link ObjectInputFilter} can check that
 190  * the classes, array lengths, number of references in the stream, depth, and
 191  * number of bytes consumed from the input stream are allowed and
 192  * if not, can terminate deserialization.
 193  * A {@linkplain ObjectInputFilter.Config#setSerialFilter(ObjectInputFilter) system-wide filter}
 194  * can be configured that is applied to each {@code ObjectInputStream} unless replaced
 195  * using {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}.
 196  *
 197  * &lt;p&gt;Any exception that occurs while deserializing an object will be caught by
 198  * the ObjectInputStream and abort the reading process.
 199  *
 200  * &lt;p&gt;Implementing the Externalizable interface allows the object to assume
 201  * complete control over the contents and format of the object&#39;s serialized
 202  * form.  The methods of the Externalizable interface, writeExternal and
 203  * readExternal, are called to save and restore the objects state.  When
 204  * implemented by a class they can write and read their own state using all of
 205  * the methods of ObjectOutput and ObjectInput.  It is the responsibility of
 206  * the objects to handle any versioning that occurs.
 207  *
 208  * &lt;p&gt;Enum constants are deserialized differently than ordinary serializable or
 209  * externalizable objects.  The serialized form of an enum constant consists
 210  * solely of its name; field values of the constant are not transmitted.  To
 211  * deserialize an enum constant, ObjectInputStream reads the constant name from
 212  * the stream; the deserialized constant is then obtained by calling the static
 213  * method {@code Enum.valueOf(Class, String)} with the enum constant&#39;s
 214  * base type and the received constant name as arguments.  Like other
 215  * serializable or externalizable objects, enum constants can function as the
 216  * targets of back references appearing subsequently in the serialization
 217  * stream.  The process by which enum constants are deserialized cannot be
 218  * customized: any class-specific readObject, readObjectNoData, and readResolve
 219  * methods defined by enum types are ignored during deserialization.
 220  * Similarly, any serialPersistentFields or serialVersionUID field declarations
 221  * are also ignored--all enum types have a fixed serialVersionUID of 0L.
 222  *
 223  * @implSpec
 224  * &lt;a id=&quot;record-serialization&quot;&gt;&lt;/a&gt;
 225  * Records are serialized differently than ordinary serializable or externalizable
 226  * objects. The serialized form of a record object is a sequence of values derived
 227  * from the record components. The stream format of a record object is the same as
 228  * that of an ordinary object in the stream. During deserialization, if the local
 229  * class equivalent of the specified stream class descriptor is a record class,
 230  * then first the stream fields are read and reconstructed to serve as the record&#39;s
 231  * component values; and second, a record object is created by invoking the
 232  * record&#39;s &lt;i&gt;canonical&lt;/i&gt; constructor with the component values as arguments (or the
 233  * default value for component&#39;s type if a component value is absent from the
 234  * stream).
 235  * Like other serializable or externalizable objects, record objects can function
 236  * as the target of back references appearing subsequently in the serialization
 237  * stream. However, a cycle in the graph where the record object is referred to,
 238  * either directly or transitively, by one of its components, is not preserved.
 239  * The record components are deserialized prior to the invocation of the record
 240  * constructor, hence this limitation (see
 241  * &lt;a href=&quot;{@docRoot}/../specs/serialization/serial-arch.html#cyclic-references&quot;&gt;
 242  * [Section 1.14, &quot;Circular References&quot;&lt;/a&gt; for additional information).
 243  * The process by which record objects are serialized or externalized cannot be
 244  * customized; any class-specific writeObject, readObject, readObjectNoData,
 245  * writeExternal, and readExternal methods defined by record classes are
 246  * ignored during serialization and deserialization. However, a substitute object
 247  * to be serialized or a designate replacement may be specified, by the
 248  * writeReplace and readResolve methods, respectively.  Any
 249  * serialPersistentFields field declaration is ignored. Documenting serializable
 250  * fields and data for record classes is unnecessary, since there is no variation
 251  * in the serial form, other than whether a substitute or replacement object is
 252  * used. The serialVersionUID of a record class is 0L unless explicitly
 253  * declared. The requirement for matching serialVersionUID values is waived for
 254  * record classes.
 255  *
 256  * @author      Mike Warres
 257  * @author      Roger Riggs
 258  * @see java.io.DataInput
 259  * @see java.io.ObjectOutputStream
 260  * @see java.io.Serializable
 261  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/input.html&quot;&gt;
 262  *     Object Serialization Specification, Section 3, Object Input Classes&lt;/a&gt;
 263  * @since   1.1
 264  */
 265 public class ObjectInputStream
 266     extends InputStream implements ObjectInput, ObjectStreamConstants
 267 {
 268     /** handle value representing null */
 269     private static final int NULL_HANDLE = -1;
 270 
 271     /** marker for unshared objects in internal handle table */
 272     private static final Object unsharedMarker = new Object();
 273 
 274     /**
 275      * immutable table mapping primitive type names to corresponding
 276      * class objects
 277      */
 278     private static final Map&lt;String, Class&lt;?&gt;&gt; primClasses =
 279         Map.of(&quot;boolean&quot;, boolean.class,
 280                &quot;byte&quot;, byte.class,
 281                &quot;char&quot;, char.class,
 282                &quot;short&quot;, short.class,
 283                &quot;int&quot;, int.class,
 284                &quot;long&quot;, long.class,
 285                &quot;float&quot;, float.class,
 286                &quot;double&quot;, double.class,
 287                &quot;void&quot;, void.class);
 288 
 289     private static class Caches {
 290         /** cache of subclass security audit results */
 291         static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =
 292             new ConcurrentHashMap&lt;&gt;();
 293 
 294         /** queue for WeakReferences to audited subclasses */
 295         static final ReferenceQueue&lt;Class&lt;?&gt;&gt; subclassAuditsQueue =
 296             new ReferenceQueue&lt;&gt;();
 297     }
 298 
 299     /*
 300      * Separate class to defer initialization of logging until needed.
 301      */
 302     private static class Logging {
 303         /*
 304          * Logger for ObjectInputFilter results.
 305          * Setup the filter logger if it is set to DEBUG or TRACE.
 306          * (Assuming it will not change).
 307          */
 308         static final System.Logger filterLogger;
 309 
 310         static {
 311             Logger filterLog = System.getLogger(&quot;java.io.serialization&quot;);
 312             filterLogger = (filterLog.isLoggable(Logger.Level.DEBUG)
 313                     || filterLog.isLoggable(Logger.Level.TRACE)) ? filterLog : null;
 314         }
 315     }
 316 
 317     /** filter stream for handling block data conversion */
 318     private final BlockDataInputStream bin;
 319     /** validation callback list */
 320     private final ValidationList vlist;
 321     /** recursion depth */
 322     private long depth;
 323     /** Total number of references to any type of object, class, enum, proxy, etc. */
 324     private long totalObjectRefs;
 325     /** whether stream is closed */
 326     private boolean closed;
 327 
 328     /** wire handle -&gt; obj/exception map */
 329     private final HandleTable handles;
 330     /** scratch field for passing handle values up/down call stack */
 331     private int passHandle = NULL_HANDLE;
 332     /** flag set when at end of field value block with no TC_ENDBLOCKDATA */
 333     private boolean defaultDataEnd = false;
 334 
 335     /** if true, invoke readObjectOverride() instead of readObject() */
 336     private final boolean enableOverride;
 337     /** if true, invoke resolveObject() */
 338     private boolean enableResolve;
 339 
 340     /**
 341      * Context during upcalls to class-defined readObject methods; holds
 342      * object currently being deserialized and descriptor for current class.
 343      * Null when not during readObject upcall.
 344      */
 345     private SerialCallbackContext curContext;
 346 
 347     /**
 348      * Filter of class descriptors and classes read from the stream;
 349      * may be null.
 350      */
 351     private ObjectInputFilter serialFilter;
 352 
 353     /**
 354      * Creates an ObjectInputStream that reads from the specified InputStream.
 355      * A serialization stream header is read from the stream and verified.
 356      * This constructor will block until the corresponding ObjectOutputStream
 357      * has written and flushed the header.
 358      *
 359      * &lt;p&gt;The serialization filter is initialized to the value of
 360      * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
 361      *
 362      * &lt;p&gt;If a security manager is installed, this constructor will check for
 363      * the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
 364      * directly or indirectly by the constructor of a subclass which overrides
 365      * the ObjectInputStream.readFields or ObjectInputStream.readUnshared
 366      * methods.
 367      *
 368      * @param   in input stream to read from
 369      * @throws  StreamCorruptedException if the stream header is incorrect
 370      * @throws  IOException if an I/O error occurs while reading stream header
 371      * @throws  SecurityException if untrusted subclass illegally overrides
 372      *          security-sensitive methods
 373      * @throws  NullPointerException if {@code in} is {@code null}
 374      * @see     ObjectInputStream#ObjectInputStream()
 375      * @see     ObjectInputStream#readFields()
 376      * @see     ObjectOutputStream#ObjectOutputStream(OutputStream)
 377      */
 378     public ObjectInputStream(InputStream in) throws IOException {
 379         verifySubclass();
 380         bin = new BlockDataInputStream(in);
 381         handles = new HandleTable(10);
 382         vlist = new ValidationList();
 383         serialFilter = ObjectInputFilter.Config.getSerialFilter();
 384         enableOverride = false;
 385         readStreamHeader();
 386         bin.setBlockDataMode(true);
 387     }
 388 
 389     /**
 390      * Provide a way for subclasses that are completely reimplementing
 391      * ObjectInputStream to not have to allocate private data just used by this
 392      * implementation of ObjectInputStream.
 393      *
 394      * &lt;p&gt;The serialization filter is initialized to the value of
 395      * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
 396      *
 397      * &lt;p&gt;If there is a security manager installed, this method first calls the
 398      * security manager&#39;s {@code checkPermission} method with the
 399      * {@code SerializablePermission(&quot;enableSubclassImplementation&quot;)}
 400      * permission to ensure it&#39;s ok to enable subclassing.
 401      *
 402      * @throws  SecurityException if a security manager exists and its
 403      *          {@code checkPermission} method denies enabling
 404      *          subclassing.
 405      * @throws  IOException if an I/O error occurs while creating this stream
 406      * @see SecurityManager#checkPermission
 407      * @see java.io.SerializablePermission
 408      */
 409     protected ObjectInputStream() throws IOException, SecurityException {
 410         SecurityManager sm = System.getSecurityManager();
 411         if (sm != null) {
 412             sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
 413         }
 414         bin = null;
 415         handles = null;
 416         vlist = null;
 417         serialFilter = ObjectInputFilter.Config.getSerialFilter();
 418         enableOverride = true;
 419     }
 420 
 421     /**
 422      * Read an object from the ObjectInputStream.  The class of the object, the
 423      * signature of the class, and the values of the non-transient and
 424      * non-static fields of the class and all of its supertypes are read.
 425      * Default deserializing for a class can be overridden using the writeObject
 426      * and readObject methods.  Objects referenced by this object are read
 427      * transitively so that a complete equivalent graph of objects is
 428      * reconstructed by readObject.
 429      *
 430      * &lt;p&gt;The root object is completely restored when all of its fields and the
 431      * objects it references are completely restored.  At this point the object
 432      * validation callbacks are executed in order based on their registered
 433      * priorities. The callbacks are registered by objects (in the readObject
 434      * special methods) as they are individually restored.
 435      *
 436      * &lt;p&gt;The serialization filter, when not {@code null}, is invoked for
 437      * each object (regular or class) read to reconstruct the root object.
 438      * See {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter} for details.
 439      *
 440      * &lt;p&gt;Exceptions are thrown for problems with the InputStream and for
 441      * classes that should not be deserialized.  All exceptions are fatal to
 442      * the InputStream and leave it in an indeterminate state; it is up to the
 443      * caller to ignore or recover the stream state.
 444      *
 445      * @throws  ClassNotFoundException Class of a serialized object cannot be
 446      *          found.
 447      * @throws  InvalidClassException Something is wrong with a class used by
 448      *          serialization.
 449      * @throws  StreamCorruptedException Control information in the
 450      *          stream is inconsistent.
 451      * @throws  OptionalDataException Primitive data was found in the
 452      *          stream instead of objects.
 453      * @throws  IOException Any of the usual Input/Output related exceptions.
 454      */
 455     public final Object readObject()
 456         throws IOException, ClassNotFoundException {
 457         return readObject(Object.class);
 458     }
 459 
 460     /**
 461      * Reads a String and only a string.
 462      *
 463      * @return  the String read
 464      * @throws  EOFException If end of file is reached.
 465      * @throws  IOException If other I/O error has occurred.
 466      */
 467     private String readString() throws IOException {
 468         try {
 469             return (String) readObject(String.class);
 470         } catch (ClassNotFoundException cnf) {
 471             throw new IllegalStateException(cnf);
 472         }
 473     }
 474 
 475     /**
 476      * Internal method to read an object from the ObjectInputStream of the expected type.
 477      * Called only from {@code readObject()} and {@code readString()}.
 478      * Only {@code Object.class} and {@code String.class} are supported.
 479      *
 480      * @param type the type expected; either Object.class or String.class
 481      * @return an object of the type
 482      * @throws  IOException Any of the usual Input/Output related exceptions.
 483      * @throws  ClassNotFoundException Class of a serialized object cannot be
 484      *          found.
 485      */
 486     private final Object readObject(Class&lt;?&gt; type)
 487         throws IOException, ClassNotFoundException
 488     {
 489         if (enableOverride) {
 490             return readObjectOverride();
 491         }
 492 
 493         if (! (type == Object.class || type == String.class))
 494             throw new AssertionError(&quot;internal error&quot;);
 495 
 496         // if nested read, passHandle contains handle of enclosing object
 497         int outerHandle = passHandle;
 498         try {
 499             Object obj = readObject0(type, false);
 500             handles.markDependency(outerHandle, passHandle);
 501             ClassNotFoundException ex = handles.lookupException(passHandle);
 502             if (ex != null) {
 503                 throw ex;
 504             }
 505             if (depth == 0) {
 506                 vlist.doCallbacks();
 507                 freeze();
 508             }
 509             return obj;
 510         } finally {
 511             passHandle = outerHandle;
 512             if (closed &amp;&amp; depth == 0) {
 513                 clear();
 514             }
 515         }
 516     }
 517 
 518     /**
 519      * This method is called by trusted subclasses of ObjectInputStream that
 520      * constructed ObjectInputStream using the protected no-arg constructor.
 521      * The subclass is expected to provide an override method with the modifier
 522      * &quot;final&quot;.
 523      *
 524      * @return  the Object read from the stream.
 525      * @throws  ClassNotFoundException Class definition of a serialized object
 526      *          cannot be found.
 527      * @throws  OptionalDataException Primitive data was found in the stream
 528      *          instead of objects.
 529      * @throws  IOException if I/O errors occurred while reading from the
 530      *          underlying stream
 531      * @see #ObjectInputStream()
 532      * @see #readObject()
 533      * @since 1.2
 534      */
 535     protected Object readObjectOverride()
 536         throws IOException, ClassNotFoundException
 537     {
 538         return null;
 539     }
 540 
 541     /**
 542      * Reads an &quot;unshared&quot; object from the ObjectInputStream.  This method is
 543      * identical to readObject, except that it prevents subsequent calls to
 544      * readObject and readUnshared from returning additional references to the
 545      * deserialized instance obtained via this call.  Specifically:
 546      * &lt;ul&gt;
 547      *   &lt;li&gt;If readUnshared is called to deserialize a back-reference (the
 548      *       stream representation of an object which has been written
 549      *       previously to the stream), an ObjectStreamException will be
 550      *       thrown.
 551      *
 552      *   &lt;li&gt;If readUnshared returns successfully, then any subsequent attempts
 553      *       to deserialize back-references to the stream handle deserialized
 554      *       by readUnshared will cause an ObjectStreamException to be thrown.
 555      * &lt;/ul&gt;
 556      * Deserializing an object via readUnshared invalidates the stream handle
 557      * associated with the returned object.  Note that this in itself does not
 558      * always guarantee that the reference returned by readUnshared is unique;
 559      * the deserialized object may define a readResolve method which returns an
 560      * object visible to other parties, or readUnshared may return a Class
 561      * object or enum constant obtainable elsewhere in the stream or through
 562      * external means. If the deserialized object defines a readResolve method
 563      * and the invocation of that method returns an array, then readUnshared
 564      * returns a shallow clone of that array; this guarantees that the returned
 565      * array object is unique and cannot be obtained a second time from an
 566      * invocation of readObject or readUnshared on the ObjectInputStream,
 567      * even if the underlying data stream has been manipulated.
 568      *
 569      * &lt;p&gt;The serialization filter, when not {@code null}, is invoked for
 570      * each object (regular or class) read to reconstruct the root object.
 571      * See {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter} for details.
 572      *
 573      * &lt;p&gt;ObjectInputStream subclasses which override this method can only be
 574      * constructed in security contexts possessing the
 575      * &quot;enableSubclassImplementation&quot; SerializablePermission; any attempt to
 576      * instantiate such a subclass without this permission will cause a
 577      * SecurityException to be thrown.
 578      *
 579      * @return  reference to deserialized object
 580      * @throws  ClassNotFoundException if class of an object to deserialize
 581      *          cannot be found
 582      * @throws  StreamCorruptedException if control information in the stream
 583      *          is inconsistent
 584      * @throws  ObjectStreamException if object to deserialize has already
 585      *          appeared in stream
 586      * @throws  OptionalDataException if primitive data is next in stream
 587      * @throws  IOException if an I/O error occurs during deserialization
 588      * @since   1.4
 589      */
 590     public Object readUnshared() throws IOException, ClassNotFoundException {
 591         // if nested read, passHandle contains handle of enclosing object
 592         int outerHandle = passHandle;
 593         try {
 594             Object obj = readObject0(Object.class, true);
 595             handles.markDependency(outerHandle, passHandle);
 596             ClassNotFoundException ex = handles.lookupException(passHandle);
 597             if (ex != null) {
 598                 throw ex;
 599             }
 600             if (depth == 0) {
 601                 vlist.doCallbacks();
 602                 freeze();
 603             }
 604             return obj;
 605         } finally {
 606             passHandle = outerHandle;
 607             if (closed &amp;&amp; depth == 0) {
 608                 clear();
 609             }
 610         }
 611     }
 612 
 613     /**
 614      * Read the non-static and non-transient fields of the current class from
 615      * this stream.  This may only be called from the readObject method of the
 616      * class being deserialized. It will throw the NotActiveException if it is
 617      * called otherwise.
 618      *
 619      * @throws  ClassNotFoundException if the class of a serialized object
 620      *          could not be found.
 621      * @throws  IOException if an I/O error occurs.
 622      * @throws  NotActiveException if the stream is not currently reading
 623      *          objects.
 624      */
 625     public void defaultReadObject()
 626         throws IOException, ClassNotFoundException
 627     {
 628         SerialCallbackContext ctx = curContext;
 629         if (ctx == null) {
 630             throw new NotActiveException(&quot;not in call to readObject&quot;);
 631         }
 632         Object curObj = ctx.getObj();
 633         ObjectStreamClass curDesc = ctx.getDesc();
 634         bin.setBlockDataMode(false);
 635         FieldValues vals = defaultReadFields(curObj, curDesc);
 636         if (curObj != null) {
 637             defaultCheckFieldValues(curObj, curDesc, vals);
 638             defaultSetFieldValues(curObj, curDesc, vals);
 639         }
 640         bin.setBlockDataMode(true);
 641         if (!curDesc.hasWriteObjectData()) {
 642             /*
 643              * Fix for 4360508: since stream does not contain terminating
 644              * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
 645              * knows to simulate end-of-custom-data behavior.
 646              */
 647             defaultDataEnd = true;
 648         }
 649         ClassNotFoundException ex = handles.lookupException(passHandle);
 650         if (ex != null) {
 651             throw ex;
 652         }
 653     }
 654 
 655     /**
 656      * Reads the persistent fields from the stream and makes them available by
 657      * name.
 658      *
 659      * @return  the {@code GetField} object representing the persistent
 660      *          fields of the object being deserialized
 661      * @throws  ClassNotFoundException if the class of a serialized object
 662      *          could not be found.
 663      * @throws  IOException if an I/O error occurs.
 664      * @throws  NotActiveException if the stream is not currently reading
 665      *          objects.
 666      * @since 1.2
 667      */
 668     public ObjectInputStream.GetField readFields()
 669         throws IOException, ClassNotFoundException
 670     {
 671         SerialCallbackContext ctx = curContext;
 672         if (ctx == null) {
 673             throw new NotActiveException(&quot;not in call to readObject&quot;);
 674         }
 675         ctx.checkAndSetUsed();
 676         ObjectStreamClass curDesc = ctx.getDesc();
 677         bin.setBlockDataMode(false);
 678         GetFieldImpl getField = new GetFieldImpl(curDesc);
 679         getField.readFields();
 680         bin.setBlockDataMode(true);
 681         if (!curDesc.hasWriteObjectData()) {
 682             /*
 683              * Fix for 4360508: since stream does not contain terminating
 684              * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
 685              * knows to simulate end-of-custom-data behavior.
 686              */
 687             defaultDataEnd = true;
 688         }
 689 
 690         return getField;
 691     }
 692 
 693     /**
 694      * Register an object to be validated before the graph is returned.  While
 695      * similar to resolveObject these validations are called after the entire
 696      * graph has been reconstituted.  Typically, a readObject method will
 697      * register the object with the stream so that when all of the objects are
 698      * restored a final set of validations can be performed.
 699      *
 700      * @param   obj the object to receive the validation callback.
 701      * @param   prio controls the order of callbacks;zero is a good default.
 702      *          Use higher numbers to be called back earlier, lower numbers for
 703      *          later callbacks. Within a priority, callbacks are processed in
 704      *          no particular order.
 705      * @throws  NotActiveException The stream is not currently reading objects
 706      *          so it is invalid to register a callback.
 707      * @throws  InvalidObjectException The validation object is null.
 708      */
 709     public void registerValidation(ObjectInputValidation obj, int prio)
 710         throws NotActiveException, InvalidObjectException
 711     {
 712         if (depth == 0) {
 713             throw new NotActiveException(&quot;stream inactive&quot;);
 714         }
 715         vlist.register(obj, prio);
 716     }
 717 
 718     /**
 719      * Load the local class equivalent of the specified stream class
 720      * description.  Subclasses may implement this method to allow classes to
 721      * be fetched from an alternate source.
 722      *
 723      * &lt;p&gt;The corresponding method in {@code ObjectOutputStream} is
 724      * {@code annotateClass}.  This method will be invoked only once for
 725      * each unique class in the stream.  This method can be implemented by
 726      * subclasses to use an alternate loading mechanism but must return a
 727      * {@code Class} object. Once returned, if the class is not an array
 728      * class, its serialVersionUID is compared to the serialVersionUID of the
 729      * serialized class, and if there is a mismatch, the deserialization fails
 730      * and an {@link InvalidClassException} is thrown.
 731      *
 732      * &lt;p&gt;The default implementation of this method in
 733      * {@code ObjectInputStream} returns the result of calling
 734      * &lt;pre&gt;
 735      *     Class.forName(desc.getName(), false, loader)
 736      * &lt;/pre&gt;
 737      * where {@code loader} is the first class loader on the current
 738      * thread&#39;s stack (starting from the currently executing method) that is
 739      * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
 740      * class loader} nor its ancestor; otherwise, {@code loader} is the
 741      * &lt;em&gt;platform class loader&lt;/em&gt;. If this call results in a
 742      * {@code ClassNotFoundException} and the name of the passed
 743      * {@code ObjectStreamClass} instance is the Java language keyword
 744      * for a primitive type or void, then the {@code Class} object
 745      * representing that primitive type or void will be returned
 746      * (e.g., an {@code ObjectStreamClass} with the name
 747      * {@code &quot;int&quot;} will be resolved to {@code Integer.TYPE}).
 748      * Otherwise, the {@code ClassNotFoundException} will be thrown to
 749      * the caller of this method.
 750      *
 751      * @param   desc an instance of class {@code ObjectStreamClass}
 752      * @return  a {@code Class} object corresponding to {@code desc}
 753      * @throws  IOException any of the usual Input/Output exceptions.
 754      * @throws  ClassNotFoundException if class of a serialized object cannot
 755      *          be found.
 756      */
 757     protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)
 758         throws IOException, ClassNotFoundException
 759     {
 760         String name = desc.getName();
 761         try {
 762             return Class.forName(name, false, latestUserDefinedLoader());
 763         } catch (ClassNotFoundException ex) {
 764             Class&lt;?&gt; cl = primClasses.get(name);
 765             if (cl != null) {
 766                 return cl;
 767             } else {
 768                 throw ex;
 769             }
 770         }
 771     }
 772 
 773     /**
 774      * Returns a proxy class that implements the interfaces named in a proxy
 775      * class descriptor; subclasses may implement this method to read custom
 776      * data from the stream along with the descriptors for dynamic proxy
 777      * classes, allowing them to use an alternate loading mechanism for the
 778      * interfaces and the proxy class.
 779      *
 780      * &lt;p&gt;This method is called exactly once for each unique proxy class
 781      * descriptor in the stream.
 782      *
 783      * &lt;p&gt;The corresponding method in {@code ObjectOutputStream} is
 784      * {@code annotateProxyClass}.  For a given subclass of
 785      * {@code ObjectInputStream} that overrides this method, the
 786      * {@code annotateProxyClass} method in the corresponding subclass of
 787      * {@code ObjectOutputStream} must write any data or objects read by
 788      * this method.
 789      *
 790      * &lt;p&gt;The default implementation of this method in
 791      * {@code ObjectInputStream} returns the result of calling
 792      * {@code Proxy.getProxyClass} with the list of {@code Class}
 793      * objects for the interfaces that are named in the {@code interfaces}
 794      * parameter.  The {@code Class} object for each interface name
 795      * {@code i} is the value returned by calling
 796      * &lt;pre&gt;
 797      *     Class.forName(i, false, loader)
 798      * &lt;/pre&gt;
 799      * where {@code loader} is the first class loader on the current
 800      * thread&#39;s stack (starting from the currently executing method) that is
 801      * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
 802      * class loader} nor its ancestor; otherwise, {@code loader} is the
 803      * &lt;em&gt;platform class loader&lt;/em&gt;.
 804      * Unless any of the resolved interfaces are non-public, this same value
 805      * of {@code loader} is also the class loader passed to
 806      * {@code Proxy.getProxyClass}; if non-public interfaces are present,
 807      * their class loader is passed instead (if more than one non-public
 808      * interface class loader is encountered, an
 809      * {@code IllegalAccessError} is thrown).
 810      * If {@code Proxy.getProxyClass} throws an
 811      * {@code IllegalArgumentException}, {@code resolveProxyClass}
 812      * will throw a {@code ClassNotFoundException} containing the
 813      * {@code IllegalArgumentException}.
 814      *
 815      * @param interfaces the list of interface names that were
 816      *                deserialized in the proxy class descriptor
 817      * @return  a proxy class for the specified interfaces
 818      * @throws        IOException any exception thrown by the underlying
 819      *                {@code InputStream}
 820      * @throws        ClassNotFoundException if the proxy class or any of the
 821      *                named interfaces could not be found
 822      * @see ObjectOutputStream#annotateProxyClass(Class)
 823      * @since 1.3
 824      */
 825     protected Class&lt;?&gt; resolveProxyClass(String[] interfaces)
 826         throws IOException, ClassNotFoundException
 827     {
 828         ClassLoader latestLoader = latestUserDefinedLoader();
 829         ClassLoader nonPublicLoader = null;
 830         boolean hasNonPublicInterface = false;
 831 
 832         // define proxy in class loader of non-public interface(s), if any
 833         Class&lt;?&gt;[] classObjs = new Class&lt;?&gt;[interfaces.length];
 834         for (int i = 0; i &lt; interfaces.length; i++) {
 835             Class&lt;?&gt; cl = Class.forName(interfaces[i], false, latestLoader);
 836             if ((cl.getModifiers() &amp; Modifier.PUBLIC) == 0) {
 837                 if (hasNonPublicInterface) {
 838                     if (nonPublicLoader != cl.getClassLoader()) {
 839                         throw new IllegalAccessError(
 840                             &quot;conflicting non-public interface class loaders&quot;);
 841                     }
 842                 } else {
 843                     nonPublicLoader = cl.getClassLoader();
 844                     hasNonPublicInterface = true;
 845                 }
 846             }
 847             classObjs[i] = cl;
 848         }
 849         try {
 850             @SuppressWarnings(&quot;deprecation&quot;)
 851             Class&lt;?&gt; proxyClass = Proxy.getProxyClass(
 852                 hasNonPublicInterface ? nonPublicLoader : latestLoader,
 853                 classObjs);
 854             return proxyClass;
 855         } catch (IllegalArgumentException e) {
 856             throw new ClassNotFoundException(null, e);
 857         }
 858     }
 859 
 860     /**
 861      * This method will allow trusted subclasses of ObjectInputStream to
 862      * substitute one object for another during deserialization. Replacing
 863      * objects is disabled until enableResolveObject is called. The
 864      * enableResolveObject method checks that the stream requesting to resolve
 865      * object can be trusted. Every reference to serializable objects is passed
 866      * to resolveObject.  To insure that the private state of objects is not
 867      * unintentionally exposed only trusted streams may use resolveObject.
 868      *
 869      * &lt;p&gt;This method is called after an object has been read but before it is
 870      * returned from readObject.  The default resolveObject method just returns
 871      * the same object.
 872      *
 873      * &lt;p&gt;When a subclass is replacing objects it must insure that the
 874      * substituted object is compatible with every field where the reference
 875      * will be stored.  Objects whose type is not a subclass of the type of the
 876      * field or array element abort the serialization by raising an exception
 877      * and the object is not be stored.
 878      *
 879      * &lt;p&gt;This method is called only once when each object is first
 880      * encountered.  All subsequent references to the object will be redirected
 881      * to the new object.
 882      *
 883      * @param   obj object to be substituted
 884      * @return  the substituted object
 885      * @throws  IOException Any of the usual Input/Output exceptions.
 886      */
 887     protected Object resolveObject(Object obj) throws IOException {
 888         return obj;
 889     }
 890 
 891     /**
 892      * Enables the stream to do replacement of objects read from the stream. When
 893      * enabled, the {@link #resolveObject} method is called for every object being
 894      * deserialized.
 895      *
 896      * &lt;p&gt;If object replacement is currently not enabled, and
 897      * {@code enable} is true, and there is a security manager installed,
 898      * this method first calls the security manager&#39;s
 899      * {@code checkPermission} method with the
 900      * {@code SerializablePermission(&quot;enableSubstitution&quot;)} permission to
 901      * ensure that the caller is permitted to enable the stream to do replacement
 902      * of objects read from the stream.
 903      *
 904      * @param   enable true for enabling use of {@code resolveObject} for
 905      *          every object being deserialized
 906      * @return  the previous setting before this method was invoked
 907      * @throws  SecurityException if a security manager exists and its
 908      *          {@code checkPermission} method denies enabling the stream
 909      *          to do replacement of objects read from the stream.
 910      * @see SecurityManager#checkPermission
 911      * @see java.io.SerializablePermission
 912      */
 913     protected boolean enableResolveObject(boolean enable)
 914         throws SecurityException
 915     {
 916         if (enable == enableResolve) {
 917             return enable;
 918         }
 919         if (enable) {
 920             SecurityManager sm = System.getSecurityManager();
 921             if (sm != null) {
 922                 sm.checkPermission(SUBSTITUTION_PERMISSION);
 923             }
 924         }
 925         enableResolve = enable;
 926         return !enableResolve;
 927     }
 928 
 929     /**
 930      * The readStreamHeader method is provided to allow subclasses to read and
 931      * verify their own stream headers. It reads and verifies the magic number
 932      * and version number.
 933      *
 934      * @throws  IOException if there are I/O errors while reading from the
 935      *          underlying {@code InputStream}
 936      * @throws  StreamCorruptedException if control information in the stream
 937      *          is inconsistent
 938      */
 939     protected void readStreamHeader()
 940         throws IOException, StreamCorruptedException
 941     {
 942         short s0 = bin.readShort();
 943         short s1 = bin.readShort();
 944         if (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) {
 945             throw new StreamCorruptedException(
 946                 String.format(&quot;invalid stream header: %04X%04X&quot;, s0, s1));
 947         }
 948     }
 949 
 950     /**
 951      * Read a class descriptor from the serialization stream.  This method is
 952      * called when the ObjectInputStream expects a class descriptor as the next
 953      * item in the serialization stream.  Subclasses of ObjectInputStream may
 954      * override this method to read in class descriptors that have been written
 955      * in non-standard formats (by subclasses of ObjectOutputStream which have
 956      * overridden the {@code writeClassDescriptor} method).  By default,
 957      * this method reads class descriptors according to the format defined in
 958      * the Object Serialization specification.
 959      *
 960      * @return  the class descriptor read
 961      * @throws  IOException If an I/O error has occurred.
 962      * @throws  ClassNotFoundException If the Class of a serialized object used
 963      *          in the class descriptor representation cannot be found
 964      * @see java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)
 965      * @since 1.3
 966      */
 967     protected ObjectStreamClass readClassDescriptor()
 968         throws IOException, ClassNotFoundException
 969     {
 970         ObjectStreamClass desc = new ObjectStreamClass();
 971         desc.readNonProxy(this);
 972         return desc;
 973     }
 974 
 975     /**
 976      * Reads a byte of data. This method will block if no input is available.
 977      *
 978      * @return  the byte read, or -1 if the end of the stream is reached.
 979      * @throws  IOException If an I/O error has occurred.
 980      */
 981     public int read() throws IOException {
 982         return bin.read();
 983     }
 984 
 985     /**
 986      * Reads into an array of bytes.  This method will block until some input
 987      * is available. Consider using java.io.DataInputStream.readFully to read
 988      * exactly &#39;length&#39; bytes.
 989      *
 990      * @param   buf the buffer into which the data is read
 991      * @param   off the start offset in the destination array {@code buf}
 992      * @param   len the maximum number of bytes read
 993      * @return  the actual number of bytes read, -1 is returned when the end of
 994      *          the stream is reached.
 995      * @throws  NullPointerException if {@code buf} is {@code null}.
 996      * @throws  IndexOutOfBoundsException if {@code off} is negative,
 997      *          {@code len} is negative, or {@code len} is greater than
 998      *          {@code buf.length - off}.
 999      * @throws  IOException If an I/O error has occurred.
1000      * @see java.io.DataInputStream#readFully(byte[],int,int)
1001      */
1002     public int read(byte[] buf, int off, int len) throws IOException {
1003         if (buf == null) {
1004             throw new NullPointerException();
1005         }
1006         int endoff = off + len;
1007         if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {
1008             throw new IndexOutOfBoundsException();
1009         }
1010         return bin.read(buf, off, len, false);
1011     }
1012 
1013     /**
1014      * Returns the number of bytes that can be read without blocking.
1015      *
1016      * @return  the number of available bytes.
1017      * @throws  IOException if there are I/O errors while reading from the
1018      *          underlying {@code InputStream}
1019      */
1020     public int available() throws IOException {
1021         return bin.available();
1022     }
1023 
1024     /**
1025      * Closes the input stream. Must be called to release any resources
1026      * associated with the stream.
1027      *
1028      * @throws  IOException If an I/O error has occurred.
1029      */
1030     public void close() throws IOException {
1031         /*
1032          * Even if stream already closed, propagate redundant close to
1033          * underlying stream to stay consistent with previous implementations.
1034          */
1035         closed = true;
1036         if (depth == 0) {
1037             clear();
1038         }
1039         bin.close();
1040     }
1041 
1042     /**
1043      * Reads in a boolean.
1044      *
1045      * @return  the boolean read.
1046      * @throws  EOFException If end of file is reached.
1047      * @throws  IOException If other I/O error has occurred.
1048      */
1049     public boolean readBoolean() throws IOException {
1050         return bin.readBoolean();
1051     }
1052 
1053     /**
1054      * Reads an 8 bit byte.
1055      *
1056      * @return  the 8 bit byte read.
1057      * @throws  EOFException If end of file is reached.
1058      * @throws  IOException If other I/O error has occurred.
1059      */
1060     public byte readByte() throws IOException  {
1061         return bin.readByte();
1062     }
1063 
1064     /**
1065      * Reads an unsigned 8 bit byte.
1066      *
1067      * @return  the 8 bit byte read.
1068      * @throws  EOFException If end of file is reached.
1069      * @throws  IOException If other I/O error has occurred.
1070      */
1071     public int readUnsignedByte()  throws IOException {
1072         return bin.readUnsignedByte();
1073     }
1074 
1075     /**
1076      * Reads a 16 bit char.
1077      *
1078      * @return  the 16 bit char read.
1079      * @throws  EOFException If end of file is reached.
1080      * @throws  IOException If other I/O error has occurred.
1081      */
1082     public char readChar()  throws IOException {
1083         return bin.readChar();
1084     }
1085 
1086     /**
1087      * Reads a 16 bit short.
1088      *
1089      * @return  the 16 bit short read.
1090      * @throws  EOFException If end of file is reached.
1091      * @throws  IOException If other I/O error has occurred.
1092      */
1093     public short readShort()  throws IOException {
1094         return bin.readShort();
1095     }
1096 
1097     /**
1098      * Reads an unsigned 16 bit short.
1099      *
1100      * @return  the 16 bit short read.
1101      * @throws  EOFException If end of file is reached.
1102      * @throws  IOException If other I/O error has occurred.
1103      */
1104     public int readUnsignedShort() throws IOException {
1105         return bin.readUnsignedShort();
1106     }
1107 
1108     /**
1109      * Reads a 32 bit int.
1110      *
1111      * @return  the 32 bit integer read.
1112      * @throws  EOFException If end of file is reached.
1113      * @throws  IOException If other I/O error has occurred.
1114      */
1115     public int readInt()  throws IOException {
1116         return bin.readInt();
1117     }
1118 
1119     /**
1120      * Reads a 64 bit long.
1121      *
1122      * @return  the read 64 bit long.
1123      * @throws  EOFException If end of file is reached.
1124      * @throws  IOException If other I/O error has occurred.
1125      */
1126     public long readLong()  throws IOException {
1127         return bin.readLong();
1128     }
1129 
1130     /**
1131      * Reads a 32 bit float.
1132      *
1133      * @return  the 32 bit float read.
1134      * @throws  EOFException If end of file is reached.
1135      * @throws  IOException If other I/O error has occurred.
1136      */
1137     public float readFloat() throws IOException {
1138         return bin.readFloat();
1139     }
1140 
1141     /**
1142      * Reads a 64 bit double.
1143      *
1144      * @return  the 64 bit double read.
1145      * @throws  EOFException If end of file is reached.
1146      * @throws  IOException If other I/O error has occurred.
1147      */
1148     public double readDouble() throws IOException {
1149         return bin.readDouble();
1150     }
1151 
1152     /**
1153      * Reads bytes, blocking until all bytes are read.
1154      *
1155      * @param   buf the buffer into which the data is read
1156      * @throws  NullPointerException If {@code buf} is {@code null}.
1157      * @throws  EOFException If end of file is reached.
1158      * @throws  IOException If other I/O error has occurred.
1159      */
1160     public void readFully(byte[] buf) throws IOException {
1161         bin.readFully(buf, 0, buf.length, false);
1162     }
1163 
1164     /**
1165      * Reads bytes, blocking until all bytes are read.
1166      *
1167      * @param   buf the buffer into which the data is read
1168      * @param   off the start offset into the data array {@code buf}
1169      * @param   len the maximum number of bytes to read
1170      * @throws  NullPointerException If {@code buf} is {@code null}.
1171      * @throws  IndexOutOfBoundsException If {@code off} is negative,
1172      *          {@code len} is negative, or {@code len} is greater than
1173      *          {@code buf.length - off}.
1174      * @throws  EOFException If end of file is reached.
1175      * @throws  IOException If other I/O error has occurred.
1176      */
1177     public void readFully(byte[] buf, int off, int len) throws IOException {
1178         int endoff = off + len;
1179         if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {
1180             throw new IndexOutOfBoundsException();
1181         }
1182         bin.readFully(buf, off, len, false);
1183     }
1184 
1185     /**
1186      * Skips bytes.
1187      *
1188      * @param   len the number of bytes to be skipped
1189      * @return  the actual number of bytes skipped.
1190      * @throws  IOException If an I/O error has occurred.
1191      */
1192     public int skipBytes(int len) throws IOException {
1193         return bin.skipBytes(len);
1194     }
1195 
1196     /**
1197      * Reads in a line that has been terminated by a \n, \r, \r\n or EOF.
1198      *
1199      * @return  a String copy of the line.
1200      * @throws  IOException if there are I/O errors while reading from the
1201      *          underlying {@code InputStream}
1202      * @deprecated This method does not properly convert bytes to characters.
1203      *          see DataInputStream for the details and alternatives.
1204      */
1205     @Deprecated
1206     public String readLine() throws IOException {
1207         return bin.readLine();
1208     }
1209 
1210     /**
1211      * Reads a String in
1212      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
1213      * format.
1214      *
1215      * @return  the String.
1216      * @throws  IOException if there are I/O errors while reading from the
1217      *          underlying {@code InputStream}
1218      * @throws  UTFDataFormatException if read bytes do not represent a valid
1219      *          modified UTF-8 encoding of a string
1220      */
1221     public String readUTF() throws IOException {
1222         return bin.readUTF();
1223     }
1224 
1225     /**
1226      * Returns the serialization filter for this stream.
1227      * The serialization filter is the most recent filter set in
1228      * {@link #setObjectInputFilter setObjectInputFilter} or
1229      * the initial system-wide filter from
1230      * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}.
1231      *
1232      * @return the serialization filter for the stream; may be null
1233      * @since 9
1234      */
1235     public final ObjectInputFilter getObjectInputFilter() {
1236         return serialFilter;
1237     }
1238 
1239     /**
1240      * Set the serialization filter for the stream.
1241      * The filter&#39;s {@link ObjectInputFilter#checkInput checkInput} method is called
1242      * for each class and reference in the stream.
1243      * The filter can check any or all of the class, the array length, the number
1244      * of references, the depth of the graph, and the size of the input stream.
1245      * The depth is the number of nested {@linkplain #readObject readObject}
1246      * calls starting with the reading of the root of the graph being deserialized
1247      * and the current object being deserialized.
1248      * The number of references is the cumulative number of objects and references
1249      * to objects already read from the stream including the current object being read.
1250      * The filter is invoked only when reading objects from the stream and for
1251      * not primitives.
1252      * &lt;p&gt;
1253      * If the filter returns {@link ObjectInputFilter.Status#REJECTED Status.REJECTED},
1254      * {@code null} or throws a {@link RuntimeException},
1255      * the active {@code readObject} or {@code readUnshared}
1256      * throws {@link InvalidClassException}, otherwise deserialization
1257      * continues uninterrupted.
1258      * &lt;p&gt;
1259      * The serialization filter is initialized to the value of
1260      * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}
1261      * when the {@code  ObjectInputStream} is constructed and can be set
1262      * to a custom filter only once.
1263      *
1264      * @implSpec
1265      * The filter, when not {@code null}, is invoked during {@link #readObject readObject}
1266      * and {@link #readUnshared readUnshared} for each object (regular or class) in the stream.
1267      * Strings are treated as primitives and do not invoke the filter.
1268      * The filter is called for:
1269      * &lt;ul&gt;
1270      *     &lt;li&gt;each object reference previously deserialized from the stream
1271      *     (class is {@code null}, arrayLength is -1),
1272      *     &lt;li&gt;each regular class (class is not {@code null}, arrayLength is -1),
1273      *     &lt;li&gt;each interface of a dynamic proxy and the dynamic proxy class itself
1274      *     (class is not {@code null}, arrayLength is -1),
1275      *     &lt;li&gt;each array is filtered using the array type and length of the array
1276      *     (class is the array type, arrayLength is the requested length),
1277      *     &lt;li&gt;each object replaced by its class&#39; {@code readResolve} method
1278      *         is filtered using the replacement object&#39;s class, if not {@code null},
1279      *         and if it is an array, the arrayLength, otherwise -1,
1280      *     &lt;li&gt;and each object replaced by {@link #resolveObject resolveObject}
1281      *         is filtered using the replacement object&#39;s class, if not {@code null},
1282      *         and if it is an array, the arrayLength, otherwise -1.
1283      * &lt;/ul&gt;
1284      *
1285      * When the {@link ObjectInputFilter#checkInput checkInput} method is invoked
1286      * it is given access to the current class, the array length,
1287      * the current number of references already read from the stream,
1288      * the depth of nested calls to {@link #readObject readObject} or
1289      * {@link #readUnshared readUnshared},
1290      * and the implementation dependent number of bytes consumed from the input stream.
1291      * &lt;p&gt;
1292      * Each call to {@link #readObject readObject} or
1293      * {@link #readUnshared readUnshared} increases the depth by 1
1294      * before reading an object and decreases by 1 before returning
1295      * normally or exceptionally.
1296      * The depth starts at {@code 1} and increases for each nested object and
1297      * decrements when each nested call returns.
1298      * The count of references in the stream starts at {@code 1} and
1299      * is increased before reading an object.
1300      *
1301      * @param filter the filter, may be null
1302      * @throws SecurityException if there is security manager and the
1303      *       {@code SerializablePermission(&quot;serialFilter&quot;)} is not granted
1304      * @throws IllegalStateException if the {@linkplain #getObjectInputFilter() current filter}
1305      *       is not {@code null} and is not the system-wide filter
1306      * @since 9
1307      */
1308     public final void setObjectInputFilter(ObjectInputFilter filter) {
1309         SecurityManager sm = System.getSecurityManager();
1310         if (sm != null) {
1311             sm.checkPermission(ObjectStreamConstants.SERIAL_FILTER_PERMISSION);
1312         }
1313         // Allow replacement of the system-wide filter if not already set
1314         if (serialFilter != null &amp;&amp;
1315                 serialFilter != ObjectInputFilter.Config.getSerialFilter()) {
1316             throw new IllegalStateException(&quot;filter can not be set more than once&quot;);
1317         }
1318         this.serialFilter = filter;
1319     }
1320 
1321     /**
1322      * Invoke the serialization filter if non-null.
1323      * If the filter rejects or an exception is thrown, throws InvalidClassException.
1324      *
1325      * @param clazz the class; may be null
1326      * @param arrayLength the array length requested; use {@code -1} if not creating an array
1327      * @throws InvalidClassException if it rejected by the filter or
1328      *        a {@link RuntimeException} is thrown
1329      */
1330     private void filterCheck(Class&lt;?&gt; clazz, int arrayLength)
1331             throws InvalidClassException {
1332         if (serialFilter != null) {
1333             RuntimeException ex = null;
1334             ObjectInputFilter.Status status;
1335             // Info about the stream is not available if overridden by subclass, return 0
1336             long bytesRead = (bin == null) ? 0 : bin.getBytesRead();
1337             try {
1338                 status = serialFilter.checkInput(new FilterValues(clazz, arrayLength,
1339                         totalObjectRefs, depth, bytesRead));
1340             } catch (RuntimeException e) {
1341                 // Preventive interception of an exception to log
1342                 status = ObjectInputFilter.Status.REJECTED;
1343                 ex = e;
1344             }
1345             if (Logging.filterLogger != null) {
1346                 // Debug logging of filter checks that fail; Tracing for those that succeed
1347                 Logging.filterLogger.log(status == null || status == ObjectInputFilter.Status.REJECTED
1348                                 ? Logger.Level.DEBUG
1349                                 : Logger.Level.TRACE,
1350                         &quot;ObjectInputFilter {0}: {1}, array length: {2}, nRefs: {3}, depth: {4}, bytes: {5}, ex: {6}&quot;,
1351                         status, clazz, arrayLength, totalObjectRefs, depth, bytesRead,
1352                         Objects.toString(ex, &quot;n/a&quot;));
1353             }
1354             if (status == null ||
1355                     status == ObjectInputFilter.Status.REJECTED) {
1356                 InvalidClassException ice = new InvalidClassException(&quot;filter status: &quot; + status);
1357                 ice.initCause(ex);
1358                 throw ice;
1359             }
1360         }
1361     }
1362 
1363     /**
1364      * Checks the given array type and length to ensure that creation of such
1365      * an array is permitted by this ObjectInputStream. The arrayType argument
1366      * must represent an actual array type.
1367      *
1368      * This private method is called via SharedSecrets.
1369      *
1370      * @param arrayType the array type
1371      * @param arrayLength the array length
1372      * @throws NullPointerException if arrayType is null
1373      * @throws IllegalArgumentException if arrayType isn&#39;t actually an array type
1374      * @throws NegativeArraySizeException if arrayLength is negative
1375      * @throws InvalidClassException if the filter rejects creation
1376      */
1377     private void checkArray(Class&lt;?&gt; arrayType, int arrayLength) throws InvalidClassException {
1378         if (! arrayType.isArray()) {
1379             throw new IllegalArgumentException(&quot;not an array type&quot;);
1380         }
1381 
1382         if (arrayLength &lt; 0) {
1383             throw new NegativeArraySizeException();
1384         }
1385 
1386         filterCheck(arrayType, arrayLength);
1387     }
1388 
1389     /**
1390      * Provide access to the persistent fields read from the input stream.
1391      */
1392     public abstract static class GetField {
1393         /**
1394          * Constructor for subclasses to call.
1395          */
1396         public GetField() {}
1397 
1398         /**
1399          * Get the ObjectStreamClass that describes the fields in the stream.
1400          *
1401          * @return  the descriptor class that describes the serializable fields
1402          */
1403         public abstract ObjectStreamClass getObjectStreamClass();
1404 
1405         /**
1406          * Return true if the named field is defaulted and has no value in this
1407          * stream.
1408          *
1409          * @param  name the name of the field
1410          * @return true, if and only if the named field is defaulted
1411          * @throws IOException if there are I/O errors while reading from
1412          *         the underlying {@code InputStream}
1413          * @throws IllegalArgumentException if {@code name} does not
1414          *         correspond to a serializable field
1415          */
1416         public abstract boolean defaulted(String name) throws IOException;
1417 
1418         /**
1419          * Get the value of the named boolean field from the persistent field.
1420          *
1421          * @param  name the name of the field
1422          * @param  val the default value to use if {@code name} does not
1423          *         have a value
1424          * @return the value of the named {@code boolean} field
1425          * @throws IOException if there are I/O errors while reading from the
1426          *         underlying {@code InputStream}
1427          * @throws IllegalArgumentException if type of {@code name} is
1428          *         not serializable or if the field type is incorrect
1429          */
1430         public abstract boolean get(String name, boolean val)
1431             throws IOException;
1432 
1433         /**
1434          * Get the value of the named byte field from the persistent field.
1435          *
1436          * @param  name the name of the field
1437          * @param  val the default value to use if {@code name} does not
1438          *         have a value
1439          * @return the value of the named {@code byte} field
1440          * @throws IOException if there are I/O errors while reading from the
1441          *         underlying {@code InputStream}
1442          * @throws IllegalArgumentException if type of {@code name} is
1443          *         not serializable or if the field type is incorrect
1444          */
1445         public abstract byte get(String name, byte val) throws IOException;
1446 
1447         /**
1448          * Get the value of the named char field from the persistent field.
1449          *
1450          * @param  name the name of the field
1451          * @param  val the default value to use if {@code name} does not
1452          *         have a value
1453          * @return the value of the named {@code char} field
1454          * @throws IOException if there are I/O errors while reading from the
1455          *         underlying {@code InputStream}
1456          * @throws IllegalArgumentException if type of {@code name} is
1457          *         not serializable or if the field type is incorrect
1458          */
1459         public abstract char get(String name, char val) throws IOException;
1460 
1461         /**
1462          * Get the value of the named short field from the persistent field.
1463          *
1464          * @param  name the name of the field
1465          * @param  val the default value to use if {@code name} does not
1466          *         have a value
1467          * @return the value of the named {@code short} field
1468          * @throws IOException if there are I/O errors while reading from the
1469          *         underlying {@code InputStream}
1470          * @throws IllegalArgumentException if type of {@code name} is
1471          *         not serializable or if the field type is incorrect
1472          */
1473         public abstract short get(String name, short val) throws IOException;
1474 
1475         /**
1476          * Get the value of the named int field from the persistent field.
1477          *
1478          * @param  name the name of the field
1479          * @param  val the default value to use if {@code name} does not
1480          *         have a value
1481          * @return the value of the named {@code int} field
1482          * @throws IOException if there are I/O errors while reading from the
1483          *         underlying {@code InputStream}
1484          * @throws IllegalArgumentException if type of {@code name} is
1485          *         not serializable or if the field type is incorrect
1486          */
1487         public abstract int get(String name, int val) throws IOException;
1488 
1489         /**
1490          * Get the value of the named long field from the persistent field.
1491          *
1492          * @param  name the name of the field
1493          * @param  val the default value to use if {@code name} does not
1494          *         have a value
1495          * @return the value of the named {@code long} field
1496          * @throws IOException if there are I/O errors while reading from the
1497          *         underlying {@code InputStream}
1498          * @throws IllegalArgumentException if type of {@code name} is
1499          *         not serializable or if the field type is incorrect
1500          */
1501         public abstract long get(String name, long val) throws IOException;
1502 
1503         /**
1504          * Get the value of the named float field from the persistent field.
1505          *
1506          * @param  name the name of the field
1507          * @param  val the default value to use if {@code name} does not
1508          *         have a value
1509          * @return the value of the named {@code float} field
1510          * @throws IOException if there are I/O errors while reading from the
1511          *         underlying {@code InputStream}
1512          * @throws IllegalArgumentException if type of {@code name} is
1513          *         not serializable or if the field type is incorrect
1514          */
1515         public abstract float get(String name, float val) throws IOException;
1516 
1517         /**
1518          * Get the value of the named double field from the persistent field.
1519          *
1520          * @param  name the name of the field
1521          * @param  val the default value to use if {@code name} does not
1522          *         have a value
1523          * @return the value of the named {@code double} field
1524          * @throws IOException if there are I/O errors while reading from the
1525          *         underlying {@code InputStream}
1526          * @throws IllegalArgumentException if type of {@code name} is
1527          *         not serializable or if the field type is incorrect
1528          */
1529         public abstract double get(String name, double val) throws IOException;
1530 
1531         /**
1532          * Get the value of the named Object field from the persistent field.
1533          *
1534          * @param  name the name of the field
1535          * @param  val the default value to use if {@code name} does not
1536          *         have a value
1537          * @return the value of the named {@code Object} field
1538          * @throws IOException if there are I/O errors while reading from the
1539          *         underlying {@code InputStream}
1540          * @throws IllegalArgumentException if type of {@code name} is
1541          *         not serializable or if the field type is incorrect
1542          */
1543         public abstract Object get(String name, Object val) throws IOException;
1544     }
1545 
1546     /**
1547      * Verifies that this (possibly subclass) instance can be constructed
1548      * without violating security constraints: the subclass must not override
1549      * security-sensitive non-final methods, or else the
1550      * &quot;enableSubclassImplementation&quot; SerializablePermission is checked.
1551      */
1552     private void verifySubclass() {
1553         Class&lt;?&gt; cl = getClass();
1554         if (cl == ObjectInputStream.class) {
1555             return;
1556         }
1557         SecurityManager sm = System.getSecurityManager();
1558         if (sm == null) {
1559             return;
1560         }
1561         processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);
1562         WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);
1563         Boolean result = Caches.subclassAudits.get(key);
1564         if (result == null) {
1565             result = auditSubclass(cl);
1566             Caches.subclassAudits.putIfAbsent(key, result);
1567         }
1568         if (!result) {
1569             sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
1570         }
1571     }
1572 
1573     /**
1574      * Performs reflective checks on given subclass to verify that it doesn&#39;t
1575      * override security-sensitive non-final methods.  Returns TRUE if subclass
1576      * is &quot;safe&quot;, FALSE otherwise.
1577      */
1578     private static Boolean auditSubclass(Class&lt;?&gt; subcl) {
1579         return AccessController.doPrivileged(
1580             new PrivilegedAction&lt;Boolean&gt;() {
1581                 public Boolean run() {
1582                     for (Class&lt;?&gt; cl = subcl;
1583                          cl != ObjectInputStream.class;
1584                          cl = cl.getSuperclass())
1585                     {
1586                         try {
1587                             cl.getDeclaredMethod(
1588                                 &quot;readUnshared&quot;, (Class[]) null);
1589                             return Boolean.FALSE;
1590                         } catch (NoSuchMethodException ex) {
1591                         }
1592                         try {
1593                             cl.getDeclaredMethod(&quot;readFields&quot;, (Class[]) null);
1594                             return Boolean.FALSE;
1595                         } catch (NoSuchMethodException ex) {
1596                         }
1597                     }
1598                     return Boolean.TRUE;
1599                 }
1600             }
1601         );
1602     }
1603 
1604     /**
1605      * Clears internal data structures.
1606      */
1607     private void clear() {
1608         handles.clear();
1609         vlist.clear();
1610     }
1611 
1612     /**
1613      * Underlying readObject implementation.
1614      * @param type a type expected to be deserialized; non-null
1615      * @param unshared true if the object can not be a reference to a shared object, otherwise false
1616      */
1617     private Object readObject0(Class&lt;?&gt; type, boolean unshared) throws IOException {
1618         boolean oldMode = bin.getBlockDataMode();
1619         if (oldMode) {
1620             int remain = bin.currentBlockRemaining();
1621             if (remain &gt; 0) {
1622                 throw new OptionalDataException(remain);
1623             } else if (defaultDataEnd) {
1624                 /*
1625                  * Fix for 4360508: stream is currently at the end of a field
1626                  * value block written via default serialization; since there
1627                  * is no terminating TC_ENDBLOCKDATA tag, simulate
1628                  * end-of-custom-data behavior explicitly.
1629                  */
1630                 throw new OptionalDataException(true);
1631             }
1632             bin.setBlockDataMode(false);
1633         }
1634 
1635         byte tc;
1636         while ((tc = bin.peekByte()) == TC_RESET) {
1637             bin.readByte();
1638             handleReset();
1639         }
1640 
1641         depth++;
1642         totalObjectRefs++;
1643         try {
1644             switch (tc) {
1645                 case TC_NULL:
1646                     return readNull();
1647 
1648                 case TC_REFERENCE:
1649                     // check the type of the existing object
1650                     return type.cast(readHandle(unshared));
1651 
1652                 case TC_CLASS:
1653                     if (type == String.class) {
1654                         throw new ClassCastException(&quot;Cannot cast a class to java.lang.String&quot;);
1655                     }
1656                     return readClass(unshared);
1657 
1658                 case TC_CLASSDESC:
1659                 case TC_PROXYCLASSDESC:
1660                     if (type == String.class) {
1661                         throw new ClassCastException(&quot;Cannot cast a class to java.lang.String&quot;);
1662                     }
1663                     return readClassDesc(unshared);
1664 
1665                 case TC_STRING:
1666                 case TC_LONGSTRING:
1667                     return checkResolve(readString(unshared));
1668 
1669                 case TC_ARRAY:
1670                     if (type == String.class) {
1671                         throw new ClassCastException(&quot;Cannot cast an array to java.lang.String&quot;);
1672                     }
1673                     return checkResolve(readArray(unshared));
1674 
1675                 case TC_ENUM:
1676                     if (type == String.class) {
1677                         throw new ClassCastException(&quot;Cannot cast an enum to java.lang.String&quot;);
1678                     }
1679                     return checkResolve(readEnum(unshared));
1680 
1681                 case TC_OBJECT:
1682                     if (type == String.class) {
1683                         throw new ClassCastException(&quot;Cannot cast an object to java.lang.String&quot;);
1684                     }
1685                     return checkResolve(readOrdinaryObject(unshared));
1686 
1687                 case TC_EXCEPTION:
1688                     if (type == String.class) {
1689                         throw new ClassCastException(&quot;Cannot cast an exception to java.lang.String&quot;);
1690                     }
1691                     IOException ex = readFatalException();
1692                     throw new WriteAbortedException(&quot;writing aborted&quot;, ex);
1693 
1694                 case TC_BLOCKDATA:
1695                 case TC_BLOCKDATALONG:
1696                     if (oldMode) {
1697                         bin.setBlockDataMode(true);
1698                         bin.peek();             // force header read
1699                         throw new OptionalDataException(
1700                             bin.currentBlockRemaining());
1701                     } else {
1702                         throw new StreamCorruptedException(
1703                             &quot;unexpected block data&quot;);
1704                     }
1705 
1706                 case TC_ENDBLOCKDATA:
1707                     if (oldMode) {
1708                         throw new OptionalDataException(true);
1709                     } else {
1710                         throw new StreamCorruptedException(
1711                             &quot;unexpected end of block data&quot;);
1712                     }
1713 
1714                 default:
1715                     throw new StreamCorruptedException(
1716                         String.format(&quot;invalid type code: %02X&quot;, tc));
1717             }
1718         } finally {
1719             depth--;
1720             bin.setBlockDataMode(oldMode);
1721         }
1722     }
1723 
1724     /**
1725      * If resolveObject has been enabled and given object does not have an
1726      * exception associated with it, calls resolveObject to determine
1727      * replacement for object, and updates handle table accordingly.  Returns
1728      * replacement object, or echoes provided object if no replacement
1729      * occurred.  Expects that passHandle is set to given object&#39;s handle prior
1730      * to calling this method.
1731      */
1732     private Object checkResolve(Object obj) throws IOException {
1733         if (!enableResolve || handles.lookupException(passHandle) != null) {
1734             return obj;
1735         }
1736         Object rep = resolveObject(obj);
1737         if (rep != obj) {
1738             // The type of the original object has been filtered but resolveObject
1739             // may have replaced it;  filter the replacement&#39;s type
1740             if (rep != null) {
1741                 if (rep.getClass().isArray()) {
1742                     filterCheck(rep.getClass(), Array.getLength(rep));
1743                 } else {
1744                     filterCheck(rep.getClass(), -1);
1745                 }
1746             }
1747             handles.setObject(passHandle, rep);
1748         }
1749         return rep;
1750     }
1751 
1752     /**
1753      * Reads string without allowing it to be replaced in stream.  Called from
1754      * within ObjectStreamClass.read().
1755      */
1756     String readTypeString() throws IOException {
1757         int oldHandle = passHandle;
1758         try {
1759             byte tc = bin.peekByte();
1760             switch (tc) {
1761                 case TC_NULL:
1762                     return (String) readNull();
1763 
1764                 case TC_REFERENCE:
1765                     return (String) readHandle(false);
1766 
1767                 case TC_STRING:
1768                 case TC_LONGSTRING:
1769                     return readString(false);
1770 
1771                 default:
1772                     throw new StreamCorruptedException(
1773                         String.format(&quot;invalid type code: %02X&quot;, tc));
1774             }
1775         } finally {
1776             passHandle = oldHandle;
1777         }
1778     }
1779 
1780     /**
1781      * Reads in null code, sets passHandle to NULL_HANDLE and returns null.
1782      */
1783     private Object readNull() throws IOException {
1784         if (bin.readByte() != TC_NULL) {
1785             throw new InternalError();
1786         }
1787         passHandle = NULL_HANDLE;
1788         return null;
1789     }
1790 
1791     /**
1792      * Reads in object handle, sets passHandle to the read handle, and returns
1793      * object associated with the handle.
1794      */
1795     private Object readHandle(boolean unshared) throws IOException {
1796         if (bin.readByte() != TC_REFERENCE) {
1797             throw new InternalError();
1798         }
1799         passHandle = bin.readInt() - baseWireHandle;
1800         if (passHandle &lt; 0 || passHandle &gt;= handles.size()) {
1801             throw new StreamCorruptedException(
1802                 String.format(&quot;invalid handle value: %08X&quot;, passHandle +
1803                 baseWireHandle));
1804         }
1805         if (unshared) {
1806             // REMIND: what type of exception to throw here?
1807             throw new InvalidObjectException(
1808                 &quot;cannot read back reference as unshared&quot;);
1809         }
1810 
1811         Object obj = handles.lookupObject(passHandle);
1812         if (obj == unsharedMarker) {
1813             // REMIND: what type of exception to throw here?
1814             throw new InvalidObjectException(
1815                 &quot;cannot read back reference to unshared object&quot;);
1816         }
1817         filterCheck(null, -1);       // just a check for number of references, depth, no class
1818         return obj;
1819     }
1820 
1821     /**
1822      * Reads in and returns class object.  Sets passHandle to class object&#39;s
1823      * assigned handle.  Returns null if class is unresolvable (in which case a
1824      * ClassNotFoundException will be associated with the class&#39; handle in the
1825      * handle table).
1826      */
1827     private Class&lt;?&gt; readClass(boolean unshared) throws IOException {
1828         if (bin.readByte() != TC_CLASS) {
1829             throw new InternalError();
1830         }
1831         ObjectStreamClass desc = readClassDesc(false);
1832         Class&lt;?&gt; cl = desc.forClass();
1833         passHandle = handles.assign(unshared ? unsharedMarker : cl);
1834 
1835         ClassNotFoundException resolveEx = desc.getResolveException();
1836         if (resolveEx != null) {
1837             handles.markException(passHandle, resolveEx);
1838         }
1839 
1840         handles.finish(passHandle);
1841         return cl;
1842     }
1843 
1844     /**
1845      * Reads in and returns (possibly null) class descriptor.  Sets passHandle
1846      * to class descriptor&#39;s assigned handle.  If class descriptor cannot be
1847      * resolved to a class in the local VM, a ClassNotFoundException is
1848      * associated with the class descriptor&#39;s handle.
1849      */
1850     private ObjectStreamClass readClassDesc(boolean unshared)
1851         throws IOException
1852     {
1853         byte tc = bin.peekByte();
1854         ObjectStreamClass descriptor;
1855         switch (tc) {
1856             case TC_NULL:
1857                 descriptor = (ObjectStreamClass) readNull();
1858                 break;
1859             case TC_REFERENCE:
1860                 descriptor = (ObjectStreamClass) readHandle(unshared);
1861                 break;
1862             case TC_PROXYCLASSDESC:
1863                 descriptor = readProxyDesc(unshared);
1864                 break;
1865             case TC_CLASSDESC:
1866                 descriptor = readNonProxyDesc(unshared);
1867                 break;
1868             default:
1869                 throw new StreamCorruptedException(
1870                     String.format(&quot;invalid type code: %02X&quot;, tc));
1871         }
1872         return descriptor;
1873     }
1874 
1875     private boolean isCustomSubclass() {
1876         // Return true if this class is a custom subclass of ObjectInputStream
1877         return getClass().getClassLoader()
1878                     != ObjectInputStream.class.getClassLoader();
1879     }
1880 
1881     /**
1882      * Reads in and returns class descriptor for a dynamic proxy class.  Sets
1883      * passHandle to proxy class descriptor&#39;s assigned handle.  If proxy class
1884      * descriptor cannot be resolved to a class in the local VM, a
1885      * ClassNotFoundException is associated with the descriptor&#39;s handle.
1886      */
1887     private ObjectStreamClass readProxyDesc(boolean unshared)
1888         throws IOException
1889     {
1890         if (bin.readByte() != TC_PROXYCLASSDESC) {
1891             throw new InternalError();
1892         }
1893 
1894         ObjectStreamClass desc = new ObjectStreamClass();
1895         int descHandle = handles.assign(unshared ? unsharedMarker : desc);
1896         passHandle = NULL_HANDLE;
1897 
1898         int numIfaces = bin.readInt();
1899         if (numIfaces &gt; 65535) {
1900             throw new InvalidObjectException(&quot;interface limit exceeded: &quot;
1901                     + numIfaces);
1902         }
1903         String[] ifaces = new String[numIfaces];
1904         for (int i = 0; i &lt; numIfaces; i++) {
1905             ifaces[i] = bin.readUTF();
1906         }
1907 
1908         Class&lt;?&gt; cl = null;
1909         ClassNotFoundException resolveEx = null;
1910         bin.setBlockDataMode(true);
1911         try {
1912             if ((cl = resolveProxyClass(ifaces)) == null) {
1913                 resolveEx = new ClassNotFoundException(&quot;null class&quot;);
1914             } else if (!Proxy.isProxyClass(cl)) {
1915                 throw new InvalidClassException(&quot;Not a proxy&quot;);
1916             } else {
1917                 // ReflectUtil.checkProxyPackageAccess makes a test
1918                 // equivalent to isCustomSubclass so there&#39;s no need
1919                 // to condition this call to isCustomSubclass == true here.
1920                 ReflectUtil.checkProxyPackageAccess(
1921                         getClass().getClassLoader(),
1922                         cl.getInterfaces());
1923                 // Filter the interfaces
1924                 for (Class&lt;?&gt; clazz : cl.getInterfaces()) {
1925                     filterCheck(clazz, -1);
1926                 }
1927             }
1928         } catch (ClassNotFoundException ex) {
1929             resolveEx = ex;
1930         }
1931 
1932         // Call filterCheck on the class before reading anything else
1933         filterCheck(cl, -1);
1934 
1935         skipCustomData();
1936 
1937         try {
1938             totalObjectRefs++;
1939             depth++;
1940             desc.initProxy(cl, resolveEx, readClassDesc(false));
1941         } finally {
1942             depth--;
1943         }
1944 
1945         handles.finish(descHandle);
1946         passHandle = descHandle;
1947         return desc;
1948     }
1949 
1950     /**
1951      * Reads in and returns class descriptor for a class that is not a dynamic
1952      * proxy class.  Sets passHandle to class descriptor&#39;s assigned handle.  If
1953      * class descriptor cannot be resolved to a class in the local VM, a
1954      * ClassNotFoundException is associated with the descriptor&#39;s handle.
1955      */
1956     private ObjectStreamClass readNonProxyDesc(boolean unshared)
1957         throws IOException
1958     {
1959         if (bin.readByte() != TC_CLASSDESC) {
1960             throw new InternalError();
1961         }
1962 
1963         ObjectStreamClass desc = new ObjectStreamClass();
1964         int descHandle = handles.assign(unshared ? unsharedMarker : desc);
1965         passHandle = NULL_HANDLE;
1966 
1967         ObjectStreamClass readDesc;
1968         try {
1969             readDesc = readClassDescriptor();
1970         } catch (ClassNotFoundException ex) {
1971             throw (IOException) new InvalidClassException(
1972                 &quot;failed to read class descriptor&quot;).initCause(ex);
1973         }
1974 
1975         Class&lt;?&gt; cl = null;
1976         ClassNotFoundException resolveEx = null;
1977         bin.setBlockDataMode(true);
1978         final boolean checksRequired = isCustomSubclass();
1979         try {
1980             if ((cl = resolveClass(readDesc)) == null) {
1981                 resolveEx = new ClassNotFoundException(&quot;null class&quot;);
1982             } else if (checksRequired) {
1983                 ReflectUtil.checkPackageAccess(cl);
1984             }
1985         } catch (ClassNotFoundException ex) {
1986             resolveEx = ex;
1987         }
1988 
1989         // Call filterCheck on the class before reading anything else
1990         filterCheck(cl, -1);
1991 
1992         skipCustomData();
1993 
1994         try {
1995             totalObjectRefs++;
1996             depth++;
1997             desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));
1998         } finally {
1999             depth--;
2000         }
2001 
2002         handles.finish(descHandle);
2003         passHandle = descHandle;
2004 
2005         return desc;
2006     }
2007 
2008     /**
2009      * Reads in and returns new string.  Sets passHandle to new string&#39;s
2010      * assigned handle.
2011      */
2012     private String readString(boolean unshared) throws IOException {
2013         String str;
2014         byte tc = bin.readByte();
2015         switch (tc) {
2016             case TC_STRING:
2017                 str = bin.readUTF();
2018                 break;
2019 
2020             case TC_LONGSTRING:
2021                 str = bin.readLongUTF();
2022                 break;
2023 
2024             default:
2025                 throw new StreamCorruptedException(
2026                     String.format(&quot;invalid type code: %02X&quot;, tc));
2027         }
2028         passHandle = handles.assign(unshared ? unsharedMarker : str);
2029         handles.finish(passHandle);
2030         return str;
2031     }
2032 
2033     /**
2034      * Reads in and returns array object, or null if array class is
2035      * unresolvable.  Sets passHandle to array&#39;s assigned handle.
2036      */
2037     private Object readArray(boolean unshared) throws IOException {
2038         if (bin.readByte() != TC_ARRAY) {
2039             throw new InternalError();
2040         }
2041 
2042         ObjectStreamClass desc = readClassDesc(false);
2043         int len = bin.readInt();
2044 
2045         filterCheck(desc.forClass(), len);
2046 
2047         Object array = null;
2048         Class&lt;?&gt; cl, ccl = null;
2049         if ((cl = desc.forClass()) != null) {
2050             ccl = cl.getComponentType();
2051             array = Array.newInstance(ccl, len);
2052         }
2053 
2054         int arrayHandle = handles.assign(unshared ? unsharedMarker : array);
2055         ClassNotFoundException resolveEx = desc.getResolveException();
2056         if (resolveEx != null) {
2057             handles.markException(arrayHandle, resolveEx);
2058         }
2059 
2060         if (ccl == null) {
2061             for (int i = 0; i &lt; len; i++) {
2062                 readObject0(Object.class, false);
2063             }
2064         } else if (ccl.isPrimitive()) {
2065             if (ccl == Integer.TYPE) {
2066                 bin.readInts((int[]) array, 0, len);
2067             } else if (ccl == Byte.TYPE) {
2068                 bin.readFully((byte[]) array, 0, len, true);
2069             } else if (ccl == Long.TYPE) {
2070                 bin.readLongs((long[]) array, 0, len);
2071             } else if (ccl == Float.TYPE) {
2072                 bin.readFloats((float[]) array, 0, len);
2073             } else if (ccl == Double.TYPE) {
2074                 bin.readDoubles((double[]) array, 0, len);
2075             } else if (ccl == Short.TYPE) {
2076                 bin.readShorts((short[]) array, 0, len);
2077             } else if (ccl == Character.TYPE) {
2078                 bin.readChars((char[]) array, 0, len);
2079             } else if (ccl == Boolean.TYPE) {
2080                 bin.readBooleans((boolean[]) array, 0, len);
2081             } else {
2082                 throw new InternalError();
2083             }
2084         } else {
2085             Object[] oa = (Object[]) array;
2086             for (int i = 0; i &lt; len; i++) {
2087                 oa[i] = readObject0(Object.class, false);
2088                 handles.markDependency(arrayHandle, passHandle);
2089             }
2090         }
2091 
2092         handles.finish(arrayHandle);
2093         passHandle = arrayHandle;
2094         return array;
2095     }
2096 
2097     /**
2098      * Reads in and returns enum constant, or null if enum type is
2099      * unresolvable.  Sets passHandle to enum constant&#39;s assigned handle.
2100      */
2101     private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException {
2102         if (bin.readByte() != TC_ENUM) {
2103             throw new InternalError();
2104         }
2105 
2106         ObjectStreamClass desc = readClassDesc(false);
2107         if (!desc.isEnum()) {
2108             throw new InvalidClassException(&quot;non-enum class: &quot; + desc);
2109         }
2110 
2111         int enumHandle = handles.assign(unshared ? unsharedMarker : null);
2112         ClassNotFoundException resolveEx = desc.getResolveException();
2113         if (resolveEx != null) {
2114             handles.markException(enumHandle, resolveEx);
2115         }
2116 
2117         String name = readString(false);
2118         Enum&lt;?&gt; result = null;
2119         Class&lt;?&gt; cl = desc.forClass();
2120         if (cl != null) {
2121             try {
2122                 @SuppressWarnings(&quot;unchecked&quot;)
2123                 Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);
2124                 result = en;
2125             } catch (IllegalArgumentException ex) {
2126                 throw (IOException) new InvalidObjectException(
2127                     &quot;enum constant &quot; + name + &quot; does not exist in &quot; +
2128                     cl).initCause(ex);
2129             }
2130             if (!unshared) {
2131                 handles.setObject(enumHandle, result);
2132             }
2133         }
2134 
2135         handles.finish(enumHandle);
2136         passHandle = enumHandle;
2137         return result;
2138     }
2139 
2140     @SuppressWarnings(&quot;preview&quot;)
2141     private static boolean isRecord(Class&lt;?&gt; cls) {
2142         return cls.isRecord();
2143     }
2144 
2145     /**
2146      * Reads and returns &quot;ordinary&quot; (i.e., not a String, Class,
2147      * ObjectStreamClass, array, or enum constant) object, or null if object&#39;s
2148      * class is unresolvable (in which case a ClassNotFoundException will be
2149      * associated with object&#39;s handle).  Sets passHandle to object&#39;s assigned
2150      * handle.
2151      */
2152     private Object readOrdinaryObject(boolean unshared)
2153         throws IOException
2154     {
2155         if (bin.readByte() != TC_OBJECT) {
2156             throw new InternalError();
2157         }
2158 
2159         ObjectStreamClass desc = readClassDesc(false);
2160         desc.checkDeserialize();
2161 
2162         Class&lt;?&gt; cl = desc.forClass();
2163         if (cl == String.class || cl == Class.class
2164                 || cl == ObjectStreamClass.class) {
2165             throw new InvalidClassException(&quot;invalid class descriptor&quot;);
2166         }
2167 
2168         Object obj;
2169         try {
2170             obj = desc.isInstantiable() ? desc.newInstance() : null;
2171         } catch (Exception ex) {
2172             throw (IOException) new InvalidClassException(
2173                 desc.forClass().getName(),
2174                 &quot;unable to create instance&quot;).initCause(ex);
2175         }
2176 
2177         passHandle = handles.assign(unshared ? unsharedMarker : obj);
2178         ClassNotFoundException resolveEx = desc.getResolveException();
2179         if (resolveEx != null) {
2180             handles.markException(passHandle, resolveEx);
2181         }
2182 
2183         final boolean isRecord = cl != null &amp;&amp; isRecord(cl) ? true : false;
2184         if (isRecord) {
2185             assert obj == null;
2186             obj = readRecord(desc);
2187             handles.setObject(passHandle, obj);
2188         } else if (desc.isExternalizable()) {
2189             readExternalData((Externalizable) obj, desc);
2190         } else {
2191             readSerialData(obj, desc);
2192         }
2193 
2194         handles.finish(passHandle);
2195 
2196         if (obj != null &amp;&amp;
2197             handles.lookupException(passHandle) == null &amp;&amp;
2198             desc.hasReadResolveMethod())
2199         {
2200             Object rep = desc.invokeReadResolve(obj);
2201             if (unshared &amp;&amp; rep.getClass().isArray()) {
2202                 rep = cloneArray(rep);
2203             }
2204             if (rep != obj) {
2205                 // Filter the replacement object
2206                 if (rep != null) {
2207                     if (rep.getClass().isArray()) {
2208                         filterCheck(rep.getClass(), Array.getLength(rep));
2209                     } else {
2210                         filterCheck(rep.getClass(), -1);
2211                     }
2212                 }
2213                 handles.setObject(passHandle, obj = rep);
2214             }
2215         }
2216 
2217         return obj;
2218     }
2219 
2220     /**
2221      * If obj is non-null, reads externalizable data by invoking readExternal()
2222      * method of obj; otherwise, attempts to skip over externalizable data.
2223      * Expects that passHandle is set to obj&#39;s handle before this method is
2224      * called.
2225      */
2226     private void readExternalData(Externalizable obj, ObjectStreamClass desc)
2227         throws IOException
2228     {
2229         SerialCallbackContext oldContext = curContext;
2230         if (oldContext != null)
2231             oldContext.check();
2232         curContext = null;
2233         try {
2234             boolean blocked = desc.hasBlockExternalData();
2235             if (blocked) {
2236                 bin.setBlockDataMode(true);
2237             }
2238             if (obj != null) {
2239                 try {
2240                     obj.readExternal(this);
2241                 } catch (ClassNotFoundException ex) {
2242                     /*
2243                      * In most cases, the handle table has already propagated
2244                      * a CNFException to passHandle at this point; this mark
2245                      * call is included to address cases where the readExternal
2246                      * method has cons&#39;ed and thrown a new CNFException of its
2247                      * own.
2248                      */
2249                      handles.markException(passHandle, ex);
2250                 }
2251             }
2252             if (blocked) {
2253                 skipCustomData();
2254             }
2255         } finally {
2256             if (oldContext != null)
2257                 oldContext.check();
2258             curContext = oldContext;
2259         }
2260         /*
2261          * At this point, if the externalizable data was not written in
2262          * block-data form and either the externalizable class doesn&#39;t exist
2263          * locally (i.e., obj == null) or readExternal() just threw a
2264          * CNFException, then the stream is probably in an inconsistent state,
2265          * since some (or all) of the externalizable data may not have been
2266          * consumed.  Since there&#39;s no &quot;correct&quot; action to take in this case,
2267          * we mimic the behavior of past serialization implementations and
2268          * blindly hope that the stream is in sync; if it isn&#39;t and additional
2269          * externalizable data remains in the stream, a subsequent read will
2270          * most likely throw a StreamCorruptedException.
2271          */
2272     }
2273 
2274     /** Reads a record. */
2275     private Object readRecord(ObjectStreamClass desc) throws IOException {
2276         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
2277         if (slots.length != 1) {
2278             // skip any superclass stream field values
2279             for (int i = 0; i &lt; slots.length-1; i++) {
2280                 ObjectStreamClass slotDesc = slots[i].desc;
2281                 if (slots[i].hasData) {
2282                     defaultReadFields(null, slotDesc);
2283                 }
2284             }
2285         }
2286 
2287         FieldValues fieldValues = defaultReadFields(null, desc);
2288 
2289         // retrieve the canonical constructor
2290         MethodHandle ctrMH = desc.getRecordConstructor();
2291 
2292         // bind the stream field values
2293         ctrMH = RecordSupport.bindCtrValues(ctrMH, desc, fieldValues);
2294 
2295         try {
2296             return ctrMH.invoke();
2297         } catch (Exception e) {
2298             InvalidObjectException ioe = new InvalidObjectException(e.getMessage());
2299             ioe.initCause(e);
2300             throw ioe;
2301         } catch (Error e) {
2302             throw e;
2303         } catch (Throwable t) {
2304             ObjectStreamException ose = new InvalidObjectException(
2305                     &quot;ReflectiveOperationException during deserialization&quot;);
2306             ose.initCause(t);
2307             throw ose;
2308         }
2309     }
2310 
2311     /**
2312      * Reads (or attempts to skip, if obj is null or is tagged with a
2313      * ClassNotFoundException) instance data for each serializable class of
2314      * object in stream, from superclass to subclass.  Expects that passHandle
2315      * is set to obj&#39;s handle before this method is called.
2316      */
2317     private void readSerialData(Object obj, ObjectStreamClass desc)
2318         throws IOException
2319     {
2320         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
2321         // Best effort Failure Atomicity; slotValues will be non-null if field
2322         // values can be set after reading all field data in the hierarchy.
2323         // Field values can only be set after reading all data if there are no
2324         // user observable methods in the hierarchy, readObject(NoData). The
2325         // top most Serializable class in the hierarchy can be skipped.
2326         FieldValues[] slotValues = null;
2327 
2328         boolean hasSpecialReadMethod = false;
2329         for (int i = 1; i &lt; slots.length; i++) {
2330             ObjectStreamClass slotDesc = slots[i].desc;
2331             if (slotDesc.hasReadObjectMethod()
2332                   || slotDesc.hasReadObjectNoDataMethod()) {
2333                 hasSpecialReadMethod = true;
2334                 break;
2335             }
2336         }
2337         // No special read methods, can store values and defer setting.
2338         if (!hasSpecialReadMethod)
2339             slotValues = new FieldValues[slots.length];
2340 
2341         for (int i = 0; i &lt; slots.length; i++) {
2342             ObjectStreamClass slotDesc = slots[i].desc;
2343 
2344             if (slots[i].hasData) {
2345                 if (obj == null || handles.lookupException(passHandle) != null) {
2346                     defaultReadFields(null, slotDesc); // skip field values
2347                 } else if (slotDesc.hasReadObjectMethod()) {
2348                     ThreadDeath t = null;
2349                     boolean reset = false;
2350                     SerialCallbackContext oldContext = curContext;
2351                     if (oldContext != null)
2352                         oldContext.check();
2353                     try {
2354                         curContext = new SerialCallbackContext(obj, slotDesc);
2355 
2356                         bin.setBlockDataMode(true);
2357                         slotDesc.invokeReadObject(obj, this);
2358                     } catch (ClassNotFoundException ex) {
2359                         /*
2360                          * In most cases, the handle table has already
2361                          * propagated a CNFException to passHandle at this
2362                          * point; this mark call is included to address cases
2363                          * where the custom readObject method has cons&#39;ed and
2364                          * thrown a new CNFException of its own.
2365                          */
2366                         handles.markException(passHandle, ex);
2367                     } finally {
2368                         do {
2369                             try {
2370                                 curContext.setUsed();
2371                                 if (oldContext!= null)
2372                                     oldContext.check();
2373                                 curContext = oldContext;
2374                                 reset = true;
2375                             } catch (ThreadDeath x) {
2376                                 t = x;  // defer until reset is true
2377                             }
2378                         } while (!reset);
2379                         if (t != null)
2380                             throw t;
2381                     }
2382 
2383                     /*
2384                      * defaultDataEnd may have been set indirectly by custom
2385                      * readObject() method when calling defaultReadObject() or
2386                      * readFields(); clear it to restore normal read behavior.
2387                      */
2388                     defaultDataEnd = false;
2389                 } else {
2390                     FieldValues vals = defaultReadFields(obj, slotDesc);
2391                     if (slotValues != null) {
2392                         slotValues[i] = vals;
2393                     } else if (obj != null) {
2394                         defaultCheckFieldValues(obj, slotDesc, vals);
2395                         defaultSetFieldValues(obj, slotDesc, vals);
2396                     }
2397                 }
2398 
2399                 if (slotDesc.hasWriteObjectData()) {
2400                     skipCustomData();
2401                 } else {
2402                     bin.setBlockDataMode(false);
2403                 }
2404             } else {
2405                 if (obj != null &amp;&amp;
2406                     slotDesc.hasReadObjectNoDataMethod() &amp;&amp;
2407                     handles.lookupException(passHandle) == null)
2408                 {
2409                     slotDesc.invokeReadObjectNoData(obj);
2410                 }
2411             }
2412         }
2413 
2414         if (obj != null &amp;&amp; slotValues != null) {
2415             // Check that the non-primitive types are assignable for all slots
2416             // before assigning.
2417             for (int i = 0; i &lt; slots.length; i++) {
2418                 if (slotValues[i] != null)
2419                     defaultCheckFieldValues(obj, slots[i].desc, slotValues[i]);
2420             }
2421             for (int i = 0; i &lt; slots.length; i++) {
2422                 if (slotValues[i] != null)
2423                     defaultSetFieldValues(obj, slots[i].desc, slotValues[i]);
2424             }
2425         }
2426     }
2427 
2428     /**
2429      * Skips over all block data and objects until TC_ENDBLOCKDATA is
2430      * encountered.
2431      */
2432     private void skipCustomData() throws IOException {
2433         int oldHandle = passHandle;
2434         for (;;) {
2435             if (bin.getBlockDataMode()) {
2436                 bin.skipBlockData();
2437                 bin.setBlockDataMode(false);
2438             }
2439             switch (bin.peekByte()) {
2440                 case TC_BLOCKDATA:
2441                 case TC_BLOCKDATALONG:
2442                     bin.setBlockDataMode(true);
2443                     break;
2444 
2445                 case TC_ENDBLOCKDATA:
2446                     bin.readByte();
2447                     passHandle = oldHandle;
2448                     return;
2449 
2450                 default:
2451                     readObject0(Object.class, false);
2452                     break;
2453             }
2454         }
2455     }
2456 
2457     /*package-private*/ class FieldValues {
2458         final byte[] primValues;
2459         final Object[] objValues;
2460 
2461         FieldValues(byte[] primValues, Object[] objValues) {
2462             this.primValues = primValues;
2463             this.objValues = objValues;
2464         }
2465     }
2466 
2467     /**
2468      * Reads in values of serializable fields declared by given class
2469      * descriptor. Expects that passHandle is set to obj&#39;s handle before this
2470      * method is called.
2471      */
2472     private FieldValues defaultReadFields(Object obj, ObjectStreamClass desc)
2473         throws IOException
2474     {
2475         Class&lt;?&gt; cl = desc.forClass();
2476         if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) {
2477             throw new ClassCastException();
2478         }
2479 
2480         byte[] primVals = null;
2481         int primDataSize = desc.getPrimDataSize();
2482         if (primDataSize &gt; 0) {
2483             primVals = new byte[primDataSize];
2484             bin.readFully(primVals, 0, primDataSize, false);
2485         }
2486 
2487         Object[] objVals = null;
2488         int numObjFields = desc.getNumObjFields();
2489         if (numObjFields &gt; 0) {
2490             int objHandle = passHandle;
2491             ObjectStreamField[] fields = desc.getFields(false);
2492             objVals = new Object[numObjFields];
2493             int numPrimFields = fields.length - objVals.length;
2494             for (int i = 0; i &lt; objVals.length; i++) {
2495                 ObjectStreamField f = fields[numPrimFields + i];
2496                 objVals[i] = readObject0(Object.class, f.isUnshared());
2497                 if (f.getField() != null) {
2498                     handles.markDependency(objHandle, passHandle);
2499                 }
2500             }
2501             passHandle = objHandle;
2502         }
2503 
2504         return new FieldValues(primVals, objVals);
2505     }
2506 
2507     /** Throws ClassCastException if any value is not assignable. */
2508     private void defaultCheckFieldValues(Object obj, ObjectStreamClass desc,
2509                                          FieldValues values) {
2510         Object[] objectValues = values.objValues;
2511         if (objectValues != null)
2512             desc.checkObjFieldValueTypes(obj, objectValues);
2513     }
2514 
2515     /** Sets field values in obj. */
2516     private void defaultSetFieldValues(Object obj, ObjectStreamClass desc,
2517                                        FieldValues values) {
2518         byte[] primValues = values.primValues;
2519         Object[] objectValues = values.objValues;
2520 
2521         if (primValues != null)
2522             desc.setPrimFieldValues(obj, primValues);
2523         if (objectValues != null)
2524             desc.setObjFieldValues(obj, objectValues);
2525     }
2526 
2527     /**
2528      * Reads in and returns IOException that caused serialization to abort.
2529      * All stream state is discarded prior to reading in fatal exception.  Sets
2530      * passHandle to fatal exception&#39;s handle.
2531      */
2532     private IOException readFatalException() throws IOException {
2533         if (bin.readByte() != TC_EXCEPTION) {
2534             throw new InternalError();
2535         }
2536         clear();
2537         return (IOException) readObject0(Object.class, false);
2538     }
2539 
2540     /**
2541      * If recursion depth is 0, clears internal data structures; otherwise,
2542      * throws a StreamCorruptedException.  This method is called when a
2543      * TC_RESET typecode is encountered.
2544      */
2545     private void handleReset() throws StreamCorruptedException {
2546         if (depth &gt; 0) {
2547             throw new StreamCorruptedException(
2548                 &quot;unexpected reset; recursion depth: &quot; + depth);
2549         }
2550         clear();
2551     }
2552 
2553     /**
2554      * Returns the first non-null and non-platform class loader (not counting
2555      * class loaders of generated reflection implementation classes) up the
2556      * execution stack, or the platform class loader if only code from the
2557      * bootstrap and platform class loader is on the stack.
2558      */
2559     private static ClassLoader latestUserDefinedLoader() {
2560         return jdk.internal.misc.VM.latestUserDefinedLoader();
2561     }
2562 
2563     /**
2564      * Default GetField implementation.
2565      */
2566     private class GetFieldImpl extends GetField {
2567 
2568         /** class descriptor describing serializable fields */
2569         private final ObjectStreamClass desc;
2570         /** primitive field values */
2571         private final byte[] primVals;
2572         /** object field values */
2573         private final Object[] objVals;
2574         /** object field value handles */
2575         private final int[] objHandles;
2576 
2577         /**
2578          * Creates GetFieldImpl object for reading fields defined in given
2579          * class descriptor.
2580          */
2581         GetFieldImpl(ObjectStreamClass desc) {
2582             this.desc = desc;
2583             primVals = new byte[desc.getPrimDataSize()];
2584             objVals = new Object[desc.getNumObjFields()];
2585             objHandles = new int[objVals.length];
2586         }
2587 
2588         public ObjectStreamClass getObjectStreamClass() {
2589             return desc;
2590         }
2591 
2592         public boolean defaulted(String name) throws IOException {
2593             return (getFieldOffset(name, null) &lt; 0);
2594         }
2595 
2596         public boolean get(String name, boolean val) throws IOException {
2597             int off = getFieldOffset(name, Boolean.TYPE);
2598             return (off &gt;= 0) ? Bits.getBoolean(primVals, off) : val;
2599         }
2600 
2601         public byte get(String name, byte val) throws IOException {
2602             int off = getFieldOffset(name, Byte.TYPE);
2603             return (off &gt;= 0) ? primVals[off] : val;
2604         }
2605 
2606         public char get(String name, char val) throws IOException {
2607             int off = getFieldOffset(name, Character.TYPE);
2608             return (off &gt;= 0) ? Bits.getChar(primVals, off) : val;
2609         }
2610 
2611         public short get(String name, short val) throws IOException {
2612             int off = getFieldOffset(name, Short.TYPE);
2613             return (off &gt;= 0) ? Bits.getShort(primVals, off) : val;
2614         }
2615 
2616         public int get(String name, int val) throws IOException {
2617             int off = getFieldOffset(name, Integer.TYPE);
2618             return (off &gt;= 0) ? Bits.getInt(primVals, off) : val;
2619         }
2620 
2621         public float get(String name, float val) throws IOException {
2622             int off = getFieldOffset(name, Float.TYPE);
2623             return (off &gt;= 0) ? Bits.getFloat(primVals, off) : val;
2624         }
2625 
2626         public long get(String name, long val) throws IOException {
2627             int off = getFieldOffset(name, Long.TYPE);
2628             return (off &gt;= 0) ? Bits.getLong(primVals, off) : val;
2629         }
2630 
2631         public double get(String name, double val) throws IOException {
2632             int off = getFieldOffset(name, Double.TYPE);
2633             return (off &gt;= 0) ? Bits.getDouble(primVals, off) : val;
2634         }
2635 
2636         public Object get(String name, Object val) throws IOException {
2637             int off = getFieldOffset(name, Object.class);
2638             if (off &gt;= 0) {
2639                 int objHandle = objHandles[off];
2640                 handles.markDependency(passHandle, objHandle);
2641                 return (handles.lookupException(objHandle) == null) ?
2642                     objVals[off] : null;
2643             } else {
2644                 return val;
2645             }
2646         }
2647 
2648         /**
2649          * Reads primitive and object field values from stream.
2650          */
2651         void readFields() throws IOException {
2652             bin.readFully(primVals, 0, primVals.length, false);
2653 
2654             int oldHandle = passHandle;
2655             ObjectStreamField[] fields = desc.getFields(false);
2656             int numPrimFields = fields.length - objVals.length;
2657             for (int i = 0; i &lt; objVals.length; i++) {
2658                 objVals[i] =
2659                     readObject0(Object.class, fields[numPrimFields + i].isUnshared());
2660                 objHandles[i] = passHandle;
2661             }
2662             passHandle = oldHandle;
2663         }
2664 
2665         /**
2666          * Returns offset of field with given name and type.  A specified type
2667          * of null matches all types, Object.class matches all non-primitive
2668          * types, and any other non-null type matches assignable types only.
2669          * If no matching field is found in the (incoming) class
2670          * descriptor but a matching field is present in the associated local
2671          * class descriptor, returns -1.  Throws IllegalArgumentException if
2672          * neither incoming nor local class descriptor contains a match.
2673          */
2674         private int getFieldOffset(String name, Class&lt;?&gt; type) {
2675             ObjectStreamField field = desc.getField(name, type);
2676             if (field != null) {
2677                 return field.getOffset();
2678             } else if (desc.getLocalDesc().getField(name, type) != null) {
2679                 return -1;
2680             } else {
2681                 throw new IllegalArgumentException(&quot;no such field &quot; + name +
2682                                                    &quot; with type &quot; + type);
2683             }
2684         }
2685     }
2686 
2687     /**
2688      * Prioritized list of callbacks to be performed once object graph has been
2689      * completely deserialized.
2690      */
2691     private static class ValidationList {
2692 
2693         private static class Callback {
2694             final ObjectInputValidation obj;
2695             final int priority;
2696             Callback next;
2697             final AccessControlContext acc;
2698 
2699             Callback(ObjectInputValidation obj, int priority, Callback next,
2700                 AccessControlContext acc)
2701             {
2702                 this.obj = obj;
2703                 this.priority = priority;
2704                 this.next = next;
2705                 this.acc = acc;
2706             }
2707         }
2708 
2709         /** linked list of callbacks */
2710         private Callback list;
2711 
2712         /**
2713          * Creates new (empty) ValidationList.
2714          */
2715         ValidationList() {
2716         }
2717 
2718         /**
2719          * Registers callback.  Throws InvalidObjectException if callback
2720          * object is null.
2721          */
2722         void register(ObjectInputValidation obj, int priority)
2723             throws InvalidObjectException
2724         {
2725             if (obj == null) {
2726                 throw new InvalidObjectException(&quot;null callback&quot;);
2727             }
2728 
2729             Callback prev = null, cur = list;
2730             while (cur != null &amp;&amp; priority &lt; cur.priority) {
2731                 prev = cur;
2732                 cur = cur.next;
2733             }
2734             AccessControlContext acc = AccessController.getContext();
2735             if (prev != null) {
2736                 prev.next = new Callback(obj, priority, cur, acc);
2737             } else {
2738                 list = new Callback(obj, priority, list, acc);
2739             }
2740         }
2741 
2742         /**
2743          * Invokes all registered callbacks and clears the callback list.
2744          * Callbacks with higher priorities are called first; those with equal
2745          * priorities may be called in any order.  If any of the callbacks
2746          * throws an InvalidObjectException, the callback process is terminated
2747          * and the exception propagated upwards.
2748          */
2749         void doCallbacks() throws InvalidObjectException {
2750             try {
2751                 while (list != null) {
2752                     AccessController.doPrivileged(
2753                         new PrivilegedExceptionAction&lt;Void&gt;()
2754                     {
2755                         public Void run() throws InvalidObjectException {
2756                             list.obj.validateObject();
2757                             return null;
2758                         }
2759                     }, list.acc);
2760                     list = list.next;
2761                 }
2762             } catch (PrivilegedActionException ex) {
2763                 list = null;
2764                 throw (InvalidObjectException) ex.getException();
2765             }
2766         }
2767 
2768         /**
2769          * Resets the callback list to its initial (empty) state.
2770          */
2771         public void clear() {
2772             list = null;
2773         }
2774     }
2775 
2776     /**
2777      * Hold a snapshot of values to be passed to an ObjectInputFilter.
2778      */
2779     static class FilterValues implements ObjectInputFilter.FilterInfo {
2780         final Class&lt;?&gt; clazz;
2781         final long arrayLength;
2782         final long totalObjectRefs;
2783         final long depth;
2784         final long streamBytes;
2785 
2786         public FilterValues(Class&lt;?&gt; clazz, long arrayLength, long totalObjectRefs,
2787                             long depth, long streamBytes) {
2788             this.clazz = clazz;
2789             this.arrayLength = arrayLength;
2790             this.totalObjectRefs = totalObjectRefs;
2791             this.depth = depth;
2792             this.streamBytes = streamBytes;
2793         }
2794 
2795         @Override
2796         public Class&lt;?&gt; serialClass() {
2797             return clazz;
2798         }
2799 
2800         @Override
2801         public long arrayLength() {
2802             return arrayLength;
2803         }
2804 
2805         @Override
2806         public long references() {
2807             return totalObjectRefs;
2808         }
2809 
2810         @Override
2811         public long depth() {
2812             return depth;
2813         }
2814 
2815         @Override
2816         public long streamBytes() {
2817             return streamBytes;
2818         }
2819     }
2820 
2821     /**
2822      * Input stream supporting single-byte peek operations.
2823      */
2824     private static class PeekInputStream extends InputStream {
2825 
2826         /** underlying stream */
2827         private final InputStream in;
2828         /** peeked byte */
2829         private int peekb = -1;
2830         /** total bytes read from the stream */
2831         private long totalBytesRead = 0;
2832 
2833         /**
2834          * Creates new PeekInputStream on top of given underlying stream.
2835          */
2836         PeekInputStream(InputStream in) {
2837             this.in = in;
2838         }
2839 
2840         /**
2841          * Peeks at next byte value in stream.  Similar to read(), except
2842          * that it does not consume the read value.
2843          */
2844         int peek() throws IOException {
2845             if (peekb &gt;= 0) {
2846                 return peekb;
2847             }
2848             peekb = in.read();
2849             totalBytesRead += peekb &gt;= 0 ? 1 : 0;
2850             return peekb;
2851         }
2852 
2853         public int read() throws IOException {
2854             if (peekb &gt;= 0) {
2855                 int v = peekb;
2856                 peekb = -1;
2857                 return v;
2858             } else {
2859                 int nbytes = in.read();
2860                 totalBytesRead += nbytes &gt;= 0 ? 1 : 0;
2861                 return nbytes;
2862             }
2863         }
2864 
2865         public int read(byte[] b, int off, int len) throws IOException {
2866             int nbytes;
2867             if (len == 0) {
2868                 return 0;
2869             } else if (peekb &lt; 0) {
2870                 nbytes = in.read(b, off, len);
2871                 totalBytesRead += nbytes &gt;= 0 ? nbytes : 0;
2872                 return nbytes;
2873             } else {
2874                 b[off++] = (byte) peekb;
2875                 len--;
2876                 peekb = -1;
2877                 nbytes = in.read(b, off, len);
2878                 totalBytesRead += nbytes &gt;= 0 ? nbytes : 0;
2879                 return (nbytes &gt;= 0) ? (nbytes + 1) : 1;
2880             }
2881         }
2882 
2883         void readFully(byte[] b, int off, int len) throws IOException {
2884             int n = 0;
2885             while (n &lt; len) {
2886                 int count = read(b, off + n, len - n);
2887                 if (count &lt; 0) {
2888                     throw new EOFException();
2889                 }
2890                 n += count;
2891             }
2892         }
2893 
2894         public long skip(long n) throws IOException {
2895             if (n &lt;= 0) {
2896                 return 0;
2897             }
2898             int skipped = 0;
2899             if (peekb &gt;= 0) {
2900                 peekb = -1;
2901                 skipped++;
2902                 n--;
2903             }
2904             n = skipped + in.skip(n);
2905             totalBytesRead += n;
2906             return n;
2907         }
2908 
2909         public int available() throws IOException {
2910             return in.available() + ((peekb &gt;= 0) ? 1 : 0);
2911         }
2912 
2913         public void close() throws IOException {
2914             in.close();
2915         }
2916 
2917         public long getBytesRead() {
2918             return totalBytesRead;
2919         }
2920     }
2921 
2922     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
2923 
2924     /**
2925      * Performs a &quot;freeze&quot; action, required to adhere to final field semantics.
2926      *
2927      * &lt;p&gt; This method can be called unconditionally before returning the graph,
2928      * from the topmost readObject call, since it is expected that the
2929      * additional cost of the freeze action is negligible compared to
2930      * reconstituting even the most simple graph.
2931      *
2932      * &lt;p&gt; Nested calls to readObject do not issue freeze actions because the
2933      * sub-graph returned from a nested call is not guaranteed to be fully
2934      * initialized yet (possible cycles).
2935      */
2936     private void freeze() {
2937         // Issue a StoreStore|StoreLoad fence, which is at least sufficient
2938         // to provide final-freeze semantics.
2939         UNSAFE.storeFence();
2940     }
2941 
2942     /**
2943      * Input stream with two modes: in default mode, inputs data written in the
2944      * same format as DataOutputStream; in &quot;block data&quot; mode, inputs data
2945      * bracketed by block data markers (see object serialization specification
2946      * for details).  Buffering depends on block data mode: when in default
2947      * mode, no data is buffered in advance; when in block data mode, all data
2948      * for the current data block is read in at once (and buffered).
2949      */
2950     private class BlockDataInputStream
2951         extends InputStream implements DataInput
2952     {
2953         /** maximum data block length */
2954         private static final int MAX_BLOCK_SIZE = 1024;
2955         /** maximum data block header length */
2956         private static final int MAX_HEADER_SIZE = 5;
2957         /** (tunable) length of char buffer (for reading strings) */
2958         private static final int CHAR_BUF_SIZE = 256;
2959         /** readBlockHeader() return value indicating header read may block */
2960         private static final int HEADER_BLOCKED = -2;
2961 
2962         /** buffer for reading general/block data */
2963         private final byte[] buf = new byte[MAX_BLOCK_SIZE];
2964         /** buffer for reading block data headers */
2965         private final byte[] hbuf = new byte[MAX_HEADER_SIZE];
2966         /** char buffer for fast string reads */
2967         private final char[] cbuf = new char[CHAR_BUF_SIZE];
2968 
2969         /** block data mode */
2970         private boolean blkmode = false;
2971 
2972         // block data state fields; values meaningful only when blkmode true
2973         /** current offset into buf */
2974         private int pos = 0;
2975         /** end offset of valid data in buf, or -1 if no more block data */
2976         private int end = -1;
2977         /** number of bytes in current block yet to be read from stream */
2978         private int unread = 0;
2979 
2980         /** underlying stream (wrapped in peekable filter stream) */
2981         private final PeekInputStream in;
2982         /** loopback stream (for data reads that span data blocks) */
2983         private final DataInputStream din;
2984 
2985         /**
2986          * Creates new BlockDataInputStream on top of given underlying stream.
2987          * Block data mode is turned off by default.
2988          */
2989         BlockDataInputStream(InputStream in) {
2990             this.in = new PeekInputStream(in);
2991             din = new DataInputStream(this);
2992         }
2993 
2994         /**
2995          * Sets block data mode to the given mode (true == on, false == off)
2996          * and returns the previous mode value.  If the new mode is the same as
2997          * the old mode, no action is taken.  Throws IllegalStateException if
2998          * block data mode is being switched from on to off while unconsumed
2999          * block data is still present in the stream.
3000          */
3001         boolean setBlockDataMode(boolean newmode) throws IOException {
3002             if (blkmode == newmode) {
3003                 return blkmode;
3004             }
3005             if (newmode) {
3006                 pos = 0;
3007                 end = 0;
3008                 unread = 0;
3009             } else if (pos &lt; end) {
3010                 throw new IllegalStateException(&quot;unread block data&quot;);
3011             }
3012             blkmode = newmode;
3013             return !blkmode;
3014         }
3015 
3016         /**
3017          * Returns true if the stream is currently in block data mode, false
3018          * otherwise.
3019          */
3020         boolean getBlockDataMode() {
3021             return blkmode;
3022         }
3023 
3024         /**
3025          * If in block data mode, skips to the end of the current group of data
3026          * blocks (but does not unset block data mode).  If not in block data
3027          * mode, throws an IllegalStateException.
3028          */
3029         void skipBlockData() throws IOException {
3030             if (!blkmode) {
3031                 throw new IllegalStateException(&quot;not in block data mode&quot;);
3032             }
3033             while (end &gt;= 0) {
3034                 refill();
3035             }
3036         }
3037 
3038         /**
3039          * Attempts to read in the next block data header (if any).  If
3040          * canBlock is false and a full header cannot be read without possibly
3041          * blocking, returns HEADER_BLOCKED, else if the next element in the
3042          * stream is a block data header, returns the block data length
3043          * specified by the header, else returns -1.
3044          */
3045         private int readBlockHeader(boolean canBlock) throws IOException {
3046             if (defaultDataEnd) {
3047                 /*
3048                  * Fix for 4360508: stream is currently at the end of a field
3049                  * value block written via default serialization; since there
3050                  * is no terminating TC_ENDBLOCKDATA tag, simulate
3051                  * end-of-custom-data behavior explicitly.
3052                  */
3053                 return -1;
3054             }
3055             try {
3056                 for (;;) {
3057                     int avail = canBlock ? Integer.MAX_VALUE : in.available();
3058                     if (avail == 0) {
3059                         return HEADER_BLOCKED;
3060                     }
3061 
3062                     int tc = in.peek();
3063                     switch (tc) {
3064                         case TC_BLOCKDATA:
3065                             if (avail &lt; 2) {
3066                                 return HEADER_BLOCKED;
3067                             }
3068                             in.readFully(hbuf, 0, 2);
3069                             return hbuf[1] &amp; 0xFF;
3070 
3071                         case TC_BLOCKDATALONG:
3072                             if (avail &lt; 5) {
3073                                 return HEADER_BLOCKED;
3074                             }
3075                             in.readFully(hbuf, 0, 5);
3076                             int len = Bits.getInt(hbuf, 1);
3077                             if (len &lt; 0) {
3078                                 throw new StreamCorruptedException(
3079                                     &quot;illegal block data header length: &quot; +
3080                                     len);
3081                             }
3082                             return len;
3083 
3084                         /*
3085                          * TC_RESETs may occur in between data blocks.
3086                          * Unfortunately, this case must be parsed at a lower
3087                          * level than other typecodes, since primitive data
3088                          * reads may span data blocks separated by a TC_RESET.
3089                          */
3090                         case TC_RESET:
3091                             in.read();
3092                             handleReset();
3093                             break;
3094 
3095                         default:
3096                             if (tc &gt;= 0 &amp;&amp; (tc &lt; TC_BASE || tc &gt; TC_MAX)) {
3097                                 throw new StreamCorruptedException(
3098                                     String.format(&quot;invalid type code: %02X&quot;,
3099                                     tc));
3100                             }
3101                             return -1;
3102                     }
3103                 }
3104             } catch (EOFException ex) {
3105                 throw new StreamCorruptedException(
3106                     &quot;unexpected EOF while reading block data header&quot;);
3107             }
3108         }
3109 
3110         /**
3111          * Refills internal buffer buf with block data.  Any data in buf at the
3112          * time of the call is considered consumed.  Sets the pos, end, and
3113          * unread fields to reflect the new amount of available block data; if
3114          * the next element in the stream is not a data block, sets pos and
3115          * unread to 0 and end to -1.
3116          */
3117         private void refill() throws IOException {
3118             try {
3119                 do {
3120                     pos = 0;
3121                     if (unread &gt; 0) {
3122                         int n =
3123                             in.read(buf, 0, Math.min(unread, MAX_BLOCK_SIZE));
3124                         if (n &gt;= 0) {
3125                             end = n;
3126                             unread -= n;
3127                         } else {
3128                             throw new StreamCorruptedException(
3129                                 &quot;unexpected EOF in middle of data block&quot;);
3130                         }
3131                     } else {
3132                         int n = readBlockHeader(true);
3133                         if (n &gt;= 0) {
3134                             end = 0;
3135                             unread = n;
3136                         } else {
3137                             end = -1;
3138                             unread = 0;
3139                         }
3140                     }
3141                 } while (pos == end);
3142             } catch (IOException ex) {
3143                 pos = 0;
3144                 end = -1;
3145                 unread = 0;
3146                 throw ex;
3147             }
3148         }
3149 
3150         /**
3151          * If in block data mode, returns the number of unconsumed bytes
3152          * remaining in the current data block.  If not in block data mode,
3153          * throws an IllegalStateException.
3154          */
3155         int currentBlockRemaining() {
3156             if (blkmode) {
3157                 return (end &gt;= 0) ? (end - pos) + unread : 0;
3158             } else {
3159                 throw new IllegalStateException();
3160             }
3161         }
3162 
3163         /**
3164          * Peeks at (but does not consume) and returns the next byte value in
3165          * the stream, or -1 if the end of the stream/block data (if in block
3166          * data mode) has been reached.
3167          */
3168         int peek() throws IOException {
3169             if (blkmode) {
3170                 if (pos == end) {
3171                     refill();
3172                 }
3173                 return (end &gt;= 0) ? (buf[pos] &amp; 0xFF) : -1;
3174             } else {
3175                 return in.peek();
3176             }
3177         }
3178 
3179         /**
3180          * Peeks at (but does not consume) and returns the next byte value in
3181          * the stream, or throws EOFException if end of stream/block data has
3182          * been reached.
3183          */
3184         byte peekByte() throws IOException {
3185             int val = peek();
3186             if (val &lt; 0) {
3187                 throw new EOFException();
3188             }
3189             return (byte) val;
3190         }
3191 
3192 
3193         /* ----------------- generic input stream methods ------------------ */
3194         /*
3195          * The following methods are equivalent to their counterparts in
3196          * InputStream, except that they interpret data block boundaries and
3197          * read the requested data from within data blocks when in block data
3198          * mode.
3199          */
3200 
3201         public int read() throws IOException {
3202             if (blkmode) {
3203                 if (pos == end) {
3204                     refill();
3205                 }
3206                 return (end &gt;= 0) ? (buf[pos++] &amp; 0xFF) : -1;
3207             } else {
3208                 return in.read();
3209             }
3210         }
3211 
3212         public int read(byte[] b, int off, int len) throws IOException {
3213             return read(b, off, len, false);
3214         }
3215 
3216         public long skip(long len) throws IOException {
3217             long remain = len;
3218             while (remain &gt; 0) {
3219                 if (blkmode) {
3220                     if (pos == end) {
3221                         refill();
3222                     }
3223                     if (end &lt; 0) {
3224                         break;
3225                     }
3226                     int nread = (int) Math.min(remain, end - pos);
3227                     remain -= nread;
3228                     pos += nread;
3229                 } else {
3230                     int nread = (int) Math.min(remain, MAX_BLOCK_SIZE);
3231                     if ((nread = in.read(buf, 0, nread)) &lt; 0) {
3232                         break;
3233                     }
3234                     remain -= nread;
3235                 }
3236             }
3237             return len - remain;
3238         }
3239 
3240         public int available() throws IOException {
3241             if (blkmode) {
3242                 if ((pos == end) &amp;&amp; (unread == 0)) {
3243                     int n;
3244                     while ((n = readBlockHeader(false)) == 0) ;
3245                     switch (n) {
3246                         case HEADER_BLOCKED:
3247                             break;
3248 
3249                         case -1:
3250                             pos = 0;
3251                             end = -1;
3252                             break;
3253 
3254                         default:
3255                             pos = 0;
3256                             end = 0;
3257                             unread = n;
3258                             break;
3259                     }
3260                 }
3261                 // avoid unnecessary call to in.available() if possible
3262                 int unreadAvail = (unread &gt; 0) ?
3263                     Math.min(in.available(), unread) : 0;
3264                 return (end &gt;= 0) ? (end - pos) + unreadAvail : 0;
3265             } else {
3266                 return in.available();
3267             }
3268         }
3269 
3270         public void close() throws IOException {
3271             if (blkmode) {
3272                 pos = 0;
3273                 end = -1;
3274                 unread = 0;
3275             }
3276             in.close();
3277         }
3278 
3279         /**
3280          * Attempts to read len bytes into byte array b at offset off.  Returns
3281          * the number of bytes read, or -1 if the end of stream/block data has
3282          * been reached.  If copy is true, reads values into an intermediate
3283          * buffer before copying them to b (to avoid exposing a reference to
3284          * b).
3285          */
3286         int read(byte[] b, int off, int len, boolean copy) throws IOException {
3287             if (len == 0) {
3288                 return 0;
3289             } else if (blkmode) {
3290                 if (pos == end) {
3291                     refill();
3292                 }
3293                 if (end &lt; 0) {
3294                     return -1;
3295                 }
3296                 int nread = Math.min(len, end - pos);
3297                 System.arraycopy(buf, pos, b, off, nread);
3298                 pos += nread;
3299                 return nread;
3300             } else if (copy) {
3301                 int nread = in.read(buf, 0, Math.min(len, MAX_BLOCK_SIZE));
3302                 if (nread &gt; 0) {
3303                     System.arraycopy(buf, 0, b, off, nread);
3304                 }
3305                 return nread;
3306             } else {
3307                 return in.read(b, off, len);
3308             }
3309         }
3310 
3311         /* ----------------- primitive data input methods ------------------ */
3312         /*
3313          * The following methods are equivalent to their counterparts in
3314          * DataInputStream, except that they interpret data block boundaries
3315          * and read the requested data from within data blocks when in block
3316          * data mode.
3317          */
3318 
3319         public void readFully(byte[] b) throws IOException {
3320             readFully(b, 0, b.length, false);
3321         }
3322 
3323         public void readFully(byte[] b, int off, int len) throws IOException {
3324             readFully(b, off, len, false);
3325         }
3326 
3327         public void readFully(byte[] b, int off, int len, boolean copy)
3328             throws IOException
3329         {
3330             while (len &gt; 0) {
3331                 int n = read(b, off, len, copy);
3332                 if (n &lt; 0) {
3333                     throw new EOFException();
3334                 }
3335                 off += n;
3336                 len -= n;
3337             }
3338         }
3339 
3340         public int skipBytes(int n) throws IOException {
3341             return din.skipBytes(n);
3342         }
3343 
3344         public boolean readBoolean() throws IOException {
3345             int v = read();
3346             if (v &lt; 0) {
3347                 throw new EOFException();
3348             }
3349             return (v != 0);
3350         }
3351 
3352         public byte readByte() throws IOException {
3353             int v = read();
3354             if (v &lt; 0) {
3355                 throw new EOFException();
3356             }
3357             return (byte) v;
3358         }
3359 
3360         public int readUnsignedByte() throws IOException {
3361             int v = read();
3362             if (v &lt; 0) {
3363                 throw new EOFException();
3364             }
3365             return v;
3366         }
3367 
3368         public char readChar() throws IOException {
3369             if (!blkmode) {
3370                 pos = 0;
3371                 in.readFully(buf, 0, 2);
3372             } else if (end - pos &lt; 2) {
3373                 return din.readChar();
3374             }
3375             char v = Bits.getChar(buf, pos);
3376             pos += 2;
3377             return v;
3378         }
3379 
3380         public short readShort() throws IOException {
3381             if (!blkmode) {
3382                 pos = 0;
3383                 in.readFully(buf, 0, 2);
3384             } else if (end - pos &lt; 2) {
3385                 return din.readShort();
3386             }
3387             short v = Bits.getShort(buf, pos);
3388             pos += 2;
3389             return v;
3390         }
3391 
3392         public int readUnsignedShort() throws IOException {
3393             if (!blkmode) {
3394                 pos = 0;
3395                 in.readFully(buf, 0, 2);
3396             } else if (end - pos &lt; 2) {
3397                 return din.readUnsignedShort();
3398             }
3399             int v = Bits.getShort(buf, pos) &amp; 0xFFFF;
3400             pos += 2;
3401             return v;
3402         }
3403 
3404         public int readInt() throws IOException {
3405             if (!blkmode) {
3406                 pos = 0;
3407                 in.readFully(buf, 0, 4);
3408             } else if (end - pos &lt; 4) {
3409                 return din.readInt();
3410             }
3411             int v = Bits.getInt(buf, pos);
3412             pos += 4;
3413             return v;
3414         }
3415 
3416         public float readFloat() throws IOException {
3417             if (!blkmode) {
3418                 pos = 0;
3419                 in.readFully(buf, 0, 4);
3420             } else if (end - pos &lt; 4) {
3421                 return din.readFloat();
3422             }
3423             float v = Bits.getFloat(buf, pos);
3424             pos += 4;
3425             return v;
3426         }
3427 
3428         public long readLong() throws IOException {
3429             if (!blkmode) {
3430                 pos = 0;
3431                 in.readFully(buf, 0, 8);
3432             } else if (end - pos &lt; 8) {
3433                 return din.readLong();
3434             }
3435             long v = Bits.getLong(buf, pos);
3436             pos += 8;
3437             return v;
3438         }
3439 
3440         public double readDouble() throws IOException {
3441             if (!blkmode) {
3442                 pos = 0;
3443                 in.readFully(buf, 0, 8);
3444             } else if (end - pos &lt; 8) {
3445                 return din.readDouble();
3446             }
3447             double v = Bits.getDouble(buf, pos);
3448             pos += 8;
3449             return v;
3450         }
3451 
3452         public String readUTF() throws IOException {
3453             return readUTFBody(readUnsignedShort());
3454         }
3455 
3456         @SuppressWarnings(&quot;deprecation&quot;)
3457         public String readLine() throws IOException {
3458             return din.readLine();      // deprecated, not worth optimizing
3459         }
3460 
3461         /* -------------- primitive data array input methods --------------- */
3462         /*
3463          * The following methods read in spans of primitive data values.
3464          * Though equivalent to calling the corresponding primitive read
3465          * methods repeatedly, these methods are optimized for reading groups
3466          * of primitive data values more efficiently.
3467          */
3468 
3469         void readBooleans(boolean[] v, int off, int len) throws IOException {
3470             int stop, endoff = off + len;
3471             while (off &lt; endoff) {
3472                 if (!blkmode) {
3473                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE);
3474                     in.readFully(buf, 0, span);
3475                     stop = off + span;
3476                     pos = 0;
3477                 } else if (end - pos &lt; 1) {
3478                     v[off++] = din.readBoolean();
3479                     continue;
3480                 } else {
3481                     stop = Math.min(endoff, off + end - pos);
3482                 }
3483 
3484                 while (off &lt; stop) {
3485                     v[off++] = Bits.getBoolean(buf, pos++);
3486                 }
3487             }
3488         }
3489 
3490         void readChars(char[] v, int off, int len) throws IOException {
3491             int stop, endoff = off + len;
3492             while (off &lt; endoff) {
3493                 if (!blkmode) {
3494                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 1);
3495                     in.readFully(buf, 0, span &lt;&lt; 1);
3496                     stop = off + span;
3497                     pos = 0;
3498                 } else if (end - pos &lt; 2) {
3499                     v[off++] = din.readChar();
3500                     continue;
3501                 } else {
3502                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 1));
3503                 }
3504 
3505                 while (off &lt; stop) {
3506                     v[off++] = Bits.getChar(buf, pos);
3507                     pos += 2;
3508                 }
3509             }
3510         }
3511 
3512         void readShorts(short[] v, int off, int len) throws IOException {
3513             int stop, endoff = off + len;
3514             while (off &lt; endoff) {
3515                 if (!blkmode) {
3516                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 1);
3517                     in.readFully(buf, 0, span &lt;&lt; 1);
3518                     stop = off + span;
3519                     pos = 0;
3520                 } else if (end - pos &lt; 2) {
3521                     v[off++] = din.readShort();
3522                     continue;
3523                 } else {
3524                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 1));
3525                 }
3526 
3527                 while (off &lt; stop) {
3528                     v[off++] = Bits.getShort(buf, pos);
3529                     pos += 2;
3530                 }
3531             }
3532         }
3533 
3534         void readInts(int[] v, int off, int len) throws IOException {
3535             int stop, endoff = off + len;
3536             while (off &lt; endoff) {
3537                 if (!blkmode) {
3538                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);
3539                     in.readFully(buf, 0, span &lt;&lt; 2);
3540                     stop = off + span;
3541                     pos = 0;
3542                 } else if (end - pos &lt; 4) {
3543                     v[off++] = din.readInt();
3544                     continue;
3545                 } else {
3546                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 2));
3547                 }
3548 
3549                 while (off &lt; stop) {
3550                     v[off++] = Bits.getInt(buf, pos);
3551                     pos += 4;
3552                 }
3553             }
3554         }
3555 
3556         void readFloats(float[] v, int off, int len) throws IOException {
3557             int stop, endoff = off + len;
3558             while (off &lt; endoff) {
3559                 if (!blkmode) {
3560                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);
3561                     in.readFully(buf, 0, span &lt;&lt; 2);
3562                     stop = off + span;
3563                     pos = 0;
3564                 } else if (end - pos &lt; 4) {
3565                     v[off++] = din.readFloat();
3566                     continue;
3567                 } else {
3568                     stop = Math.min(endoff, ((end - pos) &gt;&gt; 2));
3569                 }
3570 
3571                 while (off &lt; stop) {
3572                     v[off++] = Bits.getFloat(buf, pos);
3573                     pos += 4;
3574                 }
3575             }
3576         }
3577 
3578         void readLongs(long[] v, int off, int len) throws IOException {
3579             int stop, endoff = off + len;
3580             while (off &lt; endoff) {
3581                 if (!blkmode) {
3582                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);
3583                     in.readFully(buf, 0, span &lt;&lt; 3);
3584                     stop = off + span;
3585                     pos = 0;
3586                 } else if (end - pos &lt; 8) {
3587                     v[off++] = din.readLong();
3588                     continue;
3589                 } else {
3590                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 3));
3591                 }
3592 
3593                 while (off &lt; stop) {
3594                     v[off++] = Bits.getLong(buf, pos);
3595                     pos += 8;
3596                 }
3597             }
3598         }
3599 
3600         void readDoubles(double[] v, int off, int len) throws IOException {
3601             int stop, endoff = off + len;
3602             while (off &lt; endoff) {
3603                 if (!blkmode) {
3604                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);
3605                     in.readFully(buf, 0, span &lt;&lt; 3);
3606                     stop = off + span;
3607                     pos = 0;
3608                 } else if (end - pos &lt; 8) {
3609                     v[off++] = din.readDouble();
3610                     continue;
3611                 } else {
3612                     stop = Math.min(endoff - off, ((end - pos) &gt;&gt; 3));
3613                 }
3614 
3615                 while (off &lt; stop) {
3616                     v[off++] = Bits.getDouble(buf, pos);
3617                     pos += 8;
3618                 }
3619             }
3620         }
3621 
3622         /**
3623          * Reads in string written in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
3624          * identical to standard UTF, except that it uses an 8 byte header
3625          * (instead of the standard 2 bytes) to convey the UTF encoding length.
3626          */
3627         String readLongUTF() throws IOException {
3628             return readUTFBody(readLong());
3629         }
3630 
3631         /**
3632          * Reads in the &quot;body&quot; (i.e., the UTF representation minus the 2-byte
3633          * or 8-byte length header) of a UTF encoding, which occupies the next
3634          * utflen bytes.
3635          */
3636         private String readUTFBody(long utflen) throws IOException {
3637             StringBuilder sbuf;
3638             if (utflen &gt; 0 &amp;&amp; utflen &lt; Integer.MAX_VALUE) {
3639                 // a reasonable initial capacity based on the UTF length
3640                 int initialCapacity = Math.min((int)utflen, 0xFFFF);
3641                 sbuf = new StringBuilder(initialCapacity);
3642             } else {
3643                 sbuf = new StringBuilder();
3644             }
3645 
3646             if (!blkmode) {
3647                 end = pos = 0;
3648             }
3649 
3650             while (utflen &gt; 0) {
3651                 int avail = end - pos;
3652                 if (avail &gt;= 3 || (long) avail == utflen) {
3653                     utflen -= readUTFSpan(sbuf, utflen);
3654                 } else {
3655                     if (blkmode) {
3656                         // near block boundary, read one byte at a time
3657                         utflen -= readUTFChar(sbuf, utflen);
3658                     } else {
3659                         // shift and refill buffer manually
3660                         if (avail &gt; 0) {
3661                             System.arraycopy(buf, pos, buf, 0, avail);
3662                         }
3663                         pos = 0;
3664                         end = (int) Math.min(MAX_BLOCK_SIZE, utflen);
3665                         in.readFully(buf, avail, end - avail);
3666                     }
3667                 }
3668             }
3669 
3670             return sbuf.toString();
3671         }
3672 
3673         /**
3674          * Reads span of UTF-encoded characters out of internal buffer
3675          * (starting at offset pos and ending at or before offset end),
3676          * consuming no more than utflen bytes.  Appends read characters to
3677          * sbuf.  Returns the number of bytes consumed.
3678          */
3679         private long readUTFSpan(StringBuilder sbuf, long utflen)
3680             throws IOException
3681         {
3682             int cpos = 0;
3683             int start = pos;
3684             int avail = Math.min(end - pos, CHAR_BUF_SIZE);
3685             // stop short of last char unless all of utf bytes in buffer
3686             int stop = pos + ((utflen &gt; avail) ? avail - 2 : (int) utflen);
3687             boolean outOfBounds = false;
3688 
3689             try {
3690                 while (pos &lt; stop) {
3691                     int b1, b2, b3;
3692                     b1 = buf[pos++] &amp; 0xFF;
3693                     switch (b1 &gt;&gt; 4) {
3694                         case 0:
3695                         case 1:
3696                         case 2:
3697                         case 3:
3698                         case 4:
3699                         case 5:
3700                         case 6:
3701                         case 7:   // 1 byte format: 0xxxxxxx
3702                             cbuf[cpos++] = (char) b1;
3703                             break;
3704 
3705                         case 12:
3706                         case 13:  // 2 byte format: 110xxxxx 10xxxxxx
3707                             b2 = buf[pos++];
3708                             if ((b2 &amp; 0xC0) != 0x80) {
3709                                 throw new UTFDataFormatException();
3710                             }
3711                             cbuf[cpos++] = (char) (((b1 &amp; 0x1F) &lt;&lt; 6) |
3712                                                    ((b2 &amp; 0x3F) &lt;&lt; 0));
3713                             break;
3714 
3715                         case 14:  // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx
3716                             b3 = buf[pos + 1];
3717                             b2 = buf[pos + 0];
3718                             pos += 2;
3719                             if ((b2 &amp; 0xC0) != 0x80 || (b3 &amp; 0xC0) != 0x80) {
3720                                 throw new UTFDataFormatException();
3721                             }
3722                             cbuf[cpos++] = (char) (((b1 &amp; 0x0F) &lt;&lt; 12) |
3723                                                    ((b2 &amp; 0x3F) &lt;&lt; 6) |
3724                                                    ((b3 &amp; 0x3F) &lt;&lt; 0));
3725                             break;
3726 
3727                         default:  // 10xx xxxx, 1111 xxxx
3728                             throw new UTFDataFormatException();
3729                     }
3730                 }
3731             } catch (ArrayIndexOutOfBoundsException ex) {
3732                 outOfBounds = true;
3733             } finally {
3734                 if (outOfBounds || (pos - start) &gt; utflen) {
3735                     /*
3736                      * Fix for 4450867: if a malformed utf char causes the
3737                      * conversion loop to scan past the expected end of the utf
3738                      * string, only consume the expected number of utf bytes.
3739                      */
3740                     pos = start + (int) utflen;
3741                     throw new UTFDataFormatException();
3742                 }
3743             }
3744 
3745             sbuf.append(cbuf, 0, cpos);
3746             return pos - start;
3747         }
3748 
3749         /**
3750          * Reads in single UTF-encoded character one byte at a time, appends
3751          * the character to sbuf, and returns the number of bytes consumed.
3752          * This method is used when reading in UTF strings written in block
3753          * data mode to handle UTF-encoded characters which (potentially)
3754          * straddle block-data boundaries.
3755          */
3756         private int readUTFChar(StringBuilder sbuf, long utflen)
3757             throws IOException
3758         {
3759             int b1, b2, b3;
3760             b1 = readByte() &amp; 0xFF;
3761             switch (b1 &gt;&gt; 4) {
3762                 case 0:
3763                 case 1:
3764                 case 2:
3765                 case 3:
3766                 case 4:
3767                 case 5:
3768                 case 6:
3769                 case 7:     // 1 byte format: 0xxxxxxx
3770                     sbuf.append((char) b1);
3771                     return 1;
3772 
3773                 case 12:
3774                 case 13:    // 2 byte format: 110xxxxx 10xxxxxx
3775                     if (utflen &lt; 2) {
3776                         throw new UTFDataFormatException();
3777                     }
3778                     b2 = readByte();
3779                     if ((b2 &amp; 0xC0) != 0x80) {
3780                         throw new UTFDataFormatException();
3781                     }
3782                     sbuf.append((char) (((b1 &amp; 0x1F) &lt;&lt; 6) |
3783                                         ((b2 &amp; 0x3F) &lt;&lt; 0)));
3784                     return 2;
3785 
3786                 case 14:    // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx
3787                     if (utflen &lt; 3) {
3788                         if (utflen == 2) {
3789                             readByte();         // consume remaining byte
3790                         }
3791                         throw new UTFDataFormatException();
3792                     }
3793                     b2 = readByte();
3794                     b3 = readByte();
3795                     if ((b2 &amp; 0xC0) != 0x80 || (b3 &amp; 0xC0) != 0x80) {
3796                         throw new UTFDataFormatException();
3797                     }
3798                     sbuf.append((char) (((b1 &amp; 0x0F) &lt;&lt; 12) |
3799                                         ((b2 &amp; 0x3F) &lt;&lt; 6) |
3800                                         ((b3 &amp; 0x3F) &lt;&lt; 0)));
3801                     return 3;
3802 
3803                 default:   // 10xx xxxx, 1111 xxxx
3804                     throw new UTFDataFormatException();
3805             }
3806         }
3807 
3808         /**
3809          * Returns the number of bytes read from the input stream.
3810          * @return the number of bytes read from the input stream
3811          */
3812         long getBytesRead() {
3813             return in.getBytesRead();
3814         }
3815     }
3816 
3817     /**
3818      * Unsynchronized table which tracks wire handle to object mappings, as
3819      * well as ClassNotFoundExceptions associated with deserialized objects.
3820      * This class implements an exception-propagation algorithm for
3821      * determining which objects should have ClassNotFoundExceptions associated
3822      * with them, taking into account cycles and discontinuities (e.g., skipped
3823      * fields) in the object graph.
3824      *
3825      * &lt;p&gt;General use of the table is as follows: during deserialization, a
3826      * given object is first assigned a handle by calling the assign method.
3827      * This method leaves the assigned handle in an &quot;open&quot; state, wherein
3828      * dependencies on the exception status of other handles can be registered
3829      * by calling the markDependency method, or an exception can be directly
3830      * associated with the handle by calling markException.  When a handle is
3831      * tagged with an exception, the HandleTable assumes responsibility for
3832      * propagating the exception to any other objects which depend
3833      * (transitively) on the exception-tagged object.
3834      *
3835      * &lt;p&gt;Once all exception information/dependencies for the handle have been
3836      * registered, the handle should be &quot;closed&quot; by calling the finish method
3837      * on it.  The act of finishing a handle allows the exception propagation
3838      * algorithm to aggressively prune dependency links, lessening the
3839      * performance/memory impact of exception tracking.
3840      *
3841      * &lt;p&gt;Note that the exception propagation algorithm used depends on handles
3842      * being assigned/finished in LIFO order; however, for simplicity as well
3843      * as memory conservation, it does not enforce this constraint.
3844      */
3845     // REMIND: add full description of exception propagation algorithm?
3846     private static class HandleTable {
3847 
3848         /* status codes indicating whether object has associated exception */
3849         private static final byte STATUS_OK = 1;
3850         private static final byte STATUS_UNKNOWN = 2;
3851         private static final byte STATUS_EXCEPTION = 3;
3852 
3853         /** array mapping handle -&gt; object status */
3854         byte[] status;
3855         /** array mapping handle -&gt; object/exception (depending on status) */
3856         Object[] entries;
3857         /** array mapping handle -&gt; list of dependent handles (if any) */
3858         HandleList[] deps;
3859         /** lowest unresolved dependency */
3860         int lowDep = -1;
3861         /** number of handles in table */
3862         int size = 0;
3863 
3864         /**
3865          * Creates handle table with the given initial capacity.
3866          */
3867         HandleTable(int initialCapacity) {
3868             status = new byte[initialCapacity];
3869             entries = new Object[initialCapacity];
3870             deps = new HandleList[initialCapacity];
3871         }
3872 
3873         /**
3874          * Assigns next available handle to given object, and returns assigned
3875          * handle.  Once object has been completely deserialized (and all
3876          * dependencies on other objects identified), the handle should be
3877          * &quot;closed&quot; by passing it to finish().
3878          */
3879         int assign(Object obj) {
3880             if (size &gt;= entries.length) {
3881                 grow();
3882             }
3883             status[size] = STATUS_UNKNOWN;
3884             entries[size] = obj;
3885             return size++;
3886         }
3887 
3888         /**
3889          * Registers a dependency (in exception status) of one handle on
3890          * another.  The dependent handle must be &quot;open&quot; (i.e., assigned, but
3891          * not finished yet).  No action is taken if either dependent or target
3892          * handle is NULL_HANDLE. Additionally, no action is taken if the
3893          * dependent and target are the same.
3894          */
3895         void markDependency(int dependent, int target) {
3896             if (dependent == target || dependent == NULL_HANDLE || target == NULL_HANDLE) {
3897                 return;
3898             }
3899             switch (status[dependent]) {
3900 
3901                 case STATUS_UNKNOWN:
3902                     switch (status[target]) {
3903                         case STATUS_OK:
3904                             // ignore dependencies on objs with no exception
3905                             break;
3906 
3907                         case STATUS_EXCEPTION:
3908                             // eagerly propagate exception
3909                             markException(dependent,
3910                                 (ClassNotFoundException) entries[target]);
3911                             break;
3912 
3913                         case STATUS_UNKNOWN:
3914                             // add to dependency list of target
3915                             if (deps[target] == null) {
3916                                 deps[target] = new HandleList();
3917                             }
3918                             deps[target].add(dependent);
3919 
3920                             // remember lowest unresolved target seen
3921                             if (lowDep &lt; 0 || lowDep &gt; target) {
3922                                 lowDep = target;
3923                             }
3924                             break;
3925 
3926                         default:
3927                             throw new InternalError();
3928                     }
3929                     break;
3930 
3931                 case STATUS_EXCEPTION:
3932                     break;
3933 
3934                 default:
3935                     throw new InternalError();
3936             }
3937         }
3938 
3939         /**
3940          * Associates a ClassNotFoundException (if one not already associated)
3941          * with the currently active handle and propagates it to other
3942          * referencing objects as appropriate.  The specified handle must be
3943          * &quot;open&quot; (i.e., assigned, but not finished yet).
3944          */
3945         void markException(int handle, ClassNotFoundException ex) {
3946             switch (status[handle]) {
3947                 case STATUS_UNKNOWN:
3948                     status[handle] = STATUS_EXCEPTION;
3949                     entries[handle] = ex;
3950 
3951                     // propagate exception to dependents
3952                     HandleList dlist = deps[handle];
3953                     if (dlist != null) {
3954                         int ndeps = dlist.size();
3955                         for (int i = 0; i &lt; ndeps; i++) {
3956                             markException(dlist.get(i), ex);
3957                         }
3958                         deps[handle] = null;
3959                     }
3960                     break;
3961 
3962                 case STATUS_EXCEPTION:
3963                     break;
3964 
3965                 default:
3966                     throw new InternalError();
3967             }
3968         }
3969 
3970         /**
3971          * Marks given handle as finished, meaning that no new dependencies
3972          * will be marked for handle.  Calls to the assign and finish methods
3973          * must occur in LIFO order.
3974          */
3975         void finish(int handle) {
3976             int end;
3977             if (lowDep &lt; 0) {
3978                 // no pending unknowns, only resolve current handle
3979                 end = handle + 1;
3980             } else if (lowDep &gt;= handle) {
3981                 // pending unknowns now clearable, resolve all upward handles
3982                 end = size;
3983                 lowDep = -1;
3984             } else {
3985                 // unresolved backrefs present, can&#39;t resolve anything yet
3986                 return;
3987             }
3988 
3989             // change STATUS_UNKNOWN -&gt; STATUS_OK in selected span of handles
3990             for (int i = handle; i &lt; end; i++) {
3991                 switch (status[i]) {
3992                     case STATUS_UNKNOWN:
3993                         status[i] = STATUS_OK;
3994                         deps[i] = null;
3995                         break;
3996 
3997                     case STATUS_OK:
3998                     case STATUS_EXCEPTION:
3999                         break;
4000 
4001                     default:
4002                         throw new InternalError();
4003                 }
4004             }
4005         }
4006 
4007         /**
4008          * Assigns a new object to the given handle.  The object previously
4009          * associated with the handle is forgotten.  This method has no effect
4010          * if the given handle already has an exception associated with it.
4011          * This method may be called at any time after the handle is assigned.
4012          */
4013         void setObject(int handle, Object obj) {
4014             switch (status[handle]) {
4015                 case STATUS_UNKNOWN:
4016                 case STATUS_OK:
4017                     entries[handle] = obj;
4018                     break;
4019 
4020                 case STATUS_EXCEPTION:
4021                     break;
4022 
4023                 default:
4024                     throw new InternalError();
4025             }
4026         }
4027 
4028         /**
4029          * Looks up and returns object associated with the given handle.
4030          * Returns null if the given handle is NULL_HANDLE, or if it has an
4031          * associated ClassNotFoundException.
4032          */
4033         Object lookupObject(int handle) {
4034             return (handle != NULL_HANDLE &amp;&amp;
4035                     status[handle] != STATUS_EXCEPTION) ?
4036                 entries[handle] : null;
4037         }
4038 
4039         /**
4040          * Looks up and returns ClassNotFoundException associated with the
4041          * given handle.  Returns null if the given handle is NULL_HANDLE, or
4042          * if there is no ClassNotFoundException associated with the handle.
4043          */
4044         ClassNotFoundException lookupException(int handle) {
4045             return (handle != NULL_HANDLE &amp;&amp;
4046                     status[handle] == STATUS_EXCEPTION) ?
4047                 (ClassNotFoundException) entries[handle] : null;
4048         }
4049 
4050         /**
4051          * Resets table to its initial state.
4052          */
4053         void clear() {
4054             Arrays.fill(status, 0, size, (byte) 0);
4055             Arrays.fill(entries, 0, size, null);
4056             Arrays.fill(deps, 0, size, null);
4057             lowDep = -1;
4058             size = 0;
4059         }
4060 
4061         /**
4062          * Returns number of handles registered in table.
4063          */
4064         int size() {
4065             return size;
4066         }
4067 
4068         /**
4069          * Expands capacity of internal arrays.
4070          */
4071         private void grow() {
4072             int newCapacity = (entries.length &lt;&lt; 1) + 1;
4073 
4074             byte[] newStatus = new byte[newCapacity];
4075             Object[] newEntries = new Object[newCapacity];
4076             HandleList[] newDeps = new HandleList[newCapacity];
4077 
4078             System.arraycopy(status, 0, newStatus, 0, size);
4079             System.arraycopy(entries, 0, newEntries, 0, size);
4080             System.arraycopy(deps, 0, newDeps, 0, size);
4081 
4082             status = newStatus;
4083             entries = newEntries;
4084             deps = newDeps;
4085         }
4086 
4087         /**
4088          * Simple growable list of (integer) handles.
4089          */
4090         private static class HandleList {
4091             private int[] list = new int[4];
4092             private int size = 0;
4093 
4094             public HandleList() {
4095             }
4096 
4097             public void add(int handle) {
4098                 if (size &gt;= list.length) {
4099                     int[] newList = new int[list.length &lt;&lt; 1];
4100                     System.arraycopy(list, 0, newList, 0, list.length);
4101                     list = newList;
4102                 }
4103                 list[size++] = handle;
4104             }
4105 
4106             public int get(int index) {
4107                 if (index &gt;= size) {
4108                     throw new ArrayIndexOutOfBoundsException();
4109                 }
4110                 return list[index];
4111             }
4112 
4113             public int size() {
4114                 return size;
4115             }
4116         }
4117     }
4118 
4119     /**
4120      * Method for cloning arrays in case of using unsharing reading
4121      */
4122     private static Object cloneArray(Object array) {
4123         if (array instanceof Object[]) {
4124             return ((Object[]) array).clone();
4125         } else if (array instanceof boolean[]) {
4126             return ((boolean[]) array).clone();
4127         } else if (array instanceof byte[]) {
4128             return ((byte[]) array).clone();
4129         } else if (array instanceof char[]) {
4130             return ((char[]) array).clone();
4131         } else if (array instanceof double[]) {
4132             return ((double[]) array).clone();
4133         } else if (array instanceof float[]) {
4134             return ((float[]) array).clone();
4135         } else if (array instanceof int[]) {
4136             return ((int[]) array).clone();
4137         } else if (array instanceof long[]) {
4138             return ((long[]) array).clone();
4139         } else if (array instanceof short[]) {
4140             return ((short[]) array).clone();
4141         } else {
4142             throw new AssertionError();
4143         }
4144     }
4145 
4146     static {
4147         SharedSecrets.setJavaObjectInputStreamAccess(ObjectInputStream::checkArray);
4148         SharedSecrets.setJavaObjectInputStreamReadString(ObjectInputStream::readString);
4149     }
4150 
4151 }
    </pre>
  </body>
</html>
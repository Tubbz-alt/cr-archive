<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/nio/file/FileSystems.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.nio.file;
 27 
 28 import java.nio.file.spi.FileSystemProvider;
 29 import java.net.URI;
 30 import java.io.IOException;
 31 import java.security.AccessController;
 32 import java.security.PrivilegedAction;
 33 import java.lang.reflect.Constructor;
 34 import java.util.Collections;
 35 import java.util.Map;
 36 import java.util.ServiceConfigurationError;
 37 import java.util.ServiceLoader;
 38 
 39 import jdk.internal.misc.VM;
 40 import sun.nio.fs.DefaultFileSystemProvider;
 41 
 42 /**
 43  * Factory methods for file systems. This class defines the {@link #getDefault
 44  * getDefault} method to get the default file system and factory methods to
 45  * construct other types of file systems.
 46  *
 47  * &lt;p&gt; The first invocation of any of the methods defined by this class causes
 48  * the default {@link FileSystemProvider provider} to be loaded. The default
 49  * provider, identified by the URI scheme &quot;file&quot;, creates the {@link FileSystem}
 50  * that provides access to the file systems accessible to the Java virtual
 51  * machine. If the process of loading or initializing the default provider fails
 52  * then an unspecified error is thrown.
 53  *
 54  * &lt;p&gt; The first invocation of the {@link FileSystemProvider#installedProviders()
 55  * installedProviders} method, by way of invoking any of the {@code
 56  * newFileSystem} methods defined by this class, locates and loads all
 57  * installed file system providers. Installed providers are loaded using the
 58  * service-provider loading facility defined by the {@link ServiceLoader} class.
 59  * Installed providers are loaded using the system class loader. If the
 60  * system class loader cannot be found then the platform class loader is used.
 61  * Providers are typically installed by placing them in a JAR file on the
 62  * application class path, the JAR file contains a
 63  * provider-configuration file named {@code java.nio.file.spi.FileSystemProvider}
 64  * in the resource directory {@code META-INF/services}, and the file lists one or
 65  * more fully-qualified names of concrete subclass of {@link FileSystemProvider}
 66  * that have a zero argument constructor.
 67  * The ordering that installed providers are located is implementation specific.
 68  * If a provider is instantiated and its {@link FileSystemProvider#getScheme()
 69  * getScheme} returns the same URI scheme of a provider that was previously
 70  * instantiated then the most recently instantiated duplicate is discarded. URI
 71  * schemes are compared without regard to case. During construction a provider
 72  * may safely access files associated with the default provider but care needs
 73  * to be taken to avoid circular loading of other installed providers. If
 74  * circular loading of installed providers is detected then an unspecified error
 75  * is thrown.
 76  *
 77  * &lt;p&gt; This class also defines factory methods that allow a {@link ClassLoader}
 78  * to be specified when locating a provider. As with installed providers, the
 79  * provider classes are identified by placing the provider configuration file
 80  * in the resource directory {@code META-INF/services}.
 81  *
 82  * &lt;p&gt; If a thread initiates the loading of the installed file system providers
 83  * and another thread invokes a method that also attempts to load the providers
 84  * then the method will block until the loading completes.
 85  *
 86  * @since 1.7
 87  */
 88 
 89 public final class FileSystems {
 90     private FileSystems() { }
 91 
 92     // lazy initialization of default file system
 93     private static class DefaultFileSystemHolder {
 94         static final FileSystem defaultFileSystem = defaultFileSystem();
 95 
 96         // returns default file system
 97         private static FileSystem defaultFileSystem() {
 98             // load default provider
 99             FileSystemProvider provider = AccessController
100                 .doPrivileged(new PrivilegedAction&lt;&gt;() {
101                     public FileSystemProvider run() {
102                         return getDefaultProvider();
103                     }
104                 });
105 
106             // return file system
107             return provider.getFileSystem(URI.create(&quot;file:///&quot;));
108         }
109 
110         // returns default provider
111         private static FileSystemProvider getDefaultProvider() {
112             // start with the platform&#39;s default file system provider
113             FileSystemProvider provider = DefaultFileSystemProvider.instance();
114 
115             // if the property java.nio.file.spi.DefaultFileSystemProvider is
116             // set then its value is the name of the default provider (or a list)
117             String prop = &quot;java.nio.file.spi.DefaultFileSystemProvider&quot;;
118             String propValue = System.getProperty(prop);
119             if (propValue != null) {
120                 for (String cn: propValue.split(&quot;,&quot;)) {
121                     try {
122                         Class&lt;?&gt; c = Class
123                             .forName(cn, true, ClassLoader.getSystemClassLoader());
124                         Constructor&lt;?&gt; ctor = c
125                             .getDeclaredConstructor(FileSystemProvider.class);
126                         provider = (FileSystemProvider)ctor.newInstance(provider);
127 
128                         // must be &quot;file&quot;
129                         if (!provider.getScheme().equals(&quot;file&quot;))
130                             throw new Error(&quot;Default provider must use scheme &#39;file&#39;&quot;);
131 
132                     } catch (Exception x) {
133                         throw new Error(x);
134                     }
135                 }
136             }
137             return provider;
138         }
139     }
140 
141     /**
142      * Returns the default {@code FileSystem}. The default file system creates
143      * objects that provide access to the file systems accessible to the Java
144      * virtual machine. The &lt;em&gt;working directory&lt;/em&gt; of the file system is
145      * the current user directory, named by the system property {@code user.dir}.
146      * This allows for interoperability with the {@link java.io.File java.io.File}
147      * class.
148      *
149      * &lt;p&gt; The first invocation of any of the methods defined by this class
150      * locates the default {@link FileSystemProvider provider} object. Where the
151      * system property {@code java.nio.file.spi.DefaultFileSystemProvider} is
152      * not defined then the default provider is a system-default provider that
153      * is invoked to create the default file system.
154      *
155      * &lt;p&gt; If the system property {@code java.nio.file.spi.DefaultFileSystemProvider}
156      * is defined then it is taken to be a list of one or more fully-qualified
157      * names of concrete provider classes identified by the URI scheme
158      * {@code &quot;file&quot;}. Where the property is a list of more than one name then
159      * the names are separated by a comma. Each class is loaded, using the system
160      * class loader, and instantiated by invoking a one argument constructor
161      * whose formal parameter type is {@code FileSystemProvider}. The providers
162      * are loaded and instantiated in the order they are listed in the property.
163      * If this process fails or a provider&#39;s scheme is not equal to {@code &quot;file&quot;}
164      * then an unspecified error is thrown. URI schemes are normally compared
165      * without regard to case but for the default provider, the scheme is
166      * required to be {@code &quot;file&quot;}. The first provider class is instantiated
167      * by invoking it with a reference to the system-default provider.
168      * The second provider class is instantiated by invoking it with a reference
169      * to the first provider instance. The third provider class is instantiated
170      * by invoking it with a reference to the second instance, and so on. The
171      * last provider to be instantiated becomes the default provider; its {@code
172      * getFileSystem} method is invoked with the URI {@code &quot;file:///&quot;} to
173      * get a reference to the default file system.
174      *
175      * &lt;p&gt; Subsequent invocations of this method return the file system that was
176      * returned by the first invocation.
177      *
178      * @return  the default file system
179      */
180     public static FileSystem getDefault() {
181         if (VM.isModuleSystemInited()) {
182             return DefaultFileSystemHolder.defaultFileSystem;
183         } else {
184             // always use the platform&#39;s default file system during startup
185             return DefaultFileSystemProvider.theFileSystem();
186         }
187     }
188 
189     /**
190      * Returns a reference to an existing {@code FileSystem}.
191      *
192      * &lt;p&gt; This method iterates over the {@link FileSystemProvider#installedProviders()
193      * installed} providers to locate the provider that is identified by the URI
194      * {@link URI#getScheme scheme} of the given URI. URI schemes are compared
195      * without regard to case. The exact form of the URI is highly provider
196      * dependent. If found, the provider&#39;s {@link FileSystemProvider#getFileSystem
197      * getFileSystem} method is invoked to obtain a reference to the {@code
198      * FileSystem}.
199      *
200      * &lt;p&gt; Once a file system created by this provider is {@link FileSystem#close
201      * closed} it is provider-dependent if this method returns a reference to
202      * the closed file system or throws {@link FileSystemNotFoundException}.
203      * If the provider allows a new file system to be created with the same URI
204      * as a file system it previously created then this method throws the
205      * exception if invoked after the file system is closed (and before a new
206      * instance is created by the {@link #newFileSystem newFileSystem} method).
207      *
208      * &lt;p&gt; If a security manager is installed then a provider implementation
209      * may require to check a permission before returning a reference to an
210      * existing file system. In the case of the {@link FileSystems#getDefault
211      * default} file system, no permission check is required.
212      *
213      * @param   uri  the URI to locate the file system
214      *
215      * @return  the reference to the file system
216      *
217      * @throws  IllegalArgumentException
218      *          if the pre-conditions for the {@code uri} parameter are not met
219      * @throws  FileSystemNotFoundException
220      *          if the file system, identified by the URI, does not exist
221      * @throws  ProviderNotFoundException
222      *          if a provider supporting the URI scheme is not installed
223      * @throws  SecurityException
224      *          if a security manager is installed and it denies an unspecified
225      *          permission
226      */
227     public static FileSystem getFileSystem(URI uri) {
228         String scheme = uri.getScheme();
<a name="2" id="anc2"></a>


229         for (FileSystemProvider provider: FileSystemProvider.installedProviders()) {
230             if (scheme.equalsIgnoreCase(provider.getScheme())) {
231                 return provider.getFileSystem(uri);
232             }
233         }
234         throw new ProviderNotFoundException(&quot;Provider \&quot;&quot; + scheme + &quot;\&quot; not found&quot;);
235     }
236 
237     /**
238      * Constructs a new file system that is identified by a {@link URI}
239      *
240      * &lt;p&gt; This method iterates over the {@link FileSystemProvider#installedProviders()
241      * installed} providers to locate the provider that is identified by the URI
242      * {@link URI#getScheme scheme} of the given URI. URI schemes are compared
243      * without regard to case. The exact form of the URI is highly provider
244      * dependent. If found, the provider&#39;s {@link FileSystemProvider#newFileSystem(URI,Map)
245      * newFileSystem(URI,Map)} method is invoked to construct the new file system.
246      *
247      * &lt;p&gt; Once a file system is {@link FileSystem#close closed} it is
248      * provider-dependent if the provider allows a new file system to be created
249      * with the same URI as a file system it previously created.
250      *
251      * &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
252      * Suppose there is a provider identified by the scheme {@code &quot;memory&quot;}
253      * installed:
254      * &lt;pre&gt;
255      *  FileSystem fs = FileSystems.newFileSystem(URI.create(&quot;memory:///?name=logfs&quot;),
256      *                                            Map.of(&quot;capacity&quot;, &quot;16G&quot;, &quot;blockSize&quot;, &quot;4k&quot;));
257      * &lt;/pre&gt;
258      *
259      * @param   uri
260      *          the URI identifying the file system
261      * @param   env
262      *          a map of provider specific properties to configure the file system;
263      *          may be empty
264      *
265      * @return  a new file system
266      *
267      * @throws  IllegalArgumentException
268      *          if the pre-conditions for the {@code uri} parameter are not met,
269      *          or the {@code env} parameter does not contain properties required
270      *          by the provider, or a property value is invalid
271      * @throws  FileSystemAlreadyExistsException
272      *          if the file system has already been created
273      * @throws  ProviderNotFoundException
274      *          if a provider supporting the URI scheme is not installed
275      * @throws  IOException
276      *          if an I/O error occurs creating the file system
277      * @throws  SecurityException
278      *          if a security manager is installed and it denies an unspecified
279      *          permission required by the file system provider implementation
280      */
281     public static FileSystem newFileSystem(URI uri, Map&lt;String,?&gt; env)
282         throws IOException
283     {
284         return newFileSystem(uri, env, null);
285     }
286 
287     /**
288      * Constructs a new file system that is identified by a {@link URI}
289      *
290      * &lt;p&gt; This method first attempts to locate an installed provider in exactly
291      * the same manner as the {@link #newFileSystem(URI,Map) newFileSystem(URI,Map)}
292      * method. If none of the installed providers support the URI scheme then an
293      * attempt is made to locate the provider using the given class loader. If a
294      * provider supporting the URI scheme is located then its {@link
295      * FileSystemProvider#newFileSystem(URI,Map) newFileSystem(URI,Map)} is
296      * invoked to construct the new file system.
297      *
298      * @param   uri
299      *          the URI identifying the file system
300      * @param   env
301      *          a map of provider specific properties to configure the file system;
302      *          may be empty
303      * @param   loader
304      *          the class loader to locate the provider or {@code null} to only
305      *          attempt to locate an installed provider
306      *
307      * @return  a new file system
308      *
309      * @throws  IllegalArgumentException
310      *          if the pre-conditions for the {@code uri} parameter are not met,
311      *          or the {@code env} parameter does not contain properties required
312      *          by the provider, or a property value is invalid
313      * @throws  FileSystemAlreadyExistsException
314      *          if the URI scheme identifies an installed provider and the file
315      *          system has already been created
316      * @throws  ProviderNotFoundException
317      *          if a provider supporting the URI scheme is not found
318      * @throws  ServiceConfigurationError
319      *          when an error occurs while loading a service provider
320      * @throws  IOException
321      *          an I/O error occurs creating the file system
322      * @throws  SecurityException
323      *          if a security manager is installed and it denies an unspecified
324      *          permission required by the file system provider implementation
325      */
326     public static FileSystem newFileSystem(URI uri, Map&lt;String,?&gt; env, ClassLoader loader)
327         throws IOException
328     {
329         String scheme = uri.getScheme();
330 
331         // check installed providers
332         for (FileSystemProvider provider : FileSystemProvider.installedProviders()) {
333             if (scheme.equalsIgnoreCase(provider.getScheme())) {
334                 try {
335                     return provider.newFileSystem(uri, env);
336                 } catch (UnsupportedOperationException uoe) {
337                 }
338             }
339         }
340 
341         // if not found, use service-provider loading facility
342         if (loader != null) {
343             ServiceLoader&lt;FileSystemProvider&gt; sl = ServiceLoader
344                 .load(FileSystemProvider.class, loader);
345             for (FileSystemProvider provider : sl) {
346                 if (scheme.equalsIgnoreCase(provider.getScheme())) {
347                     try {
348                         return provider.newFileSystem(uri, env);
349                     } catch (UnsupportedOperationException uoe) {
350                     }
351                 }
352             }
353         }
354 
355         throw new ProviderNotFoundException(&quot;Provider \&quot;&quot; + scheme + &quot;\&quot; not found&quot;);
356     }
357 
358     /**
359      * Constructs a new {@code FileSystem} to access the contents of a file as a
360      * file system.
361      *
362      * &lt;p&gt; This method makes use of specialized providers that create pseudo file
363      * systems where the contents of one or more files is treated as a file
364      * system.
365      *
366      * &lt;p&gt; This method first attempts to locate an installed provider in exactly
367      * the same manner as the {@link #newFileSystem(Path, Map, ClassLoader)
368      * newFileSystem(Path, Map, ClassLoader)} method with an empty map. If none
369      * of the installed providers return a {@code FileSystem} then an attempt is
370      * made to locate the provider using the given class loader. If a provider
371      * returns a file system then the lookup terminates and the file system is
372      * returned.
373      *
374      * @param   path
375      *          the path to the file
376      * @param   loader
377      *          the class loader to locate the provider or {@code null} to only
378      *          attempt to locate an installed provider
379      *
380      * @return  a new file system
381      *
382      * @throws  ProviderNotFoundException
383      *          if a provider supporting this file type cannot be located
384      * @throws  ServiceConfigurationError
385      *          when an error occurs while loading a service provider
386      * @throws  IOException
387      *          if an I/O error occurs
388      * @throws  SecurityException
389      *          if a security manager is installed and it denies an unspecified
390      *          permission
391      */
392     public static FileSystem newFileSystem(Path path,
393                                            ClassLoader loader)
394         throws IOException
395     {
396         return newFileSystem(path, Map.of(), loader);
397     }
398 
399     /**
400      * Constructs a new {@code FileSystem} to access the contents of a file as a
401      * file system.
402      *
403      * &lt;p&gt; This method makes use of specialized providers that create pseudo file
404      * systems where the contents of one or more files is treated as a file
405      * system.
406      *
407      * &lt;p&gt; This method first attempts to locate an installed provider in exactly
408      * the same manner as the {@link #newFileSystem(Path,Map,ClassLoader)
409      * newFileSystem(Path, Map, ClassLoader)} method. If found, the provider&#39;s
410      * {@link FileSystemProvider#newFileSystem(Path, Map) newFileSystem(Path, Map)}
411      * method is invoked to construct the new file system.
412      *
413      * @param   path
414      *          the path to the file
415      * @param   env
416      *          a map of provider specific properties to configure the file system;
417      *          may be empty
418      *
419      * @return  a new file system
420      *
421      * @throws  ProviderNotFoundException
422      *          if a provider supporting this file type cannot be located
423      * @throws  ServiceConfigurationError
424      *          when an error occurs while loading a service provider
425      * @throws  IOException
426      *          if an I/O error occurs
427      * @throws  SecurityException
428      *          if a security manager is installed and it denies an unspecified
429      *          permission
430      *
431      * @since 13
432      */
433     public static FileSystem newFileSystem(Path path, Map&lt;String,?&gt; env)
434         throws IOException
435     {
436         return newFileSystem(path, env, null);
437     }
438 
439     /**
440      * Constructs a new {@code FileSystem} to access the contents of a file as a
441      * file system.
442      *
443      * &lt;p&gt; This method makes use of specialized providers that create pseudo file
444      * systems where the contents of one or more files is treated as a file
445      * system.
446      *
447      * &lt;p&gt; This method first attempts to locate an installed provider in exactly
448      * the same manner as the {@link #newFileSystem(Path,Map,ClassLoader)
449      * newFileSystem(Path, Map, ClassLoader)} method. If found, the provider&#39;s
450      * {@link FileSystemProvider#newFileSystem(Path, Map) newFileSystem(Path, Map)}
451      * method is invoked with an empty map to construct the new file system.
452      *
453      * @param   path
454      *          the path to the file
455      *
456      * @return  a new file system
457      *
458      * @throws  ProviderNotFoundException
459      *          if a provider supporting this file type cannot be located
460      * @throws  ServiceConfigurationError
461      *          when an error occurs while loading a service provider
462      * @throws  IOException
463      *          if an I/O error occurs
464      * @throws  SecurityException
465      *          if a security manager is installed and it denies an unspecified
466      *          permission
467      *
468      * @since 13
469      */
470     public static FileSystem newFileSystem(Path path) throws IOException {
471         return newFileSystem(path, Map.of(), null);
472     }
473 
474     /**
475      * Constructs a new {@code FileSystem} to access the contents of a file as a
476      * file system.
477      *
478      * &lt;p&gt; This method makes use of specialized providers that create pseudo file
479      * systems where the contents of one or more files is treated as a file
480      * system.
481      *
482      * &lt;p&gt; This method iterates over the {@link FileSystemProvider#installedProviders()
483      * installed} providers. It invokes, in turn, each provider&#39;s {@link
484      * FileSystemProvider#newFileSystem(Path,Map) newFileSystem(Path,Map)}
485      * method. If a provider returns a file system then the iteration
486      * terminates and the file system is returned.
487      * If none of the installed providers return a {@code FileSystem} then
488      * an attempt is made to locate the provider using the given class loader.
489      * If a provider returns a file
490      * system, then the lookup terminates and the file system is returned.
491      *
492      * @param   path
493      *          the path to the file
494      * @param   env
495      *          a map of provider specific properties to configure the file system;
496      *          may be empty
497      * @param   loader
498      *          the class loader to locate the provider or {@code null} to only
499      *          attempt to locate an installed provider
500      *
501      * @return  a new file system
502      *
503      * @throws  ProviderNotFoundException
504      *          if a provider supporting this file type cannot be located
505      * @throws  ServiceConfigurationError
506      *          when an error occurs while loading a service provider
507      * @throws  IOException
508      *          if an I/O error occurs
509      * @throws  SecurityException
510      *          if a security manager is installed and it denies an unspecified
511      *          permission
512      *
513      * @since 13
514      */
515     public static FileSystem newFileSystem(Path path, Map&lt;String,?&gt; env,
516                                            ClassLoader loader)
517         throws IOException
518     {
519         if (path == null)
520             throw new NullPointerException();
521         // check installed providers
522         for (FileSystemProvider provider: FileSystemProvider.installedProviders()) {
523             try {
524                 return provider.newFileSystem(path, env);
525             } catch (UnsupportedOperationException uoe) {
526             }
527         }
528 
529         // if not found, use service-provider loading facility
530         if (loader != null) {
531             ServiceLoader&lt;FileSystemProvider&gt; sl = ServiceLoader
532                 .load(FileSystemProvider.class, loader);
533             for (FileSystemProvider provider: sl) {
534                 try {
535                     return provider.newFileSystem(path, env);
536                 } catch (UnsupportedOperationException uoe) {
537                 }
538             }
539         }
540 
541         throw new ProviderNotFoundException(&quot;Provider not found&quot;);
542     }
543 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/util/regex/Grapheme.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../jar/JarFile.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Pattern.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/regex/Grapheme.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,49 ***</span>
  import java.util.Objects;
  
  final class Grapheme {
  
      /**
<span class="line-modified">!      * Determines if there is an extended  grapheme cluster boundary between two</span>
<span class="line-modified">!      * continuing characters {@code cp1} and {@code cp2}.</span>
<span class="line-removed">-      * &lt;p&gt;</span>
<span class="line-removed">-      * See Unicode Standard Annex #29 Unicode Text Segmentation for the specification</span>
<span class="line-removed">-      * for the extended grapheme cluster boundary rules</span>
<span class="line-removed">-      * &lt;p&gt;</span>
<span class="line-removed">-      * Note: this method does not take care of stateful breaking.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     static boolean isBoundary(int cp1, int cp2) {</span>
<span class="line-removed">-         return rules[getType(cp1)][getType(cp2)];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Look for the next extended grapheme cluster boundary in a CharSequence. It assumes</span>
<span class="line-removed">-      * the start of the char sequence is a boundary.</span>
       * &lt;p&gt;
       * See Unicode Standard Annex #29 Unicode Text Segmentation for the specification
       * for the extended grapheme cluster boundary rules. The following implementation
       * is based on version 12.0 of the annex.
       * (http://www.unicode.org/reports/tr29/tr29-35.html)
       *
       * @param src the {@code CharSequence} to be scanned
       * @param off offset to start looking for the next boundary in the src
       * @param limit limit offset in the src (exclusive)
<span class="line-modified">!      * @return the next possible boundary</span>
       */
      static int nextBoundary(CharSequence src, int off, int limit) {
          Objects.checkFromToIndex(off, limit, src.length());
  
<span class="line-modified">!         int ch0 = Character.codePointAt(src, 0);</span>
<span class="line-modified">!         int ret = Character.charCount(ch0);</span>
<span class="line-removed">-         int ch1;</span>
          // indicates whether gb11 or gb12 is underway
<span class="line-modified">!         int t0 = getGraphemeType(ch0);</span>
          int riCount = t0 == RI ? 1 : 0;
          boolean gb11 = t0 == EXTENDED_PICTOGRAPHIC;
          while (ret &lt; limit) {
<span class="line-modified">!             ch1 = Character.codePointAt(src, ret);</span>
<span class="line-modified">!             int t1 = getGraphemeType(ch1);</span>
  
              if (gb11 &amp;&amp; t0 == ZWJ &amp;&amp; t1 == EXTENDED_PICTOGRAPHIC) {
                  // continue for gb11
              } else if (riCount % 2 == 1 &amp;&amp; t0 == RI &amp;&amp; t1 == RI) {
                  // continue for gb12
<span class="line-new-header">--- 28,35 ---</span>
  import java.util.Objects;
  
  final class Grapheme {
  
      /**
<span class="line-modified">!      * Look for the next extended grapheme cluster boundary in a CharSequence.</span>
<span class="line-modified">!      * It assumes the start of the char sequence at offset {@code off} is a boundary.</span>
       * &lt;p&gt;
       * See Unicode Standard Annex #29 Unicode Text Segmentation for the specification
       * for the extended grapheme cluster boundary rules. The following implementation
       * is based on version 12.0 of the annex.
       * (http://www.unicode.org/reports/tr29/tr29-35.html)
       *
       * @param src the {@code CharSequence} to be scanned
       * @param off offset to start looking for the next boundary in the src
       * @param limit limit offset in the src (exclusive)
<span class="line-modified">!      * @return the next grapheme boundary</span>
       */
      static int nextBoundary(CharSequence src, int off, int limit) {
          Objects.checkFromToIndex(off, limit, src.length());
  
<span class="line-modified">!         int ch0 = Character.codePointAt(src, off);</span>
<span class="line-modified">!         int ret = off + Character.charCount(ch0);</span>
          // indicates whether gb11 or gb12 is underway
<span class="line-modified">!         int t0 = getType(ch0);</span>
          int riCount = t0 == RI ? 1 : 0;
          boolean gb11 = t0 == EXTENDED_PICTOGRAPHIC;
          while (ret &lt; limit) {
<span class="line-modified">!             int ch1 = Character.codePointAt(src, ret);</span>
<span class="line-modified">!             int t1 = getType(ch1);</span>
  
              if (gb11 &amp;&amp; t0 == ZWJ &amp;&amp; t1 == EXTENDED_PICTOGRAPHIC) {
                  // continue for gb11
              } else if (riCount % 2 == 1 &amp;&amp; t0 == RI &amp;&amp; t1 == RI) {
                  // continue for gb12
</pre>
<hr />
<pre>
<span class="line-old-header">*** 175,26 ***</span>
                 cp &gt;= 0x109A &amp;&amp; cp &lt;= 0x109C ||
                 cp == 0x1A61 || cp == 0x1A63 || cp == 0x1A64 ||
                 cp == 0xAA7B || cp == 0xAA7D;
      }
  
<span class="line-modified">!     private static int getGraphemeType(int cp) {</span>
          if (cp &lt; 0x007F) { // ASCII
              if (cp &lt; 32) { // Control characters
                  if (cp == 0x000D)
                      return CR;
                  if (cp == 0x000A)
                      return LF;
                  return CONTROL;
              }
              return OTHER;
          }
<span class="line-removed">-         return getType(cp);</span>
<span class="line-removed">-     }</span>
  
<span class="line-removed">-     @SuppressWarnings(&quot;fallthrough&quot;)</span>
<span class="line-removed">-     private static int getType(int cp) {</span>
          if (EmojiData.isExtendedPictographic(cp)) {
              return EXTENDED_PICTOGRAPHIC;
          }
  
          int type = Character.getType(cp);
<span class="line-new-header">--- 161,23 ---</span>
                 cp &gt;= 0x109A &amp;&amp; cp &lt;= 0x109C ||
                 cp == 0x1A61 || cp == 0x1A63 || cp == 0x1A64 ||
                 cp == 0xAA7B || cp == 0xAA7D;
      }
  
<span class="line-modified">!     @SuppressWarnings(&quot;fallthrough&quot;)</span>
<span class="line-added">+     private static int getType(int cp) {</span>
          if (cp &lt; 0x007F) { // ASCII
              if (cp &lt; 32) { // Control characters
                  if (cp == 0x000D)
                      return CR;
                  if (cp == 0x000A)
                      return LF;
                  return CONTROL;
              }
              return OTHER;
          }
  
          if (EmojiData.isExtendedPictographic(cp)) {
              return EXTENDED_PICTOGRAPHIC;
          }
  
          int type = Character.getType(cp);
</pre>
<center><a href="../jar/JarFile.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Pattern.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.base/share/classes/java/util/zip/ZipFile.java b/src/java.base/share/classes/java/util/zip/ZipFile.java
--- a/src/java.base/share/classes/java/util/zip/ZipFile.java
+++ b/src/java.base/share/classes/java/util/zip/ZipFile.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -48,18 +48,19 @@
 import java.util.Objects;
 import java.util.NoSuchElementException;
 import java.util.Set;
 import java.util.Spliterator;
 import java.util.Spliterators;
+import java.util.TreeSet;
 import java.util.WeakHashMap;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.IntFunction;
 import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.JavaUtilZipFileAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.VM;
 import jdk.internal.perf.PerfCounter;
 import jdk.internal.ref.CleanerFactory;
@@ -1046,23 +1047,40 @@
             }
             return names;
         }
     }
 
+    /**
+     * Returns the versions for which there exists a non-directory
+     * entry that begin with "META-INF/versions/" (case ignored).
+     * This method is used in JarFile, via SharedSecrets, as an
+     * optimization when looking up potentially versioned entries.
+     * Returns an empty array if no versioned entries exist.
+     */
+    private int[] getMetaInfVersions() {
+        synchronized (this) {
+            ensureOpen();
+            return res.zsrc.metaVersions;
+        }
+    }
+
     private static boolean isWindows;
-    private static final JavaLangAccess JLA;
 
     static {
         SharedSecrets.setJavaUtilZipFileAccess(
             new JavaUtilZipFileAccess() {
                 @Override
                 public boolean startsWithLocHeader(ZipFile zip) {
                     return zip.res.zsrc.startsWithLoc;
                 }
                 @Override
-                public String[] getMetaInfEntryNames(ZipFile zip) {
-                    return zip.getMetaInfEntryNames();
+                public String[] getMetaInfEntryNames(JarFile jar) {
+                    return ((ZipFile)jar).getMetaInfEntryNames();
+                }
+                @Override
+                public int[] getMetaInfVersions(JarFile jar) {
+                    return ((ZipFile)jar).getMetaInfVersions();
                 }
                 @Override
                 public JarEntry getEntry(ZipFile zip, String name,
                     Function<String, JarEntry> func) {
                     return (JarEntry)zip.getEntry(name, func);
@@ -1081,24 +1099,28 @@
                 public Stream<String> entryNameStream(ZipFile zip) {
                     return zip.entryNameStream();
                 }
              }
         );
-        JLA = SharedSecrets.getJavaLangAccess();
         isWindows = VM.getSavedProperty("os.name").contains("Windows");
     }
 
     private static class Source {
+        // "META-INF/".length()
+        private static final int META_INF_LENGTH = 9;
+        private static final int[] EMPTY_META_VERSIONS = new int[0];
+
         private final Key key;               // the key in files
         private int refs = 1;
 
         private RandomAccessFile zfile;      // zfile of the underlying zip file
         private byte[] cen;                  // CEN & ENDHDR
         private long locpos;                 // position of first LOC header (usually 0)
         private byte[] comment;              // zip file comment
                                              // list of meta entries in META-INF dir
         private int[] metanames;
+        private int[] metaVersions;          // list of unique versions found in META-INF/versions/
         private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)
 
         // A Hashmap for all entries.
         //
         // A cen entry of Zip/JAR file. As we have one for every entry in every active Zip/JAR,
@@ -1235,10 +1257,11 @@
             zfile = null;
             cen = null;
             entries = null;
             table = null;
             metanames = null;
+            metaVersions = EMPTY_META_VERSIONS;
         }
 
         private static final int BUF_SIZE = 8192;
         private final int readFullyAt(byte[] buf, int off, int len, long pos)
             throws IOException
@@ -1271,11 +1294,11 @@
                 h = 31 * h + a[off++];
             }
             return h;
         }
 
-        private static final int hash_append(int hash, byte b) {
+        private static final int hashAppend(int hash, byte b) {
             return hash * 31 + b;
         }
 
         private static class End {
             int  centot;     // 4 bytes
@@ -1422,10 +1445,12 @@
             int hash = 0;
             int next = -1;
 
             // list for all meta entries
             ArrayList<Integer> metanamesList = null;
+            // Set of all version numbers seen in META-INF/versions/
+            Set<Integer> metaVersionsSet = null;
 
             // Iterate through the entries in the central directory
             int i = 0;
             int hsh = 0;
             int pos = 0;
@@ -1459,10 +1484,21 @@
                 // Adds name to metanames.
                 if (isMetaName(cen, pos + CENHDR, nlen)) {
                     if (metanamesList == null)
                         metanamesList = new ArrayList<>(4);
                     metanamesList.add(pos);
+
+                    // If this is a versioned entry, parse the version
+                    // and store it for later. This optimizes lookup
+                    // performance in multi-release jar files
+                    int version = getMetaVersion(cen,
+                        pos + CENHDR + META_INF_LENGTH, nlen - META_INF_LENGTH);
+                    if (version > 0) {
+                        if (metaVersionsSet == null)
+                            metaVersionsSet = new TreeSet<>();
+                        metaVersionsSet.add(version);
+                    }
                 }
                 // skip ext and comment
                 pos += (CENHDR + nlen + elen + clen);
                 i++;
             }
@@ -1471,10 +1507,19 @@
                 metanames = new int[metanamesList.size()];
                 for (int j = 0, len = metanames.length; j < len; j++) {
                     metanames[j] = metanamesList.get(j);
                 }
             }
+            if (metaVersionsSet != null) {
+                metaVersions = new int[metaVersionsSet.size()];
+                int c = 0;
+                for (Integer version : metaVersionsSet) {
+                    metaVersions[c++] = version;
+                }
+            } else {
+                metaVersions = EMPTY_META_VERSIONS;
+            }
             if (pos + ENDHDR != cen.length) {
                 zerror("invalid CEN header (bad header size)");
             }
         }
 
@@ -1490,23 +1535,30 @@
             if (total == 0) {
                 return -1;
             }
             int hsh = hashN(name, 0, name.length);
             int idx = table[(hsh & 0x7fffffff) % tablelen];
+            boolean appendSlash = false;
             /*
              * This while loop is an optimization where a double lookup
-             * for name and name+/ is being performed. The name char
-             * array has enough room at the end to try again with a
-             * slash appended if the first table lookup does not succeed.
+             * for name and name+/ is being performed. The name byte
+             * array will be updated with an added slash only if the first
+             * table lookup fails and there is a matching hash value for
+             * name+/.
              */
             while (true) {
                 /*
                  * Search down the target hash chain for a entry whose
                  * 32 bit hash matches the hashed name.
                  */
                 while (idx != ZIP_ENDCHAIN) {
                     if (getEntryHash(idx) == hsh) {
+                        if (appendSlash) {
+                            name = Arrays.copyOf(name, name.length + 1);
+                            name[name.length - 1] = '/';
+                            appendSlash = false;
+                        }
                         // The CEN name must match the specfied one
                         int pos = getEntryPos(idx);
                         if (name.length == CENNAM(cen, pos)) {
                             boolean matched = true;
                             int nameoff = pos + CENHDR;
@@ -1525,15 +1577,15 @@
                 }
                 /* If not addSlash, or slash is already there, we are done */
                 if (!addSlash  || name.length == 0 || name[name.length - 1] == '/') {
                      return -1;
                 }
-                /* Add slash and try once more */
-                name = Arrays.copyOf(name, name.length + 1);
-                name[name.length - 1] = '/';
-                hsh = hash_append(hsh, (byte)'/');
-                //idx = table[hsh % tablelen];
+                // Add a slash to the hash code
+                hsh = hashAppend(hsh, (byte)'/');
+                // If we find a match on the new hash code, we need to append a
+                // slash when comparing
+                appendSlash = true;
                 idx = table[(hsh & 0x7fffffff) % tablelen];
                 addSlash = false;
             }
         }
 
@@ -1541,11 +1593,11 @@
          * Returns true if the bytes represent a non-directory name
          * beginning with "META-INF/", disregarding ASCII case.
          */
         private static boolean isMetaName(byte[] name, int off, int len) {
             // Use the "oldest ASCII trick in the book"
-            return len > 9                     // "META-INF/".length()
+            return len > META_INF_LENGTH       // "META-INF/".length()
                 && name[off + len - 1] != '/'  // non-directory
                 && (name[off++] | 0x20) == 'm'
                 && (name[off++] | 0x20) == 'e'
                 && (name[off++] | 0x20) == 't'
                 && (name[off++] | 0x20) == 'a'
@@ -1554,10 +1606,49 @@
                 && (name[off++] | 0x20) == 'n'
                 && (name[off++] | 0x20) == 'f'
                 && (name[off]         ) == '/';
         }
 
+        /*
+         * If the bytes represents a non-directory name beginning
+         * with "versions/", continuing with a positive integer,
+         * followed by a '/', then return that integer value.
+         * Otherwise, return 0
+         */
+        private static int getMetaVersion(byte[] name, int off, int len) {
+            int nend = off + len;
+            if (!(len > 10                         // "versions//".length()
+                    && name[off + len - 1] != '/'  // non-directory
+                    && (name[off++] | 0x20) == 'v'
+                    && (name[off++] | 0x20) == 'e'
+                    && (name[off++] | 0x20) == 'r'
+                    && (name[off++] | 0x20) == 's'
+                    && (name[off++] | 0x20) == 'i'
+                    && (name[off++] | 0x20) == 'o'
+                    && (name[off++] | 0x20) == 'n'
+                    && (name[off++] | 0x20) == 's'
+                    && (name[off++]         ) == '/')) {
+                return 0;
+            }
+            int version = 0;
+            while (off < nend) {
+                final byte c = name[off++];
+                if (c == '/') {
+                    return version;
+                }
+                if (c < '0' || c > '9') {
+                    return 0;
+                }
+                version = version * 10 + c - '0';
+                // Check for overflow and leading zeros
+                if (version <= 0) {
+                    return 0;
+                }
+            }
+            return 0;
+        }
+
         /**
          * Returns the number of CEN headers in a central directory.
          * Will not throw, even if the zip file is corrupt.
          *
          * @param cen copy of the bytes in a zip file's central directory

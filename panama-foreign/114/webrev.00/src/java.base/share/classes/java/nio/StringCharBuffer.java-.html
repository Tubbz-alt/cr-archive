<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/nio/StringCharBuffer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.nio;
 27 
 28 import java.util.Objects;
 29 
 30 // ## If the sequence is a string, use reflection to share its array
 31 
 32 class StringCharBuffer                                  // package-private
 33     extends CharBuffer
 34 {
 35     CharSequence str;
 36 
 37     StringCharBuffer(CharSequence s, int start, int end) { // package-private
 38         super(-1, start, end, s.length(), null);
 39         int n = s.length();
 40         Objects.checkFromToIndex(start, end, n);
 41         str = s;
 42         this.isReadOnly = true;
 43     }
 44 
 45     public CharBuffer slice() {
 46         return new StringCharBuffer(str,
 47                                     -1,
 48                                     0,
 49                                     this.remaining(),
 50                                     this.remaining(),
 51                                     offset + this.position());
 52     }
 53 
 54     @Override
 55     public CharBuffer slice(int index, int length) {
 56         Objects.checkFromIndexSize(index, length, limit());
 57         return new StringCharBuffer(str,
 58                                     -1,
 59                                     0,
 60                                     length,
 61                                     length,
 62                                     offset + index);
 63     }
 64 
 65     private StringCharBuffer(CharSequence s,
 66                              int mark,
 67                              int pos,
 68                              int limit,
 69                              int cap,
 70                              int offset) {
 71         super(mark, pos, limit, cap, null, offset, null);
 72         str = s;
 73         this.isReadOnly = true;
 74     }
 75 
 76     public CharBuffer duplicate() {
 77         return new StringCharBuffer(str, markValue(),
 78                                     position(), limit(), capacity(), offset);
 79     }
 80 
 81     public CharBuffer asReadOnlyBuffer() {
 82         return duplicate();
 83     }
 84 
 85     public final char get() {
 86         return str.charAt(nextGetIndex() + offset);
 87     }
 88 
 89     public final char get(int index) {
 90         return str.charAt(checkIndex(index) + offset);
 91     }
 92 
 93     char getUnchecked(int index) {
 94         return str.charAt(index + offset);
 95     }
 96 
 97     // ## Override bulk get methods for better performance
 98 
 99     public final CharBuffer put(char c) {
100         throw new ReadOnlyBufferException();
101     }
102 
103     public final CharBuffer put(int index, char c) {
104         throw new ReadOnlyBufferException();
105     }
106 
107     public final CharBuffer compact() {
108         throw new ReadOnlyBufferException();
109     }
110 
111     public final boolean isReadOnly() {
112         return true;
113     }
114 
115     final String toString(int start, int end) {
116         return str.subSequence(start + offset, end + offset).toString();
117     }
118 
119     public final CharBuffer subSequence(int start, int end) {
120         try {
121             int pos = position();
122             return new StringCharBuffer(str,
123                                         -1,
124                                         pos + checkIndex(start, pos),
125                                         pos + checkIndex(end, pos),
126                                         capacity(),
127                                         offset);
128         } catch (IllegalArgumentException x) {
129             throw new IndexOutOfBoundsException();
130         }
131     }
132 
133     public boolean isDirect() {
134         return false;
135     }
136 
137     public ByteOrder order() {
138         return ByteOrder.nativeOrder();
139     }
140 
141     ByteOrder charRegionOrder() {
142         return null;
143     }
144 
145     public boolean equals(Object ob) {
146         if (this == ob)
147             return true;
148         if (!(ob instanceof CharBuffer))
149             return false;
150         CharBuffer that = (CharBuffer)ob;
151         if (this.remaining() != that.remaining())
152             return false;
153         return BufferMismatch.mismatch(this, this.position(),
154                                        that, that.position(),
155                                        this.remaining()) &lt; 0;
156     }
157 
158     public int compareTo(CharBuffer that) {
159         int i = BufferMismatch.mismatch(this, this.position(),
160                                         that, that.position(),
161                                         Math.min(this.remaining(), that.remaining()));
162         if (i &gt;= 0) {
163             return Character.compare(this.get(this.position() + i), that.get(that.position() + i));
164         }
165         return this.remaining() - that.remaining();
166     }
167 }
    </pre>
  </body>
</html>
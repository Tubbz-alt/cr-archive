<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/nio/StringCharBuffer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.nio;
 27 
 28 import java.util.Objects;
 29 
 30 // ## If the sequence is a string, use reflection to share its array
 31 
 32 class StringCharBuffer                                  // package-private
 33     extends CharBuffer
 34 {
 35     CharSequence str;
 36 
 37     StringCharBuffer(CharSequence s, int start, int end) { // package-private
 38         super(-1, start, end, s.length(), null);
 39         int n = s.length();
 40         Objects.checkFromToIndex(start, end, n);
 41         str = s;
 42         this.isReadOnly = true;
 43     }
 44 
 45     public CharBuffer slice() {
 46         int pos = this.position();
 47         int lim = this.limit();
 48         int rem = (pos &lt;= lim ? lim - pos : 0);
 49         return new StringCharBuffer(str,
 50                                     -1,
 51                                     0,
 52                                     rem,
 53                                     rem,
 54                                     offset + pos);
 55     }
 56 
 57     @Override
 58     public CharBuffer slice(int index, int length) {
 59         Objects.checkFromIndexSize(index, length, limit());
 60         return new StringCharBuffer(str,
 61                                     -1,
 62                                     0,
 63                                     length,
 64                                     length,
 65                                     offset + index);
 66     }
 67 
 68     private StringCharBuffer(CharSequence s,
 69                              int mark,
 70                              int pos,
 71                              int limit,
 72                              int cap,
 73                              int offset) {
 74         super(mark, pos, limit, cap, null, offset, null);
 75         str = s;
 76         this.isReadOnly = true;
 77     }
 78 
 79     public CharBuffer duplicate() {
 80         return new StringCharBuffer(str, markValue(),
 81                                     position(), limit(), capacity(), offset);
 82     }
 83 
 84     public CharBuffer asReadOnlyBuffer() {
 85         return duplicate();
 86     }
 87 
 88     public final char get() {
 89         return str.charAt(nextGetIndex() + offset);
 90     }
 91 
 92     public final char get(int index) {
 93         return str.charAt(checkIndex(index) + offset);
 94     }
 95 
 96     char getUnchecked(int index) {
 97         return str.charAt(index + offset);
 98     }
 99 
100     // ## Override bulk get methods for better performance
101 
102     public final CharBuffer put(char c) {
103         throw new ReadOnlyBufferException();
104     }
105 
106     public final CharBuffer put(int index, char c) {
107         throw new ReadOnlyBufferException();
108     }
109 
110     public final CharBuffer compact() {
111         throw new ReadOnlyBufferException();
112     }
113 
114     public final boolean isReadOnly() {
115         return true;
116     }
117 
118     final String toString(int start, int end) {
119         return str.subSequence(start + offset, end + offset).toString();
120     }
121 
122     public final CharBuffer subSequence(int start, int end) {
123         try {
124             int pos = position();
125             return new StringCharBuffer(str,
126                                         -1,
127                                         pos + checkIndex(start, pos),
128                                         pos + checkIndex(end, pos),
129                                         capacity(),
130                                         offset);
131         } catch (IllegalArgumentException x) {
132             throw new IndexOutOfBoundsException();
133         }
134     }
135 
136     public boolean isDirect() {
137         return false;
138     }
139 
140     public ByteOrder order() {
141         return ByteOrder.nativeOrder();
142     }
143 
144     ByteOrder charRegionOrder() {
145         return null;
146     }
147 
148     public boolean equals(Object ob) {
149         if (this == ob)
150             return true;
151         if (!(ob instanceof CharBuffer))
152             return false;
153         CharBuffer that = (CharBuffer)ob;
154         if (this.remaining() != that.remaining())
155             return false;
156         return BufferMismatch.mismatch(this, this.position(),
157                                        that, that.position(),
158                                        this.remaining()) &lt; 0;
159     }
160 
161     public int compareTo(CharBuffer that) {
162         int i = BufferMismatch.mismatch(this, this.position(),
163                                         that, that.position(),
164                                         Math.min(this.remaining(), that.remaining()));
165         if (i &gt;= 0) {
166             return Character.compare(this.get(this.position() + i), that.get(that.position() + i));
167         }
168         return this.remaining() - that.remaining();
169     }
170 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/zip/ZipFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../regex/Pattern.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../javax/net/ssl/SSLContext.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/zip/ZipFile.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  33 import java.io.RandomAccessFile;
  34 import java.io.UncheckedIOException;
  35 import java.lang.ref.Cleaner.Cleanable;
  36 import java.nio.charset.Charset;
  37 import java.nio.file.InvalidPathException;
  38 import java.nio.file.attribute.BasicFileAttributes;
  39 import java.nio.file.Files;
  40 import java.util.ArrayDeque;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collections;
  44 import java.util.Deque;
  45 import java.util.Enumeration;
  46 import java.util.HashMap;
  47 import java.util.Iterator;
  48 import java.util.Objects;
  49 import java.util.NoSuchElementException;
  50 import java.util.Set;
  51 import java.util.Spliterator;
  52 import java.util.Spliterators;

  53 import java.util.WeakHashMap;
  54 import java.util.function.Consumer;
  55 import java.util.function.Function;
  56 import java.util.function.IntFunction;
  57 import java.util.jar.JarEntry;

  58 import java.util.stream.Stream;
  59 import java.util.stream.StreamSupport;
<span class="line-removed">  60 import jdk.internal.access.JavaLangAccess;</span>
  61 import jdk.internal.access.JavaUtilZipFileAccess;
  62 import jdk.internal.access.SharedSecrets;
  63 import jdk.internal.misc.VM;
  64 import jdk.internal.perf.PerfCounter;
  65 import jdk.internal.ref.CleanerFactory;
  66 import jdk.internal.vm.annotation.Stable;
  67 import sun.nio.cs.UTF_8;
  68 
  69 import static java.util.zip.ZipConstants64.*;
  70 import static java.util.zip.ZipUtils.*;
  71 
  72 /**
  73  * This class is used to read entries from a zip file.
  74  *
  75  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  76  * or method in this class will cause a {@link NullPointerException} to be
  77  * thrown.
  78  *
  79  * @apiNote
  80  * To release resources used by this {@code ZipFile}, the {@link #close()} method
</pre>
<hr />
<pre>
1031      * signature file entries. Returns null if no entries were found.
1032      */
1033     private String[] getMetaInfEntryNames() {
1034         synchronized (this) {
1035             ensureOpen();
1036             Source zsrc = res.zsrc;
1037             if (zsrc.metanames == null) {
1038                 return null;
1039             }
1040             String[] names = new String[zsrc.metanames.length];
1041             byte[] cen = zsrc.cen;
1042             for (int i = 0; i &lt; names.length; i++) {
1043                 int pos = zsrc.metanames[i];
1044                 names[i] = new String(cen, pos + CENHDR, CENNAM(cen, pos),
1045                                       UTF_8.INSTANCE);
1046             }
1047             return names;
1048         }
1049     }
1050 














1051     private static boolean isWindows;
<span class="line-removed">1052     private static final JavaLangAccess JLA;</span>
1053 
1054     static {
1055         SharedSecrets.setJavaUtilZipFileAccess(
1056             new JavaUtilZipFileAccess() {
1057                 @Override
1058                 public boolean startsWithLocHeader(ZipFile zip) {
1059                     return zip.res.zsrc.startsWithLoc;
1060                 }
1061                 @Override
<span class="line-modified">1062                 public String[] getMetaInfEntryNames(ZipFile zip) {</span>
<span class="line-modified">1063                     return zip.getMetaInfEntryNames();</span>




1064                 }
1065                 @Override
1066                 public JarEntry getEntry(ZipFile zip, String name,
1067                     Function&lt;String, JarEntry&gt; func) {
1068                     return (JarEntry)zip.getEntry(name, func);
1069                 }
1070                 @Override
1071                 public Enumeration&lt;JarEntry&gt; entries(ZipFile zip,
1072                     Function&lt;String, JarEntry&gt; func) {
1073                     return zip.entries(func);
1074                 }
1075                 @Override
1076                 public Stream&lt;JarEntry&gt; stream(ZipFile zip,
1077                     Function&lt;String, JarEntry&gt; func) {
1078                     return zip.stream(func);
1079                 }
1080                 @Override
1081                 public Stream&lt;String&gt; entryNameStream(ZipFile zip) {
1082                     return zip.entryNameStream();
1083                 }
1084              }
1085         );
<span class="line-removed">1086         JLA = SharedSecrets.getJavaLangAccess();</span>
1087         isWindows = VM.getSavedProperty(&quot;os.name&quot;).contains(&quot;Windows&quot;);
1088     }
1089 
1090     private static class Source {




1091         private final Key key;               // the key in files
1092         private int refs = 1;
1093 
1094         private RandomAccessFile zfile;      // zfile of the underlying zip file
1095         private byte[] cen;                  // CEN &amp; ENDHDR
1096         private long locpos;                 // position of first LOC header (usually 0)
1097         private byte[] comment;              // zip file comment
1098                                              // list of meta entries in META-INF dir
1099         private int[] metanames;

1100         private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)
1101 
1102         // A Hashmap for all entries.
1103         //
1104         // A cen entry of Zip/JAR file. As we have one for every entry in every active Zip/JAR,
1105         // We might have a lot of these in a typical system. In order to save space we don&#39;t
1106         // keep the name in memory, but merely remember a 32 bit {@code hash} value of the
1107         // entry name and its offset {@code pos} in the central directory hdeader.
1108         //
1109         // private static class Entry {
1110         //     int hash;       // 32 bit hashcode on name
1111         //     int next;       // hash chain: index into entries
1112         //     int pos;        // Offset of central directory file header
1113         // }
1114         // private Entry[] entries;             // array of hashed cen entry
1115         //
1116         // To reduce the total size of entries further, we use a int[] here to store 3 &quot;int&quot;
1117         // {@code hash}, {@code next and {@code &quot;pos for each entry. The entry can then be
1118         // referred by their index of their positions in the {@code entries}.
1119         //
</pre>
<hr />
<pre>
1220             try {
1221                 initCEN(-1);
1222                 byte[] buf = new byte[4];
1223                 readFullyAt(buf, 0, 4, 0);
1224                 this.startsWithLoc = (LOCSIG(buf) == LOCSIG);
1225             } catch (IOException x) {
1226                 try {
1227                     this.zfile.close();
1228                 } catch (IOException xx) {}
1229                 throw x;
1230             }
1231         }
1232 
1233         private void close() throws IOException {
1234             zfile.close();
1235             zfile = null;
1236             cen = null;
1237             entries = null;
1238             table = null;
1239             metanames = null;

1240         }
1241 
1242         private static final int BUF_SIZE = 8192;
1243         private final int readFullyAt(byte[] buf, int off, int len, long pos)
1244             throws IOException
1245         {
1246             synchronized (zfile) {
1247                 zfile.seek(pos);
1248                 int N = len;
1249                 while (N &gt; 0) {
1250                     int n = Math.min(BUF_SIZE, N);
1251                     zfile.readFully(buf, off, n);
1252                     off += n;
1253                     N -= n;
1254                 }
1255                 return len;
1256             }
1257         }
1258 
1259         private final int readAt(byte[] buf, int off, int len, long pos)
1260             throws IOException
1261         {
1262             synchronized (zfile) {
1263                 zfile.seek(pos);
1264                 return zfile.read(buf, off, len);
1265             }
1266         }
1267 
1268         private static final int hashN(byte[] a, int off, int len) {
1269             int h = 1;
1270             while (len-- &gt; 0) {
1271                 h = 31 * h + a[off++];
1272             }
1273             return h;
1274         }
1275 
<span class="line-modified">1276         private static final int hash_append(int hash, byte b) {</span>
1277             return hash * 31 + b;
1278         }
1279 
1280         private static class End {
1281             int  centot;     // 4 bytes
1282             long cenlen;     // 4 bytes
1283             long cenoff;     // 4 bytes
1284             long endpos;     // 4 bytes
1285         }
1286 
1287         /*
1288          * Searches for end of central directory (END) header. The contents of
1289          * the END header will be read and placed in endbuf. Returns the file
1290          * position of the END header, otherwise returns -1 if the END header
1291          * was not found or an error occurred.
1292          */
1293         private End findEND() throws IOException {
1294             long ziplen = zfile.length();
1295             if (ziplen &lt;= 0)
1296                 zerror(&quot;zip file is empty&quot;);
</pre>
<hr />
<pre>
1407                 // read in the CEN and END
1408                 cen = new byte[(int)(end.cenlen + ENDHDR)];
1409                 if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
1410                     zerror(&quot;read CEN tables failed&quot;);
1411                 }
1412                 total = end.centot;
1413             } else {
1414                 total = knownTotal;
1415             }
1416             // hash table for entries
1417             entries  = new int[total * 3];
1418             tablelen = ((total/2) | 1); // Odd -&gt; fewer collisions
1419             table    =  new int[tablelen];
1420             Arrays.fill(table, ZIP_ENDCHAIN);
1421             int idx = 0;
1422             int hash = 0;
1423             int next = -1;
1424 
1425             // list for all meta entries
1426             ArrayList&lt;Integer&gt; metanamesList = null;


1427 
1428             // Iterate through the entries in the central directory
1429             int i = 0;
1430             int hsh = 0;
1431             int pos = 0;
1432             int limit = cen.length - ENDHDR;
1433             while (pos + CENHDR &lt;= limit) {
1434                 if (i &gt;= total) {
1435                     // This will only happen if the zip file has an incorrect
1436                     // ENDTOT field, which usually means it contains more than
1437                     // 65535 entries.
1438                     initCEN(countCENHeaders(cen, limit));
1439                     return;
1440                 }
1441                 if (CENSIG(cen, pos) != CENSIG)
1442                     zerror(&quot;invalid CEN header (bad signature)&quot;);
1443                 int method = CENHOW(cen, pos);
1444                 int nlen   = CENNAM(cen, pos);
1445                 int elen   = CENEXT(cen, pos);
1446                 int clen   = CENCOM(cen, pos);
1447                 if ((CENFLG(cen, pos) &amp; 1) != 0)
1448                     zerror(&quot;invalid CEN header (encrypted entry)&quot;);
1449                 if (method != STORED &amp;&amp; method != DEFLATED)
1450                     zerror(&quot;invalid CEN header (bad compression method: &quot; + method + &quot;)&quot;);
1451                 if (pos + CENHDR + nlen &gt; limit)
1452                     zerror(&quot;invalid CEN header (bad header size)&quot;);
1453                 // Record the CEN offset and the name hash in our hash cell.
1454                 hash = hashN(cen, pos + CENHDR, nlen);
1455                 hsh = (hash &amp; 0x7fffffff) % tablelen;
1456                 next = table[hsh];
1457                 table[hsh] = idx;
1458                 idx = addEntry(idx, hash, next, pos);
1459                 // Adds name to metanames.
1460                 if (isMetaName(cen, pos + CENHDR, nlen)) {
1461                     if (metanamesList == null)
1462                         metanamesList = new ArrayList&lt;&gt;(4);
1463                     metanamesList.add(pos);











1464                 }
1465                 // skip ext and comment
1466                 pos += (CENHDR + nlen + elen + clen);
1467                 i++;
1468             }
1469             total = i;
1470             if (metanamesList != null) {
1471                 metanames = new int[metanamesList.size()];
1472                 for (int j = 0, len = metanames.length; j &lt; len; j++) {
1473                     metanames[j] = metanamesList.get(j);
1474                 }
1475             }









1476             if (pos + ENDHDR != cen.length) {
1477                 zerror(&quot;invalid CEN header (bad header size)&quot;);
1478             }
1479         }
1480 
1481         private static void zerror(String msg) throws ZipException {
1482             throw new ZipException(msg);
1483         }
1484 
1485         /*
1486          * Returns the {@code pos} of the zip cen entry corresponding to the
1487          * specified entry name, or -1 if not found.
1488          */
1489         private int getEntryPos(byte[] name, boolean addSlash) {
1490             if (total == 0) {
1491                 return -1;
1492             }
1493             int hsh = hashN(name, 0, name.length);
1494             int idx = table[(hsh &amp; 0x7fffffff) % tablelen];

1495             /*
1496              * This while loop is an optimization where a double lookup
<span class="line-modified">1497              * for name and name+/ is being performed. The name char</span>
<span class="line-modified">1498              * array has enough room at the end to try again with a</span>
<span class="line-modified">1499              * slash appended if the first table lookup does not succeed.</span>

1500              */
1501             while (true) {
1502                 /*
1503                  * Search down the target hash chain for a entry whose
1504                  * 32 bit hash matches the hashed name.
1505                  */
1506                 while (idx != ZIP_ENDCHAIN) {
1507                     if (getEntryHash(idx) == hsh) {





1508                         // The CEN name must match the specfied one
1509                         int pos = getEntryPos(idx);
1510                         if (name.length == CENNAM(cen, pos)) {
1511                             boolean matched = true;
1512                             int nameoff = pos + CENHDR;
1513                             for (int i = 0; i &lt; name.length; i++) {
1514                                 if (name[i] != cen[nameoff++]) {
1515                                     matched = false;
1516                                     break;
1517                                 }
1518                             }
1519                             if (matched) {
1520                                 return pos;
1521                             }
1522                          }
1523                     }
1524                     idx = getEntryNext(idx);
1525                 }
1526                 /* If not addSlash, or slash is already there, we are done */
1527                 if (!addSlash  || name.length == 0 || name[name.length - 1] == &#39;/&#39;) {
1528                      return -1;
1529                 }
<span class="line-modified">1530                 /* Add slash and try once more */</span>
<span class="line-modified">1531                 name = Arrays.copyOf(name, name.length + 1);</span>
<span class="line-modified">1532                 name[name.length - 1] = &#39;/&#39;;</span>
<span class="line-modified">1533                 hsh = hash_append(hsh, (byte)&#39;/&#39;);</span>
<span class="line-modified">1534                 //idx = table[hsh % tablelen];</span>
1535                 idx = table[(hsh &amp; 0x7fffffff) % tablelen];
1536                 addSlash = false;
1537             }
1538         }
1539 
1540         /**
1541          * Returns true if the bytes represent a non-directory name
1542          * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
1543          */
1544         private static boolean isMetaName(byte[] name, int off, int len) {
1545             // Use the &quot;oldest ASCII trick in the book&quot;
<span class="line-modified">1546             return len &gt; 9                     // &quot;META-INF/&quot;.length()</span>
1547                 &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1548                 &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1549                 &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1550                 &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
1551                 &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;
1552                 &amp;&amp; (name[off++]       ) == &#39;-&#39;
1553                 &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1554                 &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1555                 &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;
1556                 &amp;&amp; (name[off]         ) == &#39;/&#39;;
1557         }
1558 







































1559         /**
1560          * Returns the number of CEN headers in a central directory.
1561          * Will not throw, even if the zip file is corrupt.
1562          *
1563          * @param cen copy of the bytes in a zip file&#39;s central directory
1564          * @param size number of bytes in central directory
1565          */
1566         private static int countCENHeaders(byte[] cen, int size) {
1567             int count = 0;
1568             for (int p = 0;
1569                  p + CENHDR &lt;= size;
1570                  p += CENHDR + CENNAM(cen, p) + CENEXT(cen, p) + CENCOM(cen, p))
1571                 count++;
1572             return count;
1573         }
1574     }
1575 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  33 import java.io.RandomAccessFile;
  34 import java.io.UncheckedIOException;
  35 import java.lang.ref.Cleaner.Cleanable;
  36 import java.nio.charset.Charset;
  37 import java.nio.file.InvalidPathException;
  38 import java.nio.file.attribute.BasicFileAttributes;
  39 import java.nio.file.Files;
  40 import java.util.ArrayDeque;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collections;
  44 import java.util.Deque;
  45 import java.util.Enumeration;
  46 import java.util.HashMap;
  47 import java.util.Iterator;
  48 import java.util.Objects;
  49 import java.util.NoSuchElementException;
  50 import java.util.Set;
  51 import java.util.Spliterator;
  52 import java.util.Spliterators;
<span class="line-added">  53 import java.util.TreeSet;</span>
  54 import java.util.WeakHashMap;
  55 import java.util.function.Consumer;
  56 import java.util.function.Function;
  57 import java.util.function.IntFunction;
  58 import java.util.jar.JarEntry;
<span class="line-added">  59 import java.util.jar.JarFile;</span>
  60 import java.util.stream.Stream;
  61 import java.util.stream.StreamSupport;

  62 import jdk.internal.access.JavaUtilZipFileAccess;
  63 import jdk.internal.access.SharedSecrets;
  64 import jdk.internal.misc.VM;
  65 import jdk.internal.perf.PerfCounter;
  66 import jdk.internal.ref.CleanerFactory;
  67 import jdk.internal.vm.annotation.Stable;
  68 import sun.nio.cs.UTF_8;
  69 
  70 import static java.util.zip.ZipConstants64.*;
  71 import static java.util.zip.ZipUtils.*;
  72 
  73 /**
  74  * This class is used to read entries from a zip file.
  75  *
  76  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  77  * or method in this class will cause a {@link NullPointerException} to be
  78  * thrown.
  79  *
  80  * @apiNote
  81  * To release resources used by this {@code ZipFile}, the {@link #close()} method
</pre>
<hr />
<pre>
1032      * signature file entries. Returns null if no entries were found.
1033      */
1034     private String[] getMetaInfEntryNames() {
1035         synchronized (this) {
1036             ensureOpen();
1037             Source zsrc = res.zsrc;
1038             if (zsrc.metanames == null) {
1039                 return null;
1040             }
1041             String[] names = new String[zsrc.metanames.length];
1042             byte[] cen = zsrc.cen;
1043             for (int i = 0; i &lt; names.length; i++) {
1044                 int pos = zsrc.metanames[i];
1045                 names[i] = new String(cen, pos + CENHDR, CENNAM(cen, pos),
1046                                       UTF_8.INSTANCE);
1047             }
1048             return names;
1049         }
1050     }
1051 
<span class="line-added">1052     /**</span>
<span class="line-added">1053      * Returns the versions for which there exists a non-directory</span>
<span class="line-added">1054      * entry that begin with &quot;META-INF/versions/&quot; (case ignored).</span>
<span class="line-added">1055      * This method is used in JarFile, via SharedSecrets, as an</span>
<span class="line-added">1056      * optimization when looking up potentially versioned entries.</span>
<span class="line-added">1057      * Returns an empty array if no versioned entries exist.</span>
<span class="line-added">1058      */</span>
<span class="line-added">1059     private int[] getMetaInfVersions() {</span>
<span class="line-added">1060         synchronized (this) {</span>
<span class="line-added">1061             ensureOpen();</span>
<span class="line-added">1062             return res.zsrc.metaVersions;</span>
<span class="line-added">1063         }</span>
<span class="line-added">1064     }</span>
<span class="line-added">1065 </span>
1066     private static boolean isWindows;

1067 
1068     static {
1069         SharedSecrets.setJavaUtilZipFileAccess(
1070             new JavaUtilZipFileAccess() {
1071                 @Override
1072                 public boolean startsWithLocHeader(ZipFile zip) {
1073                     return zip.res.zsrc.startsWithLoc;
1074                 }
1075                 @Override
<span class="line-modified">1076                 public String[] getMetaInfEntryNames(JarFile jar) {</span>
<span class="line-modified">1077                     return ((ZipFile)jar).getMetaInfEntryNames();</span>
<span class="line-added">1078                 }</span>
<span class="line-added">1079                 @Override</span>
<span class="line-added">1080                 public int[] getMetaInfVersions(JarFile jar) {</span>
<span class="line-added">1081                     return ((ZipFile)jar).getMetaInfVersions();</span>
1082                 }
1083                 @Override
1084                 public JarEntry getEntry(ZipFile zip, String name,
1085                     Function&lt;String, JarEntry&gt; func) {
1086                     return (JarEntry)zip.getEntry(name, func);
1087                 }
1088                 @Override
1089                 public Enumeration&lt;JarEntry&gt; entries(ZipFile zip,
1090                     Function&lt;String, JarEntry&gt; func) {
1091                     return zip.entries(func);
1092                 }
1093                 @Override
1094                 public Stream&lt;JarEntry&gt; stream(ZipFile zip,
1095                     Function&lt;String, JarEntry&gt; func) {
1096                     return zip.stream(func);
1097                 }
1098                 @Override
1099                 public Stream&lt;String&gt; entryNameStream(ZipFile zip) {
1100                     return zip.entryNameStream();
1101                 }
1102              }
1103         );

1104         isWindows = VM.getSavedProperty(&quot;os.name&quot;).contains(&quot;Windows&quot;);
1105     }
1106 
1107     private static class Source {
<span class="line-added">1108         // &quot;META-INF/&quot;.length()</span>
<span class="line-added">1109         private static final int META_INF_LENGTH = 9;</span>
<span class="line-added">1110         private static final int[] EMPTY_META_VERSIONS = new int[0];</span>
<span class="line-added">1111 </span>
1112         private final Key key;               // the key in files
1113         private int refs = 1;
1114 
1115         private RandomAccessFile zfile;      // zfile of the underlying zip file
1116         private byte[] cen;                  // CEN &amp; ENDHDR
1117         private long locpos;                 // position of first LOC header (usually 0)
1118         private byte[] comment;              // zip file comment
1119                                              // list of meta entries in META-INF dir
1120         private int[] metanames;
<span class="line-added">1121         private int[] metaVersions;          // list of unique versions found in META-INF/versions/</span>
1122         private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)
1123 
1124         // A Hashmap for all entries.
1125         //
1126         // A cen entry of Zip/JAR file. As we have one for every entry in every active Zip/JAR,
1127         // We might have a lot of these in a typical system. In order to save space we don&#39;t
1128         // keep the name in memory, but merely remember a 32 bit {@code hash} value of the
1129         // entry name and its offset {@code pos} in the central directory hdeader.
1130         //
1131         // private static class Entry {
1132         //     int hash;       // 32 bit hashcode on name
1133         //     int next;       // hash chain: index into entries
1134         //     int pos;        // Offset of central directory file header
1135         // }
1136         // private Entry[] entries;             // array of hashed cen entry
1137         //
1138         // To reduce the total size of entries further, we use a int[] here to store 3 &quot;int&quot;
1139         // {@code hash}, {@code next and {@code &quot;pos for each entry. The entry can then be
1140         // referred by their index of their positions in the {@code entries}.
1141         //
</pre>
<hr />
<pre>
1242             try {
1243                 initCEN(-1);
1244                 byte[] buf = new byte[4];
1245                 readFullyAt(buf, 0, 4, 0);
1246                 this.startsWithLoc = (LOCSIG(buf) == LOCSIG);
1247             } catch (IOException x) {
1248                 try {
1249                     this.zfile.close();
1250                 } catch (IOException xx) {}
1251                 throw x;
1252             }
1253         }
1254 
1255         private void close() throws IOException {
1256             zfile.close();
1257             zfile = null;
1258             cen = null;
1259             entries = null;
1260             table = null;
1261             metanames = null;
<span class="line-added">1262             metaVersions = EMPTY_META_VERSIONS;</span>
1263         }
1264 
1265         private static final int BUF_SIZE = 8192;
1266         private final int readFullyAt(byte[] buf, int off, int len, long pos)
1267             throws IOException
1268         {
1269             synchronized (zfile) {
1270                 zfile.seek(pos);
1271                 int N = len;
1272                 while (N &gt; 0) {
1273                     int n = Math.min(BUF_SIZE, N);
1274                     zfile.readFully(buf, off, n);
1275                     off += n;
1276                     N -= n;
1277                 }
1278                 return len;
1279             }
1280         }
1281 
1282         private final int readAt(byte[] buf, int off, int len, long pos)
1283             throws IOException
1284         {
1285             synchronized (zfile) {
1286                 zfile.seek(pos);
1287                 return zfile.read(buf, off, len);
1288             }
1289         }
1290 
1291         private static final int hashN(byte[] a, int off, int len) {
1292             int h = 1;
1293             while (len-- &gt; 0) {
1294                 h = 31 * h + a[off++];
1295             }
1296             return h;
1297         }
1298 
<span class="line-modified">1299         private static final int hashAppend(int hash, byte b) {</span>
1300             return hash * 31 + b;
1301         }
1302 
1303         private static class End {
1304             int  centot;     // 4 bytes
1305             long cenlen;     // 4 bytes
1306             long cenoff;     // 4 bytes
1307             long endpos;     // 4 bytes
1308         }
1309 
1310         /*
1311          * Searches for end of central directory (END) header. The contents of
1312          * the END header will be read and placed in endbuf. Returns the file
1313          * position of the END header, otherwise returns -1 if the END header
1314          * was not found or an error occurred.
1315          */
1316         private End findEND() throws IOException {
1317             long ziplen = zfile.length();
1318             if (ziplen &lt;= 0)
1319                 zerror(&quot;zip file is empty&quot;);
</pre>
<hr />
<pre>
1430                 // read in the CEN and END
1431                 cen = new byte[(int)(end.cenlen + ENDHDR)];
1432                 if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
1433                     zerror(&quot;read CEN tables failed&quot;);
1434                 }
1435                 total = end.centot;
1436             } else {
1437                 total = knownTotal;
1438             }
1439             // hash table for entries
1440             entries  = new int[total * 3];
1441             tablelen = ((total/2) | 1); // Odd -&gt; fewer collisions
1442             table    =  new int[tablelen];
1443             Arrays.fill(table, ZIP_ENDCHAIN);
1444             int idx = 0;
1445             int hash = 0;
1446             int next = -1;
1447 
1448             // list for all meta entries
1449             ArrayList&lt;Integer&gt; metanamesList = null;
<span class="line-added">1450             // Set of all version numbers seen in META-INF/versions/</span>
<span class="line-added">1451             Set&lt;Integer&gt; metaVersionsSet = null;</span>
1452 
1453             // Iterate through the entries in the central directory
1454             int i = 0;
1455             int hsh = 0;
1456             int pos = 0;
1457             int limit = cen.length - ENDHDR;
1458             while (pos + CENHDR &lt;= limit) {
1459                 if (i &gt;= total) {
1460                     // This will only happen if the zip file has an incorrect
1461                     // ENDTOT field, which usually means it contains more than
1462                     // 65535 entries.
1463                     initCEN(countCENHeaders(cen, limit));
1464                     return;
1465                 }
1466                 if (CENSIG(cen, pos) != CENSIG)
1467                     zerror(&quot;invalid CEN header (bad signature)&quot;);
1468                 int method = CENHOW(cen, pos);
1469                 int nlen   = CENNAM(cen, pos);
1470                 int elen   = CENEXT(cen, pos);
1471                 int clen   = CENCOM(cen, pos);
1472                 if ((CENFLG(cen, pos) &amp; 1) != 0)
1473                     zerror(&quot;invalid CEN header (encrypted entry)&quot;);
1474                 if (method != STORED &amp;&amp; method != DEFLATED)
1475                     zerror(&quot;invalid CEN header (bad compression method: &quot; + method + &quot;)&quot;);
1476                 if (pos + CENHDR + nlen &gt; limit)
1477                     zerror(&quot;invalid CEN header (bad header size)&quot;);
1478                 // Record the CEN offset and the name hash in our hash cell.
1479                 hash = hashN(cen, pos + CENHDR, nlen);
1480                 hsh = (hash &amp; 0x7fffffff) % tablelen;
1481                 next = table[hsh];
1482                 table[hsh] = idx;
1483                 idx = addEntry(idx, hash, next, pos);
1484                 // Adds name to metanames.
1485                 if (isMetaName(cen, pos + CENHDR, nlen)) {
1486                     if (metanamesList == null)
1487                         metanamesList = new ArrayList&lt;&gt;(4);
1488                     metanamesList.add(pos);
<span class="line-added">1489 </span>
<span class="line-added">1490                     // If this is a versioned entry, parse the version</span>
<span class="line-added">1491                     // and store it for later. This optimizes lookup</span>
<span class="line-added">1492                     // performance in multi-release jar files</span>
<span class="line-added">1493                     int version = getMetaVersion(cen,</span>
<span class="line-added">1494                         pos + CENHDR + META_INF_LENGTH, nlen - META_INF_LENGTH);</span>
<span class="line-added">1495                     if (version &gt; 0) {</span>
<span class="line-added">1496                         if (metaVersionsSet == null)</span>
<span class="line-added">1497                             metaVersionsSet = new TreeSet&lt;&gt;();</span>
<span class="line-added">1498                         metaVersionsSet.add(version);</span>
<span class="line-added">1499                     }</span>
1500                 }
1501                 // skip ext and comment
1502                 pos += (CENHDR + nlen + elen + clen);
1503                 i++;
1504             }
1505             total = i;
1506             if (metanamesList != null) {
1507                 metanames = new int[metanamesList.size()];
1508                 for (int j = 0, len = metanames.length; j &lt; len; j++) {
1509                     metanames[j] = metanamesList.get(j);
1510                 }
1511             }
<span class="line-added">1512             if (metaVersionsSet != null) {</span>
<span class="line-added">1513                 metaVersions = new int[metaVersionsSet.size()];</span>
<span class="line-added">1514                 int c = 0;</span>
<span class="line-added">1515                 for (Integer version : metaVersionsSet) {</span>
<span class="line-added">1516                     metaVersions[c++] = version;</span>
<span class="line-added">1517                 }</span>
<span class="line-added">1518             } else {</span>
<span class="line-added">1519                 metaVersions = EMPTY_META_VERSIONS;</span>
<span class="line-added">1520             }</span>
1521             if (pos + ENDHDR != cen.length) {
1522                 zerror(&quot;invalid CEN header (bad header size)&quot;);
1523             }
1524         }
1525 
1526         private static void zerror(String msg) throws ZipException {
1527             throw new ZipException(msg);
1528         }
1529 
1530         /*
1531          * Returns the {@code pos} of the zip cen entry corresponding to the
1532          * specified entry name, or -1 if not found.
1533          */
1534         private int getEntryPos(byte[] name, boolean addSlash) {
1535             if (total == 0) {
1536                 return -1;
1537             }
1538             int hsh = hashN(name, 0, name.length);
1539             int idx = table[(hsh &amp; 0x7fffffff) % tablelen];
<span class="line-added">1540             boolean appendSlash = false;</span>
1541             /*
1542              * This while loop is an optimization where a double lookup
<span class="line-modified">1543              * for name and name+/ is being performed. The name byte</span>
<span class="line-modified">1544              * array will be updated with an added slash only if the first</span>
<span class="line-modified">1545              * table lookup fails and there is a matching hash value for</span>
<span class="line-added">1546              * name+/.</span>
1547              */
1548             while (true) {
1549                 /*
1550                  * Search down the target hash chain for a entry whose
1551                  * 32 bit hash matches the hashed name.
1552                  */
1553                 while (idx != ZIP_ENDCHAIN) {
1554                     if (getEntryHash(idx) == hsh) {
<span class="line-added">1555                         if (appendSlash) {</span>
<span class="line-added">1556                             name = Arrays.copyOf(name, name.length + 1);</span>
<span class="line-added">1557                             name[name.length - 1] = &#39;/&#39;;</span>
<span class="line-added">1558                             appendSlash = false;</span>
<span class="line-added">1559                         }</span>
1560                         // The CEN name must match the specfied one
1561                         int pos = getEntryPos(idx);
1562                         if (name.length == CENNAM(cen, pos)) {
1563                             boolean matched = true;
1564                             int nameoff = pos + CENHDR;
1565                             for (int i = 0; i &lt; name.length; i++) {
1566                                 if (name[i] != cen[nameoff++]) {
1567                                     matched = false;
1568                                     break;
1569                                 }
1570                             }
1571                             if (matched) {
1572                                 return pos;
1573                             }
1574                          }
1575                     }
1576                     idx = getEntryNext(idx);
1577                 }
1578                 /* If not addSlash, or slash is already there, we are done */
1579                 if (!addSlash  || name.length == 0 || name[name.length - 1] == &#39;/&#39;) {
1580                      return -1;
1581                 }
<span class="line-modified">1582                 // Add a slash to the hash code</span>
<span class="line-modified">1583                 hsh = hashAppend(hsh, (byte)&#39;/&#39;);</span>
<span class="line-modified">1584                 // If we find a match on the new hash code, we need to append a</span>
<span class="line-modified">1585                 // slash when comparing</span>
<span class="line-modified">1586                 appendSlash = true;</span>
1587                 idx = table[(hsh &amp; 0x7fffffff) % tablelen];
1588                 addSlash = false;
1589             }
1590         }
1591 
1592         /**
1593          * Returns true if the bytes represent a non-directory name
1594          * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
1595          */
1596         private static boolean isMetaName(byte[] name, int off, int len) {
1597             // Use the &quot;oldest ASCII trick in the book&quot;
<span class="line-modified">1598             return len &gt; META_INF_LENGTH       // &quot;META-INF/&quot;.length()</span>
1599                 &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1600                 &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1601                 &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1602                 &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
1603                 &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;
1604                 &amp;&amp; (name[off++]       ) == &#39;-&#39;
1605                 &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1606                 &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1607                 &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;
1608                 &amp;&amp; (name[off]         ) == &#39;/&#39;;
1609         }
1610 
<span class="line-added">1611         /*</span>
<span class="line-added">1612          * If the bytes represents a non-directory name beginning</span>
<span class="line-added">1613          * with &quot;versions/&quot;, continuing with a positive integer,</span>
<span class="line-added">1614          * followed by a &#39;/&#39;, then return that integer value.</span>
<span class="line-added">1615          * Otherwise, return 0</span>
<span class="line-added">1616          */</span>
<span class="line-added">1617         private static int getMetaVersion(byte[] name, int off, int len) {</span>
<span class="line-added">1618             int nend = off + len;</span>
<span class="line-added">1619             if (!(len &gt; 10                         // &quot;versions//&quot;.length()</span>
<span class="line-added">1620                     &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory</span>
<span class="line-added">1621                     &amp;&amp; (name[off++] | 0x20) == &#39;v&#39;</span>
<span class="line-added">1622                     &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;</span>
<span class="line-added">1623                     &amp;&amp; (name[off++] | 0x20) == &#39;r&#39;</span>
<span class="line-added">1624                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;</span>
<span class="line-added">1625                     &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;</span>
<span class="line-added">1626                     &amp;&amp; (name[off++] | 0x20) == &#39;o&#39;</span>
<span class="line-added">1627                     &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;</span>
<span class="line-added">1628                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;</span>
<span class="line-added">1629                     &amp;&amp; (name[off++]         ) == &#39;/&#39;)) {</span>
<span class="line-added">1630                 return 0;</span>
<span class="line-added">1631             }</span>
<span class="line-added">1632             int version = 0;</span>
<span class="line-added">1633             while (off &lt; nend) {</span>
<span class="line-added">1634                 final byte c = name[off++];</span>
<span class="line-added">1635                 if (c == &#39;/&#39;) {</span>
<span class="line-added">1636                     return version;</span>
<span class="line-added">1637                 }</span>
<span class="line-added">1638                 if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {</span>
<span class="line-added">1639                     return 0;</span>
<span class="line-added">1640                 }</span>
<span class="line-added">1641                 version = version * 10 + c - &#39;0&#39;;</span>
<span class="line-added">1642                 // Check for overflow and leading zeros</span>
<span class="line-added">1643                 if (version &lt;= 0) {</span>
<span class="line-added">1644                     return 0;</span>
<span class="line-added">1645                 }</span>
<span class="line-added">1646             }</span>
<span class="line-added">1647             return 0;</span>
<span class="line-added">1648         }</span>
<span class="line-added">1649 </span>
1650         /**
1651          * Returns the number of CEN headers in a central directory.
1652          * Will not throw, even if the zip file is corrupt.
1653          *
1654          * @param cen copy of the bytes in a zip file&#39;s central directory
1655          * @param size number of bytes in central directory
1656          */
1657         private static int countCENHeaders(byte[] cen, int size) {
1658             int count = 0;
1659             for (int p = 0;
1660                  p + CENHDR &lt;= size;
1661                  p += CENHDR + CENNAM(cen, p) + CENEXT(cen, p) + CENCOM(cen, p))
1662                 count++;
1663             return count;
1664         }
1665     }
1666 }
</pre>
</td>
</tr>
</table>
<center><a href="../regex/Pattern.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../javax/net/ssl/SSLContext.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
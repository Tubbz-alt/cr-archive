<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/jar/JarFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../Scanner.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../regex/Grapheme.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/jar/JarFile.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 414 
 415             JarEntry manEntry = getManEntry();
 416 
 417             // If found then load the manifest
 418             if (manEntry != null) {
 419                 if (verify) {
 420                     byte[] b = getBytes(manEntry);
 421                     if (!jvInitialized) {
 422                         jv = new JarVerifier(b);
 423                     }
 424                     man = new Manifest(jv, new ByteArrayInputStream(b), getName());
 425                 } else {
 426                     man = new Manifest(super.getInputStream(manEntry), getName());
 427                 }
 428                 manRef = new SoftReference&lt;&gt;(man);
 429             }
 430         }
 431         return man;
 432     }
 433 
<span class="line-removed"> 434     private String[] getMetaInfEntryNames() {</span>
<span class="line-removed"> 435         return JUZFA.getMetaInfEntryNames((ZipFile)this);</span>
<span class="line-removed"> 436     }</span>
<span class="line-removed"> 437 </span>
 438     /**
 439      * Returns the {@code JarEntry} for the given base entry name or
 440      * {@code null} if not found.
 441      *
 442      * &lt;p&gt;If this {@code JarFile} is a multi-release jar file and is configured
 443      * to be processed as such, then a search is performed to find and return
 444      * a {@code JarEntry} that is the latest versioned entry associated with the
 445      * given entry name.  The returned {@code JarEntry} is the versioned entry
 446      * corresponding to the given base entry name prefixed with the string
 447      * {@code &quot;META-INF/versions/{n}/&quot;}, for the largest value of {@code n} for
 448      * which an entry exists.  If such a versioned entry does not exist, then
 449      * the {@code JarEntry} for the base entry is returned, otherwise
 450      * {@code null} is returned if no entries are found.  The initial value for
 451      * the version {@code n} is the maximum version as returned by the method
 452      * {@link JarFile#getVersion()}.
 453      *
 454      * @param name the jar file entry name
 455      * @return the {@code JarEntry} for the given entry name, or
 456      *         the versioned entry name, or {@code null} if not found
 457      *
</pre>
<hr />
<pre>
 487      *
 488      * @param name the jar file entry name
 489      * @return the {@code ZipEntry} for the given entry name or
 490      *         the versioned entry name or {@code null} if not found
 491      *
 492      * @throws IllegalStateException
 493      *         may be thrown if the jar file has been closed
 494      *
 495      * @see java.util.zip.ZipEntry
 496      *
 497      * @implSpec
 498      * &lt;div class=&quot;block&quot;&gt;
 499      * This implementation may return a versioned entry for the requested name
 500      * even if there is not a corresponding base entry.  This can occur
 501      * if there is a private or package-private versioned entry that matches.
 502      * If a subclass overrides this method, assure that the override method
 503      * invokes {@code super.getEntry(name)} to obtain all versioned entries.
 504      * &lt;/div&gt;
 505      */
 506     public ZipEntry getEntry(String name) {
<span class="line-removed"> 507         JarFileEntry je = getEntry0(name);</span>
 508         if (isMultiRelease()) {
<span class="line-modified"> 509             return getVersionedEntry(name, je);</span>






 510         }
<span class="line-removed"> 511         return je;</span>
 512     }
 513 
 514     /**
 515      * Returns an enumeration of the jar file entries.
 516      *
 517      * @return an enumeration of the jar file entries
 518      * @throws IllegalStateException
 519      *         may be thrown if the jar file has been closed
 520      */
 521     public Enumeration&lt;JarEntry&gt; entries() {
 522         return JUZFA.entries(this, JarFileEntry::new);
 523     }
 524 
 525     /**
 526      * Returns an ordered {@code Stream} over the jar file entries.
 527      * Entries appear in the {@code Stream} in the order they appear in
 528      * the central directory of the jar file.
 529      *
 530      * @return an ordered {@code Stream} of entries in this jar file
 531      * @throws IllegalStateException if the jar file has been closed
</pre>
<hr />
<pre>
 581     private String getBasename(String name) {
 582         if (name.startsWith(META_INF_VERSIONS)) {
 583             int off = META_INF_VERSIONS.length();
 584             int index = name.indexOf(&#39;/&#39;, off);
 585             try {
 586                 // filter out dir META-INF/versions/ and META-INF/versions/*/
 587                 // and any entry with version &gt; &#39;version&#39;
 588                 if (index == -1 || index == (name.length() - 1) ||
 589                     Integer.parseInt(name, off, index, 10) &gt; versionFeature) {
 590                     return null;
 591                 }
 592             } catch (NumberFormatException x) {
 593                 return null; // remove malformed entries silently
 594             }
 595             // map to its base name
 596             return name.substring(index + 1);
 597         }
 598         return name;
 599     }
 600 
<span class="line-modified"> 601     private JarEntry getVersionedEntry(String name, JarEntry je) {</span>
<span class="line-modified"> 602         if (BASE_VERSION_FEATURE &lt; versionFeature) {</span>
<span class="line-modified"> 603             if (!name.startsWith(META_INF)) {</span>

 604                 // search for versioned entry
<span class="line-modified"> 605                 int v = versionFeature;</span>
<span class="line-modified"> 606                 while (v &gt; BASE_VERSION_FEATURE) {</span>
<span class="line-modified"> 607                     JarFileEntry vje = getEntry0(META_INF_VERSIONS + v + &quot;/&quot; + name);</span>








 608                     if (vje != null) {
 609                         return vje.withBasename(name);
 610                     }
<span class="line-removed"> 611                     v--;</span>
 612                 }
 613             }
 614         }
<span class="line-modified"> 615         return je;</span>
 616     }
 617 
 618     // placeholder for now
 619     String getRealName(JarEntry entry) {
 620         return entry.getRealName();
 621     }
 622 
 623     private class JarFileEntry extends JarEntry {
 624         private String basename;
 625 
 626         JarFileEntry(String name) {
 627             super(name);
 628             this.basename = name;
 629         }
 630 
 631         JarFileEntry(String name, ZipEntry vze) {
 632             super(vze);
 633             this.basename = name;
 634         }
 635 
</pre>
<hr />
<pre>
 690 
 691         // changes the basename, returns &quot;this&quot;
 692         JarFileEntry withBasename(String name) {
 693             basename = name;
 694             return this;
 695         }
 696     }
 697 
 698     /*
 699      * Ensures that the JarVerifier has been created if one is
 700      * necessary (i.e., the jar appears to be signed.) This is done as
 701      * a quick check to avoid processing of the manifest for unsigned
 702      * jars.
 703      */
 704     private void maybeInstantiateVerifier() throws IOException {
 705         if (jv != null) {
 706             return;
 707         }
 708 
 709         if (verify) {
<span class="line-modified"> 710             String[] names = getMetaInfEntryNames();</span>
 711             if (names != null) {
 712                 for (String nameLower : names) {
 713                     String name = nameLower.toUpperCase(Locale.ENGLISH);
 714                     if (name.endsWith(&quot;.DSA&quot;) ||
 715                         name.endsWith(&quot;.RSA&quot;) ||
 716                         name.endsWith(&quot;.EC&quot;) ||
 717                         name.endsWith(&quot;.SF&quot;)) {
 718                         // Assume since we found a signature-related file
 719                         // that the jar is signed and that we therefore
 720                         // need a JarVerifier and Manifest
 721                         getManifest();
 722                         return;
 723                     }
 724                 }
 725             }
 726             // No signature-related files; don&#39;t instantiate a
 727             // verifier
 728             verify = false;
 729         }
 730     }
 731 
 732     /*
 733      * Initializes the verifier object by reading all the manifest
 734      * entries and passing them to the verifier.
 735      */
 736     private void initializeVerifier() {
 737         ManifestEntryVerifier mev = null;
 738 
 739         // Verify &quot;META-INF/&quot; entries...
 740         try {
<span class="line-modified"> 741             String[] names = getMetaInfEntryNames();</span>
 742             if (names != null) {
 743                 for (String name : names) {
 744                     String uname = name.toUpperCase(Locale.ENGLISH);
 745                     if (MANIFEST_NAME.equals(uname)
 746                             || SignatureFileVerifier.isBlockOrSF(uname)) {
 747                         JarEntry e = getJarEntry(name);
 748                         if (e == null) {
 749                             throw new JarException(&quot;corrupted jar file&quot;);
 750                         }
 751                         if (mev == null) {
 752                             mev = new ManifestEntryVerifier
 753                                 (getManifestFromReference());
 754                         }
 755                         byte[] b = getBytes(e);
 756                         if (b != null &amp;&amp; b.length &gt; 0) {
 757                             jv.beginEntry(e, mev);
 758                             jv.update(b.length, b, 0, b.length, mev);
 759                             jv.update(-1, null, 0, 0, mev);
 760                         }
 761                     }
</pre>
<hr />
<pre>
 915         MULTIRELEASE_LASTOCC[(int)&#39;:&#39; - 32] = 14;
 916         MULTIRELEASE_LASTOCC[(int)&#39; &#39; - 32] = 15;
 917         MULTIRELEASE_LASTOCC[(int)&#39;T&#39; - 32] = 16;
 918         MULTIRELEASE_LASTOCC[(int)&#39;R&#39; - 32] = 17;
 919         MULTIRELEASE_LASTOCC[(int)&#39;U&#39; - 32] = 18;
 920         MULTIRELEASE_LASTOCC[(int)&#39;E&#39; - 32] = 19;
 921         for (int i = 0; i &lt; 17; i++) {
 922             MULTIRELEASE_OPTOSFT[i] = 19;
 923         }
 924         MULTIRELEASE_OPTOSFT[17] = 6;
 925         MULTIRELEASE_OPTOSFT[18] = 1;
 926     }
 927 
 928     private JarEntry getManEntry() {
 929         if (manEntry == null) {
 930             // First look up manifest entry using standard name
 931             JarEntry manEntry = getEntry0(MANIFEST_NAME);
 932             if (manEntry == null) {
 933                 // If not found, then iterate through all the &quot;META-INF/&quot;
 934                 // entries to find a match.
<span class="line-modified"> 935                 String[] names = getMetaInfEntryNames();</span>
 936                 if (names != null) {
 937                     for (String name : names) {
 938                         if (MANIFEST_NAME.equals(name.toUpperCase(Locale.ENGLISH))) {
 939                             manEntry = getEntry0(name);
 940                             break;
 941                         }
 942                     }
 943                 }
 944             }
 945             this.manEntry = manEntry;
 946         }
 947         return manEntry;
 948     }
 949 
 950    /**
 951     * Returns {@code true} iff this JAR file has a manifest with the
 952     * Class-Path attribute
 953     */
 954     boolean hasClassPathAttribute() throws IOException {
 955         checkForSpecialAttributes();
</pre>
<hr />
<pre>
 999             return;
1000         }
1001         synchronized (this) {
1002             if (hasCheckedSpecialAttributes) {
1003                 return;
1004             }
1005             JarEntry manEntry = getManEntry();
1006             if (manEntry != null) {
1007                 byte[] b = getBytes(manEntry);
1008                 hasClassPathAttribute = match(CLASSPATH_CHARS, b,
1009                         CLASSPATH_LASTOCC, CLASSPATH_OPTOSFT) != -1;
1010                 // is this a multi-release jar file
1011                 if (MULTI_RELEASE_ENABLED) {
1012                     int i = match(MULTIRELEASE_CHARS, b, MULTIRELEASE_LASTOCC,
1013                             MULTIRELEASE_OPTOSFT);
1014                     if (i != -1) {
1015                         // Read the main attributes of the manifest
1016                         byte[] lbuf = new byte[512];
1017                         Attributes attr = new Attributes();
1018                         attr.read(new Manifest.FastInputStream(
<span class="line-modified">1019                             new ByteArrayInputStream(b)), lbuf);</span>
1020                         isMultiRelease = Boolean.parseBoolean(
1021                             attr.getValue(Attributes.Name.MULTI_RELEASE));
1022                     }
1023                 }
1024             }
1025             hasCheckedSpecialAttributes = true;
1026         }
1027     }
1028 
1029     synchronized void ensureInitialization() {
1030         try {
1031             maybeInstantiateVerifier();
1032         } catch (IOException e) {
1033             throw new RuntimeException(e);
1034         }
1035         if (jv != null &amp;&amp; !jvInitialized) {
1036             isInitializing.set(Boolean.TRUE);
1037             try {
1038                 initializeVerifier();
1039                 jvInitialized = true;
</pre>
<hr />
<pre>
1051     /*
1052      * Returns a versioned {@code JarFileEntry} for the given entry,
1053      * if there is one. Otherwise returns the original entry. This
1054      * is invoked by the {@code entries2} for verifier.
1055      */
1056     JarEntry newEntry(JarEntry je) {
1057         if (isMultiRelease()) {
1058             return getVersionedEntry(je.getName(), je);
1059         }
1060         return je;
1061     }
1062 
1063     /*
1064      * Returns a versioned {@code JarFileEntry} for the given entry
1065      * name, if there is one. Otherwise returns a {@code JarFileEntry}
1066      * with the given name. It is invoked from JarVerifier&#39;s entries2
1067      * for {@code singers}.
1068      */
1069     JarEntry newEntry(String name) {
1070         if (isMultiRelease()) {
<span class="line-modified">1071             JarEntry vje = getVersionedEntry(name, (JarEntry)null);</span>
1072             if (vje != null) {
1073                 return vje;
1074             }
1075         }
1076         return new JarFileEntry(name);
1077     }
1078 
1079     Enumeration&lt;String&gt; entryNames(CodeSource[] cs) {
1080         ensureInitialization();
1081         if (jv != null) {
1082             return jv.entryNames(this, cs);
1083         }
1084 
1085         /*
1086          * JAR file has no signed content. Is there a non-signing
1087          * code source?
1088          */
1089         boolean includeUnsigned = false;
1090         for (CodeSource c : cs) {
1091             if (c.getCodeSigners() == null) {
</pre>
</td>
<td>
<hr />
<pre>
 414 
 415             JarEntry manEntry = getManEntry();
 416 
 417             // If found then load the manifest
 418             if (manEntry != null) {
 419                 if (verify) {
 420                     byte[] b = getBytes(manEntry);
 421                     if (!jvInitialized) {
 422                         jv = new JarVerifier(b);
 423                     }
 424                     man = new Manifest(jv, new ByteArrayInputStream(b), getName());
 425                 } else {
 426                     man = new Manifest(super.getInputStream(manEntry), getName());
 427                 }
 428                 manRef = new SoftReference&lt;&gt;(man);
 429             }
 430         }
 431         return man;
 432     }
 433 




 434     /**
 435      * Returns the {@code JarEntry} for the given base entry name or
 436      * {@code null} if not found.
 437      *
 438      * &lt;p&gt;If this {@code JarFile} is a multi-release jar file and is configured
 439      * to be processed as such, then a search is performed to find and return
 440      * a {@code JarEntry} that is the latest versioned entry associated with the
 441      * given entry name.  The returned {@code JarEntry} is the versioned entry
 442      * corresponding to the given base entry name prefixed with the string
 443      * {@code &quot;META-INF/versions/{n}/&quot;}, for the largest value of {@code n} for
 444      * which an entry exists.  If such a versioned entry does not exist, then
 445      * the {@code JarEntry} for the base entry is returned, otherwise
 446      * {@code null} is returned if no entries are found.  The initial value for
 447      * the version {@code n} is the maximum version as returned by the method
 448      * {@link JarFile#getVersion()}.
 449      *
 450      * @param name the jar file entry name
 451      * @return the {@code JarEntry} for the given entry name, or
 452      *         the versioned entry name, or {@code null} if not found
 453      *
</pre>
<hr />
<pre>
 483      *
 484      * @param name the jar file entry name
 485      * @return the {@code ZipEntry} for the given entry name or
 486      *         the versioned entry name or {@code null} if not found
 487      *
 488      * @throws IllegalStateException
 489      *         may be thrown if the jar file has been closed
 490      *
 491      * @see java.util.zip.ZipEntry
 492      *
 493      * @implSpec
 494      * &lt;div class=&quot;block&quot;&gt;
 495      * This implementation may return a versioned entry for the requested name
 496      * even if there is not a corresponding base entry.  This can occur
 497      * if there is a private or package-private versioned entry that matches.
 498      * If a subclass overrides this method, assure that the override method
 499      * invokes {@code super.getEntry(name)} to obtain all versioned entries.
 500      * &lt;/div&gt;
 501      */
 502     public ZipEntry getEntry(String name) {

 503         if (isMultiRelease()) {
<span class="line-modified"> 504             JarEntry je = getVersionedEntry(name, null);</span>
<span class="line-added"> 505             if (je == null) {</span>
<span class="line-added"> 506                 je = getEntry0(name);</span>
<span class="line-added"> 507             }</span>
<span class="line-added"> 508             return je;</span>
<span class="line-added"> 509         } else {</span>
<span class="line-added"> 510             return getEntry0(name);</span>
 511         }

 512     }
 513 
 514     /**
 515      * Returns an enumeration of the jar file entries.
 516      *
 517      * @return an enumeration of the jar file entries
 518      * @throws IllegalStateException
 519      *         may be thrown if the jar file has been closed
 520      */
 521     public Enumeration&lt;JarEntry&gt; entries() {
 522         return JUZFA.entries(this, JarFileEntry::new);
 523     }
 524 
 525     /**
 526      * Returns an ordered {@code Stream} over the jar file entries.
 527      * Entries appear in the {@code Stream} in the order they appear in
 528      * the central directory of the jar file.
 529      *
 530      * @return an ordered {@code Stream} of entries in this jar file
 531      * @throws IllegalStateException if the jar file has been closed
</pre>
<hr />
<pre>
 581     private String getBasename(String name) {
 582         if (name.startsWith(META_INF_VERSIONS)) {
 583             int off = META_INF_VERSIONS.length();
 584             int index = name.indexOf(&#39;/&#39;, off);
 585             try {
 586                 // filter out dir META-INF/versions/ and META-INF/versions/*/
 587                 // and any entry with version &gt; &#39;version&#39;
 588                 if (index == -1 || index == (name.length() - 1) ||
 589                     Integer.parseInt(name, off, index, 10) &gt; versionFeature) {
 590                     return null;
 591                 }
 592             } catch (NumberFormatException x) {
 593                 return null; // remove malformed entries silently
 594             }
 595             // map to its base name
 596             return name.substring(index + 1);
 597         }
 598         return name;
 599     }
 600 
<span class="line-modified"> 601     private JarEntry getVersionedEntry(String name, JarEntry defaultEntry) {</span>
<span class="line-modified"> 602         if (!name.startsWith(META_INF)) {</span>
<span class="line-modified"> 603             int[] versions = JUZFA.getMetaInfVersions(this);</span>
<span class="line-added"> 604             if (BASE_VERSION_FEATURE &lt; versionFeature &amp;&amp; versions.length &gt; 0) {</span>
 605                 // search for versioned entry
<span class="line-modified"> 606                 for (int i = versions.length - 1; i &gt;= 0; i--) {</span>
<span class="line-modified"> 607                     int version = versions[i];</span>
<span class="line-modified"> 608                     // skip versions above versionFeature</span>
<span class="line-added"> 609                     if (version &gt; versionFeature) {</span>
<span class="line-added"> 610                         continue;</span>
<span class="line-added"> 611                     }</span>
<span class="line-added"> 612                     // skip versions below base version</span>
<span class="line-added"> 613                     if (version &lt; BASE_VERSION_FEATURE) {</span>
<span class="line-added"> 614                         break;</span>
<span class="line-added"> 615                     }</span>
<span class="line-added"> 616                     JarFileEntry vje = getEntry0(META_INF_VERSIONS + version + &quot;/&quot; + name);</span>
 617                     if (vje != null) {
 618                         return vje.withBasename(name);
 619                     }

 620                 }
 621             }
 622         }
<span class="line-modified"> 623         return defaultEntry;</span>
 624     }
 625 
 626     // placeholder for now
 627     String getRealName(JarEntry entry) {
 628         return entry.getRealName();
 629     }
 630 
 631     private class JarFileEntry extends JarEntry {
 632         private String basename;
 633 
 634         JarFileEntry(String name) {
 635             super(name);
 636             this.basename = name;
 637         }
 638 
 639         JarFileEntry(String name, ZipEntry vze) {
 640             super(vze);
 641             this.basename = name;
 642         }
 643 
</pre>
<hr />
<pre>
 698 
 699         // changes the basename, returns &quot;this&quot;
 700         JarFileEntry withBasename(String name) {
 701             basename = name;
 702             return this;
 703         }
 704     }
 705 
 706     /*
 707      * Ensures that the JarVerifier has been created if one is
 708      * necessary (i.e., the jar appears to be signed.) This is done as
 709      * a quick check to avoid processing of the manifest for unsigned
 710      * jars.
 711      */
 712     private void maybeInstantiateVerifier() throws IOException {
 713         if (jv != null) {
 714             return;
 715         }
 716 
 717         if (verify) {
<span class="line-modified"> 718             String[] names = JUZFA.getMetaInfEntryNames(this);</span>
 719             if (names != null) {
 720                 for (String nameLower : names) {
 721                     String name = nameLower.toUpperCase(Locale.ENGLISH);
 722                     if (name.endsWith(&quot;.DSA&quot;) ||
 723                         name.endsWith(&quot;.RSA&quot;) ||
 724                         name.endsWith(&quot;.EC&quot;) ||
 725                         name.endsWith(&quot;.SF&quot;)) {
 726                         // Assume since we found a signature-related file
 727                         // that the jar is signed and that we therefore
 728                         // need a JarVerifier and Manifest
 729                         getManifest();
 730                         return;
 731                     }
 732                 }
 733             }
 734             // No signature-related files; don&#39;t instantiate a
 735             // verifier
 736             verify = false;
 737         }
 738     }
 739 
 740     /*
 741      * Initializes the verifier object by reading all the manifest
 742      * entries and passing them to the verifier.
 743      */
 744     private void initializeVerifier() {
 745         ManifestEntryVerifier mev = null;
 746 
 747         // Verify &quot;META-INF/&quot; entries...
 748         try {
<span class="line-modified"> 749             String[] names = JUZFA.getMetaInfEntryNames(this);</span>
 750             if (names != null) {
 751                 for (String name : names) {
 752                     String uname = name.toUpperCase(Locale.ENGLISH);
 753                     if (MANIFEST_NAME.equals(uname)
 754                             || SignatureFileVerifier.isBlockOrSF(uname)) {
 755                         JarEntry e = getJarEntry(name);
 756                         if (e == null) {
 757                             throw new JarException(&quot;corrupted jar file&quot;);
 758                         }
 759                         if (mev == null) {
 760                             mev = new ManifestEntryVerifier
 761                                 (getManifestFromReference());
 762                         }
 763                         byte[] b = getBytes(e);
 764                         if (b != null &amp;&amp; b.length &gt; 0) {
 765                             jv.beginEntry(e, mev);
 766                             jv.update(b.length, b, 0, b.length, mev);
 767                             jv.update(-1, null, 0, 0, mev);
 768                         }
 769                     }
</pre>
<hr />
<pre>
 923         MULTIRELEASE_LASTOCC[(int)&#39;:&#39; - 32] = 14;
 924         MULTIRELEASE_LASTOCC[(int)&#39; &#39; - 32] = 15;
 925         MULTIRELEASE_LASTOCC[(int)&#39;T&#39; - 32] = 16;
 926         MULTIRELEASE_LASTOCC[(int)&#39;R&#39; - 32] = 17;
 927         MULTIRELEASE_LASTOCC[(int)&#39;U&#39; - 32] = 18;
 928         MULTIRELEASE_LASTOCC[(int)&#39;E&#39; - 32] = 19;
 929         for (int i = 0; i &lt; 17; i++) {
 930             MULTIRELEASE_OPTOSFT[i] = 19;
 931         }
 932         MULTIRELEASE_OPTOSFT[17] = 6;
 933         MULTIRELEASE_OPTOSFT[18] = 1;
 934     }
 935 
 936     private JarEntry getManEntry() {
 937         if (manEntry == null) {
 938             // First look up manifest entry using standard name
 939             JarEntry manEntry = getEntry0(MANIFEST_NAME);
 940             if (manEntry == null) {
 941                 // If not found, then iterate through all the &quot;META-INF/&quot;
 942                 // entries to find a match.
<span class="line-modified"> 943                 String[] names = JUZFA.getMetaInfEntryNames(this);</span>
 944                 if (names != null) {
 945                     for (String name : names) {
 946                         if (MANIFEST_NAME.equals(name.toUpperCase(Locale.ENGLISH))) {
 947                             manEntry = getEntry0(name);
 948                             break;
 949                         }
 950                     }
 951                 }
 952             }
 953             this.manEntry = manEntry;
 954         }
 955         return manEntry;
 956     }
 957 
 958    /**
 959     * Returns {@code true} iff this JAR file has a manifest with the
 960     * Class-Path attribute
 961     */
 962     boolean hasClassPathAttribute() throws IOException {
 963         checkForSpecialAttributes();
</pre>
<hr />
<pre>
1007             return;
1008         }
1009         synchronized (this) {
1010             if (hasCheckedSpecialAttributes) {
1011                 return;
1012             }
1013             JarEntry manEntry = getManEntry();
1014             if (manEntry != null) {
1015                 byte[] b = getBytes(manEntry);
1016                 hasClassPathAttribute = match(CLASSPATH_CHARS, b,
1017                         CLASSPATH_LASTOCC, CLASSPATH_OPTOSFT) != -1;
1018                 // is this a multi-release jar file
1019                 if (MULTI_RELEASE_ENABLED) {
1020                     int i = match(MULTIRELEASE_CHARS, b, MULTIRELEASE_LASTOCC,
1021                             MULTIRELEASE_OPTOSFT);
1022                     if (i != -1) {
1023                         // Read the main attributes of the manifest
1024                         byte[] lbuf = new byte[512];
1025                         Attributes attr = new Attributes();
1026                         attr.read(new Manifest.FastInputStream(
<span class="line-modified">1027                                 new ByteArrayInputStream(b)), lbuf);</span>
1028                         isMultiRelease = Boolean.parseBoolean(
1029                             attr.getValue(Attributes.Name.MULTI_RELEASE));
1030                     }
1031                 }
1032             }
1033             hasCheckedSpecialAttributes = true;
1034         }
1035     }
1036 
1037     synchronized void ensureInitialization() {
1038         try {
1039             maybeInstantiateVerifier();
1040         } catch (IOException e) {
1041             throw new RuntimeException(e);
1042         }
1043         if (jv != null &amp;&amp; !jvInitialized) {
1044             isInitializing.set(Boolean.TRUE);
1045             try {
1046                 initializeVerifier();
1047                 jvInitialized = true;
</pre>
<hr />
<pre>
1059     /*
1060      * Returns a versioned {@code JarFileEntry} for the given entry,
1061      * if there is one. Otherwise returns the original entry. This
1062      * is invoked by the {@code entries2} for verifier.
1063      */
1064     JarEntry newEntry(JarEntry je) {
1065         if (isMultiRelease()) {
1066             return getVersionedEntry(je.getName(), je);
1067         }
1068         return je;
1069     }
1070 
1071     /*
1072      * Returns a versioned {@code JarFileEntry} for the given entry
1073      * name, if there is one. Otherwise returns a {@code JarFileEntry}
1074      * with the given name. It is invoked from JarVerifier&#39;s entries2
1075      * for {@code singers}.
1076      */
1077     JarEntry newEntry(String name) {
1078         if (isMultiRelease()) {
<span class="line-modified">1079             JarEntry vje = getVersionedEntry(name, null);</span>
1080             if (vje != null) {
1081                 return vje;
1082             }
1083         }
1084         return new JarFileEntry(name);
1085     }
1086 
1087     Enumeration&lt;String&gt; entryNames(CodeSource[] cs) {
1088         ensureInitialization();
1089         if (jv != null) {
1090             return jv.entryNames(this, cs);
1091         }
1092 
1093         /*
1094          * JAR file has no signed content. Is there a non-signing
1095          * code source?
1096          */
1097         boolean includeUnsigned = false;
1098         for (CodeSource c : cs) {
1099             if (c.getCodeSigners() == null) {
</pre>
</td>
</tr>
</table>
<center><a href="../Scanner.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../regex/Grapheme.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
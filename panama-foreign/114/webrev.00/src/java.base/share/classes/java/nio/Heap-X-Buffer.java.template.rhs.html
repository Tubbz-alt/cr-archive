<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/nio/Heap-X-Buffer.java.template</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #warn This file is preprocessed before being compiled
 27 
 28 package java.nio;
 29 
 30 import java.util.Objects;
 31 import jdk.internal.access.foreign.MemorySegmentProxy;
 32 
 33 /**
 34 #if[rw]
 35  * A read/write Heap$Type$Buffer.
 36 #else[rw]
 37  * A read-only Heap$Type$Buffer.  This class extends the corresponding
 38  * read/write class, overriding the mutation methods to throw a {@link
 39  * ReadOnlyBufferException} and overriding the view-buffer methods to return an
 40  * instance of this class rather than of the superclass.
 41 #end[rw]
 42  */
 43 
 44 class Heap$Type$Buffer$RW$
 45     extends {#if[ro]?Heap}$Type$Buffer
 46 {
 47     // Cached array base offset
 48     private static final long ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset($type$[].class);
 49 
 50     // Cached array base offset
 51     private static final long ARRAY_INDEX_SCALE = UNSAFE.arrayIndexScale($type$[].class);
 52 
 53     // For speed these fields are actually declared in X-Buffer;
 54     // these declarations are here as documentation
 55     /*
 56 #if[rw]
 57     protected final $type$[] hb;
 58     protected final int offset;
 59 #end[rw]
 60     */
 61 
 62     Heap$Type$Buffer$RW$(int cap, int lim, MemorySegmentProxy segment) {            // package-private
 63 #if[rw]
 64         super(-1, 0, lim, cap, new $type$[cap], 0, segment);
 65         /*
 66         hb = new $type$[cap];
 67         offset = 0;
 68         */
 69         this.address = ARRAY_BASE_OFFSET;
 70 #else[rw]
 71         super(cap, lim, segment);
 72         this.isReadOnly = true;
 73 #end[rw]
 74     }
 75 
 76     Heap$Type$Buffer$RW$($type$[] buf, int off, int len, MemorySegmentProxy segment) { // package-private
 77 #if[rw]
 78         super(-1, off, off + len, buf.length, buf, 0, segment);
 79         /*
 80         hb = buf;
 81         offset = 0;
 82         */
 83         this.address = ARRAY_BASE_OFFSET;
 84 #else[rw]
 85         super(buf, off, len, segment);
 86         this.isReadOnly = true;
 87 #end[rw]
 88     }
 89 
 90     protected Heap$Type$Buffer$RW$($type$[] buf,
 91                                    int mark, int pos, int lim, int cap,
 92                                    int off, MemorySegmentProxy segment)
 93     {
 94 #if[rw]
 95         super(mark, pos, lim, cap, buf, off, segment);
 96         /*
 97         hb = buf;
 98         offset = off;
 99         */
100         this.address = ARRAY_BASE_OFFSET + off * ARRAY_INDEX_SCALE;
101 #else[rw]
102         super(buf, mark, pos, lim, cap, off, segment);
103         this.isReadOnly = true;
104 #end[rw]
105     }
106 
107     public $Type$Buffer slice() {
<a name="1" id="anc1"></a><span class="line-modified">108         int pos = this.position();</span>
<span class="line-added">109         int lim = this.limit();</span>
<span class="line-added">110         int rem = (pos &lt;= lim ? lim - pos : 0);</span>
111         return new Heap$Type$Buffer$RW$(hb,
112                                         -1,
113                                         0,
114                                         rem,
115                                         rem,
<a name="2" id="anc2"></a><span class="line-modified">116                                         pos + offset, segment);</span>
117     }
118 
119     @Override
120     public $Type$Buffer slice(int index, int length) {
121         Objects.checkFromIndexSize(index, length, limit());
122         return new Heap$Type$Buffer$RW$(hb,
123                                         -1,
124                                         0,
125                                         length,
126                                         length,
127                                         index + offset, segment);
128     }
129 
130     public $Type$Buffer duplicate() {
131         return new Heap$Type$Buffer$RW$(hb,
132                                         this.markValue(),
133                                         this.position(),
134                                         this.limit(),
135                                         this.capacity(),
136                                         offset, segment);
137     }
138 
139     public $Type$Buffer asReadOnlyBuffer() {
140 #if[rw]
141         return new Heap$Type$BufferR(hb,
142                                      this.markValue(),
143                                      this.position(),
144                                      this.limit(),
145                                      this.capacity(),
146                                      offset, segment);
147 #else[rw]
148         return duplicate();
149 #end[rw]
150     }
151 
152 #if[rw]
153 
154     protected int ix(int i) {
155         return i + offset;
156     }
157 
158 #if[byte]
159     private long byteOffset(long i) {
160         return address + i;
161     }
162 #end[byte]
163 
164     public $type$ get() {
165         checkSegment();
166         return hb[ix(nextGetIndex())];
167     }
168 
169     public $type$ get(int i) {
170         checkSegment();
171         return hb[ix(checkIndex(i))];
172     }
173 
174 #if[streamableType]
175     $type$ getUnchecked(int i) {
176     return hb[ix(i)];
177     }
178 #end[streamableType]
179 
180     public $Type$Buffer get($type$[] dst, int offset, int length) {
181         checkSegment();
182         Objects.checkFromIndexSize(offset, length, dst.length);
183         int pos = position();
184         if (length &gt; limit() - pos)
185             throw new BufferUnderflowException();
186         System.arraycopy(hb, ix(pos), dst, offset, length);
187         position(pos + length);
188         return this;
189     }
190 
191     public $Type$Buffer get(int index, $type$[] dst, int offset, int length) {
192         checkSegment();
193         Objects.checkFromIndexSize(index, length, limit());
194         Objects.checkFromIndexSize(offset, length, dst.length);
195         System.arraycopy(hb, ix(index), dst, offset, length);
196         return this;
197     }
198 
199     public boolean isDirect() {
200         return false;
201     }
202 
203 #end[rw]
204 
205     public boolean isReadOnly() {
206         return {#if[rw]?false:true};
207     }
208 
209     public $Type$Buffer put($type$ x) {
210 #if[rw]
211         checkSegment();
212         hb[ix(nextPutIndex())] = x;
213         return this;
214 #else[rw]
215         throw new ReadOnlyBufferException();
216 #end[rw]
217     }
218 
219     public $Type$Buffer put(int i, $type$ x) {
220 #if[rw]
221         checkSegment();
222         hb[ix(checkIndex(i))] = x;
223         return this;
224 #else[rw]
225         throw new ReadOnlyBufferException();
226 #end[rw]
227     }
228 
229     public $Type$Buffer put($type$[] src, int offset, int length) {
230 #if[rw]
231         checkSegment();
232         Objects.checkFromIndexSize(offset, length, src.length);
233         int pos = position();
234         if (length &gt; limit() - pos)
235             throw new BufferOverflowException();
236         System.arraycopy(src, offset, hb, ix(pos), length);
237         position(pos + length);
238         return this;
239 #else[rw]
240         throw new ReadOnlyBufferException();
241 #end[rw]
242     }
243 
244     public $Type$Buffer put($Type$Buffer src) {
245 #if[rw]
246         checkSegment();
247         if (src instanceof Heap$Type$Buffer) {
248             if (src == this)
249                 throw createSameBufferException();
250             Heap$Type$Buffer sb = (Heap$Type$Buffer)src;
251             int pos = position();
252             int sbpos = sb.position();
253             int n = sb.limit() - sbpos;
254             if (n &gt; limit() - pos)
255                 throw new BufferOverflowException();
256             System.arraycopy(sb.hb, sb.ix(sbpos),
257                              hb, ix(pos), n);
258             sb.position(sbpos + n);
259             position(pos + n);
260         } else if (src.isDirect()) {
261             int n = src.remaining();
262             int pos = position();
263             if (n &gt; limit() - pos)
264                 throw new BufferOverflowException();
265             src.get(hb, ix(pos), n);
266             position(pos + n);
267         } else {
268             super.put(src);
269         }
270         return this;
271 #else[rw]
272         throw new ReadOnlyBufferException();
273 #end[rw]
274     }
275 
276     public $Type$Buffer put(int index, $type$[] src, int offset, int length) {
277 #if[rw]
278         checkSegment();
279         Objects.checkFromIndexSize(index, length, limit());
280         Objects.checkFromIndexSize(offset, length, src.length);
281         System.arraycopy(src, offset, hb, ix(index), length);
282         return this;
283 #else[rw]
284         throw new ReadOnlyBufferException();
285 #end[rw]
286     }
287 
288 #if[char]
289 
290     public $Type$Buffer put(String src, int start, int end) {
291         checkSegment();
292         int length = end - start;
293         Objects.checkFromIndexSize(start, length, src.length());
294         if (isReadOnly())
295             throw new ReadOnlyBufferException();
296         int pos = position();
297         int lim = limit();
298         int rem = (pos &lt;= lim) ? lim - pos : 0;
299         if (length &gt; rem)
300             throw new BufferOverflowException();
301         src.getChars(start, end, hb, ix(pos));
302         position(pos + length);
303         return this;
304     }
305 
306 #end[char]
307 
308     public $Type$Buffer compact() {
309 #if[rw]
310         int pos = position();
311         int rem = limit() - pos;
312         System.arraycopy(hb, ix(pos), hb, ix(0), rem);
313         position(rem);
314         limit(capacity());
315         discardMark();
316         return this;
317 #else[rw]
318         throw new ReadOnlyBufferException();
319 #end[rw]
320     }
321 
322 
323 
324 #if[byte]
325 
326     byte _get(int i) {                          // package-private
327         return hb[i];
328     }
329 
330     void _put(int i, byte b) {                  // package-private
331 #if[rw]
332         hb[i] = b;
333 #else[rw]
334         throw new ReadOnlyBufferException();
335 #end[rw]
336     }
337 
338     // char
339 
340 #if[rw]
341 
342     public char getChar() {
343         checkSegment();
344         return UNSAFE.getCharUnaligned(hb, byteOffset(nextGetIndex(2)), bigEndian);
345     }
346 
347     public char getChar(int i) {
348         return UNSAFE.getCharUnaligned(hb, byteOffset(checkIndex(i, 2)), bigEndian);
349     }
350 
351 #end[rw]
352 
353     public $Type$Buffer putChar(char x) {
354 #if[rw]
355         checkSegment();
356         UNSAFE.putCharUnaligned(hb, byteOffset(nextPutIndex(2)), x, bigEndian);
357         return this;
358 #else[rw]
359         throw new ReadOnlyBufferException();
360 #end[rw]
361     }
362 
363     public $Type$Buffer putChar(int i, char x) {
364 #if[rw]
365         checkSegment();
366         UNSAFE.putCharUnaligned(hb, byteOffset(checkIndex(i, 2)), x, bigEndian);
367         return this;
368 #else[rw]
369         throw new ReadOnlyBufferException();
370 #end[rw]
371     }
372 
373     public CharBuffer asCharBuffer() {
374         int pos = position();
375         int size = (limit() - pos) &gt;&gt; 1;
376         long addr = address + pos;
377         return (bigEndian
378                 ? (CharBuffer)(new ByteBufferAsCharBuffer$RW$B(this,
379                                                                -1,
380                                                                0,
381                                                                size,
382                                                                size,
383                                                                addr, segment))
384                 : (CharBuffer)(new ByteBufferAsCharBuffer$RW$L(this,
385                                                                -1,
386                                                                0,
387                                                                size,
388                                                                size,
389                                                                addr, segment)));
390     }
391 
392 
393     // short
394 
395 #if[rw]
396 
397     public short getShort() {
398         checkSegment();
399         return UNSAFE.getShortUnaligned(hb, byteOffset(nextGetIndex(2)), bigEndian);
400     }
401 
402     public short getShort(int i) {
403         checkSegment();
404         return UNSAFE.getShortUnaligned(hb, byteOffset(checkIndex(i, 2)), bigEndian);
405     }
406 
407 #end[rw]
408 
409     public $Type$Buffer putShort(short x) {
410 #if[rw]
411         checkSegment();
412         UNSAFE.putShortUnaligned(hb, byteOffset(nextPutIndex(2)), x, bigEndian);
413         return this;
414 #else[rw]
415         throw new ReadOnlyBufferException();
416 #end[rw]
417     }
418 
419     public $Type$Buffer putShort(int i, short x) {
420 #if[rw]
421         checkSegment();
422         UNSAFE.putShortUnaligned(hb, byteOffset(checkIndex(i, 2)), x, bigEndian);
423         return this;
424 #else[rw]
425         throw new ReadOnlyBufferException();
426 #end[rw]
427     }
428 
429     public ShortBuffer asShortBuffer() {
430         int pos = position();
431         int size = (limit() - pos) &gt;&gt; 1;
432         long addr = address + pos;
433         return (bigEndian
434                 ? (ShortBuffer)(new ByteBufferAsShortBuffer$RW$B(this,
435                                                                  -1,
436                                                                  0,
437                                                                  size,
438                                                                  size,
439                                                                  addr, segment))
440                 : (ShortBuffer)(new ByteBufferAsShortBuffer$RW$L(this,
441                                                                  -1,
442                                                                  0,
443                                                                  size,
444                                                                  size,
445                                                                  addr, segment)));
446     }
447 
448 
449     // int
450 
451 #if[rw]
452 
453     public int getInt() {
454         checkSegment();
455         return UNSAFE.getIntUnaligned(hb, byteOffset(nextGetIndex(4)), bigEndian);
456     }
457 
458     public int getInt(int i) {
459         checkSegment();
460         return UNSAFE.getIntUnaligned(hb, byteOffset(checkIndex(i, 4)), bigEndian);
461     }
462 
463 #end[rw]
464 
465     public $Type$Buffer putInt(int x) {
466 #if[rw]
467         checkSegment();
468         UNSAFE.putIntUnaligned(hb, byteOffset(nextPutIndex(4)), x, bigEndian);
469         return this;
470 #else[rw]
471         throw new ReadOnlyBufferException();
472 #end[rw]
473     }
474 
475     public $Type$Buffer putInt(int i, int x) {
476 #if[rw]
477         checkSegment();
478         UNSAFE.putIntUnaligned(hb, byteOffset(checkIndex(i, 4)), x, bigEndian);
479         return this;
480 #else[rw]
481         throw new ReadOnlyBufferException();
482 #end[rw]
483     }
484 
485     public IntBuffer asIntBuffer() {
486         int pos = position();
487         int size = (limit() - pos) &gt;&gt; 2;
488         long addr = address + pos;
489         return (bigEndian
490                 ? (IntBuffer)(new ByteBufferAsIntBuffer$RW$B(this,
491                                                              -1,
492                                                              0,
493                                                              size,
494                                                              size,
495                                                              addr, segment))
496                 : (IntBuffer)(new ByteBufferAsIntBuffer$RW$L(this,
497                                                              -1,
498                                                              0,
499                                                              size,
500                                                              size,
501                                                              addr, segment)));
502     }
503 
504 
505     // long
506 
507 #if[rw]
508 
509     public long getLong() {
510         checkSegment();
511         return UNSAFE.getLongUnaligned(hb, byteOffset(nextGetIndex(8)), bigEndian);
512     }
513 
514     public long getLong(int i) {
515         checkSegment();
516         return UNSAFE.getLongUnaligned(hb, byteOffset(checkIndex(i, 8)), bigEndian);
517     }
518 
519 #end[rw]
520 
521     public $Type$Buffer putLong(long x) {
522 #if[rw]
523         checkSegment();
524         UNSAFE.putLongUnaligned(hb, byteOffset(nextPutIndex(8)), x, bigEndian);
525         return this;
526 #else[rw]
527         throw new ReadOnlyBufferException();
528 #end[rw]
529     }
530 
531     public $Type$Buffer putLong(int i, long x) {
532 #if[rw]
533         checkSegment();
534         UNSAFE.putLongUnaligned(hb, byteOffset(checkIndex(i, 8)), x, bigEndian);
535         return this;
536 #else[rw]
537         throw new ReadOnlyBufferException();
538 #end[rw]
539     }
540 
541     public LongBuffer asLongBuffer() {
542         int pos = position();
543         int size = (limit() - pos) &gt;&gt; 3;
544         long addr = address + pos;
545         return (bigEndian
546                 ? (LongBuffer)(new ByteBufferAsLongBuffer$RW$B(this,
547                                                                -1,
548                                                                0,
549                                                                size,
550                                                                size,
551                                                                addr, segment))
552                 : (LongBuffer)(new ByteBufferAsLongBuffer$RW$L(this,
553                                                                -1,
554                                                                0,
555                                                                size,
556                                                                size,
557                                                                addr, segment)));
558     }
559 
560 
561     // float
562 
563 #if[rw]
564 
565     public float getFloat() {
566         checkSegment();
567         int x = UNSAFE.getIntUnaligned(hb, byteOffset(nextGetIndex(4)), bigEndian);
568         return Float.intBitsToFloat(x);
569     }
570 
571     public float getFloat(int i) {
572         checkSegment();
573         int x = UNSAFE.getIntUnaligned(hb, byteOffset(checkIndex(i, 4)), bigEndian);
574         return Float.intBitsToFloat(x);
575     }
576 
577 #end[rw]
578 
579     public $Type$Buffer putFloat(float x) {
580 #if[rw]
581         checkSegment();
582         int y = Float.floatToRawIntBits(x);
583         UNSAFE.putIntUnaligned(hb, byteOffset(nextPutIndex(4)), y, bigEndian);
584         return this;
585 #else[rw]
586         throw new ReadOnlyBufferException();
587 #end[rw]
588     }
589 
590     public $Type$Buffer putFloat(int i, float x) {
591 #if[rw]
592         checkSegment();
593         int y = Float.floatToRawIntBits(x);
594         UNSAFE.putIntUnaligned(hb, byteOffset(checkIndex(i, 4)), y, bigEndian);
595         return this;
596 #else[rw]
597         throw new ReadOnlyBufferException();
598 #end[rw]
599     }
600 
601     public FloatBuffer asFloatBuffer() {
602         int pos = position();
603         int size = (limit() - pos) &gt;&gt; 2;
604         long addr = address + pos;
605         return (bigEndian
606                 ? (FloatBuffer)(new ByteBufferAsFloatBuffer$RW$B(this,
607                                                                  -1,
608                                                                  0,
609                                                                  size,
610                                                                  size,
611                                                                  addr, segment))
612                 : (FloatBuffer)(new ByteBufferAsFloatBuffer$RW$L(this,
613                                                                  -1,
614                                                                  0,
615                                                                  size,
616                                                                  size,
617                                                                  addr, segment)));
618     }
619 
620 
621     // double
622 
623 #if[rw]
624 
625     public double getDouble() {
626         checkSegment();
627         long x = UNSAFE.getLongUnaligned(hb, byteOffset(nextGetIndex(8)), bigEndian);
628         return Double.longBitsToDouble(x);
629     }
630 
631     public double getDouble(int i) {
632         checkSegment();
633         long x = UNSAFE.getLongUnaligned(hb, byteOffset(checkIndex(i, 8)), bigEndian);
634         return Double.longBitsToDouble(x);
635     }
636 
637 #end[rw]
638 
639     public $Type$Buffer putDouble(double x) {
640 #if[rw]
641         checkSegment();
642         long y = Double.doubleToRawLongBits(x);
643         UNSAFE.putLongUnaligned(hb, byteOffset(nextPutIndex(8)), y, bigEndian);
644         return this;
645 #else[rw]
646         throw new ReadOnlyBufferException();
647 #end[rw]
648     }
649 
650     public $Type$Buffer putDouble(int i, double x) {
651 #if[rw]
652         checkSegment();
653         long y = Double.doubleToRawLongBits(x);
654         UNSAFE.putLongUnaligned(hb, byteOffset(checkIndex(i, 8)), y, bigEndian);
655         return this;
656 #else[rw]
657         throw new ReadOnlyBufferException();
658 #end[rw]
659     }
660 
661     public DoubleBuffer asDoubleBuffer() {
662         int pos = position();
663         int size = (limit() - pos) &gt;&gt; 3;
664         long addr = address + pos;
665         return (bigEndian
666                 ? (DoubleBuffer)(new ByteBufferAsDoubleBuffer$RW$B(this,
667                                                                    -1,
668                                                                    0,
669                                                                    size,
670                                                                    size,
671                                                                    addr, segment))
672                 : (DoubleBuffer)(new ByteBufferAsDoubleBuffer$RW$L(this,
673                                                                    -1,
674                                                                    0,
675                                                                    size,
676                                                                    size,
677                                                                    addr, segment)));
678     }
679 
680 
681 #end[byte]
682 
683 
684 #if[char]
685 
686     String toString(int start, int end) {               // package-private
687         try {
688             return new String(hb, start + offset, end - start);
689         } catch (StringIndexOutOfBoundsException x) {
690             throw new IndexOutOfBoundsException();
691         }
692     }
693 
694 
695     // --- Methods to support CharSequence ---
696 
697     public CharBuffer subSequence(int start, int end) {
698         int pos = position();
699         Objects.checkFromToIndex(start, end, limit() - pos);
700         return new HeapCharBuffer$RW$(hb,
701                                       -1,
702                                       pos + start,
703                                       pos + end,
704                                       capacity(),
705                                       offset, segment);
706     }
707 
708 #end[char]
709 
710 
711 #if[!byte]
712 
713     public ByteOrder order() {
714         return ByteOrder.nativeOrder();
715     }
716 #end[!byte]
717 #if[char]
718 
719     ByteOrder charRegionOrder() {
720         return order();
721     }
722 #end[char]
723 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
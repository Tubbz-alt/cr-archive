<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/math/MutableBigInteger.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../lang/invoke/MethodType.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../net/SocketPermission.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/math/MutableBigInteger.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -2176,12 +2176,12 @@</span>
          // Copy the mod to protect original
          return fixup(new MutableBigInteger(1), new MutableBigInteger(mod), k);
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Calculate the multiplicative inverse of this mod mod, where mod is odd.</span>
<span class="udiff-line-modified-removed">-      * This and mod are not changed by the calculation.</span>
<span class="udiff-line-modified-added">+      * Calculate the multiplicative inverse of this modulo mod, where the mod</span>
<span class="udiff-line-modified-added">+      * argument is odd.  This and mod are not changed by the calculation.</span>
       *
       * This method implements an algorithm due to Richard Schroeppel, that uses
       * the same intermediate representation as Montgomery Reduction
       * (&quot;Montgomery Form&quot;).  The algorithm is described in an unpublished
       * manuscript entitled &quot;Fast Modular Reciprocals.&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2231,12 +2231,22 @@</span>
              f.rightShift(trailingZeros);
              d.leftShift(trailingZeros);
              k += trailingZeros;
          }
  
<span class="udiff-line-modified-removed">-         while (c.sign &lt; 0)</span>
<span class="udiff-line-modified-removed">-            c.signedAdd(p);</span>
<span class="udiff-line-modified-added">+         if (c.compare(p) &gt;= 0) { // c has a larger magnitude than p</span>
<span class="udiff-line-modified-added">+             MutableBigInteger remainder = c.divide(p,</span>
<span class="udiff-line-added">+                 new MutableBigInteger());</span>
<span class="udiff-line-added">+             // The previous line ignores the sign so we copy the data back</span>
<span class="udiff-line-added">+             // into c which will restore the sign as needed (and converts</span>
<span class="udiff-line-added">+             // it back to a SignedMutableBigInteger)</span>
<span class="udiff-line-added">+             c.copyValue(remainder);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (c.sign &lt; 0) {</span>
<span class="udiff-line-added">+             c.signedAdd(p);</span>
<span class="udiff-line-added">+         }</span>
  
          return fixup(c, p, k);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2270,12 +2280,12 @@</span>
              // c = c / 2^j
              c.rightShift(numBits);
          }
  
          // In theory, c may be greater than p at this point (Very rare!)
<span class="udiff-line-modified-removed">-         while (c.compare(p) &gt;= 0)</span>
<span class="udiff-line-modified-removed">-             c.subtract(p);</span>
<span class="udiff-line-modified-added">+         if (c.compare(p) &gt;= 0)</span>
<span class="udiff-line-modified-added">+             c = c.divide(p, new MutableBigInteger());</span>
  
          return c;
      }
  
      /**
</pre>
<center><a href="../lang/invoke/MethodType.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../net/SocketPermission.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
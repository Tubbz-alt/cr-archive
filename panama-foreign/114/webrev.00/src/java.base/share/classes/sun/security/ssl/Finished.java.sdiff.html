<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/Finished.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClientKeyExchange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HandshakeContext.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/Finished.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 464 
 465             // Output the handshake message.
 466             fm.write(shc.handshakeOutput);
 467             shc.handshakeOutput.flush();
 468 
 469             /*
 470              * save client verify data for secure renegotiation
 471              */
 472             if (shc.conContext.secureRenegotiation) {
 473                 shc.conContext.serverVerifyData = fm.verifyData;
 474             }
 475 
 476             // update the consumers and producers
 477             if (shc.isResumption) {
 478                 shc.conContext.consumers.put(ContentType.CHANGE_CIPHER_SPEC.id,
 479                         ChangeCipherSpec.t10Consumer);
 480                 shc.handshakeConsumers.put(
 481                         SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 482                 shc.conContext.inputRecord.expectingFinishFlight();
 483             } else {
<span class="line-modified"> 484                 if (shc.handshakeSession.isRejoinable() &amp;&amp;</span>
<span class="line-modified"> 485                         !shc.handshakeSession.isStatelessable(shc)) {</span>
<span class="line-modified"> 486                     ((SSLSessionContextImpl)shc.sslContext.</span>
<span class="line-modified"> 487                         engineGetServerSessionContext()).put(</span>
<span class="line-modified"> 488                             shc.handshakeSession);</span>





 489                 }
 490                 shc.conContext.conSession = shc.handshakeSession.finish();
 491                 shc.conContext.protocolVersion = shc.negotiatedProtocol;
 492 
 493                 // handshake context cleanup.
 494                 shc.handshakeFinished = true;
 495 
 496                 // May need to retransmit the last flight for DTLS.
 497                 if (!shc.sslContext.isDTLS()) {
 498                     shc.conContext.finishHandshake();
 499                 }
 500             }
 501 
 502             // The handshake message has been delivered.
 503             return null;
 504         }
 505     }
 506 
 507     /**
 508      * The &quot;Finished&quot; handshake message consumer.
</pre>
<hr />
<pre>
 840                 }
 841 
 842                 shc.baseWriteSecret = writeSecret;
 843                 shc.conContext.outputRecord.changeWriteCiphers(
 844                         writeCipher, false);
 845 
 846                 // update the context for the following key derivation
 847                 shc.handshakeKeyDerivation = secretKD;
 848             } catch (GeneralSecurityException gse) {
 849                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 850                         &quot;Failure to derive application secrets&quot;, gse);
 851             }
 852 
 853             /*
 854              * save client verify data for secure renegotiation
 855              */
 856             if (shc.conContext.secureRenegotiation) {
 857                 shc.conContext.serverVerifyData = fm.verifyData;
 858             }
 859 



 860             shc.conContext.conSession = shc.handshakeSession.finish();
 861 
 862             // update the context
 863             shc.handshakeConsumers.put(
 864                     SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 865 
 866             // The handshake message has been delivered.
 867             return null;
 868         }
 869     }
 870 
 871     /**
 872      * The &quot;Finished&quot; handshake message consumer.
 873      */
 874     private static final class T13FinishedConsumer implements SSLConsumer {
 875         // Prevent instantiation of this class.
 876         private T13FinishedConsumer() {
 877             // blank
 878         }
 879 
 880         @Override
 881         public void consume(ConnectionContext context,
 882                 ByteBuffer message) throws IOException {
 883             // The consuming happens in handshake context only.
 884             HandshakeContext hc = (HandshakeContext)context;
 885             if (hc.sslConfig.isClientMode) {
 886                 onConsumeFinished(
 887                         (ClientHandshakeContext)context, message);
 888             } else {
 889                 onConsumeFinished(
 890                         (ServerHandshakeContext)context, message);
 891             }
 892         }
 893 
 894         private void onConsumeFinished(ClientHandshakeContext chc,
 895                 ByteBuffer message) throws IOException {
 896             // Make sure that any expected CertificateVerify message
 897             // has been received and processed.
 898             if (!chc.isResumption) {
 899                 if (chc.handshakeConsumers.containsKey(


 900                         SSLHandshake.CERTIFICATE_VERIFY.id)) {
 901                     throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 902                             &quot;Unexpected Finished handshake message&quot;);
 903                 }
 904             }
 905 
 906             FinishedMessage fm = new FinishedMessage(chc, message);
 907             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 908                 SSLLogger.fine(
 909                         &quot;Consuming server Finished handshake message&quot;, fm);
 910             }
 911 
 912             // Save client verify data for secure renegotiation.
 913             if (chc.conContext.secureRenegotiation) {
 914                 chc.conContext.serverVerifyData = fm.verifyData;
 915             }
 916 
 917             //
 918             // validate
 919             //
</pre>
<hr />
<pre>
1012                 SSLHandshake.CERTIFICATE,
1013                 SSLHandshake.CERTIFICATE_VERIFY,
1014                 SSLHandshake.FINISHED
1015             };
1016 
1017             for (SSLHandshake hs : probableHandshakeMessages) {
1018                 HandshakeProducer handshakeProducer =
1019                         chc.handshakeProducers.remove(hs.id);
1020                 if (handshakeProducer != null) {
1021                     handshakeProducer.produce(chc, null);
1022                 }
1023             }
1024         }
1025 
1026         private void onConsumeFinished(ServerHandshakeContext shc,
1027                 ByteBuffer message) throws IOException {
1028             // Make sure that any expected CertificateVerify message
1029             // has been received and processed.
1030             if (!shc.isResumption) {
1031                 if (shc.handshakeConsumers.containsKey(


1032                         SSLHandshake.CERTIFICATE_VERIFY.id)) {
1033                     throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
1034                             &quot;Unexpected Finished handshake message&quot;);
1035                 }
1036             }
1037 
1038             FinishedMessage fm = new FinishedMessage(shc, message);
1039             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1040                 SSLLogger.fine(
1041                         &quot;Consuming client Finished handshake message&quot;, fm);
1042             }
1043 
1044             if (shc.conContext.secureRenegotiation) {
1045                 shc.conContext.clientVerifyData = fm.verifyData;
1046             }
1047 
1048             //
1049             // validate
1050             //
1051             // blank
</pre>
<hr />
<pre>
1053             //
1054             // update
1055             //
1056             // Change client/server application traffic secrets.
1057             SSLKeyDerivation kd = shc.handshakeKeyDerivation;
1058             if (kd == null) {
1059                 // unlikely
1060                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1061                     &quot;no key derivation&quot;);
1062             }
1063 
1064             SSLTrafficKeyDerivation kdg =
1065                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
1066             if (kdg == null) {
1067                 // unlikely
1068                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1069                         &quot;Not supported key derivation: &quot; +
1070                         shc.negotiatedProtocol);
1071             }
1072 
<span class="line-removed">1073             // Save the session if possible and not stateless</span>
<span class="line-removed">1074             if (!shc.statelessResumption &amp;&amp; !shc.isResumption &amp;&amp;</span>
<span class="line-removed">1075                     shc.handshakeSession.isRejoinable()) {</span>
<span class="line-removed">1076                 SSLSessionContextImpl sessionContext = (SSLSessionContextImpl)</span>
<span class="line-removed">1077                         shc.sslContext.engineGetServerSessionContext();</span>
<span class="line-removed">1078                 sessionContext.put(shc.handshakeSession);</span>
<span class="line-removed">1079             }</span>
<span class="line-removed">1080 </span>
1081             try {
1082                 // update the application traffic read keys.
1083                 SecretKey readSecret = kd.deriveKey(
1084                         &quot;TlsClientAppTrafficSecret&quot;, null);
1085 
1086                 SSLKeyDerivation readKD =
1087                         kdg.createKeyDerivation(shc, readSecret);
1088                 SecretKey readKey = readKD.deriveKey(
1089                         &quot;TlsKey&quot;, null);
1090                 SecretKey readIvSecret = readKD.deriveKey(
1091                         &quot;TlsIv&quot;, null);
1092                 IvParameterSpec readIv =
1093                         new IvParameterSpec(readIvSecret.getEncoded());
1094                 SSLReadCipher readCipher =
1095                         shc.negotiatedCipherSuite.bulkCipher.createReadCipher(
1096                                 Authenticator.valueOf(shc.negotiatedProtocol),
1097                                 shc.negotiatedProtocol, readKey, readIv,
1098                                 shc.sslContext.getSecureRandom());
1099 
1100                 if (readCipher == null) {
</pre>
</td>
<td>
<hr />
<pre>
 464 
 465             // Output the handshake message.
 466             fm.write(shc.handshakeOutput);
 467             shc.handshakeOutput.flush();
 468 
 469             /*
 470              * save client verify data for secure renegotiation
 471              */
 472             if (shc.conContext.secureRenegotiation) {
 473                 shc.conContext.serverVerifyData = fm.verifyData;
 474             }
 475 
 476             // update the consumers and producers
 477             if (shc.isResumption) {
 478                 shc.conContext.consumers.put(ContentType.CHANGE_CIPHER_SPEC.id,
 479                         ChangeCipherSpec.t10Consumer);
 480                 shc.handshakeConsumers.put(
 481                         SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 482                 shc.conContext.inputRecord.expectingFinishFlight();
 483             } else {
<span class="line-modified"> 484                 // Set the session&#39;s context based on stateless/cache status</span>
<span class="line-modified"> 485                 if (shc.handshakeSession.isStatelessable(shc)) {</span>
<span class="line-modified"> 486                     shc.handshakeSession.setContext((SSLSessionContextImpl)</span>
<span class="line-modified"> 487                             shc.sslContext.engineGetServerSessionContext());</span>
<span class="line-modified"> 488                 } else {</span>
<span class="line-added"> 489                     if (shc.handshakeSession.isRejoinable()) {</span>
<span class="line-added"> 490                         ((SSLSessionContextImpl)shc.sslContext.</span>
<span class="line-added"> 491                                 engineGetServerSessionContext()).put(</span>
<span class="line-added"> 492                                 shc.handshakeSession);</span>
<span class="line-added"> 493                     }</span>
 494                 }
 495                 shc.conContext.conSession = shc.handshakeSession.finish();
 496                 shc.conContext.protocolVersion = shc.negotiatedProtocol;
 497 
 498                 // handshake context cleanup.
 499                 shc.handshakeFinished = true;
 500 
 501                 // May need to retransmit the last flight for DTLS.
 502                 if (!shc.sslContext.isDTLS()) {
 503                     shc.conContext.finishHandshake();
 504                 }
 505             }
 506 
 507             // The handshake message has been delivered.
 508             return null;
 509         }
 510     }
 511 
 512     /**
 513      * The &quot;Finished&quot; handshake message consumer.
</pre>
<hr />
<pre>
 845                 }
 846 
 847                 shc.baseWriteSecret = writeSecret;
 848                 shc.conContext.outputRecord.changeWriteCiphers(
 849                         writeCipher, false);
 850 
 851                 // update the context for the following key derivation
 852                 shc.handshakeKeyDerivation = secretKD;
 853             } catch (GeneralSecurityException gse) {
 854                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 855                         &quot;Failure to derive application secrets&quot;, gse);
 856             }
 857 
 858             /*
 859              * save client verify data for secure renegotiation
 860              */
 861             if (shc.conContext.secureRenegotiation) {
 862                 shc.conContext.serverVerifyData = fm.verifyData;
 863             }
 864 
<span class="line-added"> 865             // Make sure session&#39;s context is set</span>
<span class="line-added"> 866             shc.handshakeSession.setContext((SSLSessionContextImpl)</span>
<span class="line-added"> 867                     shc.sslContext.engineGetServerSessionContext());</span>
 868             shc.conContext.conSession = shc.handshakeSession.finish();
 869 
 870             // update the context
 871             shc.handshakeConsumers.put(
 872                     SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 873 
 874             // The handshake message has been delivered.
 875             return null;
 876         }
 877     }
 878 
 879     /**
 880      * The &quot;Finished&quot; handshake message consumer.
 881      */
 882     private static final class T13FinishedConsumer implements SSLConsumer {
 883         // Prevent instantiation of this class.
 884         private T13FinishedConsumer() {
 885             // blank
 886         }
 887 
 888         @Override
 889         public void consume(ConnectionContext context,
 890                 ByteBuffer message) throws IOException {
 891             // The consuming happens in handshake context only.
 892             HandshakeContext hc = (HandshakeContext)context;
 893             if (hc.sslConfig.isClientMode) {
 894                 onConsumeFinished(
 895                         (ClientHandshakeContext)context, message);
 896             } else {
 897                 onConsumeFinished(
 898                         (ServerHandshakeContext)context, message);
 899             }
 900         }
 901 
 902         private void onConsumeFinished(ClientHandshakeContext chc,
 903                 ByteBuffer message) throws IOException {
 904             // Make sure that any expected CertificateVerify message
 905             // has been received and processed.
 906             if (!chc.isResumption) {
 907                 if (chc.handshakeConsumers.containsKey(
<span class="line-added"> 908                         SSLHandshake.CERTIFICATE.id) ||</span>
<span class="line-added"> 909                     chc.handshakeConsumers.containsKey(</span>
 910                         SSLHandshake.CERTIFICATE_VERIFY.id)) {
 911                     throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 912                             &quot;Unexpected Finished handshake message&quot;);
 913                 }
 914             }
 915 
 916             FinishedMessage fm = new FinishedMessage(chc, message);
 917             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 918                 SSLLogger.fine(
 919                         &quot;Consuming server Finished handshake message&quot;, fm);
 920             }
 921 
 922             // Save client verify data for secure renegotiation.
 923             if (chc.conContext.secureRenegotiation) {
 924                 chc.conContext.serverVerifyData = fm.verifyData;
 925             }
 926 
 927             //
 928             // validate
 929             //
</pre>
<hr />
<pre>
1022                 SSLHandshake.CERTIFICATE,
1023                 SSLHandshake.CERTIFICATE_VERIFY,
1024                 SSLHandshake.FINISHED
1025             };
1026 
1027             for (SSLHandshake hs : probableHandshakeMessages) {
1028                 HandshakeProducer handshakeProducer =
1029                         chc.handshakeProducers.remove(hs.id);
1030                 if (handshakeProducer != null) {
1031                     handshakeProducer.produce(chc, null);
1032                 }
1033             }
1034         }
1035 
1036         private void onConsumeFinished(ServerHandshakeContext shc,
1037                 ByteBuffer message) throws IOException {
1038             // Make sure that any expected CertificateVerify message
1039             // has been received and processed.
1040             if (!shc.isResumption) {
1041                 if (shc.handshakeConsumers.containsKey(
<span class="line-added">1042                         SSLHandshake.CERTIFICATE.id) ||</span>
<span class="line-added">1043                     shc.handshakeConsumers.containsKey(</span>
1044                         SSLHandshake.CERTIFICATE_VERIFY.id)) {
1045                     throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
1046                             &quot;Unexpected Finished handshake message&quot;);
1047                 }
1048             }
1049 
1050             FinishedMessage fm = new FinishedMessage(shc, message);
1051             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1052                 SSLLogger.fine(
1053                         &quot;Consuming client Finished handshake message&quot;, fm);
1054             }
1055 
1056             if (shc.conContext.secureRenegotiation) {
1057                 shc.conContext.clientVerifyData = fm.verifyData;
1058             }
1059 
1060             //
1061             // validate
1062             //
1063             // blank
</pre>
<hr />
<pre>
1065             //
1066             // update
1067             //
1068             // Change client/server application traffic secrets.
1069             SSLKeyDerivation kd = shc.handshakeKeyDerivation;
1070             if (kd == null) {
1071                 // unlikely
1072                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1073                     &quot;no key derivation&quot;);
1074             }
1075 
1076             SSLTrafficKeyDerivation kdg =
1077                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
1078             if (kdg == null) {
1079                 // unlikely
1080                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1081                         &quot;Not supported key derivation: &quot; +
1082                         shc.negotiatedProtocol);
1083             }
1084 








1085             try {
1086                 // update the application traffic read keys.
1087                 SecretKey readSecret = kd.deriveKey(
1088                         &quot;TlsClientAppTrafficSecret&quot;, null);
1089 
1090                 SSLKeyDerivation readKD =
1091                         kdg.createKeyDerivation(shc, readSecret);
1092                 SecretKey readKey = readKD.deriveKey(
1093                         &quot;TlsKey&quot;, null);
1094                 SecretKey readIvSecret = readKD.deriveKey(
1095                         &quot;TlsIv&quot;, null);
1096                 IvParameterSpec readIv =
1097                         new IvParameterSpec(readIvSecret.getEncoded());
1098                 SSLReadCipher readCipher =
1099                         shc.negotiatedCipherSuite.bulkCipher.createReadCipher(
1100                                 Authenticator.valueOf(shc.negotiatedProtocol),
1101                                 shc.negotiatedProtocol, readKey, readIv,
1102                                 shc.sslContext.getSecureRandom());
1103 
1104                 if (readCipher == null) {
</pre>
</td>
</tr>
</table>
<center><a href="ClientKeyExchange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HandshakeContext.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
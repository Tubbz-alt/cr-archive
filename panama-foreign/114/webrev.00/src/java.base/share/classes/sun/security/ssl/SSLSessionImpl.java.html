<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package sun.security.ssl;
  26 
  27 import sun.security.x509.X509CertImpl;
  28 
  29 import java.io.IOException;
  30 import java.lang.reflect.Array;
  31 import java.math.BigInteger;
  32 import java.net.InetAddress;
  33 import java.nio.ByteBuffer;
  34 import java.security.Principal;
  35 import java.security.PrivateKey;
  36 import java.security.cert.CertificateEncodingException;
  37 import java.security.cert.X509Certificate;
  38 import java.util.ArrayList;
  39 import java.util.Arrays;
  40 import java.util.Queue;
  41 import java.util.Collection;
  42 import java.util.Collections;
  43 import java.util.Enumeration;
  44 import java.util.List;
  45 import java.util.concurrent.ConcurrentHashMap;
  46 import java.util.concurrent.ConcurrentLinkedQueue;
  47 import java.util.concurrent.locks.ReentrantLock;
  48 import javax.crypto.SecretKey;
  49 import javax.crypto.spec.SecretKeySpec;
  50 import javax.net.ssl.ExtendedSSLSession;
  51 import javax.net.ssl.SNIHostName;
  52 import javax.net.ssl.SNIServerName;
  53 import javax.net.ssl.SSLException;
  54 import javax.net.ssl.SSLPeerUnverifiedException;
  55 import javax.net.ssl.SSLPermission;
  56 import javax.net.ssl.SSLSessionBindingEvent;
  57 import javax.net.ssl.SSLSessionBindingListener;
  58 import javax.net.ssl.SSLSessionContext;
  59 
  60 /**
  61  * Implements the SSL session interface, and exposes the session context
  62  * which is maintained by SSL servers.
  63  *
  64  * &lt;P&gt; Servers have the ability to manage the sessions associated with
  65  * their authentication context(s).  They can do this by enumerating the
  66  * IDs of the sessions which are cached, examining those sessions, and then
  67  * perhaps invalidating a given session so that it can&#39;t be used again.
  68  * If servers do not explicitly manage the cache, sessions will linger
  69  * until memory is low enough that the runtime environment purges cache
  70  * entries automatically to reclaim space.
  71  *
  72  * &lt;P&gt;&lt;em&gt; The only reason this class is not package-private is that
  73  * there&#39;s no other public way to get at the server session context which
  74  * is associated with any given authentication context. &lt;/em&gt;
  75  *
  76  * @author David Brownell
  77  */
  78 final class SSLSessionImpl extends ExtendedSSLSession {
  79 
  80     /*
  81      * The state of a single session, as described in section 7.1
  82      * of the SSLv3 spec.
  83      */
  84     private final ProtocolVersion       protocolVersion;
  85     private final SessionId             sessionId;
  86     private X509Certificate[]   peerCerts;
  87     private CipherSuite         cipherSuite;
  88     private SecretKey           masterSecret;
  89     final boolean               useExtendedMasterSecret;
  90 
  91     /*
  92      * Information not part of the SSLv3 protocol spec, but used
  93      * to support session management policies.
  94      */
  95     private final long          creationTime;
  96     private long                lastUsedTime = 0;
  97     private final String        host;
  98     private final int           port;
  99     private SSLSessionContextImpl       context;
 100     private boolean             invalidated;
 101     private X509Certificate[]   localCerts;
 102     private PrivateKey          localPrivateKey;
 103     private final Collection&lt;SignatureScheme&gt;     localSupportedSignAlgs;
 104     private Collection&lt;SignatureScheme&gt; peerSupportedSignAlgs; //for certificate
 105     private boolean             useDefaultPeerSignAlgs = false;
 106     private List&lt;byte[]&gt;        statusResponses;
 107     private SecretKey           resumptionMasterSecret;
 108     private SecretKey           preSharedKey;
 109     private byte[]              pskIdentity;
 110     private final long          ticketCreationTime = System.currentTimeMillis();
 111     private int                 ticketAgeAdd;
 112 
 113     private int                 negotiatedMaxFragLen = -1;
 114     private int                 maximumPacketSize;
 115 
 116     private final Queue&lt;SSLSessionImpl&gt; childSessions =
 117                                         new ConcurrentLinkedQueue&lt;&gt;();
 118 
 119     /*
 120      * Is the session currently re-established with a session-resumption
 121      * abbreviated initial handshake?
 122      *
 123      * Note that currently we only set this variable in client side.
 124      */
 125     private boolean isSessionResumption = false;
 126 
 127     /*
 128      * Use of session caches is globally enabled/disabled.
 129      */
 130     private static boolean      defaultRejoinable = true;
 131 
 132     // server name indication
 133     final SNIServerName         serverNameIndication;
 134     private final List&lt;SNIServerName&gt;    requestedServerNames;
 135 
 136     // Counter used to create unique nonces in NewSessionTicket
 137     private BigInteger ticketNonceCounter = BigInteger.ONE;
 138 
 139     // The endpoint identification algorithm used to check certificates
 140     // in this session.
 141     private final String        identificationProtocol;
 142 
 143     private final ReentrantLock sessionLock = new ReentrantLock();
 144 
 145     /*
 146      * Create a new non-rejoinable session, using the default (null)
 147      * cipher spec.  This constructor returns a session which could
 148      * be used either by a client or by a server, as a connection is
 149      * first opened and before handshaking begins.
 150      */
 151     SSLSessionImpl() {
 152         this.protocolVersion = ProtocolVersion.NONE;
 153         this.cipherSuite = CipherSuite.C_NULL;
 154         this.sessionId = new SessionId(false, null);
 155         this.host = null;
 156         this.port = -1;
 157         this.localSupportedSignAlgs = Collections.emptySet();
 158         this.serverNameIndication = null;
 159         this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 160         this.useExtendedMasterSecret = false;
 161         this.creationTime = System.currentTimeMillis();
 162         this.identificationProtocol = null;
 163         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 164     }
 165 
 166     /*
 167      * Create a new session, using a given cipher spec.  This will
 168      * be rejoinable if session caching is enabled; the constructor
 169      * is intended mostly for use by serves.
 170      */
 171     SSLSessionImpl(HandshakeContext hc, CipherSuite cipherSuite) {
 172         this(hc, cipherSuite,
 173             new SessionId(defaultRejoinable, hc.sslContext.getSecureRandom()));
 174     }
 175 
 176     /*
 177      * Record a new session, using a given cipher spec and session ID.
 178      */
 179     SSLSessionImpl(HandshakeContext hc, CipherSuite cipherSuite, SessionId id) {
 180         this(hc, cipherSuite, id, System.currentTimeMillis());
 181     }
 182 
 183     /*
 184      * Record a new session, using a given cipher spec, session ID,
 185      * and creation time.
 186      * Note: For the unmodifiable collections and lists we are creating new
 187      * collections as inputs to avoid potential deep nesting of
 188      * unmodifiable collections that can cause StackOverflowErrors
 189      * (see JDK-6323374).
 190      */
 191     SSLSessionImpl(HandshakeContext hc,
 192             CipherSuite cipherSuite, SessionId id, long creationTime) {
 193         this.protocolVersion = hc.negotiatedProtocol;
 194         this.cipherSuite = cipherSuite;
 195         this.sessionId = id;
 196         this.host = hc.conContext.transport.getPeerHost();
 197         this.port = hc.conContext.transport.getPeerPort();
 198         this.localSupportedSignAlgs = hc.localSupportedSignAlgs == null ?
 199                 Collections.emptySet() :
 200                 Collections.unmodifiableCollection(
 201                         new ArrayList&lt;&gt;(hc.localSupportedSignAlgs));
 202         this.serverNameIndication = hc.negotiatedServerName;
 203         this.requestedServerNames = Collections.unmodifiableList(
 204                 new ArrayList&lt;&gt;(hc.getRequestedServerNames()));
 205         if (hc.sslConfig.isClientMode) {
 206             this.useExtendedMasterSecret =
 207                 (hc.handshakeExtensions.get(
 208                         SSLExtension.CH_EXTENDED_MASTER_SECRET) != null) &amp;&amp;
 209                 (hc.handshakeExtensions.get(
 210                         SSLExtension.SH_EXTENDED_MASTER_SECRET) != null);
 211         } else {
 212             this.useExtendedMasterSecret =
 213                 (hc.handshakeExtensions.get(
 214                         SSLExtension.CH_EXTENDED_MASTER_SECRET) != null) &amp;&amp;
 215                 (!hc.negotiatedProtocol.useTLS13PlusSpec());
 216         }
 217         this.creationTime = creationTime;
 218         this.identificationProtocol = hc.sslConfig.identificationProtocol;
 219         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 220 
 221         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 222              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 223         }
 224     }
 225 
 226     SSLSessionImpl(SSLSessionImpl baseSession, SessionId newId) {
 227         this.protocolVersion = baseSession.getProtocolVersion();
 228         this.cipherSuite = baseSession.cipherSuite;
 229         this.sessionId = newId;
 230         this.host = baseSession.getPeerHost();
 231         this.port = baseSession.getPeerPort();
 232         this.localSupportedSignAlgs =
 233                 baseSession.localSupportedSignAlgs == null ?
 234                 Collections.emptySet() : baseSession.localSupportedSignAlgs;
 235         this.peerSupportedSignAlgs =
 236                 baseSession.peerSupportedSignAlgs == null ?
 237                 Collections.emptySet() : baseSession.peerSupportedSignAlgs;
 238         this.serverNameIndication = baseSession.serverNameIndication;
 239         this.requestedServerNames = baseSession.getRequestedServerNames();
 240         this.masterSecret = baseSession.getMasterSecret();
 241         this.useExtendedMasterSecret = baseSession.useExtendedMasterSecret;
 242         this.creationTime = baseSession.getCreationTime();
 243         this.lastUsedTime = System.currentTimeMillis();
 244         this.identificationProtocol = baseSession.getIdentificationProtocol();
 245         this.localCerts = baseSession.localCerts;
 246         this.peerCerts = baseSession.peerCerts;
 247         this.statusResponses = baseSession.statusResponses;
 248         this.resumptionMasterSecret = baseSession.resumptionMasterSecret;
 249         this.context = baseSession.context;
 250         this.negotiatedMaxFragLen = baseSession.negotiatedMaxFragLen;
 251         this.maximumPacketSize = baseSession.maximumPacketSize;
 252         this.boundValues = baseSession.boundValues;
 253 
 254         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 255              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 256         }
 257     }
 258 
 259     /**
 260      * &lt; 2 bytes &gt; protocolVersion
 261      * &lt; 2 bytes &gt; cipherSuite
 262      * &lt; 1 byte &gt; localSupportedSignAlgs entries
 263      *   &lt; 2 bytes per entries &gt; localSupportedSignAlgs
 264      * &lt; 1 bytes &gt; peerSupportedSignAlgs entries
 265      *   &lt; 2 bytes per entries &gt; peerSupportedSignAlgs
 266      * &lt; 2 bytes &gt; preSharedKey length
 267      * &lt; length in bytes &gt; preSharedKey
 268      * &lt; 1 byte &gt; pskIdentity length
 269      * &lt; length in bytes &gt; pskIdentity
 270      * &lt; 1 byte &gt; masterSecret length
 271      *   &lt; 1 byte &gt; masterSecret algorithm length
 272      *   &lt; length in bytes &gt; masterSecret algorithm
 273      *   &lt; 2 bytes &gt; masterSecretKey length
 274      *   &lt; length in bytes&gt; masterSecretKey
 275      * &lt; 1 byte &gt; useExtendedMasterSecret
 276      * &lt; 1 byte &gt; identificationProtocol length
 277      * &lt; length in bytes &gt; identificationProtocol
 278      * &lt; 1 byte &gt; serverNameIndication length
 279      * &lt; length in bytes &gt; serverNameIndication
 280      * &lt; 1 byte &gt; Number of requestedServerNames entries
 281      *   &lt; 1 byte &gt; ServerName length
 282      *   &lt; length in bytes &gt; ServerName
 283      * &lt; 4 bytes &gt; creationTime
 284      * &lt; 2 byte &gt; status response length
 285      *   &lt; 2 byte &gt; status response entry length
 286      *   &lt; length in byte &gt; status response entry
 287      * &lt; 1 byte &gt; Length of peer host
 288      *   &lt; length in bytes &gt; peer host
 289      * &lt; 2 bytes&gt; peer port
 290      * &lt; 1 byte &gt; Number of peerCerts entries
 291      *   &lt; 4 byte &gt; peerCert length
 292      *   &lt; length in bytes &gt; peerCert
 293      * &lt; 1 byte &gt; localCerts type (Cert, PSK, Anonymous)
 294      *   Certificate
 295      *     &lt; 1 byte &gt; Number of Certificate entries
 296      *       &lt; 4 byte&gt; Certificate length
 297      *       &lt; length in bytes&gt; Certificate
 298      *   PSK
 299      *     &lt; 1 byte &gt; Number of PSK entries
 300      *       &lt; 1 bytes &gt; PSK algorithm length
 301      *       &lt; length in bytes &gt; PSK algorithm string
 302      *       &lt; 4 bytes &gt; PSK key length
 303      *       &lt; length in bytes&gt; PSK key
 304      *       &lt; 4 bytes &gt; PSK identity length
 305      *       &lt; length in bytes&gt; PSK identity
 306      *   Anonymous
 307      *     &lt; 1 byte &gt;
 308      * &lt; 4 bytes &gt; maximumPacketSize
 309      * &lt; 4 bytes &gt; negotiatedMaxFragSize
 310      */
 311 
 312     SSLSessionImpl(HandshakeContext hc, ByteBuffer buf) throws IOException {
 313         int i = 0;
 314         byte[] b;
 315 
 316         boundValues = new ConcurrentHashMap&lt;&gt;();
 317         this.protocolVersion =
 318                 ProtocolVersion.valueOf(Short.toUnsignedInt(buf.getShort()));
 319 
 320         // The CH session id may reset this if it&#39;s provided
 321         this.sessionId = new SessionId(true,
 322                 hc.sslContext.getSecureRandom());
 323 
 324         this.cipherSuite =
 325                 CipherSuite.valueOf(Short.toUnsignedInt(buf.getShort()));
 326 
 327         // Local Supported signature algorithms
 328         ArrayList&lt;SignatureScheme&gt; list = new ArrayList&lt;&gt;();
 329         i = Byte.toUnsignedInt(buf.get());
 330         while (i-- &gt; 0) {
 331             list.add(SignatureScheme.valueOf(
 332                     Short.toUnsignedInt(buf.getShort())));
 333         }
 334         this.localSupportedSignAlgs = Collections.unmodifiableCollection(list);
 335 
 336         // Peer Supported signature algorithms
 337         i = Byte.toUnsignedInt(buf.get());
 338         list.clear();
 339         while (i-- &gt; 0) {
 340             list.add(SignatureScheme.valueOf(
 341                     Short.toUnsignedInt(buf.getShort())));
 342         }
 343         this.peerSupportedSignAlgs = Collections.unmodifiableCollection(list);
 344 
 345         // PSK
 346         i = Short.toUnsignedInt(buf.getShort());
 347         if (i &gt; 0) {
 348             b = new byte[i];
 349             // Get algorithm string
 350             buf.get(b, 0, i);
 351             // Encoded length
 352             i = Short.toUnsignedInt(buf.getShort());
 353             // Encoded SecretKey
 354             b = new byte[i];
 355             buf.get(b);
 356             this.preSharedKey = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);
 357         } else {
 358             this.preSharedKey = null;
 359         }
 360 
 361         // PSK identity
 362         i = buf.get();
 363         if (i &gt; 0) {
 364             b = new byte[i];
 365             buf.get(b);
 366             this.pskIdentity = b;
 367         } else {
 368             this.pskIdentity = null;
 369         }
 370 
 371         // Master secret length of secret key algorithm  (one byte)
 372         i = buf.get();
 373         if (i &gt; 0) {
 374             b = new byte[i];
 375             // Get algorithm string
 376             buf.get(b, 0, i);
 377             // Encoded length
 378             i = Short.toUnsignedInt(buf.getShort());
 379             // Encoded SecretKey
 380             b = new byte[i];
 381             buf.get(b);
 382             this.masterSecret = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);
 383         } else {
 384             this.masterSecret = null;
 385         }
 386         // Use extended master secret
 387         this.useExtendedMasterSecret = (buf.get() != 0);
 388 
 389         // Identification Protocol
 390         i = buf.get();
 391         if (i == 0) {
 392             identificationProtocol = null;
 393         } else {
 394             b = new byte[i];
 395             buf.get(b);
 396             identificationProtocol = new String(b);
 397         }
 398 
 399         // SNI
 400         i = buf.get();  // length
 401         if (i == 0) {
 402             serverNameIndication = null;
 403         } else {
 404             b = new byte[i];
 405             buf.get(b, 0, b.length);
 406             serverNameIndication = new SNIHostName(b);
 407         }
 408 
 409         // List of SNIServerName
 410         int len = Short.toUnsignedInt(buf.getShort());
 411         if (len == 0) {
 412             this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 413         } else {
 414             requestedServerNames = new ArrayList&lt;&gt;();
 415             while (len &gt; 0) {
 416                 int l = buf.get();
 417                 b = new byte[l];
 418                 buf.get(b, 0, l);
 419                 requestedServerNames.add(new SNIHostName(new String(b)));
 420                 len--;
 421             }
 422         }
 423 
 424         maximumPacketSize = buf.getInt();
 425         negotiatedMaxFragLen = buf.getInt();
 426 
 427         // Get creation time
 428         this.creationTime = buf.getLong();
 429 
 430         // Get Buffer sizes
 431 
 432         // Status Response
 433         len = Short.toUnsignedInt(buf.getShort());
 434         if (len == 0) {
 435             statusResponses = Collections.emptyList();
 436         } else {
 437             statusResponses = new ArrayList&lt;&gt;();
 438         }
 439         while (len-- &gt; 0) {
 440             b = new byte[Short.toUnsignedInt(buf.getShort())];
 441             buf.get(b);
 442             statusResponses.add(b);
 443         }
 444 
 445         // Get Peer host &amp; port
 446         i = Byte.toUnsignedInt(buf.get());
 447         if (i == 0) {
 448             this.host = new String();
 449         } else {
 450             b = new byte[i];
 451             buf.get(b, 0, i);
 452             this.host = new String(b);
 453         }
 454         this.port = Short.toUnsignedInt(buf.getShort());
 455 
 456         // Peer certs
 457         i = buf.get();
 458         if (i == 0) {
 459             this.peerCerts = null;
 460         } else {
 461             this.peerCerts = new X509Certificate[i];
 462             int j = 0;
 463             while (i &gt; j) {
 464                 b = new byte[buf.getInt()];
 465                 buf.get(b);
 466                 try {
 467                     this.peerCerts[j] = new X509CertImpl(b);
 468                 } catch (Exception e) {
 469                     throw new IOException(e);
 470                 }
 471                 j++;
 472             }
 473         }
 474 
 475         // Get local certs of PSK
 476         switch (buf.get()) {
 477             case 0:
 478                 break;
 479             case 1:
 480                 // number of certs
 481                 len = buf.get();
 482                 this.localCerts = new X509Certificate[len];
 483                 i = 0;
 484                 while (len &gt; i) {
 485                     b = new byte[buf.getInt()];
 486                     buf.get(b);
 487                     try {
 488                         this.localCerts[i] = new X509CertImpl(b);
 489                     } catch (Exception e) {
 490                         throw new IOException(e);
 491                     }
 492                     i++;
 493                 }
 494                 break;
 495             case 2:
 496                 // pre-shared key
 497                 // Length of pre-shared key algorithm  (one byte)
 498                 i = buf.get();
 499                 b = new byte[i];
 500                 buf.get(b, 0 , i);
 501                 String alg = new String(b);
 502                 // Get length of encoding
 503                 i = Short.toUnsignedInt(buf.getShort());
 504                 // Get encoding
 505                 b = new byte[i];
 506                 buf.get(b);
 507                 this.preSharedKey = new SecretKeySpec(b, alg);
 508                 // Get identity len
 509                 this.pskIdentity = new byte[buf.get()];
 510                 buf.get(pskIdentity);
 511                 break;
 512             default:
 513                 throw new SSLException(&quot;Failed local certs of session.&quot;);
 514         }
 515 
 516         context = (SSLSessionContextImpl)
 517                 hc.sslContext.engineGetServerSessionContext();
 518         this.lastUsedTime = System.currentTimeMillis();
 519     }
 520 
 521     // Some situations we cannot provide a stateless ticket, but after it
 522     // has been negotiated
 523     boolean isStatelessable(HandshakeContext hc) {
 524         if (!hc.statelessResumption) {
 525             return false;
 526         }
 527 
 528         // If there is no getMasterSecret with TLS1.2 or under, do not resume.
 529         if (!protocolVersion.useTLS13PlusSpec() &amp;&amp;
 530                 getMasterSecret().getEncoded() == null) {
 531             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 532                 SSLLogger.finest(&quot;No MasterSecret, cannot make stateless&quot; +
 533                         &quot; ticket&quot;);
 534             }
 535             return false;
 536         }
 537         if (boundValues != null &amp;&amp; boundValues.size() &gt; 0) {
 538             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 539                 SSLLogger.finest(&quot;There are boundValues, cannot make&quot; +
 540                         &quot; stateless ticket&quot;);
 541             }
 542             return false;
 543         }
 544         return true;
 545     }
 546 
 547     /**
 548      * Write out a SSLSessionImpl in a byte array for a stateless session ticket
 549      */
 550     byte[] write() throws Exception {
 551         byte[] b;
 552         HandshakeOutStream hos = new HandshakeOutStream(null);
 553 
 554         hos.putInt16(protocolVersion.id);
 555         hos.putInt16(cipherSuite.id);
 556 
 557         // Local Supported signature algorithms
 558         hos.putInt8(localSupportedSignAlgs.size());
 559         for (SignatureScheme s : localSupportedSignAlgs) {
 560             hos.putInt16(s.id);
 561         }
 562 
 563         // Peer Supported signature algorithms
 564         hos.putInt8(peerSupportedSignAlgs.size());
 565         for (SignatureScheme s : peerSupportedSignAlgs) {
 566             hos.putInt16(s.id);
 567         }
 568 
 569         // PSK
 570         if (preSharedKey == null ||
 571                 preSharedKey.getAlgorithm() == null) {
 572             hos.putInt16(0);
 573         } else {
 574             hos.putInt16(preSharedKey.getAlgorithm().length());
 575             if (preSharedKey.getAlgorithm().length() != 0) {
 576                 hos.write(preSharedKey.getAlgorithm().getBytes());
 577             }
 578             b = preSharedKey.getEncoded();
 579             hos.putInt16(b.length);
 580             hos.write(b, 0, b.length);
 581         }
 582 
 583         // PSK Identity
 584         if (pskIdentity == null) {
 585             hos.putInt8(0);
 586         } else {
 587             hos.putInt8(pskIdentity.length);
 588             hos.write(pskIdentity, 0, pskIdentity.length);
 589         }
 590 
 591         // Master Secret
 592         if (getMasterSecret() == null ||
 593                 getMasterSecret().getAlgorithm() == null) {
 594             hos.putInt8(0);
 595         } else {
 596             hos.putInt8(getMasterSecret().getAlgorithm().length());
 597             if (getMasterSecret().getAlgorithm().length() != 0) {
 598                 hos.write(getMasterSecret().getAlgorithm().getBytes());
 599             }
 600             b = getMasterSecret().getEncoded();
 601             hos.putInt16(b.length);
 602             hos.write(b, 0, b.length);
 603         }
 604 
 605         hos.putInt8(useExtendedMasterSecret ? 1 : 0);
 606 
 607         // Identification Protocol
 608         if (identificationProtocol == null) {
 609             hos.putInt8(0);
 610         } else {
 611             hos.putInt8(identificationProtocol.length());
 612             hos.write(identificationProtocol.getBytes(), 0,
 613                     identificationProtocol.length());
 614         }
 615 
 616         // SNI
 617         if (serverNameIndication == null) {
 618             hos.putInt8(0);
 619         } else {
 620             b = serverNameIndication.getEncoded();
 621             hos.putInt8(b.length);
 622             hos.write(b, 0, b.length);
 623         }
 624 
 625         // List of SNIServerName
 626         hos.putInt16(requestedServerNames.size());
 627         if (requestedServerNames.size() &gt; 0) {
 628             for (SNIServerName sn : requestedServerNames) {
 629                 b = sn.getEncoded();
 630                 hos.putInt8(b.length);
 631                 hos.write(b, 0, b.length);
 632             }
 633         }
 634 
 635         // Buffer sizes
 636         hos.putInt32(maximumPacketSize);
 637         hos.putInt32(negotiatedMaxFragLen);
 638 
 639         // creation time
 640         ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
 641         hos.writeBytes(buffer.putLong(creationTime).array());
 642 
 643         // Status Responses
 644         List&lt;byte[]&gt; list = getStatusResponses();
 645         int l = list.size();
 646         hos.putInt16(l);
 647         for (byte[] e : list) {
 648             hos.putInt16(e.length);
 649             hos.write(e);
 650         }
 651 
 652         // peer Host &amp; Port
 653         if (host == null || host.length() == 0) {
 654             hos.putInt8(0);
 655         } else {
 656             hos.putInt8(host.length());
 657             hos.writeBytes(host.getBytes());
 658         }
 659         hos.putInt16(port);
 660 
 661         // Peer cert
 662         if (peerCerts == null || peerCerts.length == 0) {
 663             hos.putInt8(0);
 664         } else {
 665             hos.putInt8(peerCerts.length);
 666             for (X509Certificate c : peerCerts) {
 667                 b = c.getEncoded();
 668                 hos.putInt32(b.length);
 669                 hos.writeBytes(b);
 670             }
 671         }
 672 
 673         // Client identity
 674         if (localCerts != null &amp;&amp; localCerts.length &gt; 0) {
 675             // certificate based
 676             hos.putInt8(1);
 677             hos.putInt8(localCerts.length);
 678             for (X509Certificate c : localCerts) {
 679                 b = c.getEncoded();
 680                 hos.putInt32(b.length);
 681                 hos.writeBytes(b);
 682             }
 683         } else if (preSharedKey != null) {
 684             // pre-shared key
 685             hos.putInt8(2);
 686             hos.putInt8(preSharedKey.getAlgorithm().length());
 687             hos.write(preSharedKey.getAlgorithm().getBytes());
 688             b = preSharedKey.getEncoded();
 689             hos.putInt32(b.length);
 690             hos.writeBytes(b);
 691             hos.putInt32(pskIdentity.length);
 692             hos.writeBytes(pskIdentity);
 693         } else {
 694             // anonymous
 695             hos.putInt8(0);
 696         }
 697 
 698         return hos.toByteArray();
 699     }
 700 
 701     void setMasterSecret(SecretKey secret) {
 702         masterSecret = secret;
 703     }
 704 
 705     void setResumptionMasterSecret(SecretKey secret) {
 706         resumptionMasterSecret = secret;
 707     }
 708 
 709     void setPreSharedKey(SecretKey key) {
 710         preSharedKey = key;
 711     }
 712 
 713     void addChild(SSLSessionImpl session) {
 714         childSessions.add(session);
 715     }
 716 
 717     void setTicketAgeAdd(int ticketAgeAdd) {
 718         this.ticketAgeAdd = ticketAgeAdd;
 719     }
 720 
 721     void setPskIdentity(byte[] pskIdentity) {
 722         this.pskIdentity = pskIdentity;
 723     }
 724 
 725     BigInteger incrTicketNonceCounter() {
 726         BigInteger result = ticketNonceCounter;
 727         ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);
 728         return result;
 729     }
 730 
 731     boolean isPSKable() {
 732         return (ticketNonceCounter.compareTo(BigInteger.ZERO) &gt; 0);
 733     }
 734 
 735     /**
 736      * Returns the master secret ... treat with extreme caution!
 737      */
 738     SecretKey getMasterSecret() {
 739         return masterSecret;
 740     }
 741 
 742     SecretKey getResumptionMasterSecret() {
 743         return resumptionMasterSecret;
 744     }
 745 
 746     SecretKey getPreSharedKey() {
 747         sessionLock.lock();
 748         try {
 749             return preSharedKey;
 750         } finally {
 751             sessionLock.unlock();
 752         }
 753     }
 754 
 755     SecretKey consumePreSharedKey() {
 756         sessionLock.lock();
 757         try {
 758             return preSharedKey;
 759         } finally {
 760             preSharedKey = null;
 761             sessionLock.unlock();
 762         }
 763     }
 764 
 765     int getTicketAgeAdd() {
 766         return ticketAgeAdd;
 767     }
 768 
 769     String getIdentificationProtocol() {
 770         return this.identificationProtocol;
 771     }
 772 
 773     /* PSK identities created from new_session_ticket messages should only
 774      * be used once. This method will return the identity and then clear it
 775      * so it cannot be used again.
 776      */
 777     byte[] consumePskIdentity() {
 778         sessionLock.lock();
 779         try {
 780             return pskIdentity;
 781         } finally {
 782             pskIdentity = null;
 783             sessionLock.unlock();
 784         }
 785     }
 786 
 787     byte[] getPskIdentity() {
 788         return pskIdentity;
 789     }
 790 
 791     void setPeerCertificates(X509Certificate[] peer) {
 792         if (peerCerts == null) {
 793             peerCerts = peer;
 794         }
 795     }
 796 
 797     void setLocalCertificates(X509Certificate[] local) {
 798         localCerts = local;
 799     }
 800 
 801     void setLocalPrivateKey(PrivateKey privateKey) {
 802         localPrivateKey = privateKey;
 803     }
 804 
 805     void setPeerSupportedSignatureAlgorithms(
 806             Collection&lt;SignatureScheme&gt; signatureSchemes) {
 807         peerSupportedSignAlgs = signatureSchemes;
 808     }
 809 
 810     // TLS 1.2 only
 811     //
 812     // Per RFC 5246, If the client supports only the default hash
 813     // and signature algorithms, it MAY omit the
 814     // signature_algorithms extension.  If the client does not
 815     // support the default algorithms, or supports other hash
 816     // and signature algorithms (and it is willing to use them
 817     // for verifying messages sent by the server, i.e., server
 818     // certificates and server key exchange), it MUST send the
 819     // signature_algorithms extension, listing the algorithms it
 820     // is willing to accept.
 821     private static final ArrayList&lt;SignatureScheme&gt; defaultPeerSupportedSignAlgs =
 822             new ArrayList&lt;&gt;(Arrays.asList(SignatureScheme.RSA_PKCS1_SHA1,
 823                     SignatureScheme.DSA_SHA1,
 824                     SignatureScheme.ECDSA_SHA1));
 825 
 826     void setUseDefaultPeerSignAlgs() {
 827         useDefaultPeerSignAlgs = true;
 828         peerSupportedSignAlgs = defaultPeerSupportedSignAlgs;
 829     }
 830 
 831     // Returns the connection session.
 832     SSLSessionImpl finish() {
 833         if (useDefaultPeerSignAlgs) {
 834             peerSupportedSignAlgs = Collections.emptySet();
 835         }
 836 
 837         return this;
 838     }
 839 
 840     /**
 841      * Provide status response data obtained during the SSL handshake.
 842      *
 843      * @param responses a {@link List} of responses in binary form.
 844      */
 845     void setStatusResponses(List&lt;byte[]&gt; responses) {
 846         if (responses != null &amp;&amp; !responses.isEmpty()) {
 847             statusResponses = responses;
 848         } else {
 849             statusResponses = Collections.emptyList();
 850         }
 851     }
 852 
 853     /**
 854      * Returns true iff this session may be resumed ... sessions are
 855      * usually resumable.  Security policies may suggest otherwise,
 856      * for example sessions that haven&#39;t been used for a while (say,
 857      * a working day) won&#39;t be resumable, and sessions might have a
 858      * maximum lifetime in any case.
 859      */
 860     boolean isRejoinable() {
 861         // TLS 1.3 can have no session id
 862         if (protocolVersion.useTLS13PlusSpec()) {
 863             return (!invalidated &amp;&amp; isLocalAuthenticationValid());
 864         }
 865         return sessionId != null &amp;&amp; sessionId.length() != 0 &amp;&amp;
 866                 !invalidated &amp;&amp; isLocalAuthenticationValid();
 867     }
 868 
 869     @Override
 870     public boolean isValid() {
 871         sessionLock.lock();
 872         try {
 873             return isRejoinable();
 874         } finally {
 875             sessionLock.unlock();
 876         }
 877     }
 878 
 879     /**
 880      * Check if the authentication used when establishing this session
 881      * is still valid. Returns true if no authentication was used
 882      */
 883     private boolean isLocalAuthenticationValid() {
 884         if (localPrivateKey != null) {
 885             try {
 886                 // if the private key is no longer valid, getAlgorithm()
 887                 // should throw an exception
 888                 // (e.g. Smartcard has been removed from the reader)
 889                 localPrivateKey.getAlgorithm();
 890             } catch (Exception e) {
 891                 invalidate();
 892                 return false;
 893             }
 894         }
 895 
 896         return true;
 897     }
 898 
 899     /**
 900      * Returns the ID for this session.  The ID is fixed for the
 901      * duration of the session; neither it, nor its value, changes.
 902      */
 903     @Override
 904     public byte[] getId() {
 905         return sessionId.getId();
 906     }
 907 
 908     /**
 909      * For server sessions, this returns the set of sessions which
 910      * are currently valid in this process.  For client sessions,
 911      * this returns null.
 912      */
 913     @Override
 914     public SSLSessionContext getSessionContext() {
 915         /*
 916          * An interim security policy until we can do something
 917          * more specific in 1.2. Only allow trusted code (code which
 918          * can set system properties) to get an
 919          * SSLSessionContext. This is to limit the ability of code to
 920          * look up specific sessions or enumerate over them. Otherwise,
 921          * code can only get session objects from successful SSL
 922          * connections which implies that they must have had permission
 923          * to make the network connection in the first place.
 924          */
 925         SecurityManager sm;
 926         if ((sm = System.getSecurityManager()) != null) {
 927             sm.checkPermission(new SSLPermission(&quot;getSSLSessionContext&quot;));
 928         }
 929 
 930         return context;
 931     }
 932 
 933 
 934     SessionId getSessionId() {
 935         return sessionId;
 936     }
 937 
 938 
 939     /**
 940      * Returns the cipher spec in use on this session
 941      */
 942     CipherSuite getSuite() {
 943         return cipherSuite;
 944     }
 945 
 946     /**
 947      * Resets the cipher spec in use on this session
 948      */
 949     void setSuite(CipherSuite suite) {
 950        cipherSuite = suite;
 951 
 952         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 953              SSLLogger.finest(&quot;Negotiating session:  &quot; + this);
 954        }
 955     }
 956 
 957     /**
 958      * Return true if the session is currently re-established with a
 959      * session-resumption abbreviated initial handshake.
 960      */
 961     boolean isSessionResumption() {
 962         return isSessionResumption;
 963     }
 964 
 965     /**
 966      * Resets whether the session is re-established with a session-resumption
 967      * abbreviated initial handshake.
 968      */
 969     void setAsSessionResumption(boolean flag) {
 970         isSessionResumption = flag;
 971     }
 972 
 973     /**
 974      * Returns the name of the cipher suite in use on this session
 975      */
 976     @Override
 977     public String getCipherSuite() {
 978         return getSuite().name;
 979     }
 980 
 981     ProtocolVersion getProtocolVersion() {
 982         return protocolVersion;
 983     }
 984 
 985     /**
 986      * Returns the standard name of the protocol in use on this session
 987      */
 988     @Override
 989     public String getProtocol() {
 990         return getProtocolVersion().name;
 991     }
 992 
 993     /**
 994      * Returns the hashcode for this session
 995      */
 996     @Override
 997     public int hashCode() {
 998         return sessionId.hashCode();
 999     }
1000 
1001     /**
1002      * Returns true if sessions have same ids, false otherwise.
1003      */
1004     @Override
1005     public boolean equals(Object obj) {
1006 
1007         if (obj == this) {
1008             return true;
1009         }
1010 
1011         if (obj instanceof SSLSessionImpl) {
1012             SSLSessionImpl sess = (SSLSessionImpl) obj;
1013             return (sessionId != null) &amp;&amp; (sessionId.equals(
1014                         sess.getSessionId()));
1015         }
1016 
1017         return false;
1018     }
1019 
1020 
1021     /**
1022      * Return the cert chain presented by the peer in the
1023      * java.security.cert format.
1024      * Note: This method can be used only when using certificate-based
1025      * cipher suites; using it with non-certificate-based cipher suites
1026      * will throw an SSLPeerUnverifiedException.
1027      *
1028      * @return array of peer X.509 certs, with the peer&#39;s own cert
1029      *  first in the chain, and with the &quot;root&quot; CA last.
1030      */
1031     @Override
1032     public java.security.cert.Certificate[] getPeerCertificates()
1033             throws SSLPeerUnverifiedException {
1034         //
1035         // clone to preserve integrity of session ... caller can&#39;t
1036         // change record of peer identity even by accident, much
1037         // less do it intentionally.
1038         //
1039         if (peerCerts == null) {
1040             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1041         }
1042         // Certs are immutable objects, therefore we don&#39;t clone them.
1043         // But do need to clone the array, so that nothing is inserted
1044         // into peerCerts.
1045         return (java.security.cert.Certificate[])peerCerts.clone();
1046     }
1047 
1048     /**
1049      * Return the cert chain presented to the peer in the
1050      * java.security.cert format.
1051      * Note: This method is useful only when using certificate-based
1052      * cipher suites.
1053      *
1054      * @return array of peer X.509 certs, with the peer&#39;s own cert
1055      *  first in the chain, and with the &quot;root&quot; CA last.
1056      */
1057     @Override
1058     public java.security.cert.Certificate[] getLocalCertificates() {
1059         //
1060         // clone to preserve integrity of session ... caller can&#39;t
1061         // change record of peer identity even by accident, much
1062         // less do it intentionally.
1063         return (localCerts == null ? null :
1064             (java.security.cert.Certificate[])localCerts.clone());
1065     }
1066 
1067     /**
1068      * Return the cert chain presented by the peer.
1069      * Note: This method can be used only when using certificate-based
1070      * cipher suites; using it with non-certificate-based cipher suites
1071      * will throw an SSLPeerUnverifiedException.
1072      *
1073      * @return array of peer X.509 certs, with the peer&#39;s own cert
1074      *  first in the chain, and with the &quot;root&quot; CA last.
1075      */
1076     public X509Certificate[] getCertificateChain()
1077             throws SSLPeerUnverifiedException {
1078         /*
1079          * clone to preserve integrity of session ... caller can&#39;t
1080          * change record of peer identity even by accident, much
1081          * less do it intentionally.
1082          */
1083         if (peerCerts != null) {
1084             return peerCerts.clone();
1085         } else {
1086             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1087         }
1088     }
1089 
1090     /**
1091      * Return a List of status responses presented by the peer.
1092      * Note: This method can be used only when using certificate-based
1093      * server authentication; otherwise an empty {@code List} will be returned.
1094      *
1095      * @return an unmodifiable {@code List} of byte arrays, each consisting
1096      * of a DER-encoded OCSP response (see RFC 6960).  If no responses have
1097      * been presented by the server or non-certificate based server
1098      * authentication is used then an empty {@code List} is returned.
1099      */
1100     @Override
1101     public List&lt;byte[]&gt; getStatusResponses() {
1102         if (statusResponses == null || statusResponses.isEmpty()) {
1103             return Collections.emptyList();
1104         } else {
1105             // Clone both the list and the contents
1106             List&lt;byte[]&gt; responses = new ArrayList&lt;&gt;(statusResponses.size());
1107             for (byte[] respBytes : statusResponses) {
1108                 responses.add(respBytes.clone());
1109             }
1110             return Collections.unmodifiableList(responses);
1111         }
1112     }
1113 
1114     /**
1115      * Returns the identity of the peer which was established as part of
1116      * defining the session.
1117      *
1118      * @return the peer&#39;s principal. Returns an X500Principal of the
1119      * end-entity certificate for X509-based cipher suites.
1120      *
1121      * @throws SSLPeerUnverifiedException if the peer&#39;s identity has not
1122      *          been verified
1123      */
1124     @Override
1125     public Principal getPeerPrincipal()
1126                 throws SSLPeerUnverifiedException
1127     {
1128         if (peerCerts == null) {
1129             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1130         }
1131         return peerCerts[0].getSubjectX500Principal();
1132     }
1133 
1134     /**
1135      * Returns the principal that was sent to the peer during handshaking.
1136      *
1137      * @return the principal sent to the peer. Returns an X500Principal
1138      * of the end-entity certificate for X509-based cipher suites.
1139      * If no principal was sent, then null is returned.
1140      */
1141     @Override
1142     public Principal getLocalPrincipal() {
1143         return ((localCerts == null || localCerts.length == 0) ? null :
1144                 localCerts[0].getSubjectX500Principal());
1145     }
1146 
1147     /*
1148      * Return the time the ticket for this session was created.
1149      */
1150     public long getTicketCreationTime() {
1151         return ticketCreationTime;
1152     }
1153 
1154     /**
1155      * Returns the time this session was created.
1156      */
1157     @Override
1158     public long getCreationTime() {
1159         return creationTime;
1160     }
1161 
1162     /**
1163      * Returns the last time this session was used to initialize
1164      * a connection.
1165      */
1166     @Override
1167     public long getLastAccessedTime() {
1168         return (lastUsedTime != 0) ? lastUsedTime : creationTime;
1169     }
1170 
1171     void setLastAccessedTime(long time) {
1172         lastUsedTime = time;
1173     }
1174 
1175 
1176     /**
1177      * Returns the network address of the session&#39;s peer.  This
1178      * implementation does not insist that connections between
1179      * different ports on the same host must necessarily belong
1180      * to different sessions, though that is of course allowed.
1181      */
1182     public InetAddress getPeerAddress() {
1183         try {
1184             return InetAddress.getByName(host);
1185         } catch (java.net.UnknownHostException e) {
1186             return null;
1187         }
1188     }
1189 
1190     @Override
1191     public String getPeerHost() {
1192         return host;
1193     }
1194 
1195     /**
1196      * Need to provide the port info for caching sessions based on
1197      * host and port. Accessed by SSLSessionContextImpl
1198      */
1199     @Override
1200     public int getPeerPort() {
1201         return port;
1202     }
1203 
1204     void setContext(SSLSessionContextImpl ctx) {
1205         if (context == null) {
1206             context = ctx;
1207         }
1208     }
1209 
1210     /**
1211      * Invalidate a session.  Active connections may still exist, but
1212      * no connections will be able to rejoin this session.
1213      */
1214     @Override
1215     public void invalidate() {
1216         sessionLock.lock();
1217         try {
1218             if (context != null) {
1219                 context.remove(sessionId);
1220                 context = null;
1221             }
1222 
1223             if (invalidated) {
1224                 return;
1225             }
1226             invalidated = true;
1227             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
1228                  SSLLogger.finest(&quot;Invalidated session:  &quot; + this);
1229             }
1230             for (SSLSessionImpl child : childSessions) {
1231                 child.invalidate();
1232             }
1233         } finally {
1234             sessionLock.unlock();
1235         }
1236     }
1237 
1238     /*
1239      * Table of application-specific session data indexed by an application
1240      * key and the calling security context. This is important since
1241      * sessions can be shared across different protection domains.
1242      */
1243     private final ConcurrentHashMap&lt;SecureKey, Object&gt; boundValues;
1244     boolean updateNST;
1245 
1246     /**
1247      * Assigns a session value.  Session change events are given if
1248      * appropriate, to any original value as well as the new value.
1249      */
1250     @Override
1251     public void putValue(String key, Object value) {
1252         if ((key == null) || (value == null)) {
1253             throw new IllegalArgumentException(&quot;arguments can not be null&quot;);
1254         }
1255 
1256         SecureKey secureKey = new SecureKey(key);
1257         Object oldValue = boundValues.put(secureKey, value);
1258 
1259         if (oldValue instanceof SSLSessionBindingListener) {
1260             SSLSessionBindingEvent e;
1261 
1262             e = new SSLSessionBindingEvent(this, key);
1263             ((SSLSessionBindingListener)oldValue).valueUnbound(e);
1264         }
1265         if (value instanceof SSLSessionBindingListener) {
1266             SSLSessionBindingEvent e;
1267 
1268             e = new SSLSessionBindingEvent(this, key);
1269             ((SSLSessionBindingListener)value).valueBound(e);
1270         }
1271         if (protocolVersion.useTLS13PlusSpec()) {
1272             updateNST = true;
1273         }
1274     }
1275 
1276     /**
1277      * Returns the specified session value.
1278      */
1279     @Override
1280     public Object getValue(String key) {
1281         if (key == null) {
1282             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
1283         }
1284 
1285         SecureKey secureKey = new SecureKey(key);
1286         return boundValues.get(secureKey);
1287     }
1288 
1289 
1290     /**
1291      * Removes the specified session value, delivering a session changed
1292      * event as appropriate.
1293      */
1294     @Override
1295     public void removeValue(String key) {
1296         if (key == null) {
1297             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
1298         }
1299 
1300         SecureKey secureKey = new SecureKey(key);
1301         Object value = boundValues.remove(secureKey);
1302 
1303         if (value instanceof SSLSessionBindingListener) {
1304             SSLSessionBindingEvent e;
1305 
1306             e = new SSLSessionBindingEvent(this, key);
1307             ((SSLSessionBindingListener)value).valueUnbound(e);
1308         }
1309         if (protocolVersion.useTLS13PlusSpec()) {
1310             updateNST = true;
1311         }
1312     }
1313 
1314 
1315     /**
1316      * Lists the names of the session values.
1317      */
1318     @Override
1319     public String[] getValueNames() {
1320         ArrayList&lt;Object&gt; v = new ArrayList&lt;&gt;();
1321         Object securityCtx = SecureKey.getCurrentSecurityContext();
1322         for (Enumeration&lt;SecureKey&gt; e = boundValues.keys();
1323                 e.hasMoreElements(); ) {
1324             SecureKey key = e.nextElement();
1325             if (securityCtx.equals(key.getSecurityContext())) {
1326                 v.add(key.getAppKey());
1327             }
1328         }
1329 
1330         return v.toArray(new String[0]);
1331     }
1332 
1333     /**
1334      * Use large packet sizes now or follow RFC 2246 packet sizes (2^14)
1335      * until changed.
1336      *
1337      * In the TLS specification (section 6.2.1, RFC2246), it is not
1338      * recommended that the plaintext has more than 2^14 bytes.
1339      * However, some TLS implementations violate the specification.
1340      * This is a workaround for interoperability with these stacks.
1341      *
1342      * Application could accept large fragments up to 2^15 bytes by
1343      * setting the system property jsse.SSLEngine.acceptLargeFragments
1344      * to &quot;true&quot;.
1345      */
1346     private boolean acceptLargeFragments =
1347             Utilities.getBooleanProperty(
1348                     &quot;jsse.SSLEngine.acceptLargeFragments&quot;, false);
1349 
1350     /**
1351      * Expand the buffer size of both SSL/TLS network packet and
1352      * application data.
1353      */
1354     protected void expandBufferSizes() {
1355         sessionLock.lock();
1356         try {
1357             acceptLargeFragments = true;
1358         } finally {
1359             sessionLock.unlock();
1360         }
1361     }
1362 
1363     /**
1364      * Gets the current size of the largest SSL/TLS packet that is expected
1365      * when using this session.
1366      */
1367     @Override
1368     public int getPacketBufferSize() {
1369         sessionLock.lock();
1370         try {
1371             // Use the bigger packet size calculated from maximumPacketSize
1372             // and negotiatedMaxFragLen.
1373             int packetSize = 0;
1374             if (negotiatedMaxFragLen &gt; 0) {
1375                 packetSize = cipherSuite.calculatePacketSize(
1376                         negotiatedMaxFragLen, protocolVersion,
1377                         protocolVersion.isDTLS);
1378             }
1379 
1380             if (maximumPacketSize &gt; 0) {
1381                 return (maximumPacketSize &gt; packetSize) ?
1382                         maximumPacketSize : packetSize;
1383             }
1384 
1385             if (packetSize != 0) {
1386                return packetSize;
1387             }
1388 
1389             if (protocolVersion.isDTLS) {
1390                 return DTLSRecord.maxRecordSize;
1391             } else {
1392                 return acceptLargeFragments ?
1393                         SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;
1394             }
1395         } finally {
1396             sessionLock.unlock();
1397         }
1398     }
1399 
1400     /**
1401      * Gets the current size of the largest application data that is
1402      * expected when using this session.
1403      */
1404     @Override
1405     public int getApplicationBufferSize() {
1406         sessionLock.lock();
1407         try {
1408             // Use the bigger fragment size calculated from maximumPacketSize
1409             // and negotiatedMaxFragLen.
1410             int fragmentSize = 0;
1411             if (maximumPacketSize &gt; 0) {
1412                 fragmentSize = cipherSuite.calculateFragSize(
1413                         maximumPacketSize, protocolVersion,
1414                         protocolVersion.isDTLS);
1415             }
1416 
1417             if (negotiatedMaxFragLen &gt; 0) {
1418                 return (negotiatedMaxFragLen &gt; fragmentSize) ?
1419                         negotiatedMaxFragLen : fragmentSize;
1420             }
1421 
1422             if (fragmentSize != 0) {
1423                 return fragmentSize;
1424             }
1425 
1426             if (protocolVersion.isDTLS) {
1427                 return Record.maxDataSize;
1428             } else {
1429                 int maxPacketSize = acceptLargeFragments ?
1430                             SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;
1431                 return (maxPacketSize - SSLRecord.headerSize);
1432             }
1433         } finally {
1434             sessionLock.unlock();
1435         }
1436     }
1437 
1438     /**
1439      * Sets the negotiated maximum fragment length, as specified by the
1440      * max_fragment_length ClientHello extension in RFC 6066.
1441      *
1442      * @param  negotiatedMaxFragLen
1443      *         the negotiated maximum fragment length, or {@code -1} if
1444      *         no such length has been negotiated.
1445      */
1446     void setNegotiatedMaxFragSize(
1447             int negotiatedMaxFragLen) {
1448         sessionLock.lock();
1449         try {
1450             this.negotiatedMaxFragLen = negotiatedMaxFragLen;
1451         } finally {
1452             sessionLock.unlock();
1453         }
1454     }
1455 
1456     /**
1457      * Get the negotiated maximum fragment length, as specified by the
1458      * max_fragment_length ClientHello extension in RFC 6066.
1459      *
1460      * @return the negotiated maximum fragment length, or {@code -1} if
1461      *         no such length has been negotiated.
1462      */
1463     int getNegotiatedMaxFragSize() {
1464         sessionLock.lock();
1465         try {
1466             return negotiatedMaxFragLen;
1467         } finally {
1468             sessionLock.unlock();
1469         }
1470     }
1471 
1472     void setMaximumPacketSize(int maximumPacketSize) {
1473         sessionLock.lock();
1474         try {
1475             this.maximumPacketSize = maximumPacketSize;
1476         } finally {
1477             sessionLock.unlock();
1478         }
1479     }
1480 
1481     int getMaximumPacketSize() {
1482         sessionLock.lock();
1483         try {
1484             return maximumPacketSize;
1485         } finally {
1486             sessionLock.unlock();
1487         }
1488     }
1489 
1490     /**
1491      * Gets an array of supported signature algorithm names that the local
1492      * side is willing to verify.
1493      */
1494     @Override
1495     public String[] getLocalSupportedSignatureAlgorithms() {
1496         return SignatureScheme.getAlgorithmNames(localSupportedSignAlgs);
1497     }
1498 
1499     /**
1500      * Gets an array of supported signature schemes that the local side is
1501      * willing to verify.
1502      */
1503     public Collection&lt;SignatureScheme&gt; getLocalSupportedSignatureSchemes() {
1504         return localSupportedSignAlgs;
1505     }
1506 
1507     /**
1508      * Gets an array of supported signature algorithms that the peer is
1509      * able to verify.
1510      */
1511     @Override
1512     public String[] getPeerSupportedSignatureAlgorithms() {
1513         return SignatureScheme.getAlgorithmNames(peerSupportedSignAlgs);
1514     }
1515 
1516     /**
1517      * Obtains a &lt;code&gt;List&lt;/code&gt; containing all {@link SNIServerName}s
1518      * of the requested Server Name Indication (SNI) extension.
1519      */
1520     @Override
1521     public List&lt;SNIServerName&gt; getRequestedServerNames() {
1522         return requestedServerNames;
1523     }
1524 
1525     /** Returns a string representation of this SSL session */
1526     @Override
1527     public String toString() {
1528         return &quot;Session(&quot; + creationTime + &quot;|&quot; + getCipherSuite() + &quot;)&quot;;
1529     }
1530 }
1531 
1532 /**
1533  * This &quot;struct&quot; class serves as a Hash Key that combines an
1534  * application-specific key and a security context.
1535  */
1536 class SecureKey {
1537     private static final Object     nullObject = new Object();
1538     private final Object            appKey;
1539     private final Object            securityCtx;
1540 
1541     static Object getCurrentSecurityContext() {
1542         SecurityManager sm = System.getSecurityManager();
1543         Object context = null;
1544 
1545         if (sm != null)
1546             context = sm.getSecurityContext();
1547         if (context == null)
1548             context = nullObject;
1549         return context;
1550     }
1551 
1552     SecureKey(Object key) {
1553         this.appKey = key;
1554         this.securityCtx = getCurrentSecurityContext();
1555     }
1556 
1557     Object getAppKey() {
1558         return appKey;
1559     }
1560 
1561     Object getSecurityContext() {
1562         return securityCtx;
1563     }
1564 
1565     @Override
1566     public int hashCode() {
1567         return appKey.hashCode() ^ securityCtx.hashCode();
1568     }
1569 
1570     @Override
1571     public boolean equals(Object o) {
1572         return o instanceof SecureKey &amp;&amp; ((SecureKey)o).appKey.equals(appKey)
1573                         &amp;&amp; ((SecureKey)o).securityCtx.equals(securityCtx);
1574     }
1575 }
    </pre>
  </body>
</html>
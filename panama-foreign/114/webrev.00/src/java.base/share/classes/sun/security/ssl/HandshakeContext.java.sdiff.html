<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/HandshakeContext.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Finished.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="KeyShareExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/HandshakeContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
147     List&lt;NamedGroup&gt;                        clientRequestedNamedGroups;
148 
149     // HelloRetryRequest
150     NamedGroup                              serverSelectedNamedGroup;
151 
152     // if server name indicator is negotiated
153     //
154     // May need a public API for the indication in the future.
155     List&lt;SNIServerName&gt;                     requestedServerNames;
156     SNIServerName                           negotiatedServerName;
157 
158     // OCSP Stapling info
159     boolean                                 staplingActive = false;
160 
161     protected HandshakeContext(SSLContextImpl sslContext,
162             TransportContext conContext) throws IOException {
163         this.sslContext = sslContext;
164         this.conContext = conContext;
165         this.sslConfig = (SSLConfiguration)conContext.sslConfig.clone();
166 


167         this.activeProtocols = getActiveProtocols(sslConfig.enabledProtocols,
<span class="line-modified">168                 sslConfig.enabledCipherSuites, sslConfig.algorithmConstraints);</span>
169         if (activeProtocols.isEmpty()) {
170             throw new SSLHandshakeException(
171                 &quot;No appropriate protocol (protocol is disabled or &quot; +
172                 &quot;cipher suites are inappropriate)&quot;);
173         }
174 
175         ProtocolVersion maximumVersion = ProtocolVersion.NONE;
176         for (ProtocolVersion pv : this.activeProtocols) {
177             if (maximumVersion == ProtocolVersion.NONE ||
178                     pv.compare(maximumVersion) &gt; 0) {
179                 maximumVersion = pv;
180             }
181         }
182         this.maximumActiveProtocol = maximumVersion;
183         this.activeCipherSuites = getActiveCipherSuites(this.activeProtocols,
<span class="line-modified">184                 sslConfig.enabledCipherSuites, sslConfig.algorithmConstraints);</span>
185         if (activeCipherSuites.isEmpty()) {
186             throw new SSLHandshakeException(&quot;No appropriate cipher suite&quot;);
187         }
<span class="line-removed">188         this.algorithmConstraints =</span>
<span class="line-removed">189                 new SSLAlgorithmConstraints(sslConfig.algorithmConstraints);</span>
190 
191         this.handshakeConsumers = new LinkedHashMap&lt;&gt;();
192         this.handshakeProducers = new HashMap&lt;&gt;();
193         this.handshakeHash = conContext.inputRecord.handshakeHash;
194         this.handshakeOutput = new HandshakeOutStream(conContext.outputRecord);
195 
196         this.handshakeFinished = false;
197         this.kickstartMessageDelivered = false;
198 
199         this.delegatedActions = new LinkedList&lt;&gt;();
200         this.handshakeExtensions = new HashMap&lt;&gt;();
201         this.handshakePossessions = new LinkedList&lt;&gt;();
202         this.handshakeCredentials = new LinkedList&lt;&gt;();
203         this.requestedServerNames = null;
204         this.negotiatedServerName = null;
205         this.negotiatedCipherSuite = conContext.cipherSuite;
206         initialize();
207     }
208 
209     /**
210      * Constructor for PostHandshakeContext
211      */
<span class="line-modified">212     HandshakeContext(TransportContext conContext) {</span>
213         this.sslContext = conContext.sslContext;
214         this.conContext = conContext;
215         this.sslConfig = conContext.sslConfig;
216 
217         this.negotiatedProtocol = conContext.protocolVersion;
218         this.negotiatedCipherSuite = conContext.cipherSuite;
219         this.handshakeOutput = new HandshakeOutStream(conContext.outputRecord);
220         this.delegatedActions = new LinkedList&lt;&gt;();
221 

222         this.handshakeProducers = null;
223         this.handshakeHash = null;
224         this.activeProtocols = null;
225         this.activeCipherSuites = null;
226         this.algorithmConstraints = null;
227         this.maximumActiveProtocol = null;
228         this.handshakeExtensions = Collections.emptyMap();  // Not in TLS13
229         this.handshakePossessions = null;
230         this.handshakeCredentials = null;
231     }
232 
233     // Initialize the non-final class variables.
234     private void initialize() {
235         ProtocolVersion inputHelloVersion;
236         ProtocolVersion outputHelloVersion;
237         if (conContext.isNegotiated) {
238             inputHelloVersion = conContext.protocolVersion;
239             outputHelloVersion = conContext.protocolVersion;
240         } else {
241             if (activeProtocols.contains(ProtocolVersion.SSL20Hello)) {
</pre>
</td>
<td>
<hr />
<pre>
147     List&lt;NamedGroup&gt;                        clientRequestedNamedGroups;
148 
149     // HelloRetryRequest
150     NamedGroup                              serverSelectedNamedGroup;
151 
152     // if server name indicator is negotiated
153     //
154     // May need a public API for the indication in the future.
155     List&lt;SNIServerName&gt;                     requestedServerNames;
156     SNIServerName                           negotiatedServerName;
157 
158     // OCSP Stapling info
159     boolean                                 staplingActive = false;
160 
161     protected HandshakeContext(SSLContextImpl sslContext,
162             TransportContext conContext) throws IOException {
163         this.sslContext = sslContext;
164         this.conContext = conContext;
165         this.sslConfig = (SSLConfiguration)conContext.sslConfig.clone();
166 
<span class="line-added">167         this.algorithmConstraints = new SSLAlgorithmConstraints(</span>
<span class="line-added">168                 sslConfig.userSpecifiedAlgorithmConstraints);</span>
169         this.activeProtocols = getActiveProtocols(sslConfig.enabledProtocols,
<span class="line-modified">170                 sslConfig.enabledCipherSuites, algorithmConstraints);</span>
171         if (activeProtocols.isEmpty()) {
172             throw new SSLHandshakeException(
173                 &quot;No appropriate protocol (protocol is disabled or &quot; +
174                 &quot;cipher suites are inappropriate)&quot;);
175         }
176 
177         ProtocolVersion maximumVersion = ProtocolVersion.NONE;
178         for (ProtocolVersion pv : this.activeProtocols) {
179             if (maximumVersion == ProtocolVersion.NONE ||
180                     pv.compare(maximumVersion) &gt; 0) {
181                 maximumVersion = pv;
182             }
183         }
184         this.maximumActiveProtocol = maximumVersion;
185         this.activeCipherSuites = getActiveCipherSuites(this.activeProtocols,
<span class="line-modified">186                 sslConfig.enabledCipherSuites, algorithmConstraints);</span>
187         if (activeCipherSuites.isEmpty()) {
188             throw new SSLHandshakeException(&quot;No appropriate cipher suite&quot;);
189         }


190 
191         this.handshakeConsumers = new LinkedHashMap&lt;&gt;();
192         this.handshakeProducers = new HashMap&lt;&gt;();
193         this.handshakeHash = conContext.inputRecord.handshakeHash;
194         this.handshakeOutput = new HandshakeOutStream(conContext.outputRecord);
195 
196         this.handshakeFinished = false;
197         this.kickstartMessageDelivered = false;
198 
199         this.delegatedActions = new LinkedList&lt;&gt;();
200         this.handshakeExtensions = new HashMap&lt;&gt;();
201         this.handshakePossessions = new LinkedList&lt;&gt;();
202         this.handshakeCredentials = new LinkedList&lt;&gt;();
203         this.requestedServerNames = null;
204         this.negotiatedServerName = null;
205         this.negotiatedCipherSuite = conContext.cipherSuite;
206         initialize();
207     }
208 
209     /**
210      * Constructor for PostHandshakeContext
211      */
<span class="line-modified">212     protected HandshakeContext(TransportContext conContext) {</span>
213         this.sslContext = conContext.sslContext;
214         this.conContext = conContext;
215         this.sslConfig = conContext.sslConfig;
216 
217         this.negotiatedProtocol = conContext.protocolVersion;
218         this.negotiatedCipherSuite = conContext.cipherSuite;
219         this.handshakeOutput = new HandshakeOutStream(conContext.outputRecord);
220         this.delegatedActions = new LinkedList&lt;&gt;();
221 
<span class="line-added">222         this.handshakeConsumers = new LinkedHashMap&lt;&gt;();</span>
223         this.handshakeProducers = null;
224         this.handshakeHash = null;
225         this.activeProtocols = null;
226         this.activeCipherSuites = null;
227         this.algorithmConstraints = null;
228         this.maximumActiveProtocol = null;
229         this.handshakeExtensions = Collections.emptyMap();  // Not in TLS13
230         this.handshakePossessions = null;
231         this.handshakeCredentials = null;
232     }
233 
234     // Initialize the non-final class variables.
235     private void initialize() {
236         ProtocolVersion inputHelloVersion;
237         ProtocolVersion outputHelloVersion;
238         if (conContext.isNegotiated) {
239             inputHelloVersion = conContext.protocolVersion;
240             outputHelloVersion = conContext.protocolVersion;
241         } else {
242             if (activeProtocols.contains(ProtocolVersion.SSL20Hello)) {
</pre>
</td>
</tr>
</table>
<center><a href="Finished.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="KeyShareExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/SSLContextImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.FileInputStream;
  29 import java.net.Socket;
  30 import java.security.*;
  31 import java.security.cert.*;
  32 import java.util.*;
  33 import java.util.concurrent.locks.ReentrantLock;
  34 import javax.net.ssl.*;
  35 import sun.security.action.GetPropertyAction;
  36 import sun.security.provider.certpath.AlgorithmChecker;
  37 import sun.security.validator.Validator;
  38 
  39 /**
  40  * Implementation of an SSLContext.
  41  *
  42  * Implementation note: Instances of this class and the child classes are
  43  * immutable, except that the context initialization (SSLContext.init()) may
  44  * reset the key, trust managers and source of secure random.
  45  */
  46 
  47 public abstract class SSLContextImpl extends SSLContextSpi {
  48 
  49     private final EphemeralKeyManager ephemeralKeyManager;
  50     private final SSLSessionContextImpl clientCache;
  51     private final SSLSessionContextImpl serverCache;
  52 
  53     private boolean isInitialized;
  54 
  55     private X509ExtendedKeyManager keyManager;
  56     private X509TrustManager trustManager;
  57     private SecureRandom secureRandom;
  58 
  59     // DTLS cookie exchange manager
  60     private volatile HelloCookieManager.Builder helloCookieManagerBuilder;
  61 
  62     private final boolean clientEnableStapling = Utilities.getBooleanProperty(
  63             &quot;jdk.tls.client.enableStatusRequestExtension&quot;, true);
  64     private final boolean serverEnableStapling = Utilities.getBooleanProperty(
  65             &quot;jdk.tls.server.enableStatusRequestExtension&quot;, false);
  66     private static final Collection&lt;CipherSuite&gt; clientCustomizedCipherSuites =
  67             getCustomizedCipherSuites(&quot;jdk.tls.client.cipherSuites&quot;);
  68     private static final Collection&lt;CipherSuite&gt; serverCustomizedCipherSuites =
  69             getCustomizedCipherSuites(&quot;jdk.tls.server.cipherSuites&quot;);
  70 
  71     private volatile StatusResponseManager statusResponseManager;
  72 
  73     private final ReentrantLock contextLock = new ReentrantLock();
  74     final HashMap&lt;Integer,
  75             SessionTicketExtension.StatelessKey&gt; keyHashMap = new HashMap&lt;&gt;();
  76 
  77 
  78     SSLContextImpl() {
  79         ephemeralKeyManager = new EphemeralKeyManager();
  80         clientCache = new SSLSessionContextImpl(false);
  81         serverCache = new SSLSessionContextImpl(true);
  82     }
  83 
  84     @Override
  85     protected void engineInit(KeyManager[] km, TrustManager[] tm,
  86                                 SecureRandom sr) throws KeyManagementException {
  87         isInitialized = false;
  88         keyManager = chooseKeyManager(km);
  89 
  90         if (tm == null) {
  91             try {
  92                 TrustManagerFactory tmf = TrustManagerFactory.getInstance(
  93                         TrustManagerFactory.getDefaultAlgorithm());
  94                 tmf.init((KeyStore)null);
  95                 tm = tmf.getTrustManagers();
  96             } catch (Exception e) {
  97                 // eat
  98             }
  99         }
 100         trustManager = chooseTrustManager(tm);
 101 
 102         if (sr == null) {
 103             secureRandom = new SecureRandom();
 104         } else {
 105             secureRandom = sr;
 106         }
 107 
 108         /*
 109          * The initial delay of seeding the random number generator
 110          * could be long enough to cause the initial handshake on our
 111          * first connection to timeout and fail. Make sure it is
 112          * primed and ready by getting some initial output from it.
 113          */
 114         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 115             SSLLogger.finest(&quot;trigger seeding of SecureRandom&quot;);
 116         }
 117         secureRandom.nextInt();
 118         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 119             SSLLogger.finest(&quot;done seeding of SecureRandom&quot;);
 120         }
 121 
 122         isInitialized = true;
 123     }
 124 
 125     private X509TrustManager chooseTrustManager(TrustManager[] tm)
 126             throws KeyManagementException {
 127         // We only use the first instance of X509TrustManager passed to us.
 128         for (int i = 0; tm != null &amp;&amp; i &lt; tm.length; i++) {
 129             if (tm[i] instanceof X509TrustManager) {
 130                 if (tm[i] instanceof X509ExtendedTrustManager) {
 131                     return (X509TrustManager)tm[i];
 132                 } else {
 133                     return new AbstractTrustManagerWrapper(
 134                                         (X509TrustManager)tm[i]);
 135                 }
 136             }
 137         }
 138 
 139         // nothing found, return a dummy X509TrustManager.
 140         return DummyX509TrustManager.INSTANCE;
 141     }
 142 
 143     private X509ExtendedKeyManager chooseKeyManager(KeyManager[] kms)
 144             throws KeyManagementException {
 145         for (int i = 0; kms != null &amp;&amp; i &lt; kms.length; i++) {
 146             KeyManager km = kms[i];
 147             if (!(km instanceof X509KeyManager)) {
 148                 continue;
 149             }
 150 
 151             if (km instanceof X509ExtendedKeyManager) {
 152                 return (X509ExtendedKeyManager)km;
 153             }
 154 
 155             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 156                 SSLLogger.warning(
 157                     &quot;X509KeyManager passed to SSLContext.init():  need an &quot; +
 158                     &quot;X509ExtendedKeyManager for SSLEngine use&quot;);
 159             }
 160             return new AbstractKeyManagerWrapper((X509KeyManager)km);
 161         }
 162 
 163         // nothing found, return a dummy X509ExtendedKeyManager
 164         return DummyX509KeyManager.INSTANCE;
 165     }
 166 
 167     abstract SSLEngine createSSLEngineImpl();
 168     abstract SSLEngine createSSLEngineImpl(String host, int port);
 169 
 170     @Override
 171     protected SSLEngine engineCreateSSLEngine() {
 172         if (!isInitialized) {
 173             throw new IllegalStateException(&quot;SSLContext is not initialized&quot;);
 174         }
 175         return createSSLEngineImpl();
 176     }
 177 
 178     @Override
 179     protected SSLEngine engineCreateSSLEngine(String host, int port) {
 180         if (!isInitialized) {
 181             throw new IllegalStateException(&quot;SSLContext is not initialized&quot;);
 182         }
 183         return createSSLEngineImpl(host, port);
 184     }
 185 
 186     @Override
 187     protected SSLSocketFactory engineGetSocketFactory() {
 188         if (!isInitialized) {
 189             throw new IllegalStateException(&quot;SSLContext is not initialized&quot;);
 190         }
 191         if (isDTLS()) {
 192             throw new UnsupportedOperationException(
 193                     &quot;DTLS not supported with SSLSocket&quot;);
 194         }
 195        return new SSLSocketFactoryImpl(this);
 196     }
 197 
 198     @Override
 199     protected SSLServerSocketFactory engineGetServerSocketFactory() {
 200         if (!isInitialized) {
 201             throw new IllegalStateException(&quot;SSLContext is not initialized&quot;);
 202         }
 203         if (isDTLS()) {
 204             throw new UnsupportedOperationException(
 205                     &quot;DTLS not supported with SSLServerSocket&quot;);
 206         }
 207         return new SSLServerSocketFactoryImpl(this);
 208     }
 209 
 210     @Override
 211     protected SSLSessionContext engineGetClientSessionContext() {
 212         return clientCache;
 213     }
 214 
 215     @Override
 216     protected SSLSessionContext engineGetServerSessionContext() {
 217         return serverCache;
 218     }
 219 
 220     SecureRandom getSecureRandom() {
 221         return secureRandom;
 222     }
 223 
 224     X509ExtendedKeyManager getX509KeyManager() {
 225         return keyManager;
 226     }
 227 
 228     X509TrustManager getX509TrustManager() {
 229         return trustManager;
 230     }
 231 
 232     EphemeralKeyManager getEphemeralKeyManager() {
 233         return ephemeralKeyManager;
 234     }
 235 
 236     // Used for DTLS in server mode only.
 237     HelloCookieManager getHelloCookieManager(ProtocolVersion protocolVersion) {
 238         if (helloCookieManagerBuilder == null) {
 239             contextLock.lock();
 240             try {
 241                 if (helloCookieManagerBuilder == null) {
 242                     helloCookieManagerBuilder =
 243                             new HelloCookieManager.Builder(secureRandom);
 244                 }
 245             } finally {
 246                 contextLock.unlock();
 247             }
 248         }
 249 
 250         return helloCookieManagerBuilder.valueOf(protocolVersion);
 251     }
 252 
 253     StatusResponseManager getStatusResponseManager() {
 254         if (serverEnableStapling &amp;&amp; statusResponseManager == null) {
 255             contextLock.lock();
 256             try {
 257                 if (statusResponseManager == null) {
 258                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 259                         SSLLogger.finest(
 260                                 &quot;Initializing StatusResponseManager&quot;);
 261                     }
 262                     statusResponseManager = new StatusResponseManager();
 263                 }
 264             } finally {
 265                 contextLock.unlock();
 266             }
 267         }
 268 
 269         return statusResponseManager;
 270     }
 271 
 272     // Get supported protocols.
 273     abstract List&lt;ProtocolVersion&gt; getSupportedProtocolVersions();
 274 
 275     // Get default protocols for server mode.
 276     abstract List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions();
 277 
 278     // Get default protocols for client mode.
 279     abstract List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions();
 280 
 281     // Get supported CipherSuite list.
 282     abstract List&lt;CipherSuite&gt; getSupportedCipherSuites();
 283 
 284     // Get default CipherSuite list for server mode.
 285     abstract List&lt;CipherSuite&gt; getServerDefaultCipherSuites();
 286 
 287     // Get default CipherSuite list for client mode.
 288     abstract List&lt;CipherSuite&gt; getClientDefaultCipherSuites();
 289 
 290     // Is the context for DTLS protocols?
 291     abstract boolean isDTLS();
 292 
 293     // Get default protocols.
 294     List&lt;ProtocolVersion&gt; getDefaultProtocolVersions(boolean roleIsServer) {
 295         return roleIsServer ? getServerDefaultProtocolVersions()
 296                             : getClientDefaultProtocolVersions();
 297     }
 298 
 299     // Get default CipherSuite list.
 300     List&lt;CipherSuite&gt; getDefaultCipherSuites(boolean roleIsServer) {
 301         return roleIsServer ? getServerDefaultCipherSuites()
 302                             : getClientDefaultCipherSuites();
 303     }
 304 
 305     /**
 306      * Return whether a protocol list is the original default enabled
 307      * protocols.  See: SSLSocket/SSLEngine.setEnabledProtocols()
 308      */
 309     boolean isDefaultProtocolVesions(List&lt;ProtocolVersion&gt; protocols) {
 310         return (protocols == getServerDefaultProtocolVersions()) ||
 311                (protocols == getClientDefaultProtocolVersions());
 312     }
 313 
 314     /**
 315      * Return whether a protocol list is the original default enabled
 316      * protocols.  See: SSLSocket/SSLEngine.setEnabledProtocols()
 317      */
 318     boolean isDefaultCipherSuiteList(List&lt;CipherSuite&gt; cipherSuites) {
 319         return (cipherSuites == getServerDefaultCipherSuites()) ||
 320                (cipherSuites == getClientDefaultCipherSuites());
 321     }
 322 
 323     /**
 324      * Return whether client or server side stapling has been enabled
 325      * for this SSLContextImpl
 326      * @param isClient true if the caller is operating in a client side role,
 327      * false if acting as a server.
 328      * @return true if stapling has been enabled for the specified role, false
 329      * otherwise.
 330      */
 331     boolean isStaplingEnabled(boolean isClient) {
 332         return isClient ? clientEnableStapling : serverEnableStapling;
 333     }
 334 
 335     /*
 336      * Return the list of all available CipherSuites that are supported
 337      * using currently installed providers.
 338      */
 339     private static List&lt;CipherSuite&gt; getApplicableSupportedCipherSuites(
 340             List&lt;ProtocolVersion&gt; protocols) {
 341 
 342         return getApplicableCipherSuites(
 343                 CipherSuite.allowedCipherSuites(), protocols);
 344     }
 345 
 346     /*
 347      * Return the list of all available CipherSuites that are default enabled
 348      * in client or server side.
 349      */
 350     private static List&lt;CipherSuite&gt; getApplicableEnabledCipherSuites(
 351             List&lt;ProtocolVersion&gt; protocols, boolean isClient) {
 352 
 353         if (isClient) {
 354             if (!clientCustomizedCipherSuites.isEmpty()) {
 355                 return getApplicableCipherSuites(
 356                         clientCustomizedCipherSuites, protocols);
 357             }
 358         } else {
 359             if (!serverCustomizedCipherSuites.isEmpty()) {
 360                 return getApplicableCipherSuites(
 361                         serverCustomizedCipherSuites, protocols);
 362             }
 363         }
 364 
 365         return getApplicableCipherSuites(
 366                 CipherSuite.defaultCipherSuites(), protocols);
 367     }
 368 
 369     /*
 370      * Return the list of available CipherSuites which are applicable to
 371      * the specified protocols.
 372      */
 373     private static List&lt;CipherSuite&gt; getApplicableCipherSuites(
 374             Collection&lt;CipherSuite&gt; allowedCipherSuites,
 375             List&lt;ProtocolVersion&gt; protocols) {
 376         LinkedHashSet&lt;CipherSuite&gt; suites = new LinkedHashSet&lt;&gt;();
 377         if (protocols != null &amp;&amp; (!protocols.isEmpty())) {
 378             for (CipherSuite suite : allowedCipherSuites) {
 379                 if (!suite.isAvailable()) {
 380                     continue;
 381                 }
 382 
 383                 boolean isSupported = false;
 384                 for (ProtocolVersion protocol : protocols) {
 385                     if (!suite.supports(protocol) ||
 386                             !suite.bulkCipher.isAvailable()) {
 387                         continue;
 388                     }
 389 
 390                     if (SSLAlgorithmConstraints.DEFAULT.permits(
 391                             EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
 392                             suite.name, null)) {
 393                         suites.add(suite);
 394                         isSupported = true;
 395                     } else if (SSLLogger.isOn &amp;&amp;
 396                             SSLLogger.isOn(&quot;ssl,sslctx,verbose&quot;)) {
 397                         SSLLogger.fine(
 398                                 &quot;Ignore disabled cipher suite: &quot; + suite.name);
 399                     }
 400 
 401                     break;
 402                 }
 403 
 404                 if (!isSupported &amp;&amp; SSLLogger.isOn &amp;&amp;
 405                         SSLLogger.isOn(&quot;ssl,sslctx,verbose&quot;)) {
 406                     SSLLogger.finest(
 407                             &quot;Ignore unsupported cipher suite: &quot; + suite);
 408                 }
 409             }
 410         }
 411 
 412         return new ArrayList&lt;&gt;(suites);
 413     }
 414 
 415     /*
 416      * Get the customized cipher suites specified by the given system property.
 417      */
 418     private static Collection&lt;CipherSuite&gt; getCustomizedCipherSuites(
 419             String propertyName) {
 420 
 421         String property = GetPropertyAction.privilegedGetProperty(propertyName);
 422         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 423             SSLLogger.fine(
 424                     &quot;System property &quot; + propertyName + &quot; is set to &#39;&quot; +
 425                     property + &quot;&#39;&quot;);
 426         }
 427         if (property != null &amp;&amp; !property.isEmpty()) {
 428             // remove double quote marks from beginning/end of the property
 429             if (property.length() &gt; 1 &amp;&amp; property.charAt(0) == &#39;&quot;&#39; &amp;&amp;
 430                     property.charAt(property.length() - 1) == &#39;&quot;&#39;) {
 431                 property = property.substring(1, property.length() - 1);
 432             }
 433         }
 434 
 435         if (property != null &amp;&amp; !property.isEmpty()) {
 436             String[] cipherSuiteNames = property.split(&quot;,&quot;);
 437             Collection&lt;CipherSuite&gt; cipherSuites =
 438                         new ArrayList&lt;&gt;(cipherSuiteNames.length);
 439             for (int i = 0; i &lt; cipherSuiteNames.length; i++) {
 440                 cipherSuiteNames[i] = cipherSuiteNames[i].trim();
 441                 if (cipherSuiteNames[i].isEmpty()) {
 442                     continue;
 443                 }
 444 
 445                 CipherSuite suite;
 446                 try {
 447                     suite = CipherSuite.nameOf(cipherSuiteNames[i]);
 448                 } catch (IllegalArgumentException iae) {
 449                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 450                         SSLLogger.fine(
 451                                 &quot;Unknown or unsupported cipher suite name: &quot; +
 452                                 cipherSuiteNames[i]);
 453                     }
 454 
 455                     continue;
 456                 }
 457 
 458                 if (suite != null &amp;&amp; suite.isAvailable()) {
 459                     cipherSuites.add(suite);
 460                 } else {
 461                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 462                         SSLLogger.fine(
 463                                 &quot;The current installed providers do not &quot; +
 464                                 &quot;support cipher suite: &quot; + cipherSuiteNames[i]);
 465                     }
 466                 }
 467             }
 468 
 469             return cipherSuites;
 470         }
 471 
 472         return Collections.emptyList();
 473     }
 474 
 475 
 476     private static List&lt;ProtocolVersion&gt; getAvailableProtocols(
 477             ProtocolVersion[] protocolCandidates) {
 478 
 479         List&lt;ProtocolVersion&gt; availableProtocols =
 480                 Collections.&lt;ProtocolVersion&gt;emptyList();
 481         if (protocolCandidates != null &amp;&amp; protocolCandidates.length != 0) {
 482             availableProtocols = new ArrayList&lt;&gt;(protocolCandidates.length);
 483             for (ProtocolVersion p : protocolCandidates) {
 484                 if (p.isAvailable) {
 485                     availableProtocols.add(p);
 486                 }
 487             }
 488         }
 489 
 490         return availableProtocols;
 491     }
 492 
 493     /*
 494      * The SSLContext implementation for SSL/(D)TLS algorithm
 495      *
 496      * SSL/TLS protocols specify the forward compatibility and version
 497      * roll-back attack protections, however, a number of SSL/TLS server
 498      * vendors did not implement these aspects properly, and some current
 499      * SSL/TLS servers may refuse to talk to a TLS 1.1 or later client.
 500      *
 501      * Considering above interoperability issues, SunJSSE will not set
 502      * TLS 1.1 and TLS 1.2 as the enabled protocols for client by default.
 503      *
 504      * For SSL/TLS servers, there is no such interoperability issues as
 505      * SSL/TLS clients. In SunJSSE, TLS 1.1 or later version will be the
 506      * enabled protocols for server by default.
 507      *
 508      * We may change the behavior when popular TLS/SSL vendors support TLS
 509      * forward compatibility properly.
 510      *
 511      * SSLv2Hello is no longer necessary.  This interoperability option was
 512      * put in place in the late 90&#39;s when SSLv3/TLS1.0 were relatively new
 513      * and there were a fair number of SSLv2-only servers deployed.  Because
 514      * of the security issues in SSLv2, it is rarely (if ever) used, as
 515      * deployments should now be using SSLv3 and TLSv1.
 516      *
 517      * Considering the issues of SSLv2Hello, we should not enable SSLv2Hello
 518      * by default. Applications still can use it by enabling SSLv2Hello with
 519      * the series of setEnabledProtocols APIs.
 520      */
 521 
 522     /*
 523      * The base abstract SSLContext implementation for the Transport Layer
 524      * Security (TLS) protocols.
 525      *
 526      * This abstract class encapsulates supported and the default server
 527      * SSL/TLS parameters.
 528      *
 529      * @see SSLContext
 530      */
 531     private abstract static class AbstractTLSContext extends SSLContextImpl {
 532         private static final List&lt;ProtocolVersion&gt; supportedProtocols;
 533         private static final List&lt;ProtocolVersion&gt; serverDefaultProtocols;
 534 
 535         private static final List&lt;CipherSuite&gt; supportedCipherSuites;
 536         private static final List&lt;CipherSuite&gt; serverDefaultCipherSuites;
 537 
 538         static {
 539             supportedProtocols = Arrays.asList(
 540                 ProtocolVersion.TLS13,
 541                 ProtocolVersion.TLS12,
 542                 ProtocolVersion.TLS11,
 543                 ProtocolVersion.TLS10,
 544                 ProtocolVersion.SSL30,
 545                 ProtocolVersion.SSL20Hello
 546             );
 547 
 548             serverDefaultProtocols = getAvailableProtocols(
 549                     new ProtocolVersion[] {
 550                 ProtocolVersion.TLS13,
 551                 ProtocolVersion.TLS12,
 552                 ProtocolVersion.TLS11,
 553                 ProtocolVersion.TLS10
 554             });
 555 
 556             supportedCipherSuites = getApplicableSupportedCipherSuites(
 557                     supportedProtocols);
 558             serverDefaultCipherSuites = getApplicableEnabledCipherSuites(
 559                     serverDefaultProtocols, false);
 560         }
 561 
 562         @Override
 563         List&lt;ProtocolVersion&gt; getSupportedProtocolVersions() {
 564             return supportedProtocols;
 565         }
 566 
 567         @Override
 568         List&lt;CipherSuite&gt; getSupportedCipherSuites() {
 569             return supportedCipherSuites;
 570         }
 571 
 572         @Override
 573         List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions() {
 574             return serverDefaultProtocols;
 575         }
 576 
 577         @Override
 578         List&lt;CipherSuite&gt; getServerDefaultCipherSuites() {
 579             return serverDefaultCipherSuites;
 580         }
 581 
 582         @Override
 583         SSLEngine createSSLEngineImpl() {
 584             return new SSLEngineImpl(this);
 585         }
 586 
 587         @Override
 588         SSLEngine createSSLEngineImpl(String host, int port) {
 589             return new SSLEngineImpl(this, host, port);
 590         }
 591 
 592         @Override
 593         boolean isDTLS() {
 594             return false;
 595         }
 596     }
 597 
 598     /*
 599      * The SSLContext implementation for SSLv3 and TLS10 algorithm
 600      *
 601      * @see SSLContext
 602      */
 603     public static final class TLS10Context extends AbstractTLSContext {
 604         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 605         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 606 
 607         static {
 608             clientDefaultProtocols = getAvailableProtocols(
 609                     new ProtocolVersion[] {
 610                 ProtocolVersion.TLS10
 611             });
 612 
 613             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 614                     clientDefaultProtocols, true);
 615         }
 616 
 617         @Override
 618         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 619             return clientDefaultProtocols;
 620         }
 621 
 622         @Override
 623         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 624             return clientDefaultCipherSuites;
 625         }
 626     }
 627 
 628     /*
 629      * The SSLContext implementation for TLS11 algorithm
 630      *
 631      * @see SSLContext
 632      */
 633     public static final class TLS11Context extends AbstractTLSContext {
 634         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 635         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 636 
 637         static {
 638             clientDefaultProtocols = getAvailableProtocols(
 639                     new ProtocolVersion[] {
 640                 ProtocolVersion.TLS11,
 641                 ProtocolVersion.TLS10
 642             });
 643 
 644             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 645                     clientDefaultProtocols, true);
 646 
 647         }
 648 
 649         @Override
 650         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 651             return clientDefaultProtocols;
 652         }
 653 
 654         @Override
 655         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 656             return clientDefaultCipherSuites;
 657         }
 658     }
 659 
 660     /*
 661      * The SSLContext implementation for TLS12 algorithm
 662      *
 663      * @see SSLContext
 664      */
 665     public static final class TLS12Context extends AbstractTLSContext {
 666         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 667         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 668 
 669         static {
 670             clientDefaultProtocols = getAvailableProtocols(
 671                     new ProtocolVersion[] {
 672                 ProtocolVersion.TLS12,
 673                 ProtocolVersion.TLS11,
 674                 ProtocolVersion.TLS10
 675             });
 676 
 677             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 678                     clientDefaultProtocols, true);
 679         }
 680 
 681         @Override
 682         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 683             return clientDefaultProtocols;
 684         }
 685 
 686         @Override
 687         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 688             return clientDefaultCipherSuites;
 689         }
 690     }
 691 
 692     /*
 693      * The SSLContext implementation for TLS1.3 algorithm
 694      *
 695      * @see SSLContext
 696      */
 697     public static final class TLS13Context extends AbstractTLSContext {
 698         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 699         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 700 
 701         static {
 702             clientDefaultProtocols = getAvailableProtocols(
 703                     new ProtocolVersion[] {
 704                 ProtocolVersion.TLS13,
 705                 ProtocolVersion.TLS12,
 706                 ProtocolVersion.TLS11,
 707                 ProtocolVersion.TLS10
 708             });
 709 
 710             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 711                     clientDefaultProtocols, true);
 712         }
 713 
 714         @Override
 715         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 716             return clientDefaultProtocols;
 717         }
 718 
 719         @Override
 720         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 721             return clientDefaultCipherSuites;
 722         }
 723     }
 724 
 725     /*
 726      * The interface for the customized SSL/(D)TLS SSLContext.
 727      *
 728      * @see SSLContext
 729      */
 730     private static class CustomizedSSLProtocols {
 731         private static final String JDK_TLS_CLIENT_PROTOCOLS =
 732                 &quot;jdk.tls.client.protocols&quot;;
 733         private static final String JDK_TLS_SERVER_PROTOCOLS =
 734                 &quot;jdk.tls.server.protocols&quot;;
 735         static IllegalArgumentException reservedException = null;
 736         static final ArrayList&lt;ProtocolVersion&gt; customizedClientProtocols =
 737                 new ArrayList&lt;&gt;();
 738         static final ArrayList&lt;ProtocolVersion&gt; customizedServerProtocols =
 739                 new ArrayList&lt;&gt;();
 740 
 741         // Don&#39;t want a java.lang.LinkageError for illegal system property.
 742         //
 743         // Please don&#39;t throw exception in this static block.  Otherwise,
 744         // java.lang.LinkageError may be thrown during the instantiation of
 745         // the provider service. Instead, please handle the initialization
 746         // exception in the caller&#39;s constructor.
 747         static {
 748             populate(JDK_TLS_CLIENT_PROTOCOLS, customizedClientProtocols);
 749             populate(JDK_TLS_SERVER_PROTOCOLS, customizedServerProtocols);
 750         }
 751 
 752         private static void populate(String propname,
 753                 ArrayList&lt;ProtocolVersion&gt; arrayList) {
 754             String property = GetPropertyAction.privilegedGetProperty(propname);
 755             if (property == null) {
 756                 return;
 757             }
 758 
 759             if (!property.isEmpty()) {
 760                 // remove double quote marks from beginning/end of the property
 761                 if (property.length() &gt; 1 &amp;&amp; property.charAt(0) == &#39;&quot;&#39; &amp;&amp;
 762                         property.charAt(property.length() - 1) == &#39;&quot;&#39;) {
 763                     property = property.substring(1, property.length() - 1);
 764                 }
 765             }
 766 
 767             if (!property.isEmpty()) {
 768                 String[] protocols = property.split(&quot;,&quot;);
 769                 for (int i = 0; i &lt; protocols.length; i++) {
 770                     protocols[i] = protocols[i].trim();
 771                     // Is it a supported protocol name?
 772                     ProtocolVersion pv =
 773                             ProtocolVersion.nameOf(protocols[i]);
 774                     if (pv == null) {
 775                         reservedException = new IllegalArgumentException(
 776                             propname + &quot;: &quot; + protocols[i] +
 777                             &quot; is not a supported SSL protocol name&quot;);
 778                     }
 779 
 780                     // ignore duplicated protocols
 781                     if (!arrayList.contains(pv)) {
 782                         arrayList.add(pv);
 783                     }
 784                 }
 785             }
 786         }
 787     }
 788 
 789     /*
 790      * The SSLContext implementation for customized TLS protocols
 791      *
 792      * @see SSLContext
 793      */
 794     private static class CustomizedTLSContext extends AbstractTLSContext {
 795 
 796         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 797         private static final List&lt;ProtocolVersion&gt; serverDefaultProtocols;
 798         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 799         private static final List&lt;CipherSuite&gt; serverDefaultCipherSuites;
 800         private static final IllegalArgumentException reservedException;
 801 
 802         // Don&#39;t want a java.lang.LinkageError for illegal system property.
 803         //
 804         // Please don&#39;t throw exception in this static block.  Otherwise,
 805         // java.lang.LinkageError may be thrown during the instantiation of
 806         // the provider service. Instead, let&#39;s handle the initialization
 807         // exception in constructor.
 808         static {
 809             reservedException = CustomizedSSLProtocols.reservedException;
 810             if (reservedException == null) {
 811                 clientDefaultProtocols = customizedProtocols(true,
 812                         CustomizedSSLProtocols.customizedClientProtocols);
 813                 serverDefaultProtocols = customizedProtocols(false,
 814                         CustomizedSSLProtocols.customizedServerProtocols);
 815 
 816                 clientDefaultCipherSuites =
 817                         getApplicableEnabledCipherSuites(
 818                                 clientDefaultProtocols, true);
 819                 serverDefaultCipherSuites =
 820                         getApplicableEnabledCipherSuites(
 821                                 serverDefaultProtocols, false);
 822 
 823             } else {
 824                 // unlikely to be used
 825                 clientDefaultProtocols = null;
 826                 serverDefaultProtocols = null;
 827                 clientDefaultCipherSuites = null;
 828                 serverDefaultCipherSuites = null;
 829             }
 830         }
 831 
 832         private static List&lt;ProtocolVersion&gt; customizedProtocols(
 833                 boolean client, List&lt;ProtocolVersion&gt; customized) {
 834             List&lt;ProtocolVersion&gt; refactored = new ArrayList&lt;&gt;();
 835             for (ProtocolVersion pv : customized) {
 836                 if (!pv.isDTLS) {
 837                     refactored.add(pv);
 838                 }
 839             }
 840 
 841             // Use the default enabled protocols if no customization
 842             ProtocolVersion[] candidates;
 843             if (refactored.isEmpty()) {
 844                 // Client and server use the same default protocols.
 845                 candidates = new ProtocolVersion[] {
 846                         ProtocolVersion.TLS13,
 847                         ProtocolVersion.TLS12,
 848                         ProtocolVersion.TLS11,
 849                         ProtocolVersion.TLS10
 850                     };
 851             } else {
 852                 // Use the customized TLS protocols.
 853                 candidates =
 854                     refactored.toArray(new ProtocolVersion[refactored.size()]);
 855             }
 856 
 857             return getAvailableProtocols(candidates);
 858         }
 859 
 860         protected CustomizedTLSContext() {
 861             if (reservedException != null) {
 862                 throw reservedException;
 863             }
 864         }
 865 
 866         @Override
 867         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 868             return clientDefaultProtocols;
 869         }
 870 
 871         @Override
 872         List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions() {
 873             return serverDefaultProtocols;
 874         }
 875 
 876         @Override
 877         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 878             return clientDefaultCipherSuites;
 879         }
 880 
 881         @Override
 882         List&lt;CipherSuite&gt; getServerDefaultCipherSuites() {
 883             return serverDefaultCipherSuites;
 884         }
 885     }
 886 
 887     /*
 888      * The SSLContext implementation for default &quot;TLS&quot; algorithm
 889      *
 890      * @see SSLContext
 891      */
 892     public static final class TLSContext extends CustomizedTLSContext {
 893         // use the default constructor and methods
 894     }
 895 
 896     // lazy initialization holder class idiom for static default parameters
 897     //
 898     // See Effective Java Second Edition: Item 71.
 899     private static final class DefaultManagersHolder {
 900         private static final String NONE = &quot;NONE&quot;;
 901         private static final String P11KEYSTORE = &quot;PKCS11&quot;;
 902 
 903         private static final TrustManager[] trustManagers;
 904         private static final KeyManager[] keyManagers;
 905 
 906         private static final Exception reservedException;
 907 
 908         static {
 909             Exception reserved = null;
 910             TrustManager[] tmMediator = null;
 911             try {
 912                 tmMediator = getTrustManagers();
 913             } catch (Exception e) {
 914                 reserved = e;
 915                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,defaultctx&quot;)) {
 916                     SSLLogger.warning(
 917                             &quot;Failed to load default trust managers&quot;, e);
 918                 }
 919             }
 920 
 921             KeyManager[] kmMediator = null;
 922             if (reserved == null) {
 923                 try {
 924                     kmMediator = getKeyManagers();
 925                 } catch (Exception e) {
 926                     reserved = e;
 927                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,defaultctx&quot;)) {
 928                         SSLLogger.warning(
 929                                 &quot;Failed to load default key managers&quot;, e);
 930                     }
 931                 }
 932             }
 933 
 934             if (reserved != null) {
 935                 trustManagers = new TrustManager[0];
 936                 keyManagers = new KeyManager[0];
 937 
 938                 // Important note: please don&#39;t reserve the original exception
 939                 // object, which may be not garbage collection friendly as
 940                 // &#39;reservedException&#39; is a static filed.
 941                 reservedException =
 942                         new KeyManagementException(reserved.getMessage());
 943             } else {
 944                 trustManagers = tmMediator;
 945                 keyManagers = kmMediator;
 946 
 947                 reservedException = null;
 948             }
 949         }
 950 
 951         private static TrustManager[] getTrustManagers() throws Exception {
 952             TrustManagerFactory tmf = TrustManagerFactory.getInstance(
 953                     TrustManagerFactory.getDefaultAlgorithm());
 954             if (&quot;SunJSSE&quot;.equals(tmf.getProvider().getName())) {
 955                 // The implementation will load the default KeyStore
 956                 // automatically.  Cached trust materials may be used
 957                 // for performance improvement.
 958                 tmf.init((KeyStore)null);
 959             } else {
 960                 // Use the explicitly specified KeyStore for third party&#39;s
 961                 // TrustManagerFactory implementation.
 962                 KeyStore ks = TrustStoreManager.getTrustedKeyStore();
 963                 tmf.init(ks);
 964             }
 965 
 966             return tmf.getTrustManagers();
 967         }
 968 
 969         private static KeyManager[] getKeyManagers() throws Exception {
 970 
 971             final Map&lt;String,String&gt; props = new HashMap&lt;&gt;();
 972             AccessController.doPrivileged(
 973                         new PrivilegedExceptionAction&lt;Object&gt;() {
 974                 @Override
 975                 public Object run() throws Exception {
 976                     props.put(&quot;keyStore&quot;,  System.getProperty(
 977                                 &quot;javax.net.ssl.keyStore&quot;, &quot;&quot;));
 978                     props.put(&quot;keyStoreType&quot;, System.getProperty(
 979                                 &quot;javax.net.ssl.keyStoreType&quot;,
 980                                 KeyStore.getDefaultType()));
 981                     props.put(&quot;keyStoreProvider&quot;, System.getProperty(
 982                                 &quot;javax.net.ssl.keyStoreProvider&quot;, &quot;&quot;));
 983                     props.put(&quot;keyStorePasswd&quot;, System.getProperty(
 984                                 &quot;javax.net.ssl.keyStorePassword&quot;, &quot;&quot;));
 985                     return null;
 986                 }
 987             });
 988 
 989             final String defaultKeyStore = props.get(&quot;keyStore&quot;);
 990             String defaultKeyStoreType = props.get(&quot;keyStoreType&quot;);
 991             String defaultKeyStoreProvider = props.get(&quot;keyStoreProvider&quot;);
 992             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,defaultctx&quot;)) {
 993                 SSLLogger.fine(&quot;keyStore is : &quot; + defaultKeyStore);
 994                 SSLLogger.fine(&quot;keyStore type is : &quot; +
 995                                         defaultKeyStoreType);
 996                 SSLLogger.fine(&quot;keyStore provider is : &quot; +
 997                                         defaultKeyStoreProvider);
 998             }
 999 
1000             if (P11KEYSTORE.equals(defaultKeyStoreType) &amp;&amp;
1001                     !NONE.equals(defaultKeyStore)) {
1002                 throw new IllegalArgumentException(&quot;if keyStoreType is &quot;
1003                     + P11KEYSTORE + &quot;, then keyStore must be &quot; + NONE);
1004             }
1005 
1006             FileInputStream fs = null;
1007             KeyStore ks = null;
1008             char[] passwd = null;
1009             try {
1010                 if (!defaultKeyStore.isEmpty() &amp;&amp;
1011                         !NONE.equals(defaultKeyStore)) {
1012                     fs = AccessController.doPrivileged(
1013                             new PrivilegedExceptionAction&lt;FileInputStream&gt;() {
1014                         @Override
1015                         public FileInputStream run() throws Exception {
1016                             return new FileInputStream(defaultKeyStore);
1017                         }
1018                     });
1019                 }
1020 
1021                 String defaultKeyStorePassword = props.get(&quot;keyStorePasswd&quot;);
1022                 if (!defaultKeyStorePassword.isEmpty()) {
1023                     passwd = defaultKeyStorePassword.toCharArray();
1024                 }
1025 
1026                 /**
1027                  * Try to initialize key store.
1028                  */
1029                 if ((defaultKeyStoreType.length()) != 0) {
1030                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,defaultctx&quot;)) {
1031                         SSLLogger.finest(&quot;init keystore&quot;);
1032                     }
1033                     if (defaultKeyStoreProvider.isEmpty()) {
1034                         ks = KeyStore.getInstance(defaultKeyStoreType);
1035                     } else {
1036                         ks = KeyStore.getInstance(defaultKeyStoreType,
1037                                             defaultKeyStoreProvider);
1038                     }
1039 
1040                     // if defaultKeyStore is NONE, fs will be null
1041                     ks.load(fs, passwd);
1042                 }
1043             } finally {
1044                 if (fs != null) {
1045                     fs.close();
1046                     fs = null;
1047                 }
1048             }
1049 
1050             /*
1051              * Try to initialize key manager.
1052              */
1053             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,defaultctx&quot;)) {
1054                 SSLLogger.fine(&quot;init keymanager of type &quot; +
1055                     KeyManagerFactory.getDefaultAlgorithm());
1056             }
1057             KeyManagerFactory kmf = KeyManagerFactory.getInstance(
1058                 KeyManagerFactory.getDefaultAlgorithm());
1059 
1060             if (P11KEYSTORE.equals(defaultKeyStoreType)) {
1061                 kmf.init(ks, null); // do not pass key passwd if using token
1062             } else {
1063                 kmf.init(ks, passwd);
1064             }
1065 
1066             return kmf.getKeyManagers();
1067         }
1068     }
1069 
1070     // lazy initialization holder class idiom for static default parameters
1071     //
1072     // See Effective Java Second Edition: Item 71.
1073     private static final class DefaultSSLContextHolder {
1074 
1075         private static final SSLContextImpl sslContext;
1076         private static final Exception reservedException;
1077 
1078         static {
1079             Exception reserved = null;
1080             SSLContextImpl mediator = null;
1081             if (DefaultManagersHolder.reservedException != null) {
1082                 reserved = DefaultManagersHolder.reservedException;
1083             } else {
1084                 try {
1085                     mediator = new DefaultSSLContext();
1086                 } catch (Exception e) {
1087                     // Important note: please don&#39;t reserve the original
1088                     // exception object, which may be not garbage collection
1089                     // friendly as &#39;reservedException&#39; is a static filed.
1090                     reserved = new KeyManagementException(e.getMessage());
1091                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,defaultctx&quot;)) {
1092                         SSLLogger.warning(
1093                                 &quot;Failed to load default SSLContext&quot;, e);
1094                     }
1095                 }
1096             }
1097 
1098             sslContext = mediator;
1099             reservedException = reserved;
1100         }
1101     }
1102 
1103     /*
1104      * The SSLContext implementation for default &quot;Default&quot; algorithm
1105      *
1106      * @see SSLContext
1107      */
1108     public static final class DefaultSSLContext extends CustomizedTLSContext {
1109 
1110         // public constructor for SSLContext.getInstance(&quot;Default&quot;)
1111         public DefaultSSLContext() throws Exception {
1112             if (DefaultManagersHolder.reservedException != null) {
1113                 throw DefaultManagersHolder.reservedException;
1114             }
1115 
1116             try {
1117                 super.engineInit(DefaultManagersHolder.keyManagers,
1118                         DefaultManagersHolder.trustManagers, null);
1119             } catch (Exception e) {
1120                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,defaultctx&quot;)) {
1121                     SSLLogger.fine(&quot;default context init failed: &quot;, e);
1122                 }
1123                 throw e;
1124             }
1125         }
1126 
1127         @Override
1128         protected void engineInit(KeyManager[] km, TrustManager[] tm,
1129             SecureRandom sr) throws KeyManagementException {
1130             throw new KeyManagementException
1131                 (&quot;Default SSLContext is initialized automatically&quot;);
1132         }
1133 
1134         static SSLContextImpl getDefaultImpl() throws Exception {
1135             if (DefaultSSLContextHolder.reservedException != null) {
1136                 throw DefaultSSLContextHolder.reservedException;
1137             }
1138 
1139             return DefaultSSLContextHolder.sslContext;
1140         }
1141     }
1142 
1143     /*
1144      * The base abstract SSLContext implementation for the Datagram Transport
1145      * Layer Security (DTLS) protocols.
1146      *
1147      * This abstract class encapsulates supported and the default server DTLS
1148      * parameters.
1149      *
1150      * @see SSLContext
1151      */
1152     private abstract static class AbstractDTLSContext extends SSLContextImpl {
1153         private static final List&lt;ProtocolVersion&gt; supportedProtocols;
1154         private static final List&lt;ProtocolVersion&gt; serverDefaultProtocols;
1155 
1156         private static final List&lt;CipherSuite&gt; supportedCipherSuites;
1157         private static final List&lt;CipherSuite&gt; serverDefaultCipherSuites;
1158 
1159         static {
1160             supportedProtocols = Arrays.asList(
1161                 ProtocolVersion.DTLS12,
1162                 ProtocolVersion.DTLS10
1163             );
1164 
1165             // available protocols for server mode
1166             serverDefaultProtocols = getAvailableProtocols(
1167                     new ProtocolVersion[] {
1168                 ProtocolVersion.DTLS12,
1169                 ProtocolVersion.DTLS10
1170             });
1171 
1172             supportedCipherSuites = getApplicableSupportedCipherSuites(
1173                     supportedProtocols);
1174             serverDefaultCipherSuites = getApplicableEnabledCipherSuites(
1175                     serverDefaultProtocols, false);
1176         }
1177 
1178         @Override
1179         protected SSLParameters engineGetDefaultSSLParameters() {
1180             SSLEngine engine = createSSLEngineImpl();
<a name="2" id="anc2"></a><span class="line-added">1181             // Note: The TLSContext defaults to client side SSLParameters.</span>
<span class="line-added">1182             // We can do the same here. Please don&#39;t change the behavior</span>
<span class="line-added">1183             // for compatibility.</span>
<span class="line-added">1184             engine.setUseClientMode(true);</span>
1185             return engine.getSSLParameters();
1186         }
1187 
1188         @Override
1189         protected SSLParameters engineGetSupportedSSLParameters() {
1190             SSLEngine engine = createSSLEngineImpl();
1191             SSLParameters params = new SSLParameters();
1192             params.setCipherSuites(engine.getSupportedCipherSuites());
1193             params.setProtocols(engine.getSupportedProtocols());
1194             return params;
1195         }
1196 
1197         @Override
1198         List&lt;ProtocolVersion&gt; getSupportedProtocolVersions() {
1199             return supportedProtocols;
1200         }
1201 
1202         @Override
1203         List&lt;CipherSuite&gt; getSupportedCipherSuites() {
1204             return supportedCipherSuites;
1205         }
1206 
1207         @Override
1208         List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions() {
1209             return serverDefaultProtocols;
1210         }
1211 
1212         @Override
1213         List&lt;CipherSuite&gt; getServerDefaultCipherSuites() {
1214             return serverDefaultCipherSuites;
1215         }
1216 
1217         @Override
1218         SSLEngine createSSLEngineImpl() {
1219             return new SSLEngineImpl(this);
1220         }
1221 
1222         @Override
1223         SSLEngine createSSLEngineImpl(String host, int port) {
1224             return new SSLEngineImpl(this, host, port);
1225         }
1226 
1227         @Override
1228         boolean isDTLS() {
1229             return true;
1230         }
1231     }
1232 
1233     /*
1234      * The SSLContext implementation for DTLSv1.0 algorithm.
1235      *
1236      * @see SSLContext
1237      */
1238     public static final class DTLS10Context extends AbstractDTLSContext {
1239         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
1240         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
1241 
1242         static {
1243             // available protocols for client mode
1244             clientDefaultProtocols = getAvailableProtocols(
1245                     new ProtocolVersion[] {
1246                 ProtocolVersion.DTLS10
1247             });
1248 
1249             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
1250                     clientDefaultProtocols, true);
1251         }
1252 
1253         @Override
1254         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
1255             return clientDefaultProtocols;
1256         }
1257 
1258         @Override
1259         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
1260             return clientDefaultCipherSuites;
1261         }
1262     }
1263 
1264     /*
1265      * The SSLContext implementation for DTLSv1.2 algorithm.
1266      *
1267      * @see SSLContext
1268      */
1269     public static final class DTLS12Context extends AbstractDTLSContext {
1270         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
1271         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
1272 
1273         static {
1274             // available protocols for client mode
1275             clientDefaultProtocols = getAvailableProtocols(
1276                     new ProtocolVersion[] {
1277                 ProtocolVersion.DTLS12,
1278                 ProtocolVersion.DTLS10
1279             });
1280 
1281             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
1282                     clientDefaultProtocols, true);
1283         }
1284 
1285         @Override
1286         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
1287             return clientDefaultProtocols;
1288         }
1289 
1290         @Override
1291         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
1292             return clientDefaultCipherSuites;
1293         }
1294     }
1295 
1296     /*
1297      * The SSLContext implementation for customized TLS protocols
1298      *
1299      * @see SSLContext
1300      */
1301     private static class CustomizedDTLSContext extends AbstractDTLSContext {
1302         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
1303         private static final List&lt;ProtocolVersion&gt; serverDefaultProtocols;
1304         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
1305         private static final List&lt;CipherSuite&gt; serverDefaultCipherSuites;
1306 
1307         private static IllegalArgumentException reservedException = null;
1308 
1309         // Don&#39;t want a java.lang.LinkageError for illegal system property.
1310         //
1311         // Please don&#39;t throw exception in this static block.  Otherwise,
1312         // java.lang.LinkageError may be thrown during the instantiation of
1313         // the provider service. Instead, let&#39;s handle the initialization
1314         // exception in constructor.
1315         static {
1316             reservedException = CustomizedSSLProtocols.reservedException;
1317             if (reservedException == null) {
1318                 clientDefaultProtocols = customizedProtocols(true,
1319                         CustomizedSSLProtocols.customizedClientProtocols);
1320                 serverDefaultProtocols = customizedProtocols(false,
1321                         CustomizedSSLProtocols.customizedServerProtocols);
1322 
1323                 clientDefaultCipherSuites =
1324                         getApplicableEnabledCipherSuites(
1325                                 clientDefaultProtocols, true);
1326                 serverDefaultCipherSuites =
1327                         getApplicableEnabledCipherSuites(
1328                                 serverDefaultProtocols, false);
1329 
1330             } else {
1331                 // unlikely to be used
1332                 clientDefaultProtocols = null;
1333                 serverDefaultProtocols = null;
1334                 clientDefaultCipherSuites = null;
1335                 serverDefaultCipherSuites = null;
1336             }
1337         }
1338 
1339         private static List&lt;ProtocolVersion&gt; customizedProtocols(boolean client,
1340                 List&lt;ProtocolVersion&gt; customized) {
1341             List&lt;ProtocolVersion&gt; refactored = new ArrayList&lt;&gt;();
1342             for (ProtocolVersion pv : customized) {
1343                 if (pv.isDTLS) {
1344                     refactored.add(pv);
1345                 }
1346             }
1347 
1348             ProtocolVersion[] candidates;
1349             // Use the default enabled protocols if no customization
1350             if (refactored.isEmpty()) {
1351                 candidates = new ProtocolVersion[]{
1352                         ProtocolVersion.DTLS12,
1353                         ProtocolVersion.DTLS10
1354                 };
1355                 if (!client)
1356                     return Arrays.asList(candidates);
1357             } else {
1358                 // Use the customized TLS protocols.
1359                 candidates =
1360                         new ProtocolVersion[customized.size()];
1361                 candidates = customized.toArray(candidates);
1362             }
1363 
1364             return getAvailableProtocols(candidates);
1365         }
1366 
1367         protected CustomizedDTLSContext() {
1368             if (reservedException != null) {
1369                 throw reservedException;
1370             }
1371         }
1372 
1373         @Override
1374         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
1375             return clientDefaultProtocols;
1376         }
1377 
1378         @Override
1379         List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions() {
1380             return serverDefaultProtocols;
1381         }
1382 
1383         @Override
1384         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
1385             return clientDefaultCipherSuites;
1386         }
1387 
1388         @Override
1389         List&lt;CipherSuite&gt; getServerDefaultCipherSuites() {
1390             return serverDefaultCipherSuites;
1391         }
1392     }
1393 
1394     /*
1395      * The SSLContext implementation for default &quot;DTLS&quot; algorithm
1396      *
1397      * @see SSLContext
1398      */
1399     public static final class DTLSContext extends CustomizedDTLSContext {
1400         // use the default constructor and methods
1401     }
1402 
1403 }
1404 
1405 final class AbstractTrustManagerWrapper extends X509ExtendedTrustManager
1406             implements X509TrustManager {
1407 
1408     // the delegated trust manager
1409     private final X509TrustManager tm;
1410 
1411     AbstractTrustManagerWrapper(X509TrustManager tm) {
1412         this.tm = tm;
1413     }
1414 
1415     @Override
1416     public void checkClientTrusted(X509Certificate[] chain, String authType)
1417         throws CertificateException {
1418         tm.checkClientTrusted(chain, authType);
1419     }
1420 
1421     @Override
1422     public void checkServerTrusted(X509Certificate[] chain, String authType)
1423         throws CertificateException {
1424         tm.checkServerTrusted(chain, authType);
1425     }
1426 
1427     @Override
1428     public X509Certificate[] getAcceptedIssuers() {
1429         return tm.getAcceptedIssuers();
1430     }
1431 
1432     @Override
1433     public void checkClientTrusted(X509Certificate[] chain, String authType,
1434                 Socket socket) throws CertificateException {
1435         tm.checkClientTrusted(chain, authType);
1436         checkAdditionalTrust(chain, authType, socket, true);
1437     }
1438 
1439     @Override
1440     public void checkServerTrusted(X509Certificate[] chain, String authType,
1441             Socket socket) throws CertificateException {
1442         tm.checkServerTrusted(chain, authType);
1443         checkAdditionalTrust(chain, authType, socket, false);
1444     }
1445 
1446     @Override
1447     public void checkClientTrusted(X509Certificate[] chain, String authType,
1448             SSLEngine engine) throws CertificateException {
1449         tm.checkClientTrusted(chain, authType);
1450         checkAdditionalTrust(chain, authType, engine, true);
1451     }
1452 
1453     @Override
1454     public void checkServerTrusted(X509Certificate[] chain, String authType,
1455             SSLEngine engine) throws CertificateException {
1456         tm.checkServerTrusted(chain, authType);
1457         checkAdditionalTrust(chain, authType, engine, false);
1458     }
1459 
1460     private void checkAdditionalTrust(X509Certificate[] chain,
1461             String authType, Socket socket,
1462             boolean checkClientTrusted) throws CertificateException {
1463         if (socket != null &amp;&amp; socket.isConnected() &amp;&amp;
1464                                     socket instanceof SSLSocket) {
1465 
1466             SSLSocket sslSocket = (SSLSocket)socket;
1467             SSLSession session = sslSocket.getHandshakeSession();
1468             if (session == null) {
1469                 throw new CertificateException(&quot;No handshake session&quot;);
1470             }
1471 
1472             // check endpoint identity
1473             String identityAlg = sslSocket.getSSLParameters().
1474                                         getEndpointIdentificationAlgorithm();
1475             if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
1476                 X509TrustManagerImpl.checkIdentity(session, chain,
1477                                     identityAlg, checkClientTrusted);
1478             }
1479 
1480             // try the best to check the algorithm constraints
1481             AlgorithmConstraints constraints;
1482             if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
1483                 if (session instanceof ExtendedSSLSession) {
1484                     ExtendedSSLSession extSession =
1485                                     (ExtendedSSLSession)session;
1486                     String[] peerSupportedSignAlgs =
1487                             extSession.getLocalSupportedSignatureAlgorithms();
1488 
1489                     constraints = new SSLAlgorithmConstraints(
1490                                     sslSocket, peerSupportedSignAlgs, true);
1491                 } else {
1492                     constraints =
1493                             new SSLAlgorithmConstraints(sslSocket, true);
1494                 }
1495             } else {
1496                 constraints = new SSLAlgorithmConstraints(sslSocket, true);
1497             }
1498 
1499             checkAlgorithmConstraints(chain, constraints, checkClientTrusted);
1500         }
1501     }
1502 
1503     private void checkAdditionalTrust(X509Certificate[] chain,
1504             String authType, SSLEngine engine,
1505             boolean checkClientTrusted) throws CertificateException {
1506         if (engine != null) {
1507             SSLSession session = engine.getHandshakeSession();
1508             if (session == null) {
1509                 throw new CertificateException(&quot;No handshake session&quot;);
1510             }
1511 
1512             // check endpoint identity
1513             String identityAlg = engine.getSSLParameters().
1514                                         getEndpointIdentificationAlgorithm();
1515             if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
1516                 X509TrustManagerImpl.checkIdentity(session, chain,
1517                                     identityAlg, checkClientTrusted);
1518             }
1519 
1520             // try the best to check the algorithm constraints
1521             AlgorithmConstraints constraints;
1522             if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
1523                 if (session instanceof ExtendedSSLSession) {
1524                     ExtendedSSLSession extSession =
1525                                     (ExtendedSSLSession)session;
1526                     String[] peerSupportedSignAlgs =
1527                             extSession.getLocalSupportedSignatureAlgorithms();
1528 
1529                     constraints = new SSLAlgorithmConstraints(
1530                                     engine, peerSupportedSignAlgs, true);
1531                 } else {
1532                     constraints =
1533                             new SSLAlgorithmConstraints(engine, true);
1534                 }
1535             } else {
1536                 constraints = new SSLAlgorithmConstraints(engine, true);
1537             }
1538 
1539             checkAlgorithmConstraints(chain, constraints, checkClientTrusted);
1540         }
1541     }
1542 
1543     private void checkAlgorithmConstraints(X509Certificate[] chain,
1544             AlgorithmConstraints constraints,
1545             boolean checkClientTrusted) throws CertificateException {
1546         try {
1547             // Does the certificate chain end with a trusted certificate?
1548             int checkedLength = chain.length - 1;
1549 
1550             Collection&lt;X509Certificate&gt; trustedCerts = new HashSet&lt;&gt;();
1551             X509Certificate[] certs = tm.getAcceptedIssuers();
1552             if ((certs != null) &amp;&amp; (certs.length &gt; 0)){
1553                 Collections.addAll(trustedCerts, certs);
1554             }
1555 
1556             if (trustedCerts.contains(chain[checkedLength])) {
1557                     checkedLength--;
1558             }
1559 
1560             // A forward checker, need to check from trust to target
1561             if (checkedLength &gt;= 0) {
1562                 AlgorithmChecker checker =
1563                     new AlgorithmChecker(constraints, null,
1564                             (checkClientTrusted ? Validator.VAR_TLS_CLIENT :
1565                                         Validator.VAR_TLS_SERVER));
1566                 checker.init(false);
1567                 for (int i = checkedLength; i &gt;= 0; i--) {
1568                     X509Certificate cert = chain[i];
1569                     // We don&#39;t care about the unresolved critical extensions.
1570                     checker.check(cert, Collections.&lt;String&gt;emptySet());
1571                 }
1572             }
1573         } catch (CertPathValidatorException cpve) {
1574             throw new CertificateException(
1575                 &quot;Certificates do not conform to algorithm constraints&quot;, cpve);
1576         }
1577     }
1578 }
1579 
1580 // Dummy X509TrustManager implementation, rejects all peer certificates.
1581 // Used if the application did not specify a proper X509TrustManager.
1582 final class DummyX509TrustManager extends X509ExtendedTrustManager
1583             implements X509TrustManager {
1584 
1585     static final X509TrustManager INSTANCE = new DummyX509TrustManager();
1586 
1587     private DummyX509TrustManager() {
1588         // empty
1589     }
1590 
1591     /*
1592      * Given the partial or complete certificate chain
1593      * provided by the peer, build a certificate path
1594      * to a trusted root and return if it can be
1595      * validated and is trusted for client SSL authentication.
1596      * If not, it throws an exception.
1597      */
1598     @Override
1599     public void checkClientTrusted(X509Certificate[] chain, String authType)
1600         throws CertificateException {
1601         throw new CertificateException(
1602             &quot;No X509TrustManager implementation avaiable&quot;);
1603     }
1604 
1605     /*
1606      * Given the partial or complete certificate chain
1607      * provided by the peer, build a certificate path
1608      * to a trusted root and return if it can be
1609      * validated and is trusted for server SSL authentication.
1610      * If not, it throws an exception.
1611      */
1612     @Override
1613     public void checkServerTrusted(X509Certificate[] chain, String authType)
1614         throws CertificateException {
1615         throw new CertificateException(
1616             &quot;No X509TrustManager implementation available&quot;);
1617     }
1618 
1619     /*
1620      * Return an array of issuer certificates which are trusted
1621      * for authenticating peers.
1622      */
1623     @Override
1624     public X509Certificate[] getAcceptedIssuers() {
1625         return new X509Certificate[0];
1626     }
1627 
1628     @Override
1629     public void checkClientTrusted(X509Certificate[] chain, String authType,
1630                 Socket socket) throws CertificateException {
1631         throw new CertificateException(
1632             &quot;No X509TrustManager implementation available&quot;);
1633     }
1634 
1635     @Override
1636     public void checkServerTrusted(X509Certificate[] chain, String authType,
1637             Socket socket) throws CertificateException {
1638         throw new CertificateException(
1639             &quot;No X509TrustManager implementation available&quot;);
1640     }
1641 
1642     @Override
1643     public void checkClientTrusted(X509Certificate[] chain, String authType,
1644             SSLEngine engine) throws CertificateException {
1645         throw new CertificateException(
1646             &quot;No X509TrustManager implementation available&quot;);
1647     }
1648 
1649     @Override
1650     public void checkServerTrusted(X509Certificate[] chain, String authType,
1651             SSLEngine engine) throws CertificateException {
1652         throw new CertificateException(
1653             &quot;No X509TrustManager implementation available&quot;);
1654     }
1655 }
1656 
1657 /*
1658  * A wrapper class to turn a X509KeyManager into an X509ExtendedKeyManager
1659  */
1660 final class AbstractKeyManagerWrapper extends X509ExtendedKeyManager {
1661 
1662     private final X509KeyManager km;
1663 
1664     AbstractKeyManagerWrapper(X509KeyManager km) {
1665         this.km = km;
1666     }
1667 
1668     @Override
1669     public String[] getClientAliases(String keyType, Principal[] issuers) {
1670         return km.getClientAliases(keyType, issuers);
1671     }
1672 
1673     @Override
1674     public String chooseClientAlias(String[] keyType, Principal[] issuers,
1675             Socket socket) {
1676         return km.chooseClientAlias(keyType, issuers, socket);
1677     }
1678 
1679     @Override
1680     public String[] getServerAliases(String keyType, Principal[] issuers) {
1681         return km.getServerAliases(keyType, issuers);
1682     }
1683 
1684     @Override
1685     public String chooseServerAlias(String keyType, Principal[] issuers,
1686             Socket socket) {
1687         return km.chooseServerAlias(keyType, issuers, socket);
1688     }
1689 
1690     @Override
1691     public X509Certificate[] getCertificateChain(String alias) {
1692         return km.getCertificateChain(alias);
1693     }
1694 
1695     @Override
1696     public PrivateKey getPrivateKey(String alias) {
1697         return km.getPrivateKey(alias);
1698     }
1699 
1700     // Inherit chooseEngineClientAlias() and chooseEngineServerAlias() from
1701     // X509ExtendedKeymanager. It defines them to return null;
1702 }
1703 
1704 
1705 // Dummy X509KeyManager implementation, never returns any certificates/keys.
1706 // Used if the application did not specify a proper X509TrustManager.
1707 final class DummyX509KeyManager extends X509ExtendedKeyManager {
1708 
1709     static final X509ExtendedKeyManager INSTANCE = new DummyX509KeyManager();
1710 
1711     private DummyX509KeyManager() {
1712         // empty
1713     }
1714 
1715     /*
1716      * Get the matching aliases for authenticating the client side of a secure
1717      * socket given the public key type and the list of
1718      * certificate issuer authorities recognized by the peer (if any).
1719      */
1720     @Override
1721     public String[] getClientAliases(String keyType, Principal[] issuers) {
1722         return null;
1723     }
1724 
1725     /*
1726      * Choose an alias to authenticate the client side of a secure
1727      * socket given the public key type and the list of
1728      * certificate issuer authorities recognized by the peer (if any).
1729      */
1730     @Override
1731     public String chooseClientAlias(String[] keyTypes, Principal[] issuers,
1732             Socket socket) {
1733         return null;
1734     }
1735 
1736     /*
1737      * Choose an alias to authenticate the client side of an
1738      * engine given the public key type and the list of
1739      * certificate issuer authorities recognized by the peer (if any).
1740      */
1741     @Override
1742     public String chooseEngineClientAlias(
1743             String[] keyTypes, Principal[] issuers, SSLEngine engine) {
1744         return null;
1745     }
1746 
1747     /*
1748      * Get the matching aliases for authenticating the server side of a secure
1749      * socket given the public key type and the list of
1750      * certificate issuer authorities recognized by the peer (if any).
1751      */
1752     @Override
1753     public String[] getServerAliases(String keyType, Principal[] issuers) {
1754         return null;
1755     }
1756 
1757     /*
1758      * Choose an alias to authenticate the server side of a secure
1759      * socket given the public key type and the list of
1760      * certificate issuer authorities recognized by the peer (if any).
1761      */
1762     @Override
1763     public String chooseServerAlias(String keyType, Principal[] issuers,
1764             Socket socket) {
1765         return null;
1766     }
1767 
1768     /*
1769      * Choose an alias to authenticate the server side of an engine
1770      * given the public key type and the list of
1771      * certificate issuer authorities recognized by the peer (if any).
1772      */
1773     @Override
1774     public String chooseEngineServerAlias(
1775             String keyType, Principal[] issuers, SSLEngine engine) {
1776         return null;
1777     }
1778 
1779     /**
1780      * Returns the certificate chain associated with the given alias.
1781      *
1782      * @param alias the alias name
1783      *
1784      * @return the certificate chain (ordered with the user&#39;s certificate first
1785      * and the root certificate authority last)
1786      */
1787     @Override
1788     public X509Certificate[] getCertificateChain(String alias) {
1789         return null;
1790     }
1791 
1792     /*
1793      * Returns the key associated with the given alias, using the given
1794      * password to recover it.
1795      *
1796      * @param alias the alias name
1797      *
1798      * @return the requested key
1799      */
1800     @Override
1801     public PrivateKey getPrivateKey(String alias) {
1802         return null;
1803     }
1804 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DatagramSocketAdaptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../security/jca/ProviderConfig.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.io.UncheckedIOException;
  31 import java.lang.ref.Cleaner.Cleanable;
  32 import java.nio.ByteBuffer;
  33 import java.nio.MappedByteBuffer;
  34 import java.nio.channels.AsynchronousCloseException;
  35 import java.nio.channels.ClosedByInterruptException;
  36 import java.nio.channels.ClosedChannelException;
  37 import java.nio.channels.FileChannel;
  38 import java.nio.channels.FileLock;
  39 import java.nio.channels.FileLockInterruptionException;
  40 import java.nio.channels.NonReadableChannelException;
  41 import java.nio.channels.NonWritableChannelException;
  42 import java.nio.channels.ReadableByteChannel;
  43 import java.nio.channels.SelectableChannel;
  44 import java.nio.channels.WritableByteChannel;
  45 import java.util.Objects;
  46 
  47 import jdk.internal.access.JavaIOFileDescriptorAccess;
<span class="line-removed">  48 import jdk.internal.access.JavaNioAccess;</span>
  49 import jdk.internal.access.SharedSecrets;
  50 import jdk.internal.misc.ExtendedMapMode;
  51 import jdk.internal.misc.Unsafe;
  52 import jdk.internal.misc.VM;

  53 import jdk.internal.ref.Cleaner;
  54 import jdk.internal.ref.CleanerFactory;
  55 
  56 import jdk.internal.access.foreign.UnmapperProxy;
  57 
  58 public class FileChannelImpl
  59     extends FileChannel
  60 {
  61     // Memory allocation size for mapping buffers
  62     private static final long allocationGranularity;
  63 
  64     // Access to FileDescriptor internals
  65     private static final JavaIOFileDescriptorAccess fdAccess =
  66         SharedSecrets.getJavaIOFileDescriptorAccess();
  67 
  68     // Used to make native read and write calls
  69     private final FileDispatcher nd;
  70 
  71     // File descriptor
  72     private final FileDescriptor fd;
</pre>
<hr />
<pre>
 223             try {
 224                 beginBlocking();
 225                 ti = threads.add();
 226                 if (!isOpen())
 227                     return 0;
 228                 do {
 229                     n = IOUtil.read(fd, dst, -1, direct, alignment, nd);
 230                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 231                 return IOStatus.normalize(n);
 232             } finally {
 233                 threads.remove(ti);
 234                 endBlocking(n &gt; 0);
 235                 assert IOStatus.check(n);
 236             }
 237         }
 238     }
 239 
 240     public long read(ByteBuffer[] dsts, int offset, int length)
 241         throws IOException
 242     {
<span class="line-modified"> 243         if ((offset &lt; 0) || (length &lt; 0) || (offset &gt; dsts.length - length))</span>
<span class="line-removed"> 244             throw new IndexOutOfBoundsException();</span>
 245         ensureOpen();
 246         if (!readable)
 247             throw new NonReadableChannelException();
 248         synchronized (positionLock) {
 249             if (direct)
 250                 Util.checkChannelPositionAligned(position(), alignment);
 251             long n = 0;
 252             int ti = -1;
 253             try {
 254                 beginBlocking();
 255                 ti = threads.add();
 256                 if (!isOpen())
 257                     return 0;
 258                 do {
 259                     n = IOUtil.read(fd, dsts, offset, length,
 260                             direct, alignment, nd);
 261                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 262                 return IOStatus.normalize(n);
 263             } finally {
 264                 threads.remove(ti);
</pre>
<hr />
<pre>
 280             try {
 281                 beginBlocking();
 282                 ti = threads.add();
 283                 if (!isOpen())
 284                     return 0;
 285                 do {
 286                     n = IOUtil.write(fd, src, -1, direct, alignment, nd);
 287                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 288                 return IOStatus.normalize(n);
 289             } finally {
 290                 threads.remove(ti);
 291                 endBlocking(n &gt; 0);
 292                 assert IOStatus.check(n);
 293             }
 294         }
 295     }
 296 
 297     public long write(ByteBuffer[] srcs, int offset, int length)
 298         throws IOException
 299     {
<span class="line-modified"> 300         if ((offset &lt; 0) || (length &lt; 0) || (offset &gt; srcs.length - length))</span>
<span class="line-removed"> 301             throw new IndexOutOfBoundsException();</span>
 302         ensureOpen();
 303         if (!writable)
 304             throw new NonWritableChannelException();
 305         synchronized (positionLock) {
 306             if (direct)
 307                 Util.checkChannelPositionAligned(position(), alignment);
 308             long n = 0;
 309             int ti = -1;
 310             try {
 311                 beginBlocking();
 312                 ti = threads.add();
 313                 if (!isOpen())
 314                     return 0;
 315                 do {
 316                     n = IOUtil.write(fd, srcs, offset, length,
 317                             direct, alignment, nd);
 318                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 319                 return IOStatus.normalize(n);
 320             } finally {
 321                 threads.remove(ti);
</pre>
<hr />
<pre>
 772         if (!src.isOpen())
 773             throw new ClosedChannelException();
 774         if (!writable)
 775             throw new NonWritableChannelException();
 776         if ((position &lt; 0) || (count &lt; 0))
 777             throw new IllegalArgumentException();
 778         if (position &gt; size())
 779             return 0;
 780         if (src instanceof FileChannelImpl)
 781            return transferFromFileChannel((FileChannelImpl)src,
 782                                           position, count);
 783 
 784         return transferFromArbitraryChannel(src, position, count);
 785     }
 786 
 787     public int read(ByteBuffer dst, long position) throws IOException {
 788         if (dst == null)
 789             throw new NullPointerException();
 790         if (position &lt; 0)
 791             throw new IllegalArgumentException(&quot;Negative position&quot;);

 792         if (!readable)
 793             throw new NonReadableChannelException();
 794         if (direct)
 795             Util.checkChannelPositionAligned(position, alignment);
<span class="line-removed"> 796         ensureOpen();</span>
 797         if (nd.needsPositionLock()) {
 798             synchronized (positionLock) {
 799                 return readInternal(dst, position);
 800             }
 801         } else {
 802             return readInternal(dst, position);
 803         }
 804     }
 805 
 806     private int readInternal(ByteBuffer dst, long position) throws IOException {
 807         assert !nd.needsPositionLock() || Thread.holdsLock(positionLock);
 808         int n = 0;
 809         int ti = -1;
 810 
 811         try {
 812             beginBlocking();
 813             ti = threads.add();
 814             if (!isOpen())
 815                 return -1;
 816             do {
 817                 n = IOUtil.read(fd, dst, position, direct, alignment, nd);
 818             } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 819             return IOStatus.normalize(n);
 820         } finally {
 821             threads.remove(ti);
 822             endBlocking(n &gt; 0);
 823             assert IOStatus.check(n);
 824         }
 825     }
 826 
 827     public int write(ByteBuffer src, long position) throws IOException {
 828         if (src == null)
 829             throw new NullPointerException();
 830         if (position &lt; 0)
 831             throw new IllegalArgumentException(&quot;Negative position&quot;);

 832         if (!writable)
 833             throw new NonWritableChannelException();
 834         if (direct)
 835             Util.checkChannelPositionAligned(position, alignment);
<span class="line-removed"> 836         ensureOpen();</span>
 837         if (nd.needsPositionLock()) {
 838             synchronized (positionLock) {
 839                 return writeInternal(src, position);
 840             }
 841         } else {
 842             return writeInternal(src, position);
 843         }
 844     }
 845 
 846     private int writeInternal(ByteBuffer src, long position) throws IOException {
 847         assert !nd.needsPositionLock() || Thread.holdsLock(positionLock);
 848         int n = 0;
 849         int ti = -1;
 850         try {
 851             beginBlocking();
 852             ti = threads.add();
 853             if (!isOpen())
 854                 return -1;
 855             do {
 856                 n = IOUtil.write(fd, src, position, direct, alignment, nd);
</pre>
<hr />
<pre>
1143     }
1144 
1145     private void checkMode(MapMode mode, int prot, boolean isSync) {
1146         if (prot == MAP_INVALID) {
1147             throw new UnsupportedOperationException();
1148         }
1149         if ((mode != MapMode.READ_ONLY) &amp;&amp; mode != ExtendedMapMode.READ_ONLY_SYNC &amp;&amp; !writable)
1150             throw new NonWritableChannelException();
1151         if (!readable)
1152             throw new NonReadableChannelException();
1153         // reject SYNC request if writeback is not enabled for this platform
1154         if (isSync &amp;&amp; !Unsafe.isWritebackEnabled()) {
1155             throw new UnsupportedOperationException();
1156         }
1157     }
1158 
1159     /**
1160      * Invoked by sun.management.ManagementFactoryHelper to create the management
1161      * interface for mapped buffers.
1162      */
<span class="line-modified">1163     public static JavaNioAccess.BufferPool getMappedBufferPool() {</span>
<span class="line-modified">1164         return new JavaNioAccess.BufferPool() {</span>
1165             @Override
1166             public String getName() {
1167                 return &quot;mapped&quot;;
1168             }
1169             @Override
1170             public long getCount() {
1171                 return DefaultUnmapper.count;
1172             }
1173             @Override
1174             public long getTotalCapacity() {
1175                 return DefaultUnmapper.totalCapacity;
1176             }
1177             @Override
1178             public long getMemoryUsed() {
1179                 return DefaultUnmapper.totalSize;
1180             }
1181         };
1182     }
1183 
1184     /**
1185      * Invoked by sun.management.ManagementFactoryHelper to create the management
1186      * interface for sync mapped buffers.
1187      */
<span class="line-modified">1188     public static JavaNioAccess.BufferPool getSyncMappedBufferPool() {</span>
<span class="line-modified">1189         return new JavaNioAccess.BufferPool() {</span>
1190             @Override
1191             public String getName() {
1192                 return &quot;mapped - &#39;non-volatile memory&#39;&quot;;
1193             }
1194             @Override
1195             public long getCount() {
1196                 return SyncUnmapper.count;
1197             }
1198             @Override
1199             public long getTotalCapacity() {
1200                 return SyncUnmapper.totalCapacity;
1201             }
1202             @Override
1203             public long getMemoryUsed() {
1204                 return SyncUnmapper.totalSize;
1205             }
1206         };
1207     }
1208 
1209     // -- Locks --
</pre>
</td>
<td>
<hr />
<pre>
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.io.UncheckedIOException;
  31 import java.lang.ref.Cleaner.Cleanable;
  32 import java.nio.ByteBuffer;
  33 import java.nio.MappedByteBuffer;
  34 import java.nio.channels.AsynchronousCloseException;
  35 import java.nio.channels.ClosedByInterruptException;
  36 import java.nio.channels.ClosedChannelException;
  37 import java.nio.channels.FileChannel;
  38 import java.nio.channels.FileLock;
  39 import java.nio.channels.FileLockInterruptionException;
  40 import java.nio.channels.NonReadableChannelException;
  41 import java.nio.channels.NonWritableChannelException;
  42 import java.nio.channels.ReadableByteChannel;
  43 import java.nio.channels.SelectableChannel;
  44 import java.nio.channels.WritableByteChannel;
  45 import java.util.Objects;
  46 
  47 import jdk.internal.access.JavaIOFileDescriptorAccess;

  48 import jdk.internal.access.SharedSecrets;
  49 import jdk.internal.misc.ExtendedMapMode;
  50 import jdk.internal.misc.Unsafe;
  51 import jdk.internal.misc.VM;
<span class="line-added">  52 import jdk.internal.misc.VM.BufferPool;</span>
  53 import jdk.internal.ref.Cleaner;
  54 import jdk.internal.ref.CleanerFactory;
  55 
  56 import jdk.internal.access.foreign.UnmapperProxy;
  57 
  58 public class FileChannelImpl
  59     extends FileChannel
  60 {
  61     // Memory allocation size for mapping buffers
  62     private static final long allocationGranularity;
  63 
  64     // Access to FileDescriptor internals
  65     private static final JavaIOFileDescriptorAccess fdAccess =
  66         SharedSecrets.getJavaIOFileDescriptorAccess();
  67 
  68     // Used to make native read and write calls
  69     private final FileDispatcher nd;
  70 
  71     // File descriptor
  72     private final FileDescriptor fd;
</pre>
<hr />
<pre>
 223             try {
 224                 beginBlocking();
 225                 ti = threads.add();
 226                 if (!isOpen())
 227                     return 0;
 228                 do {
 229                     n = IOUtil.read(fd, dst, -1, direct, alignment, nd);
 230                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 231                 return IOStatus.normalize(n);
 232             } finally {
 233                 threads.remove(ti);
 234                 endBlocking(n &gt; 0);
 235                 assert IOStatus.check(n);
 236             }
 237         }
 238     }
 239 
 240     public long read(ByteBuffer[] dsts, int offset, int length)
 241         throws IOException
 242     {
<span class="line-modified"> 243         Objects.checkFromIndexSize(offset, length, dsts.length);</span>

 244         ensureOpen();
 245         if (!readable)
 246             throw new NonReadableChannelException();
 247         synchronized (positionLock) {
 248             if (direct)
 249                 Util.checkChannelPositionAligned(position(), alignment);
 250             long n = 0;
 251             int ti = -1;
 252             try {
 253                 beginBlocking();
 254                 ti = threads.add();
 255                 if (!isOpen())
 256                     return 0;
 257                 do {
 258                     n = IOUtil.read(fd, dsts, offset, length,
 259                             direct, alignment, nd);
 260                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 261                 return IOStatus.normalize(n);
 262             } finally {
 263                 threads.remove(ti);
</pre>
<hr />
<pre>
 279             try {
 280                 beginBlocking();
 281                 ti = threads.add();
 282                 if (!isOpen())
 283                     return 0;
 284                 do {
 285                     n = IOUtil.write(fd, src, -1, direct, alignment, nd);
 286                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 287                 return IOStatus.normalize(n);
 288             } finally {
 289                 threads.remove(ti);
 290                 endBlocking(n &gt; 0);
 291                 assert IOStatus.check(n);
 292             }
 293         }
 294     }
 295 
 296     public long write(ByteBuffer[] srcs, int offset, int length)
 297         throws IOException
 298     {
<span class="line-modified"> 299         Objects.checkFromIndexSize(offset, length, srcs.length);</span>

 300         ensureOpen();
 301         if (!writable)
 302             throw new NonWritableChannelException();
 303         synchronized (positionLock) {
 304             if (direct)
 305                 Util.checkChannelPositionAligned(position(), alignment);
 306             long n = 0;
 307             int ti = -1;
 308             try {
 309                 beginBlocking();
 310                 ti = threads.add();
 311                 if (!isOpen())
 312                     return 0;
 313                 do {
 314                     n = IOUtil.write(fd, srcs, offset, length,
 315                             direct, alignment, nd);
 316                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 317                 return IOStatus.normalize(n);
 318             } finally {
 319                 threads.remove(ti);
</pre>
<hr />
<pre>
 770         if (!src.isOpen())
 771             throw new ClosedChannelException();
 772         if (!writable)
 773             throw new NonWritableChannelException();
 774         if ((position &lt; 0) || (count &lt; 0))
 775             throw new IllegalArgumentException();
 776         if (position &gt; size())
 777             return 0;
 778         if (src instanceof FileChannelImpl)
 779            return transferFromFileChannel((FileChannelImpl)src,
 780                                           position, count);
 781 
 782         return transferFromArbitraryChannel(src, position, count);
 783     }
 784 
 785     public int read(ByteBuffer dst, long position) throws IOException {
 786         if (dst == null)
 787             throw new NullPointerException();
 788         if (position &lt; 0)
 789             throw new IllegalArgumentException(&quot;Negative position&quot;);
<span class="line-added"> 790         ensureOpen();</span>
 791         if (!readable)
 792             throw new NonReadableChannelException();
 793         if (direct)
 794             Util.checkChannelPositionAligned(position, alignment);

 795         if (nd.needsPositionLock()) {
 796             synchronized (positionLock) {
 797                 return readInternal(dst, position);
 798             }
 799         } else {
 800             return readInternal(dst, position);
 801         }
 802     }
 803 
 804     private int readInternal(ByteBuffer dst, long position) throws IOException {
 805         assert !nd.needsPositionLock() || Thread.holdsLock(positionLock);
 806         int n = 0;
 807         int ti = -1;
 808 
 809         try {
 810             beginBlocking();
 811             ti = threads.add();
 812             if (!isOpen())
 813                 return -1;
 814             do {
 815                 n = IOUtil.read(fd, dst, position, direct, alignment, nd);
 816             } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 817             return IOStatus.normalize(n);
 818         } finally {
 819             threads.remove(ti);
 820             endBlocking(n &gt; 0);
 821             assert IOStatus.check(n);
 822         }
 823     }
 824 
 825     public int write(ByteBuffer src, long position) throws IOException {
 826         if (src == null)
 827             throw new NullPointerException();
 828         if (position &lt; 0)
 829             throw new IllegalArgumentException(&quot;Negative position&quot;);
<span class="line-added"> 830         ensureOpen();</span>
 831         if (!writable)
 832             throw new NonWritableChannelException();
 833         if (direct)
 834             Util.checkChannelPositionAligned(position, alignment);

 835         if (nd.needsPositionLock()) {
 836             synchronized (positionLock) {
 837                 return writeInternal(src, position);
 838             }
 839         } else {
 840             return writeInternal(src, position);
 841         }
 842     }
 843 
 844     private int writeInternal(ByteBuffer src, long position) throws IOException {
 845         assert !nd.needsPositionLock() || Thread.holdsLock(positionLock);
 846         int n = 0;
 847         int ti = -1;
 848         try {
 849             beginBlocking();
 850             ti = threads.add();
 851             if (!isOpen())
 852                 return -1;
 853             do {
 854                 n = IOUtil.write(fd, src, position, direct, alignment, nd);
</pre>
<hr />
<pre>
1141     }
1142 
1143     private void checkMode(MapMode mode, int prot, boolean isSync) {
1144         if (prot == MAP_INVALID) {
1145             throw new UnsupportedOperationException();
1146         }
1147         if ((mode != MapMode.READ_ONLY) &amp;&amp; mode != ExtendedMapMode.READ_ONLY_SYNC &amp;&amp; !writable)
1148             throw new NonWritableChannelException();
1149         if (!readable)
1150             throw new NonReadableChannelException();
1151         // reject SYNC request if writeback is not enabled for this platform
1152         if (isSync &amp;&amp; !Unsafe.isWritebackEnabled()) {
1153             throw new UnsupportedOperationException();
1154         }
1155     }
1156 
1157     /**
1158      * Invoked by sun.management.ManagementFactoryHelper to create the management
1159      * interface for mapped buffers.
1160      */
<span class="line-modified">1161     public static BufferPool getMappedBufferPool() {</span>
<span class="line-modified">1162         return new BufferPool() {</span>
1163             @Override
1164             public String getName() {
1165                 return &quot;mapped&quot;;
1166             }
1167             @Override
1168             public long getCount() {
1169                 return DefaultUnmapper.count;
1170             }
1171             @Override
1172             public long getTotalCapacity() {
1173                 return DefaultUnmapper.totalCapacity;
1174             }
1175             @Override
1176             public long getMemoryUsed() {
1177                 return DefaultUnmapper.totalSize;
1178             }
1179         };
1180     }
1181 
1182     /**
1183      * Invoked by sun.management.ManagementFactoryHelper to create the management
1184      * interface for sync mapped buffers.
1185      */
<span class="line-modified">1186     public static BufferPool getSyncMappedBufferPool() {</span>
<span class="line-modified">1187         return new BufferPool() {</span>
1188             @Override
1189             public String getName() {
1190                 return &quot;mapped - &#39;non-volatile memory&#39;&quot;;
1191             }
1192             @Override
1193             public long getCount() {
1194                 return SyncUnmapper.count;
1195             }
1196             @Override
1197             public long getTotalCapacity() {
1198                 return SyncUnmapper.totalCapacity;
1199             }
1200             @Override
1201             public long getMemoryUsed() {
1202                 return SyncUnmapper.totalSize;
1203             }
1204         };
1205     }
1206 
1207     // -- Locks --
</pre>
</td>
</tr>
</table>
<center><a href="DatagramSocketAdaptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../security/jca/ProviderConfig.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
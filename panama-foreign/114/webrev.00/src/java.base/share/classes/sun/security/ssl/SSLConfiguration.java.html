<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/SSLConfiguration.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.security.AccessControlContext;
 29 import java.security.AccessController;
 30 import java.security.AlgorithmConstraints;
 31 import java.security.NoSuchAlgorithmException;
 32 import java.util.ArrayList;
 33 import java.util.Arrays;
 34 import java.util.Collection;
 35 import java.util.Collections;
 36 import java.util.HashMap;
 37 import java.util.List;
 38 import java.util.function.BiFunction;
 39 import javax.crypto.KeyGenerator;
 40 import javax.net.ssl.HandshakeCompletedListener;
 41 import javax.net.ssl.SNIMatcher;
 42 import javax.net.ssl.SNIServerName;
 43 import javax.net.ssl.SSLEngine;
 44 import javax.net.ssl.SSLParameters;
 45 import javax.net.ssl.SSLSocket;
 46 import sun.security.ssl.SSLExtension.ClientExtensions;
 47 import sun.security.ssl.SSLExtension.ServerExtensions;
 48 
 49 /**
 50  * SSL/(D)TLS configuration.
 51  */
 52 final class SSLConfiguration implements Cloneable {
 53     // configurations with SSLParameters
 54     AlgorithmConstraints        userSpecifiedAlgorithmConstraints;
 55     List&lt;ProtocolVersion&gt;       enabledProtocols;
 56     List&lt;CipherSuite&gt;           enabledCipherSuites;
 57     ClientAuthType              clientAuthType;
 58     String                      identificationProtocol;
 59     List&lt;SNIServerName&gt;         serverNames;
 60     Collection&lt;SNIMatcher&gt;      sniMatchers;
 61     String[]                    applicationProtocols;
 62     boolean                     preferLocalCipherSuites;
 63     boolean                     enableRetransmissions;
 64     int                         maximumPacketSize;
 65 
 66     // the maximum protocol version of enabled protocols
 67     ProtocolVersion             maximumProtocolVersion;
 68 
 69     // Configurations per SSLSocket or SSLEngine instance.
 70     boolean                     isClientMode;
 71     boolean                     enableSessionCreation;
 72 
 73     // the application layer protocol negotiation configuration
 74     BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt; socketAPSelector;
 75     BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt; engineAPSelector;
 76 
 77     HashMap&lt;HandshakeCompletedListener, AccessControlContext&gt;
 78                                 handshakeListeners;
 79 
 80     boolean                     noSniExtension;
 81     boolean                     noSniMatcher;
 82 
 83     // To switch off the extended_master_secret extension.
 84     static final boolean useExtendedMasterSecret;
 85 
 86     // Allow session resumption without Extended Master Secret extension.
 87     static final boolean allowLegacyResumption =
 88         Utilities.getBooleanProperty(&quot;jdk.tls.allowLegacyResumption&quot;, true);
 89 
 90     // Allow full handshake without Extended Master Secret extension.
 91     static final boolean allowLegacyMasterSecret =
 92         Utilities.getBooleanProperty(&quot;jdk.tls.allowLegacyMasterSecret&quot;, true);
 93 
 94     // Allow full handshake without Extended Master Secret extension.
 95     static final boolean useCompatibilityMode = Utilities.getBooleanProperty(
 96             &quot;jdk.tls.client.useCompatibilityMode&quot;, true);
 97 
 98     // Respond a close_notify alert if receiving close_notify alert.
 99     static final boolean acknowledgeCloseNotify  = Utilities.getBooleanProperty(
100             &quot;jdk.tls.acknowledgeCloseNotify&quot;, false);
101 
102     // Is the extended_master_secret extension supported?
103     static {
104         boolean supportExtendedMasterSecret = Utilities.getBooleanProperty(
105                     &quot;jdk.tls.useExtendedMasterSecret&quot;, true);
106         if (supportExtendedMasterSecret) {
107             try {
108                 KeyGenerator.getInstance(&quot;SunTlsExtendedMasterSecret&quot;);
109             } catch (NoSuchAlgorithmException nae) {
110                 supportExtendedMasterSecret = false;
111             }
112         }
113         useExtendedMasterSecret = supportExtendedMasterSecret;
114     }
115 
116     SSLConfiguration(SSLContextImpl sslContext, boolean isClientMode) {
117 
118         // Configurations with SSLParameters, default values.
119         this.userSpecifiedAlgorithmConstraints =
120                 SSLAlgorithmConstraints.DEFAULT;
121         this.enabledProtocols =
122                 sslContext.getDefaultProtocolVersions(!isClientMode);
123         this.enabledCipherSuites =
124                 sslContext.getDefaultCipherSuites(!isClientMode);
125         this.clientAuthType = ClientAuthType.CLIENT_AUTH_NONE;
126 
127         this.identificationProtocol = null;
128         this.serverNames = Collections.&lt;SNIServerName&gt;emptyList();
129         this.sniMatchers = Collections.&lt;SNIMatcher&gt;emptyList();
130         this.preferLocalCipherSuites = true;
131 
132         this.applicationProtocols = new String[0];
133         this.enableRetransmissions = sslContext.isDTLS();
134         this.maximumPacketSize = 0;         // please reset it explicitly later
135 
136         this.maximumProtocolVersion = ProtocolVersion.NONE;
137         for (ProtocolVersion pv : enabledProtocols) {
138             if (pv.compareTo(maximumProtocolVersion) &gt; 0) {
139                 this.maximumProtocolVersion = pv;
140             }
141         }
142 
143         // Configurations per SSLSocket or SSLEngine instance.
144         this.isClientMode = isClientMode;
145         this.enableSessionCreation = true;
146         this.socketAPSelector = null;
147         this.engineAPSelector = null;
148 
149         this.handshakeListeners = null;
150         this.noSniExtension = false;
151         this.noSniMatcher = false;
152     }
153 
154     SSLParameters getSSLParameters() {
155         SSLParameters params = new SSLParameters();
156 
157         params.setAlgorithmConstraints(this.userSpecifiedAlgorithmConstraints);
158         params.setProtocols(ProtocolVersion.toStringArray(enabledProtocols));
159         params.setCipherSuites(CipherSuite.namesOf(enabledCipherSuites));
160         switch (this.clientAuthType) {
161             case CLIENT_AUTH_REQUIRED:
162                 params.setNeedClientAuth(true);
163                 break;
164             case CLIENT_AUTH_REQUESTED:
165                 params.setWantClientAuth(true);
166                 break;
167             default:
168                 params.setWantClientAuth(false);
169         }
170         params.setEndpointIdentificationAlgorithm(this.identificationProtocol);
171 
172         if (serverNames.isEmpty() &amp;&amp; !noSniExtension) {
173             // &#39;null&#39; indicates none has been set
174             params.setServerNames(null);
175         } else {
176             params.setServerNames(this.serverNames);
177         }
178 
179         if (sniMatchers.isEmpty() &amp;&amp; !noSniMatcher) {
180             // &#39;null&#39; indicates none has been set
181             params.setSNIMatchers(null);
182         } else {
183             params.setSNIMatchers(this.sniMatchers);
184         }
185 
186         params.setApplicationProtocols(this.applicationProtocols);
187         params.setUseCipherSuitesOrder(this.preferLocalCipherSuites);
188         params.setEnableRetransmissions(this.enableRetransmissions);
189         params.setMaximumPacketSize(this.maximumPacketSize);
190 
191         return params;
192     }
193 
194     void setSSLParameters(SSLParameters params) {
195         AlgorithmConstraints ac = params.getAlgorithmConstraints();
196         if (ac != null) {
197             this.userSpecifiedAlgorithmConstraints = ac;
198         }   // otherwise, use the default value
199 
200         String[] sa = params.getCipherSuites();
201         if (sa != null) {
202             this.enabledCipherSuites = CipherSuite.validValuesOf(sa);
203         }   // otherwise, use the default values
204 
205         sa = params.getProtocols();
206         if (sa != null) {
207             this.enabledProtocols = ProtocolVersion.namesOf(sa);
208 
209             this.maximumProtocolVersion = ProtocolVersion.NONE;
210             for (ProtocolVersion pv : enabledProtocols) {
211                 if (pv.compareTo(maximumProtocolVersion) &gt; 0) {
212                     this.maximumProtocolVersion = pv;
213                 }
214             }
215         }   // otherwise, use the default values
216 
217         if (params.getNeedClientAuth()) {
218             this.clientAuthType = ClientAuthType.CLIENT_AUTH_REQUIRED;
219         } else if (params.getWantClientAuth()) {
220             this.clientAuthType = ClientAuthType.CLIENT_AUTH_REQUESTED;
221         } else {
222             this.clientAuthType = ClientAuthType.CLIENT_AUTH_NONE;
223         }
224 
225         String s = params.getEndpointIdentificationAlgorithm();
226         if (s != null) {
227             this.identificationProtocol = s;
228         }   // otherwise, use the default value
229 
230         List&lt;SNIServerName&gt; sniNames = params.getServerNames();
231         if (sniNames != null) {
232             this.noSniExtension = sniNames.isEmpty();
233             this.serverNames = sniNames;
234         }   // null if none has been set
235 
236         Collection&lt;SNIMatcher&gt; matchers = params.getSNIMatchers();
237         if (matchers != null) {
238             this.noSniMatcher = matchers.isEmpty();
239             this.sniMatchers = matchers;
240         }   // null if none has been set
241 
242         sa = params.getApplicationProtocols();
243         if (sa != null) {
244             this.applicationProtocols = sa;
245         }   // otherwise, use the default values
246 
247         this.preferLocalCipherSuites = params.getUseCipherSuitesOrder();
248         this.enableRetransmissions = params.getEnableRetransmissions();
249         this.maximumPacketSize = params.getMaximumPacketSize();
250     }
251 
252     // SSLSocket only
253     void addHandshakeCompletedListener(
254             HandshakeCompletedListener listener) {
255 
256         if (handshakeListeners == null) {
257             handshakeListeners = new HashMap&lt;&gt;(4);
258         }
259 
260         handshakeListeners.put(listener, AccessController.getContext());
261     }
262 
263     // SSLSocket only
264     void removeHandshakeCompletedListener(
265             HandshakeCompletedListener listener) {
266 
267         if (handshakeListeners == null) {
268             throw new IllegalArgumentException(&quot;no listeners&quot;);
269         }
270 
271         if (handshakeListeners.remove(listener) == null) {
272             throw new IllegalArgumentException(&quot;listener not registered&quot;);
273         }
274 
275         if (handshakeListeners.isEmpty()) {
276             handshakeListeners = null;
277         }
278     }
279 
280     /**
281      * Return true if the extension is available.
282      */
283     boolean isAvailable(SSLExtension extension) {
284         for (ProtocolVersion protocolVersion : enabledProtocols) {
285             if (extension.isAvailable(protocolVersion)) {
286                 if (isClientMode ?
287                         ClientExtensions.defaults.contains(extension) :
288                         ServerExtensions.defaults.contains(extension)) {
289                     return true;
290                 }
291             }
292         }
293 
294         return false;
295     }
296 
297     /**
298      * Return true if the extension is available for the specific protocol.
299      */
300     boolean isAvailable(SSLExtension extension,
301             ProtocolVersion protocolVersion) {
302         return extension.isAvailable(protocolVersion) &amp;&amp;
303                 (isClientMode ? ClientExtensions.defaults.contains(extension) :
304                                 ServerExtensions.defaults.contains(extension));
305     }
306 
307     /**
308      * Get the enabled extensions for the specific handshake message.
309      *
310      * Used to consume handshake extensions.
311      */
312     SSLExtension[] getEnabledExtensions(SSLHandshake handshakeType) {
313         List&lt;SSLExtension&gt; extensions = new ArrayList&lt;&gt;();
314         for (SSLExtension extension : SSLExtension.values()) {
315             if (extension.handshakeType == handshakeType) {
316                 if (isAvailable(extension)) {
317                     extensions.add(extension);
318                 }
319             }
320         }
321 
322         return extensions.toArray(new SSLExtension[0]);
323     }
324 
325     /**
326      * Get the enabled extensions for the specific handshake message, excluding
327      * the specified extensions.
328      *
329      * Used to consume handshake extensions.
330      */
331     SSLExtension[] getExclusiveExtensions(SSLHandshake handshakeType,
332             List&lt;SSLExtension&gt; excluded) {
333         List&lt;SSLExtension&gt; extensions = new ArrayList&lt;&gt;();
334         for (SSLExtension extension : SSLExtension.values()) {
335             if (extension.handshakeType == handshakeType) {
336                 if (isAvailable(extension) &amp;&amp; !excluded.contains(extension)) {
337                     extensions.add(extension);
338                 }
339             }
340         }
341 
342         return extensions.toArray(new SSLExtension[0]);
343     }
344 
345     /**
346      * Get the enabled extensions for the specific handshake message
347      * and the specific protocol version.
348      *
349      * Used to produce handshake extensions after handshake protocol
350      * version negotiation.
351      */
352     SSLExtension[] getEnabledExtensions(
353             SSLHandshake handshakeType, ProtocolVersion protocolVersion) {
354         return getEnabledExtensions(
355             handshakeType, Arrays.asList(protocolVersion));
356     }
357 
358     /**
359      * Get the enabled extensions for the specific handshake message
360      * and the specific protocol versions.
361      *
362      * Used to produce ClientHello extensions before handshake protocol
363      * version negotiation.
364      */
365     SSLExtension[] getEnabledExtensions(
366             SSLHandshake handshakeType, List&lt;ProtocolVersion&gt; activeProtocols) {
367         List&lt;SSLExtension&gt; extensions = new ArrayList&lt;&gt;();
368         for (SSLExtension extension : SSLExtension.values()) {
369             if (extension.handshakeType == handshakeType) {
370                 if (!isAvailable(extension)) {
371                     continue;
372                 }
373 
374                 for (ProtocolVersion protocolVersion : activeProtocols) {
375                     if (extension.isAvailable(protocolVersion)) {
376                         extensions.add(extension);
377                         break;
378                     }
379                 }
380             }
381         }
382 
383         return extensions.toArray(new SSLExtension[0]);
384     }
385 
386     @Override
387     @SuppressWarnings({&quot;unchecked&quot;, &quot;CloneDeclaresCloneNotSupported&quot;})
388     public Object clone() {
389         // Note that only references to the configurations are copied.
390         try {
391             SSLConfiguration config = (SSLConfiguration)super.clone();
392             if (handshakeListeners != null) {
393                 config.handshakeListeners =
394                     (HashMap&lt;HandshakeCompletedListener, AccessControlContext&gt;)
395                             handshakeListeners.clone();
396             }
397 
398             return config;
399         } catch (CloneNotSupportedException cnse) {
400             // unlikely
401         }
402 
403         return null;    // unlikely
404     }
405 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.io.UncheckedIOException;
  31 import java.lang.ref.Cleaner.Cleanable;
  32 import java.nio.ByteBuffer;
  33 import java.nio.MappedByteBuffer;
  34 import java.nio.channels.AsynchronousCloseException;
  35 import java.nio.channels.ClosedByInterruptException;
  36 import java.nio.channels.ClosedChannelException;
  37 import java.nio.channels.FileChannel;
  38 import java.nio.channels.FileLock;
  39 import java.nio.channels.FileLockInterruptionException;
  40 import java.nio.channels.NonReadableChannelException;
  41 import java.nio.channels.NonWritableChannelException;
  42 import java.nio.channels.ReadableByteChannel;
  43 import java.nio.channels.SelectableChannel;
  44 import java.nio.channels.WritableByteChannel;
  45 import java.util.Objects;
  46 
  47 import jdk.internal.access.JavaIOFileDescriptorAccess;
  48 import jdk.internal.access.SharedSecrets;
  49 import jdk.internal.misc.ExtendedMapMode;
  50 import jdk.internal.misc.Unsafe;
  51 import jdk.internal.misc.VM;
  52 import jdk.internal.misc.VM.BufferPool;
  53 import jdk.internal.ref.Cleaner;
  54 import jdk.internal.ref.CleanerFactory;
  55 
  56 import jdk.internal.access.foreign.UnmapperProxy;
  57 
  58 public class FileChannelImpl
  59     extends FileChannel
  60 {
  61     // Memory allocation size for mapping buffers
  62     private static final long allocationGranularity;
  63 
  64     // Access to FileDescriptor internals
  65     private static final JavaIOFileDescriptorAccess fdAccess =
  66         SharedSecrets.getJavaIOFileDescriptorAccess();
  67 
  68     // Used to make native read and write calls
  69     private final FileDispatcher nd;
  70 
  71     // File descriptor
  72     private final FileDescriptor fd;
  73 
  74     // File access mode (immutable)
  75     private final boolean writable;
  76     private final boolean readable;
  77 
  78     // Required to prevent finalization of creating stream (immutable)
  79     private final Object parent;
  80 
  81     // The path of the referenced file
  82     // (null if the parent stream is created with a file descriptor)
  83     private final String path;
  84 
  85     // Thread-safe set of IDs of native threads, for signalling
  86     private final NativeThreadSet threads = new NativeThreadSet(2);
  87 
  88     // Lock for operations involving position and size
  89     private final Object positionLock = new Object();
  90 
  91     // blocking operations are not interruptible
  92     private volatile boolean uninterruptible;
  93 
  94     // DirectIO flag
  95     private final boolean direct;
  96 
  97     // IO alignment value for DirectIO
  98     private final int alignment;
  99 
 100     // Cleanable with an action which closes this channel&#39;s file descriptor
 101     private final Cleanable closer;
 102 
 103     private static class Closer implements Runnable {
 104         private final FileDescriptor fd;
 105 
 106         Closer(FileDescriptor fd) {
 107             this.fd = fd;
 108         }
 109 
 110         public void run() {
 111             try {
 112                 fdAccess.close(fd);
 113             } catch (IOException ioe) {
 114                 // Rethrow as unchecked so the exception can be propagated as needed
 115                 throw new UncheckedIOException(&quot;close&quot;, ioe);
 116             }
 117         }
 118     }
 119 
 120     private FileChannelImpl(FileDescriptor fd, String path, boolean readable,
 121                             boolean writable, boolean direct, Object parent)
 122     {
 123         this.fd = fd;
 124         this.readable = readable;
 125         this.writable = writable;
 126         this.parent = parent;
 127         this.path = path;
 128         this.direct = direct;
 129         this.nd = new FileDispatcherImpl();
 130         if (direct) {
 131             assert path != null;
 132             this.alignment = nd.setDirectIO(fd, path);
 133         } else {
 134             this.alignment = -1;
 135         }
 136 
 137         // Register a cleaning action if and only if there is no parent
 138         // as the parent will take care of closing the file descriptor.
 139         // FileChannel is used by the LambdaMetaFactory so a lambda cannot
 140         // be used here hence we use a nested class instead.
 141         this.closer = parent != null ? null :
 142             CleanerFactory.cleaner().register(this, new Closer(fd));
 143     }
 144 
 145     // Used by FileInputStream.getChannel(), FileOutputStream.getChannel
 146     // and RandomAccessFile.getChannel()
 147     public static FileChannel open(FileDescriptor fd, String path,
 148                                    boolean readable, boolean writable,
 149                                    boolean direct, Object parent)
 150     {
 151         return new FileChannelImpl(fd, path, readable, writable, direct, parent);
 152     }
 153 
 154     private void ensureOpen() throws IOException {
 155         if (!isOpen())
 156             throw new ClosedChannelException();
 157     }
 158 
 159     public void setUninterruptible() {
 160         uninterruptible = true;
 161     }
 162 
 163     private void beginBlocking() {
 164         if (!uninterruptible) begin();
 165     }
 166 
 167     private void endBlocking(boolean completed) throws AsynchronousCloseException {
 168         if (!uninterruptible) end(completed);
 169     }
 170 
 171     // -- Standard channel operations --
 172 
 173     protected void implCloseChannel() throws IOException {
 174         if (!fd.valid())
 175             return; // nothing to do
 176 
 177         // Release and invalidate any locks that we still hold
 178         if (fileLockTable != null) {
 179             for (FileLock fl: fileLockTable.removeAll()) {
 180                 synchronized (fl) {
 181                     if (fl.isValid()) {
 182                         nd.release(fd, fl.position(), fl.size());
 183                         ((FileLockImpl)fl).invalidate();
 184                     }
 185                 }
 186             }
 187         }
 188 
 189         // signal any threads blocked on this channel
 190         threads.signalAndWait();
 191 
 192         if (parent != null) {
 193 
 194             // Close the fd via the parent stream&#39;s close method.  The parent
 195             // will reinvoke our close method, which is defined in the
 196             // superclass AbstractInterruptibleChannel, but the isOpen logic in
 197             // that method will prevent this method from being reinvoked.
 198             //
 199             ((java.io.Closeable)parent).close();
 200         } else if (closer != null) {
 201             // Perform the cleaning action so it is not redone when
 202             // this channel becomes phantom reachable.
 203             try {
 204                 closer.clean();
 205             } catch (UncheckedIOException uioe) {
 206                 throw uioe.getCause();
 207             }
 208         } else {
 209             fdAccess.close(fd);
 210         }
 211 
 212     }
 213 
 214     public int read(ByteBuffer dst) throws IOException {
 215         ensureOpen();
 216         if (!readable)
 217             throw new NonReadableChannelException();
 218         synchronized (positionLock) {
 219             if (direct)
 220                 Util.checkChannelPositionAligned(position(), alignment);
 221             int n = 0;
 222             int ti = -1;
 223             try {
 224                 beginBlocking();
 225                 ti = threads.add();
 226                 if (!isOpen())
 227                     return 0;
 228                 do {
 229                     n = IOUtil.read(fd, dst, -1, direct, alignment, nd);
 230                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 231                 return IOStatus.normalize(n);
 232             } finally {
 233                 threads.remove(ti);
 234                 endBlocking(n &gt; 0);
 235                 assert IOStatus.check(n);
 236             }
 237         }
 238     }
 239 
 240     public long read(ByteBuffer[] dsts, int offset, int length)
 241         throws IOException
 242     {
 243         Objects.checkFromIndexSize(offset, length, dsts.length);
 244         ensureOpen();
 245         if (!readable)
 246             throw new NonReadableChannelException();
 247         synchronized (positionLock) {
 248             if (direct)
 249                 Util.checkChannelPositionAligned(position(), alignment);
 250             long n = 0;
 251             int ti = -1;
 252             try {
 253                 beginBlocking();
 254                 ti = threads.add();
 255                 if (!isOpen())
 256                     return 0;
 257                 do {
 258                     n = IOUtil.read(fd, dsts, offset, length,
 259                             direct, alignment, nd);
 260                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 261                 return IOStatus.normalize(n);
 262             } finally {
 263                 threads.remove(ti);
 264                 endBlocking(n &gt; 0);
 265                 assert IOStatus.check(n);
 266             }
 267         }
 268     }
 269 
 270     public int write(ByteBuffer src) throws IOException {
 271         ensureOpen();
 272         if (!writable)
 273             throw new NonWritableChannelException();
 274         synchronized (positionLock) {
 275             if (direct)
 276                 Util.checkChannelPositionAligned(position(), alignment);
 277             int n = 0;
 278             int ti = -1;
 279             try {
 280                 beginBlocking();
 281                 ti = threads.add();
 282                 if (!isOpen())
 283                     return 0;
 284                 do {
 285                     n = IOUtil.write(fd, src, -1, direct, alignment, nd);
 286                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 287                 return IOStatus.normalize(n);
 288             } finally {
 289                 threads.remove(ti);
 290                 endBlocking(n &gt; 0);
 291                 assert IOStatus.check(n);
 292             }
 293         }
 294     }
 295 
 296     public long write(ByteBuffer[] srcs, int offset, int length)
 297         throws IOException
 298     {
 299         Objects.checkFromIndexSize(offset, length, srcs.length);
 300         ensureOpen();
 301         if (!writable)
 302             throw new NonWritableChannelException();
 303         synchronized (positionLock) {
 304             if (direct)
 305                 Util.checkChannelPositionAligned(position(), alignment);
 306             long n = 0;
 307             int ti = -1;
 308             try {
 309                 beginBlocking();
 310                 ti = threads.add();
 311                 if (!isOpen())
 312                     return 0;
 313                 do {
 314                     n = IOUtil.write(fd, srcs, offset, length,
 315                             direct, alignment, nd);
 316                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 317                 return IOStatus.normalize(n);
 318             } finally {
 319                 threads.remove(ti);
 320                 endBlocking(n &gt; 0);
 321                 assert IOStatus.check(n);
 322             }
 323         }
 324     }
 325 
 326     // -- Other operations --
 327 
 328     public long position() throws IOException {
 329         ensureOpen();
 330         synchronized (positionLock) {
 331             long p = -1;
 332             int ti = -1;
 333             try {
 334                 beginBlocking();
 335                 ti = threads.add();
 336                 if (!isOpen())
 337                     return 0;
 338                 boolean append = fdAccess.getAppend(fd);
 339                 do {
 340                     // in append-mode then position is advanced to end before writing
 341                     p = (append) ? nd.size(fd) : nd.seek(fd, -1);
 342                 } while ((p == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 343                 return IOStatus.normalize(p);
 344             } finally {
 345                 threads.remove(ti);
 346                 endBlocking(p &gt; -1);
 347                 assert IOStatus.check(p);
 348             }
 349         }
 350     }
 351 
 352     public FileChannel position(long newPosition) throws IOException {
 353         ensureOpen();
 354         if (newPosition &lt; 0)
 355             throw new IllegalArgumentException();
 356         synchronized (positionLock) {
 357             long p = -1;
 358             int ti = -1;
 359             try {
 360                 beginBlocking();
 361                 ti = threads.add();
 362                 if (!isOpen())
 363                     return null;
 364                 do {
 365                     p = nd.seek(fd, newPosition);
 366                 } while ((p == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 367                 return this;
 368             } finally {
 369                 threads.remove(ti);
 370                 endBlocking(p &gt; -1);
 371                 assert IOStatus.check(p);
 372             }
 373         }
 374     }
 375 
 376     public long size() throws IOException {
 377         ensureOpen();
 378         synchronized (positionLock) {
 379             long s = -1;
 380             int ti = -1;
 381             try {
 382                 beginBlocking();
 383                 ti = threads.add();
 384                 if (!isOpen())
 385                     return -1;
 386                 do {
 387                     s = nd.size(fd);
 388                 } while ((s == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 389                 return IOStatus.normalize(s);
 390             } finally {
 391                 threads.remove(ti);
 392                 endBlocking(s &gt; -1);
 393                 assert IOStatus.check(s);
 394             }
 395         }
 396     }
 397 
 398     public FileChannel truncate(long newSize) throws IOException {
 399         ensureOpen();
 400         if (newSize &lt; 0)
 401             throw new IllegalArgumentException(&quot;Negative size&quot;);
 402         if (!writable)
 403             throw new NonWritableChannelException();
 404         synchronized (positionLock) {
 405             int rv = -1;
 406             long p = -1;
 407             int ti = -1;
 408             long rp = -1;
 409             try {
 410                 beginBlocking();
 411                 ti = threads.add();
 412                 if (!isOpen())
 413                     return null;
 414 
 415                 // get current size
 416                 long size;
 417                 do {
 418                     size = nd.size(fd);
 419                 } while ((size == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 420                 if (!isOpen())
 421                     return null;
 422 
 423                 // get current position
 424                 do {
 425                     p = nd.seek(fd, -1);
 426                 } while ((p == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 427                 if (!isOpen())
 428                     return null;
 429                 assert p &gt;= 0;
 430 
 431                 // truncate file if given size is less than the current size
 432                 if (newSize &lt; size) {
 433                     do {
 434                         rv = nd.truncate(fd, newSize);
 435                     } while ((rv == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 436                     if (!isOpen())
 437                         return null;
 438                 }
 439 
 440                 // if position is beyond new size then adjust it
 441                 if (p &gt; newSize)
 442                     p = newSize;
 443                 do {
 444                     rp = nd.seek(fd, p);
 445                 } while ((rp == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 446                 return this;
 447             } finally {
 448                 threads.remove(ti);
 449                 endBlocking(rv &gt; -1);
 450                 assert IOStatus.check(rv);
 451             }
 452         }
 453     }
 454 
 455     public void force(boolean metaData) throws IOException {
 456         ensureOpen();
 457         int rv = -1;
 458         int ti = -1;
 459         try {
 460             beginBlocking();
 461             ti = threads.add();
 462             if (!isOpen())
 463                 return;
 464             do {
 465                 rv = nd.force(fd, metaData);
 466             } while ((rv == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 467         } finally {
 468             threads.remove(ti);
 469             endBlocking(rv &gt; -1);
 470             assert IOStatus.check(rv);
 471         }
 472     }
 473 
 474     // Assume at first that the underlying kernel supports sendfile();
 475     // set this to false if we find out later that it doesn&#39;t
 476     //
 477     private static volatile boolean transferSupported = true;
 478 
 479     // Assume that the underlying kernel sendfile() will work if the target
 480     // fd is a pipe; set this to false if we find out later that it doesn&#39;t
 481     //
 482     private static volatile boolean pipeSupported = true;
 483 
 484     // Assume that the underlying kernel sendfile() will work if the target
 485     // fd is a file; set this to false if we find out later that it doesn&#39;t
 486     //
 487     private static volatile boolean fileSupported = true;
 488 
 489     private long transferToDirectlyInternal(long position, int icount,
 490                                             WritableByteChannel target,
 491                                             FileDescriptor targetFD)
 492         throws IOException
 493     {
 494         assert !nd.transferToDirectlyNeedsPositionLock() ||
 495                Thread.holdsLock(positionLock);
 496 
 497         long n = -1;
 498         int ti = -1;
 499         try {
 500             beginBlocking();
 501             ti = threads.add();
 502             if (!isOpen())
 503                 return -1;
 504             do {
 505                 n = transferTo0(fd, position, icount, targetFD);
 506             } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 507             if (n == IOStatus.UNSUPPORTED_CASE) {
 508                 if (target instanceof SinkChannelImpl)
 509                     pipeSupported = false;
 510                 if (target instanceof FileChannelImpl)
 511                     fileSupported = false;
 512                 return IOStatus.UNSUPPORTED_CASE;
 513             }
 514             if (n == IOStatus.UNSUPPORTED) {
 515                 // Don&#39;t bother trying again
 516                 transferSupported = false;
 517                 return IOStatus.UNSUPPORTED;
 518             }
 519             return IOStatus.normalize(n);
 520         } finally {
 521             threads.remove(ti);
 522             end (n &gt; -1);
 523         }
 524     }
 525 
 526     private long transferToDirectly(long position, int icount,
 527                                     WritableByteChannel target)
 528         throws IOException
 529     {
 530         if (!transferSupported)
 531             return IOStatus.UNSUPPORTED;
 532 
 533         FileDescriptor targetFD = null;
 534         if (target instanceof FileChannelImpl) {
 535             if (!fileSupported)
 536                 return IOStatus.UNSUPPORTED_CASE;
 537             targetFD = ((FileChannelImpl)target).fd;
 538         } else if (target instanceof SelChImpl) {
 539             // Direct transfer to pipe causes EINVAL on some configurations
 540             if ((target instanceof SinkChannelImpl) &amp;&amp; !pipeSupported)
 541                 return IOStatus.UNSUPPORTED_CASE;
 542 
 543             // Platform-specific restrictions. Now there is only one:
 544             // Direct transfer to non-blocking channel could be forbidden
 545             SelectableChannel sc = (SelectableChannel)target;
 546             if (!nd.canTransferToDirectly(sc))
 547                 return IOStatus.UNSUPPORTED_CASE;
 548 
 549             targetFD = ((SelChImpl)target).getFD();
 550         }
 551 
 552         if (targetFD == null)
 553             return IOStatus.UNSUPPORTED;
 554         int thisFDVal = IOUtil.fdVal(fd);
 555         int targetFDVal = IOUtil.fdVal(targetFD);
 556         if (thisFDVal == targetFDVal) // Not supported on some configurations
 557             return IOStatus.UNSUPPORTED;
 558 
 559         if (nd.transferToDirectlyNeedsPositionLock()) {
 560             synchronized (positionLock) {
 561                 long pos = position();
 562                 try {
 563                     return transferToDirectlyInternal(position, icount,
 564                                                       target, targetFD);
 565                 } finally {
 566                     position(pos);
 567                 }
 568             }
 569         } else {
 570             return transferToDirectlyInternal(position, icount, target, targetFD);
 571         }
 572     }
 573 
 574     // Maximum size to map when using a mapped buffer
 575     private static final long MAPPED_TRANSFER_SIZE = 8L*1024L*1024L;
 576 
 577     private long transferToTrustedChannel(long position, long count,
 578                                           WritableByteChannel target)
 579         throws IOException
 580     {
 581         boolean isSelChImpl = (target instanceof SelChImpl);
 582         if (!((target instanceof FileChannelImpl) || isSelChImpl))
 583             return IOStatus.UNSUPPORTED;
 584 
 585         // Trusted target: Use a mapped buffer
 586         long remaining = count;
 587         while (remaining &gt; 0L) {
 588             long size = Math.min(remaining, MAPPED_TRANSFER_SIZE);
 589             try {
 590                 MappedByteBuffer dbb = map(MapMode.READ_ONLY, position, size);
 591                 try {
 592                     // ## Bug: Closing this channel will not terminate the write
 593                     int n = target.write(dbb);
 594                     assert n &gt;= 0;
 595                     remaining -= n;
 596                     if (isSelChImpl) {
 597                         // one attempt to write to selectable channel
 598                         break;
 599                     }
 600                     assert n &gt; 0;
 601                     position += n;
 602                 } finally {
 603                     unmap(dbb);
 604                 }
 605             } catch (ClosedByInterruptException e) {
 606                 // target closed by interrupt as ClosedByInterruptException needs
 607                 // to be thrown after closing this channel.
 608                 assert !target.isOpen();
 609                 try {
 610                     close();
 611                 } catch (Throwable suppressed) {
 612                     e.addSuppressed(suppressed);
 613                 }
 614                 throw e;
 615             } catch (IOException ioe) {
 616                 // Only throw exception if no bytes have been written
 617                 if (remaining == count)
 618                     throw ioe;
 619                 break;
 620             }
 621         }
 622         return count - remaining;
 623     }
 624 
 625     private long transferToArbitraryChannel(long position, int icount,
 626                                             WritableByteChannel target)
 627         throws IOException
 628     {
 629         // Untrusted target: Use a newly-erased buffer
 630         int c = Math.min(icount, TRANSFER_SIZE);
 631         ByteBuffer bb = ByteBuffer.allocate(c);
 632         long tw = 0;                    // Total bytes written
 633         long pos = position;
 634         try {
 635             while (tw &lt; icount) {
 636                 bb.limit(Math.min((int)(icount - tw), TRANSFER_SIZE));
 637                 int nr = read(bb, pos);
 638                 if (nr &lt;= 0)
 639                     break;
 640                 bb.flip();
 641                 // ## Bug: Will block writing target if this channel
 642                 // ##      is asynchronously closed
 643                 int nw = target.write(bb);
 644                 tw += nw;
 645                 if (nw != nr)
 646                     break;
 647                 pos += nw;
 648                 bb.clear();
 649             }
 650             return tw;
 651         } catch (IOException x) {
 652             if (tw &gt; 0)
 653                 return tw;
 654             throw x;
 655         }
 656     }
 657 
 658     public long transferTo(long position, long count,
 659                            WritableByteChannel target)
 660         throws IOException
 661     {
 662         ensureOpen();
 663         if (!target.isOpen())
 664             throw new ClosedChannelException();
 665         if (!readable)
 666             throw new NonReadableChannelException();
 667         if (target instanceof FileChannelImpl &amp;&amp;
 668             !((FileChannelImpl)target).writable)
 669             throw new NonWritableChannelException();
 670         if ((position &lt; 0) || (count &lt; 0))
 671             throw new IllegalArgumentException();
 672         long sz = size();
 673         if (position &gt; sz)
 674             return 0;
 675         int icount = (int)Math.min(count, Integer.MAX_VALUE);
 676         if ((sz - position) &lt; icount)
 677             icount = (int)(sz - position);
 678 
 679         long n;
 680 
 681         // Attempt a direct transfer, if the kernel supports it
 682         if ((n = transferToDirectly(position, icount, target)) &gt;= 0)
 683             return n;
 684 
 685         // Attempt a mapped transfer, but only to trusted channel types
 686         if ((n = transferToTrustedChannel(position, icount, target)) &gt;= 0)
 687             return n;
 688 
 689         // Slow path for untrusted targets
 690         return transferToArbitraryChannel(position, icount, target);
 691     }
 692 
 693     private long transferFromFileChannel(FileChannelImpl src,
 694                                          long position, long count)
 695         throws IOException
 696     {
 697         if (!src.readable)
 698             throw new NonReadableChannelException();
 699         synchronized (src.positionLock) {
 700             long pos = src.position();
 701             long max = Math.min(count, src.size() - pos);
 702 
 703             long remaining = max;
 704             long p = pos;
 705             while (remaining &gt; 0L) {
 706                 long size = Math.min(remaining, MAPPED_TRANSFER_SIZE);
 707                 // ## Bug: Closing this channel will not terminate the write
 708                 MappedByteBuffer bb = src.map(MapMode.READ_ONLY, p, size);
 709                 try {
 710                     long n = write(bb, position);
 711                     assert n &gt; 0;
 712                     p += n;
 713                     position += n;
 714                     remaining -= n;
 715                 } catch (IOException ioe) {
 716                     // Only throw exception if no bytes have been written
 717                     if (remaining == max)
 718                         throw ioe;
 719                     break;
 720                 } finally {
 721                     unmap(bb);
 722                 }
 723             }
 724             long nwritten = max - remaining;
 725             src.position(pos + nwritten);
 726             return nwritten;
 727         }
 728     }
 729 
 730     private static final int TRANSFER_SIZE = 8192;
 731 
 732     private long transferFromArbitraryChannel(ReadableByteChannel src,
 733                                               long position, long count)
 734         throws IOException
 735     {
 736         // Untrusted target: Use a newly-erased buffer
 737         int c = (int)Math.min(count, TRANSFER_SIZE);
 738         ByteBuffer bb = ByteBuffer.allocate(c);
 739         long tw = 0;                    // Total bytes written
 740         long pos = position;
 741         try {
 742             while (tw &lt; count) {
 743                 bb.limit((int)Math.min((count - tw), (long)TRANSFER_SIZE));
 744                 // ## Bug: Will block reading src if this channel
 745                 // ##      is asynchronously closed
 746                 int nr = src.read(bb);
 747                 if (nr &lt;= 0)
 748                     break;
 749                 bb.flip();
 750                 int nw = write(bb, pos);
 751                 tw += nw;
 752                 if (nw != nr)
 753                     break;
 754                 pos += nw;
 755                 bb.clear();
 756             }
 757             return tw;
 758         } catch (IOException x) {
 759             if (tw &gt; 0)
 760                 return tw;
 761             throw x;
 762         }
 763     }
 764 
 765     public long transferFrom(ReadableByteChannel src,
 766                              long position, long count)
 767         throws IOException
 768     {
 769         ensureOpen();
 770         if (!src.isOpen())
 771             throw new ClosedChannelException();
 772         if (!writable)
 773             throw new NonWritableChannelException();
 774         if ((position &lt; 0) || (count &lt; 0))
 775             throw new IllegalArgumentException();
 776         if (position &gt; size())
 777             return 0;
 778         if (src instanceof FileChannelImpl)
 779            return transferFromFileChannel((FileChannelImpl)src,
 780                                           position, count);
 781 
 782         return transferFromArbitraryChannel(src, position, count);
 783     }
 784 
 785     public int read(ByteBuffer dst, long position) throws IOException {
 786         if (dst == null)
 787             throw new NullPointerException();
 788         if (position &lt; 0)
 789             throw new IllegalArgumentException(&quot;Negative position&quot;);
 790         ensureOpen();
 791         if (!readable)
 792             throw new NonReadableChannelException();
 793         if (direct)
 794             Util.checkChannelPositionAligned(position, alignment);
 795         if (nd.needsPositionLock()) {
 796             synchronized (positionLock) {
 797                 return readInternal(dst, position);
 798             }
 799         } else {
 800             return readInternal(dst, position);
 801         }
 802     }
 803 
 804     private int readInternal(ByteBuffer dst, long position) throws IOException {
 805         assert !nd.needsPositionLock() || Thread.holdsLock(positionLock);
 806         int n = 0;
 807         int ti = -1;
 808 
 809         try {
 810             beginBlocking();
 811             ti = threads.add();
 812             if (!isOpen())
 813                 return -1;
 814             do {
 815                 n = IOUtil.read(fd, dst, position, direct, alignment, nd);
 816             } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 817             return IOStatus.normalize(n);
 818         } finally {
 819             threads.remove(ti);
 820             endBlocking(n &gt; 0);
 821             assert IOStatus.check(n);
 822         }
 823     }
 824 
 825     public int write(ByteBuffer src, long position) throws IOException {
 826         if (src == null)
 827             throw new NullPointerException();
 828         if (position &lt; 0)
 829             throw new IllegalArgumentException(&quot;Negative position&quot;);
 830         ensureOpen();
 831         if (!writable)
 832             throw new NonWritableChannelException();
 833         if (direct)
 834             Util.checkChannelPositionAligned(position, alignment);
 835         if (nd.needsPositionLock()) {
 836             synchronized (positionLock) {
 837                 return writeInternal(src, position);
 838             }
 839         } else {
 840             return writeInternal(src, position);
 841         }
 842     }
 843 
 844     private int writeInternal(ByteBuffer src, long position) throws IOException {
 845         assert !nd.needsPositionLock() || Thread.holdsLock(positionLock);
 846         int n = 0;
 847         int ti = -1;
 848         try {
 849             beginBlocking();
 850             ti = threads.add();
 851             if (!isOpen())
 852                 return -1;
 853             do {
 854                 n = IOUtil.write(fd, src, position, direct, alignment, nd);
 855             } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 856             return IOStatus.normalize(n);
 857         } finally {
 858             threads.remove(ti);
 859             endBlocking(n &gt; 0);
 860             assert IOStatus.check(n);
 861         }
 862     }
 863 
 864 
 865     // -- Memory-mapped buffers --
 866 
 867     private static abstract class Unmapper
 868         implements Runnable, UnmapperProxy
 869     {
 870         // may be required to close file
 871         private static final NativeDispatcher nd = new FileDispatcherImpl();
 872 
 873         private volatile long address;
 874         protected final long size;
 875         protected final long cap;
 876         private final FileDescriptor fd;
 877         private final int pagePosition;
 878 
 879         private Unmapper(long address, long size, long cap,
 880                          FileDescriptor fd, int pagePosition)
 881         {
 882             assert (address != 0);
 883             this.address = address;
 884             this.size = size;
 885             this.cap = cap;
 886             this.fd = fd;
 887             this.pagePosition = pagePosition;
 888         }
 889 
 890         @Override
 891         public long address() {
 892             return address;
 893         }
 894 
 895         @Override
 896         public void run() {
 897             unmap();
 898         }
 899 
 900         public void unmap() {
 901             if (address == 0)
 902                 return;
 903             unmap0(address, size);
 904             address = 0;
 905 
 906             // if this mapping has a valid file descriptor then we close it
 907             if (fd.valid()) {
 908                 try {
 909                     nd.close(fd);
 910                 } catch (IOException ignore) {
 911                     // nothing we can do
 912                 }
 913             }
 914 
 915             decrementStats();
 916         }
 917         protected abstract void incrementStats();
 918         protected abstract void decrementStats();
 919     }
 920 
 921     private static class DefaultUnmapper extends Unmapper {
 922 
 923         // keep track of non-sync mapped buffer usage
 924         static volatile int count;
 925         static volatile long totalSize;
 926         static volatile long totalCapacity;
 927 
 928         public DefaultUnmapper(long address, long size, long cap,
 929                                FileDescriptor fd, int pagePosition) {
 930             super(address, size, cap, fd, pagePosition);
 931             incrementStats();
 932         }
 933 
 934         protected void incrementStats() {
 935             synchronized (DefaultUnmapper.class) {
 936                 count++;
 937                 totalSize += size;
 938                 totalCapacity += cap;
 939             }
 940         }
 941         protected void decrementStats() {
 942             synchronized (DefaultUnmapper.class) {
 943                 count--;
 944                 totalSize -= size;
 945                 totalCapacity -= cap;
 946             }
 947         }
 948     }
 949 
 950     private static class SyncUnmapper extends Unmapper {
 951 
 952         // keep track of mapped buffer usage
 953         static volatile int count;
 954         static volatile long totalSize;
 955         static volatile long totalCapacity;
 956 
 957         public SyncUnmapper(long address, long size, long cap,
 958                             FileDescriptor fd, int pagePosition) {
 959             super(address, size, cap, fd, pagePosition);
 960             incrementStats();
 961         }
 962 
 963         protected void incrementStats() {
 964             synchronized (SyncUnmapper.class) {
 965                 count++;
 966                 totalSize += size;
 967                 totalCapacity += cap;
 968             }
 969         }
 970         protected void decrementStats() {
 971             synchronized (SyncUnmapper.class) {
 972                 count--;
 973                 totalSize -= size;
 974                 totalCapacity -= cap;
 975             }
 976         }
 977     }
 978 
 979     private static void unmap(MappedByteBuffer bb) {
 980         Cleaner cl = ((DirectBuffer)bb).cleaner();
 981         if (cl != null)
 982             cl.clean();
 983     }
 984 
 985     private static final int MAP_INVALID = -1;
 986     private static final int MAP_RO = 0;
 987     private static final int MAP_RW = 1;
 988     private static final int MAP_PV = 2;
 989 
 990     public MappedByteBuffer map(MapMode mode, long position, long size) throws IOException {
 991         if (size &gt; Integer.MAX_VALUE)
 992             throw new IllegalArgumentException(&quot;Size exceeds Integer.MAX_VALUE&quot;);
 993         boolean isSync = isSync(Objects.requireNonNull(mode, &quot;Mode is null&quot;));
 994         int prot = toProt(mode);
 995         Unmapper unmapper = mapInternal(mode, position, size, prot, isSync);
 996         if (unmapper == null) {
 997             // a valid file descriptor is not required
 998             FileDescriptor dummy = new FileDescriptor();
 999             if ((!writable) || (prot == MAP_RO))
1000                 return Util.newMappedByteBufferR(0, 0, dummy, null, isSync);
1001             else
1002                 return Util.newMappedByteBuffer(0, 0, dummy, null, isSync);
1003         } else if ((!writable) || (prot == MAP_RO)) {
1004             return Util.newMappedByteBufferR((int)unmapper.cap,
1005                     unmapper.address + unmapper.pagePosition,
1006                     unmapper.fd,
1007                     unmapper, isSync);
1008         } else {
1009             return Util.newMappedByteBuffer((int)unmapper.cap,
1010                     unmapper.address + unmapper.pagePosition,
1011                     unmapper.fd,
1012                     unmapper, isSync);
1013         }
1014     }
1015 
1016     public Unmapper mapInternal(MapMode mode, long position, long size) throws IOException {
1017         boolean isSync = isSync(Objects.requireNonNull(mode, &quot;Mode is null&quot;));
1018         int prot = toProt(mode);
1019         return mapInternal(mode, position, size, prot, isSync);
1020     }
1021 
1022     private Unmapper mapInternal(MapMode mode, long position, long size, int prot, boolean isSync)
1023         throws IOException
1024     {
1025         ensureOpen();
1026         if (mode == null)
1027             throw new NullPointerException(&quot;Mode is null&quot;);
1028         if (position &lt; 0L)
1029             throw new IllegalArgumentException(&quot;Negative position&quot;);
1030         if (size &lt; 0L)
1031             throw new IllegalArgumentException(&quot;Negative size&quot;);
1032         if (position + size &lt; 0)
1033             throw new IllegalArgumentException(&quot;Position + size overflow&quot;);
1034 
1035         checkMode(mode, prot, isSync);
1036         long addr = -1;
1037         int ti = -1;
1038         try {
1039             beginBlocking();
1040             ti = threads.add();
1041             if (!isOpen())
1042                 return null;
1043 
1044             long mapSize;
1045             int pagePosition;
1046             synchronized (positionLock) {
1047                 long filesize;
1048                 do {
1049                     filesize = nd.size(fd);
1050                 } while ((filesize == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
1051                 if (!isOpen())
1052                     return null;
1053 
1054                 if (filesize &lt; position + size) { // Extend file size
1055                     if (!writable) {
1056                         throw new IOException(&quot;Channel not open for writing &quot; +
1057                             &quot;- cannot extend file to required size&quot;);
1058                     }
1059                     int rv;
1060                     do {
1061                         rv = nd.truncate(fd, position + size);
1062                     } while ((rv == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
1063                     if (!isOpen())
1064                         return null;
1065                 }
1066 
1067                 if (size == 0) {
1068                     return null;
1069                 }
1070 
1071                 pagePosition = (int)(position % allocationGranularity);
1072                 long mapPosition = position - pagePosition;
1073                 mapSize = size + pagePosition;
1074                 try {
1075                     // If map0 did not throw an exception, the address is valid
1076                     addr = map0(prot, mapPosition, mapSize, isSync);
1077                 } catch (OutOfMemoryError x) {
1078                     // An OutOfMemoryError may indicate that we&#39;ve exhausted
1079                     // memory so force gc and re-attempt map
1080                     System.gc();
1081                     try {
1082                         Thread.sleep(100);
1083                     } catch (InterruptedException y) {
1084                         Thread.currentThread().interrupt();
1085                     }
1086                     try {
1087                         addr = map0(prot, mapPosition, mapSize, isSync);
1088                     } catch (OutOfMemoryError y) {
1089                         // After a second OOME, fail
1090                         throw new IOException(&quot;Map failed&quot;, y);
1091                     }
1092                 }
1093             } // synchronized
1094 
1095             // On Windows, and potentially other platforms, we need an open
1096             // file descriptor for some mapping operations.
1097             FileDescriptor mfd;
1098             try {
1099                 mfd = nd.duplicateForMapping(fd);
1100             } catch (IOException ioe) {
1101                 unmap0(addr, mapSize);
1102                 throw ioe;
1103             }
1104 
1105             assert (IOStatus.checkAll(addr));
1106             assert (addr % allocationGranularity == 0);
1107             Unmapper um = (isSync
1108                            ? new SyncUnmapper(addr, mapSize, size, mfd, pagePosition)
1109                            : new DefaultUnmapper(addr, mapSize, size, mfd, pagePosition));
1110             return um;
1111         } finally {
1112             threads.remove(ti);
1113             endBlocking(IOStatus.checkAll(addr));
1114         }
1115     }
1116 
1117     private boolean isSync(MapMode mode) {
1118         // Do not want to initialize ExtendedMapMode until
1119         // after the module system has been initialized
1120         return !VM.isModuleSystemInited() ? false :
1121             (mode == ExtendedMapMode.READ_ONLY_SYNC ||
1122                 mode == ExtendedMapMode.READ_WRITE_SYNC);
1123     }
1124 
1125     private int toProt(MapMode mode) {
1126         int prot;
1127         if (mode == MapMode.READ_ONLY) {
1128             prot = MAP_RO;
1129         } else if (mode == MapMode.READ_WRITE) {
1130             prot = MAP_RW;
1131         } else if (mode == MapMode.PRIVATE) {
1132             prot = MAP_PV;
1133         } else if (mode == ExtendedMapMode.READ_ONLY_SYNC) {
1134             prot = MAP_RO;
1135         } else if (mode == ExtendedMapMode.READ_WRITE_SYNC) {
1136             prot = MAP_RW;
1137         } else {
1138             prot = MAP_INVALID;
1139         }
1140         return prot;
1141     }
1142 
1143     private void checkMode(MapMode mode, int prot, boolean isSync) {
1144         if (prot == MAP_INVALID) {
1145             throw new UnsupportedOperationException();
1146         }
1147         if ((mode != MapMode.READ_ONLY) &amp;&amp; mode != ExtendedMapMode.READ_ONLY_SYNC &amp;&amp; !writable)
1148             throw new NonWritableChannelException();
1149         if (!readable)
1150             throw new NonReadableChannelException();
1151         // reject SYNC request if writeback is not enabled for this platform
1152         if (isSync &amp;&amp; !Unsafe.isWritebackEnabled()) {
1153             throw new UnsupportedOperationException();
1154         }
1155     }
1156 
1157     /**
1158      * Invoked by sun.management.ManagementFactoryHelper to create the management
1159      * interface for mapped buffers.
1160      */
1161     public static BufferPool getMappedBufferPool() {
1162         return new BufferPool() {
1163             @Override
1164             public String getName() {
1165                 return &quot;mapped&quot;;
1166             }
1167             @Override
1168             public long getCount() {
1169                 return DefaultUnmapper.count;
1170             }
1171             @Override
1172             public long getTotalCapacity() {
1173                 return DefaultUnmapper.totalCapacity;
1174             }
1175             @Override
1176             public long getMemoryUsed() {
1177                 return DefaultUnmapper.totalSize;
1178             }
1179         };
1180     }
1181 
1182     /**
1183      * Invoked by sun.management.ManagementFactoryHelper to create the management
1184      * interface for sync mapped buffers.
1185      */
1186     public static BufferPool getSyncMappedBufferPool() {
1187         return new BufferPool() {
1188             @Override
1189             public String getName() {
1190                 return &quot;mapped - &#39;non-volatile memory&#39;&quot;;
1191             }
1192             @Override
1193             public long getCount() {
1194                 return SyncUnmapper.count;
1195             }
1196             @Override
1197             public long getTotalCapacity() {
1198                 return SyncUnmapper.totalCapacity;
1199             }
1200             @Override
1201             public long getMemoryUsed() {
1202                 return SyncUnmapper.totalSize;
1203             }
1204         };
1205     }
1206 
1207     // -- Locks --
1208 
1209     // keeps track of locks on this file
1210     private volatile FileLockTable fileLockTable;
1211 
1212     private FileLockTable fileLockTable() throws IOException {
1213         if (fileLockTable == null) {
1214             synchronized (this) {
1215                 if (fileLockTable == null) {
1216                     int ti = threads.add();
1217                     try {
1218                         ensureOpen();
1219                         fileLockTable = new FileLockTable(this, fd);
1220                     } finally {
1221                         threads.remove(ti);
1222                     }
1223                 }
1224             }
1225         }
1226         return fileLockTable;
1227     }
1228 
1229     public FileLock lock(long position, long size, boolean shared)
1230         throws IOException
1231     {
1232         ensureOpen();
1233         if (shared &amp;&amp; !readable)
1234             throw new NonReadableChannelException();
1235         if (!shared &amp;&amp; !writable)
1236             throw new NonWritableChannelException();
1237         FileLockImpl fli = new FileLockImpl(this, position, size, shared);
1238         FileLockTable flt = fileLockTable();
1239         flt.add(fli);
1240         boolean completed = false;
1241         int ti = -1;
1242         try {
1243             beginBlocking();
1244             ti = threads.add();
1245             if (!isOpen())
1246                 return null;
1247             int n;
1248             do {
1249                 n = nd.lock(fd, true, position, size, shared);
1250             } while ((n == FileDispatcher.INTERRUPTED) &amp;&amp; isOpen());
1251             if (isOpen()) {
1252                 if (n == FileDispatcher.RET_EX_LOCK) {
1253                     assert shared;
1254                     FileLockImpl fli2 = new FileLockImpl(this, position, size,
1255                                                          false);
1256                     flt.replace(fli, fli2);
1257                     fli = fli2;
1258                 }
1259                 completed = true;
1260             }
1261         } finally {
1262             if (!completed)
1263                 flt.remove(fli);
1264             threads.remove(ti);
1265             try {
1266                 endBlocking(completed);
1267             } catch (ClosedByInterruptException e) {
1268                 throw new FileLockInterruptionException();
1269             }
1270         }
1271         return fli;
1272     }
1273 
1274     public FileLock tryLock(long position, long size, boolean shared)
1275         throws IOException
1276     {
1277         ensureOpen();
1278         if (shared &amp;&amp; !readable)
1279             throw new NonReadableChannelException();
1280         if (!shared &amp;&amp; !writable)
1281             throw new NonWritableChannelException();
1282         FileLockImpl fli = new FileLockImpl(this, position, size, shared);
1283         FileLockTable flt = fileLockTable();
1284         flt.add(fli);
1285         int result;
1286 
1287         int ti = threads.add();
1288         try {
1289             try {
1290                 ensureOpen();
1291                 result = nd.lock(fd, false, position, size, shared);
1292             } catch (IOException e) {
1293                 flt.remove(fli);
1294                 throw e;
1295             }
1296             if (result == FileDispatcher.NO_LOCK) {
1297                 flt.remove(fli);
1298                 return null;
1299             }
1300             if (result == FileDispatcher.RET_EX_LOCK) {
1301                 assert shared;
1302                 FileLockImpl fli2 = new FileLockImpl(this, position, size,
1303                                                      false);
1304                 flt.replace(fli, fli2);
1305                 return fli2;
1306             }
1307             return fli;
1308         } finally {
1309             threads.remove(ti);
1310         }
1311     }
1312 
1313     void release(FileLockImpl fli) throws IOException {
1314         int ti = threads.add();
1315         try {
1316             ensureOpen();
1317             nd.release(fd, fli.position(), fli.size());
1318         } finally {
1319             threads.remove(ti);
1320         }
1321         assert fileLockTable != null;
1322         fileLockTable.remove(fli);
1323     }
1324 
1325     // -- Native methods --
1326 
1327     // Creates a new mapping
1328     private native long map0(int prot, long position, long length, boolean isSync)
1329         throws IOException;
1330 
1331     // Removes an existing mapping
1332     private static native int unmap0(long address, long length);
1333 
1334     // Transfers from src to dst, or returns -2 if kernel can&#39;t do that
1335     private native long transferTo0(FileDescriptor src, long position,
1336                                     long count, FileDescriptor dst);
1337 
1338     // Caches fieldIDs
1339     private static native long initIDs();
1340 
1341     static {
1342         IOUtil.load();
1343         allocationGranularity = initIDs();
1344     }
1345 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLContextImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSocketImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 75,15 ***</span>
   *
   * @author David Brownell
   */
  final class SSLSessionImpl extends ExtendedSSLSession {
  
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * we only really need a single null session</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     static final SSLSessionImpl         nullSession = new SSLSessionImpl();</span>
<span class="line-removed">- </span>
      /*
       * The state of a single session, as described in section 7.1
       * of the SSLv3 spec.
       */
      private final ProtocolVersion       protocolVersion;
<span class="line-new-header">--- 75,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,11 ***</span>
       * Create a new non-rejoinable session, using the default (null)
       * cipher spec.  This constructor returns a session which could
       * be used either by a client or by a server, as a connection is
       * first opened and before handshaking begins.
       */
<span class="line-modified">!     private SSLSessionImpl() {</span>
          this.protocolVersion = ProtocolVersion.NONE;
          this.cipherSuite = CipherSuite.C_NULL;
          this.sessionId = new SessionId(false, null);
          this.host = null;
          this.port = -1;
<span class="line-new-header">--- 146,11 ---</span>
       * Create a new non-rejoinable session, using the default (null)
       * cipher spec.  This constructor returns a session which could
       * be used either by a client or by a server, as a connection is
       * first opened and before handshaking begins.
       */
<span class="line-modified">!     SSLSessionImpl() {</span>
          this.protocolVersion = ProtocolVersion.NONE;
          this.cipherSuite = CipherSuite.C_NULL;
          this.sessionId = new SessionId(false, null);
          this.host = null;
          this.port = -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,17 ***</span>
  
          boundValues = new ConcurrentHashMap&lt;&gt;();
          this.protocolVersion =
                  ProtocolVersion.valueOf(Short.toUnsignedInt(buf.getShort()));
  
<span class="line-modified">!         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="line-modified">!             this.sessionId = new SessionId(false, null);</span>
<span class="line-modified">!         } else {</span>
<span class="line-removed">-             // The CH session id may reset this if it&#39;s provided</span>
<span class="line-removed">-             this.sessionId = new SessionId(true,</span>
<span class="line-removed">-                     hc.sslContext.getSecureRandom());</span>
<span class="line-removed">-         }</span>
  
          this.cipherSuite =
                  CipherSuite.valueOf(Short.toUnsignedInt(buf.getShort()));
  
          // Local Supported signature algorithms
<span class="line-new-header">--- 315,13 ---</span>
  
          boundValues = new ConcurrentHashMap&lt;&gt;();
          this.protocolVersion =
                  ProtocolVersion.valueOf(Short.toUnsignedInt(buf.getShort()));
  
<span class="line-modified">!         // The CH session id may reset this if it&#39;s provided</span>
<span class="line-modified">!         this.sessionId = new SessionId(true,</span>
<span class="line-modified">!                 hc.sslContext.getSecureRandom());</span>
  
          this.cipherSuite =
                  CipherSuite.valueOf(Short.toUnsignedInt(buf.getShort()));
  
          // Local Supported signature algorithms
</pre>
<hr />
<pre>
<span class="line-old-header">*** 399,12 ***</span>
          i = buf.get();
          if (i == 0) {
              identificationProtocol = null;
          } else {
              b = new byte[i];
<span class="line-modified">!             identificationProtocol =</span>
<span class="line-modified">!                     buf.get(b, 0, i).asCharBuffer().toString();</span>
          }
  
          // SNI
          i = buf.get();  // length
          if (i == 0) {
<span class="line-new-header">--- 390,12 ---</span>
          i = buf.get();
          if (i == 0) {
              identificationProtocol = null;
          } else {
              b = new byte[i];
<span class="line-modified">!             buf.get(b);</span>
<span class="line-modified">!             identificationProtocol = new String(b);</span>
          }
  
          // SNI
          i = buf.get();  // length
          if (i == 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 455,11 ***</span>
          i = Byte.toUnsignedInt(buf.get());
          if (i == 0) {
              this.host = new String();
          } else {
              b = new byte[i];
<span class="line-modified">!             this.host = buf.get(b).toString();</span>
          }
          this.port = Short.toUnsignedInt(buf.getShort());
  
          // Peer certs
          i = buf.get();
<span class="line-new-header">--- 446,12 ---</span>
          i = Byte.toUnsignedInt(buf.get());
          if (i == 0) {
              this.host = new String();
          } else {
              b = new byte[i];
<span class="line-modified">!             buf.get(b, 0, i);</span>
<span class="line-added">+             this.host = new String(b);</span>
          }
          this.port = Short.toUnsignedInt(buf.getShort());
  
          // Peer certs
          i = buf.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 503,11 ***</span>
              case 2:
                  // pre-shared key
                  // Length of pre-shared key algorithm  (one byte)
                  i = buf.get();
                  b = new byte[i];
<span class="line-modified">!                 String alg = buf.get(b, 0, i).asCharBuffer().toString();</span>
                  // Get length of encoding
                  i = Short.toUnsignedInt(buf.getShort());
                  // Get encoding
                  b = new byte[i];
                  buf.get(b);
<span class="line-new-header">--- 495,12 ---</span>
              case 2:
                  // pre-shared key
                  // Length of pre-shared key algorithm  (one byte)
                  i = buf.get();
                  b = new byte[i];
<span class="line-modified">!                 buf.get(b, 0 , i);</span>
<span class="line-added">+                 String alg = new String(b);</span>
                  // Get length of encoding
                  i = Short.toUnsignedInt(buf.getShort());
                  // Get encoding
                  b = new byte[i];
                  buf.get(b);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 630,12 ***</span>
          }
  
          // List of SNIServerName
          hos.putInt16(requestedServerNames.size());
          if (requestedServerNames.size() &gt; 0) {
<span class="line-modified">!             for (SNIServerName host : requestedServerNames) {</span>
<span class="line-modified">!                 b = host.getEncoded();</span>
                  hos.putInt8(b.length);
                  hos.write(b, 0, b.length);
              }
          }
  
<span class="line-new-header">--- 623,12 ---</span>
          }
  
          // List of SNIServerName
          hos.putInt16(requestedServerNames.size());
          if (requestedServerNames.size() &gt; 0) {
<span class="line-modified">!             for (SNIServerName sn : requestedServerNames) {</span>
<span class="line-modified">!                 b = sn.getEncoded();</span>
                  hos.putInt8(b.length);
                  hos.write(b, 0, b.length);
              }
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1220,19 ***</span>
       */
      @Override
      public void invalidate() {
          sessionLock.lock();
          try {
<span class="line-removed">-             //</span>
<span class="line-removed">-             // Can&#39;t invalidate the NULL session -- this would be</span>
<span class="line-removed">-             // attempted when we get a handshaking error on a brand</span>
<span class="line-removed">-             // new connection, with no &quot;real&quot; session yet.</span>
<span class="line-removed">-             //</span>
<span class="line-removed">-             if (this == nullSession) {</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
              if (context != null) {
                  context.remove(sessionId);
                  context = null;
              }
  
<span class="line-new-header">--- 1213,10 ---</span>
</pre>
<center><a href="SSLContextImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSocketImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLContextImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSocketImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  60 /**
  61  * Implements the SSL session interface, and exposes the session context
  62  * which is maintained by SSL servers.
  63  *
  64  * &lt;P&gt; Servers have the ability to manage the sessions associated with
  65  * their authentication context(s).  They can do this by enumerating the
  66  * IDs of the sessions which are cached, examining those sessions, and then
  67  * perhaps invalidating a given session so that it can&#39;t be used again.
  68  * If servers do not explicitly manage the cache, sessions will linger
  69  * until memory is low enough that the runtime environment purges cache
  70  * entries automatically to reclaim space.
  71  *
  72  * &lt;P&gt;&lt;em&gt; The only reason this class is not package-private is that
  73  * there&#39;s no other public way to get at the server session context which
  74  * is associated with any given authentication context. &lt;/em&gt;
  75  *
  76  * @author David Brownell
  77  */
  78 final class SSLSessionImpl extends ExtendedSSLSession {
  79 
<span class="line-removed">  80     /*</span>
<span class="line-removed">  81      * we only really need a single null session</span>
<span class="line-removed">  82      */</span>
<span class="line-removed">  83     static final SSLSessionImpl         nullSession = new SSLSessionImpl();</span>
<span class="line-removed">  84 </span>
  85     /*
  86      * The state of a single session, as described in section 7.1
  87      * of the SSLv3 spec.
  88      */
  89     private final ProtocolVersion       protocolVersion;
  90     private final SessionId             sessionId;
  91     private X509Certificate[]   peerCerts;
  92     private CipherSuite         cipherSuite;
  93     private SecretKey           masterSecret;
  94     final boolean               useExtendedMasterSecret;
  95 
  96     /*
  97      * Information not part of the SSLv3 protocol spec, but used
  98      * to support session management policies.
  99      */
 100     private final long          creationTime;
 101     private long                lastUsedTime = 0;
 102     private final String        host;
 103     private final int           port;
 104     private SSLSessionContextImpl       context;
</pre>
<hr />
<pre>
 136 
 137     // server name indication
 138     final SNIServerName         serverNameIndication;
 139     private final List&lt;SNIServerName&gt;    requestedServerNames;
 140 
 141     // Counter used to create unique nonces in NewSessionTicket
 142     private BigInteger ticketNonceCounter = BigInteger.ONE;
 143 
 144     // The endpoint identification algorithm used to check certificates
 145     // in this session.
 146     private final String        identificationProtocol;
 147 
 148     private final ReentrantLock sessionLock = new ReentrantLock();
 149 
 150     /*
 151      * Create a new non-rejoinable session, using the default (null)
 152      * cipher spec.  This constructor returns a session which could
 153      * be used either by a client or by a server, as a connection is
 154      * first opened and before handshaking begins.
 155      */
<span class="line-modified"> 156     private SSLSessionImpl() {</span>
 157         this.protocolVersion = ProtocolVersion.NONE;
 158         this.cipherSuite = CipherSuite.C_NULL;
 159         this.sessionId = new SessionId(false, null);
 160         this.host = null;
 161         this.port = -1;
 162         this.localSupportedSignAlgs = Collections.emptySet();
 163         this.serverNameIndication = null;
 164         this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 165         this.useExtendedMasterSecret = false;
 166         this.creationTime = System.currentTimeMillis();
 167         this.identificationProtocol = null;
 168         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 169     }
 170 
 171     /*
 172      * Create a new session, using a given cipher spec.  This will
 173      * be rejoinable if session caching is enabled; the constructor
 174      * is intended mostly for use by serves.
 175      */
 176     SSLSessionImpl(HandshakeContext hc, CipherSuite cipherSuite) {
</pre>
<hr />
<pre>
 305      *       &lt; 1 bytes &gt; PSK algorithm length
 306      *       &lt; length in bytes &gt; PSK algorithm string
 307      *       &lt; 4 bytes &gt; PSK key length
 308      *       &lt; length in bytes&gt; PSK key
 309      *       &lt; 4 bytes &gt; PSK identity length
 310      *       &lt; length in bytes&gt; PSK identity
 311      *   Anonymous
 312      *     &lt; 1 byte &gt;
 313      * &lt; 4 bytes &gt; maximumPacketSize
 314      * &lt; 4 bytes &gt; negotiatedMaxFragSize
 315      */
 316 
 317     SSLSessionImpl(HandshakeContext hc, ByteBuffer buf) throws IOException {
 318         int i = 0;
 319         byte[] b;
 320 
 321         boundValues = new ConcurrentHashMap&lt;&gt;();
 322         this.protocolVersion =
 323                 ProtocolVersion.valueOf(Short.toUnsignedInt(buf.getShort()));
 324 
<span class="line-modified"> 325         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="line-modified"> 326             this.sessionId = new SessionId(false, null);</span>
<span class="line-modified"> 327         } else {</span>
<span class="line-removed"> 328             // The CH session id may reset this if it&#39;s provided</span>
<span class="line-removed"> 329             this.sessionId = new SessionId(true,</span>
<span class="line-removed"> 330                     hc.sslContext.getSecureRandom());</span>
<span class="line-removed"> 331         }</span>
 332 
 333         this.cipherSuite =
 334                 CipherSuite.valueOf(Short.toUnsignedInt(buf.getShort()));
 335 
 336         // Local Supported signature algorithms
 337         ArrayList&lt;SignatureScheme&gt; list = new ArrayList&lt;&gt;();
 338         i = Byte.toUnsignedInt(buf.get());
 339         while (i-- &gt; 0) {
 340             list.add(SignatureScheme.valueOf(
 341                     Short.toUnsignedInt(buf.getShort())));
 342         }
 343         this.localSupportedSignAlgs = Collections.unmodifiableCollection(list);
 344 
 345         // Peer Supported signature algorithms
 346         i = Byte.toUnsignedInt(buf.get());
 347         list.clear();
 348         while (i-- &gt; 0) {
 349             list.add(SignatureScheme.valueOf(
 350                     Short.toUnsignedInt(buf.getShort())));
 351         }
</pre>
<hr />
<pre>
 384             // Get algorithm string
 385             buf.get(b, 0, i);
 386             // Encoded length
 387             i = Short.toUnsignedInt(buf.getShort());
 388             // Encoded SecretKey
 389             b = new byte[i];
 390             buf.get(b);
 391             this.masterSecret = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);
 392         } else {
 393             this.masterSecret = null;
 394         }
 395         // Use extended master secret
 396         this.useExtendedMasterSecret = (buf.get() != 0);
 397 
 398         // Identification Protocol
 399         i = buf.get();
 400         if (i == 0) {
 401             identificationProtocol = null;
 402         } else {
 403             b = new byte[i];
<span class="line-modified"> 404             identificationProtocol =</span>
<span class="line-modified"> 405                     buf.get(b, 0, i).asCharBuffer().toString();</span>
 406         }
 407 
 408         // SNI
 409         i = buf.get();  // length
 410         if (i == 0) {
 411             serverNameIndication = null;
 412         } else {
 413             b = new byte[i];
 414             buf.get(b, 0, b.length);
 415             serverNameIndication = new SNIHostName(b);
 416         }
 417 
 418         // List of SNIServerName
 419         int len = Short.toUnsignedInt(buf.getShort());
 420         if (len == 0) {
 421             this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 422         } else {
 423             requestedServerNames = new ArrayList&lt;&gt;();
 424             while (len &gt; 0) {
 425                 int l = buf.get();
</pre>
<hr />
<pre>
 440 
 441         // Status Response
 442         len = Short.toUnsignedInt(buf.getShort());
 443         if (len == 0) {
 444             statusResponses = Collections.emptyList();
 445         } else {
 446             statusResponses = new ArrayList&lt;&gt;();
 447         }
 448         while (len-- &gt; 0) {
 449             b = new byte[Short.toUnsignedInt(buf.getShort())];
 450             buf.get(b);
 451             statusResponses.add(b);
 452         }
 453 
 454         // Get Peer host &amp; port
 455         i = Byte.toUnsignedInt(buf.get());
 456         if (i == 0) {
 457             this.host = new String();
 458         } else {
 459             b = new byte[i];
<span class="line-modified"> 460             this.host = buf.get(b).toString();</span>

 461         }
 462         this.port = Short.toUnsignedInt(buf.getShort());
 463 
 464         // Peer certs
 465         i = buf.get();
 466         if (i == 0) {
 467             this.peerCerts = null;
 468         } else {
 469             this.peerCerts = new X509Certificate[i];
 470             int j = 0;
 471             while (i &gt; j) {
 472                 b = new byte[buf.getInt()];
 473                 buf.get(b);
 474                 try {
 475                     this.peerCerts[j] = new X509CertImpl(b);
 476                 } catch (Exception e) {
 477                     throw new IOException(e);
 478                 }
 479                 j++;
 480             }
</pre>
<hr />
<pre>
 488                 // number of certs
 489                 len = buf.get();
 490                 this.localCerts = new X509Certificate[len];
 491                 i = 0;
 492                 while (len &gt; i) {
 493                     b = new byte[buf.getInt()];
 494                     buf.get(b);
 495                     try {
 496                         this.localCerts[i] = new X509CertImpl(b);
 497                     } catch (Exception e) {
 498                         throw new IOException(e);
 499                     }
 500                     i++;
 501                 }
 502                 break;
 503             case 2:
 504                 // pre-shared key
 505                 // Length of pre-shared key algorithm  (one byte)
 506                 i = buf.get();
 507                 b = new byte[i];
<span class="line-modified"> 508                 String alg = buf.get(b, 0, i).asCharBuffer().toString();</span>

 509                 // Get length of encoding
 510                 i = Short.toUnsignedInt(buf.getShort());
 511                 // Get encoding
 512                 b = new byte[i];
 513                 buf.get(b);
 514                 this.preSharedKey = new SecretKeySpec(b, alg);
 515                 // Get identity len
 516                 this.pskIdentity = new byte[buf.get()];
 517                 buf.get(pskIdentity);
 518                 break;
 519             default:
 520                 throw new SSLException(&quot;Failed local certs of session.&quot;);
 521         }
 522 
 523         context = (SSLSessionContextImpl)
 524                 hc.sslContext.engineGetServerSessionContext();
 525         this.lastUsedTime = System.currentTimeMillis();
 526     }
 527 
 528     // Some situations we cannot provide a stateless ticket, but after it
</pre>
<hr />
<pre>
 615         if (identificationProtocol == null) {
 616             hos.putInt8(0);
 617         } else {
 618             hos.putInt8(identificationProtocol.length());
 619             hos.write(identificationProtocol.getBytes(), 0,
 620                     identificationProtocol.length());
 621         }
 622 
 623         // SNI
 624         if (serverNameIndication == null) {
 625             hos.putInt8(0);
 626         } else {
 627             b = serverNameIndication.getEncoded();
 628             hos.putInt8(b.length);
 629             hos.write(b, 0, b.length);
 630         }
 631 
 632         // List of SNIServerName
 633         hos.putInt16(requestedServerNames.size());
 634         if (requestedServerNames.size() &gt; 0) {
<span class="line-modified"> 635             for (SNIServerName host : requestedServerNames) {</span>
<span class="line-modified"> 636                 b = host.getEncoded();</span>
 637                 hos.putInt8(b.length);
 638                 hos.write(b, 0, b.length);
 639             }
 640         }
 641 
 642         // Buffer sizes
 643         hos.putInt32(maximumPacketSize);
 644         hos.putInt32(negotiatedMaxFragLen);
 645 
 646         // creation time
 647         ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
 648         hos.writeBytes(buffer.putLong(creationTime).array());
 649 
 650         // Status Responses
 651         List&lt;byte[]&gt; list = getStatusResponses();
 652         int l = list.size();
 653         hos.putInt16(l);
 654         for (byte[] e : list) {
 655             hos.putInt16(e.length);
 656             hos.write(e);
</pre>
<hr />
<pre>
1205      */
1206     @Override
1207     public int getPeerPort() {
1208         return port;
1209     }
1210 
1211     void setContext(SSLSessionContextImpl ctx) {
1212         if (context == null) {
1213             context = ctx;
1214         }
1215     }
1216 
1217     /**
1218      * Invalidate a session.  Active connections may still exist, but
1219      * no connections will be able to rejoin this session.
1220      */
1221     @Override
1222     public void invalidate() {
1223         sessionLock.lock();
1224         try {
<span class="line-removed">1225             //</span>
<span class="line-removed">1226             // Can&#39;t invalidate the NULL session -- this would be</span>
<span class="line-removed">1227             // attempted when we get a handshaking error on a brand</span>
<span class="line-removed">1228             // new connection, with no &quot;real&quot; session yet.</span>
<span class="line-removed">1229             //</span>
<span class="line-removed">1230             if (this == nullSession) {</span>
<span class="line-removed">1231                 return;</span>
<span class="line-removed">1232             }</span>
<span class="line-removed">1233 </span>
1234             if (context != null) {
1235                 context.remove(sessionId);
1236                 context = null;
1237             }
1238 
1239             if (invalidated) {
1240                 return;
1241             }
1242             invalidated = true;
1243             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
1244                  SSLLogger.finest(&quot;Invalidated session:  &quot; + this);
1245             }
1246             for (SSLSessionImpl child : childSessions) {
1247                 child.invalidate();
1248             }
1249         } finally {
1250             sessionLock.unlock();
1251         }
1252     }
1253 
</pre>
</td>
<td>
<hr />
<pre>
  60 /**
  61  * Implements the SSL session interface, and exposes the session context
  62  * which is maintained by SSL servers.
  63  *
  64  * &lt;P&gt; Servers have the ability to manage the sessions associated with
  65  * their authentication context(s).  They can do this by enumerating the
  66  * IDs of the sessions which are cached, examining those sessions, and then
  67  * perhaps invalidating a given session so that it can&#39;t be used again.
  68  * If servers do not explicitly manage the cache, sessions will linger
  69  * until memory is low enough that the runtime environment purges cache
  70  * entries automatically to reclaim space.
  71  *
  72  * &lt;P&gt;&lt;em&gt; The only reason this class is not package-private is that
  73  * there&#39;s no other public way to get at the server session context which
  74  * is associated with any given authentication context. &lt;/em&gt;
  75  *
  76  * @author David Brownell
  77  */
  78 final class SSLSessionImpl extends ExtendedSSLSession {
  79 





  80     /*
  81      * The state of a single session, as described in section 7.1
  82      * of the SSLv3 spec.
  83      */
  84     private final ProtocolVersion       protocolVersion;
  85     private final SessionId             sessionId;
  86     private X509Certificate[]   peerCerts;
  87     private CipherSuite         cipherSuite;
  88     private SecretKey           masterSecret;
  89     final boolean               useExtendedMasterSecret;
  90 
  91     /*
  92      * Information not part of the SSLv3 protocol spec, but used
  93      * to support session management policies.
  94      */
  95     private final long          creationTime;
  96     private long                lastUsedTime = 0;
  97     private final String        host;
  98     private final int           port;
  99     private SSLSessionContextImpl       context;
</pre>
<hr />
<pre>
 131 
 132     // server name indication
 133     final SNIServerName         serverNameIndication;
 134     private final List&lt;SNIServerName&gt;    requestedServerNames;
 135 
 136     // Counter used to create unique nonces in NewSessionTicket
 137     private BigInteger ticketNonceCounter = BigInteger.ONE;
 138 
 139     // The endpoint identification algorithm used to check certificates
 140     // in this session.
 141     private final String        identificationProtocol;
 142 
 143     private final ReentrantLock sessionLock = new ReentrantLock();
 144 
 145     /*
 146      * Create a new non-rejoinable session, using the default (null)
 147      * cipher spec.  This constructor returns a session which could
 148      * be used either by a client or by a server, as a connection is
 149      * first opened and before handshaking begins.
 150      */
<span class="line-modified"> 151     SSLSessionImpl() {</span>
 152         this.protocolVersion = ProtocolVersion.NONE;
 153         this.cipherSuite = CipherSuite.C_NULL;
 154         this.sessionId = new SessionId(false, null);
 155         this.host = null;
 156         this.port = -1;
 157         this.localSupportedSignAlgs = Collections.emptySet();
 158         this.serverNameIndication = null;
 159         this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 160         this.useExtendedMasterSecret = false;
 161         this.creationTime = System.currentTimeMillis();
 162         this.identificationProtocol = null;
 163         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 164     }
 165 
 166     /*
 167      * Create a new session, using a given cipher spec.  This will
 168      * be rejoinable if session caching is enabled; the constructor
 169      * is intended mostly for use by serves.
 170      */
 171     SSLSessionImpl(HandshakeContext hc, CipherSuite cipherSuite) {
</pre>
<hr />
<pre>
 300      *       &lt; 1 bytes &gt; PSK algorithm length
 301      *       &lt; length in bytes &gt; PSK algorithm string
 302      *       &lt; 4 bytes &gt; PSK key length
 303      *       &lt; length in bytes&gt; PSK key
 304      *       &lt; 4 bytes &gt; PSK identity length
 305      *       &lt; length in bytes&gt; PSK identity
 306      *   Anonymous
 307      *     &lt; 1 byte &gt;
 308      * &lt; 4 bytes &gt; maximumPacketSize
 309      * &lt; 4 bytes &gt; negotiatedMaxFragSize
 310      */
 311 
 312     SSLSessionImpl(HandshakeContext hc, ByteBuffer buf) throws IOException {
 313         int i = 0;
 314         byte[] b;
 315 
 316         boundValues = new ConcurrentHashMap&lt;&gt;();
 317         this.protocolVersion =
 318                 ProtocolVersion.valueOf(Short.toUnsignedInt(buf.getShort()));
 319 
<span class="line-modified"> 320         // The CH session id may reset this if it&#39;s provided</span>
<span class="line-modified"> 321         this.sessionId = new SessionId(true,</span>
<span class="line-modified"> 322                 hc.sslContext.getSecureRandom());</span>




 323 
 324         this.cipherSuite =
 325                 CipherSuite.valueOf(Short.toUnsignedInt(buf.getShort()));
 326 
 327         // Local Supported signature algorithms
 328         ArrayList&lt;SignatureScheme&gt; list = new ArrayList&lt;&gt;();
 329         i = Byte.toUnsignedInt(buf.get());
 330         while (i-- &gt; 0) {
 331             list.add(SignatureScheme.valueOf(
 332                     Short.toUnsignedInt(buf.getShort())));
 333         }
 334         this.localSupportedSignAlgs = Collections.unmodifiableCollection(list);
 335 
 336         // Peer Supported signature algorithms
 337         i = Byte.toUnsignedInt(buf.get());
 338         list.clear();
 339         while (i-- &gt; 0) {
 340             list.add(SignatureScheme.valueOf(
 341                     Short.toUnsignedInt(buf.getShort())));
 342         }
</pre>
<hr />
<pre>
 375             // Get algorithm string
 376             buf.get(b, 0, i);
 377             // Encoded length
 378             i = Short.toUnsignedInt(buf.getShort());
 379             // Encoded SecretKey
 380             b = new byte[i];
 381             buf.get(b);
 382             this.masterSecret = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);
 383         } else {
 384             this.masterSecret = null;
 385         }
 386         // Use extended master secret
 387         this.useExtendedMasterSecret = (buf.get() != 0);
 388 
 389         // Identification Protocol
 390         i = buf.get();
 391         if (i == 0) {
 392             identificationProtocol = null;
 393         } else {
 394             b = new byte[i];
<span class="line-modified"> 395             buf.get(b);</span>
<span class="line-modified"> 396             identificationProtocol = new String(b);</span>
 397         }
 398 
 399         // SNI
 400         i = buf.get();  // length
 401         if (i == 0) {
 402             serverNameIndication = null;
 403         } else {
 404             b = new byte[i];
 405             buf.get(b, 0, b.length);
 406             serverNameIndication = new SNIHostName(b);
 407         }
 408 
 409         // List of SNIServerName
 410         int len = Short.toUnsignedInt(buf.getShort());
 411         if (len == 0) {
 412             this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 413         } else {
 414             requestedServerNames = new ArrayList&lt;&gt;();
 415             while (len &gt; 0) {
 416                 int l = buf.get();
</pre>
<hr />
<pre>
 431 
 432         // Status Response
 433         len = Short.toUnsignedInt(buf.getShort());
 434         if (len == 0) {
 435             statusResponses = Collections.emptyList();
 436         } else {
 437             statusResponses = new ArrayList&lt;&gt;();
 438         }
 439         while (len-- &gt; 0) {
 440             b = new byte[Short.toUnsignedInt(buf.getShort())];
 441             buf.get(b);
 442             statusResponses.add(b);
 443         }
 444 
 445         // Get Peer host &amp; port
 446         i = Byte.toUnsignedInt(buf.get());
 447         if (i == 0) {
 448             this.host = new String();
 449         } else {
 450             b = new byte[i];
<span class="line-modified"> 451             buf.get(b, 0, i);</span>
<span class="line-added"> 452             this.host = new String(b);</span>
 453         }
 454         this.port = Short.toUnsignedInt(buf.getShort());
 455 
 456         // Peer certs
 457         i = buf.get();
 458         if (i == 0) {
 459             this.peerCerts = null;
 460         } else {
 461             this.peerCerts = new X509Certificate[i];
 462             int j = 0;
 463             while (i &gt; j) {
 464                 b = new byte[buf.getInt()];
 465                 buf.get(b);
 466                 try {
 467                     this.peerCerts[j] = new X509CertImpl(b);
 468                 } catch (Exception e) {
 469                     throw new IOException(e);
 470                 }
 471                 j++;
 472             }
</pre>
<hr />
<pre>
 480                 // number of certs
 481                 len = buf.get();
 482                 this.localCerts = new X509Certificate[len];
 483                 i = 0;
 484                 while (len &gt; i) {
 485                     b = new byte[buf.getInt()];
 486                     buf.get(b);
 487                     try {
 488                         this.localCerts[i] = new X509CertImpl(b);
 489                     } catch (Exception e) {
 490                         throw new IOException(e);
 491                     }
 492                     i++;
 493                 }
 494                 break;
 495             case 2:
 496                 // pre-shared key
 497                 // Length of pre-shared key algorithm  (one byte)
 498                 i = buf.get();
 499                 b = new byte[i];
<span class="line-modified"> 500                 buf.get(b, 0 , i);</span>
<span class="line-added"> 501                 String alg = new String(b);</span>
 502                 // Get length of encoding
 503                 i = Short.toUnsignedInt(buf.getShort());
 504                 // Get encoding
 505                 b = new byte[i];
 506                 buf.get(b);
 507                 this.preSharedKey = new SecretKeySpec(b, alg);
 508                 // Get identity len
 509                 this.pskIdentity = new byte[buf.get()];
 510                 buf.get(pskIdentity);
 511                 break;
 512             default:
 513                 throw new SSLException(&quot;Failed local certs of session.&quot;);
 514         }
 515 
 516         context = (SSLSessionContextImpl)
 517                 hc.sslContext.engineGetServerSessionContext();
 518         this.lastUsedTime = System.currentTimeMillis();
 519     }
 520 
 521     // Some situations we cannot provide a stateless ticket, but after it
</pre>
<hr />
<pre>
 608         if (identificationProtocol == null) {
 609             hos.putInt8(0);
 610         } else {
 611             hos.putInt8(identificationProtocol.length());
 612             hos.write(identificationProtocol.getBytes(), 0,
 613                     identificationProtocol.length());
 614         }
 615 
 616         // SNI
 617         if (serverNameIndication == null) {
 618             hos.putInt8(0);
 619         } else {
 620             b = serverNameIndication.getEncoded();
 621             hos.putInt8(b.length);
 622             hos.write(b, 0, b.length);
 623         }
 624 
 625         // List of SNIServerName
 626         hos.putInt16(requestedServerNames.size());
 627         if (requestedServerNames.size() &gt; 0) {
<span class="line-modified"> 628             for (SNIServerName sn : requestedServerNames) {</span>
<span class="line-modified"> 629                 b = sn.getEncoded();</span>
 630                 hos.putInt8(b.length);
 631                 hos.write(b, 0, b.length);
 632             }
 633         }
 634 
 635         // Buffer sizes
 636         hos.putInt32(maximumPacketSize);
 637         hos.putInt32(negotiatedMaxFragLen);
 638 
 639         // creation time
 640         ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
 641         hos.writeBytes(buffer.putLong(creationTime).array());
 642 
 643         // Status Responses
 644         List&lt;byte[]&gt; list = getStatusResponses();
 645         int l = list.size();
 646         hos.putInt16(l);
 647         for (byte[] e : list) {
 648             hos.putInt16(e.length);
 649             hos.write(e);
</pre>
<hr />
<pre>
1198      */
1199     @Override
1200     public int getPeerPort() {
1201         return port;
1202     }
1203 
1204     void setContext(SSLSessionContextImpl ctx) {
1205         if (context == null) {
1206             context = ctx;
1207         }
1208     }
1209 
1210     /**
1211      * Invalidate a session.  Active connections may still exist, but
1212      * no connections will be able to rejoin this session.
1213      */
1214     @Override
1215     public void invalidate() {
1216         sessionLock.lock();
1217         try {









1218             if (context != null) {
1219                 context.remove(sessionId);
1220                 context = null;
1221             }
1222 
1223             if (invalidated) {
1224                 return;
1225             }
1226             invalidated = true;
1227             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
1228                  SSLLogger.finest(&quot;Invalidated session:  &quot; + this);
1229             }
1230             for (SSLSessionImpl child : childSessions) {
1231                 child.invalidate();
1232             }
1233         } finally {
1234             sessionLock.unlock();
1235         }
1236     }
1237 
</pre>
</td>
</tr>
</table>
<center><a href="SSLContextImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSocketImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
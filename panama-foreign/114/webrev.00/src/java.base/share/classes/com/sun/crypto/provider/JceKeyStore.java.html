<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/com/sun/crypto/provider/JceKeyStore.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.crypto.provider;
 27 
 28 import sun.security.util.Debug;
 29 import sun.security.util.IOUtils;
 30 
 31 import java.io.*;
 32 import java.util.*;
 33 import java.security.AccessController;
 34 import java.security.DigestInputStream;
 35 import java.security.DigestOutputStream;
 36 import java.security.MessageDigest;
 37 import java.security.NoSuchAlgorithmException;
 38 import java.security.Key;
 39 import java.security.PrivateKey;
 40 import java.security.PrivilegedAction;
 41 import java.security.KeyStoreSpi;
 42 import java.security.KeyStoreException;
 43 import java.security.UnrecoverableKeyException;
 44 import java.security.cert.Certificate;
 45 import java.security.cert.CertificateFactory;
 46 import java.security.cert.CertificateException;
 47 import javax.crypto.SealedObject;
 48 
 49 import static java.nio.charset.StandardCharsets.UTF_8;
 50 
 51 /**
 52  * This class provides the keystore implementation referred to as &quot;jceks&quot;.
 53  * This implementation strongly protects the keystore private keys using
 54  * triple-DES, where the triple-DES encryption/decryption key is derived from
 55  * the user&#39;s password.
 56  * The encrypted private keys are stored in the keystore in a standard format,
 57  * namely the &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; format defined in PKCS #8.
 58  *
 59  * @author Jan Luehe
 60  *
 61  *
 62  * @see java.security.KeyStoreSpi
 63  */
 64 
 65 public final class JceKeyStore extends KeyStoreSpi {
 66 
 67     private static final Debug debug = Debug.getInstance(&quot;keystore&quot;);
 68     private static final int JCEKS_MAGIC = 0xcececece;
 69     private static final int JKS_MAGIC = 0xfeedfeed;
 70     private static final int VERSION_1 = 0x01;
 71     private static final int VERSION_2 = 0x02;
 72 
 73     // Private key and supporting certificate chain
 74     private static final class PrivateKeyEntry {
 75         Date date; // the creation date of this entry
 76         byte[] protectedKey;
 77         Certificate[] chain;
 78     };
 79 
 80     // Secret key
 81     private static final class SecretKeyEntry {
 82         Date date; // the creation date of this entry
 83         SealedObject sealedKey;
 84 
 85         // Maximum possible length of sealedKey. Used to detect malicious
 86         // input data. This field is set to the file length of the keystore
 87         // at loading. It is useless when creating a new SecretKeyEntry
 88         // to be store in a keystore.
 89         int maxLength;
 90     }
 91 
 92     // Trusted certificate
 93     private static final class TrustedCertEntry {
 94         Date date; // the creation date of this entry
 95         Certificate cert;
 96     };
 97 
 98     /**
 99      * Private keys and certificates are stored in a hashtable.
100      * Hash entries are keyed by alias names.
101      */
102     private Hashtable&lt;String, Object&gt; entries = new Hashtable&lt;String, Object&gt;();
103 
104     /**
105      * Returns the key associated with the given alias, using the given
106      * password to recover it.
107      *
108      * @param alias the alias name
109      * @param password the password for recovering the key
110      *
111      * @return the requested key, or null if the given alias does not exist
112      * or does not identify a &lt;i&gt;key entry&lt;/i&gt;.
113      *
114      * @exception NoSuchAlgorithmException if the algorithm for recovering the
115      * key cannot be found
116      * @exception UnrecoverableKeyException if the key cannot be recovered
117      * (e.g., the given password is wrong).
118      */
119     public Key engineGetKey(String alias, char[] password)
120         throws NoSuchAlgorithmException, UnrecoverableKeyException
121     {
122         Key key = null;
123 
124         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
125 
126         if (!((entry instanceof PrivateKeyEntry) ||
127               (entry instanceof SecretKeyEntry))) {
128             return null;
129         }
130 
131         KeyProtector keyProtector = new KeyProtector(password);
132 
133         if (entry instanceof PrivateKeyEntry) {
134             byte[] encrBytes = ((PrivateKeyEntry)entry).protectedKey;
135             EncryptedPrivateKeyInfo encrInfo;
136             try {
137                 encrInfo = new EncryptedPrivateKeyInfo(encrBytes);
138             } catch (IOException ioe) {
139                 throw new UnrecoverableKeyException(&quot;Private key not stored &quot;
140                                                     + &quot;as PKCS #8 &quot; +
141                                                     &quot;EncryptedPrivateKeyInfo&quot;);
142             }
143             key = keyProtector.recover(encrInfo);
144         } else {
145             SecretKeyEntry ske = ((SecretKeyEntry)entry);
146             key = keyProtector.unseal(ske.sealedKey, ske.maxLength);
147         }
148 
149         return key;
150     }
151 
152     /**
153      * Returns the certificate chain associated with the given alias.
154      *
155      * @param alias the alias name
156      *
157      * @return the certificate chain (ordered with the user&#39;s certificate first
158      * and the root certificate authority last), or null if the given alias
159      * does not exist or does not contain a certificate chain (i.e., the given
160      * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a
161      * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).
162      */
163     public Certificate[] engineGetCertificateChain(String alias)
164     {
165         Certificate[] chain = null;
166 
167         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
168 
169         if ((entry instanceof PrivateKeyEntry)
170             &amp;&amp; (((PrivateKeyEntry)entry).chain != null)) {
171             chain = ((PrivateKeyEntry)entry).chain.clone();
172         }
173 
174         return chain;
175     }
176 
177     /**
178      * Returns the certificate associated with the given alias.
179      *
180      * &lt;p&gt;If the given alias name identifies a
181      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with that
182      * entry is returned. If the given alias name identifies a
183      * &lt;i&gt;key entry&lt;/i&gt;, the first element of the certificate chain of that
184      * entry is returned, or null if that entry does not have a certificate
185      * chain.
186      *
187      * @param alias the alias name
188      *
189      * @return the certificate, or null if the given alias does not exist or
190      * does not contain a certificate.
191      */
192     public Certificate engineGetCertificate(String alias) {
193         Certificate cert = null;
194 
195         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
196 
197         if (entry != null) {
198             if (entry instanceof TrustedCertEntry) {
199                 cert = ((TrustedCertEntry)entry).cert;
200             } else if ((entry instanceof PrivateKeyEntry) &amp;&amp;
201                        (((PrivateKeyEntry)entry).chain != null)) {
202                 cert = ((PrivateKeyEntry)entry).chain[0];
203             }
204         }
205 
206         return cert;
207     }
208 
209     /**
210      * Returns the creation date of the entry identified by the given alias.
211      *
212      * @param alias the alias name
213      *
214      * @return the creation date of this entry, or null if the given alias does
215      * not exist
216      */
217     public Date engineGetCreationDate(String alias) {
218         Date date = null;
219 
220         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
221 
222         if (entry != null) {
223             // We have to create a new instance of java.util.Date because
224             // dates are not immutable
225             if (entry instanceof TrustedCertEntry) {
226                 date = new Date(((TrustedCertEntry)entry).date.getTime());
227             } else if (entry instanceof PrivateKeyEntry) {
228                 date = new Date(((PrivateKeyEntry)entry).date.getTime());
229             } else {
230                 date = new Date(((SecretKeyEntry)entry).date.getTime());
231             }
232         }
233 
234         return date;
235     }
236 
237     /**
238      * Assigns the given key to the given alias, protecting it with the given
239      * password.
240      *
241      * &lt;p&gt;If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
242      * it must be accompanied by a certificate chain certifying the
243      * corresponding public key.
244      *
245      * &lt;p&gt;If the given alias already exists, the keystore information
246      * associated with it is overridden by the given key (and possibly
247      * certificate chain).
248      *
249      * @param alias the alias name
250      * @param key the key to be associated with the alias
251      * @param password the password to protect the key
252      * @param chain the certificate chain for the corresponding public
253      * key (only required if the given key is of type
254      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
255      *
256      * @exception KeyStoreException if the given key cannot be protected, or
257      * this operation fails for some other reason
258      */
259     public void engineSetKeyEntry(String alias, Key key, char[] password,
260                                   Certificate[] chain)
261         throws KeyStoreException
262     {
263         synchronized(entries) {
264             try {
265                 KeyProtector keyProtector = new KeyProtector(password);
266 
267                 if (key instanceof PrivateKey) {
268                     PrivateKeyEntry entry = new PrivateKeyEntry();
269                     entry.date = new Date();
270 
271                     // protect the private key
272                     entry.protectedKey = keyProtector.protect((PrivateKey)key);
273 
274                     // clone the chain
275                     if ((chain != null) &amp;&amp;
276                         (chain.length !=0)) {
277                         entry.chain = chain.clone();
278                     } else {
279                         entry.chain = null;
280                     }
281 
282                     // store the entry
283                     entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
284 
285                 } else {
286                     SecretKeyEntry entry = new SecretKeyEntry();
287                     entry.date = new Date();
288 
289                     // seal and store the key
290                     entry.sealedKey = keyProtector.seal(key);
291                     entry.maxLength = Integer.MAX_VALUE;
292                     entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
293                 }
294 
295             } catch (Exception e) {
296                 throw new KeyStoreException(e.getMessage());
297             }
298         }
299     }
300 
301     /**
302      * Assigns the given key (that has already been protected) to the given
303      * alias.
304      *
305      * &lt;p&gt;If the protected key is of type
306      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
307      * it must be accompanied by a certificate chain certifying the
308      * corresponding public key.
309      *
310      * &lt;p&gt;If the given alias already exists, the keystore information
311      * associated with it is overridden by the given key (and possibly
312      * certificate chain).
313      *
314      * @param alias the alias name
315      * @param key the key (in protected format) to be associated with the alias
316      * @param chain the certificate chain for the corresponding public
317      * key (only useful if the protected key is of type
318      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
319      *
320      * @exception KeyStoreException if this operation fails.
321      */
322     public void engineSetKeyEntry(String alias, byte[] key,
323                                   Certificate[] chain)
324         throws KeyStoreException
325     {
326         synchronized(entries) {
327             // We assume it&#39;s a private key, because there is no standard
328             // (ASN.1) encoding format for wrapped secret keys
329             PrivateKeyEntry entry = new PrivateKeyEntry();
330             entry.date = new Date();
331 
332             entry.protectedKey = key.clone();
333             if ((chain != null) &amp;&amp;
334                 (chain.length != 0)) {
335                 entry.chain = chain.clone();
336             } else {
337                 entry.chain = null;
338             }
339 
340             entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
341         }
342     }
343 
344     /**
345      * Assigns the given certificate to the given alias.
346      *
347      * &lt;p&gt;If the given alias already exists in this keystore and identifies a
348      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with it is
349      * overridden by the given certificate.
350      *
351      * @param alias the alias name
352      * @param cert the certificate
353      *
354      * @exception KeyStoreException if the given alias already exists and does
355      * not identify a &lt;i&gt;trusted certificate entry&lt;/i&gt;, or this operation
356      * fails for some other reason.
357      */
358     public void engineSetCertificateEntry(String alias, Certificate cert)
359         throws KeyStoreException
360     {
361         synchronized(entries) {
362 
363             Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
364             if (entry != null) {
365                 if (entry instanceof PrivateKeyEntry) {
366                     throw new KeyStoreException(&quot;Cannot overwrite own &quot;
367                                                 + &quot;certificate&quot;);
368                 } else if (entry instanceof SecretKeyEntry) {
369                     throw new KeyStoreException(&quot;Cannot overwrite secret key&quot;);
370                 }
371             }
372 
373             TrustedCertEntry trustedCertEntry = new TrustedCertEntry();
374             trustedCertEntry.cert = cert;
375             trustedCertEntry.date = new Date();
376             entries.put(alias.toLowerCase(Locale.ENGLISH), trustedCertEntry);
377         }
378     }
379 
380     /**
381      * Deletes the entry identified by the given alias from this keystore.
382      *
383      * @param alias the alias name
384      *
385      * @exception KeyStoreException if the entry cannot be removed.
386      */
387     public void engineDeleteEntry(String alias)
388         throws KeyStoreException
389     {
390         synchronized(entries) {
391             entries.remove(alias.toLowerCase(Locale.ENGLISH));
392         }
393     }
394 
395     /**
396      * Lists all the alias names of this keystore.
397      *
398      * @return enumeration of the alias names
399      */
400     public Enumeration&lt;String&gt; engineAliases() {
401         return entries.keys();
402     }
403 
404     /**
405      * Checks if the given alias exists in this keystore.
406      *
407      * @param alias the alias name
408      *
409      * @return true if the alias exists, false otherwise
410      */
411     public boolean engineContainsAlias(String alias) {
412         return entries.containsKey(alias.toLowerCase(Locale.ENGLISH));
413     }
414 
415     /**
416      * Retrieves the number of entries in this keystore.
417      *
418      * @return the number of entries in this keystore
419      */
420     public int engineSize() {
421         return entries.size();
422     }
423 
424     /**
425      * Returns true if the entry identified by the given alias is a
426      * &lt;i&gt;key entry&lt;/i&gt;, and false otherwise.
427      *
428      * @return true if the entry identified by the given alias is a
429      * &lt;i&gt;key entry&lt;/i&gt;, false otherwise.
430      */
431     public boolean engineIsKeyEntry(String alias) {
432         boolean isKey = false;
433 
434         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
435         if ((entry instanceof PrivateKeyEntry)
436             || (entry instanceof SecretKeyEntry)) {
437             isKey = true;
438         }
439 
440         return isKey;
441     }
442 
443     /**
444      * Returns true if the entry identified by the given alias is a
445      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, and false otherwise.
446      *
447      * @return true if the entry identified by the given alias is a
448      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, false otherwise.
449      */
450     public boolean engineIsCertificateEntry(String alias) {
451         boolean isCert = false;
452         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
453         if (entry instanceof TrustedCertEntry) {
454             isCert = true;
455         }
456         return isCert;
457     }
458 
459     /**
460      * Returns the (alias) name of the first keystore entry whose certificate
461      * matches the given certificate.
462      *
463      * &lt;p&gt;This method attempts to match the given certificate with each
464      * keystore entry. If the entry being considered
465      * is a &lt;i&gt;trusted certificate entry&lt;/i&gt;, the given certificate is
466      * compared to that entry&#39;s certificate. If the entry being considered is
467      * a &lt;i&gt;key entry&lt;/i&gt;, the given certificate is compared to the first
468      * element of that entry&#39;s certificate chain (if a chain exists).
469      *
470      * @param cert the certificate to match with.
471      *
472      * @return the (alias) name of the first entry with matching certificate,
473      * or null if no such entry exists in this keystore.
474      */
475     public String engineGetCertificateAlias(Certificate cert) {
476         Certificate certElem;
477 
478         Enumeration&lt;String&gt; e = entries.keys();
479         while (e.hasMoreElements()) {
480             String alias = e.nextElement();
481             Object entry = entries.get(alias);
482             if (entry instanceof TrustedCertEntry) {
483                 certElem = ((TrustedCertEntry)entry).cert;
484             } else if ((entry instanceof PrivateKeyEntry) &amp;&amp;
485                        (((PrivateKeyEntry)entry).chain != null)) {
486                 certElem = ((PrivateKeyEntry)entry).chain[0];
487             } else {
488                 continue;
489             }
490             if (certElem.equals(cert)) {
491                 return alias;
492             }
493         }
494         return null;
495     }
496 
497     /**
498      * Stores this keystore to the given output stream, and protects its
499      * integrity with the given password.
500      *
501      * @param stream the output stream to which this keystore is written.
502      * @param password the password to generate the keystore integrity check
503      *
504      * @exception IOException if there was an I/O problem with data
505      * @exception NoSuchAlgorithmException if the appropriate data integrity
506      * algorithm could not be found
507      * @exception CertificateException if any of the certificates included in
508      * the keystore data could not be stored
509      */
510     public void engineStore(OutputStream stream, char[] password)
511         throws IOException, NoSuchAlgorithmException, CertificateException
512     {
513         synchronized(entries) {
514             /*
515              * KEYSTORE FORMAT:
516              *
517              * Magic number (big-endian integer),
518              * Version of this file format (big-endian integer),
519              *
520              * Count (big-endian integer),
521              * followed by &quot;count&quot; instances of either:
522              *
523              *     {
524              *      tag=1 (big-endian integer)
525              *      alias (UTF string)
526              *      timestamp
527              *      encrypted private-key info according to PKCS #8
528              *          (integer length followed by encoding)
529              *      cert chain (integer count followed by certs;
530              *          for each cert: type UTF string, followed by integer
531              *              length, followed by encoding)
532              *     }
533              *
534              * or:
535              *
536              *     {
537              *      tag=2 (big-endian integer)
538              *      alias (UTF string)
539              *      timestamp
540              *      cert (type UTF string, followed by integer length,
541              *          followed by encoding)
542              *     }
543              *
544              * or:
545              *
546              *     {
547              *      tag=3 (big-endian integer)
548              *      alias (UTF string)
549              *      timestamp
550              *      sealed secret key (in serialized form)
551              *     }
552              *
553              * ended by a keyed SHA1 hash (bytes only) of
554              *     { password + whitener + preceding body }
555              */
556 
557             // password is mandatory when storing
558             if (password == null) {
559                 throw new IllegalArgumentException(&quot;password can&#39;t be null&quot;);
560             }
561 
562             byte[] encoded; // the certificate encoding
563 
564             MessageDigest md = getPreKeyedHash(password);
565             DataOutputStream dos
566                 = new DataOutputStream(new DigestOutputStream(stream, md));
567             // NOTE: don&#39;t pass dos to oos at this point or it&#39;ll corrupt
568             // the keystore!!!
569             ObjectOutputStream oos = null;
570             try {
571                 dos.writeInt(JCEKS_MAGIC);
572                 dos.writeInt(VERSION_2); // always write the latest version
573 
574                 dos.writeInt(entries.size());
575 
576                 Enumeration&lt;String&gt; e = entries.keys();
577                 while (e.hasMoreElements()) {
578 
579                     String alias = e.nextElement();
580                     Object entry = entries.get(alias);
581 
582                     if (entry instanceof PrivateKeyEntry) {
583 
584                         PrivateKeyEntry pentry = (PrivateKeyEntry)entry;
585 
586                         // write PrivateKeyEntry tag
587                         dos.writeInt(1);
588 
589                         // write the alias
590                         dos.writeUTF(alias);
591 
592                         // write the (entry creation) date
593                         dos.writeLong(pentry.date.getTime());
594 
595                         // write the protected private key
596                         dos.writeInt(pentry.protectedKey.length);
597                         dos.write(pentry.protectedKey);
598 
599                         // write the certificate chain
600                         int chainLen;
601                         if (pentry.chain == null) {
602                             chainLen = 0;
603                         } else {
604                             chainLen = pentry.chain.length;
605                         }
606                         dos.writeInt(chainLen);
607                         for (int i = 0; i &lt; chainLen; i++) {
608                             encoded = pentry.chain[i].getEncoded();
609                             dos.writeUTF(pentry.chain[i].getType());
610                             dos.writeInt(encoded.length);
611                             dos.write(encoded);
612                         }
613 
614                     } else if (entry instanceof TrustedCertEntry) {
615 
616                         // write TrustedCertEntry tag
617                         dos.writeInt(2);
618 
619                         // write the alias
620                         dos.writeUTF(alias);
621 
622                         // write the (entry creation) date
623                         dos.writeLong(((TrustedCertEntry)entry).date.getTime());
624 
625                         // write the trusted certificate
626                         encoded = ((TrustedCertEntry)entry).cert.getEncoded();
627                         dos.writeUTF(((TrustedCertEntry)entry).cert.getType());
628                         dos.writeInt(encoded.length);
629                         dos.write(encoded);
630 
631                     } else {
632 
633                         // write SecretKeyEntry tag
634                         dos.writeInt(3);
635 
636                         // write the alias
637                         dos.writeUTF(alias);
638 
639                         // write the (entry creation) date
640                         dos.writeLong(((SecretKeyEntry)entry).date.getTime());
641 
642                         // write the sealed key
643                         oos = new ObjectOutputStream(dos);
644                         oos.writeObject(((SecretKeyEntry)entry).sealedKey);
645                         // NOTE: don&#39;t close oos here since we are still
646                         // using dos!!!
647                     }
648                 }
649 
650                 /*
651                  * Write the keyed hash which is used to detect tampering with
652                  * the keystore (such as deleting or modifying key or
653                  * certificate entries).
654                  */
655                 byte digest[] = md.digest();
656 
657                 dos.write(digest);
658                 dos.flush();
659             } finally {
660                 if (oos != null) {
661                     oos.close();
662                 } else {
663                     dos.close();
664                 }
665             }
666         }
667     }
668 
669     /**
670      * Loads the keystore from the given input stream.
671      *
672      * &lt;p&gt;If a password is given, it is used to check the integrity of the
673      * keystore data. Otherwise, the integrity of the keystore is not checked.
674      *
675      * @param stream the input stream from which the keystore is loaded
676      * @param password the (optional) password used to check the integrity of
677      * the keystore.
678      *
679      * @exception IOException if there is an I/O or format problem with the
680      * keystore data
681      * @exception NoSuchAlgorithmException if the algorithm used to check
682      * the integrity of the keystore cannot be found
683      * @exception CertificateException if any of the certificates in the
684      * keystore could not be loaded
685      */
686     public void engineLoad(InputStream stream, char[] password)
687         throws IOException, NoSuchAlgorithmException, CertificateException
688     {
689         synchronized(entries) {
690             DataInputStream dis;
691             MessageDigest md = null;
692             CertificateFactory cf = null;
693             Hashtable&lt;String, CertificateFactory&gt; cfs = null;
694             ByteArrayInputStream bais = null;
695             byte[] encoded = null;
696             int trustedKeyCount = 0, privateKeyCount = 0, secretKeyCount = 0;
697 
698             if (stream == null)
699                 return;
700 
701             byte[] allData = stream.readAllBytes();
702             int fullLength = allData.length;
703 
704             stream = new ByteArrayInputStream(allData);
705             if (password != null) {
706                 md = getPreKeyedHash(password);
707                 dis = new DataInputStream(new DigestInputStream(stream, md));
708             } else {
709                 dis = new DataInputStream(stream);
710             }
711             // NOTE: don&#39;t pass dis to ois at this point or it&#39;ll fail to load
712             // the keystore!!!
713             ObjectInputStream ois = null;
714 
715             try {
716                 // Body format: see store method
717 
718                 int xMagic = dis.readInt();
719                 int xVersion = dis.readInt();
720 
721                 // Accept the following keystore implementations:
722                 // - JCEKS (this implementation), versions 1 and 2
723                 // - JKS (Sun&#39;s keystore implementation in JDK 1.2),
724                 //   versions 1 and 2
725                 if (((xMagic != JCEKS_MAGIC) &amp;&amp; (xMagic != JKS_MAGIC)) ||
726                     ((xVersion != VERSION_1) &amp;&amp; (xVersion != VERSION_2))) {
727                     throw new IOException(&quot;Invalid keystore format&quot;);
728                 }
729 
730                 if (xVersion == VERSION_1) {
731                     cf = CertificateFactory.getInstance(&quot;X509&quot;);
732                 } else {
733                     // version 2
734                     cfs = new Hashtable&lt;&gt;(3);
735                 }
736 
737                 entries.clear();
738                 int count = dis.readInt();
739 
740                 for (int i = 0; i &lt; count; i++) {
741                     int tag;
742                     String alias;
743 
744                     tag = dis.readInt();
745 
746                     if (tag == 1) { // private-key entry
747                         privateKeyCount++;
748                         PrivateKeyEntry entry = new PrivateKeyEntry();
749 
750                         // read the alias
751                         alias = dis.readUTF();
752 
753                         // read the (entry creation) date
754                         entry.date = new Date(dis.readLong());
755 
756                         // read the private key
757                         entry.protectedKey = IOUtils.readExactlyNBytes(dis, dis.readInt());
758 
759                         // read the certificate chain
760                         int numOfCerts = dis.readInt();
761                         List&lt;Certificate&gt; tmpCerts = new ArrayList&lt;&gt;();
762                         for (int j = 0; j &lt; numOfCerts; j++) {
763                             if (xVersion == 2) {
764                                 // read the certificate type, and instantiate a
765                                 // certificate factory of that type (reuse
766                                 // existing factory if possible)
767                                 String certType = dis.readUTF();
768                                 if (cfs.containsKey(certType)) {
769                                     // reuse certificate factory
770                                     cf = cfs.get(certType);
771                                 } else {
772                                     // create new certificate factory
773                                     cf = CertificateFactory.getInstance(
774                                         certType);
775                                     // store the certificate factory so we can
776                                     // reuse it later
777                                     cfs.put(certType, cf);
778                                 }
779                             }
780                             // instantiate the certificate
781                             encoded = IOUtils.readExactlyNBytes(dis, dis.readInt());
782                             bais = new ByteArrayInputStream(encoded);
783                             tmpCerts.add(cf.generateCertificate(bais));
784                         }
785                         entry.chain = tmpCerts.toArray(
786                                 new Certificate[numOfCerts]);
787 
788                         // Add the entry to the list
789                         entries.put(alias, entry);
790 
791                     } else if (tag == 2) { // trusted certificate entry
792                         trustedKeyCount++;
793                         TrustedCertEntry entry = new TrustedCertEntry();
794 
795                         // read the alias
796                         alias = dis.readUTF();
797 
798                         // read the (entry creation) date
799                         entry.date = new Date(dis.readLong());
800 
801                         // read the trusted certificate
802                         if (xVersion == 2) {
803                             // read the certificate type, and instantiate a
804                             // certificate factory of that type (reuse
805                             // existing factory if possible)
806                             String certType = dis.readUTF();
807                             if (cfs.containsKey(certType)) {
808                                 // reuse certificate factory
809                                 cf = cfs.get(certType);
810                             } else {
811                                 // create new certificate factory
812                                 cf = CertificateFactory.getInstance(certType);
813                                 // store the certificate factory so we can
814                                 // reuse it later
815                                 cfs.put(certType, cf);
816                             }
817                         }
818                         encoded = IOUtils.readExactlyNBytes(dis, dis.readInt());
819                         bais = new ByteArrayInputStream(encoded);
820                         entry.cert = cf.generateCertificate(bais);
821 
822                         // Add the entry to the list
823                         entries.put(alias, entry);
824 
825                     } else if (tag == 3) { // secret-key entry
826                         secretKeyCount++;
827                         SecretKeyEntry entry = new SecretKeyEntry();
828 
829                         // read the alias
830                         alias = dis.readUTF();
831 
832                         // read the (entry creation) date
833                         entry.date = new Date(dis.readLong());
834 
835                         // read the sealed key
836                         try {
837                             ois = new ObjectInputStream(dis);
838                             final ObjectInputStream ois2 = ois;
839                             // Set a deserialization checker
840                             AccessController.doPrivileged(
841                                 (PrivilegedAction&lt;Void&gt;)() -&gt; {
842                                     ois2.setObjectInputFilter(
843                                         new DeserializationChecker(fullLength));
844                                     return null;
845                             });
846                             entry.sealedKey = (SealedObject)ois.readObject();
847                             entry.maxLength = fullLength;
848                             // NOTE: don&#39;t close ois here since we are still
849                             // using dis!!!
850                         } catch (ClassNotFoundException cnfe) {
851                             throw new IOException(cnfe.getMessage());
852                         } catch (InvalidClassException ice) {
853                             throw new IOException(&quot;Invalid secret key format&quot;);
854                         }
855 
856                         // Add the entry to the list
857                         entries.put(alias, entry);
858 
859                     } else {
860                         throw new IOException(&quot;Unrecognized keystore entry: &quot; +
861                                 tag);
862                     }
863                 }
864 
865                 if (debug != null) {
866                     debug.println(&quot;JceKeyStore load: private key count: &quot; +
867                         privateKeyCount + &quot;. trusted key count: &quot; +
868                         trustedKeyCount + &quot;. secret key count: &quot; +
869                         secretKeyCount);
870                 }
871 
872                 /*
873                  * If a password has been provided, we check the keyed digest
874                  * at the end. If this check fails, the store has been tampered
875                  * with
876                  */
877                 if (password != null) {
878                     byte[] computed = md.digest();
879                     byte[] actual = IOUtils.readExactlyNBytes(dis, computed.length);
880                     if (!MessageDigest.isEqual(computed, actual)) {
881                         throw new IOException(
882                                 &quot;Keystore was tampered with, or &quot;
883                                         + &quot;password was incorrect&quot;,
884                                 new UnrecoverableKeyException(
885                                         &quot;Password verification failed&quot;));
886                     }
887                 }
888             }  finally {
889                 if (ois != null) {
890                     ois.close();
891                 } else {
892                     dis.close();
893                 }
894             }
895         }
896     }
897 
898     /**
899      * To guard against tampering with the keystore, we append a keyed
900      * hash with a bit of whitener.
901      */
902     private MessageDigest getPreKeyedHash(char[] password)
903         throws NoSuchAlgorithmException
904     {
905         int i, j;
906 
907         MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
908         byte[] passwdBytes = new byte[password.length * 2];
909         for (i=0, j=0; i&lt;password.length; i++) {
910             passwdBytes[j++] = (byte)(password[i] &gt;&gt; 8);
911             passwdBytes[j++] = (byte)password[i];
912         }
913         md.update(passwdBytes);
914         for (i=0; i&lt;passwdBytes.length; i++)
915             passwdBytes[i] = 0;
916         md.update(&quot;Mighty Aphrodite&quot;.getBytes(UTF_8));
917         return md;
918     }
919 
920     /**
921      * Probe the first few bytes of the keystore data stream for a valid
922      * JCEKS keystore encoding.
923      */
924     @Override
925     public boolean engineProbe(InputStream stream) throws IOException {
926         DataInputStream dataStream;
927         if (stream instanceof DataInputStream) {
928             dataStream = (DataInputStream)stream;
929         } else {
930             dataStream = new DataInputStream(stream);
931         }
932 
933         return JCEKS_MAGIC == dataStream.readInt();
934     }
935 
936     /*
937      * An ObjectInputFilter that checks the format of the secret key being
938      * deserialized.
939      */
940     private static class DeserializationChecker implements ObjectInputFilter {
941 
942         private static final int MAX_NESTED_DEPTH = 2;
943 
944         // Full length of keystore, anything inside a SecretKeyEntry should not
945         // be bigger. Otherwise, must be illegal.
946         private final int fullLength;
947 
948         public DeserializationChecker(int fullLength) {
949             this.fullLength = fullLength;
950         }
951 
952         @Override
953         public ObjectInputFilter.Status
954             checkInput(ObjectInputFilter.FilterInfo info) {
955 
956             // First run a custom filter
957             long nestedDepth = info.depth();
958             if ((nestedDepth == 1 &amp;&amp;
959                         info.serialClass() != SealedObjectForKeyProtector.class) ||
960                     info.arrayLength() &gt; fullLength ||
961                     (nestedDepth &gt; MAX_NESTED_DEPTH &amp;&amp;
962                         info.serialClass() != null &amp;&amp;
963                         info.serialClass() != Object.class)) {
964                 return Status.REJECTED;
965             }
966 
967             // Next run the default filter, if available
968             ObjectInputFilter defaultFilter =
969                 ObjectInputFilter.Config.getSerialFilter();
970             if (defaultFilter != null) {
971                 return defaultFilter.checkInput(info);
972             }
973 
974             return Status.UNDECIDED;
975         }
976     }
977 }
    </pre>
  </body>
</html>
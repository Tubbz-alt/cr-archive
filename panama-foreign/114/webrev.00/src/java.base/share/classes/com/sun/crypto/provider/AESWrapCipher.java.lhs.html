<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/com/sun/crypto/provider/AESWrapCipher.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.crypto.provider;
 27 
 28 import java.util.Arrays;
 29 import java.security.*;
 30 import java.security.spec.*;
 31 import javax.crypto.*;
 32 import javax.crypto.spec.*;
 33 
 34 /**
 35  * This class implements the AES KeyWrap algorithm as defined
 36  * in &lt;a href=http://www.w3.org/TR/xmlenc-core/#sec-Alg-SymmetricKeyWrap&gt;
 37  * &quot;XML Encryption Syntax and Processing&quot; section 5.6.3 &quot;AES Key Wrap&quot;.
 38  * Note: only &lt;code&gt;ECB&lt;/code&gt; mode and &lt;code&gt;NoPadding&lt;/code&gt; padding
 39  * can be used for this algorithm.
 40  *
 41  * @author Valerie Peng
 42  *
 43  *
 44  * @see AESCipher
 45  */
 46 abstract class AESWrapCipher extends CipherSpi {
 47     public static final class General extends AESWrapCipher {
 48         public General() {
 49             super(-1);
 50         }
 51     }
 52     public static final class AES128 extends AESWrapCipher {
 53         public AES128() {
 54             super(16);
 55         }
 56     }
 57     public static final class AES192 extends AESWrapCipher {
 58         public AES192() {
 59             super(24);
 60         }
 61     }
 62     public static final class AES256 extends AESWrapCipher {
 63         public AES256() {
 64             super(32);
 65         }
 66     }
 67     private static final byte[] IV = {
 68         (byte) 0xA6, (byte) 0xA6, (byte) 0xA6, (byte) 0xA6,
 69         (byte) 0xA6, (byte) 0xA6, (byte) 0xA6, (byte) 0xA6
 70     };
 71 
 72     private static final int blksize = AESConstants.AES_BLOCK_SIZE;
 73 
 74     /*
 75      * internal cipher object which does the real work.
 76      */
 77     private AESCrypt cipher;
 78 
 79     /*
 80      * are we encrypting or decrypting?
 81      */
 82     private boolean decrypting = false;
 83 
 84     /*
 85      * needed to support AES oids which associates a fixed key size
 86      * to the cipher object.
 87      */
 88     private final int fixedKeySize; // in bytes, -1 if no restriction
 89 
 90     /**
 91      * Creates an instance of AES KeyWrap cipher with default
 92      * mode, i.e. &quot;ECB&quot; and padding scheme, i.e. &quot;NoPadding&quot;.
 93      */
 94     public AESWrapCipher(int keySize) {
 95         cipher = new AESCrypt();
 96         fixedKeySize = keySize;
 97 
 98     }
 99 
100     /**
101      * Sets the mode of this cipher. Only &quot;ECB&quot; mode is accepted for this
102      * cipher.
103      *
104      * @param mode the cipher mode
105      *
106      * @exception NoSuchAlgorithmException if the requested cipher mode
107      * is not &quot;ECB&quot;.
108      */
109     protected void engineSetMode(String mode)
110         throws NoSuchAlgorithmException {
111         if (!mode.equalsIgnoreCase(&quot;ECB&quot;)) {
112             throw new NoSuchAlgorithmException(mode + &quot; cannot be used&quot;);
113         }
114     }
115 
116     /**
117      * Sets the padding mechanism of this cipher. Only &quot;NoPadding&quot; schmem
118      * is accepted for this cipher.
119      *
120      * @param padding the padding mechanism
121      *
122      * @exception NoSuchPaddingException if the requested padding mechanism
123      * is not &quot;NoPadding&quot;.
124      */
125     protected void engineSetPadding(String padding)
126         throws NoSuchPaddingException {
127         if (!padding.equalsIgnoreCase(&quot;NoPadding&quot;)) {
128             throw new NoSuchPaddingException(padding + &quot; cannot be used&quot;);
129         }
130     }
131 
132     /**
133      * Returns the block size (in bytes). i.e. 16 bytes.
134      *
135      * @return the block size (in bytes), i.e. 16 bytes.
136      */
137     protected int engineGetBlockSize() {
138         return blksize;
139     }
140 
141     /**
142      * Returns the length in bytes that an output buffer would need to be
143      * given the input length &lt;code&gt;inputLen&lt;/code&gt; (in bytes).
144      *
145      * &lt;p&gt;The actual output length of the next &lt;code&gt;update&lt;/code&gt; or
146      * &lt;code&gt;doFinal&lt;/code&gt; call may be smaller than the length returned
147      * by this method.
148      *
149      * @param inputLen the input length (in bytes)
150      *
151      * @return the required output buffer size (in bytes)
152      */
153     protected int engineGetOutputSize(int inputLen) {
154         // can only return an upper-limit if not initialized yet.
155         int result = 0;
156         if (decrypting) {
157             result = inputLen - 8;
158         } else {
159             result = Math.addExact(inputLen, 8);
160         }
161         return (result &lt; 0? 0:result);
162     }
163 
164     /**
165      * Returns the initialization vector (IV) which is null for this cipher.
166      *
167      * @return null for this cipher.
168      */
169     protected byte[] engineGetIV() {
170         return null;
171     }
172 
173     /**
174      * Initializes this cipher with a key and a source of randomness.
175      *
176      * &lt;p&gt;The cipher only supports the following two operation modes:&lt;b&gt;
177      * Cipher.WRAP_MODE, and &lt;b&gt;
178      * Cipher.UNWRAP_MODE.
179      * &lt;p&gt;For modes other than the above two, UnsupportedOperationException
180      * will be thrown.
181      *
182      * @param opmode the operation mode of this cipher. Only
183      * &lt;code&gt;WRAP_MODE&lt;/code&gt; or &lt;code&gt;UNWRAP_MODE&lt;/code&gt;) are accepted.
184      * @param key the secret key.
185      * @param random the source of randomness.
186      *
187      * @exception InvalidKeyException if the given key is inappropriate for
188      * initializing this cipher.
189      */
190     protected void engineInit(int opmode, Key key, SecureRandom random)
191         throws InvalidKeyException {
192         if (opmode == Cipher.WRAP_MODE) {
193             decrypting = false;
194         } else if (opmode == Cipher.UNWRAP_MODE) {
195             decrypting = true;
196         } else {
197             throw new UnsupportedOperationException(&quot;This cipher can &quot; +
198                 &quot;only be used for key wrapping and unwrapping&quot;);
199         }
200         AESCipher.checkKeySize(key, fixedKeySize);
201         cipher.init(decrypting, key.getAlgorithm(), key.getEncoded());
202     }
203 
204     /**
205      * Initializes this cipher with a key, a set of algorithm parameters,
206      * and a source of randomness.
207      *
208      * &lt;p&gt;The cipher only supports the following two operation modes:&lt;b&gt;
209      * Cipher.WRAP_MODE, and &lt;b&gt;
210      * Cipher.UNWRAP_MODE.
211      * &lt;p&gt;For modes other than the above two, UnsupportedOperationException
212      * will be thrown.
213      *
214      * @param opmode the operation mode of this cipher. Only
215      * &lt;code&gt;WRAP_MODE&lt;/code&gt; or &lt;code&gt;UNWRAP_MODE&lt;/code&gt;) are accepted.
216      * @param key the secret key.
217      * @param params the algorithm parameters; must be null for this cipher.
218      * @param random the source of randomness.
219      *
220      * @exception InvalidKeyException if the given key is inappropriate for
221      * initializing this cipher
222      * @exception InvalidAlgorithmParameterException if the given algorithm
223      * parameters is not null.
224      */
225     protected void engineInit(int opmode, Key key,
226                               AlgorithmParameterSpec params,
227                               SecureRandom random)
228         throws InvalidKeyException, InvalidAlgorithmParameterException {
229         if (params != null) {
230             throw new InvalidAlgorithmParameterException(&quot;This cipher &quot; +
231                 &quot;does not accept any parameters&quot;);
232         }
233         engineInit(opmode, key, random);
234     }
235 
236     /**
237      * Initializes this cipher with a key, a set of algorithm parameters,
238      * and a source of randomness.
239      *
240      * &lt;p&gt;The cipher only supports the following two operation modes:&lt;b&gt;
241      * Cipher.WRAP_MODE, and &lt;b&gt;
242      * Cipher.UNWRAP_MODE.
243      * &lt;p&gt;For modes other than the above two, UnsupportedOperationException
244      * will be thrown.
245      *
246      * @param opmode the operation mode of this cipher. Only
247      * &lt;code&gt;WRAP_MODE&lt;/code&gt; or &lt;code&gt;UNWRAP_MODE&lt;/code&gt;) are accepted.
248      * @param key the secret key.
249      * @param params the algorithm parameters; must be null for this cipher.
250      * @param random the source of randomness.
251      *
252      * @exception InvalidKeyException if the given key is inappropriate.
253      * @exception InvalidAlgorithmParameterException if the given algorithm
254      * parameters is not null.
255      */
256     protected void engineInit(int opmode, Key key,
257                               AlgorithmParameters params,
258                               SecureRandom random)
259         throws InvalidKeyException, InvalidAlgorithmParameterException {
260         if (params != null) {
261             throw new InvalidAlgorithmParameterException(&quot;This cipher &quot; +
262                 &quot;does not accept any parameters&quot;);
263         }
264         engineInit(opmode, key, random);
265     }
266 
267     /**
268      * This operation is not supported by this cipher.
269      * Since it&#39;s impossible to initialize this cipher given the
270      * current Cipher.engineInit(...) implementation,
271      * IllegalStateException will always be thrown upon invocation.
272      *
273      * @param in the input buffer.
274      * @param inOffset the offset in &lt;code&gt;in&lt;/code&gt; where the input
275      * starts.
276      * @param inLen the input length.
277      *
278      * @return n/a.
279      *
280      * @exception IllegalStateException upon invocation of this method.
281      */
282     protected byte[] engineUpdate(byte[] in, int inOffset, int inLen) {
283         throw new IllegalStateException(&quot;Cipher has not been initialized&quot;);
284     }
285 
286     /**
287      * This operation is not supported by this cipher.
288      * Since it&#39;s impossible to initialize this cipher given the
289      * current Cipher.engineInit(...) implementation,
290      * IllegalStateException will always be thrown upon invocation.
291      *
292      * @param in the input buffer.
293      * @param inOffset the offset in &lt;code&gt;in&lt;/code&gt; where the input
294      * starts.
295      * @param inLen the input length.
296      * @param out the buffer for the result.
297      * @param outOffset the offset in &lt;code&gt;out&lt;/code&gt; where the result
298      * is stored.
299      *
300      * @return n/a.
301      *
302      * @exception IllegalStateException upon invocation of this method.
303      */
304     protected int engineUpdate(byte[] in, int inOffset, int inLen,
305                                byte[] out, int outOffset)
306         throws ShortBufferException {
307         throw new IllegalStateException(&quot;Cipher has not been initialized&quot;);
308     }
309 
310     /**
311      * This operation is not supported by this cipher.
312      * Since it&#39;s impossible to initialize this cipher given the
313      * current Cipher.engineInit(...) implementation,
314      * IllegalStateException will always be thrown upon invocation.
315      *
<a name="2" id="anc2"></a><span class="line-modified">316      * @param in the input buffer</span>
<span class="line-modified">317      * @param inOffset the offset in &lt;code&gt;in&lt;/code&gt; where the input</span>
318      * starts
<a name="3" id="anc3"></a><span class="line-modified">319      * @param inLen the input length.</span>
320      *
321      * @return n/a.
322      *
323      * @exception IllegalStateException upon invocation of this method.
324      */
325     protected byte[] engineDoFinal(byte[] input, int inputOffset,
326                                    int inputLen)
327         throws IllegalBlockSizeException, BadPaddingException {
328         throw new IllegalStateException(&quot;Cipher has not been initialized&quot;);
329     }
330 
331     /**
332      * This operation is not supported by this cipher.
333      * Since it&#39;s impossible to initialize this cipher given the
334      * current Cipher.engineInit(...) implementation,
335      * IllegalStateException will always be thrown upon invocation.
336      *
337      * @param in the input buffer.
338      * @param inOffset the offset in &lt;code&gt;in&lt;/code&gt; where the input
339      * starts.
340      * @param inLen the input length.
341      * @param out the buffer for the result.
342      * @param outOffset the ofset in &lt;code&gt;out&lt;/code&gt; where the result
343      * is stored.
344      *
345      * @return n/a.
346      *
347      * @exception IllegalStateException upon invocation of this method.
348      */
349     protected int engineDoFinal(byte[] in, int inOffset, int inLen,
350                                 byte[] out, int outOffset)
351         throws IllegalBlockSizeException, ShortBufferException,
352                BadPaddingException {
353         throw new IllegalStateException(&quot;Cipher has not been initialized&quot;);
354     }
355 
356     /**
357      * Returns the parameters used with this cipher which is always null
358      * for this cipher.
359      *
360      * @return null since this cipher does not use any parameters.
361      */
362     protected AlgorithmParameters engineGetParameters() {
363         return null;
364     }
365 
366     /**
367      * Returns the key size of the given key object in number of bits.
368      *
369      * @param key the key object.
370      *
371      * @return the &quot;effective&quot; key size of the given key object.
372      *
373      * @exception InvalidKeyException if &lt;code&gt;key&lt;/code&gt; is invalid.
374      */
375     protected int engineGetKeySize(Key key) throws InvalidKeyException {
376         byte[] encoded = key.getEncoded();
377         if (!AESCrypt.isKeySizeValid(encoded.length)) {
378             throw new InvalidKeyException(&quot;Invalid key length: &quot; +
379                                           encoded.length + &quot; bytes&quot;);
380         }
381         return Math.multiplyExact(encoded.length, 8);
382     }
383 
384     /**
385      * Wrap a key.
386      *
387      * @param key the key to be wrapped.
388      *
389      * @return the wrapped key.
390      *
391      * @exception IllegalBlockSizeException if this cipher is a block
392      * cipher, no padding has been requested, and the length of the
393      * encoding of the key to be wrapped is not a
394      * multiple of the block size.
395      *
396      * @exception InvalidKeyException if it is impossible or unsafe to
397      * wrap the key with this cipher (e.g., a hardware protected key is
398      * being passed to a software only cipher).
399      */
400     protected byte[] engineWrap(Key key)
401         throws IllegalBlockSizeException, InvalidKeyException {
402         byte[] keyVal = key.getEncoded();
403         if ((keyVal == null) || (keyVal.length == 0)) {
404             throw new InvalidKeyException(&quot;Cannot get an encoding of &quot; +
405                                           &quot;the key to be wrapped&quot;);
406         }
407         byte[] out = new byte[Math.addExact(keyVal.length, 8)];
408 
409         if (keyVal.length == 8) {
410             System.arraycopy(IV, 0, out, 0, IV.length);
411             System.arraycopy(keyVal, 0, out, IV.length, 8);
412             cipher.encryptBlock(out, 0, out, 0);
413         } else {
414             if (keyVal.length % 8 != 0) {
415                 throw new IllegalBlockSizeException(&quot;length of the &quot; +
416                     &quot;to be wrapped key should be multiples of 8 bytes&quot;);
417             }
418             System.arraycopy(IV, 0, out, 0, IV.length);
419             System.arraycopy(keyVal, 0, out, IV.length, keyVal.length);
420             int N = keyVal.length/8;
421             byte[] buffer = new byte[blksize];
422             for (int j = 0; j &lt; 6; j++) {
423                 for (int i = 1; i &lt;= N; i++) {
424                     int T = i + j*N;
425                     System.arraycopy(out, 0, buffer, 0, IV.length);
426                     System.arraycopy(out, i*8, buffer, IV.length, 8);
427                     cipher.encryptBlock(buffer, 0, buffer, 0);
428                     for (int k = 1; T != 0; k++) {
429                         byte v = (byte) T;
430                         buffer[IV.length - k] ^= v;
431                         T &gt;&gt;&gt;= 8;
432                     }
433                     System.arraycopy(buffer, 0, out, 0, IV.length);
434                     System.arraycopy(buffer, 8, out, 8*i, 8);
435                 }
436             }
437         }
438         return out;
439     }
440 
441     /**
442      * Unwrap a previously wrapped key.
443      *
444      * @param wrappedKey the key to be unwrapped.
445      *
446      * @param wrappedKeyAlgorithm the algorithm the wrapped key is for.
447      *
448      * @param wrappedKeyType the type of the wrapped key.
449      * This is one of &lt;code&gt;Cipher.SECRET_KEY&lt;/code&gt;,
450      * &lt;code&gt;Cipher.PRIVATE_KEY&lt;/code&gt;, or &lt;code&gt;Cipher.PUBLIC_KEY&lt;/code&gt;.
451      *
452      * @return the unwrapped key.
453      *
454      * @exception NoSuchAlgorithmException if no installed providers
455      * can create keys of type &lt;code&gt;wrappedKeyType&lt;/code&gt; for the
456      * &lt;code&gt;wrappedKeyAlgorithm&lt;/code&gt;.
457      *
458      * @exception InvalidKeyException if &lt;code&gt;wrappedKey&lt;/code&gt; does not
459      * represent a wrapped key of type &lt;code&gt;wrappedKeyType&lt;/code&gt; for
460      * the &lt;code&gt;wrappedKeyAlgorithm&lt;/code&gt;.
461      */
462     protected Key engineUnwrap(byte[] wrappedKey,
463                                String wrappedKeyAlgorithm,
464                                int wrappedKeyType)
465         throws InvalidKeyException, NoSuchAlgorithmException {
466         int wrappedKeyLen = wrappedKey.length;
467         // ensure the wrappedKey length is multiples of 8 bytes and non-zero
468         if (wrappedKeyLen == 0) {
469             throw new InvalidKeyException(&quot;The wrapped key is empty&quot;);
470         }
471         if (wrappedKeyLen % 8 != 0) {
472             throw new InvalidKeyException
473                 (&quot;The wrapped key has invalid key length&quot;);
474         }
475         byte[] out = new byte[wrappedKeyLen - 8];
476         byte[] buffer = new byte[blksize];
477         if (wrappedKeyLen == 16) {
478             cipher.decryptBlock(wrappedKey, 0, buffer, 0);
479             for (int i = 0; i &lt; IV.length; i++) {
480                 if (IV[i] != buffer[i]) {
481                     throw new InvalidKeyException(&quot;Integrity check failed&quot;);
482                 }
483             }
484             System.arraycopy(buffer, IV.length, out, 0, out.length);
485         } else {
486             System.arraycopy(wrappedKey, 0, buffer, 0, IV.length);
487             System.arraycopy(wrappedKey, IV.length, out, 0, out.length);
488             int N = out.length/8;
489             for (int j = 5; j &gt;= 0; j--) {
490                 for (int i = N; i &gt; 0; i--) {
491                     int T = i + j*N;
492                     System.arraycopy(out, 8*(i-1), buffer, IV.length, 8);
493                     for (int k = 1; T != 0; k++) {
494                         byte v = (byte) T;
495                         buffer[IV.length - k] ^= v;
496                         T &gt;&gt;&gt;= 8;
497                     }
498                     cipher.decryptBlock(buffer, 0, buffer, 0);
499                     System.arraycopy(buffer, IV.length, out, 8*(i-1), 8);
500                 }
501             }
502             for (int i = 0; i &lt; IV.length; i++) {
503                 if (IV[i] != buffer[i]) {
504                     throw new InvalidKeyException(&quot;Integrity check failed&quot;);
505                 }
506             }
507         }
508         return ConstructKeys.constructKey(out, wrappedKeyAlgorithm,
509                                           wrappedKeyType);
510     }
511 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
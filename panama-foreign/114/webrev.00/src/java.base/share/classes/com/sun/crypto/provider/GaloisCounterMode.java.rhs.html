<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/com/sun/crypto/provider/GaloisCounterMode.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.crypto.provider;
 27 
 28 import java.util.Arrays;
 29 import java.io.*;
 30 import java.security.*;
 31 import javax.crypto.*;
 32 import static com.sun.crypto.provider.AESConstants.AES_BLOCK_SIZE;
 33 import sun.security.util.ArrayUtil;
 34 
 35 
 36 /**
 37  * This class represents ciphers in GaloisCounter (GCM) mode.
 38  *
 39  * &lt;p&gt;This mode currently should only be used w/ AES cipher.
 40  * Although no checking is done, caller should only pass AES
 41  * Cipher to the constructor.
 42  *
 43  * &lt;p&gt;NOTE: Unlike other modes, when used for decryption, this class
 44  * will buffer all processed outputs internally and won&#39;t return them
 45  * until the tag has been successfully verified.
 46  *
 47  * @since 1.8
 48  */
 49 final class GaloisCounterMode extends FeedbackCipher {
 50 
 51     static int DEFAULT_TAG_LEN = AES_BLOCK_SIZE;
 52     static int DEFAULT_IV_LEN = 12; // in bytes
 53 
 54     // In NIST SP 800-38D, GCM input size is limited to be no longer
 55     // than (2^36 - 32) bytes. Otherwise, the counter will wrap
 56     // around and lead to a leak of plaintext.
 57     // However, given the current GCM spec requirement that recovered
 58     // text can only be returned after successful tag verification,
 59     // we are bound by limiting the data size to the size limit of
 60     // java byte array, e.g. Integer.MAX_VALUE, since all data
 61     // can only be returned by the doFinal(...) call.
 62     private static final int MAX_BUF_SIZE = Integer.MAX_VALUE;
 63 
 64     // data size when buffer is divided up to aid in intrinsics
 65     private static final int TRIGGERLEN = 65536;  // 64k
 66 
 67     // buffer for AAD data; if null, meaning update has been called
 68     private ByteArrayOutputStream aadBuffer = new ByteArrayOutputStream();
 69     private int sizeOfAAD = 0;
 70 
 71     // buffer for storing input in decryption, not used for encryption
 72     private ByteArrayOutputStream ibuffer = null;
 73 
 74     // in bytes; need to convert to bits (default value 128) when needed
 75     private int tagLenBytes = DEFAULT_TAG_LEN;
 76 
 77     // these following 2 fields can only be initialized after init() is
 78     // called, e.g. after cipher key k is set, and STAY UNCHANGED
 79     private byte[] subkeyH = null;
 80     private byte[] preCounterBlock = null;
 81 
 82     private GCTR gctrPAndC = null;
 83     private GHASH ghashAllToS = null;
 84 
 85     // length of total data, i.e. len(C)
 86     private int processed = 0;
 87 
 88     // additional variables for save/restore calls
 89     private byte[] aadBufferSave = null;
 90     private int sizeOfAADSave = 0;
 91     private byte[] ibufferSave = null;
 92     private int processedSave = 0;
 93 
 94     // value must be 16-byte long; used by GCTR and GHASH as well
 95     static void increment32(byte[] value) {
 96         if (value.length != AES_BLOCK_SIZE) {
 97             // should never happen
 98             throw new ProviderException(&quot;Illegal counter block length&quot;);
 99         }
100         // start from last byte and only go over 4 bytes, i.e. total 32 bits
101         int n = value.length - 1;
102         while ((n &gt;= value.length - 4) &amp;&amp; (++value[n] == 0)) {
103             n--;
104         }
105     }
106 
107     private static byte[] getLengthBlock(int ivLenInBytes) {
108         long ivLen = ((long)ivLenInBytes) &lt;&lt; 3;
109         byte[] out = new byte[AES_BLOCK_SIZE];
110         out[8] = (byte)(ivLen &gt;&gt;&gt; 56);
111         out[9] = (byte)(ivLen &gt;&gt;&gt; 48);
112         out[10] = (byte)(ivLen &gt;&gt;&gt; 40);
113         out[11] = (byte)(ivLen &gt;&gt;&gt; 32);
114         out[12] = (byte)(ivLen &gt;&gt;&gt; 24);
115         out[13] = (byte)(ivLen &gt;&gt;&gt; 16);
116         out[14] = (byte)(ivLen &gt;&gt;&gt; 8);
117         out[15] = (byte)ivLen;
118         return out;
119     }
120 
121     private static byte[] getLengthBlock(int aLenInBytes, int cLenInBytes) {
122         long aLen = ((long)aLenInBytes) &lt;&lt; 3;
123         long cLen = ((long)cLenInBytes) &lt;&lt; 3;
124         byte[] out = new byte[AES_BLOCK_SIZE];
125         out[0] = (byte)(aLen &gt;&gt;&gt; 56);
126         out[1] = (byte)(aLen &gt;&gt;&gt; 48);
127         out[2] = (byte)(aLen &gt;&gt;&gt; 40);
128         out[3] = (byte)(aLen &gt;&gt;&gt; 32);
129         out[4] = (byte)(aLen &gt;&gt;&gt; 24);
130         out[5] = (byte)(aLen &gt;&gt;&gt; 16);
131         out[6] = (byte)(aLen &gt;&gt;&gt; 8);
132         out[7] = (byte)aLen;
133         out[8] = (byte)(cLen &gt;&gt;&gt; 56);
134         out[9] = (byte)(cLen &gt;&gt;&gt; 48);
135         out[10] = (byte)(cLen &gt;&gt;&gt; 40);
136         out[11] = (byte)(cLen &gt;&gt;&gt; 32);
137         out[12] = (byte)(cLen &gt;&gt;&gt; 24);
138         out[13] = (byte)(cLen &gt;&gt;&gt; 16);
139         out[14] = (byte)(cLen &gt;&gt;&gt; 8);
140         out[15] = (byte)cLen;
141         return out;
142     }
143 
144     private static byte[] expandToOneBlock(byte[] in, int inOfs, int len) {
145         if (len &gt; AES_BLOCK_SIZE) {
146             throw new ProviderException(&quot;input &quot; + len + &quot; too long&quot;);
147         }
148         if (len == AES_BLOCK_SIZE &amp;&amp; inOfs == 0) {
149             return in;
150         } else {
151             byte[] paddedIn = new byte[AES_BLOCK_SIZE];
152             System.arraycopy(in, inOfs, paddedIn, 0, len);
153             return paddedIn;
154         }
155     }
156 
157     private static byte[] getJ0(byte[] iv, byte[] subkeyH) {
158         byte[] j0;
159         if (iv.length == 12) { // 96 bits
160             j0 = expandToOneBlock(iv, 0, iv.length);
161             j0[AES_BLOCK_SIZE - 1] = 1;
162         } else {
163             GHASH g = new GHASH(subkeyH);
164             int lastLen = iv.length % AES_BLOCK_SIZE;
165             if (lastLen != 0) {
166                 g.update(iv, 0, iv.length - lastLen);
167                 byte[] padded =
168                     expandToOneBlock(iv, iv.length - lastLen, lastLen);
169                 g.update(padded);
170             } else {
171                 g.update(iv);
172             }
173             byte[] lengthBlock = getLengthBlock(iv.length);
174             g.update(lengthBlock);
175             j0 = g.digest();
176         }
177         return j0;
178     }
179 
180     private static void checkDataLength(int processed, int len) {
181         if (processed &gt; MAX_BUF_SIZE - len) {
182             throw new ProviderException(&quot;SunJCE provider only supports &quot; +
183                 &quot;input size up to &quot; + MAX_BUF_SIZE + &quot; bytes&quot;);
184         }
185     }
186 
187     GaloisCounterMode(SymmetricCipher embeddedCipher) {
188         super(embeddedCipher);
189         aadBuffer = new ByteArrayOutputStream();
190     }
191 
192     /**
193      * Gets the name of the feedback mechanism
194      *
195      * @return the name of the feedback mechanism
196      */
197     String getFeedback() {
198         return &quot;GCM&quot;;
199     }
200 
201     /**
202      * Resets the cipher object to its original state.
203      * This is used when doFinal is called in the Cipher class, so that the
204      * cipher can be reused (with its original key and iv).
205      */
206     void reset() {
207         if (aadBuffer == null) {
208             aadBuffer = new ByteArrayOutputStream();
209         } else {
210             aadBuffer.reset();
211         }
212         if (gctrPAndC != null) gctrPAndC.reset();
213         if (ghashAllToS != null) ghashAllToS.reset();
214         processed = 0;
215         sizeOfAAD = 0;
216         if (ibuffer != null) {
217             ibuffer.reset();
218         }
219     }
220 
221     /**
222      * Save the current content of this cipher.
223      */
224     void save() {
225         processedSave = processed;
226         sizeOfAADSave = sizeOfAAD;
227         aadBufferSave =
228             ((aadBuffer == null || aadBuffer.size() == 0)?
229              null : aadBuffer.toByteArray());
230         if (gctrPAndC != null) gctrPAndC.save();
231         if (ghashAllToS != null) ghashAllToS.save();
232         if (ibuffer != null) {
233             ibufferSave = ibuffer.toByteArray();
234         }
235     }
236 
237     /**
238      * Restores the content of this cipher to the previous saved one.
239      */
240     void restore() {
241         processed = processedSave;
242         sizeOfAAD = sizeOfAADSave;
243         if (aadBuffer != null) {
244             aadBuffer.reset();
245             if (aadBufferSave != null) {
246                 aadBuffer.write(aadBufferSave, 0, aadBufferSave.length);
247             }
248         }
249         if (gctrPAndC != null) gctrPAndC.restore();
250         if (ghashAllToS != null) ghashAllToS.restore();
251         if (ibuffer != null) {
252             ibuffer.reset();
253             ibuffer.write(ibufferSave, 0, ibufferSave.length);
254         }
255     }
256 
257     /**
258      * Initializes the cipher in the specified mode with the given key
259      * and iv.
260      *
261      * @param decrypting flag indicating encryption or decryption
262      * @param algorithm the algorithm name
263      * @param key the key
264      * @param iv the iv
<a name="2" id="anc2"></a>

265      * @exception InvalidKeyException if the given key is inappropriate for
266      * initializing this cipher
267      */
268     @Override
269     void init(boolean decrypting, String algorithm, byte[] key, byte[] iv)
270             throws InvalidKeyException, InvalidAlgorithmParameterException {
271         init(decrypting, algorithm, key, iv, DEFAULT_TAG_LEN);
272     }
273 
274     /**
275      * Initializes the cipher in the specified mode with the given key
276      * and iv.
277      *
278      * @param decrypting flag indicating encryption or decryption
279      * @param algorithm the algorithm name
<a name="3" id="anc3"></a><span class="line-modified">280      * @param keyValue the key</span>
<span class="line-modified">281      * @param ivValue the iv</span>
282      * @param tagLenBytes the length of tag in bytes
283      *
284      * @exception InvalidKeyException if the given key is inappropriate for
285      * initializing this cipher
286      */
287     void init(boolean decrypting, String algorithm, byte[] keyValue,
288               byte[] ivValue, int tagLenBytes)
289               throws InvalidKeyException, InvalidAlgorithmParameterException {
290         if (keyValue == null) {
291             throw new InvalidKeyException(&quot;Internal error&quot;);
292         }
293         if (ivValue == null) {
294             throw new InvalidAlgorithmParameterException(&quot;Internal error&quot;);
295         }
296         if (ivValue.length == 0) {
297             throw new InvalidAlgorithmParameterException(&quot;IV is empty&quot;);
298         }
299 
300         // always encrypt mode for embedded cipher
301         this.embeddedCipher.init(false, algorithm, keyValue);
302         this.subkeyH = new byte[AES_BLOCK_SIZE];
303         this.embeddedCipher.encryptBlock(new byte[AES_BLOCK_SIZE], 0,
304                 this.subkeyH, 0);
305 
306         this.iv = ivValue.clone();
307         preCounterBlock = getJ0(iv, subkeyH);
308         byte[] j0Plus1 = preCounterBlock.clone();
309         increment32(j0Plus1);
310         gctrPAndC = new GCTR(embeddedCipher, j0Plus1);
311         ghashAllToS = new GHASH(subkeyH);
312 
313         this.tagLenBytes = tagLenBytes;
314         if (aadBuffer == null) {
315             aadBuffer = new ByteArrayOutputStream();
316         } else {
317             aadBuffer.reset();
318         }
319         processed = 0;
320         sizeOfAAD = 0;
321         if (decrypting) {
322             ibuffer = new ByteArrayOutputStream();
323         }
324     }
325 
326     /**
327      * Continues a multi-part update of the Additional Authentication
328      * Data (AAD), using a subset of the provided buffer. If this
329      * cipher is operating in either GCM or CCM mode, all AAD must be
330      * supplied before beginning operations on the ciphertext (via the
331      * {@code update} and {@code doFinal} methods).
332      * &lt;p&gt;
333      * NOTE: Given most modes do not accept AAD, default impl for this
334      * method throws IllegalStateException.
335      *
336      * @param src the buffer containing the AAD
337      * @param offset the offset in {@code src} where the AAD input starts
338      * @param len the number of AAD bytes
339      *
340      * @throws IllegalStateException if this cipher is in a wrong state
341      * (e.g., has not been initialized), does not accept AAD, or if
342      * operating in either GCM or CCM mode and one of the {@code update}
343      * methods has already been called for the active
344      * encryption/decryption operation
345      * @throws UnsupportedOperationException if this method
346      * has not been overridden by an implementation
347      *
348      * @since 1.8
349      */
350     void updateAAD(byte[] src, int offset, int len) {
351         if (aadBuffer != null) {
352             aadBuffer.write(src, offset, len);
353         } else {
354             // update has already been called
355             throw new IllegalStateException
356                 (&quot;Update has been called; no more AAD data&quot;);
357         }
358     }
359 
360     // Feed the AAD data to GHASH, pad if necessary
361     void processAAD() {
362         if (aadBuffer != null) {
363             if (aadBuffer.size() &gt; 0) {
364                 byte[] aad = aadBuffer.toByteArray();
365                 sizeOfAAD = aad.length;
366 
367                 int lastLen = aad.length % AES_BLOCK_SIZE;
368                 if (lastLen != 0) {
369                     ghashAllToS.update(aad, 0, aad.length - lastLen);
370                     byte[] padded = expandToOneBlock(aad, aad.length - lastLen,
371                                                      lastLen);
372                     ghashAllToS.update(padded);
373                 } else {
374                     ghashAllToS.update(aad);
375                 }
376             }
377             aadBuffer = null;
378         }
379     }
380 
381     // Utility to process the last block; used by encryptFinal and decryptFinal
382     void doLastBlock(byte[] in, int inOfs, int len, byte[] out, int outOfs,
383                      boolean isEncrypt) throws IllegalBlockSizeException {
384         byte[] ct;
385         int ctOfs;
386         int ilen = len;  // internal length
387 
388         if (isEncrypt) {
389             ct = out;
390             ctOfs = outOfs;
391         } else {
392             ct = in;
393             ctOfs = inOfs;
394         }
395 
396         // Divide up larger data sizes to trigger CTR &amp; GHASH intrinsic quicker
397         if (len &gt; TRIGGERLEN) {
398             int i = 0;
399             int tlen;  // incremental lengths
400             final int plen = AES_BLOCK_SIZE * 6;
401             // arbitrary formula to aid intrinsic without reaching buffer end
402             final int count = len / 1024;
403 
404             while (count &gt; i) {
405                 tlen = gctrPAndC.update(in, inOfs, plen, out, outOfs);
406                 ghashAllToS.update(ct, ctOfs, tlen);
407                 inOfs += tlen;
408                 outOfs += tlen;
409                 ctOfs += tlen;
410                 i++;
411             }
412             ilen -= count * plen;
413             processed += count * plen;
414         }
415 
416         gctrPAndC.doFinal(in, inOfs, ilen, out, outOfs);
417         processed += ilen;
418 
419         int lastLen = ilen % AES_BLOCK_SIZE;
420         if (lastLen != 0) {
421             ghashAllToS.update(ct, ctOfs, ilen - lastLen);
422             ghashAllToS.update(
423                     expandToOneBlock(ct, (ctOfs + ilen - lastLen), lastLen));
424         } else {
425             ghashAllToS.update(ct, ctOfs, ilen);
426         }
427     }
428 
429 
430     /**
431      * Performs encryption operation.
432      *
433      * &lt;p&gt;The input plain text &lt;code&gt;in&lt;/code&gt;, starting at &lt;code&gt;inOfs&lt;/code&gt;
434      * and ending at &lt;code&gt;(inOfs + len - 1)&lt;/code&gt;, is encrypted. The result
435      * is stored in &lt;code&gt;out&lt;/code&gt;, starting at &lt;code&gt;outOfs&lt;/code&gt;.
436      *
437      * @param in the buffer with the input data to be encrypted
438      * @param inOfs the offset in &lt;code&gt;in&lt;/code&gt;
439      * @param len the length of the input data
440      * @param out the buffer for the result
441      * @param outOfs the offset in &lt;code&gt;out&lt;/code&gt;
442      * @exception ProviderException if &lt;code&gt;len&lt;/code&gt; is not
443      * a multiple of the block size
444      * @return the number of bytes placed into the &lt;code&gt;out&lt;/code&gt; buffer
445      */
446     int encrypt(byte[] in, int inOfs, int len, byte[] out, int outOfs) {
447         ArrayUtil.blockSizeCheck(len, blockSize);
448 
449         checkDataLength(processed, len);
450 
451         processAAD();
452 
453         if (len &gt; 0) {
454             ArrayUtil.nullAndBoundsCheck(in, inOfs, len);
455             ArrayUtil.nullAndBoundsCheck(out, outOfs, len);
456 
457             gctrPAndC.update(in, inOfs, len, out, outOfs);
458             processed += len;
459             ghashAllToS.update(out, outOfs, len);
460         }
461 
462         return len;
463     }
464 
465     /**
466      * Performs encryption operation for the last time.
467      *
468      * @param in the input buffer with the data to be encrypted
469      * @param inOfs the offset in &lt;code&gt;in&lt;/code&gt;
470      * @param len the length of the input data
471      * @param out the buffer for the encryption result
472      * @param outOfs the offset in &lt;code&gt;out&lt;/code&gt;
473      * @return the number of bytes placed into the &lt;code&gt;out&lt;/code&gt; buffer
474      */
475     int encryptFinal(byte[] in, int inOfs, int len, byte[] out, int outOfs)
476         throws IllegalBlockSizeException, ShortBufferException {
477         if (len &gt; MAX_BUF_SIZE - tagLenBytes) {
478             throw new ShortBufferException
479                 (&quot;Can&#39;t fit both data and tag into one buffer&quot;);
480         }
481         try {
482             ArrayUtil.nullAndBoundsCheck(out, outOfs,
483                 (len + tagLenBytes));
484         } catch (ArrayIndexOutOfBoundsException aiobe) {
485             throw new ShortBufferException(&quot;Output buffer too small&quot;);
486         }
487 
488         checkDataLength(processed, len);
489 
490         processAAD();
491         if (len &gt; 0) {
492             ArrayUtil.nullAndBoundsCheck(in, inOfs, len);
493 
494             doLastBlock(in, inOfs, len, out, outOfs, true);
495         }
496 
497         byte[] lengthBlock =
498             getLengthBlock(sizeOfAAD, processed);
499         ghashAllToS.update(lengthBlock);
500         byte[] s = ghashAllToS.digest();
501         byte[] sOut = new byte[s.length];
502         GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);
503         gctrForSToTag.doFinal(s, 0, s.length, sOut, 0);
504 
505         System.arraycopy(sOut, 0, out, (outOfs + len), tagLenBytes);
506         return (len + tagLenBytes);
507     }
508 
509     /**
510      * Performs decryption operation.
511      *
512      * &lt;p&gt;The input cipher text &lt;code&gt;in&lt;/code&gt;, starting at
513      * &lt;code&gt;inOfs&lt;/code&gt; and ending at &lt;code&gt;(inOfs + len - 1)&lt;/code&gt;,
514      * is decrypted. The result is stored in &lt;code&gt;out&lt;/code&gt;, starting at
515      * &lt;code&gt;outOfs&lt;/code&gt;.
516      *
517      * @param in the buffer with the input data to be decrypted
518      * @param inOfs the offset in &lt;code&gt;in&lt;/code&gt;
519      * @param len the length of the input data
520      * @param out the buffer for the result
521      * @param outOfs the offset in &lt;code&gt;out&lt;/code&gt;
522      * @exception ProviderException if &lt;code&gt;len&lt;/code&gt; is not
523      * a multiple of the block size
524      * @return the number of bytes placed into the &lt;code&gt;out&lt;/code&gt; buffer
525      */
526     int decrypt(byte[] in, int inOfs, int len, byte[] out, int outOfs) {
527         ArrayUtil.blockSizeCheck(len, blockSize);
528 
529         checkDataLength(ibuffer.size(), len);
530 
531         processAAD();
532 
533         if (len &gt; 0) {
534             // store internally until decryptFinal is called because
535             // spec mentioned that only return recovered data after tag
536             // is successfully verified
537             ArrayUtil.nullAndBoundsCheck(in, inOfs, len);
538             ibuffer.write(in, inOfs, len);
539         }
540         return 0;
541     }
542 
543     /**
544      * Performs decryption operation for the last time.
545      *
546      * &lt;p&gt;NOTE: For cipher feedback modes which does not perform
547      * special handling for the last few blocks, this is essentially
548      * the same as &lt;code&gt;encrypt(...)&lt;/code&gt;. Given most modes do
549      * not do special handling, the default impl for this method is
550      * to simply call &lt;code&gt;decrypt(...)&lt;/code&gt;.
551      *
552      * @param in the input buffer with the data to be decrypted
553      * @param inOfs the offset in &lt;code&gt;cipher&lt;/code&gt;
554      * @param len the length of the input data
555      * @param out the buffer for the decryption result
556      * @param outOfs the offset in &lt;code&gt;plain&lt;/code&gt;
557      * @return the number of bytes placed into the &lt;code&gt;out&lt;/code&gt; buffer
558      */
559     int decryptFinal(byte[] in, int inOfs, int len,
560                      byte[] out, int outOfs)
561         throws IllegalBlockSizeException, AEADBadTagException,
562         ShortBufferException {
563         if (len &lt; tagLenBytes) {
564             throw new AEADBadTagException(&quot;Input too short - need tag&quot;);
565         }
566 
567         // do this check here can also catch the potential integer overflow
568         // scenario for the subsequent output buffer capacity check.
569         checkDataLength(ibuffer.size(), (len - tagLenBytes));
570 
571         try {
572             ArrayUtil.nullAndBoundsCheck(out, outOfs,
573                 (ibuffer.size() + len) - tagLenBytes);
574         } catch (ArrayIndexOutOfBoundsException aiobe) {
575             throw new ShortBufferException(&quot;Output buffer too small&quot;);
576         }
577 
578         processAAD();
579 
580         ArrayUtil.nullAndBoundsCheck(in, inOfs, len);
581 
582         // get the trailing tag bytes from &#39;in&#39;
583         byte[] tag = new byte[tagLenBytes];
584         System.arraycopy(in, inOfs + len - tagLenBytes, tag, 0, tagLenBytes);
585         len -= tagLenBytes;
586 
587         // If decryption is in-place or there is buffered &quot;ibuffer&quot; data, copy
588         // the &quot;in&quot; byte array into the ibuffer before proceeding.
589         if (in == out || ibuffer.size() &gt; 0) {
590             if (len &gt; 0) {
591                 ibuffer.write(in, inOfs, len);
592             }
593 
594             // refresh &#39;in&#39; to all buffered-up bytes
595             in = ibuffer.toByteArray();
596             inOfs = 0;
597             len = in.length;
598             ibuffer.reset();
599         }
600 
601         if (len &gt; 0) {
602             doLastBlock(in, inOfs, len, out, outOfs, false);
603         }
604 
605         byte[] lengthBlock =
606             getLengthBlock(sizeOfAAD, processed);
607         ghashAllToS.update(lengthBlock);
608 
609         byte[] s = ghashAllToS.digest();
610         byte[] sOut = new byte[s.length];
611         GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);
612         gctrForSToTag.doFinal(s, 0, s.length, sOut, 0);
613 
614         // check entire authentication tag for time-consistency
615         int mismatch = 0;
616         for (int i = 0; i &lt; tagLenBytes; i++) {
617             mismatch |= tag[i] ^ sOut[i];
618         }
619 
620         if (mismatch != 0) {
621             throw new AEADBadTagException(&quot;Tag mismatch!&quot;);
622         }
623 
624         return len;
625     }
626 
627     // return tag length in bytes
628     int getTagLen() {
629         return this.tagLenBytes;
630     }
631 
632     int getBufferedLength() {
633         if (ibuffer == null) {
634             return 0;
635         } else {
636             return ibuffer.size();
637         }
638     }
639 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
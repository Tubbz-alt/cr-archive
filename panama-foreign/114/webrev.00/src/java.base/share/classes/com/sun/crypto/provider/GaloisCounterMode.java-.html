<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/com/sun/crypto/provider/GaloisCounterMode.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.crypto.provider;
 27 
 28 import java.util.Arrays;
 29 import java.io.*;
 30 import java.security.*;
 31 import javax.crypto.*;
 32 import static com.sun.crypto.provider.AESConstants.AES_BLOCK_SIZE;
 33 import sun.security.util.ArrayUtil;
 34 
 35 
 36 /**
 37  * This class represents ciphers in GaloisCounter (GCM) mode.
 38  *
 39  * &lt;p&gt;This mode currently should only be used w/ AES cipher.
 40  * Although no checking is done, caller should only pass AES
 41  * Cipher to the constructor.
 42  *
 43  * &lt;p&gt;NOTE: Unlike other modes, when used for decryption, this class
 44  * will buffer all processed outputs internally and won&#39;t return them
 45  * until the tag has been successfully verified.
 46  *
 47  * @since 1.8
 48  */
 49 final class GaloisCounterMode extends FeedbackCipher {
 50 
 51     static int DEFAULT_TAG_LEN = AES_BLOCK_SIZE;
 52     static int DEFAULT_IV_LEN = 12; // in bytes
 53 
 54     // In NIST SP 800-38D, GCM input size is limited to be no longer
 55     // than (2^36 - 32) bytes. Otherwise, the counter will wrap
 56     // around and lead to a leak of plaintext.
 57     // However, given the current GCM spec requirement that recovered
 58     // text can only be returned after successful tag verification,
 59     // we are bound by limiting the data size to the size limit of
 60     // java byte array, e.g. Integer.MAX_VALUE, since all data
 61     // can only be returned by the doFinal(...) call.
 62     private static final int MAX_BUF_SIZE = Integer.MAX_VALUE;
 63 
 64     // data size when buffer is divided up to aid in intrinsics
 65     private static final int TRIGGERLEN = 65536;  // 64k
 66 
 67     // buffer for AAD data; if null, meaning update has been called
 68     private ByteArrayOutputStream aadBuffer = new ByteArrayOutputStream();
 69     private int sizeOfAAD = 0;
 70 
 71     // buffer for storing input in decryption, not used for encryption
 72     private ByteArrayOutputStream ibuffer = null;
 73 
 74     // in bytes; need to convert to bits (default value 128) when needed
 75     private int tagLenBytes = DEFAULT_TAG_LEN;
 76 
 77     // these following 2 fields can only be initialized after init() is
 78     // called, e.g. after cipher key k is set, and STAY UNCHANGED
 79     private byte[] subkeyH = null;
 80     private byte[] preCounterBlock = null;
 81 
 82     private GCTR gctrPAndC = null;
 83     private GHASH ghashAllToS = null;
 84 
 85     // length of total data, i.e. len(C)
 86     private int processed = 0;
 87 
 88     // additional variables for save/restore calls
 89     private byte[] aadBufferSave = null;
 90     private int sizeOfAADSave = 0;
 91     private byte[] ibufferSave = null;
 92     private int processedSave = 0;
 93 
 94     // value must be 16-byte long; used by GCTR and GHASH as well
 95     static void increment32(byte[] value) {
 96         if (value.length != AES_BLOCK_SIZE) {
 97             // should never happen
 98             throw new ProviderException(&quot;Illegal counter block length&quot;);
 99         }
100         // start from last byte and only go over 4 bytes, i.e. total 32 bits
101         int n = value.length - 1;
102         while ((n &gt;= value.length - 4) &amp;&amp; (++value[n] == 0)) {
103             n--;
104         }
105     }
106 
107     private static byte[] getLengthBlock(int ivLenInBytes) {
108         long ivLen = ((long)ivLenInBytes) &lt;&lt; 3;
109         byte[] out = new byte[AES_BLOCK_SIZE];
110         out[8] = (byte)(ivLen &gt;&gt;&gt; 56);
111         out[9] = (byte)(ivLen &gt;&gt;&gt; 48);
112         out[10] = (byte)(ivLen &gt;&gt;&gt; 40);
113         out[11] = (byte)(ivLen &gt;&gt;&gt; 32);
114         out[12] = (byte)(ivLen &gt;&gt;&gt; 24);
115         out[13] = (byte)(ivLen &gt;&gt;&gt; 16);
116         out[14] = (byte)(ivLen &gt;&gt;&gt; 8);
117         out[15] = (byte)ivLen;
118         return out;
119     }
120 
121     private static byte[] getLengthBlock(int aLenInBytes, int cLenInBytes) {
122         long aLen = ((long)aLenInBytes) &lt;&lt; 3;
123         long cLen = ((long)cLenInBytes) &lt;&lt; 3;
124         byte[] out = new byte[AES_BLOCK_SIZE];
125         out[0] = (byte)(aLen &gt;&gt;&gt; 56);
126         out[1] = (byte)(aLen &gt;&gt;&gt; 48);
127         out[2] = (byte)(aLen &gt;&gt;&gt; 40);
128         out[3] = (byte)(aLen &gt;&gt;&gt; 32);
129         out[4] = (byte)(aLen &gt;&gt;&gt; 24);
130         out[5] = (byte)(aLen &gt;&gt;&gt; 16);
131         out[6] = (byte)(aLen &gt;&gt;&gt; 8);
132         out[7] = (byte)aLen;
133         out[8] = (byte)(cLen &gt;&gt;&gt; 56);
134         out[9] = (byte)(cLen &gt;&gt;&gt; 48);
135         out[10] = (byte)(cLen &gt;&gt;&gt; 40);
136         out[11] = (byte)(cLen &gt;&gt;&gt; 32);
137         out[12] = (byte)(cLen &gt;&gt;&gt; 24);
138         out[13] = (byte)(cLen &gt;&gt;&gt; 16);
139         out[14] = (byte)(cLen &gt;&gt;&gt; 8);
140         out[15] = (byte)cLen;
141         return out;
142     }
143 
144     private static byte[] expandToOneBlock(byte[] in, int inOfs, int len) {
145         if (len &gt; AES_BLOCK_SIZE) {
146             throw new ProviderException(&quot;input &quot; + len + &quot; too long&quot;);
147         }
148         if (len == AES_BLOCK_SIZE &amp;&amp; inOfs == 0) {
149             return in;
150         } else {
151             byte[] paddedIn = new byte[AES_BLOCK_SIZE];
152             System.arraycopy(in, inOfs, paddedIn, 0, len);
153             return paddedIn;
154         }
155     }
156 
157     private static byte[] getJ0(byte[] iv, byte[] subkeyH) {
158         byte[] j0;
159         if (iv.length == 12) { // 96 bits
160             j0 = expandToOneBlock(iv, 0, iv.length);
161             j0[AES_BLOCK_SIZE - 1] = 1;
162         } else {
163             GHASH g = new GHASH(subkeyH);
164             int lastLen = iv.length % AES_BLOCK_SIZE;
165             if (lastLen != 0) {
166                 g.update(iv, 0, iv.length - lastLen);
167                 byte[] padded =
168                     expandToOneBlock(iv, iv.length - lastLen, lastLen);
169                 g.update(padded);
170             } else {
171                 g.update(iv);
172             }
173             byte[] lengthBlock = getLengthBlock(iv.length);
174             g.update(lengthBlock);
175             j0 = g.digest();
176         }
177         return j0;
178     }
179 
180     private static void checkDataLength(int processed, int len) {
181         if (processed &gt; MAX_BUF_SIZE - len) {
182             throw new ProviderException(&quot;SunJCE provider only supports &quot; +
183                 &quot;input size up to &quot; + MAX_BUF_SIZE + &quot; bytes&quot;);
184         }
185     }
186 
187     GaloisCounterMode(SymmetricCipher embeddedCipher) {
188         super(embeddedCipher);
189         aadBuffer = new ByteArrayOutputStream();
190     }
191 
192     /**
193      * Gets the name of the feedback mechanism
194      *
195      * @return the name of the feedback mechanism
196      */
197     String getFeedback() {
198         return &quot;GCM&quot;;
199     }
200 
201     /**
202      * Resets the cipher object to its original state.
203      * This is used when doFinal is called in the Cipher class, so that the
204      * cipher can be reused (with its original key and iv).
205      */
206     void reset() {
207         if (aadBuffer == null) {
208             aadBuffer = new ByteArrayOutputStream();
209         } else {
210             aadBuffer.reset();
211         }
212         if (gctrPAndC != null) gctrPAndC.reset();
213         if (ghashAllToS != null) ghashAllToS.reset();
214         processed = 0;
215         sizeOfAAD = 0;
216         if (ibuffer != null) {
217             ibuffer.reset();
218         }
219     }
220 
221     /**
222      * Save the current content of this cipher.
223      */
224     void save() {
225         processedSave = processed;
226         sizeOfAADSave = sizeOfAAD;
227         aadBufferSave =
228             ((aadBuffer == null || aadBuffer.size() == 0)?
229              null : aadBuffer.toByteArray());
230         if (gctrPAndC != null) gctrPAndC.save();
231         if (ghashAllToS != null) ghashAllToS.save();
232         if (ibuffer != null) {
233             ibufferSave = ibuffer.toByteArray();
234         }
235     }
236 
237     /**
238      * Restores the content of this cipher to the previous saved one.
239      */
240     void restore() {
241         processed = processedSave;
242         sizeOfAAD = sizeOfAADSave;
243         if (aadBuffer != null) {
244             aadBuffer.reset();
245             if (aadBufferSave != null) {
246                 aadBuffer.write(aadBufferSave, 0, aadBufferSave.length);
247             }
248         }
249         if (gctrPAndC != null) gctrPAndC.restore();
250         if (ghashAllToS != null) ghashAllToS.restore();
251         if (ibuffer != null) {
252             ibuffer.reset();
253             ibuffer.write(ibufferSave, 0, ibufferSave.length);
254         }
255     }
256 
257     /**
258      * Initializes the cipher in the specified mode with the given key
259      * and iv.
260      *
261      * @param decrypting flag indicating encryption or decryption
262      * @param algorithm the algorithm name
263      * @param key the key
264      * @param iv the iv
265      * @param tagLenBytes the length of tag in bytes
266      *
267      * @exception InvalidKeyException if the given key is inappropriate for
268      * initializing this cipher
269      */
270     @Override
271     void init(boolean decrypting, String algorithm, byte[] key, byte[] iv)
272             throws InvalidKeyException, InvalidAlgorithmParameterException {
273         init(decrypting, algorithm, key, iv, DEFAULT_TAG_LEN);
274     }
275 
276     /**
277      * Initializes the cipher in the specified mode with the given key
278      * and iv.
279      *
280      * @param decrypting flag indicating encryption or decryption
281      * @param algorithm the algorithm name
282      * @param key the key
283      * @param iv the iv
284      * @param tagLenBytes the length of tag in bytes
285      *
286      * @exception InvalidKeyException if the given key is inappropriate for
287      * initializing this cipher
288      */
289     void init(boolean decrypting, String algorithm, byte[] keyValue,
290               byte[] ivValue, int tagLenBytes)
291               throws InvalidKeyException, InvalidAlgorithmParameterException {
292         if (keyValue == null) {
293             throw new InvalidKeyException(&quot;Internal error&quot;);
294         }
295         if (ivValue == null) {
296             throw new InvalidAlgorithmParameterException(&quot;Internal error&quot;);
297         }
298         if (ivValue.length == 0) {
299             throw new InvalidAlgorithmParameterException(&quot;IV is empty&quot;);
300         }
301 
302         // always encrypt mode for embedded cipher
303         this.embeddedCipher.init(false, algorithm, keyValue);
304         this.subkeyH = new byte[AES_BLOCK_SIZE];
305         this.embeddedCipher.encryptBlock(new byte[AES_BLOCK_SIZE], 0,
306                 this.subkeyH, 0);
307 
308         this.iv = ivValue.clone();
309         preCounterBlock = getJ0(iv, subkeyH);
310         byte[] j0Plus1 = preCounterBlock.clone();
311         increment32(j0Plus1);
312         gctrPAndC = new GCTR(embeddedCipher, j0Plus1);
313         ghashAllToS = new GHASH(subkeyH);
314 
315         this.tagLenBytes = tagLenBytes;
316         if (aadBuffer == null) {
317             aadBuffer = new ByteArrayOutputStream();
318         } else {
319             aadBuffer.reset();
320         }
321         processed = 0;
322         sizeOfAAD = 0;
323         if (decrypting) {
324             ibuffer = new ByteArrayOutputStream();
325         }
326     }
327 
328     /**
329      * Continues a multi-part update of the Additional Authentication
330      * Data (AAD), using a subset of the provided buffer. If this
331      * cipher is operating in either GCM or CCM mode, all AAD must be
332      * supplied before beginning operations on the ciphertext (via the
333      * {@code update} and {@code doFinal} methods).
334      * &lt;p&gt;
335      * NOTE: Given most modes do not accept AAD, default impl for this
336      * method throws IllegalStateException.
337      *
338      * @param src the buffer containing the AAD
339      * @param offset the offset in {@code src} where the AAD input starts
340      * @param len the number of AAD bytes
341      *
342      * @throws IllegalStateException if this cipher is in a wrong state
343      * (e.g., has not been initialized), does not accept AAD, or if
344      * operating in either GCM or CCM mode and one of the {@code update}
345      * methods has already been called for the active
346      * encryption/decryption operation
347      * @throws UnsupportedOperationException if this method
348      * has not been overridden by an implementation
349      *
350      * @since 1.8
351      */
352     void updateAAD(byte[] src, int offset, int len) {
353         if (aadBuffer != null) {
354             aadBuffer.write(src, offset, len);
355         } else {
356             // update has already been called
357             throw new IllegalStateException
358                 (&quot;Update has been called; no more AAD data&quot;);
359         }
360     }
361 
362     // Feed the AAD data to GHASH, pad if necessary
363     void processAAD() {
364         if (aadBuffer != null) {
365             if (aadBuffer.size() &gt; 0) {
366                 byte[] aad = aadBuffer.toByteArray();
367                 sizeOfAAD = aad.length;
368 
369                 int lastLen = aad.length % AES_BLOCK_SIZE;
370                 if (lastLen != 0) {
371                     ghashAllToS.update(aad, 0, aad.length - lastLen);
372                     byte[] padded = expandToOneBlock(aad, aad.length - lastLen,
373                                                      lastLen);
374                     ghashAllToS.update(padded);
375                 } else {
376                     ghashAllToS.update(aad);
377                 }
378             }
379             aadBuffer = null;
380         }
381     }
382 
383     // Utility to process the last block; used by encryptFinal and decryptFinal
384     void doLastBlock(byte[] in, int inOfs, int len, byte[] out, int outOfs,
385                      boolean isEncrypt) throws IllegalBlockSizeException {
386         byte[] ct;
387         int ctOfs;
388         int ilen = len;  // internal length
389 
390         if (isEncrypt) {
391             ct = out;
392             ctOfs = outOfs;
393         } else {
394             ct = in;
395             ctOfs = inOfs;
396         }
397 
398         // Divide up larger data sizes to trigger CTR &amp; GHASH intrinsic quicker
399         if (len &gt; TRIGGERLEN) {
400             int i = 0;
401             int tlen;  // incremental lengths
402             final int plen = AES_BLOCK_SIZE * 6;
403             // arbitrary formula to aid intrinsic without reaching buffer end
404             final int count = len / 1024;
405 
406             while (count &gt; i) {
407                 tlen = gctrPAndC.update(in, inOfs, plen, out, outOfs);
408                 ghashAllToS.update(ct, ctOfs, tlen);
409                 inOfs += tlen;
410                 outOfs += tlen;
411                 ctOfs += tlen;
412                 i++;
413             }
414             ilen -= count * plen;
415             processed += count * plen;
416         }
417 
418         gctrPAndC.doFinal(in, inOfs, ilen, out, outOfs);
419         processed += ilen;
420 
421         int lastLen = ilen % AES_BLOCK_SIZE;
422         if (lastLen != 0) {
423             ghashAllToS.update(ct, ctOfs, ilen - lastLen);
424             ghashAllToS.update(
425                     expandToOneBlock(ct, (ctOfs + ilen - lastLen), lastLen));
426         } else {
427             ghashAllToS.update(ct, ctOfs, ilen);
428         }
429     }
430 
431 
432     /**
433      * Performs encryption operation.
434      *
435      * &lt;p&gt;The input plain text &lt;code&gt;in&lt;/code&gt;, starting at &lt;code&gt;inOfs&lt;/code&gt;
436      * and ending at &lt;code&gt;(inOfs + len - 1)&lt;/code&gt;, is encrypted. The result
437      * is stored in &lt;code&gt;out&lt;/code&gt;, starting at &lt;code&gt;outOfs&lt;/code&gt;.
438      *
439      * @param in the buffer with the input data to be encrypted
440      * @param inOfs the offset in &lt;code&gt;in&lt;/code&gt;
441      * @param len the length of the input data
442      * @param out the buffer for the result
443      * @param outOfs the offset in &lt;code&gt;out&lt;/code&gt;
444      * @exception ProviderException if &lt;code&gt;len&lt;/code&gt; is not
445      * a multiple of the block size
446      * @return the number of bytes placed into the &lt;code&gt;out&lt;/code&gt; buffer
447      */
448     int encrypt(byte[] in, int inOfs, int len, byte[] out, int outOfs) {
449         ArrayUtil.blockSizeCheck(len, blockSize);
450 
451         checkDataLength(processed, len);
452 
453         processAAD();
454 
455         if (len &gt; 0) {
456             ArrayUtil.nullAndBoundsCheck(in, inOfs, len);
457             ArrayUtil.nullAndBoundsCheck(out, outOfs, len);
458 
459             gctrPAndC.update(in, inOfs, len, out, outOfs);
460             processed += len;
461             ghashAllToS.update(out, outOfs, len);
462         }
463 
464         return len;
465     }
466 
467     /**
468      * Performs encryption operation for the last time.
469      *
470      * @param in the input buffer with the data to be encrypted
471      * @param inOfs the offset in &lt;code&gt;in&lt;/code&gt;
472      * @param len the length of the input data
473      * @param out the buffer for the encryption result
474      * @param outOfs the offset in &lt;code&gt;out&lt;/code&gt;
475      * @return the number of bytes placed into the &lt;code&gt;out&lt;/code&gt; buffer
476      */
477     int encryptFinal(byte[] in, int inOfs, int len, byte[] out, int outOfs)
478         throws IllegalBlockSizeException, ShortBufferException {
479         if (len &gt; MAX_BUF_SIZE - tagLenBytes) {
480             throw new ShortBufferException
481                 (&quot;Can&#39;t fit both data and tag into one buffer&quot;);
482         }
483         try {
484             ArrayUtil.nullAndBoundsCheck(out, outOfs,
485                 (len + tagLenBytes));
486         } catch (ArrayIndexOutOfBoundsException aiobe) {
487             throw new ShortBufferException(&quot;Output buffer too small&quot;);
488         }
489 
490         checkDataLength(processed, len);
491 
492         processAAD();
493         if (len &gt; 0) {
494             ArrayUtil.nullAndBoundsCheck(in, inOfs, len);
495 
496             doLastBlock(in, inOfs, len, out, outOfs, true);
497         }
498 
499         byte[] lengthBlock =
500             getLengthBlock(sizeOfAAD, processed);
501         ghashAllToS.update(lengthBlock);
502         byte[] s = ghashAllToS.digest();
503         byte[] sOut = new byte[s.length];
504         GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);
505         gctrForSToTag.doFinal(s, 0, s.length, sOut, 0);
506 
507         System.arraycopy(sOut, 0, out, (outOfs + len), tagLenBytes);
508         return (len + tagLenBytes);
509     }
510 
511     /**
512      * Performs decryption operation.
513      *
514      * &lt;p&gt;The input cipher text &lt;code&gt;in&lt;/code&gt;, starting at
515      * &lt;code&gt;inOfs&lt;/code&gt; and ending at &lt;code&gt;(inOfs + len - 1)&lt;/code&gt;,
516      * is decrypted. The result is stored in &lt;code&gt;out&lt;/code&gt;, starting at
517      * &lt;code&gt;outOfs&lt;/code&gt;.
518      *
519      * @param in the buffer with the input data to be decrypted
520      * @param inOfs the offset in &lt;code&gt;in&lt;/code&gt;
521      * @param len the length of the input data
522      * @param out the buffer for the result
523      * @param outOfs the offset in &lt;code&gt;out&lt;/code&gt;
524      * @exception ProviderException if &lt;code&gt;len&lt;/code&gt; is not
525      * a multiple of the block size
526      * @return the number of bytes placed into the &lt;code&gt;out&lt;/code&gt; buffer
527      */
528     int decrypt(byte[] in, int inOfs, int len, byte[] out, int outOfs) {
529         ArrayUtil.blockSizeCheck(len, blockSize);
530 
531         checkDataLength(ibuffer.size(), len);
532 
533         processAAD();
534 
535         if (len &gt; 0) {
536             // store internally until decryptFinal is called because
537             // spec mentioned that only return recovered data after tag
538             // is successfully verified
539             ArrayUtil.nullAndBoundsCheck(in, inOfs, len);
540             ibuffer.write(in, inOfs, len);
541         }
542         return 0;
543     }
544 
545     /**
546      * Performs decryption operation for the last time.
547      *
548      * &lt;p&gt;NOTE: For cipher feedback modes which does not perform
549      * special handling for the last few blocks, this is essentially
550      * the same as &lt;code&gt;encrypt(...)&lt;/code&gt;. Given most modes do
551      * not do special handling, the default impl for this method is
552      * to simply call &lt;code&gt;decrypt(...)&lt;/code&gt;.
553      *
554      * @param in the input buffer with the data to be decrypted
555      * @param inOfs the offset in &lt;code&gt;cipher&lt;/code&gt;
556      * @param len the length of the input data
557      * @param out the buffer for the decryption result
558      * @param outOfs the offset in &lt;code&gt;plain&lt;/code&gt;
559      * @return the number of bytes placed into the &lt;code&gt;out&lt;/code&gt; buffer
560      */
561     int decryptFinal(byte[] in, int inOfs, int len,
562                      byte[] out, int outOfs)
563         throws IllegalBlockSizeException, AEADBadTagException,
564         ShortBufferException {
565         if (len &lt; tagLenBytes) {
566             throw new AEADBadTagException(&quot;Input too short - need tag&quot;);
567         }
568 
569         // do this check here can also catch the potential integer overflow
570         // scenario for the subsequent output buffer capacity check.
571         checkDataLength(ibuffer.size(), (len - tagLenBytes));
572 
573         try {
574             ArrayUtil.nullAndBoundsCheck(out, outOfs,
575                 (ibuffer.size() + len) - tagLenBytes);
576         } catch (ArrayIndexOutOfBoundsException aiobe) {
577             throw new ShortBufferException(&quot;Output buffer too small&quot;);
578         }
579 
580         processAAD();
581 
582         ArrayUtil.nullAndBoundsCheck(in, inOfs, len);
583 
584         // get the trailing tag bytes from &#39;in&#39;
585         byte[] tag = new byte[tagLenBytes];
586         System.arraycopy(in, inOfs + len - tagLenBytes, tag, 0, tagLenBytes);
587         len -= tagLenBytes;
588 
589         // If decryption is in-place or there is buffered &quot;ibuffer&quot; data, copy
590         // the &quot;in&quot; byte array into the ibuffer before proceeding.
591         if (in == out || ibuffer.size() &gt; 0) {
592             if (len &gt; 0) {
593                 ibuffer.write(in, inOfs, len);
594             }
595 
596             // refresh &#39;in&#39; to all buffered-up bytes
597             in = ibuffer.toByteArray();
598             inOfs = 0;
599             len = in.length;
600             ibuffer.reset();
601         }
602 
603         if (len &gt; 0) {
604             doLastBlock(in, inOfs, len, out, outOfs, false);
605         }
606 
607         byte[] lengthBlock =
608             getLengthBlock(sizeOfAAD, processed);
609         ghashAllToS.update(lengthBlock);
610 
611         byte[] s = ghashAllToS.digest();
612         byte[] sOut = new byte[s.length];
613         GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);
614         gctrForSToTag.doFinal(s, 0, s.length, sOut, 0);
615 
616         // check entire authentication tag for time-consistency
617         int mismatch = 0;
618         for (int i = 0; i &lt; tagLenBytes; i++) {
619             mismatch |= tag[i] ^ sOut[i];
620         }
621 
622         if (mismatch != 0) {
623             throw new AEADBadTagException(&quot;Tag mismatch!&quot;);
624         }
625 
626         return len;
627     }
628 
629     // return tag length in bytes
630     int getTagLen() {
631         return this.tagLenBytes;
632     }
633 
634     int getBufferedLength() {
635         if (ibuffer == null) {
636             return 0;
637         } else {
638             return ibuffer.size();
639         }
640     }
641 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Lower.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.stream.Collectors;
  30 
  31 import com.sun.tools.javac.code.*;
  32 import com.sun.tools.javac.code.Kinds.KindSelector;
  33 import com.sun.tools.javac.code.Scope.WriteableScope;
  34 import com.sun.tools.javac.jvm.*;
  35 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
  36 import com.sun.tools.javac.main.Option.PkgInfo;
  37 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  38 import com.sun.tools.javac.tree.*;
  39 import com.sun.tools.javac.util.*;
  40 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  41 import com.sun.tools.javac.util.List;
  42 
  43 import com.sun.tools.javac.code.Symbol.*;
  44 import com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode;
  45 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  46 import com.sun.tools.javac.tree.JCTree.*;
  47 import com.sun.tools.javac.code.Type.*;
  48 
  49 import com.sun.tools.javac.jvm.Target;
  50 import com.sun.tools.javac.tree.EndPosTable;
  51 
  52 import static com.sun.tools.javac.code.Flags.*;
  53 import static com.sun.tools.javac.code.Flags.BLOCK;
  54 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  55 import static com.sun.tools.javac.code.TypeTag.*;
  56 import static com.sun.tools.javac.code.Kinds.Kind.*;
  57 import static com.sun.tools.javac.jvm.ByteCodes.*;
  58 import com.sun.tools.javac.tree.JCTree.JCBreak;
  59 import com.sun.tools.javac.tree.JCTree.JCCase;
  60 import com.sun.tools.javac.tree.JCTree.JCExpression;
  61 import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;
  62 import static com.sun.tools.javac.tree.JCTree.JCOperatorExpression.OperandPos.LEFT;
  63 import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;
  64 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  65 
  66 /** This pass translates away some syntactic sugar: inner classes,
  67  *  class literals, assertions, foreach loops, etc.
  68  *
  69  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  70  *  If you write code that depends on this, you do so at your own risk.
  71  *  This code and its internal interfaces are subject to change or
  72  *  deletion without notice.&lt;/b&gt;
  73  */
  74 public class Lower extends TreeTranslator {
  75     protected static final Context.Key&lt;Lower&gt; lowerKey = new Context.Key&lt;&gt;();
  76 
  77     public static Lower instance(Context context) {
  78         Lower instance = context.get(lowerKey);
  79         if (instance == null)
  80             instance = new Lower(context);
  81         return instance;
  82     }
  83 
  84     private final Names names;
  85     private final Log log;
  86     private final Symtab syms;
  87     private final Resolve rs;
  88     private final Operators operators;
  89     private final Check chk;
  90     private final Attr attr;
  91     private TreeMaker make;
  92     private DiagnosticPosition make_pos;
  93     private final ConstFold cfolder;
  94     private final Target target;
  95     private final Source source;
  96     private final TypeEnvs typeEnvs;
  97     private final Name dollarAssertionsDisabled;
  98     private final Name classDollar;
  99     private final Name dollarCloseResource;
 100     private final Types types;
 101     private final boolean debugLower;
 102     private final boolean disableProtectedAccessors; // experimental
 103     private final PkgInfo pkginfoOpt;
 104 
 105     protected Lower(Context context) {
 106         context.put(lowerKey, this);
 107         names = Names.instance(context);
 108         log = Log.instance(context);
 109         syms = Symtab.instance(context);
 110         rs = Resolve.instance(context);
 111         operators = Operators.instance(context);
 112         chk = Check.instance(context);
 113         attr = Attr.instance(context);
 114         make = TreeMaker.instance(context);
 115         cfolder = ConstFold.instance(context);
 116         target = Target.instance(context);
 117         source = Source.instance(context);
 118         typeEnvs = TypeEnvs.instance(context);
 119         dollarAssertionsDisabled = names.
 120             fromString(target.syntheticNameChar() + &quot;assertionsDisabled&quot;);
 121         classDollar = names.
 122             fromString(&quot;class&quot; + target.syntheticNameChar());
 123         dollarCloseResource = names.
 124             fromString(target.syntheticNameChar() + &quot;closeResource&quot;);
 125 
 126         types = Types.instance(context);
 127         Options options = Options.instance(context);
 128         debugLower = options.isSet(&quot;debuglower&quot;);
 129         pkginfoOpt = PkgInfo.get(options);
 130         disableProtectedAccessors = options.isSet(&quot;disableProtectedAccessors&quot;);
 131     }
 132 
 133     /** The currently enclosing class.
 134      */
 135     ClassSymbol currentClass;
 136 
 137     /** A queue of all translated classes.
 138      */
 139     ListBuffer&lt;JCTree&gt; translated;
 140 
 141     /** Environment for symbol lookup, set by translateTopLevelClass.
 142      */
 143     Env&lt;AttrContext&gt; attrEnv;
 144 
 145     /** A hash table mapping syntax trees to their ending source positions.
 146      */
 147     EndPosTable endPosTable;
 148 
 149 /**************************************************************************
 150  * Global mappings
 151  *************************************************************************/
 152 
 153     /** A hash table mapping local classes to their definitions.
 154      */
 155     Map&lt;ClassSymbol, JCClassDecl&gt; classdefs;
 156 
 157     /** A hash table mapping local classes to a list of pruned trees.
 158      */
 159     public Map&lt;ClassSymbol, List&lt;JCTree&gt;&gt; prunedTree = new WeakHashMap&lt;&gt;();
 160 
 161     /** A hash table mapping virtual accessed symbols in outer subclasses
 162      *  to the actually referred symbol in superclasses.
 163      */
 164     Map&lt;Symbol,Symbol&gt; actualSymbols;
 165 
 166     /** The current method definition.
 167      */
 168     JCMethodDecl currentMethodDef;
 169 
 170     /** The current method symbol.
 171      */
 172     MethodSymbol currentMethodSym;
 173 
 174     /** The currently enclosing outermost class definition.
 175      */
 176     JCClassDecl outermostClassDef;
 177 
 178     /** The currently enclosing outermost member definition.
 179      */
 180     JCTree outermostMemberDef;
 181 
 182     /** A map from local variable symbols to their translation (as per LambdaToMethod).
 183      * This is required when a capturing local class is created from a lambda (in which
 184      * case the captured symbols should be replaced with the translated lambda symbols).
 185      */
 186     Map&lt;Symbol, Symbol&gt; lambdaTranslationMap = null;
 187 
 188     /** A navigator class for assembling a mapping from local class symbols
 189      *  to class definition trees.
 190      *  There is only one case; all other cases simply traverse down the tree.
 191      */
 192     class ClassMap extends TreeScanner {
 193 
 194         /** All encountered class defs are entered into classdefs table.
 195          */
 196         public void visitClassDef(JCClassDecl tree) {
 197             classdefs.put(tree.sym, tree);
 198             super.visitClassDef(tree);
 199         }
 200     }
 201     ClassMap classMap = new ClassMap();
 202 
 203     /** Map a class symbol to its definition.
 204      *  @param c    The class symbol of which we want to determine the definition.
 205      */
 206     JCClassDecl classDef(ClassSymbol c) {
 207         // First lookup the class in the classdefs table.
 208         JCClassDecl def = classdefs.get(c);
 209         if (def == null &amp;&amp; outermostMemberDef != null) {
 210             // If this fails, traverse outermost member definition, entering all
 211             // local classes into classdefs, and try again.
 212             classMap.scan(outermostMemberDef);
 213             def = classdefs.get(c);
 214         }
 215         if (def == null) {
 216             // If this fails, traverse outermost class definition, entering all
 217             // local classes into classdefs, and try again.
 218             classMap.scan(outermostClassDef);
 219             def = classdefs.get(c);
 220         }
 221         return def;
 222     }
 223 
 224     /** A hash table mapping class symbols to lists of free variables.
 225      *  accessed by them. Only free variables of the method immediately containing
 226      *  a class are associated with that class.
 227      */
 228     Map&lt;ClassSymbol,List&lt;VarSymbol&gt;&gt; freevarCache;
 229 
 230     /** A navigator class for collecting the free variables accessed
 231      *  from a local class. There is only one case; all other cases simply
 232      *  traverse down the tree. This class doesn&#39;t deal with the specific
 233      *  of Lower - it&#39;s an abstract visitor that is meant to be reused in
 234      *  order to share the local variable capture logic.
 235      */
 236     abstract class BasicFreeVarCollector extends TreeScanner {
 237 
 238         /** Add all free variables of class c to fvs list
 239          *  unless they are already there.
 240          */
 241         abstract void addFreeVars(ClassSymbol c);
 242 
 243         /** If tree refers to a variable in owner of local class, add it to
 244          *  free variables list.
 245          */
 246         public void visitIdent(JCIdent tree) {
 247             visitSymbol(tree.sym);
 248         }
 249         // where
 250         abstract void visitSymbol(Symbol _sym);
 251 
 252         /** If tree refers to a class instance creation expression
 253          *  add all free variables of the freshly created class.
 254          */
 255         public void visitNewClass(JCNewClass tree) {
 256             ClassSymbol c = (ClassSymbol)tree.constructor.owner;
 257             addFreeVars(c);
 258             super.visitNewClass(tree);
 259         }
 260 
 261         /** If tree refers to a superclass constructor call,
 262          *  add all free variables of the superclass.
 263          */
 264         public void visitApply(JCMethodInvocation tree) {
 265             if (TreeInfo.name(tree.meth) == names._super) {
 266                 addFreeVars((ClassSymbol) TreeInfo.symbol(tree.meth).owner);
 267             }
 268             super.visitApply(tree);
 269         }
 270 
 271         @Override
 272         public void visitYield(JCYield tree) {
 273             scan(tree.value);
 274         }
 275 
 276     }
 277 
 278     /**
 279      * Lower-specific subclass of {@code BasicFreeVarCollector}.
 280      */
 281     class FreeVarCollector extends BasicFreeVarCollector {
 282 
 283         /** The owner of the local class.
 284          */
 285         Symbol owner;
 286 
 287         /** The local class.
 288          */
 289         ClassSymbol clazz;
 290 
 291         /** The list of owner&#39;s variables accessed from within the local class,
 292          *  without any duplicates.
 293          */
 294         List&lt;VarSymbol&gt; fvs;
 295 
 296         FreeVarCollector(ClassSymbol clazz) {
 297             this.clazz = clazz;
 298             this.owner = clazz.owner;
 299             this.fvs = List.nil();
 300         }
 301 
 302         /** Add free variable to fvs list unless it is already there.
 303          */
 304         private void addFreeVar(VarSymbol v) {
 305             for (List&lt;VarSymbol&gt; l = fvs; l.nonEmpty(); l = l.tail)
 306                 if (l.head == v) return;
 307             fvs = fvs.prepend(v);
 308         }
 309 
 310         @Override
 311         void addFreeVars(ClassSymbol c) {
 312             List&lt;VarSymbol&gt; fvs = freevarCache.get(c);
 313             if (fvs != null) {
 314                 for (List&lt;VarSymbol&gt; l = fvs; l.nonEmpty(); l = l.tail) {
 315                     addFreeVar(l.head);
 316                 }
 317             }
 318         }
 319 
 320         @Override
 321         void visitSymbol(Symbol _sym) {
 322             Symbol sym = _sym;
 323             if (sym.kind == VAR || sym.kind == MTH) {
 324                 if (sym != null &amp;&amp; sym.owner != owner)
 325                     sym = proxies.get(sym);
 326                 if (sym != null &amp;&amp; sym.owner == owner) {
 327                     VarSymbol v = (VarSymbol)sym;
 328                     if (v.getConstValue() == null) {
 329                         addFreeVar(v);
 330                     }
 331                 } else {
 332                     if (outerThisStack.head != null &amp;&amp;
 333                         outerThisStack.head != _sym)
 334                         visitSymbol(outerThisStack.head);
 335                 }
 336             }
 337         }
 338 
 339         /** If tree refers to a class instance creation expression
 340          *  add all free variables of the freshly created class.
 341          */
 342         public void visitNewClass(JCNewClass tree) {
 343             ClassSymbol c = (ClassSymbol)tree.constructor.owner;
 344             if (tree.encl == null &amp;&amp;
 345                 c.hasOuterInstance() &amp;&amp;
 346                 outerThisStack.head != null)
 347                 visitSymbol(outerThisStack.head);
 348             super.visitNewClass(tree);
 349         }
 350 
 351         /** If tree refers to a qualified this or super expression
 352          *  for anything but the current class, add the outer this
 353          *  stack as a free variable.
 354          */
 355         public void visitSelect(JCFieldAccess tree) {
 356             if ((tree.name == names._this || tree.name == names._super) &amp;&amp;
 357                 tree.selected.type.tsym != clazz &amp;&amp;
 358                 outerThisStack.head != null)
 359                 visitSymbol(outerThisStack.head);
 360             super.visitSelect(tree);
 361         }
 362 
 363         /** If tree refers to a superclass constructor call,
 364          *  add all free variables of the superclass.
 365          */
 366         public void visitApply(JCMethodInvocation tree) {
 367             if (TreeInfo.name(tree.meth) == names._super) {
 368                 Symbol constructor = TreeInfo.symbol(tree.meth);
 369                 ClassSymbol c = (ClassSymbol)constructor.owner;
 370                 if (c.hasOuterInstance() &amp;&amp;
 371                     !tree.meth.hasTag(SELECT) &amp;&amp;
 372                     outerThisStack.head != null)
 373                     visitSymbol(outerThisStack.head);
 374             }
 375             super.visitApply(tree);
 376         }
 377 
 378     }
 379 
 380     ClassSymbol ownerToCopyFreeVarsFrom(ClassSymbol c) {
 381         if (!c.isLocal()) {
 382             return null;
 383         }
 384         Symbol currentOwner = c.owner;
 385         while (currentOwner.owner.kind.matches(KindSelector.TYP) &amp;&amp; currentOwner.isLocal()) {
 386             currentOwner = currentOwner.owner;
 387         }
 388         if (currentOwner.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp; c.isSubClass(currentOwner, types)) {
 389             return (ClassSymbol)currentOwner;
 390         }
 391         return null;
 392     }
 393 
 394     /** Return the variables accessed from within a local class, which
 395      *  are declared in the local class&#39; owner.
 396      *  (in reverse order of first access).
 397      */
 398     List&lt;VarSymbol&gt; freevars(ClassSymbol c)  {
 399         List&lt;VarSymbol&gt; fvs = freevarCache.get(c);
 400         if (fvs != null) {
 401             return fvs;
 402         }
 403         if (c.owner.kind.matches(KindSelector.VAL_MTH)) {
 404             FreeVarCollector collector = new FreeVarCollector(c);
 405             collector.scan(classDef(c));
 406             fvs = collector.fvs;
 407             freevarCache.put(c, fvs);
 408             return fvs;
 409         } else {
 410             ClassSymbol owner = ownerToCopyFreeVarsFrom(c);
 411             if (owner != null) {
 412                 fvs = freevarCache.get(owner);
 413                 freevarCache.put(c, fvs);
 414                 return fvs;
 415             } else {
 416                 return List.nil();
 417             }
 418         }
 419     }
 420 
 421     Map&lt;TypeSymbol,EnumMapping&gt; enumSwitchMap = new LinkedHashMap&lt;&gt;();
 422 
 423     EnumMapping mapForEnum(DiagnosticPosition pos, TypeSymbol enumClass) {
 424         EnumMapping map = enumSwitchMap.get(enumClass);
 425         if (map == null)
 426             enumSwitchMap.put(enumClass, map = new EnumMapping(pos, enumClass));
 427         return map;
 428     }
 429 
 430     /** This map gives a translation table to be used for enum
 431      *  switches.
 432      *
 433      *  &lt;p&gt;For each enum that appears as the type of a switch
 434      *  expression, we maintain an EnumMapping to assist in the
 435      *  translation, as exemplified by the following example:
 436      *
 437      *  &lt;p&gt;we translate
 438      *  &lt;pre&gt;
 439      *          switch(colorExpression) {
 440      *          case red: stmt1;
 441      *          case green: stmt2;
 442      *          }
 443      *  &lt;/pre&gt;
 444      *  into
 445      *  &lt;pre&gt;
 446      *          switch(Outer$0.$EnumMap$Color[colorExpression.ordinal()]) {
 447      *          case 1: stmt1;
 448      *          case 2: stmt2
 449      *          }
 450      *  &lt;/pre&gt;
 451      *  with the auxiliary table initialized as follows:
 452      *  &lt;pre&gt;
 453      *          class Outer$0 {
 454      *              synthetic final int[] $EnumMap$Color = new int[Color.values().length];
 455      *              static {
 456      *                  try { $EnumMap$Color[red.ordinal()] = 1; } catch (NoSuchFieldError ex) {}
 457      *                  try { $EnumMap$Color[green.ordinal()] = 2; } catch (NoSuchFieldError ex) {}
 458      *              }
 459      *          }
 460      *  &lt;/pre&gt;
 461      *  class EnumMapping provides mapping data and support methods for this translation.
 462      */
 463     class EnumMapping {
 464         EnumMapping(DiagnosticPosition pos, TypeSymbol forEnum) {
 465             this.forEnum = forEnum;
 466             this.values = new LinkedHashMap&lt;&gt;();
 467             this.pos = pos;
 468             Name varName = names
 469                 .fromString(target.syntheticNameChar() +
 470                             &quot;SwitchMap&quot; +
 471                             target.syntheticNameChar() +
 472                             names.fromUtf(ClassWriter.externalize(forEnum.type.tsym.flatName())).toString()
 473                             .replace(&#39;/&#39;, &#39;.&#39;)
 474                             .replace(&#39;.&#39;, target.syntheticNameChar()));
 475             ClassSymbol outerCacheClass = outerCacheClass();
 476             this.mapVar = new VarSymbol(STATIC | SYNTHETIC | FINAL,
 477                                         varName,
 478                                         new ArrayType(syms.intType, syms.arrayClass),
 479                                         outerCacheClass);
 480             enterSynthetic(pos, mapVar, outerCacheClass.members());
 481         }
 482 
 483         DiagnosticPosition pos = null;
 484 
 485         // the next value to use
 486         int next = 1; // 0 (unused map elements) go to the default label
 487 
 488         // the enum for which this is a map
 489         final TypeSymbol forEnum;
 490 
 491         // the field containing the map
 492         final VarSymbol mapVar;
 493 
 494         // the mapped values
 495         final Map&lt;VarSymbol,Integer&gt; values;
 496 
 497         JCLiteral forConstant(VarSymbol v) {
 498             Integer result = values.get(v);
 499             if (result == null)
 500                 values.put(v, result = next++);
 501             return make.Literal(result);
 502         }
 503 
 504         // generate the field initializer for the map
 505         void translate() {
 506             make.at(pos.getStartPosition());
 507             JCClassDecl owner = classDef((ClassSymbol)mapVar.owner);
 508 
 509             // synthetic static final int[] $SwitchMap$Color = new int[Color.values().length];
 510             MethodSymbol valuesMethod = lookupMethod(pos,
 511                                                      names.values,
 512                                                      forEnum.type,
 513                                                      List.nil());
 514             JCExpression size = make // Color.values().length
 515                 .Select(make.App(make.QualIdent(valuesMethod)),
 516                         syms.lengthVar);
 517             JCExpression mapVarInit = make
 518                 .NewArray(make.Type(syms.intType), List.of(size), null)
 519                 .setType(new ArrayType(syms.intType, syms.arrayClass));
 520 
 521             // try { $SwitchMap$Color[red.ordinal()] = 1; } catch (java.lang.NoSuchFieldError ex) {}
 522             ListBuffer&lt;JCStatement&gt; stmts = new ListBuffer&lt;&gt;();
 523             Symbol ordinalMethod = lookupMethod(pos,
 524                                                 names.ordinal,
 525                                                 forEnum.type,
 526                                                 List.nil());
 527             List&lt;JCCatch&gt; catcher = List.&lt;JCCatch&gt;nil()
 528                 .prepend(make.Catch(make.VarDef(new VarSymbol(PARAMETER, names.ex,
 529                                                               syms.noSuchFieldErrorType,
 530                                                               syms.noSymbol),
 531                                                 null),
 532                                     make.Block(0, List.nil())));
 533             for (Map.Entry&lt;VarSymbol,Integer&gt; e : values.entrySet()) {
 534                 VarSymbol enumerator = e.getKey();
 535                 Integer mappedValue = e.getValue();
 536                 JCExpression assign = make
 537                     .Assign(make.Indexed(mapVar,
 538                                          make.App(make.Select(make.QualIdent(enumerator),
 539                                                               ordinalMethod))),
 540                             make.Literal(mappedValue))
 541                     .setType(syms.intType);
 542                 JCStatement exec = make.Exec(assign);
 543                 JCStatement _try = make.Try(make.Block(0, List.of(exec)), catcher, null);
 544                 stmts.append(_try);
 545             }
 546 
 547             owner.defs = owner.defs
 548                 .prepend(make.Block(STATIC, stmts.toList()))
 549                 .prepend(make.VarDef(mapVar, mapVarInit));
 550         }
 551     }
 552 
 553 
 554 /**************************************************************************
 555  * Tree building blocks
 556  *************************************************************************/
 557 
 558     /** Equivalent to make.at(pos.getStartPosition()) with side effect of caching
 559      *  pos as make_pos, for use in diagnostics.
 560      **/
 561     TreeMaker make_at(DiagnosticPosition pos) {
 562         make_pos = pos;
 563         return make.at(pos);
 564     }
 565 
 566     /** Make an attributed tree representing a literal. This will be an
 567      *  Ident node in the case of boolean literals, a Literal node in all
 568      *  other cases.
 569      *  @param type       The literal&#39;s type.
 570      *  @param value      The literal&#39;s value.
 571      */
 572     JCExpression makeLit(Type type, Object value) {
 573         return make.Literal(type.getTag(), value).setType(type.constType(value));
 574     }
 575 
 576     /** Make an attributed tree representing null.
 577      */
 578     JCExpression makeNull() {
 579         return makeLit(syms.botType, null);
 580     }
 581 
 582     /** Make an attributed class instance creation expression.
 583      *  @param ctype    The class type.
 584      *  @param args     The constructor arguments.
 585      */
 586     JCNewClass makeNewClass(Type ctype, List&lt;JCExpression&gt; args) {
 587         JCNewClass tree = make.NewClass(null,
 588             null, make.QualIdent(ctype.tsym), args, null);
 589         tree.constructor = rs.resolveConstructor(
 590             make_pos, attrEnv, ctype, TreeInfo.types(args), List.nil());
 591         tree.type = ctype;
 592         return tree;
 593     }
 594 
 595     /** Make an attributed unary expression.
 596      *  @param optag    The operators tree tag.
 597      *  @param arg      The operator&#39;s argument.
 598      */
 599     JCUnary makeUnary(JCTree.Tag optag, JCExpression arg) {
 600         JCUnary tree = make.Unary(optag, arg);
 601         tree.operator = operators.resolveUnary(tree, optag, arg.type);
 602         tree.type = tree.operator.type.getReturnType();
 603         return tree;
 604     }
 605 
 606     /** Make an attributed binary expression.
 607      *  @param optag    The operators tree tag.
 608      *  @param lhs      The operator&#39;s left argument.
 609      *  @param rhs      The operator&#39;s right argument.
 610      */
 611     JCBinary makeBinary(JCTree.Tag optag, JCExpression lhs, JCExpression rhs) {
 612         JCBinary tree = make.Binary(optag, lhs, rhs);
 613         tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);
 614         tree.type = tree.operator.type.getReturnType();
 615         return tree;
 616     }
 617 
 618     /** Make an attributed assignop expression.
 619      *  @param optag    The operators tree tag.
 620      *  @param lhs      The operator&#39;s left argument.
 621      *  @param rhs      The operator&#39;s right argument.
 622      */
 623     JCAssignOp makeAssignop(JCTree.Tag optag, JCTree lhs, JCTree rhs) {
 624         JCAssignOp tree = make.Assignop(optag, lhs, rhs);
 625         tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), lhs.type, rhs.type);
 626         tree.type = lhs.type;
 627         return tree;
 628     }
 629 
 630     /** Convert tree into string object, unless it has already a
 631      *  reference type..
 632      */
 633     JCExpression makeString(JCExpression tree) {
 634         if (!tree.type.isPrimitiveOrVoid()) {
 635             return tree;
 636         } else {
 637             Symbol valueOfSym = lookupMethod(tree.pos(),
 638                                              names.valueOf,
 639                                              syms.stringType,
 640                                              List.of(tree.type));
 641             return make.App(make.QualIdent(valueOfSym), List.of(tree));
 642         }
 643     }
 644 
 645     /** Create an empty anonymous class definition and enter and complete
 646      *  its symbol. Return the class definition&#39;s symbol.
 647      *  and create
 648      *  @param flags    The class symbol&#39;s flags
 649      *  @param owner    The class symbol&#39;s owner
 650      */
 651     JCClassDecl makeEmptyClass(long flags, ClassSymbol owner) {
 652         return makeEmptyClass(flags, owner, null, true);
 653     }
 654 
 655     JCClassDecl makeEmptyClass(long flags, ClassSymbol owner, Name flatname,
 656             boolean addToDefs) {
 657         // Create class symbol.
 658         ClassSymbol c = syms.defineClass(names.empty, owner);
 659         if (flatname != null) {
 660             c.flatname = flatname;
 661         } else {
 662             c.flatname = chk.localClassName(c);
 663         }
 664         c.sourcefile = owner.sourcefile;
 665         c.completer = Completer.NULL_COMPLETER;
 666         c.members_field = WriteableScope.create(c);
 667         c.flags_field = flags;
 668         ClassType ctype = (ClassType) c.type;
 669         ctype.supertype_field = syms.objectType;
 670         ctype.interfaces_field = List.nil();
 671 
 672         JCClassDecl odef = classDef(owner);
 673 
 674         // Enter class symbol in owner scope and compiled table.
 675         enterSynthetic(odef.pos(), c, owner.members());
 676         chk.putCompiled(c);
 677 
 678         // Create class definition tree.
 679         JCClassDecl cdef = make.ClassDef(
 680             make.Modifiers(flags), names.empty,
 681             List.nil(),
 682             null, List.nil(), List.nil());
 683         cdef.sym = c;
 684         cdef.type = c.type;
 685 
 686         // Append class definition tree to owner&#39;s definitions.
 687         if (addToDefs) odef.defs = odef.defs.prepend(cdef);
 688         return cdef;
 689     }
 690 
 691 /**************************************************************************
 692  * Symbol manipulation utilities
 693  *************************************************************************/
 694 
 695     /** Enter a synthetic symbol in a given scope, but complain if there was already one there.
 696      *  @param pos           Position for error reporting.
 697      *  @param sym           The symbol.
 698      *  @param s             The scope.
 699      */
 700     private void enterSynthetic(DiagnosticPosition pos, Symbol sym, WriteableScope s) {
 701         s.enter(sym);
 702     }
 703 
 704     /** Create a fresh synthetic name within a given scope - the unique name is
 705      *  obtained by appending &#39;$&#39; chars at the end of the name until no match
 706      *  is found.
 707      *
 708      * @param name base name
 709      * @param s scope in which the name has to be unique
 710      * @return fresh synthetic name
 711      */
 712     private Name makeSyntheticName(Name name, Scope s) {
 713         do {
 714             name = name.append(
 715                     target.syntheticNameChar(),
 716                     names.empty);
 717         } while (lookupSynthetic(name, s) != null);
 718         return name;
 719     }
 720 
 721     /** Check whether synthetic symbols generated during lowering conflict
 722      *  with user-defined symbols.
 723      *
 724      *  @param translatedTrees lowered class trees
 725      */
 726     void checkConflicts(List&lt;JCTree&gt; translatedTrees) {
 727         for (JCTree t : translatedTrees) {
 728             t.accept(conflictsChecker);
 729         }
 730     }
 731 
 732     JCTree.Visitor conflictsChecker = new TreeScanner() {
 733 
 734         TypeSymbol currentClass;
 735 
 736         @Override
 737         public void visitMethodDef(JCMethodDecl that) {
 738             checkConflicts(that.pos(), that.sym, currentClass);
 739             super.visitMethodDef(that);
 740         }
 741 
 742         @Override
 743         public void visitVarDef(JCVariableDecl that) {
 744             if (that.sym.owner.kind == TYP) {
 745                 checkConflicts(that.pos(), that.sym, currentClass);
 746             }
 747             super.visitVarDef(that);
 748         }
 749 
 750         @Override
 751         public void visitClassDef(JCClassDecl that) {
 752             TypeSymbol prevCurrentClass = currentClass;
 753             currentClass = that.sym;
 754             try {
 755                 super.visitClassDef(that);
 756             }
 757             finally {
 758                 currentClass = prevCurrentClass;
 759             }
 760         }
 761 
 762         void checkConflicts(DiagnosticPosition pos, Symbol sym, TypeSymbol c) {
 763             for (Type ct = c.type; ct != Type.noType ; ct = types.supertype(ct)) {
 764                 for (Symbol sym2 : ct.tsym.members().getSymbolsByName(sym.name, NON_RECURSIVE)) {
 765                     // VM allows methods and variables with differing types
 766                     if (sym.kind == sym2.kind &amp;&amp;
 767                         types.isSameType(types.erasure(sym.type), types.erasure(sym2.type)) &amp;&amp;
 768                         sym != sym2 &amp;&amp;
 769                         (sym.flags() &amp; Flags.SYNTHETIC) != (sym2.flags() &amp; Flags.SYNTHETIC) &amp;&amp;
 770                         (sym.flags() &amp; BRIDGE) == 0 &amp;&amp; (sym2.flags() &amp; BRIDGE) == 0) {
 771                         syntheticError(pos, (sym2.flags() &amp; SYNTHETIC) == 0 ? sym2 : sym);
 772                         return;
 773                     }
 774                 }
 775             }
 776         }
 777 
 778         /** Report a conflict between a user symbol and a synthetic symbol.
 779          */
 780         private void syntheticError(DiagnosticPosition pos, Symbol sym) {
 781             if (!sym.type.isErroneous()) {
 782                 log.error(pos, Errors.CannotGenerateClass(sym.location(), Fragments.SyntheticNameConflict(sym, sym.location())));
 783             }
 784         }
 785     };
 786 
 787     /** Look up a synthetic name in a given scope.
 788      *  @param s            The scope.
 789      *  @param name         The name.
 790      */
 791     private Symbol lookupSynthetic(Name name, Scope s) {
 792         Symbol sym = s.findFirst(name);
 793         return (sym==null || (sym.flags()&amp;SYNTHETIC)==0) ? null : sym;
 794     }
 795 
 796     /** Look up a method in a given scope.
 797      */
 798     private MethodSymbol lookupMethod(DiagnosticPosition pos, Name name, Type qual, List&lt;Type&gt; args) {
 799         return rs.resolveInternalMethod(pos, attrEnv, qual, name, args, List.nil());
 800     }
 801 
 802     /** Anon inner classes are used as access constructor tags.
 803      * accessConstructorTag will use an existing anon class if one is available,
 804      * and synthesize a class (with makeEmptyClass) if one is not available.
 805      * However, there is a small possibility that an existing class will not
 806      * be generated as expected if it is inside a conditional with a constant
 807      * expression. If that is found to be the case, create an empty class tree here.
 808      */
 809     private void checkAccessConstructorTags() {
 810         for (List&lt;ClassSymbol&gt; l = accessConstrTags; l.nonEmpty(); l = l.tail) {
 811             ClassSymbol c = l.head;
 812             if (isTranslatedClassAvailable(c))
 813                 continue;
 814             // Create class definition tree.
 815             JCClassDecl cdec = makeEmptyClass(STATIC | SYNTHETIC,
 816                     c.outermostClass(), c.flatname, false);
 817             swapAccessConstructorTag(c, cdec.sym);
 818             translated.append(cdec);
 819         }
 820     }
 821     // where
 822     private boolean isTranslatedClassAvailable(ClassSymbol c) {
 823         for (JCTree tree: translated) {
 824             if (tree.hasTag(CLASSDEF)
 825                     &amp;&amp; ((JCClassDecl) tree).sym == c) {
 826                 return true;
 827             }
 828         }
 829         return false;
 830     }
 831 
 832     void swapAccessConstructorTag(ClassSymbol oldCTag, ClassSymbol newCTag) {
 833         for (MethodSymbol methodSymbol : accessConstrs.values()) {
 834             Assert.check(methodSymbol.type.hasTag(METHOD));
 835             MethodType oldMethodType =
 836                     (MethodType)methodSymbol.type;
 837             if (oldMethodType.argtypes.head.tsym == oldCTag)
 838                 methodSymbol.type =
 839                     types.createMethodTypeWithParameters(oldMethodType,
 840                         oldMethodType.getParameterTypes().tail
 841                             .prepend(newCTag.erasure(types)));
 842         }
 843     }
 844 
 845 /**************************************************************************
 846  * Access methods
 847  *************************************************************************/
 848 
 849     /** A mapping from symbols to their access numbers.
 850      */
 851     private Map&lt;Symbol,Integer&gt; accessNums;
 852 
 853     /** A mapping from symbols to an array of access symbols, indexed by
 854      *  access code.
 855      */
 856     private Map&lt;Symbol,MethodSymbol[]&gt; accessSyms;
 857 
 858     /** A mapping from (constructor) symbols to access constructor symbols.
 859      */
 860     private Map&lt;Symbol,MethodSymbol&gt; accessConstrs;
 861 
 862     /** A list of all class symbols used for access constructor tags.
 863      */
 864     private List&lt;ClassSymbol&gt; accessConstrTags;
 865 
 866     /** A queue for all accessed symbols.
 867      */
 868     private ListBuffer&lt;Symbol&gt; accessed;
 869 
 870     /** return access code for identifier,
 871      *  @param tree     The tree representing the identifier use.
 872      *  @param enclOp   The closest enclosing operation node of tree,
 873      *                  null if tree is not a subtree of an operation.
 874      */
 875     private static int accessCode(JCTree tree, JCTree enclOp) {
 876         if (enclOp == null)
 877             return AccessCode.DEREF.code;
 878         else if (enclOp.hasTag(ASSIGN) &amp;&amp;
 879                  tree == TreeInfo.skipParens(((JCAssign) enclOp).lhs))
 880             return AccessCode.ASSIGN.code;
 881         else if ((enclOp.getTag().isIncOrDecUnaryOp() || enclOp.getTag().isAssignop()) &amp;&amp;
 882                 tree == TreeInfo.skipParens(((JCOperatorExpression) enclOp).getOperand(LEFT)))
 883             return (((JCOperatorExpression) enclOp).operator).getAccessCode(enclOp.getTag());
 884         else
 885             return AccessCode.DEREF.code;
 886     }
 887 
 888     /** Return binary operator that corresponds to given access code.
 889      */
 890     private OperatorSymbol binaryAccessOperator(int acode, Tag tag) {
 891         return operators.lookupBinaryOp(op -&gt; op.getAccessCode(tag) == acode);
 892     }
 893 
 894     /** Return tree tag for assignment operation corresponding
 895      *  to given binary operator.
 896      */
 897     private static JCTree.Tag treeTag(OperatorSymbol operator) {
 898         switch (operator.opcode) {
 899         case ByteCodes.ior: case ByteCodes.lor:
 900             return BITOR_ASG;
 901         case ByteCodes.ixor: case ByteCodes.lxor:
 902             return BITXOR_ASG;
 903         case ByteCodes.iand: case ByteCodes.land:
 904             return BITAND_ASG;
 905         case ByteCodes.ishl: case ByteCodes.lshl:
 906         case ByteCodes.ishll: case ByteCodes.lshll:
 907             return SL_ASG;
 908         case ByteCodes.ishr: case ByteCodes.lshr:
 909         case ByteCodes.ishrl: case ByteCodes.lshrl:
 910             return SR_ASG;
 911         case ByteCodes.iushr: case ByteCodes.lushr:
 912         case ByteCodes.iushrl: case ByteCodes.lushrl:
 913             return USR_ASG;
 914         case ByteCodes.iadd: case ByteCodes.ladd:
 915         case ByteCodes.fadd: case ByteCodes.dadd:
 916         case ByteCodes.string_add:
 917             return PLUS_ASG;
 918         case ByteCodes.isub: case ByteCodes.lsub:
 919         case ByteCodes.fsub: case ByteCodes.dsub:
 920             return MINUS_ASG;
 921         case ByteCodes.imul: case ByteCodes.lmul:
 922         case ByteCodes.fmul: case ByteCodes.dmul:
 923             return MUL_ASG;
 924         case ByteCodes.idiv: case ByteCodes.ldiv:
 925         case ByteCodes.fdiv: case ByteCodes.ddiv:
 926             return DIV_ASG;
 927         case ByteCodes.imod: case ByteCodes.lmod:
 928         case ByteCodes.fmod: case ByteCodes.dmod:
 929             return MOD_ASG;
 930         default:
 931             throw new AssertionError();
 932         }
 933     }
 934 
 935     /** The name of the access method with number `anum&#39; and access code `acode&#39;.
 936      */
 937     Name accessName(int anum, int acode) {
 938         return names.fromString(
 939             &quot;access&quot; + target.syntheticNameChar() + anum + acode / 10 + acode % 10);
 940     }
 941 
 942     /** Return access symbol for a private or protected symbol from an inner class.
 943      *  @param sym        The accessed private symbol.
 944      *  @param tree       The accessing tree.
 945      *  @param enclOp     The closest enclosing operation node of tree,
 946      *                    null if tree is not a subtree of an operation.
 947      *  @param protAccess Is access to a protected symbol in another
 948      *                    package?
 949      *  @param refSuper   Is access via a (qualified) C.super?
 950      */
 951     MethodSymbol accessSymbol(Symbol sym, JCTree tree, JCTree enclOp,
 952                               boolean protAccess, boolean refSuper) {
 953         ClassSymbol accOwner = refSuper &amp;&amp; protAccess
 954             // For access via qualified super (T.super.x), place the
 955             // access symbol on T.
 956             ? (ClassSymbol)((JCFieldAccess) tree).selected.type.tsym
 957             // Otherwise pretend that the owner of an accessed
 958             // protected symbol is the enclosing class of the current
 959             // class which is a subclass of the symbol&#39;s owner.
 960             : accessClass(sym, protAccess, tree);
 961 
 962         Symbol vsym = sym;
 963         if (sym.owner != accOwner) {
 964             vsym = sym.clone(accOwner);
 965             actualSymbols.put(vsym, sym);
 966         }
 967 
 968         Integer anum              // The access number of the access method.
 969             = accessNums.get(vsym);
 970         if (anum == null) {
 971             anum = accessed.length();
 972             accessNums.put(vsym, anum);
 973             accessSyms.put(vsym, new MethodSymbol[AccessCode.numberOfAccessCodes]);
 974             accessed.append(vsym);
 975             // System.out.println(&quot;accessing &quot; + vsym + &quot; in &quot; + vsym.location());
 976         }
 977 
 978         int acode;                // The access code of the access method.
 979         List&lt;Type&gt; argtypes;      // The argument types of the access method.
 980         Type restype;             // The result type of the access method.
 981         List&lt;Type&gt; thrown;        // The thrown exceptions of the access method.
 982         switch (vsym.kind) {
 983         case VAR:
 984             acode = accessCode(tree, enclOp);
 985             if (acode &gt;= AccessCode.FIRSTASGOP.code) {
 986                 OperatorSymbol operator = binaryAccessOperator(acode, enclOp.getTag());
 987                 if (operator.opcode == string_add)
 988                     argtypes = List.of(syms.objectType);
 989                 else
 990                     argtypes = operator.type.getParameterTypes().tail;
 991             } else if (acode == AccessCode.ASSIGN.code)
 992                 argtypes = List.of(vsym.erasure(types));
 993             else
 994                 argtypes = List.nil();
 995             restype = vsym.erasure(types);
 996             thrown = List.nil();
 997             break;
 998         case MTH:
 999             acode = AccessCode.DEREF.code;
1000             argtypes = vsym.erasure(types).getParameterTypes();
1001             restype = vsym.erasure(types).getReturnType();
1002             thrown = vsym.type.getThrownTypes();
1003             break;
1004         default:
1005             throw new AssertionError();
1006         }
1007 
1008         // For references via qualified super, increment acode by one,
1009         // making it odd.
1010         if (protAccess &amp;&amp; refSuper) acode++;
1011 
1012         // Instance access methods get instance as first parameter.
1013         // For protected symbols this needs to be the instance as a member
1014         // of the type containing the accessed symbol, not the class
1015         // containing the access method.
1016         if ((vsym.flags() &amp; STATIC) == 0) {
1017             argtypes = argtypes.prepend(vsym.owner.erasure(types));
1018         }
1019         MethodSymbol[] accessors = accessSyms.get(vsym);
1020         MethodSymbol accessor = accessors[acode];
1021         if (accessor == null) {
1022             accessor = new MethodSymbol(
1023                 STATIC | SYNTHETIC | (accOwner.isInterface() ? PUBLIC : 0),
1024                 accessName(anum.intValue(), acode),
1025                 new MethodType(argtypes, restype, thrown, syms.methodClass),
1026                 accOwner);
1027             enterSynthetic(tree.pos(), accessor, accOwner.members());
1028             accessors[acode] = accessor;
1029         }
1030         return accessor;
1031     }
1032 
1033     /** The qualifier to be used for accessing a symbol in an outer class.
1034      *  This is either C.sym or C.this.sym, depending on whether or not
1035      *  sym is static.
1036      *  @param sym   The accessed symbol.
1037      */
1038     JCExpression accessBase(DiagnosticPosition pos, Symbol sym) {
1039         return (sym.flags() &amp; STATIC) != 0
1040             ? access(make.at(pos.getStartPosition()).QualIdent(sym.owner))
1041             : makeOwnerThis(pos, sym, true);
1042     }
1043 
1044     /** Do we need an access method to reference private symbol?
1045      */
1046     boolean needsPrivateAccess(Symbol sym) {
1047         if (target.hasNestmateAccess()) {
1048             return false;
1049         }
1050         if ((sym.flags() &amp; PRIVATE) == 0 || sym.owner == currentClass) {
1051             return false;
1052         } else if (sym.name == names.init &amp;&amp; sym.owner.isLocal()) {
1053             // private constructor in local class: relax protection
1054             sym.flags_field &amp;= ~PRIVATE;
1055             return false;
1056         } else {
1057             return true;
1058         }
1059     }
1060 
1061     /** Do we need an access method to reference symbol in other package?
1062      */
1063     boolean needsProtectedAccess(Symbol sym, JCTree tree) {
1064         if (disableProtectedAccessors) return false;
1065         if ((sym.flags() &amp; PROTECTED) == 0 ||
1066             sym.owner.owner == currentClass.owner || // fast special case
1067             sym.packge() == currentClass.packge())
1068             return false;
1069         if (!currentClass.isSubClass(sym.owner, types))
1070             return true;
1071         if ((sym.flags() &amp; STATIC) != 0 ||
1072             !tree.hasTag(SELECT) ||
1073             TreeInfo.name(((JCFieldAccess) tree).selected) == names._super)
1074             return false;
1075         return !((JCFieldAccess) tree).selected.type.tsym.isSubClass(currentClass, types);
1076     }
1077 
1078     /** The class in which an access method for given symbol goes.
1079      *  @param sym        The access symbol
1080      *  @param protAccess Is access to a protected symbol in another
1081      *                    package?
1082      */
1083     ClassSymbol accessClass(Symbol sym, boolean protAccess, JCTree tree) {
1084         if (protAccess) {
1085             Symbol qualifier = null;
1086             ClassSymbol c = currentClass;
1087             if (tree.hasTag(SELECT) &amp;&amp; (sym.flags() &amp; STATIC) == 0) {
1088                 qualifier = ((JCFieldAccess) tree).selected.type.tsym;
1089                 while (!qualifier.isSubClass(c, types)) {
1090                     c = c.owner.enclClass();
1091                 }
1092                 return c;
1093             } else {
1094                 while (!c.isSubClass(sym.owner, types)) {
1095                     c = c.owner.enclClass();
1096                 }
1097             }
1098             return c;
1099         } else {
1100             // the symbol is private
1101             return sym.owner.enclClass();
1102         }
1103     }
1104 
1105     private void addPrunedInfo(JCTree tree) {
1106         List&lt;JCTree&gt; infoList = prunedTree.get(currentClass);
1107         infoList = (infoList == null) ? List.of(tree) : infoList.prepend(tree);
1108         prunedTree.put(currentClass, infoList);
1109     }
1110 
1111     /** Ensure that identifier is accessible, return tree accessing the identifier.
1112      *  @param sym      The accessed symbol.
1113      *  @param tree     The tree referring to the symbol.
1114      *  @param enclOp   The closest enclosing operation node of tree,
1115      *                  null if tree is not a subtree of an operation.
1116      *  @param refSuper Is access via a (qualified) C.super?
1117      */
1118     JCExpression access(Symbol sym, JCExpression tree, JCExpression enclOp, boolean refSuper) {
1119         // Access a free variable via its proxy, or its proxy&#39;s proxy
1120         while (sym.kind == VAR &amp;&amp; sym.owner.kind == MTH &amp;&amp;
1121             sym.owner.enclClass() != currentClass) {
1122             // A constant is replaced by its constant value.
1123             Object cv = ((VarSymbol)sym).getConstValue();
1124             if (cv != null) {
1125                 make.at(tree.pos);
1126                 return makeLit(sym.type, cv);
1127             }
1128             if (lambdaTranslationMap != null &amp;&amp; lambdaTranslationMap.get(sym) != null) {
1129                 return make.at(tree.pos).Ident(lambdaTranslationMap.get(sym));
1130             } else {
1131                 // Otherwise replace the variable by its proxy.
1132                 sym = proxies.get(sym);
1133                 Assert.check(sym != null &amp;&amp; (sym.flags_field &amp; FINAL) != 0);
1134                 tree = make.at(tree.pos).Ident(sym);
1135             }
1136         }
1137         JCExpression base = (tree.hasTag(SELECT)) ? ((JCFieldAccess) tree).selected : null;
1138         switch (sym.kind) {
1139         case TYP:
1140             if (sym.owner.kind != PCK) {
1141                 // Convert type idents to
1142                 // &lt;flat name&gt; or &lt;package name&gt; . &lt;flat name&gt;
1143                 Name flatname = Convert.shortName(sym.flatName());
1144                 while (base != null &amp;&amp;
1145                        TreeInfo.symbol(base) != null &amp;&amp;
1146                        TreeInfo.symbol(base).kind != PCK) {
1147                     base = (base.hasTag(SELECT))
1148                         ? ((JCFieldAccess) base).selected
1149                         : null;
1150                 }
1151                 if (tree.hasTag(IDENT)) {
1152                     ((JCIdent) tree).name = flatname;
1153                 } else if (base == null) {
1154                     tree = make.at(tree.pos).Ident(sym);
1155                     ((JCIdent) tree).name = flatname;
1156                 } else {
1157                     ((JCFieldAccess) tree).selected = base;
1158                     ((JCFieldAccess) tree).name = flatname;
1159                 }
1160             }
1161             break;
1162         case MTH: case VAR:
1163             if (sym.owner.kind == TYP) {
1164 
1165                 // Access methods are required for
1166                 //  - private members,
1167                 //  - protected members in a superclass of an
1168                 //    enclosing class contained in another package.
1169                 //  - all non-private members accessed via a qualified super.
1170                 boolean protAccess = refSuper &amp;&amp; !needsPrivateAccess(sym)
1171                     || needsProtectedAccess(sym, tree);
1172                 boolean accReq = protAccess || needsPrivateAccess(sym);
1173 
1174                 // A base has to be supplied for
1175                 //  - simple identifiers accessing variables in outer classes.
1176                 boolean baseReq =
1177                     base == null &amp;&amp;
1178                     sym.owner != syms.predefClass &amp;&amp;
1179                     !sym.isMemberOf(currentClass, types);
1180 
1181                 if (accReq || baseReq) {
1182                     make.at(tree.pos);
1183 
1184                     // Constants are replaced by their constant value.
1185                     if (sym.kind == VAR) {
1186                         Object cv = ((VarSymbol)sym).getConstValue();
1187                         if (cv != null) {
1188                             addPrunedInfo(tree);
1189                             return makeLit(sym.type, cv);
1190                         }
1191                     }
1192 
1193                     // Private variables and methods are replaced by calls
1194                     // to their access methods.
1195                     if (accReq) {
1196                         List&lt;JCExpression&gt; args = List.nil();
1197                         if ((sym.flags() &amp; STATIC) == 0) {
1198                             // Instance access methods get instance
1199                             // as first parameter.
1200                             if (base == null)
1201                                 base = makeOwnerThis(tree.pos(), sym, true);
1202                             args = args.prepend(base);
1203                             base = null;   // so we don&#39;t duplicate code
1204                         }
1205                         Symbol access = accessSymbol(sym, tree,
1206                                                      enclOp, protAccess,
1207                                                      refSuper);
1208                         JCExpression receiver = make.Select(
1209                             base != null ? base : make.QualIdent(access.owner),
1210                             access);
1211                         return make.App(receiver, args);
1212 
1213                     // Other accesses to members of outer classes get a
1214                     // qualifier.
1215                     } else if (baseReq) {
1216                         return make.at(tree.pos).Select(
1217                             accessBase(tree.pos(), sym), sym).setType(tree.type);
1218                     }
1219                 }
1220             } else if (sym.owner.kind == MTH &amp;&amp; lambdaTranslationMap != null) {
1221                 //sym is a local variable - check the lambda translation map to
1222                 //see if sym has been translated to something else in the current
1223                 //scope (by LambdaToMethod)
1224                 Symbol translatedSym = lambdaTranslationMap.get(sym);
1225                 if (translatedSym != null) {
1226                     tree = make.at(tree.pos).Ident(translatedSym);
1227                 }
1228             }
1229         }
1230         return tree;
1231     }
1232 
1233     /** Ensure that identifier is accessible, return tree accessing the identifier.
1234      *  @param tree     The identifier tree.
1235      */
1236     JCExpression access(JCExpression tree) {
1237         Symbol sym = TreeInfo.symbol(tree);
1238         return sym == null ? tree : access(sym, tree, null, false);
1239     }
1240 
1241     /** Return access constructor for a private constructor,
1242      *  or the constructor itself, if no access constructor is needed.
1243      *  @param pos       The position to report diagnostics, if any.
1244      *  @param constr    The private constructor.
1245      */
1246     Symbol accessConstructor(DiagnosticPosition pos, Symbol constr) {
1247         if (needsPrivateAccess(constr)) {
1248             ClassSymbol accOwner = constr.owner.enclClass();
1249             MethodSymbol aconstr = accessConstrs.get(constr);
1250             if (aconstr == null) {
1251                 List&lt;Type&gt; argtypes = constr.type.getParameterTypes();
1252                 if ((accOwner.flags_field &amp; ENUM) != 0)
1253                     argtypes = argtypes
1254                         .prepend(syms.intType)
1255                         .prepend(syms.stringType);
1256                 aconstr = new MethodSymbol(
1257                     SYNTHETIC,
1258                     names.init,
1259                     new MethodType(
1260                         argtypes.append(
1261                             accessConstructorTag().erasure(types)),
1262                         constr.type.getReturnType(),
1263                         constr.type.getThrownTypes(),
1264                         syms.methodClass),
1265                     accOwner);
1266                 enterSynthetic(pos, aconstr, accOwner.members());
1267                 accessConstrs.put(constr, aconstr);
1268                 accessed.append(constr);
1269             }
1270             return aconstr;
1271         } else {
1272             return constr;
1273         }
1274     }
1275 
1276     /** Return an anonymous class nested in this toplevel class.
1277      */
1278     ClassSymbol accessConstructorTag() {
1279         ClassSymbol topClass = currentClass.outermostClass();
1280         ModuleSymbol topModle = topClass.packge().modle;
1281         for (int i = 1; ; i++) {
1282             Name flatname = names.fromString(&quot;&quot; + topClass.getQualifiedName() +
1283                                             target.syntheticNameChar() +
1284                                             i);
1285             ClassSymbol ctag = chk.getCompiled(topModle, flatname);
1286             if (ctag == null)
1287                 ctag = makeEmptyClass(STATIC | SYNTHETIC, topClass).sym;
1288             else if (!ctag.isAnonymous())
1289                 continue;
1290             // keep a record of all tags, to verify that all are generated as required
1291             accessConstrTags = accessConstrTags.prepend(ctag);
1292             return ctag;
1293         }
1294     }
1295 
1296     /** Add all required access methods for a private symbol to enclosing class.
1297      *  @param sym       The symbol.
1298      */
1299     void makeAccessible(Symbol sym) {
1300         JCClassDecl cdef = classDef(sym.owner.enclClass());
1301         if (cdef == null) Assert.error(&quot;class def not found: &quot; + sym + &quot; in &quot; + sym.owner);
1302         if (sym.name == names.init) {
1303             cdef.defs = cdef.defs.prepend(
1304                 accessConstructorDef(cdef.pos, sym, accessConstrs.get(sym)));
1305         } else {
1306             MethodSymbol[] accessors = accessSyms.get(sym);
1307             for (int i = 0; i &lt; AccessCode.numberOfAccessCodes; i++) {
1308                 if (accessors[i] != null)
1309                     cdef.defs = cdef.defs.prepend(
1310                         accessDef(cdef.pos, sym, accessors[i], i));
1311             }
1312         }
1313     }
1314 
1315     /** Construct definition of an access method.
1316      *  @param pos        The source code position of the definition.
1317      *  @param vsym       The private or protected symbol.
1318      *  @param accessor   The access method for the symbol.
1319      *  @param acode      The access code.
1320      */
1321     JCTree accessDef(int pos, Symbol vsym, MethodSymbol accessor, int acode) {
1322 //      System.err.println(&quot;access &quot; + vsym + &quot; with &quot; + accessor);//DEBUG
1323         currentClass = vsym.owner.enclClass();
1324         make.at(pos);
1325         JCMethodDecl md = make.MethodDef(accessor, null);
1326 
1327         // Find actual symbol
1328         Symbol sym = actualSymbols.get(vsym);
1329         if (sym == null) sym = vsym;
1330 
1331         JCExpression ref;           // The tree referencing the private symbol.
1332         List&lt;JCExpression&gt; args;    // Any additional arguments to be passed along.
1333         if ((sym.flags() &amp; STATIC) != 0) {
1334             ref = make.Ident(sym);
1335             args = make.Idents(md.params);
1336         } else {
1337             JCExpression site = make.Ident(md.params.head);
1338             if (acode % 2 != 0) {
1339                 //odd access codes represent qualified super accesses - need to
1340                 //emit reference to the direct superclass, even if the referred
1341                 //member is from an indirect superclass (JLS 13.1)
1342                 site.setType(types.erasure(types.supertype(vsym.owner.enclClass().type)));
1343             }
1344             ref = make.Select(site, sym);
1345             args = make.Idents(md.params.tail);
1346         }
1347         JCStatement stat;          // The statement accessing the private symbol.
1348         if (sym.kind == VAR) {
1349             // Normalize out all odd access codes by taking floor modulo 2:
1350             int acode1 = acode - (acode &amp; 1);
1351 
1352             JCExpression expr;      // The access method&#39;s return value.
1353             AccessCode aCode = AccessCode.getFromCode(acode1);
1354             switch (aCode) {
1355             case DEREF:
1356                 expr = ref;
1357                 break;
1358             case ASSIGN:
1359                 expr = make.Assign(ref, args.head);
1360                 break;
1361             case PREINC: case POSTINC: case PREDEC: case POSTDEC:
1362                 expr = makeUnary(aCode.tag, ref);
1363                 break;
1364             default:
1365                 expr = make.Assignop(
1366                     treeTag(binaryAccessOperator(acode1, JCTree.Tag.NO_TAG)), ref, args.head);
1367                 ((JCAssignOp) expr).operator = binaryAccessOperator(acode1, JCTree.Tag.NO_TAG);
1368             }
1369             stat = make.Return(expr.setType(sym.type));
1370         } else {
1371             stat = make.Call(make.App(ref, args));
1372         }
1373         md.body = make.Block(0, List.of(stat));
1374 
1375         // Make sure all parameters, result types and thrown exceptions
1376         // are accessible.
1377         for (List&lt;JCVariableDecl&gt; l = md.params; l.nonEmpty(); l = l.tail)
1378             l.head.vartype = access(l.head.vartype);
1379         md.restype = access(md.restype);
1380         for (List&lt;JCExpression&gt; l = md.thrown; l.nonEmpty(); l = l.tail)
1381             l.head = access(l.head);
1382 
1383         return md;
1384     }
1385 
1386     /** Construct definition of an access constructor.
1387      *  @param pos        The source code position of the definition.
1388      *  @param constr     The private constructor.
1389      *  @param accessor   The access method for the constructor.
1390      */
1391     JCTree accessConstructorDef(int pos, Symbol constr, MethodSymbol accessor) {
1392         make.at(pos);
1393         JCMethodDecl md = make.MethodDef(accessor,
1394                                       accessor.externalType(types),
1395                                       null);
1396         JCIdent callee = make.Ident(names._this);
1397         callee.sym = constr;
1398         callee.type = constr.type;
1399         md.body =
1400             make.Block(0, List.of(
1401                 make.Call(
1402                     make.App(
1403                         callee,
1404                         make.Idents(md.params.reverse().tail.reverse())))));
1405         return md;
1406     }
1407 
1408 /**************************************************************************
1409  * Free variables proxies and this$n
1410  *************************************************************************/
1411 
1412     /** A map which allows to retrieve the translated proxy variable for any given symbol of an
1413      *  enclosing scope that is accessed (the accessed symbol could be the synthetic &#39;this$n&#39; symbol).
1414      *  Inside a constructor, the map temporarily overrides entries corresponding to proxies and any
1415      *  &#39;this$n&#39; symbols, where they represent the constructor parameters.
1416      */
1417     Map&lt;Symbol, Symbol&gt; proxies;
1418 
1419     /** A scope containing all unnamed resource variables/saved
1420      *  exception variables for translated TWR blocks
1421      */
1422     WriteableScope twrVars;
1423 
1424     /** A stack containing the this$n field of the currently translated
1425      *  classes (if needed) in innermost first order.
1426      *  Inside a constructor, proxies and any this$n symbol are duplicated
1427      *  in an additional innermost scope, where they represent the constructor
1428      *  parameters.
1429      */
1430     List&lt;VarSymbol&gt; outerThisStack;
1431 
1432     /** The name of a free variable proxy.
1433      */
1434     Name proxyName(Name name, int index) {
1435         Name proxyName = names.fromString(&quot;val&quot; + target.syntheticNameChar() + name);
1436         if (index &gt; 0) {
1437             proxyName = proxyName.append(names.fromString(&quot;&quot; + target.syntheticNameChar() + index));
1438         }
1439         return proxyName;
1440     }
1441 
1442     /** Proxy definitions for all free variables in given list, in reverse order.
1443      *  @param pos        The source code position of the definition.
1444      *  @param freevars   The free variables.
1445      *  @param owner      The class in which the definitions go.
1446      */
1447     List&lt;JCVariableDecl&gt; freevarDefs(int pos, List&lt;VarSymbol&gt; freevars, Symbol owner) {
1448         return freevarDefs(pos, freevars, owner, 0);
1449     }
1450 
1451     List&lt;JCVariableDecl&gt; freevarDefs(int pos, List&lt;VarSymbol&gt; freevars, Symbol owner,
1452             long additionalFlags) {
1453         long flags = FINAL | SYNTHETIC | additionalFlags;
1454         List&lt;JCVariableDecl&gt; defs = List.nil();
1455         Set&lt;Name&gt; proxyNames = new HashSet&lt;&gt;();
1456         for (List&lt;VarSymbol&gt; l = freevars; l.nonEmpty(); l = l.tail) {
1457             VarSymbol v = l.head;
1458             int index = 0;
1459             Name proxyName;
1460             do {
1461                 proxyName = proxyName(v.name, index++);
1462             } while (!proxyNames.add(proxyName));
1463             VarSymbol proxy = new VarSymbol(
1464                 flags, proxyName, v.erasure(types), owner);
1465             proxies.put(v, proxy);
1466             JCVariableDecl vd = make.at(pos).VarDef(proxy, null);
1467             vd.vartype = access(vd.vartype);
1468             defs = defs.prepend(vd);
1469         }
1470         return defs;
1471     }
1472 
1473     /** The name of a this$n field
1474      *  @param type   The class referenced by the this$n field
1475      */
1476     Name outerThisName(Type type, Symbol owner) {
1477         Type t = type.getEnclosingType();
1478         int nestingLevel = 0;
1479         while (t.hasTag(CLASS)) {
1480             t = t.getEnclosingType();
1481             nestingLevel++;
1482         }
1483         Name result = names.fromString(&quot;this&quot; + target.syntheticNameChar() + nestingLevel);
1484         while (owner.kind == TYP &amp;&amp; ((ClassSymbol)owner).members().findFirst(result) != null)
1485             result = names.fromString(result.toString() + target.syntheticNameChar());
1486         return result;
1487     }
1488 
1489     private VarSymbol makeOuterThisVarSymbol(Symbol owner, long flags) {
1490         Type target = types.erasure(owner.enclClass().type.getEnclosingType());
1491         VarSymbol outerThis =
1492             new VarSymbol(flags, outerThisName(target, owner), target, owner);
1493         outerThisStack = outerThisStack.prepend(outerThis);
1494         return outerThis;
1495     }
1496 
1497     private JCVariableDecl makeOuterThisVarDecl(int pos, VarSymbol sym) {
1498         JCVariableDecl vd = make.at(pos).VarDef(sym, null);
1499         vd.vartype = access(vd.vartype);
1500         return vd;
1501     }
1502 
1503     /** Definition for this$n field.
1504      *  @param pos        The source code position of the definition.
1505      *  @param owner      The method in which the definition goes.
1506      */
1507     JCVariableDecl outerThisDef(int pos, MethodSymbol owner) {
1508         ClassSymbol c = owner.enclClass();
1509         boolean isMandated =
1510             // Anonymous constructors
1511             (owner.isConstructor() &amp;&amp; owner.isAnonymous()) ||
1512             // Constructors of non-private inner member classes
1513             (owner.isConstructor() &amp;&amp; c.isInner() &amp;&amp;
1514              !c.isPrivate() &amp;&amp; !c.isStatic());
1515         long flags =
1516             FINAL | (isMandated ? MANDATED : SYNTHETIC) | PARAMETER;
1517         VarSymbol outerThis = makeOuterThisVarSymbol(owner, flags);
1518         owner.extraParams = owner.extraParams.prepend(outerThis);
1519         return makeOuterThisVarDecl(pos, outerThis);
1520     }
1521 
1522     /** Definition for this$n field.
1523      *  @param pos        The source code position of the definition.
1524      *  @param owner      The class in which the definition goes.
1525      */
1526     JCVariableDecl outerThisDef(int pos, ClassSymbol owner) {
1527         VarSymbol outerThis = makeOuterThisVarSymbol(owner, FINAL | SYNTHETIC);
1528         return makeOuterThisVarDecl(pos, outerThis);
1529     }
1530 
1531     /** Return a list of trees that load the free variables in given list,
1532      *  in reverse order.
1533      *  @param pos          The source code position to be used for the trees.
1534      *  @param freevars     The list of free variables.
1535      */
1536     List&lt;JCExpression&gt; loadFreevars(DiagnosticPosition pos, List&lt;VarSymbol&gt; freevars) {
1537         List&lt;JCExpression&gt; args = List.nil();
1538         for (List&lt;VarSymbol&gt; l = freevars; l.nonEmpty(); l = l.tail)
1539             args = args.prepend(loadFreevar(pos, l.head));
1540         return args;
1541     }
1542 //where
1543         JCExpression loadFreevar(DiagnosticPosition pos, VarSymbol v) {
1544             return access(v, make.at(pos).Ident(v), null, false);
1545         }
1546 
1547     /** Construct a tree simulating the expression {@code C.this}.
1548      *  @param pos           The source code position to be used for the tree.
1549      *  @param c             The qualifier class.
1550      */
1551     JCExpression makeThis(DiagnosticPosition pos, TypeSymbol c) {
1552         if (currentClass == c) {
1553             // in this case, `this&#39; works fine
1554             return make.at(pos).This(c.erasure(types));
1555         } else {
1556             // need to go via this$n
1557             return makeOuterThis(pos, c);
1558         }
1559     }
1560 
1561     /**
1562      * Optionally replace a try statement with the desugaring of a
1563      * try-with-resources statement.  The canonical desugaring of
1564      *
1565      * try ResourceSpecification
1566      *   Block
1567      *
1568      * is
1569      *
1570      * {
1571      *   final VariableModifiers_minus_final R #resource = Expression;
1572      *
1573      *   try ResourceSpecificationtail
1574      *     Block
1575      *   } body-only-finally {
1576      *     if (#resource != null) //nullcheck skipped if Expression is provably non-null
1577      *         #resource.close();
1578      *   } catch (Throwable #primaryException) {
1579      *       if (#resource != null) //nullcheck skipped if Expression is provably non-null
1580      *           try {
1581      *               #resource.close();
1582      *           } catch (Throwable #suppressedException) {
1583      *              #primaryException.addSuppressed(#suppressedException);
1584      *           }
1585      *       throw #primaryException;
1586      *   }
1587      * }
1588      *
1589      * @param tree  The try statement to inspect.
1590      * @return A a desugared try-with-resources tree, or the original
1591      * try block if there are no resources to manage.
1592      */
1593     JCTree makeTwrTry(JCTry tree) {
1594         make_at(tree.pos());
1595         twrVars = twrVars.dup();
1596         JCBlock twrBlock = makeTwrBlock(tree.resources, tree.body, 0);
1597         if (tree.catchers.isEmpty() &amp;&amp; tree.finalizer == null)
1598             result = translate(twrBlock);
1599         else
1600             result = translate(make.Try(twrBlock, tree.catchers, tree.finalizer));
1601         twrVars = twrVars.leave();
1602         return result;
1603     }
1604 
1605     private JCBlock makeTwrBlock(List&lt;JCTree&gt; resources, JCBlock block, int depth) {
1606         if (resources.isEmpty())
1607             return block;
1608 
1609         // Add resource declaration or expression to block statements
1610         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
1611         JCTree resource = resources.head;
1612         JCExpression resourceUse;
1613         boolean resourceNonNull;
1614         if (resource instanceof JCVariableDecl) {
1615             JCVariableDecl var = (JCVariableDecl) resource;
1616             resourceUse = make.Ident(var.sym).setType(resource.type);
1617             resourceNonNull = var.init != null &amp;&amp; TreeInfo.skipParens(var.init).hasTag(NEWCLASS);
1618             stats.add(var);
1619         } else {
1620             Assert.check(resource instanceof JCExpression);
1621             VarSymbol syntheticTwrVar =
1622             new VarSymbol(SYNTHETIC | FINAL,
1623                           makeSyntheticName(names.fromString(&quot;twrVar&quot; +
1624                                            depth), twrVars),
1625                           (resource.type.hasTag(BOT)) ?
1626                           syms.autoCloseableType : resource.type,
1627                           currentMethodSym);
1628             twrVars.enter(syntheticTwrVar);
1629             JCVariableDecl syntheticTwrVarDecl =
1630                 make.VarDef(syntheticTwrVar, (JCExpression)resource);
1631             resourceUse = (JCExpression)make.Ident(syntheticTwrVar);
1632             resourceNonNull = false;
1633             stats.add(syntheticTwrVarDecl);
1634         }
1635 
1636         //create (semi-) finally block that will be copied into the main try body:
1637         int oldPos = make.pos;
1638         make.at(TreeInfo.endPos(block));
1639 
1640         // if (#resource != null) { #resource.close(); }
1641         JCStatement bodyCloseStatement = makeResourceCloseInvocation(resourceUse);
1642 
1643         if (!resourceNonNull) {
1644             bodyCloseStatement = make.If(makeNonNullCheck(resourceUse),
1645                                          bodyCloseStatement,
1646                                          null);
1647         }
1648 
1649         JCBlock finallyClause = make.Block(BODY_ONLY_FINALIZE, List.of(bodyCloseStatement));
1650         make.at(oldPos);
1651 
1652         // Create catch clause that saves exception, closes the resource and then rethrows the exception:
1653         VarSymbol primaryException =
1654             new VarSymbol(FINAL|SYNTHETIC,
1655                           names.fromString(&quot;t&quot; +
1656                                            target.syntheticNameChar()),
1657                           syms.throwableType,
1658                           currentMethodSym);
1659         JCVariableDecl primaryExceptionDecl = make.VarDef(primaryException, null);
1660 
1661         // close resource:
1662         // try {
1663         //     #resource.close();
1664         // } catch (Throwable #suppressedException) {
1665         //     #primaryException.addSuppressed(#suppressedException);
1666         // }
1667         VarSymbol suppressedException =
1668             new VarSymbol(SYNTHETIC, make.paramName(2),
1669                           syms.throwableType,
1670                           currentMethodSym);
1671         JCStatement addSuppressedStatement =
1672             make.Exec(makeCall(make.Ident(primaryException),
1673                                names.addSuppressed,
1674                                List.of(make.Ident(suppressedException))));
1675         JCBlock closeResourceTryBlock =
1676             make.Block(0L, List.of(makeResourceCloseInvocation(resourceUse)));
1677         JCVariableDecl catchSuppressedDecl = make.VarDef(suppressedException, null);
1678         JCBlock catchSuppressedBlock = make.Block(0L, List.of(addSuppressedStatement));
1679         List&lt;JCCatch&gt; catchSuppressedClauses =
1680                 List.of(make.Catch(catchSuppressedDecl, catchSuppressedBlock));
1681         JCTry closeResourceTry = make.Try(closeResourceTryBlock, catchSuppressedClauses, null);
1682         closeResourceTry.finallyCanCompleteNormally = true;
1683 
1684         JCStatement exceptionalCloseStatement = closeResourceTry;
1685 
1686         if (!resourceNonNull) {
1687             // if (#resource != null) {  }
1688             exceptionalCloseStatement = make.If(makeNonNullCheck(resourceUse),
1689                                                 exceptionalCloseStatement,
1690                                                 null);
1691         }
1692 
1693         JCStatement exceptionalRethrow = make.Throw(make.Ident(primaryException));
1694         JCBlock exceptionalCloseBlock = make.Block(0L, List.of(exceptionalCloseStatement, exceptionalRethrow));
1695         JCCatch exceptionalCatchClause = make.Catch(primaryExceptionDecl, exceptionalCloseBlock);
1696 
1697         //create the main try statement with the close:
1698         JCTry outerTry = make.Try(makeTwrBlock(resources.tail, block, depth + 1),
1699                                   List.of(exceptionalCatchClause),
1700                                   finallyClause);
1701 
1702         outerTry.finallyCanCompleteNormally = true;
1703         stats.add(outerTry);
1704 
1705         JCBlock newBlock = make.Block(0L, stats.toList());
1706         return newBlock;
1707     }
1708 
1709     private JCStatement makeResourceCloseInvocation(JCExpression resource) {
1710         // convert to AutoCloseable if needed
1711         if (types.asSuper(resource.type, syms.autoCloseableType.tsym) == null) {
1712             resource = convert(resource, syms.autoCloseableType);
1713         }
1714 
1715         // create resource.close() method invocation
1716         JCExpression resourceClose = makeCall(resource,
1717                                               names.close,
1718                                               List.nil());
1719         return make.Exec(resourceClose);
1720     }
1721 
1722     private JCExpression makeNonNullCheck(JCExpression expression) {
1723         return makeBinary(NE, expression, makeNull());
1724     }
1725 
1726     /** Construct a tree that represents the outer instance
1727      *  {@code C.this}. Never pick the current `this&#39;.
1728      *  @param pos           The source code position to be used for the tree.
1729      *  @param c             The qualifier class.
1730      */
1731     JCExpression makeOuterThis(DiagnosticPosition pos, TypeSymbol c) {
1732         List&lt;VarSymbol&gt; ots = outerThisStack;
1733         if (ots.isEmpty()) {
1734             log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));
1735             Assert.error();
1736             return makeNull();
1737         }
1738         VarSymbol ot = ots.head;
1739         JCExpression tree = access(make.at(pos).Ident(ot));
1740         TypeSymbol otc = ot.type.tsym;
1741         while (otc != c) {
1742             do {
1743                 ots = ots.tail;
1744                 if (ots.isEmpty()) {
1745                     log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));
1746                     Assert.error(); // should have been caught in Attr
1747                     return tree;
1748                 }
1749                 ot = ots.head;
1750             } while (ot.owner != otc);
1751             if (otc.owner.kind != PCK &amp;&amp; !otc.hasOuterInstance()) {
1752                 chk.earlyRefError(pos, c);
1753                 Assert.error(); // should have been caught in Attr
1754                 return makeNull();
1755             }
1756             tree = access(make.at(pos).Select(tree, ot));
1757             otc = ot.type.tsym;
1758         }
1759         return tree;
1760     }
1761 
1762     /** Construct a tree that represents the closest outer instance
1763      *  {@code C.this} such that the given symbol is a member of C.
1764      *  @param pos           The source code position to be used for the tree.
1765      *  @param sym           The accessed symbol.
1766      *  @param preciseMatch  should we accept a type that is a subtype of
1767      *                       sym&#39;s owner, even if it doesn&#39;t contain sym
1768      *                       due to hiding, overriding, or non-inheritance
1769      *                       due to protection?
1770      */
1771     JCExpression makeOwnerThis(DiagnosticPosition pos, Symbol sym, boolean preciseMatch) {
1772         Symbol c = sym.owner;
1773         if (preciseMatch ? sym.isMemberOf(currentClass, types)
1774                          : currentClass.isSubClass(sym.owner, types)) {
1775             // in this case, `this&#39; works fine
1776             return make.at(pos).This(c.erasure(types));
1777         } else {
1778             // need to go via this$n
1779             return makeOwnerThisN(pos, sym, preciseMatch);
1780         }
1781     }
1782 
1783     /**
1784      * Similar to makeOwnerThis but will never pick &quot;this&quot;.
1785      */
1786     JCExpression makeOwnerThisN(DiagnosticPosition pos, Symbol sym, boolean preciseMatch) {
1787         Symbol c = sym.owner;
1788         List&lt;VarSymbol&gt; ots = outerThisStack;
1789         if (ots.isEmpty()) {
1790             log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));
1791             Assert.error();
1792             return makeNull();
1793         }
1794         VarSymbol ot = ots.head;
1795         JCExpression tree = access(make.at(pos).Ident(ot));
1796         TypeSymbol otc = ot.type.tsym;
1797         while (!(preciseMatch ? sym.isMemberOf(otc, types) : otc.isSubClass(sym.owner, types))) {
1798             do {
1799                 ots = ots.tail;
1800                 if (ots.isEmpty()) {
1801                     log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));
1802                     Assert.error();
1803                     return tree;
1804                 }
1805                 ot = ots.head;
1806             } while (ot.owner != otc);
1807             tree = access(make.at(pos).Select(tree, ot));
1808             otc = ot.type.tsym;
1809         }
1810         return tree;
1811     }
1812 
1813     /** Return tree simulating the assignment {@code this.name = name}, where
1814      *  name is the name of a free variable.
1815      */
1816     JCStatement initField(int pos, Symbol rhs, Symbol lhs) {
1817         Assert.check(rhs.owner.kind == MTH);
1818         Assert.check(rhs.owner.owner == lhs.owner);
1819         make.at(pos);
1820         return
1821             make.Exec(
1822                 make.Assign(
1823                     make.Select(make.This(lhs.owner.erasure(types)), lhs),
1824                     make.Ident(rhs)).setType(lhs.erasure(types)));
1825     }
1826 
1827     /** Return tree simulating the assignment {@code this.this$n = this$n}.
1828      */
1829     JCStatement initOuterThis(int pos) {
1830         VarSymbol rhs = outerThisStack.head;
1831         Assert.check(rhs.owner.kind == MTH);
1832         VarSymbol lhs = outerThisStack.tail.head;
1833         Assert.check(rhs.owner.owner == lhs.owner);
1834         make.at(pos);
1835         return
1836             make.Exec(
1837                 make.Assign(
1838                     make.Select(make.This(lhs.owner.erasure(types)), lhs),
1839                     make.Ident(rhs)).setType(lhs.erasure(types)));
1840     }
1841 
1842 /**************************************************************************
1843  * Code for .class
1844  *************************************************************************/
1845 
1846     /** Return the symbol of a class to contain a cache of
1847      *  compiler-generated statics such as class$ and the
1848      *  $assertionsDisabled flag.  We create an anonymous nested class
1849      *  (unless one already exists) and return its symbol.  However,
1850      *  for backward compatibility in 1.4 and earlier we use the
1851      *  top-level class itself.
1852      */
1853     private ClassSymbol outerCacheClass() {
1854         ClassSymbol clazz = outermostClassDef.sym;
1855         Scope s = clazz.members();
1856         for (Symbol sym : s.getSymbols(NON_RECURSIVE))
1857             if (sym.kind == TYP &amp;&amp;
1858                 sym.name == names.empty &amp;&amp;
1859                 (sym.flags() &amp; INTERFACE) == 0) return (ClassSymbol) sym;
1860         return makeEmptyClass(STATIC | SYNTHETIC, clazz).sym;
1861     }
1862 
1863     /** Create an attributed tree of the form left.name(). */
1864     private JCMethodInvocation makeCall(JCExpression left, Name name, List&lt;JCExpression&gt; args) {
1865         Assert.checkNonNull(left.type);
1866         Symbol funcsym = lookupMethod(make_pos, name, left.type,
1867                                       TreeInfo.types(args));
1868         return make.App(make.Select(left, funcsym), args);
1869     }
1870 
1871     /** The tree simulating a T.class expression.
1872      *  @param clazz      The tree identifying type T.
1873      */
1874     private JCExpression classOf(JCTree clazz) {
1875         return classOfType(clazz.type, clazz.pos());
1876     }
1877 
1878     private JCExpression classOfType(Type type, DiagnosticPosition pos) {
1879         switch (type.getTag()) {
1880         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1881         case DOUBLE: case BOOLEAN: case VOID:
1882             // replace with &lt;BoxedClass&gt;.TYPE
1883             ClassSymbol c = types.boxedClass(type);
1884             Symbol typeSym =
1885                 rs.accessBase(
1886                     rs.findIdentInType(pos, attrEnv, c.type, names.TYPE, KindSelector.VAR),
1887                     pos, c.type, names.TYPE, true);
1888             if (typeSym.kind == VAR)
1889                 ((VarSymbol)typeSym).getConstValue(); // ensure initializer is evaluated
1890             return make.QualIdent(typeSym);
1891         case CLASS: case ARRAY:
1892                 VarSymbol sym = new VarSymbol(
1893                         STATIC | PUBLIC | FINAL, names._class,
1894                         syms.classType, type.tsym);
1895                 return make_at(pos).Select(make.Type(type), sym);
1896         default:
1897             throw new AssertionError();
1898         }
1899     }
1900 
1901 /**************************************************************************
1902  * Code for enabling/disabling assertions.
1903  *************************************************************************/
1904 
1905     private ClassSymbol assertionsDisabledClassCache;
1906 
1907     /**Used to create an auxiliary class to hold $assertionsDisabled for interfaces.
1908      */
1909     private ClassSymbol assertionsDisabledClass() {
1910         if (assertionsDisabledClassCache != null) return assertionsDisabledClassCache;
1911 
1912         assertionsDisabledClassCache = makeEmptyClass(STATIC | SYNTHETIC, outermostClassDef.sym).sym;
1913 
1914         return assertionsDisabledClassCache;
1915     }
1916 
1917     // This code is not particularly robust if the user has
1918     // previously declared a member named &#39;$assertionsDisabled&#39;.
1919     // The same faulty idiom also appears in the translation of
1920     // class literals above.  We should report an error if a
1921     // previous declaration is not synthetic.
1922 
1923     private JCExpression assertFlagTest(DiagnosticPosition pos) {
1924         // Outermost class may be either true class or an interface.
1925         ClassSymbol outermostClass = outermostClassDef.sym;
1926 
1927         //only classes can hold a non-public field, look for a usable one:
1928         ClassSymbol container = !currentClass.isInterface() ? currentClass :
1929                 assertionsDisabledClass();
1930 
1931         VarSymbol assertDisabledSym =
1932             (VarSymbol)lookupSynthetic(dollarAssertionsDisabled,
1933                                        container.members());
1934         if (assertDisabledSym == null) {
1935             assertDisabledSym =
1936                 new VarSymbol(STATIC | FINAL | SYNTHETIC,
1937                               dollarAssertionsDisabled,
1938                               syms.booleanType,
1939                               container);
1940             enterSynthetic(pos, assertDisabledSym, container.members());
1941             Symbol desiredAssertionStatusSym = lookupMethod(pos,
1942                                                             names.desiredAssertionStatus,
1943                                                             types.erasure(syms.classType),
1944                                                             List.nil());
1945             JCClassDecl containerDef = classDef(container);
1946             make_at(containerDef.pos());
1947             JCExpression notStatus = makeUnary(NOT, make.App(make.Select(
1948                     classOfType(types.erasure(outermostClass.type),
1949                                 containerDef.pos()),
1950                     desiredAssertionStatusSym)));
1951             JCVariableDecl assertDisabledDef = make.VarDef(assertDisabledSym,
1952                                                    notStatus);
1953             containerDef.defs = containerDef.defs.prepend(assertDisabledDef);
1954 
1955             if (currentClass.isInterface()) {
1956                 //need to load the assertions enabled/disabled state while
1957                 //initializing the interface:
1958                 JCClassDecl currentClassDef = classDef(currentClass);
1959                 make_at(currentClassDef.pos());
1960                 JCStatement dummy = make.If(make.QualIdent(assertDisabledSym), make.Skip(), null);
1961                 JCBlock clinit = make.Block(STATIC, List.of(dummy));
1962                 currentClassDef.defs = currentClassDef.defs.prepend(clinit);
1963             }
1964         }
1965         make_at(pos);
1966         return makeUnary(NOT, make.Ident(assertDisabledSym));
1967     }
1968 
1969 
1970 /**************************************************************************
1971  * Building blocks for let expressions
1972  *************************************************************************/
1973 
1974     interface TreeBuilder {
1975         JCExpression build(JCExpression arg);
1976     }
1977 
1978     /** Construct an expression using the builder, with the given rval
1979      *  expression as an argument to the builder.  However, the rval
1980      *  expression must be computed only once, even if used multiple
1981      *  times in the result of the builder.  We do that by
1982      *  constructing a &quot;let&quot; expression that saves the rvalue into a
1983      *  temporary variable and then uses the temporary variable in
1984      *  place of the expression built by the builder.  The complete
1985      *  resulting expression is of the form
1986      *  &lt;pre&gt;
1987      *    (let &lt;b&gt;TYPE&lt;/b&gt; &lt;b&gt;TEMP&lt;/b&gt; = &lt;b&gt;RVAL&lt;/b&gt;;
1988      *     in (&lt;b&gt;BUILDER&lt;/b&gt;(&lt;b&gt;TEMP&lt;/b&gt;)))
1989      *  &lt;/pre&gt;
1990      *  where &lt;code&gt;&lt;b&gt;TEMP&lt;/b&gt;&lt;/code&gt; is a newly declared variable
1991      *  in the let expression.
1992      */
1993     JCExpression abstractRval(JCExpression rval, Type type, TreeBuilder builder) {
1994         rval = TreeInfo.skipParens(rval);
1995         switch (rval.getTag()) {
1996         case LITERAL:
1997             return builder.build(rval);
1998         case IDENT:
1999             JCIdent id = (JCIdent) rval;
2000             if ((id.sym.flags() &amp; FINAL) != 0 &amp;&amp; id.sym.owner.kind == MTH)
2001                 return builder.build(rval);
2002         }
2003         Name name = TreeInfo.name(rval);
2004         if (name == names._super || name == names._this)
2005             return builder.build(rval);
2006         VarSymbol var =
2007             new VarSymbol(FINAL|SYNTHETIC,
2008                           names.fromString(
2009                                           target.syntheticNameChar()
2010                                           + &quot;&quot; + rval.hashCode()),
2011                                       type,
2012                                       currentMethodSym);
2013         rval = convert(rval,type);
2014         JCVariableDecl def = make.VarDef(var, rval); // XXX cast
2015         JCExpression built = builder.build(make.Ident(var));
2016         JCExpression res = make.LetExpr(def, built);
2017         res.type = built.type;
2018         return res;
2019     }
2020 
2021     // same as above, with the type of the temporary variable computed
2022     JCExpression abstractRval(JCExpression rval, TreeBuilder builder) {
2023         return abstractRval(rval, rval.type, builder);
2024     }
2025 
2026     // same as above, but for an expression that may be used as either
2027     // an rvalue or an lvalue.  This requires special handling for
2028     // Select expressions, where we place the left-hand-side of the
2029     // select in a temporary, and for Indexed expressions, where we
2030     // place both the indexed expression and the index value in temps.
2031     JCExpression abstractLval(JCExpression lval, final TreeBuilder builder) {
2032         lval = TreeInfo.skipParens(lval);
2033         switch (lval.getTag()) {
2034         case IDENT:
2035             return builder.build(lval);
2036         case SELECT: {
2037             final JCFieldAccess s = (JCFieldAccess)lval;
2038             Symbol lid = TreeInfo.symbol(s.selected);
2039             if (lid != null &amp;&amp; lid.kind == TYP) return builder.build(lval);
2040             return abstractRval(s.selected, selected -&gt; builder.build(make.Select(selected, s.sym)));
2041         }
2042         case INDEXED: {
2043             final JCArrayAccess i = (JCArrayAccess)lval;
2044             return abstractRval(i.indexed, indexed -&gt; abstractRval(i.index, syms.intType, index -&gt; {
2045                 JCExpression newLval = make.Indexed(indexed, index);
2046                 newLval.setType(i.type);
2047                 return builder.build(newLval);
2048             }));
2049         }
2050         case TYPECAST: {
2051             return abstractLval(((JCTypeCast)lval).expr, builder);
2052         }
2053         }
2054         throw new AssertionError(lval);
2055     }
2056 
2057     // evaluate and discard the first expression, then evaluate the second.
2058     JCExpression makeComma(final JCExpression expr1, final JCExpression expr2) {
2059         JCExpression res = make.LetExpr(List.of(make.Exec(expr1)), expr2);
2060         res.type = expr2.type;
2061         return res;
2062     }
2063 
2064 /**************************************************************************
2065  * Translation methods
2066  *************************************************************************/
2067 
2068     /** Visitor argument: enclosing operator node.
2069      */
2070     private JCExpression enclOp;
2071 
2072     /** Visitor method: Translate a single node.
2073      *  Attach the source position from the old tree to its replacement tree.
2074      */
2075     @Override
2076     public &lt;T extends JCTree&gt; T translate(T tree) {
2077         if (tree == null) {
2078             return null;
2079         } else {
2080             make_at(tree.pos());
2081             T result = super.translate(tree);
2082             if (endPosTable != null &amp;&amp; result != tree) {
2083                 endPosTable.replaceTree(tree, result);
2084             }
2085             return result;
2086         }
2087     }
2088 
2089     /** Visitor method: Translate a single node, boxing or unboxing if needed.
2090      */
2091     public &lt;T extends JCExpression&gt; T translate(T tree, Type type) {
2092         return (tree == null) ? null : boxIfNeeded(translate(tree), type);
2093     }
2094 
2095     /** Visitor method: Translate tree.
2096      */
2097     public &lt;T extends JCTree&gt; T translate(T tree, JCExpression enclOp) {
2098         JCExpression prevEnclOp = this.enclOp;
2099         this.enclOp = enclOp;
2100         T res = translate(tree);
2101         this.enclOp = prevEnclOp;
2102         return res;
2103     }
2104 
2105     /** Visitor method: Translate list of trees.
2106      */
2107     public &lt;T extends JCExpression&gt; List&lt;T&gt; translate(List&lt;T&gt; trees, Type type) {
2108         if (trees == null) return null;
2109         for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)
2110             l.head = translate(l.head, type);
2111         return trees;
2112     }
2113 
2114     public void visitPackageDef(JCPackageDecl tree) {
2115         if (!needPackageInfoClass(tree))
2116                         return;
2117 
2118         long flags = Flags.ABSTRACT | Flags.INTERFACE;
2119         // package-info is marked SYNTHETIC in JDK 1.6 and later releases
2120         flags = flags | Flags.SYNTHETIC;
2121         ClassSymbol c = tree.packge.package_info;
2122         c.setAttributes(tree.packge);
2123         c.flags_field |= flags;
2124         ClassType ctype = (ClassType) c.type;
2125         ctype.supertype_field = syms.objectType;
2126         ctype.interfaces_field = List.nil();
2127         createInfoClass(tree.annotations, c);
2128     }
2129     // where
2130     private boolean needPackageInfoClass(JCPackageDecl pd) {
2131         switch (pkginfoOpt) {
2132             case ALWAYS:
2133                 return true;
2134             case LEGACY:
2135                 return pd.getAnnotations().nonEmpty();
2136             case NONEMPTY:
2137                 for (Attribute.Compound a :
2138                          pd.packge.getDeclarationAttributes()) {
2139                     Attribute.RetentionPolicy p = types.getRetention(a);
2140                     if (p != Attribute.RetentionPolicy.SOURCE)
2141                         return true;
2142                 }
2143                 return false;
2144         }
2145         throw new AssertionError();
2146     }
2147 
2148     public void visitModuleDef(JCModuleDecl tree) {
2149         ModuleSymbol msym = tree.sym;
2150         ClassSymbol c = msym.module_info;
2151         c.setAttributes(msym);
2152         c.flags_field |= Flags.MODULE;
2153         createInfoClass(List.nil(), tree.sym.module_info);
2154     }
2155 
2156     private void createInfoClass(List&lt;JCAnnotation&gt; annots, ClassSymbol c) {
2157         long flags = Flags.ABSTRACT | Flags.INTERFACE;
2158         JCClassDecl infoClass =
2159                 make.ClassDef(make.Modifiers(flags, annots),
2160                     c.name, List.nil(),
2161                     null, List.nil(), List.nil());
2162         infoClass.sym = c;
2163         translated.append(infoClass);
2164     }
2165 
2166     public void visitClassDef(JCClassDecl tree) {
2167         Env&lt;AttrContext&gt; prevEnv = attrEnv;
2168         ClassSymbol currentClassPrev = currentClass;
2169         MethodSymbol currentMethodSymPrev = currentMethodSym;
2170 
2171         currentClass = tree.sym;
2172         currentMethodSym = null;
2173         attrEnv = typeEnvs.remove(currentClass);
2174         if (attrEnv == null)
2175             attrEnv = prevEnv;
2176 
2177         classdefs.put(currentClass, tree);
2178 
2179         Map&lt;Symbol, Symbol&gt; prevProxies = proxies;
2180         proxies = new HashMap&lt;&gt;(proxies);
2181         List&lt;VarSymbol&gt; prevOuterThisStack = outerThisStack;
2182 
2183         // If this is an enum definition
2184         if ((tree.mods.flags &amp; ENUM) != 0 &amp;&amp;
2185             (types.supertype(currentClass.type).tsym.flags() &amp; ENUM) == 0)
2186             visitEnumDef(tree);
2187 
2188         if ((tree.mods.flags &amp; RECORD) != 0) {
2189             visitRecordDef(tree);
2190         }
2191 
2192         // If this is a nested class, define a this$n field for
2193         // it and add to proxies.
2194         JCVariableDecl otdef = null;
2195         if (currentClass.hasOuterInstance())
2196             otdef = outerThisDef(tree.pos, currentClass);
2197 
2198         // If this is a local class, define proxies for all its free variables.
2199         List&lt;JCVariableDecl&gt; fvdefs = freevarDefs(
2200             tree.pos, freevars(currentClass), currentClass);
2201 
2202         // Recursively translate superclass, interfaces.
2203         tree.extending = translate(tree.extending);
2204         tree.implementing = translate(tree.implementing);
2205 
2206         if (currentClass.isLocal()) {
2207             ClassSymbol encl = currentClass.owner.enclClass();
2208             if (encl.trans_local == null) {
2209                 encl.trans_local = List.nil();
2210             }
2211             encl.trans_local = encl.trans_local.prepend(currentClass);
2212         }
2213 
2214         // Recursively translate members, taking into account that new members
2215         // might be created during the translation and prepended to the member
2216         // list `tree.defs&#39;.
2217         List&lt;JCTree&gt; seen = List.nil();
2218         while (tree.defs != seen) {
2219             List&lt;JCTree&gt; unseen = tree.defs;
2220             for (List&lt;JCTree&gt; l = unseen; l.nonEmpty() &amp;&amp; l != seen; l = l.tail) {
2221                 JCTree outermostMemberDefPrev = outermostMemberDef;
2222                 if (outermostMemberDefPrev == null) outermostMemberDef = l.head;
2223                 l.head = translate(l.head);
2224                 outermostMemberDef = outermostMemberDefPrev;
2225             }
2226             seen = unseen;
2227         }
2228 
2229         // Convert a protected modifier to public, mask static modifier.
2230         if ((tree.mods.flags &amp; PROTECTED) != 0) tree.mods.flags |= PUBLIC;
2231         tree.mods.flags &amp;= ClassFlags;
2232 
2233         // Convert name to flat representation, replacing &#39;.&#39; by &#39;$&#39;.
2234         tree.name = Convert.shortName(currentClass.flatName());
2235 
2236         // Add this$n and free variables proxy definitions to class.
2237 
2238         for (List&lt;JCVariableDecl&gt; l = fvdefs; l.nonEmpty(); l = l.tail) {
2239             tree.defs = tree.defs.prepend(l.head);
2240             enterSynthetic(tree.pos(), l.head.sym, currentClass.members());
2241         }
2242         if (currentClass.hasOuterInstance()) {
2243             tree.defs = tree.defs.prepend(otdef);
2244             enterSynthetic(tree.pos(), otdef.sym, currentClass.members());
2245         }
2246 
2247         proxies = prevProxies;
2248         outerThisStack = prevOuterThisStack;
2249 
2250         // Append translated tree to `translated&#39; queue.
2251         translated.append(tree);
2252 
2253         attrEnv = prevEnv;
2254         currentClass = currentClassPrev;
2255         currentMethodSym = currentMethodSymPrev;
2256 
2257         // Return empty block {} as a placeholder for an inner class.
2258         result = make_at(tree.pos()).Block(SYNTHETIC, List.nil());
2259     }
2260 
2261     List&lt;JCTree&gt; generateMandatedAccessors(JCClassDecl tree) {
2262         List&lt;JCVariableDecl&gt; fields = TreeInfo.recordFields(tree);
2263         return tree.sym.getRecordComponents().stream()
2264                 .filter(rc -&gt; (rc.accessor.flags() &amp; Flags.GENERATED_MEMBER) != 0)
2265                 .map(rc -&gt; {
2266                     // we need to return the field not the record component
2267                     JCVariableDecl field = fields.stream().filter(f -&gt; f.name == rc.name).findAny().get();
2268                     make_at(tree.pos());
2269                     return make.MethodDef(rc.accessor, make.Block(0,
2270                             List.of(make.Return(make.Ident(field)))));
2271                 }).collect(List.collector());
2272     }
2273 
2274     /** Translate an enum class. */
2275     private void visitEnumDef(JCClassDecl tree) {
2276         make_at(tree.pos());
2277 
2278         // add the supertype, if needed
2279         if (tree.extending == null)
2280             tree.extending = make.Type(types.supertype(tree.type));
2281 
2282         // classOfType adds a cache field to tree.defs
2283         JCExpression e_class = classOfType(tree.sym.type, tree.pos()).
2284             setType(types.erasure(syms.classType));
2285 
2286         // process each enumeration constant, adding implicit constructor parameters
2287         int nextOrdinal = 0;
2288         ListBuffer&lt;JCExpression&gt; values = new ListBuffer&lt;&gt;();
2289         ListBuffer&lt;JCTree&gt; enumDefs = new ListBuffer&lt;&gt;();
2290         ListBuffer&lt;JCTree&gt; otherDefs = new ListBuffer&lt;&gt;();
2291         for (List&lt;JCTree&gt; defs = tree.defs;
2292              defs.nonEmpty();
2293              defs=defs.tail) {
2294             if (defs.head.hasTag(VARDEF) &amp;&amp; (((JCVariableDecl) defs.head).mods.flags &amp; ENUM) != 0) {
2295                 JCVariableDecl var = (JCVariableDecl)defs.head;
2296                 visitEnumConstantDef(var, nextOrdinal++);
2297                 values.append(make.QualIdent(var.sym));
2298                 enumDefs.append(var);
2299             } else {
2300                 otherDefs.append(defs.head);
2301             }
2302         }
2303 
2304         // synthetic private static T[] $values() { return new T[] { a, b, c }; }
2305         // synthetic private static final T[] $VALUES = $values();
2306         Name valuesName = syntheticName(tree, &quot;VALUES&quot;);
2307         Type arrayType = new ArrayType(types.erasure(tree.type), syms.arrayClass);
2308         VarSymbol valuesVar = new VarSymbol(PRIVATE|FINAL|STATIC|SYNTHETIC,
2309                                             valuesName,
2310                                             arrayType,
2311                                             tree.type.tsym);
2312         JCNewArray newArray = make.NewArray(make.Type(types.erasure(tree.type)),
2313                                           List.nil(),
2314                                           values.toList());
2315         newArray.type = arrayType;
2316 
2317         MethodSymbol valuesMethod = new MethodSymbol(PRIVATE|STATIC|SYNTHETIC,
2318                 syntheticName(tree, &quot;values&quot;),
2319                 new MethodType(List.nil(), arrayType, List.nil(), tree.type.tsym),
2320                 tree.type.tsym);
2321         enumDefs.append(make.MethodDef(valuesMethod, make.Block(0, List.of(make.Return(newArray)))));
2322         tree.sym.members().enter(valuesMethod);
2323 
2324         enumDefs.append(make.VarDef(valuesVar, make.App(make.QualIdent(valuesMethod))));
2325         tree.sym.members().enter(valuesVar);
2326 
2327         Symbol valuesSym = lookupMethod(tree.pos(), names.values,
2328                                         tree.type, List.nil());
2329         List&lt;JCStatement&gt; valuesBody;
2330         if (useClone()) {
2331             // return (T[]) $VALUES.clone();
2332             JCTypeCast valuesResult =
2333                 make.TypeCast(valuesSym.type.getReturnType(),
2334                               make.App(make.Select(make.Ident(valuesVar),
2335                                                    syms.arrayCloneMethod)));
2336             valuesBody = List.of(make.Return(valuesResult));
2337         } else {
2338             // template: T[] $result = new T[$values.length];
2339             Name resultName = syntheticName(tree, &quot;result&quot;);
2340             VarSymbol resultVar = new VarSymbol(FINAL|SYNTHETIC,
2341                                                 resultName,
2342                                                 arrayType,
2343                                                 valuesSym);
2344             JCNewArray resultArray = make.NewArray(make.Type(types.erasure(tree.type)),
2345                                   List.of(make.Select(make.Ident(valuesVar), syms.lengthVar)),
2346                                   null);
2347             resultArray.type = arrayType;
2348             JCVariableDecl decl = make.VarDef(resultVar, resultArray);
2349 
2350             // template: System.arraycopy($VALUES, 0, $result, 0, $VALUES.length);
2351             if (systemArraycopyMethod == null) {
2352                 systemArraycopyMethod =
2353                     new MethodSymbol(PUBLIC | STATIC,
2354                                      names.fromString(&quot;arraycopy&quot;),
2355                                      new MethodType(List.of(syms.objectType,
2356                                                             syms.intType,
2357                                                             syms.objectType,
2358                                                             syms.intType,
2359                                                             syms.intType),
2360                                                     syms.voidType,
2361                                                     List.nil(),
2362                                                     syms.methodClass),
2363                                      syms.systemType.tsym);
2364             }
2365             JCStatement copy =
2366                 make.Exec(make.App(make.Select(make.Ident(syms.systemType.tsym),
2367                                                systemArraycopyMethod),
2368                           List.of(make.Ident(valuesVar), make.Literal(0),
2369                                   make.Ident(resultVar), make.Literal(0),
2370                                   make.Select(make.Ident(valuesVar), syms.lengthVar))));
2371 
2372             // template: return $result;
2373             JCStatement ret = make.Return(make.Ident(resultVar));
2374             valuesBody = List.of(decl, copy, ret);
2375         }
2376 
2377         JCMethodDecl valuesDef =
2378              make.MethodDef((MethodSymbol)valuesSym, make.Block(0, valuesBody));
2379 
2380         enumDefs.append(valuesDef);
2381 
2382         if (debugLower)
2383             System.err.println(tree.sym + &quot;.valuesDef = &quot; + valuesDef);
2384 
2385         /** The template for the following code is:
2386          *
2387          *     public static E valueOf(String name) {
2388          *         return (E)Enum.valueOf(E.class, name);
2389          *     }
2390          *
2391          *  where E is tree.sym
2392          */
2393         MethodSymbol valueOfSym = lookupMethod(tree.pos(),
2394                          names.valueOf,
2395                          tree.sym.type,
2396                          List.of(syms.stringType));
2397         Assert.check((valueOfSym.flags() &amp; STATIC) != 0);
2398         VarSymbol nameArgSym = valueOfSym.params.head;
2399         JCIdent nameVal = make.Ident(nameArgSym);
2400         JCStatement enum_ValueOf =
2401             make.Return(make.TypeCast(tree.sym.type,
2402                                       makeCall(make.Ident(syms.enumSym),
2403                                                names.valueOf,
2404                                                List.of(e_class, nameVal))));
2405         JCMethodDecl valueOf = make.MethodDef(valueOfSym,
2406                                            make.Block(0, List.of(enum_ValueOf)));
2407         nameVal.sym = valueOf.params.head.sym;
2408         if (debugLower)
2409             System.err.println(tree.sym + &quot;.valueOf = &quot; + valueOf);
2410         enumDefs.append(valueOf);
2411 
2412         enumDefs.appendList(otherDefs.toList());
2413         tree.defs = enumDefs.toList();
2414     }
2415         // where
2416         private MethodSymbol systemArraycopyMethod;
2417         private boolean useClone() {
2418             try {
2419                 return syms.objectType.tsym.members().findFirst(names.clone) != null;
2420             }
2421             catch (CompletionFailure e) {
2422                 return false;
2423             }
2424         }
2425 
2426         private Name syntheticName(JCClassDecl tree, String baseName) {
2427             Name valuesName = names.fromString(target.syntheticNameChar() + baseName);
2428             while (tree.sym.members().findFirst(valuesName) != null) // avoid name clash
2429                 valuesName = names.fromString(valuesName + &quot;&quot; + target.syntheticNameChar());
2430             return valuesName;
2431         }
2432 
2433     /** Translate an enumeration constant and its initializer. */
2434     private void visitEnumConstantDef(JCVariableDecl var, int ordinal) {
2435         JCNewClass varDef = (JCNewClass)var.init;
2436         varDef.args = varDef.args.
2437             prepend(makeLit(syms.intType, ordinal)).
2438             prepend(makeLit(syms.stringType, var.name.toString()));
2439     }
2440 
2441     private List&lt;VarSymbol&gt; recordVars(Type t) {
2442         List&lt;VarSymbol&gt; vars = List.nil();
2443         while (!t.hasTag(NONE)) {
2444             if (t.hasTag(CLASS)) {
2445                 for (Symbol s : t.tsym.members().getSymbols(s -&gt; s.kind == VAR &amp;&amp; (s.flags() &amp; RECORD) != 0)) {
2446                     vars = vars.prepend((VarSymbol)s);
2447                 }
2448             }
2449             t = types.supertype(t);
2450         }
2451         return vars;
2452     }
2453 
2454     /** Translate a record. */
2455     private void visitRecordDef(JCClassDecl tree) {
2456         make_at(tree.pos());
2457         List&lt;VarSymbol&gt; vars = recordVars(tree.type);
2458         MethodHandleSymbol[] getterMethHandles = new MethodHandleSymbol[vars.size()];
2459         int index = 0;
2460         for (VarSymbol var : vars) {
2461             if (var.owner != tree.sym) {
2462                 var = new VarSymbol(var.flags_field, var.name, var.type, tree.sym);
2463             }
2464             getterMethHandles[index] = var.asMethodHandle(true);
2465             index++;
2466         }
2467 
2468         tree.defs = tree.defs.appendList(generateMandatedAccessors(tree));
2469         tree.defs = tree.defs.appendList(List.of(
2470                 generateRecordMethod(tree, names.toString, vars, getterMethHandles),
2471                 generateRecordMethod(tree, names.hashCode, vars, getterMethHandles),
2472                 generateRecordMethod(tree, names.equals, vars, getterMethHandles)
2473         ));
2474     }
2475 
2476     JCTree generateRecordMethod(JCClassDecl tree, Name name, List&lt;VarSymbol&gt; vars, MethodHandleSymbol[] getterMethHandles) {
2477         make_at(tree.pos());
2478         boolean isEquals = name == names.equals;
2479         MethodSymbol msym = lookupMethod(tree.pos(),
2480                 name,
2481                 tree.sym.type,
2482                 isEquals ? List.of(syms.objectType) : List.nil());
2483         // compiler generated methods have the record flag set, user defined ones dont
2484         if ((msym.flags() &amp; RECORD) != 0) {
2485             /* class java.lang.runtime.ObjectMethods provides a common bootstrap that provides a customized implementation
2486              * for methods: toString, hashCode and equals. Here we just need to generate and indy call to:
2487              * java.lang.runtime.ObjectMethods::bootstrap and provide: the record class, the record component names and
2488              * the accessors.
2489              */
2490             Name bootstrapName = names.bootstrap;
2491             LoadableConstant[] staticArgsValues = new LoadableConstant[2 + getterMethHandles.length];
2492             staticArgsValues[0] = (ClassType)tree.sym.type;
2493             String concatNames = vars.stream()
2494                     .map(v -&gt; v.name)
2495                     .collect(Collectors.joining(&quot;;&quot;, &quot;&quot;, &quot;&quot;));
2496             staticArgsValues[1] = LoadableConstant.String(concatNames);
2497             int index = 2;
2498             for (MethodHandleSymbol mho : getterMethHandles) {
2499                 staticArgsValues[index] = mho;
2500                 index++;
2501             }
2502 
2503             List&lt;Type&gt; staticArgTypes = List.of(syms.classType,
2504                     syms.stringType,
2505                     new ArrayType(syms.methodHandleType, syms.arrayClass));
2506 
2507             JCFieldAccess qualifier = makeIndyQualifier(syms.objectMethodsType, tree, msym,
2508                     List.of(syms.methodHandleLookupType,
2509                             syms.stringType,
2510                             syms.typeDescriptorType).appendList(staticArgTypes),
2511                     staticArgsValues, bootstrapName, name, false);
2512 
2513             VarSymbol _this = new VarSymbol(SYNTHETIC, names._this, tree.sym.type, tree.sym);
2514 
2515             JCMethodInvocation proxyCall;
2516             if (!isEquals) {
2517                 proxyCall = make.Apply(List.nil(), qualifier, List.of(make.Ident(_this)));
2518             } else {
2519                 VarSymbol o = msym.params.head;
2520                 o.adr = 0;
2521                 proxyCall = make.Apply(List.nil(), qualifier, List.of(make.Ident(_this), make.Ident(o)));
2522             }
2523             proxyCall.type = qualifier.type;
2524             return make.MethodDef(msym, make.Block(0, List.of(make.Return(proxyCall))));
2525         } else {
2526             return make.Block(SYNTHETIC, List.nil());
2527         }
2528     }
2529 
2530     private String argsTypeSig(List&lt;Type&gt; typeList) {
2531         LowerSignatureGenerator sg = new LowerSignatureGenerator();
2532         sg.assembleSig(typeList);
2533         return sg.toString();
2534     }
2535 
2536     /**
2537      * Signature Generation
2538      */
2539     private class LowerSignatureGenerator extends Types.SignatureGenerator {
2540 
2541         /**
2542          * An output buffer for type signatures.
2543          */
2544         StringBuilder sb = new StringBuilder();
2545 
2546         LowerSignatureGenerator() {
2547             super(types);
2548         }
2549 
2550         @Override
2551         protected void append(char ch) {
2552             sb.append(ch);
2553         }
2554 
2555         @Override
2556         protected void append(byte[] ba) {
2557             sb.append(new String(ba));
2558         }
2559 
2560         @Override
2561         protected void append(Name name) {
2562             sb.append(name.toString());
2563         }
2564 
2565         @Override
2566         public String toString() {
2567             return sb.toString();
2568         }
2569     }
2570 
2571     /**
2572      * Creates an indy qualifier, helpful to be part of an indy invocation
2573      * @param site                the site
2574      * @param tree                a class declaration tree
2575      * @param msym                the method symbol
2576      * @param staticArgTypes      the static argument types
2577      * @param staticArgValues     the static argument values
2578      * @param bootstrapName       the bootstrap name to look for
2579      * @param argName             normally bootstraps receives a method name as second argument, if you want that name
2580      *                            to be different to that of the bootstrap name pass a different name here
2581      * @param isStatic            is it static or not
2582      * @return                    a field access tree
2583      */
2584     JCFieldAccess makeIndyQualifier(
2585             Type site,
2586             JCClassDecl tree,
2587             MethodSymbol msym,
2588             List&lt;Type&gt; staticArgTypes,
2589             LoadableConstant[] staticArgValues,
2590             Name bootstrapName,
2591             Name argName,
2592             boolean isStatic) {
2593         Symbol bsm = rs.resolveInternalMethod(tree.pos(), attrEnv, site,
2594                 bootstrapName, staticArgTypes, List.nil());
2595 
2596         MethodType indyType = msym.type.asMethodType();
2597         indyType = new MethodType(
2598                 isStatic ? List.nil() : indyType.argtypes.prepend(tree.sym.type),
2599                 indyType.restype,
2600                 indyType.thrown,
2601                 syms.methodClass
2602         );
2603         DynamicMethodSymbol dynSym = new DynamicMethodSymbol(argName,
2604                 syms.noSymbol,
2605                 ((MethodSymbol)bsm).asHandle(),
2606                 indyType,
2607                 staticArgValues);
2608         JCFieldAccess qualifier = make.Select(make.QualIdent(site.tsym), argName);
2609         qualifier.sym = dynSym;
2610         qualifier.type = msym.type.asMethodType().restype;
2611         return qualifier;
2612     }
2613 
2614     public void visitMethodDef(JCMethodDecl tree) {
2615         if (tree.name == names.init &amp;&amp; (currentClass.flags_field&amp;ENUM) != 0) {
2616             // Add &quot;String $enum$name, int $enum$ordinal&quot; to the beginning of the
2617             // argument list for each constructor of an enum.
2618             JCVariableDecl nameParam = make_at(tree.pos()).
2619                 Param(names.fromString(target.syntheticNameChar() +
2620                                        &quot;enum&quot; + target.syntheticNameChar() + &quot;name&quot;),
2621                       syms.stringType, tree.sym);
2622             nameParam.mods.flags |= SYNTHETIC; nameParam.sym.flags_field |= SYNTHETIC;
2623             JCVariableDecl ordParam = make.
2624                 Param(names.fromString(target.syntheticNameChar() +
2625                                        &quot;enum&quot; + target.syntheticNameChar() +
2626                                        &quot;ordinal&quot;),
2627                       syms.intType, tree.sym);
2628             ordParam.mods.flags |= SYNTHETIC; ordParam.sym.flags_field |= SYNTHETIC;
2629 
2630             MethodSymbol m = tree.sym;
2631             tree.params = tree.params.prepend(ordParam).prepend(nameParam);
2632 
2633             m.extraParams = m.extraParams.prepend(ordParam.sym);
2634             m.extraParams = m.extraParams.prepend(nameParam.sym);
2635             Type olderasure = m.erasure(types);
2636             m.erasure_field = new MethodType(
2637                 olderasure.getParameterTypes().prepend(syms.intType).prepend(syms.stringType),
2638                 olderasure.getReturnType(),
2639                 olderasure.getThrownTypes(),
2640                 syms.methodClass);
2641         }
2642 
2643         JCMethodDecl prevMethodDef = currentMethodDef;
2644         MethodSymbol prevMethodSym = currentMethodSym;
2645         try {
2646             currentMethodDef = tree;
2647             currentMethodSym = tree.sym;
2648             visitMethodDefInternal(tree);
2649         } finally {
2650             currentMethodDef = prevMethodDef;
2651             currentMethodSym = prevMethodSym;
2652         }
2653     }
2654 
2655     private void visitMethodDefInternal(JCMethodDecl tree) {
2656         if (tree.name == names.init &amp;&amp;
2657             (currentClass.isInner() || currentClass.isLocal())) {
2658             // We are seeing a constructor of an inner class.
2659             MethodSymbol m = tree.sym;
2660 
2661             // Push a new proxy scope for constructor parameters.
2662             // and create definitions for any this$n and proxy parameters.
2663             Map&lt;Symbol, Symbol&gt; prevProxies = proxies;
2664             proxies = new HashMap&lt;&gt;(proxies);
2665             List&lt;VarSymbol&gt; prevOuterThisStack = outerThisStack;
2666             List&lt;VarSymbol&gt; fvs = freevars(currentClass);
2667             JCVariableDecl otdef = null;
2668             if (currentClass.hasOuterInstance())
2669                 otdef = outerThisDef(tree.pos, m);
2670             List&lt;JCVariableDecl&gt; fvdefs = freevarDefs(tree.pos, fvs, m, PARAMETER);
2671 
2672             // Recursively translate result type, parameters and thrown list.
2673             tree.restype = translate(tree.restype);
2674             tree.params = translateVarDefs(tree.params);
2675             tree.thrown = translate(tree.thrown);
2676 
2677             // when compiling stubs, don&#39;t process body
2678             if (tree.body == null) {
2679                 result = tree;
2680                 return;
2681             }
2682 
2683             // Add this$n (if needed) in front of and free variables behind
2684             // constructor parameter list.
2685             tree.params = tree.params.appendList(fvdefs);
2686             if (currentClass.hasOuterInstance()) {
2687                 tree.params = tree.params.prepend(otdef);
2688             }
2689 
2690             // If this is an initial constructor, i.e., it does not start with
2691             // this(...), insert initializers for this$n and proxies
2692             // before (pre-1.4, after) the call to superclass constructor.
2693             JCStatement selfCall = translate(tree.body.stats.head);
2694 
2695             List&lt;JCStatement&gt; added = List.nil();
2696             if (fvs.nonEmpty()) {
2697                 List&lt;Type&gt; addedargtypes = List.nil();
2698                 for (List&lt;VarSymbol&gt; l = fvs; l.nonEmpty(); l = l.tail) {
2699                     m.capturedLocals =
2700                         m.capturedLocals.prepend((VarSymbol)
2701                                                 (proxies.get(l.head)));
2702                     if (TreeInfo.isInitialConstructor(tree)) {
2703                         added = added.prepend(
2704                           initField(tree.body.pos, proxies.get(l.head), prevProxies.get(l.head)));
2705                     }
2706                     addedargtypes = addedargtypes.prepend(l.head.erasure(types));
2707                 }
2708                 Type olderasure = m.erasure(types);
2709                 m.erasure_field = new MethodType(
2710                     olderasure.getParameterTypes().appendList(addedargtypes),
2711                     olderasure.getReturnType(),
2712                     olderasure.getThrownTypes(),
2713                     syms.methodClass);
2714             }
2715             if (currentClass.hasOuterInstance() &amp;&amp;
2716                 TreeInfo.isInitialConstructor(tree))
2717             {
2718                 added = added.prepend(initOuterThis(tree.body.pos));
2719             }
2720 
2721             // pop local variables from proxy stack
2722             proxies = prevProxies;
2723 
2724             // recursively translate following local statements and
2725             // combine with this- or super-call
2726             List&lt;JCStatement&gt; stats = translate(tree.body.stats.tail);
2727             tree.body.stats = stats.prepend(selfCall).prependList(added);
2728             outerThisStack = prevOuterThisStack;
2729         } else {
2730             Map&lt;Symbol, Symbol&gt; prevLambdaTranslationMap =
2731                     lambdaTranslationMap;
2732             try {
2733                 lambdaTranslationMap = (tree.sym.flags() &amp; SYNTHETIC) != 0 &amp;&amp;
2734                         tree.sym.name.startsWith(names.lambda) ?
2735                         makeTranslationMap(tree) : null;
2736                 super.visitMethodDef(tree);
2737             } finally {
2738                 lambdaTranslationMap = prevLambdaTranslationMap;
2739             }
2740         }
2741         if (tree.name == names.init &amp;&amp; (tree.sym.flags_field &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
2742             // lets find out if there is any field waiting to be initialized
2743             ListBuffer&lt;VarSymbol&gt; fields = new ListBuffer&lt;&gt;();
2744             for (Symbol sym : currentClass.getEnclosedElements()) {
2745                 if (sym.kind == Kinds.Kind.VAR &amp;&amp; ((sym.flags() &amp; RECORD) != 0))
2746                     fields.append((VarSymbol) sym);
2747             }
2748             for (VarSymbol field: fields) {
2749                 if ((field.flags_field &amp; Flags.UNINITIALIZED_FIELD) != 0) {
2750                     VarSymbol param = tree.params.stream().filter(p -&gt; p.name == field.name).findFirst().get().sym;
2751                     make.at(tree.pos);
2752                     tree.body.stats = tree.body.stats.append(
2753                             make.Exec(
2754                                     make.Assign(
2755                                             make.Select(make.This(field.owner.erasure(types)), field),
2756                                             make.Ident(param)).setType(field.erasure(types))));
2757                     // we don&#39;t need the flag at the field anymore
2758                     field.flags_field &amp;= ~Flags.UNINITIALIZED_FIELD;
2759                 }
2760             }
2761         }
2762         result = tree;
2763     }
2764     //where
2765         private Map&lt;Symbol, Symbol&gt; makeTranslationMap(JCMethodDecl tree) {
2766             Map&lt;Symbol, Symbol&gt; translationMap = new HashMap&lt;&gt;();
2767             for (JCVariableDecl vd : tree.params) {
2768                 Symbol p = vd.sym;
2769                 if (p != p.baseSymbol()) {
2770                     translationMap.put(p.baseSymbol(), p);
2771                 }
2772             }
2773             return translationMap;
2774         }
2775 
2776     public void visitTypeCast(JCTypeCast tree) {
2777         tree.clazz = translate(tree.clazz);
2778         if (tree.type.isPrimitive() != tree.expr.type.isPrimitive())
2779             tree.expr = translate(tree.expr, tree.type);
2780         else
2781             tree.expr = translate(tree.expr);
2782         result = tree;
2783     }
2784 
2785     public void visitNewClass(JCNewClass tree) {
2786         ClassSymbol c = (ClassSymbol)tree.constructor.owner;
2787 
2788         // Box arguments, if necessary
2789         boolean isEnum = (tree.constructor.owner.flags() &amp; ENUM) != 0;
2790         List&lt;Type&gt; argTypes = tree.constructor.type.getParameterTypes();
2791         if (isEnum) argTypes = argTypes.prepend(syms.intType).prepend(syms.stringType);
2792         tree.args = boxArgs(argTypes, tree.args, tree.varargsElement);
2793         tree.varargsElement = null;
2794 
2795         // If created class is local, add free variables after
2796         // explicit constructor arguments.
2797         if (c.isLocal()) {
2798             tree.args = tree.args.appendList(loadFreevars(tree.pos(), freevars(c)));
2799         }
2800 
2801         // If an access constructor is used, append null as a last argument.
2802         Symbol constructor = accessConstructor(tree.pos(), tree.constructor);
2803         if (constructor != tree.constructor) {
2804             tree.args = tree.args.append(makeNull());
2805             tree.constructor = constructor;
2806         }
2807 
2808         // If created class has an outer instance, and new is qualified, pass
2809         // qualifier as first argument. If new is not qualified, pass the
2810         // correct outer instance as first argument.
2811         if (c.hasOuterInstance()) {
2812             JCExpression thisArg;
2813             if (tree.encl != null) {
2814                 thisArg = attr.makeNullCheck(translate(tree.encl));
2815                 thisArg.type = tree.encl.type;
2816             } else if (c.isLocal()) {
2817                 // local class
2818                 thisArg = makeThis(tree.pos(), c.type.getEnclosingType().tsym);
2819             } else {
2820                 // nested class
2821                 thisArg = makeOwnerThis(tree.pos(), c, false);
2822             }
2823             tree.args = tree.args.prepend(thisArg);
2824         }
2825         tree.encl = null;
2826 
2827         // If we have an anonymous class, create its flat version, rather
2828         // than the class or interface following new.
2829         if (tree.def != null) {
2830             translate(tree.def);
2831             tree.clazz = access(make_at(tree.clazz.pos()).Ident(tree.def.sym));
2832             tree.def = null;
2833         } else {
2834             tree.clazz = access(c, tree.clazz, enclOp, false);
2835         }
2836         result = tree;
2837     }
2838 
2839     // Simplify conditionals with known constant controlling expressions.
2840     // This allows us to avoid generating supporting declarations for
2841     // the dead code, which will not be eliminated during code generation.
2842     // Note that Flow.isFalse and Flow.isTrue only return true
2843     // for constant expressions in the sense of JLS 15.27, which
2844     // are guaranteed to have no side-effects.  More aggressive
2845     // constant propagation would require that we take care to
2846     // preserve possible side-effects in the condition expression.
2847 
2848     // One common case is equality expressions involving a constant and null.
2849     // Since null is not a constant expression (because null cannot be
2850     // represented in the constant pool), equality checks involving null are
2851     // not captured by Flow.isTrue/isFalse.
2852     // Equality checks involving a constant and null, e.g.
2853     //     &quot;&quot; == null
2854     // are safe to simplify as no side-effects can occur.
2855 
2856     private boolean isTrue(JCTree exp) {
2857         if (exp.type.isTrue())
2858             return true;
2859         Boolean b = expValue(exp);
2860         return b == null ? false : b;
2861     }
2862     private boolean isFalse(JCTree exp) {
2863         if (exp.type.isFalse())
2864             return true;
2865         Boolean b = expValue(exp);
2866         return b == null ? false : !b;
2867     }
2868     /* look for (in)equality relations involving null.
2869      * return true - if expression is always true
2870      *       false - if expression is always false
2871      *        null - if expression cannot be eliminated
2872      */
2873     private Boolean expValue(JCTree exp) {
2874         while (exp.hasTag(PARENS))
2875             exp = ((JCParens)exp).expr;
2876 
2877         boolean eq;
2878         switch (exp.getTag()) {
2879         case EQ: eq = true;  break;
2880         case NE: eq = false; break;
2881         default:
2882             return null;
2883         }
2884 
2885         // we have a JCBinary(EQ|NE)
2886         // check if we have two literals (constants or null)
2887         JCBinary b = (JCBinary)exp;
2888         if (b.lhs.type.hasTag(BOT)) return expValueIsNull(eq, b.rhs);
2889         if (b.rhs.type.hasTag(BOT)) return expValueIsNull(eq, b.lhs);
2890         return null;
2891     }
2892     private Boolean expValueIsNull(boolean eq, JCTree t) {
2893         if (t.type.hasTag(BOT)) return Boolean.valueOf(eq);
2894         if (t.hasTag(LITERAL))  return Boolean.valueOf(!eq);
2895         return null;
2896     }
2897 
2898     /** Visitor method for conditional expressions.
2899      */
2900     @Override
2901     public void visitConditional(JCConditional tree) {
2902         JCTree cond = tree.cond = translate(tree.cond, syms.booleanType);
2903         if (isTrue(cond)) {
2904             result = convert(translate(tree.truepart, tree.type), tree.type);
2905             addPrunedInfo(cond);
2906         } else if (isFalse(cond)) {
2907             result = convert(translate(tree.falsepart, tree.type), tree.type);
2908             addPrunedInfo(cond);
2909         } else {
2910             // Condition is not a compile-time constant.
2911             tree.truepart = translate(tree.truepart, tree.type);
2912             tree.falsepart = translate(tree.falsepart, tree.type);
2913             result = tree;
2914         }
2915     }
2916 //where
2917     private JCExpression convert(JCExpression tree, Type pt) {
2918         if (tree.type == pt || tree.type.hasTag(BOT))
2919             return tree;
2920         JCExpression result = make_at(tree.pos()).TypeCast(make.Type(pt), tree);
2921         result.type = (tree.type.constValue() != null) ? cfolder.coerce(tree.type, pt)
2922                                                        : pt;
2923         return result;
2924     }
2925 
2926     /** Visitor method for if statements.
2927      */
2928     public void visitIf(JCIf tree) {
2929         JCTree cond = tree.cond = translate(tree.cond, syms.booleanType);
2930         if (isTrue(cond)) {
2931             result = translate(tree.thenpart);
2932             addPrunedInfo(cond);
2933         } else if (isFalse(cond)) {
2934             if (tree.elsepart != null) {
2935                 result = translate(tree.elsepart);
2936             } else {
2937                 result = make.Skip();
2938             }
2939             addPrunedInfo(cond);
2940         } else {
2941             // Condition is not a compile-time constant.
2942             tree.thenpart = translate(tree.thenpart);
2943             tree.elsepart = translate(tree.elsepart);
2944             result = tree;
2945         }
2946     }
2947 
2948     /** Visitor method for assert statements. Translate them away.
2949      */
2950     public void visitAssert(JCAssert tree) {
2951         tree.cond = translate(tree.cond, syms.booleanType);
2952         if (!tree.cond.type.isTrue()) {
2953             JCExpression cond = assertFlagTest(tree.pos());
2954             List&lt;JCExpression&gt; exnArgs = (tree.detail == null) ?
2955                 List.nil() : List.of(translate(tree.detail));
2956             if (!tree.cond.type.isFalse()) {
2957                 cond = makeBinary
2958                     (AND,
2959                      cond,
2960                      makeUnary(NOT, tree.cond));
2961             }
2962             result =
2963                 make.If(cond,
2964                         make_at(tree).
2965                            Throw(makeNewClass(syms.assertionErrorType, exnArgs)),
2966                         null);
2967         } else {
2968             result = make.Skip();
2969         }
2970     }
2971 
2972     public void visitApply(JCMethodInvocation tree) {
2973         Symbol meth = TreeInfo.symbol(tree.meth);
2974         List&lt;Type&gt; argtypes = meth.type.getParameterTypes();
2975         if (meth.name == names.init &amp;&amp; meth.owner == syms.enumSym)
2976             argtypes = argtypes.tail.tail;
2977         tree.args = boxArgs(argtypes, tree.args, tree.varargsElement);
2978         tree.varargsElement = null;
2979         Name methName = TreeInfo.name(tree.meth);
2980         if (meth.name==names.init) {
2981             // We are seeing a this(...) or super(...) constructor call.
2982             // If an access constructor is used, append null as a last argument.
2983             Symbol constructor = accessConstructor(tree.pos(), meth);
2984             if (constructor != meth) {
2985                 tree.args = tree.args.append(makeNull());
2986                 TreeInfo.setSymbol(tree.meth, constructor);
2987             }
2988 
2989             // If we are calling a constructor of a local class, add
2990             // free variables after explicit constructor arguments.
2991             ClassSymbol c = (ClassSymbol)constructor.owner;
2992             if (c.isLocal()) {
2993                 tree.args = tree.args.appendList(loadFreevars(tree.pos(), freevars(c)));
2994             }
2995 
2996             // If we are calling a constructor of an enum class, pass
2997             // along the name and ordinal arguments
2998             if ((c.flags_field&amp;ENUM) != 0 || c.getQualifiedName() == names.java_lang_Enum) {
2999                 List&lt;JCVariableDecl&gt; params = currentMethodDef.params;
3000                 if (currentMethodSym.owner.hasOuterInstance())
3001                     params = params.tail; // drop this$n
3002                 tree.args = tree.args
3003                     .prepend(make_at(tree.pos()).Ident(params.tail.head.sym)) // ordinal
3004                     .prepend(make.Ident(params.head.sym)); // name
3005             }
3006 
3007             // If we are calling a constructor of a class with an outer
3008             // instance, and the call
3009             // is qualified, pass qualifier as first argument in front of
3010             // the explicit constructor arguments. If the call
3011             // is not qualified, pass the correct outer instance as
3012             // first argument.
3013             if (c.hasOuterInstance()) {
3014                 JCExpression thisArg;
3015                 if (tree.meth.hasTag(SELECT)) {
3016                     thisArg = attr.
3017                         makeNullCheck(translate(((JCFieldAccess) tree.meth).selected));
3018                     tree.meth = make.Ident(constructor);
3019                     ((JCIdent) tree.meth).name = methName;
3020                 } else if (c.isLocal() || methName == names._this){
3021                     // local class or this() call
3022                     thisArg = makeThis(tree.meth.pos(), c.type.getEnclosingType().tsym);
3023                 } else {
3024                     // super() call of nested class - never pick &#39;this&#39;
3025                     thisArg = makeOwnerThisN(tree.meth.pos(), c, false);
3026                 }
3027                 tree.args = tree.args.prepend(thisArg);
3028             }
3029         } else {
3030             // We are seeing a normal method invocation; translate this as usual.
3031             tree.meth = translate(tree.meth);
3032 
3033             // If the translated method itself is an Apply tree, we are
3034             // seeing an access method invocation. In this case, append
3035             // the method arguments to the arguments of the access method.
3036             if (tree.meth.hasTag(APPLY)) {
3037                 JCMethodInvocation app = (JCMethodInvocation)tree.meth;
3038                 app.args = tree.args.prependList(app.args);
3039                 result = app;
3040                 return;
3041             }
3042         }
3043         result = tree;
3044     }
3045 
3046     List&lt;JCExpression&gt; boxArgs(List&lt;Type&gt; parameters, List&lt;JCExpression&gt; _args, Type varargsElement) {
3047         List&lt;JCExpression&gt; args = _args;
3048         if (parameters.isEmpty()) return args;
3049         boolean anyChanges = false;
3050         ListBuffer&lt;JCExpression&gt; result = new ListBuffer&lt;&gt;();
3051         while (parameters.tail.nonEmpty()) {
3052             JCExpression arg = translate(args.head, parameters.head);
3053             anyChanges |= (arg != args.head);
3054             result.append(arg);
3055             args = args.tail;
3056             parameters = parameters.tail;
3057         }
3058         Type parameter = parameters.head;
3059         if (varargsElement != null) {
3060             anyChanges = true;
3061             ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
3062             while (args.nonEmpty()) {
3063                 JCExpression arg = translate(args.head, varargsElement);
3064                 elems.append(arg);
3065                 args = args.tail;
3066             }
3067             JCNewArray boxedArgs = make.NewArray(make.Type(varargsElement),
3068                                                List.nil(),
3069                                                elems.toList());
3070             boxedArgs.type = new ArrayType(varargsElement, syms.arrayClass);
3071             result.append(boxedArgs);
3072         } else {
3073             if (args.length() != 1) throw new AssertionError(args);
3074             JCExpression arg = translate(args.head, parameter);
3075             anyChanges |= (arg != args.head);
3076             result.append(arg);
3077             if (!anyChanges) return _args;
3078         }
3079         return result.toList();
3080     }
3081 
3082     /** Expand a boxing or unboxing conversion if needed. */
3083     @SuppressWarnings(&quot;unchecked&quot;) // XXX unchecked
3084     &lt;T extends JCExpression&gt; T boxIfNeeded(T tree, Type type) {
3085         boolean havePrimitive = tree.type.isPrimitive();
3086         if (havePrimitive == type.isPrimitive())
3087             return tree;
3088         if (havePrimitive) {
3089             Type unboxedTarget = types.unboxedType(type);
3090             if (!unboxedTarget.hasTag(NONE)) {
3091                 if (!types.isSubtype(tree.type, unboxedTarget)) //e.g. Character c = 89;
3092                     tree.type = unboxedTarget.constType(tree.type.constValue());
3093                 return (T)boxPrimitive(tree, types.erasure(type));
3094             } else {
3095                 tree = (T)boxPrimitive(tree);
3096             }
3097         } else {
3098             tree = (T)unbox(tree, type);
3099         }
3100         return tree;
3101     }
3102 
3103     /** Box up a single primitive expression. */
3104     JCExpression boxPrimitive(JCExpression tree) {
3105         return boxPrimitive(tree, types.boxedClass(tree.type).type);
3106     }
3107 
3108     /** Box up a single primitive expression. */
3109     JCExpression boxPrimitive(JCExpression tree, Type box) {
3110         make_at(tree.pos());
3111         Symbol valueOfSym = lookupMethod(tree.pos(),
3112                                          names.valueOf,
3113                                          box,
3114                                          List.&lt;Type&gt;nil()
3115                                          .prepend(tree.type));
3116         return make.App(make.QualIdent(valueOfSym), List.of(tree));
3117     }
3118 
3119     /** Unbox an object to a primitive value. */
3120     JCExpression unbox(JCExpression tree, Type primitive) {
3121         Type unboxedType = types.unboxedType(tree.type);
3122         if (unboxedType.hasTag(NONE)) {
3123             unboxedType = primitive;
3124             if (!unboxedType.isPrimitive())
3125                 throw new AssertionError(unboxedType);
3126             make_at(tree.pos());
3127             tree = make.TypeCast(types.boxedClass(unboxedType).type, tree);
3128         } else {
3129             // There must be a conversion from unboxedType to primitive.
3130             if (!types.isSubtype(unboxedType, primitive))
3131                 throw new AssertionError(tree);
3132         }
3133         make_at(tree.pos());
3134         Symbol valueSym = lookupMethod(tree.pos(),
3135                                        unboxedType.tsym.name.append(names.Value), // x.intValue()
3136                                        tree.type,
3137                                        List.nil());
3138         return make.App(make.Select(tree, valueSym));
3139     }
3140 
3141     /** Visitor method for parenthesized expressions.
3142      *  If the subexpression has changed, omit the parens.
3143      */
3144     public void visitParens(JCParens tree) {
3145         JCTree expr = translate(tree.expr);
3146         result = ((expr == tree.expr) ? tree : expr);
3147     }
3148 
3149     public void visitIndexed(JCArrayAccess tree) {
3150         tree.indexed = translate(tree.indexed);
3151         tree.index = translate(tree.index, syms.intType);
3152         result = tree;
3153     }
3154 
3155     public void visitAssign(JCAssign tree) {
3156         tree.lhs = translate(tree.lhs, tree);
3157         tree.rhs = translate(tree.rhs, tree.lhs.type);
3158 
3159         // If translated left hand side is an Apply, we are
3160         // seeing an access method invocation. In this case, append
3161         // right hand side as last argument of the access method.
3162         if (tree.lhs.hasTag(APPLY)) {
3163             JCMethodInvocation app = (JCMethodInvocation)tree.lhs;
3164             app.args = List.of(tree.rhs).prependList(app.args);
3165             result = app;
3166         } else {
3167             result = tree;
3168         }
3169     }
3170 
3171     public void visitAssignop(final JCAssignOp tree) {
3172         final boolean boxingReq = !tree.lhs.type.isPrimitive() &amp;&amp;
3173             tree.operator.type.getReturnType().isPrimitive();
3174 
3175         AssignopDependencyScanner depScanner = new AssignopDependencyScanner(tree);
3176         depScanner.scan(tree.rhs);
3177 
3178         if (boxingReq || depScanner.dependencyFound) {
3179             // boxing required; need to rewrite as x = (unbox typeof x)(x op y);
3180             // or if x == (typeof x)z then z = (unbox typeof x)((typeof x)z op y)
3181             // (but without recomputing x)
3182             JCTree newTree = abstractLval(tree.lhs, lhs -&gt; {
3183                 Tag newTag = tree.getTag().noAssignOp();
3184                 // Erasure (TransTypes) can change the type of
3185                 // tree.lhs.  However, we can still get the
3186                 // unerased type of tree.lhs as it is stored
3187                 // in tree.type in Attr.
3188                 OperatorSymbol newOperator = operators.resolveBinary(tree,
3189                                                               newTag,
3190                                                               tree.type,
3191                                                               tree.rhs.type);
3192                 //Need to use the &quot;lhs&quot; at two places, once on the future left hand side
3193                 //and once in the future binary operator. But further processing may change
3194                 //the components of the tree in place (see visitSelect for e.g. &lt;Class&gt;.super.&lt;ident&gt;),
3195                 //so cloning the tree to avoid interference between the uses:
3196                 JCExpression expr = (JCExpression) lhs.clone();
3197                 if (expr.type != tree.type)
3198                     expr = make.TypeCast(tree.type, expr);
3199                 JCBinary opResult = make.Binary(newTag, expr, tree.rhs);
3200                 opResult.operator = newOperator;
3201                 opResult.type = newOperator.type.getReturnType();
3202                 JCExpression newRhs = boxingReq ?
3203                     make.TypeCast(types.unboxedType(tree.type), opResult) :
3204                     opResult;
3205                 return make.Assign(lhs, newRhs).setType(tree.type);
3206             });
3207             result = translate(newTree);
3208             return;
3209         }
3210         tree.lhs = translate(tree.lhs, tree);
3211         tree.rhs = translate(tree.rhs, tree.operator.type.getParameterTypes().tail.head);
3212 
3213         // If translated left hand side is an Apply, we are
3214         // seeing an access method invocation. In this case, append
3215         // right hand side as last argument of the access method.
3216         if (tree.lhs.hasTag(APPLY)) {
3217             JCMethodInvocation app = (JCMethodInvocation)tree.lhs;
3218             // if operation is a += on strings,
3219             // make sure to convert argument to string
3220             JCExpression rhs = tree.operator.opcode == string_add
3221               ? makeString(tree.rhs)
3222               : tree.rhs;
3223             app.args = List.of(rhs).prependList(app.args);
3224             result = app;
3225         } else {
3226             result = tree;
3227         }
3228     }
3229 
3230     class AssignopDependencyScanner extends TreeScanner {
3231 
3232         Symbol sym;
3233         boolean dependencyFound = false;
3234 
3235         AssignopDependencyScanner(JCAssignOp tree) {
3236             this.sym = TreeInfo.symbol(tree.lhs);
3237         }
3238 
3239         @Override
3240         public void scan(JCTree tree) {
3241             if (tree != null &amp;&amp; sym != null) {
3242                 tree.accept(this);
3243             }
3244         }
3245 
3246         @Override
3247         public void visitAssignop(JCAssignOp tree) {
3248             if (TreeInfo.symbol(tree.lhs) == sym) {
3249                 dependencyFound = true;
3250                 return;
3251             }
3252             super.visitAssignop(tree);
3253         }
3254 
3255         @Override
3256         public void visitUnary(JCUnary tree) {
3257             if (TreeInfo.symbol(tree.arg) == sym) {
3258                 dependencyFound = true;
3259                 return;
3260             }
3261             super.visitUnary(tree);
3262         }
3263     }
3264 
3265     /** Lower a tree of the form e++ or e-- where e is an object type */
3266     JCExpression lowerBoxedPostop(final JCUnary tree) {
3267         // translate to tmp1=lval(e); tmp2=tmp1; tmp1 OP 1; tmp2
3268         // or
3269         // translate to tmp1=lval(e); tmp2=tmp1; (typeof tree)tmp1 OP 1; tmp2
3270         // where OP is += or -=
3271         final boolean cast = TreeInfo.skipParens(tree.arg).hasTag(TYPECAST);
3272         return abstractLval(tree.arg, tmp1 -&gt; abstractRval(tmp1, tree.arg.type, tmp2 -&gt; {
3273             Tag opcode = (tree.hasTag(POSTINC))
3274                 ? PLUS_ASG : MINUS_ASG;
3275             //&quot;tmp1&quot; and &quot;tmp2&quot; may refer to the same instance
3276             //(for e.g. &lt;Class&gt;.super.&lt;ident&gt;). But further processing may
3277             //change the components of the tree in place (see visitSelect),
3278             //so cloning the tree to avoid interference between the two uses:
3279             JCExpression lhs = (JCExpression)tmp1.clone();
3280             lhs = cast
3281                 ? make.TypeCast(tree.arg.type, lhs)
3282                 : lhs;
3283             JCExpression update = makeAssignop(opcode,
3284                                          lhs,
3285                                          make.Literal(1));
3286             return makeComma(update, tmp2);
3287         }));
3288     }
3289 
3290     public void visitUnary(JCUnary tree) {
3291         boolean isUpdateOperator = tree.getTag().isIncOrDecUnaryOp();
3292         if (isUpdateOperator &amp;&amp; !tree.arg.type.isPrimitive()) {
3293             switch(tree.getTag()) {
3294             case PREINC:            // ++ e
3295                     // translate to e += 1
3296             case PREDEC:            // -- e
3297                     // translate to e -= 1
3298                 {
3299                     JCTree.Tag opcode = (tree.hasTag(PREINC))
3300                         ? PLUS_ASG : MINUS_ASG;
3301                     JCAssignOp newTree = makeAssignop(opcode,
3302                                                     tree.arg,
3303                                                     make.Literal(1));
3304                     result = translate(newTree, tree.type);
3305                     return;
3306                 }
3307             case POSTINC:           // e ++
3308             case POSTDEC:           // e --
3309                 {
3310                     result = translate(lowerBoxedPostop(tree), tree.type);
3311                     return;
3312                 }
3313             }
3314             throw new AssertionError(tree);
3315         }
3316 
3317         tree.arg = boxIfNeeded(translate(tree.arg, tree), tree.type);
3318 
3319         if (tree.hasTag(NOT) &amp;&amp; tree.arg.type.constValue() != null) {
3320             tree.type = cfolder.fold1(bool_not, tree.arg.type);
3321         }
3322 
3323         // If translated left hand side is an Apply, we are
3324         // seeing an access method invocation. In this case, return
3325         // that access method invocation as result.
3326         if (isUpdateOperator &amp;&amp; tree.arg.hasTag(APPLY)) {
3327             result = tree.arg;
3328         } else {
3329             result = tree;
3330         }
3331     }
3332 
3333     public void visitBinary(JCBinary tree) {
3334         List&lt;Type&gt; formals = tree.operator.type.getParameterTypes();
3335         JCTree lhs = tree.lhs = translate(tree.lhs, formals.head);
3336         switch (tree.getTag()) {
3337         case OR:
3338             if (isTrue(lhs)) {
3339                 result = lhs;
3340                 return;
3341             }
3342             if (isFalse(lhs)) {
3343                 result = translate(tree.rhs, formals.tail.head);
3344                 return;
3345             }
3346             break;
3347         case AND:
3348             if (isFalse(lhs)) {
3349                 result = lhs;
3350                 return;
3351             }
3352             if (isTrue(lhs)) {
3353                 result = translate(tree.rhs, formals.tail.head);
3354                 return;
3355             }
3356             break;
3357         }
3358         tree.rhs = translate(tree.rhs, formals.tail.head);
3359         result = tree;
3360     }
3361 
3362     public void visitIdent(JCIdent tree) {
3363         result = access(tree.sym, tree, enclOp, false);
3364     }
3365 
3366     /** Translate away the foreach loop.  */
3367     public void visitForeachLoop(JCEnhancedForLoop tree) {
3368         if (types.elemtype(tree.expr.type) == null)
3369             visitIterableForeachLoop(tree);
3370         else
3371             visitArrayForeachLoop(tree);
3372     }
3373         // where
3374         /**
3375          * A statement of the form
3376          *
3377          * &lt;pre&gt;
3378          *     for ( T v : arrayexpr ) stmt;
3379          * &lt;/pre&gt;
3380          *
3381          * (where arrayexpr is of an array type) gets translated to
3382          *
3383          * &lt;pre&gt;{@code
3384          *     for ( { arraytype #arr = arrayexpr;
3385          *             int #len = array.length;
3386          *             int #i = 0; };
3387          *           #i &lt; #len; i$++ ) {
3388          *         T v = arr$[#i];
3389          *         stmt;
3390          *     }
3391          * }&lt;/pre&gt;
3392          *
3393          * where #arr, #len, and #i are freshly named synthetic local variables.
3394          */
3395         private void visitArrayForeachLoop(JCEnhancedForLoop tree) {
3396             make_at(tree.expr.pos());
3397             VarSymbol arraycache = new VarSymbol(SYNTHETIC,
3398                                                  names.fromString(&quot;arr&quot; + target.syntheticNameChar()),
3399                                                  tree.expr.type,
3400                                                  currentMethodSym);
3401             JCStatement arraycachedef = make.VarDef(arraycache, tree.expr);
3402             VarSymbol lencache = new VarSymbol(SYNTHETIC,
3403                                                names.fromString(&quot;len&quot; + target.syntheticNameChar()),
3404                                                syms.intType,
3405                                                currentMethodSym);
3406             JCStatement lencachedef = make.
3407                 VarDef(lencache, make.Select(make.Ident(arraycache), syms.lengthVar));
3408             VarSymbol index = new VarSymbol(SYNTHETIC,
3409                                             names.fromString(&quot;i&quot; + target.syntheticNameChar()),
3410                                             syms.intType,
3411                                             currentMethodSym);
3412 
3413             JCVariableDecl indexdef = make.VarDef(index, make.Literal(INT, 0));
3414             indexdef.init.type = indexdef.type = syms.intType.constType(0);
3415 
3416             List&lt;JCStatement&gt; loopinit = List.of(arraycachedef, lencachedef, indexdef);
3417             JCBinary cond = makeBinary(LT, make.Ident(index), make.Ident(lencache));
3418 
3419             JCExpressionStatement step = make.Exec(makeUnary(PREINC, make.Ident(index)));
3420 
3421             Type elemtype = types.elemtype(tree.expr.type);
3422             JCExpression loopvarinit = make.Indexed(make.Ident(arraycache),
3423                                                     make.Ident(index)).setType(elemtype);
3424             JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(tree.var.mods,
3425                                                   tree.var.name,
3426                                                   tree.var.vartype,
3427                                                   loopvarinit).setType(tree.var.type);
3428             loopvardef.sym = tree.var.sym;
3429             JCBlock body = make.
3430                 Block(0, List.of(loopvardef, tree.body));
3431 
3432             result = translate(make.
3433                                ForLoop(loopinit,
3434                                        cond,
3435                                        List.of(step),
3436                                        body));
3437             patchTargets(body, tree, result);
3438         }
3439         /** Patch up break and continue targets. */
3440         private void patchTargets(JCTree body, final JCTree src, final JCTree dest) {
3441             class Patcher extends TreeScanner {
3442                 public void visitBreak(JCBreak tree) {
3443                     if (tree.target == src)
3444                         tree.target = dest;
3445                 }
3446                 public void visitYield(JCYield tree) {
3447                     if (tree.target == src)
3448                         tree.target = dest;
3449                     scan(tree.value);
3450                 }
3451                 public void visitContinue(JCContinue tree) {
3452                     if (tree.target == src)
3453                         tree.target = dest;
3454                 }
3455                 public void visitClassDef(JCClassDecl tree) {}
3456             }
3457             new Patcher().scan(body);
3458         }
3459         /**
3460          * A statement of the form
3461          *
3462          * &lt;pre&gt;
3463          *     for ( T v : coll ) stmt ;
3464          * &lt;/pre&gt;
3465          *
3466          * (where coll implements {@code Iterable&lt;? extends T&gt;}) gets translated to
3467          *
3468          * &lt;pre&gt;{@code
3469          *     for ( Iterator&lt;? extends T&gt; #i = coll.iterator(); #i.hasNext(); ) {
3470          *         T v = (T) #i.next();
3471          *         stmt;
3472          *     }
3473          * }&lt;/pre&gt;
3474          *
3475          * where #i is a freshly named synthetic local variable.
3476          */
3477         private void visitIterableForeachLoop(JCEnhancedForLoop tree) {
3478             make_at(tree.expr.pos());
3479             Type iteratorTarget = syms.objectType;
3480             Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type),
3481                                               syms.iterableType.tsym);
3482             if (iterableType.getTypeArguments().nonEmpty())
3483                 iteratorTarget = types.erasure(iterableType.getTypeArguments().head);
3484             Type eType = types.skipTypeVars(tree.expr.type, false);
3485             tree.expr.type = types.erasure(eType);
3486             if (eType.isCompound())
3487                 tree.expr = make.TypeCast(types.erasure(iterableType), tree.expr);
3488             Symbol iterator = lookupMethod(tree.expr.pos(),
3489                                            names.iterator,
3490                                            eType,
3491                                            List.nil());
3492             VarSymbol itvar = new VarSymbol(SYNTHETIC, names.fromString(&quot;i&quot; + target.syntheticNameChar()),
3493                                             types.erasure(types.asSuper(iterator.type.getReturnType(), syms.iteratorType.tsym)),
3494                                             currentMethodSym);
3495 
3496              JCStatement init = make.
3497                 VarDef(itvar, make.App(make.Select(tree.expr, iterator)
3498                      .setType(types.erasure(iterator.type))));
3499 
3500             Symbol hasNext = lookupMethod(tree.expr.pos(),
3501                                           names.hasNext,
3502                                           itvar.type,
3503                                           List.nil());
3504             JCMethodInvocation cond = make.App(make.Select(make.Ident(itvar), hasNext));
3505             Symbol next = lookupMethod(tree.expr.pos(),
3506                                        names.next,
3507                                        itvar.type,
3508                                        List.nil());
3509             JCExpression vardefinit = make.App(make.Select(make.Ident(itvar), next));
3510             if (tree.var.type.isPrimitive())
3511                 vardefinit = make.TypeCast(types.cvarUpperBound(iteratorTarget), vardefinit);
3512             else
3513                 vardefinit = make.TypeCast(tree.var.type, vardefinit);
3514             JCVariableDecl indexDef = (JCVariableDecl)make.VarDef(tree.var.mods,
3515                                                   tree.var.name,
3516                                                   tree.var.vartype,
3517                                                   vardefinit).setType(tree.var.type);
3518             indexDef.sym = tree.var.sym;
3519             JCBlock body = make.Block(0, List.of(indexDef, tree.body));
3520             body.endpos = TreeInfo.endPos(tree.body);
3521             result = translate(make.
3522                 ForLoop(List.of(init),
3523                         cond,
3524                         List.nil(),
3525                         body));
3526             patchTargets(body, tree, result);
3527         }
3528 
3529     public void visitVarDef(JCVariableDecl tree) {
3530         MethodSymbol oldMethodSym = currentMethodSym;
3531         tree.mods = translate(tree.mods);
3532         tree.vartype = translate(tree.vartype);
3533         if (currentMethodSym == null) {
3534             // A class or instance field initializer.
3535             currentMethodSym =
3536                 new MethodSymbol((tree.mods.flags&amp;STATIC) | BLOCK,
3537                                  names.empty, null,
3538                                  currentClass);
3539         }
3540         if (tree.init != null) tree.init = translate(tree.init, tree.type);
3541         result = tree;
3542         currentMethodSym = oldMethodSym;
3543     }
3544 
3545     public void visitBlock(JCBlock tree) {
3546         MethodSymbol oldMethodSym = currentMethodSym;
3547         if (currentMethodSym == null) {
3548             // Block is a static or instance initializer.
3549             currentMethodSym =
3550                 new MethodSymbol(tree.flags | BLOCK,
3551                                  names.empty, null,
3552                                  currentClass);
3553         }
3554         super.visitBlock(tree);
3555         currentMethodSym = oldMethodSym;
3556     }
3557 
3558     public void visitDoLoop(JCDoWhileLoop tree) {
3559         tree.body = translate(tree.body);
3560         tree.cond = translate(tree.cond, syms.booleanType);
3561         result = tree;
3562     }
3563 
3564     public void visitWhileLoop(JCWhileLoop tree) {
3565         tree.cond = translate(tree.cond, syms.booleanType);
3566         tree.body = translate(tree.body);
3567         result = tree;
3568     }
3569 
3570     public void visitForLoop(JCForLoop tree) {
3571         tree.init = translate(tree.init);
3572         if (tree.cond != null)
3573             tree.cond = translate(tree.cond, syms.booleanType);
3574         tree.step = translate(tree.step);
3575         tree.body = translate(tree.body);
3576         result = tree;
3577     }
3578 
3579     public void visitReturn(JCReturn tree) {
3580         if (tree.expr != null)
3581             tree.expr = translate(tree.expr,
3582                                   types.erasure(currentMethodDef
3583                                                 .restype.type));
3584         result = tree;
3585     }
3586 
3587     public void visitSwitch(JCSwitch tree) {
3588         handleSwitch(tree, tree.selector, tree.cases);
3589     }
3590 
3591     @Override
3592     public void visitSwitchExpression(JCSwitchExpression tree) {
3593         if (tree.cases.stream().noneMatch(c -&gt; c.pats.isEmpty())) {
3594             JCThrow thr = make.Throw(makeNewClass(syms.incompatibleClassChangeErrorType,
3595                                                   List.nil()));
3596             JCCase c = make.Case(JCCase.STATEMENT, List.nil(), List.of(thr), null);
3597             tree.cases = tree.cases.append(c);
3598         }
3599         handleSwitch(tree, tree.selector, tree.cases);
3600     }
3601 
3602     private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
3603         //expand multiple label cases:
3604         ListBuffer&lt;JCCase&gt; convertedCases = new ListBuffer&lt;&gt;();
3605 
3606         for (JCCase c : cases) {
3607             switch (c.pats.size()) {
3608                 case 0: //default
3609                 case 1: //single label
3610                     convertedCases.append(c);
3611                     break;
3612                 default: //multiple labels, expand:
3613                     //case C1, C2, C3: ...
3614                     //=&gt;
3615                     //case C1:
3616                     //case C2:
3617                     //case C3: ...
3618                     List&lt;JCExpression&gt; patterns = c.pats;
3619                     while (patterns.tail.nonEmpty()) {
3620                         convertedCases.append(make_at(c.pos()).Case(JCCase.STATEMENT,
3621                                                            List.of(patterns.head),
3622                                                            List.nil(),
3623                                                            null));
3624                         patterns = patterns.tail;
3625                     }
3626                     c.pats = patterns;
3627                     convertedCases.append(c);
3628                     break;
3629             }
3630         }
3631 
3632         for (JCCase c : convertedCases) {
3633             if (c.caseKind == JCCase.RULE &amp;&amp; c.completesNormally) {
3634                 JCBreak b = make_at(c.pos()).Break(null);
3635                 b.target = tree;
3636                 c.stats = c.stats.append(b);
3637             }
3638         }
3639 
3640         cases = convertedCases.toList();
3641 
3642         Type selsuper = types.supertype(selector.type);
3643         boolean enumSwitch = selsuper != null &amp;&amp;
3644             (selector.type.tsym.flags() &amp; ENUM) != 0;
3645         boolean stringSwitch = selsuper != null &amp;&amp;
3646             types.isSameType(selector.type, syms.stringType);
3647         Type target = enumSwitch ? selector.type :
3648             (stringSwitch? syms.stringType : syms.intType);
3649         selector = translate(selector, target);
3650         cases = translateCases(cases);
3651         if (tree.hasTag(SWITCH)) {
3652             ((JCSwitch) tree).selector = selector;
3653             ((JCSwitch) tree).cases = cases;
3654         } else if (tree.hasTag(SWITCH_EXPRESSION)) {
3655             ((JCSwitchExpression) tree).selector = selector;
3656             ((JCSwitchExpression) tree).cases = cases;
3657         } else {
3658             Assert.error();
3659         }
3660         if (enumSwitch) {
3661             result = visitEnumSwitch(tree, selector, cases);
3662         } else if (stringSwitch) {
3663             result = visitStringSwitch(tree, selector, cases);
3664         } else {
3665             result = tree;
3666         }
3667     }
3668 
3669     public JCTree visitEnumSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
3670         TypeSymbol enumSym = selector.type.tsym;
3671         EnumMapping map = mapForEnum(tree.pos(), enumSym);
3672         make_at(tree.pos());
3673         Symbol ordinalMethod = lookupMethod(tree.pos(),
3674                                             names.ordinal,
3675                                             selector.type,
3676                                             List.nil());
3677         JCArrayAccess newSelector = make.Indexed(map.mapVar,
3678                                         make.App(make.Select(selector,
3679                                                              ordinalMethod)));
3680         ListBuffer&lt;JCCase&gt; newCases = new ListBuffer&lt;&gt;();
3681         for (JCCase c : cases) {
3682             if (c.pats.nonEmpty()) {
3683                 VarSymbol label = (VarSymbol)TreeInfo.symbol(c.pats.head);
3684                 JCLiteral pat = map.forConstant(label);
3685                 newCases.append(make.Case(JCCase.STATEMENT, List.of(pat), c.stats, null));
3686             } else {
3687                 newCases.append(c);
3688             }
3689         }
3690         JCTree enumSwitch;
3691         if (tree.hasTag(SWITCH)) {
3692             enumSwitch = make.Switch(newSelector, newCases.toList());
3693         } else if (tree.hasTag(SWITCH_EXPRESSION)) {
3694             enumSwitch = make.SwitchExpression(newSelector, newCases.toList());
3695             enumSwitch.setType(tree.type);
3696         } else {
3697             Assert.error();
3698             throw new AssertionError();
3699         }
3700         patchTargets(enumSwitch, tree, enumSwitch);
3701         return enumSwitch;
3702     }
3703 
3704     public JCTree visitStringSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; caseList) {
3705         int alternatives = caseList.size();
3706 
3707         if (alternatives == 0) { // Strange but legal possibility (only legal for switch statement)
3708             return make.at(tree.pos()).Exec(attr.makeNullCheck(selector));
3709         } else {
3710             /*
3711              * The general approach used is to translate a single
3712              * string switch statement into a series of two chained
3713              * switch statements: the first a synthesized statement
3714              * switching on the argument string&#39;s hash value and
3715              * computing a string&#39;s position in the list of original
3716              * case labels, if any, followed by a second switch on the
3717              * computed integer value.  The second switch has the same
3718              * code structure as the original string switch statement
3719              * except that the string case labels are replaced with
3720              * positional integer constants starting at 0.
3721              *
3722              * The first switch statement can be thought of as an
3723              * inlined map from strings to their position in the case
3724              * label list.  An alternate implementation would use an
3725              * actual Map for this purpose, as done for enum switches.
3726              *
3727              * With some additional effort, it would be possible to
3728              * use a single switch statement on the hash code of the
3729              * argument, but care would need to be taken to preserve
3730              * the proper control flow in the presence of hash
3731              * collisions and other complications, such as
3732              * fallthroughs.  Switch statements with one or two
3733              * alternatives could also be specially translated into
3734              * if-then statements to omit the computation of the hash
3735              * code.
3736              *
3737              * The generated code assumes that the hashing algorithm
3738              * of String is the same in the compilation environment as
3739              * in the environment the code will run in.  The string
3740              * hashing algorithm in the SE JDK has been unchanged
3741              * since at least JDK 1.2.  Since the algorithm has been
3742              * specified since that release as well, it is very
3743              * unlikely to be changed in the future.
3744              *
3745              * Different hashing algorithms, such as the length of the
3746              * strings or a perfect hashing algorithm over the
3747              * particular set of case labels, could potentially be
3748              * used instead of String.hashCode.
3749              */
3750 
3751             ListBuffer&lt;JCStatement&gt; stmtList = new ListBuffer&lt;&gt;();
3752 
3753             // Map from String case labels to their original position in
3754             // the list of case labels.
3755             Map&lt;String, Integer&gt; caseLabelToPosition = new LinkedHashMap&lt;&gt;(alternatives + 1, 1.0f);
3756 
3757             // Map of hash codes to the string case labels having that hashCode.
3758             Map&lt;Integer, Set&lt;String&gt;&gt; hashToString = new LinkedHashMap&lt;&gt;(alternatives + 1, 1.0f);
3759 
3760             int casePosition = 0;
3761 
3762             for(JCCase oneCase : caseList) {
3763                 if (oneCase.pats.nonEmpty()) { // pats is empty for a &quot;default&quot; case
3764                     JCExpression expression = oneCase.pats.head;
3765                     String labelExpr = (String) expression.type.constValue();
3766                     Integer mapping = caseLabelToPosition.put(labelExpr, casePosition);
3767                     Assert.checkNull(mapping);
3768                     int hashCode = labelExpr.hashCode();
3769 
3770                     Set&lt;String&gt; stringSet = hashToString.get(hashCode);
3771                     if (stringSet == null) {
3772                         stringSet = new LinkedHashSet&lt;&gt;(1, 1.0f);
3773                         stringSet.add(labelExpr);
3774                         hashToString.put(hashCode, stringSet);
3775                     } else {
3776                         boolean added = stringSet.add(labelExpr);
3777                         Assert.check(added);
3778                     }
3779                 }
3780                 casePosition++;
3781             }
3782 
3783             // Synthesize a switch statement that has the effect of
3784             // mapping from a string to the integer position of that
3785             // string in the list of case labels.  This is done by
3786             // switching on the hashCode of the string followed by an
3787             // if-then-else chain comparing the input for equality
3788             // with all the case labels having that hash value.
3789 
3790             /*
3791              * s$ = top of stack;
3792              * tmp$ = -1;
3793              * switch($s.hashCode()) {
3794              *     case caseLabel.hashCode:
3795              *         if (s$.equals(&quot;caseLabel_1&quot;)
3796              *           tmp$ = caseLabelToPosition(&quot;caseLabel_1&quot;);
3797              *         else if (s$.equals(&quot;caseLabel_2&quot;))
3798              *           tmp$ = caseLabelToPosition(&quot;caseLabel_2&quot;);
3799              *         ...
3800              *         break;
3801              * ...
3802              * }
3803              */
3804 
3805             VarSymbol dollar_s = new VarSymbol(FINAL|SYNTHETIC,
3806                                                names.fromString(&quot;s&quot; + tree.pos + target.syntheticNameChar()),
3807                                                syms.stringType,
3808                                                currentMethodSym);
3809             stmtList.append(make.at(tree.pos()).VarDef(dollar_s, selector).setType(dollar_s.type));
3810 
3811             VarSymbol dollar_tmp = new VarSymbol(SYNTHETIC,
3812                                                  names.fromString(&quot;tmp&quot; + tree.pos + target.syntheticNameChar()),
3813                                                  syms.intType,
3814                                                  currentMethodSym);
3815             JCVariableDecl dollar_tmp_def =
3816                 (JCVariableDecl)make.VarDef(dollar_tmp, make.Literal(INT, -1)).setType(dollar_tmp.type);
3817             dollar_tmp_def.init.type = dollar_tmp.type = syms.intType;
3818             stmtList.append(dollar_tmp_def);
3819             ListBuffer&lt;JCCase&gt; caseBuffer = new ListBuffer&lt;&gt;();
3820             // hashCode will trigger nullcheck on original switch expression
3821             JCMethodInvocation hashCodeCall = makeCall(make.Ident(dollar_s),
3822                                                        names.hashCode,
3823                                                        List.nil()).setType(syms.intType);
3824             JCSwitch switch1 = make.Switch(hashCodeCall,
3825                                         caseBuffer.toList());
3826             for(Map.Entry&lt;Integer, Set&lt;String&gt;&gt; entry : hashToString.entrySet()) {
3827                 int hashCode = entry.getKey();
3828                 Set&lt;String&gt; stringsWithHashCode = entry.getValue();
3829                 Assert.check(stringsWithHashCode.size() &gt;= 1);
3830 
3831                 JCStatement elsepart = null;
3832                 for(String caseLabel : stringsWithHashCode ) {
3833                     JCMethodInvocation stringEqualsCall = makeCall(make.Ident(dollar_s),
3834                                                                    names.equals,
3835                                                                    List.of(make.Literal(caseLabel)));
3836                     elsepart = make.If(stringEqualsCall,
3837                                        make.Exec(make.Assign(make.Ident(dollar_tmp),
3838                                                              make.Literal(caseLabelToPosition.get(caseLabel))).
3839                                                  setType(dollar_tmp.type)),
3840                                        elsepart);
3841                 }
3842 
3843                 ListBuffer&lt;JCStatement&gt; lb = new ListBuffer&lt;&gt;();
3844                 JCBreak breakStmt = make.Break(null);
3845                 breakStmt.target = switch1;
3846                 lb.append(elsepart).append(breakStmt);
3847 
3848                 caseBuffer.append(make.Case(JCCase.STATEMENT, List.of(make.Literal(hashCode)), lb.toList(), null));
3849             }
3850 
3851             switch1.cases = caseBuffer.toList();
3852             stmtList.append(switch1);
3853 
3854             // Make isomorphic switch tree replacing string labels
3855             // with corresponding integer ones from the label to
3856             // position map.
3857 
3858             ListBuffer&lt;JCCase&gt; lb = new ListBuffer&lt;&gt;();
3859             for(JCCase oneCase : caseList ) {
3860                 boolean isDefault = (oneCase.pats.isEmpty());
3861                 JCExpression caseExpr;
3862                 if (isDefault)
3863                     caseExpr = null;
3864                 else {
3865                     caseExpr = make.Literal(caseLabelToPosition.get((String)TreeInfo.skipParens(oneCase.pats.head).
3866                                                                     type.constValue()));
3867                 }
3868 
3869                 lb.append(make.Case(JCCase.STATEMENT, caseExpr == null ? List.nil() : List.of(caseExpr),
3870                                     oneCase.stats, null));
3871             }
3872 
3873             if (tree.hasTag(SWITCH)) {
3874                 JCSwitch switch2 = make.Switch(make.Ident(dollar_tmp), lb.toList());
3875                 // Rewire up old unlabeled break statements to the
3876                 // replacement switch being created.
3877                 patchTargets(switch2, tree, switch2);
3878 
3879                 stmtList.append(switch2);
3880 
3881                 return make.Block(0L, stmtList.toList());
3882             } else {
3883                 JCSwitchExpression switch2 = make.SwitchExpression(make.Ident(dollar_tmp), lb.toList());
3884 
3885                 // Rewire up old unlabeled break statements to the
3886                 // replacement switch being created.
3887                 patchTargets(switch2, tree, switch2);
3888 
3889                 switch2.setType(tree.type);
3890 
3891                 LetExpr res = make.LetExpr(stmtList.toList(), switch2);
3892 
3893                 res.needsCond = true;
3894                 res.setType(tree.type);
3895 
3896                 return res;
3897             }
3898         }
3899     }
3900 
3901     @Override
3902     public void visitBreak(JCBreak tree) {
3903         result = tree;
3904     }
3905 
3906     @Override
3907     public void visitYield(JCYield tree) {
3908         tree.value = translate(tree.value, tree.target.type);
3909         result = tree;
3910     }
3911 
3912     public void visitNewArray(JCNewArray tree) {
3913         tree.elemtype = translate(tree.elemtype);
3914         for (List&lt;JCExpression&gt; t = tree.dims; t.tail != null; t = t.tail)
3915             if (t.head != null) t.head = translate(t.head, syms.intType);
3916         tree.elems = translate(tree.elems, types.elemtype(tree.type));
3917         result = tree;
3918     }
3919 
3920     public void visitSelect(JCFieldAccess tree) {
3921         // need to special case-access of the form C.super.x
3922         // these will always need an access method, unless C
3923         // is a default interface subclassed by the current class.
3924         boolean qualifiedSuperAccess =
3925             tree.selected.hasTag(SELECT) &amp;&amp;
3926             TreeInfo.name(tree.selected) == names._super &amp;&amp;
3927             !types.isDirectSuperInterface(((JCFieldAccess)tree.selected).selected.type.tsym, currentClass);
3928         tree.selected = translate(tree.selected);
3929         if (tree.name == names._class) {
3930             result = classOf(tree.selected);
3931         }
3932         else if (tree.name == names._super &amp;&amp;
3933                 types.isDirectSuperInterface(tree.selected.type.tsym, currentClass)) {
3934             //default super call!! Not a classic qualified super call
3935             TypeSymbol supSym = tree.selected.type.tsym;
3936             Assert.checkNonNull(types.asSuper(currentClass.type, supSym));
3937             result = tree;
3938         }
3939         else if (tree.name == names._this || tree.name == names._super) {
3940             result = makeThis(tree.pos(), tree.selected.type.tsym);
3941         }
3942         else
3943             result = access(tree.sym, tree, enclOp, qualifiedSuperAccess);
3944     }
3945 
3946     public void visitLetExpr(LetExpr tree) {
3947         tree.defs = translate(tree.defs);
3948         tree.expr = translate(tree.expr, tree.type);
3949         result = tree;
3950     }
3951 
3952     // There ought to be nothing to rewrite here;
3953     // we don&#39;t generate code.
3954     public void visitAnnotation(JCAnnotation tree) {
3955         result = tree;
3956     }
3957 
3958     @Override
3959     public void visitTry(JCTry tree) {
3960         if (tree.resources.nonEmpty()) {
3961             result = makeTwrTry(tree);
3962             return;
3963         }
3964 
3965         boolean hasBody = tree.body.getStatements().nonEmpty();
3966         boolean hasCatchers = tree.catchers.nonEmpty();
3967         boolean hasFinally = tree.finalizer != null &amp;&amp;
3968                 tree.finalizer.getStatements().nonEmpty();
3969 
3970         if (!hasCatchers &amp;&amp; !hasFinally) {
3971             result = translate(tree.body);
3972             return;
3973         }
3974 
3975         if (!hasBody) {
3976             if (hasFinally) {
3977                 result = translate(tree.finalizer);
3978             } else {
3979                 result = translate(tree.body);
3980             }
3981             return;
3982         }
3983 
3984         // no optimizations possible
3985         super.visitTry(tree);
3986     }
3987 
3988 /**************************************************************************
3989  * main method
3990  *************************************************************************/
3991 
3992     /** Translate a toplevel class and return a list consisting of
3993      *  the translated class and translated versions of all inner classes.
3994      *  @param env   The attribution environment current at the class definition.
3995      *               We need this for resolving some additional symbols.
3996      *  @param cdef  The tree representing the class definition.
3997      */
3998     public List&lt;JCTree&gt; translateTopLevelClass(Env&lt;AttrContext&gt; env, JCTree cdef, TreeMaker make) {
3999         ListBuffer&lt;JCTree&gt; translated = null;
4000         try {
4001             attrEnv = env;
4002             this.make = make;
4003             endPosTable = env.toplevel.endPositions;
4004             currentClass = null;
4005             currentMethodDef = null;
4006             outermostClassDef = (cdef.hasTag(CLASSDEF)) ? (JCClassDecl)cdef : null;
4007             outermostMemberDef = null;
4008             this.translated = new ListBuffer&lt;&gt;();
4009             classdefs = new HashMap&lt;&gt;();
4010             actualSymbols = new HashMap&lt;&gt;();
4011             freevarCache = new HashMap&lt;&gt;();
4012             proxies = new HashMap&lt;&gt;();
4013             twrVars = WriteableScope.create(syms.noSymbol);
4014             outerThisStack = List.nil();
4015             accessNums = new HashMap&lt;&gt;();
4016             accessSyms = new HashMap&lt;&gt;();
4017             accessConstrs = new HashMap&lt;&gt;();
4018             accessConstrTags = List.nil();
4019             accessed = new ListBuffer&lt;&gt;();
4020             translate(cdef, (JCExpression)null);
4021             for (List&lt;Symbol&gt; l = accessed.toList(); l.nonEmpty(); l = l.tail)
4022                 makeAccessible(l.head);
4023             for (EnumMapping map : enumSwitchMap.values())
4024                 map.translate();
4025             checkConflicts(this.translated.toList());
4026             checkAccessConstructorTags();
4027             translated = this.translated;
4028         } finally {
4029             // note that recursive invocations of this method fail hard
4030             attrEnv = null;
4031             this.make = null;
4032             endPosTable = null;
4033             currentClass = null;
4034             currentMethodDef = null;
4035             outermostClassDef = null;
4036             outermostMemberDef = null;
4037             this.translated = null;
4038             classdefs = null;
4039             actualSymbols = null;
4040             freevarCache = null;
4041             proxies = null;
4042             outerThisStack = null;
4043             accessNums = null;
4044             accessSyms = null;
4045             accessConstrs = null;
4046             accessConstrTags = null;
4047             accessed = null;
4048             enumSwitchMap.clear();
4049             assertionsDisabledClassCache = null;
4050         }
4051         return translated.toList();
4052     }
4053 }
    </pre>
  </body>
</html>
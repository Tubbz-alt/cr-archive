<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/windows/classes/sun/print/PrintServiceLookupProvider.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.print;
 27 
<a name="2" id="anc2"></a>
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 import java.util.Comparator;
<a name="3" id="anc3"></a><span class="line-added"> 31 </span>
 32 import javax.print.DocFlavor;
 33 import javax.print.MultiDocPrintService;
 34 import javax.print.PrintService;
 35 import javax.print.PrintServiceLookup;
 36 import javax.print.attribute.Attribute;
 37 import javax.print.attribute.AttributeSet;
 38 import javax.print.attribute.HashPrintRequestAttributeSet;
 39 import javax.print.attribute.HashPrintServiceAttributeSet;
 40 import javax.print.attribute.PrintRequestAttribute;
 41 import javax.print.attribute.PrintRequestAttributeSet;
 42 import javax.print.attribute.PrintServiceAttribute;
 43 import javax.print.attribute.PrintServiceAttributeSet;
 44 import javax.print.attribute.standard.PrinterName;
 45 
 46 public class PrintServiceLookupProvider extends PrintServiceLookup {
 47 
 48     private String defaultPrinter;
 49     private PrintService defaultPrintService;
 50     private String[] printers; /* excludes the default printer */
 51     private PrintService[] printServices; /* includes the default printer */
 52 
 53     private static final int DEFAULT_REFRESH_TIME = 240;  // 4 minutes
 54     private static final int MINIMUM_REFRESH_TIME = 120;  // 2 minutes
 55     private static final boolean pollServices;
 56     private static final int refreshTime;
 57 
 58     static {
 59         /* The system property &quot;sun.java2d.print.polling&quot;
 60          * can be used to force the printing code to poll or not poll
 61          * for PrintServices.
 62          */
 63         String pollStr = java.security.AccessController.doPrivileged(
 64             new sun.security.action.GetPropertyAction(&quot;sun.java2d.print.polling&quot;));
 65         pollServices = !(&quot;false&quot;.equalsIgnoreCase(pollStr));
 66 
 67         /* The system property &quot;sun.java2d.print.minRefreshTime&quot;
 68          * can be used to specify minimum refresh time (in seconds)
 69          * for polling PrintServices.  The default is 240.
 70          */
 71         String refreshTimeStr = java.security.AccessController.doPrivileged(
 72             new sun.security.action.GetPropertyAction(
 73                 &quot;sun.java2d.print.minRefreshTime&quot;));
 74         refreshTime = (refreshTimeStr != null)
 75                       ? getRefreshTime(refreshTimeStr)
 76                       : DEFAULT_REFRESH_TIME;
 77 
 78         java.security.AccessController.doPrivileged(
 79             new java.security.PrivilegedAction&lt;Void&gt;() {
 80                 public Void run() {
 81                     System.loadLibrary(&quot;awt&quot;);
 82                     return null;
 83                 }
 84             });
 85     }
 86 
 87     private static int getRefreshTime(final String refreshTimeStr) {
 88         try {
 89             int minRefreshTime = Integer.parseInt(refreshTimeStr);
 90             return (minRefreshTime &lt; MINIMUM_REFRESH_TIME)
 91                    ? MINIMUM_REFRESH_TIME
 92                    : minRefreshTime;
 93         } catch (NumberFormatException e) {
 94             return DEFAULT_REFRESH_TIME;
 95         }
 96     }
 97 
 98     /* The singleton win32 print lookup service.
 99      * Code that is aware of this field and wants to use it must first
100      * see if its null, and if so instantiate it by calling a method such as
101      * javax.print.PrintServiceLookup.defaultPrintService() so that the
102      * same instance is stored there.
103      */
104     private static PrintServiceLookupProvider win32PrintLUS;
105 
106     /* Think carefully before calling this. Preferably don&#39;t call it. */
107     public static PrintServiceLookupProvider getWin32PrintLUS() {
108         if (win32PrintLUS == null) {
109             /* This call is internally synchronized.
110              * When it returns an instance of this class will have
111              * been instantiated - else there&#39;s a JDK internal error.
112              */
113             PrintServiceLookup.lookupDefaultPrintService();
114         }
115         return win32PrintLUS;
116     }
117 
118     public PrintServiceLookupProvider() {
119 
120         if (win32PrintLUS == null) {
121             win32PrintLUS = this;
122 
<a name="4" id="anc4"></a>






123             // start the local printer listener thread
124             Thread thr = new Thread(null, new PrinterChangeListener(),
125                                     &quot;PrinterListener&quot;, 0, false);
126             thr.setDaemon(true);
127             thr.start();
128 
129             if (pollServices) {
130                 // start the remote printer listener thread
131                 Thread remThr = new Thread(null, new RemotePrinterChangeListener(),
132                                            &quot;RemotePrinterListener&quot;, 0, false);
133                 remThr.setDaemon(true);
134                 remThr.start();
135             }
136         } /* else condition ought to never happen! */
137     }
138 
139     /* Want the PrintService which is default print service to have
140      * equality of reference with the equivalent in list of print services
141      * This isn&#39;t required by the API and there&#39;s a risk doing this will
142      * lead people to assume its guaranteed.
143      */
144     public synchronized PrintService[] getPrintServices() {
145         SecurityManager security = System.getSecurityManager();
146         if (security != null) {
147             security.checkPrintJobAccess();
148         }
149         if (printServices == null) {
150             refreshServices();
151         }
152         return printServices;
153     }
154 
155     private synchronized void refreshServices() {
156         printers = getAllPrinterNames();
157         if (printers == null) {
158             // In Windows it is safe to assume no default if printers == null so we
159             // don&#39;t get the default.
160             printServices = new PrintService[0];
161             return;
162         }
163 
164         PrintService[] newServices = new PrintService[printers.length];
165         PrintService defService = getDefaultPrintService();
166         for (int p = 0; p &lt; printers.length; p++) {
167             if (defService != null &amp;&amp;
168                 printers[p].equals(defService.getName())) {
169                 newServices[p] = defService;
170             } else {
171                 if (printServices == null) {
172                     newServices[p] = new Win32PrintService(printers[p]);
173                 } else {
174                     int j;
175                     for (j = 0; j &lt; printServices.length; j++) {
176                         if ((printServices[j]!= null) &amp;&amp;
177                             (printers[p].equals(printServices[j].getName()))) {
178                             newServices[p] = printServices[j];
179                             printServices[j] = null;
180                             break;
181                         }
182                     }
183                     if (j == printServices.length) {
184                         newServices[p] = new Win32PrintService(printers[p]);
185                     }
186                 }
187             }
188         }
189 
190         // Look for deleted services and invalidate these
191         if (printServices != null) {
192             for (int j=0; j &lt; printServices.length; j++) {
193                 if ((printServices[j] instanceof Win32PrintService) &amp;&amp;
194                     (!printServices[j].equals(defaultPrintService))) {
195                     ((Win32PrintService)printServices[j]).invalidateService();
196                 }
197             }
198         }
199         printServices = newServices;
200     }
201 
202 
203     public synchronized PrintService getPrintServiceByName(String name) {
204 
205         if (name == null || name.isEmpty()) {
206             return null;
207         } else {
208             /* getPrintServices() is now very fast. */
209             PrintService[] printServices = getPrintServices();
210             for (int i=0; i&lt;printServices.length; i++) {
211                 if (printServices[i].getName().equals(name)) {
212                     return printServices[i];
213                 }
214             }
215             return null;
216         }
217     }
218 
219     @SuppressWarnings(&quot;unchecked&quot;) // Cast to Class&lt;PrintServiceAttribute&gt;
220     boolean matchingService(PrintService service,
221                             PrintServiceAttributeSet serviceSet) {
222         if (serviceSet != null) {
223             Attribute [] attrs =  serviceSet.toArray();
224             Attribute serviceAttr;
225             for (int i=0; i&lt;attrs.length; i++) {
226                 serviceAttr
227                     = service.getAttribute((Class&lt;PrintServiceAttribute&gt;)attrs[i].getCategory());
228                 if (serviceAttr == null || !serviceAttr.equals(attrs[i])) {
229                     return false;
230                 }
231             }
232         }
233         return true;
234     }
235 
236     public PrintService[] getPrintServices(DocFlavor flavor,
237                                            AttributeSet attributes) {
238 
239         SecurityManager security = System.getSecurityManager();
240         if (security != null) {
241           security.checkPrintJobAccess();
242         }
243         PrintRequestAttributeSet requestSet = null;
244         PrintServiceAttributeSet serviceSet = null;
245 
246         if (attributes != null &amp;&amp; !attributes.isEmpty()) {
247 
248             requestSet = new HashPrintRequestAttributeSet();
249             serviceSet = new HashPrintServiceAttributeSet();
250 
251             Attribute[] attrs = attributes.toArray();
252             for (int i=0; i&lt;attrs.length; i++) {
253                 if (attrs[i] instanceof PrintRequestAttribute) {
254                     requestSet.add(attrs[i]);
255                 } else if (attrs[i] instanceof PrintServiceAttribute) {
256                     serviceSet.add(attrs[i]);
257                 }
258             }
259         }
260 
261         /*
262          * Special case: If client is asking for a particular printer
263          * (by name) then we can save time by getting just that service
264          * to check against the rest of the specified attributes.
265          */
266         PrintService[] services = null;
267         if (serviceSet != null &amp;&amp; serviceSet.get(PrinterName.class) != null) {
268             PrinterName name = (PrinterName)serviceSet.get(PrinterName.class);
269             PrintService service = getPrintServiceByName(name.getValue());
270             if (service == null || !matchingService(service, serviceSet)) {
271                 services = new PrintService[0];
272             } else {
273                 services = new PrintService[1];
274                 services[0] = service;
275             }
276         } else {
277             services = getPrintServices();
278         }
279 
280         if (services.length == 0) {
281             return services;
282         } else {
283             ArrayList&lt;PrintService&gt; matchingServices = new ArrayList&lt;&gt;();
284             for (int i=0; i&lt;services.length; i++) {
285                 try {
286                     if (services[i].
287                         getUnsupportedAttributes(flavor, requestSet) == null) {
288                         matchingServices.add(services[i]);
289                     }
290                 } catch (IllegalArgumentException e) {
291                 }
292             }
293             services = new PrintService[matchingServices.size()];
294             return matchingServices.toArray(services);
295         }
296     }
297 
298     /*
299      * return empty array as don&#39;t support multi docs
300      */
301     public MultiDocPrintService[]
302         getMultiDocPrintServices(DocFlavor[] flavors,
303                                  AttributeSet attributes) {
304         SecurityManager security = System.getSecurityManager();
305         if (security != null) {
306           security.checkPrintJobAccess();
307         }
308         return new MultiDocPrintService[0];
309     }
310 
311 
312     public synchronized PrintService getDefaultPrintService() {
313         SecurityManager security = System.getSecurityManager();
314         if (security != null) {
315           security.checkPrintJobAccess();
316         }
317 
318 
319         // Windows does not have notification for a change in default
320         // so we always get the latest.
321         defaultPrinter = getDefaultPrinterName();
322         if (defaultPrinter == null) {
323             return null;
324         }
325 
326         if ((defaultPrintService != null) &amp;&amp;
327             defaultPrintService.getName().equals(defaultPrinter)) {
328 
329             return defaultPrintService;
330         }
331 
332          // Not the same as default so proceed to get new PrintService.
333 
334         // clear defaultPrintService
335         defaultPrintService = null;
336 
337         if (printServices != null) {
338             for (int j=0; j&lt;printServices.length; j++) {
339                 if (defaultPrinter.equals(printServices[j].getName())) {
340                     defaultPrintService = printServices[j];
341                     break;
342                 }
343             }
344         }
345 
346         if (defaultPrintService == null) {
347             defaultPrintService = new Win32PrintService(defaultPrinter);
348         }
349         return defaultPrintService;
350     }
351 
<a name="5" id="anc5"></a><span class="line-modified">352     private final class PrinterChangeListener implements Runnable {</span>





353         @Override
354         public void run() {
<a name="6" id="anc6"></a><span class="line-modified">355             notifyLocalPrinterChange(); // busy loop in the native code</span>














356         }
357     }
358 
359     /* Windows provides *PrinterChangeNotification* functions that provides
360        information about printer status changes of the local printers but not
361        network printers.
362        Alternatively, Windows provides a way through which one can get the
363        network printer status changes by using WMI, RegistryKeyChange combination,
364        which is a slightly complex mechanism.
365        The Windows WMI offers an async and sync method to read through registry
366        via the WQL query. The async method is considered dangerous as it leaves
367        open a channel until we close it. But the async method has the advantage of
368        being notified of a change in registry by calling callback without polling for it.
369        The sync method uses the polling mechanism to notify.
370        RegistryValueChange cannot be used in combination with WMI to get registry
371        value change notification because of an error that may be generated because the
372        scope of the query would be too big to handle(at times).
373        Hence an alternative mechanism is chosen via the EnumPrinters by polling for the
374        count of printer status changes(add\remove) and based on it update the printers
375        list.
376     */
377     class RemotePrinterChangeListener implements Comparator&lt;String&gt;, Runnable {
378 
379         RemotePrinterChangeListener() {
380         }
381 
382         @Override
383         public int compare(String o1, String o2) {
384             return ((o1 == null)
385                     ? ((o2 == null) ? 0 : 1)
386                     : ((o2 == null) ? -1 : o1.compareTo(o2)));
387         }
388 
389         @Override
390         public void run() {
391             // Init the list of remote printers
392             String[] prevRemotePrinters = getRemotePrintersNames();
393             if (prevRemotePrinters != null) {
394                 Arrays.sort(prevRemotePrinters, this);
395             }
396 
397             while (true) {
398                 try {
399                     Thread.sleep(refreshTime * 1000);
400                 } catch (InterruptedException e) {
401                     break;
402                 }
403 
404                 String[] currentRemotePrinters = getRemotePrintersNames();
405                 if (currentRemotePrinters != null) {
406                     Arrays.sort(currentRemotePrinters, this);
407                 }
408                 if (!Arrays.equals(prevRemotePrinters, currentRemotePrinters)) {
409                     // The list of remote printers got updated,
410                     // so update the cached list printers which
411                     // includes both local and network printers
412                     refreshServices();
413 
414                     // store the current data for next comparison
415                     prevRemotePrinters = currentRemotePrinters;
416                 }
417             }
418         }
419     }
420 
421     private native String getDefaultPrinterName();
422     private native String[] getAllPrinterNames();
<a name="7" id="anc7"></a><span class="line-modified">423     private native void notifyLocalPrinterChange();</span>


424     private native String[] getRemotePrintersNames();
425 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
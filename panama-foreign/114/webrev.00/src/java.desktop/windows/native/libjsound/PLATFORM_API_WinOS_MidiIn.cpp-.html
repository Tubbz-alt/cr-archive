<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/windows/native/libjsound/PLATFORM_API_WinOS_MidiIn.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #define USE_ERROR
 27 #define USE_TRACE
 28 
 29 /* include Java Sound specific headers as C code */
 30 extern &quot;C&quot; {
 31 #include &quot;PLATFORM_API_WinOS_Util.h&quot;
 32 }
 33 
 34 /* include to prevent charset problem */
 35 #include &quot;PLATFORM_API_WinOS_Charset_Util.h&quot;
 36 
 37 #if USE_PLATFORM_MIDI_IN == TRUE
 38 
 39 #ifdef USE_ERROR
 40 #include &lt;stdio.h&gt;
 41 
 42 /* Use THIS_FILE when it is available. */
 43 #ifndef THIS_FILE
 44     #define THIS_FILE __FILE__
 45 #endif
 46 
 47 #define MIDIIN_CHECK_ERROR { \
 48         if (err != MMSYSERR_NOERROR) \
 49             ERROR3(&quot;MIDI IN Error in %s:%d : %s\n&quot;, THIS_FILE, __LINE__, MIDI_IN_GetErrorStr((INT32) err)); \
 50     }
 51 #else
 52 #define MIDIIN_CHECK_ERROR
 53 #endif
 54 
 55 /*
 56  * Callback from the MIDI device for all messages.
 57  */
 58 //$$fb dwParam1 holds a pointer for long messages. How can that be a DWORD then ???
 59 void CALLBACK MIDI_IN_PutMessage( HMIDIIN hMidiIn, UINT wMsg, UINT_PTR dwInstance, UINT_PTR dwParam1, UINT_PTR dwParam2 ) {
 60 
 61     MidiDeviceHandle* handle = (MidiDeviceHandle*) dwInstance;
 62 
 63     TRACE3(&quot;&gt; MIDI_IN_PutMessage, hMidiIn: %x, wMsg: %x, dwInstance: %x\n&quot;, hMidiIn, wMsg, dwInstance);
 64     TRACE2(&quot;                      dwParam1: %x, dwParam2: %x\n&quot;, dwParam1, dwParam2);
 65 
 66     switch(wMsg) {
 67 
 68     case MIM_OPEN:
 69         TRACE0(&quot;&lt; MIDI_IN_PutMessage: MIM_OPEN\n&quot;);
 70         break;
 71 
 72     case MIM_CLOSE:
 73         TRACE0(&quot;&lt; MIDI_IN_PutMessage: MIM_CLOSE\n&quot;);
 74         break;
 75 
 76     case MIM_MOREDATA:
 77     case MIM_DATA:
 78         TRACE3(&quot;  MIDI_IN_PutMessage: MIM_MOREDATA or MIM_DATA. status=%x  data1=%x  data2=%x\n&quot;,
 79                dwParam1 &amp; 0xFF, (dwParam1 &amp; 0xFF00)&gt;&gt;8, (dwParam1 &amp; 0xFF0000)&gt;&gt;16);
 80         if (handle!=NULL &amp;&amp; handle-&gt;queue!=NULL &amp;&amp; handle-&gt;platformData) {
 81             MIDI_QueueAddShort(handle-&gt;queue,
 82                                // queue stores packedMsg in big endian
 83                                //(dwParam1 &lt;&lt; 24) | ((dwParam1 &lt;&lt; 8) &amp; 0xFF0000) | ((dwParam1 &gt;&gt; 8) &amp; 0xFF00),
 84                                (UINT32) dwParam1,
 85                                // queue uses microseconds
 86                                ((INT64) dwParam2)*1000,
 87                                // overwrite if queue is full
 88                                TRUE);
 89             SetEvent((HANDLE) handle-&gt;platformData);
 90         }
 91         TRACE0(&quot;&lt; MIDI_IN_PutMessage\n&quot;);
 92         break;
 93 
 94     case MIM_LONGDATA:
 95         TRACE1(&quot;  MIDI_IN_PutMessage: MIM_LONGDATA (%d bytes recorded)\n&quot;, (int) (((MIDIHDR*) dwParam1)-&gt;dwBytesRecorded));
 96         if (handle!=NULL &amp;&amp; handle-&gt;queue!=NULL &amp;&amp; handle-&gt;platformData) {
 97             MIDIHDR* hdr = (MIDIHDR*) dwParam1;
 98             TRACE2(&quot;  MIDI_IN_PutMessage: Adding to queue: index %d, %d bytes\n&quot;, (INT32) hdr-&gt;dwUser, hdr-&gt;dwBytesRecorded);
 99             MIDI_QueueAddLong(handle-&gt;queue,
100                               (UBYTE*) hdr-&gt;lpData,
101                               (UINT32) hdr-&gt;dwBytesRecorded,
102                               // sysex buffer index
103                               (INT32) hdr-&gt;dwUser,
104                               // queue uses microseconds
105                               ((INT64) dwParam2)*1000,
106                               // overwrite if queue is full
107                               TRUE);
108             SetEvent((HANDLE) handle-&gt;platformData);
109         }
110         TRACE0(&quot;&lt; MIDI_IN_PutMessage\n&quot;);
111         break;
112 
113     case MIM_ERROR:
114         ERROR0(&quot;&lt; MIDI_IN_PutMessage: MIM_ERROR!\n&quot;);
115         break;
116 
117     case MIM_LONGERROR:
118         if (dwParam1 != 0) {
119             MIDIHDR* hdr = (MIDIHDR*) dwParam1;
120 #ifdef USE_TRACE
121             if (hdr-&gt;dwBytesRecorded &gt; 0) {
122                 TRACE2(&quot;  MIDI_IN_PutMessage: MIM_LONGERROR! recorded: %d bytes with status 0x%2x\n&quot;,
123                         hdr-&gt;dwBytesRecorded, (int) (*((UBYTE*) hdr-&gt;lpData)));
124             }
125 #endif
126             // re-add hdr to device query
127             hdr-&gt;dwBytesRecorded = 0;
128             midiInAddBuffer((HMIDIIN)handle-&gt;deviceHandle, hdr, sizeof(MIDIHDR));
129         }
130         ERROR0(&quot;&lt; MIDI_IN_PutMessage: MIM_LONGERROR!\n&quot;);
131         break;
132 
133     default:
134         ERROR1(&quot;&lt; MIDI_IN_PutMessage: ERROR unknown message %d!\n&quot;, wMsg);
135         break;
136 
137     } // switch (wMsg)
138 }
139 
140 
141 /*
142 ** data/routines for opening MIDI input (MidiIn) device by separate thread
143 ** (joint into MidiIn_OpenHelper class)
144 ** see 6415669 - MidiIn device stops work and crushes JVM after exiting
145 ** from thread that has open the device (it looks like WinMM bug).
146 */
147 class MidiIn_OpenHelper {
148 public:
149     /* opens MidiIn device  */
150     static MMRESULT midiInOpen(INT32 deviceID, MidiDeviceHandle* handle);
151     /* checks for initialization success */
152     static inline BOOL isInitialized() { return data.threadHandle != NULL; }
153 protected:
154     MidiIn_OpenHelper() {}  // no need to create an instance
155 
156     /* data class */
157     class Data {
158     public:
159         Data();
160         ~Data();
161         // public data to access from parent class
162         CRITICAL_SECTION crit_sect;
163         volatile HANDLE threadHandle;
164         volatile HANDLE doEvent;    // event to resume thread
165         volatile HANDLE doneEvent;  // processing has been completed
166         volatile MMRESULT err;      // processing result
167         // data to process; (handle == null) is command to thread terminating
168         volatile INT32 deviceID;
169         volatile MidiDeviceHandle* handle;
170     } static data;
171 
172     /* StartThread function */
173     static DWORD WINAPI __stdcall ThreadProc(void *param);
174 };
175 
176 /* MidiIn_OpenHelper class implementation
177 */
178 MidiIn_OpenHelper::Data MidiIn_OpenHelper::data;
179 
180 MidiIn_OpenHelper::Data::Data() {
181     threadHandle = NULL;
182     ::InitializeCriticalSection(&amp;crit_sect);
183     doEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
184     doneEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
185     if (doEvent != NULL &amp;&amp; doneEvent != NULL)
186         threadHandle = ::CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);
187 }
188 
189 MidiIn_OpenHelper::Data::~Data() {
190     ::EnterCriticalSection(&amp;crit_sect);
191     if (threadHandle != NULL) {
192         // terminate thread
193         handle = NULL;
194         ::SetEvent(doEvent);
195         ::CloseHandle(threadHandle);
196         threadHandle = NULL;
197     }
198     ::LeaveCriticalSection(&amp;crit_sect);
199     // won&#39;t delete doEvent/doneEvent/crit_sect
200     // - Windows will do during process shutdown
201 }
202 
203 DWORD WINAPI __stdcall MidiIn_OpenHelper::ThreadProc(void *param) {
204     while (1) {
205         // wait for something to do
206         ::WaitForSingleObject(data.doEvent, INFINITE);
207         if (data.handle == NULL) {
208             // (data.handle == NULL) is a signal to terminate thread
209             break;
210         }
211 
212         data.err = ::midiInOpen((HMIDIIN*)&amp;(data.handle-&gt;deviceHandle),
213                                 data.deviceID, (UINT_PTR)&amp;(MIDI_IN_PutMessage),
214                                 (UINT_PTR)data.handle,
215                                 CALLBACK_FUNCTION|MIDI_IO_STATUS);
216 
217         ::SetEvent(data.doneEvent);
218     }
219     return 0;
220 }
221 
222 MMRESULT MidiIn_OpenHelper::midiInOpen(INT32 deviceID, MidiDeviceHandle* handle) {
223     MMRESULT err;
224     ::EnterCriticalSection(&amp;data.crit_sect);
225     if (!isInitialized()) {
226         ::LeaveCriticalSection(&amp;data.crit_sect);
227         return MMSYSERR_ERROR;
228     }
229     data.deviceID = deviceID;
230     data.handle = handle;
231     ::SetEvent(data.doEvent);
232     ::WaitForSingleObject(data.doneEvent, INFINITE);
233     err = data.err;
234     ::LeaveCriticalSection(&amp;data.crit_sect);
235     return err;
236 }
237 
238 
239 // PLATFORM_MIDI_IN method implementations
240 
241 /* not thread safe */
242 static char winMidiInErrMsg[WIN_MAX_ERROR_LEN];
243 
244 char* MIDI_IN_GetErrorStr(INT32 err) {
245     winMidiInErrMsg[0] = 0;
246     midiInGetErrorText((MMRESULT) err, winMidiInErrMsg, WIN_MAX_ERROR_LEN);
247     return winMidiInErrMsg;
248 }
249 
250 INT32 MIDI_IN_GetNumDevices() {
251     return (INT32) midiInGetNumDevs();
252 }
253 
254 INT32 getMidiInCaps(INT32 deviceID, MIDIINCAPSW* caps, INT32* err) {
255     (*err) = midiInGetDevCapsW(deviceID, caps, sizeof(MIDIINCAPSW));
256     return ((*err) == MMSYSERR_NOERROR);
257 }
258 
259 INT32 MIDI_IN_GetDeviceName(INT32 deviceID, char *name, UINT32 nameLength) {
260     MIDIINCAPSW midiInCaps;
261     INT32 err;
262 
263     memset(&amp;midiInCaps, 0, sizeof(midiInCaps));
264     if (getMidiInCaps(deviceID, &amp;midiInCaps, &amp;err)) {
265         UnicodeToUTF8AndCopy(name, midiInCaps.szPname, nameLength);
266         return MIDI_SUCCESS;
267     }
268     MIDIIN_CHECK_ERROR;
269     return err;
270 }
271 
272 
273 INT32 MIDI_IN_GetDeviceVendor(INT32 deviceID, char *name, UINT32 nameLength) {
274     return MIDI_NOT_SUPPORTED;
275 }
276 
277 
278 INT32 MIDI_IN_GetDeviceDescription(INT32 deviceID, char *name, UINT32 nameLength) {
279     return MIDI_NOT_SUPPORTED;
280 }
281 
282 
283 
284 INT32 MIDI_IN_GetDeviceVersion(INT32 deviceID, char *name, UINT32 nameLength) {
285     MIDIINCAPSW midiInCaps;
286     INT32 err = MIDI_NOT_SUPPORTED;
287 
288     memset(&amp;midiInCaps, 0, sizeof(midiInCaps));
289     if (getMidiInCaps(deviceID, &amp;midiInCaps, &amp;err) &amp;&amp; (nameLength&gt;7)) {
290         sprintf(name, &quot;%d.%d&quot;, (midiInCaps.vDriverVersion &amp; 0xFF00) &gt;&gt; 8, midiInCaps.vDriverVersion &amp; 0xFF);
291         return MIDI_SUCCESS;
292     }
293     MIDIIN_CHECK_ERROR;
294     return err;
295 }
296 
297 
298 INT32 prepareBuffers(MidiDeviceHandle* handle) {
299     SysExQueue* sysex;
300     MMRESULT err = MMSYSERR_NOERROR;
301     int i;
302 
303     if (!handle || !handle-&gt;longBuffers || !handle-&gt;deviceHandle) {
304         ERROR0(&quot;MIDI_IN_prepareBuffers: handle, or longBuffers, or deviceHandle==NULL\n&quot;);
305         return MIDI_INVALID_HANDLE;
306     }
307     sysex = (SysExQueue*) handle-&gt;longBuffers;
308     for (i = 0; i&lt;sysex-&gt;count; i++) {
309         MIDIHDR* hdr = &amp;(sysex-&gt;header[i]);
310         midiInPrepareHeader((HMIDIIN) handle-&gt;deviceHandle, hdr, sizeof(MIDIHDR));
311         err = midiInAddBuffer((HMIDIIN) handle-&gt;deviceHandle, hdr, sizeof(MIDIHDR));
312     }
313     MIDIIN_CHECK_ERROR;
314     return (INT32) err;
315 }
316 
317 INT32 unprepareBuffers(MidiDeviceHandle* handle) {
318     SysExQueue* sysex;
319     MMRESULT err = MMSYSERR_NOERROR;
320     int i;
321 
322     if (!handle || !handle-&gt;longBuffers || !handle-&gt;deviceHandle) {
323         ERROR0(&quot;MIDI_IN_unprepareBuffers: handle, or longBuffers, or deviceHandle==NULL\n&quot;);
324         return MIDI_INVALID_HANDLE;
325     }
326     sysex = (SysExQueue*) handle-&gt;longBuffers;
327     for (i = 0; i&lt;sysex-&gt;count; i++) {
328         err = midiInUnprepareHeader((HMIDIIN) handle-&gt;deviceHandle, &amp;(sysex-&gt;header[i]), sizeof(MIDIHDR));
329     }
330     MIDIIN_CHECK_ERROR;
331     return (INT32) err;
332 }
333 
334 INT32 MIDI_IN_OpenDevice(INT32 deviceID, MidiDeviceHandle** handle) {
335     MMRESULT err;
336 
337     TRACE0(&quot;&gt; MIDI_IN_OpenDevice\n&quot;);
338 #ifdef USE_ERROR
339     setvbuf(stdout, NULL, (int)_IONBF, 0);
340     setvbuf(stderr, NULL, (int)_IONBF, 0);
341 #endif
342 
343     (*handle) = (MidiDeviceHandle*) malloc(sizeof(MidiDeviceHandle));
344     if (!(*handle)) {
345         ERROR0(&quot;&lt; ERROR: MIDI_IN_OpenDevice: out of memory\n&quot;);
346         return MIDI_OUT_OF_MEMORY;
347     }
348     memset(*handle, 0, sizeof(MidiDeviceHandle));
349 
350     // create queue
351     (*handle)-&gt;queue = MIDI_CreateQueue(MIDI_IN_MESSAGE_QUEUE_SIZE);
352     if (!(*handle)-&gt;queue) {
353         ERROR0(&quot;&lt; ERROR: MIDI_IN_OpenDevice: could not create queue\n&quot;);
354         free(*handle);
355         (*handle) = NULL;
356         return MIDI_OUT_OF_MEMORY;
357     }
358 
359     // create long buffer queue
360     if (!MIDI_WinCreateLongBufferQueue(*handle, MIDI_IN_LONG_QUEUE_SIZE, MIDI_IN_LONG_MESSAGE_SIZE, NULL)) {
361         ERROR0(&quot;&lt; ERROR: MIDI_IN_OpenDevice: could not create long Buffers\n&quot;);
362         MIDI_DestroyQueue((*handle)-&gt;queue);
363         free(*handle);
364         (*handle) = NULL;
365         return MIDI_OUT_OF_MEMORY;
366     }
367 
368     // finally open the device
369     err = MidiIn_OpenHelper::midiInOpen(deviceID, *handle);
370 
371     if ((err != MMSYSERR_NOERROR) || (!(*handle)-&gt;deviceHandle)) {
372         MIDIIN_CHECK_ERROR;
373         MIDI_WinDestroyLongBufferQueue(*handle);
374         MIDI_DestroyQueue((*handle)-&gt;queue);
375         free(*handle);
376         (*handle) = NULL;
377         return (INT32) err;
378     }
379 
380     prepareBuffers(*handle);
381         MIDI_SetStartTime(*handle);
382     TRACE0(&quot;&lt; MIDI_IN_OpenDevice: midiInOpen succeeded\n&quot;);
383     return MIDI_SUCCESS;
384 }
385 
386 
387 INT32 MIDI_IN_CloseDevice(MidiDeviceHandle* handle) {
388     MMRESULT err;
389 
390     TRACE0(&quot;&gt; MIDI_IN_CloseDevice: midiInClose\n&quot;);
391     if (!handle) {
392         ERROR0(&quot;ERROR: MIDI_IN_CloseDevice: handle is NULL\n&quot;);
393         return MIDI_INVALID_HANDLE;
394     }
395     midiInReset((HMIDIIN) handle-&gt;deviceHandle);
396     unprepareBuffers(handle);
397     err = midiInClose((HMIDIIN) handle-&gt;deviceHandle);
398     handle-&gt;deviceHandle=NULL;
399     MIDIIN_CHECK_ERROR;
400     MIDI_WinDestroyLongBufferQueue(handle);
401 
402     if (handle-&gt;queue!=NULL) {
403         MidiMessageQueue* queue = handle-&gt;queue;
404         handle-&gt;queue = NULL;
405         MIDI_DestroyQueue(queue);
406     }
407     free(handle);
408 
409     TRACE0(&quot;&lt; MIDI_IN_CloseDevice: midiInClose succeeded\n&quot;);
410     return (INT32) err;
411 }
412 
413 
414 INT32 MIDI_IN_StartDevice(MidiDeviceHandle* handle) {
415     MMRESULT err;
416 
417     if (!handle || !handle-&gt;deviceHandle || !handle-&gt;queue) {
418         ERROR0(&quot;ERROR: MIDI_IN_StartDevice: handle or queue is NULL\n&quot;);
419         return MIDI_INVALID_HANDLE;
420     }
421 
422     // clear all the events from the queue
423     MIDI_QueueClear(handle-&gt;queue);
424 
425     handle-&gt;platformData = (void*) CreateEvent(NULL, FALSE /*manual reset*/, FALSE /*signaled*/, NULL);
426     if (!handle-&gt;platformData) {
427         ERROR0(&quot;ERROR: MIDI_IN_StartDevice: could not create event\n&quot;);
428         return MIDI_OUT_OF_MEMORY;
429     }
430 
431     err = midiInStart((HMIDIIN) handle-&gt;deviceHandle);
432         /* $$mp 200308-11: This method is already called in ...open(). It is
433            unclear why it is called again. The specification says that
434            MidiDevice.getMicrosecondPosition() returns the time since the
435            device was opened (the spec doesn&#39;t know about start/stop).
436            So I guess this call is obsolete. */
437         MIDI_SetStartTime(handle);
438 
439     MIDIIN_CHECK_ERROR;
440     TRACE0(&quot;MIDI_IN_StartDevice: midiInStart finished\n&quot;);
441     return (INT32) err;
442 }
443 
444 
445 INT32 MIDI_IN_StopDevice(MidiDeviceHandle* handle) {
446     MMRESULT err;
447     HANDLE event;
448 
449     TRACE0(&quot;&gt; MIDI_IN_StopDevice: midiInStop \n&quot;);
450     if (!handle || !handle-&gt;platformData) {
451         ERROR0(&quot;ERROR: MIDI_IN_StopDevice: handle or event is NULL\n&quot;);
452         return MIDI_INVALID_HANDLE;
453     }
454     // encourage MIDI_IN_GetMessage to return soon
455     event = handle-&gt;platformData;
456     handle-&gt;platformData = NULL;
457     SetEvent(event);
458 
459     err = midiInStop((HMIDIIN) handle-&gt;deviceHandle);
460 
461     // wait until the Java thread has exited
462     while (handle-&gt;isWaiting) Sleep(0);
463     CloseHandle(event);
464 
465     MIDIIN_CHECK_ERROR;
466     TRACE0(&quot;&lt; MIDI_IN_StopDevice: midiInStop finished\n&quot;);
467     return (INT32) err;
468 }
469 
470 
471 /* return time stamp in microseconds */
472 INT64 MIDI_IN_GetTimeStamp(MidiDeviceHandle* handle) {
473         return MIDI_GetTimeStamp(handle);
474 }
475 
476 
477 // read the next message from the queue
478 MidiMessage* MIDI_IN_GetMessage(MidiDeviceHandle* handle) {
479     if (handle == NULL) {
480         return NULL;
481     }
482     while (handle-&gt;queue!=NULL &amp;&amp; handle-&gt;platformData!=NULL) {
483         MidiMessage* msg = MIDI_QueueRead(handle-&gt;queue);
484         DWORD res;
485         if (msg != NULL) {
486             //fprintf(stdout, &quot;GetMessage returns index %d\n&quot;, msg-&gt;data.l.index); fflush(stdout);
487             return msg;
488         }
489         TRACE0(&quot;MIDI_IN_GetMessage: before waiting\n&quot;);
490         handle-&gt;isWaiting = TRUE;
491         res = WaitForSingleObject((HANDLE) handle-&gt;platformData, 2000);
492         handle-&gt;isWaiting = FALSE;
493         if (res == WAIT_TIMEOUT) {
494             // break out back to Java from time to time - just to be sure
495             TRACE0(&quot;MIDI_IN_GetMessage: waiting finished with timeout\n&quot;);
496             break;
497         }
498         TRACE0(&quot;MIDI_IN_GetMessage: waiting finished\n&quot;);
499     }
500     return NULL;
501 }
502 
503 void MIDI_IN_ReleaseMessage(MidiDeviceHandle* handle, MidiMessage* msg) {
504     SysExQueue* sysex;
505     if (handle == NULL || handle-&gt;queue == NULL) {
506         return;
507     }
508     sysex = (SysExQueue*) handle-&gt;longBuffers;
509     if (msg-&gt;type == LONG_MESSAGE &amp;&amp; sysex) {
510         MIDIHDR* hdr = &amp;(sysex-&gt;header[msg-&gt;data.l.index]);
511         //fprintf(stdout, &quot;ReleaseMessage index %d\n&quot;, msg-&gt;data.l.index); fflush(stdout);
512         hdr-&gt;dwBytesRecorded = 0;
513         midiInAddBuffer((HMIDIIN) handle-&gt;deviceHandle, hdr, sizeof(MIDIHDR));
514     }
515     MIDI_QueueRemove(handle-&gt;queue, TRUE /*onlyLocked*/);
516 }
517 
518 #endif // USE_PLATFORM_MIDI_IN
    </pre>
  </body>
</html>
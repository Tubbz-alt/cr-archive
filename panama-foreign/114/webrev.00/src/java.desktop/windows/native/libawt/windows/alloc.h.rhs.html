<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/windows/native/libawt/windows/alloc.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef _ALLOC_H_
 27 #define _ALLOC_H_
 28 
<a name="1" id="anc1"></a>




 29 #include &quot;stdhdrs.h&quot;
 30 
 31 // By defining std::bad_alloc in a local header file instead of including
 32 // the Standard C++ &lt;new&gt; header file, we avoid making awt.dll dependent
 33 // on msvcp50.dll. This reduces the size of the JRE by 500kb.
 34 namespace std {
 35     class bad_alloc {};
 36 }
 37 
 38 #define SIZECALC_ALLOC_THROWING_BAD_ALLOC
 39 #include &quot;sizecalc.h&quot;
 40 
 41 class awt_toolkit_shutdown {};
 42 
 43 // Disable &quot;C++ Exception Specification ignored&quot; warnings.
 44 // These warnings are generated because VC++ 5.0 allows, but does not enforce,
 45 // exception specifications. This #pragma can be safely removed when VC++
 46 // is updated to enforce exception specifications.
 47 #pragma warning(disable : 4290)
 48 
 49 #ifdef TRY
 50 #error Multiple definitions of TRY
 51 #endif
 52 
 53 #ifdef TRY_NO_VERIFY
 54 #error Multiple definitions of TRY_NO_VERIFY
 55 #endif
 56 
 57 #ifdef CATCH_BAD_ALLOC
 58 #error Multiple definitions of CATCH_BAD_ALLOC
 59 #endif
 60 
 61 #ifdef CATCH_BAD_ALLOC_RET
 62 #error Multiple defintions of CATCH_BAD_ALLOC_RET
 63 #endif
 64 
 65 #ifdef TRY_NO_JNI
 66 #error Multiple definitions of TRY_NO_JNI
 67 #endif
 68 
 69 #ifdef TRY_NO_VERIFY_NO_JNI
 70 #error Multiple definitions of TRY_NO_VERIFY_NO_JNI
 71 #endif
 72 
 73 #ifdef CATCH_BAD_ALLOC_NO_JNI
 74 #error Multiple definitions of CATCH_BAD_ALLOC_NO_JNI
 75 #endif
 76 
 77 #ifdef CATCH_BAD_ALLOC_RET_NO_JNI
 78 #error Multiple defintions of CATCH_BAD_ALLOC_RET_NO_JNI
 79 #endif
 80 
 81 // The unsafe versions of malloc, calloc, and realloc should not be used
 82 #define malloc Do_Not_Use_malloc_Use_safe_Malloc_Instead
 83 #define calloc Do_Not_Use_calloc_Use_safe_Calloc_Instead
 84 #define realloc Do_Not_Use_realloc_Use_safe_Realloc_Instead
 85 #define ExceptionOccurred Do_Not_Use_ExceptionOccurred_Use_safe_\
 86 ExceptionOccurred_Instead
 87 
 88 // These three functions throw std::bad_alloc in an out of memory condition
 89 // instead of returning 0. safe_Realloc will return 0 if memblock is not
 90 // NULL and size is 0. safe_Malloc and safe_Calloc will never return 0.
 91 void *safe_Malloc(size_t size) throw (std::bad_alloc);
 92 void *safe_Calloc(size_t num, size_t size) throw (std::bad_alloc);
 93 void *safe_Realloc(void *memblock, size_t size) throw (std::bad_alloc);
 94 
 95 // This function should be called instead of ExceptionOccurred. It throws
 96 // std::bad_alloc if a java.lang.OutOfMemoryError is currently pending
 97 // on the calling thread.
 98 jthrowable safe_ExceptionOccurred(JNIEnv *env) throw (std::bad_alloc);
 99 
100 // This function is called at the beginning of an entry point.
101 // Entry points are functions which are declared:
102 //   1. CALLBACK,
103 //   2. JNIEXPORT,
104 //   3. __declspec(dllexport), or
105 //   4. extern &quot;C&quot;
106 // A function which returns an HRESULT (an OLE function) is also an entry
107 // point.
108 void entry_point(void);
109 
110 // This function hangs indefinitely if the Toolkit is not active
111 void hang_if_shutdown(void);
112 
113 // This function throws awt_toolkit_shutdown if the Toolkit is not active
114 void throw_if_shutdown(void) throw (awt_toolkit_shutdown);
115 
116 // This function is called when a std::bad_alloc exception is caught
117 void handle_bad_alloc(void);
118 
119 // Uncomment to nondeterministically test OutOfMemory errors
120 // #define OUTOFMEM_TEST
121 
122 #ifdef OUTOFMEM_TEST
123     void *safe_Malloc_outofmem(size_t size, const char *, int)
124         throw (std::bad_alloc);
125     void *safe_Calloc_outofmem(size_t num, size_t size, const char *, int)
126         throw (std::bad_alloc);
127     void *safe_Realloc_outofmem(void *memblock, size_t size, const char *, int)
128         throw (std::bad_alloc);
129     void * CDECL operator new(size_t size, const char *, int)
130         throw (std::bad_alloc);
131 
132     #define safe_Malloc(size) \
<a name="2" id="anc2"></a><span class="line-modified">133         safe_Malloc_outofmem(size, __FILE__, __LINE__)</span>
134     #define safe_Calloc(num, size) \
<a name="3" id="anc3"></a><span class="line-modified">135         safe_Calloc_outofmem(num, size, __FILE__, __LINE__)</span>
136     #define safe_Realloc(memblock, size) \
<a name="4" id="anc4"></a><span class="line-modified">137         safe_Realloc_outofmem(memblock, size, __FILE__, __LINE__)</span>
<span class="line-modified">138     #define new new(__FILE__, __LINE__)</span>
139 #endif /* OUTOFMEM_TEST */
140 
141 #define TRY \
142     try { \
143         entry_point(); \
144         hang_if_shutdown();
145 // The _NO_HANG version of TRY causes the AWT native code to return to Java
146 // immediately if the Toolkit is not active. Normal AWT operations should
147 // never use this macro. It should only be used for cleanup routines where:
148 // (1) Hanging is not a valid option, because the method is called during
149 // execution of runFinalizersOnExit; and, (2) Execution of the method would
150 // generate a NullPointerException or other Exception.
151 #define TRY_NO_HANG \
152     try { \
153         entry_point(); \
154         throw_if_shutdown();
155 // The _NO_VERIFY version of TRY does not verify that the Toolkit is still
156 // active before proceeding. Normal AWT operations should never use this
157 // macro. It should only be used for cleanup routines which can safely
158 // execute after the Toolkit is disposed, and then only with caution. Users
159 // of this macro must be able to guarantee that the code which will execute
160 // will not generate a NullPointerException or other Exception.
161 #define TRY_NO_VERIFY \
162     try { \
163         entry_point();
164 #define CATCH_BAD_ALLOC \
165     } catch (std::bad_alloc&amp;) { \
166         handle_bad_alloc(); \
167         return; \
168     } catch (awt_toolkit_shutdown&amp;) {\
169         return; \
170     }
171 #define CATCH_BAD_ALLOC_RET(x) \
172     } catch (std::bad_alloc&amp;) { \
173         handle_bad_alloc(); \
174         return (x); \
175     } catch (awt_toolkit_shutdown&amp;) {\
176         return (0); \
177     }
178 
179 // The _NO_JNI versions of TRY and CATCH_BAD_ALLOC simply discard
180 // std::bad_alloc exceptions and thus should be avoided at all costs. They
181 // are only useful if the calling function currently holds the JNI lock
182 // for the thread. This lock is acquired by calling GetPrimitiveArrayCritical
183 // or GetStringCritical. No JNI function should be called by that thread
184 // until the corresponding Release function has been called.
185 
186 #define TRY_NO_JNI \
187     try { \
188         hang_if_shutdown();
189 #define TRY_NO_HANG_NO_JNI \
190     try { \
191         throw_if_shutdown();
192 #define TRY_NO_VERIFY_NO_JNI \
193     try {
194 #define CATCH_BAD_ALLOC_NO_JNI \
195     } catch (std::bad_alloc&amp;) { \
196         return; \
197     } catch (awt_toolkit_shutdown&amp;) {\
198         return; \
199     }
200 #define CATCH_BAD_ALLOC_RET_NO_JNI(x) \
201     } catch (std::bad_alloc&amp;) { \
202         return (x); \
203     } catch (awt_toolkit_shutdown&amp;) {\
204         return (0); \
205     }
206 
207 #endif /* _ALLOC_H_ */
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
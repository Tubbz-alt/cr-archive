<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/classes/sun/java2d/SunGraphics2D.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d;
  27 
  28 import java.awt.Graphics;
  29 import java.awt.Graphics2D;
  30 import java.awt.RenderingHints;
  31 import java.awt.RenderingHints.Key;
  32 import java.awt.geom.Area;
  33 import java.awt.geom.AffineTransform;
  34 import java.awt.geom.NoninvertibleTransformException;
  35 import java.awt.AlphaComposite;
  36 import java.awt.BasicStroke;
  37 import java.awt.image.BufferedImage;
  38 import java.awt.image.BufferedImageOp;
  39 import java.awt.image.RenderedImage;
  40 import java.awt.image.renderable.RenderableImage;
  41 import java.awt.image.renderable.RenderContext;
  42 import java.awt.image.AffineTransformOp;
  43 import java.awt.image.Raster;
  44 import java.awt.image.WritableRaster;
  45 import java.awt.Image;
  46 import java.awt.Composite;
  47 import java.awt.Color;
  48 import java.awt.image.ColorModel;
  49 import java.awt.GraphicsConfiguration;
  50 import java.awt.Paint;
  51 import java.awt.GradientPaint;
  52 import java.awt.LinearGradientPaint;
  53 import java.awt.RadialGradientPaint;
  54 import java.awt.TexturePaint;
  55 import java.awt.geom.Rectangle2D;
  56 import java.awt.geom.PathIterator;
  57 import java.awt.geom.GeneralPath;
  58 import java.awt.Shape;
  59 import java.awt.Stroke;
  60 import java.awt.FontMetrics;
  61 import java.awt.Rectangle;
  62 import java.text.AttributedCharacterIterator;
  63 import java.awt.Font;
  64 import java.awt.image.ImageObserver;
  65 import java.awt.Transparency;
  66 import java.awt.font.GlyphVector;
  67 import java.awt.font.TextLayout;
  68 
  69 import sun.awt.image.SurfaceManager;
  70 import sun.font.FontDesignMetrics;
  71 import sun.font.FontUtilities;
  72 import sun.java2d.pipe.PixelDrawPipe;
  73 import sun.java2d.pipe.PixelFillPipe;
  74 import sun.java2d.pipe.ShapeDrawPipe;
  75 import sun.java2d.pipe.ValidatePipe;
  76 import sun.java2d.pipe.ShapeSpanIterator;
  77 import sun.java2d.pipe.Region;
  78 import sun.java2d.pipe.TextPipe;
  79 import sun.java2d.pipe.DrawImagePipe;
  80 import sun.java2d.pipe.LoopPipe;
  81 import sun.java2d.loops.FontInfo;
  82 import sun.java2d.loops.RenderLoops;
  83 import sun.java2d.loops.CompositeType;
  84 import sun.java2d.loops.SurfaceType;
  85 import sun.java2d.loops.Blit;
  86 import sun.java2d.loops.MaskFill;
  87 import java.awt.font.FontRenderContext;
  88 import sun.java2d.loops.XORComposite;
  89 import sun.awt.ConstrainableGraphics;
  90 import sun.awt.SunHints;
  91 import sun.awt.util.PerformanceLogger;
  92 import java.util.Map;
  93 import java.util.Iterator;
  94 
  95 import java.lang.annotation.Native;
  96 import java.awt.image.MultiResolutionImage;
  97 
  98 import static java.awt.geom.AffineTransform.TYPE_FLIP;
  99 import static java.awt.geom.AffineTransform.TYPE_MASK_SCALE;
 100 import static java.awt.geom.AffineTransform.TYPE_TRANSLATION;
 101 import java.awt.image.VolatileImage;
 102 import sun.awt.image.MultiResolutionToolkitImage;
 103 import sun.awt.image.ToolkitImage;
 104 
 105 /**
 106  * This is a the master Graphics2D superclass for all of the Sun
 107  * Graphics implementations.  This class relies on subclasses to
 108  * manage the various device information, but provides an overall
 109  * general framework for performing all of the requests in the
 110  * Graphics and Graphics2D APIs.
 111  *
 112  * @author Jim Graham
 113  */
 114 public final class SunGraphics2D
 115     extends Graphics2D
 116     implements ConstrainableGraphics, Cloneable, DestSurfaceProvider
 117 {
 118     /*
 119      * Attribute States
 120      */
 121     /* Paint */
 122     @Native
 123     public static final int PAINT_CUSTOM       = 6; /* Any other Paint object */
 124     @Native
 125     public static final int PAINT_TEXTURE      = 5; /* Tiled Image */
 126     @Native
 127     public static final int PAINT_RAD_GRADIENT = 4; /* Color RadialGradient */
 128     @Native
 129     public static final int PAINT_LIN_GRADIENT = 3; /* Color LinearGradient */
 130     @Native
 131     public static final int PAINT_GRADIENT     = 2; /* Color Gradient */
 132     @Native
 133     public static final int PAINT_ALPHACOLOR   = 1; /* Non-opaque Color */
 134     @Native
 135     public static final int PAINT_OPAQUECOLOR  = 0; /* Opaque Color */
 136 
 137     /* Composite*/
 138     @Native
 139     public static final int COMP_CUSTOM = 3;/* Custom Composite */
 140     @Native
 141     public static final int COMP_XOR    = 2;/* XOR Mode Composite */
 142     @Native
 143     public static final int COMP_ALPHA  = 1;/* AlphaComposite */
 144     @Native
 145     public static final int COMP_ISCOPY = 0;/* simple stores into destination,
 146                                              * i.e. Src, SrcOverNoEa, and other
 147                                              * alpha modes which replace
 148                                              * the destination.
 149                                              */
 150 
 151     /* Stroke */
 152     @Native
 153     public static final int STROKE_CUSTOM = 3; /* custom Stroke */
 154     @Native
 155     public static final int STROKE_WIDE   = 2; /* BasicStroke */
 156     @Native
 157     public static final int STROKE_THINDASHED   = 1; /* BasicStroke */
 158     @Native
 159     public static final int STROKE_THIN   = 0; /* BasicStroke */
 160 
 161     /* Transform */
 162     @Native
 163     public static final int TRANSFORM_GENERIC = 4; /* any 3x2 */
 164     @Native
 165     public static final int TRANSFORM_TRANSLATESCALE = 3; /* scale XY */
 166     @Native
 167     public static final int TRANSFORM_ANY_TRANSLATE = 2; /* non-int translate */
 168     @Native
 169     public static final int TRANSFORM_INT_TRANSLATE = 1; /* int translate */
 170     @Native
 171     public static final int TRANSFORM_ISIDENT = 0; /* Identity */
 172 
 173     /* Clipping */
 174     @Native
 175     public static final int CLIP_SHAPE       = 2; /* arbitrary clip */
 176     @Native
 177     public static final int CLIP_RECTANGULAR = 1; /* rectangular clip */
 178     @Native
 179     public static final int CLIP_DEVICE      = 0; /* no clipping set */
 180 
 181     /* The following fields are used when the current Paint is a Color. */
 182     public int eargb;  // ARGB value with ExtraAlpha baked in
 183     public int pixel;  // pixel value for eargb
 184 
 185     public SurfaceData surfaceData;
 186 
 187     public PixelDrawPipe drawpipe;
 188     public PixelFillPipe fillpipe;
 189     public DrawImagePipe imagepipe;
 190     public ShapeDrawPipe shapepipe;
 191     public TextPipe textpipe;
 192     public MaskFill alphafill;
 193 
 194     public RenderLoops loops;
 195 
 196     public CompositeType imageComp;     /* Image Transparency checked on fly */
 197 
 198     public int paintState;
 199     public int compositeState;
 200     public int strokeState;
 201     public int transformState;
 202     public int clipState;
 203 
 204     public Color foregroundColor;
 205     public Color backgroundColor;
 206 
 207     public AffineTransform transform;
 208     public int transX;
 209     public int transY;
 210 
 211     protected static final Stroke defaultStroke = new BasicStroke();
 212     protected static final Composite defaultComposite = AlphaComposite.SrcOver;
 213     private static final Font defaultFont =
 214         new Font(Font.DIALOG, Font.PLAIN, 12);
 215 
 216     public Paint paint;
 217     public Stroke stroke;
 218     public Composite composite;
 219     protected Font font;
 220     protected FontMetrics fontMetrics;
 221 
 222     public int renderHint;
 223     public int antialiasHint;
 224     public int textAntialiasHint;
 225     protected int fractionalMetricsHint;
 226 
 227     /* A gamma adjustment to the colour used in lcd text blitting */
 228     public int lcdTextContrast;
 229     private static int lcdTextContrastDefaultValue = 140;
 230 
 231     private int interpolationHint;      // raw value of rendering Hint
 232     public int strokeHint;
 233 
 234     public int interpolationType;       // algorithm choice based on
 235                                         // interpolation and render Hints
 236 
 237     public RenderingHints hints;
 238 
 239     public Region constrainClip;        // lightweight bounds in pixels
 240     public int constrainX;
 241     public int constrainY;
 242 
 243     public Region clipRegion;
 244     public Shape usrClip;
 245     protected Region devClip;           // Actual physical drawable in pixels
 246 
 247     private int resolutionVariantHint;
 248 
 249     // cached state for text rendering
 250     private boolean validFontInfo;
 251     private FontInfo fontInfo;
 252     private FontInfo glyphVectorFontInfo;
 253     private FontRenderContext glyphVectorFRC;
 254 
 255     private static final int slowTextTransformMask =
 256                             AffineTransform.TYPE_GENERAL_TRANSFORM
 257                         |   AffineTransform.TYPE_MASK_ROTATION
 258                         |   AffineTransform.TYPE_FLIP;
 259 
 260     static {
 261         if (PerformanceLogger.loggingEnabled()) {
 262             PerformanceLogger.setTime(&quot;SunGraphics2D static initialization&quot;);
 263         }
 264     }
 265 
 266     public SunGraphics2D(SurfaceData sd, Color fg, Color bg, Font f) {
 267         surfaceData = sd;
 268         foregroundColor = fg;
 269         backgroundColor = bg;
 270         stroke = defaultStroke;
 271         composite = defaultComposite;
 272         paint = foregroundColor;
 273 
 274         imageComp = CompositeType.SrcOverNoEa;
 275 
 276         renderHint = SunHints.INTVAL_RENDER_DEFAULT;
 277         antialiasHint = SunHints.INTVAL_ANTIALIAS_OFF;
 278         textAntialiasHint = SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT;
 279         fractionalMetricsHint = SunHints.INTVAL_FRACTIONALMETRICS_OFF;
 280         lcdTextContrast = lcdTextContrastDefaultValue;
 281         interpolationHint = -1;
 282         strokeHint = SunHints.INTVAL_STROKE_DEFAULT;
 283         resolutionVariantHint = SunHints.INTVAL_RESOLUTION_VARIANT_DEFAULT;
 284 
 285         interpolationType = AffineTransformOp.TYPE_NEAREST_NEIGHBOR;
 286 
 287         transform = getDefaultTransform();
 288         if (!transform.isIdentity()) {
 289             invalidateTransform();
 290         }
 291 
 292         validateColor();
 293 
 294         font = f;
 295         if (font == null) {
 296             font = defaultFont;
 297         }
 298 
 299         setDevClip(sd.getBounds());
 300         invalidatePipe();
 301     }
 302 
 303     private AffineTransform getDefaultTransform() {
 304         GraphicsConfiguration gc = getDeviceConfiguration();
 305         return (gc == null) ? new AffineTransform() : gc.getDefaultTransform();
 306     }
 307 
 308     protected Object clone() {
 309         try {
 310             SunGraphics2D g = (SunGraphics2D) super.clone();
 311             g.transform = new AffineTransform(this.transform);
 312             if (hints != null) {
 313                 g.hints = (RenderingHints) this.hints.clone();
 314             }
 315             /* FontInfos are re-used, so must be cloned too, if they
 316              * are valid, and be nulled out if invalid.
 317              * The implied trade-off is that there is more to be gained
 318              * from re-using these objects than is lost by having to
 319              * clone them when the SG2D is cloned.
 320              */
 321             if (this.fontInfo != null) {
 322                 if (this.validFontInfo) {
 323                     g.fontInfo = (FontInfo)this.fontInfo.clone();
 324                 } else {
 325                     g.fontInfo = null;
 326                 }
 327             }
 328             if (this.glyphVectorFontInfo != null) {
 329                 g.glyphVectorFontInfo =
 330                     (FontInfo)this.glyphVectorFontInfo.clone();
 331                 g.glyphVectorFRC = this.glyphVectorFRC;
 332             }
 333             //g.invalidatePipe();
 334             return g;
 335         } catch (CloneNotSupportedException e) {
 336         }
 337         return null;
 338     }
 339 
 340     /**
 341      * Create a new SunGraphics2D based on this one.
 342      */
 343     public Graphics create() {
 344         return (Graphics) clone();
 345     }
 346 
 347     public void setDevClip(int x, int y, int w, int h) {
 348         Region c = constrainClip;
 349         if (c == null) {
 350             devClip = Region.getInstanceXYWH(x, y, w, h);
 351         } else {
 352             devClip = c.getIntersectionXYWH(x, y, w, h);
 353         }
 354         validateCompClip();
 355     }
 356 
 357     public void setDevClip(Rectangle r) {
 358         setDevClip(r.x, r.y, r.width, r.height);
 359     }
 360 
 361     /**
 362      * Constrain rendering for lightweight objects.
 363      */
 364     public void constrain(int x, int y, int w, int h, Region region) {
 365         if ((x | y) != 0) {
 366             translate(x, y);
 367         }
 368         if (transformState &gt; TRANSFORM_TRANSLATESCALE) {
 369             clipRect(0, 0, w, h);
 370             return;
 371         }
 372         // changes parameters according to the current scale and translate.
 373         final double scaleX = transform.getScaleX();
 374         final double scaleY = transform.getScaleY();
 375         x = constrainX = (int) transform.getTranslateX();
 376         y = constrainY = (int) transform.getTranslateY();
 377         w = Region.dimAdd(x, Region.clipScale(w, scaleX));
 378         h = Region.dimAdd(y, Region.clipScale(h, scaleY));
 379 
 380         Region c = constrainClip;
 381         if (c == null) {
 382             c = Region.getInstanceXYXY(x, y, w, h);
 383         } else {
 384             c = c.getIntersectionXYXY(x, y, w, h);
 385         }
 386         if (region != null) {
 387             region = region.getScaledRegion(scaleX, scaleY);
 388             region = region.getTranslatedRegion(x, y);
 389             c = c.getIntersection(region);
 390         }
 391 
 392         if (c == constrainClip) {
 393             // Common case to ignore
 394             return;
 395         }
 396 
 397         constrainClip = c;
 398         if (!devClip.isInsideQuickCheck(c)) {
 399             devClip = devClip.getIntersection(c);
 400             validateCompClip();
 401         }
 402     }
 403 
 404     /**
 405      * Constrain rendering for lightweight objects.
 406      *
 407      * REMIND: This method will back off to the &quot;workaround&quot;
 408      * of using translate and clipRect if the Graphics
 409      * to be constrained has a complex transform.  The
 410      * drawback of the workaround is that the resulting
 411      * clip and device origin cannot be &quot;enforced&quot;.
 412      *
 413      * @exception IllegalStateException If the Graphics
 414      * to be constrained has a complex transform.
 415      */
 416     @Override
 417     public void constrain(int x, int y, int w, int h) {
 418         constrain(x, y, w, h, null);
 419     }
 420 
 421     protected static ValidatePipe invalidpipe = new ValidatePipe();
 422 
 423     /*
 424      * Invalidate the pipeline
 425      */
 426     protected void invalidatePipe() {
 427         drawpipe = invalidpipe;
 428         fillpipe = invalidpipe;
 429         shapepipe = invalidpipe;
 430         textpipe = invalidpipe;
 431         imagepipe = invalidpipe;
 432         loops = null;
 433     }
 434 
 435     public void validatePipe() {
 436         /* This workaround is for the situation when we update the Pipelines
 437          * for invalid SurfaceData and run further code when the current
 438          * pipeline doesn&#39;t support the type of new SurfaceData created during
 439          * the current pipeline&#39;s work (in place of the invalid SurfaceData).
 440          * Usually SurfaceData and Pipelines are repaired (through revalidateAll)
 441          * and called again in the exception handlers */
 442 
 443         if (!surfaceData.isValid()) {
 444             throw new InvalidPipeException(&quot;attempt to validate Pipe with invalid SurfaceData&quot;);
 445         }
 446 
 447         surfaceData.validatePipe(this);
 448     }
 449 
 450     /*
 451      * Intersect two Shapes by the simplest method, attempting to produce
 452      * a simplified result.
 453      * The boolean arguments keep1 and keep2 specify whether or not
 454      * the first or second shapes can be modified during the operation
 455      * or whether that shape must be &quot;kept&quot; unmodified.
 456      */
 457     Shape intersectShapes(Shape s1, Shape s2, boolean keep1, boolean keep2) {
 458         if (s1 instanceof Rectangle &amp;&amp; s2 instanceof Rectangle) {
 459             return ((Rectangle) s1).intersection((Rectangle) s2);
 460         }
 461         if (s1 instanceof Rectangle2D) {
 462             return intersectRectShape((Rectangle2D) s1, s2, keep1, keep2);
 463         } else if (s2 instanceof Rectangle2D) {
 464             return intersectRectShape((Rectangle2D) s2, s1, keep2, keep1);
 465         }
 466         return intersectByArea(s1, s2, keep1, keep2);
 467     }
 468 
 469     /*
 470      * Intersect a Rectangle with a Shape by the simplest method,
 471      * attempting to produce a simplified result.
 472      * The boolean arguments keep1 and keep2 specify whether or not
 473      * the first or second shapes can be modified during the operation
 474      * or whether that shape must be &quot;kept&quot; unmodified.
 475      */
 476     Shape intersectRectShape(Rectangle2D r, Shape s,
 477                              boolean keep1, boolean keep2) {
 478         if (s instanceof Rectangle2D) {
 479             Rectangle2D r2 = (Rectangle2D) s;
 480             Rectangle2D outrect;
 481             if (!keep1) {
 482                 outrect = r;
 483             } else if (!keep2) {
 484                 outrect = r2;
 485             } else {
 486                 outrect = new Rectangle2D.Float();
 487             }
 488             double x1 = Math.max(r.getX(), r2.getX());
 489             double x2 = Math.min(r.getX()  + r.getWidth(),
 490                                  r2.getX() + r2.getWidth());
 491             double y1 = Math.max(r.getY(), r2.getY());
 492             double y2 = Math.min(r.getY()  + r.getHeight(),
 493                                  r2.getY() + r2.getHeight());
 494 
 495             if (((x2 - x1) &lt; 0) || ((y2 - y1) &lt; 0))
 496                 // Width or height is negative. No intersection.
 497                 outrect.setFrameFromDiagonal(0, 0, 0, 0);
 498             else
 499                 outrect.setFrameFromDiagonal(x1, y1, x2, y2);
 500             return outrect;
 501         }
 502         if (r.contains(s.getBounds2D())) {
 503             if (keep2) {
 504                 s = cloneShape(s);
 505             }
 506             return s;
 507         }
 508         return intersectByArea(r, s, keep1, keep2);
 509     }
 510 
 511     protected static Shape cloneShape(Shape s) {
 512         return new GeneralPath(s);
 513     }
 514 
 515     /*
 516      * Intersect two Shapes using the Area class.  Presumably other
 517      * attempts at simpler intersection methods proved fruitless.
 518      * The boolean arguments keep1 and keep2 specify whether or not
 519      * the first or second shapes can be modified during the operation
 520      * or whether that shape must be &quot;kept&quot; unmodified.
 521      * @see #intersectShapes
 522      * @see #intersectRectShape
 523      */
 524     Shape intersectByArea(Shape s1, Shape s2, boolean keep1, boolean keep2) {
 525         Area a1, a2;
 526 
 527         // First see if we can find an overwriteable source shape
 528         // to use as our destination area to avoid duplication.
 529         if (!keep1 &amp;&amp; (s1 instanceof Area)) {
 530             a1 = (Area) s1;
 531         } else if (!keep2 &amp;&amp; (s2 instanceof Area)) {
 532             a1 = (Area) s2;
 533             s2 = s1;
 534         } else {
 535             a1 = new Area(s1);
 536         }
 537 
 538         if (s2 instanceof Area) {
 539             a2 = (Area) s2;
 540         } else {
 541             a2 = new Area(s2);
 542         }
 543 
 544         a1.intersect(a2);
 545         if (a1.isRectangular()) {
 546             return a1.getBounds();
 547         }
 548 
 549         return a1;
 550     }
 551 
 552     /*
 553      * Intersect usrClip bounds and device bounds to determine the composite
 554      * rendering boundaries.
 555      */
 556     public Region getCompClip() {
 557         if (!surfaceData.isValid()) {
 558             // revalidateAll() implicitly recalculcates the composite clip
 559             revalidateAll();
 560         }
 561 
 562         return clipRegion;
 563     }
 564 
 565     public Font getFont() {
 566         if (font == null) {
 567             font = defaultFont;
 568         }
 569         return font;
 570     }
 571 
 572     private static final double[] IDENT_MATRIX = {1, 0, 0, 1};
 573     private static final AffineTransform IDENT_ATX =
 574         new AffineTransform();
 575 
 576     private static final int MINALLOCATED = 8;
 577     private static final int TEXTARRSIZE = 17;
 578     private static double[][] textTxArr = new double[TEXTARRSIZE][];
 579     private static AffineTransform[] textAtArr =
 580         new AffineTransform[TEXTARRSIZE];
 581 
 582     static {
 583         for (int i=MINALLOCATED;i&lt;TEXTARRSIZE;i++) {
 584           textTxArr[i] = new double [] {i, 0, 0, i};
 585           textAtArr[i] = new AffineTransform( textTxArr[i]);
 586         }
 587     }
 588 
 589     // cached state for various draw[String,Char,Byte] optimizations
 590     public FontInfo checkFontInfo(FontInfo info, Font font,
 591                                   FontRenderContext frc) {
 592         /* Do not create a FontInfo object as part of construction of an
 593          * SG2D as its possible it may never be needed - ie if no text
 594          * is drawn using this SG2D.
 595          */
 596         if (info == null) {
 597             info = new FontInfo();
 598         }
 599 
 600         float ptSize = font.getSize2D();
 601         int txFontType;
 602         AffineTransform devAt, textAt=null;
 603         if (font.isTransformed()) {
 604             textAt = font.getTransform();
 605             textAt.scale(ptSize, ptSize);
 606             txFontType = textAt.getType();
 607             info.originX = (float)textAt.getTranslateX();
 608             info.originY = (float)textAt.getTranslateY();
 609             textAt.translate(-info.originX, -info.originY);
 610             if (transformState &gt;= TRANSFORM_TRANSLATESCALE) {
 611                 transform.getMatrix(info.devTx = new double[4]);
 612                 devAt = new AffineTransform(info.devTx);
 613                 textAt.preConcatenate(devAt);
 614             } else {
 615                 info.devTx = IDENT_MATRIX;
 616                 devAt = IDENT_ATX;
 617             }
 618             textAt.getMatrix(info.glyphTx = new double[4]);
 619             double shearx = textAt.getShearX();
 620             double scaley = textAt.getScaleY();
 621             if (shearx != 0) {
 622                 scaley = Math.sqrt(shearx * shearx + scaley * scaley);
 623             }
 624             info.pixelHeight = (int)(Math.abs(scaley)+0.5);
 625         } else {
 626             txFontType = AffineTransform.TYPE_IDENTITY;
 627             info.originX = info.originY = 0;
 628             if (transformState &gt;= TRANSFORM_TRANSLATESCALE) {
 629                 transform.getMatrix(info.devTx = new double[4]);
 630                 devAt = new AffineTransform(info.devTx);
 631                 info.glyphTx = new double[4];
 632                 for (int i = 0; i &lt; 4; i++) {
 633                     info.glyphTx[i] = info.devTx[i] * ptSize;
 634                 }
 635                 textAt = new AffineTransform(info.glyphTx);
 636                 double shearx = transform.getShearX();
 637                 double scaley = transform.getScaleY();
 638                 if (shearx != 0) {
 639                     scaley = Math.sqrt(shearx * shearx + scaley * scaley);
 640                 }
 641                 info.pixelHeight = (int)(Math.abs(scaley * ptSize)+0.5);
 642             } else {
 643                 /* If the double represents a common integral, we
 644                  * may have pre-allocated objects.
 645                  * A &quot;sparse&quot; array be seems to be as fast as a switch
 646                  * even for 3 or 4 pt sizes, and is more flexible.
 647                  * This should perform comparably in single-threaded
 648                  * rendering to the old code which synchronized on the
 649                  * class and scale better on MP systems.
 650                  */
 651                 int pszInt = (int)ptSize;
 652                 if (ptSize == pszInt &amp;&amp;
 653                     pszInt &gt;= MINALLOCATED &amp;&amp; pszInt &lt; TEXTARRSIZE) {
 654                     info.glyphTx = textTxArr[pszInt];
 655                     textAt = textAtArr[pszInt];
 656                     info.pixelHeight = pszInt;
 657                 } else {
 658                     info.pixelHeight = (int)(ptSize+0.5);
 659                 }
 660                 if (textAt == null) {
 661                     info.glyphTx = new double[] {ptSize, 0, 0, ptSize};
 662                     textAt = new AffineTransform(info.glyphTx);
 663                 }
 664 
 665                 info.devTx = IDENT_MATRIX;
 666                 devAt = IDENT_ATX;
 667             }
 668         }
 669 
 670         info.font2D = FontUtilities.getFont2D(font);
 671 
 672         int fmhint = fractionalMetricsHint;
 673         if (fmhint == SunHints.INTVAL_FRACTIONALMETRICS_DEFAULT) {
 674             fmhint = SunHints.INTVAL_FRACTIONALMETRICS_OFF;
 675         }
 676         info.lcdSubPixPos = false; // conditionally set true in LCD mode.
 677 
 678         /* The text anti-aliasing hints that are set by the client need
 679          * to be interpreted for the current state and stored in the
 680          * FontInfo.aahint which is what will actually be used and
 681          * will be one of OFF, ON, LCD_HRGB or LCD_VRGB.
 682          * This is what pipe selection code should typically refer to, not
 683          * textAntialiasHint. This means we are now evaluating the meaning
 684          * of &quot;default&quot; here. Any pipe that really cares about that will
 685          * also need to consult that variable.
 686          * Otherwise these are being used only as args to getStrike,
 687          * and are encapsulated in that object which is part of the
 688          * FontInfo, so we do not need to store them directly as fields
 689          * in the FontInfo object.
 690          * That could change if FontInfo&#39;s were more selectively
 691          * revalidated when graphics state changed. Presently this
 692          * method re-evaluates all fields in the fontInfo.
 693          * The strike doesn&#39;t need to know the RGB subpixel order. Just
 694          * if its H or V orientation, so if an LCD option is specified we
 695          * always pass in the RGB hint to the strike.
 696          * frc is non-null only if this is a GlyphVector. For reasons
 697          * which are probably a historical mistake the AA hint in a GV
 698          * is honoured when we render, overriding the Graphics setting.
 699          */
 700         int aahint;
 701         if (frc == null) {
 702             aahint = textAntialiasHint;
 703         } else {
 704             aahint = ((SunHints.Value)frc.getAntiAliasingHint()).getIndex();
 705         }
 706         if (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT) {
 707             if (antialiasHint == SunHints.INTVAL_ANTIALIAS_ON) {
 708                 aahint = SunHints.INTVAL_TEXT_ANTIALIAS_ON;
 709             } else {
 710                 aahint = SunHints.INTVAL_TEXT_ANTIALIAS_OFF;
 711             }
 712         } else {
 713             /* If we are in checkFontInfo because a rendering hint has been
 714              * set then all pipes are revalidated. But we can also
 715              * be here because setFont() has been called when the &#39;gasp&#39;
 716              * hint is set, as then the font size determines the text pipe.
 717              * See comments in SunGraphics2d.setFont(Font).
 718              */
 719             if (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_GASP) {
 720                 if (info.font2D.useAAForPtSize(info.pixelHeight)) {
 721                     aahint = SunHints.INTVAL_TEXT_ANTIALIAS_ON;
 722                 } else {
 723                     aahint = SunHints.INTVAL_TEXT_ANTIALIAS_OFF;
 724                 }
 725             } else if (aahint &gt;= SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB) {
 726                 /* loops for default rendering modes are installed in the SG2D
 727                  * constructor. If there are none this will be null.
 728                  * Not all compositing modes update the render loops, so
 729                  * we also test that this is a mode we know should support
 730                  * this. One minor issue is that the loops aren&#39;t necessarily
 731                  * installed for a new rendering mode until after this
 732                  * method is called during pipeline validation. So it is
 733                  * theoretically possible that it was set to null for a
 734                  * compositing mode, the composite is then set back to Src,
 735                  * but the loop is still null when this is called and AA=ON
 736                  * is installed instead of an LCD mode.
 737                  * However this is done in the right order in SurfaceData.java
 738                  * so this is not likely to be a problem - but not
 739                  * guaranteed.
 740                  */
 741                 if (
 742                     !surfaceData.canRenderLCDText(this)
 743 //                    loops.drawGlyphListLCDLoop == null ||
 744 //                    compositeState &gt; COMP_ISCOPY ||
 745 //                    paintState &gt; PAINT_ALPHACOLOR
 746                       ) {
 747                     aahint = SunHints.INTVAL_TEXT_ANTIALIAS_ON;
 748                 } else {
 749                     info.lcdRGBOrder = true;
 750                     /* Collapse these into just HRGB or VRGB.
 751                      * Pipe selection code needs only to test for these two.
 752                      * Since these both select the same pipe anyway its
 753                      * tempting to collapse into one value. But they are
 754                      * different strikes (glyph caches) so the distinction
 755                      * needs to be made for that purpose.
 756                      */
 757                     if (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HBGR) {
 758                         aahint = SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB;
 759                         info.lcdRGBOrder = false;
 760                     } else if
 761                         (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_LCD_VBGR) {
 762                         aahint = SunHints.INTVAL_TEXT_ANTIALIAS_LCD_VRGB;
 763                         info.lcdRGBOrder = false;
 764                     }
 765                     /* Support subpixel positioning only for the case in
 766                      * which the horizontal resolution is increased
 767                      */
 768                     info.lcdSubPixPos =
 769                         fmhint == SunHints.INTVAL_FRACTIONALMETRICS_ON &amp;&amp;
 770                         aahint == SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB;
 771                 }
 772             }
 773         }
 774         if (FontUtilities.isMacOSX14 &amp;&amp;
 775             (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_OFF))
 776         {
 777              aahint =  SunHints.INTVAL_TEXT_ANTIALIAS_ON;
 778         }
 779         info.aaHint = aahint;
 780         info.fontStrike = info.font2D.getStrike(font, devAt, textAt,
 781                                                 aahint, fmhint);
 782         return info;
 783     }
 784 
 785     public static boolean isRotated(double [] mtx) {
 786         if ((mtx[0] == mtx[3]) &amp;&amp;
 787             (mtx[1] == 0.0) &amp;&amp;
 788             (mtx[2] == 0.0) &amp;&amp;
 789             (mtx[0] &gt; 0.0))
 790         {
 791             return false;
 792         }
 793 
 794         return true;
 795     }
 796 
 797     public void setFont(Font font) {
 798         /* replacing the reference equality test font != this.font with
 799          * !font.equals(this.font) did not yield any measurable difference
 800          * in testing, but there may be yet to be identified cases where it
 801          * is beneficial.
 802          */
 803         if (font != null &amp;&amp; font!=this.font/*!font.equals(this.font)*/) {
 804             /* In the GASP AA case the textpipe depends on the glyph size
 805              * as determined by graphics and font transforms as well as the
 806              * font size, and information in the font. But we may invalidate
 807              * the pipe only to find that it made no difference.
 808              * Deferring pipe invalidation to checkFontInfo won&#39;t work because
 809              * when called we may already be rendering to the wrong pipe.
 810              * So, if the font is transformed, or the graphics has more than
 811              * a simple scale, we&#39;ll take that as enough of a hint to
 812              * revalidate everything. But if they aren&#39;t we will
 813              * use the font&#39;s point size to query the gasp table and see if
 814              * what it says matches what&#39;s currently being used, in which
 815              * case there&#39;s no need to invalidate the textpipe.
 816              * This should be sufficient for all typical uses cases.
 817              */
 818             if (textAntialiasHint == SunHints.INTVAL_TEXT_ANTIALIAS_GASP &amp;&amp;
 819                 textpipe != invalidpipe &amp;&amp;
 820                 (transformState &gt; TRANSFORM_ANY_TRANSLATE ||
 821                  font.isTransformed() ||
 822                  fontInfo == null || // Precaution, if true shouldn&#39;t get here
 823                  (fontInfo.aaHint == SunHints.INTVAL_TEXT_ANTIALIAS_ON) !=
 824                      FontUtilities.getFont2D(font).
 825                          useAAForPtSize(font.getSize()))) {
 826                 textpipe = invalidpipe;
 827             }
 828             this.font = font;
 829             this.fontMetrics = null;
 830             this.validFontInfo = false;
 831         }
 832     }
 833 
 834     public FontInfo getFontInfo() {
 835         if (!validFontInfo) {
 836             this.fontInfo = checkFontInfo(this.fontInfo, font, null);
 837             validFontInfo = true;
 838         }
 839         return this.fontInfo;
 840     }
 841 
 842     /* Used by drawGlyphVector which specifies its own font. */
 843     public FontInfo getGVFontInfo(Font font, FontRenderContext frc) {
 844         if (glyphVectorFontInfo != null &amp;&amp;
 845             glyphVectorFontInfo.font == font &amp;&amp;
 846             glyphVectorFRC == frc) {
 847             return glyphVectorFontInfo;
 848         } else {
 849             glyphVectorFRC = frc;
 850             return glyphVectorFontInfo =
 851                 checkFontInfo(glyphVectorFontInfo, font, frc);
 852         }
 853     }
 854 
 855     public FontMetrics getFontMetrics() {
 856         if (this.fontMetrics != null) {
 857             return this.fontMetrics;
 858         }
 859         /* NB the constructor and the setter disallow &quot;font&quot; being null */
 860         return this.fontMetrics =
 861            FontDesignMetrics.getMetrics(font, getFontRenderContext());
 862     }
 863 
 864     public FontMetrics getFontMetrics(Font font) {
 865         if ((this.fontMetrics != null) &amp;&amp; (font == this.font)) {
 866             return this.fontMetrics;
 867         }
 868         FontMetrics fm =
 869           FontDesignMetrics.getMetrics(font, getFontRenderContext());
 870 
 871         if (this.font == font) {
 872             this.fontMetrics = fm;
 873         }
 874         return fm;
 875     }
 876 
 877     /**
 878      * Checks to see if a Path intersects the specified Rectangle in device
 879      * space.  The rendering attributes taken into account include the
 880      * clip, transform, and stroke attributes.
 881      * @param rect The area in device space to check for a hit.
 882      * @param s The path to check for a hit.
 883      * @param onStroke Flag to choose between testing the stroked or
 884      * the filled path.
 885      * @return True if there is a hit, false otherwise.
 886      * @see #setStroke
 887      * @see #fill(Shape)
 888      * @see #draw(Shape)
 889      * @see #transform
 890      * @see #setTransform
 891      * @see #clip
 892      * @see #setClip
 893      */
 894     public boolean hit(Rectangle rect, Shape s, boolean onStroke) {
 895         if (onStroke) {
 896             s = stroke.createStrokedShape(s);
 897         }
 898 
 899         s = transformShape(s);
 900         if ((constrainX|constrainY) != 0) {
 901             rect = new Rectangle(rect);
 902             rect.translate(constrainX, constrainY);
 903         }
 904 
 905         return s.intersects(rect);
 906     }
 907 
 908     /**
 909      * Return the ColorModel associated with this Graphics2D.
 910      */
 911     public ColorModel getDeviceColorModel() {
 912         return surfaceData.getColorModel();
 913     }
 914 
 915     /**
 916      * Return the device configuration associated with this Graphics2D.
 917      */
 918     public GraphicsConfiguration getDeviceConfiguration() {
 919         return surfaceData.getDeviceConfiguration();
 920     }
 921 
 922     /**
 923      * Return the SurfaceData object assigned to manage the destination
 924      * drawable surface of this Graphics2D.
 925      */
 926     public SurfaceData getSurfaceData() {
 927         return surfaceData;
 928     }
 929 
 930     /**
 931      * Sets the Composite in the current graphics state. Composite is used
 932      * in all drawing methods such as drawImage, drawString, drawPath,
 933      * and fillPath.  It specifies how new pixels are to be combined with
 934      * the existing pixels on the graphics device in the rendering process.
 935      * @param comp The Composite object to be used for drawing.
 936      * @see java.awt.Graphics#setXORMode
 937      * @see java.awt.Graphics#setPaintMode
 938      * @see AlphaComposite
 939      */
 940     public void setComposite(Composite comp) {
 941         if (composite == comp) {
 942             return;
 943         }
 944         int newCompState;
 945         CompositeType newCompType;
 946         if (comp instanceof AlphaComposite) {
 947             AlphaComposite alphacomp = (AlphaComposite) comp;
 948             newCompType = CompositeType.forAlphaComposite(alphacomp);
 949             if (newCompType == CompositeType.SrcOverNoEa) {
 950                 if (paintState == PAINT_OPAQUECOLOR ||
 951                     (paintState &gt; PAINT_ALPHACOLOR &amp;&amp;
 952                      paint.getTransparency() == Transparency.OPAQUE))
 953                 {
 954                     newCompState = COMP_ISCOPY;
 955                 } else {
 956                     newCompState = COMP_ALPHA;
 957                 }
 958             } else if (newCompType == CompositeType.SrcNoEa ||
 959                        newCompType == CompositeType.Src ||
 960                        newCompType == CompositeType.Clear)
 961             {
 962                 newCompState = COMP_ISCOPY;
 963             } else if (surfaceData.getTransparency() == Transparency.OPAQUE &amp;&amp;
 964                        newCompType == CompositeType.SrcIn)
 965             {
 966                 newCompState = COMP_ISCOPY;
 967             } else {
 968                 newCompState = COMP_ALPHA;
 969             }
 970         } else if (comp instanceof XORComposite) {
 971             newCompState = COMP_XOR;
 972             newCompType = CompositeType.Xor;
 973         } else if (comp == null) {
 974             throw new IllegalArgumentException(&quot;null Composite&quot;);
 975         } else {
 976             surfaceData.checkCustomComposite();
 977             newCompState = COMP_CUSTOM;
 978             newCompType = CompositeType.General;
 979         }
 980         if (compositeState != newCompState ||
 981             imageComp != newCompType)
 982         {
 983             compositeState = newCompState;
 984             imageComp = newCompType;
 985             invalidatePipe();
 986             validFontInfo = false;
 987         }
 988         composite = comp;
 989         if (paintState &lt;= PAINT_ALPHACOLOR) {
 990             validateColor();
 991         }
 992     }
 993 
 994     /**
 995      * Sets the Paint in the current graphics state.
 996      * @param paint The Paint object to be used to generate color in
 997      * the rendering process.
 998      * @see java.awt.Graphics#setColor
 999      * @see GradientPaint
1000      * @see TexturePaint
1001      */
1002     public void setPaint(Paint paint) {
1003         if (paint instanceof Color) {
1004             setColor((Color) paint);
1005             return;
1006         }
1007         if (paint == null || this.paint == paint) {
1008             return;
1009         }
1010         this.paint = paint;
1011         if (imageComp == CompositeType.SrcOverNoEa) {
1012             // special case where compState depends on opacity of paint
1013             if (paint.getTransparency() == Transparency.OPAQUE) {
1014                 if (compositeState != COMP_ISCOPY) {
1015                     compositeState = COMP_ISCOPY;
1016                 }
1017             } else {
1018                 if (compositeState == COMP_ISCOPY) {
1019                     compositeState = COMP_ALPHA;
1020                 }
1021             }
1022         }
1023         Class&lt;? extends Paint&gt; paintClass = paint.getClass();
1024         if (paintClass == GradientPaint.class) {
1025             paintState = PAINT_GRADIENT;
1026         } else if (paintClass == LinearGradientPaint.class) {
1027             paintState = PAINT_LIN_GRADIENT;
1028         } else if (paintClass == RadialGradientPaint.class) {
1029             paintState = PAINT_RAD_GRADIENT;
1030         } else if (paintClass == TexturePaint.class) {
1031             paintState = PAINT_TEXTURE;
1032         } else {
1033             paintState = PAINT_CUSTOM;
1034         }
1035         validFontInfo = false;
1036         invalidatePipe();
1037     }
1038 
1039     static final int NON_UNIFORM_SCALE_MASK =
1040         (AffineTransform.TYPE_GENERAL_TRANSFORM |
1041          AffineTransform.TYPE_GENERAL_SCALE);
1042     public static final double MinPenSizeAA =
1043         sun.java2d.pipe.RenderingEngine.getInstance().getMinimumAAPenSize();
1044     public static final double MinPenSizeAASquared =
1045         (MinPenSizeAA * MinPenSizeAA);
1046     // Since inaccuracies in the trig package can cause us to
1047     // calculated a rotated pen width of just slightly greater
1048     // than 1.0, we add a fudge factor to our comparison value
1049     // here so that we do not misclassify single width lines as
1050     // wide lines under certain rotations.
1051     public static final double MinPenSizeSquared = 1.000000001;
1052 
1053     private void validateBasicStroke(BasicStroke bs) {
1054         boolean aa = (antialiasHint == SunHints.INTVAL_ANTIALIAS_ON);
1055         if (transformState &lt; TRANSFORM_TRANSLATESCALE) {
1056             if (aa) {
1057                 if (bs.getLineWidth() &lt;= MinPenSizeAA) {
1058                     if (bs.getDashArray() == null) {
1059                         strokeState = STROKE_THIN;
1060                     } else {
1061                         strokeState = STROKE_THINDASHED;
1062                     }
1063                 } else {
1064                     strokeState = STROKE_WIDE;
1065                 }
1066             } else {
1067                 if (bs == defaultStroke) {
1068                     strokeState = STROKE_THIN;
1069                 } else if (bs.getLineWidth() &lt;= 1.0f) {
1070                     if (bs.getDashArray() == null) {
1071                         strokeState = STROKE_THIN;
1072                     } else {
1073                         strokeState = STROKE_THINDASHED;
1074                     }
1075                 } else {
1076                     strokeState = STROKE_WIDE;
1077                 }
1078             }
1079         } else {
1080             double widthsquared;
1081             if ((transform.getType() &amp; NON_UNIFORM_SCALE_MASK) == 0) {
1082                 /* sqrt omitted, compare to squared limits below. */
1083                 widthsquared = Math.abs(transform.getDeterminant());
1084             } else {
1085                 /* First calculate the &quot;maximum scale&quot; of this transform. */
1086                 double A = transform.getScaleX();       // m00
1087                 double C = transform.getShearX();       // m01
1088                 double B = transform.getShearY();       // m10
1089                 double D = transform.getScaleY();       // m11
1090 
1091                 /*
1092                  * Given a 2 x 2 affine matrix [ A B ] such that
1093                  *                             [ C D ]
1094                  * v&#39; = [x&#39; y&#39;] = [Ax + Cy, Bx + Dy], we want to
1095                  * find the maximum magnitude (norm) of the vector v&#39;
1096                  * with the constraint (x^2 + y^2 = 1).
1097                  * The equation to maximize is
1098                  *     |v&#39;| = sqrt((Ax+Cy)^2+(Bx+Dy)^2)
1099                  * or  |v&#39;| = sqrt((AA+BB)x^2 + 2(AC+BD)xy + (CC+DD)y^2).
1100                  * Since sqrt is monotonic we can maximize |v&#39;|^2
1101                  * instead and plug in the substitution y = sqrt(1 - x^2).
1102                  * Trigonometric equalities can then be used to get
1103                  * rid of most of the sqrt terms.
1104                  */
1105                 double EA = A*A + B*B;          // x^2 coefficient
1106                 double EB = 2*(A*C + B*D);      // xy coefficient
1107                 double EC = C*C + D*D;          // y^2 coefficient
1108 
1109                 /*
1110                  * There is a lot of calculus omitted here.
1111                  *
1112                  * Conceptually, in the interests of understanding the
1113                  * terms that the calculus produced we can consider
1114                  * that EA and EC end up providing the lengths along
1115                  * the major axes and the hypot term ends up being an
1116                  * adjustment for the additional length along the off-axis
1117                  * angle of rotated or sheared ellipses as well as an
1118                  * adjustment for the fact that the equation below
1119                  * averages the two major axis lengths.  (Notice that
1120                  * the hypot term contains a part which resolves to the
1121                  * difference of these two axis lengths in the absence
1122                  * of rotation.)
1123                  *
1124                  * In the calculus, the ratio of the EB and (EA-EC) terms
1125                  * ends up being the tangent of 2*theta where theta is
1126                  * the angle that the long axis of the ellipse makes
1127                  * with the horizontal axis.  Thus, this equation is
1128                  * calculating the length of the hypotenuse of a triangle
1129                  * along that axis.
1130                  */
1131                 double hypot = Math.sqrt(EB*EB + (EA-EC)*(EA-EC));
1132 
1133                 /* sqrt omitted, compare to squared limits below. */
1134                 widthsquared = ((EA + EC + hypot)/2.0);
1135             }
1136             if (bs != defaultStroke) {
1137                 widthsquared *= bs.getLineWidth() * bs.getLineWidth();
1138             }
1139             if (widthsquared &lt;=
1140                 (aa ? MinPenSizeAASquared : MinPenSizeSquared))
1141             {
1142                 if (bs.getDashArray() == null) {
1143                     strokeState = STROKE_THIN;
1144                 } else {
1145                     strokeState = STROKE_THINDASHED;
1146                 }
1147             } else {
1148                 strokeState = STROKE_WIDE;
1149             }
1150         }
1151     }
1152 
1153     /*
1154      * Sets the Stroke in the current graphics state.
1155      * @param s The Stroke object to be used to stroke a Path in
1156      * the rendering process.
1157      * @see BasicStroke
1158      */
1159     public void setStroke(Stroke s) {
1160         if (s == null) {
1161             throw new IllegalArgumentException(&quot;null Stroke&quot;);
1162         }
1163         int saveStrokeState = strokeState;
1164         stroke = s;
1165         if (s instanceof BasicStroke) {
1166             validateBasicStroke((BasicStroke) s);
1167         } else {
1168             strokeState = STROKE_CUSTOM;
1169         }
1170         if (strokeState != saveStrokeState) {
1171             invalidatePipe();
1172         }
1173     }
1174 
1175     /**
1176      * Sets the preferences for the rendering algorithms.
1177      * Hint categories include controls for rendering quality and
1178      * overall time/quality trade-off in the rendering process.
1179      * @param hintKey The key of hint to be set. The strings are
1180      * defined in the RenderingHints class.
1181      * @param hintValue The value indicating preferences for the specified
1182      * hint category. These strings are defined in the RenderingHints
1183      * class.
1184      * @see RenderingHints
1185      */
1186     public void setRenderingHint(Key hintKey, Object hintValue) {
1187         // If we recognize the key, we must recognize the value
1188         //     otherwise throw an IllegalArgumentException
1189         //     and do not change the Hints object
1190         // If we do not recognize the key, just pass it through
1191         //     to the Hints object untouched
1192         if (!hintKey.isCompatibleValue(hintValue)) {
1193             throw new IllegalArgumentException
1194                 (hintValue+&quot; is not compatible with &quot;+hintKey);
1195         }
1196         if (hintKey instanceof SunHints.Key) {
1197             boolean stateChanged;
1198             boolean textStateChanged = false;
1199             boolean recognized = true;
1200             SunHints.Key sunKey = (SunHints.Key) hintKey;
1201             int newHint;
1202             if (sunKey == SunHints.KEY_TEXT_ANTIALIAS_LCD_CONTRAST) {
1203                 newHint = ((Integer)hintValue).intValue();
1204             } else {
1205                 newHint = ((SunHints.Value) hintValue).getIndex();
1206             }
1207             switch (sunKey.getIndex()) {
1208             case SunHints.INTKEY_RENDERING:
1209                 stateChanged = (renderHint != newHint);
1210                 if (stateChanged) {
1211                     renderHint = newHint;
1212                     if (interpolationHint == -1) {
1213                         interpolationType =
1214                             (newHint == SunHints.INTVAL_RENDER_QUALITY
1215                              ? AffineTransformOp.TYPE_BILINEAR
1216                              : AffineTransformOp.TYPE_NEAREST_NEIGHBOR);
1217                     }
1218                 }
1219                 break;
1220             case SunHints.INTKEY_ANTIALIASING:
1221                 stateChanged = (antialiasHint != newHint);
1222                 antialiasHint = newHint;
1223                 if (stateChanged) {
1224                     textStateChanged =
1225                         (textAntialiasHint ==
1226                          SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT);
1227                     if (strokeState != STROKE_CUSTOM) {
1228                         validateBasicStroke((BasicStroke) stroke);
1229                     }
1230                 }
1231                 break;
1232             case SunHints.INTKEY_TEXT_ANTIALIASING:
1233                 stateChanged = (textAntialiasHint != newHint);
1234                 textStateChanged = stateChanged;
1235                 textAntialiasHint = newHint;
1236                 break;
1237             case SunHints.INTKEY_FRACTIONALMETRICS:
1238                 stateChanged = (fractionalMetricsHint != newHint);
1239                 textStateChanged = stateChanged;
1240                 fractionalMetricsHint = newHint;
1241                 break;
1242             case SunHints.INTKEY_AATEXT_LCD_CONTRAST:
1243                 stateChanged = false;
1244                 /* Already have validated it is an int 100 &lt;= newHint &lt;= 250 */
1245                 lcdTextContrast = newHint;
1246                 break;
1247             case SunHints.INTKEY_INTERPOLATION:
1248                 interpolationHint = newHint;
1249                 switch (newHint) {
1250                 case SunHints.INTVAL_INTERPOLATION_BICUBIC:
1251                     newHint = AffineTransformOp.TYPE_BICUBIC;
1252                     break;
1253                 case SunHints.INTVAL_INTERPOLATION_BILINEAR:
1254                     newHint = AffineTransformOp.TYPE_BILINEAR;
1255                     break;
1256                 default:
1257                 case SunHints.INTVAL_INTERPOLATION_NEAREST_NEIGHBOR:
1258                     newHint = AffineTransformOp.TYPE_NEAREST_NEIGHBOR;
1259                     break;
1260                 }
1261                 stateChanged = (interpolationType != newHint);
1262                 interpolationType = newHint;
1263                 break;
1264             case SunHints.INTKEY_STROKE_CONTROL:
1265                 stateChanged = (strokeHint != newHint);
1266                 strokeHint = newHint;
1267                 break;
1268             case SunHints.INTKEY_RESOLUTION_VARIANT:
1269                 stateChanged = (resolutionVariantHint != newHint);
1270                 resolutionVariantHint = newHint;
1271                 break;
1272             default:
1273                 recognized = false;
1274                 stateChanged = false;
1275                 break;
1276             }
1277             if (recognized) {
1278                 if (stateChanged) {
1279                     invalidatePipe();
1280                     if (textStateChanged) {
1281                         fontMetrics = null;
1282                         this.cachedFRC = null;
1283                         validFontInfo = false;
1284                         this.glyphVectorFontInfo = null;
1285                     }
1286                 }
1287                 if (hints != null) {
1288                     hints.put(hintKey, hintValue);
1289                 }
1290                 return;
1291             }
1292         }
1293         // Nothing we recognize so none of &quot;our state&quot; has changed
1294         if (hints == null) {
1295             hints = makeHints(null);
1296         }
1297         hints.put(hintKey, hintValue);
1298     }
1299 
1300 
1301     /**
1302      * Returns the preferences for the rendering algorithms.
1303      * @param hintKey The category of hint to be set. The strings
1304      * are defined in the RenderingHints class.
1305      * @return The preferences for rendering algorithms. The strings
1306      * are defined in the RenderingHints class.
1307      * @see RenderingHints
1308      */
1309     public Object getRenderingHint(Key hintKey) {
1310         if (hints != null) {
1311             return hints.get(hintKey);
1312         }
1313         if (!(hintKey instanceof SunHints.Key)) {
1314             return null;
1315         }
1316         int keyindex = ((SunHints.Key)hintKey).getIndex();
1317         switch (keyindex) {
1318         case SunHints.INTKEY_RENDERING:
1319             return SunHints.Value.get(SunHints.INTKEY_RENDERING,
1320                                       renderHint);
1321         case SunHints.INTKEY_ANTIALIASING:
1322             return SunHints.Value.get(SunHints.INTKEY_ANTIALIASING,
1323                                       antialiasHint);
1324         case SunHints.INTKEY_TEXT_ANTIALIASING:
1325             return SunHints.Value.get(SunHints.INTKEY_TEXT_ANTIALIASING,
1326                                       textAntialiasHint);
1327         case SunHints.INTKEY_FRACTIONALMETRICS:
1328             return SunHints.Value.get(SunHints.INTKEY_FRACTIONALMETRICS,
1329                                       fractionalMetricsHint);
1330         case SunHints.INTKEY_AATEXT_LCD_CONTRAST:
1331             return lcdTextContrast;
1332         case SunHints.INTKEY_INTERPOLATION:
1333             switch (interpolationHint) {
1334             case SunHints.INTVAL_INTERPOLATION_NEAREST_NEIGHBOR:
1335                 return SunHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR;
1336             case SunHints.INTVAL_INTERPOLATION_BILINEAR:
1337                 return SunHints.VALUE_INTERPOLATION_BILINEAR;
1338             case SunHints.INTVAL_INTERPOLATION_BICUBIC:
1339                 return SunHints.VALUE_INTERPOLATION_BICUBIC;
1340             }
1341             return null;
1342         case SunHints.INTKEY_STROKE_CONTROL:
1343             return SunHints.Value.get(SunHints.INTKEY_STROKE_CONTROL,
1344                                       strokeHint);
1345         case SunHints.INTKEY_RESOLUTION_VARIANT:
1346             return SunHints.Value.get(SunHints.INTKEY_RESOLUTION_VARIANT,
1347                                       resolutionVariantHint);
1348         }
1349         return null;
1350     }
1351 
1352     /**
1353      * Sets the preferences for the rendering algorithms.
1354      * Hint categories include controls for rendering quality and
1355      * overall time/quality trade-off in the rendering process.
1356      * @param hints The rendering hints to be set
1357      * @see RenderingHints
1358      */
1359     public void setRenderingHints(Map&lt;?,?&gt; hints) {
1360         this.hints = null;
1361         renderHint = SunHints.INTVAL_RENDER_DEFAULT;
1362         antialiasHint = SunHints.INTVAL_ANTIALIAS_OFF;
1363         textAntialiasHint = SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT;
1364         fractionalMetricsHint = SunHints.INTVAL_FRACTIONALMETRICS_OFF;
1365         lcdTextContrast = lcdTextContrastDefaultValue;
1366         interpolationHint = -1;
1367         interpolationType = AffineTransformOp.TYPE_NEAREST_NEIGHBOR;
1368         boolean customHintPresent = false;
1369         Iterator&lt;?&gt; iter = hints.keySet().iterator();
1370         while (iter.hasNext()) {
1371             Object key = iter.next();
1372             if (key == SunHints.KEY_RENDERING ||
1373                 key == SunHints.KEY_ANTIALIASING ||
1374                 key == SunHints.KEY_TEXT_ANTIALIASING ||
1375                 key == SunHints.KEY_FRACTIONALMETRICS ||
1376                 key == SunHints.KEY_TEXT_ANTIALIAS_LCD_CONTRAST ||
1377                 key == SunHints.KEY_STROKE_CONTROL ||
1378                 key == SunHints.KEY_INTERPOLATION)
1379             {
1380                 setRenderingHint((Key) key, hints.get(key));
1381             } else {
1382                 customHintPresent = true;
1383             }
1384         }
1385         if (customHintPresent) {
1386             this.hints = makeHints(hints);
1387         }
1388         invalidatePipe();
1389     }
1390 
1391     /**
1392      * Adds a number of preferences for the rendering algorithms.
1393      * Hint categories include controls for rendering quality and
1394      * overall time/quality trade-off in the rendering process.
1395      * @param hints The rendering hints to be set
1396      * @see RenderingHints
1397      */
1398     public void addRenderingHints(Map&lt;?,?&gt; hints) {
1399         boolean customHintPresent = false;
1400         Iterator&lt;?&gt; iter = hints.keySet().iterator();
1401         while (iter.hasNext()) {
1402             Object key = iter.next();
1403             if (key == SunHints.KEY_RENDERING ||
1404                 key == SunHints.KEY_ANTIALIASING ||
1405                 key == SunHints.KEY_TEXT_ANTIALIASING ||
1406                 key == SunHints.KEY_FRACTIONALMETRICS ||
1407                 key == SunHints.KEY_TEXT_ANTIALIAS_LCD_CONTRAST ||
1408                 key == SunHints.KEY_STROKE_CONTROL ||
1409                 key == SunHints.KEY_INTERPOLATION)
1410             {
1411                 setRenderingHint((Key) key, hints.get(key));
1412             } else {
1413                 customHintPresent = true;
1414             }
1415         }
1416         if (customHintPresent) {
1417             if (this.hints == null) {
1418                 this.hints = makeHints(hints);
1419             } else {
1420                 this.hints.putAll(hints);
1421             }
1422         }
1423     }
1424 
1425     /**
1426      * Gets the preferences for the rendering algorithms.
1427      * Hint categories include controls for rendering quality and
1428      * overall time/quality trade-off in the rendering process.
1429      * @see RenderingHints
1430      */
1431     public RenderingHints getRenderingHints() {
1432         if (hints == null) {
1433             return makeHints(null);
1434         } else {
1435             return (RenderingHints) hints.clone();
1436         }
1437     }
1438 
1439     RenderingHints makeHints(Map&lt;?,?&gt; hints) {
1440         RenderingHints model = new RenderingHints(null);
1441         if (hints != null) {
1442             model.putAll(hints);
1443         }
1444         model.put(SunHints.KEY_RENDERING,
1445                   SunHints.Value.get(SunHints.INTKEY_RENDERING,
1446                                      renderHint));
1447         model.put(SunHints.KEY_ANTIALIASING,
1448                   SunHints.Value.get(SunHints.INTKEY_ANTIALIASING,
1449                                      antialiasHint));
1450         model.put(SunHints.KEY_TEXT_ANTIALIASING,
1451                   SunHints.Value.get(SunHints.INTKEY_TEXT_ANTIALIASING,
1452                                      textAntialiasHint));
1453         model.put(SunHints.KEY_FRACTIONALMETRICS,
1454                   SunHints.Value.get(SunHints.INTKEY_FRACTIONALMETRICS,
1455                                      fractionalMetricsHint));
1456         model.put(SunHints.KEY_TEXT_ANTIALIAS_LCD_CONTRAST,
1457                   Integer.valueOf(lcdTextContrast));
1458         Object value;
1459         switch (interpolationHint) {
1460         case SunHints.INTVAL_INTERPOLATION_NEAREST_NEIGHBOR:
1461             value = SunHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR;
1462             break;
1463         case SunHints.INTVAL_INTERPOLATION_BILINEAR:
1464             value = SunHints.VALUE_INTERPOLATION_BILINEAR;
1465             break;
1466         case SunHints.INTVAL_INTERPOLATION_BICUBIC:
1467             value = SunHints.VALUE_INTERPOLATION_BICUBIC;
1468             break;
1469         default:
1470             value = null;
1471             break;
1472         }
1473         if (value != null) {
1474             model.put(SunHints.KEY_INTERPOLATION, value);
1475         }
1476         model.put(SunHints.KEY_STROKE_CONTROL,
1477                   SunHints.Value.get(SunHints.INTKEY_STROKE_CONTROL,
1478                                      strokeHint));
1479         return model;
1480     }
1481 
1482     /**
1483      * Concatenates the current transform of this Graphics2D with a
1484      * translation transformation.
1485      * This is equivalent to calling transform(T), where T is an
1486      * AffineTransform represented by the following matrix:
1487      * &lt;pre&gt;
1488      *          [   1    0    tx  ]
1489      *          [   0    1    ty  ]
1490      *          [   0    0    1   ]
1491      * &lt;/pre&gt;
1492      */
1493     public void translate(double tx, double ty) {
1494         transform.translate(tx, ty);
1495         invalidateTransform();
1496     }
1497 
1498     /**
1499      * Concatenates the current transform of this Graphics2D with a
1500      * rotation transformation.
1501      * This is equivalent to calling transform(R), where R is an
1502      * AffineTransform represented by the following matrix:
1503      * &lt;pre&gt;
1504      *          [   cos(theta)    -sin(theta)    0   ]
1505      *          [   sin(theta)     cos(theta)    0   ]
1506      *          [       0              0         1   ]
1507      * &lt;/pre&gt;
1508      * Rotating with a positive angle theta rotates points on the positive
1509      * x axis toward the positive y axis.
1510      * @param theta The angle of rotation in radians.
1511      */
1512     public void rotate(double theta) {
1513         transform.rotate(theta);
1514         invalidateTransform();
1515     }
1516 
1517     /**
1518      * Concatenates the current transform of this Graphics2D with a
1519      * translated rotation transformation.
1520      * This is equivalent to the following sequence of calls:
1521      * &lt;pre&gt;
1522      *          translate(x, y);
1523      *          rotate(theta);
1524      *          translate(-x, -y);
1525      * &lt;/pre&gt;
1526      * Rotating with a positive angle theta rotates points on the positive
1527      * x axis toward the positive y axis.
1528      * @param theta The angle of rotation in radians.
1529      * @param x The x coordinate of the origin of the rotation
1530      * @param y The x coordinate of the origin of the rotation
1531      */
1532     public void rotate(double theta, double x, double y) {
1533         transform.rotate(theta, x, y);
1534         invalidateTransform();
1535     }
1536 
1537     /**
1538      * Concatenates the current transform of this Graphics2D with a
1539      * scaling transformation.
1540      * This is equivalent to calling transform(S), where S is an
1541      * AffineTransform represented by the following matrix:
1542      * &lt;pre&gt;
1543      *          [   sx   0    0   ]
1544      *          [   0    sy   0   ]
1545      *          [   0    0    1   ]
1546      * &lt;/pre&gt;
1547      */
1548     public void scale(double sx, double sy) {
1549         transform.scale(sx, sy);
1550         invalidateTransform();
1551     }
1552 
1553     /**
1554      * Concatenates the current transform of this Graphics2D with a
1555      * shearing transformation.
1556      * This is equivalent to calling transform(SH), where SH is an
1557      * AffineTransform represented by the following matrix:
1558      * &lt;pre&gt;
1559      *          [   1   shx   0   ]
1560      *          [  shy   1    0   ]
1561      *          [   0    0    1   ]
1562      * &lt;/pre&gt;
1563      * @param shx The factor by which coordinates are shifted towards the
1564      * positive X axis direction according to their Y coordinate
1565      * @param shy The factor by which coordinates are shifted towards the
1566      * positive Y axis direction according to their X coordinate
1567      */
1568     public void shear(double shx, double shy) {
1569         transform.shear(shx, shy);
1570         invalidateTransform();
1571     }
1572 
1573     /**
1574      * Composes a Transform object with the transform in this
1575      * Graphics2D according to the rule last-specified-first-applied.
1576      * If the currrent transform is Cx, the result of composition
1577      * with Tx is a new transform Cx&#39;.  Cx&#39; becomes the current
1578      * transform for this Graphics2D.
1579      * Transforming a point p by the updated transform Cx&#39; is
1580      * equivalent to first transforming p by Tx and then transforming
1581      * the result by the original transform Cx.  In other words,
1582      * Cx&#39;(p) = Cx(Tx(p)).
1583      * A copy of the Tx is made, if necessary, so further
1584      * modifications to Tx do not affect rendering.
1585      * @param xform The Transform object to be composed with the current
1586      * transform.
1587      * @see #setTransform
1588      * @see AffineTransform
1589      */
1590     public void transform(AffineTransform xform) {
1591         this.transform.concatenate(xform);
1592         invalidateTransform();
1593     }
1594 
1595     /**
1596      * Translate
1597      */
1598     public void translate(int x, int y) {
1599         transform.translate(x, y);
1600         if (transformState &lt;= TRANSFORM_INT_TRANSLATE) {
1601             transX += x;
1602             transY += y;
1603             transformState = (((transX | transY) == 0) ?
1604                               TRANSFORM_ISIDENT : TRANSFORM_INT_TRANSLATE);
1605         } else {
1606             invalidateTransform();
1607         }
1608     }
1609 
1610     /**
1611      * Sets the Transform in the current graphics state.
1612      * @param Tx The Transform object to be used in the rendering process.
1613      * @see #transform
1614      * @see AffineTransform
1615      */
1616     @Override
1617     public void setTransform(AffineTransform Tx) {
1618         if ((constrainX | constrainY) == 0) {
1619             transform.setTransform(Tx);
1620         } else {
1621             transform.setToTranslation(constrainX, constrainY);
1622             transform.concatenate(Tx);
1623         }
1624         invalidateTransform();
1625     }
1626 
1627     protected void invalidateTransform() {
1628         int type = transform.getType();
1629         int origTransformState = transformState;
1630         if (type == AffineTransform.TYPE_IDENTITY) {
1631             transformState = TRANSFORM_ISIDENT;
1632             transX = transY = 0;
1633         } else if (type == AffineTransform.TYPE_TRANSLATION) {
1634             double dtx = transform.getTranslateX();
1635             double dty = transform.getTranslateY();
1636             transX = (int) Math.floor(dtx + 0.5);
1637             transY = (int) Math.floor(dty + 0.5);
1638             if (dtx == transX &amp;&amp; dty == transY) {
1639                 transformState = TRANSFORM_INT_TRANSLATE;
1640             } else {
1641                 transformState = TRANSFORM_ANY_TRANSLATE;
1642             }
1643         } else if ((type &amp; (AffineTransform.TYPE_FLIP |
1644                             AffineTransform.TYPE_MASK_ROTATION |
1645                             AffineTransform.TYPE_GENERAL_TRANSFORM)) == 0)
1646         {
1647             transformState = TRANSFORM_TRANSLATESCALE;
1648             transX = transY = 0;
1649         } else {
1650             transformState = TRANSFORM_GENERIC;
1651             transX = transY = 0;
1652         }
1653 
1654         if (transformState &gt;= TRANSFORM_TRANSLATESCALE ||
1655             origTransformState &gt;= TRANSFORM_TRANSLATESCALE)
1656         {
1657             /* Its only in this case that the previous or current transform
1658              * was more than a translate that font info is invalidated
1659              */
1660             cachedFRC = null;
1661             this.validFontInfo = false;
1662             this.fontMetrics = null;
1663             this.glyphVectorFontInfo = null;
1664 
1665             if (transformState != origTransformState) {
1666                 invalidatePipe();
1667             }
1668         }
1669         if (strokeState != STROKE_CUSTOM) {
1670             validateBasicStroke((BasicStroke) stroke);
1671         }
1672     }
1673 
1674     /**
1675      * Returns the current Transform in the Graphics2D state.
1676      * @see #transform
1677      * @see #setTransform
1678      */
1679     @Override
1680     public AffineTransform getTransform() {
1681         if ((constrainX | constrainY) == 0) {
1682             return new AffineTransform(transform);
1683         }
1684         AffineTransform tx
1685                 = AffineTransform.getTranslateInstance(-constrainX, -constrainY);
1686         tx.concatenate(transform);
1687         return tx;
1688     }
1689 
1690     /**
1691      * Returns the current Transform ignoring the &quot;constrain&quot;
1692      * rectangle.
1693      */
1694     public AffineTransform cloneTransform() {
1695         return new AffineTransform(transform);
1696     }
1697 
1698     /**
1699      * Returns the current Paint in the Graphics2D state.
1700      * @see #setPaint
1701      * @see java.awt.Graphics#setColor
1702      */
1703     public Paint getPaint() {
1704         return paint;
1705     }
1706 
1707     /**
1708      * Returns the current Composite in the Graphics2D state.
1709      * @see #setComposite
1710      */
1711     public Composite getComposite() {
1712         return composite;
1713     }
1714 
1715     public Color getColor() {
1716         return foregroundColor;
1717     }
1718 
1719     /*
1720      * Validate the eargb and pixel fields against the current color.
1721      *
1722      * The eargb field must take into account the extraAlpha
1723      * value of an AlphaComposite.  It may also take into account
1724      * the Fsrc Porter-Duff blending function if such a function is
1725      * a constant (see handling of Clear mode below).  For instance,
1726      * by factoring in the (Fsrc == 0) state of the Clear mode we can
1727      * use a SrcNoEa loop just as easily as a general Alpha loop
1728      * since the math will be the same in both cases.
1729      *
1730      * The pixel field will always be the best pixel data choice for
1731      * the final result of all calculations applied to the eargb field.
1732      *
1733      * Note that this method is only necessary under the following
1734      * conditions:
1735      *     (paintState &lt;= PAINT_ALPHA_COLOR &amp;&amp;
1736      *      compositeState &lt;= COMP_CUSTOM)
1737      * though nothing bad will happen if it is run in other states.
1738      */
1739     void validateColor() {
1740         int eargb;
1741         if (imageComp == CompositeType.Clear) {
1742             eargb = 0;
1743         } else {
1744             eargb = foregroundColor.getRGB();
1745             if (compositeState &lt;= COMP_ALPHA &amp;&amp;
1746                 imageComp != CompositeType.SrcNoEa &amp;&amp;
1747                 imageComp != CompositeType.SrcOverNoEa)
1748             {
1749                 AlphaComposite alphacomp = (AlphaComposite) composite;
1750                 int a = Math.round(alphacomp.getAlpha() * (eargb &gt;&gt;&gt; 24));
1751                 eargb = (eargb &amp; 0x00ffffff) | (a &lt;&lt; 24);
1752             }
1753         }
1754         this.eargb = eargb;
1755         this.pixel = surfaceData.pixelFor(eargb);
1756     }
1757 
1758     public void setColor(Color color) {
1759         if (color == null || color == paint) {
1760             return;
1761         }
1762         this.paint = foregroundColor = color;
1763         validateColor();
1764         if ((eargb &gt;&gt; 24) == -1) {
1765             if (paintState == PAINT_OPAQUECOLOR) {
1766                 return;
1767             }
1768             paintState = PAINT_OPAQUECOLOR;
1769             if (imageComp == CompositeType.SrcOverNoEa) {
1770                 // special case where compState depends on opacity of paint
1771                 compositeState = COMP_ISCOPY;
1772             }
1773         } else {
1774             if (paintState == PAINT_ALPHACOLOR) {
1775                 return;
1776             }
1777             paintState = PAINT_ALPHACOLOR;
1778             if (imageComp == CompositeType.SrcOverNoEa) {
1779                 // special case where compState depends on opacity of paint
1780                 compositeState = COMP_ALPHA;
1781             }
1782         }
1783         validFontInfo = false;
1784         invalidatePipe();
1785     }
1786 
1787     /**
1788      * Sets the background color in this context used for clearing a region.
1789      * When Graphics2D is constructed for a component, the backgroung color is
1790      * inherited from the component. Setting the background color in the
1791      * Graphics2D context only affects the subsequent clearRect() calls and
1792      * not the background color of the component. To change the background
1793      * of the component, use appropriate methods of the component.
1794      * @param color The background color that should be used in
1795      * subsequent calls to clearRect().
1796      * @see #getBackground
1797      * @see Graphics#clearRect
1798      */
1799     public void setBackground(Color color) {
1800         backgroundColor = color;
1801     }
1802 
1803     /**
1804      * Returns the background color used for clearing a region.
1805      * @see #setBackground
1806      */
1807     public Color getBackground() {
1808         return backgroundColor;
1809     }
1810 
1811     /**
1812      * Returns the current Stroke in the Graphics2D state.
1813      * @see #setStroke
1814      */
1815     public Stroke getStroke() {
1816         return stroke;
1817     }
1818 
1819     public Rectangle getClipBounds() {
1820         if (clipState == CLIP_DEVICE) {
1821             return null;
1822         }
1823         return getClipBounds(new Rectangle());
1824     }
1825 
1826     public Rectangle getClipBounds(Rectangle r) {
1827         if (clipState != CLIP_DEVICE) {
1828             if (transformState &lt;= TRANSFORM_INT_TRANSLATE) {
1829                 if (usrClip instanceof Rectangle) {
1830                     r.setBounds((Rectangle) usrClip);
1831                 } else {
1832                     r.setFrame(usrClip.getBounds2D());
1833                 }
1834                 r.translate(-transX, -transY);
1835             } else {
1836                 r.setFrame(getClip().getBounds2D());
1837             }
1838         } else if (r == null) {
1839             throw new NullPointerException(&quot;null rectangle parameter&quot;);
1840         }
1841         return r;
1842     }
1843 
1844     public boolean hitClip(int x, int y, int width, int height) {
1845         if (width &lt;= 0 || height &lt;= 0) {
1846             return false;
1847         }
1848         if (transformState &gt; TRANSFORM_INT_TRANSLATE) {
1849             // Note: Technically the most accurate test would be to
1850             // raster scan the parallelogram of the transformed rectangle
1851             // and do a span for span hit test against the clip, but for
1852             // speed we approximate the test with a bounding box of the
1853             // transformed rectangle.  The cost of rasterizing the
1854             // transformed rectangle is probably high enough that it is
1855             // not worth doing so to save the caller from having to call
1856             // a rendering method where we will end up discovering the
1857             // same answer in about the same amount of time anyway.
1858             // This logic breaks down if this hit test is being performed
1859             // on the bounds of a group of shapes in which case it might
1860             // be beneficial to be a little more accurate to avoid lots
1861             // of subsequent rendering calls.  In either case, this relaxed
1862             // test should not be significantly less accurate than the
1863             // optimal test for most transforms and so the conservative
1864             // answer should not cause too much extra work.
1865 
1866             double[] d = {
1867                 x, y,
1868                 x+width, y,
1869                 x, y+height,
1870                 x+width, y+height
1871             };
1872             transform.transform(d, 0, d, 0, 4);
1873             x = (int) Math.floor(Math.min(Math.min(d[0], d[2]),
1874                                           Math.min(d[4], d[6])));
1875             y = (int) Math.floor(Math.min(Math.min(d[1], d[3]),
1876                                           Math.min(d[5], d[7])));
1877             width = (int) Math.ceil(Math.max(Math.max(d[0], d[2]),
1878                                              Math.max(d[4], d[6])));
1879             height = (int) Math.ceil(Math.max(Math.max(d[1], d[3]),
1880                                               Math.max(d[5], d[7])));
1881         } else {
1882             x += transX;
1883             y += transY;
1884             width += x;
1885             height += y;
1886         }
1887 
1888         try {
1889             if (!getCompClip().intersectsQuickCheckXYXY(x, y, width, height)) {
1890                 return false;
1891             }
1892         } catch (InvalidPipeException e) {
1893             return false;
1894         }
1895         // REMIND: We could go one step further here and examine the
1896         // non-rectangular clip shape more closely if there is one.
1897         // Since the clip has already been rasterized, the performance
1898         // penalty of doing the scan is probably still within the bounds
1899         // of a good tradeoff between speed and quality of the answer.
1900         return true;
1901     }
1902 
1903     protected void validateCompClip() {
1904         int origClipState = clipState;
1905         if (usrClip == null) {
1906             clipState = CLIP_DEVICE;
1907             clipRegion = devClip;
1908         } else if (usrClip instanceof Rectangle2D) {
1909             clipState = CLIP_RECTANGULAR;
1910             clipRegion = devClip.getIntersection((Rectangle2D) usrClip);
1911         } else {
1912             PathIterator cpi = usrClip.getPathIterator(null);
1913             int[] box = new int[4];
1914             ShapeSpanIterator sr = LoopPipe.getFillSSI(this);
1915             try {
1916                 sr.setOutputArea(devClip);
1917                 sr.appendPath(cpi);
1918                 sr.getPathBox(box);
1919                 Region r = Region.getInstance(box, sr);
1920                 clipRegion = r;
1921                 clipState =
1922                     r.isRectangular() ? CLIP_RECTANGULAR : CLIP_SHAPE;
1923             } finally {
1924                 sr.dispose();
1925             }
1926         }
1927         if (origClipState != clipState &amp;&amp;
1928             (clipState == CLIP_SHAPE || origClipState == CLIP_SHAPE))
1929         {
1930             validFontInfo = false;
1931             invalidatePipe();
1932         }
1933     }
1934 
1935     static final int NON_RECTILINEAR_TRANSFORM_MASK =
1936         (AffineTransform.TYPE_GENERAL_TRANSFORM |
1937          AffineTransform.TYPE_GENERAL_ROTATION);
1938 
1939     protected Shape transformShape(Shape s) {
1940         if (s == null) {
1941             return null;
1942         }
1943         if (transformState &gt; TRANSFORM_INT_TRANSLATE) {
1944             return transformShape(transform, s);
1945         } else {
1946             return transformShape(transX, transY, s);
1947         }
1948     }
1949 
1950     public Shape untransformShape(Shape s) {
1951         if (s == null) {
1952             return null;
1953         }
1954         if (transformState &gt; TRANSFORM_INT_TRANSLATE) {
1955             try {
1956                 return transformShape(transform.createInverse(), s);
1957             } catch (NoninvertibleTransformException e) {
1958                 return null;
1959             }
1960         } else {
1961             return transformShape(-transX, -transY, s);
1962         }
1963     }
1964 
1965     protected static Shape transformShape(int tx, int ty, Shape s) {
1966         if (s == null) {
1967             return null;
1968         }
1969 
1970         if (s instanceof Rectangle) {
1971             Rectangle r = s.getBounds();
1972             r.translate(tx, ty);
1973             return r;
1974         }
1975         if (s instanceof Rectangle2D) {
1976             Rectangle2D rect = (Rectangle2D) s;
1977             return new Rectangle2D.Double(rect.getX() + tx,
1978                                           rect.getY() + ty,
1979                                           rect.getWidth(),
1980                                           rect.getHeight());
1981         }
1982 
1983         if (tx == 0 &amp;&amp; ty == 0) {
1984             return cloneShape(s);
1985         }
1986 
1987         AffineTransform mat = AffineTransform.getTranslateInstance(tx, ty);
1988         return mat.createTransformedShape(s);
1989     }
1990 
1991     protected static Shape transformShape(AffineTransform tx, Shape clip) {
1992         if (clip == null) {
1993             return null;
1994         }
1995 
1996         if (clip instanceof Rectangle2D &amp;&amp;
1997             (tx.getType() &amp; NON_RECTILINEAR_TRANSFORM_MASK) == 0)
1998         {
1999             Rectangle2D rect = (Rectangle2D) clip;
2000             double[] matrix = new double[4];
2001             matrix[0] = rect.getX();
2002             matrix[1] = rect.getY();
2003             matrix[2] = matrix[0] + rect.getWidth();
2004             matrix[3] = matrix[1] + rect.getHeight();
2005             tx.transform(matrix, 0, matrix, 0, 2);
2006             fixRectangleOrientation(matrix, rect);
2007             return new Rectangle2D.Double(matrix[0], matrix[1],
2008                                           matrix[2] - matrix[0],
2009                                           matrix[3] - matrix[1]);
2010         }
2011 
2012         if (tx.isIdentity()) {
2013             return cloneShape(clip);
2014         }
2015 
2016         return tx.createTransformedShape(clip);
2017     }
2018 
2019     /**
2020      * Sets orientation of the rectangle according to the clip.
2021      */
2022     private static void fixRectangleOrientation(double[] m, Rectangle2D clip) {
2023         if (clip.getWidth() &gt; 0 != (m[2] - m[0] &gt; 0)) {
2024             double t = m[0];
2025             m[0] = m[2];
2026             m[2] = t;
2027         }
2028         if (clip.getHeight() &gt; 0 != (m[3] - m[1] &gt; 0)) {
2029             double t = m[1];
2030             m[1] = m[3];
2031             m[3] = t;
2032         }
2033     }
2034 
2035     public void clipRect(int x, int y, int w, int h) {
2036         clip(new Rectangle(x, y, w, h));
2037     }
2038 
2039     public void setClip(int x, int y, int w, int h) {
2040         setClip(new Rectangle(x, y, w, h));
2041     }
2042 
2043     public Shape getClip() {
2044         return untransformShape(usrClip);
2045     }
2046 
2047     public void setClip(Shape sh) {
2048         usrClip = transformShape(sh);
2049         validateCompClip();
2050     }
2051 
2052     /**
2053      * Intersects the current clip with the specified Path and sets the
2054      * current clip to the resulting intersection. The clip is transformed
2055      * with the current transform in the Graphics2D state before being
2056      * intersected with the current clip. This method is used to make the
2057      * current clip smaller. To make the clip larger, use any setClip method.
2058      * @param s The Path to be intersected with the current clip.
2059      */
2060     public void clip(Shape s) {
2061         s = transformShape(s);
2062         if (usrClip != null) {
2063             s = intersectShapes(usrClip, s, true, true);
2064         }
2065         usrClip = s;
2066         validateCompClip();
2067     }
2068 
2069     public void setPaintMode() {
2070         setComposite(AlphaComposite.SrcOver);
2071     }
2072 
2073     public void setXORMode(Color c) {
2074         if (c == null) {
2075             throw new IllegalArgumentException(&quot;null XORColor&quot;);
2076         }
2077         setComposite(new XORComposite(c, surfaceData));
2078     }
2079 
2080     Blit lastCAblit;
2081     Composite lastCAcomp;
2082 
2083     public void copyArea(int x, int y, int w, int h, int dx, int dy) {
2084         try {
2085             doCopyArea(x, y, w, h, dx, dy);
2086         } catch (InvalidPipeException e) {
2087             try {
2088                 revalidateAll();
2089                 doCopyArea(x, y, w, h, dx, dy);
2090             } catch (InvalidPipeException e2) {
2091                 // Still catching the exception; we are not yet ready to
2092                 // validate the surfaceData correctly.  Fail for now and
2093                 // try again next time around.
2094             }
2095         } finally {
2096             surfaceData.markDirty();
2097         }
2098     }
2099 
2100     private void doCopyArea(int x, int y, int w, int h, int dx, int dy) {
2101         if (w &lt;= 0 || h &lt;= 0) {
2102             return;
2103         }
2104 
2105         if (transformState == SunGraphics2D.TRANSFORM_ISIDENT) {
2106             // do nothing
2107         } else if (transformState &lt;= SunGraphics2D.TRANSFORM_ANY_TRANSLATE) {
2108             x += transX;
2109             y += transY;
2110         } else if (transformState == SunGraphics2D.TRANSFORM_TRANSLATESCALE) {
2111             final double[] coords = {x, y, x + w, y + h, x + dx, y + dy};
2112             transform.transform(coords, 0, coords, 0, 3);
2113             x = (int) Math.ceil(coords[0] - 0.5);
2114             y = (int) Math.ceil(coords[1] - 0.5);
2115             w = ((int) Math.ceil(coords[2] - 0.5)) - x;
2116             h = ((int) Math.ceil(coords[3] - 0.5)) - y;
2117             dx = ((int) Math.ceil(coords[4] - 0.5)) - x;
2118             dy = ((int) Math.ceil(coords[5] - 0.5)) - y;
2119             // In case of negative scale transform, reflect the rect coords.
2120             if (w &lt; 0) {
2121                 w = -w;
2122                 x -= w;
2123             }
2124             if (h &lt; 0) {
2125                 h = -h;
2126                 y -= h;
2127             }
2128         } else {
2129             throw new InternalError(&quot;transformed copyArea not implemented yet&quot;);
2130         }
2131 
2132         SurfaceData theData = surfaceData;
2133         if (theData.copyArea(this, x, y, w, h, dx, dy)) {
2134             return;
2135         }
2136 
2137         // REMIND: This method does not deal with missing data from the
2138         // source object (i.e. it does not send exposure events...)
2139 
2140         Region clip = getCompClip();
2141 
2142         Composite comp = composite;
2143         if (lastCAcomp != comp) {
2144             SurfaceType dsttype = theData.getSurfaceType();
2145             CompositeType comptype = imageComp;
2146             if (CompositeType.SrcOverNoEa.equals(comptype) &amp;&amp;
2147                 theData.getTransparency() == Transparency.OPAQUE)
2148             {
2149                 comptype = CompositeType.SrcNoEa;
2150             }
2151             lastCAblit = Blit.locate(dsttype, comptype, dsttype);
2152             lastCAcomp = comp;
2153         }
2154 
2155         Blit ob = lastCAblit;
2156         if (dy == 0 &amp;&amp; dx &gt; 0 &amp;&amp; dx &lt; w) {
2157             while (w &gt; 0) {
2158                 int partW = Math.min(w, dx);
2159                 w -= partW;
2160                 int sx = x + w;
2161                 ob.Blit(theData, theData, comp, clip,
2162                         sx, y, sx+dx, y+dy, partW, h);
2163             }
2164             return;
2165         }
2166         if (dy &gt; 0 &amp;&amp; dy &lt; h &amp;&amp; dx &gt; -w &amp;&amp; dx &lt; w) {
2167             while (h &gt; 0) {
2168                 int partH = Math.min(h, dy);
2169                 h -= partH;
2170                 int sy = y + h;
2171                 ob.Blit(theData, theData, comp, clip,
2172                         x, sy, x+dx, sy+dy, w, partH);
2173             }
2174             return;
2175         }
2176             ob.Blit(theData, theData, comp, clip, x, y, x+dx, y+dy, w, h);
2177     }
2178 
2179     /*
2180     public void XcopyArea(int x, int y, int w, int h, int dx, int dy) {
2181         Rectangle rect = new Rectangle(x, y, w, h);
2182         rect = transformBounds(rect, transform);
2183         Point2D    point = new Point2D.Float(dx, dy);
2184         Point2D    root  = new Point2D.Float(0, 0);
2185         point = transform.transform(point, point);
2186         root  = transform.transform(root, root);
2187         int fdx = (int)(point.getX()-root.getX());
2188         int fdy = (int)(point.getY()-root.getY());
2189 
2190         Rectangle r = getCompBounds().intersection(rect.getBounds());
2191 
2192         if (r.isEmpty()) {
2193             return;
2194         }
2195 
2196         // Begin Rasterizer for Clip Shape
2197         boolean skipClip = true;
2198         byte[] clipAlpha = null;
2199 
2200         if (clipState == CLIP_SHAPE) {
2201 
2202             int box[] = new int[4];
2203 
2204             clipRegion.getBounds(box);
2205             Rectangle devR = new Rectangle(box[0], box[1],
2206                                            box[2] - box[0],
2207                                            box[3] - box[1]);
2208             if (!devR.isEmpty()) {
2209                 OutputManager mgr = getOutputManager();
2210                 RegionIterator ri = clipRegion.getIterator();
2211                 while (ri.nextYRange(box)) {
2212                     int spany = box[1];
2213                     int spanh = box[3] - spany;
2214                     while (ri.nextXBand(box)) {
2215                         int spanx = box[0];
2216                         int spanw = box[2] - spanx;
2217                         mgr.copyArea(this, null,
2218                                      spanw, 0,
2219                                      spanx, spany,
2220                                      spanw, spanh,
2221                                      fdx, fdy,
2222                                      null);
2223                     }
2224                 }
2225             }
2226             return;
2227         }
2228         // End Rasterizer for Clip Shape
2229 
2230         getOutputManager().copyArea(this, null,
2231                                     r.width, 0,
2232                                     r.x, r.y, r.width,
2233                                     r.height, fdx, fdy,
2234                                     null);
2235     }
2236     */
2237 
2238     public void drawLine(int x1, int y1, int x2, int y2) {
2239         try {
2240             drawpipe.drawLine(this, x1, y1, x2, y2);
2241         } catch (InvalidPipeException e) {
2242             try {
2243                 revalidateAll();
2244                 drawpipe.drawLine(this, x1, y1, x2, y2);
2245             } catch (InvalidPipeException e2) {
2246                 // Still catching the exception; we are not yet ready to
2247                 // validate the surfaceData correctly.  Fail for now and
2248                 // try again next time around.
2249             }
2250         } finally {
2251             surfaceData.markDirty();
2252         }
2253     }
2254 
2255     public void drawRoundRect(int x, int y, int w, int h, int arcW, int arcH) {
2256         try {
2257             drawpipe.drawRoundRect(this, x, y, w, h, arcW, arcH);
2258         } catch (InvalidPipeException e) {
2259             try {
2260                 revalidateAll();
2261                 drawpipe.drawRoundRect(this, x, y, w, h, arcW, arcH);
2262             } catch (InvalidPipeException e2) {
2263                 // Still catching the exception; we are not yet ready to
2264                 // validate the surfaceData correctly.  Fail for now and
2265                 // try again next time around.
2266             }
2267         } finally {
2268             surfaceData.markDirty();
2269         }
2270     }
2271 
2272     public void fillRoundRect(int x, int y, int w, int h, int arcW, int arcH) {
2273         try {
2274             fillpipe.fillRoundRect(this, x, y, w, h, arcW, arcH);
2275         } catch (InvalidPipeException e) {
2276             try {
2277                 revalidateAll();
2278                 fillpipe.fillRoundRect(this, x, y, w, h, arcW, arcH);
2279             } catch (InvalidPipeException e2) {
2280                 // Still catching the exception; we are not yet ready to
2281                 // validate the surfaceData correctly.  Fail for now and
2282                 // try again next time around.
2283             }
2284         } finally {
2285             surfaceData.markDirty();
2286         }
2287     }
2288 
2289     public void drawOval(int x, int y, int w, int h) {
2290         try {
2291             drawpipe.drawOval(this, x, y, w, h);
2292         } catch (InvalidPipeException e) {
2293             try {
2294                 revalidateAll();
2295                 drawpipe.drawOval(this, x, y, w, h);
2296             } catch (InvalidPipeException e2) {
2297                 // Still catching the exception; we are not yet ready to
2298                 // validate the surfaceData correctly.  Fail for now and
2299                 // try again next time around.
2300             }
2301         } finally {
2302             surfaceData.markDirty();
2303         }
2304     }
2305 
2306     public void fillOval(int x, int y, int w, int h) {
2307         try {
2308             fillpipe.fillOval(this, x, y, w, h);
2309         } catch (InvalidPipeException e) {
2310             try {
2311                 revalidateAll();
2312                 fillpipe.fillOval(this, x, y, w, h);
2313             } catch (InvalidPipeException e2) {
2314                 // Still catching the exception; we are not yet ready to
2315                 // validate the surfaceData correctly.  Fail for now and
2316                 // try again next time around.
2317             }
2318         } finally {
2319             surfaceData.markDirty();
2320         }
2321     }
2322 
2323     public void drawArc(int x, int y, int w, int h,
2324                         int startAngl, int arcAngl) {
2325         try {
2326             drawpipe.drawArc(this, x, y, w, h, startAngl, arcAngl);
2327         } catch (InvalidPipeException e) {
2328             try {
2329                 revalidateAll();
2330                 drawpipe.drawArc(this, x, y, w, h, startAngl, arcAngl);
2331             } catch (InvalidPipeException e2) {
2332                 // Still catching the exception; we are not yet ready to
2333                 // validate the surfaceData correctly.  Fail for now and
2334                 // try again next time around.
2335             }
2336         } finally {
2337             surfaceData.markDirty();
2338         }
2339     }
2340 
2341     public void fillArc(int x, int y, int w, int h,
2342                         int startAngl, int arcAngl) {
2343         try {
2344             fillpipe.fillArc(this, x, y, w, h, startAngl, arcAngl);
2345         } catch (InvalidPipeException e) {
2346             try {
2347                 revalidateAll();
2348                 fillpipe.fillArc(this, x, y, w, h, startAngl, arcAngl);
2349             } catch (InvalidPipeException e2) {
2350                 // Still catching the exception; we are not yet ready to
2351                 // validate the surfaceData correctly.  Fail for now and
2352                 // try again next time around.
2353             }
2354         } finally {
2355             surfaceData.markDirty();
2356         }
2357     }
2358 
2359     public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints) {
2360         try {
2361             drawpipe.drawPolyline(this, xPoints, yPoints, nPoints);
2362         } catch (InvalidPipeException e) {
2363             try {
2364                 revalidateAll();
2365                 drawpipe.drawPolyline(this, xPoints, yPoints, nPoints);
2366             } catch (InvalidPipeException e2) {
2367                 // Still catching the exception; we are not yet ready to
2368                 // validate the surfaceData correctly.  Fail for now and
2369                 // try again next time around.
2370             }
2371         } finally {
2372             surfaceData.markDirty();
2373         }
2374     }
2375 
2376     public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints) {
2377         try {
2378             drawpipe.drawPolygon(this, xPoints, yPoints, nPoints);
2379         } catch (InvalidPipeException e) {
2380             try {
2381                 revalidateAll();
2382                 drawpipe.drawPolygon(this, xPoints, yPoints, nPoints);
2383             } catch (InvalidPipeException e2) {
2384                 // Still catching the exception; we are not yet ready to
2385                 // validate the surfaceData correctly.  Fail for now and
2386                 // try again next time around.
2387             }
2388         } finally {
2389             surfaceData.markDirty();
2390         }
2391     }
2392 
2393     public void fillPolygon(int[] xPoints, int[] yPoints, int nPoints) {
2394         try {
2395             fillpipe.fillPolygon(this, xPoints, yPoints, nPoints);
2396         } catch (InvalidPipeException e) {
2397             try {
2398                 revalidateAll();
2399                 fillpipe.fillPolygon(this, xPoints, yPoints, nPoints);
2400             } catch (InvalidPipeException e2) {
2401                 // Still catching the exception; we are not yet ready to
2402                 // validate the surfaceData correctly.  Fail for now and
2403                 // try again next time around.
2404             }
2405         } finally {
2406             surfaceData.markDirty();
2407         }
2408     }
2409 
2410     public void drawRect (int x, int y, int w, int h) {
2411         try {
2412             drawpipe.drawRect(this, x, y, w, h);
2413         } catch (InvalidPipeException e) {
2414             try {
2415                 revalidateAll();
2416                 drawpipe.drawRect(this, x, y, w, h);
2417             } catch (InvalidPipeException e2) {
2418                 // Still catching the exception; we are not yet ready to
2419                 // validate the surfaceData correctly.  Fail for now and
2420                 // try again next time around.
2421             }
2422         } finally {
2423             surfaceData.markDirty();
2424         }
2425     }
2426 
2427     public void fillRect (int x, int y, int w, int h) {
2428         try {
2429             fillpipe.fillRect(this, x, y, w, h);
2430         } catch (InvalidPipeException e) {
2431             try {
2432                 revalidateAll();
2433                 fillpipe.fillRect(this, x, y, w, h);
2434             } catch (InvalidPipeException e2) {
2435                 // Still catching the exception; we are not yet ready to
2436                 // validate the surfaceData correctly.  Fail for now and
2437                 // try again next time around.
2438             }
2439         } finally {
2440             surfaceData.markDirty();
2441         }
2442     }
2443 
2444     private void revalidateAll() {
2445         try {
2446             // REMIND: This locking needs to be done around the
2447             // caller of this method so that the pipe stays valid
2448             // long enough to call the new primitive.
2449             // REMIND: No locking yet in screen SurfaceData objects!
2450             // surfaceData.lock();
2451             surfaceData = surfaceData.getReplacement();
2452             if (surfaceData == null) {
2453                 surfaceData = NullSurfaceData.theInstance;
2454             }
2455 
2456             invalidatePipe();
2457 
2458             // this will recalculate the composite clip
2459             setDevClip(surfaceData.getBounds());
2460 
2461             if (paintState &lt;= PAINT_ALPHACOLOR) {
2462                 validateColor();
2463             }
2464             if (composite instanceof XORComposite) {
2465                 Color c = ((XORComposite) composite).getXorColor();
2466                 setComposite(new XORComposite(c, surfaceData));
2467             }
2468             validatePipe();
2469         } finally {
2470             // REMIND: No locking yet in screen SurfaceData objects!
2471             // surfaceData.unlock();
2472         }
2473     }
2474 
2475     public void clearRect(int x, int y, int w, int h) {
2476         // REMIND: has some &quot;interesting&quot; consequences if threads are
2477         // not synchronized
2478         Composite c = composite;
2479         Paint p = paint;
2480         setComposite(AlphaComposite.Src);
2481         setColor(getBackground());
2482         fillRect(x, y, w, h);
2483         setPaint(p);
2484         setComposite(c);
2485     }
2486 
2487     /**
2488      * Strokes the outline of a Path using the settings of the current
2489      * graphics state.  The rendering attributes applied include the
2490      * clip, transform, paint or color, composite and stroke attributes.
2491      * @param s The path to be drawn.
2492      * @see #setStroke
2493      * @see #setPaint
2494      * @see java.awt.Graphics#setColor
2495      * @see #transform
2496      * @see #setTransform
2497      * @see #clip
2498      * @see #setClip
2499      * @see #setComposite
2500      */
2501     public void draw(Shape s) {
2502         try {
2503             shapepipe.draw(this, s);
2504         } catch (InvalidPipeException e) {
2505             try {
2506                 revalidateAll();
2507                 shapepipe.draw(this, s);
2508             } catch (InvalidPipeException e2) {
2509                 // Still catching the exception; we are not yet ready to
2510                 // validate the surfaceData correctly.  Fail for now and
2511                 // try again next time around.
2512             }
2513         } finally {
2514             surfaceData.markDirty();
2515         }
2516     }
2517 
2518 
2519     /**
2520      * Fills the interior of a Path using the settings of the current
2521      * graphics state. The rendering attributes applied include the
2522      * clip, transform, paint or color, and composite.
2523      * @see #setPaint
2524      * @see java.awt.Graphics#setColor
2525      * @see #transform
2526      * @see #setTransform
2527      * @see #setComposite
2528      * @see #clip
2529      * @see #setClip
2530      */
2531     public void fill(Shape s) {
2532         try {
2533             shapepipe.fill(this, s);
2534         } catch (InvalidPipeException e) {
2535             try {
2536                 revalidateAll();
2537                 shapepipe.fill(this, s);
2538             } catch (InvalidPipeException e2) {
2539                 // Still catching the exception; we are not yet ready to
2540                 // validate the surfaceData correctly.  Fail for now and
2541                 // try again next time around.
2542             }
2543         } finally {
2544             surfaceData.markDirty();
2545         }
2546     }
2547 
2548     /**
2549      * Returns true if the given AffineTransform is an integer
2550      * translation.
2551      */
2552     private static boolean isIntegerTranslation(AffineTransform xform) {
2553         if (xform.isIdentity()) {
2554             return true;
2555         }
2556         if (xform.getType() == AffineTransform.TYPE_TRANSLATION) {
2557             double tx = xform.getTranslateX();
2558             double ty = xform.getTranslateY();
2559             return (tx == (int)tx &amp;&amp; ty == (int)ty);
2560         }
2561         return false;
2562     }
2563 
2564     /**
2565      * Returns the index of the tile corresponding to the supplied position
2566      * given the tile grid offset and size along the same axis.
2567      */
2568     private static int getTileIndex(int p, int tileGridOffset, int tileSize) {
2569         p -= tileGridOffset;
2570         if (p &lt; 0) {
2571             p += 1 - tileSize;          // force round to -infinity (ceiling)
2572         }
2573         return p/tileSize;
2574     }
2575 
2576     /**
2577      * Returns a rectangle in image coordinates that may be required
2578      * in order to draw the given image into the given clipping region
2579      * through a pair of AffineTransforms.  In addition, horizontal and
2580      * vertical padding factors for antialising and interpolation may
2581      * be used.
2582      */
2583     private static Rectangle getImageRegion(RenderedImage img,
2584                                             Region compClip,
2585                                             AffineTransform transform,
2586                                             AffineTransform xform,
2587                                             int padX, int padY) {
2588         Rectangle imageRect =
2589             new Rectangle(img.getMinX(), img.getMinY(),
2590                           img.getWidth(), img.getHeight());
2591 
2592         Rectangle result = null;
2593         try {
2594             double[] p = new double[8];
2595             p[0] = p[2] = compClip.getLoX();
2596             p[4] = p[6] = compClip.getHiX();
2597             p[1] = p[5] = compClip.getLoY();
2598             p[3] = p[7] = compClip.getHiY();
2599 
2600             // Inverse transform the output bounding rect
2601             transform.inverseTransform(p, 0, p, 0, 4);
2602             xform.inverseTransform(p, 0, p, 0, 4);
2603 
2604             // Determine a bounding box for the inverse transformed region
2605             double x0,x1,y0,y1;
2606             x0 = x1 = p[0];
2607             y0 = y1 = p[1];
2608 
2609             for (int i = 2; i &lt; 8; ) {
2610                 double pt = p[i++];
2611                 if (pt &lt; x0)  {
2612                     x0 = pt;
2613                 } else if (pt &gt; x1) {
2614                     x1 = pt;
2615                 }
2616                 pt = p[i++];
2617                 if (pt &lt; y0)  {
2618                     y0 = pt;
2619                 } else if (pt &gt; y1) {
2620                     y1 = pt;
2621                 }
2622             }
2623 
2624             // This is padding for anti-aliasing and such.  It may
2625             // be more than is needed.
2626             int x = (int)x0 - padX;
2627             int w = (int)(x1 - x0 + 2*padX);
2628             int y = (int)y0 - padY;
2629             int h = (int)(y1 - y0 + 2*padY);
2630 
2631             Rectangle clipRect = new Rectangle(x,y,w,h);
2632             result = clipRect.intersection(imageRect);
2633         } catch (NoninvertibleTransformException nte) {
2634             // Worst case bounds are the bounds of the image.
2635             result = imageRect;
2636         }
2637 
2638         return result;
2639     }
2640 
2641     /**
2642      * Draws an image, applying a transform from image space into user space
2643      * before drawing.
2644      * The transformation from user space into device space is done with
2645      * the current transform in the Graphics2D.
2646      * The given transformation is applied to the image before the
2647      * transform attribute in the Graphics2D state is applied.
2648      * The rendering attributes applied include the clip, transform,
2649      * and composite attributes. Note that the result is
2650      * undefined, if the given transform is noninvertible.
2651      * @param img The image to be drawn. Does nothing if img is null.
2652      * @param xform The transformation from image space into user space.
2653      * @see #transform
2654      * @see #setTransform
2655      * @see #setComposite
2656      * @see #clip
2657      * @see #setClip
2658      */
2659     public void drawRenderedImage(RenderedImage img,
2660                                   AffineTransform xform) {
2661 
2662         if (img == null) {
2663             return;
2664         }
2665 
2666         // BufferedImage case: use a simple drawImage call
2667         if (img instanceof BufferedImage) {
2668             BufferedImage bufImg = (BufferedImage)img;
2669             drawImage(bufImg,xform,null);
2670             return;
2671         }
2672 
2673         // transformState tracks the state of transform and
2674         // transX, transY contain the integer casts of the
2675         // translation factors
2676         boolean isIntegerTranslate =
2677             (transformState &lt;= TRANSFORM_INT_TRANSLATE) &amp;&amp;
2678             isIntegerTranslation(xform);
2679 
2680         // Include padding for interpolation/antialiasing if necessary
2681         int pad = isIntegerTranslate ? 0 : 3;
2682 
2683         Region clip;
2684         try {
2685             clip = getCompClip();
2686         } catch (InvalidPipeException e) {
2687             return;
2688         }
2689 
2690         // Determine the region of the image that may contribute to
2691         // the clipped drawing area
2692         Rectangle region = getImageRegion(img,
2693                                           clip,
2694                                           transform,
2695                                           xform,
2696                                           pad, pad);
2697         if (region.width &lt;= 0 || region.height &lt;= 0) {
2698             return;
2699         }
2700 
2701         // Attempt to optimize integer translation of tiled images.
2702         // Although theoretically we are O.K. if the concatenation of
2703         // the user transform and the device transform is an integer
2704         // translation, we&#39;ll play it safe and only optimize the case
2705         // where both are integer translations.
2706         if (isIntegerTranslate) {
2707             // Use optimized code
2708             // Note that drawTranslatedRenderedImage calls copyImage
2709             // which takes the user space to device space transform into
2710             // account, but we need to provide the image space to user space
2711             // translations.
2712 
2713             drawTranslatedRenderedImage(img, region,
2714                                         (int) xform.getTranslateX(),
2715                                         (int) xform.getTranslateY());
2716             return;
2717         }
2718 
2719         // General case: cobble the necessary region into a single Raster
2720         Raster raster = img.getData(region);
2721 
2722         // Make a new Raster with the same contents as raster
2723         // but starting at (0, 0).  This raster is thus in the same
2724         // coordinate system as the SampleModel of the original raster.
2725         WritableRaster wRaster =
2726               Raster.createWritableRaster(raster.getSampleModel(),
2727                                           raster.getDataBuffer(),
2728                                           null);
2729 
2730         // If the original raster was in a different coordinate
2731         // system than its SampleModel, we need to perform an
2732         // additional translation in order to get the (minX, minY)
2733         // pixel of raster to be pixel (0, 0) of wRaster.  We also
2734         // have to have the correct width and height.
2735         int minX = raster.getMinX();
2736         int minY = raster.getMinY();
2737         int width = raster.getWidth();
2738         int height = raster.getHeight();
2739         int px = minX - raster.getSampleModelTranslateX();
2740         int py = minY - raster.getSampleModelTranslateY();
2741         if (px != 0 || py != 0 || width != wRaster.getWidth() ||
2742             height != wRaster.getHeight()) {
2743             wRaster =
2744                 wRaster.createWritableChild(px,
2745                                             py,
2746                                             width,
2747                                             height,
2748                                             0, 0,
2749                                             null);
2750         }
2751 
2752         // Now we have a BufferedImage starting at (0, 0)
2753         // with the same contents that started at (minX, minY)
2754         // in raster.  So we must draw the BufferedImage with a
2755         // translation of (minX, minY).
2756         AffineTransform transXform = (AffineTransform)xform.clone();
2757         transXform.translate(minX, minY);
2758 
2759         ColorModel cm = img.getColorModel();
2760         BufferedImage bufImg = new BufferedImage(cm,
2761                                                  wRaster,
2762                                                  cm.isAlphaPremultiplied(),
2763                                                  null);
2764         drawImage(bufImg, transXform, null);
2765     }
2766 
2767     /**
2768      * Intersects {@code destRect} with {@code clip} and
2769      * overwrites {@code destRect} with the result.
2770      * Returns false if the intersection was empty, true otherwise.
2771      */
2772     private boolean clipTo(Rectangle destRect, Rectangle clip) {
2773         int x1 = Math.max(destRect.x, clip.x);
2774         int x2 = Math.min(destRect.x + destRect.width, clip.x + clip.width);
2775         int y1 = Math.max(destRect.y, clip.y);
2776         int y2 = Math.min(destRect.y + destRect.height, clip.y + clip.height);
2777         if (((x2 - x1) &lt; 0) || ((y2 - y1) &lt; 0)) {
2778             destRect.width = -1; // Set both just to be safe
2779             destRect.height = -1;
2780             return false;
2781         } else {
2782             destRect.x = x1;
2783             destRect.y = y1;
2784             destRect.width = x2 - x1;
2785             destRect.height = y2 - y1;
2786             return true;
2787         }
2788     }
2789 
2790     /**
2791      * Draw a portion of a RenderedImage tile-by-tile with a given
2792      * integer image to user space translation.  The user to
2793      * device transform must also be an integer translation.
2794      */
2795     private void drawTranslatedRenderedImage(RenderedImage img,
2796                                              Rectangle region,
2797                                              int i2uTransX,
2798                                              int i2uTransY) {
2799         // Cache tile grid info
2800         int tileGridXOffset = img.getTileGridXOffset();
2801         int tileGridYOffset = img.getTileGridYOffset();
2802         int tileWidth = img.getTileWidth();
2803         int tileHeight = img.getTileHeight();
2804 
2805         // Determine the tile index extrema in each direction
2806         int minTileX =
2807             getTileIndex(region.x, tileGridXOffset, tileWidth);
2808         int minTileY =
2809             getTileIndex(region.y, tileGridYOffset, tileHeight);
2810         int maxTileX =
2811             getTileIndex(region.x + region.width - 1,
2812                          tileGridXOffset, tileWidth);
2813         int maxTileY =
2814             getTileIndex(region.y + region.height - 1,
2815                          tileGridYOffset, tileHeight);
2816 
2817         // Create a single ColorModel to use for all BufferedImages
2818         ColorModel colorModel = img.getColorModel();
2819 
2820         // Reuse the same Rectangle for each iteration
2821         Rectangle tileRect = new Rectangle();
2822 
2823         for (int ty = minTileY; ty &lt;= maxTileY; ty++) {
2824             for (int tx = minTileX; tx &lt;= maxTileX; tx++) {
2825                 // Get the current tile.
2826                 Raster raster = img.getTile(tx, ty);
2827 
2828                 // Fill in tileRect with the tile bounds
2829                 tileRect.x = tx*tileWidth + tileGridXOffset;
2830                 tileRect.y = ty*tileHeight + tileGridYOffset;
2831                 tileRect.width = tileWidth;
2832                 tileRect.height = tileHeight;
2833 
2834                 // Clip the tile against the image bounds and
2835                 // backwards mapped clip region
2836                 // The result can&#39;t be empty
2837                 clipTo(tileRect, region);
2838 
2839                 // Create a WritableRaster containing the tile
2840                 WritableRaster wRaster = null;
2841                 if (raster instanceof WritableRaster) {
2842                     wRaster = (WritableRaster)raster;
2843                 } else {
2844                     // Create a WritableRaster in the same coordinate system
2845                     // as the original raster.
2846                     wRaster =
2847                         Raster.createWritableRaster(raster.getSampleModel(),
2848                                                     raster.getDataBuffer(),
2849                                                     null);
2850                 }
2851 
2852                 // Translate wRaster to start at (0, 0) and to contain
2853                 // only the relevent portion of the tile
2854                 wRaster = wRaster.createWritableChild(tileRect.x, tileRect.y,
2855                                                       tileRect.width,
2856                                                       tileRect.height,
2857                                                       0, 0,
2858                                                       null);
2859 
2860                 // Wrap wRaster in a BufferedImage
2861                 BufferedImage bufImg =
2862                     new BufferedImage(colorModel,
2863                                       wRaster,
2864                                       colorModel.isAlphaPremultiplied(),
2865                                       null);
2866                 // Now we have a BufferedImage starting at (0, 0) that
2867                 // represents data from a Raster starting at
2868                 // (tileRect.x, tileRect.y).  Additionally, it needs
2869                 // to be translated by (i2uTransX, i2uTransY).  We call
2870                 // copyImage to draw just the region of interest
2871                 // without needing to create a child image.
2872                 copyImage(bufImg, tileRect.x + i2uTransX,
2873                           tileRect.y + i2uTransY, 0, 0, tileRect.width,
2874                           tileRect.height, null, null);
2875             }
2876         }
2877     }
2878 
2879     public void drawRenderableImage(RenderableImage img,
2880                                     AffineTransform xform) {
2881 
2882         if (img == null) {
2883             return;
2884         }
2885 
2886         AffineTransform pipeTransform = transform;
2887         AffineTransform concatTransform = new AffineTransform(xform);
2888         concatTransform.concatenate(pipeTransform);
2889         AffineTransform reverseTransform;
2890 
2891         RenderContext rc = new RenderContext(concatTransform);
2892 
2893         try {
2894             reverseTransform = pipeTransform.createInverse();
2895         } catch (NoninvertibleTransformException nte) {
2896             rc = new RenderContext(pipeTransform);
2897             reverseTransform = new AffineTransform();
2898         }
2899 
2900         RenderedImage rendering = img.createRendering(rc);
2901         drawRenderedImage(rendering,reverseTransform);
2902     }
2903 
2904 
2905 
2906     /*
2907      * Transform the bounding box of the BufferedImage
2908      */
2909     protected Rectangle transformBounds(Rectangle rect,
2910                                         AffineTransform tx) {
2911         if (tx.isIdentity()) {
2912             return rect;
2913         }
2914 
2915         Shape s = transformShape(tx, rect);
2916         return s.getBounds();
2917     }
2918 
2919     // text rendering methods
2920     public void drawString(String str, int x, int y) {
2921         if (str == null) {
2922             throw new NullPointerException(&quot;String is null&quot;);
2923         }
2924 
2925         if (font.hasLayoutAttributes()) {
2926             if (str.length() == 0) {
2927                 return;
2928             }
2929             new TextLayout(str, font, getFontRenderContext()).draw(this, x, y);
2930             return;
2931         }
2932 
2933         try {
2934             textpipe.drawString(this, str, x, y);
2935         } catch (InvalidPipeException e) {
2936             try {
2937                 revalidateAll();
2938                 textpipe.drawString(this, str, x, y);
2939             } catch (InvalidPipeException e2) {
2940                 // Still catching the exception; we are not yet ready to
2941                 // validate the surfaceData correctly.  Fail for now and
2942                 // try again next time around.
2943             }
2944         } finally {
2945             surfaceData.markDirty();
2946         }
2947     }
2948 
2949     public void drawString(String str, float x, float y) {
2950         if (str == null) {
2951             throw new NullPointerException(&quot;String is null&quot;);
2952         }
2953 
2954         if (font.hasLayoutAttributes()) {
2955             if (str.length() == 0) {
2956                 return;
2957             }
2958             new TextLayout(str, font, getFontRenderContext()).draw(this, x, y);
2959             return;
2960         }
2961 
2962         try {
2963             textpipe.drawString(this, str, x, y);
2964         } catch (InvalidPipeException e) {
2965             try {
2966                 revalidateAll();
2967                 textpipe.drawString(this, str, x, y);
2968             } catch (InvalidPipeException e2) {
2969                 // Still catching the exception; we are not yet ready to
2970                 // validate the surfaceData correctly.  Fail for now and
2971                 // try again next time around.
2972             }
2973         } finally {
2974             surfaceData.markDirty();
2975         }
2976     }
2977 
2978     public void drawString(AttributedCharacterIterator iterator,
2979                            int x, int y) {
2980         if (iterator == null) {
2981             throw new NullPointerException(&quot;AttributedCharacterIterator is null&quot;);
2982         }
2983         if (iterator.getBeginIndex() == iterator.getEndIndex()) {
2984             return; /* nothing to draw */
2985         }
2986         TextLayout tl = new TextLayout(iterator, getFontRenderContext());
2987         tl.draw(this, (float) x, (float) y);
2988     }
2989 
2990     public void drawString(AttributedCharacterIterator iterator,
2991                            float x, float y) {
2992         if (iterator == null) {
2993             throw new NullPointerException(&quot;AttributedCharacterIterator is null&quot;);
2994         }
2995         if (iterator.getBeginIndex() == iterator.getEndIndex()) {
2996             return; /* nothing to draw */
2997         }
2998         TextLayout tl = new TextLayout(iterator, getFontRenderContext());
2999         tl.draw(this, x, y);
3000     }
3001 
3002     public void drawGlyphVector(GlyphVector gv, float x, float y)
3003     {
3004         if (gv == null) {
3005             throw new NullPointerException(&quot;GlyphVector is null&quot;);
3006         }
3007 
3008         try {
3009             textpipe.drawGlyphVector(this, gv, x, y);
3010         } catch (InvalidPipeException e) {
3011             try {
3012                 revalidateAll();
3013                 textpipe.drawGlyphVector(this, gv, x, y);
3014             } catch (InvalidPipeException e2) {
3015                 // Still catching the exception; we are not yet ready to
3016                 // validate the surfaceData correctly.  Fail for now and
3017                 // try again next time around.
3018             }
3019         } finally {
3020             surfaceData.markDirty();
3021         }
3022     }
3023 
3024     public void drawChars(char[] data, int offset, int length, int x, int y) {
3025 
3026         if (data == null) {
3027             throw new NullPointerException(&quot;char data is null&quot;);
3028         }
3029         if (offset &lt; 0 || length &lt; 0 || offset + length &lt; length ||
3030             offset + length &gt; data.length) {
3031             throw new ArrayIndexOutOfBoundsException(&quot;bad offset/length&quot;);
3032         }
3033         if (font.hasLayoutAttributes()) {
3034             if (data.length == 0) {
3035                 return;
3036             }
3037             new TextLayout(new String(data, offset, length),
3038                            font, getFontRenderContext()).draw(this, x, y);
3039             return;
3040         }
3041 
3042         try {
3043             textpipe.drawChars(this, data, offset, length, x, y);
3044         } catch (InvalidPipeException e) {
3045             try {
3046                 revalidateAll();
3047                 textpipe.drawChars(this, data, offset, length, x, y);
3048             } catch (InvalidPipeException e2) {
3049                 // Still catching the exception; we are not yet ready to
3050                 // validate the surfaceData correctly.  Fail for now and
3051                 // try again next time around.
3052             }
3053         } finally {
3054             surfaceData.markDirty();
3055         }
3056     }
3057 
3058     public void drawBytes(byte[] data, int offset, int length, int x, int y) {
3059         if (data == null) {
3060             throw new NullPointerException(&quot;byte data is null&quot;);
3061         }
3062         if (offset &lt; 0 || length &lt; 0 || offset + length &lt; length ||
3063             offset + length &gt; data.length) {
3064             throw new ArrayIndexOutOfBoundsException(&quot;bad offset/length&quot;);
3065         }
3066         /* Byte data is interpreted as 8-bit ASCII. Re-use drawChars loops */
3067         char[] chData = new char[length];
3068         for (int i = length; i-- &gt; 0; ) {
3069             chData[i] = (char)(data[i+offset] &amp; 0xff);
3070         }
3071         if (font.hasLayoutAttributes()) {
3072             if (data.length == 0) {
3073                 return;
3074             }
3075             new TextLayout(new String(chData),
3076                            font, getFontRenderContext()).draw(this, x, y);
3077             return;
3078         }
3079 
3080         try {
3081             textpipe.drawChars(this, chData, 0, length, x, y);
3082         } catch (InvalidPipeException e) {
3083             try {
3084                 revalidateAll();
3085                 textpipe.drawChars(this, chData, 0, length, x, y);
3086             } catch (InvalidPipeException e2) {
3087                 // Still catching the exception; we are not yet ready to
3088                 // validate the surfaceData correctly.  Fail for now and
3089                 // try again next time around.
3090             }
3091         } finally {
3092             surfaceData.markDirty();
3093         }
3094     }
3095 // end of text rendering methods
3096 
3097     private Boolean drawHiDPIImage(Image img,
3098                                    int dx1, int dy1, int dx2, int dy2,
3099                                    int sx1, int sy1, int sx2, int sy2,
3100                                    Color bgcolor, ImageObserver observer,
3101                                    AffineTransform xform) {
3102 
3103         if (img instanceof VolatileImage) {
3104             final SurfaceData sd = SurfaceManager.getManager(img)
3105                     .getPrimarySurfaceData();
3106             final double scaleX = sd.getDefaultScaleX();
3107             final double scaleY = sd.getDefaultScaleY();
3108             if (scaleX == 1 &amp;&amp; scaleY == 1) {
3109                 return null;
3110             }
3111             sx1 = Region.clipRound(sx1 * scaleX);
3112             sx2 = Region.clipRound(sx2 * scaleX);
3113             sy1 = Region.clipRound(sy1 * scaleY);
3114             sy2 = Region.clipRound(sy2 * scaleY);
3115 
3116             AffineTransform tx = null;
3117             if (xform != null) {
3118                 tx = new AffineTransform(transform);
3119                 transform(xform);
3120             }
3121             boolean result = scaleImage(img, dx1, dy1, dx2, dy2,
3122                                         sx1, sy1, sx2, sy2,
3123                                         bgcolor, observer);
3124             if (tx != null) {
3125                 transform.setTransform(tx);
3126                 invalidateTransform();
3127             }
3128             return result;
3129         } else if (img instanceof MultiResolutionImage) {
3130             // get scaled destination image size
3131 
3132             int width = img.getWidth(observer);
3133             int height = img.getHeight(observer);
3134 
3135             MultiResolutionImage mrImage = (MultiResolutionImage) img;
3136             Image resolutionVariant = getResolutionVariant(mrImage, width, height,
3137                                                            dx1, dy1, dx2, dy2,
3138                                                            sx1, sy1, sx2, sy2,
3139                                                            xform);
3140 
3141             if (resolutionVariant != img &amp;&amp; resolutionVariant != null) {
3142                 // recalculate source region for the resolution variant
3143 
3144                 ImageObserver rvObserver = MultiResolutionToolkitImage.
3145                         getResolutionVariantObserver(img, observer,
3146                                 width, height, -1, -1);
3147 
3148                 int rvWidth = resolutionVariant.getWidth(rvObserver);
3149                 int rvHeight = resolutionVariant.getHeight(rvObserver);
3150 
3151                 if (0 &lt; width &amp;&amp; 0 &lt; height &amp;&amp; 0 &lt; rvWidth &amp;&amp; 0 &lt; rvHeight) {
3152 
3153                     double widthScale = ((double) rvWidth) / width;
3154                     double heightScale = ((double) rvHeight) / height;
3155 
3156                     if (resolutionVariant instanceof VolatileImage) {
3157                         SurfaceData sd = SurfaceManager
3158                                 .getManager(resolutionVariant)
3159                                 .getPrimarySurfaceData();
3160                         widthScale *= sd.getDefaultScaleX();
3161                         heightScale *= sd.getDefaultScaleY();
3162                     }
3163 
3164                     sx1 = Region.clipScale(sx1, widthScale);
3165                     sy1 = Region.clipScale(sy1, heightScale);
3166                     sx2 = Region.clipScale(sx2, widthScale);
3167                     sy2 = Region.clipScale(sy2, heightScale);
3168 
3169                     observer = rvObserver;
3170                     img = resolutionVariant;
3171 
3172                     if (xform != null) {
3173                         assert dx1 == 0 &amp;&amp; dy1 == 0;
3174                         assert dx2 == img.getWidth(observer);
3175                         assert dy2 == img.getHeight(observer);
3176                         AffineTransform renderTX = new AffineTransform(xform);
3177                         renderTX.scale(1 / widthScale, 1 / heightScale);
3178                         return transformImage(img, renderTX, observer);
3179                     }
3180 
3181                     return scaleImage(img, dx1, dy1, dx2, dy2,
3182                                       sx1, sy1, sx2, sy2,
3183                                       bgcolor, observer);
3184                 }
3185             }
3186         }
3187         return null;
3188     }
3189 
3190     private boolean scaleImage(Image img, int dx1, int dy1, int dx2, int dy2,
3191                                int sx1, int sy1, int sx2, int sy2,
3192                                Color bgcolor, ImageObserver observer)
3193     {
3194         try {
3195             return imagepipe.scaleImage(this, img, dx1, dy1, dx2, dy2, sx1, sy1,
3196                                         sx2, sy2, bgcolor, observer);
3197         } catch (InvalidPipeException e) {
3198             try {
3199                 revalidateAll();
3200                 return imagepipe.scaleImage(this, img, dx1, dy1, dx2, dy2, sx1,
3201                                             sy1, sx2, sy2, bgcolor, observer);
3202             } catch (InvalidPipeException e2) {
3203                 // Still catching the exception; we are not yet ready to
3204                 // validate the surfaceData correctly.  Fail for now and
3205                 // try again next time around.
3206                 return false;
3207             }
3208         } finally {
3209             surfaceData.markDirty();
3210         }
3211     }
3212 
3213     private boolean transformImage(Image img,
3214                                    AffineTransform xform,
3215                                    ImageObserver observer)
3216     {
3217         try {
3218             return imagepipe.transformImage(this, img, xform, observer);
3219         } catch (InvalidPipeException e) {
3220             try {
3221                 revalidateAll();
3222                 return imagepipe.transformImage(this, img, xform, observer);
3223             } catch (InvalidPipeException e2) {
3224                 // Still catching the exception; we are not yet ready to
3225                 // validate the surfaceData correctly.  Fail for now and
3226                 // try again next time around.
3227                 return false;
3228             }
3229         } finally {
3230             surfaceData.markDirty();
3231         }
3232     }
3233 
3234     private Image getResolutionVariant(MultiResolutionImage img,
3235             int srcWidth, int srcHeight, int dx1, int dy1, int dx2, int dy2,
3236             int sx1, int sy1, int sx2, int sy2, AffineTransform xform) {
3237 
3238         if (srcWidth &lt;= 0 || srcHeight &lt;= 0) {
3239             return null;
3240         }
3241 
3242         int sw = sx2 - sx1;
3243         int sh = sy2 - sy1;
3244 
3245         if (sw == 0 || sh == 0) {
3246             return null;
3247         }
3248 
3249         AffineTransform tx;
3250 
3251         if (xform == null) {
3252             tx = transform;
3253         } else {
3254             tx = new AffineTransform(transform);
3255             tx.concatenate(xform);
3256         }
3257 
3258         int type = tx.getType();
3259         int dw = dx2 - dx1;
3260         int dh = dy2 - dy1;
3261 
3262         double destImageWidth;
3263         double destImageHeight;
3264 
3265         if (resolutionVariantHint == SunHints.INTVAL_RESOLUTION_VARIANT_BASE) {
3266             destImageWidth = srcWidth;
3267             destImageHeight = srcHeight;
3268         } else if (resolutionVariantHint == SunHints.INTVAL_RESOLUTION_VARIANT_DPI_FIT) {
3269             AffineTransform configTransform = getDefaultTransform();
3270             if (configTransform.isIdentity()) {
3271                 destImageWidth = srcWidth;
3272                 destImageHeight = srcHeight;
3273             } else {
3274                 destImageWidth = srcWidth * configTransform.getScaleX();
3275                 destImageHeight = srcHeight * configTransform.getScaleY();
3276             }
3277         } else {
3278             double destRegionWidth;
3279             double destRegionHeight;
3280 
3281             if ((type &amp; ~(TYPE_TRANSLATION | TYPE_FLIP)) == 0) {
3282                 destRegionWidth = dw;
3283                 destRegionHeight = dh;
3284             } else if ((type &amp; ~(TYPE_TRANSLATION | TYPE_FLIP | TYPE_MASK_SCALE)) == 0) {
3285                 destRegionWidth = dw * tx.getScaleX();
3286                 destRegionHeight = dh * tx.getScaleY();
3287             } else {
3288                 destRegionWidth = dw * Math.hypot(
3289                         tx.getScaleX(), tx.getShearY());
3290                 destRegionHeight = dh * Math.hypot(
3291                         tx.getShearX(), tx.getScaleY());
3292             }
3293             destImageWidth = Math.abs(srcWidth * destRegionWidth / sw);
3294             destImageHeight = Math.abs(srcHeight * destRegionHeight / sh);
3295         }
3296 
3297         Image resolutionVariant
3298                 = img.getResolutionVariant(destImageWidth, destImageHeight);
3299 
3300         if (resolutionVariant instanceof ToolkitImage
3301                 &amp;&amp; ((ToolkitImage) resolutionVariant).hasError()) {
3302             return null;
3303         }
3304 
3305         return resolutionVariant;
3306     }
3307 
3308     /**
3309      * Draws an image scaled to x,y,w,h in nonblocking mode with a
3310      * callback object.
3311      */
3312     public boolean drawImage(Image img, int x, int y, int width, int height,
3313                              ImageObserver observer) {
3314         return drawImage(img, x, y, width, height, null, observer);
3315     }
3316 
3317     /**
3318      * Not part of the advertised API but a useful utility method
3319      * to call internally.  This is for the case where we are
3320      * drawing to/from given coordinates using a given width/height,
3321      * but we guarantee that the surfaceData&#39;s width/height of the src and dest
3322      * areas are equal (no scale needed). Note that this method intentionally
3323      * ignore scale factor of the source image, and copy it as is.
3324      */
3325     public boolean copyImage(Image img, int dx, int dy, int sx, int sy,
3326                              int width, int height, Color bgcolor,
3327                              ImageObserver observer) {
3328         try {
3329             return imagepipe.copyImage(this, img, dx, dy, sx, sy,
3330                                        width, height, bgcolor, observer);
3331         } catch (InvalidPipeException e) {
3332             try {
3333                 revalidateAll();
3334                 return imagepipe.copyImage(this, img, dx, dy, sx, sy,
3335                                            width, height, bgcolor, observer);
3336             } catch (InvalidPipeException e2) {
3337                 // Still catching the exception; we are not yet ready to
3338                 // validate the surfaceData correctly.  Fail for now and
3339                 // try again next time around.
3340                 return false;
3341             }
3342         } finally {
3343             surfaceData.markDirty();
3344         }
3345     }
3346 
3347     /**
3348      * Draws an image scaled to x,y,w,h in nonblocking mode with a
3349      * solid background color and a callback object.
3350      */
3351     public boolean drawImage(Image img, int x, int y, int width, int height,
3352                              Color bg, ImageObserver observer) {
3353 
3354         if (img == null) {
3355             return true;
3356         }
3357 
3358         if ((width == 0) || (height == 0)) {
3359             return true;
3360         }
3361 
3362         final int imgW = img.getWidth(null);
3363         final int imgH = img.getHeight(null);
3364         Boolean hidpiImageDrawn = drawHiDPIImage(img, x, y, x + width, y + height,
3365                                                  0, 0, imgW, imgH, bg, observer,
3366                                                  null);
3367         if (hidpiImageDrawn != null) {
3368             return hidpiImageDrawn;
3369         }
3370 
3371         if (width == imgW &amp;&amp; height == imgH) {
3372             return copyImage(img, x, y, 0, 0, width, height, bg, observer);
3373         }
3374 
3375         try {
3376             return imagepipe.scaleImage(this, img, x, y, width, height,
3377                                         bg, observer);
3378         } catch (InvalidPipeException e) {
3379             try {
3380                 revalidateAll();
3381                 return imagepipe.scaleImage(this, img, x, y, width, height,
3382                                             bg, observer);
3383             } catch (InvalidPipeException e2) {
3384                 // Still catching the exception; we are not yet ready to
3385                 // validate the surfaceData correctly.  Fail for now and
3386                 // try again next time around.
3387                 return false;
3388             }
3389         } finally {
3390             surfaceData.markDirty();
3391         }
3392     }
3393 
3394     /**
3395      * Draws an image at x,y in nonblocking mode.
3396      */
3397     public boolean drawImage(Image img, int x, int y, ImageObserver observer) {
3398         return drawImage(img, x, y, null, observer);
3399     }
3400 
3401     /**
3402      * Draws an image at x,y in nonblocking mode with a solid background
3403      * color and a callback object.
3404      */
3405     public boolean drawImage(Image img, int x, int y, Color bg,
3406                              ImageObserver observer) {
3407 
3408         if (img == null) {
3409             return true;
3410         }
3411 
3412         final int imgW = img.getWidth(null);
3413         final int imgH = img.getHeight(null);
3414         Boolean hidpiImageDrawn = drawHiDPIImage(img, x, y, x + imgW, y + imgH,
3415                                                  0, 0, imgW, imgH, bg, observer,
3416                                                  null);
3417         if (hidpiImageDrawn != null) {
3418             return hidpiImageDrawn;
3419         }
3420 
3421         try {
3422             return imagepipe.copyImage(this, img, x, y, bg, observer);
3423         } catch (InvalidPipeException e) {
3424             try {
3425                 revalidateAll();
3426                 return imagepipe.copyImage(this, img, x, y, bg, observer);
3427             } catch (InvalidPipeException e2) {
3428                 // Still catching the exception; we are not yet ready to
3429                 // validate the surfaceData correctly.  Fail for now and
3430                 // try again next time around.
3431                 return false;
3432             }
3433         } finally {
3434             surfaceData.markDirty();
3435         }
3436     }
3437 
3438     /**
3439      * Draws a subrectangle of an image scaled to a destination rectangle
3440      * in nonblocking mode with a callback object.
3441      */
3442     public boolean drawImage(Image img,
3443                              int dx1, int dy1, int dx2, int dy2,
3444                              int sx1, int sy1, int sx2, int sy2,
3445                              ImageObserver observer) {
3446         return drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, null,
3447                          observer);
3448     }
3449 
3450     /**
3451      * Draws a subrectangle of an image scaled to a destination rectangle in
3452      * nonblocking mode with a solid background color and a callback object.
3453      */
3454     public boolean drawImage(Image img,
3455                              int dx1, int dy1, int dx2, int dy2,
3456                              int sx1, int sy1, int sx2, int sy2,
3457                              Color bgcolor, ImageObserver observer) {
3458 
3459         if (img == null) {
3460             return true;
3461         }
3462 
3463         if (dx1 == dx2 || dy1 == dy2 ||
3464             sx1 == sx2 || sy1 == sy2)
3465         {
3466             return true;
3467         }
3468 
3469         Boolean hidpiImageDrawn = drawHiDPIImage(img, dx1, dy1, dx2, dy2,
3470                                                  sx1, sy1, sx2, sy2,
3471                                                  bgcolor, observer, null);
3472 
3473         if (hidpiImageDrawn != null) {
3474             return hidpiImageDrawn;
3475         }
3476 
3477         if (((sx2 - sx1) == (dx2 - dx1)) &amp;&amp;
3478             ((sy2 - sy1) == (dy2 - dy1)))
3479         {
3480             // Not a scale - forward it to a copy routine
3481             int srcX, srcY, dstX, dstY, width, height;
3482             if (sx2 &gt; sx1) {
3483                 width = sx2 - sx1;
3484                 srcX = sx1;
3485                 dstX = dx1;
3486             } else {
3487                 width = sx1 - sx2;
3488                 srcX = sx2;
3489                 dstX = dx2;
3490             }
3491             if (sy2 &gt; sy1) {
3492                 height = sy2-sy1;
3493                 srcY = sy1;
3494                 dstY = dy1;
3495             } else {
3496                 height = sy1-sy2;
3497                 srcY = sy2;
3498                 dstY = dy2;
3499             }
3500             return copyImage(img, dstX, dstY, srcX, srcY,
3501                              width, height, bgcolor, observer);
3502         }
3503 
3504         try {
3505             return imagepipe.scaleImage(this, img, dx1, dy1, dx2, dy2,
3506                                           sx1, sy1, sx2, sy2, bgcolor,
3507                                           observer);
3508         } catch (InvalidPipeException e) {
3509             try {
3510                 revalidateAll();
3511                 return imagepipe.scaleImage(this, img, dx1, dy1, dx2, dy2,
3512                                               sx1, sy1, sx2, sy2, bgcolor,
3513                                               observer);
3514             } catch (InvalidPipeException e2) {
3515                 // Still catching the exception; we are not yet ready to
3516                 // validate the surfaceData correctly.  Fail for now and
3517                 // try again next time around.
3518                 return false;
3519             }
3520         } finally {
3521             surfaceData.markDirty();
3522         }
3523     }
3524 
3525     /**
3526      * Draw an image, applying a transform from image space into user space
3527      * before drawing.
3528      * The transformation from user space into device space is done with
3529      * the current transform in the Graphics2D.
3530      * The given transformation is applied to the image before the
3531      * transform attribute in the Graphics2D state is applied.
3532      * The rendering attributes applied include the clip, transform,
3533      * paint or color and composite attributes. Note that the result is
3534      * undefined, if the given transform is non-invertible.
3535      * @param img The image to be drawn.
3536      * @param xform The transformation from image space into user space.
3537      * @param observer The image observer to be notified on the image producing
3538      * progress.
3539      * @see #transform
3540      * @see #setComposite
3541      * @see #setClip
3542      */
3543     public boolean drawImage(Image img,
3544                              AffineTransform xform,
3545                              ImageObserver observer) {
3546 
3547         if (img == null) {
3548             return true;
3549         }
3550 
3551         if (xform == null || xform.isIdentity()) {
3552             return drawImage(img, 0, 0, null, observer);
3553         }
3554 
3555         final int w = img.getWidth(null);
3556         final int h = img.getHeight(null);
3557         Boolean hidpiImageDrawn = drawHiDPIImage(img, 0, 0, w, h, 0, 0, w, h,
3558                                                  null, observer, xform);
3559 
3560         if (hidpiImageDrawn != null) {
3561             return hidpiImageDrawn;
3562         }
3563 
3564         return transformImage(img, xform, observer);
3565     }
3566 
3567     public void drawImage(BufferedImage bImg,
3568                           BufferedImageOp op,
3569                           int x,
3570                           int y)  {
3571 
3572         if (bImg == null) {
3573             return;
3574         }
3575 
3576         try {
3577             imagepipe.transformImage(this, bImg, op, x, y);
3578         } catch (InvalidPipeException e) {
3579             try {
3580                 revalidateAll();
3581                 imagepipe.transformImage(this, bImg, op, x, y);
3582             } catch (InvalidPipeException e2) {
3583                 // Still catching the exception; we are not yet ready to
3584                 // validate the surfaceData correctly.  Fail for now and
3585                 // try again next time around.
3586             }
3587         } finally {
3588             surfaceData.markDirty();
3589         }
3590     }
3591 
3592     /**
3593     * Get the rendering context of the font
3594     * within this Graphics2D context.
3595     */
3596     public FontRenderContext getFontRenderContext() {
3597         if (cachedFRC == null) {
3598             int aahint = textAntialiasHint;
3599             if (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT &amp;&amp;
3600                 antialiasHint == SunHints.INTVAL_ANTIALIAS_ON) {
3601                 aahint = SunHints.INTVAL_TEXT_ANTIALIAS_ON;
3602             }
3603             // Translation components should be excluded from the FRC transform
3604             AffineTransform tx = null;
3605             if (transformState &gt;= TRANSFORM_TRANSLATESCALE) {
3606                 if (transform.getTranslateX() == 0 &amp;&amp;
3607                     transform.getTranslateY() == 0) {
3608                     tx = transform;
3609                 } else {
3610                     tx = new AffineTransform(transform.getScaleX(),
3611                                              transform.getShearY(),
3612                                              transform.getShearX(),
3613                                              transform.getScaleY(),
3614                                              0, 0);
3615                 }
3616             }
3617             cachedFRC = new FontRenderContext(tx,
3618              SunHints.Value.get(SunHints.INTKEY_TEXT_ANTIALIASING, aahint),
3619              SunHints.Value.get(SunHints.INTKEY_FRACTIONALMETRICS,
3620                                 fractionalMetricsHint));
3621         }
3622         return cachedFRC;
3623     }
3624     private FontRenderContext cachedFRC;
3625 
3626     /**
3627      * This object has no resources to dispose of per se, but the
3628      * doc comments for the base method in java.awt.Graphics imply
3629      * that this object will not be useable after it is disposed.
3630      * So, we sabotage the object to prevent further use to prevent
3631      * developers from relying on behavior that may not work on
3632      * other, less forgiving, VMs that really need to dispose of
3633      * resources.
3634      */
3635     public void dispose() {
3636         surfaceData = NullSurfaceData.theInstance;
3637         invalidatePipe();
3638     }
3639 
3640     /**
3641      * Graphics has a finalize method that automatically calls dispose()
3642      * for subclasses.  For SunGraphics2D we do not need to be finalized
3643      * so that method simply causes us to be enqueued on the Finalizer
3644      * queues for no good reason.  Unfortunately, that method and
3645      * implementation are now considered part of the public contract
3646      * of that base class so we can not remove or gut the method.
3647      * We override it here with an empty method and the VM is smart
3648      * enough to know that if our override is empty then it should not
3649      * mark us as finalizeable.
3650      */
3651     @SuppressWarnings(&quot;deprecation&quot;)
3652     public void finalize() {
3653         // DO NOT REMOVE THIS METHOD
3654     }
3655 
3656     /**
3657      * Returns destination that this Graphics renders to.  This could be
3658      * either an Image or a Component; subclasses of SurfaceData are
3659      * responsible for returning the appropriate object.
3660      */
3661     public Object getDestination() {
3662         return surfaceData.getDestination();
3663     }
3664 
3665     /**
3666      * {@inheritDoc}
3667      *
3668      * @see sun.java2d.DestSurfaceProvider#getDestSurface
3669      */
3670     @Override
3671     public Surface getDestSurface() {
3672         return surfaceData;
3673     }
3674 }
    </pre>
  </body>
</html>
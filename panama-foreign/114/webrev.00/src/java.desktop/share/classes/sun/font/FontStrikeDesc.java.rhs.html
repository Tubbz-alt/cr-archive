<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/sun/font/FontStrikeDesc.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.font;
 27 
 28 import java.awt.Font;
 29 import java.awt.font.FontRenderContext;
 30 import java.awt.geom.AffineTransform;
 31 import static sun.awt.SunHints.*;
 32 
 33 /*
 34  * This class encapsulates every thing needed that distinguishes a strike.
 35  * It can be used as a key to locate a FontStrike in a Hashmap/cache.
 36  * It is not mutatable, but contains mutatable AffineTransform objects,
 37  * which for performance reasons it does not keep private copies of.
 38  * Therefore code constructing these must pass in transforms it guarantees
 39  * not to mutate.
 40  */
 41 public class FontStrikeDesc {
 42 
 43     /* Values to use as a mask that is used for faster comparison of
 44      * two strikes using just an int equality test.
 45      * The ones we don&#39;t use are listed here but commented out.
 46      * ie style is already built and hint &quot;OFF&quot; values are zero.
 47      * Note that this is used as a strike key and the same strike is used
 48      * for HRGB and HBGR, so only the orientation needed (H or V) is needed
 49      * to construct and distinguish a FontStrikeDesc. The rgb ordering
 50      * needed for rendering is stored in the graphics state.
 51      */
 52 //     static final int STYLE_PLAIN       = Font.PLAIN;            // 0x0000
 53 //     static final int STYLE_BOLD        = Font.BOLD;             // 0x0001
 54 //     static final int STYLE_ITALIC      = Font.ITALIC;           // 0x0002
 55 //     static final int STYLE_BOLDITALIC  = Font.BOLD|Font.ITALIC; // 0x0003
 56 //     static final int AA_OFF            = 0x0000;
 57     static final int AA_ON             = 0x0010;
 58     static final int AA_LCD_H          = 0x0020;
 59     static final int AA_LCD_V          = 0x0040;
 60 //     static final int FRAC_METRICS_OFF  = 0x0000;
 61     static final int FRAC_METRICS_ON   = 0x0100;
 62     static final int FRAC_METRICS_SP   = 0x0200;
 63 
 64     /* devTx is to get an inverse transform to get user space values
 65      * for metrics. Its not used otherwise, as the glyphTx is the important
 66      * one. But it does mean that a strike representing a 6pt font and identity
 67      * graphics transform is not equal to one for a 12 pt font and 2x scaled
 68      * graphics transform. Its likely to be very rare that this causes
 69      * duplication.
 70      */
 71     AffineTransform devTx;
 72     AffineTransform glyphTx; // all of ptSize, Font tx and Graphics tx.
 73     int style;
 74     int aaHint;
 75     int fmHint;
 76     private int hashCode;
 77     private int valuemask;
 78 
 79     public int hashCode() {
 80         /* Can cache hashcode since a strike(desc) is immutable.*/
 81         if (hashCode == 0) {
 82             hashCode = glyphTx.hashCode() + devTx.hashCode() + valuemask;
 83         }
 84         return hashCode;
 85     }
 86 
 87     public boolean equals(Object obj) {
 88         try {
 89             FontStrikeDesc desc = (FontStrikeDesc)obj;
 90             return (desc.valuemask == this.valuemask &amp;&amp;
 91                     desc.glyphTx.equals(this.glyphTx) &amp;&amp;
 92                     desc.devTx.equals(this.devTx));
 93         } catch (Exception e) {
 94             /* class cast or NP exceptions should not happen often, if ever,
 95              * and I am hoping that this is faster than an instanceof check.
 96              */
 97             return false;
 98         }
 99     }
100 
101     FontStrikeDesc() {
102         // used with init
103     }
104 
105 
106     /* This maps a public text AA hint value into one of the subset of values
107      * used to index strikes. For the purpose of the strike cache there are
108      * only 4 values : OFF, ON, LCD_HRGB, LCD_VRGB.
109      * Font and ptSize are needed to resolve the &#39;gasp&#39; table. The ptSize
110      * must therefore include device and font transforms.
111      */
112     public static int getAAHintIntVal(Object aa, Font2D font2D, int ptSize) {
<a name="1" id="anc1"></a><span class="line-added">113 </span>
<span class="line-added">114         if (FontUtilities.isMacOSX14 &amp;&amp;</span>
<span class="line-added">115             (aa == VALUE_TEXT_ANTIALIAS_OFF ||</span>
<span class="line-added">116              aa == VALUE_TEXT_ANTIALIAS_DEFAULT ||</span>
<span class="line-added">117              aa == VALUE_TEXT_ANTIALIAS_ON ||</span>
<span class="line-added">118              aa == VALUE_TEXT_ANTIALIAS_GASP))</span>
<span class="line-added">119         {</span>
<span class="line-added">120              return INTVAL_TEXT_ANTIALIAS_ON;</span>
<span class="line-added">121         }</span>
<span class="line-added">122 </span>
123         if (aa == VALUE_TEXT_ANTIALIAS_OFF ||
124             aa == VALUE_TEXT_ANTIALIAS_DEFAULT) {
125             return INTVAL_TEXT_ANTIALIAS_OFF;
126         } else if (aa == VALUE_TEXT_ANTIALIAS_ON) {
127             return INTVAL_TEXT_ANTIALIAS_ON;
128         } else if (aa == VALUE_TEXT_ANTIALIAS_GASP) {
129             if (font2D.useAAForPtSize(ptSize)) {
130                 return INTVAL_TEXT_ANTIALIAS_ON;
131             } else {
132                 return INTVAL_TEXT_ANTIALIAS_OFF;
133             }
134         } else if (aa == VALUE_TEXT_ANTIALIAS_LCD_HRGB ||
135                    aa == VALUE_TEXT_ANTIALIAS_LCD_HBGR) {
136             return INTVAL_TEXT_ANTIALIAS_LCD_HRGB;
137         } else if (aa == VALUE_TEXT_ANTIALIAS_LCD_VRGB ||
138                    aa == VALUE_TEXT_ANTIALIAS_LCD_VBGR) {
139             return INTVAL_TEXT_ANTIALIAS_LCD_VRGB;
140         } else {
141             return INTVAL_TEXT_ANTIALIAS_OFF;
142         }
143     }
144 
145     /* This maps a public text AA hint value into one of the subset of values
146      * used to index strikes. For the purpose of the strike cache there are
147      * only 4 values : OFF, ON, LCD_HRGB, LCD_VRGB.
148      * Font and FontRenderContext are needed to resolve the &#39;gasp&#39; table.
149      * This is similar to the method above, but used by callers which have not
150      * already calculated the glyph device point size.
151      */
152     public static int getAAHintIntVal(Font2D font2D, Font font,
153                                       FontRenderContext frc) {
154         Object aa = frc.getAntiAliasingHint();
<a name="2" id="anc2"></a><span class="line-added">155 </span>
<span class="line-added">156         if (FontUtilities.isMacOSX14 &amp;&amp;</span>
<span class="line-added">157             (aa == VALUE_TEXT_ANTIALIAS_OFF ||</span>
<span class="line-added">158              aa == VALUE_TEXT_ANTIALIAS_DEFAULT ||</span>
<span class="line-added">159              aa == VALUE_TEXT_ANTIALIAS_ON ||</span>
<span class="line-added">160              aa == VALUE_TEXT_ANTIALIAS_GASP))</span>
<span class="line-added">161         {</span>
<span class="line-added">162              return INTVAL_TEXT_ANTIALIAS_ON;</span>
<span class="line-added">163         }</span>
<span class="line-added">164 </span>
165         if (aa == VALUE_TEXT_ANTIALIAS_OFF ||
166             aa == VALUE_TEXT_ANTIALIAS_DEFAULT) {
167             return INTVAL_TEXT_ANTIALIAS_OFF;
168         } else if (aa == VALUE_TEXT_ANTIALIAS_ON) {
169             return INTVAL_TEXT_ANTIALIAS_ON;
170         } else if (aa == VALUE_TEXT_ANTIALIAS_GASP) {
171             /* FRC.isIdentity() would have been useful */
172             int ptSize;
173             AffineTransform tx = frc.getTransform();
174             if (tx.isIdentity() &amp;&amp; !font.isTransformed()) {
175                 ptSize = font.getSize();
176             } else {
177                 /* one or both transforms is not identity */
178                 float size = font.getSize2D();
179                 if (tx.isIdentity()) {
180                     tx = font.getTransform();
181                     tx.scale(size, size);
182                 } else {
183                     tx.scale(size, size);
184                     if (font.isTransformed()) {
185                         tx.concatenate(font.getTransform());
186                     }
187                 }
188                 double shearx = tx.getShearX();
189                 double scaley = tx.getScaleY();
190                 if (shearx != 0) {
191                     scaley = Math.sqrt(shearx * shearx + scaley * scaley);
192                 }
193                 ptSize = (int)(Math.abs(scaley)+0.5);
194             }
195             if (font2D.useAAForPtSize(ptSize)) {
196                 return INTVAL_TEXT_ANTIALIAS_ON;
197             } else {
198                 return INTVAL_TEXT_ANTIALIAS_OFF;
199             }
200         } else if (aa == VALUE_TEXT_ANTIALIAS_LCD_HRGB ||
201                    aa == VALUE_TEXT_ANTIALIAS_LCD_HBGR) {
202             return INTVAL_TEXT_ANTIALIAS_LCD_HRGB;
203         } else if (aa == VALUE_TEXT_ANTIALIAS_LCD_VRGB ||
204                    aa == VALUE_TEXT_ANTIALIAS_LCD_VBGR) {
205             return INTVAL_TEXT_ANTIALIAS_LCD_VRGB;
206         } else {
207             return INTVAL_TEXT_ANTIALIAS_OFF;
208         }
209     }
210 
211     public static int getFMHintIntVal(Object fm) {
212         if (fm == VALUE_FRACTIONALMETRICS_OFF ||
213             fm == VALUE_FRACTIONALMETRICS_DEFAULT) {
214             return INTVAL_FRACTIONALMETRICS_OFF;
215         } else {
216             return INTVAL_FRACTIONALMETRICS_ON;
217         }
218     }
219 
220     public FontStrikeDesc(AffineTransform devAt, AffineTransform at,
221                           int fStyle, int aa, int fm) {
222         devTx = devAt;
223         glyphTx = at; // not cloning glyphTx. Callers trusted to not mutate it.
224         style = fStyle;
225         aaHint = aa;
226         fmHint = fm;
227         valuemask = fStyle;
228         switch (aa) {
229            case INTVAL_TEXT_ANTIALIAS_OFF :
230                 break;
231            case INTVAL_TEXT_ANTIALIAS_ON  :
232                 valuemask |= AA_ON;
233                 break;
234            case INTVAL_TEXT_ANTIALIAS_LCD_HRGB :
235            case INTVAL_TEXT_ANTIALIAS_LCD_HBGR :
236                 valuemask |= AA_LCD_H;
237                 break;
238            case INTVAL_TEXT_ANTIALIAS_LCD_VRGB :
239            case INTVAL_TEXT_ANTIALIAS_LCD_VBGR :
240                 valuemask |= AA_LCD_V;
241                 break;
242            default: break;
243         }
244         if (fm == INTVAL_FRACTIONALMETRICS_ON) {
245            valuemask |= FRAC_METRICS_ON;
246         }
247     }
248 
249     FontStrikeDesc(FontStrikeDesc desc) {
250         devTx = desc.devTx;
251         // Clone the TX in this case as this is called when its known
252         // that &quot;desc&quot; is being re-used by its creator.
253         glyphTx = (AffineTransform)desc.glyphTx.clone();
254         style = desc.style;
255         aaHint = desc.aaHint;
256         fmHint = desc.fmHint;
257         hashCode = desc.hashCode;
258         valuemask = desc.valuemask;
259     }
260 
261 
262     public String toString() {
263         return &quot;FontStrikeDesc: Style=&quot;+style+ &quot; AA=&quot;+aaHint+ &quot; FM=&quot;+fmHint+
264             &quot; devTx=&quot;+devTx+ &quot; devTx.FontTx.ptSize=&quot;+glyphTx;
265     }
266 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
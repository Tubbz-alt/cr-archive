<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/print/PSPathGraphics.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../java2d/SurfaceData.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PathGraphics.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/print/PSPathGraphics.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
406             int boundsWidth = (int) rotBounds.getWidth();
407             int boundsHeight = (int) rotBounds.getHeight();
408 
409             if (boundsWidth &gt; 0 &amp;&amp; boundsHeight &gt; 0) {
410 
411 
412                 /* If the image has transparent or semi-transparent
413                  * pixels then we&#39;ll have the application re-render
414                  * the portion of the page covered by the image.
415                  * This will be done in a later call to print using the
416                  * saved graphics state.
417                  * However several special cases can be handled otherwise:
418                  * - bitmask transparency with a solid background colour
419                  * - images which have transparency color models but no
420                  * transparent pixels
421                  * - images with bitmask transparency and an IndexColorModel
422                  * (the common transparent GIF case) can be handled by
423                  * rendering just the opaque pixels.
424                  */
425                 boolean drawOpaque = true;
<span class="line-modified">426                 if (!handlingTransparency &amp;&amp; hasTransparentPixels(img)) {</span>


427                     drawOpaque = false;
428                     if (isBitmaskTransparency(img)) {
429                         if (bgcolor == null) {
430                             if (drawBitmaskImage(img, xform, bgcolor,
431                                                 srcX, srcY,
432                                                  srcWidth, srcHeight)) {
433                                 // image drawn, just return.
434                                 return true;
435                             }
436                         } else if (bgcolor.getTransparency()
437                                    == Transparency.OPAQUE) {
438                             drawOpaque = true;
439                         }
440                     }
441                     if (!canDoRedraws()) {
442                         drawOpaque = true;
443                     }
444                 } else {
445                     // if there&#39;s no transparent pixels there&#39;s no need
446                     // for a background colour. This can avoid edge artifacts
</pre>
</td>
<td>
<hr />
<pre>
406             int boundsWidth = (int) rotBounds.getWidth();
407             int boundsHeight = (int) rotBounds.getHeight();
408 
409             if (boundsWidth &gt; 0 &amp;&amp; boundsHeight &gt; 0) {
410 
411 
412                 /* If the image has transparent or semi-transparent
413                  * pixels then we&#39;ll have the application re-render
414                  * the portion of the page covered by the image.
415                  * This will be done in a later call to print using the
416                  * saved graphics state.
417                  * However several special cases can be handled otherwise:
418                  * - bitmask transparency with a solid background colour
419                  * - images which have transparency color models but no
420                  * transparent pixels
421                  * - images with bitmask transparency and an IndexColorModel
422                  * (the common transparent GIF case) can be handled by
423                  * rendering just the opaque pixels.
424                  */
425                 boolean drawOpaque = true;
<span class="line-modified">426                 if (isCompositing(getComposite())) {</span>
<span class="line-added">427                     drawOpaque = false;</span>
<span class="line-added">428                 } else if (!handlingTransparency &amp;&amp; hasTransparentPixels(img)) {</span>
429                     drawOpaque = false;
430                     if (isBitmaskTransparency(img)) {
431                         if (bgcolor == null) {
432                             if (drawBitmaskImage(img, xform, bgcolor,
433                                                 srcX, srcY,
434                                                  srcWidth, srcHeight)) {
435                                 // image drawn, just return.
436                                 return true;
437                             }
438                         } else if (bgcolor.getTransparency()
439                                    == Transparency.OPAQUE) {
440                             drawOpaque = true;
441                         }
442                     }
443                     if (!canDoRedraws()) {
444                         drawOpaque = true;
445                     }
446                 } else {
447                     // if there&#39;s no transparent pixels there&#39;s no need
448                     // for a background colour. This can avoid edge artifacts
</pre>
</td>
</tr>
</table>
<center><a href="../java2d/SurfaceData.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PathGraphics.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
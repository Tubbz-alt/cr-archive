<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/javax/swing/plaf/basic/BasicDirectoryModel.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../JFileChooser.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../text/html/FormView.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/javax/swing/plaf/basic/BasicDirectoryModel.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.swing.plaf.basic;
 27 
<span class="line-removed"> 28 import sun.awt.shell.ShellFolder;</span>
<span class="line-removed"> 29 </span>
<span class="line-removed"> 30 import javax.swing.*;</span>
<span class="line-removed"> 31 import javax.swing.event.ListDataEvent;</span>
<span class="line-removed"> 32 import javax.swing.filechooser.FileSystemView;</span>
 33 import java.beans.PropertyChangeEvent;
 34 import java.beans.PropertyChangeListener;
 35 import java.beans.PropertyChangeSupport;
 36 import java.io.File;
 37 import java.util.List;
 38 import java.util.Vector;
 39 import java.util.concurrent.Callable;









 40 
 41 /**
 42  * Basic implementation of a file list.
 43  *
 44  * @author Jeff Dinkins
 45  */
 46 @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
 47 public class BasicDirectoryModel extends AbstractListModel&lt;Object&gt; implements PropertyChangeListener {
 48 
<span class="line-modified"> 49     private JFileChooser filechooser = null;</span>
 50     // PENDING(jeff) pick the size more sensibly
<span class="line-modified"> 51     private Vector&lt;File&gt; fileCache = new Vector&lt;File&gt;(50);</span>
 52     private FilesLoader filesLoader = null;
 53     private Vector&lt;File&gt; files = null;
 54     private Vector&lt;File&gt; directories = null;
<span class="line-modified"> 55     private int fetchID = 0;</span>
 56 
 57     private PropertyChangeSupport changeSupport;
 58 
 59     private boolean busy = false;
 60 
 61     /**
 62      * Constructs a new instance of {@code BasicDirectoryModel}.
 63      *
 64      * @param filechooser an instance of {JFileChooser}
 65      */
 66     public BasicDirectoryModel(JFileChooser filechooser) {
 67         this.filechooser = filechooser;
 68         validateFileCache();
 69     }
 70 
 71     public void propertyChange(PropertyChangeEvent e) {
 72         String prop = e.getPropertyName();
 73         if(prop == JFileChooser.DIRECTORY_CHANGED_PROPERTY ||
 74            prop == JFileChooser.FILE_VIEW_CHANGED_PROPERTY ||
 75            prop == JFileChooser.FILE_FILTER_CHANGED_PROPERTY ||
</pre>
<hr />
<pre>
140                     files.add(f);
141                 }
142             }
143             return files;
144         }
145     }
146 
147     /**
148      * Validates content of file cache.
149      */
150     public void validateFileCache() {
151         File currentDirectory = filechooser.getCurrentDirectory();
152         if (currentDirectory == null) {
153             return;
154         }
155         if (filesLoader != null) {
156             filesLoader.loadThread.interrupt();
157             filesLoader.cancelRunnables();
158         }
159 
<span class="line-modified">160         setBusy(true, ++fetchID);</span>
<span class="line-modified">161 </span>
<span class="line-modified">162         filesLoader = new FilesLoader(currentDirectory, fetchID);</span>
163     }
164 
165     /**
166      * Renames a file in the underlying file system.
167      *
168      * @param oldFile a &lt;code&gt;File&lt;/code&gt; object representing
169      *        the existing file
170      * @param newFile a &lt;code&gt;File&lt;/code&gt; object representing
171      *        the desired new file name
172      * @return &lt;code&gt;true&lt;/code&gt; if rename succeeded,
173      *        otherwise &lt;code&gt;false&lt;/code&gt;
174      * @since 1.4
175      */
176     public boolean renameFile(File oldFile, File newFile) {
177         synchronized(fileCache) {
178             if (oldFile.renameTo(newFile)) {
179                 validateFileCache();
180                 return true;
181             }
182             return false;
</pre>
<hr />
<pre>
243     }
244 
245     /**
246      * Obsolete - not used
247      * @return a comparison of the file names
248      * @param a a file
249      * @param b another file
250      */
251     protected boolean lt(File a, File b) {
252         // First ignore case when comparing
253         int diff = a.getName().toLowerCase().compareTo(b.getName().toLowerCase());
254         if (diff != 0) {
255             return diff &lt; 0;
256         } else {
257             // May differ in case (e.g. &quot;mail&quot; vs. &quot;Mail&quot;)
258             return a.getName().compareTo(b.getName()) &lt; 0;
259         }
260     }
261 
262 
<span class="line-modified">263     class FilesLoader implements Runnable {</span>
<span class="line-modified">264         File currentDirectory = null;</span>
<span class="line-modified">265         int fid;</span>
<span class="line-modified">266         Vector&lt;DoChangeContents&gt; runnables = new Vector&lt;DoChangeContents&gt;(10);</span>
<span class="line-modified">267         final Thread loadThread;</span>



268 
<span class="line-modified">269         public FilesLoader(File currentDirectory, int fid) {</span>
270             this.currentDirectory = currentDirectory;
271             this.fid = fid;



272             String name = &quot;Basic L&amp;F File Loading Thread&quot;;
<span class="line-modified">273             this.loadThread = new Thread(null, this, name, 0, false);</span>
<span class="line-modified">274             this.loadThread.start();</span>
275         }
276 
277         @Override
278         public void run() {
279             run0();
280             setBusy(false, fid);
281         }
282 
<span class="line-modified">283         public void run0() {</span>
<span class="line-modified">284             FileSystemView fileSystem = filechooser.getFileSystemView();</span>
285 
286             if (loadThread.isInterrupted()) {
287                 return;
288             }
289 
<span class="line-modified">290             File[] list = fileSystem.getFiles(currentDirectory, filechooser.isFileHidingEnabled());</span>
291 
292             if (loadThread.isInterrupted()) {
293                 return;
294             }
295 
296             final Vector&lt;File&gt; newFileCache = new Vector&lt;File&gt;();
297             Vector&lt;File&gt; newFiles = new Vector&lt;File&gt;();
298 
299             // run through the file list, add directories and selectable files to fileCache
300             // Note that this block must be OUTSIDE of Invoker thread because of
301             // deadlock possibility with custom synchronized FileSystemView
302             for (File file : list) {
303                 if (filechooser.accept(file)) {
304                     boolean isTraversable = filechooser.isTraversable(file);
305 
306                     if (isTraversable) {
307                         newFileCache.addElement(file);
<span class="line-modified">308                     } else if (filechooser.isFileSelectionEnabled()) {</span>
309                         newFiles.addElement(file);
310                     }
311 
312                     if (loadThread.isInterrupted()) {
313                         return;
314                     }
315                 }
316             }
317 
318             // First sort alphabetically by filename
319             sort(newFileCache);
320             sort(newFiles);
321 
322             newFileCache.addAll(newFiles);
323 
324             // To avoid loads of synchronizations with Invoker and improve performance we
325             // execute the whole block on the COM thread
<span class="line-modified">326             DoChangeContents doChangeContents = ShellFolder.invoke(new Callable&lt;DoChangeContents&gt;() {</span>
327                 public DoChangeContents call() {
328                     int newSize = newFileCache.size();
329                     int oldSize = fileCache.size();
330 
331                     if (newSize &gt; oldSize) {
332                         //see if interval is added
333                         int start = oldSize;
334                         int end = newSize;
335                         for (int i = 0; i &lt; oldSize; i++) {
336                             if (!newFileCache.get(i).equals(fileCache.get(i))) {
337                                 start = i;
338                                 for (int j = i; j &lt; newSize; j++) {
339                                     if (newFileCache.get(j).equals(fileCache.get(i))) {
340                                         end = j;
341                                         break;
342                                     }
343                                 }
344                                 break;
345                             }
346                         }
</pre>
<hr />
<pre>
355                         //see if interval is removed
356                         int start = -1;
357                         int end = -1;
358                         for (int i = 0; i &lt; newSize; i++) {
359                             if (!newFileCache.get(i).equals(fileCache.get(i))) {
360                                 start = i;
361                                 end = i + oldSize - newSize;
362                                 break;
363                             }
364                         }
365                         if (start &gt;= 0 &amp;&amp; end &gt; start
366                             &amp;&amp; fileCache.subList(end, oldSize).equals(newFileCache.subList(start, newSize))) {
367                             if (loadThread.isInterrupted()) {
368                                 return null;
369                             }
370                             return new DoChangeContents(null, 0, new Vector&lt;&gt;(fileCache.subList(start, end)), start, fid);
371                         }
372                     }
373                     if (!fileCache.equals(newFileCache)) {
374                         if (loadThread.isInterrupted()) {
<span class="line-modified">375                             cancelRunnables(runnables);</span>
376                         }
377                         return new DoChangeContents(newFileCache, 0, fileCache, 0, fid);
378                     }
379                     return null;
380                 }
381             });
382 
<span class="line-modified">383             if (doChangeContents != null) {</span>
<span class="line-modified">384                 runnables.addElement(doChangeContents);</span>
<span class="line-removed">385                 SwingUtilities.invokeLater(doChangeContents);</span>
386             }
387         }
388 
<span class="line-modified">389 </span>
<span class="line-modified">390         public void cancelRunnables(Vector&lt;DoChangeContents&gt; runnables) {</span>
<span class="line-removed">391             for (DoChangeContents runnable : runnables) {</span>
392                 runnable.cancel();
393             }
394         }
<span class="line-removed">395 </span>
<span class="line-removed">396         public void cancelRunnables() {</span>
<span class="line-removed">397             cancelRunnables(runnables);</span>
<span class="line-removed">398         }</span>
399    }
400 
401 
402     /**
403      * Adds a PropertyChangeListener to the listener list. The listener is
404      * registered for all bound properties of this class.
405      * &lt;p&gt;
406      * If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
407      * no exception is thrown and no action is performed.
408      *
409      * @param    listener  the property change listener to be added
410      *
411      * @see #removePropertyChangeListener
412      * @see #getPropertyChangeListeners
413      *
414      * @since 1.6
415      */
416     public void addPropertyChangeListener(PropertyChangeListener listener) {
417         if (changeSupport == null) {
418             changeSupport = new PropertyChangeSupport(this);
</pre>
<hr />
<pre>
469      * @param oldValue the property&#39;s previous value
470      * @param newValue the property&#39;s new value
471      *
472      * @since 1.6
473      */
474     protected void firePropertyChange(String propertyName,
475                                       Object oldValue, Object newValue) {
476         if (changeSupport != null) {
477             changeSupport.firePropertyChange(propertyName,
478                                              oldValue, newValue);
479         }
480     }
481 
482 
483     /**
484      * Set the busy state for the model. The model is considered
485      * busy when it is running a separate (interruptable)
486      * thread in order to load the contents of a directory.
487      */
488     private synchronized void setBusy(final boolean busy, int fid) {
<span class="line-modified">489         if (fid == fetchID) {</span>
490             boolean oldValue = this.busy;
491             this.busy = busy;
492 
493             if (changeSupport != null &amp;&amp; busy != oldValue) {
494                 SwingUtilities.invokeLater(new Runnable() {
495                     public void run() {
496                         firePropertyChange(&quot;busy&quot;, !busy, busy);
497                     }
498                 });
499             }
500         }
501     }
502 
503 
<span class="line-modified">504     class DoChangeContents implements Runnable {</span>
<span class="line-modified">505         private List&lt;File&gt; addFiles;</span>
<span class="line-modified">506         private List&lt;File&gt; remFiles;</span>
507         private boolean doFire = true;
<span class="line-modified">508         private int fid;</span>
509         private int addStart = 0;
510         private int remStart = 0;
511 
<span class="line-modified">512         public DoChangeContents(List&lt;File&gt; addFiles, int addStart, List&lt;File&gt; remFiles, int remStart, int fid) {</span>

513             this.addFiles = addFiles;
514             this.addStart = addStart;
515             this.remFiles = remFiles;
516             this.remStart = remStart;
517             this.fid = fid;
518         }
519 
520         synchronized void cancel() {
<span class="line-modified">521                 doFire = false;</span>
522         }
523 
524         public synchronized void run() {
<span class="line-modified">525             if (fetchID == fid &amp;&amp; doFire) {</span>
526                 int remSize = (remFiles == null) ? 0 : remFiles.size();
527                 int addSize = (addFiles == null) ? 0 : addFiles.size();
528                 synchronized(fileCache) {
529                     if (remSize &gt; 0) {
530                         fileCache.removeAll(remFiles);
531                     }
532                     if (addSize &gt; 0) {
533                         fileCache.addAll(addStart, addFiles);
534                     }
535                     files = null;
536                     directories = null;
537                 }
538                 if (remSize &gt; 0 &amp;&amp; addSize == 0) {
539                     fireIntervalRemoved(BasicDirectoryModel.this, remStart, remStart + remSize - 1);
540                 } else if (addSize &gt; 0 &amp;&amp; remSize == 0 &amp;&amp; addStart + addSize &lt;= fileCache.size()) {
541                     fireIntervalAdded(BasicDirectoryModel.this, addStart, addStart + addSize - 1);
542                 } else {
543                     fireContentsChanged();
544                 }
545             }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.swing.plaf.basic;
 27 





 28 import java.beans.PropertyChangeEvent;
 29 import java.beans.PropertyChangeListener;
 30 import java.beans.PropertyChangeSupport;
 31 import java.io.File;
 32 import java.util.List;
 33 import java.util.Vector;
 34 import java.util.concurrent.Callable;
<span class="line-added"> 35 import java.util.concurrent.atomic.AtomicInteger;</span>
<span class="line-added"> 36 </span>
<span class="line-added"> 37 import javax.swing.AbstractListModel;</span>
<span class="line-added"> 38 import javax.swing.JFileChooser;</span>
<span class="line-added"> 39 import javax.swing.SwingUtilities;</span>
<span class="line-added"> 40 import javax.swing.event.ListDataEvent;</span>
<span class="line-added"> 41 import javax.swing.filechooser.FileSystemView;</span>
<span class="line-added"> 42 </span>
<span class="line-added"> 43 import sun.awt.shell.ShellFolder;</span>
 44 
 45 /**
 46  * Basic implementation of a file list.
 47  *
 48  * @author Jeff Dinkins
 49  */
 50 @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
 51 public class BasicDirectoryModel extends AbstractListModel&lt;Object&gt; implements PropertyChangeListener {
 52 
<span class="line-modified"> 53     private final JFileChooser filechooser;</span>
 54     // PENDING(jeff) pick the size more sensibly
<span class="line-modified"> 55     private final Vector&lt;File&gt; fileCache = new Vector&lt;File&gt;(50);</span>
 56     private FilesLoader filesLoader = null;
 57     private Vector&lt;File&gt; files = null;
 58     private Vector&lt;File&gt; directories = null;
<span class="line-modified"> 59     private final AtomicInteger fetchID = new AtomicInteger();</span>
 60 
 61     private PropertyChangeSupport changeSupport;
 62 
 63     private boolean busy = false;
 64 
 65     /**
 66      * Constructs a new instance of {@code BasicDirectoryModel}.
 67      *
 68      * @param filechooser an instance of {JFileChooser}
 69      */
 70     public BasicDirectoryModel(JFileChooser filechooser) {
 71         this.filechooser = filechooser;
 72         validateFileCache();
 73     }
 74 
 75     public void propertyChange(PropertyChangeEvent e) {
 76         String prop = e.getPropertyName();
 77         if(prop == JFileChooser.DIRECTORY_CHANGED_PROPERTY ||
 78            prop == JFileChooser.FILE_VIEW_CHANGED_PROPERTY ||
 79            prop == JFileChooser.FILE_FILTER_CHANGED_PROPERTY ||
</pre>
<hr />
<pre>
144                     files.add(f);
145                 }
146             }
147             return files;
148         }
149     }
150 
151     /**
152      * Validates content of file cache.
153      */
154     public void validateFileCache() {
155         File currentDirectory = filechooser.getCurrentDirectory();
156         if (currentDirectory == null) {
157             return;
158         }
159         if (filesLoader != null) {
160             filesLoader.loadThread.interrupt();
161             filesLoader.cancelRunnables();
162         }
163 
<span class="line-modified">164         int fid = fetchID.incrementAndGet();</span>
<span class="line-modified">165         setBusy(true, fid);</span>
<span class="line-modified">166         filesLoader = new FilesLoader(currentDirectory, fid);</span>
167     }
168 
169     /**
170      * Renames a file in the underlying file system.
171      *
172      * @param oldFile a &lt;code&gt;File&lt;/code&gt; object representing
173      *        the existing file
174      * @param newFile a &lt;code&gt;File&lt;/code&gt; object representing
175      *        the desired new file name
176      * @return &lt;code&gt;true&lt;/code&gt; if rename succeeded,
177      *        otherwise &lt;code&gt;false&lt;/code&gt;
178      * @since 1.4
179      */
180     public boolean renameFile(File oldFile, File newFile) {
181         synchronized(fileCache) {
182             if (oldFile.renameTo(newFile)) {
183                 validateFileCache();
184                 return true;
185             }
186             return false;
</pre>
<hr />
<pre>
247     }
248 
249     /**
250      * Obsolete - not used
251      * @return a comparison of the file names
252      * @param a a file
253      * @param b another file
254      */
255     protected boolean lt(File a, File b) {
256         // First ignore case when comparing
257         int diff = a.getName().toLowerCase().compareTo(b.getName().toLowerCase());
258         if (diff != 0) {
259             return diff &lt; 0;
260         } else {
261             // May differ in case (e.g. &quot;mail&quot; vs. &quot;Mail&quot;)
262             return a.getName().compareTo(b.getName()) &lt; 0;
263         }
264     }
265 
266 
<span class="line-modified">267     private final class FilesLoader implements Runnable {</span>
<span class="line-modified">268         private final FileSystemView fileSystemView;</span>
<span class="line-modified">269         private final boolean useFileHiding;</span>
<span class="line-modified">270         private final boolean fileSelectionEnabled;</span>
<span class="line-modified">271         private final int fid;</span>
<span class="line-added">272         private final File currentDirectory;</span>
<span class="line-added">273         private volatile DoChangeContents runnable;</span>
<span class="line-added">274         private final Thread loadThread;</span>
275 
<span class="line-modified">276         private FilesLoader(File currentDirectory, int fid) {</span>
277             this.currentDirectory = currentDirectory;
278             this.fid = fid;
<span class="line-added">279             fileSystemView = filechooser.getFileSystemView();</span>
<span class="line-added">280             useFileHiding = filechooser.isFileHidingEnabled();</span>
<span class="line-added">281             fileSelectionEnabled = filechooser.isFileSelectionEnabled();</span>
282             String name = &quot;Basic L&amp;F File Loading Thread&quot;;
<span class="line-modified">283             loadThread = new Thread(null, this, name, 0, false);</span>
<span class="line-modified">284             loadThread.start();</span>
285         }
286 
287         @Override
288         public void run() {
289             run0();
290             setBusy(false, fid);
291         }
292 
<span class="line-modified">293         private void run0() {</span>
<span class="line-modified">294             FileSystemView fileSystem = fileSystemView;</span>
295 
296             if (loadThread.isInterrupted()) {
297                 return;
298             }
299 
<span class="line-modified">300             File[] list = fileSystem.getFiles(currentDirectory, useFileHiding);</span>
301 
302             if (loadThread.isInterrupted()) {
303                 return;
304             }
305 
306             final Vector&lt;File&gt; newFileCache = new Vector&lt;File&gt;();
307             Vector&lt;File&gt; newFiles = new Vector&lt;File&gt;();
308 
309             // run through the file list, add directories and selectable files to fileCache
310             // Note that this block must be OUTSIDE of Invoker thread because of
311             // deadlock possibility with custom synchronized FileSystemView
312             for (File file : list) {
313                 if (filechooser.accept(file)) {
314                     boolean isTraversable = filechooser.isTraversable(file);
315 
316                     if (isTraversable) {
317                         newFileCache.addElement(file);
<span class="line-modified">318                     } else if (fileSelectionEnabled) {</span>
319                         newFiles.addElement(file);
320                     }
321 
322                     if (loadThread.isInterrupted()) {
323                         return;
324                     }
325                 }
326             }
327 
328             // First sort alphabetically by filename
329             sort(newFileCache);
330             sort(newFiles);
331 
332             newFileCache.addAll(newFiles);
333 
334             // To avoid loads of synchronizations with Invoker and improve performance we
335             // execute the whole block on the COM thread
<span class="line-modified">336             runnable = ShellFolder.invoke(new Callable&lt;DoChangeContents&gt;() {</span>
337                 public DoChangeContents call() {
338                     int newSize = newFileCache.size();
339                     int oldSize = fileCache.size();
340 
341                     if (newSize &gt; oldSize) {
342                         //see if interval is added
343                         int start = oldSize;
344                         int end = newSize;
345                         for (int i = 0; i &lt; oldSize; i++) {
346                             if (!newFileCache.get(i).equals(fileCache.get(i))) {
347                                 start = i;
348                                 for (int j = i; j &lt; newSize; j++) {
349                                     if (newFileCache.get(j).equals(fileCache.get(i))) {
350                                         end = j;
351                                         break;
352                                     }
353                                 }
354                                 break;
355                             }
356                         }
</pre>
<hr />
<pre>
365                         //see if interval is removed
366                         int start = -1;
367                         int end = -1;
368                         for (int i = 0; i &lt; newSize; i++) {
369                             if (!newFileCache.get(i).equals(fileCache.get(i))) {
370                                 start = i;
371                                 end = i + oldSize - newSize;
372                                 break;
373                             }
374                         }
375                         if (start &gt;= 0 &amp;&amp; end &gt; start
376                             &amp;&amp; fileCache.subList(end, oldSize).equals(newFileCache.subList(start, newSize))) {
377                             if (loadThread.isInterrupted()) {
378                                 return null;
379                             }
380                             return new DoChangeContents(null, 0, new Vector&lt;&gt;(fileCache.subList(start, end)), start, fid);
381                         }
382                     }
383                     if (!fileCache.equals(newFileCache)) {
384                         if (loadThread.isInterrupted()) {
<span class="line-modified">385                             cancelRunnables();</span>
386                         }
387                         return new DoChangeContents(newFileCache, 0, fileCache, 0, fid);
388                     }
389                     return null;
390                 }
391             });
392 
<span class="line-modified">393             if (runnable != null &amp;&amp; !loadThread.isInterrupted()) {</span>
<span class="line-modified">394                 SwingUtilities.invokeLater(runnable);</span>

395             }
396         }
397 
<span class="line-modified">398         private void cancelRunnables() {</span>
<span class="line-modified">399             if (runnable != null) {</span>

400                 runnable.cancel();
401             }
402         }




403    }
404 
405 
406     /**
407      * Adds a PropertyChangeListener to the listener list. The listener is
408      * registered for all bound properties of this class.
409      * &lt;p&gt;
410      * If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
411      * no exception is thrown and no action is performed.
412      *
413      * @param    listener  the property change listener to be added
414      *
415      * @see #removePropertyChangeListener
416      * @see #getPropertyChangeListeners
417      *
418      * @since 1.6
419      */
420     public void addPropertyChangeListener(PropertyChangeListener listener) {
421         if (changeSupport == null) {
422             changeSupport = new PropertyChangeSupport(this);
</pre>
<hr />
<pre>
473      * @param oldValue the property&#39;s previous value
474      * @param newValue the property&#39;s new value
475      *
476      * @since 1.6
477      */
478     protected void firePropertyChange(String propertyName,
479                                       Object oldValue, Object newValue) {
480         if (changeSupport != null) {
481             changeSupport.firePropertyChange(propertyName,
482                                              oldValue, newValue);
483         }
484     }
485 
486 
487     /**
488      * Set the busy state for the model. The model is considered
489      * busy when it is running a separate (interruptable)
490      * thread in order to load the contents of a directory.
491      */
492     private synchronized void setBusy(final boolean busy, int fid) {
<span class="line-modified">493         if (fid == fetchID.get()) {</span>
494             boolean oldValue = this.busy;
495             this.busy = busy;
496 
497             if (changeSupport != null &amp;&amp; busy != oldValue) {
498                 SwingUtilities.invokeLater(new Runnable() {
499                     public void run() {
500                         firePropertyChange(&quot;busy&quot;, !busy, busy);
501                     }
502                 });
503             }
504         }
505     }
506 
507 
<span class="line-modified">508     private final class DoChangeContents implements Runnable {</span>
<span class="line-modified">509         private final List&lt;File&gt; addFiles;</span>
<span class="line-modified">510         private final List&lt;File&gt; remFiles;</span>
511         private boolean doFire = true;
<span class="line-modified">512         private final int fid;</span>
513         private int addStart = 0;
514         private int remStart = 0;
515 
<span class="line-modified">516         DoChangeContents(List&lt;File&gt; addFiles, int addStart, List&lt;File&gt; remFiles,</span>
<span class="line-added">517                          int remStart, int fid) {</span>
518             this.addFiles = addFiles;
519             this.addStart = addStart;
520             this.remFiles = remFiles;
521             this.remStart = remStart;
522             this.fid = fid;
523         }
524 
525         synchronized void cancel() {
<span class="line-modified">526             doFire = false;</span>
527         }
528 
529         public synchronized void run() {
<span class="line-modified">530             if (fetchID.get() == fid &amp;&amp; doFire) {</span>
531                 int remSize = (remFiles == null) ? 0 : remFiles.size();
532                 int addSize = (addFiles == null) ? 0 : addFiles.size();
533                 synchronized(fileCache) {
534                     if (remSize &gt; 0) {
535                         fileCache.removeAll(remFiles);
536                     }
537                     if (addSize &gt; 0) {
538                         fileCache.addAll(addStart, addFiles);
539                     }
540                     files = null;
541                     directories = null;
542                 }
543                 if (remSize &gt; 0 &amp;&amp; addSize == 0) {
544                     fireIntervalRemoved(BasicDirectoryModel.this, remStart, remStart + remSize - 1);
545                 } else if (addSize &gt; 0 &amp;&amp; remSize == 0 &amp;&amp; addStart + addSize &lt;= fileCache.size()) {
546                     fireIntervalAdded(BasicDirectoryModel.this, addStart, addStart + addSize - 1);
547                 } else {
548                     fireContentsChanged();
549                 }
550             }
</pre>
</td>
</tr>
</table>
<center><a href="../../JFileChooser.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../text/html/FormView.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
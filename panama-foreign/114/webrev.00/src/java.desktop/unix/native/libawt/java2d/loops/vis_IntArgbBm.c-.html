<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libawt/java2d/loops/vis_IntArgbBm.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #if !defined(JAVA2D_NO_MLIB) || defined(MLIB_ADD_SUFF)
 27 
 28 #include &quot;vis_AlphaMacros.h&quot;
 29 
 30 /***************************************************************/
 31 
 32 static mlib_u64 vis_amask_arr[] = {
 33     0x0000000000000000,
 34     0x00000000FF000000,
 35     0xFF00000000000000,
 36     0xFF000000FF000000,
 37 };
 38 
 39 /***************************************************************/
 40 
 41 void ADD_SUFF(IntArgbBmToIntArgbConvert)(BLIT_PARAMS)
 42 {
 43     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
 44     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
 45     mlib_d64 dd, dmask, dFF;
 46     mlib_s32 i, i0, j, x, mask;
 47 
 48     if (dstScan == 4*width &amp;&amp; srcScan == 4*width) {
 49         width *= height;
 50         height = 1;
 51     }
 52 
 53     dmask = vis_to_double_dup(0xFFFFFF);
 54     dFF = vis_to_double_dup(0xFFFFFFFF);
 55 
 56     for (j = 0; j &lt; height; j++) {
 57         mlib_s32 *src = srcBase;
 58         mlib_s32 *dst = dstBase;
 59 
 60         i = i0 = 0;
 61 
 62         if ((mlib_s32)dst &amp; 7) {
 63             x = src[i];
 64             dst[i] = (x &lt;&lt; 7) &gt;&gt; 7;
 65             i0 = 1;
 66         }
 67 
 68 #pragma pipeloop(0)
 69         for (i = i0; i &lt;= (mlib_s32)width - 2; i += 2) {
 70             mlib_u8 *pp0 = (mlib_u8*)(src + i);
 71             mlib_u8 *pp1 = (mlib_u8*)(src + i + 1);
 72             dd = vis_freg_pair(*(mlib_f32*)pp0, *(mlib_f32*)pp1);
 73             dd = vis_fand(dd, dmask);
 74 #if 1
 75             mask = ((*pp0 &amp; 1) &lt;&lt; 7) | ((*pp1 &amp; 1) &lt;&lt; 3);
 76             *(mlib_d64*)(dst + i) = dd;
 77             vis_pst_8(dFF, dst + i, mask);
 78 #else
 79             mask = ((*pp0 &amp; 1) &lt;&lt; 1) | (*pp1 &amp; 1);
 80             dd = vis_for(dd, ((mlib_d64*)vis_amask_arr)[mask]);
 81             *(mlib_d64*)(dst + i) = dd;
 82 #endif
 83         }
 84 
 85         if (i &lt; width) {
 86             x = src[i];
 87             dst[i] = (x &lt;&lt; 7) &gt;&gt; 7;
 88         }
 89 
 90         PTR_ADD(dstBase, dstScan);
 91         PTR_ADD(srcBase, srcScan);
 92     }
 93 }
 94 
 95 /***************************************************************/
 96 
 97 void ADD_SUFF(IntArgbToIntArgbBmConvert)(BLIT_PARAMS)
 98 {
 99     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
100     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
101     mlib_d64 dd, dFF;
102     mlib_s32 i, i0, j, x, mask;
103 
104     if (dstScan == 4*width &amp;&amp; srcScan == 4*width) {
105         width *= height;
106         height = 1;
107     }
108 
109     dFF = vis_to_double_dup(0xFFFFFFFF);
110 
111     for (j = 0; j &lt; height; j++) {
112         mlib_s32 *src = srcBase;
113         mlib_s32 *dst = dstBase;
114 
115         i = i0 = 0;
116 
117         if ((mlib_s32)dst &amp; 7) {
118             x = src[i];
119             dst[i] = x | ((x &gt;&gt; 31) &lt;&lt; 24);
120             i0 = 1;
121         }
122 
123 #pragma pipeloop(0)
124         for (i = i0; i &lt;= (mlib_s32)width - 2; i += 2) {
125             dd = vis_freg_pair(((mlib_f32*)src)[i], ((mlib_f32*)src)[i + 1]);
126 #ifdef VIS_USE_FCMP
127             mask = vis_fcmplt32(dd, dzero);
128             mask = ((mask &lt;&lt; 3) | (mask &lt;&lt; 6)) &amp; 0x88;
129 #else
130             mask = (*(mlib_u8*)(src + i) &amp; 0x80) |
131                    ((*(mlib_u8*)(src + i + 1) &gt;&gt; 4) &amp; 0x8);
132 #endif
133             *(mlib_d64*)(dst + i) = dd;
134             vis_pst_8(dFF, dst + i, mask);
135         }
136 
137         if (i &lt; width) {
138             x = src[i];
139             dst[i] = x | ((x &gt;&gt; 31) &lt;&lt; 24);
140         }
141 
142         PTR_ADD(dstBase, dstScan);
143         PTR_ADD(srcBase, srcScan);
144     }
145 }
146 
147 /***************************************************************/
148 
149 void ADD_SUFF(IntArgbToIntArgbBmScaleConvert)(SCALE_PARAMS)
150 {
151     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
152     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
153     mlib_d64 dd, dFF;
154     mlib_s32 j, x, mask;
155 
156     dFF = vis_to_double_dup(0xFFFFFFFF);
157 
158     for (j = 0; j &lt; height; j++) {
159         mlib_u32 *src = srcBase;
160         mlib_u32 *dst = dstBase;
161         mlib_u32 *dst_end = dst + width;
162         mlib_s32 tmpsxloc = sxloc;
163 
164         PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
165 
166         if ((mlib_s32)dst &amp; 7) {
167             x = src[tmpsxloc &gt;&gt; shift];
168             *dst++ = x | ((x &gt;&gt; 31) &lt;&lt; 24);
169             tmpsxloc += sxinc;
170         }
171 
172 #pragma pipeloop(0)
173         for (; dst &lt;= dst_end - 2; dst += 2) {
174             mlib_u8 *pp0 = (mlib_u8*)(src + (tmpsxloc &gt;&gt; shift));
175             mlib_u8 *pp1 = (mlib_u8*)(src + ((tmpsxloc + sxinc) &gt;&gt; shift));
176             dd = vis_freg_pair(*(mlib_f32*)pp0, *(mlib_f32*)pp1);
177 #ifdef VIS_USE_FCMP
178             mask = vis_fcmplt32(dd, dzero);
179             mask = ((mask &lt;&lt; 3) | (mask &lt;&lt; 6)) &amp; 0x88;
180 #else
181             mask = (*pp0 &amp; 0x80) | ((*pp1 &gt;&gt; 4) &amp; 0x8);
182 #endif
183             *(mlib_d64*)dst = dd;
184             vis_pst_8(dFF, dst, mask);
185             tmpsxloc += 2*sxinc;
186         }
187 
188         for (; dst &lt; dst_end; dst++) {
189             x = src[tmpsxloc &gt;&gt; shift];
190             *dst++ = x | ((x &gt;&gt; 31) &lt;&lt; 24);
191             tmpsxloc += sxinc;
192         }
193 
194         PTR_ADD(dstBase, dstScan);
195         syloc += syinc;
196     }
197 }
198 
199 /***************************************************************/
200 
201 void ADD_SUFF(ByteIndexedToIntArgbBmConvert)(BLIT_PARAMS)
202 {
203     jint *pixLut = pSrcInfo-&gt;lutBase;
204     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
205     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
206     mlib_d64 dd, dFF;
207     mlib_s32 i, i0, j, x, mask;
208 
209     if (srcScan == width &amp;&amp; dstScan == 4*width) {
210         width *= height;
211         height = 1;
212     }
213 
214     dFF = vis_to_double_dup(0xFFFFFFFF);
215 
216     for (j = 0; j &lt; height; j++) {
217         mlib_u8  *src = srcBase;
218         mlib_s32 *dst = dstBase;
219 
220         i = i0 = 0;
221 
222         if ((mlib_s32)dst &amp; 7) {
223             x = pixLut[src[i]];
224             dst[i] =  x | ((x &gt;&gt; 31) &lt;&lt; 24);
225             i0 = 1;
226         }
227 
228 #pragma pipeloop(0)
229         for (i = i0; i &lt;= (mlib_s32)width - 2; i += 2) {
230             mlib_u8 *pp0 = (mlib_u8*)(pixLut + src[i]);
231             mlib_u8 *pp1 = (mlib_u8*)(pixLut + src[i + 1]);
232             dd = vis_freg_pair(*(mlib_f32*)pp0, *(mlib_f32*)pp1);
233 #ifdef VIS_USE_FCMP
234             mask = vis_fcmplt32(dd, dzero);
235             mask = ((mask &lt;&lt; 3) | (mask &lt;&lt; 6)) &amp; 0x88;
236 #else
237             mask = (*pp0 &amp; 0x80) | ((*pp1 &gt;&gt; 4) &amp; 0x8);
238 #endif
239             *(mlib_d64*)(dst + i) = dd;
240             vis_pst_8(dFF, dst + i, mask);
241         }
242 
243         for (; i &lt; width; i++) {
244             x = pixLut[src[i]];
245             dst[i] =  x | ((x &gt;&gt; 31) &lt;&lt; 24);
246         }
247 
248         PTR_ADD(dstBase, dstScan);
249         PTR_ADD(srcBase, srcScan);
250     }
251 }
252 
253 /***************************************************************/
254 
255 void ADD_SUFF(ByteIndexedToIntArgbBmScaleConvert)(SCALE_PARAMS)
256 {
257     jint *pixLut = pSrcInfo-&gt;lutBase;
258     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
259     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
260     mlib_d64 dd, dFF;
261     mlib_s32 j, x, mask;
262 
263     dFF = vis_to_double_dup(0xFFFFFFFF);
264 
265     for (j = 0; j &lt; height; j++) {
266         mlib_u8  *src = srcBase;
267         mlib_s32 *dst = dstBase;
268         mlib_s32 *dst_end = dst + width;
269         mlib_s32 tmpsxloc = sxloc;
270 
271         PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
272 
273         if ((mlib_s32)dst &amp; 7) {
274             x = pixLut[src[tmpsxloc &gt;&gt; shift]];
275             *dst++ = x | ((x &gt;&gt; 31) &lt;&lt; 24);
276             tmpsxloc += sxinc;
277         }
278 
279 #pragma pipeloop(0)
280         for (; dst &lt;= dst_end - 2; dst += 2) {
281             mlib_u8 *pp0 = (void*)(pixLut + src[tmpsxloc &gt;&gt; shift]);
282             mlib_u8 *pp1 = (void*)(pixLut + src[(tmpsxloc + sxinc) &gt;&gt; shift]);
283             dd = vis_freg_pair(*(mlib_f32*)pp0, *(mlib_f32*)pp1);
284 #ifdef VIS_USE_FCMP
285             mask = vis_fcmplt32(dd, dzero);
286             mask = ((mask &lt;&lt; 3) | (mask &lt;&lt; 6)) &amp; 0x88;
287 #else
288             mask = (*pp0 &amp; 0x80) | ((*pp1 &gt;&gt; 4) &amp; 0x8);
289 #endif
290             *(mlib_d64*)dst = dd;
291             vis_pst_8(dFF, dst, mask);
292             tmpsxloc += 2*sxinc;
293         }
294 
295         for (; dst &lt; dst_end; dst++) {
296             x = pixLut[src[tmpsxloc &gt;&gt; shift]];
297             *dst++ = x | ((x &gt;&gt; 31) &lt;&lt; 24);
298             tmpsxloc += sxinc;
299         }
300 
301         PTR_ADD(dstBase, dstScan);
302         syloc += syinc;
303     }
304 }
305 
306 /***************************************************************/
307 
308 void ADD_SUFF(ByteIndexedBmToIntArgbBmXparOver)(BLIT_PARAMS)
309 {
310     jint *pixLut = pSrcInfo-&gt;lutBase;
311     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
312     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
313     mlib_d64 dd, dFF;
314     mlib_s32 i, i0, j, x, mask;
315 
316     if (srcScan == width &amp;&amp; dstScan == 4*width) {
317         width *= height;
318         height = 1;
319     }
320 
321     dFF = vis_to_double_dup(0xFF000000);
322 
323     for (j = 0; j &lt; height; j++) {
324         mlib_u8  *src = srcBase;
325         mlib_s32 *dst = dstBase;
326 
327         i = i0 = 0;
328 
329         if ((mlib_s32)dst &amp; 7) {
330             x = pixLut[src[i]];
331             if (x &lt; 0) {
332                 dst[i] = x | 0xFF000000;
333             }
334             i0 = 1;
335         }
336 
337 #pragma pipeloop(0)
338         for (i = i0; i &lt;= (mlib_s32)width - 2; i += 2) {
339             mlib_u8 *pp0 = (mlib_u8*)(pixLut + src[i]);
340             mlib_u8 *pp1 = (mlib_u8*)(pixLut + src[i + 1]);
341             dd = vis_freg_pair(*(mlib_f32*)pp0, *(mlib_f32*)pp1);
342 #ifdef VIS_USE_FCMP
343             mask = vis_fcmplt32(dd, dzero);
344 #else
345             mask = ((*pp0 &amp; 0x80) &gt;&gt; 6) | ((*pp1 &amp; 0x80) &gt;&gt; 7);
346 #endif
347             dd = vis_for(dd, dFF);
348             vis_pst_32(dd, dst + i, mask);
349         }
350 
351         for (; i &lt; width; i++) {
352             x = pixLut[src[i]];
353             if (x &lt; 0) {
354                 dst[i] = x | 0xFF000000;
355             }
356         }
357 
358         PTR_ADD(dstBase, dstScan);
359         PTR_ADD(srcBase, srcScan);
360     }
361 }
362 
363 /***************************************************************/
364 
365 void ADD_SUFF(ByteIndexedBmToIntArgbBmScaleXparOver)(SCALE_PARAMS)
366 {
367     jint *pixLut = pSrcInfo-&gt;lutBase;
368     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
369     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
370     mlib_d64 dd, dFF;
371     mlib_s32 j, x, mask;
372 
373     dFF = vis_to_double_dup(0xFF000000);
374 
375     for (j = 0; j &lt; height; j++) {
376         mlib_u8  *src = srcBase;
377         mlib_s32 *dst = dstBase;
378         mlib_s32 *dst_end = dst + width;
379         mlib_s32 tmpsxloc = sxloc;
380 
381         PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
382 
383         if ((mlib_s32)dst &amp; 7) {
384             x = pixLut[src[tmpsxloc &gt;&gt; shift]];
385             tmpsxloc += sxinc;
386             if (x &lt; 0) {
387                 *dst = x | 0xFF000000;
388             }
389             dst++;
390         }
391 
392 #pragma pipeloop(0)
393         for (; dst &lt;= dst_end - 2; dst += 2) {
394             mlib_u8 *pp0 = (void*)(pixLut + src[tmpsxloc &gt;&gt; shift]);
395             mlib_u8 *pp1 = (void*)(pixLut + src[(tmpsxloc + sxinc) &gt;&gt; shift]);
396             dd = vis_freg_pair(*(mlib_f32*)pp0, *(mlib_f32*)pp1);
397 #ifdef VIS_USE_FCMP
398             mask = vis_fcmplt32(dd, dzero);
399 #else
400             mask = ((*pp0 &amp; 0x80) &gt;&gt; 6) | ((*pp1 &amp; 0x80) &gt;&gt; 7);
401 #endif
402             dd = vis_for(dd, dFF);
403             vis_pst_32(dd, dst, mask);
404             tmpsxloc += 2*sxinc;
405         }
406 
407         for (; dst &lt; dst_end; dst++) {
408             x = pixLut[src[tmpsxloc &gt;&gt; shift]];
409             tmpsxloc += sxinc;
410             if (x &lt; 0) {
411                 *dst = x | 0xFF000000;
412             }
413         }
414 
415         PTR_ADD(dstBase, dstScan);
416         syloc += syinc;
417     }
418 }
419 
420 /***************************************************************/
421 
422 void ADD_SUFF(ByteIndexedBmToIntArgbBmXparBgCopy)(BCOPY_PARAMS)
423 {
424     jint *pixLut = pSrcInfo-&gt;lutBase;
425     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
426     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
427     mlib_d64 dd, dFF, d_bgpixel;
428     mlib_s32 j, x, mask;
429 
430     if (srcScan == width &amp;&amp; dstScan == 4*width) {
431         width *= height;
432         height = 1;
433     }
434 
435     dFF = vis_to_double_dup(0xFF000000);
436     d_bgpixel = vis_to_double_dup(bgpixel);
437 
438     for (j = 0; j &lt; height; j++) {
439         mlib_u8  *src = srcBase;
440         mlib_s32 *dst = dstBase;
441         mlib_s32 *dst_end;
442 
443         dst_end = dst + width;
444 
445         if ((mlib_s32)dst &amp; 7) {
446             x = pixLut[*src++];
447             if (x &lt; 0) {
448                 *dst = x | 0xFF000000;
449             } else {
450                 *dst = bgpixel;
451             }
452             dst++;
453         }
454 
455 #pragma pipeloop(0)
456         for (; dst &lt;= (dst_end - 2); dst += 2) {
457             mlib_u8 *pp0 = (mlib_u8*)(pixLut + src[0]);
458             mlib_u8 *pp1 = (mlib_u8*)(pixLut + src[1]);
459             dd = vis_freg_pair(*(mlib_f32*)pp0, *(mlib_f32*)pp1);
460 #ifdef VIS_USE_FCMP
461             mask = vis_fcmplt32(dd, dzero);
462 #else
463             mask = ((*pp0 &amp; 0x80) &gt;&gt; 6) | ((*pp1 &amp; 0x80) &gt;&gt; 7);
464 #endif
465             dd = vis_for(dd, dFF);
466             *(mlib_d64*)dst = d_bgpixel;
467             vis_pst_32(dd, dst, mask);
468             src += 2;
469         }
470 
471         while (dst &lt; dst_end) {
472             x = pixLut[*src++];
473             if (x &lt; 0) {
474                 *dst = x | 0xFF000000;
475             } else {
476                 *dst = bgpixel;
477             }
478             dst++;
479         }
480 
481         PTR_ADD(dstBase, dstScan);
482         PTR_ADD(srcBase, srcScan);
483     }
484 }
485 
486 /***************************************************************/
487 
488 void ADD_SUFF(IntArgbAlphaMaskFill)(void *rasBase,
489                                     jubyte *pMask,
490                                     jint maskOff,
491                                     jint maskScan,
492                                     jint width,
493                                     jint height,
494                                     jint fgColor,
495                                     SurfaceDataRasInfo *pRasInfo,
496                                     NativePrimitive *pPrim,
497                                     CompositeInfo *pCompInfo);
498 
499 void ADD_SUFF(IntArgbBmAlphaMaskFill)(void *rasBase,
500                                       jubyte *pMask,
501                                       jint maskOff,
502                                       jint maskScan,
503                                       jint width,
504                                       jint height,
505                                       jint fgColor,
506                                       SurfaceDataRasInfo *pRasInfo,
507                                       NativePrimitive *pPrim,
508                                       CompositeInfo *pCompInfo)
509 {
510     mlib_u8  *dst = rasBase;
511     mlib_s32 rasScan = pRasInfo-&gt;scanStride;
512     mlib_s32 i, j;
513 
514     if (rasScan == 4*width) {
515         width *= height;
516         height = 1;
517     }
518 
519     for (j = 0; j &lt; height; j++) {
520         for (i = 0; i &lt; width; i++) {
521             dst[4*i] = ((mlib_s32)dst[4*i] &lt;&lt; 31) &gt;&gt; 31;
522         }
523         PTR_ADD(dst, rasScan);
524     }
525 
526     ADD_SUFF(IntArgbAlphaMaskFill)(rasBase, pMask, maskOff, maskScan,
527                                    width, height,
528                                    fgColor, pRasInfo, pPrim, pCompInfo);
529 
530     for (j = 0; j &lt; height; j++) {
531         for (i = 0; i &lt; width; i++) {
532             dst[4*i] = ((mlib_s32)dst[4*i] &lt;&lt; 31) &gt;&gt; 31;
533         }
534         PTR_ADD(dst, rasScan);
535     }
536 }
537 
538 /***************************************************************/
539 
540 void ADD_SUFF(IntArgbBmDrawGlyphListAA)(GLYPH_LIST_PARAMS)
541 {
542     mlib_s32 glyphCounter;
543     mlib_s32 scan = pRasInfo-&gt;scanStride;
544     mlib_u8  *dstBase;
545     mlib_s32 j;
546     mlib_d64 dmix0, dmix1, dd, d0, d1, e0, e1, fgpixel_d;
547     mlib_d64 done, done16, d_half;
548     mlib_s32 pix, mask, srcA, dstA;
549     mlib_f32 srcG_f;
550 
551     done = vis_to_double_dup(0x7fff7fff);
552     done16 = vis_to_double_dup(0x7fff);
553     d_half = vis_to_double_dup((1 &lt;&lt; (16 + 6)) | (1 &lt;&lt; 6));
554 
555     fgpixel_d = vis_to_double_dup(fgpixel);
556     srcG_f = vis_to_float(argbcolor);
557 
558     srcA = (mlib_u32)argbcolor &gt;&gt; 24;
559 
560     vis_write_gsr(0 &lt;&lt; 3);
561 
562     for (glyphCounter = 0; glyphCounter &lt; totalGlyphs; glyphCounter++) {
563         const jubyte *pixels;
564         unsigned int rowBytes;
565         int left, top;
566         int width, height;
567         int right, bottom;
568 
569         pixels = (const jubyte *) glyphs[glyphCounter].pixels;
570 
571         if (!pixels) continue;
572 
573         left = glyphs[glyphCounter].x;
574         top = glyphs[glyphCounter].y;
575         width = glyphs[glyphCounter].width;
576         height = glyphs[glyphCounter].height;
577         rowBytes = width;
578         right = left + width;
579         bottom = top + height;
580         if (left &lt; clipLeft) {
581             pixels += clipLeft - left;
582             left = clipLeft;
583         }
584         if (top &lt; clipTop) {
585             pixels += (clipTop - top) * rowBytes;
586             top = clipTop;
587         }
588         if (right &gt; clipRight) {
589             right = clipRight;
590         }
591         if (bottom &gt; clipBottom) {
592             bottom = clipBottom;
593         }
594         if (right &lt;= left || bottom &lt;= top) {
595             continue;
596         }
597         width = right - left;
598         height = bottom - top;
599 
600         dstBase = pRasInfo-&gt;rasBase;
601         PTR_ADD(dstBase, top*scan + 4*left);
602 
603         for (j = 0; j &lt; height; j++) {
604             mlib_u8  *src = (void*)pixels;
605             mlib_s32 *dst, *dst_end;
606 
607             dst = (void*)dstBase;
608             dst_end = dst + width;
609 
610             if ((mlib_s32)dst &amp; 7) {
611                 pix = *src++;
612                 if (pix) {
613                     dd = vis_fpadd16(MUL8_VIS(srcG_f, pix), d_half);
614                     dd = vis_fpadd16(MUL8_VIS(*(mlib_f32*)dst, 255 - pix), dd);
615                     *(mlib_f32*)dst = vis_fpack16(dd);
616                     dstA = ((dst[0] &lt;&lt; 7) &gt;&gt; 31) &amp; 0xff;
617                     dstA = mul8table[dstA][255 - pix] + mul8table[srcA][pix];
618                     ((mlib_u8*)dst)[0] = dstA &gt;&gt; 7;
619                     if (pix == 255) *(mlib_f32*)dst = vis_read_hi(fgpixel_d);
620                 }
621                 dst++;
622             }
623 
624 #pragma pipeloop(0)
625             for (; dst &lt;= (dst_end - 2); dst += 2) {
626                 mlib_s32 pix0 = src[0];
627                 mlib_s32 pix1 = src[1];
628                 dmix0 = vis_freg_pair(((mlib_f32 *)vis_mul8s_tbl)[pix0],
629                                       ((mlib_f32 *)vis_mul8s_tbl)[pix1]);
630                 mask = vis_fcmplt32(dmix0, done16);
631                 dmix1 = vis_fpsub16(done, dmix0);
632                 src += 2;
633 
634                 dd = *(mlib_d64*)dst;
635                 d0 = vis_fmul8x16al(srcG_f, vis_read_hi(dmix0));
636                 d1 = vis_fmul8x16al(srcG_f, vis_read_lo(dmix0));
637                 e0 = vis_fmul8x16al(vis_read_hi(dd), vis_read_hi(dmix1));
638                 e1 = vis_fmul8x16al(vis_read_lo(dd), vis_read_lo(dmix1));
639                 d0 = vis_fpadd16(vis_fpadd16(d0, d_half), e0);
640                 d1 = vis_fpadd16(vis_fpadd16(d1, d_half), e1);
641                 dd = vis_fpack16_pair(d0, d1);
642 
643                 *(mlib_d64*)dst = dd;
644                 dstA = ((dst[0] &lt;&lt; 7) &gt;&gt; 31) &amp; 0xff;
645                 dstA = mul8table[dstA][255 - pix0] + mul8table[srcA][pix0];
646                 pix0 = (-pix0) &gt;&gt; 31;
647                 ((mlib_u8*)dst)[0] = ((dstA &gt;&gt; 7) &amp; pix0) |
648                                      (((mlib_u8*)dst)[0] &amp;~ pix0);
649                 dstA = ((dst[1] &lt;&lt; 7) &gt;&gt; 31) &amp; 0xff;
650                 dstA = mul8table[dstA][255 - pix1] + mul8table[srcA][pix1];
651                 pix1 = (-pix1) &gt;&gt; 31;
652                 ((mlib_u8*)dst)[4] = ((dstA &gt;&gt; 7) &amp; pix1) |
653                                      (((mlib_u8*)dst)[4] &amp;~ pix1);
654 
655                 vis_pst_32(fgpixel_d, dst, ~mask);
656             }
657 
658             while (dst &lt; dst_end) {
659                 pix = *src++;
660                 if (pix) {
661                     dd = vis_fpadd16(MUL8_VIS(srcG_f, pix), d_half);
662                     dd = vis_fpadd16(MUL8_VIS(*(mlib_f32*)dst, 255 - pix), dd);
663                     *(mlib_f32*)dst = vis_fpack16(dd);
664                     dstA = ((dst[0] &lt;&lt; 7) &gt;&gt; 31) &amp; 0xff;
665                     dstA = mul8table[dstA][255 - pix] + mul8table[srcA][pix];
666                     ((mlib_u8*)dst)[0] = dstA &gt;&gt; 7;
667                     if (pix == 255) *(mlib_f32*)dst = vis_read_hi(fgpixel_d);
668                 }
669                 dst++;
670             }
671 
672             PTR_ADD(dstBase, scan);
673             pixels += rowBytes;
674         }
675     }
676 }
677 
678 /***************************************************************/
679 
680 #endif /* JAVA2D_NO_MLIB */
    </pre>
  </body>
</html>
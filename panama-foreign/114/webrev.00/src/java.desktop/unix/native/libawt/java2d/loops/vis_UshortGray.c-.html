<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libawt/java2d/loops/vis_UshortGray.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #if !defined(JAVA2D_NO_MLIB) || defined(MLIB_ADD_SUFF)
 27 
 28 #include &lt;vis_proto.h&gt;
 29 #include &quot;java2d_Mlib.h&quot;
 30 #include &quot;vis_AlphaMacros.h&quot;
 31 
 32 /***************************************************************/
 33 
 34 #define RGB2GRAY(r, g, b)      \
 35     (((19672 * (r)) + (38621 * (g)) + (7500 * (b))) &gt;&gt; 8)
 36 
 37 /***************************************************************/
 38 
 39 #define Gray2Argb(x)   \
 40     0xff000000 | (x &lt;&lt; 16) | (x &lt;&lt; 8) | x
 41 
 42 /***************************************************************/
 43 
 44 void ADD_SUFF(ByteGrayToUshortGrayConvert)(BLIT_PARAMS)
 45 {
 46     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
 47     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
 48     mlib_d64 s0, s1, ss, d0, d1;
 49     mlib_s32 i, j, x;
 50 
 51     if (width &lt;= 8) {
 52         for (j = 0; j &lt; height; j++) {
 53             mlib_u8  *src = srcBase;
 54             mlib_u16 *dst = dstBase;
 55 
 56             for (i = 0; i &lt; width; i++) {
 57                 x = src[i];
 58                 dst[i] = x | (x &lt;&lt; 8);
 59             }
 60 
 61             PTR_ADD(dstBase, dstScan);
 62             PTR_ADD(srcBase, srcScan);
 63         }
 64         return;
 65     }
 66 
 67     if (srcScan == width &amp;&amp; dstScan == 2*width) {
 68         width *= height;
 69         height = 1;
 70     }
 71 
 72     for (j = 0; j &lt; height; j++) {
 73         mlib_u8  *src = srcBase;
 74         mlib_u16 *dst = dstBase;
 75         mlib_u16 *dst_end;
 76         mlib_d64 *sp;
 77 
 78         dst_end = dst + width;
 79 
 80         while (((mlib_s32)dst &amp; 7) &amp;&amp; dst &lt; dst_end) {
 81             x = *src++;
 82             *dst++ = x | (x &lt;&lt; 8);
 83         }
 84 
 85         if ((mlib_s32)src &amp; 7) {
 86             sp = vis_alignaddr(src, 0);
 87             s1 = *sp++;
 88 
 89 #pragma pipeloop(0)
 90             for (; dst &lt;= (dst_end - 8); dst += 8) {
 91                 s0 = s1;
 92                 s1 = *sp++;
 93                 ss = vis_faligndata(s0, s1);
 94                 d0 = vis_fpmerge(vis_read_hi(ss), vis_read_hi(ss));
 95                 d1 = vis_fpmerge(vis_read_lo(ss), vis_read_lo(ss));
 96                 ((mlib_d64*)dst)[0] = d0;
 97                 ((mlib_d64*)dst)[1] = d1;
 98                 src += 8;
 99             }
100         } else {
101 #pragma pipeloop(0)
102             for (; dst &lt;= (dst_end - 8); dst += 8) {
103                 ss = *(mlib_d64*)src;
104                 d0 = vis_fpmerge(vis_read_hi(ss), vis_read_hi(ss));
105                 d1 = vis_fpmerge(vis_read_lo(ss), vis_read_lo(ss));
106                 ((mlib_d64*)dst)[0] = d0;
107                 ((mlib_d64*)dst)[1] = d1;
108                 src += 8;
109             }
110         }
111 
112         while (dst &lt; dst_end) {
113             x = *src++;
114             *dst++ = x | (x &lt;&lt; 8);
115         }
116 
117         PTR_ADD(dstBase, dstScan);
118         PTR_ADD(srcBase, srcScan);
119     }
120 }
121 
122 /***************************************************************/
123 
124 void ADD_SUFF(UshortGrayToIntArgbConvert)(BLIT_PARAMS)
125 {
126     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
127     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
128     mlib_d64 ss, d0, d1, d2, d3;
129     mlib_f32 ff, aa = vis_fones();
130     mlib_s32 i, j, x;
131 
132     if (width &lt; 8) {
133         for (j = 0; j &lt; height; j++) {
134             mlib_u16 *src = srcBase;
135             mlib_s32 *dst = dstBase;
136 
137             for (i = 0; i &lt; width; i++) {
138                 x = src[i] &gt;&gt; 8;
139                 dst[i] = Gray2Argb(x);
140             }
141 
142             PTR_ADD(dstBase, dstScan);
143             PTR_ADD(srcBase, srcScan);
144         }
145         return;
146     }
147 
148     if (srcScan == 2*width &amp;&amp; dstScan == 4*width) {
149         width *= height;
150         height = 1;
151     }
152 
153     for (j = 0; j &lt; height; j++) {
154         mlib_u16 *src = srcBase;
155         mlib_s32 *dst = dstBase;
156         mlib_s32 *dst_end;
157 
158         dst_end = dst + width;
159 
160         while (((mlib_s32)src &amp; 7) &amp;&amp; dst &lt; dst_end) {
161             x = *src++ &gt;&gt; 8;
162             *dst++ = Gray2Argb(x);
163         }
164 
165 #pragma pipeloop(0)
166         for (; dst &lt;= (dst_end - 4); dst += 4) {
167             ss = *(mlib_d64*)src;
168             ss = vis_fpmerge(vis_read_hi(ss), vis_read_lo(ss));
169             ss = vis_fpmerge(vis_read_hi(ss), vis_read_lo(ss));
170             ff = vis_read_hi(ss);
171 
172             d0 = vis_fpmerge(aa, ff);
173             d1 = vis_fpmerge(ff, ff);
174             d2 = vis_fpmerge(vis_read_hi(d0), vis_read_hi(d1));
175             d3 = vis_fpmerge(vis_read_lo(d0), vis_read_lo(d1));
176             ((mlib_f32*)dst)[0] = vis_read_hi(d2);
177             ((mlib_f32*)dst)[1] = vis_read_lo(d2);
178             ((mlib_f32*)dst)[2] = vis_read_hi(d3);
179             ((mlib_f32*)dst)[3] = vis_read_lo(d3);
180             src += 4;
181         }
182 
183         while (dst &lt; dst_end) {
184             x = *src++ &gt;&gt; 8;
185             *dst++ = Gray2Argb(x);
186         }
187 
188         PTR_ADD(dstBase, dstScan);
189         PTR_ADD(srcBase, srcScan);
190     }
191 }
192 
193 /***************************************************************/
194 
195 void ADD_SUFF(UshortGrayToIntArgbScaleConvert)(SCALE_PARAMS)
196 {
197     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
198     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
199     mlib_d64 d0, d1, d2, d3, dd;
200     mlib_f32 ff, aa = vis_fones();
201     mlib_s32 i, j, x;
202 
203     if (width &lt; 16) {
204         for (j = 0; j &lt; height; j++) {
205             mlib_u16 *src = srcBase;
206             mlib_s32 *dst = dstBase;
207             mlib_s32 tmpsxloc = sxloc;
208 
209             PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
210 
211             for (i = 0; i &lt; width; i++) {
212                 x = src[tmpsxloc &gt;&gt; shift] &gt;&gt; 8;
213                 tmpsxloc += sxinc;
214                 dst[i] = Gray2Argb(x);
215             }
216 
217             PTR_ADD(dstBase, dstScan);
218             syloc += syinc;
219         }
220         return;
221     }
222 
223     vis_alignaddr(NULL, 7);
224 
225     for (j = 0; j &lt; height; j++) {
226         mlib_u16 *src = srcBase;
227         mlib_s32 *dst = dstBase;
228         mlib_s32 *dst_end;
229         mlib_s32 tmpsxloc = sxloc;
230 
231         PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
232 
233         dst_end = dst + width;
234 
235 #pragma pipeloop(0)
236         for (; dst &lt;= (dst_end - 4); dst += 4) {
237             LOAD_NEXT_U8(dd, src + ((tmpsxloc + 3*sxinc) &gt;&gt; shift));
238             LOAD_NEXT_U8(dd, src + ((tmpsxloc + 2*sxinc) &gt;&gt; shift));
239             LOAD_NEXT_U8(dd, src + ((tmpsxloc +   sxinc) &gt;&gt; shift));
240             LOAD_NEXT_U8(dd, src + ((tmpsxloc          ) &gt;&gt; shift));
241             tmpsxloc += 4*sxinc;
242             ff = vis_read_hi(dd);
243             d0 = vis_fpmerge(aa, ff);
244             d1 = vis_fpmerge(ff, ff);
245             d2 = vis_fpmerge(vis_read_hi(d0), vis_read_hi(d1));
246             d3 = vis_fpmerge(vis_read_lo(d0), vis_read_lo(d1));
247             ((mlib_f32*)dst)[0] = vis_read_hi(d2);
248             ((mlib_f32*)dst)[1] = vis_read_lo(d2);
249             ((mlib_f32*)dst)[2] = vis_read_hi(d3);
250             ((mlib_f32*)dst)[3] = vis_read_lo(d3);
251         }
252 
253         while (dst &lt; dst_end) {
254             x = src[tmpsxloc &gt;&gt; shift] &gt;&gt; 8;
255             tmpsxloc += sxinc;
256             *dst++ = Gray2Argb(x);
257         }
258 
259         PTR_ADD(dstBase, dstScan);
260         syloc += syinc;
261     }
262 }
263 
264 /***************************************************************/
265 
266 void ADD_SUFF(ByteGrayToUshortGrayScaleConvert)(SCALE_PARAMS)
267 {
268     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
269     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
270     mlib_d64 dd;
271     mlib_s32 i, j, x;
272 
273     if (width &lt; 16) {
274         for (j = 0; j &lt; height; j++) {
275             mlib_u8  *src = srcBase;
276             mlib_u16 *dst = dstBase;
277             mlib_s32 tmpsxloc = sxloc;
278 
279             PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
280 
281             for (i = 0; i &lt; width; i++) {
282                 x = src[tmpsxloc &gt;&gt; shift];
283                 tmpsxloc += sxinc;
284                 dst[i] = x | (x &lt;&lt; 8);
285             }
286 
287             PTR_ADD(dstBase, dstScan);
288             syloc += syinc;
289         }
290         return;
291     }
292 
293     vis_alignaddr(NULL, 7);
294 
295     for (j = 0; j &lt; height; j++) {
296         mlib_u8  *src = srcBase;
297         mlib_u16 *dst = dstBase;
298         mlib_u16 *dst_end;
299         mlib_s32 tmpsxloc = sxloc;
300 
301         PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
302 
303         dst_end = dst + width;
304 
305         while (((mlib_s32)dst &amp; 7) &amp;&amp; dst &lt; dst_end) {
306             x = src[tmpsxloc &gt;&gt; shift];
307             tmpsxloc += sxinc;
308             *dst++ = x | (x &lt;&lt; 8);
309         }
310 
311 #pragma pipeloop(0)
312         for (; dst &lt;= (dst_end - 4); dst += 4) {
313             LOAD_NEXT_U8(dd, src + ((tmpsxloc + 3*sxinc) &gt;&gt; shift));
314             LOAD_NEXT_U8(dd, src + ((tmpsxloc + 2*sxinc) &gt;&gt; shift));
315             LOAD_NEXT_U8(dd, src + ((tmpsxloc +   sxinc) &gt;&gt; shift));
316             LOAD_NEXT_U8(dd, src + ((tmpsxloc          ) &gt;&gt; shift));
317             tmpsxloc += 4*sxinc;
318             *(mlib_d64*)dst = vis_fpmerge(vis_read_hi(dd), vis_read_hi(dd));
319         }
320 
321         while (dst &lt; dst_end) {
322             x = src[tmpsxloc &gt;&gt; shift];
323             tmpsxloc += sxinc;
324             *dst++ = x | (x &lt;&lt; 8);
325         }
326 
327         PTR_ADD(dstBase, dstScan);
328         syloc += syinc;
329     }
330 }
331 
332 /***************************************************************/
333 
334 void ADD_SUFF(ByteIndexedToUshortGrayConvert)(BLIT_PARAMS)
335 {
336     jint  *srcLut = pSrcInfo-&gt;lutBase;
337     juint lutSize = pSrcInfo-&gt;lutSize;
338     mlib_u16 LutU16[256];
339     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
340     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
341     mlib_s32 i, j;
342 
343     if (width &lt; 8) {
344         for (j = 0; j &lt; height; j++) {
345             mlib_u8  *src = srcBase;
346             mlib_u16 *dst = dstBase;
347 
348             for (i = 0; i &lt; width; i++) {
349                 jint argb = srcLut[src[i]];
350                 int r, g, b;
351                 b = (argb) &amp; 0xff;
352                 g = (argb &gt;&gt; 8) &amp; 0xff;
353                 r = (argb &gt;&gt; 16) &amp; 0xff;
354                 dst[i] = RGB2GRAY(r, g, b);
355             }
356 
357             PTR_ADD(dstBase, dstScan);
358             PTR_ADD(srcBase, srcScan);
359         }
360         return;
361     }
362 
363     if (lutSize &gt;= 256) lutSize = 256;
364 
365     ADD_SUFF(IntArgbToUshortGrayConvert)(srcLut, LutU16, lutSize, 1,
366                                          pSrcInfo, pDstInfo, pPrim, pCompInfo);
367 
368     for (i = lutSize; i &lt; 256; i++) {
369         LutU16[i] = 0;
370     }
371 
372     if (srcScan == width &amp;&amp; dstScan == 2*width) {
373         width *= height;
374         height = 1;
375     }
376 
377     for (j = 0; j &lt; height; j++) {
378         mlib_u8 *src = srcBase;
379         mlib_u16 *dst = dstBase;
380         mlib_u16 *dst_end = dst + width;
381 
382         if ((mlib_s32)dst &amp; 3) {
383             *dst++ = LutU16[*src];
384             src++;
385         }
386 
387 #pragma pipeloop(0)
388         for (; dst &lt;= (dst_end - 2); dst += 2) {
389             ((mlib_u32*)dst)[0] = (LutU16[src[0]] &lt;&lt; 16) | LutU16[src[1]];
390             src += 2;
391         }
392 
393         if (dst &lt; dst_end) {
394             *dst++ = LutU16[*src];
395             src++;
396         }
397 
398         PTR_ADD(dstBase, dstScan);
399         PTR_ADD(srcBase, srcScan);
400     }
401 }
402 
403 /***************************************************************/
404 
405 void ADD_SUFF(ByteIndexedToUshortGrayScaleConvert)(SCALE_PARAMS)
406 {
407     jint  *srcLut = pSrcInfo-&gt;lutBase;
408     juint lutSize = pSrcInfo-&gt;lutSize;
409     mlib_u16 LutU16[256];
410     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
411     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
412     mlib_s32 i, j;
413 
414     if (width &lt; 8) {
415         for (j = 0; j &lt; height; j++) {
416             mlib_u8  *src = srcBase;
417             mlib_u16 *dst = dstBase;
418             jint  tmpsxloc = sxloc;
419 
420             PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
421 
422             for (i = 0; i &lt; width; i++) {
423                 jint argb = srcLut[src[tmpsxloc &gt;&gt; shift]];
424                 int r, g, b;
425                 b = (argb) &amp; 0xff;
426                 g = (argb &gt;&gt; 8) &amp; 0xff;
427                 r = (argb &gt;&gt; 16) &amp; 0xff;
428                 dst[i] = RGB2GRAY(r, g, b);
429                 tmpsxloc += sxinc;
430             }
431 
432             PTR_ADD(dstBase, dstScan);
433             syloc += syinc;
434         }
435         return;
436     }
437 
438     if (lutSize &gt;= 256) lutSize = 256;
439 
440     ADD_SUFF(IntArgbToUshortGrayConvert)(srcLut, LutU16, lutSize, 1,
441                                        pSrcInfo, pDstInfo, pPrim, pCompInfo);
442 
443     for (i = lutSize; i &lt; 256; i++) {
444         LutU16[i] = 0;
445     }
446 
447     for (j = 0; j &lt; height; j++) {
448         mlib_u8 *src = srcBase;
449         mlib_u16 *dst = dstBase;
450         mlib_u16 *dst_end = dst + width;
451         jint  tmpsxloc = sxloc;
452 
453         PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
454 
455         if ((mlib_s32)dst &amp; 3) {
456             *dst++ = LutU16[src[tmpsxloc &gt;&gt; shift]];
457             tmpsxloc += sxinc;
458         }
459 
460 #pragma pipeloop(0)
461         for (; dst &lt;= (dst_end - 2); dst += 2) {
462             ((mlib_u32*)dst)[0] = (LutU16[src[tmpsxloc &gt;&gt; shift]] &lt;&lt; 16) |
463                                    LutU16[src[(tmpsxloc + sxinc) &gt;&gt; shift]];
464             tmpsxloc += 2*sxinc;
465         }
466 
467         if (dst &lt; dst_end) {
468             *dst = LutU16[src[tmpsxloc &gt;&gt; shift]];
469         }
470 
471         PTR_ADD(dstBase, dstScan);
472         syloc += syinc;
473     }
474 }
475 
476 /***************************************************************/
477 
478 void ADD_SUFF(ByteIndexedBmToUshortGrayXparOver)(BLIT_PARAMS)
479 {
480     jint  *srcLut = pSrcInfo-&gt;lutBase;
481     juint lutSize = pSrcInfo-&gt;lutSize;
482     mlib_u16 LutU16[256];
483     mlib_u32 LutU32[256];
484     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
485     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
486     mlib_s32 i, j, x0, mask, res;
487 
488     if (width &lt; 16) {
489         for (j = 0; j &lt; height; j++) {
490             mlib_u8  *src = srcBase;
491             mlib_u16 *dst = dstBase;
492 
493             for (i = 0; i &lt; width; i++) {
494                 mlib_s32 argb = srcLut[src[i]];
495                 if (argb &lt; 0) {
496                     int r, g, b;
497                     b = (argb) &amp; 0xff;
498                     g = (argb &gt;&gt; 8) &amp; 0xff;
499                     r = (argb &gt;&gt; 16) &amp; 0xff;
500                     dst[i] = RGB2GRAY(r, g, b);
501                 }
502             }
503 
504             PTR_ADD(dstBase, dstScan);
505             PTR_ADD(srcBase, srcScan);
506         }
507         return;
508     }
509 
510     if (lutSize &gt;= 256) lutSize = 256;
511 
512     ADD_SUFF(IntArgbToUshortGrayConvert)(srcLut, LutU16, lutSize, 1,
513                                          pSrcInfo, pDstInfo, pPrim, pCompInfo);
514 
515     for (i = lutSize; i &lt; 256; i++) {
516         LutU16[i] = 0;
517     }
518 
519 #pragma pipeloop(0)
520     for (i = 0; i &lt; 256; i++) {
521         LutU32[i] = ((srcLut[i] &gt;&gt; 31) &amp; 0xFFFF0000) | LutU16[i];
522     }
523 
524     if (srcScan == width &amp;&amp; dstScan == 2*width) {
525         width *= height;
526         height = 1;
527     }
528 
529     for (j = 0; j &lt; height; j++) {
530         mlib_u8  *src = srcBase;
531         mlib_u16 *dst = dstBase;
532         mlib_u16 *dst_end = dst + width;
533 
534 #pragma pipeloop(0)
535         for (; dst &lt; dst_end; dst++) {
536             x0 = *src;
537             res = LutU32[x0];
538             mask = res &gt;&gt; 16;
539             *dst = (res &amp; mask) | (*dst &amp;~ mask);
540             src++;
541         }
542 
543         PTR_ADD(dstBase, dstScan);
544         PTR_ADD(srcBase, srcScan);
545     }
546 }
547 
548 /***************************************************************/
549 
550 void ADD_SUFF(ByteIndexedBmToUshortGrayXparBgCopy)(BCOPY_PARAMS)
551 {
552     jint  *srcLut = pSrcInfo-&gt;lutBase;
553     juint lutSize = pSrcInfo-&gt;lutSize;
554     mlib_u16 LutU16[256];
555     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
556     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
557     mlib_s32 i, j;
558 
559     if (width &lt; 16) {
560         for (j = 0; j &lt; height; j++) {
561             mlib_u8  *src = srcBase;
562             mlib_u16 *dst = dstBase;
563 
564             for (i = 0; i &lt; width; i++) {
565                 mlib_s32 argb = srcLut[src[i]];
566                 if (argb &lt; 0) {
567                     int r, g, b;
568                     b = (argb) &amp; 0xff;
569                     g = (argb &gt;&gt; 8) &amp; 0xff;
570                     r = (argb &gt;&gt; 16) &amp; 0xff;
571                     dst[i] = RGB2GRAY(r, g, b);
572                 } else {
573                     dst[i] = bgpixel;
574                 }
575             }
576 
577             PTR_ADD(dstBase, dstScan);
578             PTR_ADD(srcBase, srcScan);
579         }
580         return;
581     }
582 
583     if (lutSize &gt;= 256) lutSize = 256;
584 
585     ADD_SUFF(IntArgbToUshortGrayConvert)(srcLut, LutU16, lutSize, 1,
586                                          pSrcInfo, pDstInfo, pPrim, pCompInfo);
587 
588     for (i = lutSize; i &lt; 256; i++) {
589         LutU16[i] = 0;
590     }
591 
592 #pragma pipeloop(0)
593     for (i = 0; i &lt; 256; i++) {
594         if (srcLut[i] &gt;= 0) LutU16[i] = bgpixel;
595     }
596 
597     if (srcScan == width &amp;&amp; dstScan == 2*width) {
598         width *= height;
599         height = 1;
600     }
601 
602     for (j = 0; j &lt; height; j++) {
603         mlib_u8 *src = srcBase;
604         mlib_u16 *dst = dstBase;
605         mlib_u16 *dst_end = dst + width;
606 
607         if ((mlib_s32)dst &amp; 3) {
608             *dst++ = LutU16[*src];
609             src++;
610         }
611 
612 #pragma pipeloop(0)
613         for (; dst &lt;= (dst_end - 2); dst += 2) {
614             ((mlib_u32*)dst)[0] = (LutU16[src[0]] &lt;&lt; 16) | LutU16[src[1]];
615             src += 2;
616         }
617 
618         if (dst &lt; dst_end) {
619             *dst++ = LutU16[*src];
620             src++;
621         }
622 
623         PTR_ADD(dstBase, dstScan);
624         PTR_ADD(srcBase, srcScan);
625     }
626 }
627 
628 /***************************************************************/
629 
630 void ADD_SUFF(ByteIndexedBmToUshortGrayScaleXparOver)(SCALE_PARAMS)
631 {
632     jint  *srcLut = pSrcInfo-&gt;lutBase;
633     juint lutSize = pSrcInfo-&gt;lutSize;
634     mlib_u16 LutU16[256];
635     mlib_u32 LutU32[256];
636     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
637     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
638     mlib_s32 i, j, x0, mask, res;
639 
640     if (width &lt; 16) {
641         for (j = 0; j &lt; height; j++) {
642             mlib_u8  *src = srcBase;
643             mlib_u16 *dst = dstBase;
644             jint  tmpsxloc = sxloc;
645 
646             PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
647 
648             for (i = 0; i &lt; width; i++) {
649                 mlib_s32 argb = srcLut[src[tmpsxloc &gt;&gt; shift]];
650                 if (argb &lt; 0) {
651                     int r, g, b;
652                     b = (argb) &amp; 0xff;
653                     g = (argb &gt;&gt; 8) &amp; 0xff;
654                     r = (argb &gt;&gt; 16) &amp; 0xff;
655                     dst[i] = RGB2GRAY(r, g, b);
656                 }
657                 tmpsxloc += sxinc;
658             }
659 
660             PTR_ADD(dstBase, dstScan);
661             syloc += syinc;
662         }
663         return;
664     }
665 
666     if (lutSize &gt;= 256) lutSize = 256;
667 
668     ADD_SUFF(IntArgbToUshortGrayConvert)(srcLut, LutU16, lutSize, 1,
669                                          pSrcInfo, pDstInfo, pPrim, pCompInfo);
670 
671     for (i = lutSize; i &lt; 256; i++) {
672         LutU16[i] = 0;
673     }
674 
675 #pragma pipeloop(0)
676     for (i = 0; i &lt; 256; i++) {
677         LutU32[i] = ((srcLut[i] &gt;&gt; 31) &amp; 0xFFFF0000) | LutU16[i];
678     }
679 
680     for (j = 0; j &lt; height; j++) {
681         mlib_u8  *src = srcBase;
682         mlib_u16 *dst = dstBase;
683         mlib_u16 *dst_end = dst + width;
684         jint  tmpsxloc = sxloc;
685 
686         PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
687 
688 #pragma pipeloop(0)
689         for (; dst &lt; dst_end; dst++) {
690             x0 = src[tmpsxloc &gt;&gt; shift];
691             res = LutU32[x0];
692             mask = res &gt;&gt; 16;
693             *dst = (res &amp; mask) | (*dst &amp;~ mask);
694             tmpsxloc += sxinc;
695         }
696 
697         PTR_ADD(dstBase, dstScan);
698         syloc += syinc;
699     }
700 }
701 
702 /***************************************************************/
703 
704 #endif
    </pre>
  </body>
</html>
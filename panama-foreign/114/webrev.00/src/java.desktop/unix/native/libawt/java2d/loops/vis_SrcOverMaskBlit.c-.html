<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libawt/java2d/loops/vis_SrcOverMaskBlit.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #if !defined(JAVA2D_NO_MLIB) || defined(MLIB_ADD_SUFF)
 27 
 28 #include &quot;vis_AlphaMacros.h&quot;
 29 
 30 /***************************************************************/
 31 
 32 /* ##############################################################
 33  * IntArgbToIntArgbSrcOverMaskBlit()
 34  * IntArgbToFourByteAbgrSrcOverMaskBlit()
 35  */
 36 
 37 #define MASK_FILL(rr, pathA, dstA, dstARGB, srcA, srcARGB)     \
 38 {                                                              \
 39     mlib_d64 t0, t1;                                           \
 40                                                                \
 41     srcA = MUL8_INT(srcA, mul8_extra[pathA]);                  \
 42     dstA = MUL8_INT(dstA, 0xff - srcA);                        \
 43                                                                \
 44     t0 = MUL8_VIS(srcARGB, srcA);                              \
 45     t1 = MUL8_VIS(dstARGB, dstA);                              \
 46     rr = vis_fpadd16(t0, t1);                                  \
 47                                                                \
 48     dstA += srcA;                                              \
 49     DIV_ALPHA(rr, dstA);                                       \
 50 }
 51 
 52 /***************************************************************/
 53 
 54 static void IntArgbToIntArgbSrcOverMaskBlit_line(mlib_f32 *dst_ptr,
 55                                                  mlib_f32 *src_ptr,
 56                                                  mlib_u8  *pMask,
 57                                                  mlib_s32 width,
 58                                                  mlib_u8  *mul8_extra,
 59                                                  mlib_u8  *mul8_tbl)
 60 {
 61     mlib_s32 i, i0;
 62     mlib_s32 pathA0, pathA1, dstA0, dstA1, srcA0, srcA1, msk;
 63     mlib_d64 res0, res1, dstARGB;
 64     mlib_f32 dstARGB0, srcARGB0, srcARGB1;
 65 
 66     i = i0 = 0;
 67 
 68     if ((mlib_s32)dst_ptr &amp; 7) {
 69         pathA0 = pMask[i];
 70         dstA0 = *(mlib_u8*)(dst_ptr + i);
 71         srcA0 = *(mlib_u8*)(src_ptr + i);
 72         dstARGB0 = dst_ptr[i];
 73         srcARGB0 = src_ptr[i];
 74         MASK_FILL(res0, pathA0, dstA0, dstARGB0, srcA0, srcARGB0);
 75         if (srcA0) {
 76             dst_ptr[i] = vis_fpack16(res0);
 77             *(mlib_u8*)(dst_ptr + i) = dstA0;
 78         }
 79 
 80         i0 = 1;
 81     }
 82 
 83 #pragma pipeloop(0)
 84     for (i = i0; i &lt;= width - 2; i += 2) {
 85         pathA0 = pMask[i];
 86         pathA1 = pMask[i + 1];
 87         dstA0 = *(mlib_u8*)(dst_ptr + i);
 88         dstA1 = *(mlib_u8*)(dst_ptr + i + 1);
 89         dstARGB = *(mlib_d64*)(dst_ptr + i);
 90         srcA0 = *(mlib_u8*)(src_ptr + i);
 91         srcA1 = *(mlib_u8*)(src_ptr + i + 1);
 92         srcARGB0 = src_ptr[i];
 93         srcARGB1 = src_ptr[i + 1];
 94 
 95         MASK_FILL(res0, pathA0, dstA0, vis_read_hi(dstARGB), srcA0, srcARGB0);
 96         MASK_FILL(res1, pathA1, dstA1, vis_read_lo(dstARGB), srcA1, srcARGB1);
 97 
 98         res0 = vis_fpack16_pair(res0, res1);
 99 
100         msk = (((-srcA0) &amp; (1 &lt;&lt; 11)) | ((-srcA1) &amp; (1 &lt;&lt; 10))) &gt;&gt; 10;
101         vis_pst_32(res0, dst_ptr + i, msk);
102 
103         *(mlib_u8*)(dst_ptr + i    ) = dstA0;
104         *(mlib_u8*)(dst_ptr + i + 1) = dstA1;
105     }
106 
107     if (i &lt; width) {
108         pathA0 = pMask[i];
109         dstA0 = *(mlib_u8*)(dst_ptr + i);
110         srcA0 = *(mlib_u8*)(src_ptr + i);
111         dstARGB0 = dst_ptr[i];
112         srcARGB0 = src_ptr[i];
113         MASK_FILL(res0, pathA0, dstA0, dstARGB0, srcA0, srcARGB0);
114         if (srcA0) {
115             dst_ptr[i] = vis_fpack16(res0);
116             *(mlib_u8*)(dst_ptr + i) = dstA0;
117         }
118     }
119 }
120 
121 /***************************************************************/
122 
123 #undef  MASK_FILL
124 #define MASK_FILL(rr, pathA, dstA, dstARGB, srcA, srcARGB)     \
125 {                                                              \
126     mlib_d64 t0, t1;                                           \
127                                                                \
128     srcA = mul8_extra[srcA];                                   \
129     dstA = MUL8_INT(dstA, 0xff - srcA);                        \
130                                                                \
131     t0 = MUL8_VIS(srcARGB, srcA);                              \
132     t1 = MUL8_VIS(dstARGB, dstA);                              \
133     rr = vis_fpadd16(t0, t1);                                  \
134                                                                \
135     dstA += srcA;                                              \
136     DIV_ALPHA(rr, dstA);                                       \
137 }
138 
139 /***************************************************************/
140 
141 static void IntArgbToIntArgbSrcOverMaskBlit_A1_line(mlib_f32 *dst_ptr,
142                                                     mlib_f32 *src_ptr,
143                                                     mlib_u8  *pMask,
144                                                     mlib_s32 width,
145                                                     mlib_u8  *mul8_extra,
146                                                     mlib_u8  *mul8_tbl)
147 {
148     mlib_s32 i, i0;
149     mlib_s32 dstA0, dstA1, srcA0, srcA1, msk;
150     mlib_d64 res0, res1, dstARGB;
151     mlib_f32 dstARGB0, srcARGB0, srcARGB1;
152 
153     i = i0 = 0;
154 
155     if ((mlib_s32)dst_ptr &amp; 7) {
156         dstA0 = *(mlib_u8*)(dst_ptr + i);
157         srcA0 = *(mlib_u8*)(src_ptr + i);
158         dstARGB0 = dst_ptr[i];
159         srcARGB0 = src_ptr[i];
160         MASK_FILL(res0, pathA0, dstA0, dstARGB0, srcA0, srcARGB0);
161         if (srcA0) {
162             dst_ptr[i] = vis_fpack16(res0);
163             *(mlib_u8*)(dst_ptr + i) = dstA0;
164         }
165 
166         i0 = 1;
167     }
168 
169 #pragma pipeloop(0)
170     for (i = i0; i &lt;= width - 2; i += 2) {
171         dstA0 = *(mlib_u8*)(dst_ptr + i);
172         dstA1 = *(mlib_u8*)(dst_ptr + i + 1);
173         dstARGB = *(mlib_d64*)(dst_ptr + i);
174         srcA0 = *(mlib_u8*)(src_ptr + i);
175         srcA1 = *(mlib_u8*)(src_ptr + i + 1);
176         srcARGB0 = src_ptr[i];
177         srcARGB1 = src_ptr[i + 1];
178 
179         MASK_FILL(res0, pathA0, dstA0, vis_read_hi(dstARGB), srcA0, srcARGB0);
180         MASK_FILL(res1, pathA1, dstA1, vis_read_lo(dstARGB), srcA1, srcARGB1);
181 
182         res0 = vis_fpack16_pair(res0, res1);
183 
184         msk = (((-srcA0) &amp; (1 &lt;&lt; 11)) | ((-srcA1) &amp; (1 &lt;&lt; 10))) &gt;&gt; 10;
185         vis_pst_32(res0, dst_ptr + i, msk);
186 
187         *(mlib_u8*)(dst_ptr + i    ) = dstA0;
188         *(mlib_u8*)(dst_ptr + i + 1) = dstA1;
189     }
190 
191     if (i &lt; width) {
192         dstA0 = *(mlib_u8*)(dst_ptr + i);
193         srcA0 = *(mlib_u8*)(src_ptr + i);
194         dstARGB0 = dst_ptr[i];
195         srcARGB0 = src_ptr[i];
196         MASK_FILL(res0, pathA0, dstA0, dstARGB0, srcA0, srcARGB0);
197         if (srcA0) {
198             dst_ptr[i] = vis_fpack16(res0);
199             *(mlib_u8*)(dst_ptr + i) = dstA0;
200         }
201     }
202 }
203 
204 /***************************************************************/
205 
206 void ADD_SUFF(IntArgbToIntArgbSrcOverMaskBlit)(MASKBLIT_PARAMS)
207 {
208     mlib_s32 extraA;
209     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
210     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
211     mlib_u8  *mul8_extra;
212     mlib_s32 j;
213 
214     extraA = (mlib_s32)(pCompInfo-&gt;details.extraAlpha * 255.0 + 0.5);
215 
216     mul8_extra = mul8table[extraA];
217 
218     vis_write_gsr(7 &lt;&lt; 3);
219 
220     if (pMask != NULL) {
221         pMask += maskOff;
222 
223         if (dstScan == 4*width &amp;&amp; srcScan == dstScan &amp;&amp; maskScan == width) {
224             width *= height;
225             height = 1;
226         }
227 
228         for (j = 0; j &lt; height; j++) {
229             IntArgbToIntArgbSrcOverMaskBlit_line(dstBase, srcBase, pMask,
230                                                  width, mul8_extra,
231                                                  (void*)mul8table);
232 
233             PTR_ADD(dstBase, dstScan);
234             PTR_ADD(srcBase, srcScan);
235             PTR_ADD(pMask, maskScan);
236         }
237     } else {
238         if (dstScan == 4*width &amp;&amp; srcScan == dstScan) {
239             width *= height;
240             height = 1;
241         }
242 
243         for (j = 0; j &lt; height; j++) {
244             IntArgbToIntArgbSrcOverMaskBlit_A1_line(dstBase, srcBase, pMask,
245                                                     width, mul8_extra,
246                                                     (void*)mul8table);
247 
248             PTR_ADD(dstBase, dstScan);
249             PTR_ADD(srcBase, srcScan);
250         }
251     }
252 }
253 
254 /***************************************************************/
255 
256 void ADD_SUFF(IntArgbToFourByteAbgrSrcOverMaskBlit)(MASKBLIT_PARAMS)
257 {
258     mlib_d64 buff[BUFF_SIZE/2];
259     void     *src_buff = buff, *dst_buff;
260     mlib_s32 extraA;
261     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
262     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
263     mlib_u8  *mul8_extra;
264     mlib_s32 j;
265 
266     extraA = (mlib_s32)(pCompInfo-&gt;details.extraAlpha * 255.0 + 0.5);
267 
268     mul8_extra = mul8table[extraA];
269 
270     vis_write_gsr(7 &lt;&lt; 3);
271 
272     if (2*width &gt; BUFF_SIZE) src_buff = mlib_malloc(2*width*sizeof(mlib_s32));
273     dst_buff = (mlib_s32*)src_buff + width;
274 
275     if (pMask != NULL) {
276         pMask += maskOff;
277 
278         for (j = 0; j &lt; height; j++) {
279             IntArgbToIntAbgrConvert_line(srcBase, src_buff, width);
280             if (!((mlib_s32)dstBase &amp; 3)) {
281                 IntArgbToIntArgbSrcOverMaskBlit_line(dstBase, src_buff, pMask,
282                                                      width, mul8_extra,
283                                                      (void*)mul8table);
284             } else {
285                 mlib_ImageCopy_na(dstBase, dst_buff, width*sizeof(mlib_s32));
286                 IntArgbToIntArgbSrcOverMaskBlit_line(dst_buff, src_buff, pMask,
287                                                      width, mul8_extra,
288                                                      (void*)mul8table);
289                 mlib_ImageCopy_na(dst_buff, dstBase, width*sizeof(mlib_s32));
290             }
291 
292             PTR_ADD(dstBase, dstScan);
293             PTR_ADD(srcBase, srcScan);
294             PTR_ADD(pMask, maskScan);
295         }
296     } else {
297         for (j = 0; j &lt; height; j++) {
298             IntArgbToIntAbgrConvert_line(srcBase, src_buff, width);
299             if (!((mlib_s32)dstBase &amp; 3)) {
300                 IntArgbToIntArgbSrcOverMaskBlit_A1_line(dstBase, src_buff,
301                                                         pMask, width,
302                                                         mul8_extra,
303                                                         (void*)mul8table);
304             } else {
305                 mlib_ImageCopy_na(dstBase, dst_buff, width*sizeof(mlib_s32));
306                 IntArgbToIntArgbSrcOverMaskBlit_A1_line(dst_buff, src_buff,
307                                                         pMask, width,
308                                                         mul8_extra,
309                                                         (void*)mul8table);
310                 mlib_ImageCopy_na(dst_buff, dstBase, width*sizeof(mlib_s32));
311             }
312 
313             PTR_ADD(dstBase, dstScan);
314             PTR_ADD(srcBase, srcScan);
315         }
316     }
317 
318     if (src_buff != buff) {
319         mlib_free(src_buff);
320     }
321 }
322 
323 /***************************************************************/
324 
325 /* ##############################################################
326  * IntArgbToIntRgbSrcOverMaskBlit()
327  * IntArgbToIntBgrSrcOverMaskBlit()
328  */
329 
330 #undef  MASK_FILL
331 #define MASK_FILL(rr, pathA, dstA, dstARGB, srcA, srcARGB)     \
332 {                                                              \
333     mlib_d64 t0, t1;                                           \
334     mlib_f32 srcAf, dstAf;                                     \
335                                                                \
336     srcA = MUL8_INT(srcA, mul8_extra[pathA]);                  \
337     srcAf = ((mlib_f32 *)vis_mul8s_tbl)[srcA];                 \
338     dstAf = vis_fpsub16s(cnst1, srcAf);                        \
339                                                                \
340     t0 = vis_fmul8x16al(srcARGB, srcAf);                       \
341     t1 = vis_fmul8x16al(dstARGB, dstAf);                       \
342     rr = vis_fpadd16(t0, t1);                                  \
343 }
344 
345 /***************************************************************/
346 
347 static void IntArgbToIntRgbSrcOverMaskBlit_line(mlib_f32 *dst_ptr,
348                                                 mlib_f32 *src_ptr,
349                                                 mlib_u8  *pMask,
350                                                 mlib_s32 width,
351                                                 mlib_u8  *mul8_extra,
352                                                 mlib_u8  *mul8_tbl)
353 {
354     mlib_s32 i, i0;
355     mlib_s32 pathA0, pathA1, srcA0, srcA1, msk;
356     mlib_d64 res0, res1, dstARGB;
357     mlib_f32 dstARGB0, srcARGB0, srcARGB1;
358     mlib_d64 maskRGB = vis_to_double_dup(0x00FFFFFF);
359     mlib_f32 cnst1 = vis_to_float(0x8000);
360 
361     i = i0 = 0;
362 
363     if ((mlib_s32)dst_ptr &amp; 7) {
364         pathA0 = pMask[i];
365         srcA0 = *(mlib_u8*)(src_ptr + i);
366         dstARGB0 = dst_ptr[i];
367         srcARGB0 = src_ptr[i];
368         MASK_FILL(res0, pathA0, dstA0, dstARGB0, srcA0, srcARGB0);
369         if (srcA0) {
370             dst_ptr[i] = vis_fands(vis_fpack16(res0), vis_read_hi(maskRGB));
371         }
372 
373         i0 = 1;
374     }
375 
376 #pragma pipeloop(0)
377     for (i = i0; i &lt;= width - 2; i += 2) {
378         pathA0 = pMask[i];
379         pathA1 = pMask[i + 1];
380         dstARGB = *(mlib_d64*)(dst_ptr + i);
381         srcA0 = *(mlib_u8*)(src_ptr + i);
382         srcA1 = *(mlib_u8*)(src_ptr + i + 1);
383         srcARGB0 = src_ptr[i];
384         srcARGB1 = src_ptr[i + 1];
385 
386         MASK_FILL(res0, pathA0, dstA0, vis_read_hi(dstARGB), srcA0, srcARGB0);
387         MASK_FILL(res1, pathA1, dstA1, vis_read_lo(dstARGB), srcA1, srcARGB1);
388 
389         res0 = vis_fpack16_pair(res0, res1);
390         res0 = vis_fand(res0, maskRGB);
391 
392         msk = (((-srcA0) &amp; (1 &lt;&lt; 11)) | ((-srcA1) &amp; (1 &lt;&lt; 10))) &gt;&gt; 10;
393         vis_pst_32(res0, dst_ptr + i, msk);
394     }
395 
396     if (i &lt; width) {
397         pathA0 = pMask[i];
398         srcA0 = *(mlib_u8*)(src_ptr + i);
399         dstARGB0 = dst_ptr[i];
400         srcARGB0 = src_ptr[i];
401         MASK_FILL(res0, pathA0, dstA0, dstARGB0, srcA0, srcARGB0);
402         if (srcA0) {
403             dst_ptr[i] = vis_fands(vis_fpack16(res0), vis_read_hi(maskRGB));
404         }
405     }
406 }
407 
408 /***************************************************************/
409 
410 static void IntArgbToIntBgrSrcOverMaskBlit_line(mlib_f32 *dst_ptr,
411                                                 mlib_f32 *src_ptr,
412                                                 mlib_u8  *pMask,
413                                                 mlib_s32 width,
414                                                 mlib_u8  *mul8_extra,
415                                                 mlib_u8  *mul8_tbl)
416 {
417     mlib_s32 i, i0;
418     mlib_s32 pathA0, pathA1, srcA0, srcA1, msk;
419     mlib_d64 res0, res1, dstARGB, srcARGB;
420     mlib_f32 dstARGB0, srcARGB0;
421     mlib_d64 maskRGB = vis_to_double_dup(0x00FFFFFF);
422     mlib_f32 cnst1 = vis_to_float(0x8000);
423 
424 #if VIS &gt;= 0x200
425     vis_write_bmask(0x03214765, 0);
426 #endif
427 
428     i = i0 = 0;
429 
430     if ((mlib_s32)dst_ptr &amp; 7) {
431         pathA0 = pMask[i];
432         srcA0 = *(mlib_u8*)(src_ptr + i);
433         dstARGB0 = dst_ptr[i];
434         srcARGB0 = src_ptr[i];
435         ARGB2ABGR_FL(srcARGB0)
436         MASK_FILL(res0, pathA0, dstA0, dstARGB0, srcA0, srcARGB0);
437         if (srcA0) {
438             dst_ptr[i] = vis_fands(vis_fpack16(res0), vis_read_hi(maskRGB));
439         }
440 
441         i0 = 1;
442     }
443 
444 #pragma pipeloop(0)
445     for (i = i0; i &lt;= width - 2; i += 2) {
446         pathA0 = pMask[i];
447         pathA1 = pMask[i + 1];
448         dstARGB = *(mlib_d64*)(dst_ptr + i);
449         srcA0 = *(mlib_u8*)(src_ptr + i);
450         srcA1 = *(mlib_u8*)(src_ptr + i + 1);
451         srcARGB = vis_freg_pair(src_ptr[i], src_ptr[i + 1]);
452         ARGB2ABGR_DB(srcARGB)
453 
454         MASK_FILL(res0, pathA0, dstA0, vis_read_hi(dstARGB),
455                                 srcA0, vis_read_hi(srcARGB));
456         MASK_FILL(res1, pathA1, dstA1, vis_read_lo(dstARGB),
457                                 srcA1, vis_read_lo(srcARGB));
458 
459         res0 = vis_fpack16_pair(res0, res1);
460         res0 = vis_fand(res0, maskRGB);
461 
462         msk = (((-srcA0) &amp; (1 &lt;&lt; 11)) | ((-srcA1) &amp; (1 &lt;&lt; 10))) &gt;&gt; 10;
463         vis_pst_32(res0, dst_ptr + i, msk);
464     }
465 
466     if (i &lt; width) {
467         pathA0 = pMask[i];
468         srcA0 = *(mlib_u8*)(src_ptr + i);
469         dstARGB0 = dst_ptr[i];
470         srcARGB0 = src_ptr[i];
471         ARGB2ABGR_FL(srcARGB0)
472         MASK_FILL(res0, pathA0, dstA0, dstARGB0, srcA0, srcARGB0);
473         if (srcA0) {
474             dst_ptr[i] = vis_fands(vis_fpack16(res0), vis_read_hi(maskRGB));
475         }
476     }
477 }
478 
479 /***************************************************************/
480 
481 #undef  MASK_FILL
482 #define MASK_FILL(rr, pathA, dstA, dstARGB, srcA, srcARGB)     \
483 {                                                              \
484     mlib_d64 t0, t1;                                           \
485     mlib_f32 srcAf, dstAf;                                     \
486                                                                \
487     srcA = mul8_extra[srcA];                                   \
488     srcAf = ((mlib_f32 *)vis_mul8s_tbl)[srcA];                 \
489     dstAf = vis_fpsub16s(cnst1, srcAf);                        \
490                                                                \
491     t0 = vis_fmul8x16al(srcARGB, srcAf);                       \
492     t1 = vis_fmul8x16al(dstARGB, dstAf);                       \
493     rr = vis_fpadd16(t0, t1);                                  \
494 }
495 
496 /***************************************************************/
497 
498 static void IntArgbToIntRgbSrcOverMaskBlit_A1_line(mlib_f32 *dst_ptr,
499                                                    mlib_f32 *src_ptr,
500                                                    mlib_u8  *pMask,
501                                                    mlib_s32 width,
502                                                    mlib_u8  *mul8_extra,
503                                                    mlib_u8  *mul8_tbl)
504 {
505     mlib_s32 i, i0;
506     mlib_s32 srcA0, srcA1, msk;
507     mlib_d64 res0, res1, dstARGB;
508     mlib_f32 dstARGB0, srcARGB0, srcARGB1;
509     mlib_d64 maskRGB = vis_to_double_dup(0x00FFFFFF);
510     mlib_f32 cnst1 = vis_to_float(0x8000);
511 
512     i = i0 = 0;
513 
514     if ((mlib_s32)dst_ptr &amp; 7) {
515         srcA0 = *(mlib_u8*)(src_ptr + i);
516         dstARGB0 = dst_ptr[i];
517         srcARGB0 = src_ptr[i];
518         MASK_FILL(res0, pathA0, dstA0, dstARGB0, srcA0, srcARGB0);
519         if (srcA0) {
520             dst_ptr[i] = vis_fands(vis_fpack16(res0), vis_read_hi(maskRGB));
521         }
522 
523         i0 = 1;
524     }
525 
526 #pragma pipeloop(0)
527     for (i = i0; i &lt;= width - 2; i += 2) {
528         dstARGB = *(mlib_d64*)(dst_ptr + i);
529         srcA0 = *(mlib_u8*)(src_ptr + i);
530         srcA1 = *(mlib_u8*)(src_ptr + i + 1);
531         srcARGB0 = src_ptr[i];
532         srcARGB1 = src_ptr[i + 1];
533 
534         MASK_FILL(res0, pathA0, dstA0, vis_read_hi(dstARGB), srcA0, srcARGB0);
535         MASK_FILL(res1, pathA1, dstA1, vis_read_lo(dstARGB), srcA1, srcARGB1);
536 
537         res0 = vis_fpack16_pair(res0, res1);
538         res0 = vis_fand(res0, maskRGB);
539 
540         msk = (((-srcA0) &amp; (1 &lt;&lt; 11)) | ((-srcA1) &amp; (1 &lt;&lt; 10))) &gt;&gt; 10;
541         vis_pst_32(res0, dst_ptr + i, msk);
542     }
543 
544     if (i &lt; width) {
545         srcA0 = *(mlib_u8*)(src_ptr + i);
546         dstARGB0 = dst_ptr[i];
547         srcARGB0 = src_ptr[i];
548         MASK_FILL(res0, pathA0, dstA0, dstARGB0, srcA0, srcARGB0);
549         if (srcA0) {
550             dst_ptr[i] = vis_fands(vis_fpack16(res0), vis_read_hi(maskRGB));
551         }
552     }
553 }
554 
555 /***************************************************************/
556 
557 static void IntArgbToIntBgrSrcOverMaskBlit_A1_line(mlib_f32 *dst_ptr,
558                                                    mlib_f32 *src_ptr,
559                                                    mlib_u8  *pMask,
560                                                    mlib_s32 width,
561                                                    mlib_u8  *mul8_extra,
562                                                    mlib_u8  *mul8_tbl)
563 {
564     mlib_s32 i, i0;
565     mlib_s32 srcA0, srcA1, msk;
566     mlib_d64 res0, res1, dstARGB, srcARGB;
567     mlib_f32 dstARGB0, srcARGB0;
568     mlib_d64 maskRGB = vis_to_double_dup(0x00FFFFFF);
569     mlib_f32 cnst1 = vis_to_float(0x8000);
570 
571 #if VIS &gt;= 0x200
572     vis_write_bmask(0x03214765, 0);
573 #endif
574 
575     i = i0 = 0;
576 
577     if ((mlib_s32)dst_ptr &amp; 7) {
578         srcA0 = *(mlib_u8*)(src_ptr + i);
579         dstARGB0 = dst_ptr[i];
580         srcARGB0 = src_ptr[i];
581         ARGB2ABGR_FL(srcARGB0)
582         MASK_FILL(res0, pathA0, dstA0, dstARGB0, srcA0, srcARGB0);
583         if (srcA0) {
584             dst_ptr[i] = vis_fands(vis_fpack16(res0), vis_read_hi(maskRGB));
585         }
586 
587         i0 = 1;
588     }
589 
590 #pragma pipeloop(0)
591     for (i = i0; i &lt;= width - 2; i += 2) {
592         dstARGB = *(mlib_d64*)(dst_ptr + i);
593         srcA0 = *(mlib_u8*)(src_ptr + i);
594         srcA1 = *(mlib_u8*)(src_ptr + i + 1);
595         srcARGB = vis_freg_pair(src_ptr[i], src_ptr[i + 1]);
596         ARGB2ABGR_DB(srcARGB)
597 
598         MASK_FILL(res0, pathA0, dstA0, vis_read_hi(dstARGB),
599                                 srcA0, vis_read_hi(srcARGB));
600         MASK_FILL(res1, pathA1, dstA1, vis_read_lo(dstARGB),
601                                 srcA1, vis_read_lo(srcARGB));
602 
603         res0 = vis_fpack16_pair(res0, res1);
604         res0 = vis_fand(res0, maskRGB);
605 
606         msk = (((-srcA0) &amp; (1 &lt;&lt; 11)) | ((-srcA1) &amp; (1 &lt;&lt; 10))) &gt;&gt; 10;
607         vis_pst_32(res0, dst_ptr + i, msk);
608     }
609 
610     if (i &lt; width) {
611         srcA0 = *(mlib_u8*)(src_ptr + i);
612         dstARGB0 = dst_ptr[i];
613         srcARGB0 = src_ptr[i];
614         ARGB2ABGR_FL(srcARGB0)
615         MASK_FILL(res0, pathA0, dstA0, dstARGB0, srcA0, srcARGB0);
616         if (srcA0) {
617             dst_ptr[i] = vis_fands(vis_fpack16(res0), vis_read_hi(maskRGB));
618         }
619     }
620 }
621 
622 /***************************************************************/
623 
624 void ADD_SUFF(IntArgbToIntRgbSrcOverMaskBlit)(MASKBLIT_PARAMS)
625 {
626     mlib_s32 extraA;
627     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
628     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
629     mlib_u8  *mul8_extra;
630     mlib_s32 j;
631 
632     extraA = (mlib_s32)(pCompInfo-&gt;details.extraAlpha * 255.0 + 0.5);
633 
634     mul8_extra = mul8table[extraA];
635 
636     vis_write_gsr(0 &lt;&lt; 3);
637 
638     if (pMask != NULL) {
639         pMask += maskOff;
640 
641         if (dstScan == 4*width &amp;&amp; srcScan == dstScan &amp;&amp; maskScan == width) {
642             width *= height;
643             height = 1;
644         }
645 
646         for (j = 0; j &lt; height; j++) {
647             IntArgbToIntRgbSrcOverMaskBlit_line(dstBase, srcBase, pMask,
648                                                  width, mul8_extra,
649                                                  (void*)mul8table);
650 
651             PTR_ADD(dstBase, dstScan);
652             PTR_ADD(srcBase, srcScan);
653             PTR_ADD(pMask, maskScan);
654         }
655     } else {
656         if (dstScan == 4*width &amp;&amp; srcScan == dstScan) {
657             width *= height;
658             height = 1;
659         }
660 
661         for (j = 0; j &lt; height; j++) {
662             IntArgbToIntRgbSrcOverMaskBlit_A1_line(dstBase, srcBase, pMask,
663                                                     width, mul8_extra,
664                                                     (void*)mul8table);
665 
666             PTR_ADD(dstBase, dstScan);
667             PTR_ADD(srcBase, srcScan);
668         }
669     }
670 }
671 
672 /***************************************************************/
673 
674 void ADD_SUFF(IntArgbToIntBgrSrcOverMaskBlit)(MASKBLIT_PARAMS)
675 {
676     mlib_s32 extraA;
677     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
678     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
679     mlib_u8  *mul8_extra;
680     mlib_s32 j;
681 
682     extraA = (mlib_s32)(pCompInfo-&gt;details.extraAlpha * 255.0 + 0.5);
683 
684     mul8_extra = mul8table[extraA];
685 
686     vis_write_gsr(0 &lt;&lt; 3);
687 
688     if (pMask != NULL) {
689         pMask += maskOff;
690 
691         if (dstScan == 4*width &amp;&amp; srcScan == dstScan &amp;&amp; maskScan == width) {
692             width *= height;
693             height = 1;
694         }
695 
696         for (j = 0; j &lt; height; j++) {
697             IntArgbToIntBgrSrcOverMaskBlit_line(dstBase, srcBase, pMask,
698                                                  width, mul8_extra,
699                                                  (void*)mul8table);
700 
701             PTR_ADD(dstBase, dstScan);
702             PTR_ADD(srcBase, srcScan);
703             PTR_ADD(pMask, maskScan);
704         }
705     } else {
706         if (dstScan == 4*width &amp;&amp; srcScan == dstScan) {
707             width *= height;
708             height = 1;
709         }
710 
711         for (j = 0; j &lt; height; j++) {
712             IntArgbToIntBgrSrcOverMaskBlit_A1_line(dstBase, srcBase, pMask,
713                                                     width, mul8_extra,
714                                                     (void*)mul8table);
715 
716             PTR_ADD(dstBase, dstScan);
717             PTR_ADD(srcBase, srcScan);
718         }
719     }
720 }
721 
722 /***************************************************************/
723 
724 #endif
    </pre>
  </body>
</html>
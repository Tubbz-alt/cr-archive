<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libawt/java2d/loops/vis_GlyphListXor.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #if !defined(JAVA2D_NO_MLIB) || defined(MLIB_ADD_SUFF)
 27 
 28 #include &lt;vis_proto.h&gt;
 29 #include &quot;vis_AlphaMacros.h&quot;
 30 
 31 /***************************************************************/
 32 
 33 #define STORE_INT      \
 34     *dst ^= fgpixel
 35 
 36 #define STORE_D64(TSIZE, dst, mask)    \
 37     vis_pst_##TSIZE(vis_fxor(*(mlib_d64*)(dst), fgpixel_d), dst, mask)
 38 
 39 /***************************************************************/
 40 
 41 #define INIT_FG                                                \
 42     fgpixel = (fgpixel ^ pCompInfo-&gt;details.xorPixel)          \
 43               &amp;~ pCompInfo-&gt;alphaMask;
 44 
 45 /***************************************************************/
 46 
 47 #define DEF_GLYPH(TSIZE)                                       \
 48     const jubyte *pixels;                                      \
 49     unsigned int rowBytes;                                     \
 50     int left, top;                                             \
 51     int width, height;                                         \
 52     int right, bottom;                                         \
 53                                                                \
 54     pixels = (const jubyte *) glyphs[glyphCounter].pixels;     \
 55                                                                \
 56     if (!pixels) continue;                                     \
 57                                                                \
 58     left = glyphs[glyphCounter].x;                             \
 59     top = glyphs[glyphCounter].y;                              \
 60     width = glyphs[glyphCounter].width;                        \
 61     height = glyphs[glyphCounter].height;                      \
 62     rowBytes = width;                                          \
 63     right = left + width;                                      \
 64     bottom = top + height;                                     \
 65     if (left &lt; clipLeft) {                                     \
 66         pixels += clipLeft - left;                             \
 67         left = clipLeft;                                       \
 68     }                                                          \
 69     if (top &lt; clipTop) {                                       \
 70         pixels += (clipTop - top) * rowBytes;                  \
 71         top = clipTop;                                         \
 72     }                                                          \
 73     if (right &gt; clipRight) {                                   \
 74         right = clipRight;                                     \
 75     }                                                          \
 76     if (bottom &gt; clipBottom) {                                 \
 77         bottom = clipBottom;                                   \
 78     }                                                          \
 79     if (right &lt;= left || bottom &lt;= top) {                      \
 80         continue;                                              \
 81     }                                                          \
 82     width = right - left;                                      \
 83     height = bottom - top;                                     \
 84                                                                \
 85     dstBase = pRasInfo-&gt;rasBase;                               \
 86     PTR_ADD(dstBase, top*scan + TSIZE*left)
 87 
 88 /***************************************************************/
 89 
 90 void ADD_SUFF(AnyByteDrawGlyphListXor)(GLYPH_LIST_PARAMS)
 91 {
 92     mlib_s32 glyphCounter;
 93     mlib_s32 scan = pRasInfo-&gt;scanStride;
 94     mlib_u8  *dstBase;
 95     mlib_s32 j;
 96     mlib_d64 fgpixel_d;
 97     mlib_d64 dzero;
 98     mlib_s32 pix, mask0, mask1, mask_h, mask_l, off;
 99     mlib_f32 fzero;
100 
101     INIT_FG
102 
103     fzero = vis_fzeros();
104     dzero = vis_fzero();
105     D64_FROM_U8x8(fgpixel_d, fgpixel);
106 
107     for (glyphCounter = 0; glyphCounter &lt; totalGlyphs; glyphCounter++) {
108         DEF_GLYPH(1);
109 
110         for (j = 0; j &lt; height; j++) {
111             mlib_u8 *src = (void*)pixels;
112             mlib_u8 *dst, *dst_end;
113             mlib_d64 ss, s0, s1;
114 
115             dst = (void*)dstBase;
116             dst_end = dst + width;
117 
118             while (((mlib_s32)dst &amp; 7) &amp;&amp; (dst &lt; dst_end)) {
119                 pix = *src++;
120                 if (pix) STORE_INT;
121                 dst++;
122             }
123 
124             off = (mlib_s32)src &amp; 7;
125             ss = *(mlib_d64*)(src - off);
126             mask_h = vis_fcmpne16(vis_fpmerge(vis_read_hi(ss), fzero), dzero);
127             mask_l = vis_fcmpne16(vis_fpmerge(vis_read_lo(ss), fzero), dzero);
128             mask1 = (mask_h &lt;&lt; 4) | mask_l;
129 
130 #pragma pipeloop(0)
131             for (; dst &lt;= (dst_end - 8); dst += 8) {
132                 mask0 = mask1;
133                 src += 8;
134                 ss = *(mlib_d64*)(src - off);
135                 s0 = vis_fpmerge(vis_read_hi(ss), fzero);
136                 s1 = vis_fpmerge(vis_read_lo(ss), fzero);
137                 mask_h = vis_fcmpne16(s0, dzero);
138                 mask_l = vis_fcmpne16(s1, dzero);
139                 mask1 = (mask_h &lt;&lt; 4) | mask_l;
140                 STORE_D64(8, dst, (mask0 &lt;&lt; off) | (mask1 &gt;&gt; (8 - off)));
141             }
142 
143             while (dst &lt; dst_end) {
144                 pix = *src++;
145                 if (pix) STORE_INT;
146                 dst++;
147             }
148 
149             PTR_ADD(dstBase, scan);
150             pixels += rowBytes;
151         }
152     }
153 }
154 
155 /***************************************************************/
156 
157 void ADD_SUFF(AnyShortDrawGlyphListXor)(GLYPH_LIST_PARAMS)
158 {
159     mlib_s32 glyphCounter;
160     mlib_s32 scan = pRasInfo-&gt;scanStride;
161     mlib_u8  *dstBase;
162     mlib_s32 j;
163     mlib_d64 fgpixel_d;
164     mlib_d64 dzero;
165     mlib_s32 pix, mask0, mask1, off;
166     mlib_f32 fzero;
167 
168     INIT_FG
169 
170     fzero = vis_fzeros();
171     dzero = vis_fzero();
172     D64_FROM_U16x4(fgpixel_d, fgpixel);
173 
174     for (glyphCounter = 0; glyphCounter &lt; totalGlyphs; glyphCounter++) {
175         DEF_GLYPH(2);
176 
177         for (j = 0; j &lt; height; j++) {
178             mlib_u8 *src = (void*)pixels;
179             mlib_u16 *dst, *dst_end;
180             mlib_f32 ss;
181 
182             dst = (void*)dstBase;
183             dst_end = dst + width;
184 
185             while (((mlib_s32)dst &amp; 7) &amp;&amp; (dst &lt; dst_end)) {
186                 pix = *src++;
187                 if (pix) STORE_INT;
188                 dst++;
189             }
190 
191             off = (mlib_s32)src &amp; 3;
192             ss = *(mlib_f32*)(src - off);
193             mask1 = vis_fcmpne16(vis_fpmerge(ss, fzero), dzero);
194 
195 #pragma pipeloop(0)
196             for (; dst &lt;= (dst_end - 4); dst += 4) {
197                 mask0 = mask1;
198                 src += 4;
199                 ss = *(mlib_f32*)(src - off);
200                 mask1 = vis_fcmpne16(vis_fpmerge(ss, fzero), dzero);
201                 STORE_D64(16, dst, (mask0 &lt;&lt; off) | (mask1 &gt;&gt; (4 - off)));
202             }
203 
204             while (dst &lt; dst_end) {
205                 pix = *src++;
206                 if (pix) STORE_INT;
207                 dst++;
208             }
209 
210             PTR_ADD(dstBase, scan);
211             pixels += rowBytes;
212         }
213     }
214 }
215 
216 /***************************************************************/
217 
218 void ADD_SUFF(AnyIntDrawGlyphListXor)(GLYPH_LIST_PARAMS)
219 {
220     mlib_s32 glyphCounter;
221     mlib_s32 scan = pRasInfo-&gt;scanStride;
222     mlib_u8  *dstBase;
223     mlib_s32 j;
224     mlib_d64 fgpixel_d;
225     mlib_d64 dzero;
226     mlib_s32 pix, mask0, mask1, mask, off;
227     mlib_f32 fzero;
228 
229     INIT_FG
230 
231     fzero = vis_fzeros();
232     dzero = vis_fzero();
233     fgpixel_d = vis_to_double_dup(fgpixel);
234 
235     for (glyphCounter = 0; glyphCounter &lt; totalGlyphs; glyphCounter++) {
236         DEF_GLYPH(4);
237 
238         for (j = 0; j &lt; height; j++) {
239             mlib_u8 *src = (void*)pixels;
240             mlib_u32 *dst, *dst_end;
241             mlib_f32 ss;
242 
243             dst = (void*)dstBase;
244             dst_end = dst + width;
245 
246             while (((mlib_s32)dst &amp; 7) &amp;&amp; (dst &lt; dst_end)) {
247                 pix = *src++;
248                 if (pix) STORE_INT;
249                 dst++;
250             }
251 
252             off = (mlib_s32)src &amp; 3;
253             ss = *(mlib_f32*)(src - off);
254             mask1 = vis_fcmpne16(vis_fpmerge(ss, fzero), dzero);
255 
256 #pragma pipeloop(0)
257             for (; dst &lt;= (dst_end - 4); dst += 4) {
258                 mask0 = mask1;
259                 src += 4;
260                 ss = *(mlib_f32*)(src - off);
261                 mask1 = vis_fcmpne16(vis_fpmerge(ss, fzero), dzero);
262                 mask = (mask0 &lt;&lt; off) | (mask1 &gt;&gt; (4 - off));
263                 STORE_D64(32, dst, mask &gt;&gt; 2);
264                 STORE_D64(32, dst + 2, mask);
265             }
266 
267             while (dst &lt; dst_end) {
268                 pix = *src++;
269                 if (pix) STORE_INT;
270                 dst++;
271             }
272 
273             PTR_ADD(dstBase, scan);
274             pixels += rowBytes;
275         }
276     }
277 }
278 
279 /***************************************************************/
280 
281 void ADD_SUFF(Any4ByteDrawGlyphListXor)(GLYPH_LIST_PARAMS)
282 {
283     mlib_d64 buff[BUFF_SIZE/2];
284     void     *pbuff = buff;
285     mlib_s32 glyphCounter;
286     mlib_s32 scan = pRasInfo-&gt;scanStride;
287     mlib_u8  *dstBase;
288     mlib_s32 j;
289     mlib_d64 fgpixel_d;
290     mlib_d64 dzero;
291     mlib_s32 pix, mask0, mask1, mask, off;
292     mlib_f32 fzero, fgpixel_f;
293     mlib_s32 max_width = BUFF_SIZE;
294 
295     INIT_FG
296 
297     fzero = vis_fzeros();
298     dzero = vis_fzero();
299     fgpixel_f = vis_ldfa_ASI_PL(&amp;fgpixel);
300     fgpixel_d = vis_freg_pair(fgpixel_f, fgpixel_f);
301     fgpixel = *(mlib_u32*)&amp;fgpixel_f;
302 
303     for (glyphCounter = 0; glyphCounter &lt; totalGlyphs; glyphCounter++) {
304         DEF_GLYPH(4);
305 
306         if (((mlib_s32)dstBase | scan) &amp; 3) {
307             if (width &gt; max_width) {
308                 if (pbuff != buff) {
309                     mlib_free(pbuff);
310                 }
311                 pbuff = mlib_malloc(width*sizeof(mlib_s32));
312                 if (pbuff == NULL) return;
313                 max_width = width;
314             }
315         }
316 
317         for (j = 0; j &lt; height; j++) {
318             mlib_u8 *src = (void*)pixels;
319             mlib_u32 *dst, *dst_end;
320             mlib_f32 ss;
321 
322             if ((mlib_s32)dstBase &amp; 3) {
323                 COPY_NA(dstBase, pbuff, width*sizeof(mlib_s32));
324                 dst = pbuff;
325             } else {
326                 dst = (void*)dstBase;
327             }
328             dst_end = dst + width;
329 
330             while (((mlib_s32)dst &amp; 7) &amp;&amp; (dst &lt; dst_end)) {
331                 pix = *src++;
332                 if (pix) STORE_INT;
333                 dst++;
334             }
335 
336             off = (mlib_s32)src &amp; 3;
337             ss = *(mlib_f32*)(src - off);
338             mask1 = vis_fcmpne16(vis_fpmerge(ss, fzero), dzero);
339 
340 #pragma pipeloop(0)
341             for (; dst &lt;= (dst_end - 4); dst += 4) {
342                 mask0 = mask1;
343                 src += 4;
344                 ss = *(mlib_f32*)(src - off);
345                 mask1 = vis_fcmpne16(vis_fpmerge(ss, fzero), dzero);
346                 mask = (mask0 &lt;&lt; off) | (mask1 &gt;&gt; (4 - off));
347                 STORE_D64(32, dst, mask &gt;&gt; 2);
348                 STORE_D64(32, dst + 2, mask);
349             }
350 
351             while (dst &lt; dst_end) {
352                 pix = *src++;
353                 if (pix) STORE_INT;
354                 dst++;
355             }
356 
357             if ((mlib_s32)dstBase &amp; 3) {
358                 COPY_NA(pbuff, dstBase, width*sizeof(mlib_s32));
359             }
360 
361             PTR_ADD(dstBase, scan);
362             pixels += rowBytes;
363         }
364     }
365 
366     if (pbuff != buff) {
367         mlib_free(pbuff);
368     }
369 }
370 
371 /***************************************************************/
372 
373 #endif /* JAVA2D_NO_MLIB */
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libawt/java2d/loops/vis_IntRgb.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #if !defined(JAVA2D_NO_MLIB) || defined(MLIB_ADD_SUFF)
 27 
 28 #include &quot;vis_AlphaMacros.h&quot;
 29 
 30 /***************************************************************/
 31 
 32 #define Gray2Rgb(x)    \
 33     (x &lt;&lt; 16) | (x &lt;&lt; 8) | x
 34 
 35 /***************************************************************/
 36 
 37 #define INT_RGB(r, g, b)       \
 38     ((r &lt;&lt; 16) | (g &lt;&lt; 8) | b)
 39 
 40 /***************************************************************/
 41 
 42 void ADD_SUFF(IntRgbToIntArgbConvert)(BLIT_PARAMS)
 43 {
 44     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
 45     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
 46     mlib_d64 dd, mask;
 47     mlib_s32 i, i0, j;
 48 
 49     if (dstScan == 4*width &amp;&amp; srcScan == 4*width) {
 50         width *= height;
 51         height = 1;
 52     }
 53 
 54     mask = vis_to_double_dup(0xFF000000);
 55 
 56     for (j = 0; j &lt; height; j++) {
 57         mlib_f32 *src = srcBase;
 58         mlib_f32 *dst = dstBase;
 59 
 60         i = i0 = 0;
 61 
 62         if ((mlib_s32)dst &amp; 7) {
 63             dst[i] = vis_fors(src[i], vis_read_hi(mask));
 64             i0 = 1;
 65         }
 66 
 67 #pragma pipeloop(0)
 68         for (i = i0; i &lt;= (mlib_s32)width - 2; i += 2) {
 69             dd = vis_freg_pair(src[i], src[i + 1]);
 70 
 71             *(mlib_d64*)(dst + i) = vis_for(dd, mask);
 72         }
 73 
 74         if (i &lt; width) {
 75             dst[i] = vis_fors(src[i], vis_read_hi(mask));
 76         }
 77 
 78         PTR_ADD(dstBase, dstScan);
 79         PTR_ADD(srcBase, srcScan);
 80     }
 81 }
 82 
 83 /***************************************************************/
 84 
 85 void ADD_SUFF(IntRgbToIntArgbScaleConvert)(SCALE_PARAMS)
 86 {
 87     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
 88     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
 89     mlib_d64 dd, mask;
 90     mlib_s32 j;
 91 
 92     mask = vis_to_double_dup(0xFF000000);
 93 
 94     for (j = 0; j &lt; height; j++) {
 95         mlib_f32 *src = srcBase;
 96         mlib_f32 *dst = dstBase;
 97         mlib_f32 *dst_end = dst + width;
 98         mlib_s32 tmpsxloc = sxloc;
 99 
100         PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
101 
102         if ((mlib_s32)dst &amp; 7) {
103             *dst++ = vis_fors(src[tmpsxloc &gt;&gt; shift], vis_read_hi(mask));
104             tmpsxloc += sxinc;
105         }
106 
107 #pragma pipeloop(0)
108         for (; dst &lt;= dst_end - 2; dst += 2) {
109             dd = vis_freg_pair(src[tmpsxloc &gt;&gt; shift],
110                                src[(tmpsxloc + sxinc) &gt;&gt; shift]);
111             *(mlib_d64*)dst = vis_for(dd, mask);
112             tmpsxloc += 2*sxinc;
113         }
114 
115         for (; dst &lt; dst_end; dst++) {
116             *dst++ = vis_fors(src[tmpsxloc &gt;&gt; shift], vis_read_hi(mask));
117             tmpsxloc += sxinc;
118         }
119 
120         PTR_ADD(dstBase, dstScan);
121         syloc += syinc;
122     }
123 }
124 
125 /***************************************************************/
126 
127 #define BGR_TO_ARGB {                                          \
128     mlib_d64 sda, sdb, sdc, sdd, sde, sdf;                     \
129     mlib_d64 s_1, s_2, s_3, a13, b13, a02, b02;                \
130                                                                \
131     sda = vis_fpmerge(vis_read_hi(sd0), vis_read_lo(sd1));     \
132     sdb = vis_fpmerge(vis_read_lo(sd0), vis_read_hi(sd2));     \
133     sdc = vis_fpmerge(vis_read_hi(sd1), vis_read_lo(sd2));     \
134                                                                \
135     sdd = vis_fpmerge(vis_read_hi(sda), vis_read_lo(sdb));     \
136     sde = vis_fpmerge(vis_read_lo(sda), vis_read_hi(sdc));     \
137     sdf = vis_fpmerge(vis_read_hi(sdb), vis_read_lo(sdc));     \
138                                                                \
139     s_3 = vis_fpmerge(vis_read_hi(sdd), vis_read_lo(sde));     \
140     s_2 = vis_fpmerge(vis_read_lo(sdd), vis_read_hi(sdf));     \
141     s_1 = vis_fpmerge(vis_read_hi(sde), vis_read_lo(sdf));     \
142                                                                \
143     a13 = vis_fpmerge(vis_read_hi(s_1), vis_read_hi(s_3));     \
144     b13 = vis_fpmerge(vis_read_lo(s_1), vis_read_lo(s_3));     \
145     a02 = vis_fpmerge(vis_read_hi(s_0), vis_read_hi(s_2));     \
146     b02 = vis_fpmerge(vis_read_lo(s_0), vis_read_lo(s_2));     \
147                                                                \
148     dd0 = vis_fpmerge(vis_read_hi(a02), vis_read_hi(a13));     \
149     dd1 = vis_fpmerge(vis_read_lo(a02), vis_read_lo(a13));     \
150     dd2 = vis_fpmerge(vis_read_hi(b02), vis_read_hi(b13));     \
151     dd3 = vis_fpmerge(vis_read_lo(b02), vis_read_lo(b13));     \
152 }
153 
154 /***************************************************************/
155 
156 void ADD_SUFF(ThreeByteBgrToIntRgbConvert)(BLIT_PARAMS)
157 {
158     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
159     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
160     mlib_d64 *sp;
161     mlib_d64 s_0;
162     mlib_d64 s0, s1, s2, s3, sd0, sd1, sd2, dd0, dd1, dd2, dd3;
163     mlib_s32 i, i0, j;
164 
165     if (width &lt; 16) {
166         for (j = 0; j &lt; height; j++) {
167             mlib_u8  *src = srcBase;
168             mlib_s32 *dst = dstBase;
169 
170             for (i = 0; i &lt; width; i++) {
171                 dst[i] = INT_RGB(src[3*i + 2], src[3*i + 1], src[3*i]);
172             }
173 
174             PTR_ADD(dstBase, dstScan);
175             PTR_ADD(srcBase, srcScan);
176         }
177         return;
178     }
179 
180     if (srcScan == 3*width &amp;&amp; dstScan == 4*width) {
181         width *= height;
182         height = 1;
183     }
184 
185     s_0 = vis_fzero();
186 
187     for (j = 0; j &lt; height; j++) {
188         mlib_u8  *src = srcBase;
189         mlib_f32 *dst = dstBase;
190 
191         i = i0 = 0;
192 
193         if ((mlib_s32)dst &amp; 7) {
194             ((mlib_s32*)dst)[i] = INT_RGB(src[3*i + 2], src[3*i + 1], src[3*i]);
195             i0 = 1;
196         }
197 
198         sp = vis_alignaddr(src, 3*i0);
199         s3 = *sp++;
200 
201 #pragma pipeloop(0)
202         for (i = i0; i &lt;= (mlib_s32)width - 8; i += 8) {
203             s0 = s3;
204             s1 = *sp++;
205             s2 = *sp++;
206             s3 = *sp++;
207             sd0 = vis_faligndata(s0, s1);
208             sd1 = vis_faligndata(s1, s2);
209             sd2 = vis_faligndata(s2, s3);
210 
211             BGR_TO_ARGB
212 
213             *(mlib_d64*)(dst + i    ) = dd0;
214             *(mlib_d64*)(dst + i + 2) = dd1;
215             *(mlib_d64*)(dst + i + 4) = dd2;
216             *(mlib_d64*)(dst + i + 6) = dd3;
217         }
218 
219         for (; i &lt; width; i++) {
220             ((mlib_s32*)dst)[i] = INT_RGB(src[3*i + 2], src[3*i + 1], src[3*i]);
221         }
222 
223         PTR_ADD(dstBase, dstScan);
224         PTR_ADD(srcBase, srcScan);
225     }
226 }
227 
228 /***************************************************************/
229 
230 void ADD_SUFF(ThreeByteBgrToIntRgbScaleConvert)(SCALE_PARAMS)
231 {
232     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
233     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
234     mlib_d64 dd, maskFF;
235     mlib_s32 i, i0, i1, j;
236 
237     if (width &lt; 16) {
238         for (j = 0; j &lt; height; j++) {
239             mlib_u8  *src = srcBase;
240             mlib_s32 *dst = dstBase;
241             mlib_s32 *dst_end = dst + width;
242             mlib_s32 tmpsxloc = sxloc;
243 
244             PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
245 
246             for (; dst &lt; dst_end; dst++) {
247                 i = tmpsxloc &gt;&gt; shift;
248                 tmpsxloc += sxinc;
249                 *(mlib_s32*)dst = INT_RGB(src[3*i + 2], src[3*i + 1], src[3*i]);
250             }
251 
252             PTR_ADD(dstBase, dstScan);
253             syloc += syinc;
254         }
255         return;
256     }
257 
258     maskFF = vis_fzero();
259 
260     vis_alignaddr(NULL, 7);
261 
262     for (j = 0; j &lt; height; j++) {
263         mlib_u8  *src = srcBase;
264         mlib_f32 *dst = dstBase;
265         mlib_f32 *dst_end = dst + width;
266         mlib_s32 tmpsxloc = sxloc;
267 
268         PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
269 
270         if ((mlib_s32)dst &amp; 7) {
271             i = tmpsxloc &gt;&gt; shift;
272             tmpsxloc += sxinc;
273             *(mlib_s32*)dst = INT_RGB(src[3*i + 2], src[3*i + 1], src[3*i]);
274             dst++;
275         }
276 
277 #pragma pipeloop(0)
278         for (; dst &lt;= dst_end - 2; dst += 2) {
279             i0 = tmpsxloc &gt;&gt; shift;
280             i1 = (tmpsxloc + sxinc) &gt;&gt; shift;
281             tmpsxloc += 2*sxinc;
282 
283             dd = vis_faligndata(vis_ld_u8(src + 3*i1    ), dd);
284             dd = vis_faligndata(vis_ld_u8(src + 3*i1 + 1), dd);
285             dd = vis_faligndata(vis_ld_u8(src + 3*i1 + 2), dd);
286             dd = vis_faligndata(maskFF, dd);
287             dd = vis_faligndata(vis_ld_u8(src + 3*i0    ), dd);
288             dd = vis_faligndata(vis_ld_u8(src + 3*i0 + 1), dd);
289             dd = vis_faligndata(vis_ld_u8(src + 3*i0 + 2), dd);
290             dd = vis_faligndata(maskFF, dd);
291 
292             *(mlib_d64*)dst = dd;
293         }
294 
295         for (; dst &lt; dst_end; dst++) {
296             i = tmpsxloc &gt;&gt; shift;
297             tmpsxloc += sxinc;
298             *(mlib_s32*)dst = INT_RGB(src[3*i + 2], src[3*i + 1], src[3*i]);
299         }
300 
301         PTR_ADD(dstBase, dstScan);
302         syloc += syinc;
303     }
304 }
305 
306 /***************************************************************/
307 
308 void ADD_SUFF(ByteGrayToIntRgbConvert)(BLIT_PARAMS)
309 {
310     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
311     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
312     mlib_d64 d0, d1, d2, d3;
313     mlib_f32 ff, aa = vis_fzero();
314     mlib_s32 i, j, x;
315 
316     if (width &lt; 8) {
317         for (j = 0; j &lt; height; j++) {
318             mlib_u8  *src = srcBase;
319             mlib_s32 *dst = dstBase;
320 
321             for (i = 0; i &lt; width; i++) {
322                 x = src[i];
323                 dst[i] = Gray2Rgb(x);
324             }
325 
326             PTR_ADD(dstBase, dstScan);
327             PTR_ADD(srcBase, srcScan);
328         }
329         return;
330     }
331 
332     if (srcScan == width &amp;&amp; dstScan == 4*width) {
333         width *= height;
334         height = 1;
335     }
336 
337     for (j = 0; j &lt; height; j++) {
338         mlib_u8  *src = srcBase;
339         mlib_s32 *dst = dstBase;
340         mlib_s32 *dst_end;
341 
342         dst_end = dst + width;
343 
344         while (((mlib_s32)src &amp; 3) &amp;&amp; dst &lt; dst_end) {
345             x = *src++;
346             *dst++ = Gray2Rgb(x);
347         }
348 
349 #pragma pipeloop(0)
350         for (; dst &lt;= (dst_end - 4); dst += 4) {
351             ff = *(mlib_f32*)src;
352             d0 = vis_fpmerge(aa, ff);
353             d1 = vis_fpmerge(ff, ff);
354             d2 = vis_fpmerge(vis_read_hi(d0), vis_read_hi(d1));
355             d3 = vis_fpmerge(vis_read_lo(d0), vis_read_lo(d1));
356             ((mlib_f32*)dst)[0] = vis_read_hi(d2);
357             ((mlib_f32*)dst)[1] = vis_read_lo(d2);
358             ((mlib_f32*)dst)[2] = vis_read_hi(d3);
359             ((mlib_f32*)dst)[3] = vis_read_lo(d3);
360             src += 4;
361         }
362 
363         while (dst &lt; dst_end) {
364             x = *src++;
365             *dst++ = Gray2Rgb(x);
366         }
367 
368         PTR_ADD(dstBase, dstScan);
369         PTR_ADD(srcBase, srcScan);
370     }
371 }
372 
373 /***************************************************************/
374 
375 void ADD_SUFF(ByteGrayToIntRgbScaleConvert)(SCALE_PARAMS)
376 {
377     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
378     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
379     mlib_d64 d0, d1, d2, d3, dd;
380     mlib_f32 ff, aa = vis_fzero();
381     mlib_s32 i, j, x;
382 
383     if (width &lt; 16) {
384         for (j = 0; j &lt; height; j++) {
385             mlib_u8  *src = srcBase;
386             mlib_s32 *dst = dstBase;
387             mlib_s32 tmpsxloc = sxloc;
388 
389             PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
390 
391             for (i = 0; i &lt; width; i++) {
392                 x = src[tmpsxloc &gt;&gt; shift];
393                 tmpsxloc += sxinc;
394                 dst[i] = Gray2Rgb(x);
395             }
396 
397             PTR_ADD(dstBase, dstScan);
398             syloc += syinc;
399         }
400         return;
401     }
402 
403     vis_alignaddr(NULL, 7);
404 
405     for (j = 0; j &lt; height; j++) {
406         mlib_u8  *src = srcBase;
407         mlib_s32 *dst = dstBase;
408         mlib_s32 *dst_end;
409         mlib_s32 tmpsxloc = sxloc;
410 
411         PTR_ADD(src, (syloc &gt;&gt; shift) * srcScan);
412 
413         dst_end = dst + width;
414 
415 #pragma pipeloop(0)
416         for (; dst &lt;= (dst_end - 4); dst += 4) {
417             LOAD_NEXT_U8(dd, src + ((tmpsxloc + 3*sxinc) &gt;&gt; shift));
418             LOAD_NEXT_U8(dd, src + ((tmpsxloc + 2*sxinc) &gt;&gt; shift));
419             LOAD_NEXT_U8(dd, src + ((tmpsxloc +   sxinc) &gt;&gt; shift));
420             LOAD_NEXT_U8(dd, src + ((tmpsxloc          ) &gt;&gt; shift));
421             tmpsxloc += 4*sxinc;
422             ff = vis_read_hi(dd);
423             d0 = vis_fpmerge(aa, ff);
424             d1 = vis_fpmerge(ff, ff);
425             d2 = vis_fpmerge(vis_read_hi(d0), vis_read_hi(d1));
426             d3 = vis_fpmerge(vis_read_lo(d0), vis_read_lo(d1));
427             ((mlib_f32*)dst)[0] = vis_read_hi(d2);
428             ((mlib_f32*)dst)[1] = vis_read_lo(d2);
429             ((mlib_f32*)dst)[2] = vis_read_hi(d3);
430             ((mlib_f32*)dst)[3] = vis_read_lo(d3);
431         }
432 
433         while (dst &lt; dst_end) {
434             x = src[tmpsxloc &gt;&gt; shift];
435             tmpsxloc += sxinc;
436             *dst++ = Gray2Rgb(x);
437         }
438 
439         PTR_ADD(dstBase, dstScan);
440         syloc += syinc;
441     }
442 }
443 
444 /***************************************************************/
445 
446 void ADD_SUFF(IntArgbBmToIntRgbXparOver)(BLIT_PARAMS)
447 {
448     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
449     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
450     mlib_d64 dd;
451     mlib_s32 i, i0, j, mask;
452 
453     if (dstScan == 4*width &amp;&amp; srcScan == 4*width) {
454         width *= height;
455         height = 1;
456     }
457 
458     for (j = 0; j &lt; height; j++) {
459         mlib_f32 *src = srcBase;
460         mlib_f32 *dst = dstBase;
461 
462         i = i0 = 0;
463 
464         if ((mlib_s32)dst &amp; 7) {
465             if (*(mlib_u8*)(src + i)) {
466                 dst[i] = src[i];
467             }
468             i0 = 1;
469         }
470 
471 #pragma pipeloop(0)
472         for (i = i0; i &lt;= (mlib_s32)width - 2; i += 2) {
473             dd = vis_freg_pair(src[i], src[i + 1]);
474 
475             mask = (((-*(mlib_u8*)(src + i)) &gt;&gt; 31) &amp; 2) |
476                    (((-*(mlib_u8*)(src + i + 1)) &gt;&gt; 31) &amp; 1);
477             vis_pst_32(dd, dst + i, mask);
478         }
479 
480         if (i &lt; width) {
481             if (*(mlib_u8*)(src + i)) {
482                 dst[i] = src[i];
483             }
484         }
485 
486         PTR_ADD(dstBase, dstScan);
487         PTR_ADD(srcBase, srcScan);
488     }
489 }
490 
491 /***************************************************************/
492 
493 void ADD_SUFF(IntArgbBmToIntRgbXparBgCopy)(BCOPY_PARAMS)
494 {
495     mlib_s32 dstScan = pDstInfo-&gt;scanStride;
496     mlib_s32 srcScan = pSrcInfo-&gt;scanStride;
497     mlib_d64 dd, d_bgpixel;
498     mlib_s32 i, i0, j, mask;
499 
500     if (dstScan == 4*width &amp;&amp; srcScan == 4*width) {
501         width *= height;
502         height = 1;
503     }
504 
505     d_bgpixel = vis_to_double_dup(bgpixel);
506 
507     for (j = 0; j &lt; height; j++) {
508         mlib_f32 *src = srcBase;
509         mlib_f32 *dst = dstBase;
510 
511         i = i0 = 0;
512 
513         if ((mlib_s32)dst &amp; 7) {
514             if (*(mlib_u8*)(src + i)) {
515                 dst[i] = src[i];
516             } else {
517                 dst[i] = vis_read_hi(d_bgpixel);
518             }
519             i0 = 1;
520         }
521 
522 #pragma pipeloop(0)
523         for (i = i0; i &lt;= (mlib_s32)width - 2; i += 2) {
524             dd = vis_freg_pair(src[i], src[i + 1]);
525 
526             mask = (((-*(mlib_u8*)(src + i)) &gt;&gt; 31) &amp; 2) |
527                    (((-*(mlib_u8*)(src + i + 1)) &gt;&gt; 31) &amp; 1);
528             *(mlib_d64*)(dst + i) = d_bgpixel;
529             vis_pst_32(dd, dst + i, mask);
530         }
531 
532         if (i &lt; width) {
533             if (*(mlib_u8*)(src + i)) {
534                 dst[i] = src[i];
535             } else {
536                 dst[i] = vis_read_hi(d_bgpixel);
537             }
538         }
539 
540         PTR_ADD(dstBase, dstScan);
541         PTR_ADD(srcBase, srcScan);
542     }
543 }
544 
545 /***************************************************************/
546 
547 void ADD_SUFF(IntRgbDrawGlyphListAA)(GLYPH_LIST_PARAMS)
548 {
549     mlib_s32 glyphCounter;
550     mlib_s32 scan = pRasInfo-&gt;scanStride;
551     mlib_u8  *dstBase;
552     mlib_s32 j;
553     mlib_d64 dmix0, dmix1, dd, d0, d1, e0, e1, fgpixel_d;
554     mlib_d64 done, done16, d_half, maskRGB, dzero;
555     mlib_s32 pix, mask, mask_z;
556     mlib_f32 srcG_f;
557 
558     done = vis_to_double_dup(0x7fff7fff);
559     done16 = vis_to_double_dup(0x7fff);
560     d_half = vis_to_double_dup((1 &lt;&lt; (16 + 6)) | (1 &lt;&lt; 6));
561 
562     fgpixel_d = vis_to_double_dup(fgpixel);
563     srcG_f = vis_to_float(argbcolor);
564     maskRGB = vis_to_double_dup(0xffffff);
565     dzero = vis_fzero();
566 
567     vis_write_gsr(0 &lt;&lt; 3);
568 
569     for (glyphCounter = 0; glyphCounter &lt; totalGlyphs; glyphCounter++) {
570         const jubyte *pixels;
571         unsigned int rowBytes;
572         int left, top;
573         int width, height;
574         int right, bottom;
575 
576         pixels = (const jubyte *) glyphs[glyphCounter].pixels;
577 
578         if (!pixels) continue;
579 
580         left = glyphs[glyphCounter].x;
581         top = glyphs[glyphCounter].y;
582         width = glyphs[glyphCounter].width;
583         height = glyphs[glyphCounter].height;
584         rowBytes = width;
585         right = left + width;
586         bottom = top + height;
587         if (left &lt; clipLeft) {
588             pixels += clipLeft - left;
589             left = clipLeft;
590         }
591         if (top &lt; clipTop) {
592             pixels += (clipTop - top) * rowBytes;
593             top = clipTop;
594         }
595         if (right &gt; clipRight) {
596             right = clipRight;
597         }
598         if (bottom &gt; clipBottom) {
599             bottom = clipBottom;
600         }
601         if (right &lt;= left || bottom &lt;= top) {
602             continue;
603         }
604         width = right - left;
605         height = bottom - top;
606 
607         dstBase = pRasInfo-&gt;rasBase;
608         PTR_ADD(dstBase, top*scan + 4*left);
609 
610         for (j = 0; j &lt; height; j++) {
611             mlib_u8  *src = (void*)pixels;
612             mlib_s32 *dst, *dst_end;
613 
614             dst = (void*)dstBase;
615             dst_end = dst + width;
616 
617             if ((mlib_s32)dst &amp; 7) {
618                 pix = *src++;
619                 if (pix) {
620                     dd = vis_fpadd16(MUL8_VIS(srcG_f, pix), d_half);
621                     dd = vis_fpadd16(MUL8_VIS(*(mlib_f32*)dst, 255 - pix), dd);
622                     *(mlib_f32*)dst = vis_fands(vis_fpack16(dd),
623                                                 vis_read_hi(maskRGB));
624                     if (pix == 255) *(mlib_f32*)dst = vis_read_hi(fgpixel_d);
625                 }
626                 dst++;
627             }
628 
629 #pragma pipeloop(0)
630             for (; dst &lt;= (dst_end - 2); dst += 2) {
631                 dmix0 = vis_freg_pair(((mlib_f32 *)vis_mul8s_tbl)[src[0]],
632                                       ((mlib_f32 *)vis_mul8s_tbl)[src[1]]);
633                 mask = vis_fcmplt32(dmix0, done16);
634                 mask_z = vis_fcmpne32(dmix0, dzero);
635                 dmix1 = vis_fpsub16(done, dmix0);
636                 src += 2;
637 
638                 dd = *(mlib_d64*)dst;
639                 d0 = vis_fmul8x16al(srcG_f, vis_read_hi(dmix0));
640                 d1 = vis_fmul8x16al(srcG_f, vis_read_lo(dmix0));
641                 e0 = vis_fmul8x16al(vis_read_hi(dd), vis_read_hi(dmix1));
642                 e1 = vis_fmul8x16al(vis_read_lo(dd), vis_read_lo(dmix1));
643                 d0 = vis_fpadd16(vis_fpadd16(d0, d_half), e0);
644                 d1 = vis_fpadd16(vis_fpadd16(d1, d_half), e1);
645                 dd = vis_fpack16_pair(d0, d1);
646                 dd = vis_fand(dd, maskRGB);
647 
648                 vis_pst_32(fgpixel_d, dst, mask_z);
649                 vis_pst_32(dd, dst, mask &amp; mask_z);
650             }
651 
652             while (dst &lt; dst_end) {
653                 pix = *src++;
654                 if (pix) {
655                     dd = vis_fpadd16(MUL8_VIS(srcG_f, pix), d_half);
656                     dd = vis_fpadd16(MUL8_VIS(*(mlib_f32*)dst, 255 - pix), dd);
657                     *(mlib_f32*)dst = vis_fands(vis_fpack16(dd),
658                                                 vis_read_hi(maskRGB));
659                     if (pix == 255) *(mlib_f32*)dst = vis_read_hi(fgpixel_d);
660                 }
661                 dst++;
662             }
663 
664             PTR_ADD(dstBase, scan);
665             pixels += rowBytes;
666         }
667     }
668 }
669 
670 /***************************************************************/
671 
672 #endif /* JAVA2D_NO_MLIB */
    </pre>
  </body>
</html>
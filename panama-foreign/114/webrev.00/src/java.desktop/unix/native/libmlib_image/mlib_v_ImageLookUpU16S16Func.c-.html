<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libmlib_image/mlib_v_ImageLookUpU16S16Func.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 
 28 #include &quot;vis_proto.h&quot;
 29 #include &quot;mlib_image.h&quot;
 30 #include &quot;mlib_v_ImageLookUpFunc.h&quot;
 31 
 32 /***************************************************************/
 33 static void mlib_v_ImageLookUp_U16_S16_124_D1(const mlib_u16 *src,
 34                                               mlib_s16       *dst,
 35                                               mlib_s32       xsize,
 36                                               const mlib_s16 *table0,
 37                                               const mlib_s16 *table1,
 38                                               const mlib_s16 *table2,
 39                                               const mlib_s16 *table3);
 40 
 41 static void mlib_v_ImageLookUp_U16_S16_3_D1(const mlib_u16 *src,
 42                                             mlib_s16       *dst,
 43                                             mlib_s32       xsize,
 44                                             const mlib_s16 *table0,
 45                                             const mlib_s16 *table1,
 46                                             const mlib_s16 *table2);
 47 
 48 /***************************************************************/
 49 #define VIS_LD_U16_I(X, Y)      vis_ld_u16_i((void *)(X), (Y))
 50 
 51 /***************************************************************/
 52 void mlib_v_ImageLookUp_U16_S16_124_D1(const mlib_u16 *src,
 53                                        mlib_s16       *dst,
 54                                        mlib_s32       xsize,
 55                                        const mlib_s16 *table0,
 56                                        const mlib_s16 *table1,
 57                                        const mlib_s16 *table2,
 58                                        const mlib_s16 *table3)
 59 {
 60   mlib_u16 *sp;                        /* pointer to source data */
 61   mlib_s32 s0, s1, s2, s3;             /* source data */
 62   mlib_s16 *dl;                        /* pointer to start of destination */
 63   mlib_s16 *dend;                      /* pointer to end of destination */
 64   mlib_d64 *dp;                        /* aligned pointer to destination */
 65   mlib_d64 t0, t1, t2;                 /* destination data */
 66   mlib_d64 t3, acc0;                   /* destination data */
 67   mlib_s32 emask;                      /* edge mask */
 68   mlib_s32 i, num;                     /* loop variable */
 69 
 70   dl = dst;
 71   sp = (void *)src;
 72   dp = (mlib_d64 *) dl;
 73   dend = dl + xsize - 1;
 74 
 75   vis_alignaddr((void *)0, 6);
 76 
 77   i = 0;
 78 
 79   if (xsize &gt;= 4) {
 80 
 81     s0 = sp[0];
 82     s1 = sp[1];
 83     s2 = sp[2];
 84     s3 = sp[3];
 85     sp += 4;
 86 
 87 #pragma pipeloop(0)
 88     for (i = 0; i &lt;= xsize - 8; i += 4, sp += 4) {
 89       t3 = VIS_LD_U16_I(table3, 2 * s3);
 90       t2 = VIS_LD_U16_I(table2, 2 * s2);
 91       t1 = VIS_LD_U16_I(table1, 2 * s1);
 92       t0 = VIS_LD_U16_I(table0, 2 * s0);
 93       acc0 = vis_faligndata(t3, acc0);
 94       acc0 = vis_faligndata(t2, acc0);
 95       acc0 = vis_faligndata(t1, acc0);
 96       acc0 = vis_faligndata(t0, acc0);
 97       s0 = sp[0];
 98       s1 = sp[1];
 99       s2 = sp[2];
100       s3 = sp[3];
101       *dp++ = acc0;
102     }
103 
104     t3 = VIS_LD_U16_I(table3, 2 * s3);
105     t2 = VIS_LD_U16_I(table2, 2 * s2);
106     t1 = VIS_LD_U16_I(table1, 2 * s1);
107     t0 = VIS_LD_U16_I(table0, 2 * s0);
108     acc0 = vis_faligndata(t3, acc0);
109     acc0 = vis_faligndata(t2, acc0);
110     acc0 = vis_faligndata(t1, acc0);
111     acc0 = vis_faligndata(t0, acc0);
112     *dp++ = acc0;
113   }
114 
115   if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
116 
117     num = (mlib_s16 *) dend - (mlib_s16 *) dp;
118     sp += num;
119     num++;
120 
121     if (num == 1) {
122       s0 = (mlib_s32) * sp;
123       sp--;
124 
125       t0 = VIS_LD_U16_I(table0, 2 * s0);
126       acc0 = vis_faligndata(t0, acc0);
127     }
128     else if (num == 2) {
129       s0 = (mlib_s32) * sp;
130       sp--;
131 
132       t0 = VIS_LD_U16_I(table1, 2 * s0);
133       acc0 = vis_faligndata(t0, acc0);
134 
135       s0 = (mlib_s32) * sp;
136       sp--;
137 
138       t0 = VIS_LD_U16_I(table0, 2 * s0);
139       acc0 = vis_faligndata(t0, acc0);
140     }
141     else if (num == 3) {
142       s0 = (mlib_s32) * sp;
143       sp--;
144 
145       t0 = VIS_LD_U16_I(table2, 2 * s0);
146       acc0 = vis_faligndata(t0, acc0);
147 
148       s0 = (mlib_s32) * sp;
149       sp--;
150 
151       t0 = VIS_LD_U16_I(table1, 2 * s0);
152       acc0 = vis_faligndata(t0, acc0);
153 
154       s0 = (mlib_s32) * sp;
155       sp--;
156 
157       t0 = VIS_LD_U16_I(table0, 2 * s0);
158       acc0 = vis_faligndata(t0, acc0);
159     }
160 
161     emask = vis_edge16(dp, dend);
162     vis_pst_16(acc0, dp, emask);
163   }
164 }
165 
166 /***************************************************************/
167 void mlib_v_ImageLookUp_U16_S16_1(const mlib_u16 *src,
168                                   mlib_s32       slb,
169                                   mlib_s16       *dst,
170                                   mlib_s32       dlb,
171                                   mlib_s32       xsize,
172                                   mlib_s32       ysize,
173                                   const mlib_s16 **table)
174 {
175   mlib_u16 *sl;
176   mlib_s16 *dl;
177   const mlib_s16 *tab = &amp;table[0][0];
178   mlib_s32 j, i;
179 
180   sl = (void *)src;
181   dl = dst;
182 
183   /* row loop */
184   for (j = 0; j &lt; ysize; j++) {
185     mlib_u16 *sp = sl;
186     mlib_s16 *dp = dl;
187     mlib_s32 off, size = xsize;
188 
189     off = ((8 - ((mlib_addr) dp &amp; 7)) &amp; 7) &gt;&gt; 1;
190 
191     off = (off &lt; size) ? off : size;
192 
193     for (i = 0; i &lt; off; i++, sp++) {
194       *dp++ = tab[sp[0]];
195       size--;
196     }
197 
198     if (size &gt; 0) {
199       mlib_v_ImageLookUp_U16_S16_124_D1(sp, dp, size, tab, tab, tab, tab);
200     }
201 
202     sl = (mlib_u16 *) ((mlib_u8 *) sl + slb);
203     dl = (mlib_s16 *) ((mlib_u8 *) dl + dlb);
204   }
205 }
206 
207 /***************************************************************/
208 void mlib_v_ImageLookUp_U16_S16_2(const mlib_u16 *src,
209                                   mlib_s32       slb,
210                                   mlib_s16       *dst,
211                                   mlib_s32       dlb,
212                                   mlib_s32       xsize,
213                                   mlib_s32       ysize,
214                                   const mlib_s16 **table)
215 {
216   mlib_u16 *sl;
217   mlib_s16 *dl;
218   const mlib_s16 *tab;
219   mlib_s32 j, i;
220 
221   sl = (void *)src;
222   dl = dst;
223 
224   /* row loop */
225   for (j = 0; j &lt; ysize; j++) {
226     mlib_u16 *sp = sl;
227     mlib_s16 *dp = dl;
228     mlib_s32 off, size = xsize * 2;
229     const mlib_s16 *tab0 = &amp;table[0][0];
230     const mlib_s16 *tab1 = &amp;table[1][0];
231 
232     off = ((8 - ((mlib_addr) dp &amp; 7)) &amp; 7) &gt;&gt; 1;
233 
234     off = (off &lt; size) ? off : size;
235 
236     for (i = 0; i &lt; off - 1; i += 2, sp += 2) {
237       *dp++ = tab0[sp[0]];
238       *dp++ = tab1[sp[1]];
239       size -= 2;
240     }
241 
242     if ((off &amp; 1) != 0) {
243       *dp++ = tab0[sp[0]];
244       size--;
245       sp++;
246       tab = tab0;
247       tab0 = tab1;
248       tab1 = tab;
249     }
250 
251     if (size &gt; 0) {
252       mlib_v_ImageLookUp_U16_S16_124_D1(sp, dp, size, tab0, tab1, tab0, tab1);
253     }
254 
255     sl = (mlib_u16 *) ((mlib_u8 *) sl + slb);
256     dl = (mlib_s16 *) ((mlib_u8 *) dl + dlb);
257   }
258 }
259 
260 /***************************************************************/
261 void mlib_v_ImageLookUp_U16_S16_4(const mlib_u16 *src,
262                                   mlib_s32       slb,
263                                   mlib_s16       *dst,
264                                   mlib_s32       dlb,
265                                   mlib_s32       xsize,
266                                   mlib_s32       ysize,
267                                   const mlib_s16 **table)
268 {
269   mlib_u16 *sl;
270   mlib_s16 *dl;
271   const mlib_s16 *tab;
272   mlib_s32 j;
273 
274   sl = (void *)src;
275   dl = dst;
276 
277   /* row loop */
278   for (j = 0; j &lt; ysize; j++) {
279     mlib_u16 *sp = sl;
280     mlib_s16 *dp = dl;
281     const mlib_s16 *tab0 = &amp;table[0][0];
282     const mlib_s16 *tab1 = &amp;table[1][0];
283     const mlib_s16 *tab2 = &amp;table[2][0];
284     const mlib_s16 *tab3 = &amp;table[3][0];
285     mlib_s32 off, size = xsize * 4;
286 
287     off = ((8 - ((mlib_addr) dp &amp; 7)) &amp; 7) &gt;&gt; 1;
288 
289     off = (off &lt; size) ? off : size;
290 
291     if (off == 1) {
292       *dp++ = tab0[sp[0]];
293       tab = tab0;
294       tab0 = tab1;
295       tab1 = tab2;
296       tab2 = tab3;
297       tab3 = tab;
298       size--;
299       sp++;
300     }
301     else if (off == 2) {
302       *dp++ = tab0[sp[0]];
303       *dp++ = tab1[sp[1]];
304       tab = tab0;
305       tab0 = tab2;
306       tab2 = tab;
307       tab = tab1;
308       tab1 = tab3;
309       tab3 = tab;
310       size -= 2;
311       sp += 2;
312     }
313     else if (off == 3) {
314       *dp++ = tab0[sp[0]];
315       *dp++ = tab1[sp[1]];
316       *dp++ = tab2[sp[2]];
317       tab = tab3;
318       tab3 = tab2;
319       tab2 = tab1;
320       tab1 = tab0;
321       tab0 = tab;
322       size -= 3;
323       sp += 3;
324     }
325 
326     if (size &gt; 0) {
327       mlib_v_ImageLookUp_U16_S16_124_D1(sp, dp, size, tab0, tab1, tab2, tab3);
328     }
329 
330     sl = (mlib_u16 *) ((mlib_u8 *) sl + slb);
331     dl = (mlib_s16 *) ((mlib_u8 *) dl + dlb);
332   }
333 }
334 
335 /***************************************************************/
336 void mlib_v_ImageLookUp_U16_S16_3_D1(const mlib_u16 *src,
337                                      mlib_s16       *dst,
338                                      mlib_s32       xsize,
339                                      const mlib_s16 *table0,
340                                      const mlib_s16 *table1,
341                                      const mlib_s16 *table2)
342 {
343   mlib_u16 *sp;                        /* pointer to source data */
344   mlib_s32 s0, s1, s2, s3;             /* source data */
345   mlib_s16 *dl;                        /* pointer to start of destination */
346   mlib_s16 *dend;                      /* pointer to end of destination */
347   mlib_d64 *dp;                        /* aligned pointer to destination */
348   mlib_d64 t0, t1, t2, t3;             /* destination data */
349   mlib_d64 acc0;                       /* destination data */
350   mlib_s32 emask;                      /* edge mask */
351   mlib_s32 i, num;                     /* loop variable */
352   const mlib_s16 *table;
353 
354   dl = dst;
355   sp = (void *)src;
356   dp = (mlib_d64 *) dl;
357   dend = dl + xsize - 1;
358 
359   vis_alignaddr((void *)0, 6);
360 
361   i = 0;
362 
363   if (xsize &gt;= 4) {
364 
365     s0 = sp[0];
366     s1 = sp[1];
367     s2 = sp[2];
368     s3 = sp[3];
369     sp += 4;
370 
371 #pragma pipeloop(0)
372     for (i = 0; i &lt;= xsize - 8; i += 4, sp += 4) {
373       t3 = VIS_LD_U16_I(table0, 2 * s3);
374       t2 = VIS_LD_U16_I(table2, 2 * s2);
375       t1 = VIS_LD_U16_I(table1, 2 * s1);
376       t0 = VIS_LD_U16_I(table0, 2 * s0);
377       acc0 = vis_faligndata(t3, acc0);
378       acc0 = vis_faligndata(t2, acc0);
379       acc0 = vis_faligndata(t1, acc0);
380       acc0 = vis_faligndata(t0, acc0);
381       s0 = sp[0];
382       s1 = sp[1];
383       s2 = sp[2];
384       s3 = sp[3];
385       *dp++ = acc0;
386       table = table0;
387       table0 = table1;
388       table1 = table2;
389       table2 = table;
390     }
391 
392     t3 = VIS_LD_U16_I(table0, 2 * s3);
393     t2 = VIS_LD_U16_I(table2, 2 * s2);
394     t1 = VIS_LD_U16_I(table1, 2 * s1);
395     t0 = VIS_LD_U16_I(table0, 2 * s0);
396     acc0 = vis_faligndata(t3, acc0);
397     acc0 = vis_faligndata(t2, acc0);
398     acc0 = vis_faligndata(t1, acc0);
399     acc0 = vis_faligndata(t0, acc0);
400     *dp++ = acc0;
401     table = table0;
402     table0 = table1;
403     table1 = table2;
404     table2 = table;
405     i += 4;
406   }
407 
408   if ((mlib_addr) dp &lt;= (mlib_addr) dend) {
409 
410     num = (mlib_s16 *) dend - (mlib_s16 *) dp;
411     sp += num;
412     num++;
413 
414     if (num == 1) {
415       s0 = (mlib_s32) * sp;
416       sp--;
417 
418       t0 = VIS_LD_U16_I(table0, 2 * s0);
419       acc0 = vis_faligndata(t0, acc0);
420     }
421     else if (num == 2) {
422       s0 = (mlib_s32) * sp;
423       sp--;
424 
425       t0 = VIS_LD_U16_I(table1, 2 * s0);
426       acc0 = vis_faligndata(t0, acc0);
427 
428       s0 = (mlib_s32) * sp;
429       sp--;
430 
431       t0 = VIS_LD_U16_I(table0, 2 * s0);
432       acc0 = vis_faligndata(t0, acc0);
433     }
434     else if (num == 3) {
435       s0 = (mlib_s32) * sp;
436       sp--;
437 
438       t0 = VIS_LD_U16_I(table2, 2 * s0);
439       acc0 = vis_faligndata(t0, acc0);
440 
441       s0 = (mlib_s32) * sp;
442       sp--;
443 
444       t0 = VIS_LD_U16_I(table1, 2 * s0);
445       acc0 = vis_faligndata(t0, acc0);
446 
447       s0 = (mlib_s32) * sp;
448       sp--;
449 
450       t0 = VIS_LD_U16_I(table0, 2 * s0);
451       acc0 = vis_faligndata(t0, acc0);
452     }
453 
454     emask = vis_edge16(dp, dend);
455     vis_pst_16(acc0, dp, emask);
456   }
457 }
458 
459 /***************************************************************/
460 void mlib_v_ImageLookUp_U16_S16_3(const mlib_u16 *src,
461                                   mlib_s32       slb,
462                                   mlib_s16       *dst,
463                                   mlib_s32       dlb,
464                                   mlib_s32       xsize,
465                                   mlib_s32       ysize,
466                                   const mlib_s16 **table)
467 {
468   mlib_u16 *sl;
469   mlib_s16 *dl;
470   const mlib_s16 *tab;
471   mlib_s32 j, i;
472 
473   sl = (void *)src;
474   dl = dst;
475 
476   /* row loop */
477   for (j = 0; j &lt; ysize; j++) {
478     mlib_u16 *sp = sl;
479     mlib_s16 *dp = dl;
480     const mlib_s16 *tab0 = &amp;table[0][0];
481     const mlib_s16 *tab1 = &amp;table[1][0];
482     const mlib_s16 *tab2 = &amp;table[2][0];
483     mlib_s32 off, size = xsize * 3;
484 
485     off = ((8 - ((mlib_addr) dp &amp; 7)) &amp; 7) &gt;&gt; 1;
486 
487     off = (off &lt; size) ? off : size;
488 
489     for (i = 0; i &lt; off - 2; i += 3, sp += 3) {
490       *dp++ = tab0[sp[0]];
491       *dp++ = tab1[sp[1]];
492       *dp++ = tab2[sp[2]];
493       size -= 3;
494     }
495 
496     off -= i;
497 
498     if (off == 1) {
499       *dp++ = tab0[sp[0]];
500       tab = tab0;
501       tab0 = tab1;
502       tab1 = tab2;
503       tab2 = tab;
504       size--;
505       sp++;
506     }
507     else if (off == 2) {
508       *dp++ = tab0[sp[0]];
509       *dp++ = tab1[sp[1]];
510       tab = tab2;
511       tab2 = tab1;
512       tab1 = tab0;
513       tab0 = tab;
514       size -= 2;
515       sp += 2;
516     }
517 
518     if (size &gt; 0) {
519       mlib_v_ImageLookUp_U16_S16_3_D1(sp, dp, size, tab0, tab1, tab2);
520     }
521 
522     sl = (mlib_u16 *) ((mlib_u8 *) sl + slb);
523     dl = (mlib_s16 *) ((mlib_u8 *) dl + dlb);
524   }
525 }
526 
527 /***************************************************************/
    </pre>
  </body>
</html>
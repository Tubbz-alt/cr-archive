<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libmlib_image/mlib_ImageConvCopyEdge_Fp.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * FUNCTIONS
 28  *      mlib_ImageConvCopyEdge_Fp  - Copy src edges  to dst edges
 29  *
 30  *
 31  * SYNOPSIS
 32  *      mlib_status mlib_ImageConvCopyEdge_Fp(mlib_image       *dst,
 33  *                                            const mlib_image *src,
 34  *                                            mlib_s32         dx_l,
 35  *                                            mlib_32          dx_r,
 36  *                                            mlib_s32         dy_t,
 37  *                                            mlib_32          dy_b,
 38  *                                            mlib_s32         cmask);
 39  *
 40  * ARGUMENT
 41  *      dst       Pointer to an dst image.
 42  *      src       Pointer to an src image.
 43  *      dx_l      Number of columns on the left side of the
 44  *                image to be copyed.
 45  *      dx_r      Number of columns on the right side of the
 46  *                image to be copyed.
 47  *      dy_t      Number of rows on the top edge of the
 48  *                image to be copyed.
 49  *      dy_b      Number of rows on the top edge of the
 50  *                image to be copyed.
 51  *      cmask     Channel mask to indicate the channels to be convolved.
 52  *                Each bit of which represents a channel in the image. The
 53  *                channels corresponded to 1 bits are those to be processed.
 54  *
 55  * RESTRICTION
 56  *      The src and the dst must be the same type, same width, same height and have same number
 57  *      of channels (1, 2, 3, or 4). The unselected channels are not
 58  *      overwritten. If both src and dst have just one channel,
 59  *      cmask is ignored.
 60  *
 61  * DESCRIPTION
 62  *      Copy src edges  to dst edges.
 63  *
 64  *      The unselected channels are not overwritten.
 65  *      If src and dst have just one channel,
 66  *      cmask is ignored.
 67  */
 68 
 69 #include &quot;mlib_image.h&quot;
 70 #include &quot;mlib_ImageConvEdge.h&quot;
 71 
 72 /***************************************************************/
 73 #define EDGES(chan, type, mask)                                   \
 74 {                                                                 \
 75   type *pdst = (type *) mlib_ImageGetData(dst);                   \
 76   type *psrc = (type *) mlib_ImageGetData(src);                   \
 77   mlib_s32 dst_stride = mlib_ImageGetStride(dst) / sizeof(type);  \
 78   mlib_s32 src_stride = mlib_ImageGetStride(src) / sizeof(type);  \
 79   mlib_s32 i, j, l;                                               \
 80   mlib_s32 testchan;                                              \
 81                                                                   \
 82   testchan = 1;                                                   \
 83   for (l = chan - 1; l &gt;= 0; l--) {                               \
 84     if ((mask &amp; testchan) == 0) {                                 \
 85       testchan &lt;&lt;= 1;                                             \
 86       continue;                                                   \
 87     }                                                             \
 88     testchan &lt;&lt;= 1;                                               \
 89     for (j = 0; j &lt; dx_l; j++) {                                  \
 90       for (i = dy_t; i &lt; (img_height - dy_b); i++) {              \
 91         pdst[i * dst_stride + l + j * chan] =                     \
 92           psrc[i * src_stride + l + j * chan];                    \
 93       }                                                           \
 94     }                                                             \
 95     for (j = 0; j &lt; dx_r; j++) {                                  \
 96       for (i = dy_t; i &lt; (img_height - dy_b); i++) {              \
 97         pdst[i * dst_stride + l + (img_width - 1 - j) * chan] =   \
 98           psrc[i * src_stride + l + (img_width - 1 - j) * chan];  \
 99       }                                                           \
100     }                                                             \
101     for (i = 0; i &lt; dy_t; i++) {                                  \
102       for (j = 0; j &lt; img_width; j++) {                           \
103         pdst[i * dst_stride + l + j * chan] =                     \
104           psrc[i * src_stride + l + j * chan];                    \
105       }                                                           \
106     }                                                             \
107     for (i = 0; i &lt; dy_b; i++) {                                  \
108       for (j = 0; j &lt; img_width; j++) {                           \
109         pdst[(img_height - 1 - i) * dst_stride + l + j * chan] =  \
110           psrc[(img_height - 1 - i) * src_stride + l + j * chan]; \
111       }                                                           \
112     }                                                             \
113   }                                                               \
114 }
115 
116 /***************************************************************/
117 mlib_status mlib_ImageConvCopyEdge_Fp(mlib_image       *dst,
118                                       const mlib_image *src,
119                                       mlib_s32         dx_l,
120                                       mlib_s32         dx_r,
121                                       mlib_s32         dy_t,
122                                       mlib_s32         dy_b,
123                                       mlib_s32         cmask)
124 {
125   mlib_s32 img_width  = mlib_ImageGetWidth(dst);
126   mlib_s32 img_height = mlib_ImageGetHeight(dst);
127   mlib_s32 channel    = mlib_ImageGetChannels(dst);
128 
129   if (dx_l + dx_r &gt; img_width) {
130     dx_l = img_width;
131     dx_r = 0;
132   }
133 
134   if (dy_t + dy_b &gt; img_height) {
135     dy_t = img_height;
136     dy_b = 0;
137   }
138 
139   if (channel == 1) cmask = 1;
140 
141   switch (mlib_ImageGetType(src)) {
142     case MLIB_FLOAT:
143       EDGES(channel,mlib_f32, cmask)
144       break;
145     case MLIB_DOUBLE:
146       EDGES(channel,mlib_d64, cmask)
147       break;
148     default:
149       return MLIB_FAILURE;
150   }
151 
152   return MLIB_SUCCESS;
153 }
154 
155 /***************************************************************/
    </pre>
  </body>
</html>
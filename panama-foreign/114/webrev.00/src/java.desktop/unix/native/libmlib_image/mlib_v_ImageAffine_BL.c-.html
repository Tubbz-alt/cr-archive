<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libmlib_image/mlib_v_ImageAffine_BL.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 
 28 /*
 29  *      The functions step along the lines from xLeft to xRight and apply
 30  *      the bilinear filtering.
 31  *
 32  */
 33 
 34 #include &quot;vis_proto.h&quot;
 35 #include &quot;mlib_image.h&quot;
 36 #include &quot;mlib_ImageCopy.h&quot;
 37 #include &quot;mlib_ImageAffine.h&quot;
 38 #include &quot;mlib_v_ImageFilters.h&quot;
 39 #include &quot;mlib_v_ImageChannelExtract.h&quot;
 40 
 41 /***************************************************************/
 42 /*#define MLIB_VIS2*/
 43 
 44 /***************************************************************/
 45 #define DTYPE mlib_u8
 46 
 47 #define FUN_NAME(CHAN) mlib_ImageAffine_u8_##CHAN##_bl
 48 
 49 /***************************************************************/
 50 static mlib_status FUN_NAME(2ch_na)(mlib_affine_param *param);
 51 static mlib_status FUN_NAME(4ch_na)(mlib_affine_param *param);
 52 
 53 /***************************************************************/
 54 #ifdef MLIB_VIS2
 55 #define MLIB_WRITE_BMASK(bmask) vis_write_bmask(bmask, 0)
 56 #else
 57 #define MLIB_WRITE_BMASK(bmask)
 58 #endif /* MLIB_VIS2 */
 59 
 60 /***************************************************************/
 61 #define FILTER_BITS  8
 62 
 63 /***************************************************************/
 64 #undef  DECLAREVAR
 65 #define DECLAREVAR()                                            \
 66   DECLAREVAR0();                                                \
 67   mlib_s32  *warp_tbl   = param -&gt; warp_tbl;                    \
 68   mlib_s32  srcYStride = param -&gt; srcYStride;                   \
 69   mlib_u8   *dl;                                                \
 70   mlib_s32  i, size;                                            \
 71   mlib_d64  k05 = vis_to_double_dup(0x00080008);                \
 72   mlib_d64  d0, d1, d2, d3, dd
 73 
 74 /***************************************************************/
 75 #define FMUL_16x16(x, y)                                        \
 76   vis_fpadd16(vis_fmul8sux16(x, y), vis_fmul8ulx16(x, y))
 77 
 78 /***************************************************************/
 79 #define BUF_SIZE  512
 80 
 81 /***************************************************************/
 82 const mlib_u32 mlib_fmask_arr[] = {
 83   0x00000000, 0x000000FF, 0x0000FF00, 0x0000FFFF,
 84   0x00FF0000, 0x00FF00FF, 0x00FFFF00, 0x00FFFFFF,
 85   0xFF000000, 0xFF0000FF, 0xFF00FF00, 0xFF00FFFF,
 86   0xFFFF0000, 0xFFFF00FF, 0xFFFFFF00, 0xFFFFFFFF
 87 };
 88 
 89 /***************************************************************/
 90 #define DOUBLE_4U16(x0, x1, x2, x3)                             \
 91   vis_to_double((((x0 &amp; 0xFFFE) &lt;&lt; 15) | ((x1 &amp; 0xFFFE) &gt;&gt; 1)), \
 92                 (((x2 &amp; 0xFFFE) &lt;&lt; 15) | ((x3 &amp; 0xFFFE) &gt;&gt; 1)))
 93 
 94 /***************************************************************/
 95 #define BL_SUM(HL)                                              \
 96   delta1_x = vis_fpsub16(mask_7fff, deltax);                    \
 97   delta1_y = vis_fpsub16(mask_7fff, deltay);                    \
 98                                                                 \
 99   d0 = vis_fmul8x16(vis_read_##HL(s0), delta1_x);               \
100   d1 = vis_fmul8x16(vis_read_##HL(s1), deltax);                 \
101   d0 = vis_fpadd16(d0, d1);                                     \
102   d0 = FMUL_16x16(d0, delta1_y);                                \
103   d2 = vis_fmul8x16(vis_read_##HL(s2), delta1_x);               \
104   d3 = vis_fmul8x16(vis_read_##HL(s3), deltax);                 \
105   d2 = vis_fpadd16(d2, d3);                                     \
106   d2 = FMUL_16x16(d2, deltay);                                  \
107   dd = vis_fpadd16(d0, d2);                                     \
108   dd = vis_fpadd16(dd, k05);                                    \
109   df = vis_fpack16(dd);                                         \
110                                                                 \
111   deltax = vis_fpadd16(deltax, dx64);                           \
112   deltay = vis_fpadd16(deltay, dy64);                           \
113   deltax = vis_fand(deltax, mask_7fff);                         \
114   deltay = vis_fand(deltay, mask_7fff)
115 
116 /***************************************************************/
117 #define GET_FILTER_XY()                                         \
118   mlib_d64 filterx, filtery, filterxy;                          \
119   mlib_s32 filterpos;                                           \
120   filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;                \
121   filterx = *((mlib_d64 *) ((mlib_u8 *) mlib_filters_u8_bl +    \
122                                         filterpos));            \
123   filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;                \
124   filtery = *((mlib_d64 *) ((mlib_u8 *) mlib_filters_u8_bl +    \
125                                 filterpos + 8*FILTER_SIZE));    \
126   filterxy = FMUL_16x16(filterx, filtery)
127 
128 /***************************************************************/
129 #define LD_U8(sp, ind)  vis_read_lo(vis_ld_u8(sp + ind))
130 #define LD_U16(sp, ind) vis_ld_u16(sp + ind)
131 
132 /***************************************************************/
133 #define LOAD_1CH()                                                  \
134   s0 = vis_fpmerge(LD_U8(sp0, 0), LD_U8(sp2, 0));                   \
135   s1 = vis_fpmerge(LD_U8(sp0, 1), LD_U8(sp2, 1));                   \
136   s2 = vis_fpmerge(LD_U8(sp0, srcYStride), LD_U8(sp2, srcYStride)); \
137   s3 = vis_fpmerge(LD_U8(sp0, srcYStride + 1),                      \
138                               LD_U8(sp2, srcYStride + 1));          \
139                                                                     \
140   t0 = vis_fpmerge(LD_U8(sp1, 0), LD_U8(sp3, 0));                   \
141   t1 = vis_fpmerge(LD_U8(sp1, 1), LD_U8(sp3, 1));                   \
142   t2 = vis_fpmerge(LD_U8(sp1, srcYStride), LD_U8(sp3, srcYStride)); \
143   t3 = vis_fpmerge(LD_U8(sp1, srcYStride + 1),                      \
144                               LD_U8(sp3, srcYStride + 1));          \
145                                                                     \
146   s0 = vis_fpmerge(vis_read_lo(s0), vis_read_lo(t0));               \
147   s1 = vis_fpmerge(vis_read_lo(s1), vis_read_lo(t1));               \
148   s2 = vis_fpmerge(vis_read_lo(s2), vis_read_lo(t2));               \
149   s3 = vis_fpmerge(vis_read_lo(s3), vis_read_lo(t3))
150 
151 /***************************************************************/
152 #define GET_POINTER(sp)                                         \
153   sp = *(mlib_u8**)((mlib_u8*)lineAddr + PTR_SHIFT(Y)) +        \
154                                 (X &gt;&gt; MLIB_SHIFT);              \
155   X += dX;                                                      \
156   Y += dY
157 
158 /***************************************************************/
159 #undef  PREPARE_DELTAS
160 #define PREPARE_DELTAS                                                             \
161   if (warp_tbl != NULL) {                                                          \
162     dX = warp_tbl[2*j    ];                                                        \
163     dY = warp_tbl[2*j + 1];                                                        \
164     dx64 = vis_to_double_dup((((dX &lt;&lt; 1) &amp; 0xFFFF) &lt;&lt; 16) | ((dX &lt;&lt; 1) &amp; 0xFFFF)); \
165     dy64 = vis_to_double_dup((((dY &lt;&lt; 1) &amp; 0xFFFF) &lt;&lt; 16) | ((dY &lt;&lt; 1) &amp; 0xFFFF)); \
166   }
167 
168 /***************************************************************/
169 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)
170 {
171   DECLAREVAR();
172   mlib_d64 mask_7fff = vis_to_double_dup(0x7FFF7FFF);
173   mlib_d64 dx64, dy64, deltax, deltay, delta1_x, delta1_y;
174   mlib_s32 off, x0, x1, x2, x3, y0, y1, y2, y3;
175   mlib_f32 *dp, fmask;
176 
177   vis_write_gsr((1 &lt;&lt; 3) | 7);
178 
179   dx64 = vis_to_double_dup((((dX &lt;&lt; 1) &amp; 0xFFFF) &lt;&lt; 16) | ((dX &lt;&lt; 1) &amp; 0xFFFF));
180   dy64 = vis_to_double_dup((((dY &lt;&lt; 1) &amp; 0xFFFF) &lt;&lt; 16) | ((dY &lt;&lt; 1) &amp; 0xFFFF));
181 
182   for (j = yStart; j &lt;= yFinish; j++) {
183     mlib_u8  *sp0, *sp1, *sp2, *sp3;
184     mlib_d64 s0, s1, s2, s3, t0, t1, t2, t3;
185     mlib_f32 df;
186 
187     NEW_LINE(1);
188 
189     off = (mlib_s32)dl &amp; 3;
190     dp = (mlib_f32*)(dl - off);
191 
192     x0 = X - off*dX; y0 = Y - off*dY;
193     x1 = x0 + dX;    y1 = y0 + dY;
194     x2 = x1 + dX;    y2 = y1 + dY;
195     x3 = x2 + dX;    y3 = y2 + dY;
196 
197     deltax = DOUBLE_4U16(x0, x1, x2, x3);
198     deltay = DOUBLE_4U16(y0, y1, y2, y3);
199 
200     if (off) {
201       mlib_s32 emask = vis_edge16((void*)(2*off), (void*)(2*(off + size - 1)));
202 
203       off = 4 - off;
204       GET_POINTER(sp3);
205       sp0 = sp1 = sp2 = sp3;
206 
207       if (off &gt; 1 &amp;&amp; size &gt; 1) {
208         GET_POINTER(sp3);
209       }
210 
211       if (off &gt; 2) {
212         sp2 = sp3;
213 
214         if (size &gt; 2) {
215           GET_POINTER(sp3);
216         }
217       }
218 
219       LOAD_1CH();
220       BL_SUM(lo);
221 
222       fmask = ((mlib_f32*)mlib_fmask_arr)[emask];
223       *dp++ = vis_fors(vis_fands(fmask, df), vis_fandnots(fmask, dp[0]));
224 
225       size -= off;
226 
227       if (size &lt; 0) size = 0;
228     }
229 
230 #pragma pipeloop(0)
231     for (i = 0; i &lt; size/4; i++) {
232       GET_POINTER(sp0);
233       GET_POINTER(sp1);
234       GET_POINTER(sp2);
235       GET_POINTER(sp3);
236 
237       LOAD_1CH();
238       BL_SUM(lo);
239 
240       dp[i] = df;
241     }
242 
243     off = size &amp; 3;
244 
245     if (off) {
246       GET_POINTER(sp0);
247       sp1 = sp2 = sp3 = sp0;
248 
249       if (off &gt; 1) {
250         GET_POINTER(sp1);
251       }
252 
253       if (off &gt; 2) {
254         GET_POINTER(sp2);
255       }
256 
257       LOAD_1CH();
258       BL_SUM(lo);
259 
260       fmask = ((mlib_f32*)mlib_fmask_arr)[(0xF0 &gt;&gt; off) &amp; 0x0F];
261       dp[i] = vis_fors(vis_fands(fmask, df), vis_fandnots(fmask, dp[i]));
262     }
263   }
264 
265   return MLIB_SUCCESS;
266 }
267 
268 /***************************************************************/
269 #undef  GET_POINTER
270 #define GET_POINTER(sp)                                         \
271   sp = *(mlib_u8**)((mlib_u8*)lineAddr + PTR_SHIFT(Y)) +        \
272                         2*(X &gt;&gt; MLIB_SHIFT);                    \
273   X += dX;                                                      \
274   Y += dY
275 
276 /***************************************************************/
277 #ifndef MLIB_VIS2
278 
279 #define LOAD_2CH()                                              \
280   s0 = vis_faligndata(LD_U16(sp1, 0), k05);                     \
281   s1 = vis_faligndata(LD_U16(sp1, 2), k05);                     \
282   s2 = vis_faligndata(LD_U16(sp1, srcYStride), k05);            \
283   s3 = vis_faligndata(LD_U16(sp1, srcYStride + 2), k05);        \
284                                                                 \
285   s0 = vis_faligndata(LD_U16(sp0, 0), s0);                      \
286   s1 = vis_faligndata(LD_U16(sp0, 2), s1);                      \
287   s2 = vis_faligndata(LD_U16(sp0, srcYStride), s2);             \
288   s3 = vis_faligndata(LD_U16(sp0, srcYStride + 2), s3)
289 
290 #define BL_SUM_2CH() BL_SUM(hi)
291 
292 #else
293 
294 #define LOAD_2CH()                                              \
295   s0 = vis_bshuffle(LD_U16(sp0, 0), LD_U16(sp1, 0));            \
296   s1 = vis_bshuffle(LD_U16(sp0, 2), LD_U16(sp1, 2));            \
297   s2 = vis_bshuffle(LD_U16(sp0, srcYStride),                    \
298                                 LD_U16(sp1, srcYStride));                             \
299   s3 = vis_bshuffle(LD_U16(sp0, srcYStride + 2),                \
300                                 LD_U16(sp1, srcYStride + 2))
301 
302 #define BL_SUM_2CH() BL_SUM(lo)
303 
304 #endif /* MLIB_VIS2 */
305 
306 /***************************************************************/
307 #undef  PREPARE_DELTAS
308 #define PREPARE_DELTAS                                               \
309   if (warp_tbl != NULL) {                                            \
310     dX = warp_tbl[2*j    ];                                          \
311     dY = warp_tbl[2*j + 1];                                          \
312     dx64 = vis_to_double_dup(((dX &amp; 0xFFFF) &lt;&lt; 16) | (dX &amp; 0xFFFF)); \
313     dy64 = vis_to_double_dup(((dY &amp; 0xFFFF) &lt;&lt; 16) | (dY &amp; 0xFFFF)); \
314   }
315 
316 /***************************************************************/
317 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)
318 {
319   DECLAREVAR();
320   mlib_d64 mask_7fff = vis_to_double_dup(0x7FFF7FFF);
321   mlib_d64 dx64, dy64, deltax, deltay, delta1_x, delta1_y;
322   mlib_s32 off, x0, x1, y0, y1;
323 
324   if (((mlib_s32)lineAddr[0] | (mlib_s32)dstData | srcYStride | dstYStride) &amp; 1) {
325     return FUN_NAME(2ch_na)(param);
326   }
327 
328   vis_write_gsr((1 &lt;&lt; 3) | 6);
329   MLIB_WRITE_BMASK(0x45cd67ef);
330 
331   dx64 = vis_to_double_dup(((dX &amp; 0xFFFF) &lt;&lt; 16) | (dX &amp; 0xFFFF));
332   dy64 = vis_to_double_dup(((dY &amp; 0xFFFF) &lt;&lt; 16) | (dY &amp; 0xFFFF));
333 
334   for (j = yStart; j &lt;= yFinish; j++) {
335     mlib_u8  *sp0, *sp1;
336     mlib_d64 s0, s1, s2, s3;
337     mlib_f32 *dp, df, fmask;
338 
339     NEW_LINE(2);
340 
341     off = (mlib_s32)dl &amp; 3;
342     dp = (mlib_f32*)(dl - off);
343 
344     if (off) {
345       x0 = X - dX; y0 = Y - dY;
346       x1 = X;      y1 = Y;
347     } else {
348       x0 = X;      y0 = Y;
349       x1 = X + dX; y1 = Y + dY;
350     }
351 
352     deltax = DOUBLE_4U16(x0, x0, x1, x1);
353     deltay = DOUBLE_4U16(y0, y0, y1, y1);
354 
355     if (off) {
356       GET_POINTER(sp1);
357       sp0 = sp1;
358       LOAD_2CH();
359 
360       BL_SUM_2CH();
361 
362       fmask = ((mlib_f32*)mlib_fmask_arr)[0x3];
363       *dp++ = vis_fors(vis_fands(fmask, df), vis_fandnots(fmask, dp[0]));
364 
365       size--;
366     }
367 
368     if (size &gt;= 2) {
369       GET_POINTER(sp0);
370       GET_POINTER(sp1);
371       LOAD_2CH();
372 
373 #pragma pipeloop(0)
374       for (i = 0; i &lt; (size - 2)/2; i++) {
375         BL_SUM_2CH();
376 
377         GET_POINTER(sp0);
378         GET_POINTER(sp1);
379         LOAD_2CH();
380 
381         *dp++ = df;
382       }
383 
384       BL_SUM_2CH();
385       *dp++ = df;
386     }
387 
388     if (size &amp; 1) {
389       GET_POINTER(sp0);
390       sp1 = sp0;
391       LOAD_2CH();
392 
393       BL_SUM_2CH();
394 
395       fmask = ((mlib_f32*)mlib_fmask_arr)[0x0C];
396       *dp = vis_fors(vis_fands(fmask, df), vis_fandnots(fmask, *dp));
397     }
398   }
399 
400   return MLIB_SUCCESS;
401 }
402 
403 /***************************************************************/
404 #ifndef MLIB_VIS2
405 
406 #define LOAD_2CH_NA()                                           \
407   s0 = vis_fpmerge(LD_U8(sp0, 0), LD_U8(sp1, 0));               \
408   s1 = vis_fpmerge(LD_U8(sp0, 2), LD_U8(sp1, 2));               \
409   s2 = vis_fpmerge(LD_U8(sp0, srcYStride),                      \
410                               LD_U8(sp1, srcYStride));                         \
411   s3 = vis_fpmerge(LD_U8(sp0, srcYStride + 2),                  \
412                               LD_U8(sp1, srcYStride + 2));      \
413                                                                 \
414   t0 = vis_fpmerge(LD_U8(sp0, 1), LD_U8(sp1, 1));               \
415   t1 = vis_fpmerge(LD_U8(sp0, 3), LD_U8(sp1, 3));               \
416   t2 = vis_fpmerge(LD_U8(sp0, srcYStride + 1),                  \
417                               LD_U8(sp1, srcYStride + 1));      \
418   t3 = vis_fpmerge(LD_U8(sp0, srcYStride + 3),                  \
419                               LD_U8(sp1, srcYStride + 3));      \
420                                                                 \
421   s0 = vis_fpmerge(vis_read_lo(s0), vis_read_lo(t0));           \
422   s1 = vis_fpmerge(vis_read_lo(s1), vis_read_lo(t1));           \
423   s2 = vis_fpmerge(vis_read_lo(s2), vis_read_lo(t2));           \
424   s3 = vis_fpmerge(vis_read_lo(s3), vis_read_lo(t3))
425 
426 #define BL_SUM_2CH_NA()  BL_SUM(lo)
427 
428 #else
429 
430 #define LOAD_2CH_NA()                                           \
431   vis_alignaddr(sp0, 0);                                        \
432   spa = AL_ADDR(sp0, 0);                                        \
433   s0 = vis_faligndata(spa[0], spa[1]);                          \
434                                                                 \
435   vis_alignaddr(sp1, 0);                                        \
436   spa = AL_ADDR(sp1, 0);                                        \
437   s1 = vis_faligndata(spa[0], spa[1]);                          \
438                                                                 \
439   vis_alignaddr(sp0, srcYStride);                               \
440   spa = AL_ADDR(sp0, srcYStride);                               \
441   s2 = vis_faligndata(spa[0], spa[1]);                          \
442                                                                 \
443   vis_alignaddr(sp1, srcYStride);                               \
444   spa = AL_ADDR(sp1, srcYStride);                               \
445   s3 = vis_faligndata(spa[0], spa[1]);                          \
446                                                                 \
447   s0 = vis_bshuffle(s0, s1);                                    \
448   s2 = vis_bshuffle(s2, s3)
449 
450 #define BL_SUM_2CH_NA()                                         \
451   delta1_x = vis_fpsub16(mask_7fff, deltax);                    \
452   delta1_y = vis_fpsub16(mask_7fff, deltay);                    \
453                                                                 \
454   d0 = vis_fmul8x16(vis_read_hi(s0), delta1_x);                 \
455   d1 = vis_fmul8x16(vis_read_lo(s0), deltax);                   \
456   d0 = vis_fpadd16(d0, d1);                                     \
457   d0 = FMUL_16x16(d0, delta1_y);                                \
458   d2 = vis_fmul8x16(vis_read_hi(s2), delta1_x);                 \
459   d3 = vis_fmul8x16(vis_read_lo(s2), deltax);                   \
460   d2 = vis_fpadd16(d2, d3);                                     \
461   d2 = FMUL_16x16(d2, deltay);                                  \
462   dd = vis_fpadd16(d0, d2);                                     \
463   dd = vis_fpadd16(dd, k05);                                    \
464   df = vis_fpack16(dd);                                         \
465                                                                 \
466   deltax = vis_fpadd16(deltax, dx64);                           \
467   deltay = vis_fpadd16(deltay, dy64);                           \
468   deltax = vis_fand(deltax, mask_7fff);                         \
469   deltay = vis_fand(deltay, mask_7fff)
470 
471 #endif /* MLIB_VIS2 */
472 
473 /***************************************************************/
474 mlib_status FUN_NAME(2ch_na)(mlib_affine_param *param)
475 {
476   DECLAREVAR();
477   mlib_d64 mask_7fff = vis_to_double_dup(0x7FFF7FFF);
478   mlib_d64 dx64, dy64, deltax, deltay, delta1_x, delta1_y;
479   mlib_s32 max_xsize = param -&gt; max_xsize, bsize;
480   mlib_s32 x0, x1, y0, y1;
481   mlib_f32 buff[BUF_SIZE], *pbuff = buff;
482 
483   bsize = (max_xsize + 1)/2;
484 
485   if (bsize &gt; BUF_SIZE) {
486     pbuff = mlib_malloc(bsize*sizeof(mlib_f32));
487 
488     if (pbuff == NULL) return MLIB_FAILURE;
489   }
490 
491   vis_write_gsr((1 &lt;&lt; 3) | 6);
492   MLIB_WRITE_BMASK(0x018923AB);
493 
494   dx64 = vis_to_double_dup(((dX &amp; 0xFFFF) &lt;&lt; 16) | (dX &amp; 0xFFFF));
495   dy64 = vis_to_double_dup(((dY &amp; 0xFFFF) &lt;&lt; 16) | (dY &amp; 0xFFFF));
496 
497   for (j = yStart; j &lt;= yFinish; j++) {
498     mlib_u8  *sp0, *sp1;
499     mlib_d64 s0, s1, s2, s3;
500 #ifndef MLIB_VIS2
501     mlib_d64 t0, t1, t2, t3;
502 #else
503     mlib_d64 *spa;
504 #endif /* MLIB_VIS2 */
505     mlib_f32 *dp, df;
506 
507     NEW_LINE(2);
508 
509     dp = pbuff;
510 
511     x0 = X;      y0 = Y;
512     x1 = X + dX; y1 = Y + dY;
513 
514     deltax = DOUBLE_4U16(x0, x0, x1, x1);
515     deltay = DOUBLE_4U16(y0, y0, y1, y1);
516 
517 #pragma pipeloop(0)
518     for (i = 0; i &lt; size/2; i++) {
519       GET_POINTER(sp0);
520       GET_POINTER(sp1);
521       LOAD_2CH_NA();
522 
523       BL_SUM_2CH_NA();
524 
525       *dp++ = df;
526     }
527 
528     if (size &amp; 1) {
529       GET_POINTER(sp0);
530       sp1 = sp0;
531       LOAD_2CH_NA();
532 
533       BL_SUM_2CH_NA();
534 
535       *dp++ = df;
536     }
537 
538     mlib_ImageCopy_na((mlib_u8*)pbuff, dl, 2*size);
539   }
540 
541   if (pbuff != buff) {
542     mlib_free(pbuff);
543   }
544 
545   return MLIB_SUCCESS;
546 }
547 
548 /***************************************************************/
549 #undef  PREPARE_DELTAS
550 #define PREPARE_DELTAS                                          \
551   if (warp_tbl != NULL) {                                       \
552     dX = warp_tbl[2*j    ];                                     \
553     dY = warp_tbl[2*j + 1];                                     \
554   }
555 
556 /***************************************************************/
557 mlib_status FUN_NAME(3ch)(mlib_affine_param *param)
558 {
559   DECLAREVAR();
560   mlib_s32 max_xsize = param -&gt; max_xsize;
561   mlib_f32 buff[BUF_SIZE], *pbuff = buff;
562 
563   if (max_xsize &gt; BUF_SIZE) {
564     pbuff = mlib_malloc(max_xsize*sizeof(mlib_f32));
565 
566     if (pbuff == NULL) return MLIB_FAILURE;
567   }
568 
569   vis_write_gsr(3 &lt;&lt; 3);
570 
571   for (j = yStart; j &lt;= yFinish; j++) {
572     mlib_d64 *sp0, *sp1, s0, s1;
573     mlib_u8  *sp;
574 
575     NEW_LINE(3);
576 
577 #pragma pipeloop(0)
578     for (i = 0; i &lt; size; i++) {
579       GET_FILTER_XY();
580 
581       sp = *(mlib_u8**)((mlib_u8*)lineAddr + PTR_SHIFT(Y)) + 3*(X &gt;&gt; MLIB_SHIFT) - 1;
582 
583       vis_alignaddr(sp, 0);
584       sp0 = AL_ADDR(sp, 0);
585       s0 = vis_faligndata(sp0[0], sp0[1]);
586       d0 = vis_fmul8x16au(vis_read_hi(s0), vis_read_hi(filterxy));
587       d1 = vis_fmul8x16al(vis_read_lo(s0), vis_read_hi(filterxy));
588 
589       vis_alignaddr(sp, srcYStride);
590       sp1 = AL_ADDR(sp, srcYStride);
591       s1 = vis_faligndata(sp1[0], sp1[1]);
592       d2 = vis_fmul8x16au(vis_read_hi(s1), vis_read_lo(filterxy));
593       d3 = vis_fmul8x16al(vis_read_lo(s1), vis_read_lo(filterxy));
594 
595       vis_alignaddr((void*)0, 2);
596       d0 = vis_fpadd16(d0, d2);
597       dd = vis_fpadd16(k05, d1);
598       dd = vis_fpadd16(dd, d3);
599       d0 = vis_faligndata(d0, d0);
600       dd = vis_fpadd16(dd, d0);
601 
602       pbuff[i] = vis_fpack16(dd);
603       X += dX;
604       Y += dY;
605     }
606 
607     mlib_v_ImageChannelExtract_U8_43L_D1((mlib_u8*)pbuff, dl, size);
608   }
609 
610   if (pbuff != buff) {
611     mlib_free(pbuff);
612   }
613 
614   return MLIB_SUCCESS;
615 }
616 
617 /***************************************************************/
618 #define PROCESS_4CH(s0, s1, s2, s3)                             \
619   d0 = vis_fmul8x16au(s0, vis_read_hi(filterxy));               \
620   d1 = vis_fmul8x16al(s1, vis_read_hi(filterxy));               \
621   d2 = vis_fmul8x16au(s2, vis_read_lo(filterxy));               \
622   d3 = vis_fmul8x16al(s3, vis_read_lo(filterxy));               \
623                                                                 \
624   dd = vis_fpadd16(d0, k05);                                    \
625   d1 = vis_fpadd16(d1, d2);                                     \
626   dd = vis_fpadd16(dd, d3);                                     \
627   dd = vis_fpadd16(dd, d1)
628 
629 /***************************************************************/
630 mlib_status FUN_NAME(4ch)(mlib_affine_param *param)
631 {
632   DECLAREVAR();
633 
634   if (((mlib_s32)lineAddr[0] | (mlib_s32)dstData | srcYStride | dstYStride) &amp; 3) {
635     return FUN_NAME(4ch_na)(param);
636   }
637 
638   vis_write_gsr(3 &lt;&lt; 3);
639 
640   srcYStride &gt;&gt;= 2;
641 
642   for (j = yStart; j &lt;= yFinish; j++) {
643     mlib_f32 *sp, s0, s1, s2, s3;
644 
645     NEW_LINE(4);
646 
647 #pragma pipeloop(0)
648     for (i = 0; i &lt; size; i++) {
649       GET_FILTER_XY();
650 
651       sp = *(mlib_f32**)((mlib_u8*)lineAddr + PTR_SHIFT(Y)) + (X &gt;&gt; MLIB_SHIFT);
652       s0 = sp[0];
653       s1 = sp[1];
654       s2 = sp[srcYStride];
655       s3 = sp[srcYStride + 1];
656 
657       PROCESS_4CH(s0, s1, s2, s3);
658 
659       ((mlib_f32*)dl)[i] = vis_fpack16(dd);
660       X += dX;
661       Y += dY;
662     }
663   }
664 
665   return MLIB_SUCCESS;
666 }
667 
668 /***************************************************************/
669 mlib_status FUN_NAME(4ch_na)(mlib_affine_param *param)
670 {
671   DECLAREVAR();
672   mlib_s32 max_xsize = param -&gt; max_xsize;
673   mlib_f32 buff[BUF_SIZE], *pbuff = buff;
674 
675   if (max_xsize &gt; BUF_SIZE) {
676     pbuff = mlib_malloc(max_xsize*sizeof(mlib_f32));
677 
678     if (pbuff == NULL) return MLIB_FAILURE;
679   }
680 
681   vis_write_gsr(3 &lt;&lt; 3);
682 
683   for (j = yStart; j &lt;= yFinish; j++) {
684     mlib_d64 *sp0, *sp1, s0, s1;
685     mlib_u8  *sp;
686 
687     NEW_LINE(4);
688 
689 #pragma pipeloop(0)
690     for (i = 0; i &lt; size; i++) {
691       GET_FILTER_XY();
692 
693       sp = *(mlib_u8**)((mlib_u8*)lineAddr + PTR_SHIFT(Y)) + 4*(X &gt;&gt; MLIB_SHIFT);
694 
695       vis_alignaddr(sp, 0);
696       sp0 = AL_ADDR(sp, 0);
697       s0 = vis_faligndata(sp0[0], sp0[1]);
698 
699       vis_alignaddr(sp, srcYStride);
700       sp1 = AL_ADDR(sp, srcYStride);
701       s1 = vis_faligndata(sp1[0], sp1[1]);
702 
703       PROCESS_4CH(vis_read_hi(s0), vis_read_lo(s0), vis_read_hi(s1), vis_read_lo(s1));
704 
705       pbuff[i] = vis_fpack16(dd);
706       X += dX;
707       Y += dY;
708     }
709 
710     mlib_ImageCopy_na((mlib_u8*)pbuff, dl, 4*size);
711   }
712 
713   if (pbuff != buff) {
714     mlib_free(pbuff);
715   }
716 
717   return MLIB_SUCCESS;
718 }
719 
720 /***************************************************************/
    </pre>
  </body>
</html>
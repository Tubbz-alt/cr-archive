<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/native/libmlib_image/mlib_v_ImageAffine_NN.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 
 28 /*
 29  * FUNCTION
 30  *      mlib_ImageAffine_u8_1ch_nn
 31  *      mlib_ImageAffine_u8_2ch_nn
 32  *      mlib_ImageAffine_u8_3ch_nn
 33  *      mlib_ImageAffine_u8_4ch_nn
 34  *      mlib_ImageAffine_s16_1ch_nn
 35  *      mlib_ImageAffine_s16_2ch_nn
 36  *      mlib_ImageAffine_s16_3ch_nn
 37  *      mlib_ImageAffine_s16_4ch_nn
 38  *        - image affine transformation with Nearest Neighbor filtering
 39  *
 40  */
 41 
 42 #include &quot;vis_proto.h&quot;
 43 #include &quot;mlib_image.h&quot;
 44 #include &quot;mlib_ImageCopy.h&quot;
 45 #include &quot;mlib_ImageAffine.h&quot;
 46 
 47 #define BUFF_SIZE  256
 48 
 49 /***************************************************************/
 50 #define sp srcPixelPtr
 51 #define dp dstPixelPtr
 52 
 53 /***************************************************************/
 54 #undef  DTYPE
 55 #define DTYPE mlib_u8
 56 
 57 #define LD_U8(sp, x) vis_read_lo(vis_ld_u8_i(sp, ((x) &gt;&gt; MLIB_SHIFT)))
 58 
 59 /***************************************************************/
 60 mlib_status mlib_ImageAffine_u8_1ch_nn(mlib_affine_param *param)
 61 {
 62   DECLAREVAR();
 63   mlib_s32 i, size;
 64 #ifndef _NO_LONGLONG
 65   mlib_s64 Y0, Y1, dYl;
 66 #endif /* _NO_LONGLONG */
 67 
 68   for (j = yStart; j &lt;= yFinish; j++) {
 69     mlib_d64 s0, s1;
 70 
 71     CLIP(1);
 72     size = xRight - xLeft + 1;
 73 
 74     while (((mlib_s32)dp &amp; 3) &amp;&amp; (size &gt; 0)) {
 75       *dp = *(S_PTR(Y) + (X &gt;&gt; MLIB_SHIFT));
 76       dp++;
 77       X += dX;
 78       Y += dY;
 79       size--;
 80     }
 81 
 82 #ifdef _NO_LONGLONG
 83 #pragma pipeloop(0)
 84     for (i = 0; i &lt;= (size - 4); i += 4) {
 85       mlib_u8 *sp0, *sp1, *sp2, *sp3;
 86 
 87       sp0 = S_PTR(Y);
 88       sp1 = S_PTR(Y +   dY);
 89       sp2 = S_PTR(Y + 2*dY);
 90       sp3 = S_PTR(Y + 3*dY);
 91 
 92       s0 = vis_fpmerge(LD_U8(sp0, X), LD_U8(sp2, X + 2*dX));
 93       s1 = vis_fpmerge(LD_U8(sp1, X + dX), LD_U8(sp3, X + 3*dX));
 94       s0 = vis_fpmerge(vis_read_lo(s0), vis_read_lo(s1));
 95 
 96       *(mlib_f32*)dp = vis_read_lo(s0);
 97 
 98       dp += 4;
 99       X += 4*dX;
100       Y += 4*dY;
101     }
102 
103 #else
104     Y0 = ((mlib_s64)(Y + dY) &lt;&lt; 32) | Y;
105 
106     if (dY &gt;= 0) {
107       dYl = ((mlib_s64)dY &lt;&lt; 33) | (dY &lt;&lt; 1);
108     } else {
109       dYl = -(((mlib_s64)(-dY) &lt;&lt; 33) | ((-dY) &lt;&lt; 1));
110     }
111 
112 #pragma pipeloop(0)
113     for (i = 0; i &lt;= (size - 4); i += 4) {
114       mlib_u8 *sp0, *sp1, *sp2, *sp3;
115 
116       Y1 = Y0 + dYl;
117       sp0 = S_PTRl(Y0, 16);
118       sp1 = S_PTRl(Y0, 48);
119       sp2 = S_PTRl(Y1, 16);
120       sp3 = S_PTRl(Y1, 48);
121 
122       s0 = vis_fpmerge(LD_U8(sp0, X), LD_U8(sp2, X + 2*dX));
123       s1 = vis_fpmerge(LD_U8(sp1, X + dX), LD_U8(sp3, X + 3*dX));
124       s0 = vis_fpmerge(vis_read_lo(s0), vis_read_lo(s1));
125 
126       *(mlib_f32*)dp = vis_read_lo(s0);
127 
128       dp += 4;
129       X += 4*dX;
130       Y0 += 2*dYl;
131     }
132 
133     Y = Y0 &amp; ((1u &lt;&lt; 31) - 1);
134 #endif /* _NO_LONGLONG */
135 
136     for (i = 0; i &lt; (size &amp; 3); i++) {
137       dp[i] = *(S_PTR(Y) + (X &gt;&gt; MLIB_SHIFT));
138       X += dX;
139       Y += dY;
140     }
141   }
142 
143   return MLIB_SUCCESS;
144 }
145 
146 /***************************************************************/
147 #undef  LD_U8
148 #define LD_U8(sp, x) vis_read_lo(vis_ld_u8_i(sp, x))
149 
150 /***************************************************************/
151 #define GET_POINTERS_2CH                                        \
152   sp0 = S_PTR(Y) + 2*(X &gt;&gt; MLIB_SHIFT);                         \
153   sp1 = S_PTR(Y +   dY) + 2*((X +   dX) &gt;&gt; MLIB_SHIFT);         \
154   sp2 = S_PTR(Y + 2*dY) + 2*((X + 2*dX) &gt;&gt; MLIB_SHIFT);         \
155   sp3 = S_PTR(Y + 3*dY) + 2*((X + 3*dX) &gt;&gt; MLIB_SHIFT);         \
156   X += 4*dX;                                                    \
157   Y += 4*dY
158 
159 /***************************************************************/
160 #define AFFINE_U8_2CH                                           \
161   s0 = vis_fpmerge(LD_U8(sp0, 0), LD_U8(sp2, 0));               \
162   s1 = vis_fpmerge(LD_U8(sp0, 1), LD_U8(sp2, 1));               \
163   s2 = vis_fpmerge(LD_U8(sp1, 0), LD_U8(sp3, 0));               \
164   s3 = vis_fpmerge(LD_U8(sp1, 1), LD_U8(sp3, 1));               \
165                                                                 \
166   s0 = vis_fpmerge(vis_read_lo(s0), vis_read_lo(s2));           \
167   s1 = vis_fpmerge(vis_read_lo(s1), vis_read_lo(s3));           \
168   dd = vis_fpmerge(vis_read_lo(s0), vis_read_lo(s1))
169 
170 /***************************************************************/
171 mlib_status mlib_ImageAffine_u8_2ch_nn(mlib_affine_param *param)
172 {
173   DECLAREVAR();
174   DTYPE  *dstLineEnd;
175   mlib_s32 i, size;
176 
177   for (j = yStart; j &lt;= yFinish; j++) {
178     mlib_u8  *sp0, *sp1, *sp2, *sp3;
179     mlib_d64 *da, s0, s1, s2, s3, dd, d_old;
180     mlib_s32 emask;
181 
182     CLIP(2);
183     dstLineEnd  = (DTYPE*)dstData + 2 * xRight;
184     size = xRight - xLeft + 1;
185     dstLineEnd++;
186 
187     if (((mlib_s32)dp &amp; 7) == 0) {
188 #pragma pipeloop(0)
189       for (i = 0; i &lt;= (size - 4); i += 4) {
190         GET_POINTERS_2CH;
191         AFFINE_U8_2CH;
192         *(mlib_d64*)dp = dd;
193         dp += 8;
194       }
195 
196       if (i &lt; size) {
197         sp0 = sp1 = sp2 = sp3 = S_PTR(Y) + 2*(X &gt;&gt; MLIB_SHIFT);
198         if (i + 1 &lt; size) sp1 = S_PTR(Y +   dY) + 2*((X +   dX) &gt;&gt; MLIB_SHIFT);
199         if (i + 2 &lt; size) sp2 = S_PTR(Y + 2*dY) + 2*((X + 2*dX) &gt;&gt; MLIB_SHIFT);
200         if (i + 3 &lt; size) sp3 = S_PTR(Y + 3*dY) + 2*((X + 3*dX) &gt;&gt; MLIB_SHIFT);
201 
202         AFFINE_U8_2CH;
203         emask = vis_edge8(dp, dstLineEnd);
204         vis_pst_8(dd, dp, emask);
205       }
206 
207     } else {
208       da = vis_alignaddr(dp, 0);
209       d_old = vis_faligndata(da[0], da[0]);
210       vis_alignaddr((void*)0, (mlib_u8*)da - dp);
211 
212 #pragma pipeloop(0)
213       for (i = 0; i &lt;= (size - 4); i += 4) {
214         GET_POINTERS_2CH;
215         AFFINE_U8_2CH;
216 
217         *da++ = vis_faligndata(d_old, dd);
218         d_old = dd;
219       }
220 
221       if (i &lt; size) {
222         sp0 = sp1 = sp2 = sp3 = S_PTR(Y) + 2*(X &gt;&gt; MLIB_SHIFT);
223         if (i + 1 &lt; size) sp1 = S_PTR(Y +   dY) + 2*((X +   dX) &gt;&gt; MLIB_SHIFT);
224         if (i + 2 &lt; size) sp2 = S_PTR(Y + 2*dY) + 2*((X + 2*dX) &gt;&gt; MLIB_SHIFT);
225         if (i + 3 &lt; size) sp3 = S_PTR(Y + 3*dY) + 2*((X + 3*dX) &gt;&gt; MLIB_SHIFT);
226 
227         AFFINE_U8_2CH;
228       }
229 
230       emask = vis_edge8(da, dstLineEnd);
231       vis_pst_8(vis_faligndata(d_old, dd), da++, emask);
232 
233       if ((mlib_u8*)da &lt;= dstLineEnd) {
234         emask = vis_edge8(da, dstLineEnd);
235         vis_pst_8(vis_faligndata(dd, dd), da, emask);
236       }
237     }
238   }
239 
240   return MLIB_SUCCESS;
241 }
242 
243 /***************************************************************/
244 #undef  LD_U8
245 #define LD_U8(sp, x) vis_read_lo(vis_ld_u8(sp + x))
246 
247 /***************************************************************/
248 mlib_status mlib_ImageAffine_u8_3ch_nn(mlib_affine_param *param)
249 {
250   DECLAREVAR();
251   DTYPE  *srcPixelPtr;
252   mlib_s32 i, size;
253 
254   for (j = yStart; j &lt;= yFinish; j++) {
255     mlib_d64 s0, s1, s2, s3, s4, s5;
256 
257     CLIP(3);
258     size = xRight - xLeft + 1;
259 
260     while (((mlib_s32)dp &amp; 3) &amp;&amp; (size &gt; 0)) {
261       sp = S_PTR(Y) + 3*(X &gt;&gt; MLIB_SHIFT);
262       dp[0] = sp[0];
263       dp[1] = sp[1];
264       dp[2] = sp[2];
265       dp += 3;
266       X += dX;
267       Y += dY;
268       size--;
269     }
270 
271 #pragma pipeloop(0)
272     for (i = 0; i &lt;= (size - 4); i += 4) {
273       mlib_u8 *sp0, *sp1, *sp2, *sp3;
274 
275       sp0 = S_PTR(Y);
276       sp1 = S_PTR(Y +   dY);
277       sp2 = S_PTR(Y + 2*dY);
278       sp3 = S_PTR(Y + 3*dY);
279 
280       sp0 += 3*(X &gt;&gt; MLIB_SHIFT);
281       sp1 += 3*((X + dX) &gt;&gt; MLIB_SHIFT);
282       sp2 += 3*((X + 2*dX) &gt;&gt; MLIB_SHIFT);
283       sp3 += 3*((X + 3*dX) &gt;&gt; MLIB_SHIFT);
284 
285       s0 = vis_fpmerge(LD_U8(sp0, 0), LD_U8(sp0, 2));
286       s1 = vis_fpmerge(LD_U8(sp0, 1), LD_U8(sp1, 0));
287       s0 = vis_fpmerge(vis_read_lo(s0), vis_read_lo(s1));
288       s2 = vis_fpmerge(LD_U8(sp1, 1), LD_U8(sp2, 0));
289       s3 = vis_fpmerge(LD_U8(sp1, 2), LD_U8(sp2, 1));
290       s2 = vis_fpmerge(vis_read_lo(s2), vis_read_lo(s3));
291       s4 = vis_fpmerge(LD_U8(sp2, 2), LD_U8(sp3, 1));
292       s5 = vis_fpmerge(LD_U8(sp3, 0), LD_U8(sp3, 2));
293       s4 = vis_fpmerge(vis_read_lo(s4), vis_read_lo(s5));
294 
295       ((mlib_f32*)dp)[0] = vis_read_lo(s0);
296       ((mlib_f32*)dp)[1] = vis_read_lo(s2);
297       ((mlib_f32*)dp)[2] = vis_read_lo(s4);
298 
299       dp += 12;
300       X += 4*dX;
301       Y += 4*dY;
302     }
303 
304     for (i = 0; i &lt; (size &amp; 3); i++) {
305       sp = S_PTR(Y) + 3*(X &gt;&gt; MLIB_SHIFT);
306       dp[0] = sp[0];
307       dp[1] = sp[1];
308       dp[2] = sp[2];
309       dp += 3;
310       X += dX;
311       Y += dY;
312     }
313   }
314 
315   return MLIB_SUCCESS;
316 }
317 
318 /***************************************************************/
319 #undef  LD_U8
320 #define LD_U8(sp, x) vis_read_lo(vis_ld_u8_i(sp, x))
321 
322 /***************************************************************/
323 #define AFFINE_U8_4x2                                           \
324   sp0 = S_PTR(Y) + 4*(X &gt;&gt; MLIB_SHIFT);                         \
325   sp1 = S_PTR(Y + dY) + 4*((X + dX) &gt;&gt; MLIB_SHIFT);             \
326                                                                 \
327   s0 = vis_fpmerge(LD_U8(sp0, 0), LD_U8(sp1, 0));               \
328   s1 = vis_fpmerge(LD_U8(sp0, 1), LD_U8(sp1, 1));               \
329   s2 = vis_fpmerge(LD_U8(sp0, 2), LD_U8(sp1, 2));               \
330   s3 = vis_fpmerge(LD_U8(sp0, 3), LD_U8(sp1, 3));               \
331                                                                 \
332   s0 = vis_fpmerge(vis_read_lo(s0), vis_read_lo(s2));           \
333   s1 = vis_fpmerge(vis_read_lo(s1), vis_read_lo(s3));           \
334   dd = vis_fpmerge(vis_read_lo(s0), vis_read_lo(s1));           \
335                                                                 \
336   X += 2*dX;                                                    \
337   Y += 2*dY
338 
339 /***************************************************************/
340 #define AFFINE_U8_4x1                                           \
341   sp0 = S_PTR(Y) + 4*(X &gt;&gt; MLIB_SHIFT);                         \
342                                                                 \
343   s0 = vis_fpmerge(LD_U8(sp0, 0), LD_U8(sp0, 2));               \
344   s1 = vis_fpmerge(LD_U8(sp0, 1), LD_U8(sp0, 3));               \
345   s0 = vis_fpmerge(vis_read_lo(s0), vis_read_lo(s1));           \
346   dd = vis_freg_pair(vis_read_lo(s0), vis_fzeros())
347 
348 /***************************************************************/
349 mlib_status mlib_ImageAffine_u8_4ch_nn(mlib_affine_param *param)
350 {
351   DECLAREVAR();
352   DTYPE  *dstLineEnd;
353   mlib_s32 i, size;
354 
355   for (j = yStart; j &lt;= yFinish; j++) {
356     mlib_u8  *sp0, *sp1;
357     mlib_d64 *da, s0, s1, s2, s3, dd, d_old;
358     mlib_s32 emask;
359 
360     CLIP(4);
361     dstLineEnd  = (DTYPE*)dstData + 4 * xRight;
362     size = xRight - xLeft + 1;
363 
364     if (((mlib_s32)dp &amp; 7) == 0) {
365 #pragma pipeloop(0)
366       for (i = 0; i &lt;= (size - 2); i += 2) {
367         AFFINE_U8_4x2;
368         *(mlib_d64*)dp = dd;
369         dp += 8;
370       }
371 
372       if (i &lt; size) {
373         AFFINE_U8_4x1;
374         *(mlib_f32*)dp = vis_read_hi(dd);
375       }
376 
377     } else {
378       da = vis_alignaddr(dp, 0);
379       d_old = vis_faligndata(da[0], da[0]);
380       vis_alignaddr((void*)0, (mlib_u8*)da - dp);
381 
382 #pragma pipeloop(0)
383       for (i = 0; i &lt;= (size - 2); i += 2) {
384         AFFINE_U8_4x2;
385 
386         *da++ = vis_faligndata(d_old, dd);
387         d_old = dd;
388       }
389 
390       if (i &lt; size) {
391         AFFINE_U8_4x1;
392       }
393 
394       dstLineEnd += 3;
395       emask = vis_edge8(da, dstLineEnd);
396       vis_pst_8(vis_faligndata(d_old, dd), da++, emask);
397 
398       if ((mlib_u8*)da &lt;= dstLineEnd) {
399         emask = vis_edge8(da, dstLineEnd);
400         vis_pst_8(vis_faligndata(dd, dd), da, emask);
401       }
402     }
403   }
404 
405   return MLIB_SUCCESS;
406 }
407 
408 /***************************************************************/
409 #undef  DTYPE
410 #define DTYPE mlib_u16
411 
412 #define SHIFT1(x) (((x) &gt;&gt; (MLIB_SHIFT - 1)) &amp;~ 1)
413 
414 /***************************************************************/
415 mlib_status mlib_ImageAffine_s16_1ch_nn(mlib_affine_param *param)
416 {
417   DECLAREVAR();
418   mlib_s32 i, size;
419 
420   vis_alignaddr((void*)0, 6);
421 
422   for (j = yStart; j &lt;= yFinish; j++) {
423     mlib_d64 ss;
424 
425     CLIP(1);
426     size = xRight - xLeft + 1;
427 
428     while (((mlib_s32)dp &amp; 7) &amp;&amp; (size &gt; 0)) {
429       *dp = *(S_PTR(Y) + (X &gt;&gt; MLIB_SHIFT));
430       dp++;
431       X += dX;
432       Y += dY;
433       size--;
434     }
435 
436 #pragma pipeloop(0)
437     for (i = 0; i &lt;= (size - 4); i += 4) {
438       mlib_u16 *sp0, *sp1, *sp2, *sp3;
439 
440       sp0 = S_PTR(Y);
441       sp1 = S_PTR(Y +   dY);
442       sp2 = S_PTR(Y + 2*dY);
443       sp3 = S_PTR(Y + 3*dY);
444 
445       ss = vis_faligndata(vis_ld_u16_i(sp3, SHIFT1(X + 3*dX)), ss);
446       ss = vis_faligndata(vis_ld_u16_i(sp2, SHIFT1(X + 2*dX)), ss);
447       ss = vis_faligndata(vis_ld_u16_i(sp1, SHIFT1(X +   dX)), ss);
448       ss = vis_faligndata(vis_ld_u16_i(sp0, SHIFT1(X)), ss);
449 
450       *(mlib_d64*)dp = ss;
451 
452       dp += 4;
453       X += 4*dX;
454       Y += 4*dY;
455     }
456 
457     for (i = 0; i &lt; (size &amp; 3); i++) {
458       dp[i] = *(S_PTR(Y) + (X &gt;&gt; MLIB_SHIFT));
459       X += dX;
460       Y += dY;
461     }
462   }
463 
464   return MLIB_SUCCESS;
465 }
466 
467 /***************************************************************/
468 mlib_status mlib_ImageAffine_s16_2ch_nn(mlib_affine_param *param)
469 {
470   DECLAREVAR();
471   DTYPE  *srcPixelPtr;
472   DTYPE  *dstLineEnd;
473 
474   for (j = yStart; j &lt;= yFinish; j++) {
475     CLIP(2);
476     dstLineEnd  = (DTYPE*)dstData + 2 * xRight;
477 
478 #pragma pipeloop(0)
479     for (; dp &lt;= dstLineEnd; dp += 2) {
480       sp = S_PTR(Y) + 2*(X &gt;&gt; MLIB_SHIFT);
481       dp[0] = sp[0];
482       dp[1] = sp[1];
483 
484       X += dX;
485       Y += dY;
486     }
487   }
488 
489   return MLIB_SUCCESS;
490 }
491 
492 /***************************************************************/
493 #undef  LD_U16
494 #define LD_U16(sp, x) vis_ld_u16(sp + x)
495 
496 /***************************************************************/
497 mlib_status mlib_ImageAffine_s16_3ch_nn(mlib_affine_param *param)
498 {
499   DECLAREVAR();
500   DTYPE  *srcPixelPtr;
501   mlib_s32 i, size;
502 
503   vis_alignaddr((void*)0, 6);
504 
505   for (j = yStart; j &lt;= yFinish; j++) {
506     mlib_d64 s0, s1, s2;
507 
508     CLIP(3);
509     size = xRight - xLeft + 1;
510 
511     while (((mlib_s32)dp &amp; 7) &amp;&amp; (size &gt; 0)) {
512       sp = S_PTR(Y) + 3*(X &gt;&gt; MLIB_SHIFT);
513       dp[0] = sp[0];
514       dp[1] = sp[1];
515       dp[2] = sp[2];
516       dp += 3;
517       X += dX;
518       Y += dY;
519       size--;
520     }
521 
522 #pragma pipeloop(0)
523     for (i = 0; i &lt;= (size - 4); i += 4) {
524       mlib_u16 *sp0, *sp1, *sp2, *sp3;
525 
526       sp0 = S_PTR(Y);
527       sp1 = S_PTR(Y +   dY);
528       sp2 = S_PTR(Y + 2*dY);
529       sp3 = S_PTR(Y + 3*dY);
530 
531       sp0 += 3*(X &gt;&gt; MLIB_SHIFT);
532       sp1 += 3*((X + dX) &gt;&gt; MLIB_SHIFT);
533       sp2 += 3*((X + 2*dX) &gt;&gt; MLIB_SHIFT);
534       sp3 += 3*((X + 3*dX) &gt;&gt; MLIB_SHIFT);
535 
536       s2 = vis_faligndata(LD_U16(sp3, 2), s2);
537       s2 = vis_faligndata(LD_U16(sp3, 1), s2);
538       s2 = vis_faligndata(LD_U16(sp3, 0), s2);
539       s2 = vis_faligndata(LD_U16(sp2, 2), s2);
540       s1 = vis_faligndata(LD_U16(sp2, 1), s1);
541       s1 = vis_faligndata(LD_U16(sp2, 0), s1);
542       s1 = vis_faligndata(LD_U16(sp1, 2), s1);
543       s1 = vis_faligndata(LD_U16(sp1, 1), s1);
544       s0 = vis_faligndata(LD_U16(sp1, 0), s0);
545       s0 = vis_faligndata(LD_U16(sp0, 2), s0);
546       s0 = vis_faligndata(LD_U16(sp0, 1), s0);
547       s0 = vis_faligndata(LD_U16(sp0, 0), s0);
548 
549       ((mlib_d64*)dp)[0] = s0;
550       ((mlib_d64*)dp)[1] = s1;
551       ((mlib_d64*)dp)[2] = s2;
552 
553       dp += 12;
554       X += 4*dX;
555       Y += 4*dY;
556     }
557 
558     for (i = 0; i &lt; (size &amp; 3); i++) {
559       sp = S_PTR(Y) + 3*(X &gt;&gt; MLIB_SHIFT);
560       dp[0] = sp[0];
561       dp[1] = sp[1];
562       dp[2] = sp[2];
563       dp += 3;
564       X += dX;
565       Y += dY;
566     }
567   }
568 
569   return MLIB_SUCCESS;
570 }
571 
572 /***************************************************************/
573 #define AFFINE_S16_4ch                                          \
574   sp = S_PTR(Y) + 4*(X &gt;&gt; MLIB_SHIFT);                          \
575                                                                 \
576   dd = vis_faligndata(LD_U16(sp, 3), dd);                       \
577   dd = vis_faligndata(LD_U16(sp, 2), dd);                       \
578   dd = vis_faligndata(LD_U16(sp, 1), dd);                       \
579   dd = vis_faligndata(LD_U16(sp, 0), dd);                       \
580                                                                 \
581   X += dX;                                                      \
582   Y += dY
583 
584 /***************************************************************/
585 mlib_status mlib_ImageAffine_s16_4ch_nn(mlib_affine_param *param)
586 {
587   DECLAREVAR();
588   DTYPE  *srcPixelPtr;
589   mlib_s32 i, size, max_xsize = param -&gt; max_xsize;
590   mlib_d64 buff[BUFF_SIZE], *pbuff = buff;
591 
592   if (max_xsize &gt; BUFF_SIZE) {
593     pbuff = mlib_malloc(sizeof(mlib_d64)*max_xsize);
594   }
595 
596   for (j = yStart; j &lt;= yFinish; j++) {
597     mlib_d64 *da, dd;
598 
599     vis_alignaddr((void*)0, 6);
600 
601     CLIP(4);
602     size = xRight - xLeft + 1;
603 
604     if ((mlib_s32)dp &amp; 7) {
605       da = buff;
606     } else {
607       da = (mlib_d64*)dp;
608     }
609 
610 #pragma pipeloop(0)
611     for (i = 0; i &lt; size; i++) {
612       AFFINE_S16_4ch;
613       da[i] = dd;
614     }
615 
616     if ((mlib_s32)dp &amp; 7) {
617       mlib_ImageCopy_na((mlib_u8*)buff, (mlib_u8*)dp, 8*size);
618     }
619   }
620 
621   if (pbuff != buff) {
622     mlib_free(pbuff);
623   }
624 
625   return MLIB_SUCCESS;
626 }
627 
628 /***************************************************************/
    </pre>
  </body>
</html>
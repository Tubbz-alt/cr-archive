<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/ui/classbrowser/HTMLGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 package sun.jvm.hotspot.ui.classbrowser;
  26 
  27 import java.io.*;
  28 import java.util.*;
  29 import sun.jvm.hotspot.asm.*;
  30 import sun.jvm.hotspot.code.*;
  31 import sun.jvm.hotspot.compiler.*;
  32 import sun.jvm.hotspot.debugger.*;
  33 import sun.jvm.hotspot.interpreter.*;
  34 import sun.jvm.hotspot.oops.*;
  35 import sun.jvm.hotspot.runtime.*;
  36 import sun.jvm.hotspot.tools.jcore.*;
  37 import sun.jvm.hotspot.types.*;
  38 import sun.jvm.hotspot.utilities.*;
  39 
  40 public class HTMLGenerator implements /* imports */ ClassConstants {
  41     static class Formatter {
  42         boolean html;
  43         StringBuffer buf = new StringBuffer();
  44 
  45         Formatter(boolean h) {
  46             html = h;
  47         }
  48 
  49         void append(String s) {
  50             buf.append(s);
  51         }
  52 
  53         void append(int s) {
  54             buf.append(s);
  55         }
  56 
  57         void append(char s) {
  58             buf.append(s);
  59         }
  60 
  61         void append(StringBuffer s) {
  62             buf.append(s);
  63         }
  64 
  65         void append(Formatter s) {
  66             buf.append(s);
  67         }
  68 
  69         StringBuffer getBuffer() {
  70             return buf;
  71         }
  72 
  73         public String toString() {
  74             return buf.toString();
  75         }
  76 
  77         void wrap(String tag, String text) {
  78             wrap(tag, tag, text);
  79         }
  80         void wrap(String before, String after, String text) {
  81             beginTag(before);
  82             append(text);
  83             endTag(after);
  84         }
  85 
  86         // header tags
  87         void h1(String s) { nl(); wrap(&quot;h1&quot;, s); nl(); }
  88         void h2(String s) { nl(); wrap(&quot;h2&quot;, s); nl(); }
  89         void h3(String s) { nl(); wrap(&quot;h3&quot;, s); nl(); }
  90         void h4(String s) { nl(); wrap(&quot;h4&quot;, s); nl(); }
  91 
  92         // list tags
  93         void beginList()  { beginTag(&quot;ul&quot;); nl(); }
  94         void endList()    { endTag(&quot;ul&quot;); nl();   }
  95         void beginListItem() { beginTag(&quot;li&quot;); }
  96         void endListItem()   { endTag(&quot;li&quot;); nl();   }
  97         void li(String s) { wrap(&quot;li&quot;, s); nl();  }
  98 
  99         // table tags
 100         void beginTable(int border) {
 101             beginTag(&quot;table border=&#39;&quot; + border + &quot;&#39;&quot;);
 102         }
 103         void cell(String s) { wrap(&quot;td&quot;, s); }
 104         void headerCell(String s) { wrap(&quot;th&quot;, s); }
 105         void endTable() { endTag(&quot;table&quot;); }
 106 
 107         void link(String href, String text) {
 108             wrap(&quot;a href=&#39;&quot; + href + &quot;&#39;&quot;, &quot;a&quot;, text);
 109         }
 110         void beginTag(String s) {
 111             if (html) { append(&quot;&lt;&quot;); append(s); append(&quot;&gt;&quot;); }
 112         }
 113         void endTag(String s) {
 114             if (html) {
 115                append(&quot;&lt;/&quot;); append(s); append(&quot;&gt;&quot;);
 116             } else {
 117                if (s.equals(&quot;table&quot;) || s.equals(&quot;tr&quot;)) {
 118                   nl();
 119                }
 120                if (s.equals(&quot;td&quot;) || s.equals(&quot;th&quot;)) {
 121                   append(&quot; &quot;);
 122                }
 123             }
 124         }
 125         void bold(String s) {
 126             wrap(&quot;b&quot;, s);
 127         }
 128 
 129         void nl() {
 130             if (!html) buf.append(&quot;\n&quot;);
 131         }
 132 
 133         void br() {
 134             if (html) append(&quot;&lt;br&gt;&quot;);
 135             else      append(&quot;\n&quot;);
 136         }
 137         void genEmptyHTML() {
 138             if (html) append(&quot;&lt;html&gt;&lt;/html&gt;&quot;);
 139         }
 140 
 141         void genHTMLPrologue() {
 142             if (html) append(&quot;&lt;html&gt;&lt;body&gt;&quot;);
 143         }
 144 
 145         void genHTMLPrologue(String title) {
 146             if (html) {
 147                 append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;);
 148                 append(title);
 149                 append(&quot;&lt;/title&gt;&lt;/head&gt;&quot;);
 150                 append(&quot;&lt;body&gt;&quot;);
 151             }
 152             h2(title);
 153         }
 154         void genHTMLEpilogue() {
 155             if (html) append(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);
 156         }
 157 
 158     }
 159 
 160    private static final String DUMP_KLASS_OUTPUT_DIR = &quot;.&quot;;
 161    private static final int NATIVE_CODE_SIZE = 200;
 162    private final String spaces;
 163    private final String tab;
 164 
 165    private boolean genHTML = true;
 166 
 167    public HTMLGenerator() {
 168        this(true);
 169    }
 170 
 171    public HTMLGenerator(boolean html) {
 172        genHTML = html;
 173        if (html) {
 174            spaces = &quot;&amp;nbsp;&amp;nbsp;&quot;;
 175            tab = &quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;;
 176        } else {
 177            spaces = &quot;  &quot;;
 178            tab = &quot;    &quot;;
 179        }
 180    }
 181 
 182    protected String escapeHTMLSpecialChars(String value) {
 183       if (!genHTML) return value;
 184 
 185       Formatter buf = new Formatter(genHTML);
 186       int len = value.length();
 187       for (int i=0; i &lt; len; i++) {
 188          char c = value.charAt(i);
 189          switch (c) {
 190             case &#39;&lt;&#39;:
 191                buf.append(&quot;&amp;lt;&quot;);
 192                break;
 193             case &#39;&gt;&#39;:
 194                buf.append(&quot;&amp;gt;&quot;);
 195                break;
 196             case &#39;&amp;&#39;:
 197                buf.append(&quot;&amp;amp;&quot;);
 198                break;
 199             default:
 200                buf.append(c);
 201                break;
 202          }
 203       }
 204       return buf.toString();
 205    }
 206 
 207    public String genHTMLForMessage(String message) {
 208       Formatter buf = new Formatter(genHTML);
 209       buf.genHTMLPrologue(message);
 210       buf.genHTMLEpilogue();
 211       return buf.toString();
 212    }
 213 
 214    public String genHTMLErrorMessage(Exception exp) {
 215       exp.printStackTrace();
 216       return genHTMLForMessage(exp.getClass().getName() + &quot; : &quot; + exp.getMessage());
 217    }
 218 
 219    public String genHTMLForWait(String message) {
 220       Formatter buf = new Formatter(genHTML);
 221       buf.genHTMLPrologue(&quot;Please wait ..&quot;);
 222       buf.h2(message);
 223       return buf.toString();
 224    }
 225 
 226    protected String genKlassTitle(InstanceKlass klass) {
 227       Formatter buf = new Formatter(genHTML);
 228       AccessFlags acc = klass.getAccessFlagsObj();
 229       if (acc.isPublic()) {
 230          buf.append(&quot;public &quot;);
 231       } else if (acc.isProtected()) {
 232          buf.append(&quot;protected &quot;);
 233       } else if (acc.isPrivate()) {
 234          buf.append(&quot;private &quot;);
 235       }
 236 
 237       if (acc.isStatic()) {
 238          buf.append(&quot;static &quot;);
 239       }
 240 
 241       if (acc.isAbstract() ) {
 242          buf.append(&quot;abstract &quot;);
 243       } else if (acc.isFinal()) {
 244          buf.append(&quot;final &quot;);
 245       }
 246 
 247       if (acc.isStrict()) {
 248          buf.append(&quot;strict &quot;);
 249       }
 250 
 251       // javac generated flags
 252       if (acc.isEnum()) {
 253          buf.append(&quot;[enum] &quot;);
 254       }
 255       if (acc.isSynthetic()) {
 256          buf.append(&quot;[synthetic] &quot;);
 257       }
 258 
 259       if (klass.isInterface()) {
 260          buf.append(&quot;interface&quot;);
 261       } else {
 262          buf.append(&quot;class&quot;);
 263       }
 264 
 265       buf.append(&#39; &#39;);
 266       buf.append(klass.getName().asString().replace(&#39;/&#39;, &#39;.&#39;));
 267       // is it generic?
 268       Symbol genSig = klass.getGenericSignature();
 269       if (genSig != null) {
 270          buf.append(&quot; [signature &quot;);
 271          buf.append(escapeHTMLSpecialChars(genSig.asString()));
 272          buf.append(&quot;] &quot;);
 273       } else {
 274          buf.append(&#39; &#39;);
 275       }
 276       buf.append(&#39;@&#39;);
 277       buf.append(klass.getAddress().toString());
 278       return buf.toString();
 279    }
 280 
 281    protected String genBaseHref() {
 282       return &quot;&quot;;
 283    }
 284 
 285    protected String genKlassHref(InstanceKlass klass) {
 286       return genBaseHref() + &quot;klass=&quot; + klass.getAddress();
 287    }
 288 
 289    protected String genKlassLink(InstanceKlass klass) {
 290       Formatter buf = new Formatter(genHTML);
 291       buf.link(genKlassHref(klass), genKlassTitle(klass));
 292       return buf.toString();
 293    }
 294 
 295    protected String genMethodModifierString(AccessFlags acc) {
 296       Formatter buf = new Formatter(genHTML);
 297       if (acc.isPrivate()) {
 298          buf.append(&quot;private &quot;);
 299       } else if (acc.isProtected()) {
 300          buf.append(&quot;protected &quot;);
 301       } else if (acc.isPublic()) {
 302          buf.append(&quot;public &quot;);
 303       }
 304 
 305       if (acc.isStatic()) {
 306          buf.append(&quot;static &quot;);
 307       } else if (acc.isAbstract() ) {
 308          buf.append(&quot;abstract &quot;);
 309       } else if (acc.isFinal()) {
 310          buf.append(&quot;final &quot;);
 311       }
 312 
 313        if (acc.isNative()) {
 314          buf.append(&quot;native &quot;);
 315       }
 316 
 317       if (acc.isStrict()) {
 318          buf.append(&quot;strict &quot;);
 319       }
 320 
 321       if (acc.isSynchronized()) {
 322          buf.append(&quot;synchronized &quot;);
 323       }
 324 
 325       // javac generated flags
 326       if (acc.isBridge()) {
 327          buf.append(&quot;[bridge] &quot;);
 328       }
 329 
 330       if (acc.isSynthetic()) {
 331          buf.append(&quot;[synthetic] &quot;);
 332       }
 333 
 334       if (acc.isVarArgs()) {
 335          buf.append(&quot;[varargs] &quot;);
 336       }
 337 
 338       return buf.toString();
 339    }
 340 
 341    protected String genMethodNameAndSignature(Method method) {
 342       Formatter buf = new Formatter(genHTML);
 343       buf.append(genMethodModifierString(method.getAccessFlagsObj()));
 344       Symbol sig = method.getSignature();
 345       new SignatureConverter(sig, buf.getBuffer()).iterateReturntype();
 346       buf.append(&quot; &quot;);
 347       String methodName = method.getName().asString();
 348       buf.append(escapeHTMLSpecialChars(methodName));
 349       buf.append(&#39;(&#39;);
 350       new SignatureConverter(sig, buf.getBuffer()).iterateParameters();
 351       buf.append(&#39;)&#39;);
 352       // is it generic?
 353       Symbol genSig = method.getGenericSignature();
 354       if (genSig != null) {
 355          buf.append(&quot; [signature &quot;);
 356          buf.append(escapeHTMLSpecialChars(genSig.asString()));
 357          buf.append(&quot;] &quot;);
 358       }
 359       return buf.toString().replace(&#39;/&#39;, &#39;.&#39;);
 360    }
 361 
 362    protected String genMethodTitle(Method method) {
 363       Formatter buf = new Formatter(genHTML);
 364       buf.append(genMethodNameAndSignature(method));
 365       buf.append(&#39; &#39;);
 366       buf.append(&#39;@&#39;);
 367       buf.append(method.getAddress().toString());
 368       return buf.toString();
 369    }
 370 
 371    protected String genMethodHref(Method m) {
 372       return genBaseHref() + &quot;method=&quot; + m.getAddress();
 373    }
 374 
 375    protected String genMethodLink(Method m) {
 376       Formatter buf = new Formatter(genHTML);
 377       buf.link(genMethodHref(m), genMethodTitle(m));
 378       return buf.toString();
 379    }
 380 
 381    protected String genMethodAndKlassLink(Method m) {
 382       Formatter buf = new Formatter(genHTML);
 383       buf.append(genMethodLink(m));
 384       buf.append(&quot; of &quot;);
 385       buf.append(genKlassLink((InstanceKlass) m.getMethodHolder()));
 386       return buf.toString();
 387    }
 388 
 389    protected String genNMethodHref(NMethod nm) {
 390       return genBaseHref() + &quot;nmethod=&quot; + nm.getAddress();
 391    }
 392 
 393    public String genNMethodTitle(NMethod nmethod) {
 394       Formatter buf = new Formatter(genHTML);
 395       Method m = nmethod.getMethod();
 396 
 397       buf.append(&quot;Disassembly for compiled method [&quot;);
 398       buf.append(genMethodTitle(m));
 399       buf.append(&quot; ] &quot;);
 400       buf.append(&#39;@&#39;);
 401       buf.append(nmethod.getAddress().toString());
 402       return buf.toString();
 403    }
 404 
 405    protected String genNMethodLink(NMethod nm) {
 406       Formatter buf = new Formatter(genHTML);
 407       buf.link(genNMethodHref(nm), genNMethodTitle(nm));
 408       return buf.toString();
 409    }
 410 
 411    public String genCodeBlobTitle(CodeBlob blob) {
 412       Formatter buf = new Formatter(genHTML);
 413       buf.append(&quot;Disassembly for code blob &quot; + blob.getName() + &quot; [&quot;);
 414       buf.append(blob.getClass().getName());
 415       buf.append(&quot; ] @&quot;);
 416       buf.append(blob.getAddress().toString());
 417       return buf.toString();
 418    }
 419 
 420    protected BytecodeDisassembler createBytecodeDisassembler(Method m) {
 421       return new BytecodeDisassembler(m);
 422    }
 423 
 424    private String genLowHighShort(int val) {
 425       Formatter buf = new Formatter(genHTML);
 426       buf.append(&#39;#&#39;);
 427       buf.append(Integer.toString(val &amp; 0xFFFF));
 428       buf.append(&quot; #&quot;);
 429       buf.append(Integer.toString((val &gt;&gt; 16) &amp; 0xFFFF));
 430       return buf.toString();
 431    }
 432 
 433    private String genListOfShort(short[] values) {
 434       if (values == null || values.length == 0)  return &quot;&quot;;
 435       Formatter buf = new Formatter(genHTML);
 436       buf.append(&#39;[&#39;);
 437       for (int i = 0; i &lt; values.length; i++) {
 438           if (i &gt; 0)  buf.append(&#39; &#39;);
 439           buf.append(&#39;#&#39;);
 440           buf.append(Integer.toString(values[i]));
 441       }
 442       buf.append(&#39;]&#39;);
 443       return buf.toString();
 444    }
 445 
 446    protected String genHTMLTableForConstantPool(ConstantPool cpool) {
 447       Formatter buf = new Formatter(genHTML);
 448       buf.beginTable(1);
 449 
 450       buf.beginTag(&quot;tr&quot;);
 451       buf.headerCell(&quot;Index&quot;);
 452       buf.headerCell(&quot;Constant Type&quot;);
 453       buf.headerCell(&quot;Constant Value&quot;);
 454       buf.endTag(&quot;tr&quot;);
 455 
 456       final int length = (int) cpool.getLength();
 457       // zero&#39;th pool entry is always invalid. ignore it.
 458       for (int index = 1; index &lt; length; index++) {
 459          buf.beginTag(&quot;tr&quot;);
 460          buf.cell(Integer.toString(index));
 461 
 462          int ctag = (int) cpool.getTags().at((int) index);
 463          switch (ctag) {
 464             case JVM_CONSTANT_Integer:
 465                buf.cell(&quot;JVM_CONSTANT_Integer&quot;);
 466                buf.cell(Integer.toString(cpool.getIntAt(index)));
 467                break;
 468 
 469             case JVM_CONSTANT_Float:
 470                buf.cell(&quot;JVM_CONSTANT_Float&quot;);
 471                buf.cell(Float.toString(cpool.getFloatAt(index)));
 472                break;
 473 
 474             case JVM_CONSTANT_Long:
 475                buf.cell(&quot;JVM_CONSTANT_Long&quot;);
 476                buf.cell(Long.toString(cpool.getLongAt(index)));
 477                // long entries occupy two slots
 478                index++;
 479                break;
 480 
 481             case JVM_CONSTANT_Double:
 482                buf.cell(&quot;JVM_CONSTANT_Double&quot;);
 483                buf.cell(Double.toString(cpool.getDoubleAt(index)));
 484                // double entries occupy two slots
 485                index++;
 486                break;
 487 
 488             case JVM_CONSTANT_UnresolvedClass:
 489                buf.cell(&quot;JVM_CONSTANT_UnresolvedClass&quot;);
 490                buf.cell(cpool.getKlassNameAt(index).asString());
 491                break;
 492 
 493             case JVM_CONSTANT_UnresolvedClassInError:
 494                buf.cell(&quot;JVM_CONSTANT_UnresolvedClassInError&quot;);
 495                buf.cell(cpool.getSymbolAt(index).asString());
 496                break;
 497 
 498             case JVM_CONSTANT_Class:
 499                buf.cell(&quot;JVM_CONSTANT_Class&quot;);
 500                Klass klass = (Klass) cpool.getKlassAt(index);
 501                if (klass instanceof InstanceKlass) {
 502                   buf.cell(genKlassLink((InstanceKlass) klass));
 503                } else {
 504                   buf.cell(klass.getName().asString().replace(&#39;/&#39;, &#39;.&#39;));
 505                }
 506                break;
 507 
 508             case JVM_CONSTANT_Utf8:
 509                buf.cell(&quot;JVM_CONSTANT_Utf8&quot;);
 510                buf.cell(&quot;\&quot;&quot; +
 511                  escapeHTMLSpecialChars(cpool.getSymbolAt(index).asString()) +
 512                  &quot;\&quot;&quot;);
 513                break;
 514 
 515             case JVM_CONSTANT_String:
 516                buf.cell(&quot;JVM_CONSTANT_String&quot;);
 517                buf.cell(&quot;\&quot;&quot; +
 518                         escapeHTMLSpecialChars(cpool.getUnresolvedStringAt(index).asString()) + &quot;\&quot;&quot;);
 519                break;
 520 
 521             case JVM_CONSTANT_Fieldref:
 522                buf.cell(&quot;JVM_CONSTANT_Fieldref&quot;);
 523                buf.cell(genLowHighShort(cpool.getIntAt(index)));
 524                break;
 525 
 526             case JVM_CONSTANT_Methodref:
 527                buf.cell(&quot;JVM_CONSTANT_Methodref&quot;);
 528                buf.cell(genLowHighShort(cpool.getIntAt(index)));
 529                break;
 530 
 531             case JVM_CONSTANT_InterfaceMethodref:
 532                buf.cell(&quot;JVM_CONSTANT_InterfaceMethodref&quot;);
 533                buf.cell(genLowHighShort(cpool.getIntAt(index)));
 534                break;
 535 
 536             case JVM_CONSTANT_NameAndType:
 537                buf.cell(&quot;JVM_CONSTANT_NameAndType&quot;);
 538                buf.cell(genLowHighShort(cpool.getIntAt(index)));
 539                break;
 540 
 541             case JVM_CONSTANT_ClassIndex:
 542                buf.cell(&quot;JVM_CONSTANT_ClassIndex&quot;);
 543                buf.cell(Integer.toString(cpool.getIntAt(index)));
 544                break;
 545 
 546             case JVM_CONSTANT_StringIndex:
 547                buf.cell(&quot;JVM_CONSTANT_StringIndex&quot;);
 548                buf.cell(Integer.toString(cpool.getIntAt(index)));
 549                break;
 550 
 551             case JVM_CONSTANT_MethodHandle:
 552                buf.cell(&quot;JVM_CONSTANT_MethodHandle&quot;);
 553                buf.cell(genLowHighShort(cpool.getIntAt(index)));
 554                break;
 555 
 556             case JVM_CONSTANT_MethodType:
 557                buf.cell(&quot;JVM_CONSTANT_MethodType&quot;);
 558                buf.cell(Integer.toString(cpool.getIntAt(index)));
 559                break;
 560 
 561            case JVM_CONSTANT_Dynamic:
 562                buf.cell(&quot;JVM_CONSTANT_Dynamic&quot;);
 563                buf.cell(genLowHighShort(cpool.getIntAt(index)) +
 564                         genListOfShort(cpool.getBootstrapSpecifierAt(index)));
 565              break;
 566 
 567             case JVM_CONSTANT_InvokeDynamic:
 568                buf.cell(&quot;JVM_CONSTANT_InvokeDynamic&quot;);
 569                buf.cell(genLowHighShort(cpool.getIntAt(index)) +
 570                         genListOfShort(cpool.getBootstrapSpecifierAt(index)));
 571                break;
 572 
 573             default:
 574                throw new InternalError(&quot;unknown tag: &quot; + ctag);
 575          }
 576 
 577          buf.endTag(&quot;tr&quot;);
 578       }
 579 
 580       buf.endTable();
 581       return buf.toString();
 582    }
 583 
 584    public String genHTML(ConstantPool cpool) {
 585       try {
 586          Formatter buf = new Formatter(genHTML);
 587          buf.genHTMLPrologue(genConstantPoolTitle(cpool));
 588          buf.h3(&quot;Holder Class&quot;);
 589          buf.append(genKlassLink((InstanceKlass) cpool.getPoolHolder()));
 590          buf.h3(&quot;Constants&quot;);
 591          buf.append(genHTMLTableForConstantPool(cpool));
 592          buf.genHTMLEpilogue();
 593          return buf.toString();
 594       } catch (Exception exp) {
 595          return genHTMLErrorMessage(exp);
 596       }
 597    }
 598 
 599    protected String genConstantPoolHref(ConstantPool cpool) {
 600       return genBaseHref() + &quot;cpool=&quot; + cpool.getAddress();
 601    }
 602 
 603    protected String genConstantPoolTitle(ConstantPool cpool) {
 604       Formatter buf = new Formatter(genHTML);
 605       buf.append(&quot;Constant Pool of [&quot;);
 606       buf.append(genKlassTitle((InstanceKlass) cpool.getPoolHolder()));
 607       buf.append(&quot;] @&quot;);
 608       buf.append(cpool.getAddress().toString());
 609       return buf.toString();
 610    }
 611 
 612    protected String genConstantPoolLink(ConstantPool cpool) {
 613       Formatter buf = new Formatter(genHTML);
 614       buf.link(genConstantPoolHref(cpool), genConstantPoolTitle(cpool));
 615       return buf.toString();
 616    }
 617 
 618    public String genHTML(Method method) {
 619       try {
 620          final Formatter buf = new Formatter(genHTML);
 621          buf.genHTMLPrologue(genMethodTitle(method));
 622 
 623          buf.h3(&quot;Holder Class&quot;);
 624          buf.append(genKlassLink((InstanceKlass) method.getMethodHolder()));
 625 
 626          NMethod nmethod = method.getNativeMethod();
 627          if (nmethod != null) {
 628             buf.h3(&quot;Compiled Code&quot;);
 629             buf.append(genNMethodLink(nmethod));
 630          }
 631 
 632          boolean hasThrows = method.hasCheckedExceptions();
 633          ConstantPool cpool = ((InstanceKlass) method.getMethodHolder()).getConstants();
 634          if (hasThrows) {
 635             buf.h3(&quot;Checked Exception(s)&quot;);
 636             CheckedExceptionElement[] exceptions = method.getCheckedExceptions();
 637             buf.beginTag(&quot;ul&quot;);
 638             for (int exp = 0; exp &lt; exceptions.length; exp++) {
 639                short cpIndex = (short) exceptions[exp].getClassCPIndex();
 640                ConstantTag tag = cpool.getTagAt(cpIndex);
 641                if (tag.isUnresolvedKlass()) {
 642                  buf.li(cpool.getKlassNameAt(cpIndex).asString().replace(&#39;/&#39;, &#39;.&#39;));
 643                } else {
 644                  Klass k = cpool.getKlassAt(cpIndex);
 645                  buf.li(genKlassLink((InstanceKlass)k));
 646                }
 647             }
 648             buf.endTag(&quot;ul&quot;);
 649          }
 650 
 651          if (method.isNative() || method.isAbstract()) {
 652            buf.genHTMLEpilogue();
 653            return buf.toString();
 654          }
 655 
 656          buf.h3(&quot;Bytecode&quot;);
 657          BytecodeDisassembler disasm = createBytecodeDisassembler(method);
 658          final boolean hasLineNumbers = method.hasLineNumberTable();
 659          disasm.decode(new BytecodeVisitor() {
 660                           private Method method;
 661                           public void prologue(Method m) {
 662                              method = m;
 663                              buf.beginTable(0);
 664                              buf.beginTag(&quot;tr&quot;);
 665                              if (hasLineNumbers) {
 666                                 buf.headerCell(&quot;line&quot;);
 667                              }
 668                              buf.headerCell(&quot;bci&quot; + spaces);
 669                              buf.headerCell(&quot;bytecode&quot;);
 670                              buf.endTag(&quot;tr&quot;);
 671                           }
 672 
 673                           public void visit(Bytecode instr) {
 674                              int curBci = instr.bci();
 675                              buf.beginTag(&quot;tr&quot;);
 676                              if (hasLineNumbers) {
 677                                 int lineNumber = method.getLineNumberFromBCI(curBci);
 678                                 buf.cell(Integer.toString(lineNumber) + spaces);
 679                              }
 680                              buf.cell(Integer.toString(curBci) + spaces);
 681 
 682                              buf.beginTag(&quot;td&quot;);
 683                              String instrStr = null;
 684                              try {
 685                                  instrStr = escapeHTMLSpecialChars(instr.toString());
 686                              } catch (RuntimeException re) {
 687                                  buf.append(&quot;exception while printing &quot; + instr.getBytecodeName());
 688                                  buf.endTag(&quot;td&quot;);
 689                                  buf.endTag(&quot;tr&quot;);
 690                                  re.printStackTrace();
 691                                  return;
 692                              }
 693 
 694                              if (instr instanceof BytecodeNew) {
 695                                 BytecodeNew newBytecode = (BytecodeNew) instr;
 696                                 InstanceKlass klass = newBytecode.getNewKlass();
 697                                 if (klass != null) {
 698                                     buf.link(genKlassHref(klass), instrStr);
 699                                 } else {
 700                                     buf.append(instrStr);
 701                                 }
 702                              } else if (instr instanceof BytecodeInvoke) {
 703                                 BytecodeInvoke invokeBytecode = (BytecodeInvoke) instr;
 704                                 if (invokeBytecode.isInvokedynamic()) {
 705                                   buf.append(instrStr);
 706                                 } else {
 707                                   Method m = invokeBytecode.getInvokedMethod();
 708                                   if (m != null) {
 709                                     buf.link(genMethodHref(m), instrStr);
 710                                     buf.append(&quot; of &quot;);
 711                                     InstanceKlass klass = (InstanceKlass) m.getMethodHolder();
 712                                     buf.link(genKlassHref(klass), genKlassTitle(klass));
 713                                   } else {
 714                                     buf.append(instrStr);
 715                                   }
 716                                }
 717                              } else if (instr instanceof BytecodeGetPut) {
 718                                 BytecodeGetPut getPut = (BytecodeGetPut) instr;
 719                                 sun.jvm.hotspot.oops.Field f = getPut.getField();
 720                                 buf.append(instrStr);
 721                                 if (f != null) {
 722                                    InstanceKlass klass = f.getFieldHolder();
 723                                    buf.append(&quot; of &quot;);
 724                                    buf.link(genKlassHref(klass), genKlassTitle(klass));
 725                                 }
 726                              } else if (instr instanceof BytecodeLoadConstant) {
 727                                 BytecodeLoadConstant ldc = (BytecodeLoadConstant) instr;
 728                                 if (ldc.isKlassConstant()) {
 729                                    Object oop = ldc.getKlass();
 730                                    if (oop instanceof InstanceKlass) {
 731                                       buf.append(&quot;&lt;a href=&#39;&quot;);
 732                                       buf.append(genKlassHref((InstanceKlass) oop));
 733                                       buf.append(&quot;&#39;&gt;&quot;);
 734                                       buf.append(instrStr);
 735                                       buf.append(&quot;&lt;/a&gt;&quot;);
 736                                    } else {
 737                                       // unresolved klass literal
 738                                       buf.append(instrStr);
 739                                    }
 740                                 } else {
 741                                    // not a klass literal
 742                                    buf.append(instrStr);
 743                                 }
 744                              } else {
 745                                 buf.append(instrStr);
 746                              }
 747                              buf.endTag(&quot;td&quot;);
 748                              buf.endTag(&quot;tr&quot;);
 749                           }
 750 
 751                           public void epilogue() {
 752                              buf.endTable();
 753                           }
 754                        });
 755 
 756          // display exception table for this method
 757          boolean hasException = method.hasExceptionTable();
 758          if (hasException) {
 759             ExceptionTableElement[] exceptionTable = method.getExceptionTable();
 760             int numEntries = exceptionTable.length;
 761             if (numEntries != 0) {
 762                buf.h4(&quot;Exception Table&quot;);
 763                buf.beginTable(1);
 764                buf.beginTag(&quot;tr&quot;);
 765                buf.headerCell(&quot;start bci&quot;);
 766                buf.headerCell(&quot;end bci&quot;);
 767                buf.headerCell(&quot;handler bci&quot;);
 768                buf.headerCell(&quot;catch type&quot;);
 769                buf.endTag(&quot;tr&quot;);
 770 
 771                for (int e = 0; e &lt; numEntries; e ++) {
 772                   buf.beginTag(&quot;tr&quot;);
 773                   buf.cell(Integer.toString(exceptionTable[e].getStartPC()));
 774                   buf.cell(Integer.toString(exceptionTable[e].getEndPC()));
 775                   buf.cell(Integer.toString(exceptionTable[e].getHandlerPC()));
 776                   short cpIndex = (short) exceptionTable[e].getCatchTypeIndex();
 777                   ConstantTag tag = cpIndex == 0? null : cpool.getTagAt(cpIndex);
 778                   if (tag == null) {
 779                     buf.cell(&quot;Any&quot;);
 780                   } else if (tag.isUnresolvedKlass()) {
 781                     buf.cell(cpool.getKlassNameAt(cpIndex).asString().replace(&#39;/&#39;, &#39;.&#39;));
 782                   } else {
 783                     Klass k = cpool.getKlassAt(cpIndex);
 784                     buf.cell(genKlassLink((InstanceKlass)k));
 785                   }
 786                   buf.endTag(&quot;tr&quot;);
 787                }
 788 
 789                buf.endTable();
 790             }
 791          }
 792 
 793          // display constant pool hyperlink
 794          buf.h3(&quot;Constant Pool&quot;);
 795          buf.append(genConstantPoolLink(cpool));
 796          buf.genHTMLEpilogue();
 797          return buf.toString();
 798       } catch (Exception exp) {
 799          return genHTMLErrorMessage(exp);
 800       }
 801    }
 802 
 803    protected SymbolFinder createSymbolFinder() {
 804       return new DummySymbolFinder();
 805    }
 806 
 807    // genHTML for a given address. Address may be a PC or
 808    // Method* or Klass*.
 809 
 810    public String genHTMLForAddress(String addrStr) {
 811       return genHTML(parseAddress(addrStr));
 812    }
 813 
 814    public String genHTML(sun.jvm.hotspot.debugger.Address pc) {
 815       CodeBlob blob = null;
 816 
 817       try {
 818          blob = (CodeBlob)VM.getVM().getCodeCache().findBlobUnsafe(pc);
 819       } catch (Exception exp) {
 820          // ignore
 821       }
 822 
 823       if (blob != null) {
 824          if (blob instanceof NMethod) {
 825             return genHTML((NMethod)blob);
 826          } else {
 827             // may be interpreter code.
 828             Interpreter interp = VM.getVM().getInterpreter();
 829             if (interp.contains(pc)) {
 830                InterpreterCodelet codelet = interp.getCodeletContaining(pc);
 831                if (codelet == null) {
 832                   return &quot;Unknown location in the Interpreter: &quot; + pc;
 833                }
 834                return genHTML(codelet);
 835             }
 836             return genHTML(blob);
 837          }
 838       } else if (VM.getVM().getCodeCache().contains(pc)) {
 839          return &quot;Unknown location in the CodeCache: &quot; + pc;
 840       }
 841 
 842       // did not find nmethod.
 843       // try Method*, Klass* and ConstantPool*.
 844       try {
 845         Metadata obj = Metadata.instantiateWrapperFor(pc);
 846          if (obj != null) {
 847             if (obj instanceof Method) {
 848                return genHTML((Method) obj);
 849             } else if (obj instanceof InstanceKlass) {
 850                return genHTML((InstanceKlass) obj);
 851             } else if (obj instanceof ConstantPool) {
 852                return genHTML((ConstantPool) obj);
 853             }
 854          }
 855       } catch (Exception exp) {
 856         exp.printStackTrace();
 857          // ignore
 858       }
 859 
 860       // didn&#39;t find any. do raw disassembly.
 861       return genHTMLForRawDisassembly(pc, null);
 862    }
 863 
 864    public String genHTMLForRawDisassembly(sun.jvm.hotspot.debugger.Address startPc, int size) {
 865       try {
 866          return genHTMLForRawDisassembly(startPc, size, null);
 867       } catch (Exception exp) {
 868          return genHTMLErrorMessage(exp);
 869       }
 870    }
 871 
 872    protected String genHTMLForRawDisassembly(sun.jvm.hotspot.debugger.Address startPc,
 873                                              String prevPCs) {
 874       try {
 875          return genHTMLForRawDisassembly(startPc, NATIVE_CODE_SIZE, prevPCs);
 876       } catch (Exception exp) {
 877          return genHTMLErrorMessage(exp);
 878       }
 879    }
 880 
 881    protected String genPCHref(long targetPc) {
 882       return genBaseHref() + &quot;pc=0x&quot; + Long.toHexString(targetPc);
 883    }
 884 
 885    protected String genMultPCHref(String pcs) {
 886       StringBuffer buf = new StringBuffer(genBaseHref());
 887       buf.append(&quot;pc_multiple=&quot;);
 888       buf.append(pcs);
 889       return buf.toString();
 890    }
 891 
 892    protected String genPCHref(Address addr) {
 893       return genPCHref(addressToLong(addr));
 894    }
 895 
 896    class HTMLDisassembler implements InstructionVisitor {
 897       private int instrSize = 0;
 898       private Formatter buf;
 899       private SymbolFinder symFinder = createSymbolFinder();
 900       private long pc;
 901       private ImmutableOopMapSet oms;
 902       private CodeBlob blob;
 903       private NMethod nmethod;
 904 
 905       HTMLDisassembler(Formatter buf, CodeBlob blob) {
 906          this.buf = buf;
 907          this.blob = blob;
 908          if (blob != null) {
 909             if (blob instanceof NMethod) {
 910                nmethod = (NMethod)blob;
 911             }
 912             oms = blob.getOopMaps();
 913          }
 914       }
 915 
 916       public int getInstructionSize() {
 917          return  instrSize;
 918       }
 919 
 920       public void prologue() {
 921       }
 922 
 923       public void beginInstruction(long currentPc) {
 924          pc = currentPc;
 925 
 926          sun.jvm.hotspot.debugger.Address adr = longToAddress(pc);
 927          if (nmethod != null) {
 928             if (adr.equals(nmethod.getEntryPoint()))             print(&quot;[Entry Point]\n&quot;);
 929             if (adr.equals(nmethod.getVerifiedEntryPoint()))     print(&quot;[Verified Entry Point]\n&quot;);
 930             if (adr.equals(nmethod.exceptionBegin()))            print(&quot;[Exception Handler]\n&quot;);
 931             if (adr.equals(nmethod.stubBegin()) &amp;&amp;
 932                 !nmethod.stubBegin().equals(nmethod.stubEnd()))  print(&quot;[Stub Code]\n&quot;);
 933             // if (adr.equals(nmethod.constsBegin()))               print(&quot;[Constants]\n&quot;);
 934          }
 935 
 936          buf.append(adr.toString());
 937          buf.append(&#39;:&#39;);
 938          buf.append(tab);
 939       }
 940 
 941       public void printAddress(long address) {
 942          sun.jvm.hotspot.debugger.Address addr = longToAddress(address);
 943          if (VM.getVM().getCodeCache().contains(addr)) {
 944             buf.link(genPCHref(address), addr.toString());
 945          } else {
 946             buf.append(addr.toString());
 947          }
 948       }
 949 
 950       public void print(String s) {
 951          buf.append(s);
 952       }
 953 
 954       public void endInstruction(long endPc) {
 955          instrSize += endPc - pc;
 956          if (genHTML) buf.br();
 957 
 958          if (nmethod != null) {
 959             ScopeDesc sd = nmethod.scope_desc_in(pc, endPc);
 960             if (sd != null) {
 961                buf.br();
 962                buf.append(genSafepointInfo(nmethod, sd));
 963             }
 964          }
 965 
 966          if (oms != null) {
 967             long base = addressToLong(blob.codeBegin());
 968             for (int i = 0, imax = oms.getCount(); i &lt; imax; i++) {
 969                ImmutableOopMapPair pair = oms.getPairAt(i);
 970                long omspc = base + pair.getPC();
 971                if (omspc &gt; pc) {
 972                   if (omspc &lt;= endPc) {
 973                      buf.br();
 974                      buf.append(genOopMapInfo(oms.getMap(pair)));
 975                      // st.move_to(column);
 976                      // visitor.print(&quot;; &quot;);
 977                         // om.print_on(st);
 978                   }
 979                   break;
 980                }
 981             }
 982          }
 983          // follow each complete insn by a nice newline
 984          buf.br();
 985       }
 986 
 987       public void epilogue() {
 988       }
 989    };
 990 
 991    protected String genHTMLForRawDisassembly(sun.jvm.hotspot.debugger.Address addr,
 992                                              int size,
 993                                              String prevPCs) {
 994       try {
 995          final Formatter buf = new Formatter(genHTML);
 996          buf.genHTMLPrologue(&quot;Disassembly @ &quot; + addr);
 997 
 998          if (prevPCs != null &amp;&amp; genHTML) {
 999              buf.beginTag(&quot;p&quot;);
1000              buf.link(genMultPCHref(prevPCs), &quot;show previous code ..&quot;);
1001              buf.endTag(&quot;p&quot;);
1002          }
1003 
1004 
1005          buf.h3(&quot;Code&quot;);
1006          HTMLDisassembler visitor = new HTMLDisassembler(buf, null);
1007          Disassembler.decode(visitor, null, addr, addr.addOffsetTo(size));
1008 
1009          if (genHTML) buf.beginTag(&quot;p&quot;);
1010          Formatter tmpBuf = new Formatter(genHTML);
1011          long startPc = addressToLong(addr);
1012          tmpBuf.append(&quot;0x&quot;);
1013          tmpBuf.append(Long.toHexString(startPc + visitor.getInstructionSize()).toString());
1014          tmpBuf.append(&quot;,0x&quot;);
1015          tmpBuf.append(Long.toHexString(startPc));
1016          if (prevPCs != null) {
1017             tmpBuf.append(&#39;,&#39;);
1018             tmpBuf.append(prevPCs);
1019          }
1020          if (genHTML) {
1021              buf.link(genMultPCHref(tmpBuf.toString()), &quot;show more code ..&quot;);
1022              buf.endTag(&quot;p&quot;);
1023          }
1024 
1025          buf.genHTMLEpilogue();
1026          return buf.toString();
1027       } catch (Exception exp) {
1028          return genHTMLErrorMessage(exp);
1029       }
1030    }
1031 
1032    protected String genSafepointInfo(NMethod nm, ScopeDesc sd) {
1033        Formatter buf = new Formatter(genHTML);
1034        Formatter tabs = new Formatter(genHTML);
1035        tabs.append(tab + tab + tab); // Initial indent for debug info
1036 
1037        buf.beginTag(&quot;pre&quot;);
1038        genScope(buf, tabs, sd);
1039 
1040        // Reset indent for scalar replaced objects
1041        tabs = new Formatter(genHTML);
1042        tabs.append(tab + tab + tab); // Initial indent for debug info
1043 
1044        genScObjInfo(buf, tabs, sd);
1045        buf.endTag(&quot;pre&quot;);
1046 
1047        return buf.toString();
1048    }
1049 
1050     protected void genScope(Formatter buf, Formatter tabs, ScopeDesc sd) {
1051         if (sd == null) {
1052             return;
1053         }
1054 
1055         genScope(buf, tabs, sd.sender());
1056 
1057         buf.append(tabs);
1058         Method m = sd.getMethod();
1059         buf.append(genMethodAndKlassLink(m));
1060         int bci = sd.getBCI();
1061         buf.append(&quot; @ bci = &quot;);
1062         buf.append(Integer.toString(bci));
1063 
1064         int line = m.getLineNumberFromBCI(bci);
1065         if (line != -1) {
1066             buf.append(&quot;, line = &quot;);
1067             buf.append(Integer.toString(line));
1068         }
1069 
<a name="2" id="anc2"></a><span class="line-modified">1070         List&lt;ScopeValue&gt; locals = sd.getLocals();</span>
1071         if (locals != null) {
1072             buf.br();
1073             buf.append(tabs);
1074             buf.append(genHTMLForLocals(sd, locals));
1075         }
1076 
<a name="3" id="anc3"></a><span class="line-modified">1077         List&lt;ScopeValue&gt; expressions = sd.getExpressions();</span>
1078         if (expressions != null) {
1079             buf.br();
1080             buf.append(tabs);
1081             buf.append(genHTMLForExpressions(sd, expressions));
1082         }
1083 
<a name="4" id="anc4"></a><span class="line-modified">1084         List&lt;MonitorValue&gt; monitors = sd.getMonitors();</span>
1085         if (monitors != null) {
1086             buf.br();
1087             buf.append(tabs);
1088             buf.append(genHTMLForMonitors(sd, monitors));
1089         }
1090 
1091         buf.br();
1092         tabs.append(tab);
1093     }
1094 
1095     protected void genScObjInfo(Formatter buf, Formatter tabs, ScopeDesc sd) {
1096         if (sd == null) {
1097             return;
1098         }
1099 
<a name="5" id="anc5"></a><span class="line-modified">1100         List&lt;ObjectValue&gt; objects = sd.getObjects();</span>
1101         if (objects == null) {
1102             return;
1103         }
1104         int length = objects.size();
1105         for (int i = 0; i &lt; length; i++) {
1106             buf.append(tabs);
<a name="6" id="anc6"></a><span class="line-modified">1107             ObjectValue ov = objects.get(i);</span>
1108             buf.append(&quot;ScObj&quot; + i);
1109             ScopeValue sv = ov.getKlass();
1110             if (Assert.ASSERTS_ENABLED) {
1111                 Assert.that(sv.isConstantOop(), &quot;scalar replaced object klass must be constant oop&quot;);
1112             }
1113             ConstantOopReadValue klv = (ConstantOopReadValue)sv;
1114             OopHandle klHandle = klv.getValue();
1115             if (Assert.ASSERTS_ENABLED) {
1116                 Assert.that(klHandle != null, &quot;scalar replaced object klass must be not NULL&quot;);
1117             }
1118             Oop obj = VM.getVM().getObjectHeap().newOop(klHandle);
1119             // Obj is a Java mirror
1120             Klass klass = java_lang_Class.asKlass(obj);
1121             if (klass instanceof InstanceKlass) {
1122                 InstanceKlass kls = (InstanceKlass) klass;
1123                 buf.append(&quot; &quot; + kls.getName().asString() + &quot;={&quot;);
1124                 int flen = ov.fieldsSize();
1125 
1126                 U2Array klfields = kls.getFields();
1127                 int klen = (int) klfields.length();
1128                 int findex = 0;
1129                 for (int index = 0; index &lt; klen; index++) {
1130                     int accsFlags = kls.getFieldAccessFlags(index);
1131                     Symbol f_name = kls.getFieldName(index);
1132                     AccessFlags access = new AccessFlags(accsFlags);
1133                     if (!access.isStatic()) {
1134                         ScopeValue svf = ov.getFieldAt(findex++);
1135                         String    fstr = scopeValueAsString(sd, svf);
1136                         buf.append(&quot; [&quot; + f_name.asString() + &quot; :&quot;+ index + &quot;]=(#&quot; + fstr + &quot;)&quot;);
1137                     }
1138                 }
1139                 buf.append(&quot; }&quot;);
1140             } else {
1141                 buf.append(&quot; &quot;);
1142                 int flen = ov.fieldsSize();
1143                 if (klass instanceof TypeArrayKlass) {
1144                     TypeArrayKlass kls = (TypeArrayKlass) klass;
1145                     buf.append(kls.getElementTypeName() + &quot;[&quot; + flen + &quot;]&quot;);
1146                 } else if (klass instanceof ObjArrayKlass) {
1147                     ObjArrayKlass kls = (ObjArrayKlass) klass;
1148                     Klass elobj = kls.getBottomKlass();
1149                     if (elobj instanceof InstanceKlass) {
1150                         buf.append(elobj.getName().asString());
1151                     } else if (elobj instanceof TypeArrayKlass) {
1152                         TypeArrayKlass elkls = (TypeArrayKlass) elobj;
1153                         buf.append(elkls.getElementTypeName());
1154                     } else {
1155                         if (Assert.ASSERTS_ENABLED) {
1156                             Assert.that(false, &quot;unknown scalar replaced object klass!&quot;);
1157                         }
1158                     }
1159                     buf.append(&quot;[&quot; + flen + &quot;]&quot;);
1160                     int ndim = (int) kls.getDimension();
1161                     while (--ndim &gt; 0) {
1162                         buf.append(&quot;[]&quot;);
1163                     }
1164                 } else {
1165                     if (Assert.ASSERTS_ENABLED) {
1166                         Assert.that(false, &quot;unknown scalar replaced object klass!&quot;);
1167                     }
1168                 }
1169                 buf.append(&quot;={&quot;);
1170                 for (int findex = 0; findex &lt; flen; findex++) {
1171                     ScopeValue svf = ov.getFieldAt(findex);
1172                     String fstr = scopeValueAsString(sd, svf);
1173                     buf.append(&quot; [&quot; + findex + &quot;]=(#&quot; + fstr + &quot;)&quot;);
1174                 }
1175                 buf.append(&quot; }&quot;);
1176             }
1177             buf.br();
1178         }
1179     }
1180 
1181    protected String genHTMLForOopMap(ImmutableOopMap map) {
1182       final int stack0 = VMRegImpl.getStack0().getValue();
1183       Formatter buf = new Formatter(genHTML);
1184 
1185       final class OopMapValueIterator {
1186          final Formatter iterate(OopMapStream oms, String type, boolean printContentReg) {
1187             Formatter tmpBuf = new Formatter(genHTML);
1188             boolean found = false;
1189             tmpBuf.beginTag(&quot;tr&quot;);
1190             tmpBuf.beginTag(&quot;td&quot;);
1191             tmpBuf.append(type);
1192             for (; ! oms.isDone(); oms.next()) {
1193                OopMapValue omv = oms.getCurrent();
1194                if (omv == null) {
1195                   continue;
1196                }
1197                found = true;
1198                VMReg vmReg = omv.getReg();
1199                int reg = vmReg.getValue();
1200                if (reg &lt; stack0) {
1201                   tmpBuf.append(VMRegImpl.getRegisterName(reg));
1202                } else {
1203                   tmpBuf.append(&#39;[&#39;);
1204                   tmpBuf.append(Integer.toString((reg - stack0) * 4));
1205                   tmpBuf.append(&#39;]&#39;);
1206                }
1207                if (printContentReg) {
1208                   tmpBuf.append(&quot; = &quot;);
1209                   VMReg vmContentReg = omv.getContentReg();
1210                   int contentReg = vmContentReg.getValue();
1211                   if (contentReg &lt; stack0) {
1212                      tmpBuf.append(VMRegImpl.getRegisterName(contentReg));
1213                   } else {
1214                      tmpBuf.append(&#39;[&#39;);
1215                      tmpBuf.append(Integer.toString((contentReg - stack0) * 4));
1216                      tmpBuf.append(&#39;]&#39;);
1217                   }
1218                }
1219                tmpBuf.append(spaces);
1220             }
1221             tmpBuf.endTag(&quot;td&quot;);
1222             tmpBuf.endTag(&quot;tr&quot;);
1223             return found ? tmpBuf : new Formatter(genHTML);
1224          }
1225       }
1226 
1227       buf.beginTable(0);
1228 
1229       OopMapValueIterator omvIterator = new OopMapValueIterator();
1230       OopMapStream oms = new OopMapStream(map, OopMapValue.OopTypes.OOP_VALUE);
1231       buf.append(omvIterator.iterate(oms, &quot;Oops:&quot;, false));
1232 
1233       oms = new OopMapStream(map, OopMapValue.OopTypes.NARROWOOP_VALUE);
1234       buf.append(omvIterator.iterate(oms, &quot;NarrowOops:&quot;, false));
1235 
1236       oms = new OopMapStream(map, OopMapValue.OopTypes.CALLEE_SAVED_VALUE);
1237       buf.append(omvIterator.iterate(oms, &quot;Callee saved:&quot;,  true));
1238 
1239       oms = new OopMapStream(map, OopMapValue.OopTypes.DERIVED_OOP_VALUE);
1240       buf.append(omvIterator.iterate(oms, &quot;Derived oops:&quot;, true));
1241 
1242       buf.endTag(&quot;table&quot;);
1243       return buf.toString();
1244    }
1245 
1246 
1247    protected String genOopMapInfo(NMethod nmethod, PCDesc pcDesc) {
1248       ImmutableOopMapSet mapSet = nmethod.getOopMaps();
1249       if (mapSet == null || (mapSet.getCount() &lt;= 0))
1250         return &quot;&quot;;
1251       int pcOffset = pcDesc.getPCOffset();
1252       ImmutableOopMap map = mapSet.findMapAtOffset(pcOffset, VM.getVM().isDebugging());
1253       if (map == null) {
1254          throw new IllegalArgumentException(&quot;no oopmap at safepoint!&quot;);
1255       }
1256 
1257       return genOopMapInfo(map);
1258    }
1259 
1260    protected String genOopMapInfo(ImmutableOopMap map) {
1261      Formatter buf = new Formatter(genHTML);
1262      buf.beginTag(&quot;pre&quot;);
1263      buf.append(&quot;OopMap: &quot;);
1264      buf.br();
1265      buf.append(genHTMLForOopMap(map));
1266      buf.endTag(&quot;pre&quot;);
1267 
1268      return buf.toString();
1269    }
1270 
1271    protected String locationAsString(Location loc) {
1272       Formatter buf = new Formatter(genHTML);
1273       if (loc.isIllegal()) {
1274          buf.append(&quot;illegal&quot;);
1275       } else {
1276          Location.Where  w  = loc.getWhere();
1277          Location.Type type = loc.getType();
1278 
1279          if (w == Location.Where.ON_STACK) {
1280             buf.append(&quot;stack[&quot; + loc.getStackOffset() + &quot;]&quot;);
1281          } else if (w == Location.Where.IN_REGISTER) {
1282             boolean isFloat = (type == Location.Type.FLOAT_IN_DBL ||
1283                                type == Location.Type.DBL);
1284             int regNum = loc.getRegisterNumber();
1285             VMReg vmReg = new VMReg(regNum);
1286             buf.append(VMRegImpl.getRegisterName(vmReg.getValue()));
1287          }
1288 
1289          buf.append(&quot;, &quot;);
1290          if (type == Location.Type.NORMAL) {
1291             buf.append(&quot;normal&quot;);
1292          } else if (type == Location.Type.OOP) {
1293             buf.append(&quot;oop&quot;);
1294          } else if (type == Location.Type.NARROWOOP) {
1295             buf.append(&quot;narrowoop&quot;);
1296          } else if (type == Location.Type.INT_IN_LONG) {
1297             buf.append(&quot;int&quot;);
1298          } else if (type == Location.Type.LNG) {
1299             buf.append(&quot;long&quot;);
1300          } else if (type == Location.Type.FLOAT_IN_DBL) {
1301             buf.append(&quot;float&quot;);
1302          } else if (type == Location.Type.DBL) {
1303             buf.append(&quot;double&quot;);
1304          } else if (type == Location.Type.ADDR) {
1305             buf.append(&quot;address&quot;);
1306          } else if (type == Location.Type.INVALID) {
1307             buf.append(&quot;invalid&quot;);
1308          }
1309       }
1310       return buf.toString();
1311    }
1312 
1313    private String scopeValueAsString(ScopeDesc sd, ScopeValue sv) {
1314       Formatter buf = new Formatter(genHTML);
1315       if (sv.isConstantInt()) {
1316          buf.append(&quot;int &quot;);
1317          ConstantIntValue intValue = (ConstantIntValue) sv;
1318          buf.append(Integer.toString(intValue.getValue()));
1319       } else if (sv.isConstantLong()) {
1320          buf.append(&quot;long &quot;);
1321          ConstantLongValue longValue = (ConstantLongValue) sv;
1322          buf.append(Long.toString(longValue.getValue()));
1323          buf.append(&quot;L&quot;);
1324       } else if (sv.isConstantDouble()) {
1325          buf.append(&quot;double &quot;);
1326          ConstantDoubleValue dblValue = (ConstantDoubleValue) sv;
1327          buf.append(Double.toString(dblValue.getValue()));
1328          buf.append(&quot;D&quot;);
1329       } else if (sv.isConstantOop()) {
1330          buf.append(&quot;oop &quot;);
1331          ConstantOopReadValue oopValue = (ConstantOopReadValue) sv;
1332          OopHandle oopHandle = oopValue.getValue();
1333          if (oopHandle != null) {
1334             buf.append(oopHandle.toString());
1335          } else {
1336             buf.append(&quot;null&quot;);
1337          }
1338       } else if (sv.isLocation()) {
1339          LocationValue lvalue = (LocationValue) sv;
1340          Location loc = lvalue.getLocation();
1341          if (loc != null) {
1342             buf.append(locationAsString(loc));
1343          } else {
1344             buf.append(&quot;null&quot;);
1345          }
1346       } else if (sv.isObject()) {
1347          ObjectValue ov = (ObjectValue)sv;
1348          buf.append(&quot;#ScObj&quot; + sd.getObjects().indexOf(ov));
1349       } else {
1350          buf.append(&quot;unknown scope value &quot; + sv);
1351       }
1352       return buf.toString();
1353    }
1354 
<a name="7" id="anc7"></a><span class="line-modified">1355    protected String genHTMLForScopeValues(ScopeDesc sd, boolean locals, List&lt;ScopeValue&gt; values) {</span>
1356       int length = values.size();
1357       Formatter buf = new Formatter(genHTML);
1358       buf.append(locals? &quot;locals &quot; : &quot;expressions &quot;);
1359       for (int i = 0; i &lt; length; i++) {
<a name="8" id="anc8"></a><span class="line-modified">1360          ScopeValue sv = values.get(i);</span>
1361          if (sv == null) {
1362             continue;
1363          }
1364          buf.append(&#39;(&#39;);
1365          if (locals) {
1366             Symbol name = sd.getMethod().getLocalVariableName(sd.getBCI(), i);
1367             if (name != null) {
1368                buf.append(&quot;&#39;&quot;);
1369                buf.append(name.asString());
1370                buf.append(&#39;\&#39;&#39;);
1371             } else {
1372                buf.append(&quot;[&quot;);
1373                buf.append(Integer.toString(i));
1374                buf.append(&#39;]&#39;);
1375             }
1376          } else {
1377             buf.append(&quot;[&quot;);
1378             buf.append(Integer.toString(i));
1379             buf.append(&#39;]&#39;);
1380          }
1381 
1382          buf.append(&quot;, &quot;);
1383          buf.append(scopeValueAsString(sd, sv));
1384          buf.append(&quot;) &quot;);
1385       }
1386 
1387       return buf.toString();
1388    }
1389 
<a name="9" id="anc9"></a><span class="line-modified">1390    protected String genHTMLForLocals(ScopeDesc sd, List&lt;ScopeValue&gt; locals) {</span>
1391       return genHTMLForScopeValues(sd, true, locals);
1392    }
1393 
<a name="10" id="anc10"></a><span class="line-modified">1394    protected String genHTMLForExpressions(ScopeDesc sd, List&lt;ScopeValue&gt; expressions) {</span>
1395       return genHTMLForScopeValues(sd, false, expressions);
1396    }
1397 
<a name="11" id="anc11"></a><span class="line-modified">1398    protected String genHTMLForMonitors(ScopeDesc sd, List&lt;MonitorValue&gt; monitors) {</span>
1399       int length = monitors.size();
1400       Formatter buf = new Formatter(genHTML);
1401       buf.append(&quot;monitors &quot;);
1402       for (int i = 0; i &lt; length; i++) {
<a name="12" id="anc12"></a><span class="line-modified">1403          MonitorValue mv = monitors.get(i);</span>
1404          if (mv == null) {
1405             continue;
1406          }
1407          buf.append(&quot;(owner = &quot;);
1408          ScopeValue owner = mv.owner();
1409          if (owner != null) {
1410             buf.append(scopeValueAsString(sd, owner));
1411          } else {
1412             buf.append(&quot;null&quot;);
1413          }
1414          buf.append(&quot;, lock = &quot;);
1415 
1416          Location loc = mv.basicLock();
1417          if (loc != null) {
1418             buf.append(locationAsString(loc));
1419          } else {
1420             buf.append(&quot;null&quot;);
1421          }
1422          buf.append(&quot;) &quot;);
1423       }
1424       return buf.toString();
1425    }
1426 
1427    public String genHTML(final NMethod nmethod) {
1428       try {
1429          final Formatter buf = new Formatter(genHTML);
1430          buf.genHTMLPrologue(genNMethodTitle(nmethod));
1431          buf.h3(&quot;Method&quot;);
1432          buf.append(genMethodAndKlassLink(nmethod.getMethod()));
1433 
1434          buf.h3(&quot;Compiled Code&quot;);
1435          Disassembler.decode(new HTMLDisassembler(buf, nmethod), nmethod);
1436          buf.genHTMLEpilogue();
1437          return buf.toString();
1438       } catch (Exception exp) {
1439          return genHTMLErrorMessage(exp);
1440       }
1441    }
1442 
1443   public String genHTML(final CodeBlob blob) {
1444       try {
1445          final Formatter buf = new Formatter(genHTML);
1446          buf.genHTMLPrologue(genCodeBlobTitle(blob));
1447          buf.h3(&quot;CodeBlob&quot;);
1448 
1449          buf.h3(&quot;Compiled Code&quot;);
1450          Disassembler.decode(new HTMLDisassembler(buf, blob), blob);
1451 
1452          buf.genHTMLEpilogue();
1453          return buf.toString();
1454       } catch (Exception exp) {
1455          return genHTMLErrorMessage(exp);
1456       }
1457    }
1458 
1459    protected String genInterpreterCodeletTitle(InterpreterCodelet codelet) {
1460       Formatter buf = new Formatter(genHTML);
1461       buf.append(&quot;Interpreter codelet [&quot;);
1462       buf.append(codelet.codeBegin().toString());
1463       buf.append(&#39;,&#39;);
1464       buf.append(codelet.codeEnd().toString());
1465       buf.append(&quot;) - &quot;);
1466       buf.append(codelet.getDescription());
1467       return buf.toString();
1468    }
1469 
1470    protected String genInterpreterCodeletLinkPageHref(StubQueue stubq) {
1471       return genBaseHref() + &quot;interp_codelets&quot;;
1472    }
1473 
1474    public String genInterpreterCodeletLinksPage() {
1475       Formatter buf = new Formatter(genHTML);
1476       buf.genHTMLPrologue(&quot;Interpreter Codelets&quot;);
1477       buf.beginTag(&quot;ul&quot;);
1478 
1479       Interpreter interp = VM.getVM().getInterpreter();
1480       StubQueue code = interp.getCode();
1481       InterpreterCodelet stub = (InterpreterCodelet) code.getFirst();
1482       while (stub != null) {
1483          buf.beginTag(&quot;li&quot;);
1484          sun.jvm.hotspot.debugger.Address addr = stub.codeBegin();
1485          buf.link(genPCHref(addressToLong(addr)), stub.getDescription() + &quot; @&quot; + addr);
1486          buf.endTag(&quot;li&quot;);
1487          stub = (InterpreterCodelet) code.getNext(stub);
1488       }
1489 
1490       buf.endTag(&quot;ul&quot;);
1491       buf.genHTMLEpilogue();
1492       return buf.toString();
1493    }
1494 
1495    public String genHTML(InterpreterCodelet codelet) {
1496       Formatter buf = new Formatter(genHTML);
1497       buf.genHTMLPrologue(genInterpreterCodeletTitle(codelet));
1498       Interpreter interp = VM.getVM().getInterpreter();
1499       StubQueue stubq = interp.getCode();
1500 
1501       if (genHTML) {
1502          buf.beginTag(&quot;h3&quot;);
1503          buf.link(genInterpreterCodeletLinkPageHref(stubq), &quot;View links for all codelets&quot;);
1504          buf.endTag(&quot;h3&quot;);
1505          buf.br();
1506       }
1507 
1508       Stub prev = stubq.getPrev(codelet);
1509       if (prev != null) {
1510          if (genHTML) {
1511             buf.beginTag(&quot;h3&quot;);
1512             buf.link(genPCHref(addressToLong(prev.codeBegin())), &quot;View Previous Codelet&quot;);
1513             buf.endTag(&quot;h3&quot;);
1514             buf.br();
1515          } else {
1516             buf.h3(&quot;Previous Codelet = 0x&quot; + Long.toHexString(addressToLong(prev.codeBegin())));
1517          }
1518       }
1519 
1520       buf.h3(&quot;Code&quot;);
1521       Disassembler.decode(new HTMLDisassembler(buf, null), null,
1522                           codelet.codeBegin(), codelet.codeEnd());
1523 
1524       Stub next = stubq.getNext(codelet);
1525       if (next != null) {
1526          if (genHTML) {
1527             buf.beginTag(&quot;h3&quot;);
1528             buf.link(genPCHref(addressToLong(next.codeBegin())), &quot;View Next Codelet&quot;);
1529             buf.endTag(&quot;h3&quot;);
1530          } else {
1531             buf.h3(&quot;Next Codelet = 0x&quot; + Long.toHexString(addressToLong(next.codeBegin())));
1532          }
1533       }
1534 
1535       buf.genHTMLEpilogue();
1536       return buf.toString();
1537    }
1538 
1539    protected String genDumpKlassesTitle(InstanceKlass[] klasses) {
1540       return (klasses.length == 1) ? &quot;Create .class for this class&quot;
1541                                    : &quot;Create .class for all classes&quot;;
1542    }
1543 
1544    protected String genDumpKlassesHref(InstanceKlass[] klasses) {
1545       StringBuffer buf = new StringBuffer(genBaseHref());
1546       buf.append(&quot;jcore_multiple=&quot;);
1547       for (int k = 0; k &lt; klasses.length; k++) {
1548          buf.append(klasses[k].getAddress().toString());
1549          buf.append(&#39;,&#39;);
1550       }
1551       return buf.toString();
1552    }
1553 
1554    protected String genDumpKlassesLink(InstanceKlass[] klasses) {
1555       if (!genHTML) return &quot;&quot;;
1556 
1557       Formatter buf = new Formatter(genHTML);
1558       buf.link(genDumpKlassesHref(klasses), genDumpKlassesTitle(klasses));
1559       return buf.toString();
1560    }
1561 
1562    public String genHTMLForKlassNames(InstanceKlass[] klasses) {
1563       try {
1564          Formatter buf = new Formatter(genHTML);
1565          buf.genHTMLPrologue();
1566          buf.h3(genDumpKlassesLink(klasses));
1567 
1568          buf.append(genHTMLListForKlassNames(klasses));
1569          buf.genHTMLEpilogue();
1570          return buf.toString();
1571       } catch (Exception exp) {
1572          return genHTMLErrorMessage(exp);
1573       }
1574    }
1575 
1576    protected String genHTMLListForKlassNames(InstanceKlass[] klasses) {
1577       final Formatter buf = new Formatter(genHTML);
1578       buf.beginTable(0);
1579       for (int i = 0; i &lt; klasses.length; i++) {
1580          InstanceKlass ik = klasses[i];
1581          buf.beginTag(&quot;tr&quot;);
1582          buf.cell(genKlassLink(ik));
1583          buf.endTag(&quot;tr&quot;);
1584       }
1585 
1586       buf.endTable();
1587       return buf.toString();
1588    }
1589 
1590    public String genHTMLForMethodNames(InstanceKlass klass) {
1591       try {
1592          Formatter buf = new Formatter(genHTML);
1593          buf.genHTMLPrologue();
1594          buf.append(genHTMLListForMethods(klass));
1595          buf.genHTMLEpilogue();
1596          return buf.toString();
1597       } catch (Exception exp) {
1598          return genHTMLErrorMessage(exp);
1599       }
1600    }
1601 
1602    protected String genHTMLListForMethods(InstanceKlass klass) {
1603       Formatter buf = new Formatter(genHTML);
1604       MethodArray methods = klass.getMethods();
1605       int numMethods = methods.length();
1606       if (numMethods != 0) {
1607          buf.h3(&quot;Methods&quot;);
1608          buf.beginTag(&quot;ul&quot;);
1609          for (int m = 0; m &lt; numMethods; m++) {
1610             Method mtd = methods.at(m);
1611             buf.li(genMethodLink(mtd) + &quot;;&quot;);
1612          }
1613          buf.endTag(&quot;ul&quot;);
1614       }
1615       return buf.toString();
1616    }
1617 
1618    protected String genHTMLListForInterfaces(InstanceKlass klass) {
1619       try {
1620          Formatter buf = new Formatter(genHTML);
1621          KlassArray interfaces = klass.getLocalInterfaces();
1622          int numInterfaces = interfaces.length();
1623          if (numInterfaces != 0) {
1624             buf.h3(&quot;Interfaces&quot;);
1625             buf.beginTag(&quot;ul&quot;);
1626             for (int i = 0; i &lt; numInterfaces; i++) {
1627                InstanceKlass inf = (InstanceKlass) interfaces.getAt(i);
1628                buf.li(genKlassLink(inf));
1629             }
1630             buf.endTag(&quot;ul&quot;);
1631          }
1632          return buf.toString();
1633       } catch (Exception exp) {
1634          return genHTMLErrorMessage(exp);
1635       }
1636    }
1637 
1638    protected String genFieldModifierString(AccessFlags acc) {
1639       Formatter buf = new Formatter(genHTML);
1640       if (acc.isPrivate()) {
1641          buf.append(&quot;private &quot;);
1642       } else if (acc.isProtected()) {
1643          buf.append(&quot;protected &quot;);
1644       } else if (acc.isPublic()) {
1645          buf.append(&quot;public &quot;);
1646       }
1647 
1648       if (acc.isStatic()) {
1649          buf.append(&quot;static &quot;);
1650       }
1651 
1652       if (acc.isFinal()) {
1653          buf.append(&quot;final &quot;);
1654       }
1655       if (acc.isVolatile()) {
1656          buf.append(&quot;volatile &quot;);
1657       }
1658       if (acc.isTransient()) {
1659          buf.append(&quot;transient &quot;);
1660       }
1661 
1662       // javac generated flags
1663       if (acc.isSynthetic()) {
1664          buf.append(&quot;[synthetic] &quot;);
1665       }
1666       return buf.toString();
1667    }
1668 
1669    public String genHTMLForFieldNames(InstanceKlass klass) {
1670       try {
1671          Formatter buf = new Formatter(genHTML);
1672          buf.genHTMLPrologue();
1673          buf.append(genHTMLListForFields(klass));
1674          buf.genHTMLEpilogue();
1675          return buf.toString();
1676       } catch (Exception exp) {
1677          return genHTMLErrorMessage(exp);
1678       }
1679    }
1680 
1681    protected String genHTMLListForFields(InstanceKlass klass) {
1682       Formatter buf = new Formatter(genHTML);
1683       U2Array fields = klass.getFields();
1684       int numFields = klass.getAllFieldsCount();
1685       if (numFields != 0) {
1686          buf.h3(&quot;Fields&quot;);
1687          buf.beginList();
1688          for (int f = 0; f &lt; numFields; f++) {
1689            sun.jvm.hotspot.oops.Field field = klass.getFieldByIndex(f);
1690            String f_name = ((NamedFieldIdentifier)field.getID()).getName();
1691            Symbol f_sig  = field.getSignature();
1692            Symbol f_genSig = field.getGenericSignature();
1693            AccessFlags acc = field.getAccessFlagsObj();
1694 
1695            buf.beginListItem();
1696            buf.append(genFieldModifierString(acc));
1697            buf.append(&#39; &#39;);
1698            Formatter sigBuf = new Formatter(genHTML);
1699            new SignatureConverter(f_sig, sigBuf.getBuffer()).dispatchField();
1700            buf.append(sigBuf.toString().replace(&#39;/&#39;, &#39;.&#39;));
1701            buf.append(&#39; &#39;);
1702            buf.append(f_name);
1703            buf.append(&#39;;&#39;);
1704            // is it generic?
1705            if (f_genSig != null) {
1706               buf.append(&quot; [signature &quot;);
1707               buf.append(escapeHTMLSpecialChars(f_genSig.asString()));
1708               buf.append(&quot;] &quot;);
1709            }
1710            buf.append(&quot; (offset = &quot; + field.getOffset() + &quot;)&quot;);
1711            buf.endListItem();
1712          }
1713          buf.endList();
1714       }
1715       return buf.toString();
1716    }
1717 
1718    protected String genKlassHierarchyHref(InstanceKlass klass) {
1719       return genBaseHref() + &quot;hierarchy=&quot; + klass.getAddress();
1720    }
1721 
1722    protected String genKlassHierarchyTitle(InstanceKlass klass) {
1723       Formatter buf = new Formatter(genHTML);
1724       buf.append(&quot;Class Hierarchy of &quot;);
1725       buf.append(genKlassTitle(klass));
1726       return buf.toString();
1727    }
1728 
1729    protected String genKlassHierarchyLink(InstanceKlass klass) {
1730       Formatter buf = new Formatter(genHTML);
1731       buf.link(genKlassHierarchyHref(klass), genKlassHierarchyTitle(klass));
1732       return buf.toString();
1733    }
1734 
1735    protected String genHTMLListForSubKlasses(InstanceKlass klass) {
1736       Formatter buf = new Formatter(genHTML);
1737       Klass subklass = klass.getSubklassKlass();
1738       if (subklass != null) {
1739          buf.beginList();
1740          while (subklass != null) {
1741             if (subklass instanceof InstanceKlass) {
1742                buf.li(genKlassLink((InstanceKlass)subklass));
1743             }
1744             subklass = subklass.getNextSiblingKlass();
1745          }
1746          buf.endList();
1747       }
1748       return buf.toString();
1749    }
1750 
1751    public String genHTMLForKlassHierarchy(InstanceKlass klass) {
1752       Formatter buf = new Formatter(genHTML);
1753       buf.genHTMLPrologue(genKlassHierarchyTitle(klass));
1754 
1755 
1756       buf.beginTag(&quot;pre&quot;);
1757       buf.append(genKlassLink(klass));
1758       buf.br();
1759       StringBuffer tabs = new StringBuffer(tab);
1760       InstanceKlass superKlass = klass;
1761       while ( (superKlass = (InstanceKlass) superKlass.getSuper()) != null ) {
1762          buf.append(tabs);
1763          buf.append(genKlassLink(superKlass));
1764          tabs.append(tab);
1765          buf.br();
1766       }
1767       buf.endTag(&quot;pre&quot;);
1768 
1769       // generate subklass list
1770       Klass subklass = klass.getSubklassKlass();
1771       if (subklass != null) {
1772          buf.h3(&quot;Direct Subclasses&quot;);
1773          buf.append(genHTMLListForSubKlasses(klass));
1774       }
1775 
1776       buf.genHTMLEpilogue();
1777       return buf.toString();
1778    }
1779 
1780    protected String genDumpKlassHref(InstanceKlass klass) {
1781       return genBaseHref() + &quot;jcore=&quot; + klass.getAddress();
1782    }
1783 
1784    protected String genDumpKlassLink(InstanceKlass klass) {
1785       if (!genHTML) return &quot;&quot;;
1786 
1787       Formatter buf = new Formatter(genHTML);
1788       buf.link(genDumpKlassHref(klass), &quot;Create .class File&quot;);
1789       return buf.toString();
1790    }
1791 
1792    public String genHTML(InstanceKlass klass) {
1793       Formatter buf = new Formatter(genHTML);
1794       buf.genHTMLPrologue(genKlassTitle(klass));
1795       InstanceKlass superKlass = (InstanceKlass) klass.getSuper();
1796 
1797       if (genHTML) {
1798           // super class tree and subclass list
1799           buf.beginTag(&quot;h3&quot;);
1800           buf.link(genKlassHierarchyHref(klass), &quot;View Class Hierarchy&quot;);
1801           buf.endTag(&quot;h3&quot;);
1802       }
1803 
1804       // jcore - create .class link
1805       buf.h3(genDumpKlassLink(klass));
1806 
1807       // super class
1808       if (superKlass != null) {
1809          buf.h3(&quot;Super Class&quot;);
1810          buf.append(genKlassLink(superKlass));
1811       }
1812 
1813       // interfaces
1814       buf.append(genHTMLListForInterfaces(klass));
1815 
1816       // fields
1817       buf.append(genHTMLListForFields(klass));
1818 
1819       // methods
1820       buf.append(genHTMLListForMethods(klass));
1821 
1822       // constant pool link
1823       buf.h3(&quot;Constant Pool&quot;);
1824       buf.append(genConstantPoolLink(klass.getConstants()));
1825 
1826       buf.genHTMLEpilogue();
1827       return buf.toString();
1828    }
1829 
1830    protected sun.jvm.hotspot.debugger.Address parseAddress(String address) {
1831       VM vm = VM.getVM();
1832       sun.jvm.hotspot.debugger.Address addr = vm.getDebugger().parseAddress(address);
1833       return addr;
1834    }
1835 
1836    protected long addressToLong(sun.jvm.hotspot.debugger.Address addr) {
1837       return VM.getVM().getDebugger().getAddressValue(addr);
1838    }
1839 
1840    protected sun.jvm.hotspot.debugger.Address longToAddress(long addr) {
1841       return parseAddress(&quot;0x&quot; + Long.toHexString(addr));
1842    }
1843 
1844    protected Oop getOopAtAddress(sun.jvm.hotspot.debugger.Address addr) {
1845       OopHandle oopHandle = addr.addOffsetToAsOopHandle(0);
1846       return VM.getVM().getObjectHeap().newOop(oopHandle);
1847    }
1848 
1849    protected Oop getOopAtAddress(String address) {
1850       sun.jvm.hotspot.debugger.Address addr = parseAddress(address);
1851       return getOopAtAddress(addr);
1852    }
1853 
1854    protected Klass getKlassAtAddress(String address) {
1855       sun.jvm.hotspot.debugger.Address addr = parseAddress(address);
1856       return (Klass)Metadata.instantiateWrapperFor(addr);
1857    }
1858 
1859    protected Method getMethodAtAddress(String address) {
1860       sun.jvm.hotspot.debugger.Address addr = parseAddress(address);
1861       return (Method)Metadata.instantiateWrapperFor(addr);
1862    }
1863 
1864    protected ConstantPool getConstantPoolAtAddress(String address) {
1865       sun.jvm.hotspot.debugger.Address addr = parseAddress(address);
1866       return (ConstantPool) Metadata.instantiateWrapperFor(addr);
1867    }
1868 
1869    private void dumpKlass(InstanceKlass kls) throws IOException {
1870       String klassName = kls.getName().asString();
1871       klassName = klassName.replace(&#39;/&#39;, File.separatorChar);
1872       int index = klassName.lastIndexOf(File.separatorChar);
1873       File dir = null;
1874       if (index != -1) {
1875         String dirName = klassName.substring(0, index);
1876         dir =  new File(DUMP_KLASS_OUTPUT_DIR,  dirName);
1877       } else {
1878         dir = new File(DUMP_KLASS_OUTPUT_DIR);
1879       }
1880 
1881       dir.mkdirs();
1882       File f = new File(dir, klassName.substring(klassName.lastIndexOf(File.separatorChar) + 1)
1883                               + &quot;.class&quot;);
1884       f.createNewFile();
1885       FileOutputStream fis = new FileOutputStream(f);
1886       ClassWriter cw = new ClassWriter(kls, fis);
1887       cw.write();
1888    }
1889 
1890    public String genDumpKlass(InstanceKlass kls) {
1891       try {
1892          dumpKlass(kls);
1893          Formatter buf = new Formatter(genHTML);
1894          buf.genHTMLPrologue(genKlassTitle(kls));
1895          buf.append(&quot;.class created for &quot;);
1896          buf.append(genKlassLink(kls));
1897          buf.genHTMLEpilogue();
1898          return buf.toString();
1899       } catch(IOException exp) {
1900          return genHTMLErrorMessage(exp);
1901       }
1902    }
1903 
1904    protected String genJavaStackTraceTitle(JavaThread thread) {
1905       Formatter buf = new Formatter(genHTML);
1906       buf.append(&quot;Java Stack Trace for &quot;);
1907       buf.append(thread.getThreadName());
1908       return buf.toString();
1909    }
1910 
1911    public String genHTMLForJavaStackTrace(JavaThread thread) {
1912       Formatter buf = new Formatter(genHTML);
1913       buf.genHTMLPrologue(genJavaStackTraceTitle(thread));
1914 
1915       buf.append(&quot;Thread state = &quot;);
1916       buf.append(thread.getThreadState().toString());
1917       buf.br();
1918       buf.beginTag(&quot;pre&quot;);
1919       int count = 0;
1920       for (JavaVFrame vf = thread.getLastJavaVFrameDbg(); vf != null; vf = vf.javaSender()) {
1921          Method method = vf.getMethod();
1922          buf.append(&quot; - &quot;);
1923          buf.append(genMethodLink(method));
1924          buf.append(&quot; @bci = &quot; + vf.getBCI());
1925 
1926          int lineNumber = method.getLineNumberFromBCI(vf.getBCI());
1927          if (lineNumber != -1) {
1928             buf.append(&quot;, line = &quot;);
1929             buf.append(lineNumber);
1930          }
1931 
1932          sun.jvm.hotspot.debugger.Address pc = vf.getFrame().getPC();
1933          if (pc != null) {
1934             buf.append(&quot;, pc = &quot;);
1935             buf.link(genPCHref(addressToLong(pc)), pc.toString());
1936          }
1937 
1938          if (!method.isStatic() &amp;&amp; !method.isNative()) {
1939             try {
1940                OopHandle oopHandle = vf.getLocals().oopHandleAt(0);
1941 
1942                if (oopHandle != null) {
1943                   buf.append(&quot;, oop = &quot;);
1944                   buf.append(oopHandle.toString());
1945                }
1946             } catch (WrongTypeException e) {
1947               // Do nothing.
1948               // It might be caused by JIT&#39;ed inline frame.
1949             }
1950          }
1951 
1952          if (vf.isCompiledFrame()) {
1953             buf.append(&quot; (Compiled&quot;);
1954          }
1955          else if (vf.isInterpretedFrame()) {
1956             buf.append(&quot; (Interpreted&quot;);
1957          }
1958 
1959          if (vf.mayBeImpreciseDbg()) {
1960             buf.append(&quot;; information may be imprecise&quot;);
1961          }
1962          buf.append(&quot;)&quot;);
1963          buf.br();
1964 
1965          ByteArrayOutputStream bytes = new ByteArrayOutputStream();
1966          PrintStream printStream = new PrintStream(bytes);
1967          try (printStream) {
1968              vf.printLockInfo(printStream, count++);
1969              for (String line : bytes.toString().split(&quot;\n&quot;)) {
1970                  if (genHTML) {
1971                      line = line.replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;).replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;);
1972                  }
1973                  buf.append(line);
1974                  buf.br();
1975              }
1976          }
1977       }
1978 
1979       buf.endTag(&quot;pre&quot;);
1980       buf.genHTMLEpilogue();
1981       return buf.toString();
1982    }
1983 
1984    public String genHTMLForHyperlink(String href) {
1985       if (href.startsWith(&quot;klass=&quot;)) {
1986          href = href.substring(href.indexOf(&#39;=&#39;) + 1);
1987          Klass k = getKlassAtAddress(href);
1988          if (Assert.ASSERTS_ENABLED) {
1989             Assert.that(k instanceof InstanceKlass, &quot;class= href with improper InstanceKlass!&quot;);
1990          }
1991          return genHTML((InstanceKlass) k);
1992       } else if (href.startsWith(&quot;method=&quot;)) {
1993          href = href.substring(href.indexOf(&#39;=&#39;) + 1);
1994          Method obj = getMethodAtAddress(href);
1995          if (Assert.ASSERTS_ENABLED) {
1996             Assert.that(obj instanceof Method, &quot;method= href with improper Method!&quot;);
1997          }
1998          return genHTML(obj);
1999       } else if (href.startsWith(&quot;nmethod=&quot;)) {
2000          String addr = href.substring(href.indexOf(&#39;=&#39;) + 1);
2001          Object obj = VMObjectFactory.newObject(NMethod.class, parseAddress(addr));
2002          if (Assert.ASSERTS_ENABLED) {
2003             Assert.that(obj instanceof NMethod, &quot;nmethod= href with improper NMethod!&quot;);
2004          }
2005          return genHTML((NMethod) obj);
2006       } else if (href.startsWith(&quot;pc=&quot;)) {
2007          String address = href.substring(href.indexOf(&#39;=&#39;) + 1);
2008          return genHTML(parseAddress(address));
2009       } else if (href.startsWith(&quot;pc_multiple=&quot;)) {
2010          int indexOfComma = href.indexOf(&#39;,&#39;);
2011          if (indexOfComma == -1) {
2012             String firstPC = href.substring(href.indexOf(&#39;=&#39;) + 1);
2013             return genHTMLForRawDisassembly(parseAddress(firstPC), null);
2014          } else {
2015             String firstPC = href.substring(href.indexOf(&#39;=&#39;) + 1, indexOfComma);
2016             return genHTMLForRawDisassembly(parseAddress(firstPC), href.substring(indexOfComma + 1));
2017          }
2018       } else if (href.startsWith(&quot;interp_codelets&quot;)) {
2019          return genInterpreterCodeletLinksPage();
2020       } else if (href.startsWith(&quot;hierarchy=&quot;)) {
2021          href = href.substring(href.indexOf(&#39;=&#39;) + 1);
2022          Klass obj = getKlassAtAddress(href);
2023          if (Assert.ASSERTS_ENABLED) {
2024             Assert.that(obj instanceof InstanceKlass, &quot;class= href with improper InstanceKlass!&quot;);
2025          }
2026          return genHTMLForKlassHierarchy((InstanceKlass) obj);
2027       } else if (href.startsWith(&quot;cpool=&quot;)) {
2028          href = href.substring(href.indexOf(&#39;=&#39;) + 1);
2029          ConstantPool obj = getConstantPoolAtAddress(href);
2030          if (Assert.ASSERTS_ENABLED) {
2031             Assert.that(obj instanceof ConstantPool, &quot;cpool= href with improper ConstantPool!&quot;);
2032          }
2033          return genHTML(obj);
2034       } else if (href.startsWith(&quot;jcore=&quot;)) {
2035          href = href.substring(href.indexOf(&#39;=&#39;) + 1);
2036          Klass obj = getKlassAtAddress(href);
2037          if (Assert.ASSERTS_ENABLED) {
2038             Assert.that(obj instanceof InstanceKlass, &quot;jcore= href with improper InstanceKlass!&quot;);
2039          }
2040          return genDumpKlass((InstanceKlass) obj);
2041       } else if (href.startsWith(&quot;jcore_multiple=&quot;)) {
2042          href = href.substring(href.indexOf(&#39;=&#39;) + 1);
2043          Formatter buf = new Formatter(genHTML);
2044          buf.genHTMLPrologue();
2045          StringTokenizer st = new StringTokenizer(href, &quot;,&quot;);
2046          while (st.hasMoreTokens()) {
2047             Klass obj = getKlassAtAddress(st.nextToken());
2048             if (Assert.ASSERTS_ENABLED) {
2049                Assert.that(obj instanceof InstanceKlass, &quot;jcore_multiple= href with improper InstanceKlass!&quot;);
2050             }
2051 
2052             InstanceKlass kls = (InstanceKlass) obj;
2053             try {
2054                dumpKlass(kls);
2055                buf.append(&quot;.class created for &quot;);
2056                buf.append(genKlassLink(kls));
2057             } catch(Exception exp) {
2058                buf.bold(&quot;can&#39;t .class for &quot; +
2059                         genKlassTitle(kls) +
2060                         &quot; : &quot; +
2061                         exp.getMessage());
2062             }
2063             buf.br();
2064          }
2065 
2066          buf.genHTMLEpilogue();
2067          return buf.toString();
2068       } else {
2069          if (Assert.ASSERTS_ENABLED) {
2070             Assert.that(false, &quot;unknown href link!&quot;);
2071          }
2072          return null;
2073       }
2074    }
2075 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
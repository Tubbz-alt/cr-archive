<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/CommandProcessor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../com/sun/java/swing/ui/WizardDlg.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HSDB.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/CommandProcessor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 126,11 ***</span>
              return kls.getClassLoader() == null;
          }
      }
  
      public static class NonBootFilter implements ClassFilter {
<span class="line-modified">!         private HashMap emitted = new HashMap();</span>
          public boolean canInclude(InstanceKlass kls) {
              if (kls.getClassLoader() == null) return false;
              if (emitted.get(kls.getName()) != null) {
                  // Since multiple class loaders are being shoved
                  // together duplicate classes are a possibilty.  For
<span class="line-new-header">--- 126,11 ---</span>
              return kls.getClassLoader() == null;
          }
      }
  
      public static class NonBootFilter implements ClassFilter {
<span class="line-modified">!         private HashMap&lt;Symbol, InstanceKlass&gt; emitted = new HashMap&lt;&gt;();</span>
          public boolean canInclude(InstanceKlass kls) {
              if (kls.getClassLoader() == null) return false;
              if (emitted.get(kls.getName()) != null) {
                  // Since multiple class loaders are being shoved
                  // together duplicate classes are a possibilty.  For
</pre>
<hr />
<pre>
<span class="line-old-header">*** 154,22 ***</span>
                  return new String[0];
              }
              return t;
          }
  
<span class="line-modified">!         void add(String s, ArrayList t) {</span>
              if (s.length() &gt; 0) {
                  t.add(s);
              }
          }
  
          Tokens(String cmd) {
              input = cmd;
  
              // check for quoting
              int quote = cmd.indexOf(&#39;&quot;&#39;);
<span class="line-modified">!             ArrayList t = new ArrayList();</span>
              if (quote != -1) {
                  while (cmd.length() &gt; 0) {
                      if (quote != -1) {
                          int endquote = cmd.indexOf(&#39;&quot;&#39;, quote + 1);
                          if (endquote == -1) {
<span class="line-new-header">--- 154,22 ---</span>
                  return new String[0];
              }
              return t;
          }
  
<span class="line-modified">!         void add(String s, ArrayList&lt;String&gt; t) {</span>
              if (s.length() &gt; 0) {
                  t.add(s);
              }
          }
  
          Tokens(String cmd) {
              input = cmd;
  
              // check for quoting
              int quote = cmd.indexOf(&#39;&quot;&#39;);
<span class="line-modified">!             ArrayList&lt;String&gt; t = new ArrayList&lt;&gt;();</span>
              if (quote != -1) {
                  while (cmd.length() &gt; 0) {
                      if (quote != -1) {
                          int endquote = cmd.indexOf(&#39;&quot;&#39;, quote + 1);
                          if (endquote == -1) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 680,11 ***</span>
                  if (cmd != null) {
                      cmd.usage();
                  } else if (tokens == 0) {
                      out.println(&quot;Available commands:&quot;);
                      Object[] keys = commands.keySet().toArray();
<span class="line-modified">!                     Arrays.sort(keys, new Comparator() {</span>
                               public int compare(Object o1, Object o2) {
                                   return o1.toString().compareTo(o2.toString());
                               }
                            });
                      for (int i = 0; i &lt; keys.length; i++) {
<span class="line-new-header">--- 680,11 ---</span>
                  if (cmd != null) {
                      cmd.usage();
                  } else if (tokens == 0) {
                      out.println(&quot;Available commands:&quot;);
                      Object[] keys = commands.keySet().toArray();
<span class="line-modified">!                     Arrays.sort(keys, new Comparator&lt;&gt;() {</span>
                               public int compare(Object o1, Object o2) {
                                   return o1.toString().compareTo(o2.toString());
                               }
                            });
                      for (int i = 0; i &lt; keys.length; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 991,12 ***</span>
  
                  // Dump a copy of the type database in a form that can
                  // be read back.
                  Iterator i = agent.getTypeDataBase().getTypes();
                  // Make sure the types are emitted in an order than can be read back in
<span class="line-modified">!                 HashSet emitted = new HashSet();</span>
<span class="line-modified">!                 Stack pending = new Stack();</span>
                  while (i.hasNext()) {
                      Type n = (Type)i.next();
                      if (emitted.contains(n.getName())) {
                          continue;
                      }
<span class="line-new-header">--- 991,12 ---</span>
  
                  // Dump a copy of the type database in a form that can
                  // be read back.
                  Iterator i = agent.getTypeDataBase().getTypes();
                  // Make sure the types are emitted in an order than can be read back in
<span class="line-modified">!                 HashSet&lt;String&gt; emitted = new HashSet&lt;&gt;();</span>
<span class="line-modified">!                 Stack&lt;Type&gt; pending = new Stack&lt;&gt;();</span>
                  while (i.hasNext()) {
                      Type n = (Type)i.next();
                      if (emitted.contains(n.getName())) {
                          continue;
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1203,11 ***</span>
                          base = base.addOffsetTo(step);
                      }
                  }
              }
          },
<span class="line-modified">!         new Command(&quot;intConstant&quot;, &quot;intConstant [ name [ value ] ]&quot;, true) {</span>
              public void doit(Tokens t) {
                  if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 2) {
                      usage();
                      return;
                  }
<span class="line-new-header">--- 1203,11 ---</span>
                          base = base.addOffsetTo(step);
                      }
                  }
              }
          },
<span class="line-modified">!         new Command(&quot;intConstant&quot;, &quot;intConstant [ name [ value ] ]&quot;, false) {</span>
              public void doit(Tokens t) {
                  if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 2) {
                      usage();
                      return;
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1226,11 ***</span>
                      Integer value = Integer.valueOf(t.nextToken());
                      db.addIntConstant(name, value);
                  }
              }
          },
<span class="line-modified">!         new Command(&quot;longConstant&quot;, &quot;longConstant [ name [ value ] ]&quot;, true) {</span>
              public void doit(Tokens t) {
                  if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 2) {
                      usage();
                      return;
                  }
<span class="line-new-header">--- 1226,11 ---</span>
                      Integer value = Integer.valueOf(t.nextToken());
                      db.addIntConstant(name, value);
                  }
              }
          },
<span class="line-modified">!         new Command(&quot;longConstant&quot;, &quot;longConstant [ name [ value ] ]&quot;, false) {</span>
              public void doit(Tokens t) {
                  if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 2) {
                      usage();
                      return;
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1249,11 ***</span>
                      Long value = Long.valueOf(t.nextToken());
                      db.addLongConstant(name, value);
                  }
              }
          },
<span class="line-modified">!         new Command(&quot;field&quot;, &quot;field [ type [ name fieldtype isStatic offset address ] ]&quot;, true) {</span>
              public void doit(Tokens t) {
                  if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 6) {
                      usage();
                      return;
                  }
<span class="line-new-header">--- 1249,11 ---</span>
                      Long value = Long.valueOf(t.nextToken());
                      db.addLongConstant(name, value);
                  }
              }
          },
<span class="line-modified">!         new Command(&quot;field&quot;, &quot;field [ type [ name fieldtype isStatic offset address ] ]&quot;, false) {</span>
              public void doit(Tokens t) {
                  if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 6) {
                      usage();
                      return;
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1321,11 ***</span>
                  while (t.hasMoreTokens()) {
                      out.println(&quot;\&quot;&quot; + t.nextToken() + &quot;\&quot;&quot;);
                  }
              }
          },
<span class="line-modified">!         new Command(&quot;type&quot;, &quot;type [ type [ name super isOop isInteger isUnsigned size ] ]&quot;, true) {</span>
              public void doit(Tokens t) {
                  if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 6) {
                      usage();
                      return;
                  }
<span class="line-new-header">--- 1321,11 ---</span>
                  while (t.hasMoreTokens()) {
                      out.println(&quot;\&quot;&quot; + t.nextToken() + &quot;\&quot;&quot;);
                  }
              }
          },
<span class="line-modified">!         new Command(&quot;type&quot;, &quot;type [ type [ name super isOop isInteger isUnsigned size ] ]&quot;, false) {</span>
              public void doit(Tokens t) {
                  if (t.countTokens() != 1 &amp;&amp; t.countTokens() != 0 &amp;&amp; t.countTokens() != 6) {
                      usage();
                      return;
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1387,12 ***</span>
                      Type type = agent.getTypeDataBase().lookupType(t.nextToken());
                      dumpType(type);
                  } else {
                      Iterator i = agent.getTypeDataBase().getTypes();
                      // Make sure the types are emitted in an order than can be read back in
<span class="line-modified">!                     HashSet emitted = new HashSet();</span>
<span class="line-modified">!                     Stack pending = new Stack();</span>
                      while (i.hasNext()) {
                          Type n = (Type)i.next();
                          if (emitted.contains(n.getName())) {
                              continue;
                          }
<span class="line-new-header">--- 1387,12 ---</span>
                      Type type = agent.getTypeDataBase().lookupType(t.nextToken());
                      dumpType(type);
                  } else {
                      Iterator i = agent.getTypeDataBase().getTypes();
                      // Make sure the types are emitted in an order than can be read back in
<span class="line-modified">!                     HashSet&lt;String&gt; emitted = new HashSet&lt;&gt;();</span>
<span class="line-modified">!                     Stack&lt;Type&gt; pending = new Stack&lt;&gt;();</span>
                      while (i.hasNext()) {
                          Type n = (Type)i.next();
                          if (emitted.contains(n.getName())) {
                              continue;
                          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1638,11 ***</span>
          new Command(&quot;livenmethods&quot;, false) {
              public void doit(Tokens t) {
                  if (t.countTokens() != 0) {
                      usage();
                  } else {
<span class="line-modified">!                     ArrayList nmethods = new ArrayList();</span>
                      Threads threads = VM.getVM().getThreads();
                      HTMLGenerator gen = new HTMLGenerator(false);
                      for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
                          JavaThread thread = threads.getJavaThreadAt(i);
                          try {
<span class="line-new-header">--- 1638,11 ---</span>
          new Command(&quot;livenmethods&quot;, false) {
              public void doit(Tokens t) {
                  if (t.countTokens() != 0) {
                      usage();
                  } else {
<span class="line-modified">!                     ArrayList&lt;NMethod&gt; nmethods = new ArrayList&lt;&gt;();</span>
                      Threads threads = VM.getVM().getThreads();
                      HTMLGenerator gen = new HTMLGenerator(false);
                      for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {
                          JavaThread thread = threads.getJavaThreadAt(i);
                          try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1830,12 ***</span>
              }
          },
      };
  
      private boolean verboseExceptions = false;
<span class="line-modified">!     private ArrayList history = new ArrayList();</span>
<span class="line-modified">!     private HashMap commands = new HashMap();</span>
      private boolean doEcho = false;
  
      private Command findCommand(String key) {
          return (Command)commands.get(key);
      }
<span class="line-new-header">--- 1830,12 ---</span>
              }
          },
      };
  
      private boolean verboseExceptions = false;
<span class="line-modified">!     private ArrayList&lt;String&gt; history = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!     private HashMap&lt;String, Command&gt; commands = new HashMap&lt;&gt;();</span>
      private boolean doEcho = false;
  
      private Command findCommand(String key) {
          return (Command)commands.get(key);
      }
</pre>
<center><a href="../../../com/sun/java/swing/ui/WizardDlg.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HSDB.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/aarch64/AARCH64Frame.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2015, 2019, Red Hat Inc.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 package sun.jvm.hotspot.runtime.aarch64;
 27 
 28 import java.util.*;
 29 import sun.jvm.hotspot.code.*;
 30 import sun.jvm.hotspot.compiler.*;
 31 import sun.jvm.hotspot.debugger.*;
 32 import sun.jvm.hotspot.oops.*;
 33 import sun.jvm.hotspot.runtime.*;
 34 import sun.jvm.hotspot.types.*;
 35 import sun.jvm.hotspot.utilities.*;
<a name="2" id="anc2"></a><span class="line-added"> 36 import sun.jvm.hotspot.utilities.Observable;</span>
<span class="line-added"> 37 import sun.jvm.hotspot.utilities.Observer;</span>
 38 
 39 /** Specialization of and implementation of abstract methods of the
 40     Frame class for the aarch64 family of CPUs. */
 41 
 42 public class AARCH64Frame extends Frame {
 43   private static final boolean DEBUG;
 44   static {
 45     DEBUG = System.getProperty(&quot;sun.jvm.hotspot.runtime.aarch64.AARCH64Frame.DEBUG&quot;) != null;
 46   }
 47 
 48   // All frames
 49   private static final int LINK_OFFSET                =  0;
 50   private static final int RETURN_ADDR_OFFSET         =  1;
 51   private static final int SENDER_SP_OFFSET           =  2;
 52 
 53   // Interpreter frames
 54   private static final int INTERPRETER_FRAME_SENDER_SP_OFFSET = -1;
 55   private static final int INTERPRETER_FRAME_LAST_SP_OFFSET   = INTERPRETER_FRAME_SENDER_SP_OFFSET - 1;
 56   private static final int INTERPRETER_FRAME_METHOD_OFFSET    = INTERPRETER_FRAME_LAST_SP_OFFSET - 1;
 57   private static       int INTERPRETER_FRAME_MDX_OFFSET;         // Non-core builds only
 58   private static       int INTERPRETER_FRAME_PADDING_OFFSET;
 59   private static       int INTERPRETER_FRAME_MIRROR_OFFSET;
 60   private static       int INTERPRETER_FRAME_CACHE_OFFSET;
 61   private static       int INTERPRETER_FRAME_LOCALS_OFFSET;
 62   private static       int INTERPRETER_FRAME_BCX_OFFSET;
 63   private static       int INTERPRETER_FRAME_INITIAL_SP_OFFSET;
 64   private static       int INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET;
 65   private static       int INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET;
 66 
 67   // Entry frames
 68   private static       int ENTRY_FRAME_CALL_WRAPPER_OFFSET = -8;
 69 
 70   // Native frames
 71   private static final int NATIVE_FRAME_INITIAL_PARAM_OFFSET =  2;
 72 
 73   private static VMReg fp = new VMReg(29);
 74 
 75   static {
 76     VM.registerVMInitializedObserver(new Observer() {
 77         public void update(Observable o, Object data) {
 78           initialize(VM.getVM().getTypeDataBase());
 79         }
 80       });
 81   }
 82 
 83   private static synchronized void initialize(TypeDataBase db) {
 84     INTERPRETER_FRAME_MDX_OFFSET                  = INTERPRETER_FRAME_METHOD_OFFSET - 1;
 85     INTERPRETER_FRAME_PADDING_OFFSET              = INTERPRETER_FRAME_MDX_OFFSET - 1;
 86     INTERPRETER_FRAME_MIRROR_OFFSET               = INTERPRETER_FRAME_PADDING_OFFSET - 1;
 87     INTERPRETER_FRAME_CACHE_OFFSET                = INTERPRETER_FRAME_MIRROR_OFFSET - 1;
 88     INTERPRETER_FRAME_LOCALS_OFFSET               = INTERPRETER_FRAME_CACHE_OFFSET - 1;
 89     INTERPRETER_FRAME_BCX_OFFSET                  = INTERPRETER_FRAME_LOCALS_OFFSET - 1;
 90     INTERPRETER_FRAME_INITIAL_SP_OFFSET           = INTERPRETER_FRAME_BCX_OFFSET - 1;
 91     INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET    = INTERPRETER_FRAME_INITIAL_SP_OFFSET;
 92     INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET = INTERPRETER_FRAME_INITIAL_SP_OFFSET;
 93   }
 94 
 95 
 96   // an additional field beyond sp and pc:
 97   Address raw_fp; // frame pointer
 98   private Address raw_unextendedSP;
 99 
100   private AARCH64Frame() {
101   }
102 
103   private void adjustForDeopt() {
104     if ( pc != null) {
105       // Look for a deopt pc and if it is deopted convert to original pc
106       CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);
107       if (cb != null &amp;&amp; cb.isJavaMethod()) {
108         NMethod nm = (NMethod) cb;
109         if (pc.equals(nm.deoptHandlerBegin())) {
110           if (Assert.ASSERTS_ENABLED) {
111             Assert.that(this.getUnextendedSP() != null, &quot;null SP in Java frame&quot;);
112           }
113           // adjust pc if frame is deoptimized.
114           pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());
115           deoptimized = true;
116         }
117       }
118     }
119   }
120 
121   public AARCH64Frame(Address raw_sp, Address raw_fp, Address pc) {
122     this.raw_sp = raw_sp;
123     this.raw_unextendedSP = raw_sp;
124     this.raw_fp = raw_fp;
125     this.pc = pc;
126     adjustUnextendedSP();
127 
128     // Frame must be fully constructed before this call
129     adjustForDeopt();
130 
131     if (DEBUG) {
132       System.out.println(&quot;AARCH64Frame(sp, fp, pc): &quot; + this);
133       dumpStack();
134     }
135   }
136 
137   public AARCH64Frame(Address raw_sp, Address raw_fp) {
138     this.raw_sp = raw_sp;
139     this.raw_unextendedSP = raw_sp;
140     this.raw_fp = raw_fp;
141 
142     // We cannot assume SP[-1] always contains a valid return PC (e.g. if
143     // the callee is a C/C++ compiled frame). If the PC is not known to
144     // Java then this.pc is null.
145     Address savedPC = raw_sp.getAddressAt(-1 * VM.getVM().getAddressSize());
146     if (VM.getVM().isJavaPCDbg(savedPC)) {
147       this.pc = savedPC;
148     }
149 
150     adjustUnextendedSP();
151 
152     // Frame must be fully constructed before this call
153     adjustForDeopt();
154 
155     if (DEBUG) {
156       System.out.println(&quot;AARCH64Frame(sp, fp): &quot; + this);
157       dumpStack();
158     }
159   }
160 
161   public AARCH64Frame(Address raw_sp, Address raw_unextendedSp, Address raw_fp, Address pc) {
162     this.raw_sp = raw_sp;
163     this.raw_unextendedSP = raw_unextendedSp;
164     this.raw_fp = raw_fp;
165     this.pc = pc;
166     adjustUnextendedSP();
167 
168     // Frame must be fully constructed before this call
169     adjustForDeopt();
170 
171     if (DEBUG) {
172       System.out.println(&quot;AARCH64Frame(sp, unextendedSP, fp, pc): &quot; + this);
173       dumpStack();
174     }
175 
176   }
177 
178   public Object clone() {
179     AARCH64Frame frame = new AARCH64Frame();
180     frame.raw_sp = raw_sp;
181     frame.raw_unextendedSP = raw_unextendedSP;
182     frame.raw_fp = raw_fp;
183     frame.pc = pc;
184     frame.deoptimized = deoptimized;
185     return frame;
186   }
187 
188   public boolean equals(Object arg) {
189     if (arg == null) {
190       return false;
191     }
192 
193     if (!(arg instanceof AARCH64Frame)) {
194       return false;
195     }
196 
197     AARCH64Frame other = (AARCH64Frame) arg;
198 
199     return (AddressOps.equal(getSP(), other.getSP()) &amp;&amp;
200             AddressOps.equal(getUnextendedSP(), other.getUnextendedSP()) &amp;&amp;
201             AddressOps.equal(getFP(), other.getFP()) &amp;&amp;
202             AddressOps.equal(getPC(), other.getPC()));
203   }
204 
205   public int hashCode() {
206     if (raw_sp == null) {
207       return 0;
208     }
209 
210     return raw_sp.hashCode();
211   }
212 
213   public String toString() {
214     return &quot;sp: &quot; + (getSP() == null? &quot;null&quot; : getSP().toString()) +
215          &quot;, unextendedSP: &quot; + (getUnextendedSP() == null? &quot;null&quot; : getUnextendedSP().toString()) +
216          &quot;, fp: &quot; + (getFP() == null? &quot;null&quot; : getFP().toString()) +
217          &quot;, pc: &quot; + (pc == null? &quot;null&quot; : pc.toString());
218   }
219 
220   // accessors for the instance variables
221   public Address getFP() { return raw_fp; }
222   public Address getSP() { return raw_sp; }
223   public Address getID() { return raw_sp; }
224 
225   // FIXME: not implemented yet
226   public boolean isSignalHandlerFrameDbg() { return false; }
227   public int     getSignalNumberDbg()      { return 0;     }
228   public String  getSignalNameDbg()        { return null;  }
229 
230   public boolean isInterpretedFrameValid() {
231     if (Assert.ASSERTS_ENABLED) {
232       Assert.that(isInterpretedFrame(), &quot;Not an interpreted frame&quot;);
233     }
234 
235     // These are reasonable sanity checks
236     if (getFP() == null || getFP().andWithMask(0x3) != null) {
237       return false;
238     }
239 
240     if (getSP() == null || getSP().andWithMask(0x3) != null) {
241       return false;
242     }
243 
244     if (getFP().addOffsetTo(INTERPRETER_FRAME_INITIAL_SP_OFFSET * VM.getVM().getAddressSize()).lessThan(getSP())) {
245       return false;
246     }
247 
248     // These are hacks to keep us out of trouble.
249     // The problem with these is that they mask other problems
250     if (getFP().lessThanOrEqual(getSP())) {
251       // this attempts to deal with unsigned comparison above
252       return false;
253     }
254 
255     if (getFP().minus(getSP()) &gt; 4096 * VM.getVM().getAddressSize()) {
256       // stack frames shouldn&#39;t be large.
257       return false;
258     }
259 
260     return true;
261   }
262 
263   // FIXME: not applicable in current system
264   //  void    patch_pc(Thread* thread, address pc);
265 
266   public Frame sender(RegisterMap regMap, CodeBlob cb) {
267     AARCH64RegisterMap map = (AARCH64RegisterMap) regMap;
268 
269     if (Assert.ASSERTS_ENABLED) {
270       Assert.that(map != null, &quot;map must be set&quot;);
271     }
272 
273     // Default is we done have to follow them. The sender_for_xxx will
274     // update it accordingly
275     map.setIncludeArgumentOops(false);
276 
277     if (isEntryFrame())       return senderForEntryFrame(map);
278     if (isInterpretedFrame()) return senderForInterpreterFrame(map);
279 
280     if(cb == null) {
281       cb = VM.getVM().getCodeCache().findBlob(getPC());
282     } else {
283       if (Assert.ASSERTS_ENABLED) {
284         Assert.that(cb.equals(VM.getVM().getCodeCache().findBlob(getPC())), &quot;Must be the same&quot;);
285       }
286     }
287 
288     if (cb != null) {
289       return senderForCompiledFrame(map, cb);
290     }
291 
292     // Must be native-compiled frame, i.e. the marshaling code for native
293     // methods that exists in the core system.
294     return new AARCH64Frame(getSenderSP(), getLink(), getSenderPC());
295   }
296 
297   private Frame senderForEntryFrame(AARCH64RegisterMap map) {
298     if (DEBUG) {
299       System.out.println(&quot;senderForEntryFrame&quot;);
300     }
301     if (Assert.ASSERTS_ENABLED) {
302       Assert.that(map != null, &quot;map must be set&quot;);
303     }
304     // Java frame called from C; skip all C frames and return top C
305     // frame of that chunk as the sender
306     AARCH64JavaCallWrapper jcw = (AARCH64JavaCallWrapper) getEntryFrameCallWrapper();
307     if (Assert.ASSERTS_ENABLED) {
308       Assert.that(!entryFrameIsFirst(), &quot;next Java fp must be non zero&quot;);
309       Assert.that(jcw.getLastJavaSP().greaterThan(getSP()), &quot;must be above this frame on stack&quot;);
310     }
311     AARCH64Frame fr;
312     if (jcw.getLastJavaPC() != null) {
313       fr = new AARCH64Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP(), jcw.getLastJavaPC());
314     } else {
315       fr = new AARCH64Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP());
316     }
317     map.clear();
318     if (Assert.ASSERTS_ENABLED) {
319       Assert.that(map.getIncludeArgumentOops(), &quot;should be set by clear&quot;);
320     }
321     return fr;
322   }
323 
324   //------------------------------------------------------------------------------
325   // frame::adjust_unextended_sp
326   private void adjustUnextendedSP() {
327     // If we are returning to a compiled MethodHandle call site, the
328     // saved_fp will in fact be a saved value of the unextended SP.  The
329     // simplest way to tell whether we are returning to such a call site
330     // is as follows:
331 
332     CodeBlob cb = cb();
333     NMethod senderNm = (cb == null) ? null : cb.asNMethodOrNull();
334     if (senderNm != null) {
335       // If the sender PC is a deoptimization point, get the original
336       // PC.  For MethodHandle call site the unextended_sp is stored in
337       // saved_fp.
338       if (senderNm.isDeoptMhEntry(getPC())) {
339         // DEBUG_ONLY(verifyDeoptMhOriginalPc(senderNm, getFP()));
340         raw_unextendedSP = getFP();
341       }
342       else if (senderNm.isDeoptEntry(getPC())) {
343         // DEBUG_ONLY(verifyDeoptOriginalPc(senderNm, raw_unextendedSp));
344       }
345       else if (senderNm.isMethodHandleReturn(getPC())) {
346         raw_unextendedSP = getFP();
347       }
348     }
349   }
350 
351   private Frame senderForInterpreterFrame(AARCH64RegisterMap map) {
352     if (DEBUG) {
353       System.out.println(&quot;senderForInterpreterFrame&quot;);
354     }
355     Address unextendedSP = addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);
356     Address sp = addressOfStackSlot(SENDER_SP_OFFSET);
357     // We do not need to update the callee-save register mapping because above
358     // us is either another interpreter frame or a converter-frame, but never
359     // directly a compiled frame.
360     // 11/24/04 SFG. With the removal of adapter frames this is no longer true.
361     // However c2 no longer uses callee save register for java calls so there
362     // are no callee register to find.
363 
364     if (map.getUpdateMap())
365       updateMapWithSavedLink(map, addressOfStackSlot(LINK_OFFSET));
366 
367     return new AARCH64Frame(sp, unextendedSP, getLink(), getSenderPC());
368   }
369 
370   private void updateMapWithSavedLink(RegisterMap map, Address savedFPAddr) {
371     map.setLocation(fp, savedFPAddr);
372   }
373 
374   private Frame senderForCompiledFrame(AARCH64RegisterMap map, CodeBlob cb) {
375     if (DEBUG) {
376       System.out.println(&quot;senderForCompiledFrame&quot;);
377     }
378 
379     //
380     // NOTE: some of this code is (unfortunately) duplicated  AARCH64CurrentFrameGuess
381     //
382 
383     if (Assert.ASSERTS_ENABLED) {
384       Assert.that(map != null, &quot;map must be set&quot;);
385     }
386 
387     // frame owned by optimizing compiler
388     if (Assert.ASSERTS_ENABLED) {
389         Assert.that(cb.getFrameSize() &gt;= 0, &quot;must have non-zero frame size&quot;);
390     }
391     Address senderSP = getUnextendedSP().addOffsetTo(cb.getFrameSize());
392 
393     // The return_address is always the word on the stack
394     Address senderPC = senderSP.getAddressAt(-1 * VM.getVM().getAddressSize());
395 
396     // This is the saved value of FP which may or may not really be an FP.
397     // It is only an FP if the sender is an interpreter frame.
398     Address savedFPAddr = senderSP.addOffsetTo(- SENDER_SP_OFFSET * VM.getVM().getAddressSize());
399 
400     if (map.getUpdateMap()) {
401       // Tell GC to use argument oopmaps for some runtime stubs that need it.
402       // For C1, the runtime stub might not have oop maps, so set this flag
403       // outside of update_register_map.
404       map.setIncludeArgumentOops(cb.callerMustGCArguments());
405 
406       if (cb.getOopMaps() != null) {
407         ImmutableOopMapSet.updateRegisterMap(this, cb, map, true);
408       }
409 
410       // Since the prolog does the save and restore of FP there is no oopmap
411       // for it so we must fill in its location as if there was an oopmap entry
412       // since if our caller was compiled code there could be live jvm state in it.
413       updateMapWithSavedLink(map, savedFPAddr);
414     }
415 
416     return new AARCH64Frame(senderSP, savedFPAddr.getAddressAt(0), senderPC);
417   }
418 
419   protected boolean hasSenderPD() {
420     return true;
421   }
422 
423   public long frameSize() {
424     return (getSenderSP().minus(getSP()) / VM.getVM().getAddressSize());
425   }
426 
427     public Address getLink() {
428         try {
429             if (DEBUG) {
430                 System.out.println(&quot;Reading link at &quot; + addressOfStackSlot(LINK_OFFSET)
431                         + &quot; = &quot; + addressOfStackSlot(LINK_OFFSET).getAddressAt(0));
432             }
433             return addressOfStackSlot(LINK_OFFSET).getAddressAt(0);
434         } catch (Exception e) {
435             if (DEBUG)
436                 System.out.println(&quot;Returning null&quot;);
437             return null;
438         }
439     }
440 
441   // FIXME: not implementable yet
442   //inline void      frame::set_link(intptr_t* addr)  { *(intptr_t **)addr_at(link_offset) = addr; }
443 
444   public Address getUnextendedSP() { return raw_unextendedSP; }
445 
446   // Return address:
447   public Address getSenderPCAddr() { return addressOfStackSlot(RETURN_ADDR_OFFSET); }
448   public Address getSenderPC()     { return getSenderPCAddr().getAddressAt(0);      }
449 
450   // return address of param, zero origin index.
451   public Address getNativeParamAddr(int idx) {
452     return addressOfStackSlot(NATIVE_FRAME_INITIAL_PARAM_OFFSET + idx);
453   }
454 
455   public Address getSenderSP()     { return addressOfStackSlot(SENDER_SP_OFFSET); }
456 
457   public Address addressOfInterpreterFrameLocals() {
458     return addressOfStackSlot(INTERPRETER_FRAME_LOCALS_OFFSET);
459   }
460 
461   private Address addressOfInterpreterFrameBCX() {
462     return addressOfStackSlot(INTERPRETER_FRAME_BCX_OFFSET);
463   }
464 
465   public int getInterpreterFrameBCI() {
466     // FIXME: this is not atomic with respect to GC and is unsuitable
467     // for use in a non-debugging, or reflective, system. Need to
468     // figure out how to express this.
469     Address bcp = addressOfInterpreterFrameBCX().getAddressAt(0);
470     Address methodHandle = addressOfInterpreterFrameMethod().getAddressAt(0);
471     Method method = (Method)Metadata.instantiateWrapperFor(methodHandle);
472     return bcpToBci(bcp, method);
473   }
474 
475   public Address addressOfInterpreterFrameMDX() {
476     return addressOfStackSlot(INTERPRETER_FRAME_MDX_OFFSET);
477   }
478 
479   // FIXME
480   //inline int frame::interpreter_frame_monitor_size() {
481   //  return BasicObjectLock::size();
482   //}
483 
484   // expression stack
485   // (the max_stack arguments are used by the GC; see class FrameClosure)
486 
487   public Address addressOfInterpreterFrameExpressionStack() {
488     Address monitorEnd = interpreterFrameMonitorEnd().address();
489     return monitorEnd.addOffsetTo(-1 * VM.getVM().getAddressSize());
490   }
491 
492   public int getInterpreterFrameExpressionStackDirection() { return -1; }
493 
494   // top of expression stack
495   public Address addressOfInterpreterFrameTOS() {
496     return getSP();
497   }
498 
499   /** Expression stack from top down */
500   public Address addressOfInterpreterFrameTOSAt(int slot) {
501     return addressOfInterpreterFrameTOS().addOffsetTo(slot * VM.getVM().getAddressSize());
502   }
503 
504   public Address getInterpreterFrameSenderSP() {
505     if (Assert.ASSERTS_ENABLED) {
506       Assert.that(isInterpretedFrame(), &quot;interpreted frame expected&quot;);
507     }
508     return addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);
509   }
510 
511   // Monitors
512   public BasicObjectLock interpreterFrameMonitorBegin() {
513     return new BasicObjectLock(addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET));
514   }
515 
516   public BasicObjectLock interpreterFrameMonitorEnd() {
517     Address result = addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET).getAddressAt(0);
518     if (Assert.ASSERTS_ENABLED) {
519       // make sure the pointer points inside the frame
520       Assert.that(AddressOps.gt(getFP(), result), &quot;result must &lt;  than frame pointer&quot;);
521       Assert.that(AddressOps.lte(getSP(), result), &quot;result must &gt;= than stack pointer&quot;);
522     }
523     return new BasicObjectLock(result);
524   }
525 
526   public int interpreterFrameMonitorSize() {
527     return BasicObjectLock.size();
528   }
529 
530   // Method
531   public Address addressOfInterpreterFrameMethod() {
532     return addressOfStackSlot(INTERPRETER_FRAME_METHOD_OFFSET);
533   }
534 
535   // Constant pool cache
536   public Address addressOfInterpreterFrameCPCache() {
537     return addressOfStackSlot(INTERPRETER_FRAME_CACHE_OFFSET);
538   }
539 
540   // Entry frames
541   public JavaCallWrapper getEntryFrameCallWrapper() {
542     return new AARCH64JavaCallWrapper(addressOfStackSlot(ENTRY_FRAME_CALL_WRAPPER_OFFSET).getAddressAt(0));
543   }
544 
545   protected Address addressOfSavedOopResult() {
546     // offset is 2 for compiler2 and 3 for compiler1
547     return getSP().addOffsetTo((VM.getVM().isClientCompiler() ? 2 : 3) *
548                                VM.getVM().getAddressSize());
549   }
550 
551   protected Address addressOfSavedReceiver() {
552     return getSP().addOffsetTo(-4 * VM.getVM().getAddressSize());
553   }
554 
555   private void dumpStack() {
556     for (Address addr = getSP().addOffsetTo(-4 * VM.getVM().getAddressSize());
557          AddressOps.lt(addr, getSP());
558          addr = addr.addOffsetTo(VM.getVM().getAddressSize())) {
559       System.out.println(addr + &quot;: &quot; + addr.getAddressAt(0));
560     }
561     System.out.println(&quot;-----------------------&quot;);
562     for (Address addr = getSP();
563          AddressOps.lte(addr, getSP().addOffsetTo(20 * VM.getVM().getAddressSize()));
564          addr = addr.addOffsetTo(VM.getVM().getAddressSize())) {
565       System.out.println(addr + &quot;: &quot; + addr.getAddressAt(0));
566     }
567   }
568 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
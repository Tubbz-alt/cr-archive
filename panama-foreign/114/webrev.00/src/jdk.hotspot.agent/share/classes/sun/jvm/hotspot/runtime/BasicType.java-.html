<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/BasicType.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.runtime;
 26 
 27 import java.util.Observer;
 28 import sun.jvm.hotspot.types.TypeDataBase;
 29 
 30 
 31 /** Encapsulates the BasicType enum in globalDefinitions.hpp in the
 32     VM. */
 33 
 34 public class BasicType {
 35   public static final BasicType T_BOOLEAN = new BasicType();
 36   public static final BasicType T_CHAR = new BasicType();
 37   public static final BasicType T_FLOAT = new BasicType();
 38   public static final BasicType T_DOUBLE = new BasicType();
 39   public static final BasicType T_BYTE = new BasicType();
 40   public static final BasicType T_SHORT = new BasicType();
 41   public static final BasicType T_INT = new BasicType();
 42   public static final BasicType T_LONG = new BasicType();
 43   public static final BasicType T_OBJECT = new BasicType();
 44   public static final BasicType T_ARRAY = new BasicType();
 45   public static final BasicType T_VOID = new BasicType();
 46   public static final BasicType T_ADDRESS = new BasicType();
 47   public static final BasicType T_NARROWOOP = new BasicType();
 48   public static final BasicType T_METADATA = new BasicType();
 49   public static final BasicType T_NARROWKLASS = new BasicType();
 50   public static final BasicType T_CONFLICT = new BasicType();
 51   public static final BasicType T_ILLEGAL = new BasicType();
 52 
 53   static {
 54     VM.registerVMInitializedObserver(
 55         (o, d) -&gt; initialize(VM.getVM().getTypeDataBase()));
 56   }
 57 
 58   private static synchronized void initialize(TypeDataBase db) {
 59     T_BOOLEAN.setType(db.lookupIntConstant(&quot;T_BOOLEAN&quot;).intValue());
 60     T_CHAR.setType(db.lookupIntConstant(&quot;T_CHAR&quot;).intValue());
 61     T_FLOAT.setType(db.lookupIntConstant(&quot;T_FLOAT&quot;).intValue());
 62     T_DOUBLE.setType(db.lookupIntConstant(&quot;T_DOUBLE&quot;).intValue());
 63     T_BYTE.setType(db.lookupIntConstant(&quot;T_BYTE&quot;).intValue());
 64     T_SHORT.setType(db.lookupIntConstant(&quot;T_SHORT&quot;).intValue());
 65     T_INT.setType(db.lookupIntConstant(&quot;T_INT&quot;).intValue());
 66     T_LONG.setType(db.lookupIntConstant(&quot;T_LONG&quot;).intValue());
 67     T_OBJECT.setType(db.lookupIntConstant(&quot;T_OBJECT&quot;).intValue());
 68     T_ARRAY.setType(db.lookupIntConstant(&quot;T_ARRAY&quot;).intValue());
 69     T_VOID.setType(db.lookupIntConstant(&quot;T_VOID&quot;).intValue());
 70     T_ADDRESS.setType(db.lookupIntConstant(&quot;T_ADDRESS&quot;).intValue());
 71     T_NARROWOOP.setType(db.lookupIntConstant(&quot;T_NARROWOOP&quot;).intValue());
 72     T_METADATA.setType(db.lookupIntConstant(&quot;T_METADATA&quot;).intValue());
 73     T_NARROWKLASS.setType(db.lookupIntConstant(&quot;T_NARROWKLASS&quot;).intValue());
 74     T_CONFLICT.setType(db.lookupIntConstant(&quot;T_CONFLICT&quot;).intValue());
 75     T_ILLEGAL.setType(db.lookupIntConstant(&quot;T_ILLEGAL&quot;).intValue());
 76   }
 77 
 78   public static int getTBoolean() {
 79     return T_BOOLEAN.getType();
 80   }
 81 
 82   public static int getTChar() {
 83     return T_CHAR.getType();
 84   }
 85 
 86   public static int getTFloat() {
 87     return T_FLOAT.getType();
 88   }
 89 
 90   public static int getTDouble() {
 91     return T_DOUBLE.getType();
 92   }
 93 
 94   public static int getTByte() {
 95     return T_BYTE.getType();
 96   }
 97 
 98   public static int getTShort() {
 99     return T_SHORT.getType();
100   }
101 
102   public static int getTInt() {
103     return T_INT.getType();
104   }
105 
106   public static int getTLong() {
107     return T_LONG.getType();
108   }
109 
110   public static int getTObject() {
111     return T_OBJECT.getType();
112   }
113 
114   public static int getTArray() {
115     return T_ARRAY.getType();
116   }
117 
118   public static int getTVoid() {
119     return T_VOID.getType();
120   }
121 
122   public static int getTAddress() {
123     return T_ADDRESS.getType();
124   }
125 
126   public static int getTNarrowOop() {
127     return T_NARROWOOP.getType();
128   }
129 
130   public static int getTMetadata() {
131     return T_METADATA.getType();
132   }
133 
134   public static int getTNarrowKlass() {
135     return T_NARROWKLASS.getType();
136   }
137 
138   /** For stack value type with conflicting contents */
139   public static int getTConflict() {
140     return T_CONFLICT.getType();
141   }
142 
143   public static int getTIllegal() {
144     return T_ILLEGAL.getType();
145   }
146 
147   public static BasicType intToBasicType(int i) {
148     if (i == T_BOOLEAN.getType()) {
149       return T_BOOLEAN;
150     } else if (i == T_CHAR.getType()) {
151       return T_CHAR;
152     } else if (i == T_FLOAT.getType()) {
153       return T_FLOAT;
154     } else if (i == T_DOUBLE.getType()) {
155       return T_DOUBLE;
156     } else if (i == T_BYTE.getType()) {
157       return T_BYTE;
158     } else if (i == T_SHORT.getType()) {
159       return T_SHORT;
160     } else if (i == T_INT.getType()) {
161       return T_INT;
162     } else if (i == T_LONG.getType()) {
163       return T_LONG;
164     } else if (i == T_OBJECT.getType()) {
165       return T_OBJECT;
166     } else if (i == T_ARRAY.getType()) {
167       return T_ARRAY;
168     } else if (i == T_VOID.getType()) {
169       return T_VOID;
170     } else if (i == T_ADDRESS.getType()) {
171       return T_ADDRESS;
172     } else if (i == T_NARROWOOP.getType()) {
173       return T_NARROWOOP;
174     } else if (i == T_METADATA.getType()) {
175       return T_METADATA;
176     } else if (i == T_NARROWKLASS.getType()) {
177       return T_NARROWKLASS;
178     } else {
179       return T_ILLEGAL;
180     }
181   }
182 
183   public static BasicType charToBasicType(char c) {
184     switch( c ) {
185     case &#39;B&#39;: return T_BYTE;
186     case &#39;C&#39;: return T_CHAR;
187     case &#39;D&#39;: return T_DOUBLE;
188     case &#39;F&#39;: return T_FLOAT;
189     case &#39;I&#39;: return T_INT;
190     case &#39;J&#39;: return T_LONG;
191     case &#39;S&#39;: return T_SHORT;
192     case &#39;Z&#39;: return T_BOOLEAN;
193     case &#39;V&#39;: return T_VOID;
194     case &#39;L&#39;: return T_OBJECT;
195     case &#39;[&#39;: return T_ARRAY;
196     }
197     return T_ILLEGAL;
198   }
199 
200   public static int charToType(char c) {
201     return charToBasicType(c).getType();
202   }
203 
204   public int getType() {
205     return type;
206   }
207 
208   public String getName() {
209     if (type == T_BOOLEAN.getType()) {
210       return &quot;boolean&quot;;
211     } else if (type == T_CHAR.getType()) {
212       return &quot;char&quot;;
213     } else if (type == T_FLOAT.getType()) {
214       return &quot;float&quot;;
215     } else if (type == T_DOUBLE.getType()) {
216       return &quot;double&quot;;
217     } else if (type == T_BYTE.getType()) {
218       return &quot;byte&quot;;
219     } else if (type == T_SHORT.getType()) {
220       return &quot;short&quot;;
221     } else if (type == T_INT.getType()) {
222       return &quot;int&quot;;
223     } else if (type == T_LONG.getType()) {
224       return &quot;long&quot;;
225     } else if (type == T_OBJECT.getType()) {
226       return &quot;object&quot;;
227     } else if (type == T_ARRAY.getType()) {
228       return &quot;array&quot;;
229     } else if (type == T_VOID.getType()) {
230       return &quot;void&quot;;
231     } else if (type == T_ADDRESS.getType()) {
232       return &quot;address&quot;;
233     } else if (type == T_NARROWOOP.getType()) {
234       return &quot;narrow oop&quot;;
235     } else if (type == T_METADATA.getType()) {
236       return &quot;metadata&quot;;
237     } else if (type == T_NARROWKLASS.getType()) {
238       return &quot;narrow klass&quot;;
239     } else if (type == T_CONFLICT.getType()) {
240       return &quot;conflict&quot;;
241     } else {
242       return &quot;ILLEGAL TYPE&quot;;
243     }
244   }
245 
246   //-- Internals only below this point
247   private BasicType() {
248   }
249 
250   private void setType(int type) {
251     this.type = type;
252   }
253 
254   private int type;
255 }
    </pre>
  </body>
</html>
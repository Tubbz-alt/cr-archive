<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/GenerateOopMap.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ExceptionTableElement.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Instance.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/GenerateOopMap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 151       iterateParameters();
 152 
 153       return length();
 154     };
 155 
 156     int computeForReturntype(CellTypeStateList effect) {
 157       _idx    = 0;
 158       _effect = effect;
 159       iterateReturntype();
 160       set(CellTypeState.bottom);  // Always terminate with a bottom state, so ppush works
 161 
 162       return length();
 163     }
 164   }
 165 
 166   /** Contains maping between jsr targets and there return addresses.
 167       One-to-many mapping. */
 168   static class RetTableEntry {
 169     private static int _init_nof_jsrs; // Default size of jsrs list
 170     private int _target_bci;           // Target PC address of jump (bytecode index)
<span class="line-modified"> 171     private List/*&lt;int&gt;*/ _jsrs;       // List of return addresses  (bytecode index)</span>
 172     private RetTableEntry _next;       // Link to next entry
 173 
 174     RetTableEntry(int target, RetTableEntry next) {
 175       _target_bci = target;
<span class="line-modified"> 176       _jsrs = new ArrayList(_init_nof_jsrs);</span>
 177       _next = next;
 178     }
 179 
 180     // Query
 181     int targetBci()  { return _target_bci; }
 182     int nofJsrs()    { return _jsrs.size(); }
<span class="line-modified"> 183     int jsrs(int i)  { return ((Integer) _jsrs.get(i)).intValue(); }</span>
 184 
 185     // Update entry
<span class="line-modified"> 186     void addJsr  (int return_bci)     { _jsrs.add(new Integer(return_bci)); }</span>
 187     void addDelta(int bci, int delta) {
 188       if (_target_bci &gt; bci) {
 189         _target_bci += delta;
 190       }
 191 
 192       for (int k = 0; k &lt; nofJsrs(); k++) {
 193         int jsr = jsrs(k);
 194         if (jsr &gt; bci) {
<span class="line-modified"> 195           _jsrs.set(k, new Integer(jsr+delta));</span>
 196         }
 197       }
 198     }
 199     RetTableEntry next()               { return _next; }
 200   }
 201 
 202   static class RetTable {
 203     private RetTableEntry _first;
 204     private static int _init_nof_entries;
 205 
 206     private void addJsr(int return_bci, int target_bci) {
 207       RetTableEntry entry = _first;
 208 
 209       // Scan table for entry
 210       for (;(entry != null) &amp;&amp; (entry.targetBci() != target_bci); entry = entry.next());
 211 
 212       if (entry == null) {
 213         // Allocate new entry and put in list
 214         entry = new RetTableEntry(target_bci, _first);
 215         _first = entry;
</pre>
<hr />
<pre>
1909     // Mark everything changed, then do one interpretation pass.
1910     for (int i = 0; i&lt;_bb_count; i++) {
1911       if (_basic_blocks[i].isReachable()) {
1912         _basic_blocks[i].setChanged(true);
1913         interpBB(_basic_blocks[i]);
1914       }
1915     }
1916 
1917     // Note: Since we are skipping dead-code when we are reporting results, then
1918     // the no. of encountered gc-points might be fewer than the previously number
1919     // we have counted. (dead-code is a pain - it should be removed before we get here)
1920     fillStackmapEpilog();
1921 
1922     // Report initvars
1923     fillInitVars(_init_vars);
1924 
1925     _report_result = false;
1926   }
1927 
1928   // Initvars
<span class="line-modified">1929   List/*&lt;Integer&gt;*/ _init_vars;</span>
1930 
1931   void  initializeVars                      () {
1932     for (int k = 0; k &lt; _init_vars.size(); k++)
<span class="line-modified">1933       _state.get(((Integer) _init_vars.get(k)).intValue()).set(CellTypeState.makeSlotRef(k));</span>
1934   }
1935 
1936   void  addToRefInitSet                     (int localNo) {
1937     //    if (TraceNewOopMapGeneration)
1938     //      tty.print_cr(&quot;Added init vars: %d&quot;, localNo);
1939 
<span class="line-modified">1940     Integer local = new Integer(localNo);</span>
1941 
1942     // Is it already in the set?
1943     if (_init_vars.contains(local))
1944       return;
1945 
1946     _init_vars.add(local);
1947   }
1948 
1949   // Conflicts rewrite logic
1950   boolean   _conflict;                      // True, if a conflict occured during interpretation
1951   int       _nof_refval_conflicts;          // No. of conflicts that require rewrites
1952   int[]     _new_var_map;
1953 
1954   void recordRefvalConflict                 (int varNo) {
1955     if (Assert.ASSERTS_ENABLED) {
1956       Assert.that(varNo&gt;=0 &amp;&amp; varNo&lt; _max_locals, &quot;index out of range&quot;);
1957     }
1958 
1959     if (TraceOopMapRewrites) {
1960       System.err.println(&quot;### Conflict detected (local no: &quot; + varNo + &quot;)&quot;);
</pre>
<hr />
<pre>
2138     _rt = new RetTable();
2139   }
2140 
2141 
2142   // Compute the map.
2143   public void computeMap() {
2144     if (DEBUG) {
2145       System.err.println(&quot;*** GenerateOopMap: computing for &quot; +
2146                          method().getMethodHolder().getName().asString() + &quot;.&quot; +
2147                          method().getName().asString() +
2148                          method().getSignature().asString());
2149     }
2150 
2151     // Initialize values
2152     _got_error      = false;
2153     _conflict       = false;
2154     _max_locals     = (int) method().getMaxLocals();
2155     _max_stack      = (int) method().getMaxStack();
2156     _has_exceptions = (method().hasExceptionTable());
2157     _nof_refval_conflicts = 0;
<span class="line-modified">2158     _init_vars      = new ArrayList(5);  // There are seldom more than 5 init_vars</span>
2159     _report_result  = false;
2160     _report_result_for_send = false;
2161     _report_for_exit_bci = -1;
2162     _new_var_map    = null;
2163     //    _ret_adr_tos    = new GrowableArray&lt;intptr_t&gt;(5);  // 5 seems like a good number;
2164     //    _did_rewriting  = false;
2165     //    _did_relocation = false;
2166 
2167     // FIXME: remove
2168     /*
2169     if (TraceNewOopMapGeneration) {
2170       tty.print(&quot;Method name: %s\n&quot;, method().name().as_C_string());
2171       if (Verbose) {
2172         _method.print_codes();
2173         tty.print_cr(&quot;Exception table:&quot;);
2174         typeArrayOop excps = method().exception_table();
2175         for(int i = 0; i &lt; excps.length(); i += 4) {
2176           tty.print_cr(&quot;[%d - %d] . %d&quot;, excps.int_at(i + 0), excps.int_at(i + 1), excps.int_at(i + 2));
2177         }
2178       }
</pre>
<hr />
<pre>
2297   //   during the epilog. It is the responsibility of the subclass to
2298   //   count the correct number.
2299   // - fillInitVars are called once with the result of the init_vars
2300   //   computation
2301   //
2302   // All these methods are used during a call to computeMap. Note:
2303   // None of the return results are valid after computeMap returns,
2304   // since all values are allocated as resource objects.
2305   //
2306   // All virtual method must be implemented in subclasses
2307   public boolean allowRewrites            ()                              { return false; }
2308   public boolean reportResults            ()                              { return true;  }
2309   public boolean reportInitVars           ()                              { return true;  }
2310   public boolean possibleGCPoint          (BytecodeStream bcs)            { throw new RuntimeException(&quot;ShouldNotReachHere&quot;); }
2311   public void fillStackmapProlog          (int nofGCPoints)               { throw new RuntimeException(&quot;ShouldNotReachHere&quot;); }
2312   public void fillStackmapEpilog          ()                              { throw new RuntimeException(&quot;ShouldNotReachHere&quot;); }
2313   public void fillStackmapForOpcodes      (BytecodeStream bcs,
2314                                            CellTypeStateList vars,
2315                                            CellTypeStateList stack,
2316                                            int stackTop)                  { throw new RuntimeException(&quot;ShouldNotReachHere&quot;); }
<span class="line-modified">2317   public void fillInitVars                (List/*&lt;Integer&gt;*/ init_vars)   { throw new RuntimeException(&quot;ShouldNotReachHere&quot;); }</span>
2318 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 151       iterateParameters();
 152 
 153       return length();
 154     };
 155 
 156     int computeForReturntype(CellTypeStateList effect) {
 157       _idx    = 0;
 158       _effect = effect;
 159       iterateReturntype();
 160       set(CellTypeState.bottom);  // Always terminate with a bottom state, so ppush works
 161 
 162       return length();
 163     }
 164   }
 165 
 166   /** Contains maping between jsr targets and there return addresses.
 167       One-to-many mapping. */
 168   static class RetTableEntry {
 169     private static int _init_nof_jsrs; // Default size of jsrs list
 170     private int _target_bci;           // Target PC address of jump (bytecode index)
<span class="line-modified"> 171     private List&lt;Integer&gt; _jsrs;       // List of return addresses  (bytecode index)</span>
 172     private RetTableEntry _next;       // Link to next entry
 173 
 174     RetTableEntry(int target, RetTableEntry next) {
 175       _target_bci = target;
<span class="line-modified"> 176       _jsrs = new ArrayList&lt;&gt;(_init_nof_jsrs);</span>
 177       _next = next;
 178     }
 179 
 180     // Query
 181     int targetBci()  { return _target_bci; }
 182     int nofJsrs()    { return _jsrs.size(); }
<span class="line-modified"> 183     int jsrs(int i)  { return _jsrs.get(i).intValue(); }</span>
 184 
 185     // Update entry
<span class="line-modified"> 186     void addJsr  (int return_bci)     { _jsrs.add(return_bci); }</span>
 187     void addDelta(int bci, int delta) {
 188       if (_target_bci &gt; bci) {
 189         _target_bci += delta;
 190       }
 191 
 192       for (int k = 0; k &lt; nofJsrs(); k++) {
 193         int jsr = jsrs(k);
 194         if (jsr &gt; bci) {
<span class="line-modified"> 195           _jsrs.set(k, jsr + delta);</span>
 196         }
 197       }
 198     }
 199     RetTableEntry next()               { return _next; }
 200   }
 201 
 202   static class RetTable {
 203     private RetTableEntry _first;
 204     private static int _init_nof_entries;
 205 
 206     private void addJsr(int return_bci, int target_bci) {
 207       RetTableEntry entry = _first;
 208 
 209       // Scan table for entry
 210       for (;(entry != null) &amp;&amp; (entry.targetBci() != target_bci); entry = entry.next());
 211 
 212       if (entry == null) {
 213         // Allocate new entry and put in list
 214         entry = new RetTableEntry(target_bci, _first);
 215         _first = entry;
</pre>
<hr />
<pre>
1909     // Mark everything changed, then do one interpretation pass.
1910     for (int i = 0; i&lt;_bb_count; i++) {
1911       if (_basic_blocks[i].isReachable()) {
1912         _basic_blocks[i].setChanged(true);
1913         interpBB(_basic_blocks[i]);
1914       }
1915     }
1916 
1917     // Note: Since we are skipping dead-code when we are reporting results, then
1918     // the no. of encountered gc-points might be fewer than the previously number
1919     // we have counted. (dead-code is a pain - it should be removed before we get here)
1920     fillStackmapEpilog();
1921 
1922     // Report initvars
1923     fillInitVars(_init_vars);
1924 
1925     _report_result = false;
1926   }
1927 
1928   // Initvars
<span class="line-modified">1929   List&lt;Integer&gt; _init_vars;</span>
1930 
1931   void  initializeVars                      () {
1932     for (int k = 0; k &lt; _init_vars.size(); k++)
<span class="line-modified">1933       _state.get((_init_vars.get(k)).intValue()).set(CellTypeState.makeSlotRef(k));</span>
1934   }
1935 
1936   void  addToRefInitSet                     (int localNo) {
1937     //    if (TraceNewOopMapGeneration)
1938     //      tty.print_cr(&quot;Added init vars: %d&quot;, localNo);
1939 
<span class="line-modified">1940     Integer local = localNo;</span>
1941 
1942     // Is it already in the set?
1943     if (_init_vars.contains(local))
1944       return;
1945 
1946     _init_vars.add(local);
1947   }
1948 
1949   // Conflicts rewrite logic
1950   boolean   _conflict;                      // True, if a conflict occured during interpretation
1951   int       _nof_refval_conflicts;          // No. of conflicts that require rewrites
1952   int[]     _new_var_map;
1953 
1954   void recordRefvalConflict                 (int varNo) {
1955     if (Assert.ASSERTS_ENABLED) {
1956       Assert.that(varNo&gt;=0 &amp;&amp; varNo&lt; _max_locals, &quot;index out of range&quot;);
1957     }
1958 
1959     if (TraceOopMapRewrites) {
1960       System.err.println(&quot;### Conflict detected (local no: &quot; + varNo + &quot;)&quot;);
</pre>
<hr />
<pre>
2138     _rt = new RetTable();
2139   }
2140 
2141 
2142   // Compute the map.
2143   public void computeMap() {
2144     if (DEBUG) {
2145       System.err.println(&quot;*** GenerateOopMap: computing for &quot; +
2146                          method().getMethodHolder().getName().asString() + &quot;.&quot; +
2147                          method().getName().asString() +
2148                          method().getSignature().asString());
2149     }
2150 
2151     // Initialize values
2152     _got_error      = false;
2153     _conflict       = false;
2154     _max_locals     = (int) method().getMaxLocals();
2155     _max_stack      = (int) method().getMaxStack();
2156     _has_exceptions = (method().hasExceptionTable());
2157     _nof_refval_conflicts = 0;
<span class="line-modified">2158     _init_vars      = new ArrayList&lt;&gt;(5);  // There are seldom more than 5 init_vars</span>
2159     _report_result  = false;
2160     _report_result_for_send = false;
2161     _report_for_exit_bci = -1;
2162     _new_var_map    = null;
2163     //    _ret_adr_tos    = new GrowableArray&lt;intptr_t&gt;(5);  // 5 seems like a good number;
2164     //    _did_rewriting  = false;
2165     //    _did_relocation = false;
2166 
2167     // FIXME: remove
2168     /*
2169     if (TraceNewOopMapGeneration) {
2170       tty.print(&quot;Method name: %s\n&quot;, method().name().as_C_string());
2171       if (Verbose) {
2172         _method.print_codes();
2173         tty.print_cr(&quot;Exception table:&quot;);
2174         typeArrayOop excps = method().exception_table();
2175         for(int i = 0; i &lt; excps.length(); i += 4) {
2176           tty.print_cr(&quot;[%d - %d] . %d&quot;, excps.int_at(i + 0), excps.int_at(i + 1), excps.int_at(i + 2));
2177         }
2178       }
</pre>
<hr />
<pre>
2297   //   during the epilog. It is the responsibility of the subclass to
2298   //   count the correct number.
2299   // - fillInitVars are called once with the result of the init_vars
2300   //   computation
2301   //
2302   // All these methods are used during a call to computeMap. Note:
2303   // None of the return results are valid after computeMap returns,
2304   // since all values are allocated as resource objects.
2305   //
2306   // All virtual method must be implemented in subclasses
2307   public boolean allowRewrites            ()                              { return false; }
2308   public boolean reportResults            ()                              { return true;  }
2309   public boolean reportInitVars           ()                              { return true;  }
2310   public boolean possibleGCPoint          (BytecodeStream bcs)            { throw new RuntimeException(&quot;ShouldNotReachHere&quot;); }
2311   public void fillStackmapProlog          (int nofGCPoints)               { throw new RuntimeException(&quot;ShouldNotReachHere&quot;); }
2312   public void fillStackmapEpilog          ()                              { throw new RuntimeException(&quot;ShouldNotReachHere&quot;); }
2313   public void fillStackmapForOpcodes      (BytecodeStream bcs,
2314                                            CellTypeStateList vars,
2315                                            CellTypeStateList stack,
2316                                            int stackTop)                  { throw new RuntimeException(&quot;ShouldNotReachHere&quot;); }
<span class="line-modified">2317   public void fillInitVars                (List&lt;Integer&gt; init_vars)       { throw new RuntimeException(&quot;ShouldNotReachHere&quot;); }</span>
2318 }
</pre>
</td>
</tr>
</table>
<center><a href="ExceptionTableElement.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Instance.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
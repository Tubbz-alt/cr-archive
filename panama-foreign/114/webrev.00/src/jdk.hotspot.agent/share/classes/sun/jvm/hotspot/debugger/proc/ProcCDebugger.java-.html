<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/proc/ProcCDebugger.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.debugger.proc;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.debugger.cdbg.*;
 31 import sun.jvm.hotspot.utilities.*;
 32 
 33 class ProcCDebugger implements CDebugger {
 34   private ProcDebugger dbg;
 35 
 36   ProcCDebugger(ProcDebugger dbg) {
 37     this.dbg = dbg;
 38   }
 39 
 40   public List getThreadList() throws DebuggerException {
 41     return dbg.getThreadList();
 42   }
 43 
 44   public List/*&lt;LoadObject&gt;*/ getLoadObjectList() throws DebuggerException {
 45     return dbg.getLoadObjectList();
 46   }
 47 
 48   public LoadObject loadObjectContainingPC(Address pc) throws DebuggerException {
 49     if (pc == null) {
 50       return null;
 51     }
 52     List objs = getLoadObjectList();
 53     Object[] arr = objs.toArray();
 54     // load objects are sorted by base address, do binary search
 55     int mid  = -1;
 56     int low  = 0;
 57     int high = arr.length - 1;
 58 
 59     while (low &lt;= high) {
 60        mid = (low + high) &gt;&gt; 1;
 61        LoadObject midVal = (LoadObject) arr[mid];
 62        long cmp = pc.minus(midVal.getBase());
 63        if (cmp &lt; 0) {
 64           high = mid - 1;
 65        } else if (cmp &gt; 0) {
 66           long size = midVal.getSize();
 67           if (cmp &gt;= size) {
 68              low = mid + 1;
 69           } else {
 70              return (LoadObject) arr[mid];
 71           }
 72        } else { // match found
 73           return (LoadObject) arr[mid];
 74        }
 75     }
 76     // no match found.
 77     return null;
 78   }
 79 
 80   public CFrame topFrameForThread(ThreadProxy thread) throws DebuggerException {
 81     return dbg.topFrameForThread(thread);
 82   }
 83 
 84   public String getNameOfFile(String fileName) {
 85     return new File(fileName).getName();
 86   }
 87 
 88   public ProcessControl getProcessControl() throws DebuggerException {
 89     // FIXME: after stabs parser
 90     return null;
 91   }
 92 
 93   // C++ name demangling
 94   public boolean canDemangle() {
 95     return true;
 96   }
 97 
 98   public String demangle(String sym) {
 99     return dbg.demangle(sym);
100   }
101 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/InstanceKlass.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InstanceClassLoaderKlass.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InstanceMirrorKlass.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/InstanceKlass.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 package sun.jvm.hotspot.oops;
  26 
  27 import java.io.*;
  28 import java.util.*;
  29 import sun.jvm.hotspot.classfile.ClassLoaderData;
  30 import sun.jvm.hotspot.debugger.*;
  31 import sun.jvm.hotspot.memory.*;
  32 import sun.jvm.hotspot.memory.Dictionary;
  33 import sun.jvm.hotspot.runtime.*;
  34 import sun.jvm.hotspot.types.*;
  35 import sun.jvm.hotspot.utilities.*;


  36 
  37 // An InstanceKlass is the VM level representation of a Java class.
  38 
  39 public class InstanceKlass extends Klass {
  40   static {
  41     VM.registerVMInitializedObserver(new Observer() {
  42         public void update(Observable o, Object data) {
  43           initialize(VM.getVM().getTypeDataBase());
  44         }
  45       });
  46   }
  47 
  48   // field offset constants
  49   private static int ACCESS_FLAGS_OFFSET;
  50   private static int NAME_INDEX_OFFSET;
  51   private static int SIGNATURE_INDEX_OFFSET;
  52   private static int INITVAL_INDEX_OFFSET;
  53   private static int LOW_OFFSET;
  54   private static int HIGH_OFFSET;
  55   private static int FIELD_SLOTS;
</pre>
<hr />
<pre>
 665     }
 666   }
 667 
 668   public Klass getJavaSuper() {
 669     return getSuper();
 670   }
 671 
 672   public static class StaticField {
 673     public AccessFlags flags;
 674     public Field field;
 675 
 676     StaticField(Field field, AccessFlags flags) {
 677       this.field = field;
 678       this.flags = flags;
 679     }
 680   }
 681 
 682   public Field[] getStaticFields() {
 683     U2Array fields = getFields();
 684     int length = getJavaFieldsCount();
<span class="line-modified"> 685     ArrayList result = new ArrayList();</span>
 686     for (int index = 0; index &lt; length; index++) {
 687       Field f = newField(index);
 688       if (f.isStatic()) {
 689         result.add(f);
 690       }
 691     }
<span class="line-modified"> 692     return (Field[])result.toArray(new Field[result.size()]);</span>
 693   }
 694 
 695   public void iterateNonStaticFields(OopVisitor visitor, Oop obj) {
 696     if (getSuper() != null) {
 697       ((InstanceKlass) getSuper()).iterateNonStaticFields(visitor, obj);
 698     }
 699     int length = getJavaFieldsCount();
 700     for (int index = 0; index &lt; length; index++) {
 701       short accessFlags    = getFieldAccessFlags(index);
 702       FieldType   type   = new FieldType(getFieldSignature(index));
 703       AccessFlags access = new AccessFlags(accessFlags);
 704       if (!access.isStatic()) {
 705         visitField(visitor, type, index);
 706       }
 707     }
 708   }
 709 
 710   /** Field access by name. */
 711   public Field findLocalField(String name, String sig) {
 712     int length = getJavaFieldsCount();
</pre>
<hr />
<pre>
 767   }
 768 
 769   /** Find field according to JVM spec 5.4.3.2, returns the klass in
 770       which the field is defined (retained only for backward
 771       compatibility with jdbx) */
 772   public Field findFieldDbg(String name, String sig) {
 773     return findField(name, sig);
 774   }
 775 
 776   /** Get field by its index in the fields array. Only designed for
 777       use in a debugging system. */
 778   public Field getFieldByIndex(int fieldIndex) {
 779     return newField(fieldIndex);
 780   }
 781 
 782 
 783     /** Return a List of SA Fields for the fields declared in this class.
 784         Inherited fields are not included.
 785         Return an empty list if there are no fields declared in this class.
 786         Only designed for use in a debugging system. */
<span class="line-modified"> 787     public List getImmediateFields() {</span>
 788         // A list of Fields for each field declared in this class/interface,
 789         // not including inherited fields.
 790         int length = getJavaFieldsCount();
<span class="line-modified"> 791         List immediateFields = new ArrayList(length);</span>
 792         for (int index = 0; index &lt; length; index++) {
 793             immediateFields.add(getFieldByIndex(index));
 794         }
 795 
 796         return immediateFields;
 797     }
 798 
 799     /** Return a List of SA Fields for all the java fields in this class,
 800         including all inherited fields.  This includes hidden
 801         fields.  Thus the returned list can contain fields with
 802         the same name.
 803         Return an empty list if there are no fields.
 804         Only designed for use in a debugging system. */
<span class="line-modified"> 805     public List getAllFields() {</span>
 806         // Contains a Field for each field in this class, including immediate
 807         // fields and inherited fields.
<span class="line-modified"> 808         List  allFields = getImmediateFields();</span>
 809 
 810         // transitiveInterfaces contains all interfaces implemented
 811         // by this class and its superclass chain with no duplicates.
 812 
 813         KlassArray interfaces = getTransitiveInterfaces();
 814         int n = interfaces.length();
 815         for (int i = 0; i &lt; n; i++) {
 816             InstanceKlass intf1 = (InstanceKlass) interfaces.getAt(i);
 817             if (Assert.ASSERTS_ENABLED) {
 818                 Assert.that(intf1.isInterface(), &quot;just checking type&quot;);
 819             }
 820             allFields.addAll(intf1.getImmediateFields());
 821         }
 822 
 823         // Get all fields in the superclass, recursively.  But, don&#39;t
 824         // include fields in interfaces implemented by superclasses;
 825         // we already have all those.
 826         if (!isInterface()) {
 827             InstanceKlass supr;
 828             if  ( (supr = (InstanceKlass) getSuper()) != null) {
 829                 allFields.addAll(supr.getImmediateFields());
 830             }
 831         }
 832 
 833         return allFields;
 834     }
 835 
 836 
 837     /** Return a List of SA Methods declared directly in this class/interface.
 838         Return an empty list if there are none, or if this isn&#39;t a class/
 839         interface.
 840     */
<span class="line-modified"> 841     public List getImmediateMethods() {</span>
 842       // Contains a Method for each method declared in this class/interface
 843       // not including inherited methods.
 844 
 845       MethodArray methods = getMethods();
 846       int length = methods.length();
<span class="line-modified"> 847       Object[] tmp = new Object[length];</span>
 848 
 849       IntArray methodOrdering = getMethodOrdering();
 850       if (methodOrdering.length() != length) {
 851          // no ordering info present
 852          for (int index = 0; index &lt; length; index++) {
 853             tmp[index] = methods.at(index);
 854          }
 855       } else {
 856          for (int index = 0; index &lt; length; index++) {
 857             int originalIndex = methodOrdering.at(index);
 858             tmp[originalIndex] = methods.at(index);
 859          }
 860       }
 861 
 862       return Arrays.asList(tmp);
 863     }
 864 
 865     /** Return a List containing an SA InstanceKlass for each
 866         interface named in this class&#39;s &#39;implements&#39; clause.
 867     */
<span class="line-modified"> 868     public List getDirectImplementedInterfaces() {</span>
 869         // Contains an InstanceKlass for each interface in this classes
 870         // &#39;implements&#39; clause.
 871 
 872         KlassArray interfaces = getLocalInterfaces();
 873         int length = interfaces.length();
<span class="line-modified"> 874         List directImplementedInterfaces = new ArrayList(length);</span>
 875 
 876         for (int index = 0; index &lt; length; index ++) {
 877             directImplementedInterfaces.add(interfaces.getAt(index));
 878         }
 879 
 880         return directImplementedInterfaces;
 881     }
 882 
 883   public Klass arrayKlassImpl(boolean orNull, int n) {
 884     // FIXME: in reflective system this would need to change to
 885     // actually allocate
 886     if (getArrayKlasses() == null) { return null; }
 887     ObjArrayKlass oak = (ObjArrayKlass) getArrayKlasses();
 888     if (orNull) {
 889       return oak.arrayKlassOrNull(n);
 890     }
 891     return oak.arrayKlass(n);
 892   }
 893 
 894   public Klass arrayKlassImpl(boolean orNull) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 package sun.jvm.hotspot.oops;
  26 
  27 import java.io.*;
  28 import java.util.*;
  29 import sun.jvm.hotspot.classfile.ClassLoaderData;
  30 import sun.jvm.hotspot.debugger.*;
  31 import sun.jvm.hotspot.memory.*;
  32 import sun.jvm.hotspot.memory.Dictionary;
  33 import sun.jvm.hotspot.runtime.*;
  34 import sun.jvm.hotspot.types.*;
  35 import sun.jvm.hotspot.utilities.*;
<span class="line-added">  36 import sun.jvm.hotspot.utilities.Observable;</span>
<span class="line-added">  37 import sun.jvm.hotspot.utilities.Observer;</span>
  38 
  39 // An InstanceKlass is the VM level representation of a Java class.
  40 
  41 public class InstanceKlass extends Klass {
  42   static {
  43     VM.registerVMInitializedObserver(new Observer() {
  44         public void update(Observable o, Object data) {
  45           initialize(VM.getVM().getTypeDataBase());
  46         }
  47       });
  48   }
  49 
  50   // field offset constants
  51   private static int ACCESS_FLAGS_OFFSET;
  52   private static int NAME_INDEX_OFFSET;
  53   private static int SIGNATURE_INDEX_OFFSET;
  54   private static int INITVAL_INDEX_OFFSET;
  55   private static int LOW_OFFSET;
  56   private static int HIGH_OFFSET;
  57   private static int FIELD_SLOTS;
</pre>
<hr />
<pre>
 667     }
 668   }
 669 
 670   public Klass getJavaSuper() {
 671     return getSuper();
 672   }
 673 
 674   public static class StaticField {
 675     public AccessFlags flags;
 676     public Field field;
 677 
 678     StaticField(Field field, AccessFlags flags) {
 679       this.field = field;
 680       this.flags = flags;
 681     }
 682   }
 683 
 684   public Field[] getStaticFields() {
 685     U2Array fields = getFields();
 686     int length = getJavaFieldsCount();
<span class="line-modified"> 687     ArrayList&lt;Field&gt; result = new ArrayList&lt;&gt;();</span>
 688     for (int index = 0; index &lt; length; index++) {
 689       Field f = newField(index);
 690       if (f.isStatic()) {
 691         result.add(f);
 692       }
 693     }
<span class="line-modified"> 694     return result.toArray(new Field[result.size()]);</span>
 695   }
 696 
 697   public void iterateNonStaticFields(OopVisitor visitor, Oop obj) {
 698     if (getSuper() != null) {
 699       ((InstanceKlass) getSuper()).iterateNonStaticFields(visitor, obj);
 700     }
 701     int length = getJavaFieldsCount();
 702     for (int index = 0; index &lt; length; index++) {
 703       short accessFlags    = getFieldAccessFlags(index);
 704       FieldType   type   = new FieldType(getFieldSignature(index));
 705       AccessFlags access = new AccessFlags(accessFlags);
 706       if (!access.isStatic()) {
 707         visitField(visitor, type, index);
 708       }
 709     }
 710   }
 711 
 712   /** Field access by name. */
 713   public Field findLocalField(String name, String sig) {
 714     int length = getJavaFieldsCount();
</pre>
<hr />
<pre>
 769   }
 770 
 771   /** Find field according to JVM spec 5.4.3.2, returns the klass in
 772       which the field is defined (retained only for backward
 773       compatibility with jdbx) */
 774   public Field findFieldDbg(String name, String sig) {
 775     return findField(name, sig);
 776   }
 777 
 778   /** Get field by its index in the fields array. Only designed for
 779       use in a debugging system. */
 780   public Field getFieldByIndex(int fieldIndex) {
 781     return newField(fieldIndex);
 782   }
 783 
 784 
 785     /** Return a List of SA Fields for the fields declared in this class.
 786         Inherited fields are not included.
 787         Return an empty list if there are no fields declared in this class.
 788         Only designed for use in a debugging system. */
<span class="line-modified"> 789     public List&lt;Field&gt; getImmediateFields() {</span>
 790         // A list of Fields for each field declared in this class/interface,
 791         // not including inherited fields.
 792         int length = getJavaFieldsCount();
<span class="line-modified"> 793         List&lt;Field&gt; immediateFields = new ArrayList&lt;&gt;(length);</span>
 794         for (int index = 0; index &lt; length; index++) {
 795             immediateFields.add(getFieldByIndex(index));
 796         }
 797 
 798         return immediateFields;
 799     }
 800 
 801     /** Return a List of SA Fields for all the java fields in this class,
 802         including all inherited fields.  This includes hidden
 803         fields.  Thus the returned list can contain fields with
 804         the same name.
 805         Return an empty list if there are no fields.
 806         Only designed for use in a debugging system. */
<span class="line-modified"> 807     public List&lt;Field&gt; getAllFields() {</span>
 808         // Contains a Field for each field in this class, including immediate
 809         // fields and inherited fields.
<span class="line-modified"> 810         List&lt;Field&gt; allFields = getImmediateFields();</span>
 811 
 812         // transitiveInterfaces contains all interfaces implemented
 813         // by this class and its superclass chain with no duplicates.
 814 
 815         KlassArray interfaces = getTransitiveInterfaces();
 816         int n = interfaces.length();
 817         for (int i = 0; i &lt; n; i++) {
 818             InstanceKlass intf1 = (InstanceKlass) interfaces.getAt(i);
 819             if (Assert.ASSERTS_ENABLED) {
 820                 Assert.that(intf1.isInterface(), &quot;just checking type&quot;);
 821             }
 822             allFields.addAll(intf1.getImmediateFields());
 823         }
 824 
 825         // Get all fields in the superclass, recursively.  But, don&#39;t
 826         // include fields in interfaces implemented by superclasses;
 827         // we already have all those.
 828         if (!isInterface()) {
 829             InstanceKlass supr;
 830             if  ( (supr = (InstanceKlass) getSuper()) != null) {
 831                 allFields.addAll(supr.getImmediateFields());
 832             }
 833         }
 834 
 835         return allFields;
 836     }
 837 
 838 
 839     /** Return a List of SA Methods declared directly in this class/interface.
 840         Return an empty list if there are none, or if this isn&#39;t a class/
 841         interface.
 842     */
<span class="line-modified"> 843     public List&lt;Method&gt; getImmediateMethods() {</span>
 844       // Contains a Method for each method declared in this class/interface
 845       // not including inherited methods.
 846 
 847       MethodArray methods = getMethods();
 848       int length = methods.length();
<span class="line-modified"> 849       Method[] tmp = new Method[length];</span>
 850 
 851       IntArray methodOrdering = getMethodOrdering();
 852       if (methodOrdering.length() != length) {
 853          // no ordering info present
 854          for (int index = 0; index &lt; length; index++) {
 855             tmp[index] = methods.at(index);
 856          }
 857       } else {
 858          for (int index = 0; index &lt; length; index++) {
 859             int originalIndex = methodOrdering.at(index);
 860             tmp[originalIndex] = methods.at(index);
 861          }
 862       }
 863 
 864       return Arrays.asList(tmp);
 865     }
 866 
 867     /** Return a List containing an SA InstanceKlass for each
 868         interface named in this class&#39;s &#39;implements&#39; clause.
 869     */
<span class="line-modified"> 870     public List&lt;Klass&gt; getDirectImplementedInterfaces() {</span>
 871         // Contains an InstanceKlass for each interface in this classes
 872         // &#39;implements&#39; clause.
 873 
 874         KlassArray interfaces = getLocalInterfaces();
 875         int length = interfaces.length();
<span class="line-modified"> 876         List&lt;Klass&gt; directImplementedInterfaces = new ArrayList&lt;&gt;(length);</span>
 877 
 878         for (int index = 0; index &lt; length; index ++) {
 879             directImplementedInterfaces.add(interfaces.getAt(index));
 880         }
 881 
 882         return directImplementedInterfaces;
 883     }
 884 
 885   public Klass arrayKlassImpl(boolean orNull, int n) {
 886     // FIXME: in reflective system this would need to change to
 887     // actually allocate
 888     if (getArrayKlasses() == null) { return null; }
 889     ObjArrayKlass oak = (ObjArrayKlass) getArrayKlasses();
 890     if (orNull) {
 891       return oak.arrayKlassOrNull(n);
 892     }
 893     return oak.arrayKlass(n);
 894   }
 895 
 896   public Klass arrayKlassImpl(boolean orNull) {
</pre>
</td>
</tr>
</table>
<center><a href="InstanceClassLoaderKlass.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InstanceMirrorKlass.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/linux/LinuxDebuggerLocal.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.debugger.linux;
 26 
 27 import java.io.File;
 28 import java.io.IOException;
 29 import java.io.UncheckedIOException;
 30 import java.nio.file.Files;
 31 import java.nio.file.Path;
 32 import java.nio.file.Paths;
 33 import java.util.ArrayList;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.NoSuchElementException;
 37 import java.util.stream.Collectors;
 38 
 39 import sun.jvm.hotspot.debugger.Address;
 40 import sun.jvm.hotspot.debugger.DebuggerBase;
 41 import sun.jvm.hotspot.debugger.DebuggerException;
 42 import sun.jvm.hotspot.debugger.DebuggerUtilities;
 43 import sun.jvm.hotspot.debugger.MachineDescription;
 44 import sun.jvm.hotspot.debugger.NotInHeapException;
 45 import sun.jvm.hotspot.debugger.OopHandle;
<a name="1" id="anc1"></a><span class="line-added"> 46 import sun.jvm.hotspot.debugger.ProcessInfo;</span>
 47 import sun.jvm.hotspot.debugger.ReadResult;
 48 import sun.jvm.hotspot.debugger.ThreadProxy;
 49 import sun.jvm.hotspot.debugger.UnalignedAddressException;
 50 import sun.jvm.hotspot.debugger.UnmappedAddressException;
 51 import sun.jvm.hotspot.debugger.cdbg.CDebugger;
 52 import sun.jvm.hotspot.debugger.cdbg.ClosestSymbol;
 53 import sun.jvm.hotspot.debugger.cdbg.LoadObject;
 54 import sun.jvm.hotspot.utilities.PlatformInfo;
 55 
 56 /** &lt;P&gt; An implementation of the JVMDebugger interface. The basic debug
 57     facilities are implemented through ptrace interface in the JNI code
 58     (libsaproc.so). Library maps and symbol table management are done in
 59     JNI. &lt;/P&gt;
 60 
 61     &lt;P&gt; &lt;B&gt;NOTE&lt;/B&gt; that since we have the notion of fetching &quot;Java
 62     primitive types&quot; from the remote process (which might have
 63     different sizes than we expect) we have a bootstrapping
 64     problem. We need to know the sizes of these types before we can
 65     fetch them. The current implementation solves this problem by
 66     requiring that it be configured with these type sizes before they
 67     can be fetched. The readJ(Type) routines here will throw a
 68     RuntimeException if they are called before the debugger is
 69     configured with the Java primitive type sizes. &lt;/P&gt; */
 70 
 71 public class LinuxDebuggerLocal extends DebuggerBase implements LinuxDebugger {
 72     private boolean useGCC32ABI;
 73     private boolean attached;
 74     private long    p_ps_prochandle; // native debugger handle
 75     private boolean isCore;
 76 
 77     // CDebugger support
 78     private LinuxCDebugger cdbg;
 79 
 80     // threadList and loadObjectList are filled by attach0 method
<a name="2" id="anc2"></a><span class="line-modified"> 81     private List&lt;ThreadProxy&gt; threadList;</span>
<span class="line-modified"> 82     private List&lt;LoadObject&gt; loadObjectList;</span>
 83 
 84     // PID namespace support
 85     // It maps the LWPID in the host to the LWPID in the container.
 86     private Map&lt;Integer, Integer&gt; nspidMap;
 87 
 88     // called by native method lookupByAddress0
 89     private ClosestSymbol createClosestSymbol(String name, long offset) {
 90        return new ClosestSymbol(name, offset);
 91     }
 92 
 93     // called by native method attach0
 94     private LoadObject createLoadObject(String fileName, long textsize,
 95                                         long base) {
 96        File f = new File(fileName);
 97        Address baseAddr = newAddress(base);
 98        return new SharedObject(this, fileName, f.length(), baseAddr);
 99     }
100 
101     // native methods
102 
103     private native static void init0()
104                                 throws DebuggerException;
105     private native void setSAAltRoot0(String altroot);
106     private native void attach0(int pid)
107                                 throws DebuggerException;
108     private native void attach0(String execName, String coreName)
109                                 throws DebuggerException;
110     private native void detach0()
111                                 throws DebuggerException;
112     private native long lookupByName0(String objectName, String symbol)
113                                 throws DebuggerException;
114     private native ClosestSymbol lookupByAddress0(long address)
115                                 throws DebuggerException;
116     private native long[] getThreadIntegerRegisterSet0(int lwp_id)
117                                 throws DebuggerException;
118     private native byte[] readBytesFromProcess0(long address, long numBytes)
119                                 throws DebuggerException;
120     public native static int  getAddressSize() ;
121 
122     @Override
123     public native String demangle(String sym);
124 
125     public native long findLibPtrByAddress0(long pc);
126 
127     @Override
128     public Address findLibPtrByAddress(Address pc) {
129       long ptr = findLibPtrByAddress0(pc.asLongValue());
130       return (ptr == 0L) ? null
131                          : new LinuxAddress(this, ptr);
132     }
133 
134     // Note on Linux threads are really processes. When target process is
135     // attached by a serviceability agent thread, only that thread can do
136     // ptrace operations on the target. This is because from kernel&#39;s point
137     // view, other threads are just separate processes and they are not
138     // attached to the target. When they attempt to make ptrace calls,
139     // an ESRCH error will be returned as kernel believes target is not
140     // being traced by the caller.
141     // To work around the problem, we use a worker thread here to handle
142     // all JNI functions that are making ptrace calls.
143 
144     interface WorkerThreadTask {
145        public void doit(LinuxDebuggerLocal debugger) throws DebuggerException;
146     }
147 
148     class LinuxDebuggerLocalWorkerThread extends Thread {
149        LinuxDebuggerLocal debugger;
150        WorkerThreadTask task;
151        DebuggerException lastException;
152 
153        public LinuxDebuggerLocalWorkerThread(LinuxDebuggerLocal debugger) {
154          this.debugger = debugger;
155          setDaemon(true);
156        }
157 
158        public void run() {
159           synchronized (workerThread) {
160              for (;;) {
161                 if (task != null) {
162                    lastException = null;
163                    try {
164                       task.doit(debugger);
165                    } catch (DebuggerException exp) {
166                       lastException = exp;
167                    }
168                    task = null;
169                    workerThread.notifyAll();
170                 }
171 
172                 try {
173                    workerThread.wait();
174                 } catch (InterruptedException x) {}
175              }
176           }
177        }
178 
179        public WorkerThreadTask execute(WorkerThreadTask task) throws DebuggerException {
180           synchronized (workerThread) {
181              this.task = task;
182              workerThread.notifyAll();
183              while (this.task != null) {
184                 try {
185                    workerThread.wait();
186                 } catch (InterruptedException x) {}
187              }
188              if (lastException != null) {
189                 throw new DebuggerException(lastException);
190              } else {
191                 return task;
192              }
193           }
194        }
195     }
196 
197     private LinuxDebuggerLocalWorkerThread workerThread = null;
198 
199     //----------------------------------------------------------------------
200     // Implementation of Debugger interface
201     //
202 
203     /** &lt;P&gt; machDesc may not be null. &lt;/P&gt;
204 
205     &lt;P&gt; useCache should be set to true if debugging is being done
206     locally, and to false if the debugger is being created for the
207     purpose of supporting remote debugging. &lt;/P&gt; */
208     public LinuxDebuggerLocal(MachineDescription machDesc,
209                               boolean useCache) throws DebuggerException {
210         this.machDesc = machDesc;
211         utils = new DebuggerUtilities(machDesc.getAddressSize(),
212                                       machDesc.isBigEndian()) {
213            public void checkAlignment(long address, long alignment) {
214              // Need to override default checkAlignment because we need to
215              // relax alignment constraints on Linux/x86
216              if ( (address % alignment != 0)
217                 &amp;&amp;(alignment != 8 || address % 4 != 0)) {
218                 throw new UnalignedAddressException(
219                         &quot;Trying to read at address: &quot;
220                       + addressValueToString(address)
221                       + &quot; with alignment: &quot; + alignment,
222                         address);
223              }
224            }
225         };
226 
227         if (useCache) {
228             // FIXME: re-test necessity of cache on Linux, where data
229             // fetching is faster
230             // Cache portion of the remote process&#39;s address space.
231             // Fetching data over the socket connection to dbx is slow.
232             // Might be faster if we were using a binary protocol to talk to
233             // dbx, but would have to test. For now, this cache works best
234             // if it covers the entire heap of the remote process. FIXME: at
235             // least should make this tunable from the outside, i.e., via
236             // the UI. This is a cache of 4096 4K pages, or 16 MB. The page
237             // size must be adjusted to be the hardware&#39;s page size.
238             // (FIXME: should pick this up from the debugger.)
239             initCache(4096, parseCacheNumPagesProperty(4096));
240         }
241 
242         workerThread = new LinuxDebuggerLocalWorkerThread(this);
243         workerThread.start();
244     }
245 
246     /** From the Debugger interface via JVMDebugger */
247     public boolean hasProcessList() throws DebuggerException {
248         return false;
249     }
250 
251     /** From the Debugger interface via JVMDebugger */
<a name="3" id="anc3"></a><span class="line-modified">252     public List&lt;ProcessInfo&gt; getProcessList() throws DebuggerException {</span>
253         throw new DebuggerException(&quot;getProcessList not implemented yet&quot;);
254     }
255 
256     private void checkAttached() throws DebuggerException {
257         if (attached) {
258             if (isCore) {
259                 throw new DebuggerException(&quot;attached to a core dump already&quot;);
260             } else {
261                 throw new DebuggerException(&quot;attached to a process already&quot;);
262             }
263         }
264     }
265 
266     private void requireAttach() {
267         if (! attached) {
268             throw new RuntimeException(&quot;not attached to a process or a core!&quot;);
269         }
270     }
271 
272     /* called from attach methods */
273     private void findABIVersion() throws DebuggerException {
274         if (lookupByName0(&quot;libjvm.so&quot;, &quot;__vt_10JavaThread&quot;) != 0) {
275             // old C++ ABI
276             useGCC32ABI = false;
277         } else {
278             // new C++ ABI
279             useGCC32ABI = true;
280         }
281     }
282 
283     // Get namespace PID from /proc/&lt;PID&gt;/status.
284     private int getNamespacePID(Path statusPath) {
285         try (var lines = Files.lines(statusPath)) {
286             return lines.map(s -&gt; s.split(&quot;\\s+&quot;))
287                         .filter(a -&gt; a.length == 3)
288                         .filter(a -&gt; a[0].equals(&quot;NSpid:&quot;))
289                         .mapToInt(a -&gt; Integer.valueOf(a[2]))
290                         .findFirst()
291                         .getAsInt();
292         } catch (IOException | NoSuchElementException e) {
293             return Integer.valueOf(statusPath.getParent()
294                                              .toFile()
295                                              .getName());
296         }
297     }
298 
299     // Get LWPID in the host from the container&#39;s LWPID.
300     // Returns -1 if the process is running in the host.
301     public int getHostPID(int id) {
302         return (nspidMap == null) ? -1 : nspidMap.get(id);
303     }
304 
305     // Fill namespace PID map from procfs.
306     // This method scans all tasks (/proc/&lt;PID&gt;/task) in the process.
307     private void fillNSpidMap(Path proc) {
308         Path task = Paths.get(proc.toString(), &quot;task&quot;);
309         try (var tasks = Files.list(task)) {
310             nspidMap = tasks.filter(p -&gt; !p.toString().startsWith(&quot;.&quot;))
311                             .collect(Collectors.toMap(p -&gt; Integer.valueOf(getNamespacePID(Paths.get(p.toString(), &quot;status&quot;))),
312                                                       p -&gt; Integer.valueOf(p.toFile().getName())));
313         } catch (IOException e) {
314             throw new UncheckedIOException(e);
315         }
316     }
317 
318     /** From the Debugger interface via JVMDebugger */
319     public synchronized void attach(int processID) throws DebuggerException {
320         checkAttached();
<a name="4" id="anc4"></a><span class="line-modified">321         threadList = new ArrayList&lt;&gt;();</span>
<span class="line-modified">322         loadObjectList = new ArrayList&lt;&gt;();</span>
323 
324         Path proc = Paths.get(&quot;/proc&quot;, Integer.toString(processID));
325         int NSpid = getNamespacePID(Paths.get(proc.toString(), &quot;status&quot;));
326         if (NSpid != processID) {
327             // If PID different from namespace PID, we can assume the process
328             // is running in the container.
329             // So we need to set SA_ALTROOT environment variable that SA reads
330             // binaries in the container.
331             setSAAltRoot0(Paths.get(proc.toString(), &quot;root&quot;).toString());
332             fillNSpidMap(proc);
333         }
334 
335         class AttachTask implements WorkerThreadTask {
336            int pid;
337            public void doit(LinuxDebuggerLocal debugger) {
338               debugger.attach0(pid);
339               debugger.attached = true;
340               debugger.isCore = false;
341               findABIVersion();
342            }
343         }
344 
345         AttachTask task = new AttachTask();
346         task.pid = processID;
347         workerThread.execute(task);
348     }
349 
350     /** From the Debugger interface via JVMDebugger */
351     public synchronized void attach(String execName, String coreName) {
352         checkAttached();
<a name="5" id="anc5"></a><span class="line-modified">353         threadList = new ArrayList&lt;&gt;();</span>
<span class="line-modified">354         loadObjectList = new ArrayList&lt;&gt;();</span>
355         attach0(execName, coreName);
356         attached = true;
357         isCore = true;
358         findABIVersion();
359     }
360 
361     /** From the Debugger interface via JVMDebugger */
362     public synchronized boolean detach() {
363         if (!attached) {
364             return false;
365         }
366 
367         threadList = null;
368         loadObjectList = null;
369 
370         if (isCore) {
371             detach0();
372             attached = false;
373             return true;
374         } else {
375             class DetachTask implements WorkerThreadTask {
376                 boolean result = false;
377 
378                 public void doit(LinuxDebuggerLocal debugger) {
379                     debugger.detach0();
380                     debugger.attached = false;
381                     result = true;
382                 }
383             }
384 
385             DetachTask task = new DetachTask();
386             workerThread.execute(task);
387             return task.result;
388         }
389     }
390 
391     /** From the Debugger interface via JVMDebugger */
392     public Address parseAddress(String addressString)
393             throws NumberFormatException {
394         long addr = utils.scanAddress(addressString);
395         if (addr == 0) {
396             return null;
397         }
398         return new LinuxAddress(this, addr);
399     }
400 
401     /** From the Debugger interface via JVMDebugger */
402     public String getOS() {
403         return PlatformInfo.getOS();
404     }
405 
406     /** From the Debugger interface via JVMDebugger */
407     public String getCPU() {
408         return PlatformInfo.getCPU();
409     }
410 
411     public boolean hasConsole() throws DebuggerException {
412         return false;
413     }
414 
415     public String consoleExecuteCommand(String cmd) throws DebuggerException {
416         throw new DebuggerException(&quot;No debugger console available on Linux&quot;);
417     }
418 
419     public String getConsolePrompt() throws DebuggerException {
420         return null;
421     }
422 
423     /* called from lookup */
424     private long handleGCC32ABI(long addr, String symbol) throws DebuggerException {
425         if (useGCC32ABI &amp;&amp; symbol.startsWith(&quot;_ZTV&quot;)) {
426             return addr + (2 * machDesc.getAddressSize());
427         } else {
428             return addr;
429         }
430     }
431 
432     /** From the SymbolLookup interface via Debugger and JVMDebugger */
433     public synchronized Address lookup(String objectName, String symbol) {
434         requireAttach();
435         if (!attached) {
436             return null;
437         }
438 
439         if (isCore) {
440             long addr = lookupByName0(objectName, symbol);
441             return (addr == 0)? null : new LinuxAddress(this, handleGCC32ABI(addr, symbol));
442         } else {
443             class LookupByNameTask implements WorkerThreadTask {
444                 String objectName, symbol;
445                 Address result;
446 
447                 public void doit(LinuxDebuggerLocal debugger) {
448                     long addr = debugger.lookupByName0(objectName, symbol);
449                     result = (addr == 0 ? null : new LinuxAddress(debugger, handleGCC32ABI(addr, symbol)));
450                 }
451             }
452 
453             LookupByNameTask task = new LookupByNameTask();
454             task.objectName = objectName;
455             task.symbol = symbol;
456             workerThread.execute(task);
457             return task.result;
458         }
459     }
460 
461     /** From the SymbolLookup interface via Debugger and JVMDebugger */
462     public synchronized OopHandle lookupOop(String objectName, String symbol) {
463         Address addr = lookup(objectName, symbol);
464         if (addr == null) {
465             return null;
466         }
467         return addr.addOffsetToAsOopHandle(0);
468     }
469 
470     /** From the Debugger interface */
471     public MachineDescription getMachineDescription() {
472         return machDesc;
473     }
474 
475     //----------------------------------------------------------------------
476     // Implementation of ThreadAccess interface
477     //
478 
479     /** From the ThreadAccess interface via Debugger and JVMDebugger */
480     public ThreadProxy getThreadForIdentifierAddress(Address addr) {
481         return new LinuxThread(this, addr);
482     }
483 
484     /** From the ThreadAccess interface via Debugger and JVMDebugger */
485     public ThreadProxy getThreadForThreadId(long id) {
486         return new LinuxThread(this, id);
487     }
488 
489     //----------------------------------------------------------------------
490     // Internal routines (for implementation of LinuxAddress).
491     // These must not be called until the MachineDescription has been set up.
492     //
493 
494     /** From the LinuxDebugger interface */
495     public String addressValueToString(long address) {
496         return utils.addressValueToString(address);
497     }
498 
499     /** From the LinuxDebugger interface */
500     public LinuxAddress readAddress(long address)
501             throws UnmappedAddressException, UnalignedAddressException {
502         long value = readAddressValue(address);
503         return (value == 0 ? null : new LinuxAddress(this, value));
504     }
505     public LinuxAddress readCompOopAddress(long address)
506             throws UnmappedAddressException, UnalignedAddressException {
507         long value = readCompOopAddressValue(address);
508         return (value == 0 ? null : new LinuxAddress(this, value));
509     }
510 
511     public LinuxAddress readCompKlassAddress(long address)
512             throws UnmappedAddressException, UnalignedAddressException {
513         long value = readCompKlassAddressValue(address);
514         return (value == 0 ? null : new LinuxAddress(this, value));
515     }
516 
517     /** From the LinuxDebugger interface */
518     public LinuxOopHandle readOopHandle(long address)
519             throws UnmappedAddressException, UnalignedAddressException,
520                 NotInHeapException {
521         long value = readAddressValue(address);
522         return (value == 0 ? null : new LinuxOopHandle(this, value));
523     }
524     public LinuxOopHandle readCompOopHandle(long address)
525             throws UnmappedAddressException, UnalignedAddressException,
526                 NotInHeapException {
527         long value = readCompOopAddressValue(address);
528         return (value == 0 ? null : new LinuxOopHandle(this, value));
529     }
530 
531     //----------------------------------------------------------------------
532     // Thread context access
533     //
534 
535     public synchronized long[] getThreadIntegerRegisterSet(int lwp_id)
536                                             throws DebuggerException {
537         requireAttach();
538         if (isCore) {
539             return getThreadIntegerRegisterSet0(lwp_id);
540         } else {
541             class GetThreadIntegerRegisterSetTask implements WorkerThreadTask {
542                 int lwp_id;
543                 long[] result;
544                 public void doit(LinuxDebuggerLocal debugger) {
545                     result = debugger.getThreadIntegerRegisterSet0(lwp_id);
546                 }
547             }
548 
549             GetThreadIntegerRegisterSetTask task = new GetThreadIntegerRegisterSetTask();
550             task.lwp_id = lwp_id;
551             workerThread.execute(task);
552             return task.result;
553         }
554     }
555 
556     /** Need to override this to relax alignment checks on x86. */
557     public long readCInteger(long address, long numBytes, boolean isUnsigned)
558         throws UnmappedAddressException, UnalignedAddressException {
559         // Only slightly relaxed semantics -- this is a hack, but is
560         // necessary on x86 where it seems the compiler is
561         // putting some global 64-bit data on 32-bit boundaries
562         if (numBytes == 8) {
563             utils.checkAlignment(address, 4);
564         } else {
565             utils.checkAlignment(address, numBytes);
566         }
567         byte[] data = readBytes(address, numBytes);
568         return utils.dataToCInteger(data, isUnsigned);
569     }
570 
571     // Overridden from DebuggerBase because we need to relax alignment
572     // constraints on x86
573     public long readJLong(long address)
574         throws UnmappedAddressException, UnalignedAddressException {
575         utils.checkAlignment(address, jintSize);
576         byte[] data = readBytes(address, jlongSize);
577         return utils.dataToJLong(data, jlongSize);
578     }
579 
580     //----------------------------------------------------------------------
581     // Address access. Can not be package private, but should only be
582     // accessed by the architecture-specific subpackages.
583 
584     /** From the LinuxDebugger interface */
585     public long getAddressValue(Address addr) {
586       if (addr == null) return 0;
587       return ((LinuxAddress) addr).getValue();
588     }
589 
590     /** From the LinuxDebugger interface */
591     public Address newAddress(long value) {
592       if (value == 0) return null;
593       return new LinuxAddress(this, value);
594     }
595 
596     /** From the LinuxCDebugger interface */
<a name="6" id="anc6"></a><span class="line-modified">597     public List&lt;ThreadProxy&gt; getThreadList() {</span>
598       requireAttach();
599       return threadList;
600     }
601 
602     /** From the LinuxCDebugger interface */
<a name="7" id="anc7"></a><span class="line-modified">603     public List&lt;LoadObject&gt; getLoadObjectList() {</span>
604       requireAttach();
605       return loadObjectList;
606     }
607 
608     /** From the LinuxCDebugger interface */
609     public synchronized ClosestSymbol lookup(long addr) {
610        requireAttach();
611        if (isCore) {
612           return lookupByAddress0(addr);
613        } else {
614           class LookupByAddressTask implements WorkerThreadTask {
615              long addr;
616              ClosestSymbol result;
617 
618              public void doit(LinuxDebuggerLocal debugger) {
619                  result = debugger.lookupByAddress0(addr);
620              }
621           }
622 
623           LookupByAddressTask task = new LookupByAddressTask();
624           task.addr = addr;
625           workerThread.execute(task);
626           return task.result;
627        }
628     }
629 
630     public CDebugger getCDebugger() {
631       if (cdbg == null) {
632          cdbg = new LinuxCDebugger(this);
633       }
634       return cdbg;
635     }
636 
637     /** This reads bytes from the remote process. */
638     public synchronized ReadResult readBytesFromProcess(long address,
639             long numBytes) throws UnmappedAddressException, DebuggerException {
640         requireAttach();
641         if (isCore) {
642             byte[] res = readBytesFromProcess0(address, numBytes);
643             return (res != null)? new ReadResult(res) : new ReadResult(address);
644         } else {
645             class ReadBytesFromProcessTask implements WorkerThreadTask {
646                 long address, numBytes;
647                 ReadResult result;
648                 public void doit(LinuxDebuggerLocal debugger) {
649                     byte[] res = debugger.readBytesFromProcess0(address, numBytes);
650                     if (res != null)
651                         result = new ReadResult(res);
652                     else
653                         result = new ReadResult(address);
654                 }
655             }
656 
657             ReadBytesFromProcessTask task = new ReadBytesFromProcessTask();
658             task.address = address;
659             task.numBytes = numBytes;
660             workerThread.execute(task);
661             return task.result;
662         }
663     }
664 
665     public void writeBytesToProcess(long address, long numBytes, byte[] data)
666         throws UnmappedAddressException, DebuggerException {
667         // FIXME
668         throw new DebuggerException(&quot;Unimplemented&quot;);
669     }
670 
671     static {
672         System.loadLibrary(&quot;saproc&quot;);
673         init0();
674     }
675 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
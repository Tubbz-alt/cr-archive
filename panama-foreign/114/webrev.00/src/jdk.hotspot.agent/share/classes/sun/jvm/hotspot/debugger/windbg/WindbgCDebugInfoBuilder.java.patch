diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/windbg/WindbgCDebugInfoBuilder.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/windbg/WindbgCDebugInfoBuilder.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/windbg/WindbgCDebugInfoBuilder.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/windbg/WindbgCDebugInfoBuilder.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2002, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -46,17 +46,17 @@
   // Logical->physical segment mapping
   private COFFFile file;
   private DebugVC50SSSegMap segMap;
 
   // Canonicalization of primitive types
-  private Map primIndexToTypeMap;
+  private Map<Integer, BasicType> primIndexToTypeMap;
 
   // Global unnamed enumeration
   // (FIXME: must figure out how to handle nested type descriptions)
   private BasicEnumType unnamedEnum;
 
-  private Stack blockStack;
+  private Stack<BlockSym> blockStack;
   private int   endsToSkip;
 
   private static final int POINTER_SIZE = 4;
 
   WindbgCDebugInfoBuilder(WindbgDebugger dbg) {
@@ -70,12 +70,12 @@
 
     if (vc50 == null) return null;
 
     segMap = getSegMap();
 
-    primIndexToTypeMap = new HashMap();
-    blockStack = new Stack();
+    primIndexToTypeMap = new HashMap<>();
+    blockStack = new Stack<>();
     endsToSkip = 0;
 
     db = new BasicCDebugInfoDataBase();
     db.beginConstruction();
 
@@ -662,11 +662,11 @@
     }
     throw new DebuggerException("Unable to find subsection of type " + ssType);
   }
 
   private void putType(Type t) {
-    db.addType(new Integer(iter.getTypeIndex()), t);
+    db.addType(iter.getTypeIndex(), t);
   }
 
   private Address newAddress(int offset, short segment) {
     int seg = segment & 0xFFFF;
     // NOTE: it isn't clear how to use the segMap to map from logical
@@ -680,11 +680,11 @@
     // Result is relative to image base
     return base.addOffsetTo(section.getVirtualAddress() + offset);
   }
 
   private BasicType getTypeByIndex(int intIndex) {
-    Integer index = new Integer(intIndex);
+    Integer index = intIndex;
 
     // Handle primitive types here.
     if (intIndex <= 0x0FFF) {
       BasicType type = (BasicType) primIndexToTypeMap.get(index);
       if (type != null) {
@@ -779,11 +779,11 @@
     // (Is it worth canonicalizing these as well to save space?)
     return new LazyType(index);
   }
 
   private void addBlock(BlockSym block) {
-    db.addBlock(new Integer(symIter.getOffset()), block);
+    db.addBlock(symIter.getOffset(), block);
     blockStack.push(block);
   }
 
   private void skipEnd() {
     ++endsToSkip;
@@ -792,11 +792,11 @@
   private BlockSym newLazyBlockSym(int offset) {
     if (offset == 0) {
       return null;
     }
 
-    return new LazyBlockSym(new Integer(offset));
+    return new LazyBlockSym(offset);
   }
 
   private int memberAttributeToAccessControl(short memberAttribute) {
     int acc = memberAttribute & MEMATTR_ACCESS_MASK;
     switch (acc) {

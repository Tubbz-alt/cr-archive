<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/Mark.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.oops;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 
 30 import sun.jvm.hotspot.debugger.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.types.*;
 33 import sun.jvm.hotspot.utilities.*;
 34 import sun.jvm.hotspot.utilities.Observable;
 35 import sun.jvm.hotspot.utilities.Observer;
 36 
 37 public class Mark extends VMObject {
 38   static {
 39     VM.registerVMInitializedObserver(new Observer() {
 40         public void update(Observable o, Object data) {
 41           initialize(VM.getVM().getTypeDataBase());
 42         }
 43       });
 44   }
 45 
 46   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
 47     Type type  = db.lookupType(&quot;oopDesc&quot;);
 48     markField  = type.getCIntegerField(&quot;_mark&quot;);
 49 
 50     ageBits             = db.lookupLongConstant(&quot;markWord::age_bits&quot;).longValue();
 51     lockBits            = db.lookupLongConstant(&quot;markWord::lock_bits&quot;).longValue();
 52     biasedLockBits      = db.lookupLongConstant(&quot;markWord::biased_lock_bits&quot;).longValue();
 53     maxHashBits         = db.lookupLongConstant(&quot;markWord::max_hash_bits&quot;).longValue();
 54     hashBits            = db.lookupLongConstant(&quot;markWord::hash_bits&quot;).longValue();
 55     lockShift           = db.lookupLongConstant(&quot;markWord::lock_shift&quot;).longValue();
 56     biasedLockShift     = db.lookupLongConstant(&quot;markWord::biased_lock_shift&quot;).longValue();
 57     ageShift            = db.lookupLongConstant(&quot;markWord::age_shift&quot;).longValue();
 58     hashShift           = db.lookupLongConstant(&quot;markWord::hash_shift&quot;).longValue();
 59     lockMask            = db.lookupLongConstant(&quot;markWord::lock_mask&quot;).longValue();
 60     lockMaskInPlace     = db.lookupLongConstant(&quot;markWord::lock_mask_in_place&quot;).longValue();
 61     biasedLockMask      = db.lookupLongConstant(&quot;markWord::biased_lock_mask&quot;).longValue();
 62     biasedLockMaskInPlace  = db.lookupLongConstant(&quot;markWord::biased_lock_mask_in_place&quot;).longValue();
 63     biasedLockBitInPlace  = db.lookupLongConstant(&quot;markWord::biased_lock_bit_in_place&quot;).longValue();
 64     ageMask             = db.lookupLongConstant(&quot;markWord::age_mask&quot;).longValue();
 65     ageMaskInPlace      = db.lookupLongConstant(&quot;markWord::age_mask_in_place&quot;).longValue();
 66     hashMask            = db.lookupLongConstant(&quot;markWord::hash_mask&quot;).longValue();
 67     hashMaskInPlace     = db.lookupLongConstant(&quot;markWord::hash_mask_in_place&quot;).longValue();
 68     biasedLockAlignment  = db.lookupLongConstant(&quot;markWord::biased_lock_alignment&quot;).longValue();
 69     lockedValue         = db.lookupLongConstant(&quot;markWord::locked_value&quot;).longValue();
 70     unlockedValue       = db.lookupLongConstant(&quot;markWord::unlocked_value&quot;).longValue();
 71     monitorValue        = db.lookupLongConstant(&quot;markWord::monitor_value&quot;).longValue();
 72     markedValue         = db.lookupLongConstant(&quot;markWord::marked_value&quot;).longValue();
 73     biasedLockPattern = db.lookupLongConstant(&quot;markWord::biased_lock_pattern&quot;).longValue();
 74     noHash              = db.lookupLongConstant(&quot;markWord::no_hash&quot;).longValue();
 75     noHashInPlace       = db.lookupLongConstant(&quot;markWord::no_hash_in_place&quot;).longValue();
 76     noLockInPlace       = db.lookupLongConstant(&quot;markWord::no_lock_in_place&quot;).longValue();
 77     maxAge              = db.lookupLongConstant(&quot;markWord::max_age&quot;).longValue();
 78   }
 79 
 80   // Field accessors
 81   private static CIntegerField markField;
 82 
 83   // Constants -- read from VM
 84   private static long ageBits;
 85   private static long lockBits;
 86   private static long biasedLockBits;
 87   private static long maxHashBits;
 88   private static long hashBits;
 89 
 90   private static long lockShift;
 91   private static long biasedLockShift;
 92   private static long ageShift;
 93   private static long hashShift;
 94 
 95   private static long lockMask;
 96   private static long lockMaskInPlace;
 97   private static long biasedLockMask;
 98   private static long biasedLockMaskInPlace;
 99   private static long biasedLockBitInPlace;
100   private static long ageMask;
101   private static long ageMaskInPlace;
102   private static long hashMask;
103   private static long hashMaskInPlace;
104   private static long biasedLockAlignment;
105 
106   private static long lockedValue;
107   private static long unlockedValue;
108   private static long monitorValue;
109   private static long markedValue;
110   private static long biasedLockPattern;
111 
112   private static long noHash;
113 
114   private static long noHashInPlace;
115   private static long noLockInPlace;
116 
117   private static long maxAge;
118 
119   /* Constants in markWord used by CMS. */
120   private static long cmsShift;
121   private static long cmsMask;
122   private static long sizeShift;
123 
124   public Mark(Address addr) {
125     super(addr);
126   }
127 
128   public long value() {
129     return markField.getValue(addr);
130   }
131 
132   public Address valueAsAddress() {
133     return addr.getAddressAt(markField.getOffset());
134   }
135 
136   // Biased locking accessors
137   // These must be checked by all code which calls into the
138   // ObjectSynchoronizer and other code. The biasing is not understood
139   // by the lower-level CAS-based locking code, although the runtime
140   // fixes up biased locks to be compatible with it when a bias is
141   // revoked.
142   public boolean hasBiasPattern() {
143     return (Bits.maskBitsLong(value(), biasedLockMaskInPlace) == biasedLockPattern);
144   }
145 
146   public JavaThread biasedLocker() {
147     Threads threads = VM.getVM().getThreads();
148     Address addr = valueAsAddress().andWithMask(~(biasedLockMaskInPlace &amp; ageMaskInPlace));
149     return threads.createJavaThreadWrapper(addr);
150   }
151 
152   // Indicates that the mark gas the bias bit set but that it has not
153   // yet been biased toward a particular thread
154   public boolean isBiasedAnonymously() {
155     return hasBiasPattern() &amp;&amp; (biasedLocker() == null);
156   }
157 
158   // lock accessors (note that these assume lock_shift == 0)
159   public boolean isLocked() {
160     return (Bits.maskBitsLong(value(), lockMaskInPlace) != unlockedValue);
161   }
162   public boolean isUnlocked() {
163     return (Bits.maskBitsLong(value(), biasedLockMaskInPlace) == unlockedValue);
164   }
165   public boolean isMarked() {
166     return (Bits.maskBitsLong(value(), lockMaskInPlace) == markedValue);
167   }
168 
169   // Special temporary state of the markWord while being inflated.
170   // Code that looks at mark outside a lock need to take this into account.
171   public boolean isBeingInflated() {
172     return (value() == 0);
173   }
174 
175   // Should this header be preserved during GC?
176   public boolean mustBePreserved() {
177      return (!isUnlocked() || !hasNoHash());
178   }
179 
180   // WARNING: The following routines are used EXCLUSIVELY by
181   // synchronization functions. They are not really gc safe.
182   // They must get updated if markWord layout get changed.
183 
184   public boolean hasLocker() {
185     return ((value() &amp; lockMaskInPlace) == lockedValue);
186   }
187   public BasicLock locker() {
188     if (Assert.ASSERTS_ENABLED) {
189       Assert.that(hasLocker(), &quot;check&quot;);
190     }
191     return new BasicLock(valueAsAddress());
192   }
193   public boolean hasMonitor() {
194     return ((value() &amp; monitorValue) != 0);
195   }
196   public ObjectMonitor monitor() {
197     if (Assert.ASSERTS_ENABLED) {
198       Assert.that(hasMonitor(), &quot;check&quot;);
199     }
200     // Use xor instead of &amp;~ to provide one extra tag-bit check.
201     Address monAddr = valueAsAddress().xorWithMask(monitorValue);
202     return new ObjectMonitor(monAddr);
203   }
204   public boolean hasDisplacedMarkHelper() {
205     return ((value() &amp; unlockedValue) == 0);
206   }
207   public Mark displacedMarkHelper() {
208     if (Assert.ASSERTS_ENABLED) {
209       Assert.that(hasDisplacedMarkHelper(), &quot;check&quot;);
210     }
211     Address addr = valueAsAddress().andWithMask(~monitorValue);
212     return new Mark(addr.getAddressAt(0));
213   }
214   public int age() { return (int) Bits.maskBitsLong(value() &gt;&gt; ageShift, ageMask); }
215 
216   // hash operations
217   public long hash() {
218     return Bits.maskBitsLong(value() &gt;&gt; hashShift, hashMask);
219   }
220 
221   public boolean hasNoHash() {
222     return hash() == noHash;
223   }
224 
225   // Debugging
226   public void printOn(PrintStream tty) {
227     if (isLocked()) {
228       tty.print(&quot;locked(0x&quot; +
229                 Long.toHexString(value()) + &quot;)-&gt;&quot;);
230       displacedMarkHelper().printOn(tty);
231     } else {
232       if (Assert.ASSERTS_ENABLED) {
233         Assert.that(isUnlocked(), &quot;just checking&quot;);
234       }
235       tty.print(&quot;mark(&quot;);
236       tty.print(&quot;hash &quot; + Long.toHexString(hash()) + &quot;,&quot;);
237       tty.print(&quot;age &quot; + age() + &quot;)&quot;);
238     }
239   }
240 
241   // Copy markWord methods for CMS here.
242   public boolean isCmsFreeChunk() {
243     return isUnlocked() &amp;&amp;
244            (Bits.maskBitsLong(value() &gt;&gt; cmsShift, cmsMask) &amp; 0x1L) == 0x1L;
245   }
246   public long getSize() { return (long)(value() &gt;&gt; sizeShift); }
247 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/ui/FindInHeapPanel.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Annotation.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HighPrecisionJScrollBar.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/ui/FindInHeapPanel.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 32 import javax.swing.text.*;
 33 
 34 import sun.jvm.hotspot.debugger.*;
 35 import sun.jvm.hotspot.oops.*;
 36 import sun.jvm.hotspot.runtime.*;
 37 import sun.jvm.hotspot.utilities.*;
 38 
 39 /** Finds a given (Address) value in the heap. Only intended for use
 40     in a debugging system. */
 41 
 42 public class FindInHeapPanel extends JPanel {
 43   private RawHeapVisitor   iterator;
 44   private long             addressSize;
 45   private long             usedSize;
 46   private long             iterated;
 47   private Address          value;
 48   private ProgressBarPanel progressBar;
 49   private HistoryComboBox  addressField;
 50   private JButton          findButton;
 51   private JTextArea        textArea;
<span class="line-modified"> 52   private ArrayList        updates;</span>
 53   private double           lastFrac;
 54 
 55   static final double minUpdateFraction = 0.05;
 56 
 57   public FindInHeapPanel() {
 58     super();
 59 
 60     setLayout(new BorderLayout());
 61 
 62     JPanel topPanel = new JPanel();
 63     topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
 64 
 65     JPanel panel = new JPanel();
 66     panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
 67     panel.add(new JLabel(&quot;Address to search for:&quot;));
 68 
 69     addressField = new HistoryComboBox();
 70     panel.add(addressField);
 71 
 72     addressSize = VM.getVM().getAddressSize();
 73 
 74     iterator = new RawHeapVisitor() {
 75         boolean error = false;
 76 
 77         public void prologue(long used) {
 78           usedSize = used;
 79           iterated = 0;
 80           lastFrac = 0;
 81           error = false;
<span class="line-modified"> 82           updates = new ArrayList();</span>
 83         }
 84 
 85         public void visitAddress(Address addr) {
 86           if (error) return;
 87 
 88           Address val = addr.getAddressAt(0);
 89           if (AddressOps.equal(val, value)) {
 90             error = reportResult(addr);
 91           }
 92           iterated += addressSize;
 93           updateProgressBar();
 94         }
 95         public void visitCompOopAddress(Address addr) {
 96           if (error) return;
 97 
 98           Address val = addr.getCompOopAddressAt(0);
 99           if (AddressOps.equal(val, value)) {
100             error = reportResult(addr);
101           }
102           iterated += addressSize;
</pre>
<hr />
<pre>
180 
181   private void clearResultWindow() {
182     SwingUtilities.invokeLater(new Runnable() {
183         public void run() {
184 
185           Document d = textArea.getDocument();
186           try {
187             d.remove(0, d.getLength());
188           } catch (BadLocationException e) {
189           }
190         }
191       });
192   }
193 
194   private synchronized void updateResultWindow() {
195     if (updates.size() &gt; 0) {
196       Iterator i = updates.iterator();
197       while (i.hasNext()) {
198         textArea.append((String)i.next());
199       }
<span class="line-modified">200       updates = new ArrayList();;</span>
201     }
202     pendingUpdate = false;
203   }
204 
205   private void invokeInDispatchThread(Runnable runnable) {
206     if (EventQueue.isDispatchThread()) {
207       runnable.run();
208     } else {
209       SwingUtilities.invokeLater(runnable);
210     }
211   }
212 
213   private void updateProgressBar() {
214     final double frac = (double) iterated / (double) usedSize;
215     if (frac == 0.0 || (frac - lastFrac &gt; minUpdateFraction)) {
216       lastFrac = frac;
217       if (iterated &gt; usedSize) {
218         System.out.println(&quot;iterated &quot; + iterated + &quot; usedSize &quot; + usedSize);
219       }
220       SwingUtilities.invokeLater(new Runnable() {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 32 import javax.swing.text.*;
 33 
 34 import sun.jvm.hotspot.debugger.*;
 35 import sun.jvm.hotspot.oops.*;
 36 import sun.jvm.hotspot.runtime.*;
 37 import sun.jvm.hotspot.utilities.*;
 38 
 39 /** Finds a given (Address) value in the heap. Only intended for use
 40     in a debugging system. */
 41 
 42 public class FindInHeapPanel extends JPanel {
 43   private RawHeapVisitor   iterator;
 44   private long             addressSize;
 45   private long             usedSize;
 46   private long             iterated;
 47   private Address          value;
 48   private ProgressBarPanel progressBar;
 49   private HistoryComboBox  addressField;
 50   private JButton          findButton;
 51   private JTextArea        textArea;
<span class="line-modified"> 52   private ArrayList&lt;String&gt; updates;</span>
 53   private double           lastFrac;
 54 
 55   static final double minUpdateFraction = 0.05;
 56 
 57   public FindInHeapPanel() {
 58     super();
 59 
 60     setLayout(new BorderLayout());
 61 
 62     JPanel topPanel = new JPanel();
 63     topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
 64 
 65     JPanel panel = new JPanel();
 66     panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
 67     panel.add(new JLabel(&quot;Address to search for:&quot;));
 68 
 69     addressField = new HistoryComboBox();
 70     panel.add(addressField);
 71 
 72     addressSize = VM.getVM().getAddressSize();
 73 
 74     iterator = new RawHeapVisitor() {
 75         boolean error = false;
 76 
 77         public void prologue(long used) {
 78           usedSize = used;
 79           iterated = 0;
 80           lastFrac = 0;
 81           error = false;
<span class="line-modified"> 82           updates = new ArrayList&lt;&gt;();</span>
 83         }
 84 
 85         public void visitAddress(Address addr) {
 86           if (error) return;
 87 
 88           Address val = addr.getAddressAt(0);
 89           if (AddressOps.equal(val, value)) {
 90             error = reportResult(addr);
 91           }
 92           iterated += addressSize;
 93           updateProgressBar();
 94         }
 95         public void visitCompOopAddress(Address addr) {
 96           if (error) return;
 97 
 98           Address val = addr.getCompOopAddressAt(0);
 99           if (AddressOps.equal(val, value)) {
100             error = reportResult(addr);
101           }
102           iterated += addressSize;
</pre>
<hr />
<pre>
180 
181   private void clearResultWindow() {
182     SwingUtilities.invokeLater(new Runnable() {
183         public void run() {
184 
185           Document d = textArea.getDocument();
186           try {
187             d.remove(0, d.getLength());
188           } catch (BadLocationException e) {
189           }
190         }
191       });
192   }
193 
194   private synchronized void updateResultWindow() {
195     if (updates.size() &gt; 0) {
196       Iterator i = updates.iterator();
197       while (i.hasNext()) {
198         textArea.append((String)i.next());
199       }
<span class="line-modified">200       updates = new ArrayList&lt;&gt;();;</span>
201     }
202     pendingUpdate = false;
203   }
204 
205   private void invokeInDispatchThread(Runnable runnable) {
206     if (EventQueue.isDispatchThread()) {
207       runnable.run();
208     } else {
209       SwingUtilities.invokeLater(runnable);
210     }
211   }
212 
213   private void updateProgressBar() {
214     final double frac = (double) iterated / (double) usedSize;
215     if (frac == 0.0 || (frac - lastFrac &gt; minUpdateFraction)) {
216       lastFrac = frac;
217       if (iterated &gt; usedSize) {
218         System.out.println(&quot;iterated &quot; + iterated + &quot; usedSize &quot; + usedSize);
219       }
220       SwingUtilities.invokeLater(new Runnable() {
</pre>
</td>
</tr>
</table>
<center><a href="Annotation.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HighPrecisionJScrollBar.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
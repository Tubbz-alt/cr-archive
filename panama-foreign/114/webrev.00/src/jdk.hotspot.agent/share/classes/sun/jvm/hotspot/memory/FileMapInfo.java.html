<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/memory/FileMapInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.memory;
 26 
 27 import java.util.*;
 28 import sun.jvm.hotspot.debugger.Address;
 29 import sun.jvm.hotspot.runtime.VM;
 30 import sun.jvm.hotspot.runtime.VMObject;
 31 import sun.jvm.hotspot.runtime.VMObjectFactory;
 32 import sun.jvm.hotspot.types.*;
 33 import sun.jvm.hotspot.utilities.Observable;
 34 import sun.jvm.hotspot.utilities.Observer;
 35 
 36 public class FileMapInfo {
 37   private static FileMapHeader headerObj;
 38 
 39   // Fields for handling the copied C++ vtables
 40   private static Address mcRegionBaseAddress;
 41   private static Address mcRegionEndAddress;
 42   private static Address vtablesStartAddress;
 43 
 44   // HashMap created by mapping the vTable addresses in the mc region with
 45   // the corresponding metadata type.
 46   private static Map&lt;Address, Type&gt; vTableTypeMap;
 47 
 48   private static Type metadataTypeArray[];
 49 
 50   static {
 51     VM.registerVMInitializedObserver(new Observer() {
 52         public void update(Observable o, Object data) {
 53           initialize(VM.getVM().getTypeDataBase());
 54         }
 55       });
 56   }
 57 
 58   static Address getStatic_AddressField(Type type, String fieldName) {
 59     AddressField field = type.getAddressField(fieldName);
 60     return field.getValue();
 61   }
 62 
 63   static Address get_AddressField(Type type, Address instance, String fieldName) {
 64     AddressField field = type.getAddressField(fieldName);
 65     return field.getValue(instance);
 66   }
 67 
 68   static long get_CIntegerField(Type type, Address instance, String fieldName) {
 69     CIntegerField field = type.getCIntegerField(fieldName);
 70     return field.getValue(instance);
 71   }
 72 
 73   // C equivalent:   return &amp;header-&gt;_space[index];
 74   static Address get_CDSFileMapRegion(Type FileMapHeader_type, Address header, int index) {
 75     AddressField spaceField = FileMapHeader_type.getAddressField(&quot;_space[0]&quot;);
 76 
 77     // size_t offset = offsetof(FileMapHeader, _space[0]);
 78     // CDSFileMapRegion* space_0 = ((char*)header) + offset; // space_0 = &amp;header-&gt;_space[index];
 79     // return ((char*)space_0) + index * sizeof(CDSFileMapRegion);
 80     long offset = spaceField.getOffset();
 81     Address space_0 = header.addOffsetTo(offset);
 82     return space_0.addOffsetTo(index * spaceField.getSize());
 83   }
 84 
 85   private static void initialize(TypeDataBase db) {
 86     Type FileMapInfo_type = db.lookupType(&quot;FileMapInfo&quot;);
 87     Type FileMapHeader_type = db.lookupType(&quot;FileMapHeader&quot;);
 88     Type CDSFileMapRegion_type = db.lookupType(&quot;CDSFileMapRegion&quot;);
 89 
 90     // FileMapInfo * info = FileMapInfo::_current_info;
 91     // FileMapHeader* header = info-&gt;_header
 92     Address info = getStatic_AddressField(FileMapInfo_type, &quot;_current_info&quot;);
 93     Address header = get_AddressField(FileMapInfo_type, info, &quot;_header&quot;);
 94     headerObj = (FileMapHeader) VMObjectFactory.newObject(FileMapInfo.FileMapHeader.class, header);
 95 
 96     // char* mapped_base_address = header-&gt;_mapped_base_address
 97     // size_t cloned_vtable_offset = header-&gt;_cloned_vtable_offset
 98     // char* vtablesStartAddress = mapped_base_address + cloned_vtable_offset;
 99     Address mapped_base_address = get_AddressField(FileMapHeader_type, header, &quot;_mapped_base_address&quot;);
100     long cloned_vtable_offset = get_CIntegerField(FileMapHeader_type, header, &quot;_cloned_vtables_offset&quot;);
101     vtablesStartAddress = mapped_base_address.addOffsetTo(cloned_vtable_offset);
102 
103     // CDSFileMapRegion* mc_space = &amp;header-&gt;_space[mc];
104     // char* mcRegionBaseAddress = mc_space-&gt;_mapped_base;
105     // size_t used = mc_space-&gt;_used;
106     // char* mcRegionEndAddress = mcRegionBaseAddress + used;
107     Address mc_space = get_CDSFileMapRegion(FileMapHeader_type, header, 0);
108     mcRegionBaseAddress = get_AddressField(CDSFileMapRegion_type, mc_space, &quot;_mapped_base&quot;);
109     long used = get_CIntegerField(CDSFileMapRegion_type, mc_space, &quot;_used&quot;);
110     mcRegionEndAddress = mcRegionBaseAddress.addOffsetTo(used);
111 
112     populateMetadataTypeArray(db);
113   }
114 
115   private static void populateMetadataTypeArray(TypeDataBase db) {
116     metadataTypeArray = new Type[8];
117 
118     metadataTypeArray[0] = db.lookupType(&quot;ConstantPool&quot;);
119     metadataTypeArray[1] = db.lookupType(&quot;InstanceKlass&quot;);
120     metadataTypeArray[2] = db.lookupType(&quot;InstanceClassLoaderKlass&quot;);
121     metadataTypeArray[3] = db.lookupType(&quot;InstanceMirrorKlass&quot;);
122     metadataTypeArray[4] = db.lookupType(&quot;InstanceRefKlass&quot;);
123     metadataTypeArray[5] = db.lookupType(&quot;Method&quot;);
124     metadataTypeArray[6] = db.lookupType(&quot;ObjArrayKlass&quot;);
125     metadataTypeArray[7] = db.lookupType(&quot;TypeArrayKlass&quot;);
126   }
127 
128   public FileMapHeader getHeader() {
129     return headerObj;
130   }
131 
132   public boolean inCopiedVtableSpace(Address vptrAddress) {
133     FileMapHeader fmHeader = getHeader();
134     return fmHeader.inCopiedVtableSpace(vptrAddress);
135   }
136 
137   public Type getTypeForVptrAddress(Address vptrAddress) {
138     if (vTableTypeMap == null) {
139       getHeader().createVtableTypeMapping();
140     }
141     return vTableTypeMap.get(vptrAddress);
142   }
143 
144 
145   //------------------------------------------------------------------------------------------
146 
147   public static class FileMapHeader extends VMObject {
148 
149     public FileMapHeader(Address addr) {
150       super(addr);
151     }
152 
153     public boolean inCopiedVtableSpace(Address vptrAddress) {
154       if (vptrAddress.greaterThan(mcRegionBaseAddress) &amp;&amp;
155           vptrAddress.lessThanOrEqual(mcRegionEndAddress)) {
156         return true;
157       }
158       return false;
159     }
160 
161     public void createVtableTypeMapping() {
162       vTableTypeMap = new HashMap&lt;Address, Type&gt;();
163       long metadataVTableSize = 0;
164       long addressSize = VM.getVM().getAddressSize();
165 
166       Address copiedVtableAddress = vtablesStartAddress;
167       for (int i=0; i &lt; metadataTypeArray.length; i++) {
168         // The first entry denotes the vtable size.
169         metadataVTableSize = copiedVtableAddress.getAddressAt(0).asLongValue();
170         vTableTypeMap.put(copiedVtableAddress.addOffsetTo(addressSize), metadataTypeArray[i]);
171 
172         // The &#39;+ 1&#39; below is to skip the entry containing the size of this metadata&#39;s vtable.
173         copiedVtableAddress =
174           copiedVtableAddress.addOffsetTo((metadataVTableSize + 1) * addressSize);
175       }
176     }
177   }
178 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/ObjectReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodArray.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RBTree.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/ObjectReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 61  * JDK version:
 62  *
 63  * JDK classes are loaded by bootstrap class loader and not by the
 64  * supplied class loader or ProcImageClassLoader. This may create
 65  * problems if a JDK class evolves. i.e., if SA runs a JDK version
 66  * different from that of the debuggee, there is a possibility of
 67  * schema change. It is recommended that the matching JDK version be
 68  * used to run SA for proper object deserialization.
 69  *
 70  */
 71 
 72 public class ObjectReader {
 73 
 74    private static final boolean DEBUG;
 75    static {
 76       DEBUG = System.getProperty(&quot;sun.jvm.hotspot.utilities.ObjectReader.DEBUG&quot;) != null;
 77    }
 78 
 79    public ObjectReader(ClassLoader cl) {
 80       this.cl = cl;
<span class="line-modified"> 81       this.oopToObjMap = new HashMap();</span>
<span class="line-modified"> 82       this.fieldMap = new HashMap();</span>
 83    }
 84 
 85    public ObjectReader() {
 86       this(new ProcImageClassLoader());
 87    }
 88 
 89    static void debugPrintln(String msg) {
 90       if (DEBUG) {
 91          System.err.println(&quot;DEBUG&gt;&quot; + msg);
 92       }
 93    }
 94 
 95    static void debugPrintStackTrace(Exception exp) {
 96       if (DEBUG) {
 97          StackTraceElement[] els = exp.getStackTrace();
 98          for (int i = 0; i &lt; els.length; i++) {
 99             System.err.println(&quot;DEBUG&gt;&quot; + els[i].toString());
100          }
101       }
102    }
103 
104    public Object readObject(Oop oop) throws ClassNotFoundException {
105       if (oop instanceof Instance) {
106          return readInstance((Instance) oop);
107       } else if (oop instanceof TypeArray){
108          return readPrimitiveArray((TypeArray)oop);
109       } else if (oop instanceof ObjArray){
110          return readObjectArray((ObjArray)oop);
111       } else {
112          return null;
113       }
114    }
115 
116    protected final Object getDefaultPrimitiveValue(Class clz) {
117       if (clz == Boolean.TYPE) {
118          return Boolean.FALSE;
119       } else if (clz == Character.TYPE) {
<span class="line-modified">120          return new Character(&#39; &#39;);</span>
121       } else if (clz == Byte.TYPE) {
<span class="line-modified">122          return new Byte((byte) 0);</span>
123       } else if (clz == Short.TYPE) {
<span class="line-modified">124          return new Short((short) 0);</span>
125       } else if (clz == Integer.TYPE) {
<span class="line-modified">126          return new Integer(0);</span>
127       } else if (clz == Long.TYPE) {
<span class="line-modified">128          return new Long(0L);</span>
129       } else if (clz == Float.TYPE) {
<span class="line-modified">130          return new Float(0.0f);</span>
131       } else if (clz == Double.TYPE) {
<span class="line-modified">132          return new Double(0.0);</span>
133       } else {
134          throw new RuntimeException(&quot;should not reach here!&quot;);
135       }
136    }
137 
138    protected String javaLangString;
139    protected String javaUtilHashtableEntry;
140    protected String javaUtilHashtable;
141    protected String javaUtilProperties;
142 
143    protected String javaLangString() {
144       if (javaLangString == null) {
145          javaLangString = &quot;java/lang/String&quot;;
146       }
147       return javaLangString;
148    }
149 
150    protected String javaUtilHashtableEntry() {
151       if (javaUtilHashtableEntry == null) {
152          javaUtilHashtableEntry = &quot;java/util/Hashtable$Entry&quot;;
153       }
154       return javaUtilHashtableEntry;
155    }
156 
157    protected String javaUtilHashtable() {
158       if (javaUtilHashtable == null) {
159          javaUtilHashtable = &quot;java/util/Hashtable&quot;;
160       }
161       return javaUtilHashtable;
162    }
163 
164    protected String javaUtilProperties() {
165       if (javaUtilProperties == null) {
166          javaUtilProperties = &quot;java/util/Properties&quot;;
167       }
168       return javaUtilProperties;
169    }
170 
<span class="line-modified">171    private void setHashtableEntry(java.util.Hashtable p, Oop oop) {</span>
172       InstanceKlass ik = (InstanceKlass)oop.getKlass();
173       OopField keyField = (OopField)ik.findField(&quot;key&quot;, &quot;Ljava/lang/Object;&quot;);
174       OopField valueField = (OopField)ik.findField(&quot;value&quot;, &quot;Ljava/lang/Object;&quot;);
175       OopField nextField = (OopField)ik.findField(&quot;next&quot;, &quot;Ljava/util/Hashtable$Entry;&quot;);
176       if (DEBUG) {
177          if (Assert.ASSERTS_ENABLED) {
178             Assert.that(ik.getName().equals(javaUtilHashtableEntry()), &quot;Not a Hashtable$Entry?&quot;);
179             Assert.that(keyField != null &amp;&amp; valueField != null &amp;&amp; nextField != null, &quot;Invalid fields!&quot;);
180          }
181       }
182 
183       Object key = null;
184       Object value = null;
185       Oop next = null;
186       try {
187          key = readObject(keyField.getValue(oop));
188          value = readObject(valueField.getValue(oop));
189          next =  (Oop)nextField.getValue(oop);
190          // For Properties, should use setProperty(k, v). Since it only runs in SA
191          // using put(k, v) should be OK.
</pre>
<hr />
<pre>
212                        (String)readObject(valueField.getValue(oop)));
213       } catch (ClassNotFoundException ce) {
214          if (DEBUG) {
215             debugPrintStackTrace(ce);
216          }
217       }
218       // If this hashmap table Node is chained, then follow the chain to the next Node.
219       Oop chainedOop = nextField.getValue(oop);
220       if (chainedOop != null) {
221           setPropertiesEntry(p, chainedOop);
222       }
223    }
224 
225    protected Object getHashtable(Instance oop) {
226       InstanceKlass k = (InstanceKlass)oop.getKlass();
227       OopField tableField = (OopField)k.findField(&quot;table&quot;, &quot;[Ljava/util/Hashtable$Entry;&quot;);
228       if (tableField == null) {
229          debugPrintln(&quot;Could not find field of [Ljava/util/Hashtable$Entry;&quot;);
230          return null;
231       }
<span class="line-modified">232       java.util.Hashtable table = new java.util.Hashtable();</span>
233       ObjArray kvs = (ObjArray)tableField.getValue(oop);
234       long size = kvs.getLength();
235       debugPrintln(&quot;Hashtable$Entry Size = &quot; + size);
236       for (long i=0; i&lt;size; i++) {
237          Oop entry = kvs.getObjAt(i);
238          if (entry != null &amp;&amp; entry.isInstance()) {
239             setHashtableEntry(table, entry);
240          }
241       }
242       return table;
243    }
244 
245    private Properties getProperties(Instance oop) {
246       InstanceKlass k = (InstanceKlass)oop.getKlass();
247       OopField mapField = (OopField)k.findField(&quot;map&quot;, &quot;Ljava/util/concurrent/ConcurrentHashMap;&quot;);
248       if (mapField == null) {
249          debugPrintln(&quot;Could not find field of Ljava/util/concurrent/ConcurrentHashMap&quot;);
250          return null;
251       }
252 
</pre>
<hr />
<pre>
282          // Handle java.lang.String instances differently. As part of JSR-133, fields of immutable
283          // classes have been made final. The algorithm below will not be able to read Strings from
284          // debuggee (can&#39;t use reflection to set final fields). But, need to read Strings is very
285          // important.
286          // Same for Hashtable, key and hash are final, could not be set in the algorithm too.
287          // FIXME: need a framework to handle many other special cases.
288          if (kls.getName().equals(javaLangString())) {
289             return OopUtilities.stringOopToString(oop);
290          }
291 
292          if (kls.getName().equals(javaUtilHashtable())) {
293             return getHashtable(oop);
294          }
295 
296          if (kls.getName().equals(javaUtilProperties())) {
297             return getProperties(oop);
298          }
299 
300          Class clz = readClass(kls);
301          try {
<span class="line-modified">302             result = clz.newInstance();</span>
303          } catch (Exception ex) {
304             // no-arg constructor failed to create object. Let us try
305             // to call constructors one-by-one with default arguments
306             // (null for objects, 0/0.0 etc. for primitives) till we
307             // succeed or fail on all constructors.
308 
309             java.lang.reflect.Constructor[] ctrs = clz.getDeclaredConstructors();
310             for (int n = 0; n &lt; ctrs.length; n++) {
311                java.lang.reflect.Constructor c = ctrs[n];
312                Class[] paramTypes = c.getParameterTypes();
313                Object[] params = new Object[paramTypes.length];
314                for (int i = 0; i &lt; params.length; i++) {
315                   if (paramTypes[i].isPrimitive()) {
316                      params[i] = getDefaultPrimitiveValue(paramTypes[i]);
317                   }
318                }
319                try {
320                   c.setAccessible(true);
321                   result = c.newInstance(params);
322                   break;
</pre>
<hr />
<pre>
636          cls = Class.forName(kls.getName().asString().replace(&#39;/&#39;, &#39;.&#39;), true, cl);
637          putIntoObjTable(kls, cls);
638       }
639       return cls;
640    }
641 
642    public Object readMethodOrConstructor(sun.jvm.hotspot.oops.Method m)
643                      throws NoSuchMethodException, ClassNotFoundException {
644       String name = m.getName().asString();
645       if (name.equals(&quot;&lt;init&gt;&quot;)) {
646          return readConstructor(m);
647       } else {
648          return readMethod(m);
649       }
650    }
651 
652    public java.lang.reflect.Method readMethod(sun.jvm.hotspot.oops.Method m)
653             throws NoSuchMethodException, ClassNotFoundException {
654       java.lang.reflect.Method result = (java.lang.reflect.Method) getFromObjTable(m);
655       if (result == null) {
<span class="line-modified">656          Class clz = readClass((InstanceKlass)m.getMethodHolder());</span>
657          String name = m.getName().asString();
658          Class[] paramTypes = getParamTypes(m.getSignature());
659          result = clz.getMethod(name, paramTypes);
660          putIntoObjTable(m, result);
661       }
662       return result;
663    }
664 
665    public java.lang.reflect.Constructor readConstructor(sun.jvm.hotspot.oops.Method m)
666             throws NoSuchMethodException, ClassNotFoundException {
667       java.lang.reflect.Constructor result = (java.lang.reflect.Constructor) getFromObjTable(m);
668       if (result == null) {
<span class="line-modified">669          Class clz = readClass((InstanceKlass)m.getMethodHolder());</span>
670          String name = m.getName().asString();
671          Class[] paramTypes = getParamTypes(m.getSignature());
672          result = clz.getDeclaredConstructor(paramTypes);
673          putIntoObjTable(m, result);
674       }
675       return result;
676    }
677 
678    public java.lang.reflect.Field readField(sun.jvm.hotspot.oops.Field f)
679             throws NoSuchFieldException, ClassNotFoundException {
680       java.lang.reflect.Field result = (java.lang.reflect.Field) fieldMap.get(f);
681       if (result == null) {
682          FieldIdentifier fieldId = f.getID();
683          Class clz = readClass((InstanceKlass) f.getFieldHolder());
684          String name = fieldId.getName();
685          try {
686             result = clz.getField(name);
687          } catch (NoSuchFieldException nsfe) {
688             result = clz.getDeclaredField(name);
689          }
690          fieldMap.put(f, result);
691       }
692       return result;
693    }
694 
695    protected final ClassLoader cl;
<span class="line-modified">696    protected Map   oopToObjMap; // Map&lt;Oop, Object&gt;</span>
<span class="line-modified">697    protected Map   fieldMap;    // Map&lt;sun.jvm.hotspot.oops.Field, java.lang.reflect.Field&gt;</span>
698 
699    protected void putIntoObjTable(Oop oop, Object obj) {
700       oopToObjMap.put(oop, obj);
701    }
702 
703    protected Object getFromObjTable(Oop oop) {
704       return oopToObjMap.get(oop);
705    }
706 
707    protected void putIntoObjTable(Metadata oop, Object obj) {
708       oopToObjMap.put(oop, obj);
709    }
710 
711    protected Object getFromObjTable(Metadata oop) {
712       return oopToObjMap.get(oop);
713    }
714 
715    protected class SignatureParser extends SignatureIterator {
<span class="line-modified">716       protected Vector tmp = new Vector(); // Vector&lt;Class&gt;</span>
717 
718       public SignatureParser(Symbol s) {
719          super(s);
720       }
721 
722       public void doBool  () { tmp.add(Boolean.TYPE);    }
723       public void doChar  () { tmp.add(Character.TYPE);  }
724       public void doFloat () { tmp.add(Float.TYPE);      }
725       public void doDouble() { tmp.add(Double.TYPE);     }
726       public void doByte  () { tmp.add(Byte.TYPE);       }
727       public void doShort () { tmp.add(Short.TYPE);      }
728       public void doInt   () { tmp.add(Integer.TYPE);    }
729       public void doLong  () { tmp.add(Long.TYPE);       }
730       public void doVoid  () {
731          if(isReturnType()) {
732             tmp.add(Void.TYPE);
733          } else {
734             throw new RuntimeException(&quot;should not reach here&quot;);
735          }
736       }
</pre>
</td>
<td>
<hr />
<pre>
 61  * JDK version:
 62  *
 63  * JDK classes are loaded by bootstrap class loader and not by the
 64  * supplied class loader or ProcImageClassLoader. This may create
 65  * problems if a JDK class evolves. i.e., if SA runs a JDK version
 66  * different from that of the debuggee, there is a possibility of
 67  * schema change. It is recommended that the matching JDK version be
 68  * used to run SA for proper object deserialization.
 69  *
 70  */
 71 
 72 public class ObjectReader {
 73 
 74    private static final boolean DEBUG;
 75    static {
 76       DEBUG = System.getProperty(&quot;sun.jvm.hotspot.utilities.ObjectReader.DEBUG&quot;) != null;
 77    }
 78 
 79    public ObjectReader(ClassLoader cl) {
 80       this.cl = cl;
<span class="line-modified"> 81       this.oopToObjMap = new HashMap&lt;&gt;();</span>
<span class="line-modified"> 82       this.fieldMap = new HashMap&lt;&gt;();</span>
 83    }
 84 
 85    public ObjectReader() {
 86       this(new ProcImageClassLoader());
 87    }
 88 
 89    static void debugPrintln(String msg) {
 90       if (DEBUG) {
 91          System.err.println(&quot;DEBUG&gt;&quot; + msg);
 92       }
 93    }
 94 
 95    static void debugPrintStackTrace(Exception exp) {
 96       if (DEBUG) {
 97          StackTraceElement[] els = exp.getStackTrace();
 98          for (int i = 0; i &lt; els.length; i++) {
 99             System.err.println(&quot;DEBUG&gt;&quot; + els[i].toString());
100          }
101       }
102    }
103 
104    public Object readObject(Oop oop) throws ClassNotFoundException {
105       if (oop instanceof Instance) {
106          return readInstance((Instance) oop);
107       } else if (oop instanceof TypeArray){
108          return readPrimitiveArray((TypeArray)oop);
109       } else if (oop instanceof ObjArray){
110          return readObjectArray((ObjArray)oop);
111       } else {
112          return null;
113       }
114    }
115 
116    protected final Object getDefaultPrimitiveValue(Class clz) {
117       if (clz == Boolean.TYPE) {
118          return Boolean.FALSE;
119       } else if (clz == Character.TYPE) {
<span class="line-modified">120          return &#39; &#39;;</span>
121       } else if (clz == Byte.TYPE) {
<span class="line-modified">122          return (byte) 0;</span>
123       } else if (clz == Short.TYPE) {
<span class="line-modified">124          return (short) 0;</span>
125       } else if (clz == Integer.TYPE) {
<span class="line-modified">126          return 0;</span>
127       } else if (clz == Long.TYPE) {
<span class="line-modified">128          return 0L;</span>
129       } else if (clz == Float.TYPE) {
<span class="line-modified">130          return 0.0f;</span>
131       } else if (clz == Double.TYPE) {
<span class="line-modified">132          return 0.0;</span>
133       } else {
134          throw new RuntimeException(&quot;should not reach here!&quot;);
135       }
136    }
137 
138    protected String javaLangString;
139    protected String javaUtilHashtableEntry;
140    protected String javaUtilHashtable;
141    protected String javaUtilProperties;
142 
143    protected String javaLangString() {
144       if (javaLangString == null) {
145          javaLangString = &quot;java/lang/String&quot;;
146       }
147       return javaLangString;
148    }
149 
150    protected String javaUtilHashtableEntry() {
151       if (javaUtilHashtableEntry == null) {
152          javaUtilHashtableEntry = &quot;java/util/Hashtable$Entry&quot;;
153       }
154       return javaUtilHashtableEntry;
155    }
156 
157    protected String javaUtilHashtable() {
158       if (javaUtilHashtable == null) {
159          javaUtilHashtable = &quot;java/util/Hashtable&quot;;
160       }
161       return javaUtilHashtable;
162    }
163 
164    protected String javaUtilProperties() {
165       if (javaUtilProperties == null) {
166          javaUtilProperties = &quot;java/util/Properties&quot;;
167       }
168       return javaUtilProperties;
169    }
170 
<span class="line-modified">171    private void setHashtableEntry(java.util.Hashtable&lt;Object, Object&gt; p, Oop oop) {</span>
172       InstanceKlass ik = (InstanceKlass)oop.getKlass();
173       OopField keyField = (OopField)ik.findField(&quot;key&quot;, &quot;Ljava/lang/Object;&quot;);
174       OopField valueField = (OopField)ik.findField(&quot;value&quot;, &quot;Ljava/lang/Object;&quot;);
175       OopField nextField = (OopField)ik.findField(&quot;next&quot;, &quot;Ljava/util/Hashtable$Entry;&quot;);
176       if (DEBUG) {
177          if (Assert.ASSERTS_ENABLED) {
178             Assert.that(ik.getName().equals(javaUtilHashtableEntry()), &quot;Not a Hashtable$Entry?&quot;);
179             Assert.that(keyField != null &amp;&amp; valueField != null &amp;&amp; nextField != null, &quot;Invalid fields!&quot;);
180          }
181       }
182 
183       Object key = null;
184       Object value = null;
185       Oop next = null;
186       try {
187          key = readObject(keyField.getValue(oop));
188          value = readObject(valueField.getValue(oop));
189          next =  (Oop)nextField.getValue(oop);
190          // For Properties, should use setProperty(k, v). Since it only runs in SA
191          // using put(k, v) should be OK.
</pre>
<hr />
<pre>
212                        (String)readObject(valueField.getValue(oop)));
213       } catch (ClassNotFoundException ce) {
214          if (DEBUG) {
215             debugPrintStackTrace(ce);
216          }
217       }
218       // If this hashmap table Node is chained, then follow the chain to the next Node.
219       Oop chainedOop = nextField.getValue(oop);
220       if (chainedOop != null) {
221           setPropertiesEntry(p, chainedOop);
222       }
223    }
224 
225    protected Object getHashtable(Instance oop) {
226       InstanceKlass k = (InstanceKlass)oop.getKlass();
227       OopField tableField = (OopField)k.findField(&quot;table&quot;, &quot;[Ljava/util/Hashtable$Entry;&quot;);
228       if (tableField == null) {
229          debugPrintln(&quot;Could not find field of [Ljava/util/Hashtable$Entry;&quot;);
230          return null;
231       }
<span class="line-modified">232       java.util.Hashtable&lt;Object, Object&gt; table = new java.util.Hashtable&lt;&gt;();</span>
233       ObjArray kvs = (ObjArray)tableField.getValue(oop);
234       long size = kvs.getLength();
235       debugPrintln(&quot;Hashtable$Entry Size = &quot; + size);
236       for (long i=0; i&lt;size; i++) {
237          Oop entry = kvs.getObjAt(i);
238          if (entry != null &amp;&amp; entry.isInstance()) {
239             setHashtableEntry(table, entry);
240          }
241       }
242       return table;
243    }
244 
245    private Properties getProperties(Instance oop) {
246       InstanceKlass k = (InstanceKlass)oop.getKlass();
247       OopField mapField = (OopField)k.findField(&quot;map&quot;, &quot;Ljava/util/concurrent/ConcurrentHashMap;&quot;);
248       if (mapField == null) {
249          debugPrintln(&quot;Could not find field of Ljava/util/concurrent/ConcurrentHashMap&quot;);
250          return null;
251       }
252 
</pre>
<hr />
<pre>
282          // Handle java.lang.String instances differently. As part of JSR-133, fields of immutable
283          // classes have been made final. The algorithm below will not be able to read Strings from
284          // debuggee (can&#39;t use reflection to set final fields). But, need to read Strings is very
285          // important.
286          // Same for Hashtable, key and hash are final, could not be set in the algorithm too.
287          // FIXME: need a framework to handle many other special cases.
288          if (kls.getName().equals(javaLangString())) {
289             return OopUtilities.stringOopToString(oop);
290          }
291 
292          if (kls.getName().equals(javaUtilHashtable())) {
293             return getHashtable(oop);
294          }
295 
296          if (kls.getName().equals(javaUtilProperties())) {
297             return getProperties(oop);
298          }
299 
300          Class clz = readClass(kls);
301          try {
<span class="line-modified">302             result = clz.getDeclaredConstructor().newInstance();</span>
303          } catch (Exception ex) {
304             // no-arg constructor failed to create object. Let us try
305             // to call constructors one-by-one with default arguments
306             // (null for objects, 0/0.0 etc. for primitives) till we
307             // succeed or fail on all constructors.
308 
309             java.lang.reflect.Constructor[] ctrs = clz.getDeclaredConstructors();
310             for (int n = 0; n &lt; ctrs.length; n++) {
311                java.lang.reflect.Constructor c = ctrs[n];
312                Class[] paramTypes = c.getParameterTypes();
313                Object[] params = new Object[paramTypes.length];
314                for (int i = 0; i &lt; params.length; i++) {
315                   if (paramTypes[i].isPrimitive()) {
316                      params[i] = getDefaultPrimitiveValue(paramTypes[i]);
317                   }
318                }
319                try {
320                   c.setAccessible(true);
321                   result = c.newInstance(params);
322                   break;
</pre>
<hr />
<pre>
636          cls = Class.forName(kls.getName().asString().replace(&#39;/&#39;, &#39;.&#39;), true, cl);
637          putIntoObjTable(kls, cls);
638       }
639       return cls;
640    }
641 
642    public Object readMethodOrConstructor(sun.jvm.hotspot.oops.Method m)
643                      throws NoSuchMethodException, ClassNotFoundException {
644       String name = m.getName().asString();
645       if (name.equals(&quot;&lt;init&gt;&quot;)) {
646          return readConstructor(m);
647       } else {
648          return readMethod(m);
649       }
650    }
651 
652    public java.lang.reflect.Method readMethod(sun.jvm.hotspot.oops.Method m)
653             throws NoSuchMethodException, ClassNotFoundException {
654       java.lang.reflect.Method result = (java.lang.reflect.Method) getFromObjTable(m);
655       if (result == null) {
<span class="line-modified">656          Class&lt;?&gt; clz = readClass(m.getMethodHolder());</span>
657          String name = m.getName().asString();
658          Class[] paramTypes = getParamTypes(m.getSignature());
659          result = clz.getMethod(name, paramTypes);
660          putIntoObjTable(m, result);
661       }
662       return result;
663    }
664 
665    public java.lang.reflect.Constructor readConstructor(sun.jvm.hotspot.oops.Method m)
666             throws NoSuchMethodException, ClassNotFoundException {
667       java.lang.reflect.Constructor result = (java.lang.reflect.Constructor) getFromObjTable(m);
668       if (result == null) {
<span class="line-modified">669          Class&lt;?&gt; clz = readClass(m.getMethodHolder());</span>
670          String name = m.getName().asString();
671          Class[] paramTypes = getParamTypes(m.getSignature());
672          result = clz.getDeclaredConstructor(paramTypes);
673          putIntoObjTable(m, result);
674       }
675       return result;
676    }
677 
678    public java.lang.reflect.Field readField(sun.jvm.hotspot.oops.Field f)
679             throws NoSuchFieldException, ClassNotFoundException {
680       java.lang.reflect.Field result = (java.lang.reflect.Field) fieldMap.get(f);
681       if (result == null) {
682          FieldIdentifier fieldId = f.getID();
683          Class clz = readClass((InstanceKlass) f.getFieldHolder());
684          String name = fieldId.getName();
685          try {
686             result = clz.getField(name);
687          } catch (NoSuchFieldException nsfe) {
688             result = clz.getDeclaredField(name);
689          }
690          fieldMap.put(f, result);
691       }
692       return result;
693    }
694 
695    protected final ClassLoader cl;
<span class="line-modified">696    protected Map&lt;Object, Object&gt; oopToObjMap;</span>
<span class="line-modified">697    protected Map&lt;sun.jvm.hotspot.oops.Field, java.lang.reflect.Field&gt; fieldMap;</span>
698 
699    protected void putIntoObjTable(Oop oop, Object obj) {
700       oopToObjMap.put(oop, obj);
701    }
702 
703    protected Object getFromObjTable(Oop oop) {
704       return oopToObjMap.get(oop);
705    }
706 
707    protected void putIntoObjTable(Metadata oop, Object obj) {
708       oopToObjMap.put(oop, obj);
709    }
710 
711    protected Object getFromObjTable(Metadata oop) {
712       return oopToObjMap.get(oop);
713    }
714 
715    protected class SignatureParser extends SignatureIterator {
<span class="line-modified">716       protected Vector&lt;Class&lt;?&gt;&gt; tmp = new Vector&lt;&gt;();</span>
717 
718       public SignatureParser(Symbol s) {
719          super(s);
720       }
721 
722       public void doBool  () { tmp.add(Boolean.TYPE);    }
723       public void doChar  () { tmp.add(Character.TYPE);  }
724       public void doFloat () { tmp.add(Float.TYPE);      }
725       public void doDouble() { tmp.add(Double.TYPE);     }
726       public void doByte  () { tmp.add(Byte.TYPE);       }
727       public void doShort () { tmp.add(Short.TYPE);      }
728       public void doInt   () { tmp.add(Integer.TYPE);    }
729       public void doLong  () { tmp.add(Long.TYPE);       }
730       public void doVoid  () {
731          if(isReturnType()) {
732             tmp.add(Void.TYPE);
733          } else {
734             throw new RuntimeException(&quot;should not reach here&quot;);
735          }
736       }
</pre>
</td>
</tr>
</table>
<center><a href="MethodArray.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RBTree.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/soql/JSJavaInstanceKlass.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSJavaHeap.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSJavaKlass.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/soql/JSJavaInstanceKlass.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 35    private static final int FIELD_SOURCE_FILE        = 1;
 36    private static final int FIELD_INTERFACES         = 2;
 37    private static final int FIELD_FIELDS             = 3;
 38    private static final int FIELD_METHODS            = 4;
 39    private static final int FIELD_IS_PRIVATE         = 5;
 40    private static final int FIELD_IS_PUBLIC          = 6;
 41    private static final int FIELD_IS_PROTECTED       = 7;
 42    private static final int FIELD_IS_PACKAGE_PRIVATE = 8;
 43    private static final int FIELD_IS_STATIC          = 9;
 44    private static final int FIELD_IS_FINAL           = 10;
 45    private static final int FIELD_IS_ABSTRACT        = 11;
 46    private static final int FIELD_IS_STRICT          = 12;
 47    private static final int FIELD_IS_SYNTHETIC       = 13;
 48    private static final int FIELD_IS_INTERFACE       = 14;
 49    private static final int FIELD_CLASS_LOADER       = 15;
 50    private static final int FIELD_STATICS            = 18;
 51    private static final int FIELD_UNDEFINED          = -1;
 52 
 53    public JSJavaInstanceKlass(InstanceKlass kls, JSJavaFactory fac) {
 54       super(kls, fac);
<span class="line-modified"> 55       this.instanceFields = new HashMap();</span>
<span class="line-modified"> 56       this.staticFields = new HashMap();</span>
 57    }
 58 
 59    public final InstanceKlass getInstanceKlass() {
 60       return (InstanceKlass) getKlass();
 61    }
 62 
 63    public Object getMetaClassFieldValue(String name) {
 64       int fieldID = getFieldID(name);
 65       InstanceKlass ik = getInstanceKlass();
 66       switch (fieldID) {
 67       case FIELD_SOURCE_FILE: {
 68          Symbol sourceFile = ik.getSourceFileName();
 69          return (sourceFile != null)? sourceFile.asString() : &quot;&lt;unknown&gt;&quot;;
 70       }
 71       case FIELD_INTERFACES:
 72          return getInterfaces();
 73       case FIELD_FIELDS:
 74          return factory.newJSList(ik.getImmediateFields());
 75       case FIELD_METHODS:
 76          return factory.newJSList(ik.getImmediateMethods());
</pre>
<hr />
<pre>
142       } else {
143          throw new NoSuchFieldException(name + &quot; is not field of &quot;
144                 + getInstanceKlass().getName().asString().replace(&#39;/&#39;, &#39;.&#39;));
145       }
146    }
147 
148    public Object getStaticFieldValue(String name) throws NoSuchFieldException {
149       Field fld = findStaticField(name);
150       if (fld != null) {
151          return getFieldValue(fld, name, getInstanceKlass());
152       } else {
153          throw new NoSuchFieldException(name + &quot; is not field of &quot;
154                 + getInstanceKlass().getName().asString().replace(&#39;/&#39;, &#39;.&#39;));
155       }
156    }
157 
158    public String[] getInstanceFieldNames() {
159       if (instanceFieldNames == null) {
160          InstanceKlass current = getInstanceKlass();
161          while (current != null) {
<span class="line-modified">162             List tmp = current.getImmediateFields();</span>
<span class="line-modified">163             for (Iterator itr = tmp.iterator(); itr.hasNext();) {</span>
<span class="line-modified">164                Field fld = (Field) itr.next();</span>
165                if (!fld.isStatic()) {
166                   String name = fld.getID().getName();
167                   if (instanceFields.get(name) == null) {
168                      instanceFields.put(name, fld);
169                   }
170                }
171             }
172             current = (InstanceKlass) current.getSuper();
173          }
174 
175          Set s = instanceFields.keySet();
176          instanceFieldNames = new String[s.size()];
177          int i = 0;
178          for (Iterator itr = s.iterator(); itr.hasNext(); i++) {
179             instanceFieldNames[i] = (String) itr.next();
180          }
181       }
182       return instanceFieldNames;
183    }
184 
185    public boolean hasInstanceField(String name) {
186       Field fld = findInstanceField(name);
187       return (fld != null)? true: false;
188    }
189 
190    public String[] getStaticFieldNames() {
191       if (staticFieldNames == null) {
192          InstanceKlass current = getInstanceKlass();
<span class="line-modified">193          List tmp = current.getImmediateFields();</span>
<span class="line-modified">194          for (Iterator itr = tmp.iterator(); itr.hasNext();) {</span>
<span class="line-modified">195             Field fld = (Field) itr.next();</span>
196             if (fld.isStatic()) {
197                staticFields.put(fld.getID().getName(), fld);
198             }
199          }
200 
201          Set s = staticFields.keySet();
202          staticFieldNames = new String[s.size()];
203          int i = 0;
204          for (Iterator itr = s.iterator(); itr.hasNext(); i++) {
205             staticFieldNames[i] = (String) itr.next();
206          }
207       }
208       return staticFieldNames;
209    }
210 
211    public boolean hasStaticField(String name) {
212       Field fld = findStaticField(name);
213       return (fld != null)? true: false;
214    }
215 
216    //-- Intenals only below this point
<span class="line-modified">217    private static Map fields = new HashMap();</span>
218    private static void addField(String name, int fieldId) {
<span class="line-modified">219       fields.put(name, new Integer(fieldId));</span>
220    }
221 
222    private static int getFieldID(String name) {
223       Integer res = (Integer) fields.get(name);
224       return (res != null)? res.intValue() : FIELD_UNDEFINED;
225    }
226 
227    static {
228       addField(&quot;sourceFile&quot;, FIELD_SOURCE_FILE);
229       addField(&quot;interfaces&quot;, FIELD_INTERFACES);
230       addField(&quot;fields&quot;, FIELD_FIELDS);
231       addField(&quot;methods&quot;, FIELD_METHODS);
232       addField(&quot;isPrivate&quot;, FIELD_IS_PRIVATE);
233       addField(&quot;isPublic&quot;, FIELD_IS_PUBLIC);
234       addField(&quot;isProtected&quot;, FIELD_IS_PROTECTED);
235       addField(&quot;isPackagePrivate&quot;, FIELD_IS_PACKAGE_PRIVATE);
236       addField(&quot;isStatic&quot;, FIELD_IS_STATIC);
237       addField(&quot;isFinal&quot;, FIELD_IS_FINAL);
238       addField(&quot;isAbstract&quot;, FIELD_IS_ABSTRACT);
239       addField(&quot;isStrict&quot;, FIELD_IS_STRICT);
240       addField(&quot;isSynthetic&quot;, FIELD_IS_SYNTHETIC);
241       addField(&quot;isInterface&quot;, FIELD_IS_INTERFACE);
242       addField(&quot;classLoader&quot;, FIELD_CLASS_LOADER);
243       addField(&quot;statics&quot;, FIELD_STATICS);
244    }
245 
246    private AccessFlags getAccessFlags() {
247       if (accFlags == null) {
248          accFlags = new AccessFlags(getInstanceKlass().computeModifierFlags());
249       }
250       return accFlags;
251    }
252 
253    private Object getFieldValue(Field fld, String name, Oop oop) {
254        FieldType fd = fld.getFieldType();
255        if (fd.isObject() || fd.isArray()) {
256          return factory.newJSJavaObject(((OopField)fld).getValue(oop));
257        } else if (fd.isByte()) {
<span class="line-modified">258           return new Byte(((ByteField)fld).getValue(oop));</span>
259        } else if (fd.isChar()) {
260           return new String(new char[] { ((CharField)fld).getValue(oop) });
261        } else if (fd.isDouble()) {
<span class="line-modified">262           return new Double(((DoubleField)fld).getValue(oop));</span>
263        } else if (fd.isFloat()) {
<span class="line-modified">264           return new Float(((FloatField)fld).getValue(oop));</span>
265        } else if (fd.isInt()) {
<span class="line-modified">266           return new Integer(((IntField)fld).getValue(oop));</span>
267        } else if (fd.isLong()) {
<span class="line-modified">268           return new Long(((LongField)fld).getValue(oop));</span>
269        } else if (fd.isShort()) {
<span class="line-modified">270           return new Short(((ShortField)fld).getValue(oop));</span>
271        } else if (fd.isBoolean()) {
<span class="line-modified">272           return Boolean.valueOf(((BooleanField)fld).getValue(oop));</span>
273        } else {
274           if (Assert.ASSERTS_ENABLED) {
275              Assert.that(false, &quot;invalid field type for &quot; + name);
276           }
277           return null;
278        }
279    }
280 
281    private Object getFieldValue(Field fld, String name, InstanceKlass oop) {
282        FieldType fd = fld.getFieldType();
283        if (fd.isObject() || fd.isArray()) {
284          return factory.newJSJavaObject(((OopField)fld).getValue(oop));
285        } else if (fd.isByte()) {
<span class="line-modified">286           return new Byte(((ByteField)fld).getValue(oop));</span>
287        } else if (fd.isChar()) {
288           return new String(new char[] { ((CharField)fld).getValue(oop) });
289        } else if (fd.isDouble()) {
<span class="line-modified">290           return new Double(((DoubleField)fld).getValue(oop));</span>
291        } else if (fd.isFloat()) {
<span class="line-modified">292           return new Float(((FloatField)fld).getValue(oop));</span>
293        } else if (fd.isInt()) {
<span class="line-modified">294           return new Integer(((IntField)fld).getValue(oop));</span>
295        } else if (fd.isLong()) {
<span class="line-modified">296           return new Long(((LongField)fld).getValue(oop));</span>
297        } else if (fd.isShort()) {
<span class="line-modified">298           return new Short(((ShortField)fld).getValue(oop));</span>
299        } else if (fd.isBoolean()) {
<span class="line-modified">300           return Boolean.valueOf(((BooleanField)fld).getValue(oop));</span>
301        } else {
302           if (Assert.ASSERTS_ENABLED) {
303              Assert.that(false, &quot;invalid field type for &quot; + name);
304           }
305           return null;
306        }
307    }
308 
309    private Field findInstanceField(String name) {
310       Field fld = (Field) instanceFields.get(name);
311       if (fld != null) {
312          return fld;
313       } else {
314          InstanceKlass current = getInstanceKlass();
315          while (current != null) {
<span class="line-modified">316             List tmp = current.getImmediateFields();</span>
<span class="line-modified">317             for (Iterator itr = tmp.iterator(); itr.hasNext();) {</span>
<span class="line-modified">318                fld = (Field) itr.next();</span>
319                if (fld.getID().getName().equals(name) &amp;&amp; !fld.isStatic()) {
320                    instanceFields.put(name, fld);
321                    return fld;
322                }
323             }
324             // lookup in super class.
325             current = (InstanceKlass) current.getSuper();
326          }
327       }
328       // no match
329       return null;
330    }
331 
332    private Field findStaticField(String name) {
333       Field fld = (Field) staticFields.get(name);
334       if (fld != null) {
335          return fld;
336       } else {
337          // static fields are searched only in current.
338          // Direct/indirect super classes and interfaces
339          // are not included in search.
340          InstanceKlass current = getInstanceKlass();
<span class="line-modified">341          List tmp = current.getImmediateFields();</span>
<span class="line-modified">342          for (Iterator itr = tmp.iterator(); itr.hasNext();) {</span>
<span class="line-modified">343             fld = (Field) itr.next();</span>
344             if (fld.getID().getName().equals(name) &amp;&amp; fld.isStatic()) {
345                staticFields.put(name, fld);
346                return fld;
347             }
348          }
349          // no match
350          return null;
351       }
352    }
353 
354    private JSList getInterfaces() {
355       InstanceKlass ik = getInstanceKlass();
<span class="line-modified">356       List intfs = ik.getDirectImplementedInterfaces();</span>
<span class="line-modified">357       List res = new ArrayList(0);</span>
<span class="line-modified">358       for (Iterator itr = intfs.iterator(); itr.hasNext();) {</span>
<span class="line-modified">359           Klass k = (Klass) itr.next();</span>
360           res.add(k.getJavaMirror());
361       }
362       return factory.newJSList(res);
363    }
364 
365    private JSMap getStatics() {
366       String[] names = getStaticFieldNames();
<span class="line-modified">367       Map map = new HashMap();</span>
368       for (int i=0; i &lt; names.length; i++) {
369          try {
370             map.put(names[i], getStaticFieldValue(names[i]));
371          } catch (NoSuchFieldException exp) {}
372       }
373       return factory.newJSMap(map);
374   }
375 
<span class="line-modified">376    private Map           instanceFields;</span>
<span class="line-modified">377    private Map           staticFields;</span>
378    private String[]      instanceFieldNames;
379    private String[]      staticFieldNames;
380    private AccessFlags   accFlags;
381 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 35    private static final int FIELD_SOURCE_FILE        = 1;
 36    private static final int FIELD_INTERFACES         = 2;
 37    private static final int FIELD_FIELDS             = 3;
 38    private static final int FIELD_METHODS            = 4;
 39    private static final int FIELD_IS_PRIVATE         = 5;
 40    private static final int FIELD_IS_PUBLIC          = 6;
 41    private static final int FIELD_IS_PROTECTED       = 7;
 42    private static final int FIELD_IS_PACKAGE_PRIVATE = 8;
 43    private static final int FIELD_IS_STATIC          = 9;
 44    private static final int FIELD_IS_FINAL           = 10;
 45    private static final int FIELD_IS_ABSTRACT        = 11;
 46    private static final int FIELD_IS_STRICT          = 12;
 47    private static final int FIELD_IS_SYNTHETIC       = 13;
 48    private static final int FIELD_IS_INTERFACE       = 14;
 49    private static final int FIELD_CLASS_LOADER       = 15;
 50    private static final int FIELD_STATICS            = 18;
 51    private static final int FIELD_UNDEFINED          = -1;
 52 
 53    public JSJavaInstanceKlass(InstanceKlass kls, JSJavaFactory fac) {
 54       super(kls, fac);
<span class="line-modified"> 55       this.instanceFields = new HashMap&lt;&gt;();</span>
<span class="line-modified"> 56       this.staticFields = new HashMap&lt;&gt;();</span>
 57    }
 58 
 59    public final InstanceKlass getInstanceKlass() {
 60       return (InstanceKlass) getKlass();
 61    }
 62 
 63    public Object getMetaClassFieldValue(String name) {
 64       int fieldID = getFieldID(name);
 65       InstanceKlass ik = getInstanceKlass();
 66       switch (fieldID) {
 67       case FIELD_SOURCE_FILE: {
 68          Symbol sourceFile = ik.getSourceFileName();
 69          return (sourceFile != null)? sourceFile.asString() : &quot;&lt;unknown&gt;&quot;;
 70       }
 71       case FIELD_INTERFACES:
 72          return getInterfaces();
 73       case FIELD_FIELDS:
 74          return factory.newJSList(ik.getImmediateFields());
 75       case FIELD_METHODS:
 76          return factory.newJSList(ik.getImmediateMethods());
</pre>
<hr />
<pre>
142       } else {
143          throw new NoSuchFieldException(name + &quot; is not field of &quot;
144                 + getInstanceKlass().getName().asString().replace(&#39;/&#39;, &#39;.&#39;));
145       }
146    }
147 
148    public Object getStaticFieldValue(String name) throws NoSuchFieldException {
149       Field fld = findStaticField(name);
150       if (fld != null) {
151          return getFieldValue(fld, name, getInstanceKlass());
152       } else {
153          throw new NoSuchFieldException(name + &quot; is not field of &quot;
154                 + getInstanceKlass().getName().asString().replace(&#39;/&#39;, &#39;.&#39;));
155       }
156    }
157 
158    public String[] getInstanceFieldNames() {
159       if (instanceFieldNames == null) {
160          InstanceKlass current = getInstanceKlass();
161          while (current != null) {
<span class="line-modified">162             List&lt;Field&gt; tmp = current.getImmediateFields();</span>
<span class="line-modified">163             for (Iterator&lt;Field&gt; itr = tmp.iterator(); itr.hasNext();) {</span>
<span class="line-modified">164                Field fld = itr.next();</span>
165                if (!fld.isStatic()) {
166                   String name = fld.getID().getName();
167                   if (instanceFields.get(name) == null) {
168                      instanceFields.put(name, fld);
169                   }
170                }
171             }
172             current = (InstanceKlass) current.getSuper();
173          }
174 
175          Set s = instanceFields.keySet();
176          instanceFieldNames = new String[s.size()];
177          int i = 0;
178          for (Iterator itr = s.iterator(); itr.hasNext(); i++) {
179             instanceFieldNames[i] = (String) itr.next();
180          }
181       }
182       return instanceFieldNames;
183    }
184 
185    public boolean hasInstanceField(String name) {
186       Field fld = findInstanceField(name);
187       return (fld != null)? true: false;
188    }
189 
190    public String[] getStaticFieldNames() {
191       if (staticFieldNames == null) {
192          InstanceKlass current = getInstanceKlass();
<span class="line-modified">193          List&lt;Field&gt; tmp = current.getImmediateFields();</span>
<span class="line-modified">194          for (Iterator&lt;Field&gt; itr = tmp.iterator(); itr.hasNext();) {</span>
<span class="line-modified">195             Field fld = itr.next();</span>
196             if (fld.isStatic()) {
197                staticFields.put(fld.getID().getName(), fld);
198             }
199          }
200 
201          Set s = staticFields.keySet();
202          staticFieldNames = new String[s.size()];
203          int i = 0;
204          for (Iterator itr = s.iterator(); itr.hasNext(); i++) {
205             staticFieldNames[i] = (String) itr.next();
206          }
207       }
208       return staticFieldNames;
209    }
210 
211    public boolean hasStaticField(String name) {
212       Field fld = findStaticField(name);
213       return (fld != null)? true: false;
214    }
215 
216    //-- Intenals only below this point
<span class="line-modified">217    private static Map&lt;String, Integer&gt; fields = new HashMap&lt;&gt;();</span>
218    private static void addField(String name, int fieldId) {
<span class="line-modified">219       fields.put(name, fieldId);</span>
220    }
221 
222    private static int getFieldID(String name) {
223       Integer res = (Integer) fields.get(name);
224       return (res != null)? res.intValue() : FIELD_UNDEFINED;
225    }
226 
227    static {
228       addField(&quot;sourceFile&quot;, FIELD_SOURCE_FILE);
229       addField(&quot;interfaces&quot;, FIELD_INTERFACES);
230       addField(&quot;fields&quot;, FIELD_FIELDS);
231       addField(&quot;methods&quot;, FIELD_METHODS);
232       addField(&quot;isPrivate&quot;, FIELD_IS_PRIVATE);
233       addField(&quot;isPublic&quot;, FIELD_IS_PUBLIC);
234       addField(&quot;isProtected&quot;, FIELD_IS_PROTECTED);
235       addField(&quot;isPackagePrivate&quot;, FIELD_IS_PACKAGE_PRIVATE);
236       addField(&quot;isStatic&quot;, FIELD_IS_STATIC);
237       addField(&quot;isFinal&quot;, FIELD_IS_FINAL);
238       addField(&quot;isAbstract&quot;, FIELD_IS_ABSTRACT);
239       addField(&quot;isStrict&quot;, FIELD_IS_STRICT);
240       addField(&quot;isSynthetic&quot;, FIELD_IS_SYNTHETIC);
241       addField(&quot;isInterface&quot;, FIELD_IS_INTERFACE);
242       addField(&quot;classLoader&quot;, FIELD_CLASS_LOADER);
243       addField(&quot;statics&quot;, FIELD_STATICS);
244    }
245 
246    private AccessFlags getAccessFlags() {
247       if (accFlags == null) {
248          accFlags = new AccessFlags(getInstanceKlass().computeModifierFlags());
249       }
250       return accFlags;
251    }
252 
253    private Object getFieldValue(Field fld, String name, Oop oop) {
254        FieldType fd = fld.getFieldType();
255        if (fd.isObject() || fd.isArray()) {
256          return factory.newJSJavaObject(((OopField)fld).getValue(oop));
257        } else if (fd.isByte()) {
<span class="line-modified">258           return ((ByteField) fld).getValue(oop);</span>
259        } else if (fd.isChar()) {
260           return new String(new char[] { ((CharField)fld).getValue(oop) });
261        } else if (fd.isDouble()) {
<span class="line-modified">262           return ((DoubleField) fld).getValue(oop);</span>
263        } else if (fd.isFloat()) {
<span class="line-modified">264           return ((FloatField) fld).getValue(oop);</span>
265        } else if (fd.isInt()) {
<span class="line-modified">266           return ((IntField) fld).getValue(oop);</span>
267        } else if (fd.isLong()) {
<span class="line-modified">268           return ((LongField) fld).getValue(oop);</span>
269        } else if (fd.isShort()) {
<span class="line-modified">270           return ((ShortField) fld).getValue(oop);</span>
271        } else if (fd.isBoolean()) {
<span class="line-modified">272           return ((BooleanField) fld).getValue(oop);</span>
273        } else {
274           if (Assert.ASSERTS_ENABLED) {
275              Assert.that(false, &quot;invalid field type for &quot; + name);
276           }
277           return null;
278        }
279    }
280 
281    private Object getFieldValue(Field fld, String name, InstanceKlass oop) {
282        FieldType fd = fld.getFieldType();
283        if (fd.isObject() || fd.isArray()) {
284          return factory.newJSJavaObject(((OopField)fld).getValue(oop));
285        } else if (fd.isByte()) {
<span class="line-modified">286           return ((ByteField) fld).getValue(oop);</span>
287        } else if (fd.isChar()) {
288           return new String(new char[] { ((CharField)fld).getValue(oop) });
289        } else if (fd.isDouble()) {
<span class="line-modified">290           return ((DoubleField) fld).getValue(oop);</span>
291        } else if (fd.isFloat()) {
<span class="line-modified">292           return ((FloatField) fld).getValue(oop);</span>
293        } else if (fd.isInt()) {
<span class="line-modified">294           return ((IntField) fld).getValue(oop);</span>
295        } else if (fd.isLong()) {
<span class="line-modified">296           return ((LongField) fld).getValue(oop);</span>
297        } else if (fd.isShort()) {
<span class="line-modified">298           return ((ShortField) fld).getValue(oop);</span>
299        } else if (fd.isBoolean()) {
<span class="line-modified">300           return ((BooleanField) fld).getValue(oop);</span>
301        } else {
302           if (Assert.ASSERTS_ENABLED) {
303              Assert.that(false, &quot;invalid field type for &quot; + name);
304           }
305           return null;
306        }
307    }
308 
309    private Field findInstanceField(String name) {
310       Field fld = (Field) instanceFields.get(name);
311       if (fld != null) {
312          return fld;
313       } else {
314          InstanceKlass current = getInstanceKlass();
315          while (current != null) {
<span class="line-modified">316             List&lt;Field&gt; tmp = current.getImmediateFields();</span>
<span class="line-modified">317             for (Iterator&lt;Field&gt; itr = tmp.iterator(); itr.hasNext();) {</span>
<span class="line-modified">318                fld = itr.next();</span>
319                if (fld.getID().getName().equals(name) &amp;&amp; !fld.isStatic()) {
320                    instanceFields.put(name, fld);
321                    return fld;
322                }
323             }
324             // lookup in super class.
325             current = (InstanceKlass) current.getSuper();
326          }
327       }
328       // no match
329       return null;
330    }
331 
332    private Field findStaticField(String name) {
333       Field fld = (Field) staticFields.get(name);
334       if (fld != null) {
335          return fld;
336       } else {
337          // static fields are searched only in current.
338          // Direct/indirect super classes and interfaces
339          // are not included in search.
340          InstanceKlass current = getInstanceKlass();
<span class="line-modified">341          List&lt;Field&gt; tmp = current.getImmediateFields();</span>
<span class="line-modified">342          for (Iterator&lt;Field&gt; itr = tmp.iterator(); itr.hasNext();) {</span>
<span class="line-modified">343             fld = itr.next();</span>
344             if (fld.getID().getName().equals(name) &amp;&amp; fld.isStatic()) {
345                staticFields.put(name, fld);
346                return fld;
347             }
348          }
349          // no match
350          return null;
351       }
352    }
353 
354    private JSList getInterfaces() {
355       InstanceKlass ik = getInstanceKlass();
<span class="line-modified">356       List&lt;Klass&gt; intfs = ik.getDirectImplementedInterfaces();</span>
<span class="line-modified">357       List&lt;Instance&gt; res = new ArrayList&lt;&gt;(0);</span>
<span class="line-modified">358       for (Iterator&lt;Klass&gt; itr = intfs.iterator(); itr.hasNext();) {</span>
<span class="line-modified">359           Klass k = itr.next();</span>
360           res.add(k.getJavaMirror());
361       }
362       return factory.newJSList(res);
363    }
364 
365    private JSMap getStatics() {
366       String[] names = getStaticFieldNames();
<span class="line-modified">367       Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span>
368       for (int i=0; i &lt; names.length; i++) {
369          try {
370             map.put(names[i], getStaticFieldValue(names[i]));
371          } catch (NoSuchFieldException exp) {}
372       }
373       return factory.newJSMap(map);
374   }
375 
<span class="line-modified">376    private Map&lt;String, Field&gt; instanceFields;</span>
<span class="line-modified">377    private Map&lt;String, Field&gt; staticFields;</span>
378    private String[]      instanceFieldNames;
379    private String[]      staticFieldNames;
380    private AccessFlags   accFlags;
381 }
</pre>
</td>
</tr>
</table>
<center><a href="JSJavaHeap.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSJavaKlass.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
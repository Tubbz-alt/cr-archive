<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/code/NMethod.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.code;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.oops.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.types.*;
 33 import sun.jvm.hotspot.utilities.*;
 34 import sun.jvm.hotspot.utilities.Observable;
 35 import sun.jvm.hotspot.utilities.Observer;
 36 
 37 public class NMethod extends CompiledMethod {
 38   private static long          pcDescSize;
 39   /** != InvocationEntryBci if this nmethod is an on-stack replacement method */
 40   private static CIntegerField entryBCIField;
 41   /** To support simple linked-list chaining of nmethods */
 42   private static AddressField  osrLinkField;
 43 
 44   /** Offsets for different nmethod parts */
 45   private static CIntegerField exceptionOffsetField;
 46   private static CIntegerField origPCOffsetField;
 47   private static CIntegerField stubOffsetField;
 48   private static CIntegerField oopsOffsetField;
 49   private static CIntegerField metadataOffsetField;
 50   private static CIntegerField scopesPCsOffsetField;
 51   private static CIntegerField dependenciesOffsetField;
 52   private static CIntegerField handlerTableOffsetField;
 53   private static CIntegerField nulChkTableOffsetField;
 54   private static CIntegerField nmethodEndOffsetField;
 55 
 56   /** Offsets for entry points */
 57   /** Entry point with class check */
 58   private static AddressField  entryPointField;
 59   /** Entry point without class check */
 60   private static AddressField  verifiedEntryPointField;
 61   /** Entry point for on stack replacement */
 62   private static AddressField  osrEntryPointField;
 63 
 64   // FIXME: add access to flags (how?)
 65 
 66   /** NMethod Flushing lock (if non-zero, then the nmethod is not removed) */
 67   private static JIntField     lockCountField;
 68 
 69   /** not_entrant method removal. Each mark_sweep pass will update
 70       this mark to current sweep invocation count if it is seen on the
 71       stack.  An not_entrant method can be removed when there is no
 72       more activations, i.e., when the _stack_traversal_mark is less than
 73       current sweep traversal index. */
 74   private static CIntegerField stackTraversalMarkField;
 75 
 76   private static CIntegerField compLevelField;
 77 
 78   static {
 79     VM.registerVMInitializedObserver(new Observer() {
 80         public void update(Observable o, Object data) {
 81           initialize(VM.getVM().getTypeDataBase());
 82         }
 83       });
 84   }
 85 
 86   private static void initialize(TypeDataBase db) {
 87     Type type = db.lookupType(&quot;nmethod&quot;);
 88 
 89     entryBCIField               = type.getCIntegerField(&quot;_entry_bci&quot;);
 90     osrLinkField                = type.getAddressField(&quot;_osr_link&quot;);
 91 
 92     exceptionOffsetField        = type.getCIntegerField(&quot;_exception_offset&quot;);
 93     origPCOffsetField           = type.getCIntegerField(&quot;_orig_pc_offset&quot;);
 94     stubOffsetField             = type.getCIntegerField(&quot;_stub_offset&quot;);
 95     oopsOffsetField             = type.getCIntegerField(&quot;_oops_offset&quot;);
 96     metadataOffsetField         = type.getCIntegerField(&quot;_metadata_offset&quot;);
 97     scopesPCsOffsetField        = type.getCIntegerField(&quot;_scopes_pcs_offset&quot;);
 98     dependenciesOffsetField     = type.getCIntegerField(&quot;_dependencies_offset&quot;);
 99     handlerTableOffsetField     = type.getCIntegerField(&quot;_handler_table_offset&quot;);
100     nulChkTableOffsetField      = type.getCIntegerField(&quot;_nul_chk_table_offset&quot;);
101     nmethodEndOffsetField       = type.getCIntegerField(&quot;_nmethod_end_offset&quot;);
102     entryPointField             = type.getAddressField(&quot;_entry_point&quot;);
103     verifiedEntryPointField     = type.getAddressField(&quot;_verified_entry_point&quot;);
104     osrEntryPointField          = type.getAddressField(&quot;_osr_entry_point&quot;);
105     lockCountField              = type.getJIntField(&quot;_lock_count&quot;);
106     stackTraversalMarkField     = type.getCIntegerField(&quot;_stack_traversal_mark&quot;);
107     compLevelField              = type.getCIntegerField(&quot;_comp_level&quot;);
108     pcDescSize = db.lookupType(&quot;PcDesc&quot;).getSize();
109   }
110 
111   public NMethod(Address addr) {
112     super(addr);
113   }
114 
115   // Accessors
116   public Address getAddress() {
117     return addr;
118   }
119 
120   // Type info
121   public boolean isNMethod()      { return true;                    }
122   public boolean isJavaMethod()   { return !getMethod().isNative(); }
123   public boolean isNativeMethod() { return getMethod().isNative();  }
124   public boolean isOSRMethod()    { return getEntryBCI() != VM.getVM().getInvocationEntryBCI(); }
125 
126   /** Boundaries for different parts */
127   public Address constantsBegin()       { return contentBegin();                                     }
128   public Address constantsEnd()         { return getEntryPoint();                                    }
129   public Address instsBegin()           { return codeBegin();                                        }
130   public Address instsEnd()             { return headerBegin().addOffsetTo(getStubOffset());         }
131   public Address exceptionBegin()       { return headerBegin().addOffsetTo(getExceptionOffset());    }
132   public Address stubBegin()            { return headerBegin().addOffsetTo(getStubOffset());         }
133   public Address stubEnd()              { return headerBegin().addOffsetTo(getOopsOffset());         }
134   public Address oopsBegin()            { return headerBegin().addOffsetTo(getOopsOffset());         }
135   public Address oopsEnd()              { return headerBegin().addOffsetTo(getMetadataOffset());     }
136   public Address metadataBegin()        { return headerBegin().addOffsetTo(getMetadataOffset());     }
137   public Address metadataEnd()          { return scopesDataBegin();                                  }
138   public Address scopesDataEnd()        { return headerBegin().addOffsetTo(getScopesPCsOffset());    }
139   public Address scopesPCsBegin()       { return headerBegin().addOffsetTo(getScopesPCsOffset());    }
140   public Address scopesPCsEnd()         { return headerBegin().addOffsetTo(getDependenciesOffset()); }
141   public Address dependenciesBegin()    { return headerBegin().addOffsetTo(getDependenciesOffset()); }
142   public Address dependenciesEnd()      { return headerBegin().addOffsetTo(getHandlerTableOffset()); }
143   public Address handlerTableBegin()    { return headerBegin().addOffsetTo(getHandlerTableOffset()); }
144   public Address handlerTableEnd()      { return headerBegin().addOffsetTo(getNulChkTableOffset());  }
145   public Address nulChkTableBegin()     { return headerBegin().addOffsetTo(getNulChkTableOffset());  }
146   public Address nulChkTableEnd()       { return headerBegin().addOffsetTo(getNMethodEndOffset());   }
147 
148   public int constantsSize()            { return (int) constantsEnd()   .minus(constantsBegin());    }
149   public int instsSize()                { return (int) instsEnd()       .minus(instsBegin());        }
150   public int stubSize()                 { return (int) stubEnd()        .minus(stubBegin());         }
151   public int oopsSize()                 { return (int) oopsEnd()        .minus(oopsBegin());         }
152   public int metadataSize()             { return (int) metadataEnd()    .minus(metadataBegin());     }
153   public int scopesDataSize()           { return (int) scopesDataEnd()  .minus(scopesDataBegin());   }
154   public int scopesPCsSize()            { return (int) scopesPCsEnd()   .minus(scopesPCsBegin());    }
155   public int dependenciesSize()         { return (int) dependenciesEnd().minus(dependenciesBegin()); }
156   public int handlerTableSize()         { return (int) handlerTableEnd().minus(handlerTableBegin()); }
157   public int nulChkTableSize()          { return (int) nulChkTableEnd() .minus(nulChkTableBegin());  }
158   public int origPCOffset()             { return (int) origPCOffsetField.getValue(addr);             }
159 
160   public int totalSize() {
161     return
162       constantsSize()    +
163       instsSize()        +
164       stubSize()         +
165       scopesDataSize()   +
166       scopesPCsSize()    +
167       dependenciesSize() +
168       handlerTableSize() +
169       nulChkTableSize();
170   }
171 
172   public boolean constantsContains   (Address addr) { return constantsBegin()   .lessThanOrEqual(addr) &amp;&amp; constantsEnd()   .greaterThan(addr); }
173   public boolean instsContains       (Address addr) { return instsBegin()       .lessThanOrEqual(addr) &amp;&amp; instsEnd()       .greaterThan(addr); }
174   public boolean stubContains        (Address addr) { return stubBegin()        .lessThanOrEqual(addr) &amp;&amp; stubEnd()        .greaterThan(addr); }
175   public boolean oopsContains        (Address addr) { return oopsBegin()        .lessThanOrEqual(addr) &amp;&amp; oopsEnd()        .greaterThan(addr); }
176   public boolean metadataContains    (Address addr) { return metadataBegin()    .lessThanOrEqual(addr) &amp;&amp; metadataEnd()    .greaterThan(addr); }
177   public boolean scopesDataContains  (Address addr) { return scopesDataBegin()  .lessThanOrEqual(addr) &amp;&amp; scopesDataEnd()  .greaterThan(addr); }
178   public boolean scopesPCsContains   (Address addr) { return scopesPCsBegin()   .lessThanOrEqual(addr) &amp;&amp; scopesPCsEnd()   .greaterThan(addr); }
179   public boolean handlerTableContains(Address addr) { return handlerTableBegin().lessThanOrEqual(addr) &amp;&amp; handlerTableEnd().greaterThan(addr); }
180   public boolean nulChkTableContains (Address addr) { return nulChkTableBegin() .lessThanOrEqual(addr) &amp;&amp; nulChkTableEnd() .greaterThan(addr); }
181 
182   public int getOopsLength() { return (int) (oopsSize() / VM.getVM().getOopSize()); }
183   public int getMetadataLength() { return (int) (metadataSize() / VM.getVM().getOopSize()); }
184 
185   /** Entry points */
186   public Address getEntryPoint()         { return entryPointField.getValue(addr);         }
187   public Address getVerifiedEntryPoint() { return verifiedEntryPointField.getValue(addr); }
188 
189   /** Support for oops in scopes and relocs. Note: index 0 is reserved for null. */
190   public OopHandle getOopAt(int index) {
191     if (index == 0) return null;
192     if (Assert.ASSERTS_ENABLED) {
193       Assert.that(index &gt; 0 &amp;&amp; index &lt;= getOopsLength(), &quot;must be a valid non-zero index&quot;);
194     }
195     return oopsBegin().getOopHandleAt((index - 1) * VM.getVM().getOopSize());
196   }
197 
198   /** Support for metadata in scopes and relocs. Note: index 0 is reserved for null. */
199   public Address getMetadataAt(int index) {
200     if (index == 0) return null;
201     if (Assert.ASSERTS_ENABLED) {
202       Assert.that(index &gt; 0 &amp;&amp; index &lt;= getMetadataLength(), &quot;must be a valid non-zero index&quot;);
203     }
204     return metadataBegin().getAddressAt((index - 1) * VM.getVM().getOopSize());
205   }
206 
207   public Method getMethodAt(int index) {
208     return (Method)Metadata.instantiateWrapperFor(getMetadataAt(index));
209   }
210 
211   // FIXME: add interpreter_entry_point()
212   // FIXME: add lazy_interpreter_entry_point() for C2
213 
214   // **********
215   // * FIXME: * ADD ACCESS TO FLAGS!!!!
216   // **********
217   // public boolean isInUse();
218   // public boolean isAlive();
219   // public boolean isNotEntrant();
220   // public boolean isZombie();
221 
222   // ********************************
223   // * MAJOR FIXME: MAJOR HACK HERE *
224   // ********************************
225   public boolean isZombie() { return false; }
226 
227   // public boolean isUnloaded();
228   // public boolean isYoung();
229   // public boolean isOld();
230   // public int     age();
231   // public boolean isMarkedForDeoptimization();
232   // public boolean isMarkedForUnloading();
233   // public int     level();
234   // public int     version();
235 
236   // FIXME: add mutators for above
237   // FIXME: add exception cache access?
238 
239   /** On-stack replacement support */
240   // FIXME: add mutators
241   public int getOSREntryBCI() {
242     if (Assert.ASSERTS_ENABLED) {
243       Assert.that(getEntryBCI() != VM.getVM().getInvocationEntryBCI(), &quot;wrong kind of nmethod&quot;);
244     }
245     return getEntryBCI();
246   }
247 
248   public NMethod getOSRLink() {
249     return (NMethod) VMObjectFactory.newObject(NMethod.class, osrLinkField.getValue(addr));
250   }
251 
252   // MethodHandle
253   public boolean isMethodHandleReturn(Address returnPc) {
254     // Hard to read a bit fields from Java and it&#39;s only there for performance
255     // so just go directly to the PCDesc
256     // if (!hasMethodHandleInvokes())  return false;
257     PCDesc pd = getPCDescAt(returnPc);
258     if (pd == null)
259       return false;
260     return pd.isMethodHandleInvoke();
261   }
262 
263   // Deopt
264   // Return true is the PC is one would expect if the frame is being deopted.
265   public boolean isDeoptPc      (Address pc) { return isDeoptEntry(pc) || isDeoptMhEntry(pc); }
266   public boolean isDeoptEntry   (Address pc) { return pc == deoptHandlerBegin(); }
267   public boolean isDeoptMhEntry (Address pc) { return pc == deoptMhHandlerBegin(); }
268 
269   /** Tells whether frames described by this nmethod can be
270       deoptimized. Note: native wrappers cannot be deoptimized. */
271   public boolean canBeDeoptimized() { return isJavaMethod(); }
272 
273   // FIXME: add inline cache support
274   // FIXME: add flush()
275 
276   public boolean isLockedByVM() { return lockCountField.getValue(addr) &gt; 0; }
277 
278   // FIXME: add mark_as_seen_on_stack
279   // FIXME: add can_not_entrant_be_converted
280 
281   // FIXME: add GC support
282   //  void follow_roots_or_mark_for_unloading(bool unloading_occurred, bool&amp; marked_for_unloading);
283   //  void follow_root_or_mark_for_unloading(oop* root, bool unloading_occurred, bool&amp; marked_for_unloading);
284   //  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, void f(oop*));
285   //  void adjust_pointers();
286 
287   /** Finds a PCDesc with real-pc equal to &quot;pc&quot; */
288   public PCDesc getPCDescAt(Address pc) {
289     // FIXME: consider adding cache like the one down in the VM
290     for (Address p = scopesPCsBegin(); p.lessThan(scopesPCsEnd()); p = p.addOffsetTo(pcDescSize)) {
291       PCDesc pcDesc = new PCDesc(p);
292       if (pcDesc.getRealPC(this).equals(pc)) {
293         return pcDesc;
294       }
295     }
296     return null;
297   }
298 
299   /** ScopeDesc for an instruction */
300   public ScopeDesc getScopeDescAt(Address pc) {
301     PCDesc pd = getPCDescAt(pc);
302     if (Assert.ASSERTS_ENABLED) {
303       Assert.that(pd != null, &quot;scope must be present&quot;);
304     }
305     return new ScopeDesc(this, pd.getScopeDecodeOffset(), pd.getObjDecodeOffset(), pd.getReexecute());
306   }
307 
308   /** This is only for use by the debugging system, and is only
309       intended for use in the topmost frame, where we are not
310       guaranteed to be at a PC for which we have a PCDesc. It finds
311       the PCDesc with realPC closest to the current PC that has
312       a valid scope decode offset. */
313   public PCDesc getPCDescNearDbg(Address pc) {
314     PCDesc bestGuessPCDesc = null;
315     long bestDistance = 0;
316     for (Address p = scopesPCsBegin(); p.lessThan(scopesPCsEnd()); p = p.addOffsetTo(pcDescSize)) {
317       PCDesc pcDesc = new PCDesc(p);
318       if (pcDesc.getScopeDecodeOffset() == DebugInformationRecorder.SERIALIZED_NULL) {
319         // We&#39;ve observed a serialized null decode offset. Ignore this PcDesc.
320         continue;
321       }
322       // In case pc is null
323       long distance = -pcDesc.getRealPC(this).minus(pc);
324       if ((bestGuessPCDesc == null) ||
325           ((distance &gt;= 0) &amp;&amp; (distance &lt; bestDistance))) {
326         bestGuessPCDesc = pcDesc;
327         bestDistance    = distance;
328       }
329     }
330     return bestGuessPCDesc;
331   }
332 
333   PCDesc find_pc_desc(long pc, boolean approximate) {
334     return find_pc_desc_internal(pc, approximate);
335   }
336 
337   // Finds a PcDesc with real-pc equal to &quot;pc&quot;
338   PCDesc find_pc_desc_internal(long pc, boolean approximate) {
339     long base_address = VM.getAddressValue(codeBegin());
340     int pc_offset = (int) (pc - base_address);
341 
342     // Fallback algorithm: quasi-linear search for the PcDesc
343     // Find the last pc_offset less than the given offset.
344     // The successor must be the required match, if there is a match at all.
345     // (Use a fixed radix to avoid expensive affine pointer arithmetic.)
346     Address lower = scopesPCsBegin();
347     Address upper = scopesPCsEnd();
348     upper = upper.addOffsetTo(-pcDescSize); // exclude final sentinel
349     if (lower.greaterThan(upper))  return null;  // native method; no PcDescs at all
350 
351     // Take giant steps at first (4096, then 256, then 16, then 1)
352     int LOG2_RADIX = 4;
353     int RADIX = (1 &lt;&lt; LOG2_RADIX);
354     Address mid;
355     for (int step = (1 &lt;&lt; (LOG2_RADIX*3)); step &gt; 1; step &gt;&gt;= LOG2_RADIX) {
356       while ((mid = lower.addOffsetTo(step * pcDescSize)).lessThan(upper)) {
357         PCDesc m = new PCDesc(mid);
358         if (m.getPCOffset() &lt; pc_offset) {
359           lower = mid;
360         } else {
361           upper = mid;
362           break;
363         }
364       }
365     }
366     // Sneak up on the value with a linear search of length ~16.
367     while (true) {
368       mid = lower.addOffsetTo(pcDescSize);
369       PCDesc m = new PCDesc(mid);
370       if (m.getPCOffset() &lt; pc_offset) {
371         lower = mid;
372       } else {
373         upper = mid;
374         break;
375       }
376     }
377 
378     PCDesc u = new PCDesc(upper);
379     if (match_desc(u, pc_offset, approximate)) {
380       return u;
381     } else {
382       return null;
383     }
384   }
385 
386   // ScopeDesc retrieval operation
387   PCDesc pc_desc_at(long pc)   { return find_pc_desc(pc, false); }
388   // pc_desc_near returns the first PCDesc at or after the givne pc.
389   PCDesc pc_desc_near(long pc) { return find_pc_desc(pc, true); }
390 
391   // Return a the last scope in (begin..end]
392   public ScopeDesc scope_desc_in(long begin, long end) {
393     PCDesc p = pc_desc_near(begin+1);
394     if (p != null &amp;&amp; VM.getAddressValue(p.getRealPC(this)) &lt;= end) {
395       return new ScopeDesc(this, p.getScopeDecodeOffset(), p.getObjDecodeOffset(), p.getReexecute());
396     }
397     return null;
398   }
399 
400   static boolean match_desc(PCDesc pc, int pc_offset, boolean approximate) {
401     if (!approximate) {
402       return pc.getPCOffset() == pc_offset;
403     } else {
404       PCDesc prev = new PCDesc(pc.getAddress().addOffsetTo(-pcDescSize));
405        return prev.getPCOffset() &lt; pc_offset &amp;&amp; pc_offset &lt;= pc.getPCOffset();
406     }
407   }
408 
409   /** This is only for use by the debugging system, and is only
410       intended for use in the topmost frame, where we are not
411       guaranteed to be at a PC for which we have a PCDesc. It finds
412       the ScopeDesc closest to the current PC. NOTE that this may
413       return NULL for compiled methods which don&#39;t have any
414       ScopeDescs! */
415   public ScopeDesc getScopeDescNearDbg(Address pc) {
416     PCDesc pd = getPCDescNearDbg(pc);
417     if (pd == null) return null;
418     return new ScopeDesc(this, pd.getScopeDecodeOffset(), pd.getObjDecodeOffset(), pd.getReexecute());
419   }
420 
421   public Map&lt;sun.jvm.hotspot.debugger.Address, PCDesc&gt; getSafepoints() {
422     Map&lt;sun.jvm.hotspot.debugger.Address, PCDesc&gt; safepoints = new HashMap&lt;&gt;();
423     sun.jvm.hotspot.debugger.Address p = null;
424     for (p = scopesPCsBegin(); p.lessThan(scopesPCsEnd());
425          p = p.addOffsetTo(pcDescSize)) {
426        PCDesc pcDesc = new PCDesc(p);
427        sun.jvm.hotspot.debugger.Address pc = pcDesc.getRealPC(this);
428        safepoints.put(pc, pcDesc);
429     }
430     return safepoints;
431   }
432 
433   // FIXME: add getPCOffsetForBCI()
434   // FIXME: add embeddedOopAt()
435   // FIXME: add isDependentOn()
436   // FIXME: add isPatchableAt()
437 
438   /** Support for code generation. Only here for proof-of-concept. */
439   public static int getEntryPointOffset()            { return (int) entryPointField.getOffset();            }
440   public static int getVerifiedEntryPointOffset()    { return (int) verifiedEntryPointField.getOffset();    }
441   public static int getOSREntryPointOffset()         { return (int) osrEntryPointField.getOffset();         }
442   public static int getEntryBCIOffset()              { return (int) entryBCIField.getOffset();              }
443 
444   public void print() {
445     printOn(System.out);
446   }
447 
448   protected void printComponentsOn(PrintStream tty) {
449     // FIXME: add relocation information
450     tty.println(&quot; content: [&quot; + contentBegin() + &quot;, &quot; + contentEnd() + &quot;), &quot; +
451                 &quot; code: [&quot; + codeBegin() + &quot;, &quot; + codeEnd() + &quot;), &quot; +
452                 &quot; data: [&quot; + dataBegin() + &quot;, &quot; + dataEnd() + &quot;), &quot; +
453                 &quot; oops: [&quot; + oopsBegin() + &quot;, &quot; + oopsEnd() + &quot;), &quot; +
454                 &quot; frame size: &quot; + getFrameSize());
455   }
456 
457   public String toString() {
458     Method method = getMethod();
459     return &quot;NMethod for &quot; +
460             method.getMethodHolder().getName().asString() + &quot;.&quot; +
461             method.getName().asString() + method.getSignature().asString() + &quot;==&gt;n&quot; +
462             super.toString();
463   }
464 
465   public String flagsToString() {
466     // FIXME need access to flags...
467     return &quot;&quot;;
468   }
469 
470   public String getName() {
471     Method method = getMethod();
472     return &quot;NMethod for &quot; +
473            method.getMethodHolder().getName().asString() + &quot;.&quot; +
474            method.getName().asString() +
475            method.getSignature().asString();
476   }
477 
478   public void dumpReplayData(PrintStream out) {
479     HashMap&lt;Metadata, Metadata&gt; h = new HashMap&lt;&gt;();
480     for (int i = 1; i &lt; getMetadataLength(); i++) {
481       Metadata meta = Metadata.instantiateWrapperFor(getMetadataAt(i));
482       System.err.println(meta);
483       if (h.get(meta) != null) continue;
484       h.put(meta, meta);
485       if (meta instanceof InstanceKlass) {
486         ((InstanceKlass)meta).dumpReplayData(out);
487       } else if (meta instanceof Method) {
488         ((Method)meta).dumpReplayData(out);
489         MethodData mdo = ((Method)meta).getMethodData();
490         if (mdo != null) {
491           mdo.dumpReplayData(out);
492         }
493       }
494     }
495     Method method = getMethod();
496     if (h.get(method) == null) {
497       method.dumpReplayData(out);
498       MethodData mdo = method.getMethodData();
499       if (mdo != null) {
500         mdo.dumpReplayData(out);
501       }
502     }
503     if (h.get(method.getMethodHolder()) == null) {
504       ((InstanceKlass)method.getMethodHolder()).dumpReplayData(out);
505     }
506     Klass holder = method.getMethodHolder();
507     out.println(&quot;compile &quot; + holder.getName().asString() + &quot; &quot; +
508                 OopUtilities.escapeString(method.getName().asString()) + &quot; &quot; +
509                 method.getSignature().asString() + &quot; &quot; +
510                 getEntryBCI() + &quot; &quot; + getCompLevel());
511 
512   }
513 
514   //--------------------------------------------------------------------------------
515   // Internals only below this point
516   //
517 
518   private int getEntryBCI()           { return (int) entryBCIField          .getValue(addr); }
519   private int getExceptionOffset()    { return (int) exceptionOffsetField   .getValue(addr); }
520   private int getStubOffset()         { return (int) stubOffsetField        .getValue(addr); }
521   private int getOopsOffset()         { return (int) oopsOffsetField        .getValue(addr); }
522   private int getMetadataOffset()     { return (int) metadataOffsetField    .getValue(addr); }
523   private int getScopesPCsOffset()    { return (int) scopesPCsOffsetField   .getValue(addr); }
524   private int getDependenciesOffset() { return (int) dependenciesOffsetField.getValue(addr); }
525   private int getHandlerTableOffset() { return (int) handlerTableOffsetField.getValue(addr); }
526   private int getNulChkTableOffset()  { return (int) nulChkTableOffsetField .getValue(addr); }
527   private int getNMethodEndOffset()   { return (int) nmethodEndOffsetField  .getValue(addr); }
528   private int getCompLevel()          { return (int) compLevelField         .getValue(addr); }
529 }
    </pre>
  </body>
</html>
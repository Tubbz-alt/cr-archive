<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/win32/coff/COFFFileParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../remote/RemoteDebuggerClient.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../windbg/WindbgCDebugInfoBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/win32/coff/COFFFileParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
1410           public short getName() { return iSegName; }
1411           public short getClassName() { return iClassName; }
1412           public int   getOffset() { return offset; }
1413           public int   getSize() { return cbSeg; }
1414         }
1415 
1416 
1417         class DebugVC50SSSegNameImpl extends DebugVC50SubsectionImpl implements DebugVC50SSSegName {
1418           private int offset;
1419           private int size;
1420           private MemoizedObject names;
1421 
1422           DebugVC50SSSegNameImpl(short ssType, short iMod, int ssSize, int offset) {
1423             super(ssType, iMod, ssSize, offset);
1424             this.offset = offset;
1425             this.size   = ssSize;
1426             seek(offset);
1427             names = new MemoizedObject() {
1428                 public Object computeValue() {
1429                   int i = 0;
<span class="line-modified">1430                   List data = new ArrayList();</span>
1431                   while (i &lt; size) {
1432                     String s = readCString();
1433                     data.add(s);
1434                     i += s.length();
1435                   }
1436                   String[] res = new String[data.size()];
<span class="line-modified">1437                   res = (String[]) data.toArray(res);</span>
1438                   return res;
1439                 }
1440               };
1441           }
1442 
1443           public String getSegName(int i) {
1444             return ((String[]) names.getValue())[i];
1445           }
1446         }
1447 
1448         class DebugVC50SSPreCompImpl extends DebugVC50SubsectionImpl implements DebugVC50SSPreComp {
1449           DebugVC50SSPreCompImpl(short ssType, short iMod, int ssSize, int offset) {
1450             super(ssType, iMod, ssSize, offset);
1451           }
1452         }
1453 
1454         class DebugVC50SSOffsetMap16Impl extends DebugVC50SubsectionImpl implements DebugVC50SSOffsetMap16 {
1455           DebugVC50SSOffsetMap16Impl(short ssType, short iMod, int ssSize, int offset) {
1456             super(ssType, iMod, ssSize, offset);
1457           }
</pre>
<hr />
<pre>
3758                                           offset + ptr + 4);
3759             } catch (UnsupportedEncodingException e) {
3760               throw new COFFException(e);
3761             }
3762             ptr++;
3763             lastPtr = ptr;
3764           }
3765         }
3766 
3767         int getNum() {
3768           return strings.length;
3769         }
3770 
3771         String get(int i) {
3772           return strings[i].str;
3773         }
3774 
3775         /** This version takes an absolute offset in the file */
3776         String getAtOffset(int offset) {
3777           int i = Arrays.binarySearch(strings, new COFFString(null, offset),
<span class="line-modified">3778                                       new Comparator() {</span>
<span class="line-modified">3779                                           public int compare(Object o1, Object o2) {</span>
<span class="line-removed">3780                                             COFFString s1 = (COFFString) o1;</span>
<span class="line-removed">3781                                             COFFString s2 = (COFFString) o2;</span>
3782                                             if (s1.offset == s2.offset) {
3783                                               return 0;
3784                                             } else if (s1.offset &lt; s2.offset) {
3785                                               return -1;
3786                                             } else {
3787                                               return 1;
3788                                             }
3789                                           }
3790                                         });
3791           if (i &lt; 0) {
3792             throw new COFFException(&quot;No string found at file offset &quot; + offset);
3793           }
3794           return strings[i].str;
3795         }
3796       }
3797     }
3798 
3799     void initialize() throws COFFException {
3800       // Figure out whether this file is an object file or an image
3801       // (either executable or DLL).
</pre>
<hr />
<pre>
3888         return byteSwap(file.readLong());
3889       } catch (IOException e) {
3890         throw new COFFException(e.toString() + &quot; at offset 0x&quot; +
3891                                 Long.toHexString(filePos), e);
3892       }
3893     }
3894 
3895     /** NOTE: reads little-endian float */
3896     float readFloat() throws COFFException {
3897       int i = readInt();
3898       return Float.intBitsToFloat(i);
3899     }
3900 
3901     /** NOTE: reads little-endian double */
3902     double readDouble() throws COFFException {
3903       long l = readLong();
3904       return Double.longBitsToDouble(l);
3905     }
3906 
3907     String readCString() throws COFFException {
<span class="line-modified">3908       List data = new ArrayList();</span>
3909       byte b = 0;
3910       while ((b = readByte()) != 0) {
<span class="line-modified">3911         data.add(new Byte(b));</span>
3912       }
3913       byte[] bytes = new byte[data.size()];
3914       for (int i = 0; i &lt; data.size(); i++) {
<span class="line-modified">3915         bytes[i] = ((Byte) data.get(i)).byteValue();</span>
3916       }
3917       try {
3918         return new String(bytes, US_ASCII);
3919       } catch (UnsupportedEncodingException e) {
3920         throw new COFFException(e);
3921       }
3922     }
3923 
3924     void seek(long offset) throws COFFException {
3925       try {
3926         filePos = offset;
3927         file.seek(offset);
3928       } catch (IOException e) {
3929         throw new COFFException(e.toString() + &quot; at offset 0x&quot; +
3930                                 Long.toHexString(offset), e);
3931       }
3932     }
3933 
3934     long getFilePointer() throws COFFException {
3935       try {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
1410           public short getName() { return iSegName; }
1411           public short getClassName() { return iClassName; }
1412           public int   getOffset() { return offset; }
1413           public int   getSize() { return cbSeg; }
1414         }
1415 
1416 
1417         class DebugVC50SSSegNameImpl extends DebugVC50SubsectionImpl implements DebugVC50SSSegName {
1418           private int offset;
1419           private int size;
1420           private MemoizedObject names;
1421 
1422           DebugVC50SSSegNameImpl(short ssType, short iMod, int ssSize, int offset) {
1423             super(ssType, iMod, ssSize, offset);
1424             this.offset = offset;
1425             this.size   = ssSize;
1426             seek(offset);
1427             names = new MemoizedObject() {
1428                 public Object computeValue() {
1429                   int i = 0;
<span class="line-modified">1430                   List&lt;String&gt; data = new ArrayList&lt;&gt;();</span>
1431                   while (i &lt; size) {
1432                     String s = readCString();
1433                     data.add(s);
1434                     i += s.length();
1435                   }
1436                   String[] res = new String[data.size()];
<span class="line-modified">1437                   res = data.toArray(res);</span>
1438                   return res;
1439                 }
1440               };
1441           }
1442 
1443           public String getSegName(int i) {
1444             return ((String[]) names.getValue())[i];
1445           }
1446         }
1447 
1448         class DebugVC50SSPreCompImpl extends DebugVC50SubsectionImpl implements DebugVC50SSPreComp {
1449           DebugVC50SSPreCompImpl(short ssType, short iMod, int ssSize, int offset) {
1450             super(ssType, iMod, ssSize, offset);
1451           }
1452         }
1453 
1454         class DebugVC50SSOffsetMap16Impl extends DebugVC50SubsectionImpl implements DebugVC50SSOffsetMap16 {
1455           DebugVC50SSOffsetMap16Impl(short ssType, short iMod, int ssSize, int offset) {
1456             super(ssType, iMod, ssSize, offset);
1457           }
</pre>
<hr />
<pre>
3758                                           offset + ptr + 4);
3759             } catch (UnsupportedEncodingException e) {
3760               throw new COFFException(e);
3761             }
3762             ptr++;
3763             lastPtr = ptr;
3764           }
3765         }
3766 
3767         int getNum() {
3768           return strings.length;
3769         }
3770 
3771         String get(int i) {
3772           return strings[i].str;
3773         }
3774 
3775         /** This version takes an absolute offset in the file */
3776         String getAtOffset(int offset) {
3777           int i = Arrays.binarySearch(strings, new COFFString(null, offset),
<span class="line-modified">3778                                       new Comparator&lt;&gt;() {</span>
<span class="line-modified">3779                                           public int compare(COFFString s1, COFFString s2) {</span>


3780                                             if (s1.offset == s2.offset) {
3781                                               return 0;
3782                                             } else if (s1.offset &lt; s2.offset) {
3783                                               return -1;
3784                                             } else {
3785                                               return 1;
3786                                             }
3787                                           }
3788                                         });
3789           if (i &lt; 0) {
3790             throw new COFFException(&quot;No string found at file offset &quot; + offset);
3791           }
3792           return strings[i].str;
3793         }
3794       }
3795     }
3796 
3797     void initialize() throws COFFException {
3798       // Figure out whether this file is an object file or an image
3799       // (either executable or DLL).
</pre>
<hr />
<pre>
3886         return byteSwap(file.readLong());
3887       } catch (IOException e) {
3888         throw new COFFException(e.toString() + &quot; at offset 0x&quot; +
3889                                 Long.toHexString(filePos), e);
3890       }
3891     }
3892 
3893     /** NOTE: reads little-endian float */
3894     float readFloat() throws COFFException {
3895       int i = readInt();
3896       return Float.intBitsToFloat(i);
3897     }
3898 
3899     /** NOTE: reads little-endian double */
3900     double readDouble() throws COFFException {
3901       long l = readLong();
3902       return Double.longBitsToDouble(l);
3903     }
3904 
3905     String readCString() throws COFFException {
<span class="line-modified">3906       List&lt;Byte&gt; data = new ArrayList&lt;&gt;();</span>
3907       byte b = 0;
3908       while ((b = readByte()) != 0) {
<span class="line-modified">3909         data.add(b);</span>
3910       }
3911       byte[] bytes = new byte[data.size()];
3912       for (int i = 0; i &lt; data.size(); i++) {
<span class="line-modified">3913         bytes[i] = (data.get(i)).byteValue();</span>
3914       }
3915       try {
3916         return new String(bytes, US_ASCII);
3917       } catch (UnsupportedEncodingException e) {
3918         throw new COFFException(e);
3919       }
3920     }
3921 
3922     void seek(long offset) throws COFFException {
3923       try {
3924         filePos = offset;
3925         file.seek(offset);
3926       } catch (IOException e) {
3927         throw new COFFException(e.toString() + &quot; at offset 0x&quot; +
3928                                 Long.toHexString(offset), e);
3929       }
3930     }
3931 
3932     long getFilePointer() throws COFFException {
3933       try {
</pre>
</td>
</tr>
</table>
<center><a href="../../remote/RemoteDebuggerClient.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../windbg/WindbgCDebugInfoBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
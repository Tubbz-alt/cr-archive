<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/windbg/WindbgDebuggerLocal.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WindbgDebugger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../gc/epsilon/EpsilonHeap.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/windbg/WindbgDebuggerLocal.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 42 /** &lt;P&gt; An implementation of the JVMDebugger interface which talks to
 43     windbg and symbol table management is done in Java. &lt;/P&gt;
 44 
 45     &lt;P&gt; &lt;B&gt;NOTE&lt;/B&gt; that since we have the notion of fetching &quot;Java
 46     primitive types&quot; from the remote process (which might have
 47     different sizes than we expect) we have a bootstrapping
 48     problem. We need to know the sizes of these types before we can
 49     fetch them. The current implementation solves this problem by
 50     requiring that it be configured with these type sizes before they
 51     can be fetched. The readJ(Type) routines here will throw a
 52     RuntimeException if they are called before the debugger is
 53     configured with the Java primitive type sizes. &lt;/P&gt; */
 54 
 55 public class WindbgDebuggerLocal extends DebuggerBase implements WindbgDebugger {
 56   private PageCache cache;
 57   private boolean   attached;
 58   private boolean   isCore;
 59 
 60   // Symbol lookup support
 61   // This is a map of library names to DLLs
<span class="line-modified"> 62   private Map nameToDllMap;</span>
 63 
 64   // C/C++ debugging support
<span class="line-modified"> 65   private List/*&lt;LoadObject&gt;*/ loadObjects;</span>
 66   private CDebugger cdbg;
 67 
 68   // thread access
<span class="line-modified"> 69   private Map threadIntegerRegisterSet;</span>
<span class="line-modified"> 70   private List threadList;</span>
 71 
 72   // windbg native interface pointers
 73 
 74   private long ptrIDebugClient;
 75   private long ptrIDebugControl;
 76   private long ptrIDebugDataSpaces;
 77   private long ptrIDebugOutputCallbacks;
 78   private long ptrIDebugAdvanced;
 79   private long ptrIDebugSymbols;
 80   private long ptrIDebugSystemObjects;
 81 
 82   private WindbgThreadFactory threadFactory;
 83 
 84   //--------------------------------------------------------------------------------
 85   // Implementation of Debugger interface
 86   //
 87 
 88   /** &lt;P&gt; machDesc may not be null. &lt;/P&gt;
 89 
 90       &lt;P&gt; useCache should be set to true if debugging is being done
</pre>
<hr />
<pre>
120       // Fetching data over the socket connection to dbx is slow.
121       // Might be faster if we were using a binary protocol to talk to
122       // dbx, but would have to test. For now, this cache works best
123       // if it covers the entire heap of the remote process. FIXME: at
124       // least should make this tunable from the outside, i.e., via
125       // the UI. This is a cache of 4096 4K pages, or 16 MB. The page
126       // size must be adjusted to be the hardware&#39;s page size.
127       // (FIXME: should pick this up from the debugger.)
128       initCache(4096, 4096);
129     }
130     // FIXME: add instantiation of thread factory
131 
132   }
133 
134   /** From the Debugger interface via JVMDebugger */
135   public boolean hasProcessList() throws DebuggerException {
136     return false;
137   }
138 
139   /** From the Debugger interface via JVMDebugger */
<span class="line-modified">140   public List getProcessList() throws DebuggerException {</span>
141     return null;
142   }
143 
144 
145   /** From the Debugger interface via JVMDebugger */
146   public synchronized void attach(int processID) throws DebuggerException {
147     attachInit();
148     attach0(processID);
149     attached = true;
150     isCore = false;
151   }
152 
153   /** From the Debugger interface via JVMDebugger */
154   public synchronized void attach(String executableName, String coreFileName) throws DebuggerException {
155     attachInit();
156     attach0(executableName, coreFileName);
157     attached = true;
158     isCore = true;
159   }
160 
<span class="line-modified">161   public List getLoadObjectList() {</span>
162     requireAttach();
163     return loadObjects;
164   }
165 
166   /** From the Debugger interface via JVMDebugger */
167   public synchronized boolean detach() {
168     if ( ! attached)
169        return false;
170 
171     // Close all open DLLs
172     if (nameToDllMap != null) {
173       for (Iterator iter = nameToDllMap.values().iterator(); iter.hasNext(); ) {
174         DLL dll = (DLL) iter.next();
175         dll.close();
176       }
177       nameToDllMap = null;
178       loadObjects = null;
179     }
180 
181     cdbg = null;
</pre>
<hr />
<pre>
324     long value = readAddressValue(address);
325     return (value == 0 ? null : new WindbgOopHandle(this, value));
326   }
327   public WindbgOopHandle readCompOopHandle(long address)
328     throws UnmappedAddressException, UnalignedAddressException, NotInHeapException {
329     long value = readCompOopAddressValue(address);
330     return (value == 0 ? null : new WindbgOopHandle(this, value));
331   }
332 
333   /** From the WindbgDebugger interface */
334   public int getAddressSize() {
335     return (int) machDesc.getAddressSize();
336   }
337 
338   //--------------------------------------------------------------------------------
339   // Thread context access
340   //
341 
342   private synchronized void setThreadIntegerRegisterSet(long threadId,
343                                                long[] regs) {
<span class="line-modified">344     threadIntegerRegisterSet.put(new Long(threadId), regs);</span>
345   }
346 
347   private synchronized void addThread(long sysId) {
348     threadList.add(threadFactory.createThreadWrapper(sysId));
349   }
350 
351   public synchronized long[] getThreadIntegerRegisterSet(long threadId)
352     throws DebuggerException {
353     requireAttach();
<span class="line-modified">354     return (long[]) threadIntegerRegisterSet.get(new Long(threadId));</span>
355   }
356 
<span class="line-modified">357   public synchronized List getThreadList() throws DebuggerException {</span>
358     requireAttach();
359     return threadList;
360   }
361 
362   private String findFullPath(String file) {
363     File f = new File(file);
364     if (f.exists()) {
365        return file;
366     } else {
367        // remove path part, if any.
368        file = f.getName();
369        StringTokenizer st = new StringTokenizer(imagePath, File.pathSeparator);
370        while (st.hasMoreTokens()) {
371           f = new File(st.nextToken(), file);
372           if (f.exists()) {
373              return f.getPath();
374           }
375        }
376     }
377     return null;
</pre>
<hr />
<pre>
421   // Internals only below this point
422   //
423 
424   // attach/detach helpers
425   private void checkAttached() {
426     if (attached) {
427        String msg = (isCore)? &quot;already attached to a Dr. Watson dump!&quot; :
428                               &quot;already attached to a process!&quot;;
429        throw new DebuggerException(msg);
430     }
431   }
432 
433   private void requireAttach() {
434     if (!attached) {
435        throw new RuntimeException(&quot;not attached to a process or Dr Watson dump&quot;);
436     }
437   }
438 
439   private void attachInit() {
440     checkAttached();
<span class="line-modified">441     loadObjects = new ArrayList();</span>
<span class="line-modified">442     nameToDllMap = new HashMap();</span>
<span class="line-modified">443     threadIntegerRegisterSet = new HashMap();</span>
<span class="line-modified">444     threadList = new ArrayList();</span>
445   }
446 
447   private void resetNativePointers() {
448     ptrIDebugClient          = 0L;
449     ptrIDebugControl         = 0L;
450     ptrIDebugDataSpaces      = 0L;
451     ptrIDebugOutputCallbacks = 0L;
452     ptrIDebugAdvanced        = 0L;
453     ptrIDebugSymbols         = 0L;
454     ptrIDebugSystemObjects   = 0L;
455   }
456 
457   synchronized long lookupByName(String objectName, String symbol) {
458     long res = 0L;
459     if (useNativeLookup) {
460       res = lookupByName0(objectName, symbol);
461       if (res != 0L) {
462         return res;
463       } // else fallthru...
464     }
</pre>
<hr />
<pre>
522       * are included in the standard system directory. However, the
523       * versions included in the standard system directory may not
524       * be able to handle symbol information for the newer compilers.
525       *
526       * We search for and explicitly load the libraries using the
527       * following directory search order:
528       *
529       * - java.home/bin (same as $JAVA_HOME/jre/bin)
530       * - dir named by DEBUGGINGTOOLSFORWINDOWS environment variable
531       * - various &quot;Debugging Tools For Windows&quot; program directories
532       * - the system directory ($SYSROOT/system32)
533       *
534       * If SA is invoked with -Dsun.jvm.hotspot.loadLibrary.DEBUG=1,
535       * then debug messages about library loading are printed to
536       * System.err.
537       */
538 
539     String dbgengPath   = null;
540     String dbghelpPath  = null;
541     String saprocPath = null;
<span class="line-modified">542     List   searchList   = new ArrayList();</span>
543 
544     boolean loadLibraryDEBUG =
545         System.getProperty(&quot;sun.jvm.hotspot.loadLibrary.DEBUG&quot;) != null;
546 
547     {
548       // First place to search is co-located with saproc.dll in
549       // $JAVA_HOME/jre/bin (java.home property is set to $JAVA_HOME/jre):
550       searchList.add(System.getProperty(&quot;java.home&quot;) + File.separator + &quot;bin&quot;);
551       saprocPath = (String) searchList.get(0) + File.separator +
552           &quot;saproc.dll&quot;;
553 
554       // second place to search is specified by an environment variable:
555       String DTFWHome = System.getenv(&quot;DEBUGGINGTOOLSFORWINDOWS&quot;);
556       if (DTFWHome != null) {
557         searchList.add(DTFWHome);
558       }
559 
560       // The third place to search is the install directory for the
561       // &quot;Debugging Tools For Windows&quot; package; so far there are three
562       // name variations that we know of:
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 42 /** &lt;P&gt; An implementation of the JVMDebugger interface which talks to
 43     windbg and symbol table management is done in Java. &lt;/P&gt;
 44 
 45     &lt;P&gt; &lt;B&gt;NOTE&lt;/B&gt; that since we have the notion of fetching &quot;Java
 46     primitive types&quot; from the remote process (which might have
 47     different sizes than we expect) we have a bootstrapping
 48     problem. We need to know the sizes of these types before we can
 49     fetch them. The current implementation solves this problem by
 50     requiring that it be configured with these type sizes before they
 51     can be fetched. The readJ(Type) routines here will throw a
 52     RuntimeException if they are called before the debugger is
 53     configured with the Java primitive type sizes. &lt;/P&gt; */
 54 
 55 public class WindbgDebuggerLocal extends DebuggerBase implements WindbgDebugger {
 56   private PageCache cache;
 57   private boolean   attached;
 58   private boolean   isCore;
 59 
 60   // Symbol lookup support
 61   // This is a map of library names to DLLs
<span class="line-modified"> 62   private Map&lt;String, DLL&gt; nameToDllMap;</span>
 63 
 64   // C/C++ debugging support
<span class="line-modified"> 65   private List&lt;LoadObject&gt; loadObjects;</span>
 66   private CDebugger cdbg;
 67 
 68   // thread access
<span class="line-modified"> 69   private Map&lt;Long, long[]&gt; threadIntegerRegisterSet;</span>
<span class="line-modified"> 70   private List&lt;ThreadProxy&gt; threadList;</span>
 71 
 72   // windbg native interface pointers
 73 
 74   private long ptrIDebugClient;
 75   private long ptrIDebugControl;
 76   private long ptrIDebugDataSpaces;
 77   private long ptrIDebugOutputCallbacks;
 78   private long ptrIDebugAdvanced;
 79   private long ptrIDebugSymbols;
 80   private long ptrIDebugSystemObjects;
 81 
 82   private WindbgThreadFactory threadFactory;
 83 
 84   //--------------------------------------------------------------------------------
 85   // Implementation of Debugger interface
 86   //
 87 
 88   /** &lt;P&gt; machDesc may not be null. &lt;/P&gt;
 89 
 90       &lt;P&gt; useCache should be set to true if debugging is being done
</pre>
<hr />
<pre>
120       // Fetching data over the socket connection to dbx is slow.
121       // Might be faster if we were using a binary protocol to talk to
122       // dbx, but would have to test. For now, this cache works best
123       // if it covers the entire heap of the remote process. FIXME: at
124       // least should make this tunable from the outside, i.e., via
125       // the UI. This is a cache of 4096 4K pages, or 16 MB. The page
126       // size must be adjusted to be the hardware&#39;s page size.
127       // (FIXME: should pick this up from the debugger.)
128       initCache(4096, 4096);
129     }
130     // FIXME: add instantiation of thread factory
131 
132   }
133 
134   /** From the Debugger interface via JVMDebugger */
135   public boolean hasProcessList() throws DebuggerException {
136     return false;
137   }
138 
139   /** From the Debugger interface via JVMDebugger */
<span class="line-modified">140   public List&lt;ProcessInfo&gt; getProcessList() throws DebuggerException {</span>
141     return null;
142   }
143 
144 
145   /** From the Debugger interface via JVMDebugger */
146   public synchronized void attach(int processID) throws DebuggerException {
147     attachInit();
148     attach0(processID);
149     attached = true;
150     isCore = false;
151   }
152 
153   /** From the Debugger interface via JVMDebugger */
154   public synchronized void attach(String executableName, String coreFileName) throws DebuggerException {
155     attachInit();
156     attach0(executableName, coreFileName);
157     attached = true;
158     isCore = true;
159   }
160 
<span class="line-modified">161   public List&lt;LoadObject&gt; getLoadObjectList() {</span>
162     requireAttach();
163     return loadObjects;
164   }
165 
166   /** From the Debugger interface via JVMDebugger */
167   public synchronized boolean detach() {
168     if ( ! attached)
169        return false;
170 
171     // Close all open DLLs
172     if (nameToDllMap != null) {
173       for (Iterator iter = nameToDllMap.values().iterator(); iter.hasNext(); ) {
174         DLL dll = (DLL) iter.next();
175         dll.close();
176       }
177       nameToDllMap = null;
178       loadObjects = null;
179     }
180 
181     cdbg = null;
</pre>
<hr />
<pre>
324     long value = readAddressValue(address);
325     return (value == 0 ? null : new WindbgOopHandle(this, value));
326   }
327   public WindbgOopHandle readCompOopHandle(long address)
328     throws UnmappedAddressException, UnalignedAddressException, NotInHeapException {
329     long value = readCompOopAddressValue(address);
330     return (value == 0 ? null : new WindbgOopHandle(this, value));
331   }
332 
333   /** From the WindbgDebugger interface */
334   public int getAddressSize() {
335     return (int) machDesc.getAddressSize();
336   }
337 
338   //--------------------------------------------------------------------------------
339   // Thread context access
340   //
341 
342   private synchronized void setThreadIntegerRegisterSet(long threadId,
343                                                long[] regs) {
<span class="line-modified">344     threadIntegerRegisterSet.put(threadId, regs);</span>
345   }
346 
347   private synchronized void addThread(long sysId) {
348     threadList.add(threadFactory.createThreadWrapper(sysId));
349   }
350 
351   public synchronized long[] getThreadIntegerRegisterSet(long threadId)
352     throws DebuggerException {
353     requireAttach();
<span class="line-modified">354     return (long[]) threadIntegerRegisterSet.get(threadId);</span>
355   }
356 
<span class="line-modified">357   public synchronized List&lt;ThreadProxy&gt; getThreadList() throws DebuggerException {</span>
358     requireAttach();
359     return threadList;
360   }
361 
362   private String findFullPath(String file) {
363     File f = new File(file);
364     if (f.exists()) {
365        return file;
366     } else {
367        // remove path part, if any.
368        file = f.getName();
369        StringTokenizer st = new StringTokenizer(imagePath, File.pathSeparator);
370        while (st.hasMoreTokens()) {
371           f = new File(st.nextToken(), file);
372           if (f.exists()) {
373              return f.getPath();
374           }
375        }
376     }
377     return null;
</pre>
<hr />
<pre>
421   // Internals only below this point
422   //
423 
424   // attach/detach helpers
425   private void checkAttached() {
426     if (attached) {
427        String msg = (isCore)? &quot;already attached to a Dr. Watson dump!&quot; :
428                               &quot;already attached to a process!&quot;;
429        throw new DebuggerException(msg);
430     }
431   }
432 
433   private void requireAttach() {
434     if (!attached) {
435        throw new RuntimeException(&quot;not attached to a process or Dr Watson dump&quot;);
436     }
437   }
438 
439   private void attachInit() {
440     checkAttached();
<span class="line-modified">441     loadObjects = new ArrayList&lt;&gt;();</span>
<span class="line-modified">442     nameToDllMap = new HashMap&lt;&gt;();</span>
<span class="line-modified">443     threadIntegerRegisterSet = new HashMap&lt;&gt;();</span>
<span class="line-modified">444     threadList = new ArrayList&lt;&gt;();</span>
445   }
446 
447   private void resetNativePointers() {
448     ptrIDebugClient          = 0L;
449     ptrIDebugControl         = 0L;
450     ptrIDebugDataSpaces      = 0L;
451     ptrIDebugOutputCallbacks = 0L;
452     ptrIDebugAdvanced        = 0L;
453     ptrIDebugSymbols         = 0L;
454     ptrIDebugSystemObjects   = 0L;
455   }
456 
457   synchronized long lookupByName(String objectName, String symbol) {
458     long res = 0L;
459     if (useNativeLookup) {
460       res = lookupByName0(objectName, symbol);
461       if (res != 0L) {
462         return res;
463       } // else fallthru...
464     }
</pre>
<hr />
<pre>
522       * are included in the standard system directory. However, the
523       * versions included in the standard system directory may not
524       * be able to handle symbol information for the newer compilers.
525       *
526       * We search for and explicitly load the libraries using the
527       * following directory search order:
528       *
529       * - java.home/bin (same as $JAVA_HOME/jre/bin)
530       * - dir named by DEBUGGINGTOOLSFORWINDOWS environment variable
531       * - various &quot;Debugging Tools For Windows&quot; program directories
532       * - the system directory ($SYSROOT/system32)
533       *
534       * If SA is invoked with -Dsun.jvm.hotspot.loadLibrary.DEBUG=1,
535       * then debug messages about library loading are printed to
536       * System.err.
537       */
538 
539     String dbgengPath   = null;
540     String dbghelpPath  = null;
541     String saprocPath = null;
<span class="line-modified">542     List&lt;String&gt; searchList = new ArrayList&lt;&gt;();</span>
543 
544     boolean loadLibraryDEBUG =
545         System.getProperty(&quot;sun.jvm.hotspot.loadLibrary.DEBUG&quot;) != null;
546 
547     {
548       // First place to search is co-located with saproc.dll in
549       // $JAVA_HOME/jre/bin (java.home property is set to $JAVA_HOME/jre):
550       searchList.add(System.getProperty(&quot;java.home&quot;) + File.separator + &quot;bin&quot;);
551       saprocPath = (String) searchList.get(0) + File.separator +
552           &quot;saproc.dll&quot;;
553 
554       // second place to search is specified by an environment variable:
555       String DTFWHome = System.getenv(&quot;DEBUGGINGTOOLSFORWINDOWS&quot;);
556       if (DTFWHome != null) {
557         searchList.add(DTFWHome);
558       }
559 
560       // The third place to search is the install directory for the
561       // &quot;Debugging Tools For Windows&quot; package; so far there are three
562       // name variations that we know of:
</pre>
</td>
</tr>
</table>
<center><a href="WindbgDebugger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../gc/epsilon/EpsilonHeap.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
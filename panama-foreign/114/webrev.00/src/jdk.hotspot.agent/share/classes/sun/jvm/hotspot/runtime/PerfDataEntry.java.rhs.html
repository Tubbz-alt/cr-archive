<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/PerfDataEntry.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.runtime;
 26 
 27 import java.nio.charset.StandardCharsets;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.oops.*;
 31 import sun.jvm.hotspot.types.*;
 32 import sun.jvm.hotspot.utilities.*;
<a name="2" id="anc2"></a><span class="line-added"> 33 import sun.jvm.hotspot.utilities.Observable;</span>
<span class="line-added"> 34 import sun.jvm.hotspot.utilities.Observer;</span>
 35 
 36 public class PerfDataEntry extends VMObject {
 37     private static JIntField  entryLengthField;
 38     private static JIntField  nameOffsetField;
 39     private static JIntField  vectorLengthField;
 40     private static JByteField dataTypeField;
 41     private static JByteField flagsField;
 42     private static JByteField dataUnitsField;
 43     private static JByteField dataVariabilityField;
 44     private static JIntField  dataOffsetField;
 45 
 46     static {
 47         VM.registerVMInitializedObserver(new Observer() {
 48                 public void update(Observable o, Object data) {
 49                     initialize(VM.getVM().getTypeDataBase());
 50                 }
 51             });
 52     }
 53 
 54     private static synchronized void initialize(TypeDataBase db) {
 55         Type type = db.lookupType(&quot;PerfDataEntry&quot;);
 56         entryLengthField = type.getJIntField(&quot;entry_length&quot;);
 57         nameOffsetField = type.getJIntField(&quot;name_offset&quot;);
 58         vectorLengthField = type.getJIntField(&quot;vector_length&quot;);
 59         dataTypeField = type.getJByteField(&quot;data_type&quot;);
 60         flagsField = type.getJByteField(&quot;flags&quot;);
 61         dataUnitsField = type.getJByteField(&quot;data_units&quot;);
 62         dataVariabilityField = type.getJByteField(&quot;data_variability&quot;);
 63         dataOffsetField = type.getJIntField(&quot;data_offset&quot;);
 64     }
 65 
 66     public PerfDataEntry(Address addr) {
 67         super(addr);
 68     }
 69 
 70     // Accessors
 71 
 72     public int entryLength() {
 73         return (int) entryLengthField.getValue(addr);
 74     }
 75 
 76     public int nameOffset() {
 77         return (int) nameOffsetField.getValue(addr);
 78     }
 79 
 80     public int vectorLength() {
 81         return (int) vectorLengthField.getValue(addr);
 82     }
 83 
 84     // returns one of the constants in BasicType class
 85     public int dataType() {
 86         char ch = (char) (byte) dataTypeField.getValue(addr);
 87         return BasicType.charToType(ch);
 88     }
 89 
 90     public byte flags() {
 91         return (byte) flagsField.getValue(addr);
 92     }
 93 
 94     public boolean supported() {
 95         return (flags() &amp; 0x1) != 0;
 96     }
 97 
 98     private static class PerfDataUnits {
 99         public static int U_None;
100         public static int U_Bytes;
101         public static int U_Ticks;
102         public static int U_Events;
103         public static int U_String;
104         public static int U_Hertz;
105 
106         static {
107             VM.registerVMInitializedObserver(new Observer() {
108                 public void update(Observable o, Object data) {
109                     initialize(VM.getVM().getTypeDataBase());
110                 }
111             });
112         }
113         private static synchronized void initialize(TypeDataBase db) {
114             U_None = db.lookupIntConstant(&quot;PerfData::U_None&quot;);
115             U_Bytes = db.lookupIntConstant(&quot;PerfData::U_Bytes&quot;);
116             U_Ticks = db.lookupIntConstant(&quot;PerfData::U_Ticks&quot;);
117             U_Events = db.lookupIntConstant(&quot;PerfData::U_Events&quot;);
118             U_String = db.lookupIntConstant(&quot;PerfData::U_String&quot;);
119             U_Hertz = db.lookupIntConstant(&quot;PerfData::U_Hertz&quot;);
120         }
121     }
122 
123     // returns one of the constants in PerfDataUnits
124     public int dataUnits() {
125         return (int) dataUnitsField.getValue(addr);
126     }
127 
128     // returns one of the constants in PerfDataVariability
129     public int dataVariability() {
130         return (int) dataVariabilityField.getValue(addr);
131     }
132 
133     public int dataOffset() {
134         return (int) dataOffsetField.getValue(addr);
135     }
136 
137     public String name() {
138         int off = nameOffset();
139         return CStringUtilities.getString(addr.addOffsetTo(off));
140     }
141 
142     public boolean booleanValue() {
143         if (Assert.ASSERTS_ENABLED) {
144             Assert.that(vectorLength() == 0 &amp;&amp;
145                         dataType() == BasicType.getTBoolean(), &quot;not a boolean&quot;);
146         }
147         return addr.getJBooleanAt(dataOffset());
148     }
149 
150     public char charValue() {
151         if (Assert.ASSERTS_ENABLED) {
152             Assert.that(vectorLength() == 0 &amp;&amp;
153                         dataType() == BasicType.getTChar(), &quot;not a char&quot;);
154         }
155         return addr.getJCharAt(dataOffset());
156     }
157 
158     public byte byteValue() {
159         if (Assert.ASSERTS_ENABLED) {
160             Assert.that(vectorLength() == 0 &amp;&amp;
161                         dataType() == BasicType.getTByte(), &quot;not a byte&quot;);
162         }
163         return addr.getJByteAt(dataOffset());
164 
165     }
166 
167     public short shortValue() {
168         if (Assert.ASSERTS_ENABLED) {
169             Assert.that(vectorLength() == 0 &amp;&amp;
170                         dataType() == BasicType.getTShort(), &quot;not a short&quot;);
171         }
172         return addr.getJShortAt(dataOffset());
173     }
174 
175     public int intValue() {
176         if (Assert.ASSERTS_ENABLED) {
177             Assert.that(vectorLength() == 0 &amp;&amp;
178                         dataType() == BasicType.getTInt(), &quot;not an int&quot;);
179         }
180         return addr.getJIntAt(dataOffset());
181     }
182 
183     public long longValue() {
184         if (Assert.ASSERTS_ENABLED) {
185             Assert.that(vectorLength() == 0 &amp;&amp;
186                         dataType() == BasicType.getTLong(), &quot;not a long&quot;);
187         }
188         return addr.getJLongAt(dataOffset());
189     }
190 
191     public float floatValue() {
192         if (Assert.ASSERTS_ENABLED) {
193             Assert.that(vectorLength() == 0 &amp;&amp;
194                         dataType() == BasicType.getTFloat(), &quot;not a float&quot;);
195         }
196         return addr.getJFloatAt(dataOffset());
197     }
198 
199     public double doubleValue() {
200         if (Assert.ASSERTS_ENABLED) {
201             Assert.that(vectorLength() == 0 &amp;&amp;
202                         dataType() == BasicType.getTDouble(), &quot;not a double&quot;);
203         }
204         return addr.getJDoubleAt(dataOffset());
205     }
206 
207     public boolean[] booleanArrayValue() {
208         int len = vectorLength();
209         if (Assert.ASSERTS_ENABLED) {
210             Assert.that(len &gt; 0 &amp;&amp;
211                         dataType() == BasicType.getTBoolean(), &quot;not a boolean vector&quot;);
212         }
213         boolean[] res = new boolean[len];
214         final int off = dataOffset();
215         final long size =  getHeap().getBooleanSize();
216         for (int i = 0; i &lt; len; i++) {
217             res[i] = addr.getJBooleanAt(off + i * size);
218         }
219         return res;
220     }
221 
222     public char[] charArrayValue() {
223         int len = vectorLength();
224         if (Assert.ASSERTS_ENABLED) {
225             Assert.that(len &gt; 0 &amp;&amp;
226                         dataType() == BasicType.getTChar(), &quot;not a char vector&quot;);
227         }
228         char[] res = new char[len];
229         final int off = dataOffset();
230         final long size = getHeap().getCharSize();
231         for (int i = 0; i &lt; len; i++) {
232             res[i] = addr.getJCharAt(off + i * size);
233         }
234         return res;
235     }
236 
237     public byte[] byteArrayValue() {
238         int len = vectorLength();
239         if (Assert.ASSERTS_ENABLED) {
240             Assert.that(len &gt; 0 &amp;&amp;
241                         dataType() == BasicType.getTByte(), &quot;not a byte vector&quot;);
242         }
243         byte[] res = new byte[len];
244         final int off = dataOffset();
245         final long size = getHeap().getByteSize();
246         for (int i = 0; i &lt; len; i++) {
247             res[i] = addr.getJByteAt(off + i * size);
248         }
249         return res;
250     }
251 
252     public short[] shortArrayValue() {
253         int len = vectorLength();
254         if (Assert.ASSERTS_ENABLED) {
255             Assert.that(len &gt; 0 &amp;&amp;
256                         dataType() == BasicType.getTShort(), &quot;not a short vector&quot;);
257         }
258         short[] res = new short[len];
259         final int off = dataOffset();
260         final long size = getHeap().getShortSize();
261         for (int i = 0; i &lt; len; i++) {
262             res[i] = addr.getJShortAt(off + i * size);
263         }
264         return res;
265     }
266 
267     public int[] intArrayValue() {
268         int len = vectorLength();
269         if (Assert.ASSERTS_ENABLED) {
270             Assert.that(len &gt; 0 &amp;&amp;
271                         dataType() == BasicType.getTInt(), &quot;not an int vector&quot;);
272         }
273         int[] res = new int[len];
274         final int off = dataOffset();
275         final long size = getHeap().getIntSize();
276         for (int i = 0; i &lt; len; i++) {
277             res[i] = addr.getJIntAt(off + i * size);
278         }
279         return res;
280     }
281 
282     public long[] longArrayValue() {
283         int len = vectorLength();
284         if (Assert.ASSERTS_ENABLED) {
285             Assert.that(len &gt; 0 &amp;&amp;
286                         dataType() == BasicType.getTLong(), &quot;not a long vector&quot;);
287         }
288         long[] res = new long[len];
289         final int off = dataOffset();
290         final long size = getHeap().getLongSize();
291         for (int i = 0; i &lt; len; i++) {
292             res[i] = addr.getJLongAt(off + i * size);
293         }
294         return res;
295     }
296 
297     public float[] floatArrayValue() {
298         int len = vectorLength();
299         if (Assert.ASSERTS_ENABLED) {
300             Assert.that(len &gt; 0 &amp;&amp;
301                         dataType() == BasicType.getTFloat(), &quot;not a float vector&quot;);
302         }
303         float[] res = new float[len];
304         final int off = dataOffset();
305         final long size = getHeap().getFloatSize();
306         for (int i = 0; i &lt; len; i++) {
307             res[i] = addr.getJFloatAt(off + i * size);
308         }
309         return res;
310     }
311 
312     public double[] doubleArrayValue() {
313         int len = vectorLength();
314         if (Assert.ASSERTS_ENABLED) {
315             Assert.that(len &gt; 0 &amp;&amp;
316                         dataType() == BasicType.getTDouble(), &quot;not a double vector&quot;);
317         }
318         double[] res = new double[len];
319         final int off = dataOffset();
320         final long size = getHeap().getDoubleSize();
321         for (int i = 0; i &lt; len; i++) {
322             res[i] = addr.getJDoubleAt(off + i * size);
323         }
324         return res;
325     }
326 
327     // value as String
328     public String valueAsString() {
329         int dataType = dataType();
330         int len = vectorLength();
331         String str = null;
332         if (len == 0) { // scalar
333             if (dataType == BasicType.getTBoolean()) {
334                 str = Boolean.toString(booleanValue());
335             } else if (dataType == BasicType.getTChar()) {
336                 str = &quot;&#39;&quot; + Character.toString(charValue()) + &quot;&#39;&quot;;
337             } else if (dataType == BasicType.getTByte()) {
338                 str = Byte.toString(byteValue());
339             } else if (dataType == BasicType.getTShort()) {
340                 str = Short.toString(shortValue());
341             } else if (dataType ==  BasicType.getTInt()) {
342                 str = Integer.toString(intValue());
343             } else if (dataType == BasicType.getTLong()) {
344                 str = Long.toString(longValue());
345             } else if (dataType == BasicType.getTFloat()) {
346                 str = Float.toString(floatValue());
347             } else if (dataType == BasicType.getTDouble()) {
348                 str = Double.toString(doubleValue());
349             } else {
350                 str = &quot;&lt;unknown scalar value&gt;&quot;;
351             }
352         } else { // vector
353             if (dataType == BasicType.getTBoolean()) {
354                 boolean[] res = booleanArrayValue();
355                 StringBuffer buf = new StringBuffer();
356                 buf.append(&#39;[&#39;);
357                 for (int i = 0; i &lt; res.length; i++) {
358                     buf.append(Boolean.toString(res[i]));
359                     buf.append(&quot;, &quot;);
360                 }
361                 buf.append(&#39;]&#39;);
362                 str = buf.toString();
363             } else if (dataType == BasicType.getTChar()) {
364                 // char[] is returned as a String
365                 str = new String(charArrayValue());
366             } else if (dataType == BasicType.getTByte()) {
367                 // byte[] is returned as a String
368                 str = CStringUtilities.getString(addr.addOffsetTo(dataOffset()),
369                                                  StandardCharsets.US_ASCII);
370             } else if (dataType == BasicType.getTShort()) {
371                 short[] res = shortArrayValue();
372                 StringBuffer buf = new StringBuffer();
373                 buf.append(&#39;[&#39;);
374                 for (int i = 0; i &lt; res.length; i++) {
375                     buf.append(Short.toString(res[i]));
376                     buf.append(&quot;, &quot;);
377                 }
378                 buf.append(&#39;]&#39;);
379                 str = buf.toString();
380             } else if (dataType ==  BasicType.getTInt()) {
381                 int[] res = intArrayValue();
382                 StringBuffer buf = new StringBuffer();
383                 buf.append(&#39;[&#39;);
384                 for (int i = 0; i &lt; res.length; i++) {
385                     buf.append(Integer.toString(res[i]));
386                     buf.append(&quot;, &quot;);
387                 }
388                 buf.append(&#39;]&#39;);
389                 str = buf.toString();
390             } else if (dataType == BasicType.getTLong()) {
391                 long[] res = longArrayValue();
392                 StringBuffer buf = new StringBuffer();
393                 buf.append(&#39;[&#39;);
394                 for (int i = 0; i &lt; res.length; i++) {
395                     buf.append(Long.toString(res[i]));
396                     buf.append(&quot;, &quot;);
397                 }
398                 buf.append(&#39;]&#39;);
399                 str = buf.toString();
400             } else if (dataType == BasicType.getTFloat()) {
401                 float[] res = floatArrayValue();
402                 StringBuffer buf = new StringBuffer();
403                 buf.append(&#39;[&#39;);
404                 for (int i = 0; i &lt; res.length; i++) {
405                     buf.append(Float.toString(res[i]));
406                     buf.append(&quot;, &quot;);
407                 }
408                 buf.append(&#39;]&#39;);
409                 str = buf.toString();
410             } else if (dataType == BasicType.getTDouble()) {
411                 double[] res = doubleArrayValue();
412                 StringBuffer buf = new StringBuffer();
413                 buf.append(&#39;[&#39;);
414                 for (int i = 0; i &lt; res.length; i++) {
415                     buf.append(Double.toString(res[i]));
416                     buf.append(&quot;, &quot;);
417                 }
418                 buf.append(&#39;]&#39;);
419                 str = buf.toString();
420             } else {
421                 str = &quot;&lt;unknown vector value&gt;&quot;;
422             }
423         }
424 
425         // add units
426         int dataUnitsValue = dataUnits();
427 
428         if (dataUnitsValue == PerfDataUnits.U_Bytes) {
429             str += &quot; byte(s)&quot;;
430         } else if (dataUnitsValue == PerfDataUnits.U_Ticks) {
431             str += &quot; tick(s)&quot;;
432         } else if (dataUnitsValue == PerfDataUnits.U_Events) {
433             str += &quot; event(s)&quot;;
434         } else if (dataUnitsValue == PerfDataUnits.U_Hertz) {
435             str += &quot; Hz&quot;;
436         }
437 
438         return str;
439     }
440 
441     // -- Internals only below this point
442     private ObjectHeap getHeap() {
443         return VM.getVM().getObjectHeap();
444     }
445 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
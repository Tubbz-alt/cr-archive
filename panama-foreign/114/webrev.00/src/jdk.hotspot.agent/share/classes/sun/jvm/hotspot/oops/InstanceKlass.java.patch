diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/InstanceKlass.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/InstanceKlass.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/InstanceKlass.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/InstanceKlass.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -31,10 +31,12 @@
 import sun.jvm.hotspot.memory.*;
 import sun.jvm.hotspot.memory.Dictionary;
 import sun.jvm.hotspot.runtime.*;
 import sun.jvm.hotspot.types.*;
 import sun.jvm.hotspot.utilities.*;
+import sun.jvm.hotspot.utilities.Observable;
+import sun.jvm.hotspot.utilities.Observer;
 
 // An InstanceKlass is the VM level representation of a Java class.
 
 public class InstanceKlass extends Klass {
   static {
@@ -680,18 +682,18 @@
   }
 
   public Field[] getStaticFields() {
     U2Array fields = getFields();
     int length = getJavaFieldsCount();
-    ArrayList result = new ArrayList();
+    ArrayList<Field> result = new ArrayList<>();
     for (int index = 0; index < length; index++) {
       Field f = newField(index);
       if (f.isStatic()) {
         result.add(f);
       }
     }
-    return (Field[])result.toArray(new Field[result.size()]);
+    return result.toArray(new Field[result.size()]);
   }
 
   public void iterateNonStaticFields(OopVisitor visitor, Oop obj) {
     if (getSuper() != null) {
       ((InstanceKlass) getSuper()).iterateNonStaticFields(visitor, obj);
@@ -782,15 +784,15 @@
 
     /** Return a List of SA Fields for the fields declared in this class.
         Inherited fields are not included.
         Return an empty list if there are no fields declared in this class.
         Only designed for use in a debugging system. */
-    public List getImmediateFields() {
+    public List<Field> getImmediateFields() {
         // A list of Fields for each field declared in this class/interface,
         // not including inherited fields.
         int length = getJavaFieldsCount();
-        List immediateFields = new ArrayList(length);
+        List<Field> immediateFields = new ArrayList<>(length);
         for (int index = 0; index < length; index++) {
             immediateFields.add(getFieldByIndex(index));
         }
 
         return immediateFields;
@@ -800,14 +802,14 @@
         including all inherited fields.  This includes hidden
         fields.  Thus the returned list can contain fields with
         the same name.
         Return an empty list if there are no fields.
         Only designed for use in a debugging system. */
-    public List getAllFields() {
+    public List<Field> getAllFields() {
         // Contains a Field for each field in this class, including immediate
         // fields and inherited fields.
-        List  allFields = getImmediateFields();
+        List<Field> allFields = getImmediateFields();
 
         // transitiveInterfaces contains all interfaces implemented
         // by this class and its superclass chain with no duplicates.
 
         KlassArray interfaces = getTransitiveInterfaces();
@@ -836,17 +838,17 @@
 
     /** Return a List of SA Methods declared directly in this class/interface.
         Return an empty list if there are none, or if this isn't a class/
         interface.
     */
-    public List getImmediateMethods() {
+    public List<Method> getImmediateMethods() {
       // Contains a Method for each method declared in this class/interface
       // not including inherited methods.
 
       MethodArray methods = getMethods();
       int length = methods.length();
-      Object[] tmp = new Object[length];
+      Method[] tmp = new Method[length];
 
       IntArray methodOrdering = getMethodOrdering();
       if (methodOrdering.length() != length) {
          // no ordering info present
          for (int index = 0; index < length; index++) {
@@ -863,17 +865,17 @@
     }
 
     /** Return a List containing an SA InstanceKlass for each
         interface named in this class's 'implements' clause.
     */
-    public List getDirectImplementedInterfaces() {
+    public List<Klass> getDirectImplementedInterfaces() {
         // Contains an InstanceKlass for each interface in this classes
         // 'implements' clause.
 
         KlassArray interfaces = getLocalInterfaces();
         int length = interfaces.length();
-        List directImplementedInterfaces = new ArrayList(length);
+        List<Klass> directImplementedInterfaces = new ArrayList<>(length);
 
         for (int index = 0; index < length; index ++) {
             directImplementedInterfaces.add(interfaces.getAt(index));
         }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/code/StubQueue.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.code;
 26 
 27 import java.util.*;
 28 import sun.jvm.hotspot.debugger.*;
 29 import sun.jvm.hotspot.runtime.*;
 30 import sun.jvm.hotspot.types.*;
 31 import sun.jvm.hotspot.utilities.*;
<a name="2" id="anc2"></a><span class="line-added"> 32 import sun.jvm.hotspot.utilities.Observable;</span>
<span class="line-added"> 33 import sun.jvm.hotspot.utilities.Observer;</span>
 34 
 35 /** &lt;P&gt; A port of the VM&#39;s StubQueue. Note that the VM implicitly
 36     knows the type of the objects contained in each StubQueue because
 37     it passes in an instance of a StubInterface to the StubQueue&#39;s
 38     constructor; the goal in the VM was to save space in the generated
 39     code. In the SA APIs the pattern has been to use the
 40     VirtualConstructor mechanism to instantiate wrapper objects of the
 41     appropriate type for objects down in the VM; see, for example, the
 42     CodeCache, which identifies NMethods, RuntimeStubs, etc. &lt;/P&gt;
 43 
 44     &lt;P&gt; In this port we eliminate the StubInterface in favor of
 45     passing in the class corresponding to the type of Stub which this
 46     StubQueue contains. &lt;/P&gt; */
 47 
 48 public class StubQueue extends VMObject {
 49   // FIXME: add the rest of the fields
 50   private static AddressField  stubBufferField;
 51   private static CIntegerField bufferLimitField;
 52   private static CIntegerField queueBeginField;
 53   private static CIntegerField queueEndField;
 54   private static CIntegerField numberOfStubsField;
 55 
 56   // The type of the contained stubs (i.e., InterpreterCodelet,
 57   // ICStub). Must be a subclass of type Stub.
<a name="3" id="anc3"></a><span class="line-modified"> 58   private Class&lt;?&gt; stubType;</span>
 59 
 60   static {
 61     VM.registerVMInitializedObserver(new Observer() {
 62         public void update(Observable o, Object data) {
 63           initialize(VM.getVM().getTypeDataBase());
 64         }
 65       });
 66   }
 67 
 68   private static synchronized void initialize(TypeDataBase db) {
 69     Type type = db.lookupType(&quot;StubQueue&quot;);
 70 
 71     stubBufferField    = type.getAddressField(&quot;_stub_buffer&quot;);
 72     bufferLimitField   = type.getCIntegerField(&quot;_buffer_limit&quot;);
 73     queueBeginField    = type.getCIntegerField(&quot;_queue_begin&quot;);
 74     queueEndField      = type.getCIntegerField(&quot;_queue_end&quot;);
 75     numberOfStubsField = type.getCIntegerField(&quot;_number_of_stubs&quot;);
 76   }
 77 
 78   public StubQueue(Address addr, Class stubType) {
 79     super(addr);
 80     this.stubType = stubType;
 81   }
 82 
 83   public boolean contains(Address pc) {
 84     if (pc == null) return false;
 85     long offset = pc.minus(getStubBuffer());
 86     return ((0 &lt;= offset) &amp;&amp; (offset &lt; getBufferLimit()));
 87   }
 88 
 89   public Stub getStubContaining(Address pc) {
 90     if (contains(pc)) {
 91       int i = 0;
 92       for (Stub s = getFirst(); s != null; s = getNext(s)) {
 93         if (stubContains(s, pc)) {
 94           return s;
 95         }
 96       }
 97     }
 98     return null;
 99   }
100 
101   public boolean stubContains(Stub s, Address pc) {
102     return (s.codeBegin().lessThanOrEqual(pc) &amp;&amp; s.codeEnd().greaterThan(pc));
103   }
104 
105   public int getNumberOfStubs() {
106     return (int) numberOfStubsField.getValue(addr);
107   }
108 
109   public Stub getFirst() {
110     return ((getNumberOfStubs() &gt; 0) ? getStubAt(getQueueBegin()) : null);
111   }
112 
113   public Stub getNext(Stub s) {
114     long i = getIndexOf(s) + getStubSize(s);
115     if (i == getBufferLimit()) {
116       i = 0;
117     }
118     return ((i == getQueueEnd()) ? null : getStubAt(i));
119   }
120 
121   public Stub getPrev(Stub s) {
122     if (getIndexOf(s) == getQueueBegin()) {
123        return null;
124     }
125 
126     Stub temp = getFirst();
127     Stub prev = null;
128     while (temp != null &amp;&amp; getIndexOf(temp) != getIndexOf(s)) {
129        prev = temp;
130        temp  = getNext(temp);
131     }
132 
133     return prev;
134   }
135 
136   //--------------------------------------------------------------------------------
137   // Internals only below this point
138   //
139 
140   private long getQueueBegin() {
141     return queueBeginField.getValue(addr);
142   }
143 
144   private long getQueueEnd() {
145     return queueEndField.getValue(addr);
146   }
147 
148   private long getBufferLimit() {
149     return bufferLimitField.getValue(addr);
150   }
151 
152   private Address getStubBuffer() {
153     return stubBufferField.getValue(addr);
154   }
155 
156   private Stub getStubAt(long offset) {
157     checkIndex(offset);
158     return (Stub) VMObjectFactory.newObject(stubType, getStubBuffer().addOffsetTo(offset));
159   }
160 
161   private long getIndexOf(Stub s) {
162     long i = s.getAddress().minus(getStubBuffer());
163     checkIndex(i);
164     return i;
165   }
166 
167   private long getStubSize(Stub s) {
168     return s.getSize();
169   }
170 
171   private void checkIndex(long i) {
172     if (Assert.ASSERTS_ENABLED) {
173       Assert.that(0 &lt;= i &amp;&amp; i &lt; getBufferLimit() &amp;&amp; (i % VM.getVM().getAddressSize() == 0), &quot;illegal index&quot;);
174     }
175   }
176 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
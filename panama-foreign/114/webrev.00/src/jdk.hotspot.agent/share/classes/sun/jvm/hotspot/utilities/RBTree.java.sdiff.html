<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/RBTree.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ObjectReader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReversePtrs.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/RBTree.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 40 
 41     &lt;P&gt; An RBTree takes a Comparator as argument to its constructor
 42     which is used internally to order the nodes in the tree. The
 43     comparator&#39;s arguments are obtained by calling the routine
 44     &quot;getNodeData&quot; on two nodes; the default implementaion returns the
 45     node data. This Comparator is also used to perform the generic
 46     &quot;find&quot; operation, which returns the RBNode containing user data
 47     precisely equalling the query data. Different types of user data
 48     will typically require different types of traversals as well as
 49     additional comparison operations; these are left to the RBTree
 50     subclass. &lt;/P&gt;
 51 
 52 */
 53 
 54 import java.io.PrintStream;
 55 import java.util.Comparator;
 56 import java.util.Random;
 57 
 58 public class RBTree {
 59   private RBNode root;
<span class="line-modified"> 60   private Comparator comparator;</span>
 61   protected static final boolean DEBUGGING = true;
 62   protected static final boolean VERBOSE   = true;
 63   protected static final boolean REALLY_VERBOSE = false;
 64 
<span class="line-modified"> 65   public RBTree(Comparator comparator) {</span>
 66     this.comparator = comparator;
 67   }
 68 
 69   public RBNode getRoot() {
 70     return root;
 71   }
 72 
 73   public void insertNode(RBNode x) {
 74     treeInsert(x);
 75 
 76     x.setColor(RBColor.RED);
 77     boolean shouldPropagate = x.update();
 78 
 79     if (DEBUGGING &amp;&amp; REALLY_VERBOSE) {
 80       System.err.println(&quot;RBTree.insertNode&quot;);
 81     }
 82 
 83     RBNode propagateStart = x;
 84 
 85     // Loop invariant: x has been updated.
</pre>
<hr />
<pre>
517     tty.print(&quot;-&quot;);
518     if (node == null) {
519       tty.println();
520       return;
521     }
522 
523     tty.println(&quot; &quot; + getNodeValue(node) +
524                 ((node.getColor() == RBColor.RED) ? &quot; (red)&quot; : &quot; (black)&quot;));
525     printFromNode(node.getLeft(), tty, indentDepth + 2);
526     printFromNode(node.getRight(), tty, indentDepth + 2);
527   }
528 
529   //----------------------------------------------------------------------
530   // Test harness
531   //
532 
533   public static void main(String[] args) {
534     int treeSize = 10000;
535     int maxVal = treeSize;
536     System.err.println(&quot;Building tree...&quot;);
<span class="line-modified">537     RBTree tree = new RBTree(new Comparator() {</span>
538         public int compare(Object o1, Object o2) {
539           Integer i1 = (Integer) o1;
540           Integer i2 = (Integer) o2;
541           if (i1.intValue() &lt; i2.intValue()) {
542             return -1;
543           } else if (i1.intValue() == i2.intValue()) {
544             return 0;
545           }
546           return 1;
547         }
548       });
549     Random rand = new Random(System.currentTimeMillis());
550     for (int i = 0; i &lt; treeSize; i++) {
<span class="line-modified">551       Integer val = new Integer(rand.nextInt(maxVal) + 1);</span>
552       try {
553         tree.insertNode(new RBNode(val));
554         if ((i &gt; 0) &amp;&amp; (i % 100 == 0)) {
555           System.err.print(i + &quot;...&quot;);
556           System.err.flush();
557         }
558       }
559       catch (Exception e) {
560         e.printStackTrace();
561         System.err.println(&quot;While inserting value &quot; + val);
562         tree.printOn(System.err);
563         System.exit(1);
564       }
565     }
566     // Now churn data in tree by deleting and inserting lots of nodes
567     System.err.println();
568     System.err.println(&quot;Churning tree...&quot;);
569     for (int i = 0; i &lt; treeSize; i++) {
570       if (DEBUGGING &amp;&amp; VERBOSE) {
571         System.err.println(&quot;Iteration &quot; + i + &quot;:&quot;);
</pre>
<hr />
<pre>
588       }
589       // Pick a random height at which to remove value
590       int height = rand.nextInt(depth);
591       if (DEBUGGING) {
592         if (height &gt;= depth) {
593           throw new RuntimeException(&quot;bug in java.util.Random&quot;);
594         }
595       }
596       // Walk that far back up (FIXME: off by one?)
597       while (height &gt; 0) {
598         xParent = xParent.getParent();
599         --height;
600       }
601       // Tell the tree to remove this node
602       if (DEBUGGING &amp;&amp; VERBOSE) {
603         System.err.println(&quot;(Removing value &quot; + tree.getNodeValue(xParent) + &quot;)&quot;);
604       }
605       tree.deleteNode(xParent);
606 
607       // Now create and insert a new value
<span class="line-modified">608       Integer newVal = new Integer(rand.nextInt(maxVal) + 1);</span>
609       if (DEBUGGING &amp;&amp; VERBOSE) {
610         System.err.println(&quot;(Inserting value &quot; + newVal + &quot;)&quot;);
611       }
612       tree.insertNode(new RBNode(newVal));
613     }
614     System.err.println(&quot;All tests passed.&quot;);
615   }
616 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 40 
 41     &lt;P&gt; An RBTree takes a Comparator as argument to its constructor
 42     which is used internally to order the nodes in the tree. The
 43     comparator&#39;s arguments are obtained by calling the routine
 44     &quot;getNodeData&quot; on two nodes; the default implementaion returns the
 45     node data. This Comparator is also used to perform the generic
 46     &quot;find&quot; operation, which returns the RBNode containing user data
 47     precisely equalling the query data. Different types of user data
 48     will typically require different types of traversals as well as
 49     additional comparison operations; these are left to the RBTree
 50     subclass. &lt;/P&gt;
 51 
 52 */
 53 
 54 import java.io.PrintStream;
 55 import java.util.Comparator;
 56 import java.util.Random;
 57 
 58 public class RBTree {
 59   private RBNode root;
<span class="line-modified"> 60   private Comparator&lt;Object&gt; comparator;</span>
 61   protected static final boolean DEBUGGING = true;
 62   protected static final boolean VERBOSE   = true;
 63   protected static final boolean REALLY_VERBOSE = false;
 64 
<span class="line-modified"> 65   public RBTree(Comparator&lt;Object&gt; comparator) {</span>
 66     this.comparator = comparator;
 67   }
 68 
 69   public RBNode getRoot() {
 70     return root;
 71   }
 72 
 73   public void insertNode(RBNode x) {
 74     treeInsert(x);
 75 
 76     x.setColor(RBColor.RED);
 77     boolean shouldPropagate = x.update();
 78 
 79     if (DEBUGGING &amp;&amp; REALLY_VERBOSE) {
 80       System.err.println(&quot;RBTree.insertNode&quot;);
 81     }
 82 
 83     RBNode propagateStart = x;
 84 
 85     // Loop invariant: x has been updated.
</pre>
<hr />
<pre>
517     tty.print(&quot;-&quot;);
518     if (node == null) {
519       tty.println();
520       return;
521     }
522 
523     tty.println(&quot; &quot; + getNodeValue(node) +
524                 ((node.getColor() == RBColor.RED) ? &quot; (red)&quot; : &quot; (black)&quot;));
525     printFromNode(node.getLeft(), tty, indentDepth + 2);
526     printFromNode(node.getRight(), tty, indentDepth + 2);
527   }
528 
529   //----------------------------------------------------------------------
530   // Test harness
531   //
532 
533   public static void main(String[] args) {
534     int treeSize = 10000;
535     int maxVal = treeSize;
536     System.err.println(&quot;Building tree...&quot;);
<span class="line-modified">537     RBTree tree = new RBTree(new Comparator&lt;&gt;() {</span>
538         public int compare(Object o1, Object o2) {
539           Integer i1 = (Integer) o1;
540           Integer i2 = (Integer) o2;
541           if (i1.intValue() &lt; i2.intValue()) {
542             return -1;
543           } else if (i1.intValue() == i2.intValue()) {
544             return 0;
545           }
546           return 1;
547         }
548       });
549     Random rand = new Random(System.currentTimeMillis());
550     for (int i = 0; i &lt; treeSize; i++) {
<span class="line-modified">551       Integer val = rand.nextInt(maxVal) + 1;</span>
552       try {
553         tree.insertNode(new RBNode(val));
554         if ((i &gt; 0) &amp;&amp; (i % 100 == 0)) {
555           System.err.print(i + &quot;...&quot;);
556           System.err.flush();
557         }
558       }
559       catch (Exception e) {
560         e.printStackTrace();
561         System.err.println(&quot;While inserting value &quot; + val);
562         tree.printOn(System.err);
563         System.exit(1);
564       }
565     }
566     // Now churn data in tree by deleting and inserting lots of nodes
567     System.err.println();
568     System.err.println(&quot;Churning tree...&quot;);
569     for (int i = 0; i &lt; treeSize; i++) {
570       if (DEBUGGING &amp;&amp; VERBOSE) {
571         System.err.println(&quot;Iteration &quot; + i + &quot;:&quot;);
</pre>
<hr />
<pre>
588       }
589       // Pick a random height at which to remove value
590       int height = rand.nextInt(depth);
591       if (DEBUGGING) {
592         if (height &gt;= depth) {
593           throw new RuntimeException(&quot;bug in java.util.Random&quot;);
594         }
595       }
596       // Walk that far back up (FIXME: off by one?)
597       while (height &gt; 0) {
598         xParent = xParent.getParent();
599         --height;
600       }
601       // Tell the tree to remove this node
602       if (DEBUGGING &amp;&amp; VERBOSE) {
603         System.err.println(&quot;(Removing value &quot; + tree.getNodeValue(xParent) + &quot;)&quot;);
604       }
605       tree.deleteNode(xParent);
606 
607       // Now create and insert a new value
<span class="line-modified">608       Integer newVal = rand.nextInt(maxVal) + 1;</span>
609       if (DEBUGGING &amp;&amp; VERBOSE) {
610         System.err.println(&quot;(Inserting value &quot; + newVal + &quot;)&quot;);
611       }
612       tree.insertNode(new RBNode(newVal));
613     }
614     System.err.println(&quot;All tests passed.&quot;);
615   }
616 }
</pre>
</td>
</tr>
</table>
<center><a href="ObjectReader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReversePtrs.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/IntervalTree.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/IntervalTree.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/IntervalTree.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/IntervalTree.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -30,16 +30,16 @@
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.List;
 
 public class IntervalTree extends RBTree {
-  private Comparator endpointComparator;
+  private Comparator<Object> endpointComparator;
 
   /** This constructor takes only one comparator: one which operates
       upon the endpoints of the Intervals this tree will store. It
       constructs an internal "interval comparator" out of this one. */
-  public IntervalTree(Comparator endpointComparator) {
+  public IntervalTree(Comparator<Object> endpointComparator) {
     super(new IntervalComparator(endpointComparator));
     this.endpointComparator = endpointComparator;
   }
 
   public void insert(Interval interval, Object data) {
@@ -49,12 +49,12 @@
 
   /** Returns a List&lt;IntervalNode&gt; indicating which nodes'
       intervals were intersected by the given query interval. It is
       guaranteed that these nodes will be returned sorted by
       increasing low endpoint. */
-  public List findAllNodesIntersecting(Interval interval) {
-    List retList = new ArrayList();
+  public List<IntervalNode> findAllNodesIntersecting(Interval interval) {
+    List<IntervalNode> retList = new ArrayList<>();
     searchForIntersectingNodesFrom((IntervalNode) getRoot(), interval, retList);
     return retList;
   }
 
   public void print() {
@@ -106,14 +106,14 @@
 
     verifyFromNode(node.getLeft());
     verifyFromNode(node.getRight());
   }
 
-  static class IntervalComparator implements Comparator {
-    private Comparator endpointComparator;
+  static class IntervalComparator implements Comparator<Object> {
+    private Comparator<Object> endpointComparator;
 
-    public IntervalComparator(Comparator endpointComparator) {
+    public IntervalComparator(Comparator<Object> endpointComparator) {
       this.endpointComparator = endpointComparator;
     }
 
     public int compare(Object o1, Object o2) {
       Interval i1 = (Interval) o1;
@@ -122,11 +122,11 @@
     }
   }
 
   private void searchForIntersectingNodesFrom(IntervalNode node,
                                               Interval interval,
-                                              List resultList) {
+                                              List<IntervalNode> resultList) {
     if (node == null) {
       return;
     }
 
     // Inorder traversal (very important to guarantee sorted order)

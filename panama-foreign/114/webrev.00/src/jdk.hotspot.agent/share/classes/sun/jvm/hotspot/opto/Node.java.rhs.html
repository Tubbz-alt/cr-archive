<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/opto/Node.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.opto;
 26 
 27 import java.io.*;
 28 import java.lang.reflect.Constructor;
 29 import java.util.*;
 30 import sun.jvm.hotspot.debugger.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.oops.*;
 33 import sun.jvm.hotspot.types.*;
<a name="2" id="anc2"></a><span class="line-added"> 34 import sun.jvm.hotspot.utilities.Observable;</span>
<span class="line-added"> 35 import sun.jvm.hotspot.utilities.Observer;</span>
 36 
 37 public class Node extends VMObject {
 38   static {
 39     VM.registerVMInitializedObserver(new Observer() {
 40         public void update(Observable o, Object data) {
 41           initialize(VM.getVM().getTypeDataBase());
 42         }
 43       });
 44   }
 45 
 46   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
 47     Type type      = db.lookupType(&quot;Node&quot;);
 48     outmaxField = new CIntField(type.getCIntegerField(&quot;_outmax&quot;), 0);
 49     outcntField = new CIntField(type.getCIntegerField(&quot;_outcnt&quot;), 0);
 50     maxField = new CIntField(type.getCIntegerField(&quot;_max&quot;), 0);
 51     cntField = new CIntField(type.getCIntegerField(&quot;_cnt&quot;), 0);
 52     idxField = new CIntField(type.getCIntegerField(&quot;_idx&quot;), 0);
 53     outField = type.getAddressField(&quot;_out&quot;);
 54     inField = type.getAddressField(&quot;_in&quot;);
 55 
 56     nodeType = db.lookupType(&quot;Node&quot;);
 57 
<a name="3" id="anc3"></a><span class="line-modified"> 58     virtualConstructor = new VirtualBaseConstructor&lt;&gt;(db, nodeType, &quot;sun.jvm.hotspot.opto&quot;, Node.class);</span>
 59   }
 60 
 61   private static CIntField outmaxField;
 62   private static CIntField outcntField;
 63   private static CIntField maxField;
 64   private static CIntField cntField;
 65   private static CIntField idxField;
 66   private static AddressField outField;
 67   private static AddressField inField;
 68 
<a name="4" id="anc4"></a><span class="line-modified"> 69   private static VirtualBaseConstructor&lt;Node&gt; virtualConstructor;</span>
 70 
 71   private static Type nodeType;
 72 
<a name="5" id="anc5"></a><span class="line-modified"> 73   static HashMap&lt;Address, Node&gt; nodes = new HashMap&lt;&gt;();</span>
 74 
 75   static HashMap constructors = new HashMap();
 76 
 77   static abstract class Instantiator {
 78     abstract Node create(Address addr);
 79   }
 80 
 81   static public Node create(Address addr) {
 82     if (addr == null) return null;
<a name="6" id="anc6"></a><span class="line-modified"> 83     Node result = nodes.get(addr);</span>
 84     if (result == null) {
 85       result = (Node)virtualConstructor.instantiateWrapperFor(addr);
 86       nodes.put(addr, result);
 87     }
 88     return result;
 89   }
 90 
 91   public Node(Address addr) {
 92     super(addr);
 93   }
 94 
 95   public int outcnt() {
 96     return (int)outcntField.getValue(this.getAddress());
 97   }
 98 
 99   public int req() {
100     return (int)cntField.getValue(this.getAddress());
101   }
102 
103   public int len() {
104     return (int)maxField.getValue(this.getAddress());
105   }
106 
107   public int idx() {
108     return (int)idxField.getValue(this.getAddress());
109   }
110 
111   private Node[] _out;
112   private Node[] _in;
113 
114   public Node rawOut(int i) {
115     if (_out == null) {
116       int addressSize = (int)VM.getVM().getAddressSize();
117       _out = new Node[outcnt()];
118       Address ptr = outField.getValue(this.getAddress());
119       for (int j = 0; j &lt; outcnt(); j++) {
120         _out[j] = Node.create(ptr.getAddressAt(j * addressSize));
121       }
122     }
123     return _out[i];
124   }
125 
126   public Node in(int i) {
127     if (_in == null) {
128       int addressSize = (int)VM.getVM().getAddressSize();
129       _in = new Node[len()];
130       Address ptr = inField.getValue(this.getAddress());
131       for (int j = 0; j &lt; len(); j++) {
132         _in[j] = Node.create(ptr.getAddressAt(j * addressSize));
133       }
134     }
135     return _in[i];
136   }
137 
<a name="7" id="anc7"></a><span class="line-modified">138   public ArrayList&lt;Node&gt; collect(int d, boolean onlyCtrl) {</span>
139     int depth = Math.abs(d);
<a name="8" id="anc8"></a><span class="line-modified">140     ArrayList&lt;Node&gt; nstack = new ArrayList&lt;&gt;();</span>
141     BitSet set = new BitSet();
142 
143     nstack.add(this);
144     set.set(idx());
145     int begin = 0;
146     int end = 0;
147     for (int i = 0; i &lt; depth; i++) {
148       end = nstack.size();
149       for(int j = begin; j &lt; end; j++) {
150         Node tp  = (Node)nstack.get(j);
151         int limit = d &gt; 0 ? tp.len() : tp.outcnt();
152         for(int k = 0; k &lt; limit; k++) {
153           Node n = d &gt; 0 ? tp.in(k) : tp.rawOut(k);
154 
155           // if (NotANode(n))  continue;
156           if (n == null) continue;
157           // do not recurse through top or the root (would reach unrelated stuff)
158           // if (n.isRoot() || n.isTop())  continue;
159           // if (onlyCtrl &amp;&amp; !n.isCfg()) continue;
160 
161           if (!set.get(n.idx())) {
162             nstack.add(n);
163             set.set(n.idx());
164           }
165         }
166       }
167       begin = end;
168     }
169     return nstack;
170   }
171 
172   protected void dumpNodes(Node s, int d, boolean onlyCtrl, PrintStream out) {
173     if (s == null) return;
174 
175     ArrayList nstack = s.collect(d, onlyCtrl);
176     int end = nstack.size();
177     if (d &gt; 0) {
178       for(int j = end-1; j &gt;= 0; j--) {
179         ((Node)nstack.get(j)).dump(out);
180       }
181     } else {
182       for(int j = 0; j &lt; end; j++) {
183         ((Node)nstack.get(j)).dump(out);
184       }
185     }
186   }
187 
188   public void dump(int depth, PrintStream out) {
189     dumpNodes(this, depth, false, out);
190   }
191 
192   public String Name() {
193     Type t = VM.getVM().getTypeDataBase().findDynamicTypeForAddress(getAddress(), nodeType);
194     String name = null;
195     if (t != null) {
196         name = t.toString();
197     } else {
198         Class c = getClass();
199         if (c == Node.class) {
200             // couldn&#39;t identify class type
201             return &quot;UnknownNode&lt;&quot; + getAddress().getAddressAt(0) + &quot;&gt;&quot;;
202         }
203         name = getClass().getName();
204         if (name.startsWith(&quot;sun.jvm.hotspot.opto.&quot;)) {
205             name = name.substring(&quot;sun.jvm.hotspot.opto.&quot;.length());
206         }
207     }
208     if (name.endsWith(&quot;Node&quot;)) {
209         return name.substring(0, name.length() - 4);
210     }
211     return name;
212   }
213 
214   public void dump(PrintStream out) {
215     out.print(&quot; &quot;);
216     out.print(idx());
217     out.print(&quot;\t&quot;);
218     out.print(Name());
219     out.print(&quot;\t=== &quot;);
220     int i = 0;
221     for (i = 0; i &lt; req(); i++) {
222       Node n = in(i);
223       if (n != null) {
224         out.print(&#39; &#39;);
225         out.print(in(i).idx());
226       } else {
227         out.print(&quot;_&quot;);
228       }
229       out.print(&quot; &quot;);
230     }
231     if (len() != req()) {
232       int prec = 0;
233       for (; i &lt; len(); i++) {
234         Node n = in(i);
235         if (n != null) {
236           if (prec++ == 0) {
237             out.print(&quot;| &quot;);
238           }
239           out.print(in(i).idx());
240         }
241         out.print(&quot; &quot;);
242       }
243     }
244     dumpOut(out);
245     dumpSpec(out);
246     out.println();
247   }
248 
249   void dumpOut(PrintStream out) {
250     // Delimit the output edges
251     out.print(&quot; [[&quot;);
252     // Dump the output edges
253     for (int i = 0; i &lt; outcnt(); i++) {    // For all outputs
254       Node u = rawOut(i);
255       if (u == null) {
256         out.print(&quot;_ &quot;);
257       // } else if (NotANode(u)) {
258       //   out.print(&quot;NotANode &quot;);
259       } else {
260         // out.print(&quot;%c%d &quot;, Compile::current()-&gt;nodeArena()-&gt;contains(u) ? &#39; &#39; : &#39;o&#39;, u-&gt;_idx);
261         out.print(&#39; &#39;);
262         out.print(u.idx());
263         out.print(&#39; &#39;);
264       }
265     }
266     out.print(&quot;]] &quot;);
267   }
268 
269   public void dumpSpec(PrintStream out) {
270   }
271 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/ConcurrentLocksPrinter.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
 1 /*
 2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
 3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 4  *
 5  * This code is free software; you can redistribute it and/or modify it
 6  * under the terms of the GNU General Public License version 2 only, as
 7  * published by the Free Software Foundation.
 8  *
 9  * This code is distributed in the hope that it will be useful, but WITHOUT
10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
12  * version 2 for more details (a copy is included in the LICENSE file that
13  * accompanied this code).
14  *
15  * You should have received a copy of the GNU General Public License version
16  * 2 along with this work; if not, write to the Free Software Foundation,
17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
18  *
19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
20  * or visit www.oracle.com if you need additional information or have any
21  * questions.
22  *
23  */
24 
25 package sun.jvm.hotspot.runtime;
26 
27 import java.io.*;
28 import java.util.*;
29 import sun.jvm.hotspot.memory.*;
30 import sun.jvm.hotspot.oops.*;
31 
32 public class ConcurrentLocksPrinter {
33     private Map&lt;JavaThread, List&lt;Oop&gt;&gt; locksMap = new HashMap&lt;&gt;();
34 
35     public ConcurrentLocksPrinter() {
36         fillLocks();
37     }
38 
39     public void print(JavaThread jthread, PrintStream tty) {
40         List&lt;Oop&gt; locks = locksMap.get(jthread);
41         tty.println(&quot;Locked ownable synchronizers:&quot;);
42         if (locks == null || locks.isEmpty()) {
43             tty.println(&quot;    - None&quot;);
44         } else {
45             for (Iterator&lt;Oop&gt; itr = locks.iterator(); itr.hasNext();) {
46                 Oop oop = itr.next();
47                 tty.println(&quot;    - &lt;&quot; + oop.getHandle() + &quot;&gt;, (a &quot; +
48                        oop.getKlass().getName().asString() + &quot;)&quot;);
49             }
50         }
51     }
52 
53     //-- Internals only below this point
54     private JavaThread getOwnerThread(Oop oop) {
55         Oop threadOop = OopUtilities.abstractOwnableSynchronizerGetOwnerThread(oop);
56         if (threadOop == null) {
57             return null;
58         } else {
59             return OopUtilities.threadOopGetJavaThread(threadOop);
60         }
61     }
62 
63     private void fillLocks() {
64         VM vm = VM.getVM();
65         SystemDictionary sysDict = vm.getSystemDictionary();
66         Klass absOwnSyncKlass = sysDict.getAbstractOwnableSynchronizerKlass();
67         ObjectHeap heap = vm.getObjectHeap();
68         // may be not loaded at all
69         if (absOwnSyncKlass != null) {
70             heap.iterateObjectsOfKlass(new DefaultHeapVisitor() {
71                     public boolean doObj(Oop oop) {
72                         JavaThread thread = getOwnerThread(oop);
73                         if (thread != null) {
74                             List&lt;Oop&gt; locks = locksMap.get(thread);
75                             if (locks == null) {
76                                 locks = new LinkedList&lt;&gt;();
77                                 locksMap.put(thread, locks);
78                             }
79                             locks.add(oop);
80                         }
81                         return false;
82                     }
83 
84                 }, absOwnSyncKlass, true);
85         }
86     }
87 }
    </pre>
  </body>
</html>
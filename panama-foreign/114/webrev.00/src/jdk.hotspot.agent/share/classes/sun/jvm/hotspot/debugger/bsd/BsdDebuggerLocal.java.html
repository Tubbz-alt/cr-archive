<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdDebuggerLocal.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.debugger.bsd;
 26 
 27 import java.io.File;
 28 import java.util.ArrayList;
 29 import java.util.List;
 30 
 31 import sun.jvm.hotspot.debugger.Address;
 32 import sun.jvm.hotspot.debugger.DebuggerBase;
 33 import sun.jvm.hotspot.debugger.DebuggerException;
 34 import sun.jvm.hotspot.debugger.DebuggerUtilities;
 35 import sun.jvm.hotspot.debugger.MachineDescription;
 36 import sun.jvm.hotspot.debugger.NotInHeapException;
 37 import sun.jvm.hotspot.debugger.OopHandle;
 38 import sun.jvm.hotspot.debugger.ProcessInfo;
 39 import sun.jvm.hotspot.debugger.ReadResult;
 40 import sun.jvm.hotspot.debugger.ThreadProxy;
 41 import sun.jvm.hotspot.debugger.UnalignedAddressException;
 42 import sun.jvm.hotspot.debugger.UnmappedAddressException;
 43 import sun.jvm.hotspot.debugger.cdbg.CDebugger;
 44 import sun.jvm.hotspot.debugger.cdbg.ClosestSymbol;
 45 import sun.jvm.hotspot.debugger.cdbg.LoadObject;
 46 import sun.jvm.hotspot.runtime.JavaThread;
 47 import sun.jvm.hotspot.runtime.Threads;
 48 import sun.jvm.hotspot.runtime.VM;
 49 import sun.jvm.hotspot.utilities.PlatformInfo;
 50 
 51 /** &lt;P&gt; An implementation of the JVMDebugger interface. The basic debug
 52     facilities are implemented through ptrace interface in the JNI code
 53     (libsaproc.so). Library maps and symbol table management are done in
 54     JNI. &lt;/P&gt;
 55 
 56     &lt;P&gt; &lt;B&gt;NOTE&lt;/B&gt; that since we have the notion of fetching &quot;Java
 57     primitive types&quot; from the remote process (which might have
 58     different sizes than we expect) we have a bootstrapping
 59     problem. We need to know the sizes of these types before we can
 60     fetch them. The current implementation solves this problem by
 61     requiring that it be configured with these type sizes before they
 62     can be fetched. The readJ(Type) routines here will throw a
 63     RuntimeException if they are called before the debugger is
 64     configured with the Java primitive type sizes. &lt;/P&gt; */
 65 
 66 public class BsdDebuggerLocal extends DebuggerBase implements BsdDebugger {
 67     private boolean useGCC32ABI;
 68     private boolean attached;
 69     private long    p_ps_prochandle;      // native debugger handle
 70     private long    symbolicator;         // macosx symbolicator handle
 71     private long    task;                 // macosx task handle
 72     private boolean isCore;
 73     private boolean isDarwin;             // variant for bsd
 74 
 75     // CDebugger support
 76     private BsdCDebugger cdbg;
 77 
 78     // threadList and loadObjectList are filled by attach0 method
 79     private List&lt;ThreadProxy&gt; threadList;
 80     private List&lt;LoadObject&gt; loadObjectList;
 81 
 82     // called by native method lookupByAddress0
 83     private ClosestSymbol createClosestSymbol(String name, long offset) {
 84        return new ClosestSymbol(name, offset);
 85     }
 86 
 87     // called by native method attach0
 88     private LoadObject createLoadObject(String fileName, long textsize,
 89                                         long base) {
 90        File f = new File(fileName);
 91        Address baseAddr = newAddress(base);
 92        return new SharedObject(this, fileName, f.length(), baseAddr);
 93     }
 94 
 95     // native methods
 96 
 97     private native static void init0()
 98                                 throws DebuggerException;
 99     private native void attach0(int pid)
100                                 throws DebuggerException;
101     private native void attach0(String execName, String coreName)
102                                 throws DebuggerException;
103     private native void detach0()
104                                 throws DebuggerException;
105     private native long lookupByName0(String objectName, String symbol)
106                                 throws DebuggerException;
107     private native ClosestSymbol lookupByAddress0(long address)
108                                 throws DebuggerException;
109     private native long[] getThreadIntegerRegisterSet0(long unique_thread_id)
110                                 throws DebuggerException;
111     private native byte[] readBytesFromProcess0(long address, long numBytes)
112                                 throws DebuggerException;
113     public native static int  getAddressSize() ;
114 
115     // Note on Bsd threads are really processes. When target process is
116     // attached by a serviceability agent thread, only that thread can do
117     // ptrace operations on the target. This is because from kernel&#39;s point
118     // view, other threads are just separate processes and they are not
119     // attached to the target. When they attempt to make ptrace calls,
120     // an ESRCH error will be returned as kernel believes target is not
121     // being traced by the caller.
122     // To work around the problem, we use a worker thread here to handle
123     // all JNI functions that are making ptrace calls.
124 
125     interface WorkerThreadTask {
126        public void doit(BsdDebuggerLocal debugger) throws DebuggerException;
127     }
128 
129     class BsdDebuggerLocalWorkerThread extends Thread {
130        BsdDebuggerLocal debugger;
131        WorkerThreadTask task;
132        DebuggerException lastException;
133 
134        public BsdDebuggerLocalWorkerThread(BsdDebuggerLocal debugger) {
135          this.debugger = debugger;
136          setDaemon(true);
137        }
138 
139        public void run() {
140           synchronized (workerThread) {
141              for (;;) {
142                 if (task != null) {
143                    lastException = null;
144                    try {
145                       task.doit(debugger);
146                    } catch (DebuggerException exp) {
147                       lastException = exp;
148                    }
149                    task = null;
150                    workerThread.notifyAll();
151                 }
152 
153                 try {
154                    workerThread.wait();
155                 } catch (InterruptedException x) {}
156              }
157           }
158        }
159 
160        public WorkerThreadTask execute(WorkerThreadTask task) throws DebuggerException {
161           synchronized (workerThread) {
162              this.task = task;
163              workerThread.notifyAll();
164              while (this.task != null) {
165                 try {
166                    workerThread.wait();
167                 } catch (InterruptedException x) {}
168              }
169              if (lastException != null) {
170                 throw new DebuggerException(lastException);
171              } else {
172                 return task;
173              }
174           }
175        }
176     }
177 
178     private BsdDebuggerLocalWorkerThread workerThread = null;
179 
180     //----------------------------------------------------------------------
181     // Implementation of Debugger interface
182     //
183 
184     /** &lt;P&gt; machDesc may not be null. &lt;/P&gt;
185 
186     &lt;P&gt; useCache should be set to true if debugging is being done
187     locally, and to false if the debugger is being created for the
188     purpose of supporting remote debugging. &lt;/P&gt; */
189     public BsdDebuggerLocal(MachineDescription machDesc,
190                               boolean useCache) throws DebuggerException {
191         this.machDesc = machDesc;
192         utils = new DebuggerUtilities(machDesc.getAddressSize(),
193                                       machDesc.isBigEndian()) {
194            public void checkAlignment(long address, long alignment) {
195              // Need to override default checkAlignment because we need to
196              // relax alignment constraints on Bsd/x86
197              if ( (address % alignment != 0)
198                 &amp;&amp;(alignment != 8 || address % 4 != 0)) {
199                 throw new UnalignedAddressException(
200                         &quot;Trying to read at address: &quot;
201                       + addressValueToString(address)
202                       + &quot; with alignment: &quot; + alignment,
203                         address);
204              }
205            }
206         };
207 
208         if (useCache) {
209             // FIXME: re-test necessity of cache on Bsd, where data
210             // fetching is faster
211             // Cache portion of the remote process&#39;s address space.
212             // Fetching data over the socket connection to dbx is slow.
213             // Might be faster if we were using a binary protocol to talk to
214             // dbx, but would have to test. For now, this cache works best
215             // if it covers the entire heap of the remote process. FIXME: at
216             // least should make this tunable from the outside, i.e., via
217             // the UI. This is a cache of 4096 4K pages, or 16 MB. The page
218             // size must be adjusted to be the hardware&#39;s page size.
219             // (FIXME: should pick this up from the debugger.)
220             initCache(4096, parseCacheNumPagesProperty(4096));
221         }
222 
223         isDarwin = getOS().equals(&quot;darwin&quot;);
224         workerThread = new BsdDebuggerLocalWorkerThread(this);
225         workerThread.start();
226     }
227 
228     /** From the Debugger interface via JVMDebugger */
229     public boolean hasProcessList() throws DebuggerException {
230         return false;
231     }
232 
233     /** From the Debugger interface via JVMDebugger */
234     public List&lt;ProcessInfo&gt; getProcessList() throws DebuggerException {
235         throw new DebuggerException(&quot;getProcessList not implemented yet&quot;);
236     }
237 
238     private void checkAttached() throws DebuggerException {
239         if (attached) {
240             if (isCore) {
241                 throw new DebuggerException(&quot;attached to a core dump already&quot;);
242             } else {
243                 throw new DebuggerException(&quot;attached to a process already&quot;);
244             }
245         }
246     }
247 
248     private void requireAttach() {
249         if (! attached) {
250             throw new RuntimeException(&quot;not attached to a process or a core!&quot;);
251         }
252     }
253 
254     /* called from attach methods */
255     private void findABIVersion() throws DebuggerException {
256         String libjvmName = isDarwin ? &quot;libjvm.dylib&quot; : &quot;libjvm.so&quot;;
257         String javaThreadVt = isDarwin ? &quot;_vt_10JavaThread&quot; : &quot;__vt_10JavaThread&quot;;
258         if (lookupByName0(libjvmName, javaThreadVt) != 0) {
259             // old C++ ABI
260             useGCC32ABI = false;
261         } else {
262             // new C++ ABI
263             useGCC32ABI = true;
264         }
265     }
266 
267     /** From the Debugger interface via JVMDebugger */
268     public synchronized void attach(int processID) throws DebuggerException {
269         checkAttached();
270         threadList = new ArrayList&lt;&gt;();
271         loadObjectList = new ArrayList&lt;&gt;();
272         class AttachTask implements WorkerThreadTask {
273            int pid;
274            public void doit(BsdDebuggerLocal debugger) {
275               debugger.attach0(pid);
276               debugger.attached = true;
277               debugger.isCore = false;
278               findABIVersion();
279            }
280         }
281 
282         AttachTask task = new AttachTask();
283         task.pid = processID;
284         workerThread.execute(task);
285     }
286 
287     /** From the Debugger interface via JVMDebugger */
288     public synchronized void attach(String execName, String coreName) {
289         checkAttached();
290         threadList = new ArrayList&lt;&gt;();
291         loadObjectList = new ArrayList&lt;&gt;();
292         attach0(execName, coreName);
293         attached = true;
294         isCore = true;
295         findABIVersion();
296     }
297 
298     /** From the Debugger interface via JVMDebugger */
299     public synchronized boolean detach() {
300         if (!attached) {
301             return false;
302         }
303 
304         threadList = null;
305         loadObjectList = null;
306 
307         if (isCore) {
308             detach0();
309             attached = false;
310             return true;
311         } else {
312             class DetachTask implements WorkerThreadTask {
313                 boolean result = false;
314 
315                 public void doit(BsdDebuggerLocal debugger) {
316                     debugger.detach0();
317                     debugger.attached = false;
318                     result = true;
319                 }
320             }
321 
322             DetachTask task = new DetachTask();
323             workerThread.execute(task);
324             return task.result;
325         }
326     }
327 
328     /** From the Debugger interface via JVMDebugger */
329     public Address parseAddress(String addressString)
330             throws NumberFormatException {
331         long addr = utils.scanAddress(addressString);
332         if (addr == 0) {
333             return null;
334         }
335         return new BsdAddress(this, addr);
336     }
337 
338     /** From the Debugger interface via JVMDebugger */
339     public String getOS() {
340         return PlatformInfo.getOS();
341     }
342 
343     /** From the Debugger interface via JVMDebugger */
344     public String getCPU() {
345         return PlatformInfo.getCPU();
346     }
347 
348     public boolean hasConsole() throws DebuggerException {
349         return false;
350     }
351 
352     public String consoleExecuteCommand(String cmd) throws DebuggerException {
353         throw new DebuggerException(&quot;No debugger console available on Bsd&quot;);
354     }
355 
356     public String getConsolePrompt() throws DebuggerException {
357         return null;
358     }
359 
360     /* called from lookup */
361     private long handleGCC32ABI(long addr, String symbol) throws DebuggerException {
362         if (useGCC32ABI &amp;&amp; symbol.startsWith(&quot;_ZTV&quot;)) {
363             return addr + (2 * machDesc.getAddressSize());
364         } else {
365             return addr;
366         }
367     }
368 
369     /** From the SymbolLookup interface via Debugger and JVMDebugger */
370     public synchronized Address lookup(String objectName, String symbol) {
371         requireAttach();
372         if (!attached) {
373             return null;
374         }
375 
376         if (isCore) {
377             // MacOSX symbol with &quot;_&quot; as leading
378             long addr = lookupByName0(objectName, isDarwin ? &quot;_&quot; + symbol : symbol);
379             return (addr == 0)? null : new BsdAddress(this, handleGCC32ABI(addr, symbol));
380         } else {
381             class LookupByNameTask implements WorkerThreadTask {
382                 String objectName, symbol;
383                 Address result;
384 
385                 public void doit(BsdDebuggerLocal debugger) {
386                     long addr = debugger.lookupByName0(objectName, symbol);
387                     result = (addr == 0 ? null : new BsdAddress(debugger, handleGCC32ABI(addr, symbol)));
388                 }
389             }
390 
391             LookupByNameTask task = new LookupByNameTask();
392             task.objectName = objectName;
393             task.symbol = symbol;
394             workerThread.execute(task);
395             return task.result;
396         }
397     }
398 
399     /** From the SymbolLookup interface via Debugger and JVMDebugger */
400     public synchronized OopHandle lookupOop(String objectName, String symbol) {
401         Address addr = lookup(objectName, symbol);
402         if (addr == null) {
403             return null;
404         }
405         return addr.addOffsetToAsOopHandle(0);
406     }
407 
408     /** From the Debugger interface */
409     public MachineDescription getMachineDescription() {
410         return machDesc;
411     }
412 
413     //----------------------------------------------------------------------
414     // Implementation of ThreadAccess interface
415     //
416 
417     /** From the ThreadAccess interface via Debugger and JVMDebugger */
418     public ThreadProxy getThreadForIdentifierAddress(Address threadIdAddr, Address uniqueThreadIdAddr) {
419         return new BsdThread(this, threadIdAddr, uniqueThreadIdAddr);
420     }
421 
422     @Override
423     public ThreadProxy getThreadForIdentifierAddress(Address addr) {
424         throw new RuntimeException(&quot;unimplemented&quot;);
425     }
426 
427     /** From the ThreadAccess interface via Debugger and JVMDebugger */
428     public ThreadProxy getThreadForThreadId(long id) {
429         return new BsdThread(this, id);
430     }
431 
432     //----------------------------------------------------------------------
433     // Internal routines (for implementation of BsdAddress).
434     // These must not be called until the MachineDescription has been set up.
435     //
436 
437     /** From the BsdDebugger interface */
438     public String addressValueToString(long address) {
439         return utils.addressValueToString(address);
440     }
441 
442     /** From the BsdDebugger interface */
443     public BsdAddress readAddress(long address)
444             throws UnmappedAddressException, UnalignedAddressException {
445         long value = readAddressValue(address);
446         return (value == 0 ? null : new BsdAddress(this, value));
447     }
448     public BsdAddress readCompOopAddress(long address)
449             throws UnmappedAddressException, UnalignedAddressException {
450         long value = readCompOopAddressValue(address);
451         return (value == 0 ? null : new BsdAddress(this, value));
452     }
453 
454     public BsdAddress readCompKlassAddress(long address)
455             throws UnmappedAddressException, UnalignedAddressException {
456         long value = readCompKlassAddressValue(address);
457         return (value == 0 ? null : new BsdAddress(this, value));
458     }
459 
460     /** From the BsdDebugger interface */
461     public BsdOopHandle readOopHandle(long address)
462             throws UnmappedAddressException, UnalignedAddressException,
463                 NotInHeapException {
464         long value = readAddressValue(address);
465         return (value == 0 ? null : new BsdOopHandle(this, value));
466     }
467     public BsdOopHandle readCompOopHandle(long address)
468             throws UnmappedAddressException, UnalignedAddressException,
469                 NotInHeapException {
470         long value = readCompOopAddressValue(address);
471         return (value == 0 ? null : new BsdOopHandle(this, value));
472     }
473 
474     //----------------------------------------------------------------------
475     // Thread context access
476     //
477 
478     public synchronized long[] getThreadIntegerRegisterSet(long unique_thread_id)
479                                             throws DebuggerException {
480         requireAttach();
481         if (isCore) {
482             return getThreadIntegerRegisterSet0(unique_thread_id);
483         } else {
484             class GetThreadIntegerRegisterSetTask implements WorkerThreadTask {
485                 long unique_thread_id;
486                 long[] result;
487                 public void doit(BsdDebuggerLocal debugger) {
488                     result = debugger.getThreadIntegerRegisterSet0(unique_thread_id);
489                 }
490             }
491 
492             GetThreadIntegerRegisterSetTask task = new GetThreadIntegerRegisterSetTask();
493             task.unique_thread_id = unique_thread_id;
494             workerThread.execute(task);
495             return task.result;
496         }
497     }
498 
499     /** Need to override this to relax alignment checks on x86. */
500     public long readCInteger(long address, long numBytes, boolean isUnsigned)
501         throws UnmappedAddressException, UnalignedAddressException {
502         // Only slightly relaxed semantics -- this is a hack, but is
503         // necessary on x86 where it seems the compiler is
504         // putting some global 64-bit data on 32-bit boundaries
505         if (numBytes == 8) {
506             utils.checkAlignment(address, 4);
507         } else {
508             utils.checkAlignment(address, numBytes);
509         }
510         byte[] data = readBytes(address, numBytes);
511         return utils.dataToCInteger(data, isUnsigned);
512     }
513 
514     // Overridden from DebuggerBase because we need to relax alignment
515     // constraints on x86
516     public long readJLong(long address)
517         throws UnmappedAddressException, UnalignedAddressException {
518         utils.checkAlignment(address, jintSize);
519         byte[] data = readBytes(address, jlongSize);
520         return utils.dataToJLong(data, jlongSize);
521     }
522 
523     //----------------------------------------------------------------------
524     // Address access. Can not be package private, but should only be
525     // accessed by the architecture-specific subpackages.
526 
527     /** From the BsdDebugger interface */
528     public long getAddressValue(Address addr) {
529       if (addr == null) return 0;
530       return ((BsdAddress) addr).getValue();
531     }
532 
533     /** From the BsdDebugger interface */
534     public Address newAddress(long value) {
535       if (value == 0) return null;
536       return new BsdAddress(this, value);
537     }
538 
539     /** From the BsdCDebugger interface */
540     public List&lt;ThreadProxy&gt; getThreadList() {
541       requireAttach();
542       return threadList;
543     }
544 
545     /** From the BsdCDebugger interface */
546     public List&lt;LoadObject&gt; getLoadObjectList() {
547       requireAttach();
548       return loadObjectList;
549     }
550 
551     /** From the BsdCDebugger interface */
552     public synchronized ClosestSymbol lookup(long addr) {
553        requireAttach();
554        if (isCore) {
555           return lookupByAddress0(addr);
556        } else {
557           class LookupByAddressTask implements WorkerThreadTask {
558              long addr;
559              ClosestSymbol result;
560 
561              public void doit(BsdDebuggerLocal debugger) {
562                  result = debugger.lookupByAddress0(addr);
563              }
564           }
565 
566           LookupByAddressTask task = new LookupByAddressTask();
567           task.addr = addr;
568           workerThread.execute(task);
569           return task.result;
570        }
571     }
572 
573     public CDebugger getCDebugger() {
574       if (cdbg == null) {
575          cdbg = new BsdCDebugger(this);
576       }
577       return cdbg;
578     }
579 
580     /** This reads bytes from the remote process. */
581     public synchronized ReadResult readBytesFromProcess(long address,
582             long numBytes) throws UnmappedAddressException, DebuggerException {
583         requireAttach();
584         if (isCore) {
585             byte[] res = readBytesFromProcess0(address, numBytes);
586             return (res != null)? new ReadResult(res) : new ReadResult(address);
587         } else {
588             class ReadBytesFromProcessTask implements WorkerThreadTask {
589                 long address, numBytes;
590                 ReadResult result;
591                 public void doit(BsdDebuggerLocal debugger) {
592                     byte[] res = debugger.readBytesFromProcess0(address, numBytes);
593                     if (res != null)
594                         result = new ReadResult(res);
595                     else
596                         result = new ReadResult(address);
597                 }
598             }
599 
600             ReadBytesFromProcessTask task = new ReadBytesFromProcessTask();
601             task.address = address;
602             task.numBytes = numBytes;
603             workerThread.execute(task);
604             return task.result;
605         }
606     }
607 
608     public void writeBytesToProcess(long address, long numBytes, byte[] data)
609         throws UnmappedAddressException, DebuggerException {
610         // FIXME
611         throw new DebuggerException(&quot;Unimplemented&quot;);
612     }
613 
614     /** this functions used for core file reading and called from native attach0,
615         it returns an array of long integers as
616         [thread_id, stack_start, stack_end, thread_id, stack_start, stack_end, ....] for
617         all java threads recorded in Threads. Also adds the ThreadProxy to threadList */
618     public long[] getJavaThreadsInfo() {
619         requireAttach();
620         Threads threads = VM.getVM().getThreads();
621         int len = threads.getNumberOfThreads();
622         long[] result = new long[len * 3];    // triple
623         long beg, end;
624         int i = 0;
625         for (int k = 0; k &lt; threads.getNumberOfThreads(); k++) {
626             JavaThread t = threads.getJavaThreadAt(k);
627             end = t.getStackBaseValue();
628             beg = end - t.getStackSize();
629             BsdThread bsdt = (BsdThread)t.getThreadProxy();
630             long uid = bsdt.getUniqueThreadId();
631             if (threadList != null) threadList.add(bsdt);
632             result[i] = uid;
633             result[i + 1] = beg;
634             result[i + 2] = end;
635             i += 3;
636         }
637         return result;
638     }
639 
640     static {
641         System.loadLibrary(&quot;saproc&quot;);
642         init0();
643     }
644 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/soql/JSJavaInstanceKlass.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.utilities.soql;
 26 
 27 import java.util.*;
 28 import sun.jvm.hotspot.oops.*;
 29 import sun.jvm.hotspot.utilities.*;
 30 
 31 /**
 32    This is JavaScript wrapper for InstanceKlass.
 33 */
 34 public class JSJavaInstanceKlass extends JSJavaKlass {
 35    private static final int FIELD_SOURCE_FILE        = 1;
 36    private static final int FIELD_INTERFACES         = 2;
 37    private static final int FIELD_FIELDS             = 3;
 38    private static final int FIELD_METHODS            = 4;
 39    private static final int FIELD_IS_PRIVATE         = 5;
 40    private static final int FIELD_IS_PUBLIC          = 6;
 41    private static final int FIELD_IS_PROTECTED       = 7;
 42    private static final int FIELD_IS_PACKAGE_PRIVATE = 8;
 43    private static final int FIELD_IS_STATIC          = 9;
 44    private static final int FIELD_IS_FINAL           = 10;
 45    private static final int FIELD_IS_ABSTRACT        = 11;
 46    private static final int FIELD_IS_STRICT          = 12;
 47    private static final int FIELD_IS_SYNTHETIC       = 13;
 48    private static final int FIELD_IS_INTERFACE       = 14;
 49    private static final int FIELD_CLASS_LOADER       = 15;
 50    private static final int FIELD_STATICS            = 18;
 51    private static final int FIELD_UNDEFINED          = -1;
 52 
 53    public JSJavaInstanceKlass(InstanceKlass kls, JSJavaFactory fac) {
 54       super(kls, fac);
 55       this.instanceFields = new HashMap&lt;&gt;();
 56       this.staticFields = new HashMap&lt;&gt;();
 57    }
 58 
 59    public final InstanceKlass getInstanceKlass() {
 60       return (InstanceKlass) getKlass();
 61    }
 62 
 63    public Object getMetaClassFieldValue(String name) {
 64       int fieldID = getFieldID(name);
 65       InstanceKlass ik = getInstanceKlass();
 66       switch (fieldID) {
 67       case FIELD_SOURCE_FILE: {
 68          Symbol sourceFile = ik.getSourceFileName();
 69          return (sourceFile != null)? sourceFile.asString() : &quot;&lt;unknown&gt;&quot;;
 70       }
 71       case FIELD_INTERFACES:
 72          return getInterfaces();
 73       case FIELD_FIELDS:
 74          return factory.newJSList(ik.getImmediateFields());
 75       case FIELD_METHODS:
 76          return factory.newJSList(ik.getImmediateMethods());
 77       case FIELD_IS_PRIVATE:
 78          return Boolean.valueOf(getAccessFlags().isPrivate());
 79       case FIELD_IS_PUBLIC:
 80          return Boolean.valueOf(getAccessFlags().isPublic());
 81       case FIELD_IS_PROTECTED:
 82          return Boolean.valueOf(getAccessFlags().isProtected());
 83       case FIELD_IS_PACKAGE_PRIVATE: {
 84          AccessFlags acc = getAccessFlags();
 85          return Boolean.valueOf(!acc.isPrivate() &amp;&amp; !acc.isPublic() &amp;&amp; !acc.isProtected());
 86       }
 87       case FIELD_IS_STATIC:
 88          return Boolean.valueOf(getAccessFlags().isStatic());
 89       case FIELD_IS_FINAL:
 90          return Boolean.valueOf(getAccessFlags().isFinal());
 91       case FIELD_IS_ABSTRACT:
 92          return Boolean.valueOf(getAccessFlags().isAbstract());
 93       case FIELD_IS_STRICT:
 94          return Boolean.valueOf(getAccessFlags().isStrict());
 95       case FIELD_IS_SYNTHETIC:
 96          return Boolean.valueOf(getAccessFlags().isSynthetic());
 97       case FIELD_IS_INTERFACE:
 98          return Boolean.valueOf(ik.isInterface());
 99       case FIELD_CLASS_LOADER:
100          return factory.newJSJavaObject(ik.getClassLoader());
101       case FIELD_STATICS:
102          return getStatics();
103       case FIELD_UNDEFINED:
104       default:
105          return super.getMetaClassFieldValue(name);
106       }
107    }
108 
109    public boolean hasMetaClassField(String name) {
110       if (getFieldID(name) != FIELD_UNDEFINED) {
111           return true;
112       } else {
113           return super.hasMetaClassField(name);
114       }
115    }
116 
117    public String getName() {
118       return getInstanceKlass().getName().asString().replace(&#39;/&#39;, &#39;.&#39;);
119    }
120 
121    public boolean isArray() {
122       return false;
123    }
124 
125    public String[] getMetaClassFieldNames() {
126       String[] superFields = super.getMetaClassFieldNames();
127       Set k = fields.keySet();
128       String[] res = new String[k.size() + superFields.length];
129       System.arraycopy(superFields, 0, res, 0, superFields.length);
130       int i = superFields.length;
131       for (Iterator itr = k.iterator(); itr.hasNext();) {
132           res[i] = (String) itr.next();
133           i++;
134       }
135       return res;
136    }
137 
138    public Object getInstanceFieldValue(String name, Instance instance) throws NoSuchFieldException {
139       Field fld = findInstanceField(name);
140       if (fld != null) {
141          return getFieldValue(fld, name, instance);
142       } else {
143          throw new NoSuchFieldException(name + &quot; is not field of &quot;
144                 + getInstanceKlass().getName().asString().replace(&#39;/&#39;, &#39;.&#39;));
145       }
146    }
147 
148    public Object getStaticFieldValue(String name) throws NoSuchFieldException {
149       Field fld = findStaticField(name);
150       if (fld != null) {
151          return getFieldValue(fld, name, getInstanceKlass());
152       } else {
153          throw new NoSuchFieldException(name + &quot; is not field of &quot;
154                 + getInstanceKlass().getName().asString().replace(&#39;/&#39;, &#39;.&#39;));
155       }
156    }
157 
158    public String[] getInstanceFieldNames() {
159       if (instanceFieldNames == null) {
160          InstanceKlass current = getInstanceKlass();
161          while (current != null) {
162             List&lt;Field&gt; tmp = current.getImmediateFields();
163             for (Iterator&lt;Field&gt; itr = tmp.iterator(); itr.hasNext();) {
164                Field fld = itr.next();
165                if (!fld.isStatic()) {
166                   String name = fld.getID().getName();
167                   if (instanceFields.get(name) == null) {
168                      instanceFields.put(name, fld);
169                   }
170                }
171             }
172             current = (InstanceKlass) current.getSuper();
173          }
174 
175          Set s = instanceFields.keySet();
176          instanceFieldNames = new String[s.size()];
177          int i = 0;
178          for (Iterator itr = s.iterator(); itr.hasNext(); i++) {
179             instanceFieldNames[i] = (String) itr.next();
180          }
181       }
182       return instanceFieldNames;
183    }
184 
185    public boolean hasInstanceField(String name) {
186       Field fld = findInstanceField(name);
187       return (fld != null)? true: false;
188    }
189 
190    public String[] getStaticFieldNames() {
191       if (staticFieldNames == null) {
192          InstanceKlass current = getInstanceKlass();
193          List&lt;Field&gt; tmp = current.getImmediateFields();
194          for (Iterator&lt;Field&gt; itr = tmp.iterator(); itr.hasNext();) {
195             Field fld = itr.next();
196             if (fld.isStatic()) {
197                staticFields.put(fld.getID().getName(), fld);
198             }
199          }
200 
201          Set s = staticFields.keySet();
202          staticFieldNames = new String[s.size()];
203          int i = 0;
204          for (Iterator itr = s.iterator(); itr.hasNext(); i++) {
205             staticFieldNames[i] = (String) itr.next();
206          }
207       }
208       return staticFieldNames;
209    }
210 
211    public boolean hasStaticField(String name) {
212       Field fld = findStaticField(name);
213       return (fld != null)? true: false;
214    }
215 
216    //-- Intenals only below this point
217    private static Map&lt;String, Integer&gt; fields = new HashMap&lt;&gt;();
218    private static void addField(String name, int fieldId) {
219       fields.put(name, fieldId);
220    }
221 
222    private static int getFieldID(String name) {
223       Integer res = (Integer) fields.get(name);
224       return (res != null)? res.intValue() : FIELD_UNDEFINED;
225    }
226 
227    static {
228       addField(&quot;sourceFile&quot;, FIELD_SOURCE_FILE);
229       addField(&quot;interfaces&quot;, FIELD_INTERFACES);
230       addField(&quot;fields&quot;, FIELD_FIELDS);
231       addField(&quot;methods&quot;, FIELD_METHODS);
232       addField(&quot;isPrivate&quot;, FIELD_IS_PRIVATE);
233       addField(&quot;isPublic&quot;, FIELD_IS_PUBLIC);
234       addField(&quot;isProtected&quot;, FIELD_IS_PROTECTED);
235       addField(&quot;isPackagePrivate&quot;, FIELD_IS_PACKAGE_PRIVATE);
236       addField(&quot;isStatic&quot;, FIELD_IS_STATIC);
237       addField(&quot;isFinal&quot;, FIELD_IS_FINAL);
238       addField(&quot;isAbstract&quot;, FIELD_IS_ABSTRACT);
239       addField(&quot;isStrict&quot;, FIELD_IS_STRICT);
240       addField(&quot;isSynthetic&quot;, FIELD_IS_SYNTHETIC);
241       addField(&quot;isInterface&quot;, FIELD_IS_INTERFACE);
242       addField(&quot;classLoader&quot;, FIELD_CLASS_LOADER);
243       addField(&quot;statics&quot;, FIELD_STATICS);
244    }
245 
246    private AccessFlags getAccessFlags() {
247       if (accFlags == null) {
248          accFlags = new AccessFlags(getInstanceKlass().computeModifierFlags());
249       }
250       return accFlags;
251    }
252 
253    private Object getFieldValue(Field fld, String name, Oop oop) {
254        FieldType fd = fld.getFieldType();
255        if (fd.isObject() || fd.isArray()) {
256          return factory.newJSJavaObject(((OopField)fld).getValue(oop));
257        } else if (fd.isByte()) {
258           return ((ByteField) fld).getValue(oop);
259        } else if (fd.isChar()) {
260           return new String(new char[] { ((CharField)fld).getValue(oop) });
261        } else if (fd.isDouble()) {
262           return ((DoubleField) fld).getValue(oop);
263        } else if (fd.isFloat()) {
264           return ((FloatField) fld).getValue(oop);
265        } else if (fd.isInt()) {
266           return ((IntField) fld).getValue(oop);
267        } else if (fd.isLong()) {
268           return ((LongField) fld).getValue(oop);
269        } else if (fd.isShort()) {
270           return ((ShortField) fld).getValue(oop);
271        } else if (fd.isBoolean()) {
272           return ((BooleanField) fld).getValue(oop);
273        } else {
274           if (Assert.ASSERTS_ENABLED) {
275              Assert.that(false, &quot;invalid field type for &quot; + name);
276           }
277           return null;
278        }
279    }
280 
281    private Object getFieldValue(Field fld, String name, InstanceKlass oop) {
282        FieldType fd = fld.getFieldType();
283        if (fd.isObject() || fd.isArray()) {
284          return factory.newJSJavaObject(((OopField)fld).getValue(oop));
285        } else if (fd.isByte()) {
286           return ((ByteField) fld).getValue(oop);
287        } else if (fd.isChar()) {
288           return new String(new char[] { ((CharField)fld).getValue(oop) });
289        } else if (fd.isDouble()) {
290           return ((DoubleField) fld).getValue(oop);
291        } else if (fd.isFloat()) {
292           return ((FloatField) fld).getValue(oop);
293        } else if (fd.isInt()) {
294           return ((IntField) fld).getValue(oop);
295        } else if (fd.isLong()) {
296           return ((LongField) fld).getValue(oop);
297        } else if (fd.isShort()) {
298           return ((ShortField) fld).getValue(oop);
299        } else if (fd.isBoolean()) {
300           return ((BooleanField) fld).getValue(oop);
301        } else {
302           if (Assert.ASSERTS_ENABLED) {
303              Assert.that(false, &quot;invalid field type for &quot; + name);
304           }
305           return null;
306        }
307    }
308 
309    private Field findInstanceField(String name) {
310       Field fld = (Field) instanceFields.get(name);
311       if (fld != null) {
312          return fld;
313       } else {
314          InstanceKlass current = getInstanceKlass();
315          while (current != null) {
316             List&lt;Field&gt; tmp = current.getImmediateFields();
317             for (Iterator&lt;Field&gt; itr = tmp.iterator(); itr.hasNext();) {
318                fld = itr.next();
319                if (fld.getID().getName().equals(name) &amp;&amp; !fld.isStatic()) {
320                    instanceFields.put(name, fld);
321                    return fld;
322                }
323             }
324             // lookup in super class.
325             current = (InstanceKlass) current.getSuper();
326          }
327       }
328       // no match
329       return null;
330    }
331 
332    private Field findStaticField(String name) {
333       Field fld = (Field) staticFields.get(name);
334       if (fld != null) {
335          return fld;
336       } else {
337          // static fields are searched only in current.
338          // Direct/indirect super classes and interfaces
339          // are not included in search.
340          InstanceKlass current = getInstanceKlass();
341          List&lt;Field&gt; tmp = current.getImmediateFields();
342          for (Iterator&lt;Field&gt; itr = tmp.iterator(); itr.hasNext();) {
343             fld = itr.next();
344             if (fld.getID().getName().equals(name) &amp;&amp; fld.isStatic()) {
345                staticFields.put(name, fld);
346                return fld;
347             }
348          }
349          // no match
350          return null;
351       }
352    }
353 
354    private JSList getInterfaces() {
355       InstanceKlass ik = getInstanceKlass();
356       List&lt;Klass&gt; intfs = ik.getDirectImplementedInterfaces();
357       List&lt;Instance&gt; res = new ArrayList&lt;&gt;(0);
358       for (Iterator&lt;Klass&gt; itr = intfs.iterator(); itr.hasNext();) {
359           Klass k = itr.next();
360           res.add(k.getJavaMirror());
361       }
362       return factory.newJSList(res);
363    }
364 
365    private JSMap getStatics() {
366       String[] names = getStaticFieldNames();
367       Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
368       for (int i=0; i &lt; names.length; i++) {
369          try {
370             map.put(names[i], getStaticFieldValue(names[i]));
371          } catch (NoSuchFieldException exp) {}
372       }
373       return factory.newJSMap(map);
374   }
375 
376    private Map&lt;String, Field&gt; instanceFields;
377    private Map&lt;String, Field&gt; staticFields;
378    private String[]      instanceFieldNames;
379    private String[]      staticFieldNames;
380    private AccessFlags   accFlags;
381 }
    </pre>
  </body>
</html>
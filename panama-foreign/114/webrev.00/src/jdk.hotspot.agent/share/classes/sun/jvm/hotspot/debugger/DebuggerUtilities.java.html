<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/DebuggerUtilities.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.debugger;
 26 
 27 /** Common routines for data conversion */
 28 
 29 public class DebuggerUtilities {
 30   protected long addressSize;
 31   protected boolean isBigEndian;
 32 
 33   public DebuggerUtilities(long addressSize, boolean isBigEndian) {
 34     this.addressSize = addressSize;
 35     this.isBigEndian = isBigEndian;
 36   }
 37 
 38   public String addressValueToString(long address) {
 39     StringBuffer buf = new StringBuffer();
 40     buf.append(&quot;0x&quot;);
 41     String val;
 42     // Make negative addresses have the correct size
 43     if (addressSize == 8) {
 44       val = Long.toHexString(address);
 45     } else {
 46       val = Integer.toHexString((int) address);
 47     }
 48     for (int i = 0; i &lt; ((2 * addressSize) - val.length()); i++) {
 49       buf.append(&#39;0&#39;);
 50     }
 51     buf.append(val);
 52     return buf.toString();
 53   }
 54 
 55   public void checkAlignment(long address, long alignment) {
 56     if (address % alignment != 0) {
 57       throw new UnalignedAddressException(&quot;Trying to read at address: &quot; +
 58                                            addressValueToString(address) +
 59                                            &quot; with alignment: &quot; + alignment,
 60                                           address);
 61     }
 62   }
 63 
 64   public long scanAddress(String addrStr) throws NumberFormatException {
 65     String s = addrStr.trim();
 66     if (!s.startsWith(&quot;0x&quot;)) {
 67       throw new NumberFormatException(addrStr);
 68     }
 69     long l = 0;
 70     for (int i = 2; i &lt; s.length(); ++i) {
 71       int val = charToNibble(s.charAt(i));
 72       l &lt;&lt;= 4;
 73       l |= val;
 74     }
 75     return l;
 76   }
 77 
 78   public int charToNibble(char ascii) throws NumberFormatException {
 79     if (ascii &gt;= &#39;0&#39; &amp;&amp; ascii &lt;= &#39;9&#39;) {
 80       return ascii - &#39;0&#39;;
 81     } else if (ascii &gt;= &#39;A&#39; &amp;&amp; ascii &lt;= &#39;F&#39;) {
 82       return 10 + ascii - &#39;A&#39;;
 83     } else if (ascii &gt;= &#39;a&#39; &amp;&amp; ascii &lt;= &#39;f&#39;) {
 84       return 10 + ascii - &#39;a&#39;;
 85     }
 86     throw new NumberFormatException(Character.toString(ascii));
 87   }
 88 
 89   public boolean dataToJBoolean(byte[] data, long jbooleanSize) {
 90     checkDataContents(data, jbooleanSize);
 91 
 92     return (data[0] != 0);
 93   }
 94 
 95   public byte dataToJByte(byte[] data, long jbyteSize) {
 96     checkDataContents(data, jbyteSize);
 97 
 98     return data[0];
 99   }
100 
101   public char dataToJChar(byte[] data, long jcharSize) {
102     checkDataContents(data, jcharSize);
103 
104     if (!isBigEndian) {
105       byteSwap(data);
106     }
107 
108     return (char) (((data[0] &amp; 0xFF) &lt;&lt; 8) | (data[1] &amp; 0xFF));
109   }
110 
111   public double dataToJDouble(byte[] data, long jdoubleSize) {
112     long longBits = dataToJLong(data, jdoubleSize);
113 
114     return Double.longBitsToDouble(longBits);
115   }
116 
117   public float dataToJFloat(byte[] data, long jfloatSize) {
118     int intBits = dataToJInt(data, jfloatSize);
119 
120     return Float.intBitsToFloat(intBits);
121   }
122 
123   public int dataToJInt(byte[] data, long jintSize) {
124     checkDataContents(data, jintSize);
125 
126     if (!isBigEndian) {
127       byteSwap(data);
128     }
129 
130     return (((data[0] &amp; 0xFF) &lt;&lt; 24) | ((data[1] &amp; 0xFF) &lt;&lt; 16) | ((data[2] &amp; 0xFF) &lt;&lt; 8) | (data[3] &amp; 0xFF));
131   }
132 
133   public long dataToJLong(byte[] data, long jlongSize) {
134     checkDataContents(data, jlongSize);
135 
136     if (!isBigEndian) {
137       byteSwap(data);
138     }
139 
140     return rawDataToJLong(data);
141   }
142 
143   public short dataToJShort(byte[] data, long jshortSize) {
144     checkDataContents(data, jshortSize);
145 
146     if (!isBigEndian) {
147       byteSwap(data);
148     }
149 
150     return (short) (((data[0] &amp; 0xFF) &lt;&lt; 8) | (data[1] &amp; 0xFF));
151   }
152 
153   public long dataToCInteger(byte[] data, boolean isUnsigned) {
154     checkDataContents(data, data.length);
155 
156     if (!isBigEndian) {
157       byteSwap(data);
158     }
159 
160     // By default we&#39;ll be zero-extending.
161     // Therefore we need to check to see whether isUnsigned is false and
162     // also the high bit of the data is set.
163     if ((data.length &lt; 8) &amp;&amp;
164         (isUnsigned == false) &amp;&amp;
165         ((data[0] &amp; 0x80) != 0)) {
166       // Must sign-extend and right-align the data
167       byte[] newData = new byte[8];
168       for (int i = 0; i &lt; 8; ++i) {
169         if ((7 - i) &lt; data.length) {
170           newData[i] = data[i + data.length - 8];
171         } else {
172           newData[i] = (byte) 0xFF;
173         }
174       }
175       data = newData;
176     }
177 
178     // Now just do the usual loop
179     return rawDataToJLong(data);
180   }
181 
182   public long dataToAddressValue(byte[] data) {
183     checkDataContents(data, addressSize);
184 
185     if (!isBigEndian) {
186       byteSwap(data);
187     }
188 
189     return rawDataToJLong(data);
190   }
191 
192   public byte[] jbooleanToData(boolean value) {
193     byte[] res = new byte[1];
194     res[0] = (byte) (value ? 1 : 0);
195     return res;
196   }
197 
198   public byte[] jbyteToData(byte value) {
199     byte[] res = new byte[1];
200     res[0] = value;
201     return res;
202   }
203 
204   public byte[] jcharToData(char value) {
205     byte[] res = new byte[2];
206     res[0] = (byte) ((value &gt;&gt; 8) &amp; 0xFF);
207     res[1] = (byte) value;
208     if (!isBigEndian) {
209       byteSwap(res);
210     }
211     return res;
212   }
213 
214   public byte[] jdoubleToData(double value) {
215     return jlongToData(Double.doubleToLongBits(value));
216   }
217 
218   public byte[] jfloatToData(float value) {
219     return jintToData(Float.floatToIntBits(value));
220   }
221 
222   public byte[] jintToData(int value) {
223     byte[] res = new byte[4];
224     for (int i = 0; i &lt; 4; i++) {
225       res[3 - i] = (byte) (value &amp; 0xFF);
226       value &gt;&gt;&gt;= 8;
227     }
228     if (!isBigEndian) {
229       byteSwap(res);
230     }
231     return res;
232   }
233 
234   public byte[] jlongToData(long value) {
235     byte[] res = new byte[8];
236     for (int i = 0; i &lt; 8; i++) {
237       res[7 - i] = (byte) (value &amp; 0xFF);
238       value &gt;&gt;&gt;= 8;
239     }
240     if (!isBigEndian) {
241       byteSwap(res);
242     }
243     return res;
244   }
245 
246   public byte[] jshortToData(short value) {
247     byte[] res = new byte[2];
248     res[0] = (byte) ((value &gt;&gt; 8) &amp; 0xFF);
249     res[1] = (byte) value;
250     if (!isBigEndian) {
251       byteSwap(res);
252     }
253     return res;
254   }
255 
256   public byte[] cIntegerToData(long longNumBytes, long value) {
257     int numBytes = (int) longNumBytes;
258     byte[] res = new byte[numBytes];
259     for (int i = 0; i &lt; numBytes; i++) {
260       res[numBytes - i - 1] = (byte) (value &amp; 0xFF);
261       value &gt;&gt;&gt;= 8;
262     }
263     if (!isBigEndian) {
264       byteSwap(res);
265     }
266     return res;
267   }
268 
269   //--------------------------------------------------------------------------------
270   // Internals only below this point
271   //
272 
273   private void checkDataContents(byte[] data, long len) {
274     if (data.length != (int) len) {
275       throw new InternalError(&quot;Bug in Win32Debugger&quot;);
276     }
277   }
278 
279   private void byteSwap(byte[] data) {
280     for (int i = 0; i &lt; (data.length / 2); ++i) {
281       int altIndex = data.length - i - 1;
282       byte t = data[altIndex];
283       data[altIndex] = data[i];
284       data[i] = t;
285     }
286   }
287 
288   private long rawDataToJLong(byte[] data) {
289     long addr = 0;
290     for (int i = 0; i &lt; data.length; ++i) {
291       addr &lt;&lt;= 8;
292       addr |= data[i] &amp; 0xFF;
293     }
294 
295     return addr;
296   }
297 }
    </pre>
  </body>
</html>
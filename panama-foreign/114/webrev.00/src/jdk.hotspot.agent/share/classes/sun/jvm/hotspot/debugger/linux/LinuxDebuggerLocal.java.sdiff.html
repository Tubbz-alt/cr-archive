<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/linux/LinuxDebuggerLocal.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LinuxDebugger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../proc/ProcCDebugger.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/linux/LinuxDebuggerLocal.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 26 
 27 import java.io.File;
 28 import java.io.IOException;
 29 import java.io.UncheckedIOException;
 30 import java.nio.file.Files;
 31 import java.nio.file.Path;
 32 import java.nio.file.Paths;
 33 import java.util.ArrayList;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.NoSuchElementException;
 37 import java.util.stream.Collectors;
 38 
 39 import sun.jvm.hotspot.debugger.Address;
 40 import sun.jvm.hotspot.debugger.DebuggerBase;
 41 import sun.jvm.hotspot.debugger.DebuggerException;
 42 import sun.jvm.hotspot.debugger.DebuggerUtilities;
 43 import sun.jvm.hotspot.debugger.MachineDescription;
 44 import sun.jvm.hotspot.debugger.NotInHeapException;
 45 import sun.jvm.hotspot.debugger.OopHandle;

 46 import sun.jvm.hotspot.debugger.ReadResult;
 47 import sun.jvm.hotspot.debugger.ThreadProxy;
 48 import sun.jvm.hotspot.debugger.UnalignedAddressException;
 49 import sun.jvm.hotspot.debugger.UnmappedAddressException;
 50 import sun.jvm.hotspot.debugger.cdbg.CDebugger;
 51 import sun.jvm.hotspot.debugger.cdbg.ClosestSymbol;
 52 import sun.jvm.hotspot.debugger.cdbg.LoadObject;
 53 import sun.jvm.hotspot.utilities.PlatformInfo;
 54 
 55 /** &lt;P&gt; An implementation of the JVMDebugger interface. The basic debug
 56     facilities are implemented through ptrace interface in the JNI code
 57     (libsaproc.so). Library maps and symbol table management are done in
 58     JNI. &lt;/P&gt;
 59 
 60     &lt;P&gt; &lt;B&gt;NOTE&lt;/B&gt; that since we have the notion of fetching &quot;Java
 61     primitive types&quot; from the remote process (which might have
 62     different sizes than we expect) we have a bootstrapping
 63     problem. We need to know the sizes of these types before we can
 64     fetch them. The current implementation solves this problem by
 65     requiring that it be configured with these type sizes before they
 66     can be fetched. The readJ(Type) routines here will throw a
 67     RuntimeException if they are called before the debugger is
 68     configured with the Java primitive type sizes. &lt;/P&gt; */
 69 
 70 public class LinuxDebuggerLocal extends DebuggerBase implements LinuxDebugger {
 71     private boolean useGCC32ABI;
 72     private boolean attached;
 73     private long    p_ps_prochandle; // native debugger handle
 74     private boolean isCore;
 75 
 76     // CDebugger support
 77     private LinuxCDebugger cdbg;
 78 
 79     // threadList and loadObjectList are filled by attach0 method
<span class="line-modified"> 80     private List threadList;</span>
<span class="line-modified"> 81     private List loadObjectList;</span>
 82 
 83     // PID namespace support
 84     // It maps the LWPID in the host to the LWPID in the container.
 85     private Map&lt;Integer, Integer&gt; nspidMap;
 86 
 87     // called by native method lookupByAddress0
 88     private ClosestSymbol createClosestSymbol(String name, long offset) {
 89        return new ClosestSymbol(name, offset);
 90     }
 91 
 92     // called by native method attach0
 93     private LoadObject createLoadObject(String fileName, long textsize,
 94                                         long base) {
 95        File f = new File(fileName);
 96        Address baseAddr = newAddress(base);
 97        return new SharedObject(this, fileName, f.length(), baseAddr);
 98     }
 99 
100     // native methods
101 
</pre>
<hr />
<pre>
231             // Might be faster if we were using a binary protocol to talk to
232             // dbx, but would have to test. For now, this cache works best
233             // if it covers the entire heap of the remote process. FIXME: at
234             // least should make this tunable from the outside, i.e., via
235             // the UI. This is a cache of 4096 4K pages, or 16 MB. The page
236             // size must be adjusted to be the hardware&#39;s page size.
237             // (FIXME: should pick this up from the debugger.)
238             initCache(4096, parseCacheNumPagesProperty(4096));
239         }
240 
241         workerThread = new LinuxDebuggerLocalWorkerThread(this);
242         workerThread.start();
243     }
244 
245     /** From the Debugger interface via JVMDebugger */
246     public boolean hasProcessList() throws DebuggerException {
247         return false;
248     }
249 
250     /** From the Debugger interface via JVMDebugger */
<span class="line-modified">251     public List getProcessList() throws DebuggerException {</span>
252         throw new DebuggerException(&quot;getProcessList not implemented yet&quot;);
253     }
254 
255     private void checkAttached() throws DebuggerException {
256         if (attached) {
257             if (isCore) {
258                 throw new DebuggerException(&quot;attached to a core dump already&quot;);
259             } else {
260                 throw new DebuggerException(&quot;attached to a process already&quot;);
261             }
262         }
263     }
264 
265     private void requireAttach() {
266         if (! attached) {
267             throw new RuntimeException(&quot;not attached to a process or a core!&quot;);
268         }
269     }
270 
271     /* called from attach methods */
</pre>
<hr />
<pre>
300     public int getHostPID(int id) {
301         return (nspidMap == null) ? -1 : nspidMap.get(id);
302     }
303 
304     // Fill namespace PID map from procfs.
305     // This method scans all tasks (/proc/&lt;PID&gt;/task) in the process.
306     private void fillNSpidMap(Path proc) {
307         Path task = Paths.get(proc.toString(), &quot;task&quot;);
308         try (var tasks = Files.list(task)) {
309             nspidMap = tasks.filter(p -&gt; !p.toString().startsWith(&quot;.&quot;))
310                             .collect(Collectors.toMap(p -&gt; Integer.valueOf(getNamespacePID(Paths.get(p.toString(), &quot;status&quot;))),
311                                                       p -&gt; Integer.valueOf(p.toFile().getName())));
312         } catch (IOException e) {
313             throw new UncheckedIOException(e);
314         }
315     }
316 
317     /** From the Debugger interface via JVMDebugger */
318     public synchronized void attach(int processID) throws DebuggerException {
319         checkAttached();
<span class="line-modified">320         threadList = new ArrayList();</span>
<span class="line-modified">321         loadObjectList = new ArrayList();</span>
322 
323         Path proc = Paths.get(&quot;/proc&quot;, Integer.toString(processID));
324         int NSpid = getNamespacePID(Paths.get(proc.toString(), &quot;status&quot;));
325         if (NSpid != processID) {
326             // If PID different from namespace PID, we can assume the process
327             // is running in the container.
328             // So we need to set SA_ALTROOT environment variable that SA reads
329             // binaries in the container.
330             setSAAltRoot0(Paths.get(proc.toString(), &quot;root&quot;).toString());
331             fillNSpidMap(proc);
332         }
333 
334         class AttachTask implements WorkerThreadTask {
335            int pid;
336            public void doit(LinuxDebuggerLocal debugger) {
337               debugger.attach0(pid);
338               debugger.attached = true;
339               debugger.isCore = false;
340               findABIVersion();
341            }
342         }
343 
344         AttachTask task = new AttachTask();
345         task.pid = processID;
346         workerThread.execute(task);
347     }
348 
349     /** From the Debugger interface via JVMDebugger */
350     public synchronized void attach(String execName, String coreName) {
351         checkAttached();
<span class="line-modified">352         threadList = new ArrayList();</span>
<span class="line-modified">353         loadObjectList = new ArrayList();</span>
354         attach0(execName, coreName);
355         attached = true;
356         isCore = true;
357         findABIVersion();
358     }
359 
360     /** From the Debugger interface via JVMDebugger */
361     public synchronized boolean detach() {
362         if (!attached) {
363             return false;
364         }
365 
366         threadList = null;
367         loadObjectList = null;
368 
369         if (isCore) {
370             detach0();
371             attached = false;
372             return true;
373         } else {
</pre>
<hr />
<pre>
576         return utils.dataToJLong(data, jlongSize);
577     }
578 
579     //----------------------------------------------------------------------
580     // Address access. Can not be package private, but should only be
581     // accessed by the architecture-specific subpackages.
582 
583     /** From the LinuxDebugger interface */
584     public long getAddressValue(Address addr) {
585       if (addr == null) return 0;
586       return ((LinuxAddress) addr).getValue();
587     }
588 
589     /** From the LinuxDebugger interface */
590     public Address newAddress(long value) {
591       if (value == 0) return null;
592       return new LinuxAddress(this, value);
593     }
594 
595     /** From the LinuxCDebugger interface */
<span class="line-modified">596     public List/*&lt;ThreadProxy&gt;*/ getThreadList() {</span>
597       requireAttach();
598       return threadList;
599     }
600 
601     /** From the LinuxCDebugger interface */
<span class="line-modified">602     public List/*&lt;LoadObject&gt;*/ getLoadObjectList() {</span>
603       requireAttach();
604       return loadObjectList;
605     }
606 
607     /** From the LinuxCDebugger interface */
608     public synchronized ClosestSymbol lookup(long addr) {
609        requireAttach();
610        if (isCore) {
611           return lookupByAddress0(addr);
612        } else {
613           class LookupByAddressTask implements WorkerThreadTask {
614              long addr;
615              ClosestSymbol result;
616 
617              public void doit(LinuxDebuggerLocal debugger) {
618                  result = debugger.lookupByAddress0(addr);
619              }
620           }
621 
622           LookupByAddressTask task = new LookupByAddressTask();
</pre>
</td>
<td>
<hr />
<pre>
 26 
 27 import java.io.File;
 28 import java.io.IOException;
 29 import java.io.UncheckedIOException;
 30 import java.nio.file.Files;
 31 import java.nio.file.Path;
 32 import java.nio.file.Paths;
 33 import java.util.ArrayList;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.NoSuchElementException;
 37 import java.util.stream.Collectors;
 38 
 39 import sun.jvm.hotspot.debugger.Address;
 40 import sun.jvm.hotspot.debugger.DebuggerBase;
 41 import sun.jvm.hotspot.debugger.DebuggerException;
 42 import sun.jvm.hotspot.debugger.DebuggerUtilities;
 43 import sun.jvm.hotspot.debugger.MachineDescription;
 44 import sun.jvm.hotspot.debugger.NotInHeapException;
 45 import sun.jvm.hotspot.debugger.OopHandle;
<span class="line-added"> 46 import sun.jvm.hotspot.debugger.ProcessInfo;</span>
 47 import sun.jvm.hotspot.debugger.ReadResult;
 48 import sun.jvm.hotspot.debugger.ThreadProxy;
 49 import sun.jvm.hotspot.debugger.UnalignedAddressException;
 50 import sun.jvm.hotspot.debugger.UnmappedAddressException;
 51 import sun.jvm.hotspot.debugger.cdbg.CDebugger;
 52 import sun.jvm.hotspot.debugger.cdbg.ClosestSymbol;
 53 import sun.jvm.hotspot.debugger.cdbg.LoadObject;
 54 import sun.jvm.hotspot.utilities.PlatformInfo;
 55 
 56 /** &lt;P&gt; An implementation of the JVMDebugger interface. The basic debug
 57     facilities are implemented through ptrace interface in the JNI code
 58     (libsaproc.so). Library maps and symbol table management are done in
 59     JNI. &lt;/P&gt;
 60 
 61     &lt;P&gt; &lt;B&gt;NOTE&lt;/B&gt; that since we have the notion of fetching &quot;Java
 62     primitive types&quot; from the remote process (which might have
 63     different sizes than we expect) we have a bootstrapping
 64     problem. We need to know the sizes of these types before we can
 65     fetch them. The current implementation solves this problem by
 66     requiring that it be configured with these type sizes before they
 67     can be fetched. The readJ(Type) routines here will throw a
 68     RuntimeException if they are called before the debugger is
 69     configured with the Java primitive type sizes. &lt;/P&gt; */
 70 
 71 public class LinuxDebuggerLocal extends DebuggerBase implements LinuxDebugger {
 72     private boolean useGCC32ABI;
 73     private boolean attached;
 74     private long    p_ps_prochandle; // native debugger handle
 75     private boolean isCore;
 76 
 77     // CDebugger support
 78     private LinuxCDebugger cdbg;
 79 
 80     // threadList and loadObjectList are filled by attach0 method
<span class="line-modified"> 81     private List&lt;ThreadProxy&gt; threadList;</span>
<span class="line-modified"> 82     private List&lt;LoadObject&gt; loadObjectList;</span>
 83 
 84     // PID namespace support
 85     // It maps the LWPID in the host to the LWPID in the container.
 86     private Map&lt;Integer, Integer&gt; nspidMap;
 87 
 88     // called by native method lookupByAddress0
 89     private ClosestSymbol createClosestSymbol(String name, long offset) {
 90        return new ClosestSymbol(name, offset);
 91     }
 92 
 93     // called by native method attach0
 94     private LoadObject createLoadObject(String fileName, long textsize,
 95                                         long base) {
 96        File f = new File(fileName);
 97        Address baseAddr = newAddress(base);
 98        return new SharedObject(this, fileName, f.length(), baseAddr);
 99     }
100 
101     // native methods
102 
</pre>
<hr />
<pre>
232             // Might be faster if we were using a binary protocol to talk to
233             // dbx, but would have to test. For now, this cache works best
234             // if it covers the entire heap of the remote process. FIXME: at
235             // least should make this tunable from the outside, i.e., via
236             // the UI. This is a cache of 4096 4K pages, or 16 MB. The page
237             // size must be adjusted to be the hardware&#39;s page size.
238             // (FIXME: should pick this up from the debugger.)
239             initCache(4096, parseCacheNumPagesProperty(4096));
240         }
241 
242         workerThread = new LinuxDebuggerLocalWorkerThread(this);
243         workerThread.start();
244     }
245 
246     /** From the Debugger interface via JVMDebugger */
247     public boolean hasProcessList() throws DebuggerException {
248         return false;
249     }
250 
251     /** From the Debugger interface via JVMDebugger */
<span class="line-modified">252     public List&lt;ProcessInfo&gt; getProcessList() throws DebuggerException {</span>
253         throw new DebuggerException(&quot;getProcessList not implemented yet&quot;);
254     }
255 
256     private void checkAttached() throws DebuggerException {
257         if (attached) {
258             if (isCore) {
259                 throw new DebuggerException(&quot;attached to a core dump already&quot;);
260             } else {
261                 throw new DebuggerException(&quot;attached to a process already&quot;);
262             }
263         }
264     }
265 
266     private void requireAttach() {
267         if (! attached) {
268             throw new RuntimeException(&quot;not attached to a process or a core!&quot;);
269         }
270     }
271 
272     /* called from attach methods */
</pre>
<hr />
<pre>
301     public int getHostPID(int id) {
302         return (nspidMap == null) ? -1 : nspidMap.get(id);
303     }
304 
305     // Fill namespace PID map from procfs.
306     // This method scans all tasks (/proc/&lt;PID&gt;/task) in the process.
307     private void fillNSpidMap(Path proc) {
308         Path task = Paths.get(proc.toString(), &quot;task&quot;);
309         try (var tasks = Files.list(task)) {
310             nspidMap = tasks.filter(p -&gt; !p.toString().startsWith(&quot;.&quot;))
311                             .collect(Collectors.toMap(p -&gt; Integer.valueOf(getNamespacePID(Paths.get(p.toString(), &quot;status&quot;))),
312                                                       p -&gt; Integer.valueOf(p.toFile().getName())));
313         } catch (IOException e) {
314             throw new UncheckedIOException(e);
315         }
316     }
317 
318     /** From the Debugger interface via JVMDebugger */
319     public synchronized void attach(int processID) throws DebuggerException {
320         checkAttached();
<span class="line-modified">321         threadList = new ArrayList&lt;&gt;();</span>
<span class="line-modified">322         loadObjectList = new ArrayList&lt;&gt;();</span>
323 
324         Path proc = Paths.get(&quot;/proc&quot;, Integer.toString(processID));
325         int NSpid = getNamespacePID(Paths.get(proc.toString(), &quot;status&quot;));
326         if (NSpid != processID) {
327             // If PID different from namespace PID, we can assume the process
328             // is running in the container.
329             // So we need to set SA_ALTROOT environment variable that SA reads
330             // binaries in the container.
331             setSAAltRoot0(Paths.get(proc.toString(), &quot;root&quot;).toString());
332             fillNSpidMap(proc);
333         }
334 
335         class AttachTask implements WorkerThreadTask {
336            int pid;
337            public void doit(LinuxDebuggerLocal debugger) {
338               debugger.attach0(pid);
339               debugger.attached = true;
340               debugger.isCore = false;
341               findABIVersion();
342            }
343         }
344 
345         AttachTask task = new AttachTask();
346         task.pid = processID;
347         workerThread.execute(task);
348     }
349 
350     /** From the Debugger interface via JVMDebugger */
351     public synchronized void attach(String execName, String coreName) {
352         checkAttached();
<span class="line-modified">353         threadList = new ArrayList&lt;&gt;();</span>
<span class="line-modified">354         loadObjectList = new ArrayList&lt;&gt;();</span>
355         attach0(execName, coreName);
356         attached = true;
357         isCore = true;
358         findABIVersion();
359     }
360 
361     /** From the Debugger interface via JVMDebugger */
362     public synchronized boolean detach() {
363         if (!attached) {
364             return false;
365         }
366 
367         threadList = null;
368         loadObjectList = null;
369 
370         if (isCore) {
371             detach0();
372             attached = false;
373             return true;
374         } else {
</pre>
<hr />
<pre>
577         return utils.dataToJLong(data, jlongSize);
578     }
579 
580     //----------------------------------------------------------------------
581     // Address access. Can not be package private, but should only be
582     // accessed by the architecture-specific subpackages.
583 
584     /** From the LinuxDebugger interface */
585     public long getAddressValue(Address addr) {
586       if (addr == null) return 0;
587       return ((LinuxAddress) addr).getValue();
588     }
589 
590     /** From the LinuxDebugger interface */
591     public Address newAddress(long value) {
592       if (value == 0) return null;
593       return new LinuxAddress(this, value);
594     }
595 
596     /** From the LinuxCDebugger interface */
<span class="line-modified">597     public List&lt;ThreadProxy&gt; getThreadList() {</span>
598       requireAttach();
599       return threadList;
600     }
601 
602     /** From the LinuxCDebugger interface */
<span class="line-modified">603     public List&lt;LoadObject&gt; getLoadObjectList() {</span>
604       requireAttach();
605       return loadObjectList;
606     }
607 
608     /** From the LinuxCDebugger interface */
609     public synchronized ClosestSymbol lookup(long addr) {
610        requireAttach();
611        if (isCore) {
612           return lookupByAddress0(addr);
613        } else {
614           class LookupByAddressTask implements WorkerThreadTask {
615              long addr;
616              ClosestSymbol result;
617 
618              public void doit(LinuxDebuggerLocal debugger) {
619                  result = debugger.lookupByAddress0(addr);
620              }
621           }
622 
623           LookupByAddressTask task = new LookupByAddressTask();
</pre>
</td>
</tr>
</table>
<center><a href="LinuxDebugger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../proc/ProcCDebugger.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
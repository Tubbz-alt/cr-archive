<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/windbg/WindbgCDebugInfoBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../win32/coff/COFFFileParser.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WindbgCDebugger.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/windbg/WindbgCDebugInfoBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2003, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 31 import sun.jvm.hotspot.debugger.cdbg.*;
 32 import sun.jvm.hotspot.debugger.cdbg.basic.*;
 33 import sun.jvm.hotspot.utilities.Assert;
 34 
 35 class WindbgCDebugInfoBuilder
 36   implements DebugVC50SubsectionTypes, DebugVC50TypeLeafIndices, DebugVC50TypeEnums, DebugVC50SymbolTypes, DebugVC50MemberAttributes, CVAttributes, AccessControl {
 37   private WindbgDebugger dbg;
 38   private Address       base;
 39 
 40   private DebugVC50 vc50;
 41   private BasicCDebugInfoDataBase db;
 42   private DebugVC50TypeIterator iter;
 43 
 44   private DebugVC50SymbolIterator symIter;
 45 
 46   // Logical-&gt;physical segment mapping
 47   private COFFFile file;
 48   private DebugVC50SSSegMap segMap;
 49 
 50   // Canonicalization of primitive types
<span class="line-modified"> 51   private Map primIndexToTypeMap;</span>
 52 
 53   // Global unnamed enumeration
 54   // (FIXME: must figure out how to handle nested type descriptions)
 55   private BasicEnumType unnamedEnum;
 56 
<span class="line-modified"> 57   private Stack blockStack;</span>
 58   private int   endsToSkip;
 59 
 60   private static final int POINTER_SIZE = 4;
 61 
 62   WindbgCDebugInfoBuilder(WindbgDebugger dbg) {
 63     this.dbg = dbg;
 64   }
 65 
 66   CDebugInfoDataBase buildDataBase(String dllName, Address base) {
 67     this.base = base;
 68     file = COFFFileParser.getParser().parse(dllName);
 69     vc50 = getDebugVC50(file);
 70 
 71     if (vc50 == null) return null;
 72 
 73     segMap = getSegMap();
 74 
<span class="line-modified"> 75     primIndexToTypeMap = new HashMap();</span>
<span class="line-modified"> 76     blockStack = new Stack();</span>
 77     endsToSkip = 0;
 78 
 79     db = new BasicCDebugInfoDataBase();
 80     db.beginConstruction();
 81 
 82     // Get global types and add them to the database
 83     DebugVC50SSGlobalTypes types = getGlobalTypes();
 84     for (iter = types.getTypeIterator(); !iter.done(); iter.next()) {
 85       while (!iter.typeStringDone()) {
 86         switch (iter.typeStringLeaf()) {
 87         case LF_MODIFIER: {
 88           int idx = iter.getModifierIndex();
 89           BasicType target = getTypeByIndex(idx);
 90           short windowsMods = iter.getModifierAttribute();
 91           short mods = 0;
 92           if ((windowsMods &amp; MODIFIER_CONST_MASK)    != 0) mods |= CONST;
 93           if ((windowsMods &amp; MODIFIER_VOLATILE_MASK) != 0) mods |= VOLATILE;
 94           putType(target.getCVVariant(mods));
 95           break;
 96         }
</pre>
<hr />
<pre>
647   private DebugVC50SSGlobalTypes getGlobalTypes() {
648     return (DebugVC50SSGlobalTypes) findSubsection(SST_GLOBAL_TYPES);
649   }
650 
651   private DebugVC50SSGlobalSym getGlobalSymbols() {
652     return (DebugVC50SSGlobalSym) findSubsection(SST_GLOBAL_SYM);
653   }
654 
655   private DebugVC50Subsection findSubsection(short ssType) {
656     DebugVC50SubsectionDirectory dir = vc50.getSubsectionDirectory();
657     for (int i = 0; i &lt; dir.getNumEntries(); i++) {
658       DebugVC50Subsection ss = dir.getSubsection(i);
659       if (ss.getSubsectionType() == ssType) {
660         return ss;
661       }
662     }
663     throw new DebuggerException(&quot;Unable to find subsection of type &quot; + ssType);
664   }
665 
666   private void putType(Type t) {
<span class="line-modified">667     db.addType(new Integer(iter.getTypeIndex()), t);</span>
668   }
669 
670   private Address newAddress(int offset, short segment) {
671     int seg = segment &amp; 0xFFFF;
672     // NOTE: it isn&#39;t clear how to use the segMap to map from logical
673     // to physical segments. It seems it would make more sense if the
674     // SegDescs contained a physical segment number in addition to the
675     // offset within the physical segment of the logical one.
676 
677     // Get the section header corresponding to this segment
678     SectionHeader section = file.getHeader().getSectionHeader(seg);
679 
680     // Result is relative to image base
681     return base.addOffsetTo(section.getVirtualAddress() + offset);
682   }
683 
684   private BasicType getTypeByIndex(int intIndex) {
<span class="line-modified">685     Integer index = new Integer(intIndex);</span>
686 
687     // Handle primitive types here.
688     if (intIndex &lt;= 0x0FFF) {
689       BasicType type = (BasicType) primIndexToTypeMap.get(index);
690       if (type != null) {
691         return type;
692       }
693       // Construct appropriate new primitive type
694       int primMode = intIndex &amp; RESERVED_MODE_MASK;
695       if (primMode == RESERVED_MODE_DIRECT) {
696         int primType = intIndex &amp; RESERVED_TYPE_MASK;
697         switch (primType) {
698         case RESERVED_TYPE_SIGNED_INT:
699         case RESERVED_TYPE_UNSIGNED_INT: {
700           boolean unsigned = (primType == RESERVED_TYPE_UNSIGNED_INT);
701           int size = 0;
702           String name = null;
703           switch (intIndex &amp; RESERVED_SIZE_MASK) {
704           case RESERVED_SIZE_INT_1_BYTE: size = 1; name = &quot;char&quot;;    break;
705           case RESERVED_SIZE_INT_2_BYTE: size = 2; name = &quot;short&quot;;   break;
</pre>
<hr />
<pre>
764       } else {
765         // Fold all pointer types together since we only support
766         // flat-mode addressing anyway
767         Type targetType = getTypeByIndex(intIndex &amp; (~RESERVED_MODE_MASK));
768 
769         type = new BasicPointerType(POINTER_SIZE, targetType);
770       }
771       if (Assert.ASSERTS_ENABLED) {
772         Assert.that(type != null, &quot;Got null Type for primitive type &quot; + intIndex);
773       }
774       primIndexToTypeMap.put(index, type);
775       return type;
776     }
777 
778     // Not primitive type. Construct lazy reference to target type.
779     // (Is it worth canonicalizing these as well to save space?)
780     return new LazyType(index);
781   }
782 
783   private void addBlock(BlockSym block) {
<span class="line-modified">784     db.addBlock(new Integer(symIter.getOffset()), block);</span>
785     blockStack.push(block);
786   }
787 
788   private void skipEnd() {
789     ++endsToSkip;
790   }
791 
792   private BlockSym newLazyBlockSym(int offset) {
793     if (offset == 0) {
794       return null;
795     }
796 
<span class="line-modified">797     return new LazyBlockSym(new Integer(offset));</span>
798   }
799 
800   private int memberAttributeToAccessControl(short memberAttribute) {
801     int acc = memberAttribute &amp; MEMATTR_ACCESS_MASK;
802     switch (acc) {
803     case MEMATTR_ACCESS_NO_PROTECTION: return NO_PROTECTION;
804     case MEMATTR_ACCESS_PRIVATE:       return PRIVATE;
805     case MEMATTR_ACCESS_PROTECTED:     return PROTECTED;
806     case MEMATTR_ACCESS_PUBLIC:        return PUBLIC;
807     default: throw new RuntimeException(&quot;Should not reach here&quot;);
808     }
809   }
810 
811   private void addLocalToCurBlock(LocalSym local) {
812     ((BasicBlockSym) blockStack.peek()).addLocal(local);
813   }
814 
815   private void addGlobalSym(GlobalSym sym) {
816     db.addGlobalSym(sym);
817   }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 31 import sun.jvm.hotspot.debugger.cdbg.*;
 32 import sun.jvm.hotspot.debugger.cdbg.basic.*;
 33 import sun.jvm.hotspot.utilities.Assert;
 34 
 35 class WindbgCDebugInfoBuilder
 36   implements DebugVC50SubsectionTypes, DebugVC50TypeLeafIndices, DebugVC50TypeEnums, DebugVC50SymbolTypes, DebugVC50MemberAttributes, CVAttributes, AccessControl {
 37   private WindbgDebugger dbg;
 38   private Address       base;
 39 
 40   private DebugVC50 vc50;
 41   private BasicCDebugInfoDataBase db;
 42   private DebugVC50TypeIterator iter;
 43 
 44   private DebugVC50SymbolIterator symIter;
 45 
 46   // Logical-&gt;physical segment mapping
 47   private COFFFile file;
 48   private DebugVC50SSSegMap segMap;
 49 
 50   // Canonicalization of primitive types
<span class="line-modified"> 51   private Map&lt;Integer, BasicType&gt; primIndexToTypeMap;</span>
 52 
 53   // Global unnamed enumeration
 54   // (FIXME: must figure out how to handle nested type descriptions)
 55   private BasicEnumType unnamedEnum;
 56 
<span class="line-modified"> 57   private Stack&lt;BlockSym&gt; blockStack;</span>
 58   private int   endsToSkip;
 59 
 60   private static final int POINTER_SIZE = 4;
 61 
 62   WindbgCDebugInfoBuilder(WindbgDebugger dbg) {
 63     this.dbg = dbg;
 64   }
 65 
 66   CDebugInfoDataBase buildDataBase(String dllName, Address base) {
 67     this.base = base;
 68     file = COFFFileParser.getParser().parse(dllName);
 69     vc50 = getDebugVC50(file);
 70 
 71     if (vc50 == null) return null;
 72 
 73     segMap = getSegMap();
 74 
<span class="line-modified"> 75     primIndexToTypeMap = new HashMap&lt;&gt;();</span>
<span class="line-modified"> 76     blockStack = new Stack&lt;&gt;();</span>
 77     endsToSkip = 0;
 78 
 79     db = new BasicCDebugInfoDataBase();
 80     db.beginConstruction();
 81 
 82     // Get global types and add them to the database
 83     DebugVC50SSGlobalTypes types = getGlobalTypes();
 84     for (iter = types.getTypeIterator(); !iter.done(); iter.next()) {
 85       while (!iter.typeStringDone()) {
 86         switch (iter.typeStringLeaf()) {
 87         case LF_MODIFIER: {
 88           int idx = iter.getModifierIndex();
 89           BasicType target = getTypeByIndex(idx);
 90           short windowsMods = iter.getModifierAttribute();
 91           short mods = 0;
 92           if ((windowsMods &amp; MODIFIER_CONST_MASK)    != 0) mods |= CONST;
 93           if ((windowsMods &amp; MODIFIER_VOLATILE_MASK) != 0) mods |= VOLATILE;
 94           putType(target.getCVVariant(mods));
 95           break;
 96         }
</pre>
<hr />
<pre>
647   private DebugVC50SSGlobalTypes getGlobalTypes() {
648     return (DebugVC50SSGlobalTypes) findSubsection(SST_GLOBAL_TYPES);
649   }
650 
651   private DebugVC50SSGlobalSym getGlobalSymbols() {
652     return (DebugVC50SSGlobalSym) findSubsection(SST_GLOBAL_SYM);
653   }
654 
655   private DebugVC50Subsection findSubsection(short ssType) {
656     DebugVC50SubsectionDirectory dir = vc50.getSubsectionDirectory();
657     for (int i = 0; i &lt; dir.getNumEntries(); i++) {
658       DebugVC50Subsection ss = dir.getSubsection(i);
659       if (ss.getSubsectionType() == ssType) {
660         return ss;
661       }
662     }
663     throw new DebuggerException(&quot;Unable to find subsection of type &quot; + ssType);
664   }
665 
666   private void putType(Type t) {
<span class="line-modified">667     db.addType(iter.getTypeIndex(), t);</span>
668   }
669 
670   private Address newAddress(int offset, short segment) {
671     int seg = segment &amp; 0xFFFF;
672     // NOTE: it isn&#39;t clear how to use the segMap to map from logical
673     // to physical segments. It seems it would make more sense if the
674     // SegDescs contained a physical segment number in addition to the
675     // offset within the physical segment of the logical one.
676 
677     // Get the section header corresponding to this segment
678     SectionHeader section = file.getHeader().getSectionHeader(seg);
679 
680     // Result is relative to image base
681     return base.addOffsetTo(section.getVirtualAddress() + offset);
682   }
683 
684   private BasicType getTypeByIndex(int intIndex) {
<span class="line-modified">685     Integer index = intIndex;</span>
686 
687     // Handle primitive types here.
688     if (intIndex &lt;= 0x0FFF) {
689       BasicType type = (BasicType) primIndexToTypeMap.get(index);
690       if (type != null) {
691         return type;
692       }
693       // Construct appropriate new primitive type
694       int primMode = intIndex &amp; RESERVED_MODE_MASK;
695       if (primMode == RESERVED_MODE_DIRECT) {
696         int primType = intIndex &amp; RESERVED_TYPE_MASK;
697         switch (primType) {
698         case RESERVED_TYPE_SIGNED_INT:
699         case RESERVED_TYPE_UNSIGNED_INT: {
700           boolean unsigned = (primType == RESERVED_TYPE_UNSIGNED_INT);
701           int size = 0;
702           String name = null;
703           switch (intIndex &amp; RESERVED_SIZE_MASK) {
704           case RESERVED_SIZE_INT_1_BYTE: size = 1; name = &quot;char&quot;;    break;
705           case RESERVED_SIZE_INT_2_BYTE: size = 2; name = &quot;short&quot;;   break;
</pre>
<hr />
<pre>
764       } else {
765         // Fold all pointer types together since we only support
766         // flat-mode addressing anyway
767         Type targetType = getTypeByIndex(intIndex &amp; (~RESERVED_MODE_MASK));
768 
769         type = new BasicPointerType(POINTER_SIZE, targetType);
770       }
771       if (Assert.ASSERTS_ENABLED) {
772         Assert.that(type != null, &quot;Got null Type for primitive type &quot; + intIndex);
773       }
774       primIndexToTypeMap.put(index, type);
775       return type;
776     }
777 
778     // Not primitive type. Construct lazy reference to target type.
779     // (Is it worth canonicalizing these as well to save space?)
780     return new LazyType(index);
781   }
782 
783   private void addBlock(BlockSym block) {
<span class="line-modified">784     db.addBlock(symIter.getOffset(), block);</span>
785     blockStack.push(block);
786   }
787 
788   private void skipEnd() {
789     ++endsToSkip;
790   }
791 
792   private BlockSym newLazyBlockSym(int offset) {
793     if (offset == 0) {
794       return null;
795     }
796 
<span class="line-modified">797     return new LazyBlockSym(offset);</span>
798   }
799 
800   private int memberAttributeToAccessControl(short memberAttribute) {
801     int acc = memberAttribute &amp; MEMATTR_ACCESS_MASK;
802     switch (acc) {
803     case MEMATTR_ACCESS_NO_PROTECTION: return NO_PROTECTION;
804     case MEMATTR_ACCESS_PRIVATE:       return PRIVATE;
805     case MEMATTR_ACCESS_PROTECTED:     return PROTECTED;
806     case MEMATTR_ACCESS_PUBLIC:        return PUBLIC;
807     default: throw new RuntimeException(&quot;Should not reach here&quot;);
808     }
809   }
810 
811   private void addLocalToCurBlock(LocalSym local) {
812     ((BasicBlockSym) blockStack.peek()).addLocal(local);
813   }
814 
815   private void addGlobalSym(GlobalSym sym) {
816     db.addGlobalSym(sym);
817   }
</pre>
</td>
</tr>
</table>
<center><a href="../win32/coff/COFFFileParser.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WindbgCDebugger.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
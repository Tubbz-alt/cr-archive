<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/HeapHprofBinWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HeapGXLWriter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntArray.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/HeapHprofBinWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 635,25 ***</span>
              writeObjectID(null);  // ik.getJavaMirror().getSigners());
              writeObjectID(null);  // ik.getJavaMirror().getProtectionDomain());
              // two reserved id fields
              writeObjectID(null);
              writeObjectID(null);
<span class="line-modified">!             List fields = getInstanceFields(ik);</span>
              int instSize = getSizeForFields(fields);
              classDataCache.put(ik, new ClassData(instSize, fields));
              out.writeInt(instSize);
  
              // For now, ignore constant pool - HAT ignores too!
              // output number of cp entries as zero.
              out.writeShort((short) 0);
  
<span class="line-modified">!             List declaredFields = ik.getImmediateFields();</span>
<span class="line-modified">!             List staticFields = new ArrayList();</span>
<span class="line-modified">!             List instanceFields = new ArrayList();</span>
<span class="line-modified">!             Iterator itr = null;</span>
              for (itr = declaredFields.iterator(); itr.hasNext();) {
<span class="line-modified">!                 Field field = (Field) itr.next();</span>
                  if (field.isStatic()) {
                      staticFields.add(field);
                  } else {
                      instanceFields.add(field);
                  }
<span class="line-new-header">--- 635,25 ---</span>
              writeObjectID(null);  // ik.getJavaMirror().getSigners());
              writeObjectID(null);  // ik.getJavaMirror().getProtectionDomain());
              // two reserved id fields
              writeObjectID(null);
              writeObjectID(null);
<span class="line-modified">!             List&lt;Field&gt; fields = getInstanceFields(ik);</span>
              int instSize = getSizeForFields(fields);
              classDataCache.put(ik, new ClassData(instSize, fields));
              out.writeInt(instSize);
  
              // For now, ignore constant pool - HAT ignores too!
              // output number of cp entries as zero.
              out.writeShort((short) 0);
  
<span class="line-modified">!             List&lt;Field&gt; declaredFields = ik.getImmediateFields();</span>
<span class="line-modified">!             List&lt;Field&gt; staticFields = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!             List&lt;Field&gt; instanceFields = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!             Iterator&lt;Field&gt; itr = null;</span>
              for (itr = declaredFields.iterator(); itr.hasNext();) {
<span class="line-modified">!                 Field field = itr.next();</span>
                  if (field.isStatic()) {
                      staticFields.add(field);
                  } else {
                      instanceFields.add(field);
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 953,26 ***</span>
          ClassData cd = (ClassData) classDataCache.get(klass);
  
          if (Assert.ASSERTS_ENABLED) {
              Assert.that(cd != null, &quot;can not get class data for &quot; + klass.getName().asString() + klass.getAddress());
          }
<span class="line-modified">!         List fields = cd.fields;</span>
          int size = cd.instSize;
          out.writeInt(size);
<span class="line-modified">!         for (Iterator itr = fields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">!             writeField((Field) itr.next(), instance);</span>
          }
      }
  
      //-- Internals only below this point
  
<span class="line-modified">!     private void writeFieldDescriptors(List fields, InstanceKlass ik)</span>
          throws IOException {
          // ik == null for instance fields.
          out.writeShort((short) fields.size());
<span class="line-modified">!         for (Iterator itr = fields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">!             Field field = (Field) itr.next();</span>
              Symbol name = field.getName();
              writeSymbolID(name);
              char typeCode = (char) field.getSignature().getByteAt(0);
              int kind = signatureToHprofKind(typeCode);
              out.writeByte((byte)kind);
<span class="line-new-header">--- 953,26 ---</span>
          ClassData cd = (ClassData) classDataCache.get(klass);
  
          if (Assert.ASSERTS_ENABLED) {
              Assert.that(cd != null, &quot;can not get class data for &quot; + klass.getName().asString() + klass.getAddress());
          }
<span class="line-modified">!         List&lt;Field&gt; fields = cd.fields;</span>
          int size = cd.instSize;
          out.writeInt(size);
<span class="line-modified">!         for (Iterator&lt;Field&gt; itr = fields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">!             writeField(itr.next(), instance);</span>
          }
      }
  
      //-- Internals only below this point
  
<span class="line-modified">!     private void writeFieldDescriptors(List&lt;Field&gt; fields, InstanceKlass ik)</span>
          throws IOException {
          // ik == null for instance fields.
          out.writeShort((short) fields.size());
<span class="line-modified">!         for (Iterator&lt;Field&gt; itr = fields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">!             Field field = itr.next();</span>
              Symbol name = field.getName();
              writeSymbolID(name);
              char typeCode = (char) field.getSignature().getByteAt(0);
              int kind = signatureToHprofKind(typeCode);
              out.writeByte((byte)kind);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1067,13 ***</span>
  
      private void writeClassSymbols(Klass k) throws IOException {
          writeSymbol(k.getName());
          if (k instanceof InstanceKlass) {
              InstanceKlass ik = (InstanceKlass) k;
<span class="line-modified">!             List declaredFields = ik.getImmediateFields();</span>
<span class="line-modified">!             for (Iterator itr = declaredFields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">!                 Field field = (Field) itr.next();</span>
                  writeSymbol(field.getName());
              }
          }
      }
  
<span class="line-new-header">--- 1067,13 ---</span>
  
      private void writeClassSymbols(Klass k) throws IOException {
          writeSymbol(k.getName());
          if (k instanceof InstanceKlass) {
              InstanceKlass ik = (InstanceKlass) k;
<span class="line-modified">!             List&lt;Field&gt; declaredFields = ik.getImmediateFields();</span>
<span class="line-modified">!             for (Iterator&lt;Field&gt; itr = declaredFields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">!                 Field field = itr.next();</span>
                  writeSymbol(field.getName());
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1172,17 ***</span>
      private long getAddressValue(Address addr) {
          return (addr == null)? 0L : dbg.getAddressValue(addr);
      }
  
      // get all declared as well as inherited (directly/indirectly) fields
<span class="line-modified">!     private static List/*&lt;Field&gt;*/ getInstanceFields(InstanceKlass ik) {</span>
          InstanceKlass klass = ik;
<span class="line-modified">!         List res = new ArrayList();</span>
          while (klass != null) {
<span class="line-modified">!             List curFields = klass.getImmediateFields();</span>
<span class="line-modified">!             for (Iterator itr = curFields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">!                 Field f = (Field) itr.next();</span>
                  if (! f.isStatic()) {
                      res.add(f);
                  }
              }
              klass = (InstanceKlass) klass.getSuper();
<span class="line-new-header">--- 1172,17 ---</span>
      private long getAddressValue(Address addr) {
          return (addr == null)? 0L : dbg.getAddressValue(addr);
      }
  
      // get all declared as well as inherited (directly/indirectly) fields
<span class="line-modified">!     private static List&lt;Field&gt; getInstanceFields(InstanceKlass ik) {</span>
          InstanceKlass klass = ik;
<span class="line-modified">!         List&lt;Field&gt; res = new ArrayList&lt;&gt;();</span>
          while (klass != null) {
<span class="line-modified">!             List&lt;Field&gt; curFields = klass.getImmediateFields();</span>
<span class="line-modified">!             for (Iterator&lt;Field&gt; itr = curFields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">!                 Field f = itr.next();</span>
                  if (! f.isStatic()) {
                      res.add(f);
                  }
              }
              klass = (InstanceKlass) klass.getSuper();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1191,14 ***</span>
      }
  
      // get size in bytes (in stream) required for given fields.  Note
      // that this is not the same as object size in heap. The size in
      // heap will include size of padding/alignment bytes as well.
<span class="line-modified">!     private int getSizeForFields(List fields) {</span>
          int size = 0;
<span class="line-modified">!         for (Iterator itr = fields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">!             Field field = (Field) itr.next();</span>
              char typeCode = (char) field.getSignature().getByteAt(0);
              switch (typeCode) {
              case JVM_SIGNATURE_BOOLEAN:
              case JVM_SIGNATURE_BYTE:
                  size++;
<span class="line-new-header">--- 1191,14 ---</span>
      }
  
      // get size in bytes (in stream) required for given fields.  Note
      // that this is not the same as object size in heap. The size in
      // heap will include size of padding/alignment bytes as well.
<span class="line-modified">!     private int getSizeForFields(List&lt;Field&gt; fields) {</span>
          int size = 0;
<span class="line-modified">!         for (Iterator&lt;Field&gt; itr = fields.iterator(); itr.hasNext();) {</span>
<span class="line-modified">!             Field field = itr.next();</span>
              char typeCode = (char) field.getSignature().getByteAt(0);
              switch (typeCode) {
              case JVM_SIGNATURE_BOOLEAN:
              case JVM_SIGNATURE_BYTE:
                  size++;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1263,15 ***</span>
      private long FLOAT_SIZE;
      private long DOUBLE_SIZE;
  
      private static class ClassData {
          int instSize;
<span class="line-modified">!         List fields;</span>
  
<span class="line-modified">!         ClassData(int instSize, List fields) {</span>
              this.instSize = instSize;
              this.fields = fields;
          }
      }
  
<span class="line-modified">!     private Map classDataCache = new HashMap(); // &lt;InstanceKlass, ClassData&gt;</span>
  }
<span class="line-new-header">--- 1263,15 ---</span>
      private long FLOAT_SIZE;
      private long DOUBLE_SIZE;
  
      private static class ClassData {
          int instSize;
<span class="line-modified">!         List&lt;Field&gt; fields;</span>
  
<span class="line-modified">!         ClassData(int instSize, List&lt;Field&gt; fields) {</span>
              this.instSize = instSize;
              this.fields = fields;
          }
      }
  
<span class="line-modified">!     private Map&lt;InstanceKlass, ClassData&gt; classDataCache = new HashMap&lt;&gt;();</span>
  }
</pre>
<center><a href="HeapGXLWriter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntArray.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
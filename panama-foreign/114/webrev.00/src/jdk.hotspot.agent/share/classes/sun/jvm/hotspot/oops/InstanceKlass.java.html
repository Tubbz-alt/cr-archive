<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/InstanceKlass.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 package sun.jvm.hotspot.oops;
  26 
  27 import java.io.*;
  28 import java.util.*;
  29 import sun.jvm.hotspot.classfile.ClassLoaderData;
  30 import sun.jvm.hotspot.debugger.*;
  31 import sun.jvm.hotspot.memory.*;
  32 import sun.jvm.hotspot.memory.Dictionary;
  33 import sun.jvm.hotspot.runtime.*;
  34 import sun.jvm.hotspot.types.*;
  35 import sun.jvm.hotspot.utilities.*;
  36 import sun.jvm.hotspot.utilities.Observable;
  37 import sun.jvm.hotspot.utilities.Observer;
  38 
  39 // An InstanceKlass is the VM level representation of a Java class.
  40 
  41 public class InstanceKlass extends Klass {
  42   static {
  43     VM.registerVMInitializedObserver(new Observer() {
  44         public void update(Observable o, Object data) {
  45           initialize(VM.getVM().getTypeDataBase());
  46         }
  47       });
  48   }
  49 
  50   // field offset constants
  51   private static int ACCESS_FLAGS_OFFSET;
  52   private static int NAME_INDEX_OFFSET;
  53   private static int SIGNATURE_INDEX_OFFSET;
  54   private static int INITVAL_INDEX_OFFSET;
  55   private static int LOW_OFFSET;
  56   private static int HIGH_OFFSET;
  57   private static int FIELD_SLOTS;
  58   private static short FIELDINFO_TAG_SIZE;
  59   private static short FIELDINFO_TAG_MASK;
  60   private static short FIELDINFO_TAG_OFFSET;
  61 
  62   // ClassState constants
  63   private static int CLASS_STATE_ALLOCATED;
  64   private static int CLASS_STATE_LOADED;
  65   private static int CLASS_STATE_LINKED;
  66   private static int CLASS_STATE_BEING_INITIALIZED;
  67   private static int CLASS_STATE_FULLY_INITIALIZED;
  68   private static int CLASS_STATE_INITIALIZATION_ERROR;
  69 
  70   // _misc_flags constants
  71   private static int MISC_REWRITTEN;
  72   private static int MISC_HAS_NONSTATIC_FIELDS;
  73   private static int MISC_SHOULD_VERIFY_CLASS;
  74   private static int MISC_IS_UNSAFE_ANONYMOUS;
  75   private static int MISC_IS_CONTENDED;
  76   private static int MISC_HAS_NONSTATIC_CONCRETE_METHODS;
  77   private static int MISC_DECLARES_NONSTATIC_CONCRETE_METHODS;
  78   private static int MISC_HAS_BEEN_REDEFINED;
  79   private static int MISC_HAS_PASSED_FINGERPRINT_CHECK;
  80   private static int MISC_IS_SCRATCH_CLASS;
  81   private static int MISC_IS_SHARED_BOOT_CLASS;
  82   private static int MISC_IS_SHARED_PLATFORM_CLASS;
  83   private static int MISC_IS_SHARED_APP_CLASS;
  84 
  85   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
  86     Type type            = db.lookupType(&quot;InstanceKlass&quot;);
  87     arrayKlasses         = new MetadataField(type.getAddressField(&quot;_array_klasses&quot;), 0);
  88     methods              = type.getAddressField(&quot;_methods&quot;);
  89     defaultMethods       = type.getAddressField(&quot;_default_methods&quot;);
  90     methodOrdering       = type.getAddressField(&quot;_method_ordering&quot;);
  91     localInterfaces      = type.getAddressField(&quot;_local_interfaces&quot;);
  92     transitiveInterfaces = type.getAddressField(&quot;_transitive_interfaces&quot;);
  93     fields               = type.getAddressField(&quot;_fields&quot;);
  94     javaFieldsCount      = new CIntField(type.getCIntegerField(&quot;_java_fields_count&quot;), 0);
  95     constants            = new MetadataField(type.getAddressField(&quot;_constants&quot;), 0);
  96     sourceDebugExtension = type.getAddressField(&quot;_source_debug_extension&quot;);
  97     innerClasses         = type.getAddressField(&quot;_inner_classes&quot;);
  98     sourceFileNameIndex  = new CIntField(type.getCIntegerField(&quot;_source_file_name_index&quot;), 0);
  99     nonstaticFieldSize   = new CIntField(type.getCIntegerField(&quot;_nonstatic_field_size&quot;), 0);
 100     staticFieldSize      = new CIntField(type.getCIntegerField(&quot;_static_field_size&quot;), 0);
 101     staticOopFieldCount  = new CIntField(type.getCIntegerField(&quot;_static_oop_field_count&quot;), 0);
 102     nonstaticOopMapSize  = new CIntField(type.getCIntegerField(&quot;_nonstatic_oop_map_size&quot;), 0);
 103     isMarkedDependent    = new CIntField(type.getCIntegerField(&quot;_is_marked_dependent&quot;), 0);
 104     initState            = new CIntField(type.getCIntegerField(&quot;_init_state&quot;), 0);
 105     itableLen            = new CIntField(type.getCIntegerField(&quot;_itable_len&quot;), 0);
 106     if (VM.getVM().isJvmtiSupported()) {
 107       breakpoints        = type.getAddressField(&quot;_breakpoints&quot;);
 108     }
 109     genericSignatureIndex = new CIntField(type.getCIntegerField(&quot;_generic_signature_index&quot;), 0);
 110     miscFlags            = new CIntField(type.getCIntegerField(&quot;_misc_flags&quot;), 0);
 111     majorVersion         = new CIntField(type.getCIntegerField(&quot;_major_version&quot;), 0);
 112     minorVersion         = new CIntField(type.getCIntegerField(&quot;_minor_version&quot;), 0);
 113     headerSize           = type.getSize();
 114 
 115     // read field offset constants
 116     ACCESS_FLAGS_OFFSET            = db.lookupIntConstant(&quot;FieldInfo::access_flags_offset&quot;).intValue();
 117     NAME_INDEX_OFFSET              = db.lookupIntConstant(&quot;FieldInfo::name_index_offset&quot;).intValue();
 118     SIGNATURE_INDEX_OFFSET         = db.lookupIntConstant(&quot;FieldInfo::signature_index_offset&quot;).intValue();
 119     INITVAL_INDEX_OFFSET           = db.lookupIntConstant(&quot;FieldInfo::initval_index_offset&quot;).intValue();
 120     LOW_OFFSET                     = db.lookupIntConstant(&quot;FieldInfo::low_packed_offset&quot;).intValue();
 121     HIGH_OFFSET                    = db.lookupIntConstant(&quot;FieldInfo::high_packed_offset&quot;).intValue();
 122     FIELD_SLOTS                    = db.lookupIntConstant(&quot;FieldInfo::field_slots&quot;).intValue();
 123     FIELDINFO_TAG_SIZE             = db.lookupIntConstant(&quot;FIELDINFO_TAG_SIZE&quot;).shortValue();
 124     FIELDINFO_TAG_MASK             = db.lookupIntConstant(&quot;FIELDINFO_TAG_MASK&quot;).shortValue();
 125     FIELDINFO_TAG_OFFSET           = db.lookupIntConstant(&quot;FIELDINFO_TAG_OFFSET&quot;).shortValue();
 126 
 127     // read ClassState constants
 128     CLASS_STATE_ALLOCATED = db.lookupIntConstant(&quot;InstanceKlass::allocated&quot;).intValue();
 129     CLASS_STATE_LOADED = db.lookupIntConstant(&quot;InstanceKlass::loaded&quot;).intValue();
 130     CLASS_STATE_LINKED = db.lookupIntConstant(&quot;InstanceKlass::linked&quot;).intValue();
 131     CLASS_STATE_BEING_INITIALIZED = db.lookupIntConstant(&quot;InstanceKlass::being_initialized&quot;).intValue();
 132     CLASS_STATE_FULLY_INITIALIZED = db.lookupIntConstant(&quot;InstanceKlass::fully_initialized&quot;).intValue();
 133     CLASS_STATE_INITIALIZATION_ERROR = db.lookupIntConstant(&quot;InstanceKlass::initialization_error&quot;).intValue();
 134 
 135     MISC_REWRITTEN                    = db.lookupIntConstant(&quot;InstanceKlass::_misc_rewritten&quot;).intValue();
 136     MISC_HAS_NONSTATIC_FIELDS         = db.lookupIntConstant(&quot;InstanceKlass::_misc_has_nonstatic_fields&quot;).intValue();
 137     MISC_SHOULD_VERIFY_CLASS          = db.lookupIntConstant(&quot;InstanceKlass::_misc_should_verify_class&quot;).intValue();
 138     MISC_IS_UNSAFE_ANONYMOUS          = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_unsafe_anonymous&quot;).intValue();
 139     MISC_IS_CONTENDED                 = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_contended&quot;).intValue();
 140     MISC_HAS_NONSTATIC_CONCRETE_METHODS      = db.lookupIntConstant(&quot;InstanceKlass::_misc_has_nonstatic_concrete_methods&quot;).intValue();
 141     MISC_DECLARES_NONSTATIC_CONCRETE_METHODS = db.lookupIntConstant(&quot;InstanceKlass::_misc_declares_nonstatic_concrete_methods&quot;).intValue();
 142     MISC_HAS_BEEN_REDEFINED           = db.lookupIntConstant(&quot;InstanceKlass::_misc_has_been_redefined&quot;).intValue();
 143     MISC_HAS_PASSED_FINGERPRINT_CHECK = db.lookupIntConstant(&quot;InstanceKlass::_misc_has_passed_fingerprint_check&quot;).intValue();
 144     MISC_IS_SCRATCH_CLASS             = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_scratch_class&quot;).intValue();
 145     MISC_IS_SHARED_BOOT_CLASS         = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_shared_boot_class&quot;).intValue();
 146     MISC_IS_SHARED_PLATFORM_CLASS     = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_shared_platform_class&quot;).intValue();
 147     MISC_IS_SHARED_APP_CLASS          = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_shared_app_class&quot;).intValue();
 148   }
 149 
 150   public InstanceKlass(Address addr) {
 151     super(addr);
 152     if (getJavaFieldsCount() != getAllFieldsCount()) {
 153       // Exercise the injected field logic
 154       for (int i = getJavaFieldsCount(); i &lt; getAllFieldsCount(); i++) {
 155         getFieldName(i);
 156         getFieldSignature(i);
 157       }
 158     }
 159   }
 160 
 161   private static MetadataField arrayKlasses;
 162   private static AddressField  methods;
 163   private static AddressField  defaultMethods;
 164   private static AddressField  methodOrdering;
 165   private static AddressField  localInterfaces;
 166   private static AddressField  transitiveInterfaces;
 167   private static AddressField fields;
 168   private static CIntField javaFieldsCount;
 169   private static MetadataField constants;
 170   private static AddressField  sourceDebugExtension;
 171   private static AddressField  innerClasses;
 172   private static CIntField sourceFileNameIndex;
 173   private static CIntField nonstaticFieldSize;
 174   private static CIntField staticFieldSize;
 175   private static CIntField staticOopFieldCount;
 176   private static CIntField nonstaticOopMapSize;
 177   private static CIntField isMarkedDependent;
 178   private static CIntField initState;
 179   private static CIntField itableLen;
 180   private static AddressField breakpoints;
 181   private static CIntField genericSignatureIndex;
 182   private static CIntField miscFlags;
 183   private static CIntField majorVersion;
 184   private static CIntField minorVersion;
 185 
 186   // type safe enum for ClassState from instanceKlass.hpp
 187   public static class ClassState {
 188      public static final ClassState ALLOCATED    = new ClassState(&quot;allocated&quot;);
 189      public static final ClassState LOADED       = new ClassState(&quot;loaded&quot;);
 190      public static final ClassState LINKED       = new ClassState(&quot;linked&quot;);
 191      public static final ClassState BEING_INITIALIZED      = new ClassState(&quot;beingInitialized&quot;);
 192      public static final ClassState FULLY_INITIALIZED    = new ClassState(&quot;fullyInitialized&quot;);
 193      public static final ClassState INITIALIZATION_ERROR = new ClassState(&quot;initializationError&quot;);
 194 
 195      private ClassState(String value) {
 196         this.value = value;
 197      }
 198 
 199      public String toString() {
 200         return value;
 201      }
 202 
 203      private String value;
 204   }
 205 
 206   public int  getInitStateAsInt() { return (int) initState.getValue(this); }
 207   public ClassState getInitState() {
 208      int state = getInitStateAsInt();
 209      if (state == CLASS_STATE_ALLOCATED) {
 210         return ClassState.ALLOCATED;
 211      } else if (state == CLASS_STATE_LOADED) {
 212         return ClassState.LOADED;
 213      } else if (state == CLASS_STATE_LINKED) {
 214         return ClassState.LINKED;
 215      } else if (state == CLASS_STATE_BEING_INITIALIZED) {
 216         return ClassState.BEING_INITIALIZED;
 217      } else if (state == CLASS_STATE_FULLY_INITIALIZED) {
 218         return ClassState.FULLY_INITIALIZED;
 219      } else if (state == CLASS_STATE_INITIALIZATION_ERROR) {
 220         return ClassState.INITIALIZATION_ERROR;
 221      } else {
 222         throw new RuntimeException(&quot;should not reach here&quot;);
 223      }
 224   }
 225 
 226   // initialization state quaries
 227   public boolean isLoaded() {
 228      return getInitStateAsInt() &gt;= CLASS_STATE_LOADED;
 229   }
 230 
 231   public boolean isLinked() {
 232      return getInitStateAsInt() &gt;= CLASS_STATE_LINKED;
 233   }
 234 
 235   public boolean isInitialized() {
 236      return getInitStateAsInt() == CLASS_STATE_FULLY_INITIALIZED;
 237   }
 238 
 239   public boolean isNotInitialized() {
 240      return getInitStateAsInt() &lt; CLASS_STATE_BEING_INITIALIZED;
 241   }
 242 
 243   public boolean isBeingInitialized() {
 244      return getInitStateAsInt() == CLASS_STATE_BEING_INITIALIZED;
 245   }
 246 
 247   public boolean isInErrorState() {
 248      return getInitStateAsInt() == CLASS_STATE_INITIALIZATION_ERROR;
 249   }
 250 
 251   public int getClassStatus() {
 252      int result = 0;
 253      if (isLinked()) {
 254         result |= JVMDIClassStatus.VERIFIED | JVMDIClassStatus.PREPARED;
 255      }
 256 
 257      if (isInitialized()) {
 258         if (Assert.ASSERTS_ENABLED) {
 259            Assert.that(isLinked(), &quot;Class status is not consistent&quot;);
 260         }
 261         result |= JVMDIClassStatus.INITIALIZED;
 262      }
 263 
 264      if (isInErrorState()) {
 265         result |= JVMDIClassStatus.ERROR;
 266      }
 267      return result;
 268   }
 269 
 270   // Byteside of the header
 271   private static long headerSize;
 272 
 273   public long getObjectSize(Oop object) {
 274     return getSizeHelper() * VM.getVM().getAddressSize();
 275   }
 276 
 277   public long getSize() { // in number of bytes
 278     long wordLength = VM.getVM().getBytesPerWord();
 279     long size = getHeaderSize() +
 280                 (getVtableLen() +
 281                  getItableLen() +
 282                  getNonstaticOopMapSize()) * wordLength;
 283     if (isInterface()) {
 284       size += wordLength;
 285     }
 286     if (isUnsafeAnonymous()) {
 287       size += wordLength;
 288     }
 289     if (hasStoredFingerprint()) {
 290       size += 8; // uint64_t
 291     }
 292     return alignSize(size);
 293   }
 294 
 295   private int getMiscFlags() {
 296     return (int) miscFlags.getValue(this);
 297   }
 298 
 299   public boolean isUnsafeAnonymous() {
 300     return (getMiscFlags() &amp; MISC_IS_UNSAFE_ANONYMOUS) != 0;
 301   }
 302 
 303   public static boolean shouldStoreFingerprint() {
 304     VM vm = VM.getVM();
 305     if (vm.getCommandLineBooleanFlag(&quot;EnableJVMCI&quot;) &amp;&amp; !vm.getCommandLineBooleanFlag(&quot;UseJVMCICompiler&quot;)) {
 306       return true;
 307     }
 308     if (vm.getCommandLineBooleanFlag(&quot;DumpSharedSpaces&quot;)) {
 309       return true;
 310     }
 311     return false;
 312   }
 313 
 314   public boolean hasStoredFingerprint() {
 315     return shouldStoreFingerprint() || isShared();
 316   }
 317 
 318   public static long getHeaderSize() { return headerSize; }
 319 
 320   public short getFieldAccessFlags(int index) {
 321     return getFields().at(index * FIELD_SLOTS + ACCESS_FLAGS_OFFSET);
 322   }
 323 
 324   public short getFieldNameIndex(int index) {
 325     if (index &gt;= getJavaFieldsCount()) throw new IndexOutOfBoundsException(&quot;not a Java field;&quot;);
 326     return getFields().at(index * FIELD_SLOTS + NAME_INDEX_OFFSET);
 327   }
 328 
 329   public Symbol getFieldName(int index) {
 330     int nameIndex = getFields().at(index * FIELD_SLOTS + NAME_INDEX_OFFSET);
 331     if (index &lt; getJavaFieldsCount()) {
 332       return getConstants().getSymbolAt(nameIndex);
 333     } else {
 334       return vmSymbols.symbolAt(nameIndex);
 335     }
 336   }
 337 
 338   public short getFieldSignatureIndex(int index) {
 339     if (index &gt;= getJavaFieldsCount()) throw new IndexOutOfBoundsException(&quot;not a Java field;&quot;);
 340     return getFields().at(index * FIELD_SLOTS + SIGNATURE_INDEX_OFFSET);
 341   }
 342 
 343   public Symbol getFieldSignature(int index) {
 344     int signatureIndex = getFields().at(index * FIELD_SLOTS + SIGNATURE_INDEX_OFFSET);
 345     if (index &lt; getJavaFieldsCount()) {
 346       return getConstants().getSymbolAt(signatureIndex);
 347     } else {
 348       return vmSymbols.symbolAt(signatureIndex);
 349     }
 350   }
 351 
 352   public short getFieldGenericSignatureIndex(int index) {
 353     // int len = getFields().length();
 354     int allFieldsCount = getAllFieldsCount();
 355     int generic_signature_slot = allFieldsCount * FIELD_SLOTS;
 356     for (int i = 0; i &lt; allFieldsCount; i++) {
 357       short flags = getFieldAccessFlags(i);
 358       AccessFlags access = new AccessFlags(flags);
 359       if (i == index) {
 360         if (access.fieldHasGenericSignature()) {
 361            return getFields().at(generic_signature_slot);
 362         } else {
 363           return 0;
 364         }
 365       } else {
 366         if (access.fieldHasGenericSignature()) {
 367           generic_signature_slot ++;
 368         }
 369       }
 370     }
 371     return 0;
 372   }
 373 
 374   public Symbol getFieldGenericSignature(int index) {
 375     short genericSignatureIndex = getFieldGenericSignatureIndex(index);
 376     if (genericSignatureIndex != 0)  {
 377       return getConstants().getSymbolAt(genericSignatureIndex);
 378     }
 379     return null;
 380   }
 381 
 382   public short getFieldInitialValueIndex(int index) {
 383     if (index &gt;= getJavaFieldsCount()) throw new IndexOutOfBoundsException(&quot;not a Java field;&quot;);
 384     return getFields().at(index * FIELD_SLOTS + INITVAL_INDEX_OFFSET);
 385   }
 386 
 387   public int getFieldOffset(int index) {
 388     U2Array fields = getFields();
 389     short lo = fields.at(index * FIELD_SLOTS + LOW_OFFSET);
 390     short hi = fields.at(index * FIELD_SLOTS + HIGH_OFFSET);
 391     if ((lo &amp; FIELDINFO_TAG_MASK) == FIELDINFO_TAG_OFFSET) {
 392       return VM.getVM().buildIntFromShorts(lo, hi) &gt;&gt; FIELDINFO_TAG_SIZE;
 393     }
 394     throw new RuntimeException(&quot;should not reach here&quot;);
 395   }
 396 
 397   // Accessors for declared fields
 398   public Klass     getArrayKlasses()        { return (Klass)        arrayKlasses.getValue(this); }
 399   public MethodArray  getMethods()              { return new MethodArray(methods.getValue(getAddress())); }
 400 
 401   public MethodArray  getDefaultMethods() {
 402     if (defaultMethods != null) {
 403       Address addr = defaultMethods.getValue(getAddress());
 404       if ((addr != null) &amp;&amp; (addr.getAddressAt(0) != null)) {
 405         return new MethodArray(addr);
 406       } else {
 407         return null;
 408       }
 409     } else {
 410       return null;
 411     }
 412   }
 413 
 414   public KlassArray   getLocalInterfaces()      { return new KlassArray(localInterfaces.getValue(getAddress())); }
 415   public KlassArray   getTransitiveInterfaces() { return new KlassArray(transitiveInterfaces.getValue(getAddress())); }
 416   public int       getJavaFieldsCount()     { return                (int) javaFieldsCount.getValue(this); }
 417   public int       getAllFieldsCount()      {
 418     int len = getFields().length();
 419     int allFieldsCount = 0;
 420     for (; allFieldsCount*FIELD_SLOTS &lt; len; allFieldsCount++) {
 421       short flags = getFieldAccessFlags(allFieldsCount);
 422       AccessFlags access = new AccessFlags(flags);
 423       if (access.fieldHasGenericSignature()) {
 424         len --;
 425       }
 426     }
 427     return allFieldsCount;
 428   }
 429   public ConstantPool getConstants()        { return (ConstantPool) constants.getValue(this); }
 430   public Symbol    getSourceFileName()      { return                getConstants().getSymbolAt(sourceFileNameIndex.getValue(this)); }
 431   public String    getSourceDebugExtension(){ return                CStringUtilities.getString(sourceDebugExtension.getValue(getAddress())); }
 432   public long      getNonstaticFieldSize()  { return                nonstaticFieldSize.getValue(this); }
 433   public long      getStaticOopFieldCount() { return                staticOopFieldCount.getValue(this); }
 434   public long      getNonstaticOopMapSize() { return                nonstaticOopMapSize.getValue(this); }
 435   public boolean   getIsMarkedDependent()   { return                isMarkedDependent.getValue(this) != 0; }
 436   public long      getItableLen()           { return                itableLen.getValue(this); }
 437   public long      majorVersion()           { return                majorVersion.getValue(this); }
 438   public long      minorVersion()           { return                minorVersion.getValue(this); }
 439   public Symbol    getGenericSignature()    {
 440     long index = genericSignatureIndex.getValue(this);
 441     if (index != 0) {
 442       return getConstants().getSymbolAt(index);
 443     } else {
 444       return null;
 445     }
 446   }
 447 
 448   // &quot;size helper&quot; == instance size in words
 449   public long getSizeHelper() {
 450     int lh = getLayoutHelper();
 451     if (Assert.ASSERTS_ENABLED) {
 452       Assert.that(lh &gt; 0, &quot;layout helper initialized for instance class&quot;);
 453     }
 454     return lh / VM.getVM().getAddressSize();
 455   }
 456 
 457   // same as enum InnerClassAttributeOffset in VM code.
 458   private static class InnerClassAttributeOffset {
 459     // from JVM spec. &quot;InnerClasses&quot; attribute
 460     public static int innerClassInnerClassInfoOffset;
 461     public static int innerClassOuterClassInfoOffset;
 462     public static int innerClassInnerNameOffset;
 463     public static int innerClassAccessFlagsOffset;
 464     public static int innerClassNextOffset;
 465     static {
 466       VM.registerVMInitializedObserver(new Observer() {
 467           public void update(Observable o, Object data) {
 468               initialize(VM.getVM().getTypeDataBase());
 469           }
 470       });
 471     }
 472 
 473     private static synchronized void initialize(TypeDataBase db) {
 474       innerClassInnerClassInfoOffset = db.lookupIntConstant(
 475           &quot;InstanceKlass::inner_class_inner_class_info_offset&quot;).intValue();
 476       innerClassOuterClassInfoOffset = db.lookupIntConstant(
 477           &quot;InstanceKlass::inner_class_outer_class_info_offset&quot;).intValue();
 478       innerClassInnerNameOffset = db.lookupIntConstant(
 479           &quot;InstanceKlass::inner_class_inner_name_offset&quot;).intValue();
 480       innerClassAccessFlagsOffset = db.lookupIntConstant(
 481           &quot;InstanceKlass::inner_class_access_flags_offset&quot;).intValue();
 482       innerClassNextOffset = db.lookupIntConstant(
 483           &quot;InstanceKlass::inner_class_next_offset&quot;).intValue();
 484     }
 485   }
 486 
 487   private static class EnclosingMethodAttributeOffset {
 488     public static int enclosingMethodAttributeSize;
 489     static {
 490       VM.registerVMInitializedObserver(new Observer() {
 491           public void update(Observable o, Object data) {
 492               initialize(VM.getVM().getTypeDataBase());
 493           }
 494       });
 495     }
 496     private static synchronized void initialize(TypeDataBase db) {
 497       enclosingMethodAttributeSize = db.lookupIntConstant(&quot;InstanceKlass::enclosing_method_attribute_size&quot;).intValue();
 498     }
 499   }
 500 
 501   // refer to compute_modifier_flags in VM code.
 502   public long computeModifierFlags() {
 503     long access = getAccessFlags();
 504     // But check if it happens to be member class.
 505     U2Array innerClassList = getInnerClasses();
 506     int length = (innerClassList == null)? 0 : (int) innerClassList.length();
 507     if (length &gt; 0) {
 508        if (Assert.ASSERTS_ENABLED) {
 509           Assert.that(length % InnerClassAttributeOffset.innerClassNextOffset == 0 ||
 510                       length % InnerClassAttributeOffset.innerClassNextOffset == EnclosingMethodAttributeOffset.enclosingMethodAttributeSize,
 511                       &quot;just checking&quot;);
 512        }
 513        for (int i = 0; i &lt; length; i += InnerClassAttributeOffset.innerClassNextOffset) {
 514           if (i == length - EnclosingMethodAttributeOffset.enclosingMethodAttributeSize) {
 515               break;
 516           }
 517           int ioff = innerClassList.at(i +
 518                          InnerClassAttributeOffset.innerClassInnerClassInfoOffset);
 519           // &#39;ioff&#39; can be zero.
 520           // refer to JVM spec. section 4.7.5.
 521           if (ioff != 0) {
 522              // only look at classes that are already loaded
 523              // since we are looking for the flags for our self.
 524              Symbol name = getConstants().getKlassNameAt(ioff);
 525 
 526              if (name.equals(getName())) {
 527                 // This is really a member class
 528                 access = innerClassList.at(i +
 529                         InnerClassAttributeOffset.innerClassAccessFlagsOffset);
 530                 break;
 531              }
 532           }
 533        } // for inner classes
 534     }
 535 
 536     // Remember to strip ACC_SUPER bit
 537     return (access &amp; (~JVM_ACC_SUPER)) &amp; JVM_ACC_WRITTEN_FLAGS;
 538   }
 539 
 540 
 541   // whether given Symbol is name of an inner/nested Klass of this Klass?
 542   // anonymous and local classes are excluded.
 543   public boolean isInnerClassName(Symbol sym) {
 544     return isInInnerClasses(sym, false);
 545   }
 546 
 547   // whether given Symbol is name of an inner/nested Klass of this Klass?
 548   // anonymous classes excluded, but local classes are included.
 549   public boolean isInnerOrLocalClassName(Symbol sym) {
 550     return isInInnerClasses(sym, true);
 551   }
 552 
 553   private boolean isInInnerClasses(Symbol sym, boolean includeLocals) {
 554     U2Array innerClassList = getInnerClasses();
 555     int length = ( innerClassList == null)? 0 : (int) innerClassList.length();
 556     if (length &gt; 0) {
 557        if (Assert.ASSERTS_ENABLED) {
 558          Assert.that(length % InnerClassAttributeOffset.innerClassNextOffset == 0 ||
 559                      length % InnerClassAttributeOffset.innerClassNextOffset == EnclosingMethodAttributeOffset.enclosingMethodAttributeSize,
 560                      &quot;just checking&quot;);
 561        }
 562        for (int i = 0; i &lt; length; i += InnerClassAttributeOffset.innerClassNextOffset) {
 563          if (i == length - EnclosingMethodAttributeOffset.enclosingMethodAttributeSize) {
 564              break;
 565          }
 566          int ioff = innerClassList.at(i +
 567                         InnerClassAttributeOffset.innerClassInnerClassInfoOffset);
 568          // &#39;ioff&#39; can be zero.
 569          // refer to JVM spec. section 4.7.5.
 570          if (ioff != 0) {
 571             Symbol innerName = getConstants().getKlassNameAt(ioff);
 572             Symbol myname = getName();
 573             int ooff = innerClassList.at(i +
 574                         InnerClassAttributeOffset.innerClassOuterClassInfoOffset);
 575             // for anonymous classes inner_name_index of InnerClasses
 576             // attribute is zero.
 577             int innerNameIndex = innerClassList.at(i +
 578                         InnerClassAttributeOffset.innerClassInnerNameOffset);
 579             // if this is not a member (anonymous, local etc.), &#39;ooff&#39; will be zero
 580             // refer to JVM spec. section 4.7.5.
 581             if (ooff == 0) {
 582                if (includeLocals) {
 583                   // does it looks like my local class?
 584                   if (innerName.equals(sym) &amp;&amp;
 585                      innerName.asString().startsWith(myname.asString())) {
 586                      // exclude anonymous classes.
 587                      return (innerNameIndex != 0);
 588                   }
 589                }
 590             } else {
 591                Symbol outerName = getConstants().getKlassNameAt(ooff);
 592 
 593                // include only if current class is outer class.
 594                if (outerName.equals(myname) &amp;&amp; innerName.equals(sym)) {
 595                   return true;
 596                }
 597            }
 598          }
 599        } // for inner classes
 600        return false;
 601     } else {
 602        return false;
 603     }
 604   }
 605 
 606   public boolean implementsInterface(Klass k) {
 607     if (Assert.ASSERTS_ENABLED) {
 608       Assert.that(k.isInterface(), &quot;should not reach here&quot;);
 609     }
 610     KlassArray interfaces =  getTransitiveInterfaces();
 611     final int len = interfaces.length();
 612     for (int i = 0; i &lt; len; i++) {
 613       if (interfaces.getAt(i).equals(k)) return true;
 614     }
 615     return false;
 616   }
 617 
 618   boolean computeSubtypeOf(Klass k) {
 619     if (k.isInterface()) {
 620       return implementsInterface(k);
 621     } else {
 622       return super.computeSubtypeOf(k);
 623     }
 624   }
 625 
 626   public void printValueOn(PrintStream tty) {
 627     tty.print(&quot;InstanceKlass for &quot; + getName().asString());
 628   }
 629 
 630   public void iterateFields(MetadataVisitor visitor) {
 631     super.iterateFields(visitor);
 632     visitor.doMetadata(arrayKlasses, true);
 633     // visitor.doOop(methods, true);
 634     // visitor.doOop(localInterfaces, true);
 635     // visitor.doOop(transitiveInterfaces, true);
 636       visitor.doCInt(nonstaticFieldSize, true);
 637       visitor.doCInt(staticFieldSize, true);
 638       visitor.doCInt(staticOopFieldCount, true);
 639       visitor.doCInt(nonstaticOopMapSize, true);
 640       visitor.doCInt(isMarkedDependent, true);
 641       visitor.doCInt(initState, true);
 642       visitor.doCInt(itableLen, true);
 643     }
 644 
 645   /*
 646    *  Visit the static fields of this InstanceKlass with the obj of
 647    *  the visitor set to the oop holding the fields, which is
 648    *  currently the java mirror.
 649    */
 650   public void iterateStaticFields(OopVisitor visitor) {
 651     visitor.setObj(getJavaMirror());
 652     visitor.prologue();
 653     iterateStaticFieldsInternal(visitor);
 654     visitor.epilogue();
 655 
 656   }
 657 
 658   void iterateStaticFieldsInternal(OopVisitor visitor) {
 659     int length = getJavaFieldsCount();
 660     for (int index = 0; index &lt; length; index++) {
 661       short accessFlags    = getFieldAccessFlags(index);
 662       FieldType   type   = new FieldType(getFieldSignature(index));
 663       AccessFlags access = new AccessFlags(accessFlags);
 664       if (access.isStatic()) {
 665         visitField(visitor, type, index);
 666       }
 667     }
 668   }
 669 
 670   public Klass getJavaSuper() {
 671     return getSuper();
 672   }
 673 
 674   public static class StaticField {
 675     public AccessFlags flags;
 676     public Field field;
 677 
 678     StaticField(Field field, AccessFlags flags) {
 679       this.field = field;
 680       this.flags = flags;
 681     }
 682   }
 683 
 684   public Field[] getStaticFields() {
 685     U2Array fields = getFields();
 686     int length = getJavaFieldsCount();
 687     ArrayList&lt;Field&gt; result = new ArrayList&lt;&gt;();
 688     for (int index = 0; index &lt; length; index++) {
 689       Field f = newField(index);
 690       if (f.isStatic()) {
 691         result.add(f);
 692       }
 693     }
 694     return result.toArray(new Field[result.size()]);
 695   }
 696 
 697   public void iterateNonStaticFields(OopVisitor visitor, Oop obj) {
 698     if (getSuper() != null) {
 699       ((InstanceKlass) getSuper()).iterateNonStaticFields(visitor, obj);
 700     }
 701     int length = getJavaFieldsCount();
 702     for (int index = 0; index &lt; length; index++) {
 703       short accessFlags    = getFieldAccessFlags(index);
 704       FieldType   type   = new FieldType(getFieldSignature(index));
 705       AccessFlags access = new AccessFlags(accessFlags);
 706       if (!access.isStatic()) {
 707         visitField(visitor, type, index);
 708       }
 709     }
 710   }
 711 
 712   /** Field access by name. */
 713   public Field findLocalField(String name, String sig) {
 714     int length = getJavaFieldsCount();
 715     for (int i = 0; i &lt; length; i++) {
 716       Symbol f_name = getFieldName(i);
 717       Symbol f_sig  = getFieldSignature(i);
 718       if (f_name.equals(name) &amp;&amp; f_sig.equals(sig)) {
 719         return newField(i);
 720       }
 721     }
 722 
 723     return null;
 724   }
 725 
 726   /** Find field in direct superinterfaces. */
 727   public Field findInterfaceField(String name, String sig) {
 728     KlassArray interfaces = getLocalInterfaces();
 729     int n = interfaces.length();
 730     for (int i = 0; i &lt; n; i++) {
 731       InstanceKlass intf1 = (InstanceKlass) interfaces.getAt(i);
 732       if (Assert.ASSERTS_ENABLED) {
 733         Assert.that(intf1.isInterface(), &quot;just checking type&quot;);
 734      }
 735       // search for field in current interface
 736       Field f = intf1.findLocalField(name, sig);
 737       if (f != null) {
 738         if (Assert.ASSERTS_ENABLED) {
 739           Assert.that(f.getAccessFlagsObj().isStatic(), &quot;interface field must be static&quot;);
 740         }
 741         return f;
 742       }
 743       // search for field in direct superinterfaces
 744       f = intf1.findInterfaceField(name, sig);
 745       if (f != null) return f;
 746     }
 747     // otherwise field lookup fails
 748     return null;
 749   }
 750 
 751   /** Find field according to JVM spec 5.4.3.2, returns the klass in
 752       which the field is defined. */
 753   public Field findField(String name, String sig) {
 754     // search order according to newest JVM spec (5.4.3.2, p.167).
 755     // 1) search for field in current klass
 756     Field f = findLocalField(name, sig);
 757     if (f != null) return f;
 758 
 759     // 2) search for field recursively in direct superinterfaces
 760     f = findInterfaceField(name, sig);
 761     if (f != null) return f;
 762 
 763     // 3) apply field lookup recursively if superclass exists
 764     InstanceKlass supr = (InstanceKlass) getSuper();
 765     if (supr != null) return supr.findField(name, sig);
 766 
 767     // 4) otherwise field lookup fails
 768     return null;
 769   }
 770 
 771   /** Find field according to JVM spec 5.4.3.2, returns the klass in
 772       which the field is defined (retained only for backward
 773       compatibility with jdbx) */
 774   public Field findFieldDbg(String name, String sig) {
 775     return findField(name, sig);
 776   }
 777 
 778   /** Get field by its index in the fields array. Only designed for
 779       use in a debugging system. */
 780   public Field getFieldByIndex(int fieldIndex) {
 781     return newField(fieldIndex);
 782   }
 783 
 784 
 785     /** Return a List of SA Fields for the fields declared in this class.
 786         Inherited fields are not included.
 787         Return an empty list if there are no fields declared in this class.
 788         Only designed for use in a debugging system. */
 789     public List&lt;Field&gt; getImmediateFields() {
 790         // A list of Fields for each field declared in this class/interface,
 791         // not including inherited fields.
 792         int length = getJavaFieldsCount();
 793         List&lt;Field&gt; immediateFields = new ArrayList&lt;&gt;(length);
 794         for (int index = 0; index &lt; length; index++) {
 795             immediateFields.add(getFieldByIndex(index));
 796         }
 797 
 798         return immediateFields;
 799     }
 800 
 801     /** Return a List of SA Fields for all the java fields in this class,
 802         including all inherited fields.  This includes hidden
 803         fields.  Thus the returned list can contain fields with
 804         the same name.
 805         Return an empty list if there are no fields.
 806         Only designed for use in a debugging system. */
 807     public List&lt;Field&gt; getAllFields() {
 808         // Contains a Field for each field in this class, including immediate
 809         // fields and inherited fields.
 810         List&lt;Field&gt; allFields = getImmediateFields();
 811 
 812         // transitiveInterfaces contains all interfaces implemented
 813         // by this class and its superclass chain with no duplicates.
 814 
 815         KlassArray interfaces = getTransitiveInterfaces();
 816         int n = interfaces.length();
 817         for (int i = 0; i &lt; n; i++) {
 818             InstanceKlass intf1 = (InstanceKlass) interfaces.getAt(i);
 819             if (Assert.ASSERTS_ENABLED) {
 820                 Assert.that(intf1.isInterface(), &quot;just checking type&quot;);
 821             }
 822             allFields.addAll(intf1.getImmediateFields());
 823         }
 824 
 825         // Get all fields in the superclass, recursively.  But, don&#39;t
 826         // include fields in interfaces implemented by superclasses;
 827         // we already have all those.
 828         if (!isInterface()) {
 829             InstanceKlass supr;
 830             if  ( (supr = (InstanceKlass) getSuper()) != null) {
 831                 allFields.addAll(supr.getImmediateFields());
 832             }
 833         }
 834 
 835         return allFields;
 836     }
 837 
 838 
 839     /** Return a List of SA Methods declared directly in this class/interface.
 840         Return an empty list if there are none, or if this isn&#39;t a class/
 841         interface.
 842     */
 843     public List&lt;Method&gt; getImmediateMethods() {
 844       // Contains a Method for each method declared in this class/interface
 845       // not including inherited methods.
 846 
 847       MethodArray methods = getMethods();
 848       int length = methods.length();
 849       Method[] tmp = new Method[length];
 850 
 851       IntArray methodOrdering = getMethodOrdering();
 852       if (methodOrdering.length() != length) {
 853          // no ordering info present
 854          for (int index = 0; index &lt; length; index++) {
 855             tmp[index] = methods.at(index);
 856          }
 857       } else {
 858          for (int index = 0; index &lt; length; index++) {
 859             int originalIndex = methodOrdering.at(index);
 860             tmp[originalIndex] = methods.at(index);
 861          }
 862       }
 863 
 864       return Arrays.asList(tmp);
 865     }
 866 
 867     /** Return a List containing an SA InstanceKlass for each
 868         interface named in this class&#39;s &#39;implements&#39; clause.
 869     */
 870     public List&lt;Klass&gt; getDirectImplementedInterfaces() {
 871         // Contains an InstanceKlass for each interface in this classes
 872         // &#39;implements&#39; clause.
 873 
 874         KlassArray interfaces = getLocalInterfaces();
 875         int length = interfaces.length();
 876         List&lt;Klass&gt; directImplementedInterfaces = new ArrayList&lt;&gt;(length);
 877 
 878         for (int index = 0; index &lt; length; index ++) {
 879             directImplementedInterfaces.add(interfaces.getAt(index));
 880         }
 881 
 882         return directImplementedInterfaces;
 883     }
 884 
 885   public Klass arrayKlassImpl(boolean orNull, int n) {
 886     // FIXME: in reflective system this would need to change to
 887     // actually allocate
 888     if (getArrayKlasses() == null) { return null; }
 889     ObjArrayKlass oak = (ObjArrayKlass) getArrayKlasses();
 890     if (orNull) {
 891       return oak.arrayKlassOrNull(n);
 892     }
 893     return oak.arrayKlass(n);
 894   }
 895 
 896   public Klass arrayKlassImpl(boolean orNull) {
 897     return arrayKlassImpl(orNull, 1);
 898   }
 899 
 900   public String signature() {
 901      return &quot;L&quot; + super.signature() + &quot;;&quot;;
 902   }
 903 
 904   /** Find method in vtable. */
 905   public Method findMethod(String name, String sig) {
 906     return findMethod(getMethods(), name, sig);
 907   }
 908 
 909   /** Breakpoint support (see methods on Method* for details) */
 910   public BreakpointInfo getBreakpoints() {
 911     if (!VM.getVM().isJvmtiSupported()) {
 912       return null;
 913     }
 914     Address addr = getAddress().getAddressAt(breakpoints.getOffset());
 915     return (BreakpointInfo) VMObjectFactory.newObject(BreakpointInfo.class, addr);
 916   }
 917 
 918   public IntArray  getMethodOrdering() {
 919     Address addr = getAddress().getAddressAt(methodOrdering.getOffset());
 920     return (IntArray) VMObjectFactory.newObject(IntArray.class, addr);
 921   }
 922 
 923   public U2Array getFields() {
 924     Address addr = getAddress().getAddressAt(fields.getOffset());
 925     return (U2Array) VMObjectFactory.newObject(U2Array.class, addr);
 926   }
 927 
 928   public U2Array getInnerClasses() {
 929     Address addr = getAddress().getAddressAt(innerClasses.getOffset());
 930     return (U2Array) VMObjectFactory.newObject(U2Array.class, addr);
 931   }
 932 
 933 
 934   //----------------------------------------------------------------------
 935   // Internals only below this point
 936   //
 937 
 938   private void visitField(OopVisitor visitor, FieldType type, int index) {
 939     Field f = newField(index);
 940     if (type.isOop()) {
 941       visitor.doOop((OopField) f, false);
 942       return;
 943     }
 944     if (type.isByte()) {
 945       visitor.doByte((ByteField) f, false);
 946       return;
 947     }
 948     if (type.isChar()) {
 949       visitor.doChar((CharField) f, false);
 950       return;
 951     }
 952     if (type.isDouble()) {
 953       visitor.doDouble((DoubleField) f, false);
 954       return;
 955     }
 956     if (type.isFloat()) {
 957       visitor.doFloat((FloatField) f, false);
 958       return;
 959     }
 960     if (type.isInt()) {
 961       visitor.doInt((IntField) f, false);
 962       return;
 963     }
 964     if (type.isLong()) {
 965       visitor.doLong((LongField) f, false);
 966       return;
 967     }
 968     if (type.isShort()) {
 969       visitor.doShort((ShortField) f, false);
 970       return;
 971     }
 972     if (type.isBoolean()) {
 973       visitor.doBoolean((BooleanField) f, false);
 974       return;
 975     }
 976   }
 977 
 978   // Creates new field from index in fields TypeArray
 979   private Field newField(int index) {
 980     FieldType type = new FieldType(getFieldSignature(index));
 981     if (type.isOop()) {
 982      if (VM.getVM().isCompressedOopsEnabled()) {
 983         return new NarrowOopField(this, index);
 984      } else {
 985         return new OopField(this, index);
 986      }
 987     }
 988     if (type.isByte()) {
 989       return new ByteField(this, index);
 990     }
 991     if (type.isChar()) {
 992       return new CharField(this, index);
 993     }
 994     if (type.isDouble()) {
 995       return new DoubleField(this, index);
 996     }
 997     if (type.isFloat()) {
 998       return new FloatField(this, index);
 999     }
1000     if (type.isInt()) {
1001       return new IntField(this, index);
1002     }
1003     if (type.isLong()) {
1004       return new LongField(this, index);
1005     }
1006     if (type.isShort()) {
1007       return new ShortField(this, index);
1008     }
1009     if (type.isBoolean()) {
1010       return new BooleanField(this, index);
1011     }
1012     throw new RuntimeException(&quot;Illegal field type at index &quot; + index);
1013   }
1014 
1015   private static Method findMethod(MethodArray methods, String name, String signature) {
1016     int index = linearSearch(methods, name, signature);
1017     if (index != -1) {
1018       return methods.at(index);
1019     } else {
1020       return null;
1021     }
1022   }
1023 
1024   private static int linearSearch(MethodArray methods, String name, String signature) {
1025     int len = (int) methods.length();
1026     for (int index = 0; index &lt; len; index++) {
1027       Method m = methods.at(index);
1028       if (m.getSignature().equals(signature) &amp;&amp; m.getName().equals(name)) {
1029         return index;
1030       }
1031     }
1032     return -1;
1033   }
1034 
1035   public void dumpReplayData(PrintStream out) {
1036     ConstantPool cp = getConstants();
1037 
1038     // Try to record related loaded classes
1039     Klass sub = getSubklassKlass();
1040     while (sub != null) {
1041         if (sub instanceof InstanceKlass) {
1042             out.println(&quot;instanceKlass &quot; + sub.getName().asString());
1043         }
1044         sub = sub.getNextSiblingKlass();
1045     }
1046 
1047     final int length = (int) cp.getLength();
1048     out.print(&quot;ciInstanceKlass &quot; + getName().asString() + &quot; &quot; + (isLinked() ? 1 : 0) + &quot; &quot; + (isInitialized() ? 1 : 0) + &quot; &quot; + length);
1049     for (int index = 1; index &lt; length; index++) {
1050       out.print(&quot; &quot; + cp.getTags().at(index));
1051     }
1052     out.println();
1053     if (isInitialized()) {
1054       Field[] staticFields = getStaticFields();
1055       for (int i = 0; i &lt; staticFields.length; i++) {
1056         Field f = staticFields[i];
1057         Oop mirror = getJavaMirror();
1058         if (f.isFinal() &amp;&amp; !f.hasInitialValue()) {
1059           out.print(&quot;staticfield &quot; + getName().asString() + &quot; &quot; +
1060                     OopUtilities.escapeString(f.getID().getName()) + &quot; &quot; +
1061                     f.getFieldType().getSignature().asString() + &quot; &quot;);
1062           if (f instanceof ByteField) {
1063             ByteField bf = (ByteField)f;
1064             out.println(bf.getValue(mirror));
1065           } else if (f instanceof BooleanField) {
1066             BooleanField bf = (BooleanField)f;
1067             out.println(bf.getValue(mirror) ? 1 : 0);
1068           } else if (f instanceof ShortField) {
1069             ShortField bf = (ShortField)f;
1070             out.println(bf.getValue(mirror));
1071           } else if (f instanceof CharField) {
1072             CharField bf = (CharField)f;
1073             out.println(bf.getValue(mirror) &amp; 0xffff);
1074           } else if (f instanceof IntField) {
1075             IntField bf = (IntField)f;
1076             out.println(bf.getValue(mirror));
1077           } else  if (f instanceof LongField) {
1078             LongField bf = (LongField)f;
1079             out.println(bf.getValue(mirror));
1080           } else if (f instanceof FloatField) {
1081             FloatField bf = (FloatField)f;
1082             out.println(Float.floatToRawIntBits(bf.getValue(mirror)));
1083           } else if (f instanceof DoubleField) {
1084             DoubleField bf = (DoubleField)f;
1085             out.println(Double.doubleToRawLongBits(bf.getValue(mirror)));
1086           } else if (f instanceof OopField) {
1087             OopField bf = (OopField)f;
1088 
1089             Oop value = bf.getValue(mirror);
1090             if (value == null) {
1091               out.println(&quot;null&quot;);
1092             } else if (value.isInstance()) {
1093               Instance inst = (Instance)value;
1094               if (inst.isA(SystemDictionary.getStringKlass())) {
1095                 out.println(&quot;\&quot;&quot; + OopUtilities.stringOopToEscapedString(inst) + &quot;\&quot;&quot;);
1096               } else {
1097                 out.println(inst.getKlass().getName().asString());
1098               }
1099             } else if (value.isObjArray()) {
1100               ObjArray oa = (ObjArray)value;
1101               Klass ek = (ObjArrayKlass)oa.getKlass();
1102               out.println(oa.getLength() + &quot; &quot; + ek.getName().asString());
1103             } else if (value.isTypeArray()) {
1104               TypeArray ta = (TypeArray)value;
1105               out.println(ta.getLength());
1106             } else {
1107               out.println(value);
1108             }
1109           }
1110         }
1111       }
1112     }
1113   }
1114 }
    </pre>
  </body>
</html>
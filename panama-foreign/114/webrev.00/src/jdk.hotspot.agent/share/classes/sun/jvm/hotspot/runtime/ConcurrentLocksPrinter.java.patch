diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/ConcurrentLocksPrinter.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/ConcurrentLocksPrinter.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/ConcurrentLocksPrinter.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/ConcurrentLocksPrinter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -28,24 +28,24 @@
 import java.util.*;
 import sun.jvm.hotspot.memory.*;
 import sun.jvm.hotspot.oops.*;
 
 public class ConcurrentLocksPrinter {
-    private Map locksMap = new HashMap(); // <JavaThread, List<Oop>>
+    private Map<JavaThread, List<Oop>> locksMap = new HashMap<>();
 
     public ConcurrentLocksPrinter() {
         fillLocks();
     }
 
     public void print(JavaThread jthread, PrintStream tty) {
-        List locks = (List) locksMap.get(jthread);
+        List<Oop> locks = locksMap.get(jthread);
         tty.println("Locked ownable synchronizers:");
         if (locks == null || locks.isEmpty()) {
             tty.println("    - None");
         } else {
-            for (Iterator itr = locks.iterator(); itr.hasNext();) {
-                Oop oop = (Oop) itr.next();
+            for (Iterator<Oop> itr = locks.iterator(); itr.hasNext();) {
+                Oop oop = itr.next();
                 tty.println("    - <" + oop.getHandle() + ">, (a " +
                        oop.getKlass().getName().asString() + ")");
             }
         }
     }
@@ -69,13 +69,13 @@
         if (absOwnSyncKlass != null) {
             heap.iterateObjectsOfKlass(new DefaultHeapVisitor() {
                     public boolean doObj(Oop oop) {
                         JavaThread thread = getOwnerThread(oop);
                         if (thread != null) {
-                            List locks = (List) locksMap.get(thread);
+                            List<Oop> locks = locksMap.get(thread);
                             if (locks == null) {
-                                locks = new LinkedList();
+                                locks = new LinkedList<>();
                                 locksMap.put(thread, locks);
                             }
                             locks.add(oop);
                         }
                         return false;
